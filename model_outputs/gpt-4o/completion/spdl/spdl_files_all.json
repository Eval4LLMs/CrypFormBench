{"SPDL-1/2r890-ex3-a.spdl": [[true, "/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(I,X,Y)\n{\n\trole I\n\t{\n\t\tfresh nx: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(I,X, nx );\n\t\trecv_2(X,I, { I,nx }sk(X) );\n\t\tsend_3(I,Y, ny );\n\t\trecv_4(Y,I, { ny,I }sk(Y) );\n\n\t\tclaim_i1(I,Niagree);\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar nx: Nonce;\n\n\t\trecv_1(I,X, nx );\n\t\tsend_2(X,I, { I,nx }sk(X) );\n\t}\n\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(I,Y, ny );\n\t\tsend_4(Y,I, { ny,I }sk(Y) );\n\t}\n}"]], "SPDL-1/AccessRequestEvaluation_CRCBAC.spdl": [[true, "hashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (Da,GW){\n\nrole Da{\n\nfresh T1:Nonce;\n\nvar T2:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (Da,GW,M,T1);\n\nrecv_2(GW,Da,XOR(Concat(IDa,c,Resp),h(SKa)),T2);\n\nclaim(Da,Secret,SKa);\n\nclaim(Da,Alive);\n\nclaim(Da,Weakagree);\n\nclaim(Da,Niagree);\n\nclaim(Da,Nisynch);}\n\nrole GW{\n\nfresh T2:Nonce; \n\nvar T1:Nonce; \n\nconst IDa;\n\nrecv_1(Da,GW,M,T1);\n\nsend_2 (GW,Da,XOR(Concat(IDa,c,Resp),h(SKa)),T2);\n\nclaim(GW,Alive);\n\nclaim(GW,Weakagree);\n\nclaim(GW,Niagree);\n\nclaim(GW,Nisynch);\n\nclaim(GW,Secret,SKa);}\n\n  }"]], "SPDL-1/boyd.spdl": [[true, "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}"]], "SPDL-1/CapabilityRevocation_CRCBAC.spdl": [[true, "hashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, GW) \n\n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var T2:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, GW, M);\n\n    recv_2(GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(Da, Secret, SKa);\n\n    claim(Da, Alive);\n\n    claim(Da, Weakagree);\n\n    claim(Da, Niagree);\n\n    claim(Da, Nisynch);\n\n}\n\nrole GW {\n\n    fresh T2:Nonce; \n\n    var T1:Nonce; \n\n    secret IDa;\n\n    recv_1(Da, GW, M);\n\n    macro M' = XOR(M,h(SKa));\n\n    macro rgb=getRoles(IDb,ctxb);\n\n    macro rga=getRoles(IDa,ctxa);\n\n    macro ver = Roleheirarchy(rgb,rga);\n\n    macro Cb= getCapabilities(rgb);\n\n    macro rgb =sub(rgb,c');\n\n    send_2 (GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(GW, Alive);\n\n    claim(GW, Weakagree);\n\n    claim(GW, Niagree);\n\n    claim(GW, Nisynch);\n\n    claim(GW, Secret, SKa);\n\n} \n\n}"]], "SPDL-1/carkey-ni.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);"]], "SPDL-1/ccitt509-ban.spdl": [[true, "usertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(I,R)\n{\n\trole I\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\trecv_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\tsend_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_4(I,Secret,yi);\n\t\tclaim_5(I,Secret,yr);\n\t\tclaim_6(I,Nisynch);\n\t\tclaim_7(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar xi,yi: Data;\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh yr,xr: Data;\n\n\t\trecv_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\tsend_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\trecv_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_8(R,Secret,yi);\n\t\tclaim_9(R,Secret,yr);\n\t\tclaim_10(R,Nisynch);\n\t\tclaim_11(R,Niagree);\n\t}\n}\n\n\nconst de: Data;"]], "SPDL-1/cotes_de_porc-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\trecv_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\tsend_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\trecv_3(I, R, n2);\n\t}\n}"]], "SPDL-1/DHKE-1.spdl": [[true, "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}"]], "SPDL-1/encryption2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nsecret k: Function;\n\nhashfunction hash, MAC, KDF;\nusertype UID, Timestamp, Amount;\n\nmacro Kcm = KDF(k(M, C), Nm, Nc);\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(B, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\nprotocol EncryptionProtocol2(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh a: Amount;\n\t\tfresh Nm, r: Nonce;\n\t\tfresh IDm: UID;\n\t\tvar Nc: Nonce;\n\t\tvar IDc: UID;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\n\t\tsend_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\trecv_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Send encrypted transaction request to customer\n\t\t*/\n\t\tsend_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_5 (B, M, { IDt, a, r, t, Sb }k(M,B) );\n\n\t\tclaim (M, Secret, IDm);\n\t\tclaim (M, Secret, a);\n\t\tclaim (M, Secret, r);\n\t\tclaim (M, Secret, Kcm);\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tfresh Nc: Nonce;\n\t\tfresh IDc: UID;\n\t\tvar IDm: UID;\n\t\tvar Nm, r: Nonce;\n\t\tvar t: Timestamp;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Authenticated key exchange with the merchant\n\t\t*/ \n\n\t\trecv_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\tsend_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Receive encrypted transaction request from merchant\n\t\t*/\n\t\trecv_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Send encrypted transaction confirmation to bank\n\t\t*/\n\t\tsend_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_6 (B, C, { IDt, a, r, t, Sb }k(C,B) );\n\n\t\tclaim (C, Secret, Kcm);\n\t\tclaim (C, Secret, IDc);\n\t\tclaim (C, Secret, Sc);\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar IDc, IDm: UID;\n\t\tvar r: Nonce;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Receive encrypted transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send encrypted payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_5 (B, M, { IDt, a, r, t, Sb }k(M, B) );\n\t\tsend_6 (B, C, { IDt, a, r, t, Sb }k(C, B) );\n\n\t\tclaim (B, Secret, IDt);\n\t\tclaim (B, Secret, t);\n\t\tclaim (B, Secret, Sb);\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}"]], "SPDL-1/en_y-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I, R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\trecv_2(R, I, {n2, R}pk(I), n1);\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\tsend_2(R, I, {n2, R}pk(I), n1);\n\t\trecv_3(I, R, n2);\n\t}\n}"]], "SPDL-1/exchange-hash.spdl": [[true, "/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\n\n// Protocol description\n\nprotocol protocol2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_i1 (I, Secret, kir );\n\t\tclaim_i2 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Key;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_r1 (R, Secret, kir );\n\t\tclaim_r2 (R, Nisynch );\n\t}\n}"]], "SPDL-1/five-run-bound.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,R)\n{\n\trole R\n\t{\n\t\tvar k1: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,R, ni );\n\t\tsend_!2 (R,I, { ni }sk(R) );\n\t\trecv_!3 (I,R, {{{ {k1}pk(R) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (R,I, {k2}k1 );\n\n\t\tclaim_6 (R, Secret, k2);\n\t}\n}"]], "SPDL-1/andrew-ban-1.spdl": [[true, "# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr, nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {ni,nr}k(I,R) );\n        send_3(I,R, {nr}k(I,R) );\n        recv_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Niagree);\n        claim_I3(I,Secret, kir);\n        claim_I5(I,Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {ni,nr}k(I,R) );\n        recv_3(I,R, {nr}k(I,R) );\n        send_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Niagree);\n        claim_R3(R,Secret, kir);\n        claim_R5(R,Empty, (Fresh,kir));\n    }\n}"]], "SPDL-1/Fortified-Chain2.spdl": [[true, "const E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\nprotocol Fortified-Chain2(DeviceA, Edge, DeviceB)\n{\nrole DeviceA {\n  fresh RN:Nonce;\n  const IDdev,DIsig,MATdiv,IDa;\n  fresh RNa:Nonce;\n  const msg,DIsigb,P1,RIa,PRa,IDa;\n  const Temp,Temp1;\n  fresh PRa,PUedge,PUa:key;\n  fresh SessionKey,Timestamp:key;\n  const V0,V1,V2,V3,V4;\n  recv_!2(Edge,DeviceA,P1);\n\n  recv_!4(DeviceB,DeviceA,Q1);\n\n  macro V0 = E(PUedge,H(IDdev));\n  macro Temp = H(RIa);\n  macro Temp1 = E(PRa,Temp);\n  macro DIsig = APN(Temp1,RIa);\n  macro V1 = E(PUb,RNa,MATdiv,IDa,DIsig);\n  macro V2 = D(PRa,SessionKey,IDb,DIsigb,Timestamp);\n  macro V3 = E(SessionKey,msg);\n  macro V4 = D(PRa,IDa,RIa,GIid,SIid,MATdiv);\n\n  send_!1(DeviceA,Edge,V0);\n  send_!5(DeviceA,DeviceB,V1,V3);\n  claim_DeviceA2(DeviceA,Secret,SessionKey);\n  claim_DeviceA3(DeviceA,Niagree);\n  claim_DeviceA4(DeviceA,Nisynch);\n}\n\nrole Edge {\n  fresh PRedge,PUedge,PUa,PUb:key;\n  fresh RNhc,MATdiv,GIid,SIid:Nonce;\n  const IDhc,RIa,IDa,RIa1,Hdev,MATdivb,MATdiv,RIb,IDb;\n  const P0,P1,P2;\n  const IDdev;\n  recv_!1(DeviceA,Edge,V0);\n\n  macro P0 = D(PRedge,H(IDdev));\n  macro Hdev = H(IDdev);\n  macro RIa1 = XOR(RNhc,Hdev,IDhc);\n  macro RIa = H(RIa1);\n  macro IDa = XOR(RIa,Hdev);\n  macro P1 = E(PUa,IDa,RIa,GIid,SIid,MATdiv);\n  macro P2 = E(PUb,IDb,RIb,GIid,SIid,MATdivb);\n  send_!2(Edge,DeviceA,P1);\n  send_!3(Edge,DeviceB,P2);\n  claim_Edge2(Edge,Secret,PRedge);\n  claim_Edge3(Edge,Niagree);\n  claim_Edge4(Edge,Nisynch);\n}\n\nrole DeviceB {\n  fresh PRb,PUedge,PUa,PUb,DIsigb:key;\n  fresh RNb:Nonce;\n  const IDdevb,DIsigb,MATdivb,Q1,Q2,Q3,Q4,MATdivb,MATdiv,IDb;\n  fresh RIb,RIa,RNb:Nonce;\n  const Temp2,Temp3,msg,RNa;\n  fresh SessionKey,Timestamp:key;\n  recv_!3(Edge,DeviceB,P2);\n\n  recv_!5(DeviceA,DeviceB,V1,V3);\n\n  macro Temp3 = D(PUa,DIsig);\n\n  macro Temp2 = H(RIa);\n\n  macro Q2 = D(PRb,IDb,RIb,GIid,SIid,MATdivb);\n  macro Q3 = D(PUb,RNa,MATdiv,IDa,DIsig);\n  match(MATdiv,MATdivb);\n  match(Temp2,Temp3);\n  macro SessionKey = POW(RNa,RNb);\n  macro Q1 = E(PUa,SessionKey,IDb,DIsigb,Timestamp);\n  macro Q4 = D(SessionKey,msg);\n  send_!4(DeviceB,DeviceA,Q1);\n  claim_DeviceB2(DeviceB,Secret,msg);\n  claim_DeviceB3(DeviceB,Niagree);\n  claim_DeviceB4(DeviceB,Nisynch);\n}\n}"]], "SPDL-1/fourway-HSDDM05.spdl": [[true, "# 1 \"fourway-HSDDM05.cpp\"\n# 1 \"<built-in>\"\n# 1 \"<command line>\"\n# 1 \"fourway-HSDDM05.cpp\"\n# 10 \"fourway-HSDDM05.cpp\"\nusertype Params, String;\n\nconst hash: Function;\nsecret unhash: Function;\ninversekeys(hash,unhash);\nsecret pmk: Function;\n\nconst msg1,msg2,msg3,msg4: String;\n\nconst Alice, Bob, Eve: Agent;\n\nprotocol fourway(Alice, Bob)\n{\n        role Alice\n        {\n                fresh x: Nonce;\n                var y: Nonce;\n\n                send_1(Alice, Bob, x, msg1);\n                recv_2(Bob, Alice, y, msg2, hash(hash(pmk(Alice, Bob), x, y), y, msg2));\n                send_3(Alice, Bob, x, msg3, hash(hash(pmk(Alice, Bob), x, y), x, msg3));\n                recv_4(Bob, Alice, msg4, hash(hash(pmk(Alice, Bob), x, y), msg4));\n\n                claim_X1(Alice, Secret, hash(pmk(Alice, Bob), x, y));\n                claim_X2(Alice, Niagree);\n        }\n\n        role Bob\n        {\n                var x: Nonce;\n                fresh y: Nonce;\n\n                recv_1(Alice, Bob, x, msg1);\n                send_2(Bob, Alice, y, msg2, hash(hash(pmk(Alice, Bob), x, y), y, msg2));\n                recv_3(Alice, Bob, x, msg3, hash(hash(pmk(Alice, Bob), x, y), x, msg3));\n                send_4(Bob, Alice, msg4, hash(hash(pmk(Alice, Bob), x, y), msg4));\n\n                claim_Y1(Bob, Secret, hash(pmk(Alice, Bob), x, y));\n                claim_Y2(Bob, Niagree);\n        }\n}"]], "SPDL-1/gros_pigeons-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(I, R, {sec}pk(R));\n\t\trecv_2(R, I, h(sec), {n}pk(I));\n\t\tsend_3(I, R, h(n));\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(I, R, {sec}pk(R));\n\t\tsend_2(R, I, h(sec), {n}pk(I));\n\t\trecv_3(I, R, h(n));\n\t}\n}"]], "SPDL-1/HMQV.spdl": [[true, "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}"]], "SPDL-1/ikev1-quick.spdl": [[true, "# 1 \"ikev1-quick.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-quick.cpp\"\n# 16 \"ikev1-quick.cpp\"\n# 1 \"common.h\" 1\n\n\nhashfunction prf, KDF;\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n  var I, R: Agent;\n  \n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),h(g(i),r),Ni,Nr) );\n\n }\n}\n# 17 \"ikev1-quick.cpp\" 2\n# 28 \"ikev1-quick.cpp\"\nprotocol ikev1-quick(I, R)\n{\n role I {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( I, R, mid, {prf(k(I,R), mid, list, Ni, g(i), I, R), list, Ni, g(i), I, R}k(I,R) );\n  recv_!2( R, I, mid, {prf(k(I,R), mid, Ni, algo, Nr, Gr, I, R), algo, Nr, Gr, I, R}k(I,R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( I, R, mid, {prf(k(I,R), mid, Ni, Nr)}k(I,R) );\n\n  claim( I, SKR, KDF(k(I,R),h(Gr,i),Ni,Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr );\n\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( I, R, mid, {prf(k(R,I), mid, list, Ni, Gi, I, R), list, Ni, Gi, I, R}k(R,I) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r) );\n  send_!2( R, I, mid, {prf(k(R,I), mid, Ni, algo, Nr, g(r), I, R), algo, Nr, g(r), I, R}k(R,I) );\n  recv_!3( I, R, mid, {prf(k(R,I), mid, Ni, Nr)}k(R,I) );\n\n  claim( R, SKR, KDF(k(R,I),h(Gi,r),Ni,Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r) );\n\n }\n}"]], "SPDL-1/ikev2-mac.spdl": [[true, "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\nhashfunction prf, KDF;\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\nrole DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\nrole SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n }\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector;\nconst O: Number;\nconst SA1 ,SA2, SA3: SecurityAssociation;\nconst TSi, TSr: TrafficSelector;\n\nprotocol @executability(E) {\n\nrole E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce;\n  var I, R: Agent;\n\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {R, MAC(k(I,R), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n }\n}\n\nprotocol ikev2-mac(I, R)\n{\nrole I {\n  fresh i, Ni, SPIi: Nonce;\n  var Nr, SPIr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni );\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr );\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr);\n  send_!3( I, R, (SPIi,SPIr), {I, MAC(k(R,I), SPIi, O, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr);\n }\n\nrole R {\n  fresh r, Nr, SPIr: Nonce;\n  var Ni, SPIi: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni );\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr );\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr);\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr);\n }\n}"]], "SPDL-1/iso25-tag.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * four-pass\n * mutual\n *\n * Modeling notes:\n * - The use of TNb in message 4, as specified by the ISO standard, is\n *   different from other models, in which it was TNa.\n */\nusertype SessionKey;\nusertype Tag;\n\nconst t1,t2a,t2b,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-5(A,B,P)\n{\n\trole A\n\t{\n\t\tfresh TVPa: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNa: Nonce;\n\t\tvar TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text5,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\tsend_1(A,P, TVPa, B, Text1);\n\t\trecv_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text5);\n\t\tsend_3(A,B, Text6, T, { t3, TNa, B, Text5 }Kab );\n\t\trecv_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text5,Text7);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text5);\n\t\tclaim(A,Secret,Text7);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNp: Nonce;\n\t\tvar TNa: Nonce;\n\t\tfresh TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text7,Text8: Ticket;\n\t\tvar Text2,Text5,Text6: Ticket;\n\n\t\trecv_3(A,B, Text6, { t2b, TNp, Kab, A, Text2  }k(B,P), {\n\t\tt3, TNa, B, Text5 }Kab );\n\t\tclaim(B,Running,A,Kab,Text5,Text7);\n\t\tsend_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(B,Commit,A,Kab,Text5);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text5);\n\t\tclaim(B,Secret,Text7);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar TVPa: Nonce;\n\t\tfresh TNp: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text2,Text3,Text4: Ticket;\n\t\tvar Text1: Ticket;\n\n\t\trecv_1(A,P, TVPa, B, Text1);\n\t\tsend_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P),\n\t\t\t\t  { t2b, TNp, Kab, A, Text2  }k(B,P) );\n\t}\n}"]], "SPDL-1/isoiec-9798-2-1.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}"]], "SPDL-1/isoiec11770-2-13.spdl": [[false, "Based on the provided description, the formal analysis code in SPDL language can be completed as follows:\n\n```houzhui\nusertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, ni);\n\t\trecv_4 (R,I, { ni,kir,R }k(I,S) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, ni);\n\t\tsend_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\trecv_3 (S,R, { nr, I }k(R,S), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\trecv_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\tsend_3 (S,R, { nr, I }k(R,S), { ni,kir,R }k(I,S) );\n\t}\n}\n```\n\n---\nThis completed formal analysis code should compile successfully with Scyther and correctly reflects the protocol steps described."]], "SPDL-1/KAS1.spdl": [[true, "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(PUBLIC_KEY,SENDER_KEY,RANDOM_KEY)\n{\n\trole PUBLIC_KEY\n\t{\n\t\tsend_!1(PUBLIC_KEY,PUBLIC_KEY, g1(sk(PUBLIC_KEY)) );\n\t}\n\trole SENDER_KEY\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(SENDER_KEY,SENDER_KEY, g2(g1(T),sk(SENDER_KEY)) );\n\t\tsend_!3(SENDER_KEY,SENDER_KEY, g2(pk(SENDER_KEY),T) );\n\t}\n\trole RANDOM_KEY\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RANDOM_KEY,RANDOM_KEY, g2(pk(RANDOM_KEY),T) );\n\t\tsend_!5(RANDOM_KEY,RANDOM_KEY, g2(g1(T),sk(RANDOM_KEY)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(PUBLIC_KEY,SENDER_KEY,RANDOM_KEY)\n{\n\trole PUBLIC_KEY\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(PUBLIC_KEY,PUBLIC_KEY, g2(g1(T1),T2) );\n\t\tsend_!2(PUBLIC_KEY,PUBLIC_KEY, g2(g1(T2),T1) );\n\t}\n\trole SENDER_KEY\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(SENDER_KEY,SENDER_KEY, h1(g2(g1(T1),T2),T3,RANDOM_KEY,SENDER_KEY) );\n\t\tsend_!4(SENDER_KEY,SENDER_KEY, h1(g2(g1(T2),T1),T3,RANDOM_KEY,SENDER_KEY) );\n\t}\n\trole RANDOM_KEY\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RANDOM_KEY,RANDOM_KEY, h1(T3,g2(g1(T1),T2),RANDOM_KEY,PUBLIC_KEY) );\n\t\tsend_!6(RANDOM_KEY,RANDOM_KEY, h1(T3,g2(g1(T2),T1),RANDOM_KEY,PUBLIC_KEY) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}"]], "SPDL-1/andrew-lowe-ban.spdl": [[true, "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I, ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I, ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}"]], "SPDL-1/KEA+.spdl": [[true, "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(Alice,Bob,Charlie)\n{\n\trole Alice\n\t{\n\t\tsend_!1(Alice,Alice, g1(sk(Alice)) );\n\t}\n\trole Bob\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(Bob,Bob, g2(g1(T),sk(Bob)) );\n\t\tsend_!3(Bob,Bob, g2(pk(Bob),T) );\n\t}\n\trole Charlie\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(Charlie,Charlie, g2(pk(Charlie),T) );\n\t\tsend_!5(Charlie,Charlie, g2(g1(T),sk(Charlie)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(Alice,Bob,Charlie)\n{\n\trole Alice\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(Alice,Alice, g2(g1(T1),T2) );\n\t\tsend_!2(Alice,Alice, g2(g1(T2),T1) );\n\t}\n\trole Bob\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(Bob,Bob, h1(g2(g1(T1),T2),T3,Charlie,Bob) );\n\t\tsend_!4(Bob,Bob, h1(g2(g1(T2),T1),T3,Charlie,Bob) );\n\t}\n\trole Charlie\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(Charlie,Charlie, h1(T3,g2(g1(T1),T2),Charlie,Alice) );\n\t\tsend_!6(Charlie,Charlie, h1(T3,g2(g1(T2),T1),Charlie,Alice) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}"]], "SPDL-1/kerberos-rddm.spdl": [[true, "/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(Role1, Role2)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role Role1\n    {\n        var Ticket1:Ticket;\n\n\n        recv_!X1(Role2, Role1, {Ticket1}ktk(Role1, Role2));\n        send_!X2(Role1, Role2, {Ticket1}ktk(Role2, Role1));\n    }\n    role Role2\n    {\n    }\n}\nprotocol @swapkey-kck(Role1, Role2)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role Role1\n    {\n        var Ticket2:Ticket;\n\n\n        recv_!X1(Role2, Role1, {Ticket2}kck(Role1, Role2));\n        send_!X2(Role1, Role2, {Ticket2}kck(Role2, Role1));\n    }\n    role Role2\n    {\n    }\n}\nprotocol @swapkey-kst(Role1, Role2)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role Role1\n    {\n        var Ticket3:Ticket;\n\n\n        recv_!X1(Role2, Role1, {Ticket3}kst(Role1, Role2));\n        send_!X2(Role1, Role2, {Ticket3}kst(Role2, Role1));\n    }\n    role Role2\n    {\n    }\n}\n\nprotocol kerberos(C,K,T,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,T,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,T }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,T, tgt, { C }AKey,C,S,n2 );\n\t\trecv_4(T,C, C, st, { SKey, n2, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,T,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(T,K), { AKey,n1,T }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole T {\n\t\tvar AKey: Sessionkey;\n\t\tvar n2: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,T, { AKey, C }ktk(T,K), { C }AKey,C,S,n2 );\n\t\tsend_4(T,C, C,{ SKey, C }kst(S,T), { SKey, n2, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(T,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(T,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(T,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,T), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted"]], "SPDL-1/localclaims-breaker.spdl": [[true, "/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr,I}pk(R) );\n\n\t\trecv_x1(R,I, { x }pk(I) );\n\t\tsend_x2(I,R, { x }ni );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh x: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr,I}pk(R) );\n\n\t\tsend_x1(R,I, { x }pk(I) );\n\t\trecv_x2(I,R, { x }ni );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t}\n}"]], "SPDL-1/myProt.spdl": [[true, "hashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(A,B)\n{\n\trole A\n\t{\n\t\tfresh K: MySecret;\n\t\tvar W: Nonce;\n\n\t\tsend_1(A, B, h(A, K), {K}pk(B));\n\t\trecv_2(B, A, h(B, K, W), {W}pk(A));\n\t\tsend_3(A, B, h(W));\n\n\t\tclaim_4(A, Secret, K);\n\t\tclaim_6(A, Nisynch);\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar V: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(A, B, h(A, V), {V}pk(B));\n\t\tsend_2(B, A, h(B, V, n), {n}pk(A));\n\t\trecv_3(A, B, h(n));\n\n\t\tclaim_5(B, Secret, V);\n\t\tclaim_7(B, Nisynch);\n\t}\n}"]], "SPDL-1/NAXOS.spdl": [[true, "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}"]], "SPDL-1/needham-schroeder-sk.spdl": [[true, "# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroedersk(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var Kir: SessionKey;\n        var T: Ticket;\n        \n        send_1(I,S,(I,R,Ni));\n        recv_2(S,I, {Ni,R,Kir,T}k(I,S));\n        send_3(I,R,T);\n        recv_4(R,I,{Nr}Kir);\n        send_5(I,R,{{Nr}dec}Kir);\n        claim_I2(I,Secret,Kir);\n        claim_I3(I,Nisynch);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Kir: SessionKey;\n        \n        recv_3(I,R,{Kir,I}k(R,S));\n        send_4(R,I,{Nr}Kir);\n        recv_5(I,R,{{Nr}dec}Kir);\n        claim_R1(R,Secret,Kir);\n        claim_R3(R,Nisynch);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni: Nonce;\n        fresh Kir: SessionKey;\n        recv_1(I,S,(I,R,Ni));\n        send_2(S,I,{Ni,R,Kir,{Kir,I}k(R,S)}k(I,S));\n    }\n}"]], "SPDL-1/nsl3.spdl": [[true, "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}"]], "SPDL-1/nuts-auth.spdl": [[true, "hashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, Sat), Ra, Rb);\n\nprotocol NUTSAuth (GS, Sat) {\n\n    role GS {\n        var Ra: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        recv_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        send_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        recv_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Send command\n        send_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        recv_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Send another command (repeat CMDs for scyther to spot replay attacks)\n        send_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        recv_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(GS, Alive);\n        claim(GS, Secret, Ks);\n        claim(GS, Weakagree);\n        claim(GS, Niagree);\n        claim(GS, Nisynch);\n    };\n\n    role Sat {\n        fresh Ra: Nonce;\n        var Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        recv_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        send_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        recv_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        send_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Receive command\n        recv_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        send_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Receive second command\n        recv_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        send_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(Sat, Alive);\n        claim(Sat, Secret, Ks);\n        claim(Sat, Weakagree);\n        claim(Sat, Niagree);\n        claim(Sat, Nisynch);\n    };\n}"]], "SPDL-1/oakley-a.spdl": [[true, "# 1 \"oakley-a.cpp\"\n# 1 \"<command-line>\"\n# 1 \"oakley-a.cpp\"\n# 18 \"oakley-a.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 141 \"common.h\"\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 19 \"oakley-a.cpp\" 2\n\n\n\nusertype String;\nconst list, algo: String;\n\nprotocol oakley-a(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, g(i), list, I, R, Ni, {I, R, Ni, g(i), list}sk(I) );\n  recv_2( R, I, Cr, Ci, Gr, algo, R, I, Nr, Ni, {R, I, Nr, Ni, g(i), Gr, algo}sk(R) );\n  send_3( I, R, Ci, Cr, g(i), algo, I, R, Ni, Nr, {I, R, Ni, Nr, g(i), Gr, algo}sk(I) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, Gi, list, I, R, Ni, {I, R, Ni, Gi, list}sk(I) );\n  send_2( R, I, Cr, Ci, g(r), algo, R, I, Nr, Ni, {R, I, Nr, Ni, Gi, g(r), algo}sk(R) );\n  recv_3( I, R, Ci, Cr, Gi, algo, I, R, Ni, Nr, {I, R, Ni, Nr, Gi, g(r), algo}sk(I) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"]], "SPDL-1/pkmv2rsacorrected.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, bsrand, prepak, BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, bsrand, prepak}pk(MS), {msrand, bsrand, prepak, BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}"]], "SPDL-1/athena-breaker.spdl": [[true, "/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_!1(I,R, {{I,ni}pk(R)}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar T:Ticket;\n\n\t\trecv_!1(I,R, {T}pk(R) );\n\t\tsend_!2(R,I, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information"]], "SPDL-1/pqr.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said, c: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    send_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    send_tekup1(MS,BS,{c}hash(prepak));\n    recv_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai5(MS,SKR,prepak);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n    claim_rsar8(MS,SKR,tek2);\n    claim_rsar9(MS,SKR,tek3);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said, c: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    recv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    recv_tekup1(MS,BS,{c}hash(prepak));\n    send_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar5(BS,SKR,prepak);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n    claim_rsar8(BS,SKR,tek2);\n    claim_rsar9(BS,SKR,tek3);\n  }\n}"]], "SPDL-1/protocol0-symm.spdl": [[true, "/*\n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}"]], "SPDL-1/Signed-DH.spdl": [[true, "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(____(ROLE_1)____)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(____(ROLE_1)____,____(ROLE_1)____, g2(g1(T1),T2) );\n\t\tsend_!2(____(ROLE_1)____,____(ROLE_1)____, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}"]], "SPDL-1/skeme-basic.spdl": [[true, "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (ROLE_1, SWAP) {\n\n\n\n\n\n\n\n role ROLE_1 {\n  var i, r: Nonce;\n\n  recv_!DH1( ROLE_1, ROLE_1, h(g(r),i) );\n  send_!DH2( ROLE_1, ROLE_1, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"]], "SPDL-1/soph.spdl": [[true, "protocol soph(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, ni );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, ni );\n\t}\n}"]], "SPDL-1/sts-modified.spdl": [[true, "# 1 \"sts-modified.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-modified.cpp\"\n# 17 \"sts-modified.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (D, SWAP) {\n\n\n\n\n\n\n\n role D {\n  var i, d: Nonce;\n\n  recv_!DH1( D, D, h(g(d),i) );\n  send_!DH2( D, D, h(g(i),d) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 18 \"sts-modified.cpp\" 2\n\n\n\n\nprotocol sts-modified(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_2( R, I, Gr, {Gr, g(i), I}sk(R) );\n  send_3( I, R, {g(i), Gr, R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_2( R, I, g(r), {g(r), Gi, I}sk(R) );\n  recv_3( I, R, {Gi, g(r), R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"]], "SPDL-1/th-1par2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}\n\n\n\n\nprotocol nsl3th2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P2,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P2,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}"]], "SPDL-1/tls-BM-1.spdl": [[true, "/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n/* below is just Scyther input and no further macro definitions */\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\nprotocol tls-bm-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( A,B, na );\n\t\trecv_2( B,A, nb );\n\t\tsend_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\trecv_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_A1( A, Secret, hash(pmk,na,nb) );\n\t\tclaim_A2( A, Nisynch );\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar na: Nonce;\n\t\tvar pmk: Nonce;\n\t\tfresh nb: Nonce;\n\n\t\trecv_1( A,B, na );\n\t\tsend_2( B,A, nb );\n\t\trecv_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\tsend_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_B1( B, Secret, hash(pmk,na,nb) );\n\t\tclaim_B2( B, Nisynch );\n\t}\n}"]], "SPDL-1/wmf-brutus.spdl": [[true, "usertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { B,kab }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,B, { A, kab }k(B,S) );\n\n\t\tclaim_3(B, Secret, kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { B,kab }k(A,S) );\n\t\tsend_2(S,B, { A, kab }k(B,S) );\n\t}\n}"]], "SPDL-1/yahalom-ban-paulson.spdl": [[true, "// BAN modified version of the yahalom protocol\n//\n// Modeled as version in Paulson's paper:\n// \"Relations Between Secrets: Two Formal Analyses of the Yahalom\n// Protocol\"\n\nusertype Server;\nusertype SessionKey;\n\nprotocol yahalom-BAN-Paulson(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tvar nb: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\tsend_1(A,B, A,na);\n\t\trecv_3(S,A, {B,kab,na,nb}k(A,S), ticket );\n\t\tsend_4(A,B, ticket, {nb}kab );\n\t\tclaim_5(A, Secret,kab);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\trecv_1(A,B, A,na);\n\t\tsend_2(B,S, B, {A,na,nb}k(B,S) );\n\t\trecv_4(A,B, {A,kab}k(B,S) , {nb}kab );\n\t\tclaim_6(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tfresh kab: SessionKey;\n\t\tvar na,nb: Nonce;\n\n\t\trecv_2(B,S, B, {A,na,nb}k(B,S) );\n\t\tsend_3(S,A, {B,kab,na,nb}k(A,S), {A,kab}k(B,S) );\n\t}\n}"]], "SPDL-1/Authentication_CRCBAC.spdl": [[true, "hashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,GW)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var T2:Nonce;secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,GW,e,AID,Tr,T1);\n\n        recv_2(GW,D,Npr,T2);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role GW\n\n     {\n\n          fresh Npr,T2:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,GW,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (GW,D,Npr,T2);\n\n          claim(GW,Alive);\n\n          claim(GW,Weakagree);\n\n          claim(GW,Commit,D,Npr);\n\n          claim(GW,Niagree);\n\n          claim(GW,Nisynch);\n\n          claim(GW,Secret,Krs);\n\n          claim(GW,Secret,K);\n\n      }\n\n}"]], "SPDL-1/andrew-ban-concrete.spdl": [[true, "# BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN2.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# In order to overcome this a 'dummy' role X has been hadded that recrypts\n# a given term crypted with k(I,R) with k(R,I)\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is \n# completely fresh and can therefore always be replaced by an arbitrary value \n# created by the intruder) which are not considered in SPORE\n#\n\nusertype SessionKey;\nconst Fresh: Function;\n\nprotocol @swapkey(X)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role X\n    {\n        var I,R: Agent;\n        var T:Ticket;\n        recv_!X1(X,X,I,R,{T}k(I,R));\n        send_!X2(X,X,{T}k(R,I));\n    }\n}\n\nprotocol andrew-Concrete(I,R)\n{\n    \n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n        \n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir}k(I,R) );\n        send_3(I,R, {ni}kir);\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,kir));\n        recv_6(R,I, nr);\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir}k(I,R) );\n        recv_3(I,R, {ni}kir);\n        send_6(R,I, nr);\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,kir));\n    }\n}"]], "SPDL-1/andrew.spdl": [[true, "# Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrew.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n\nusertype SessionKey;\nconst succ: Function;\nconst Fresh: Function;\n\nprotocol andrew(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {succ(ni),nr}k(I,R) );\n        send_3(I,R, {succ(nr)}k(I,R) );\n        recv_4(R,I, {kir,nr2}k(I,R) );\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Niagree);\n        claim_I4(I,Empty,(Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {succ(ni),nr}k(I,R) );\n        recv_3(I,R, {succ(nr)}k(I,R) );\n        send_4(R,I, {kir,nr2}k(I,R) );\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Niagree);\n        claim_R4(R,Empty,(Fresh,kir));\n    }\n}"]], "SPDL-1/asymmetric-encryption.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh n1: Nonce;\n\n\t\tsend_1(I,R, {I,n1}pk(R) );\n\t\tclaim_i(I,Secret,n1);\n\t}\n\n\trole R\n\t{\n\t\tvar n1: Nonce;\n\n\t\trecv_1(I,R, {I,n1}pk(R) );\n\t\tclaim_r(R,Secret,n1);\n\t}\n}"]], "SPDL-1/bakatar.spdl": [[true, "#by louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol bakatar-0(A, B, S) {\n    role A {\n        fresh K: MySecret;\n \n        send_1(A, S, (A, {B, K}k(A, S)));\n        recv_4(S, A, {B, h(K)}k(A, S));\n \n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var K: MySecret;\n \n        recv_1(A, S, (A, {B, K}k(A, S)));\n        send_2(S, B, {A, K}k(B, S));\n        recv_3(B, S, (B, {A, h(K)}k(B, S)));\n        send_4(S, A, {B, h(K)}k(A, S));\n    }\n    role B {\n        var K: MySecret;\n \n        recv_2(S, B, {A, K}k(B, S));\n        send_3(B, S, (B, {A, h(K)}k(B, S)));\n \n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}"]], "SPDL-1/bke-broken.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n\n\tCMV version with explicit secrecy claims.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkepk(Initiator,Responder)\n{\n\trole Initiator\n\t{\n\t\tconst NI: Nonce;\n\t\tvar NR: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tread_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tsend_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_4 (Initiator, Secret, kab );\n\t}\n\n\trole Responder\n\t{\n\t\tvar NI: Nonce;\n\t\tconst NR: Nonce;\n\t\tconst kab: Key;\n\n\t\tread_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tsend_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tread_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_5 (Responder, Secret, kab );\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\ncompromised sk(Eve);\nconst ne: Nonce;\n\nrun bkepk.Initiator(Alice,Agent);\nrun bkepk.Responder(Agent,Bob);\nrun bkepk.Initiator(Alice,Agent);\nrun bkepk.Responder(Agent,Bob);\n\nrun bkepk.Initiator(Alice,Agent);\nrun bkepk.Responder(Agent,Bob);\nrun bkepk.Initiator(Alice,Agent);\nrun bkepk.Responder(Agent,Bob);\n\nrun bkepk.Initiator(Alice,Agent);\nrun bkepk.Responder(Agent,Bob);"]], "SPDL-1/boyd-1.spdl": [[true, "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t\tclaim_7 (I, Niagree);\n\t\tclaim_8 (I, Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t\tclaim_11 (R, Niagree);\n\t\tclaim_12 (R, Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}"]], "SPDL-1/broken1-1.spdl": [[true, "/*\n * A broken protocol\n *\n * Cas Cremers\n * Visualization challenge of the week.\n * Can be checked withouth CL, please do so.\n */\n\nusertype String, Key;\nconst PlainSight: String;\nsecret HelloWorld, HelloServer: String;\nsecret k: Key;\n\nprotocol broken1(I,R,S)\n{\n\trole I\n\t{\n\t\tsend_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tsend_2(I, S, {HelloServer, I, S}k );\n\t}\t\n\trole R\n\t{\n\t\trecv_3(S, R, {HelloWorld, S, I, R}k );\n\t\trecv_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tclaim_4(R, Secret, PlainSight);\n\t}\n\trole S\n\t{\n\t\trecv_2(I, S, {HelloServer, I, S}k );\n\t\tsend_3(S, R, {HelloWorld, S, I, R}k );\n\t}\n}\n\nconst a, b, S: Agent;\n\nrun broken1.I(a, b, S);\nrun broken1.R(a, b, S);\nrun broken1.S(a, b, S);"]], "SPDL-1/bunava-1-3.spdl": [[true, "# Buttyan Nagy Vajda protocol 1 (3-party)\n#\n# Modelled after the description in the paper\n# \"Efficient multi-party challenge-response protocols for entity\n# authentication\"\n#\n# Attacks:\n# Does not satisfy ni-agree, because when Alice in the R0 role terminates\n# it cannot be sure that the agent in role R1 is aware of having sent a\n# reply for Alice.\n# R0 type flaw attack exists in which there are only two agents active.\n#\n\nsecret k: Function;\n\nprotocol intruderhelp(Swap)\n{\n    role Swap\n    {\n        var T: Ticket;\n\tvar R0,R1: Agent;\n\n\trecv_!1(Swap,Swap, { T }k(R0,R1) );\n\tsend_!2(Swap,Swap, { T }k(R1,R0) );\n    }\n}\n\nprotocol bunava13(R0,R1,R2)\n{\n    role R0\n    {\n        fresh n0: Nonce;\n\tvar n1,n2: Nonce;\n\n\tsend_1(R0,R1, n0);\n\trecv_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\tsend_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\n\tclaim_A1(R0, Niagree);\n\tclaim_A2(R0, Nisynch);\n    }\n\n    role R1\n    {\n        fresh n1: Nonce;\n\tvar n0,n2: Nonce;\n\n\trecv_1(R0,R1, n0);\n\tsend_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\trecv_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\tsend_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_B1(R1, Niagree);\n\tclaim_B2(R1, Nisynch);\n    }\n\n    role R2\n    {\n        fresh n2: Nonce;\n\tvar n0,n1: Nonce;\n\n\trecv_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\tsend_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\trecv_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_C1(R2, Niagree);\n\tclaim_C2(R2, Nisynch);\n    }\n}\n\n\n\n# General scenario, 2 parallel runs of the protocol"]], "SPDL-1/carkey-broken-limited.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeybrokenlim(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, I,R, ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, I,R, ni);\n\t\tclaim_2(R,Nisynch);\n\t}\n}"]], "SPDL-1/carkey-ni2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tsend_2(I,R, {R,ni}sk(I) );\n\t\tclaim_5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tread_2(I,R, {R,ni}sk(I) );\n\t\tclaim_4(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);"]], "SPDL-1/base.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(B, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\n\nprotocol BaseCaseProtocol(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh r: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_3 (B, M, IDt, a, r, t, Sb);\n\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tvar t: Timestamp;\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction request from merchant\n\t\t*/\n\t\trecv_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Send transaction confirmation to bank\n\t\t*/\n\t\tsend_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_3 (B, M, IDt, a, r, t, Sb);\n\t\tsend_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}"]], "SPDL-1/ccitt509-3.spdl": [[true, "# CCITT X.509 (3)\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/ccittx509_3.html\n#\n# Note:\n# The protocol description also states that Xa and Ya should be fresh\n# this can not be verified using scyther\n#\n\nusertype Timestamp;\n\nprotocol ccitt509-3(I,R)\n{\n    role I\n    {\n        fresh Ta: Timestamp;\n        var Tb: Timestamp;\n        fresh Na,Xa,Ya: Nonce;\n        var Xb,Nb,Yb: Nonce;\n        send_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        recv_2(R,I, R,{Tb, Nb, I, Na, Xb, {Yb}pk(I)}sk(R));\n        send_3(I,R, I, {Nb}sk(I));\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret,Ya);\n        claim_I3(I,Secret,Yb);\n    }    \n    \n    role R\n    {\n        var Ta: Timestamp;\n        fresh Tb: Timestamp;\n        var Na,Xa,Ya: Nonce;\n        fresh Xb,Yb,Nb: Nonce;\n\n        recv_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        send_2(R,I, R,{Tb, Nb, I, Na, Xb, {Yb}pk(I)}sk(R));\n        recv_3(I,R, I, {Nb}sk(I));\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret,Ya);\n        claim_R3(R,Secret,Yb);\n        # There should also be Fresh Xa and Fresh Ya claims here\n    }\n}"]], "SPDL-1/denning-sacco-lowe.spdl": [[true, "# Lowe modified Denning-Sacco shared key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/denningSaccoLowe.html\n#\n# Note:\n# According to SPORE there are no attacks on this protocol. Scyther\n# finds a straightforward pre-play attack on the first message, which\n# violates synchronisation. However, this does not seem to be a\n# practical attack unless consistency is required, e.g., for logging or\n# auditing.\n\nusertype Key;\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\nusertype PseudoFunction;\nconst dec: PseudoFunction;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol denningSacco-Lowe(I,R,S)\n{\n    role I\n    {\n        var W: Ticket;\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        var Ni: Nonce;\n\n        send_1(I,S, I,R );\n        recv_2(S,I, {R, Kir, T, W}k(I,S) );\n        send_3(I,R, W);\n        recv_4(R,I, {Ni}Kir);\n        send_5(I,R, {{Ni}dec}Kir);\n        claim_I1(I,Niagree);\n        claim_I2(I,Nisynch);\n        claim_I3(I,SKR,Kir);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        fresh Ni: Nonce;\n\n        recv_3(I,R, {Kir,I,T}k(R,S));\n        send_4(R,I, {Ni}Kir);\n        recv_5(I,R, {{Ni}dec}Kir);\n        claim_R1(R,Niagree);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Secret,Kir);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n    \n    role S\n    {\n        var W: Ticket;\n        fresh Kir: SessionKey;\n        fresh T: TimeStamp;\n\n        recv_1(I,S, I,R );\n        send_2(S,I, {R, Kir, T, {Kir, I,T}k(R,S)}k(I,S));\n    }    \n}"]], "SPDL-1/exchange.spdl": [[true, "/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {R,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {R,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}"]], "SPDL-1/f4.spdl": [[true, "/*\n * f4.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r4 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f4(I,R)\n{\n\trole I\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_!1(R,I, ni );\n\t\tsend_!2(I,R, { ni }sk(I) );\n\t\trecv_!3(R,I, {{{{ ni }sk(R)}sk(R)}sk(R)}sk(R) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tsend_!1(R,I, nr );\n\t}\n\t\n}"]], "SPDL-1/f5.spdl": [[true, "/*\n * f5.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r5 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f5(I,R)\n{\n\trole I\n\t{\n\t\tvar Na: Nonce;\n\n\t\trecv_!1(R,I, Na );\n\t\tsend_!2(I,R, { Na }sk(I) );\n\t\trecv_!3(R,I, {{{{{ Na }sk(R)}sk(R)}sk(R)}sk(R)}sk(R)} );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh Na: Nonce;\n\t\tsend_!1(R,I, Na );\n\t}\n\t\n}"]], "SPDL-1/gong-nonce-1.spdl": [[true, "usertype Sessionkey;\nusertype Keypart;\nsecret k: Function;\n\nprotocol gongnonce(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tfresh ki: Keypart;\n\t\tvar kr: Keypart;\n\n\t\tsend_1 (I,R, I,R,ni );\n\t\trecv_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\tsend_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\n\t\tclaim_6 (I, Secret, ki);\n\t\tclaim_7 (I, Secret, kr);\n\t\tclaim_8 (I, Nisynch);\n\t\tclaim_9 (I, Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kr: Keypart;\n\t\tvar ki: Keypart;\n\n\t\trecv_1 (I,R, I,R,ni );\n\t\tsend_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\trecv_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\n\t\tclaim_10 (R, Secret, ki);\n\t\tclaim_11 (R, Secret, kr);\n\t\tclaim_12 (R, Nisynch);\n\t\tclaim_13 (R, Niagree);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar ki,kr: Keypart;\n\n\t\trecv_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\tsend_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\trecv_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\t\tsend_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\t}\n}\n\n\nconst kpe: Keypart;\nconst ke: Sessionkey;"]], "SPDL-1/ikev1-psk-m.spdl": [[true, "protocol @oracle (DH, SWAP) {\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n  var Ci, Cr: Nonce;\n  var I, R: Agent;\n\n  recv_!SWAP1( SWAP, SWAP, prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n}"]], "SPDL-1/ikev1-sig-a2.spdl": [[true, "# 1 \"ikev1-sig-a2.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-sig-a2.cpp\"\n# 17 \"ikev1-sig-a2.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n\n\n\n\n\n\n\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, ROLE_1) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role ROLE_1 {\n  var i, r, Ni, Nr: Nonce;\n\n\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( ROLE_1, ROLE_1, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( ROLE_1, ROLE_1, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 18 \"ikev1-sig-a2.cpp\" 2\n# 29 \"ikev1-sig-a2.cpp\"\nusertype String;\nconst list, algo: String;\n\n\n\n\n\n\n\nprotocol @executability(O) {\n\n\n role O {\n  var i, r, Ni, Nr, Ci, Cr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {prf(Ni, Nr, h(g(i),r), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n  send_!O2( O, O, {prf(Ni, Nr, h(g(r),i), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n\n\n  recv_!O3( O, O, {{prf(Ni, Nr, h(g(r),i), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!O4( O, O, {{prf(Ni, Nr, h(g(i),r), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n\n\nprotocol ikev1-sig-a2(I, R)\n{\n\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, list, g(i), Ni, I );\n  recv_!2( R, I, (Ci,Cr), algo, Gr, Nr, R, {prf(Ni, Nr, h(Gr,i), Gr, g(i), Cr, Ci, list, R)}sk(R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr, Ci, Cr );\n  send_!3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gr,i), g(i), Gr, Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr, Ci, Cr );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, list, Gi, Ni, I );\n  claim( R, Running, I, Ni, Nr, Gi, g(r), Ci, Cr );\n  send_!2( R, I, (Ci,Cr), algo, g(r), Nr, R, {prf(Ni, Nr, h(Gi,r), g(r), Gi, Cr, Ci, list, R)}sk(R) );\n  recv_!3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gi,r), Gi, g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r), Ci, Cr );\n\n }\n}"]], "SPDL-1/ikev2-child-nopfs.spdl": [[true, "# 1 \"ikev2-child-nopfs.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-child-nopfs.cpp\"\n# 15 \"ikev2-child-nopfs.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\nhashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 138 \"common.h\"\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),Ni,Nr) );\n\n }\n\n\n}\n# 16 \"ikev2-child-nopfs.cpp\" 2\n\n\nconst SA3: Nonce;\n\n\n\n\n\n\nprotocol @executability(O) {\n role O {\n  var Ni, Nr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {SA3, Ni}k(I,R) );\n  send_!O2( O, O, {SA3, Ni}k(R,I) );\n\n\n  recv_!O3( O, O, {Nr}k(R,I) );\n  send_!O4( O, O, {Nr}k(I,R) );\n\n }\n}\n\n\nprotocol ikev2-child-nopfs(I, R)\n{\n\n role I {\n  fresh Ni: Nonce;\n  var Nr: Nonce;\n\n\n  claim( I, Running, R,Ni );\n  send_!1( I, R, {SA3, Ni}k(I,R) );\n  recv_!2( R, I, {Nr}k(I,R) );\n\n\n  claim( I, SKR, KDF(k(I,R),Ni,Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R,Ni,Nr );\n\n }\n\n role R {\n  fresh Nr: Nonce;\n  var Ni: Nonce;\n\n  recv_!1( I, R, {SA3, Ni}k(R,I) );\n  claim( R, Running, I,Ni,Nr );\n  send_!2( R, I, {Nr}k(R,I) );\n\n\n  claim( R, SKR, KDF(k(R,I),Ni,Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I,Ni );\n }\n}"]], "SPDL-1/iso26-tag.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * five-pass\n * mutual\n *\n * MPA Attack reported by Mathuria:\n * - Type flaw MPA when in parallel with Abadi-Needham protocol.\n *\n */\nusertype Tag;\n\nconst t1,t2,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-6-tag(A,B,P)\n{\n\trole A\n\t{\n\t\tvar Nb: Nonce;\n\t\tfresh Ra,Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar T: Ticket;\n\t\tfresh Text2,Text6,Text7: Ticket;\n\t\tvar Text1,Text4,Text5,Text8,Text9: Ticket;\n\n\t\trecv_1(B,A, Nb, Text1);\n\t\tsend_2(A,P, Ra, Nb, B, Text2);\n\t\trecv_3(P,A, Text5, {t1, Ra,Kab,B,Text4}k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text6);\n\t\tsend_4(A,B, Text7, T, {t3,Rpa,Nb,Text6}Kab );\n\t\trecv_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text6,Text8);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text6);\n\t\tclaim(A,Secret,Text8);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text8,Text9: Ticket;\n\t\tvar Text3,Text6,Text7: Ticket;\n\n\t\tsend_1(B,A, Nb, Text1);\n\t\trecv_4(A,B, Text7, {t2,Nb,Kab,A,Text3}k(B,P), {t3,Rpa,Nb,Text6}Kab );\n\t\tclaim(B,Running,A,Kab,Text6,Text8);\n\t\tsend_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\t\t\n\t\tclaim(B,Commit,A,Kab,Text6);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text6);\n\t\tclaim(B,Secret,Text8);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar Ra, Nb: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text3,Text4,Text5: Ticket;\n\t\tvar Text2: Ticket;\n\n\t\trecv_2(A,P, Ra, Nb, B, Text2);\n\t\tsend_3(P,A, Text5, {t1,Ra,Kab,B,Text4}k(A,P),\n\t\t\t\t  {t2,Nb,Kab,A,Text3}k(B,P) );\n\t}\n}\n\nprotocol @keysymm26(A,B,P)\n{\n\trole A\n\t{\n\t\tvar TVPN: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar Text: Ticket;\n\t\tvar Tag: Ticket;\n\n\t\trecv_!1(B,A, { Tag,TVPN, Kab, B, Text }k(P,A) );\n\t\tsend_!2(A,B, { Tag,TVPN, Kab, B, Text }k(A,P) );\n\t}\n\trole B\n\t{\n\t}\n\trole P\n\t{\n\t}\n}"]], "SPDL-1/BCNP-1.spdl": [[true, "/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,R)\n{\n\trole I\n\t{\n\t\tfresh Kap: Nonce;\n\t\tvar Kbp: Nonce;\n\n\t\tsend_Compromise(I,I, Kap);\n\n\t\tsend_1(I,R, I, { Kap }pk(R) );\n\t\trecv_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(I,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar Kap: Nonce;\n\t\tfresh Kbp: Nonce;\n\n\t\tsend_Compromise(R,R, Kbp);\n\n\t\trecv_1(I,R, I, { Kap }pk(R) );\n\t\tsend_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(R,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\n}"]], "SPDL-1/isoiec-9798-2-3.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * two-pass\n * mutual\n *\n * Note: the identity inside the encryption may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n *\n */\nprotocol @keysymm-23(A,B)\n{\n\trole A\n\t{\n\t\tvar NA: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { NA, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { NA, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar NA: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { NA, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { NA, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-3(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tvar TNB: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\t\tvar Text3,Text4: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\trecv_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(A,Commit,B,TNB,Text3);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tfresh TNB: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\t\tfresh Text3,Text4: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\tclaim(B,Running,A,TNB,Text3);\n\t\tsend_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}"]], "SPDL-1/jfki-core.spdl": [[true, "# 1 \"jfki-core.cpp\"\n# 1 \"<command-line>\"\n# 1 \"jfki-core.cpp\"\n# 15 \"jfki-core.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 60 \"common.h\"\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i), Ni, Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r), Ni, Nr) );\n\n }\n\n\n}\n# 16 \"jfki-core.cpp\" 2\n\n\n\nprotocol jfki-core(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ni, I, g(i) );\n  recv_2( R, I, Nr, Ni, R, Gr, {Nr, Ni, Gr, g(i), I}sk(R) );\n  send_3( I, R, Nr, Ni, {Nr, Ni, Gr, g(i), R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i), Ni, Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ni, I, Gi );\n  send_2( R, I, Nr, Ni, R, g(r), {Nr, Ni, g(r), Gi, I}sk(R) );\n  recv_3( I, R, Nr, Ni, {Nr, Ni, g(r), Gi, R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,r), Ni, Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"]], "SPDL-1/kaochow-v3.spdl": [[true, "# Kao Chow Authentication v.3\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow3.html\n#\n\nusertype SessionKey;\nusertype ExpiredTimeStamp;\nusertype TimeStamp;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow-3(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir,kt}k(I,S), {ni, kir}kt, nr, T2 );\n        send_4 (I,R, {nr,kir}kt, T2 );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir,kt: SessionKey;\n        var T: Ticket;\n        fresh tr: TimeStamp;\n\n        recv_2 (S,R, T, { I,R,ni,kir,kt }k(R,S) ); \n        send_3 (R,I, T, {ni, kir}kt, nr, {I,R,tr,kir}k(R,S) );\n        recv_4 (I,R, {nr,kir}kt, {I,R,tr,kir}k(R,S) );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir, kt: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir,kt}k(I,S), { I,R,ni,kir,kt }k(R,S) ); \n    }\n}"]], "SPDL-1/kaochow.spdl": [[true, "# Kao Chow Authentication v.1\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow1.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir}k(I,S), {ni}kir, nr );\n        send_4 (I,R, {nr}kir );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir: SessionKey;\n        var T;\n\n        recv_2 (S,R, T, { I,R,ni,kir }k(R,S) ); \n        send_3 (R,I, T, {ni}kir, nr );\n        recv_4 (I,R, {nr}kir );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir}k(I,S), { I,R,ni,kir }k(R,S)  ); \n    }\n}"]], "SPDL-1/localclaims.spdl": [[true, "/* \n * Local claims\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol localclaims(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {ni}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {ni}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information"]], "SPDL-1/needham-schroeder.spdl": [[true, "# Needham Schroeder Public Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nspk.html\n#\n#\n# Note:\n# The modelling in SPORE includes a server to distribute the public keys\n# of the agents, this is not necessary and it allows for attacks against\n# synchronisation and agreement, because the keys that the server sends\n# out can be replayed.\n\nprotocol needhamschroederpk(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n\n        send_1(I,S,(I,R));\n        recv_2(S,I, {pk(R), R}sk(S));\n        send_3(I,R,{Ni,I}pk(R));\n        recv_6(R,I, {Ni, Nr}pk(I));\n        send_7(I,R, {Nr}pk(R));\n        claim_I1(I,Secret,Ni);\n        claim_I2(I,Secret,Nr);\n        claim_I3(I,Nisynch);\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        \n        recv_3(I,R,{Ni,I}pk(R));\n        send_4(R,S,(R,I));\n        recv_5(S,R,{pk(I),I}sk(S));\n        send_6(R,I,{Ni,Nr}pk(I));\n        recv_7(I,R,{Nr}pk(R));\n        claim_R1(R,Secret,Nr);\n        claim_R2(R,Secret,Ni);\n        claim_R3(R,Nisynch);\n    }\n\n    role S\n    {\n        recv_1(I,S,(I,R));\n        send_2(S,I,{pk(R),R}sk(S));\n        recv_4(R,S,(R,I));\n        send_5(S,R,{pk(I),I}sk(S));\n    }\n}"]], "SPDL-1/ns3-1.spdl": [[true, "/* \n * Needham-Schroeder protocol\n */\n\n// The protocol description\n\nprotocol ns3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {ni,I}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\t//claim_i3(I,Alive);\n\t\tclaim_i4(I,Niagree);\n\t\tclaim_i5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {ni,I}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\t//claim_r3(R,Alive);\n\t\tclaim_r4(R,Niagree);\n\t\tclaim_r5(R,Nisynch);\n\t}\n}"]], "SPDL-1/nsl3-broken.spdl": [[true, "/* \n * Needham-Schroeder-Lowe protocol,\n * broken version (wrong role name in first message)\n */\n\n// The protocol description\n\nprotocol nsl3-broken(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,I, {ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}"]], "SPDL-1/onetrace-1.spdl": [[true, "usertype String;\n\nconst Alice,Bob,Charlie: Agent;\nconst Hallo: String;\n\nprotocol onetrace(I)\n{\n\trole I\n\t{\n\t\tvar input: String;\n\n\t\trecv_!1(I,I, input);\n\t\tsend_!2(I,I, Hallo);\n\t\trecv_!3(I,I, input);\n\t\tclaim_4(I, Secret, input);\n\t}\n}"]], "SPDL-1/otwayrees.spdl": [[true, "# Otway Rees\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/otwayRees.html\n#\n\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nusertype String,SessionKey;\n\nprotocol otwayrees(I,R,S)\n{\n    role I\n    {\n        fresh Ni : Nonce;\n        fresh M : String;\n        var Kir : SessionKey;\n\n        send_1(I,R, M,I,R,{Ni,M,I,R}k(I,S) );\n        recv_4(R,I, M,{Ni,Kir}k(I,S) );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        var M : String;\n        fresh Nr : Nonce;\n        var Kir : SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, M,I,R, T1 );\n        send_2(R,S, M,I,R, T1, { Nr,M,I,R }k(R,S) );\n        recv_3(S,R, M, T2, { Nr,Kir }k(R,S) );\n        send_4(R,I, M, T2 );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni,Nr : Nonce;\n        var M : String;\n        fresh Kir : SessionKey;\n        \n        recv_2(R,S, M,I,R, { Ni,M,I,R}k(I,S), { Nr,M,I,R }k(R,S) );\n        send_3(S,R, M, { Ni,Kir }k(I,S) , { Nr,Kir }k(R,S) );\n    }\n}"]], "SPDL-1/BKE-1.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr) }kir );\n\t\tclaim_4 (I, Secret, kir );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: SessionKey;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr) }kir );\n\t\tclaim_7 (R, Secret, kir );\n\t\t//claim_8 (R, Niagree );\n\t\t//claim_9 (R, Nisynch );\n\t}\n}"]], "SPDL-1/pkmv2rsa.spdl": [[true, "/*\n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, bsrand, prepak, MS}pk(BS),BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, bsrand, prepak, MS}pk(BS),BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}"]], "SPDL-1/pkmv2satek.spdl": [[true, "/*\n * PKMv2-SA-TEK\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol pkmv2satek(MS,BS)\n{\n  role MS\n  {\n    fresh msrand': Nonce;\n    var bsrand', tek0, tek1: Nonce;\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand': Nonce;\n    fresh bsrand', tek0, tek1: Nonce;\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n  }\n}"]], "SPDL-1/protocol0.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}"]], "SPDL-1/protocol1.spdl": [[true, "/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I, R, {R, ni}pk(R) );\n\t\t\n\t\trecv_2(R, I, {ni, nr, R}pk(I) );\n\t\t\n\t\tsend_3(I, R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I, R, {R, ni}pk(R) );\n\t\t\n\t\tsend_2(R,I, {ni, nr, R}pk(I) );\n\t\t\n\t\trecv_3(I, R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}"]], "SPDL-1/rsaplussatek.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    send_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n//    claim_rsai5(MS,SKR,prepak);\n//    claim_rsai6(MS,SKR,tek0);\n//    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    recv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n//    claim_rsar5(BS,SKR,prepak);\n//    claim_rsar6(BS,SKR,tek0);\n//    claim_rsar7(BS,SKR,tek1);\n  }\n}"]], "SPDL-1/simplest-1.spdl": [[true, "secret k: Nonce;\n\nprotocol simplest(I)\n{\n\trole I\n\t{\n\t\tvar x: Nonce;\n\t\tfresh n: Nonce;\n\n\t\trecv_!1(I,I, x);\n\t\tsend_!2(I,I, n, {n, x}k );\n\t\tclaim_3(I, Secret, n);\n\t}\n}"]], "SPDL-1/smartright.spdl": [[true, "# SmartRight view-only\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/smartright_viewonly.html\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n# Note:\n# Scyther finds an attack because the value of VoR in the last message can\n# be replaced with an arbitrary value\n\nhashfunction hash;\nusertype SessionKey;\nusertype XorKey;\nconst Vor: XorKey;\n\nprotocol smartright(I,R)\n{\n    role I\n    {\n        fresh VoKey: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var VoRi: Nonce;\n\n        send_1(I,R, {VoKey,{CW}^VoR}k(I,R));\n        recv_2(R,I, VoRi);\n        send_3(I,R, VoR, {{VoRi}hash}VoKey);\n    }\n    \n    role R\n    {\n        var T: Ticket;\n        var VoR: XorKey;\n        var VoKey: SessionKey;\n        fresh VoRi: Nonce;\n\n        recv_1(I,R, {VoKey,T}k(I,R));\n        send_2(R,I, VoRi);\n        recv_3(I,R, VoR,{{VoRi}hash}VoKey);\n\n        claim_R1(R,Nisynch);\n    }\n}"]], "SPDL-1/speedtest-1.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ns3speedtest(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\t\tclaim_4(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\t\tclaim_5(R,Secret,ni);\n\t}\n}\n\n\n/* something like this will later on all be implied by 'untrusted Eve' */\n\n\n/* pre-defined 10 runs, limit using --max-runs parameters */\n\n\trun ns3speedtest.R(Alice,Bob);\n\trun ns3speedtest.R(Eve,Bob);\n\trun ns3speedtest.R(Bob,Alice);\n\trun ns3speedtest.R(Eve,Alice);\n\trun ns3speedtest.R(Bob,Bob);"]], "SPDL-1/splice-as-hc.spdl": [[true, "# Hwang and Chen Modified SPLICE/AS\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/spliceas2.html\n#\n\nusertype TimeStamp, LifeTime;\n\nconst inc,dec: Function;\ninversekeys (inc,dec);\n\nprotocol spliceAS-HC(I,R,S)\n{\n    role I\n    {\n        fresh N1,N2: Nonce;\n        fresh T: TimeStamp;\n        fresh L: LifeTime;\n\n        send_1(I,S, I, R, N1 );\n        recv_2(S,I, S, {S, I, N1, R, pk(R)}sk(S) );\n        send_3(I,R, I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        recv_6(R,I, R, I, {R, {N2}inc}pk(I) );\n\n        claim_7(I, Secret, N2);\n        claim_9(I, Niagree);\n        claim_10(I, Nisynch);\n    }\n\n    role S\n    {\n        var N1,N3: Nonce;\n\n        recv_1(I,S, I, R, N1 );\n        send_2(S,I, S, {S, I, N1, R, pk(R)}sk(S) );\n        recv_4(R,S, R, I, N3 );\n        send_5(S,R, S, {S, R, N3, I, pk(I)}sk(S) );\n    }\n\n    role R\n    {\n        fresh N3: Nonce;\n        var N2: Nonce;\n        var T: TimeStamp;\n        var L: LifeTime;\n\n        var ni: Nonce;\n        fresh nr: Nonce;\n\n        recv_3(I,R, I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        send_4(R,S, R, I, N3 );\n        recv_5(S,R, S, {S, R, N3, I, pk(I)}sk(S) );\n        send_6(R,I, R, I, {R, {N2}inc}pk(I) );\n\n        claim_8(R, Secret, N2);\n        claim_11(R, Niagree);\n        claim_12(R, Nisynch);\n    }\n}"]], "SPDL-1/SR3.spdl": [[true, "hashfunction H;\nusertype Key;\n\nprotocol sr3(V,S)\n{\n\n\trole V\n\t{\n\t\tfresh Nv: Nonce;\n\t\tfresh D:Ticket;\n\t\tsend_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\trecv_2(S,V,Nv,V);\n\t\t\n\t\tclaim_V1(V, Niagree);\n\t\tclaim_V2(V, Secret, D);\n\t\tclaim_V3(V, Secret, k(V,S));\n\t\tclaim_V4(V, Nisynch);\n\t\tclaim_V5(V, Secret, Nv);\n\t}\n\n\trole S\n\t{\n\t\tvar D:Ticket;\n\t\tvar Nv:Nonce;\n\t\trecv_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\tsend_2(S,V,Nv,V);\n\n\t\tclaim_S1(S, Niagree);\n\t\tclaim_S2(S, Secret, D);\n\t\tclaim_S3(S, Secret, k(V,S));\n\t\tclaim_S4(S, Nisynch);\n\t\tclaim_S5(S, Secret, Nv);\n\t}\n\n}"]], "SPDL-1/bkepk-ce-1.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (bkeCE)\n\n\tVersion from Corin/Etalle: An Improved Constraint-Based System for the Verification of Security Protocols.\n\tTried to stay as close as possible to compare timing results.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ nb,B }pk(A) );\n\t\tsend_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_A1 (A, Secret, na);\n\t\tclaim_A2 (A, Secret, nb);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,A, B,{ nb,B }pk(A) );\n\t\trecv_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\tsend_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, nb);\n\t}\n\n}\n\nconst Alice,Bob,Eve;"]], "SPDL-1/sts-mac.spdl": [[true, "# 1 \"sts-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-mac.cpp\"\n# 16 \"sts-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(Nr),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),Nr)) );\n\n }\n\n\n}\n# 17 \"sts-mac.cpp\" 2\n\n\n\n\n\n\n\nprotocol @executability(O) {\n\n\n role O {\n  var i, r: Nonce;\n\n\n  recv_!O1( O, O, MAC(h(g(i),r), g(r), g(i)) );\n  send_!O2( O, O, MAC(h(g(r),i), g(r), g(i)) );\n\n\n  recv_!O3( O, O, MAC(h(g(r),i), g(i), g(r)) );\n  send_!O4( O, O, MAC(h(g(i),r), g(i), g(r)) );\n\n }\n\n\n}\n\n\n\nprotocol sts-mac(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_!2( R, I, Gr, {Gr, g(i)}sk(R), MAC(h(Gr,i), Gr, g(i)) );\n  send_!3( I, R, {g(i), Gr}sk(I), MAC(h(Gr,i), g(i), Gr) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_!2( R, I, Gi, {g(r), Gi}sk(R), MAC(h(Gi,r), g(r), Gi) );\n  recv_!3( I, R, {Gi, g(r)}sk(I), MAC(h(Gi,r), Gi, g(r)) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"]], "SPDL-1/th-1seq2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni,ni2: Nonce;\n\t\tvar nr,nr2: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P1,nr}pk(R) );\n\n\t\t//claim_i(I,Nisynch);\n\n\t\tsend_21(I,R, {P2,I,ni2}pk(R) );\n\t\trecv_21b(R,I, {nr2}pk(I) );\n\t\trecv_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\tsend_23(I,R, {P2,nr2}pk(R) );\n\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni,ni2: Nonce;\n\t\tfresh nr,nr2: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P1,nr}pk(R) );\n\n\t\t//claim_r(R,Nisynch);\n\n\t\trecv_21(I,R, {P2,I,ni2}pk(R) );\n\t\tsend_21b(R,I, {nr2}pk(I) );\n\t\tsend_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\trecv_23(I,R, {P2,nr2}pk(R) );\n\n\t\tclaim_r2(R,Nisynch);\n\t}\n}"]], "SPDL-1/tmn-2.spdl": [[true, "usertype Key;\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys(pk,sk);\n\nprotocol tmn(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh Ka: Key;\n\t\tvar Kb: Key;\n\n\t\tsend_1(A,S, B,{Ka}pk(S) );\n\t\trecv_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_5(A,Secret,Ka);\n\t\tclaim_8(A,Secret,Kb);\n\t}\t\n\t\n\trole B\n\t{\n\t\tfresh Kb: Key;\n\n\t\trecv_2(S,B, A );\n\t\tsend_3(B,S, A, { Kb }pk(S) );\n\n\t\tclaim_6(B,Secret,Kb);\n\t}\n\n\trole S\n\t{\n\t\tvar Ka,Kb: Key;\n\n\t\trecv_1(A,S, B,{Ka}pk(S) );\n\t\tsend_2(S,B, A );\n\t\trecv_3(B,S, A, { Kb }pk(S) );\n\t\tsend_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_7(S,Secret,Ka);\n\t}\n}\n\nconst Alice,Bob,Eve,Simon: Agent;"]], "SPDL-1/unknown2.spdl": [[true, "usertype SessionKey;\nsecret k: Function;\n\nprotocol unknown2(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\t\tvar T;\n\n\t\tsend_1(I,R, ni );\n\t\trecv_3(S,I, { I,R,kir,ni,nr }k(I,S), T );\n\t\tsend_4(I,R, T, {nr}kir );\n\n\t\tclaim_i1(I,Nisynch);\n\t\tclaim_i2(I,Niagree);\n\t\tclaim_i3(I,Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tvar ni: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\trecv_1(I,R, ni );\n\t\tsend_2(R,S, { I,R,ni,nr }k(R,S) );\n\t\trecv_4(I,R, { I,R,kir,ni,nr }k(R,S), {nr}kir );\n\n\t\tclaim_r1(R,Nisynch);\n\t\tclaim_r2(R,Niagree);\n\t\tclaim_r3(R,Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tfresh kir: SessionKey;\n\t\tvar ni,nr: Nonce;\n\n\t\trecv_2(R,S, { I,R,ni,nr }k(R,S) );\n\t\tsend_3(S,I, { I,R,kir,ni,nr }k(I,S), { I,R,kir,ni,nr }k(R,S) );\n\n/*\n\t\tclaim_s1(S,Nisynch);\n\t\tclaim_s2(S,Niagree);\n\t\tclaim_s3(S,Secret, kir);\n\t\t*/\n\t}\n}\n\nconst kee: SessionKey;"]], "SPDL-1/void.spdl": [[true, "# By Louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol void-0(A, B, S) {\n    role A {\n        fresh t: Nonce;\n        fresh K: MySecret;\n       \n        send_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        recv_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n        send_5(A, B, {t, K}pk(B));\n        recv_6(B, A, {h(t, K)}pk(A));\n \n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var t: Nonce;\n \n        recv_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        send_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        recv_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        send_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n \n        claim(S, Weakagree);\n    }\n    role B {\n        var t: Nonce;\n        var K: MySecret;\n \n        recv_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        send_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        recv_5(A, B, {t, K}pk(B));\n        send_6(B, A, {h(t, K)}pk(A));\n \n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}"]], "SPDL-1/wmf.spdl": [[true, "# Wide Mouthed Frog\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wideMouthedFrog.html\n#\n# Note\n# The name of the party that has generated a message was added in order\n# to model the property described in SPORE that an agent can identify\n# its own messages and will reject them.\n\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol wmf(I,R,S)\n{\n    role I\n    {\n        fresh Kir: SessionKey;\n        fresh Ti: TimeStamp;\n        var Kr: SessionKey;\n\n        send_1(I,S, I, {I, Ti, R, Kir}k(I,S)); \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Ts: TimeStamp;\n        var Kir: SessionKey;\n\n        recv_2(S,R, {S, Ts, I, Kir}k(R,S) );\n\n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Kir: SessionKey;\n        fresh Ts: TimeStamp;\n        var Ti: TimeStamp;\n\n        recv_1(I,S, I,{I, Ti, R, Kir}k(I,S) );\n        send_2(S,R, {S, Ts, I, Kir}k(R,S));\n    }\n}"]], "SPDL-1/woo-lam.spdl": [[true, "# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var Kir: SessionKey;\n        var N2: Nonce;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, N2);\n        send_3(I,R, {I, R, N1, N2}k(I,S));\n        recv_6(R,I, {R, N1, N2, Kir}k(I,S), {N1,N2}Kir);\n        send_7(I,R, {N2}Kir);\n        \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var Kir: SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, N2);\n        recv_3(I,R, T1);\n        send_4(R,S, T1, {I, R, N1, N2}k(R,S));\n        recv_5(S,R, T2, {I, N1, N2, Kir}k(R,S));\n        send_6(R,I, T2, {N1,N2}Kir);\n        recv_7(I,R, {N2}Kir);\n        \n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var N1,N2: Nonce;\n\n        recv_4(R,S, {I, R, N1, N2}k(I,S), {I, R, N1, N2}k(R,S));\n        send_5(S,R, {R, N1, N2, Kir}k(I,S), {I, N1, N2, Kir}k(R,S));\n    }\n}"]], "SPDL-1/woolam-pi-f.spdl": [[true, "/*\n * Woo-lam version from Spore, Pi f\n *\n * Only one-way verification version\n */\n\nusertype Server, SessionKey, Ticket;\nsecret k: Function;\n\nconst Simon: Server;\n\nconst ke: SessionKey;\n\nprotocol woolampif(A,B,S)\n{\n\trole A\n\t{\n\t\tvar Na: Nonce;\n\n\t\tsend_1(A,B, A);\n\t\trecv_2(B,A, Na);\n\t\tsend_3(A,B, { A,B,Na }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar T: Ticket;\n\n\t\trecv_1(A,B, A);\n\t\tsend_2(B,A, Nb);\n\t\trecv_3(A,B, T);\n\t\tsend_4(B,S, { A,B,Nb, T }k(B,S) );\n\t\trecv_5(S,B, { A,B,Nb }k(B,S) );\n\n\t\tclaim_6(B,Niagree);\n\t\tclaim_7(B,Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar Ns: Nonce;\n\n\t\trecv_4(B,S, { A,B,Nb, { A,B,Nb }k(A,S) }k(B,S) );\n\t\tsend_5(S,B, { A,B,Nb }k(B,S) );\n\t}\n}"]], "SPDL-1/yahalom-ban-1.spdl": [[true, "# BAN simplified version of Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalomBAN.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol yahalom-BAN(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, Nr, {R,Kir,Ni}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        recv_4(I,R, {I,Kir,Nr}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        send_3(S,I, Nr, {R,Kir,Ni}k(I,S), {I,Kir,Nr}k(R,S) );\n    }\n}"]], "SPDL-1/yahalom.spdl": [[true, "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}"]]}