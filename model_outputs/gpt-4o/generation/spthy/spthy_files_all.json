{"SPTHY-1/9.spthy": [[true, "theory SecureCommunication\n\nbegin\n\n// Declare sorts\nsorts agent message key\n\n// Define functions\nfunctions\n    pk: agent -> key\n    sk: agent -> key\n    symK: agent * agent -> key\n    aenc: message * key -> message\n    adec: message * key -> message\n    senc: message * key -> message\n    sdec: message * key -> message\n    msg1_A: agent -> message\n    msg2_S: agent * message -> message\n    msg4_B: agent * message -> message\n\n// Declare free variables\nvariables\n    A, B, S: agent\n    M: message\n\n// Initial knowledge\n// Each participant has their own private key and knows public keys\nequations\n    adec(aenc(M, pk(A)), sk(A)) = M\n    sdec(senc(M, symK(A, B)), symK(A, B)) = M\n\n// Define rules for the protocol\n\n// Alice sends her identity and public key to the server\nrule Alice_to_Server:\n    [ Fr(~n1) ]\n    --[ msg1_A(A) ]->\n    [ Out(aenc(~n1, pk(S))) ]\n\n// Server receives Alice's message and updates state\nrule Server_to_Bob:\n    let\n        symKA_B = symK(A, B)\n    in\n    [ In(aenc(N_A, pk(S))) ]\n    --[ msg2_S(A, senc(symKA_B, pk(B))) ]->\n    [ Out(aenc(senc(symKA_B, N_A), pk(B))) ]\n\n// Bob receives message from server, decrypts and encrypts with Alice's pk\nrule Bob_to_Alice:\n    let\n        symKA_B = symK(A, B)\n    in\n    [ In(aenc(senc(symKA_B, N_A), pk(B))) ]\n    --[ msg4_B(B, aenc(M, pk(A))) ]->\n    [ Out(aenc(M, pk(A))) ]\n\n// Security Property: Secrecy of the symmetric key\nlemma secrecy_of_symmetric_key:\n    \"All A B #i. Secret(symK(A, B), symunion(msg1_A(A), msg2_S(A, B)), [A, B])\"\n\nend"]], "SPTHY-1/ake_KEAplus.spthy": [[true, "// KEA+ Protocol Specification in Tamarin's SPTHY Language\n\n// Functions\nfunctions: \n    h/1 // Cryptographic hash function\n    g/0 // Diffie-Hellman generator\n\n// Types\ntypes:\n    Initiator, Responder, Key, Message\n\n// Free variables\nfree:\n    skI: Initiator // Long-term secret key of the initiator\n    skR: Responder // Long-term secret key of the responder\n    pkI: Initiator // Long-term public key of the initiator\n    pkR: Responder // Long-term public key of the responder\n    ephemeralI: Initiator // Ephemeral key of the initiator\n    ephemeralR: Responder // Ephemeral key of the responder\n\n// Protocol roles and rules\n\n// Initiator Role\nrules:\n\n    // Long-term key generation\n    Init_KeyGen:\n    [ Fr(~skI) ]\n    --[ GenKey($userInitiator, skI) ]->\n    [ Out(pkI = g^skI) ]\n\n    // Initiation phase\n    Init_MsgSend:\n    [ Fr(~ephemeralI), In(pkR) ]\n    --[ SendMsg($userInitiator, g^ephemeralI, pkI, h(ephemeralI^skI), pkR) ]->\n    [ Out(Message1(g^ephemeralI, pkI, h(ephemeralI^skI), pkR)) ]\n\n// Responder Role\nrules:\n\n    // Long-term key generation\n    Resp_KeyGen:\n    [ Fr(~skR) ]\n    --[ GenKey($userResponder, skR) ]->\n    [ Out(pkR = g^skR) ]\n\n    // Response phase\n    Resp_MsgRecv:\n    [ In(Message1(ephemeralI, pkI, h(ephemeralI^skI), ~pkR)) ]\n    --[ ComputeSessionKey($userResponder, ephemeralI, skR) ]->\n    [ Out(Message2(g^ephemeralR, h(ephemeralR^skR), ephemeralI)) ]\n\n// Security Lemmas\nlemmas:\n\n    // Lemma that establishes key indistinguishability\n    KeyIndistinguishableFromRandomness:\n    \"All traces contain a point where both keys (initiator's and responder's session keys) are indistinguishable from random values.\"\n\n    // Observation for successful protocol execution\n    KeyExchangeSuccess:\n    \"(exists i, r. GenKey(i, skI) @i & GenKey(r, skR) @r &\n        SendMsg(i, _, _, _, _) @i & ComputeSessionKey(r, _, _) @r)\""]], "SPTHY-1/DH_Message_Deduction.spthy": [[true, "theory P_Msg\n\nbuiltins: dh\n\nfunctions: \n  g: -> dh_exp\n\nrules:\n\n  [Start]\n  forall i: Time, x: DhSecret, y: DhSecret\n  let gx = exp(g, x)\n  in\n    Fr(x)\n    Fr(y)\n    Out(gx, inv(y))\n\n  [Fin]\n  forall i: Time, j: Time, x: DhSecret\n  let gx = exp(g, x)\n  in\n    In(gx)\n    Out(\"Key exchange complete\")\n\nlemmas:\n  key_deducible:\n  \"forall i j. (Start @ i) & (Fin @ j) => exists x y. unique(x) & unique(y)\"\n\nend"]], "SPTHY-1/Example-R.spthy": [[true, "// Secure Client-Server Communication Protocol in Tamarin\n\nbuiltins: asymmetric-encryption, hashing\n\n/* Types */\ntype Ltk // Long-term Keys\ntype Pk  // Public Keys\ntype k   // Session Keys\n\n/* Functions */\nfunctions\n  pubkey: Ltk -> Pk // Function to derive Public Key from Long-term Key\n  enc:  (Msg, Pk) -> Ciphertext  // Asymmetric encryption\n  dec:  (Ciphertext, Ltk) -> Msg // Asymmetric decryption\n  hash: Msg -> Hash // Hashing function\n\n/* Initial Knowledge */\nknowledge\n  // Participants initially know the public keys of others\n  attacker: Pk \n\n/* Protocol Roles */\nrule Registration:\n  let\n    ltkA: Ltk, ltkB: Ltk\n    pkA: Pk := pubkey(ltkA)\n    pkB: Pk := pubkey(ltkB)\n  in\n    // Register public keys for client and server\n    [ Fr(ltkA), Fr(ltkB) ]\n    --[ !Registered(pkA), !Registered(pkB) ]-> \n    [ Out(pkA), Out(pkB) ]\n\nrule ClientInitiate:\n  let\n    ltkA: Ltk\n    pkB: Pk\n    k: k\n    msg: Msg\n    cipher: Ciphertext := enc(k, pkB)\n  in\n    // Client starts communication by encrypting session key\n    [ In(pkB), Fr(k), Fr(msg) ]\n    --[ !ClientSent(k, pkB, msg) ]-> \n    [ Out(cipher), Out(msg) ]\n\nrule ServerRespond:\n  let\n    ltkB: Ltk\n    cipher: Ciphertext\n    k: k := dec(cipher, ltkB)\n    msg: Msg\n    response: Msg := hash(msg)\n  in\n    // Server responds with hash of decrypted request\n    [ In(cipher), In(msg) ]\n    --[ !ServerReceived(k) ]-> \n    [ Out(response) ]\n\n/* Lemmas */\n/* Ensure session key secrecy */\nlemma SessionKeySecrecy:\n  \"All(ClientSent(k, pkB, msg), ServerReceived(k))\"\n    \n/* Ensure client authentication */\nlemma ClientAuthentication:\n  \"All(ClientSent(k, pkB, msg), !ServerReceived(k))\"\n\nlemma InjectiveAuthentication:\n  \"Unique(ClientSent(k, pkB, msg))\"\n\nlemma HonestSetup:\n  \"All(Registered(pkB), !Attacker(ltkB), !ClientSent(k, pkB, msg))\"\n\n/* Advanced security properties can be defined as needed */"]], "SPTHY-1/issue193.spthy": [[true, "// Protocol description in the Spthy language for Tamarin tool\n\n// Types\ntype key\ntype signature\ntype message\ntype nonce\n\n// Functions\nfunctions\n    pk: key -> key // Public Key\n    sk: ~key -> key // Secret Key\n    h: message * key * nonce * signature * key * key * message -> message // Hash function\n    revealingSigning: key * nonce * message -> signature // Revealing-Signing function\n    revealVerify: key * signature * message -> bool // Verify function\n\n// Rules\n\nrule Sign_Creation:\n    [Fr(~sk), Fr(~random)]\n    -->\n    [ Out(revealingSigning(pk(~sk), ~random, m)), \n      Out(Key(~sk))\n    ]\n\nrule Signature_Verification:\n    [ In(sig), In(Key(~sk)) ]\n    -->\n    [ (revealVerify(pk(~sk), sig, m) = true) ]\n\n// Lemmas\n\nlemma Exist_Trace:\n    exists-trace\n\n// Restrictions\n\nrestriction Equality:\n    All x #i. x = x @i"]], "SPTHY-1/final_protocol_and_property-6.spthy": [[true, "// Protocol3 Tamarin specification\n\n// Define built-in functions\nfunctions: \n    pk/1, sk/1, symenc/2, symdec/2, pubenc/2, pubdec/2\n\n// Define channels and roles\nchannels:\n    ch1, ch2\n\nnames:\n    A, B\n\n// Define state variables\nstate vars:\n    A_State_1, B_State_1\n\n// Declare agent identifiers\nagent:\n    Alice, Bob\n\n// Define adversary capabilities\nadversary:\n    DY\n\n// Key registration rules\nrule Register_pk:\n  [Fr(~ltk), Fr(~id)]\n  --[RegisterPK(~id, pk(~ltk))]\n  --> \n  Out(ch1, ~id, pk(~ltk))\n\nrule Get_pk:\n  [In(ch1, ~id, pk(~ltk))]\n  --> \n  Out(ch2, pk(~ltk))\n\n// Protocol rules\nrule A_1:\n  let pkB = pk(ltkB) in\n  [Fr(~symkey), Fr(~m), GeneratePk(ltkA), In(ch2, pkB)]\n  --> \n  Out(ch1, symenc(~symkey, <A, ~m>)), \n  State(Alice, A_State_1, ~symkey)\n\nrule B_1:\n  [In(ch1, symenc(~symkey, <A, ~m>)), GeneratePk(ltkB)]\n  --> \n  Out(ch1, <B, ~n>), \n  State(Bob, B_State_1, ~symkey)\n\nrule A_2:\n  let pkB = pk(ltkB) in\n  [In(ch1, <B, ~n>), In(ch2, pkB)]\n  --> \n  Out(ch1, pubenc(pkB, <~n, ~symkey>))\n\nrule B_2:\n  [In(ch1, pubenc(pk(ltkB), <~n, ~symkey>))]\n  --> \n  Fact(AuthOk(~n))\n\n// Lemma: Message Authentication\nlemma MessageAuth:\n  \"All n #i. Exists m #j. \n   Fact(AuthOk(n)) @ i => \n   Sent(A, m) @ j\"\n\n// Define the security property\nproperty:\n  Lemma MessageAuth ensures\n  if a message is authenticated, it must have been sent by the corresponding party"]], "SPTHY-1/Google2Step_EA.spthy": [[true, "// Tamarin model for Google 2-step Authentication Protocol\n\n// Type declarations\ntype Agent // Represents agents like Human User (H), Device (D), Service (S)\ntype Password // Represents password used for authentication\ntype Code // Represents the one-time code\ntype Channel // Represents communication channels\ntype State // Represents unique states of human agents\ntype Device // Represents the device used in authentication\n\n// Functions\nfunction UniqueState(Agent): State\nfunction UniqueDevice(Agent): Device\nfunction ValidPassword(Password, Agent): bool\nfunction ValidCode(Code, Device): bool\n\n// Facts\n// Initial assumption that each human agent is in a unique state\nfact InitialState(a: Agent, s: State)\nfact PasswordSetup(a: Agent, pass: Password)\nfact ReceiveCode(d: Device, code: Code)\nfact CorrectAuth(a: Agent, s: Service)\nfact IncorrectAuth(a: Agent, s: Service)\n\n// Rules\nrule SetupPassword:\n  [ InitialState(a) ]\n  --[ PasswordSetup(a, pass) ]->\n  [ PasswordSetup(a, pass) ]\n\nrule ReceiveOneTimeCode:\n  [ PasswordSetup(a, pass), UniqueDevice(a, d) ]\n  --[ ReceiveCode(d, code) ]->\n  [ ReceiveCode(d, code) ]\n\nrule CorrectAuthentication:\n  [ PasswordSetup(a, pass), ReceiveCode(d, code) ]\n  --[ ValidPassword(pass, a) && ValidCode(code, d) ]->\n  [ CorrectAuth(a, s) ]\n\nrule IncorrectAuthentication:\n  [ PasswordSetup(a, pass), ReceiveCode(d, code) ]\n  --[ !ValidPassword(pass, a) || !ValidCode(code, d) ]->\n  [ IncorrectAuth(a, s) ]\n\n// Lemmas\nlemma \"Functional Lemma\":\n  forall H1, H2, s1, s2.\n    PasswordSetup(H1, _) & PasswordSetup(H2, _) & InitialState(H1, s1) & InitialState(H2, s2) & (s1 != s2) => (H1 != H2)\n\nlemma \"Entity Authentication Lemma\":\n  forall a, s.\n    CorrectAuth(a, s) => (PasswordSetup(a, _) & ReceiveCode(_, _) & ValidPassword(_, a) & ValidCode(_, _))\n\nlemma \"Device Authentication Lemma\":\n  forall a, d.\n    CorrectAuth(a, _) => UniqueDevice(a, d)"]], "SPTHY-1/injectivity.spthy": [[true, "theory InjectivityTest\n\nbegin\n\nfunctions\n  inj : fact\n\nrules\n\n  rule Init:\n    [Fr(~i)]\n  --[ Init(~i) ]->\n    [inj(~i)]\n\n  rule Copy:\n    [inj(i)]\n  --[ Copy(i) ]->\n    [inj(i)]\n\n  rule Remove:\n    [inj(i)]\n  --[ Remove(i) ]->\n    []\n\nlemmas\n\n  injectivity_check:\n    \"not (Ex i. Init(i) @l1 & Remove(i) @l2 & Copy(i) @l3 & l1 < l2 & l2 < l3)\"\n\nend"]], "SPTHY-1/JCS12_Typing_Example.spthy": [[true, "// Participants\nfunctions: User, equal: Agent -> Agent\n// Long-term Keys\nfunctions: ~ltk: Agent -> Ltk\nfunctions: pk: Agent -> PubKey\n\n// Session Keys\nfunctions: k: Agent * Agent -> SKey\n\n// Message Tags\nfunctions: Msg, TypingTag: Message Tag\n\n// Actions for Input and Output\nfunctions: In, Out: Message -> Action\nfunctions: LtkReveal: Agent -> Action\nfunctions: Eq: Message * Message -> Action\n\n// Protocol Rules\n\n// Key Registration and Retrieval\nrule Register_pk:\n  [Fr(~ltk(A))]\n  --[Out(pk(A))]\n  // Register the public key associated with long-term key\n\nrule Get_pk:\n  [Out(pk(A))]\n  --[In(pk(A))]\n  // Retrieve the public key of a participant\n  \nrule Reveal_ltk:\n  [In(pk(A)), Fr(~ltk(A))]\n  --[LtkReveal(A)]\n  // Reveal the long-term key of a participant\n\n// Client Communication\nrule Client_1:\n  [Fr(k(C,S))]\n  --[Out(AEnc(Msg, pk(S))), In(AEnc(TypingTag, pk(C)))]\n  // Client initiates encrypted communication with the server\n\n// Server Response\nrule Serv_1:\n  [In(AEnc(Msg, pk(S))), Fr(k(S,C))]\n  --[Out(AEnc(TypingTag, pk(C)), Out(k(S,C)))]\n  // Server processes the request and responds with a session key\n\n// Security Assertions\n\n// Typing Assertion\nlemma TypingAssertion:\n  \"All m. (In(m) @ t) => ((LtkReveal(A) @ t') & (t' < t) | !Actor(m))\"\n\n// Session Key Secrecy\nlemma SessionKeySecrecy:\n  \"All k. (Out(k(S,C)) @ t) => ((LtkReveal(S) | LtkReveal(C)) @ t') & (t' < t)\"\n\n// Client Authentication\nlemma ClientAuthentication:\n  \"All k. (Out(k(C,S)) @ t) => ((Serv_1(C,S)) @ t' | LtkReveal(C) @ t') & (t' < t)\""]], "SPTHY-1/JKL_TS2_2008_KI_wPFS.spthy": [[true, "# Protocol: JKL-TS2-2008\n# Description: Authenticated key exchange protocol for two parties\n# Authors: Jeong, Katz, Lee\n\nfunctions:\n  g/0: pub\n  pk_I/1: priv -> pub\n  pk_R/1: priv -> pub\n  sk_I/3: priv * pub * priv -> sym\n  sk_R/3: priv * pub * priv -> sym\n\nequations:\n  forall a: priv, b: priv, c: priv.\n    sk_I(a, pk_R(b), c) = sk_R(b, pk_I(a), c)\n\ntypes:\n  Init\n  Resp\n\nchannels:\n  ChInit: init, pub\n  ChResp: resp, pub\n\nknowledge:\n  Initiator: Init\n  Responder: Resp\n\nrules:\n\n  rule Initiator_Sends_Message:\n    [ !InitUnique(?sid) ]\n  ==>\n    let a = genTuples(?sid) in\n    new ik: priv\n    snd(ChInit, <pk_I(ik), ?sid, a>)\n\n  rule Responder_Responds:\n    let b = genTuples(?sid) in\n    new rk: priv\n    recv(ChInit, <pk_I(ia), ?sid, a>)\n    snd(ChResp, <pk_R(rk), ?sid, b>)\n\n  rule Session_Key_Generation:\n    let s = \"session\" in\n    recv(ChResp, <pk_R(rb), ?sid, b>)\n    let sk1 = sk_I(ik, pk_R(rb), ik)\n    let sk2 = sk_R(rk, pk_I(ia), rk)\n    [ !SkI(?sid, sk1), !SkR(?sid, sk2), !SessionKey(?sid, s, sk1), !SessionKey(?sid, s, sk2) ]\n\nlemmas:\n\n  lemma Key_Agreement:\n    \"AllSID(!SessionKey(?sid, s, sk1)) /\\ AllSID(!SessionKey(?sid, s, sk2)) ==> sk1 = sk2\"\n\n  lemma Resistance_to_Key_Reveal_Attacks:\n    \"~(Existed(!SessionKey(?sid, s, sk1)) /\\ KeyReveal(ik, ?sid))\"\n\n  lemma Weak_Perfect_Forward_Secrecy:\n    \"~(Existed(!SessionKey(?sid, s, sk1)) /\\ KeyReveal(rk, ?sid))\"\n\n  lemma Key_Reveal_for_Initiator:\n    \"~(AllSID(!SkR(?sid, sk1)) /\\ KeyReveal(ik, ?sid))\"\n\n  lemma Key_Reveal_for_Responder:\n    \"~(AllSID(!SkI(?sid, sk2)) /\\ KeyReveal(rk, ?sid))\""]], "SPTHY-1/Joux.spthy": [[true, "type Key\ntype PublicKey\ntype LongTermKey\ntype Signature\ntype HashKey\ntype SessionKey\n\nconst pk_A: PublicKey\nconst pk_B: PublicKey\nconst pk_C: PublicKey\n\nconst ltk_A: LongTermKey\nconst ltk_B: LongTermKey\nconst ltk_C: LongTermKey\n\nconst sk_A: SessionKey\nconst sk_B: SessionKey\nconst sk_C: SessionKey\n\nconst hkA: HashKey\nconst hkB: HashKey\nconst hkC: HashKey\n\nrule Register_pk_A:\n  [ Fr(~ltkA) ]\n  --[ !pubKey(pk_A), Out(pk_A) ]-> \n  [ LtkTerm(ltk_A), LtkMapping(pk_A, ltk_A) ]\n\nrule Register_pk_B:\n  [ Fr(~ltkB) ]\n  --[ !pubKey(pk_B), Out(pk_B) ]-> \n  [ LtkTerm(ltk_B), LtkMapping(pk_B, ltk_B) ]\n\nrule Register_pk_C:\n  [ Fr(~ltkC) ]\n  --[ !pubKey(pk_C), Out(pk_C) ]-> \n  [ LtkTerm(ltk_C), LtkMapping(pk_C, ltk_C) ]\n\nrule Reveal_ltk_A:\n  [ LtkTerm(ltk_A) ]\n  --[ Out(ltk_A) ]-> \n  []\n\nrule Reveal_ltk_B:\n  [ LtkTerm(ltk_B) ]\n  --[ Out(ltk_B) ]-> \n  []\n\nrule Reveal_ltk_C:\n  [ LtkTerm(ltk_C) ]\n  --[ Out(ltk_C) ]-> \n  []\n\nrule Proto1_A:\n  [ LtkTerm(ltk_A), In(Identity_A, Identity_B, Identity_C) ]\n  --[ Out(hkA), Out(Signature(Identity_A, Identity_B, Identity_C)) ]->\n  []\n\nrule Proto2_B:\n  [ LtkTerm(ltk_B), In(hkA, Signature(Identity_A, Identity_B, Identity_C)) ]\n  --[ Out(hkB), Out(Signature(Identity_B, Identity_A, Identity_C)) ]->\n  [ SessionKey(sk_B) ]\n\nrule Proto2_C:\n  [ LtkTerm(ltk_C), In(hkA, hkB, Signature(Identity_A, Identity_B, Identity_C), Signature(Identity_B, Identity_A, Identity_C)) ]\n  --[ Out(hkC), Out(Signature(Identity_C, Identity_A, Identity_B)) ]->\n  [ SessionKey(sk_C) ]\n\nrule Compute_SessionKey_A:\n  [ SessionKeyTerm(sk_C), SessionKeyTerm(sk_B) ]\n  --[ Out(sk_A) ]->\n  [ SessionKey(sk_A) ]\n\nlemma session_key_establish:\n  \"All A,B,C. Exists sk_A, sk_B, sk_C. SessionKey_A(sk_A) & SessionKey_B(sk_B) & SessionKey_C(sk_C) & sk_A = sk_B & sk_B = sk_C\"\n\nlemma Session_Key_Secrecy_PFS:\n  \"All A,B,C. Not Revealed_Ensure_SessionKey(sk_A, sk_B, sk_C)\""]], "SPTHY-1/KAS1.spthy": [[true, "// Tamarin specification for the KAS1 protocol\n\n// Types\ntype Principal\ntype Nonce\ntype Key\n\n// Free variables\nconst I, R: Principal\nconst m1: Nonce\nconst longTermKey_I, longTermKey_R: Key\nconst ephemeralKey_I, sessionKey: Key\n\n// Functions\nfun Encrypt(key: Key, data: Nonce): msg\nfun Decrypt(key: Key, msg: msg): Nonce\nfun KDF(nonce: Nonce, key: Key): Key\nfun MAC(key: Key, msg: msg): mac\n\n// Protocol rules\n\nrule GenerateKeys_I:\n  [ Fr(~longTermKey_I) ]\n  --> \n  Out(longTermKeyPair_I(longTermKey_I, I))\n\nrule InitiatorSend:\n  [ In(longTermKeyPair_I(longTermKey_I, I)), Fr(~ephemeralKey_I), Fr(~m1) ]\n  -->\n  let c1 = Encrypt(longTermKey_R, m1) in\n  Out(Initiate(I, R, c1))\n\nrule ResponderReceiveAndRespond:\n  [ In(Initiate(I, R, c1)), In(longTermKeyPair_R(longTermKey_R, R)) ]\n  -->\n  let nonce = Decrypt(longTermKey_R, c1) in\n  let sessionKey = KDF(nonce, ephemeralKey_I) in\n  let mac = MAC(sessionKey, c1) in\n  Out(Response(R, I, nonce, mac))\n\nrule InitiatorVerify:\n  [ In(Response(R, I, nonce, mac)), In(longTermKeyPair_I(longTermKey_I, I)) ]\n  -->\n  let sessionKey = KDF(nonce, ephemeralKey_I) in\n  if mac = MAC(sessionKey, Encrypt(longTermKey_R, nonce)) then\n    Out(SessionEstablished(I, R, sessionKey))\n  else\n    Out(SessionFailed(I, R))\n\n// Security properties\n\nlemma key_secrecy:\n  \"All x #i. (SessionEstablished(I,R,x) @ i) => not(Exposes(longTermKey_I) or Exposes(longTermKey_R) or Exposes(ephemeralKey_I))\"\n\n// Reveal rules\nrule RevealLongTermKey_I:\n  [ In(longTermKeyPair_I(longTermKey_I, I)) ]\n  -->\n  Out(RevealKey(longTermKey_I))\n\nrule RevealEphemeralKey_I:\n  [ In(ephemeralKey_I) ]\n  -->\n  Out(RevealKey(ephemeralKey_I))\n\nrule RevealSessionKey:\n  [ In(SessionEstablished(I, R, sessionKey)) ]\n  -->\n  Out(RevealKey(sessionKey))"]], "SPTHY-1/ake_NAXOS.spthy": [[true, "theory NAXOS\n\nbegin\n\n  builtins: asymmetric, hashing\n\n  // Function Symbols\n  functions:\n    h1/1\n    h2/3\n\n  // Free Variables\n  free variables:\n    I, R : Agent\n    lkI, lkR, eskI, eskR, pkI, pkR : skey\n    exI, exR, kI, kR : message\n    g : message\n    sid : sid\n\n  // Rules\n\n  rule InitGenKeys:\n    [ Fr(lkI) ]\n  -->\n    [ LTK(I, lkI), PK(I, pkI) ]\n\n  rule RespGenKeys:\n    [ Fr(lkR) ]\n  -->\n    [ LTK(R, lkR), PK(R, pkR) ]\n\n  rule InitiatorStep:\n    [ LTK(I, lkI), PK(R, pkR) ]\n  -->\n    [ Out(<pkI, exI>) ]\n    where exI = h1(<lkI, eskI>)\n\n  rule ResponderStep:\n    [ In(<pkI, exI>), LTK(R, lkR) ]\n  -->\n    [ Out(exR) ]\n    where \n      exR = h1(<lkR, eskR>),\n      kR = h2(<exI, exR, pkR>)\n\n  rule KeyEstablishmentInitiator:\n    [ In(exR) ]\n  -->\n    [ Sout(kI) ]\n    where \n      kI = h2(<exI, exR, pkI>)\n\n  rule KeyEstablishmentResponder:\n    [ In(<pkI, exI>) ]\n  -->\n    [ Sout(kR) ]\n    where \n      kR = h2(<exI, exR, pkR>)\n\n  // Security Lemmas\n\n  lemma SessionKeyConsistency:\n    \"All i j #init #resp #secKeyInit #secKeyResp.\n      (KeyEstablishmentInitiator(i, pkR, exR, sid, kI) @ #init\n      & KeyEstablishmentResponder(j, pkI, exI, sid, kR) @ #resp\n      & i = j\n      & kI ~= kR\n      ==> Stmt)\"\n\n  lemma ForwardSecrecy:\n    \"All i j #init #resp #compromise.\n      (KeyEstablishmentInitiator(i, pkR, exR, sid, kI) @ #init\n      & Compromised(skA) @ #compromise\n      & skA = pkR\n      ==> Stmt)\"\n\nend"]], "SPTHY-1/KCL07.spthy": [[true, "theory KCL07\n\nbuiltins: functions: xor/2, h/2\n\n// Define roles with their knowledge\nfunctions: kcl07_R/1, kcl07_T/1\n\n// Messages, nonces, and challenge-responses\nfunctions: r1/0, r2/0, ID/0\n\n// Knowledge setup\nconsts: k: msg, ID_val: msg\n\n// Setup phase: Shared knowledge initialization\nrule setup:\n  [ Fr(~init) ]\n--[ InitR(~init), InitT(~init) ]-> \n  [ // Reader knows ID and k\n    R(~R1, kcl07_R(ID_val), kcl07_R(k))\n    // Tag knows ID and k\n    T(~T1, kcl07_T(ID_val), kcl07_T(k)) ] \n\n// Challenge phase: Reader sends nonce r1\nrule challenge_R:\n  [ R($Session, kcl07_R(ID_val), kcl07_R(k)) , Fr(~r1) ]\n--[ SentR($Session, ~r1 ) ]->\n  [ R($Session, kcl07_R(ID_val), kcl07_R(k)) ]\n\n// Response phase: Tag responds with r2 and xor\nrule response_T:\n  [ T($Session, kcl07_T(ID_val), kcl07_T(k)), Fr(~r2) , In($r1) ]\n--[ SentT($Session, ID_val xor ~r2, h($r1, k) xor ~r2) ]->\n  [ T($Session, kcl07_T(ID_val), kcl07_T(k)) ]\n\n// Check phase: Reader checks Tag's aliveness\nrule check_R:\n  [ R($Session, kcl07_R(ID_val), kcl07_R(k)), In(ID_val xor $r2, h($r1, k) xor $r2) ]\n--[ CheckedR($Session) ]->\n  [ R($Session, kcl07_R(ID_val), kcl07_R(k)) ]\n\n// Security properties\nlemma recent_aliveness:\n  \"All $Session $r1 $r2 #i #j. CheckedR($Session) @ #i ==> \n   (Ex #k. SentR($Session, $r1) @ #j &\n   SentT($Session, ID_val xor $r2, h($r1, k) xor $r2) @ #j)\"\n   \n// Unique restriction\nrestriction unique_challenge:\n  \"All $r1 #i #j. SentR($r1) @ #i & SentR($r1) @ #j ==> #i = #j\"\n\nend"]], "SPTHY-1/katz-yung.spthy": [[true, "// Protocol: Katz-Yung Key Exchange Protocol\n\n// Functions and equations\nfunctions: \n    g/0, exp/2, sign/3, verify/4, hash/1, pk/1, sk/1, pub/1\n\nequations: \n    exp(exp(g,x),y) = exp(exp(g,y),x)\n\n// Types\ntypes: \n    Agent, Ltk, Pk, Sk, DHValue, Nonce, Key\n\n// Free variables\nvariables: \n    C, S: Agent\n    x, y: DHValue\n    rC, rS: Nonce\n    skC, skS: Sk\n    pkC, pkS: Pk\n    k: Key\n\n// Protocol roles\nknowledge:\n    C: Ltk(C), pkS, rC, exp(g, y)\n    S: Ltk(S), pkC, rS, exp(g, x)\n\n// Role: Server (S)\nrule ServerInitiate:\n    [ Fr(rS), Fr(skS), Fr(x) ]\n--[ Send('Server', {C, exp(g,x), sign(Ltk(S), {exp(g,x), rC, rS})}) ]-> \n    Out({exp(g,x), sign(Ltk(S), {exp(g,x), rC, rS})})\n    // Server sends its DH value and signature\n\n// Role: Client (C)\nrule ClientInitiate:\n    [ Fr(rC), Fr(skC), Fr(y) ]\n--[ Send('Client', {S, rC}) ]-> \n    Out({rC})\n    // Client sends its nonce\n\nrule ClientResponse:\n    [ In({exp(g,x), sign(Ltk(S), {exp(g,x), rC, rS})}), Fr(y) ]\n--[ Verify(pkS, sign(Ltk(S), {exp(g,x), rC, rS}), {exp(g,x), rC, rS}),\n    Send('Client', {exp(g,y), sign(Ltk(C), {exp(g,y), rS, exp(g,x)})}) ]-> \n    Out({exp(g,y), sign(Ltk(C), {exp(g,y), rS, exp(g,x)})}),\n    Ltk(C), exp(g,x), exp(g,y)\n    // Client verifies the server's response and sends its DH value\n\n// Role: Server completes key establishment\nrule ServerComplete:\n    [ In({exp(g,y), sign(Ltk(C), {exp(g,y), rS, exp(g,x)})}) ]\n--[ Verify(pkC, sign(Ltk(C), {exp(g,y), rS, exp(g,x)}), {exp(g,y), rS, exp(g,x)}) ]-> \n    Ltk(S), exp(g,x), exp(g,y)\n    // Server verifies and establishes the session key\n\n// Lemmas\nlemma HonestTrace:\n    \"Exists Trace where Client and Server complete session without Ltk(C), Ltk(S) being revealed.\"\n\nlemma KeySecrecy:\n    \"For all k: Key, \n    not(Attacker(k)) unless Reveal(Ltk(C)) or Reveal(Ltk(S))\"\n\nlemma ServerLiveness:\n    \"For all S, C: Agent,\n    exists exp(g,x), exp(g,y), \n    if Server establishes session key,\n    then Server must have received exp(g,y) from Client.\"\n\nlemma ClientLiveness:\n    \"For all C, S: Agent,\n    exists exp(g,x), exp(g,y), \n    if Client establishes session key,\n    then Client must have received exp(g,x) from Server.\"\n\nlemma InjectiveAgreement:\n    \"For all k: Key, S, C: Agent,\n    if both Client and Server establish session keys,\n    then session keys for each session are unique to the (C, S) pair.\""]], "SPTHY-1/KEA_plus_KI_KCI.spthy": [[true, "// KEA+ Protocol Specification\n\n// Constants for agents and keys\nfunctions\n    a: agent\n    b: agent\n    ek: agent -> skey\n    lkA: agent -> skey\n    lkB: agent -> skey\n    epkI: agent -> pkey\n    epkR: agent -> pkey\n    pkA: agent -> pkey\n    pkB: agent -> pkey\n    key: agent -> agent -> message\n    enc: message -> message -> message // Encryption\n    hash: message -> message // Hash function\n\n// KEA+ Protocol rules\n\n// Rule 1: Key Generation\nrule generate_ltk:\n    [ Fr(~a), Fr(~lkA) ]\n    --> \n    [ PkA: epkI(a), LtkA: pkA(a), !LtkRegistered(a, pkA(a)) ]\n\n// Rule 2: Initiator Phase\nrule Init_1:\n    [ Fr(~ekI) ]\n    --[ SendStart ]-> \n    [ EInit: epkI(a), LtkA: pkA(a), Out(enc(epkI(a), pkA(a))) ]\n\n// Rule 3: Responder Phase\nrule Init_2:\n    [ In(enc(epkI(a), pkA(a))), Fr(~ekR) ]\n    --[ RecvStart, SendResp ]-> \n    [ EResp: epkR(b), LtkB: pkB(b), Out(enc(epkR(b), pkB(b))), SK: hash(epkI(a) * epkR(b)) ]\n\n// Rule 4: Response from Initiator\nrule Resp_1:\n    [ In(enc(epkR(b), pkB(b))) ]\n    --[ RecvResp ]-> \n    [ SK: hash(epkI(a) * epkR(b)), Out(enc(SK, pkA(a))) ]\n\n// Reveal Rules\nrule reveal_SessionKey:\n    [ Reveal(SessionKey) ]\n    --> \n    [ !RevealKey ]\n\nrule reveal_LongTermKey:\n    [ Reveal(LongTermKey) ]\n    --> \n    [ !RevealKey, !CompromiseImpersonation ]\n\n// Security Properties\n\n// Lemma: Key Independence (KI)\nlemma KI:\n    \"All(ShowSK(a, b)) implies (Exists(SKclean) and Not(Exposed(SKclean)))\"\n\n// Lemma: Key Compromise Impersonation (KCI)\nlemma KCI:\n    \"All(SecureSession(a, b)) implies Not(Exists(ImpersonatedSession(b)))\"\n\nend"]], "SPTHY-1/Keyserver.spthy": [[true, "type agent\ntype user\ntype server\ntype key\ntype status\ntype msg\n\nconst a, b, c, i, s: agent\nconst valid, revoked: status\nconst pk(n), npk(n): key [data]\nconst sign(m, k): msg\nconst inv(k): key\nconst pair(m1, m2): msg\n\nknowledge\n  agent_knowledge: agent -> msg -> prop\n  honest_knowledge: agent -> key -> prop\n\nfacts\n  iknows: msg -> fact\n  knows_key_status: agent * key * status -> fact\n  database_update: server * key * status -> fact\n  attack: fact\n\nrules\n\n  // Knowledge Initialization Rule\n  rule Init_Agent_Knowledge:\n    [Fr(~m)]\n    -->\n    !iknows(pair(a, ~m))\n    !iknows(pair(b, ~m))\n    !iknows(pair(c, ~m))\n    !iknows(pair(i, ~m))\n    !iknows(pair(s, ~m))\n\n  // Signing Knowledge Rule\n  rule Acquires_Sign_Knowledge:\n    [iknows(sign(m, k))]\n    -->\n    !iknows(m)\n\n  // Pairing Knowledge Rule\n  rule Acquires_Pair_Knowledge:\n    [iknows(pair(m1, m2))]\n    -->\n    !iknows(m1)\n    !iknows(m2)\n\n  // Key Registration Rule\n  rule Key_Registration:\n    // Honest agent registers key\n    [Fr(~pk), Fr(~sts), !iknows(pair(pk(~pk), sign(pk(~pk), inv(pk(~pk)))))]\n    -->\n    knows_key_status(s, ~pk, valid)\n    database_update(s, ~pk, valid)\n\n  // Key Renewal (Honest)\n  rule Honest_Key_Renewal:\n    // Honest agent renews key and server acknowledges\n    [iknows(pair(npk(~npk), pair(pk(~pk), sign(pk(~pk), inv(pk(~pk)))))), know_key_status(s, ~pk, valid)]\n    -->\n    knows_key_status(s, ~npk, valid)\n    knows_key_status(s, ~pk, revoked)\n    database_update(s, ~npk, valid)\n    database_update(s, ~pk, revoked)\n\n  // Key Renewal (Dishonest)\n  rule Dishonest_Key_Renewal_Attempt:\n    // Dishonest agents attempt to register key\n    [iknows(pair(npk(~npk), pair(pk(~pk), sign(pk(~pk), inv(pk(~pk))))))]\n    -->\n    knows_key_status(s, ~npk, valid)\n    attack\n\n  // Server Key Setup\n  rule Server_Key_Setup:\n    [Fr(~pk), Fr(~sts)]\n    -->\n    database_update(s, ~pk, valid)\n\n  // Client Key Leak Rule\n  rule Client_Key_Leak:\n    [iknows(pair(npk(~npk), pair(pk(~pk), sign(pk(~pk), inv(pk(~pk))))))]\n    -->\n    knows_key_status(s, ~npk, valid)\n    database_update(s, ~npk, valid)\n    database_update(s, ~pk, revoked)\n    attack\n\nlemmas\n  Knows_Honest_Key_imp_Revoked: \"All a key. (honest_knowledge(a, key) => eventually knows_key_status(s, key, revoked))\"\n  Honest_Revoked_Known_Reachable: \"Exists trace. (eventually knows_key_status(a, key, revoked))\""]], "SPTHY-1/Minimal_HashChain.spthy": [[true, "// Minimal HashChain Protocol in Tamarin\n\nfunctions\n    f/1: Function // Hash function used for key generation\n\ntypes\n    Key: opaque // Type for keys\n\nrules\n\n// Key Generation Rules\n\n// Gen_Start: Generates the initial key from a seed\nrule Gen_Start:\n    [Fr(seed)]\n    -->\n    [Out(k:=f(seed))]\n\n// Gen_Step: Generates a new key from the previous key using the hash function f\nrule Gen_Step:\n    [In(k1), Fr(x)]\n    -->\n    [Out(k2:=f(k1)), Out(k1)]\n\n// Gen_Stop: Represents the termination of new key generation\nrule Gen_Stop:\n    [In(final_key)]\n    -->\n    []\n\n// Key Verification Rules\n\n// Check0: Initiates the key verification process\nrule Check0:\n    [In(orig_key), Fr(r)]\n    -->\n    [Out(check_start(orig_key))]\n\n// Check: Iterates through the hash chain to verify the original key\nrule Check:\n    [In(check_start(orig_key)), In(k_next)]\n    -->\n    [Out(check_step(orig_key, k_next))]\n\n// Success: Successfully verifies the original key against the final key\nrule Success:\n    [In(check_step(orig_key, final_key))]\n    -->\n    [Out(success(orig_key))]\n\n// Lemmas\nlemma Loop_Start:\n    \"All e. Gen_Start(@e) => Exists k. Check0(k)\"\n\nlemma Loop_Success_ord:\n    \"All orig_key. Check(orig_key) => Exists final_key. Success(orig_key, final_key)\"\n\nlemma Loop_charn:\n    \"All loop key. Exists start_key. Check(loop, start_key)\"\n\nlemma Helper_Loop_and_success:\n    \"All loop key. Exists k. Loop_Success_ord(loop, k)\"\n\nlemma Loop_and_success:\n    \"All k. Exists loop. Helper_Loop_and_success(loop, k)\"\n\nlemma Success_charn:\n    \"All key succ. Exists final_key. Success_charn(succ, final_key)\""]], "SPTHY-1/mls-04a.spthy": [[true, "// MLS04 Protocol in Tamarin with SPTHY Language\n\nfunctions: \n    mac/2, sign/2, hash/1, encrypt/2\n\n// Types\nbuiltins:\n    asymmetric-encryption, hashing, signature\n\n// Facts\nfacts:\n    ClientInit, ClientFinish, ServerInit, ServerFinish,\n    RegisterPK, RevealLTK\n\n// Rules\nrules:\n\n// Register Rule: Entities register their long-term keys and public keys\nrule RegisterPK:\n  [ ]\n==>\n  [ RegisterPK($U, PK($U)) ]\n\n// Reveal Long-Term Key Rule\nrule RevealLTK:\n  [ RevealLTK($U) ]\n==>\n  [ ]\n\n// Client Initialization\nrule ClientInit:\nlet\n  uik = sign(SK($C), (id_C, PK($C)))\nin\n  [ Fr(gx), RegisterPK($C, PK($C)) ]\n==>\n  [ Out(<uik, gx>) ]\n\n// Client Finishing\nrule ClientFinish:\n  [ In(<welcome, add_request_mac>), RevealLTK($C) ]\n==>\n  [ ClientFinish($C), In(add_request(mac(add_request, SK($C)))) ]\n\n// Server Initialization\nrule ServerInit:\n  [ In(<uik, gx>), RegisterPK($S, PK($S)) ]\n==>\n  [ ServerInit($S), Out(<welcome, mac(add_request, SK($S))>) ]\n\n// Security Properties\n\n// Honest Server Trace\nlemma HonestServerTrace:\n  \u2200 $S #i. \n  ServerFinish($S)@i \u21d2 \u00acRevealLTK($S)@i\n\n// Honest Trace\nlemma HonestTrace:\n  \u2200 $C #i. \n  ClientFinish($C)@i \u21d2 \u00acRevealLTK($C)@i\n\n// Key Secrecy\nlemma KeySecrecy:\n  \u2200 k #i #j. \n  ClientFinish(k)@i \u2227 ServerFinish(k)@j \u21d2 \u00acRevealLTK(k)@i\n\n// Server Liveness\nlemma ServerLiveness:\n  \u2200 $C $S #i #j. \n  ClientFinish($C)@i \u21d2 (ServerInit($S)@j \u2228 RevealLTK($S)@i)\n\n// Client Liveness\nlemma ClientLiveness:\n  \u2200 $C $S #i #j. \n  ServerFinish($S)@i \u21d2 ClientInit($C)@j\n\n// Injective Agreement\nlemma InjectiveAgreement:\n  \u2200 k $C $S #i #j. \n  ClientFinish(k)@i \u21d2 ServerFinish(k, $C, $S)@j"]], "SPTHY-1/MPAuth_MA_NoTellOK.spthy": [[true, "// Protocol Description: MP-Auth_MA\n// Source: \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n// Built-in Functions\nbuiltins: signing, aenc, hash, senc\n\n// Protocol Functions\nfunctions:\n    f/1\n    m/1\n\n// Free Variables\nfree:\n    Human, Device, Server: Agent\n    Key: CryptoKey\n    Msg: Message\n\n// Actor Definitions\nknowledge:\n    // Each actor initializes with certain knowledge\n    Human: [AuthStart]\n    Device: [DeviceKey]\n    Server: [ServerKey]\n\nfragments:\n\n// Initial State Setup\nrules:\n    // Setup by a human agent involves password and initial state setup\n    rule HumanSetup:\n        [ !Init(Human) ]\n        --[ HumanSetup(Human) ]->\n        [ Init(Human), HumanState(Human) ]\n\n    // Device setup for communication and processing messages\n    rule DeviceSetup:\n        [ !Init(Device) ]\n        --[ DeviceSetup(Device) ]->\n        [ Init(Device), DeviceComm(Device) ]\n\n    // Server setup for key distribution and authentication\n    rule ServerSetup:\n        [ !Init(Server) ]\n        --[ ServerSetup(Server) ]->\n        [ Init(Server), ServerState(Server) ]\n\n// Communication Rules\n    // Human-to-Device message sending via insecure channel\n    rule HumanToDevice:\n        [ HumanState(Human), DeviceKey(Device) ]\n        --[ SendInsecure(Human, Device, Msg) ]->\n        [ m(f(Msg)), HumanState(Human), DeviceComm(Device) ]\n\n    // Device response to Human via secure channel\n    rule DeviceToHuman:\n        [ DeviceComm(Device), HumanState(Human) ]\n        --[ SendSecure(Device, Human, Msg) ]->\n        [ senc(m(f(Msg)), Key), DeviceComm(Device), HumanState(Human) ]\n\n    // Device-to-Server communication over secure channel\n    rule DeviceToServer:\n        [ DeviceComm(Device), ServerState(Server) ]\n        --[ SendSecure(Device, Server, Msg) ]->\n        [ senc(m(f(Msg)), Key), DeviceComm(Device), ServerState(Server) ]\n\n// Axioms and Assumptions\n    // Assumption that humans cannot share devices\n    clause HumanDeviceExclusion:\n        !SharedDevice(Human1, Human2, Device)\n        -[ SharedDevice(Human1, Human2, Device) ]-> false\n\n    // Assumption distinct roles are exclusive\n    clause RoleExclusivity:\n        !Role(Human, Device, Role)\n        -[ Role(Human, Device, Role) ]-> false\n\n// Lemmas\nlemmas:\n    // Ensure two humans have distinct initial states\n    lemma DistinctInitialState:\n        forall Human1, Human2.\n            Init(Human1) & Init(Human2) & Human1 != Human2\n            ==> DistinctStates(Human1, Human2)"]], "SPTHY-1/NAXOS_eCK.spthy": [[true, "// NAXOS Protocol Specification in Tamarin Tool\n\n// Define constants and functions\nfunctions: \n    h1/1, h2/1, \n    g/0, \n    exp/2, \n    KeyDerivation/2\n\n/* Roles: Alice (initiator) and Bob (responder) */\n\n// Define Alice's role, where she generates the ephemeral key, computes X, and sends it\nrule Alice_1:\n    [\n        Fr(~ex), Fr(~ea)\n    ]\n    --[ \n        SendInitA(~ex) \n    ]->\n    [\n        Out(<exp(g, h1(<~ex, ~ea>)), pkA>)\n    ]\n\n// Define Bob's role where he generates the ephemeral key, computes Y, and sends it\nrule Bob_1:\n    [\n        Fr(~ey), Fr(~eb), \n        In(<X, pkA>)\n    ]\n    --[ \n        SendResponseB(X, ~ey)\n    ]->\n    [\n        Out(<exp(g, h1(<~ey, ~eb>)), pkB>)\n    ]\n\n// Define session key derivation for Alice\nrule Alice_2:\n    [\n        In(<Y, pkB>)\n    ]\n    --[\n        KeyDerivation_A(Y)\n    ]->\n    [\n        SKeyA = KeyDerivation(~ex, pkB),\n        Out(SKeyA)\n    ]\n\n// Define session key derivation for Bob\nrule Bob_2:\n    [\n        In(<X, pkA>)\n    ]\n    --[\n        KeyDerivation_B(X)\n    ]->\n    [\n        SKeyB = KeyDerivation(~ey, pkA),\n        Out(SKeyB)\n    ]\n\n// Lemmas\nlemmas:\n// Lemma: eCK Same Key Lemma \n// Ensures that the same session key is derived by both parties in matching sessions\n    eCK_SameKey: \n    \"All session keys generated by agents in matching sessions must be equal. \n    (SKeyA = SKeyB)\"\n\n// Lemma: eCK Key Secrecy Lemma \n// Ensures that if a session key is known by the adversary, the session must be compromised\n    eCK_KeySecrecy:\n    \"If there exists a test session key that is revealed to the adversary, \n    then the session must be unclean. \n    (Exposed(SKeyA) => Unclean)\""]], "SPTHY-1/NSLPK3.spthy": [[true, "theory NSLPK3\n\nbegin\n\n// Define free variables\nfree I R : Agent\nfree ni nr : Nonce\nfree ltkI ltkR : Ltk\nfree pkI pkR : Pk\n\n// Define public these terms\npublic_terms\n  pkI, pkR\n\n// Initial knowledge for the adversary\nbuiltins: (symmetric-encryption, public-key-encryption)\n\n// Protocol Rules\nrule InitToResp:\n  [ Fr(ni),\n    !Ltk(I, pkI, ltkI),\n    !Ltk(R, pkR, ltkR),\n    Out(enc(<ni, I>, pkR))\n  ]\n  --[InitToResp(I,R,ni)]->\n  [ In(enc(<ni, I>, pkR)) ]\n\nrule RespToInit:\n  [ In(enc(<ni, I>, pkR)),\n    Fr(nr),\n    !Ltk(R, pkR, ltkR),\n    !Ltk(I, pkI, ltkI)\n  ]\n  --[RespToInit(I,R,ni,nr)]->\n  [ Out(enc(<nr, ni, R>, pkI)) ]\n\nrule InitToRespConfirm:\n  [ In(enc(<nr, ni, R>, pkI)),\n    !Ltk(I, pkI, ltkI),\n    !Ltk(R, pkR, ltkR)\n  ]\n  --[InitToRespConfirm(I,R,ni,nr)]->\n  [ Out(enc(<nr>, pkR)) ]\n\n// Lemmas for Security Goals\n\n// Nonce Secrecy\nlemma Nonce_Secret_I:\n  \"All I R ni #i. InitToResp(I,R,ni) @i ==> not(Knowledge(ni) @i)\"\n\nlemma Nonce_Secret_R:\n  \"All I R nr ni #i. RespToInit(I,R,ni,nr) @i ==> not(Knowledge(nr) @i)\"\n\n// Injective Agreement\nlemma Injective_Agreement:\n  \"All I R ni nr #i #j.\n     (InitToResp(I, R, ni) @i) & (RespToInit(I, R, ni, nr) @j)\n     ==> (Exists #k. (InitToRespConfirm(I, R, ni, nr) @k) & (#j < #k))\"\n\nend"]], "SPTHY-1/OTPoverSMS_EA.spthy": [[true, "theory OTP_over_SMS\n\nbegin\n\n  // Define sorts for the various agents and types within the protocol\n  sorts\n    human_agent, device, server, otp, message, ch_key\n\n  // Free variables representing the entities in the protocol\n  free\n    H, H': human_agent // Human agents\n    D, D': device      // Devices\n    S:    server       // Server\n    OTP:  otp          // One-time password\n    \n  // Public-private key pairs for communication\n  functions\n    // Encrypt/decrypt for channels\n    enc: (message, ch_key) -> message \n    dec: (message, ch_key) -> message\n    pubkey, privkey: human_agent -> ch_key\n    \n    // Messages related to OTPs\n    generate_otp: server -> otp\n    verify_otp: (otp, otp) -> bool\n\n  // Describes the generation and verification of OTPs\n  equations\n    dec(enc(m, k), k) = m // Message decryption\n    verify_otp(x, x) = true\n    verify_otp(x, y) = false if x != y\n\n  // Protocol rules \n  rules\n\n    // OTP Generation by the server\n    // Server generates OTP and sends it to the device\n    OTP_Generation:\n      [ Fr(otp) ]\n      --[ GenerateOTP(S, OTP) ]->\n      [ Out(enc(OTP, pubkey(D))) ]\n\n    // OTP Reception and Forwarding by the human through device\n    // Device receives OTP, human agent verifies and sends to the server for authentication\n    Human_Receives_And_Sends_OTP:\n      [ In(enc(OTP, pubkey(D))) ]\n      --[ HumanVerifyAndSendOTP(H, OTP) ]->\n      [ Out(enc(OTP, pubkey(S))) ]\n\n    // OTP Verification by the server\n    // Server receives OTP and verifies it\n    Server_Verifies_OTP:\n      [ In(enc(OTP, pubkey(S))) ]\n      --[ VerifyOTP(S, OTP) ]->\n      [ VERIFIED(OTP) ]\n\n  // Lemmas for security properties\n  lemmas\n\n    // The unique setup phase for each agent\n    Unique_Setup:\n      \"All x y #i #j. GenerateOTP(x, y) @i & GenerateOTP(x, y) @j ==> i = j\"\n\n    // Authentication lemma\n    Entity_Authentication:\n      \"All H D #i. Ex #j. \n        HumanVerifyAndSendOTP(H, ?) @i ==> \n        (VerifyOTP(S, OTP) @j & VERIFIED(OTP))\"\n\n    // Device authentication lemma\n    Device_Authentication:\n      \"All D S #i. Ex #j.\n       (HumanVerifyAndSendOTP(?) @i ==> \n       (VerifyOTP(S, OTP) @j & VERIFIED(OTP)))=====> (S = server(D))\"\n\nend"]], "SPTHY-1/alethea_sel_SmHh.spthy": [[true, "theory alethea_selection_phase\n\nbegin\n\n// Set up cryptographic primitives\nbuiltins: asymmetric-encryption, signing, hashing, symmetric-encryption, multiset\n\n// Define free variables\nfree: V D S A E r, skS, pkS, skD, pkD, n, m, eid, mid, pseud, serverNonce, deviceNonce, finalSelection\n\n// Protocol Rules\n\nrule Setup:\n  let\n    pkS = pub(skS),\n    pkD = pub(skD)\n  in\n    [Fr(~serverNonce), Fr(~deviceNonce)]\n  -->\n    [!Server(S, pkS), !Device(D, pkD),\n     Out(<S, 'setup', pkS, pkD>)]\n\nrule GeneratePseudonym:\n  [!Server(S, pkS), !Device(D, pkD), Fr(~r), Fr(~pseud)]\n  -->\n  [Out(<D, 'pseudonym', pseud>)]\n\nrule PublishPseudonym:\n  [!Server(S, pkS), !Device(D, pkD), In(<D, pseud>)]\n  -->\n  [!PublishedPseudonym(D, pseud), Out(<S, 'publish', pseud>)]\n\nrule SelectVoter:\n  [!PublishedPseudonym(D, pseud), Fr(~finalSelection), !Server(S, pkS)]\n  -->\n  [Out(<S, 'selected', finalSelection>)]\n\nrule VoterVerification:\n  [In(<D, 'verifySelection', finalSelection>)]\n  -->\n  [Out(<A, 'verificationResult', finalSelection>)]\n\n// Lemmas\n\nlemma functional:\n  \"All D S pseud #i #j. (Inputs(i, <D, pseud>) & Inputs(j, <D, pseud>)) ==> i = j\"\n\nlemma indivVerif_ps:\n  \"All D pseud #i. (PublishedPseudonym(D, pseud) @ i ==> Ex #j. Inputs(j, <D, pseud>))\"\n\nlemma indivVerif_sel:\n  \"All D finalSelection #i. (Selected(D, finalSelection) @ i ==> Ex #j. Outputs(j, <D, 'verifySelection', finalSelection>))\"\n\nlemma univVerif_sel:\n  \"All finalSelection. (Exists #i. Outputs(i, <A, 'verificationResult', finalSelection>))\"\n\nlemma oneSetup:\n  \"All S pkS pkD #i #j. (Server(S, pkS) @ i & Server(S, pkD) @ j) ==> i = j\"\n\nend"]], "SPTHY-1/Pattern_matching_and_destructors.spthy": [[true, "// Protocol: Demonstration of Pattern Matching Using Destructor Functions\n\n// Built-in Functions\nbuiltins: symmetric-encryption, hashing\n\n// Custom Functions\nfunctions: \n  isPair/1, \n  true/0, \n  encSucc/2, \n  and/2\n\n// Equations\nequations:\n  isPair(pair(x, y)) = true\n  encSucc(senc(x,y), y) = true\n  and(true, true) = true\n\n// Protocol Rules\n\nrule Setup_Key:\n  [ Fr(k) ]\n  -->\n  [ !ValidKey(k) ]\n\nrule Reveal_Key:\n  [ !ValidKey(k) ]\n  -->\n  [ Out(k) ]\n\nrule Initiator:\n  [ Fr(secret), Fr(publicValue) ]\n  -->\n  [ Out(senc(pair(secret, publicValue), k)), Out(publicValue) ]\n\nrule Responder:\n  [ In(encryptedMsg) ]\n  let \n    pairMsg = pair(secretPart, publicPart)\n  in\n  if encSucc(encryptedMsg, k) = true && isPair(pairMsg) = true then\n  [ Out(publicPart) ]\n\n// Restrictions\nrestriction TrueIntegrity:\n  forall x. x = true => x = @true\n\n// Lemmas\n\nlemma Type_Assertion:\n  \"forall m. Received(m) => (Ex(k). Knows(k) & Origin(k, m)) | Origin(Alice, m)\"\n\nlemma Responder_Secrecy:\n  \"forall secret. ReceivedSecret(secret) => !(Out(secret))\"\n\nlemma Public_Part_Accessibility:\n  \"forall public. Out(public) => Knows(public)\""]], "SPTHY-1/PR1_ShHm.spthy": [[true, "--- Protocol PR_1 in Tamarin's spthy language\n\ntypes\n  Agent, Ballot, BS, VS, PublicKey, PrivateKey, Message\n\nfunctions\n  pk: PrivateKey -> PublicKey\n  encrypt: Ballot * PublicKey -> Message\n  sign: Message * PrivateKey -> Message\n  verifySign: Message * PublicKey -> Bool\n\nrules\n\n  // Setup Phase: Voter generates keys\n  rule Setup:\n    fresh v_priv : PrivateKey\n    fresh id : Agent\n    let v_pub = pk(v_priv)\n    in\n    // Output voter's public key\n    Out(voter_pubkey(id, v_pub))\n\n  // Voting Phase: Voter sends ballot to P, P forwards to S\n  rule Vote:\n    let ballot = any(Ballot)\n    fresh nonce : Message\n    [ \n      // Voter's private and public keys are known\n      In(voter_key(priv_key, pub_key))\n    ]\n    --[\n      // Process of sending encrypted ballot\n      // Voter encrypts ballot with server's public key\n      let encrypted_ballot = encrypt(ballot, pub_key)\n    ]-->\n    Out(toP(sign(encrypted_ballot, priv_key), nonce))\n\n  // Forwarding by P to S\n  rule Forward_P_to_S:\n    let signed_msg = any(Message)\n    fresh nonce_p : Message\n    [\n      In(toP(signed_msg, nonce))\n    ]-->\n    Out(toS(signed_msg, nonce_p))\n\n  // Server Processing Phase: S verifies and responds\n  rule Server_Verify_and_Respond:\n    let signed_msg = any(Message)\n    fresh bs : BS\n    fresh vs : VS\n    [\n      In(toS(signed_msg, nonce_p))\n    ]\n    --[\n      // Server verifies signature\n      verifySign(signed_msg, pub_key) = true\n    ]-->\n    // Output ballot status and vote status\n    Out(bs_msg(bs, vote_status(vs)))\n\nlemmas\n\n  // Functional Lemma: A vote eventually leads to a ballot status output\n  lemma functional:\n    \"Exists private_key: PrivateKey, public_key: PublicKey, ballot: Ballot, bs: BS, vs: VS.\n    (Out(voter_pubkey(_, public_key)) \n     & Out(bs_msg(bs, vote_status(vs))))\"\n\n  // AuthP Lemma: Ensures integrity when the server is honest\n  lemma authP:\n    \"All signed_msg: Message, pub_key: PublicKey.\n    (Input(toS(signed_msg, _)) & verifySign(signed_msg, pub_key) = true) \n    => \n    (Exists bs: BS, vs: VS. Out(bs_msg(bs, vote_status(vs))))\""]], "SPTHY-1/probEnc.spthy": [[true, "theory probEnc \nbegin\n\n/*\n * Protocol:     Probabilistic Encryption\n * Modeler:      Jannik Dreier and Ralf Sasse\n * Described in: Automated Symbolic Proofs of Observational Equivalence [CCS'15]\n * Date:         April 2015\n *\n * Status:       working\n * Note: The protocol ensures probabilistic encryption by utilizing randomness\n * during encryption, maintaining security through observational equivalence.\n */\n\n// Declaration of functions used in the protocol\nfunctions: \n  penc/3, // probabilistic encryption: function of message, public key, and randomness\n  pdec/2, // decryption: function of ciphertext and private key\n  pk/1    // public key generation: function of private key\n\n// Equations to ensure correctness of encryption and decryption\nequations: \n  pdec(penc(m, pk(k), r), k) = m // decrypting an encrypted message retrieves the original message\n\n// Rule for Key Generation\nrule gen:\n  // A fresh private key is created\n  [ Fr(~k) ]\n--[ ]->\n  // The public key is derived and made available\n  [ !Key(~k), Out(pk(~k)) ]\n\n// Rule for Encryption\nrule enc:\n  // Preconditions: availability of a public key and fresh randomness\n  [ !Key(k), Fr(~r1), Fr(~r2), In(x) ]\n--[ ]->\n  // Outputs the encrypted message with associated randomness\n  [ Out(diff(~r1, penc(x, pk(k), ~r2))) ]\n\nend"]], "SPTHY-1/RFID_Simple.spthy": [[true, "theory ExtendedRFID begins\n\n// --- Function symbols ---\nfunctions: \n    senc/2, // symmetric encryption\n    aenc/2, // asymmetric encryption\n    adec/2, // asymmetric decryption\n    genkey/0, // key generation\n    key_pub/1, key_priv/1 // key derivation\n\n// --- Free function symbols ---\nfree-functions:\n    f/1, // represents sensitive data\n    g/1 // represents conditional access\n\n// --- Fact base ---\nfacts:\n    Device\n    Device_Select\n    EncryptedMessage/1\n\n// --- Protocol rules ---\nrules:\n\n// Key generation by a device\nrule GenKey:\n    let\n        pk = key_pub(genkey())\n    in\n    [\n        Fr(~privk) // fresh private key\n    ]\n    -->\n    [\n        !Device(pk) // device initialized with public key\n    ]\n    // Adversary learns the public key\n    & Out(pk)\n\n// Device Alice sends data\nrule Alice:\n    let\n        enc_data = aenc(f(~x), key_pub(~privk))\n    in\n    [\n        !Device(~pk)\n    ]\n    -->\n    [\n        Out(enc_data)\n    ]\n    & (\n        !Device_Select(~pk)\n    )\n\n// Communicating Device to Bob\nrule DeviceToBob:\n    [\n        !Device_Select(pk)\n    ]\n    -->\n    [\n        Device_Select(pk)\n    ]\n    // Bob is informed of the device's readiness\n    & Out(pk)\n\n// Selection rules\nrule Select_Left:\n    let\n        selected_data = f(~x)\n    in\n    [\n        Device_Select(pk),\n        Device\n    ]\n    -->\n    [\n        Out(selected_data) // send left piece of information to Bob\n    ]\n\nrule Select_Right:\n    let\n        selected_data = g(~y)\n    in\n    [\n        Device_Select(pk),\n        Device\n    ]\n    -->\n    [\n        Out(selected_data) // send right piece of information to Bob\n    ]\n\n// Decryption rules\nrule Decrypt_Left:\n    [\n        Out(aenc(f(~x), pk))\n    ]\n    -->\n    [\n        Out(~x) // Decrypt and expose left information\n    ]\n\nrule Decrypt_Right:\n    [\n        Out(aenc(g(~y), pk))\n    ]\n    -->\n    [\n        Out(~y) // Decrypt and expose right information\n    ]\n\n// --- Lemmas ---\n// Types lemma\nlemma types_lemma:\n    forall pk #i. Device(pk) @ i \n    implies \n    (Ex m. K(m) @ i)\n\n// Device to Bob lemma\nlemma device_to_bob_lemma:\n    forall pk #i. \n    Device_Select(pk) @ i \n    implies \n    (Device(pk) @ i)\n\n// Device initialization and use lemma\nlemma device_initialization_use_lemma:\n    forall pk #i #j.\n    Device(~pk) @ i \n    & Device(~pk) @ j \n    implies \n    i = j\n\n// Secrecy lemma\nlemma secrecy:\n    All m #i. Out(aenc(m, pk)) @ i \n    implies \n    Not(Ex x y. (K(x) @ i & K(y) @ i & x != y))\n\nend"]], "SPTHY-1/RF_dist_bound.spthy": [[true, "// Signature Setup\nfunctions: \n    sign: Message * Key -> Signature\n    verify: Signature * Message * Key -> Bool\n\n// Hash Function for Commitment\nfunctions:\n    hash: Nonce -> Commit\n\n// Protocol Constants\nfresh: Np, Nv: Nonce\npubkeys: kp, kv: Key\n\n// Rules for Distance Bounding Protocol\n\nrule Init:\n    let self: Agent, other: Agent in\n    var commitP: Commit\n    let msgV = hash(Np), commitP = sign(msgV, kv) in\n    Out(<'Commit', other, Np, commitP>)\n\nrule Prov1:\n    let prov: Agent, verif: Agent in\n    In(<'Commit', verif, Np, commitV>)\n    verify(commitV, hash(Np), kv)\n    Out(<'Challenge', verif, Nv>)\n\nrule Verif1:\n    let verif: Agent, prov: Agent in\n    In(<'Challenge', prov, Nv>)\n    Out(<'Nonce', prov, Nv>)\n\nrule Prov2:\n    let prov: Agent, verif: Agent in\n    In(<'Nonce', verif, Nv>)\n    Out(<'Response', verif, sign(<Np, Nv>, kp)>)\n\nrule Prov3:\n    let prov: Agent, verif: Agent in\n    In(<'Response', prov, response>)\n    verify(response, <Np, Nv>, kp)    \n    Out(<'Verification', verif>)\n\n// Lemmas\n\nlemma C_k_secrecy:\n    forall Np, Nv, kp, kv, commitP: Commit, response: Message.\n    Exists K: Key. Check(sign(<N, Nv>, kp), K) -> IsSecret(Np, Nv, commitP, response, K)\n\nlemma C_niagree:\n    forall session_key: Key, verif: Agent, prov: Agent.\n    Init(session_key, prov, verif) -> Agreement(session_key, verif, prov)"]], "SPTHY-1/SAKE.spthy": [[true, "// Define functions and operators\nfunctions: \n  h/1, cksum/1, mac/2, g/0, ^/2, mod/2\n\n// Define the messages\nmessage($v0, $v1, $v2, $w0, $w1, $w2, $k, $a, $b, $r, $c)\n\nprocess Verifier\n  [Init_Verifier]\n  {\n    // Generate random secret 'a' and compute v0, v1, v2, c\n    Fr(a)\n    let v0 = g ^ a mod p\n    let v1 = h(v0)\n    let v2 = h(v1)\n    let c = cksum(v2)\n    send_1(v2)\n  }\n  [Receive_Response_Device]\n  {\n    // Receive device message and verify MAC\n    recv_2(w2, mac_device)\n    verify(mac(c, w2), mac_device)\n    send_3(v1)\n  }\n  [Final_Verification_Device]\n  {\n    // Receive final device message and verify MAC and integrity\n    recv_4(w1, k, mac_w2_k)\n    verify(mac(w2, k), mac_w2_k)\n    verify(h(w1), w2)\n    send_5(v0)\n  }\n  [Final_Confirms_Secret]\n  {\n    // Receive w0 and confirm shared secret\n    recv_6(w0)\n    verify(h(w0), w1)\n    Fr(sk)\n    let sk = (g ^ b mod p) ^ a mod p\n    Out(sk)\n  }\n\nprocess Device\n  [Receive_Initialization_Verifier]\n  {\n    // Receive initialization and compute checksum\n    recv_1(v2)\n    let c_checksum = cksum(v2)\n    Fr(r)\n    let w0 = h(c_checksum | r)\n    let w1 = h(w0)\n    let w2 = h(w1)\n    Fr(b)\n    let k = g ^ b mod p\n    send_2(w2, mac(c_checksum, w2))\n  }\n  [Receive_Verification_Verifier]\n  {\n    // Receive verification and verify integrity\n    recv_3(v1)\n    verify(h(v1), v2)\n    send_4(w1, k, mac(w2, k))\n  }\n  [Final_Confirms_Secret]\n  {\n    // Receive v0 and confirm shared secret\n    recv_5(v0)\n    verify(h(v0), v1)\n    Fr(sk)\n    let sk = (g ^ a mod p) ^ b mod p\n    send_6(w0)\n  }\n\n// Define security properties  \nlemma secrecy: All{x} !(St(sk) @ Device & St(sk) @ Verifier)\nlemma authentication_D_to_V: All{x} St(mac(c, w2) @ Verifier) -> St(mac(c, w2) @ Device)\nlemma authentication_V_to_D: All{x} St(v2 @ Device) -> St(v2 @ Verifier)\nlemma integrity: All{x,y} St(mac(x,y) @ Verifier) -> St(mac(x,y) @ Device)\nlemma freshness: All{x} St(r @ Device) -> St(r @ Verifier)"]], "SPTHY-1/RYY.spthy": [[true, "// Protocol RYY\ntypes\n  Message\n  User\n  Key\n\nfunctions\n  msk: -> Key\n  ltk: User -> Key\n  ephemeral: -> Key\n  session: Key, Key, Key -> Key\n\nconstants\n  Alice, Bob: User\n\nactions\n  StartAlice(), StartBob(), SessionKey(Key), RevealLTK(User), RevealMSK(), RevealSessionKey(Key)\n\nrules\n\n  // Key Generation Center Setup - Initialize the master secret key\n  KGC_Setup:\n    [Fr(msk')]\n    --[ KGC_Setup(msk') ]-->\n    [ !MSK(msk') ]\n\n  // Key Request - Users request their long-term keys from KGC\n  KGC_request:\n    [ !MSK(msk'), Fr(ltk')]\n    --[ LTK_Issued(ltk', user) ]-->\n    [ !LTK(user, ltk') ]\n\n  // Reveal long-term key\n  Reveal_ltk:\n    [ !LTK(user, ltk) ]\n    --[ RevealLTK(user) ]-->\n\n  // Reveal master secret key\n  Reveal_master_key:\n    [ !MSK(msk) ]\n    --[ RevealMSK() ]-->\n\n  // Reveal session key\n  Reveal_session_key:\n    [ SessionKey(skey) ]\n    --[ RevealSessionKey(skey) ]-->\n\n  // Initialization phase - Alice initiates the protocol\n  Init:\n    [ Fr(e_kA), !LTK(Alice, ltkA), !LTK(Bob, ltkB) ]\n    --[ StartAlice(), Send(ephemeral(e_kA)) ]-->\n    [ EphemeralAlice(e_kA), AwaitResp(e_kA) ]\n\n  // Response phase - Bob responds to Alice's initiation\n  Resp:\n    [ EphemeralAlice(e_kA), Fr(e_kB), !LTK(Alice, ltkA), !LTK(Bob, ltkB) ]\n    --[ StartBob(), SessionKey(session_key) ]-->\n    [ SessionKey(session_key), Send(ephemeral(e_kB)) ]\n\nlemmas\n\n  // Key agreement lemma - The protocol guarantees successful key agreement\n  key_agreement_reachable:\n    All e_kA, e_kB, ltkA, ltkB, skey.\n      !LTK(Alice, ltkA) & !LTK(Bob, ltkB) &\n      EphemeralAlice(e_kA) & EphemeralBob(e_kB) &\n      SessionKey(session(e_kA, e_kB, ltkA, ltkB)) &\n      SessionKey(skey) ==> skey = session(e_kA, e_kB, ltkA, ltkB)\n\n  // Key secrecy lemma - Conditions under which the session key may be revealed\n  key_secrecy_WPFS:\n    All skey.\n      SessionKey(skey) & RevealSessionKey(skey) ==> \n      (\n        RevealMSK() |\n        (Exists user: RevealLTK(user)) |\n        EphemeralCompromise()\n      )"]], "SPTHY-1/Scott.spthy": [[true, "theory Scott_Identity_Based_Key_Exchange\n\nbegin\n\n  functions\n    msk/0                  // Master Secret Key\n    ltk/1                  // Long-term Key for a user\n    id/0, idA/0, idB/0     // Identity for users A and B\n    x/1                    // Session key component from A\n    y/1                    // Session key component from B\n    sessionkey/2           // Session key derived for a session\n    kdf/2                  // Key derivation function\n    h/1                    // Hash function, for cryptographic operations\n\n  builtins: asymmetric\n\n  // Initial state: KGC setup\n  rules\n\n    // Rule: KGC_Setup\n    // Establishes a master secret key (MSK) by the KGC\n    [ Fr(msk_generated) ]\n    --> \n    [ !MSK(msk_generated) ]\n\n    // Rule: KGC_request\n    // Generate long-term key (LTK) for a specific identity\n    [ !MSK(msk_generated), Fr(id) ]\n    -->\n    [ Out(ltk(h(id))) ]\n\n    // Rule: Init (Initialization phase by A)\n    // Party A sends a message with its session key component\n    [ !MSK(msk), !LtkA(ltkA), Fr(idA) ]\n    -->\n    [ Out(x(ltkA)) ]\n\n    // Rule: Resp (Response phase by B)\n    // Party B generates its session key component and responds\n    [ !MSK(msk), !LtkB(ltkB), Fr(idB), In(x(ltkA)) ]\n    -->\n    [ Out(y(ltkB)), !SharedKeyA_B(sessionkey(x(ltkA), y(ltkB))) ]\n\n    // Rule: Key Agreement Reachability \n    // Ensure both parties derive the same session key\n    rule KeyAgreementReachability\n    [ !SharedKeyA_B(sessionkey(x(ltkA), y(ltkB))) ]\n    --[ !KeyAgreementSuccess(x(ltkA), y(ltkB)) ]->\n\n  lemmas\n\n    // Secret of session key\n    lemma KeySecrecy:\n      \"All x y. KeyAgreementSuccess(x, y) ==> K(sessionkey(x, y))\"\n\n    // Restrictions to prevent use of neutral elements\n    restriction HonestComputation:\n    \"All x y. KeyAgreementSuccess(x, y) ==> Not(x = y)\"\n\nend"]], "SPTHY-1/sig.spthy": [[true, "theory SecureSignatureProtocol\n\nbegin\n\n(* Define the Agent type *)\ntype Agent\n\n(* Define the Key types *)\ntype Ltk\ntype Pk\n\n(* Define the Message type *)\ntype Message\n\n(* Functions for key generation and nonce generation *)\nknown functions\n  pk: Ltk -> Pk\n  sign: Message # Ltk -> Message\n  verify: Message # Message # Pk -> Bool\n\n(* Fresh constants *)\nfunctions\n  ltk: Agent -> Ltk\n  n: Agent -> Message\n\n(* Rules for Key Generation *)\nrule LtkGen:\n  [ Fr(~ltkA) ]\n  -->\n  [ !LtkGen(ltkA), !PkGen(pk(ltkA)) ]\n\n(* Rules for Sending Signatures *)\nrule Send_Signature:\n  [ Fr(~nA) ]\n  -->\n  [ Out(<nA, sign(nA, ltkA)>) ]\n\n(* Rules for Receiving Signatures *)\nrule Recv_Signature:\n  forall A B\n  In(<nB, msg>)\n  [& verify(nB, msg, pk(ltkB)) = true] \n  -->\n  [ !SignatureVerified(A,B,nB,msg) ]\n\n(* Security properties *)\n\nrestriction equal:\n  forall A B m1 m2\n  SignatureVerified(A, B, m1, m2)\n  implies m1 = m2\n\nlemma executable:\n  exists-trace\n  Send_Signature\n\nlemma signature_sent_by_agent:\n  forall A B m1 m2\n  SignatureVerified(A, B, m1, m2)\n  implies\n  Send_Signature(A, m1)\n\nend"]], "SPTHY-1/sigma-1.spthy": [[true, "theory SigmaProtocol\n\nbegin\n\nfunctions \n    // Diffie-Hellman exponentiation\n    exp/2, \n    // MAC function\n    mac/2, \n    // Signature function\n    sign/2\n\n // Long-term keys and corresponding public keys\n    ltk/1, \n    pk/1\n\nassumptions\n    // Diffie-Hellman Key Exchange\n    DH_Equation: forall x, y. exp(exp(g, x), y) = exp(exp(g, y), x)\n\nrules\n\n  // Client Initialization rule\n  [CN_Init]\n  forall i, x, Client\n  let DH_value = exp(g, x)\n  in\n  // Event for Client initiation\n  Init(Client, DH_value) ==> Out(<DH_value, i>)\n\n  // Server Response rule\n  [SR_Response]\n  forall i, y, DH_value, Server\n  let DH_value_S = exp(g, y)\n      MAC_S = mac((DH_value, DH_value_S), pk(Server))\n      Signature_S = sign((DH_value, DH_value_S), ltk(Server))\n  in\n  // Event for Server response\n  In(<DH_value, i>) ==> Out(<DH_value_S, MAC_S, Signature_S, i, Server>)\n\n  // Client Finalization rule\n  [CN_Final]\n  forall i, x, DH_value_S, MAC_S, Signature_S, Client\n  let Signature_C = sign((DH_value_S, DH_value_C), ltk(Client))\n      MAC_C = mac((DH_value_S, DH_value_C), pk(Client))\n  in\n  // Verification and completion event\n  In(<DH_value_S, MAC_S, Signature_S, i, Client>) \n    ==> if (verify(Signature_S, pk(Server))) then Out(<Signature_C, MAC_C, i, Client>) \n\n  // Server Finalization rule\n  [SR_Final]\n  forall i, Signature_C, MAC_C, Server\n  if verify(Signature_C, pk(Client))\n  then In(<Signature_C, MAC_C, i, Server>) ==> Event(SessionEstablished(Server, Client))\n\nlemmas\n\n  // Key Secrecy lemma\n  key_secrecy: forall K, Client, Server.\n    ~ (Reveal(K) & SessionEstablished(Server, Client))\n  \n  // Injective Agreement lemma\n  injective_agreement: forall Server, Client.\n    In(SessionEstablished(Server, Client) & SessionEstablished(Server, _))\n    => Client = _\n\n  // Server Liveness lemma\n  server_liveness: forall Client, Server.\n    Init(Client, _) => Ex (SessionEstablished(Server, Client)) \n  \n  // Client Liveness lemma\n  client_liveness: forall Server, Client.\n    SessionEstablished(Server, Client) => Ex (Init(Client, _))\n\nend"]], "SPTHY-1/Artificial.spthy": [[true, "// Define the sorts (basic types) for agents and keys\ntype Agent\ntype Key\n\n// Constants representing participants\nconst x, S: Agent\n\n// Fresh function to denote the generation of fresh keys\nfresh k: Key\n\n// Protocol rules\nrule KeyGenerationAndSending:\n  // Agent x generates a fresh key and sends it to S\n  let StMsg = senc(x, k)\n  in\n  [ Fr(k) ]\n  --[ Send(St(x, k), StMsg) ]-> \n  [ StoredKey(x, k) ]\n\nrule FinishingSession:\n  // Agent S sends a finishing signal acknowledging reception of key\n  let FinMsg = Fin(x, k)\n  in\n  [ Send(St(x, k), senc(x, k)) ]\n  --[ Send(FinMsg) ]-> \n  [ FinishedSession(S, k) ]\n\nrule KeyReveal:\n  // Reveal the session key k\n  [ Rev(k) ]\n  --[ Reveal(k) ]->\n  []\n\n// Lemmas asserting properties of the protocol\n\nlemma Characterize_Fin:\n  \"Exists[ k ]: exists-trace(Send(?Fin(x, k)))\"\n\nlemma Fin_unique:\n  \"All[ k ]: All[ x, S ]: \n     (Send(Fin(x, k))@i & Send(Fin(x, k))@j) ==> (i = j)\"\n\nlemma Keys_must_be_revealed:\n  \"All[ k ]: All[ S ]: \n     (Send(Fin(S, k))@i) ==> (Exists[ j ]: Reveal(k)@j & j < i)\""]], "SPTHY-1/signed_dh.spthy": [[true, "# Signature Diffie-Hellman Protocol in Tamarin\n\n# Functions\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\n# Diffie-Hellman key agreement built-in\nuse_diffie-hellman: true\n\n# Equations for encryption and decryption\nequations:\n  adec(aenc(x, pk(y)), sk(y)) = x\n  adec(aenc(x, sk(y)), pk(y)) = x\n\n# Initial knowledge\ninitial_knowledge: {Alice} // Alice knows her own private key\n\n# Protocol description\nrules:\n\n  // Alice's first step\n  rule dh_1_A:\n    let m = #mh(\"One\"),\n        randA = #rand,\n        msg = aenc(m(randA, 'A', 'B'), pk(B))\n    in\n    [!Fr(randA)] --[send_1_A(msg)]-> [out(msg), Fr(sk(A))]\n  \n  // Bob's first step: receiving Alice's message\n  rule dh_1_B:\n    let msg = aenc(\"One\", pk(A)),\n        randB = #rand\n    in\n    [in(msg)] --[recv_1_B(msg)]-> [!Fr(randB), out(aenc(\"Two\", pk(A)(g(randB))))]\n\n  // Alice's second step\n  rule dh_2_A:\n    let response = aenc(\"Two\", pk(B)),\n        keyA = g(randA)\n    in\n    [in(response), Fr(randA)] --[compute_A(response)]-> [Fr(keyA), Secret(keyA)]\n  \n  // Bob's second step\n  rule dh_2_B:\n    let keyB = g(randB)\n    in\n    [recv_2_B, Fr(randB), Secret(keyB)]\n\n# Lemmas for secrecy\nlemmas:\n  key_secrecy: All x #i. Secret(x) @ #i ==> not exists y. In(y) @ #i\n  key_secrecy_Alice: All key #i. Secret(key) @ dh_2_A(key) ==> not exists msg. In(msg) @ #i\n  key_secrecy_Bob: All key #i. Secret(key) @ dh_2_B(key) ==> not exists msg. In(msg) @ #i"]], "SPTHY-1/StatVerif_GM_Contract_Signing.spthy": [[true, "theory ContractSigningProtocol\n\n  builtins: symmetric-encryption, asymmetric-encryption\n\n  // Functions\n  functions: \n    pk/1, sk/1, sign/2, pcs/3, check_getmsg/2, checkpcs/5, convertpcs/2\n\n  // User-defined types\n  types: \n    Agent, Message, Contract, Role\n\n  // Initial facts\n  consts:\n    TTP: Agent\n    pk1, pk2: Message\n    // Initial knowledge for parties\n    x_key: (Message * Agent) -> Message\n    y_key: (Message * Agent) -> Message\n\n  // Protocol rules:\n  rules:\n\n    [SetupTTP]\n      [ Fr(~sk_TTP) ]\n    -->\n      [ Init(TTP, pk(sk(~sk_TTP))) ]\n\n    [ContractInitiation]\n      [ !Init(TTP, ~pk_TTP), Fr(~ct,~sk_x) ]\n    -->\n      [ ContractProposed(TTP, pk(~sk_x), pk2, ~ct), !Knows(pk(~sk_x)), !Knows(pk2) ]\n\n    [AbortRequest]\n      [ !ContractProposed(TTP, pk(~sk_x), pk2, ~ct),\n        Fr(~abort_certificate)\n        ]\n    -->\n      [ AbortCertificate(TTP, ~ct, ~abort_certificate) ]\n\n    [ResolveRequest]\n      [ !ContractProposed(TTP, pk(~sk_x), pk2, ~ct),\n        Fr(~resolve_certificate)\n        ]\n    -->\n      [ ResolveCertificate(TTP, ~ct, ~resolve_certificate) ]\n\n    [WitnessAborted]\n      [ !AbortCertificate(TTP, ~ct, ~abort_certificate) ]\n    -->\n      [ WitnessOutcome(TTP, \"aborted\", ~ct) ]\n\n    [WitnessResolved]\n      [ !ResolveCertificate(TTP, ~ct, ~resolve_certificate) ]\n    -->\n      [ WitnessOutcome(TTP, \"resolved\", ~ct) ]\n\n  // Security goals:\n  lemmas:\n\n    unique_outcome: \"All ct ContractProposed(TTP, pk(~sk_x), pk2, ct) ==> \n                     (WitnessOutcome(TTP, x, ct) & WitnessOutcome(TTP, y, ct)) ==>  x = y\"\n\n    non_repudiation_x: \"All ct ResolveCertificate(TTP, ct, rc) ==> \n                         Exists sk_x check_getmsg(sign(sk_x, ct), ct)\"\n\n    non_repudiation_y: \"All ct ResolveCertificate(TTP, ct, rc) ==> \n                         Exists sk_y check_getmsg(sign(sk_y, ct), ct)\"\n\n    integrity: \"All ct ContractProposed(TTP, pk(~sk_x), pk2, ct) ==> \n                ResolveCertificate(TTP, ct, rc) ==> checkpcs(ct, pk(~sk_x), pk2, rc, ...\"\n                \nend"]], "SPTHY-1/STR_signed.spthy": [[true, "theory GroupKeyEstablishment\nbegin\n\nconsts\n  groupId: Data\n  randomValue: Data\n  blindedRandom: Data\n  blindedKey: Data\n  groupElement: Data\n  sharedKey: Data\n\nfunctions\n  blindedRandomOf: Agent * groupId -> blindedRandom\n  blindedKeyFor: Agent * groupId -> blindedKey\n  sign: Data * sk -> Signature\n  te: GroupElement -> Exponent  // Transformation from group elements to exponents not hiding\n\ntypes\n  Key\n  GroupElement\n  Exponent\n  Signature\n\nconsts\n  skI, skR: Key\n  pkI, pkR: Key\n\nequations\n  sign(n,m) = sign(n,m) // Signature scheme\n  // Other equations modeling the asymmetric key operations\n\nrules\n\n  // Group Initialization by Initiator I\n  rule Initiator_Start:\n    [ Fr(groupId), Fr(randomValue), Fr(skI) ]\n    --[ SendMsg(groupId, sign(groupId, sklI)) ]->\n    [ Init_I(groupId) ]\n\n  // Responder Activation - Responders join the group\n  rule Responder_Join:\n    [ Fr(blindedRandom), Fr(skR) ]\n    --[ BeginResponder(R, groupId), SendMsg(R, sign(blindedRandom, skR)) ]->\n    [ Responder_Active(R, groupId) ]\n\n  // Message Exchange - Initiator receives and authenticates messages\n  rule Initiator_Receive_Msg:\n    [ Init_I(groupId), Responder_Active(R, groupId) ]\n    --[ ReceiveMsg(R, sign(blindedRandom, skR)), VerifySignature(sign(blindedRandom, skR), pkR) ]->\n    [ Actived(R, groupId), SendBlindedKey(R, sign(blindedKeyFor(R, groupId), skI)) ]\n\n  // Completion - Derivation of shared key\n  rule Key_Derivation:\n    [ Actived(R, groupId) ]\n    --[ DeriveSharedKey(groupId) ]->\n    [ DerivedSharedKey(sharedKey) ]\n\n  // Intruder model handling participant corruption\n  rule Intruder_Corrupt:\n    [ !Corrupt(R) ]\n    --[ IntruderHas(skR) ]->\n    [ ]\n\nlemmas\n  lemma Key_Secrecy:\n    \"All x y. DerivedSharedKey(x) & DerivedSharedKey(y) -> x = y\"\n\nend"]], "SPTHY-1/STS_MAC_fix1.spthy": [[true, "theory STSMAC\n\nbegin\n\n// Define sorts\nbuiltin sort Bool\nbuiltin sort Message\n\n// Define functions and public key infrastructure (PKI)\nfunctions\n    pk: Message -> Message // Public key function\n    mac: Message * Message -> Message // MAC function\n    sign: Message * Message -> Message // Signature function\n    kdf: Message -> Message // Key derivation function\n    dh: Message * Message -> Message // Diffie-Hellman function\n\n// Channels\nchannels\n    ch: Message\n\n// Define knowledge for honest parties\nbuiltins: \n    Pk, Sk\n\n// Define asymmetric encryption\nfunction enc: Message * Message -> Message\ninversekeys (pk, sk)\n\n// Free variables for role identities and long-term keys\nfree variables\n    I, R: Message // role identities\n    ltkI, ltkR: Message // long-term keys for initiator and responder\n    epkI, epkR: Message // ephemeral public keys\n    s: Message // shared secret\n    m: Message // messages\n\n// Protocol rules\nrules\n\n  // Key registration phase\n  KeyRegistration:\n    [ Fr(ltkI) ]\n  --[ !Pk(pk(ltkI)) ]-> \n    [ !Pk(pk(ltkI)) ]\n\n  KeyRegistrationEvil:\n    [ !Pk(pk(ltkI)) ]\n  --[ ]-> \n    [ Sk(pk(ltkI)) ]\n\n  // Initiator starts the protocol\n  Initiate:\n    [ Fr(epkI) ]\n  --[ Begin(I, R, epkI) ]-> \n    [ Out(<I, R, epkI>) ]\n\n  // Responder receives the initiation and responds\n  Respond:\n    [ In(<I, R, epkI>), Fr(epkR) ]\n  --[ Begin(R,I, epkI, epkR) ]-> \n    [ Out(<R, I, epkR, sign(A, pk(ltkR)), mac(m, epkI)) >, !DhShared(DH(epkI, epkR)) ]\n\n  // Initiator finalizes the handshake\n  Finalize:\n    [ In(<R, I, epkR, sign(A, pk(ltkR)), mac(m, epkI)) >, \n      !DhShared(DH(epkI, epkR)) ]\n  --[ End(I, R, epkI, epkR) ]->\n    [ Out(sign(B, pk(ltkI))) ]\n\n// Security properties\n\n// Secrecy of derived key\nlemma session_key_secrecy:\n    \"All I R K #i. Secret(K, sk, #i) ==> \n      always (!WeakSecret(K, sk, #i)) \"\n\n// Authentication properties: Initiator\nlemma initiator_authentication:\n    \"All I R #i #r. \n      F_Completed(I,R,#i,#r) ==> (Ex epkI. Begin(I,R,epkI) @ #i)\"\n\n// Forward secrecy\nlemma forward_secrecy:\n    \"All I R #i. PastSecret(S, #i) ==>\n     always (!WeakSecret(S, fs, #i))\"\n\nend"]], "SPTHY-1/TESLA_Scheme1.spthy": [[true, "# TESLA Protocol, Scheme 1 Analysis in Tamarin Language\n# Modeling based on description provided\n\n# Directions\n# S: Sender\n# R: Receiver\n\n# Initial knowledge\nlet attacker_knowledge = { } in\n\n# Protocol variables\nknowledge agent : type.\nknowledge key : type.\nknowledge msg : type.\nknowledge nonce : type.\n\nknowledge S : agent.\nknowledge R : agent.\n\nknowledge k1, k2, k3 : key. # Secret keys\nknowledge ltkS : key. # Long-term key of sender\n\nknowledge nR : nonce.\n\nknowledge m1, m2, mn : msg.\nknowledge D1, D2, Dn : msg.\n\nrules\n\n// Initialization phase\nrule send_nonce:\n  [Fr(nR)] -->\n  [!Msg(R, S, nR)] // Receiver sends nonce to sender\n\nrule sender_commit:\n  [!Msg(R, S, nR)] -->\n  [!Msg(S, R, sign({f(k1), nR}, ltkS))] // Sender commits to first key\n\n// Authenticated Broadcast phase\nrule send_message_1:\n  [Fr(k1)] --> \n  [!Msg(S, R, (m1, f(k2))), !MAC(S, R, MAC(k1, (m1, f(k2))))] // First data and MAC with k1\n\nrule send_message_2:\n  [Fr(k2), Fr(k1)] -->\n  [!Msg(S, R, (m2, f(k3), k1)), !MAC(S, R, MAC(k2, (m2, f(k3), k1)))] // Second data, MAC, and previous key\n\nrule send_message_n:\n  [Fr(kn), Fr(kn-1)] -->\n  [!Msg(S, R, (mn, f(kn+1), kn-1)), !MAC(S, R, MAC(kn, (mn, f(kn+1), kn-1)))] // Subsequent messages\n\n# Security properties\nlemma authenticity:\n  \"All r #i #j #k. receive(R, S, r) @ i ==> \n    (send(S, R, r) @ j & j < i) |\n    (Compromise(ltkS) @ k & k < i) |\n    (Replay(r) @ i)\"\n\nend"]], "SPTHY-1/thirdAttestation.spthy": [[true, "theory ThirdEATImplementation\n\n/* Define the functions and data types */\nfunctions\n    IdentityCreation: Agent -> Identity\n    NonceExchange: Nonce\n    EATGeneration: State -> Evidence\n    Sign: (Message, Key) -> SignedMessage\n    Verify: (SignedMessage, Key) -> Bool\n    GoodState, BadState, PartiallyCompromised: State\n\n/* Define the agents involved */\nbuiltins: asymmetric-encryption\n\nchannels\n    Attester_to_Verifier_A: {sender: Attester, receiver: Verifier, label: \"nonce_exchange\"}\n\nrules\n\n// Identity Creation Rule\n[identity_creation_attester]\n    [Agent(Attester)]\n-- \n    [Identity_created_A: IdentityCreation(Attester)]\n    \n[identity_creation_verifier]\n    [Agent(Verifier)]\n-- \n    [Identity_created_V: IdentityCreation(Verifier)]\n\n// Nonce Exchange Rule\n[nonce_exchange_rule]\n    [Identity_created_V]\n-- \n    [Nonce_exchange: NonceExchange]\n\n// EAT Generation Rule\n[eat_generation_good]\n    [Identity_created_A]\n    [Nonce_exchange]\n--\n    [EAT_Generated_A: EATGeneration(GoodState)]\n\n[eat_generation_bad]\n    [Identity_created_A]\n    [Nonce_exchange]\n--\n    [EAT_Generated_A: EATGeneration(BadState)]\n\n[eat_generation_partial]\n    [Identity_created_A]\n    [Nonce_exchange]\n--\n    [EAT_Generated_A: EATGeneration(PartiallyCompromised)]\n\n// EAT Sending Rule\n[eat_sending]\n    [Nonce_exchange]\n-- \n    [eat_sent: Out(Attester_to_Verifier_A, Sign(Nonce_exchange, EAT_Generated_A))]\n\n// Verification Rule\n[verification_success]\n    [eat_sent]\n    [Identity_created_V]\n-- \n    [Verified: Verify(Sign(Nonce_exchange, EAT_Generated_A), IdentityCreation(Verifier))]\n\n[verification_failure]\n    [eat_sent]\n    [Identity_created_V]\n-- \n    [NotVerified: ~Verify(Sign(Nonce_exchange, EAT_Generated_A), IdentityCreation(Verifier))]\n\n// Lemmas\n\nlemma sanity_check:\n    \"All Attester Agent: Attester has Identity_creation_attester & EAT_Generated_A ==> Verified\"\n\nlemma no_verification_of_bad_state:\n    \"All Attester Agent: (EAT_Generated_A == EATGeneration(BadState)) ==> NotVerified\"\n\nlemma key_compromise:\n    \"Ex Attester Agent: ~Compromise(IdentityCreation(Attester)) & ~Compromise(IdentityCreation(Verifier))\"\n\nend"]], "SPTHY-1/TLS_Handshake.spthy": [[true, "// TLS Handshake Protocol in Tamarin\n\n// Define sorts\nsort principal, text, message, key\n\n// Define functions\nfunctions\n  pk: principal -> key\n  sign: key * message -> text\n  encrypt: key * message -> text\n  PRF: message * message * message -> message\n  h: message -> message\n\n// Define protocol constants\nconst clientHello, serverHello, clientKey, serverKey, clientFinished, serverFinished: message\nconst longTermKeyClient, longTermKeyServer: key\nconst preMasterSecret: message\n\n// Participants\ntype\n  Client: principal\n  Server: principal\n\n// Define initial knowledge\nknowledge\n  ActionT: text\n\n// Facts\nfacts\n  SessionKeySecrecy: principal * principal * message\n  InjectiveAgreement: principal * principal * message\n  SessionKeySetup: principal * principal * message\n\n// Rules\n\nrule ClientHello:\n  [Fr(nc), Fr(sid)]\n  --> \n  Out(<Client, nc, sid, pk(Client)>)\n\nrule ServerHello:\n  [Fr(ns), Fr(sid), In(<Client, nc, sid, pk(Client)>)]\n  --> \n  Out(<ns, sid, pk(Server)>)\n\nrule ClientKeyExchangeFinished:\n  [Fr(pms), Fr(ActionT), In(<ns, sid, pk(Server)>)]\n  -->\n  Out(encrypt(pk(Server), <clientFinished, pms>))\n  Out(sign(pk(Client), h('clientKey', ns, Server, pms)))\n  Out(encrypt(PRF(pms, nc, ns), <clientKey, sid, PRF(pms, nc, ns), nc, pk(Client), Client, ns, pk(Server), Server>))\n  In(h('serverKey', nc, ns, PRF(pms, nc, ns)))\n\nrule ServerFinished:\n  [Fr(ActionT), In(each client keys exchange and finish steps info)]\n  -->\n  Out(encrypt(PRF(pms, nc, ns), <serverFinished, sid, PRF(pms, nc, ns), nc, pk(Client), Client, ns, pk(Server), Server>))\n  Out(h('serverKey', nc, ns, PRF(pms, nc, ns)))\n\n// Security properties\n\nlemma SessionKeySecrecy:\n  forall C: Client, S: Server, pms: message.\n  not (Exposes(C) and Exposes(S) and SessionKeySecrecy(C, S, pms))\n\nlemma InjectiveAgreement:\n  forall C: Client, S: Server, params: message.\n  not (Exposes(C) and Exposes(S) and InjectiveAgreement(C, S, params))\n\nlemma SessionKeySetup:\n  forall C: Client, S: Server, pms: message.\n  not (Exposes(C) and Exposes(S) and SessionKeySetup(C, S, pms))"]], "SPTHY-1/TPM_Exclusive_Secrets.spthy": [[true, "theory TPMExclusiveSecrets\n\nbegin\n\n// Declare built-in sorts\nbuiltins: asymmetric, symmetric, hashing\n\n// Declare free sorts\nfree sort PCR, AIK, Key, Secret\n\n// Declare free functions\nfunctions: \n    // Relationships\n    initAIK: -> AIK\n    initPCR: -> PCR\n    extendPCR: PCR * message -> PCR\n    createKey: PCR -> Key\n    certifyKey: Key * AIK -> Key\n    encryptSecret: Secret * Key -> message\n\n// Declare channels\nchannels:\n// You can use 'In', 'Out', or private channels here as needed\n\n// Initial State\nrule Init:\n    let ai in AIK, pr in PCR\n    [ \n        // Initial AIK\n        !initAIK() = ai,\n        // Initial PCR\n        !initPCR() = pr\n    ]\n    --[ \n        // No action, just setup\n    ]-->\n\n// PCR Extension\nrule ExtendPCR:\n    let curr_pcr, new_pcr in PCR, m in message\n    [ \n         // Current PCR status\n        !(currentPCR = curr_pcr) \n    ]\n    --[\n        // Extend with a new message\n        NewNonce(m)\n    ]->\n    [ \n        out(pcr_extends = new_pcr = extendPCR(curr_pcr, m))\n    ]\n\n// Key Creation\nrule KeyCreation:\n    let curr_pcr in PCR, k in Key\n    [ \n        out(active_pcr = curr_pcr) \n    ]\n    --[\n        // Create a key\n        CreateKey(curr_pcr)\n    ]->\n    [ \n        out(key = k = createKey(curr_pcr))\n    ]\n\n// Key Certification\nrule KeyCertification:\n    let k in Key, aik in AIK\n    [ \n        out(unbound_key = k),\n        !initAIK = aik\n    ]\n    --[\n        // Certify the key using AIK\n        Certify(k, aik)\n    ]->\n    [ \n        out(cert_key = certifyKey(k, aik))\n    ]\n\n// Unbind Secret\nrule UnbindSecret:\n    let m in message, s in Secret, k in Key, curr_pcr in PCR\n    [ \n        in(cert_key = certifyKey(k, ai)),\n        !(currentPCR = curr_pcr),\n        out(secret_cipher = m = encryptSecret(s, k))\n    ]\n    --[ \n        DecryptAttempt(s)\n    ]->\n    [ \n        out(secret_plain = s) \n    ]\n\n// Security properties\nlemma exclusive_secrets:\n    \"All s1 s2 #j. (DecryptAttempt(s1)@j & DecryptAttempt(s2)@j) \n    => (s1 = s2)\" by oracle\n\nlemma reachability:\n    \"Exists s #j. DecryptAttempt(s)@j\" \n\nend"]], "SPTHY-1/Typing_and_Destructors.spthy": [[true, "// Protocol: Interaction between Sources and Destructors\n// Modeler: Simon Meier\n// Date: July 2012\n\n// Types and Built-in functions\nfunctions: \n    symmetric-encryption/2 // Symmetric encryption using a key and message\n    hashing/1               // Hashing function\n\n// Free Types and Facts\ntypes:\n    Key\n    Message\n\nfree-facts: \n    public(Component) // Fact representing public components\n    secret(Value)     // Fact representing secret values\n\n// Protocol Rules\nrules:\n\n    // Setup Key Rule\n    rule Setup_Key:\n        [ Fr(k) ] --[ NewKey(k) ]-> [ ValidKey(k) ]\n\n    // Reveal Key Rule\n    rule Reveal_Key:\n        [ ValidKey(k) ] --[ Reveal(k) ]-> [ Compromised(k) ]\n\n    // Initiator Rule\n    rule Initiator:\n        [ ValidKey(k), Fr(secret), Fr(pub) ]\n        --[ InitMessage(secret, pub) ]->\n        [ SymmetricMessage(symmetric-encryption(k, secret), pub) ]\n\n    // Responder Rule\n    rule Responder:\n        [ SymmetricMessage(msg, pub), ValidKey(k) ]\n        | exists secret: secret(Value)  // Guard: secret originated from the protocol\n        --[ ReceiveMessage(msg, pub) ]->\n        [ DecodedMessage(secret, pub) ]\n\n// Restrictions\nrestrictions:\n    // Filter out traces with failure terms\n    restriction No_failure_terms:\n        forall pub: public(Component) \n        exists msg: SymmetricMessage(msg, pub) \n        exists secret: DecodedMessage(secret, pub)\n\n// Assertions and Lemmas\nlemmas:\n\n    // Assert types of messages received by responder\n    lemma type_assertion:\n        \"forall pub secret : public(Component), secret(Value) |\n           ReceiveMessage(SymmetricMessage(symmetric-encryption(k, secret), pub), pub)\"\n\n    // Verify secrecy of responder's messages\n    lemma Responder_secrecy:\n        \"forall secret pub : secret(Value), public(Component) |\n           DecodedMessage(secret, pub) => not Compromised(secret)\"\n\n    // Verify accessibility of public parts\n    lemma Public_part_public:\n        \"forall pub : public(Component) | exists pub: DecodedMessage(secret, pub) \n           => public(pub)\"\n\n// End of Protocol Definition"]], "SPTHY-1/UM_wPFS.spthy": [[true, "# Protocol: Unified Model (UM) Key-Exchange Protocol\n\n# Functions\nfunctions: \n    pk/1, sk/1, g/0, exp/2, hash/1, generateSessionKey/3\n\n# Types\ntypes: \n    Agent, Nonce, PublicKey, SecretKey, SessionKeyId\n\n# Free variables\nfree: \n    I, R: Agent \n    SidI, SidR: Nonce\n\n# Initial Knowledge\n# The adversary knows the generator and can perform hash operations.\nknowledge: \n    [ g, hash ]\n\n# Facts and Lemmas\n# Ltk, EkI, EkR are used to represent long-term keys and ephemeral keys.\nfacts: \n    Ltk(I): PublicKey\n    Ltk(R): PublicKey\n    EkI: SecretKey\n    EkR: SecretKey\n    Sessk(I,R): SessionKeyId\n\n# Lemmas\nlemmas:\n    SecretChannel: \n        \"All I R SidI SidR. \n         Exists Se. \n         Sessk(I,R)@Se ==> !Sessk_reveal(Se)\"\n\n# Rules\n\n# Rule: generate_ltk\nrule generate_ltk:\n    [Fr(~lk)]\n    -->\n    [Ltk(I), Out(pk(exp(g, ~lk)))]\n\n# Rule: Init_1 - Initiator sends Initial Message\nrule Init_1:\n    [Ltk(I)]\n    [Fr(~ekI)]\n    -->\n    [Out(<'g'^~ekI, I, SidI, hash(exp(g, ~ekI))>), EkI(@I)]\n\n# Rule: Resp_1 - Responder processes Initial Message\nrule Resp_1:\n    [Ltk(R)]\n    # Consumption of the initial message sent by Initiator\n    [In(<'g'^?ekI, I, SidI, ?M>)]\n    [Fr(~ekR)]\n    -->\n    # Responder generates ephemeral key and sends response including hash\n    [Out(<'g'^~ekR, R, SidR, hash(exp(g, ~ekR))>), EkR(@R)]\n\n# Rule: Init_2 - Initiator processes Responder's Message and derives session key\nrule Init_2:\n    [In(<'g'^?ekR, R, SidR, ?N>)]\n    [EkI(@I)]\n    [Ltk(I)]\n    [Ltk(R)]\n    -->\n    # Derive session key and establish channel secrecy\n    [Sessk(I,R), SecretChannel]\n\n# Rule: Ephk_reveal - Allows revealing of ephemeral keys under controlled conditions\nrule Ephk_reveal:\n    [EkI(@A)]\n    -->\n    [Out(reveal_Ek)(A), SecretChannel]\n\n# Rule: Sessk_reveal - Allows revealing of session keys\nrule Sessk_reveal:\n    [Sessk(I, R)]\n    -->\n    [Out(reveal_Sessk(I, R))]\n\n# Rule: Ltk_reveal - Allows revealing of long-term keys\nrule Ltk_reveal:\n    [Ltk(@A)]\n    -->\n    [Out(reveal_Ltk)(A), SecretChannel]"]], "SPTHY-1/auto_protocol_and_property.spthy": [[true, "theory SecureCommunicationProtocol\nbegin\n\n  // Define functions for cryptographic operations\n  functions:\n    pk/1, sk/1, senc/2, hash/1\n\n  // Define free variables for identities, nonces, messages, and symmetric key\n  free variables:\n    A, B : actor\n    N, M : msg\n    k_AB : symkey\n\n  // Define asymmetric key pairs\n  equations:\n    inv(pk(A)) = sk(A)\n    inv(pk(B)) = sk(B)\n\n  // Protocol roles\n\n  // Alice's role\n  rule Alice_Send_Msg1:\n    [ Fr(N) ]\n    -->\n    [ Out(<A, B, senc(<A, B, N, hash(N)>, k_AB)>) ]\n\n  rule Alice_Receive_Msg2:\n    [ In(senc(M, k_AB)) ]\n    -->\n    [ State(<A, M>) ]\n\n  rule Alice_Send_Msg3:\n    [ State(<A, M>) ]\n    -->\n    [ Out(senc(hash(M), k_AB)) ]\n\n  // Bob's role\n  rule Bob_Receive_Msg1:\n    [ In(senc(<A, B, N, hash(N)>, k_AB)) ]\n    -->\n    [ State(<B, N>) ]\n\n  rule Bob_Send_Msg2:\n    [ State(<B, N>) ]\n    -->\n    [ Out(senc(M, k_AB)) ]\n\n  rule Bob_Receive_Msg3:\n    [ In(senc(hash(M), k_AB)) ]\n    -->\n    [ State(<B, M>) ]\n\n  // Security properties\n\n  // Confidentiality of the symmetric key\n  lemma secrecy_of_symmetric_key:\n    \"All instances of < k_AB > are kept confidential.\"\n\n  // Authentication of the parties\n  lemma alice_authenticates_bob:\n    \"If Alice reaches state <A, M>, then there is some Bob who previously processed Alice\u2019s first message.\"\n\n  lemma bob_authenticates_alice:\n    \"If Bob reaches state <B, M>, then there is some Alice who previously sent the third message.\"\n\nend"]], "SPTHY-1/3.spthy": [[true, "theory Symmetric_Key_Exchange_Authentication\n\n  builtins: asymmetric-encryption, symmetric-encryption\n\n  functions:\n    pubKeyB/0\n\n    types:\n      Agent: A, B\n      Message: M\n      Key: K\n      Nonce: N\n\n  rules:\n\n    rule KeyGeneration_A:\n      [ Fr(K) ]\n      --[ Start(A, M) ]-->\n      let EncM = senc(K, M)\n      in\n      Out(EncM)\n\n    rule NonceExchange_B:\n      let EncM = senc(K, M)\n      in\n      In(EncM)\n      --[ ReceivedMessage(B, M) ]-->\n      Fr(N)\n      Out(N)\n\n    rule FinalKeyExchange_A:\n      In(N)\n      let EncK_N = aenc(pubKeyB, pair(K, N))\n      in\n      Out(EncK_N)\n\n  lemmas:\n\n    lemma authenticity:\n      \"All b t i. ReceivedMessage(b, M)@i ==> (Ex j. SentMessage(b, M)@j & j < i)\"\n\nend"]], "SPTHY-1/5.spthy": [[true, "// Tamarin formal analysis code for secure communication protocol\n\n// Define the protocol theory\ntheory SecureCommunication\n\n// Declaration of sorts for roles and keys\nsorts\n  Role\n  Key\n  Nonce\n  Message\n\n// Declaration of functions for encryption, hashing, and identity\nfunctions\n  pk(Role): Key          // Public key of a role\n  sk(Role): Key          // Secret key of a role\n  sym_key(Role, Role): Key // Symmetric key between two roles\n  hash(Message): Message // Hash function\n  encrypt(Message, Key): Message // Encryption function\n  identity(Role): Message // Identity function for roles\n\n// Declaration of initial knowledge as facts\nfacts\n  OwnKey(Role, Key, Key) // Own asymmetric key pair (pk, sk)\n  SymmetricKey(Role, Role, Key) // Shared symmetric key\n  PublicKey(Role, Key)  // Known public key of a role\n\n// Roles: Alice and Bob\nconstants\n  Alice, Bob: Role\n  k_A_B: Key\n\n// Define rules for the actions of Alice\nrules\n\n// Alice Step 1: Sends initial nonce message\n  rule AliceStep1:\n    [ Fr(n: Nonce) ]\n    --[ NewNonce(n), Send(p1_A) ]->\n    [ Out(encrypt(<identity(Alice), identity(Bob), n, hash(n)>, sym_key(Alice, Bob))) ]\n\n// Alice Step 2: Receives response message and processes\n  rule AliceStep2:\n    [ In(encrypt(m: Message, sym_key(Alice, Bob))) ]\n    --[ ReceiveResponse(m), Send(p2_A) ]->\n    [ ]\n\n// Alice Step 3: Commitment to transaction\n  rule AliceStep3:\n    [ In(encrypt(m: Message, sym_key(Alice, Bob))) ]\n    --[ Send(p3_A) ]->\n    [ Out(encrypt(hash(m), sym_key(Alice, Bob))) ]\n\n// Define rules for the actions of Bob\nrules\n\n// Bob Step 1: Receives Alice's initial message\n  rule BobStep1:\n    [ In(encrypt(<identity(Alice), identity(Bob), n: Nonce, h_n: Message>, sym_key(Alice, Bob))) ]\n    --[ ReceiveNonce(n, h_n), Send(p1_B) ]->\n    [ ]\n\n// Bob Step 2: Sends encrypted response message\n  rule BobStep2:\n    [ Fr(m: Message) ]\n    --[ SendResponse(m), Send(p2_B) ]->\n    [ Out(encrypt(m, sym_key(Bob, Alice))) ]\n\n// Bob Step 3: Processes hash of Alice's message\n  rule BobStep3:\n    [ In(encrypt(h_m: Message, sym_key(Bob, Alice))) ]\n    --[ VerifyIntegrity(h_m), Send(p3_B) ]->\n    [ ]\n\n// Security lemma definition: Aliveness\nlemmas\n  aliveness: All role: Role. exists partner: Role. Exists n: Nonce. Send(p3_A) @ role --> Exists m: Message. NewNonce(n) @ partner"]], "SPTHY-1/asw.spthy": [[true, "// Protocol: Asymmetric Secure Message Exchange Protocol (ASW)\n\n// Key Generation and Message Encryption/Decryption\nfunctions: \n  aenc/2\n  adec/2\n  hash/1\n\nequations: \n  adec(aenc(m, K), pk(sk)) = m\n\n// Initial Knowledge\nknowledge: \n  init(A) := {pkA, skA, pkB, m}\n  init(B) := {pkB, skB, pkA}\n\n// Role Definitions\nrule asw1_A:\n  let\n    m: Message,\n    n_1: Nonce\n  in\n  [\n    Fr(n_1)\n    Out(MsgA) := aenc(<pkA, pkB, m, hash(n_1)>, pkB)\n  ]\n\nrule asw2_A:\n  let\n    beta: Message\n  in\n  [\n    In(beta)\n    Out(n1A) := #(n_1)\n  ]\n\nrule asw3_A:\n  let\n    n_2: Nonce\n  in\n  [\n    Fr(n_2)\n    Out(MsgA2) := aenc(<n_2, m>, pkB)\n  ]\n\nrule asw1_B:\n  let\n    beta: Message\n  in\n  [\n    In(beta)\n    Out(MsgB) := aenc(<pkB, hash(beta)>, pkA)\n  ]\n\nrule asw2_B:\n  let\n    n_2: Nonce\n  in\n  [\n    Fr(n_2)\n    Out(n2B) := #(n_2)\n  ]\n\nrule asw3_B:\n  let\n    n_1: Nonce\n  in\n  [\n    In(n1A)\n  ]\n\nrule asw4_B:\n  let\n    n_2: Nonce\n  in\n  [\n    Out(n2B) := #(n_2)\n  ]\n\n// Security Assertions\nlemma secrecy: \"All msg #m. Secret(m, asw) => !Loses(A) & !Loses(B)\"\n\nlemma weak_commitment_A: \n  \"Exists msg #m. Commit(A, m) => Bmsg(A, m)\"\n\nlemma strong_commitment_A: \n  \"Exists msg #m. Bmsg(A, m) => Commit(A, m)\"\n\nlemma weak_commitment_B: \n  \"Exists msg #m. Commit(B, m) => Bmsg(B, m)\"\n\nlemma strong_commitment_B: \n  \"Exists msg #m. Bmsg(B, m) => Commit(B, m)\""]], "SPTHY-1/asym.spthy": [[true, "/* Asymmetric Key Exchange Protocol in Tamarin */\n\ntheory AsymmetricKeyExchange\n\nbegin\n\n/* Types */\ndatatype pubkey\ndatatype privkey\ndatatype msg\ndatatype nonce\n\n/* Functions */\nfunctions \n  pk: privkey -> pubkey\n  sk: pubkey -> privkey\n  aenc: msg * privkey -> msg\n  adec: msg * pubkey -> msg\n\n/* Protocol Rules */\n\n/* Asymmetric Key Setup */\nrule Asymmetric_key_setup:\n  [ Fr(k_A) ]\n--[ ]-->\n  [ !PubKey(pk(k_A)), !PrivKey(sk(k_A)) ]\n\n/* Publish Public Keys */\nrule Publish_public_keys:\n  [ !PubKey(pk(k_A)) ]\n--[ ]-->\n  [ Out(pk(k_A)) ]\n\n/* Initialization of Knowledge */\nrule Init_Knowledge:\n  [ !PrivKey(sk(k_A)), !PubKey(pk(k_A)) ]\n--[ ]-->\n  [ !K_A(sk(k_A)), !K_A(pk(k_A)) ]\n\n/* Role A - Encrypt and Send Nonce */\nrule a1_A:\n  [ Fr(n) ]\n  --[ In(pk(k_A)) ]-->\n  [ Out(aenc(n, sk(k_A))) ]\n\n/* Role B - Decrypt and Acknowledge Nonce */\nrule a1_B:\n  [ In(aenc(n, sk(k_A))), !PubKey(pk(k_A)) ]\n  --[ ]-->\n  [ Out(adec(aenc(n, sk(k_A)), pk(k_A))) ]\n\n/* Security Lemma */\nlemma secret_message:\n  \"All n #i. Ex x. Aenc(x, sk(k_A))@i & Adecy(x, pk(k_A))@i => A(x)@i\"\n\nend"]], "SPTHY-1/AS_Concrete_RPC.spthy": [[true, "theory Secure_RPC_Protocol\n\n  begin\n\n  builtins: symmetric-encryption\n\n  types:\n    principal, nonce, key\n\n  consts:\n    A, B: principal\n    Na, Nb, N'b: nonce\n    Kab, K'ab: key\n    succ: nonce -> nonce\n    pred: nonce -> nonce\n\n  functions:\n    genKey: principal * principal -> key\n\n  equations:\n    inv(genKey(x,y)) = genKey(x,y)\n\n  rules:\n\n    // Step 1: A -> B: A, Na\n    Step1:\n      [ Fr(Na) ]\n      --[ Send_A_B(A, Na) ]->\n      [ Out(A, Na) ]\n\n    // Step 2: B -> A: {Na, K'ab}_Kab\n    Step2:\n      [ !Ltk(B, Kab), Fr(K'ab), In(A, Na) ]\n      --[ Send_B_A({Na, K'ab}_Kab), Generate_K'ab(K'ab) ]->\n      [ Out({Na, K'ab}_Kab) ]\n\n    // Step 3: A -> B: {Na}_{K'ab}\n    Step3:\n      [ In({Na, K'ab}_Kab), SymK(K'ab), In({Nb, K'ab}_Kab) ]\n      --[ Send_A_B({Na}_{K'ab}), Accept_K_ab(A, B, K'ab) ]->\n      [ Out({Na}_{K'ab}) ]\n\n    // Step 4: B -> A: Nb\n    Step4:\n      [ In({Na}_{K'ab}), SymK(K'ab), Fr(Nb) ]\n      --[ Send_B_A(Nb), Confirm_B(A, K'ab) ]->\n      [ Out(Nb) ]\n\n  lemmas:\n\n    lemma Secrecy_K'ab:\n      \"All K'ab. not(Lost_K'ab(K'ab)) --> K'ab_Secret(K'ab)\"\n\n    lemma InjectiveAgreement_A:\n      \"All A, B, Na, K'ab. \n       (Send_B_A({Na, K'ab}_Kab) @ x & Receive_A_B({Na}_{K'ab}) @ y) \n       --> A_Session(A, B, K'ab, x, y)\"\n\n    lemma InjectiveAgreement_B:\n      \"All B, A, Na, Nb, K'ab. \n       (Receive_A_B({Na}_{K'ab}) @ x & Send_B_A(Nb) @ y) \n       --> B_Session(B, A, K'ab, x, y)\"\n\n  end"]], "SPTHY-1/axiom_test_symmetric.spthy": [[true, "functions:\n    enc/2\n    dec/2\n\nequations:\n    dec(enc(m, k), k) = m\n\nrules:\n    // Rule for basic symmetric encryption\n    rule Out_enc:\n        let\n            k = fresh_k\n        in\n            out(enc(k, k)) // output encrypted message\n            |- (enc(k, k), k)  // knowledge of encryption and key\n\n    // Rule for symmetric encryption with two fresh keys\n    rule Out_enc_twice:\n        let\n            k = fresh_k,\n            k2 = fresh_k2\n        in\n            out(enc(k, k2)) // output encrypted message\n            out(enc(k, k))  // output encrypted message with itself\n            |- (enc(k, k2), enc(k, k), k, k2)  // knowledge of encryptions and keys\n\nrestrictions:\n    restriction crazy:\n        \"No action in left context under previous actions\":\n        forall i m1 k1 m2 k2. Left(i) & Action(i) =! m1 k1 m2 k2."]], "SPTHY-1/BP_ABSTRACT_IBE_toyExample.spthy": [[true, "theory IBE_Toy_Example\n\n% --- Types ---\ntypes\n  User, Challenge, Response\n\n% --- Functions ---\nfunctions\n  pub(User): PublicKey\n  sk(User, PrivateKey): PrivateKey\n  enc(PublicKey, Message): Ciphertext\n  dec(PrivateKey, Ciphertext): Message\n\n% --- Axioms ---\naxioms\n\n% --- Rules ---\n\nrule Alice_Creates_Challenge:\n  [ Fr(~n), Fr(~challenge) ]\n--[ Start(Alice, ~n) ]->\n  [ Sent(Alice, enc(pub(Bob), ~challenge)) ]\n\nrule Bob_Responds:\n  [ !Sent(Alice, ?c), Fr(~response) ]\n--[ Receive(Bob, ?c) ]->\n  [ Sent(Bob, enc(pub(Alice), dec(sk(Bob, privKey), ?c) + ~response)) ]\n\nrule Alice_Verifies_Response:\n  [ !Sent(Bob, ?r), !Sent(Alice, ?c) ]\n--[ Receive(Alice, ?r), Verify(Alice, dec(sk(Alice, privKey), ?r) = dec(sk(Bob, privKey), ?c) + ~response) ]->\n  [ Commit(Alice, Bob, ~challenge) ]\n\n% --- Lemmas ---\n\nlemma Challenge_Secrecy:\n  \"All x #i. Not(Sent(Alice, x) @ i) |- <Challenge(x)> @ i\"\n\nlemma NonInjectiveAgreement_Alice_Bob:\n  \"Exists x #i. Sent(Alice, x) @ i ==> Exists y #j. Sent(Bob, y) @ j\"\n\n% --- Restrictions ---\nrestriction NonReveal:\n  \"All x #i. Reveal(x) @ i ==> False\"\n\n% --- Compromise rules ---\n\nrule Reveal_Master_Key:\n  [ !Reveal(privKey) ]\n--[ Compromise(MasterKey) ]->\n  [ !Compromised(MasterKey) ]\n\nrule Reveal_User_Key:\n  [ !Reveal(sk(User, privKey)) ]\n--[ Compromise(User) ]->\n  [ !Compromised(User) ]\n\nend theory"]], "SPTHY-1/CCITT-X509-R.spthy": [[true, "theory CCITT_X509\n\nbegin\n\n// Define sorts\nsort principal, text, key\n\n// Define free variables\nfree variables\n  A, B, I : principal\n  Na, Nb, Ta, Tb : text\n  Ya, Yb, Xa, Xb : text\n  SK_A, SK_B : key\n  PK_A, PK_B : key\n\n// Define functions\nfunctions\n  pk, sk : principal -> key\n  enc : key * text -> text\n  sign : key * text -> text\n  h : text -> text\n\n// Axioms\nequations\n  pk(A) = PK_A\n  pk(B) = PK_B\n  sk(A) = SK_A\n  sk(B) = SK_B  \n\n// Define rules: Message sending from A to B\nrule Send_A_to_B:\n  [ Fr(Ta), Fr(Na), Fr(Xa), Fr(Ya) ]\n--[ !Send(A, B, {Ya}pk(B), {h(Ta, Na, B, Xa, {Ya}pk(B))}sk(A)) ]->\n  [ Out(<A, Ta, Na, B, Xa, enc(pk(B), Ya), sign(sk(A), h(Ta, Na, B, Xa, enc(pk(B), Ya)))>) ]\n\n// Define rules: Message reception at B\nrule Receive_B:\n  let Msg = <A_i, Ta_i, Na_i, B_i, Xa_i, EYa_i, Sig_i> in\n  In(Msg)\n  --[ !Receive(A_i, B_i) ]->\n  [ !Secret(EYa_i)\n  , If (Sig_i = sign(sk(A_i), h(Ta_i, Na_i, B_i, Xa_i, EYa_i))) then In(<A_i, Ta_i, Na_i, B_i, Xa_i, EYa_i>) else In(<>) ]\n\n// Lemma: Confidentiality of Ya\nlemma Conf_Ya:\n  \"All x #i. Exists A_i, Ta_i, Na_i, B_i, Xa_i, Ya_i. \n      (Receive(A_i, B_i) @i) & \n      (Secret(enc(pk(B_i), Ya_i)) @i) & \n      not (A_i = I)\"\n\n// Lemma: Authenticity of Data\nlemma Auth_Xa_Ya:\n  \"All x #i. Exists A_i, B_i, Ta_i, Na_i, Xa_i, Ya_i.\n      (Receive(A_i, B_i) @i) & \n      (!Send(A_i, B_i, enc(pk(B_i), Ya_i), sign(sk(A_i), h(Ta_i, Na_i, B_i, Xa_i, enc(pk(B_i), Ya_i)))) @i) -> \n      (Valid(Sig_i, Msg_i) @i)\"\n\nend"]], "SPTHY-1/CH07.spthy": [[true, "theory RFID_Protocol\n\ntypes\n  Agent\n  Message\n  Nonce\n\nfunctions\n  hash: Message, Message, Message -> Message\n  hmac: Agent, Message, Message -> Message \n\nconsts\n  R: Agent\n  T: Agent\n  k: Message\n  ID: Message\n\nfacts\n  Init: Agent\n  Received: Agent, Message\n\nrules\n\n  rule Reader_Initialization:\n    let r1 = fresh() in\n    [ Fr(r1) ] --[ Init(R) ]-> [ Out(<R,r1>) ]\n\n  rule Tag_Response:\n    let r1 = in\n        r2 = fresh() in\n    [ In(<R,r1>) ]\n    --[ Init(T) ]->\n    [ Out(<T,r2,hash(ID,r1,r2)>) ]\n\n  rule Reader_Verification:\n    let \n        r1 = in,\n        r2 = in,\n        hval = in in\n    [ In(<T,r2,hval>), Out(<R,r1>) ]\n    --[ Received(R,<T,r2,hval>) ]->\n    [ If hval = hash(ID,r1,r2) then Out(<R,r1,r2>) else Fr(r1) ]\n\n  rule Tag_Confirmation:\n    let \n        r1 = in,\n        r2 = in in\n    [ In(<R,r1,r2>) ]\n    --[ Received(T,<R,r1,r2>) ]->\n    [ If r1 != r2 then Fr(r2) ]\n\nlemmas\n  lemma recent_aliveness:\n    \"forall R T. Exists r1 r2. \n      Init(R) @i & \n      Init(T) @j & \n      Received(T,<R,r1,r2>) @k\n    ==> k > i & k > j\"\n\n  lemma agreement:\n    \"forall R T. Exists r1 r2. \n      Init(T) @i & \n      Received(R,<T,r2,hash(ID,r1,r2)>) @j\n    ==> Exists <R,r1,r2>. \n      Received(T,<R,r1,r2>) @k \n    \"\n\nend"]], "SPTHY-1/CHx.spthy": [[true, "theory SecureCommunicationProtocol\n\nbegin\n\n  // Declare relevant functions and sorts\n  builtins: functions, hashing\n\n  // Declare free public sorts\n  free sort Reader, Tag\n  free type ID, Key, Nonce, Hash\n\n  // Declare private sorts for modeling roles\n  private type RoleState: enum { init, challenge_sent, response_received, verified }\n\n  // Declare constants for roles, keys and nonces\n  free name Reader_:Reader\n  free name Tag_:Tag\n  free name k:Key\n  free name id:ID\n\n  // Declare a protocol variable for nonces\n  private name r1, r2:Nonce \n\n  // Protocol rules\n\n  // Setup rule: establishing initial state and knowledge\n  rule Setup:\n    let\n      initKey = k\n    in\n    [\n      Fr(k), Fr(id)\n    ]\n    --[ Init(Reader_, k, id), Init(Tag_, k, id) ]->\n\n  // Reader initiation: sends challenge with r1\n  rule reader1:\n    let\n      r1_nonce = r1\n    in\n    [ State(Reader_, init) ]\n    --[ Generate(r1_nonce), Send(Reader_, r1_nonce) ]->\n    [ State(Reader_, challenge_sent) ]\n\n  // Tag response: receives nonce r1 and sends back hash and r2\n  rule tag1:\n    [ State(Tag_, init), In(?m) ]\n    --[\n         !Receive(?m), \n         FreshNonce(r2), \n         HashCalculation(Reader_, Tag_, ?m, r2, h) \n       ]->\n    [\n      State(Tag_, response_sent),\n      Out(!<h, r2>)\n    ]\n\n  // Reader verification: checks received hash\n  rule reader2:\n    [ State(Reader_, challenge_sent), In(<?hash, ?nap>) ]\n    --[\n         !Receive(?hash),\n         HashCheck(?hash, Reader_, Tag_, r1, ?nap)\n       ]->\n    [\n      State(Reader_, verified),\n      Out(Alive_Response)\n    ]\n\n  // Tag final confirmation: state transition after reader response\n  rule tag2:\n    [ State(Tag_, response_sent), In(Alive_Response) ]\n    --[\n         !Verify(Reader_, Tag_),\n         !ConfirmReceipt(Tag_)\n       ]->\n    [\n      State(Tag_, verified)\n    ]\n\n  // Lemmas\n  lemma Recent_Alive_Tag:\n    \"All tagAlive @i. (Ex readerSent @j. (j < i) & State(Tag_, response_sent) @j) \"\n\n  lemma Recent_Alive_Reader:\n    \"All readerAlive @i. (Ex tagResponse @j. (j < i) & State(Reader_, challenge_sent) @j) \"\n\n  lemma Executable_Trace:\n    \"Ex trace. (State(Reader_, verified) @k, State(Tag_, verified) @l, k < l) \"\n\n  // Attack detection mechanism - placeholder for potential attack vectors\n  // Attack definition optional\n\nend"]], "SPTHY-1/chen_kudla-1.spthy": [[true, "theory ChenKudla\n\nbegin\n\n// Define the initial facts\nfunctions\n  genMSK:         -> ssk    // Master Secret Key generation\n  genMPK: ssk    -> pubKey // Master Public Key generated from MSK\n  genLTK: id, ssk -> ltk   // Long-term key derived from identity and MSK\n\n  // Ephemeral key generation by the parties\n  genEphk:        -> eKey\n  computeX: eKey -> pubKey  // Compute public ephemeral key X \n  computeY: eKey -> pubKey  // Compute public ephemeral key Y \n\n  // Session key derivation\n  deriveSessk: ltk, pubKey, pubKey, pubKey -> sessKey\n\nfacts\n  // Key reveal operations\n  RevealLTK: ltk\n  RevealEphk: eKey\n  RevealMSK: ssk\n  RevealSessk: sessKey\n\n  // Key exchange steps\n  Init_1: id, eKey, pubKey\n  Init_2: id, pubKey\n  Resp_1: pubKey, id, eKey, pubKey, sessKey\n  SessionKey: pubKey, sessKey\n\nrules\n  // Master key setup by KGC\n  [KGC_Init]\n  -->\n  let msk = genMSK(), mpk = genMPK(msk) in\n  Out(mpk)\n\n  // Party A initializes the key exchange\n  [A_Init_1]\n  -->\n  let ex = genEphk(), x = computeX(ex), ltkA = genLTK('A', msk) in\n  Init_1('A', ex, x) /\\\n  Out(x)\n\n  // Party B receives X and initializes its response and computes session key\n  [B_Resp_1]\n  let x = [ pubKey ] // received public key X from A\n  -->\n  let ey = genEphk(), y = computeY(ey), ltkB = genLTK('B', msk) in\n  let sessk = deriveSessk(ltkB, x, y, mpk) in\n  Resp_1(x, 'B', ey, y, sessk) /\\\n  Out(y) /\\ Out(SessionKey(y, sessk))\n\n  // Party A finalizes and derives its session key post receiving Y\n  [A_Init_2]\n  let y = [ pubKey ] // received public key Y from B\n  -->\n  let sessk = deriveSessk(ltkA, x, y, mpk) in\n  SessionKey(x, sessk)\n\nequations\n  // Define the behavior of concat and deriveSessk\n  deriveSessk(genLTK(A, msk), X, Y, mpk) = deriveSessk(genLTK(B, msk), X, Y, mpk)\n\nlemmas\n  // Key secrecy and reachability conditions\n  KeyAgreement:\n    \"All c x y #i #idA #idB. \n      (SessionKey(c, x) @ i) => \n      (Ex msk. (Out(msk) @ idA & Out(msk) @ idB))\"\n\n  KeySecrecy:\n    \"All sessk #i. \n      (Out(RevealSessk(sessk)) @ i) => \n      (Ex ephk. (RevealEphk(ephk) @ i))\"\n\nend"]], "SPTHY-1/CombinedHPED.spthy": [[true, "theory Hash_Enc_Dec_Protocol\n\nbegin\n\n// Declaring free sort for agents and messages\nfree message: type\nfree agent: type\n\n// Functions for hashing, encryption, decryption, and public key operations\nfunctions\n    h: message -> message\n    aenc: message * message -> message\n    adec: message * message -> message\n    pk: message -> message\n\n// Declaring public constants representing public values\nbuiltins: constants\n    $A: message\n    $B: message\n\n// Equations for decryption, ensuring that decrypting an encrypted message retrieves the original message\nequations\n    adec(aenc(m, pk(k)), k) = m\n\n// Initial State\nrules\n\n// Rule for outputting the hash of a fresh long-term key\nrule Out_Hash:\n    let\n        ltk = ~ltk\n    in\n    [ Fr(ltk) ]\n    --[ LtkSecret(ltk) ]-->\n    [ Out(h(ltk)) ]\n\n// Rule for outputting public values\nrule Out_pub:\n    [ ]\n    --[ PublicOutput($A, $B) ]-->\n    [ Out($A), Out($B) ]\n\n// Rule for managing encryption of the difference of public values with a fresh key\nrule Out_Enc:\n    let\n        ltk = ~ltk\n        diff = diff($A, $B)\n    in\n    [ Fr(ltk) ]\n    --[ EncodedDiff(ltk, diff) ]-->\n    [ Out(aenc(diff, pk(ltk))), Out(ltk) ]\n\n// Rule for managing decryption given the long-term key and encrypted message\nrule Out_Dec:\n    let\n        m = adec(c, ltk)\n    in\n    [ In(c), LtkSecret(ltk) ]\n    --[ Decoded(ltk, m) ]-->\n    [ Out(m) ]\n\n// Lemma to assert no traces of protocol difference output\nlemma Diff_test:\n    \"All m. not(tau(EncodedDiff(~k, m)))\"\n\n// Lemma ensuring no traces of specific conditions\nlemma Diff_test2:\n    \"All n. not(tau(Decoded(~lt, n)))\"\n\n// Lemma asserting confidentiality of the long-term key\nlemma Ltk_secret:\n    \"All k. (Ex i. LtkSecret(k)@i) ==> not LtkPublic@i\"\n\n// Lemma ensuring only appropriate conditions are met during message exchange\nlemma Types:\n    \"All c. (In(c) ==> (Ex i. (Out($A)@i or Out($B)@i)))\"\n\nend"]], "SPTHY-1/correct.spthy": [[true, "theory DiffieHellman begins\n\nconst g: pub\n\nfree roleA, roleB: agent\n\nfree sk: skey\nfree pk: pkey\n\nfunctions \n  exp/2: key\n  senc: msg * skey -> msg\n\nrules\n\n// Alice's Key Generation\nlet Abram: roleA,\n    skA = sk(Abram),\n    pkA = exp(g, skA)\nin\n  Rule_Alice_Start:\n    [ Fr(na) ] --[ GenKey(Abram, pkA) ]-> [ St_init_A(Abram, pkA) ]\n\n// Bob's Key Generation\nlet Bman: roleB,\n    skB = sk(Bman),\n    pkB = exp(g, skB)\nin\n  Rule_Bob_Start:\n    [ Fr(nb) ] --[ GenKey(Bman, pkB) ]-> [ St_init_B(Bman, pkB) ]\n\n// Alice sends her public value\nlet Abram: roleA,\n    Bman: roleB,\n    pkA = exp(g, Abram),\n    gx_A = exp(g, sk(Abram))\nin\n  Send_Alice_To_Bob:\n    [ St_init_A(Abram, pkA) ] --[ SendPublicA(Abram, Bman, gx_A) ]->\n    [ St_dh_1_A(Abram, gx_A) ]\n\n// Bob sends his public value and computes shared secret\nlet Abram: roleA,\n    Bman: roleB,\n    gx_A = exp(g, sk(Abram)),\n    gy_B = exp(g, sk(Bman)),\n    sharedAB_B = exp(gx_A, sk(Bman))\nin\n  Receive_From_Alice_And_Send_Bob:\n    [ St_init_B(Bman, gy_B) ] --[ ReceivePublicA_SendPublicB(Bman, gx_A, gy_B) ]->\n    [ St_dh_1_B(Bman, gy_B), SharedSecret_B(Bman, sharedAB_B) ]\n\n// Alice computes shared secret\nlet Abram: roleA,\n    Bman: roleB,\n    gy_B = exp(g, sk(Bman)),\n    sharedAB_A = exp(gy_B, sk(Abram))\nin\n  Receive_From_Bob_Alice:\n    [ St_dh_1_A(Abram, _), In(Receive(gy_B)) ] --[ ComputeShared_A(Abram, sharedAB_A) ]->\n    [ SharedSecret_A(Abram, sharedAB_A) ]\n\n// Secure communication\nlet sharedSecret: key\nin\n  Secure_Comm:\n    [ SharedSecret_A(Abram, sharedSecret), SharedSecret_B(Bman, sharedSecret) ]\n      --[ SecureComm(Abram, Bman, senc(\"Message\", sharedSecret)) ]-> []\n\n// Lemmas for secrecy\nlemma secrecy_of_shared_key: \"AllOld {A,Bm}. (I_If (Ex gSE.volume) (not precedes SecureComm(A, Bm, gSE.volume)) (Never observed(gSE.volume)))\"\n\nend"]], "SPTHY-1/cr-1.spthy": [[true, "// Functions\nfunctions:\n    pk/1, sk/1: Key\n    aenc/2: Message, Key -> Ciphertext\n    adec/2: Ciphertext, Key -> Message\n    hash/1: Message -> Hash\n    fresh/0: -> Nonce\n\n// Initial knowledge\ninitial knowledge:\n    C : pk(R), sk(C), pk(C)\n    R : pk(C), sk(R), pk(R)\n\n// Rules\n\n// Client Role\nrule cr1_C:\n  let n = fresh()\n  in\n  [\n    Fr(n) // Generate fresh nonce\n  ]\n  --[\n    // Properties for authenticity and secrecy can be added here\n  ]-->\n  [\n    Out(aenc(n, pk(R))) // Send encrypted nonce to R\n  ]\n\nrule cr2_C:\n  let \n    m = adec(EncryptedNonce, sk(C))\n    hashed_m = hash(m)\n  in\n  [\n    In(hash(Nonce)) // Receive hash of nonce\n  ]\n  --[\n    // Commitment to properties can be added here\n  ]-->\n  [\n    // Update state, commitments\n  ]\n\n// Responder Role\nrule cr1_R:\n  let n = adec(EncryptedNonce, sk(R))\n  in\n  [\n    In(aenc(Nonce, pk(R))) // Receive encrypted nonce from C\n  ]\n  --[\n    // Properties related to authenticity can be added here\n  ]-->\n  [\n    Out(hash(n)) // Send hash of the nonce back to C\n  ]\n\nrule cr2_R:\n  []\n  --[\n    // Commitment to properties of secrecy and authenticity\n  ]-->\n  [\n    // Update state, commitments\n  ]\n\n// Lemmas\n\nlemma n_secret:\n  \"All x. Not(Known(C, x) & Known(R, x))\"\n\nlemma n_secretC:\n  \"All x. K(C, x) => Not(K(R, x))\"\n\nlemma n_secretR:\n  \"All x. K(R, x) => Not(K(C, x))\"\n\nlemma authNonInj:\n  \"All n. Commit(C, n) => Ex n'. Auth(R, n') & Before(n', Commit(C, n))\"\n\nlemma authInj:\n  \"All n. Commit(C, n) => Ex n'. Auth(R, n') & Unique(n')\"\n\n// End Protocol"]], "SPTHY-1/Cronto_MA.spthy": [[true, "theory Cronto_MA\n\n  builtins:\n    signing\n    asymmetric-encryption\n    hashing\n    symmetric-encryption\n\n  functions:\n    otpw/1\n    m/1\n\n  types:\n    Agent\n    Message\n\n  consts:\n    H, D, S, P: Agent\n\n  rules:\n\n    // Rule for Setup Phase\n    Setup:\n      [ Fr(aKey), Fr(sKey), Fr(ctxt) ]\n    -->\n      [ State(H, SharedSecret(aKey)),\n        State(D, SharedSecret(sKey)),\n        State(S, Context(ctxt)),\n        State(P, Init) ]\n\n    // Rule for Message Exchange Phase\n    Exchange:\n      \u2200 msg, otp, id #freshNonce\n      [ In(trustedChannel, msg = otpw(otp), m(id)),\n        State(H, Active) ]\n    -->\n      [ Out(insecureChannel, <msg, otp>),\n        State(D, Received(msg, otp, id)) ]\n\n    // Rule for Device Response Phase\n    DeviceResponse:\n      \u2200 msg, otp, id, token #newToken\n      [ State(D, Received(msg, otp, id)) ]\n    -->\n      [ Out(trustedChannel, <msg, token>),\n        State(D, AuthToken(token)) ]\n\n    // Rule for Server Verification Phase\n    ServerVerify:\n      \u2200 msg, otp, token\n      [ In(trustedChannel, <msg, token>),\n        State(S, Context(ctxt)) ]\n    -->\n      [ State(S, Verified(msg, otp)) ]\n\n    // Rule for Human Agent Verification Phase\n    HumanVerify:\n      \u2200 token\n      [ In(trustedChannel, <msg, token>),\n        State(H, AwaitAuth) ]\n    -->\n      [ Out(trustedChannel, token),\n        State(H, Authenticated) ]\n\nlemmas:\n  \n  // Functional Lemma\n  Functionality:\n    \"All agents successfully execute setup and message exchange resulting in valid interactions.\"\n\n  // Message Authentication Lemma\n  AuthTokenTrace:\n    \"All tokens committed by the server can be traced back to a message sent by a human agent.\"\n\nend"]], "SPTHY-1/CRxor.spthy": [[true, "theory Challenge_Response_XOR begins\n\n// Declare types for participants and nonces\nfree type Agent\nfree type Nonce\n\n// Function to model hashes\nfree function h: message -> message\n\n// Function to model XOR operation\nbuiltins: xor\n\n// Define the shared secret key k\nconst k: message\n\n// Rules for protocol steps\n\nrule Setup:\n  [ Fr(~ltkey) ]\n--[ InitLTK(~ltkey) ]\n-> [ !Ltk('A', ~ltkey), !Ltk('B', ~ltkey) ]\n\nrule Challenge:\n  [ Fr(~na), !Ltk('A', k) ]\n--[ Isent('A', 'B', ~na) ]\n-> [ Out(<'A', 'B', ~na>) ]\n\nrule Response:\n  let r = h(~na xor k xor ~nb)\n  [ !Ltk('B', k), In(<'A', 'B', ~na>), Fr(~nb) ]\n--[ Irecv('A', 'B', ~na), Isent('B', 'A', r), Isent('B', 'A', ~nb) ]\n-> [ Out(<r, ~nb>) ]\n\nrule Verify:\n  let r = h(~na xor k xor ~nb)\n  [ !Ltk('A', k), In(<r, ~nb>), In(<'A', 'B', ~na>) ]\n--[ Irecv('B', 'A', r), Irecv('B', 'A', ~nb) ]\n-> [ True ]\n\n// Security properties\n\nlemma Alive:\n  \"All A B na nb #i. Exists r. (Irecv('A', 'B', na) @ i & Isent('B', 'A', r) @ i) ==> True\"\n\nlemma Recent_Alive_Tag:\n  \"All A B na #i. (Isent('A', 'B', na) @ i) ==> (Exists nb r. Irecv('B', 'A', r) @ i & Isent('B', 'A', r) @ i & Isent('B', 'A', nb) @ i)\"\n\nlemma Executable:\n  \"Exists A B na nb k. (InitLTK(k) & Isent('A', 'B', na) & Isent('B', 'A', h(na xor k xor nb)))\"\n\nend"]], "SPTHY-1/dh_alternative.spthy": [[true, "// Diffie-Hellman Protocol in Tamarin\n\n// Types for terms\ntype term\n\n// Functions\nfunctions\n    pk/1: term -> term\n    sk/1: term -> term\n    aenc/2: term * term -> term\n    adec/2: term * term -> term\n    diffie-hellman/2: term * term -> term\n    symmetric-encryption/2: term * term -> term\n\n// Equations\nequations\n    adec(aenc(x1, sk(x2)), pk(x2)) = x1\n    adec(aenc(x1, pk(x2)), sk(x2)) = x1\n\n// Rules\nrules\n\n// Asymmetric Key Setup\nasym_key_setup_A:\n    [ Fr(~privateKeyA) ]\n    -->\n    [ !GenKeysA(pk(~privateKeyA), ~privateKeyA) ]\n\nasym_key_setup_B:\n    [ Fr(~privateKeyB) ]\n    -->\n    [ !GenKeysB(pk(~privateKeyB), ~privateKeyB) ]\n\n// Publish Public Keys\npublish_key_A_to_B:\n    [ !GenKeysA(pk(~privateKeyA), ~privateKeyA) ]\n    -->\n    [ Out(pk(~privateKeyA)) ]\n\npublish_key_B_to_A:\n    [ !GenKeysB(pk(~privateKeyB), ~privateKeyB) ]\n    -->\n    [ Out(pk(~privateKeyB)) ]\n\n// Symmetric Key Setup\nsym_key_setup:\n    [ Fr(~symKey) ]\n    -->\n    [ !SymKey(~symKey) ]\n\n// Role A\ndh_1_A:\n    [ Fr(~x) ]\n    -->\n    [ Out(diffie-hellman(g, ~x)) ]\n\ndh_2_A:\n    [ In(alpha) ]\n    -->\n    [ ]\n\ndh_3_A:\n    [ Fr(~n), In(diffie-hellman(g, ~x)) ]\n    -->\n    [ Out(symmetric-encryption(diffie-hellman(alpha, ~x), ~symKey)) ]\n\n// Role B\ndh_1_B:\n    [ In(alpha) ]\n    -->\n    [ ]\n\ndh_2_B:\n    [ Fr(~y) ]\n    -->\n    [ Out(diffie-hellman(g, ~y)) ]\n\ndh_3_B:\n    [ In(symmetric-encryption(diffie-hellman(alpha, ~y), ~symKey)) ]\n    -->\n    [ ]\n\n// Security Lemmas\nlemmas\n    key_secret:\n        All x. Secret(x) ==> not SharedSecret(x)\n\n    key_secretA:\n        All x. SecretA(x) ==> not KnownToA(x)\n\n    key_secretB:\n        All x. SecretB(x) ==> not KnownToB(x)"]], "SPTHY-1/ex1-2.spthy": [[true, "# Define the initial setup for the public keys\nrule PubKey:\n  [ Fr(ska) ]\n--[ !PubKey(pk(ska)) ]-->\n  [ Out(pk(ska)) ]\n\n# Define the compromise rule where Alice's secret key is leaked\nrule Compromise:\n  [ !PubKey(pk(ska)) ]\n--[ !Compromise(ska) ]-->\n  [ Out(ska) ]\n\n# Represent Alice's action of sending a secure message to Bob\nrule AliceSends:\n  [ Fr(ma), Fr(kAB) ]\n--[ !AliceSent(ma, kAB) ]-->\n  [\n    Out(<'A', aenc(kAB, pkB), senc(<ma, sign(ma, ska)>, kAB)>)\n  ]\n\n# Represent Bob's action of receiving and processing Alice's message\nrule BobReceived:\n  [ In(<'A', aenc(kAB, pkB), senc(<ma, sign(ma, ska)>, kAB)>) ]\n--[ !BobCompleted(ma) ]-->\n  [\n    Out(senc(mb, kAB)),\n    In({fr_mb})\n  ]\n\n# Define the action where Alice receives Bob's response\nrule AliceReceives:\n  [ In(senc(mb, kAB)) ]\n--[ !SessionComplete(mb) ]-->\n  []\n\n# Specify the restrictions to ensure protocol correctness\nrestriction EqualityRestriction:\n  All x y. (x = y) ==> (x == y)\n\n# Define properties to be checked in the protocol execution\nlemma executable:\n  \"Exists Trace !AliceSent(ma, kAB) & !BobCompleted(ma) & !SessionComplete(mb)\"\n\nlemma secrecyA:\n  \"All ma. (Secret(Alice, ma, Event !BobCompleted(ma))) ==> \n  ( (Event !Compromise(ska)) | !Secret(Alice, ma) )\"\n\nlemma secrecyB:\n  \"All mb. (Secret(Bob, mb, Event !SessionComplete(mb))) ==> \n  ( (Event !Compromise(skb)) | !Secret(Bob, mb) )\""]], "SPTHY-1/exADH-kn.spthy": [[true, "theory ExerciseADH\n\nbegin\n\n  builtins: \n    diffie_hellman\n\n  functions:\n    sk    : ltk -> key\n    pk    : ltk -> key\n    enc   : message * key -> message\n    dec   : message * key -> message\n\n  rules:\n\n    rule Ltk:\n      [ Fr(~ltk) ]\n      --[ GenKeys($id, pk(~ltk), sk(~ltk)) ]->\n      [ Ltk($id, ~ltk) ]\n\n    rule A_Init:\n      [ Ltk(A, ltk_A), !(Ltk(B, ltk_B)) ]\n      --[ Send(A, B, m1(A, pk(ltk_A), B)) ]->\n      [ State_A1(A, pk(ltk_A), B) ]\n\n    rule B_Init:\n      [ In(m1(A, pk(~ltk_A), B)), Ltk(B, ltk_B) ]\n      --[ Send(B, A, m2(pk(ltk_B))) ]->\n      [ State_B1(B, sk(ltk_B), pk(~ltk_A)) ]\n\n    rule A_SendMsg:\n      [ In(m2(pk(~ltk_B))), State_A1(A, pk(ltk_A), B) ]\n      --[ Send(A, B, m3(enc(msg, DH(sk(~ltk_A), pk(~ltk_B))))) ]->\n      [ Out(m3(enc(msg, DH(sk(~ltk_A), pk(~ltk_B))))) ]\n\n  lemmas:\n\n    lemma SecrecyKeys:\n      \"All-traces secret(m3(enc(msg, DH(sk(~ltk_A), pk(~ltk_B)))))\"\n\n    lemma AgreementKeys:\n      \"All-traces Agreement($id, SharedKey_B_A)\"\n\nend"]], "SPTHY-1/final_protocol_and_property-2.spthy": [[true, "type Name\ntype Nonce\ntype Key\n\nfunctions\n    senc/2\n    h/1\n\nfreenames\n    Alice: Name\n    Bob: Name\n    kab: Key\n\nrules\n\n// Step 1 - Initiation by Alice (A)\nrule Initiate_Alice:\n    [ Fr(~n1: Nonce) ]\n    -->\n    [ Out(senc(<Alice, Bob, ~n1, h(~n1)>, kab)) ]\n\n// Step 2 - Response by Bob (B)\nrule Response_Bob:\n    let msg1 = senc(<Alice, Bob, ~n1, h(~n1)>, kab) in\n    [ In(msg1), Fr(~m: Nonce) ]\n    -->\n    [ Out(senc(<Bob, ~m, h(~n1)>, kab)) ]\n\n// Step 3 - Final Message by Alice (A)\nrule FinalMessage_Alice:\n    let msg2 = senc(<Bob, ~m, h(~n1)>, kab) in\n    [ In(msg2) ]\n    -->\n    [ Out(senc(<h(~m), h(~n1)>, kab)) ]\n\n// Step 4 - Completion by Bob (B)\nrule Completion_Bob:\n    let msg3 = senc(<h(~m), h(~n1)>, kab) in\n    [ In(msg3) ]\n    -->\n\nlemmas\n\n// Aliveness of Bob\nlemma Aliveness:\n    exists-trace\n    \"Exists m; NodeB2(m)\"   // Ensure that Bob commits and sends his response"]], "SPTHY-1/final_protocol_and_property-5.spthy": [[true, "// Protocol Constants\nsymbols: \n  A, B: agent // Identities of the parties\n  M: msg     // Message to be sent\n  k_A_B: symmetric_key // Shared symmetric key\n\n// Functions\nfunctions:\n  senc: msg * symmetric_key -> msg\n\n// Protocol Description\n\n// Rules\n\nrule Initialize:\n  [ Fr(~k_A_B), Fr(~M) ]\n==>\n  [ State(A), State(B), State(M), SymKey(k_A_B) ]\n\nrule RoleA_SendNonce:\n  [ State(A), State(B), SymKey(k_A_B), Fr(~n) ]\n==>\n  [ Out(n) ]\n\nrule RoleB_ReceiveNonce:\n  [ In(n), State(B), State(A), SymKey(k_A_B) ]\n==>\n  [ Out(senc(n, k_A_B)) ]\n\nrule RoleA_SendMessage:\n  [ In(senc(n, k_A_B)), State(A), SymKey(k_A_B), State(M) ]\n==>\n  [ Out(senc(M, k_A_B)) ]\n\nrule RoleB_ReceiveMessage:\n  [ In(senc(M, k_A_B)), State(B), SymKey(k_A_B) ]\n==>\n  []\n\n// Lemmas\n\n// Freshness lemma to prevent replay attacks\nlemma Nonce_Freshness:\n  \"All n #i. (In(n) @ i => not (Exists j. Out(n) @ j & i != j))\"\n\nlemma Message_Confidentiality:\n  \"All M #i. (Out(senc(M, k_A_B)) @ i => not Ex(M))\""]], "SPTHY-1/CR.spthy": [[true, "theory AB_Secure_Communication imports\n  terms\n\nbegin\n\n/*--- Types ---*/\nfree-types \n  agent\n  hash\n\n/*--- Functions ---*/\nfunctions\n  h/3 // Hash function with three inputs\n  not/1\n\n/*--- Protocol Rules ---*/\n\n/* Setup Phase \n   A generates a secret key k and a fresh nonce na\n*/\nrule Init_A:\n  [ Fr(na) ]\n  --[ Challenge(na) ]->\n  [ Out(na) ]\n\n/* Response Phase \n   B receives the nonce na, and responds with a new nonce nb and a hash of (na, k, nb)\n*/\nrule Response_B:\n  let k = not(0) in\n  [ In(na), Fr(nb) ]\n  --[ Response(na, nb) ]->\n  [ Out(<h(na, k, nb), nb>) ]\n\n/* Verification at A \n   A receives the response from B and verifies the hash value\n*/\nrule Verify_A:\n  let k = not(0) in\n  [ In(<h(na, k, nb), nb>) ]\n  --[ Alive(na, nb) ]->\n  []\n\n/*--- Security Goals using Lemmas ---*/\n\n/* Alive Lemma: If there is an Alive(na, nb), Response(na, nb) must precede it */\nlemma Alive_Lemma:\n  \"All na #i nb #j. Alive(na, nb) @i ==> (Ex #k. Response(na, nb) @k & k < i)\"\n\n/* Recent Aliveness Lemma: There exists a response generated after the challenge */\nlemma Recent_Aliveness_Lemma:\n  \"All na #i. Challenge(na) @i ==> (Ex nb #j. Response(na, nb) @j & i < j)\"\n\n/* Executable Lemma: If there is a Challenge(na), eventually there will be an Alive for some nb */\nlemma Executable_Lemma:\n  \"All na #i. Challenge(na) @i ==> (Ex nb #j. Alive(na, nb) @j & i < j)\"\n\nend"]], "SPTHY-1/FirstAttestation.spthy": [[true, "definitions\n  [Verifier, Attester] : agent\n\nequations\n  // Define the usual cryptographic primitives\n  sign(skey, msg) = signed_msg\n  verify(pkey, signed_msg, msg) = true\n\nrules\n\n// Identity Creation Rule\nrule CreateIdentities_Verifier:\n  fresh skeyVerifier: skey\n  let pkeyVerifier = pk(skeyVerifier)\n  [ Fr(~ltkVerifier) ]\n  --[ Out(pkeyVerifier) ]-> \n  [ !Verifier(pkeyVerifier) ]\n\nrule CreateIdentities_Attester:\n  fresh skeyAttester: skey\n  let pkeyAttester = pk(skeyAttester)\n  [ Fr(~ltkAttester) ]\n  --[ Out(pkeyAttester) ]->\n  [ !Attester(pkeyAttester) ]  \n\n// Verifier sends Nonce to Attester\nrule Verifier_sends_Nonce_to_Attester:\n  fresh nonce: nonce\n  let verPKey = pk(~ltkVerifier)\n  [ !Attester(AttesterPKey), !Verifier(verPKey) ]\n  --[ Out(nonce) ]->\n  [ ]\n\n// Attester creates and sends EAT\nrule Attester_create_and_sends_EAT:\n  let attPKey = pk(~ltkAttester)\n  let eat = (nonce, attData)\n  let signedEAT = sign(~ltkAttester, eat)\n  [ In(nonce), !Verifier(VerifierPKey) ]\n  --[ Out(signedEAT) ]->\n  [ ]\n\n// Verifier receives and verifies EAT\nrule Verifier_receive_and_verify_EAT:\n  let VerPKey = pk(~ltkVerifier)\n  let AttPKey = pk(~ltkAttester)\n  let eat = (nonce, attData)\n  [ In(signedEAT), !Attester(AttPKey), !Verifier(VerPKey) ]\n  if verify(AttPKey, signedEAT, eat)\n  then\n  --[ Out(\"EAT Verified\")] -> \n  [ ]\n\nlemmas\n  // Lemma 1: Verifier can only verify an EAT sent by Attester\n  lemma AttesterAuthenticity:\n    \"All verPKey #i: Verifier(verPKey) @i ==> (Ex attPKey, signedEAT #j: AttesterCreate(attPKey, signedEAT) @j)\"\n\n  // Restriction on Equality Lemma\n  lemma RestrictEquality:\n    \"All x y #i: Equals(x, y) @i ==> (x = y)\"\n\n  // State-based Verification Lemma\n  lemma StateBasedVerification:\n    \"All attPKey #i: Attester(attPKey) @i ==> (Not CompromisedState(attPKey))\""]], "SPTHY-1/Google2Step_MA.spthy": [[true, "theory Google_2Step_Protocol\n\nbegin\n\n(* Declare sorts *)\ndatatype message\n\n(* Functions and public keys *)\nfun pk(secret): message\nfun sk(identity): message\nfun hash(message): message\nfun enc(message, pk): message\n\n(* Agent identities *)\nconst human, device, password_server, security_server: message\n\n(* Protocol messages *)\nfun pw(human): message\nfun code(device): message\nfun m(authenticated): message\n\nrules\n\n// Setup phase: Human securely sets up account on device\nrule Setup:\n  [ Fr(~sk_human), Fr(~sk_device) ]\n--[ !Setup(human, device) ]-> \n  [ Out(pw(human)), Out(code(device)) ]\n\nrule SetupComplete:\n  [ Fr(~code_shared), !Setup(human, device) ]\n--[ !SetupComplete(human, device) ]-> \n  [ Out(hash(code(device))) ]\n\n// Authentication phase: Human sends password\nrule SendPassword:\n  [ !SetupComplete(human, device), Fr(~pw_verified) ]\n--[ !TryAuth(human, device) ]-> \n  [ Out(enc(pw(human), pk(password_server))) ]\n\n// Password server verifies password\nrule VerifyPassword:\n  [ !TryAuth(human, device), Fr(~pw_valid) ]\n--[ !PasswordValid(human) ]->\n  [ Out(m(human)), Out(code(device)) ]\n\n// Device verifies code, completing authentication\nrule VerifyCode:\n  [ !PasswordValid(human), !SetupComplete(human, device) ]\n--[ !Authenticated(human) ]-> \n  [ Out(m(human)) ]\n\n(* Security properties *)\nlemma FunctionalityAssurance:\n  \"All x #i. (Ex #j. !Setup(x,$i) @j) ==> \n             (Ex #j. !Authenticated(x) @j)\"\n\nlemma MessageAuthentication:\n  \"All x #i. (Ex y #j. Out(m(x)) @j) ==> \n             (Ex #k. !Authenticated(x) @k)\"\n\nend"]], "SPTHY-1/HPagree.spthy": [[true, "// Define the basic HPagree protocol structure using Tamarin's spthy language\n\n// Protocol HPagree\ntheory HPagree\n\n// Functions\nfunctions\n    pk: Agent -> PubKey\n    sk: Agent -> PrivKey\n    sign: Message * PrivKey -> Signature\n    verify: Message * Signature * PubKey -> Bool\n    encrypt: Message * PubKey -> Cipher\n    decrypt: Cipher * PrivKey -> Message\n    hash: Message -> Hash\n    zero_knowledge_proof: Message * PubKey -> ZKP\n\n// Agents and initial knowledge\nletting\n    Agents = {a, b, c, h}\n    Honest = {a, b}\n    Keys = {pk(a), pk(b), pk(c), pk(h)}\n    InitialKnowledge = {\n        a: {pk(b), pk(c)},\n        b: {pk(a), pk(c)},\n        c: {pk(a), pk(b)},\n        h: {pk(a), pk(b), pk(c)}\n    }\n\n// Protocol rules\nrule SetupPhase:\n    /* Each agent initializes long-term keys */\n    [Fr(~n)]\n    -->\n    [!GenKeys(a), !GenKeys(b), !GenKeys(c), !GenKeys(h)]\n\nrule MessageExchange_IP1:\n    /* Infallible agent sends a signed and encrypted message */\n    [Fr(~m)]\n    -->\n    [Out(sign(encrypt(~m, pk(b)), sk(a)))]\n\nrule MessageExchange_RESP:\n    /* Infallible agent receives and verifies message */\n    [In(sign(encrypt(~m, pk(a)), sk(b))),\n     Verify(encrypt(~m, pk(a)), sign(encrypt(~m, pk(a)), sk(b)), pk(b)) = true]\n    -->\n    [Out(~m)]\n\nrule Commitment_IP2:\n    /* Agents commit to their messages */\n    [In(~m)]\n    -->\n    [Out(hash(~m))]\n\n// Lemmas\nlemma FunctionalProperty:\n    \"Ex a,b,m #i. In(m)@i & m = encrypt(pk(a), m)\"\n\nlemma AgreementProperty_agree_HE:\n    // Guarantees that if a commitment is made, the goal is claimed.\n    \"All a,m #i. (Commit(m)@i & Goal(m)@i) ==> Claims(a,m)@i\"\n\nlemma AgreementProperty_agree_HE2:\n    // Alternative for assurance\n    \"All a,m #i. (Commit(m)@i) ==> Claims(a,m)@i\"\n\nend"]], "SPTHY-1/InputOutput.spthy": [[true, "theory TestSimpleInputOutputMemorized\n\n  functions \n    h/1\n    aenc/2\n    adec/2\n    pk/1\n\n  equations\n    adec(aenc(m, pk(k)), k) = m\n  \n  rules\n\n    rule Initialize:\n      let \n        ~x \n      in\n        [ Fr(~x) ]\n      --[ TestInitLabel(~x) ]->\n        [ Out(~x) ]\n\n    rule Initialize2:\n      let \n        ~x \n      in\n        [ Fr(~x) ]\n      --[ TestInitLabel2(~x) ]->\n        [ Out(~x) ]\n\n    rule Register_pk:\n      let \n        ~ltk \n      in\n        [ Fr(~ltk), Fr(x), Test(diff(x,y)) ]\n      --[ Testlabel() ]->\n        [ Out(~ltk) ]\n\n  lemmas\n\n    lemma client_session_key_secrecy:\n      \"All x #i #j. (KU(#i, k) & KU(#j, k)) ==> False\"\n\n    lemma diff_test:\n      \"Ex #i. Testlabel()@#i\"\n\n    lemma diff_test_2:\n      \"All #i. not DiffProtoRegister_pk()@#i\"\n      \nend"]], "SPTHY-1/issue446-1.spthy": [[true, "theory MinimalExample\n\nbegin\n\nrule Rule_A:\n  []\n  ==>\n  [ A('x') ]\n\nlemma lemma_verified:\n  \"All x i. A(x) @ i ==> A(x) @ i\"\n\nlemma lemma_falsified:\n  \"All x i. A(x) @ i ==> A(x) @ i\"\n  [falsified]\n\nend"]], "SPTHY-1/issue519.spthy": [[true, "/* Source Computation Issue in Tamarin */\n\ntheory Source_Computation_Issue\n\nbuiltins: multiset\n\nfunctions: +/2\n\n/* Facts */\nmessages:\n  Secret_MsgVar/1\n  Secret_FreshVar/1\n\n/* Rules */\nrules:\n\n  rule CreateAndStoreFresh:\n    let\n      x = fresh()\n    in\n    [ Fr(x) ]\n    --[ St(x) ]->\n    [ St(x) ]\n\n  rule Send_multiset_msgVar:\n    [ St(x), In(y) ]\n    --[ Out(x + y) ]->\n    [ ]\n\n  rule Send_multiset_freshVar:\n    let\n      x = fresh()\n    in\n    [ St(x), In(y) ]\n    --[ St(x), Out(x + y) ]->\n    [ ]\n\n/* Lemmas */\nlemmas:\n\n  /* This lemma is expected to be incorrectly verified by Tamarin 1.6.1 */\n  lemma secret_msgVar:\n    \"All x i j. Secret_MsgVar(x)@i & K(x)@j ==> False\"\n\n  /* This lemma should be correctly falsified, indicating proper fresh handling */\n  lemma secret_freshVar:\n    \"All x i j. Secret_FreshVar(x)@i & K(x)@j ==> False\""]], "SPTHY-1/JKL_TS1_2004-KI.spthy": [[true, "// JKL-TS1-2004 Protocol in Tamarin Language\n\n// Participants\ntype Principal\n\n// Messages and Keys\ntype Message\ntype Key\n\n// Roles\nrule InitiatorKeyGeneration:\n  [ Fr(~lkA), Fr(~ephA), !Role(I) ]\n  -->\n  [ Out((Init, pkA, ephA)),\n    Ltk(I, ~lkA), Ephk(~ephA),\n    PkA(pkA), Sessk(I, skI) ]\n\nrule ResponderKeyGeneration:\n  [ In((Init, pkA, ephA)), Fr(~lkB), Fr(~ephB), !Role(R) ]\n  -->\n  [ Out((Resp, pkB, ephB)),\n    Ltk(R, ~lkB), Ephk(~ephB),\n    PkB(pkB), Sessk(R, skR) ]\n\n// Session Key Agreement\nrule InitiatorSessionKeyAgreement:\n  [ In((Resp, pkB, ephB)), Ephk(~ephA), Ltk(I, ~lkA), Sessk(I, skI), PkB(pkB) ]\n  -->\n  [ Out(SessionKey(skI)), !KeyAgreement(I, skI) ]\n\nrule ResponderSessionKeyAgreement:\n  [ Ephk(~ephB), Ltk(R, ~lkB), Sessk(R, skR), PkA(pkA) ]\n  -->\n  [ Out(SessionKey(skR)), !KeyAgreement(R, skR) ]\n\n// Key Reveal Rules\nrule InitiatorKeyReveal:\n  [ Ltk(I, ~lkA), Ephk(~ephA), Sessk(I, skI), PkB(pkB) ]\n  -->\n  [ !Reveal(I, ~lkA), !RevealEph(I, ~ephA), !RevealSess(I, skI) ]\n\nrule ResponderKeyReveal:\n  [ Ltk(R, ~lkB), Ephk(~ephB), Sessk(R, skR), PkA(pkA) ]\n  -->\n  [ !Reveal(R, ~lkB), !RevealEph(R, ~ephB), !RevealSess(R, skR) ]\n\n// Lemmas - Security Properties\nlemma InitiatorKeyAgreement:\n  \"All role I. !KeyAgreement(I, skI) --> Ex skI. SessionKey(skI)\"\n\nlemma ResponderKeyAgreement:\n  \"All role R. !KeyAgreement(R, skR) --> Ex skR. SessionKey(skR)\"\n\nlemma Confidentiality:\n  \"All skI skR. (SessionKey(skI) & SessionKey(skR)) --> !(RevealSess(any, skI) | RevealSess(any, skR))\"\n\nlemma Authenticity:\n  \"All role I R. (SessionKey(skI) & SessionKey(skR)) --> I = R\""]], "SPTHY-1/JKL_TS1_2008-KI_wPFS.spthy": [[true, "theory JKL_TS1_2008\n\nbegin\n\n  builtins: symmetric-encryption, asymmetric-encryption, hashes\n\n  datatype agent = Initiator | Responder\n\n  consts: \n    g: publickey   -- 'g' is a public generator\n\n  funs:\n    ltk: agent -> skey           -- Long-term private key\n    pkey: agent -> publickey     -- Long-term public key\n    ek: nat -> skey              -- Ephemeral private key\n    epk: nat -> publickey        -- Ephemeral public key\n    skey: nat -> agent -> agent -> key  -- Session key\n\n  equations:\n    pkey(a) = aenc(ltk(a), g)    -- Public key derived from the long-term private key\n    epk(n) = aenc(ek(n), g)      -- Ephemeral public key derived from the ephemeral private key\n\n  rules:\n\n  rule Init_1:\n    let\n      i = NewNonce  -- New session index\n      ni = NewNonce -- Ephemeral key index for initiator\n    in\n      [ Fr(ni), Fr(i) ]\n      -- Initiator sends initial message containing their ephemeral key and identity\n      -- along with a random nonce and the public key derived from their long-term key\n      -- The attacker can learn the ephemeral public key and identity\n      --> [ Out(epk(ni)), Out(Initiator), Out(i) ]\n      -- Save ephemeral private information locally\n      [ M1(i) := ltk(Initiator), M2(i) := ek(ni), M3(i) := ni ]\n\n  rule Resp_1:\n    let\n      rj = NewNonce -- New session index\n      nr = NewNonce -- Ephemeral key index for responder(s)\n    in\n      [ In(epk(ni)), In(Initiator), In(i) ]\n      -- Responder generates ephemeral key, computes the shared session key, and responds\n      -- with its own ephemeral key along with the derived session key\n      --> [ Out(epk(nr)), Out(skey(i, Initiator, Responder)) ]\n      [ M4(i) := ltk(Responder), M5(i) := ek(nr), M6(i) := nr ]\n\n  rule Init_2:\n    [ In(epk(nr)), In(skey(i, Initiator, Responder)) ]\n    -- Initiator computes the session key and confirms secure establishment\n    --> [ Out(skey(i, Initiator, Responder)) ]\n\n  lemmas:\n\n  lemma KeyAgreement:\n    \"All i #i: not (LtkCompromised(Initiator) & LtkCompromised(Responder)) ==> \n    (K<>{}) /\\\\ not(K \\in KSet)\"\n\n  lemma JKL2008_2_initiator_key:\n    \"All i #i : \n    (Attack(skey(i, Initiator, Responder)) ==> LtkCompromised(Initiator) \\\\/ \n    EphemeralCompromised(M3(i)) \\\\/ \n    LtkCompromised(Responder))\"\n\n  lemma JKL2008_2_responder_key:\n    \"All i #i : \n    (Attack(skey(i, Responder, Initiator)) ==> LtkCompromised(Responder) \\\\/ \n    EphemeralCompromised(M5(i)) \\\\/ \n    LtkCompromised(Initiator))\"\n\nend"]], "SPTHY-1/Joux_EphkRev.spthy": [[true, "functions: \n    bilinear_pairing/3\n    signing/2\n    multiset/1\n\nsort user\ntype pubkey(user): message\ntype ltk(user): message\ntype ephemeralkey(user): message\ntype hash(user, message): message\ntype sessionkey: message\n\nfacts:\n    RevealLtk(user)\n    RevealEphkey(user)\n    Register_pk(user, pubkey(user))\n    Step1(user, ephemeralkey(user), hash(user, ephemeralkey(user)))\n    Step2(user, ephemeralkey(user), hash(user, ephemeralkey(user)))\n    EstablishedSessionKey(user, sessionkey)\n\nrules:\n\nrule Register_pk:\n    let U: user,\n        L: ltk(U),\n        P: pubkey(U)\n    in \n      [ ] --[ Register_pk(U, P) ]-> \n      [ Ltk(U) $:= L, Pubkey(U) $:= P ]\n\nrule Proto1:\n    let A: user,\n        ekA: ephemeralkey(A),\n        hkA: hash(A, ekA)\n    in\n      [ Register_pk(A, P) ] --[ Step1(A, ekA, hkA) ]->\n      [ ]\n\nrule Proto2:\n    let B: user,\n        ekB: ephemeralkey(B),\n        hkB: hash(B, ekB)\n    in\n      [ Step1(A, ekA, hkA),\n        Register_pk(B, P) ] --[ Step2(B, ekB, hkB) ]->\n      [ ]\n\nrule EphkRev:\n    let U: user\n    in\n      [ ] --[ RevealEphkey(U) ]->\n      [ ]\n\nlemmas:\n\nlemma SessionKeyEstablishment:\n    \"All A, B, C. Exists sk.\n     (Step1(A, ekA, hkA) @ n1) &\n     (Step2(B, ekB, hkB) @ n2) &\n     (Step2(C, ekC, hkC) @ n3) ==> \n     EstablishedSessionKey(A, sk) @ n4\"\n\nlemma SessionKeySecrecyAndPFS:\n    \"All A, sk.\n     EstablishedSessionKey(A, sk) @ n & \n     !(RevealLtk(A) before n) ==\n     !Attacker(sk)\""]], "SPTHY-1/KAS2_eCK.spthy": [[true, "// Define sorts\nsort agent\nsort key\nsort message\nsort enc_message\nsort mac\n\n// Define functions\nfunctions\n    pk: agent -> key   // Public key function\n    sk: agent -> key   // Private key function\n    enc: key * message -> enc_message   // Encryption function\n    dec: key * enc_message -> message   // Decryption function\n    kdf: message * message * agent * agent -> key   // Key derivation function\n    mac: key * message -> mac   // Message authentication code function\n\n// Define rules for session initiation by Alice (Initiator)\nrules\n    // Registration step (long-term key pair generation)\n    [Registration]\n    let kI = sk(A), pkI = pk(A)\n    let kR = sk(B), pkR = pk(B)\n    output(pkI, pkR)\n\n    // Initialization (Initiator) - Alice sends encrypted message to Bob\n    [Alice_Init]\n    let m1 = fresh(), sid = fresh()   // Random message and session ID\n    let c1 = enc(pkR, m1)   // Encrypt m1 using Bob's public key\n    output(A, B, sid, c1)\n\n// Define Bob's response to Alice's request\nrules\n    // Response (Responder) - Bob generates response message and sends back encrypted\n    [Bob_Response]\n    let m1' = dec(sk(B), c1)   // Decrypt m1 using Bob's private key\n    let m2 = fresh()   // Generate random message m2\n    let c2 = enc(pkI, m2)   // Encrypt m2 using Alice's public key\n    let keys = kdf(m1', m2, A, B)   // Compute shared key\n    let mac_b = mac(keys, m1')   // Compute MAC for integrity\n    output(B, A, sid, c2, mac_b)\n\n// Define Alice's finalization step\nrules\n    [Alice_Final]\n    let m2' = dec(sk(A), c2)   // Decrypt response\n    let keys = kdf(m1, m2', A, B)   // Compute shared key\n    let mac_b' = mac(keys, m1)   // Verify Bob's MAC\n    let mac_a = mac(keys, m2')   // Generate Alice's MAC\n    output(A, B, sid, mac_a)\n\n// Assume Bob verifies Alice's MAC for completion\nrules\n    [Bob_Final]\n    let mac_a' = mac(keys, m2')   // Verify Alice's MAC integrity\n    output(B, A, sid)\n\n// Define security properties\nlemma Key_Secrecy\n    forall A, B, m1, m2, c1, c2, sid, mac_a, mac_b, keys\n    \"Keys are secret except to A and B unless revealed\"\n\nlemma Session_Key_Reveal\n    exists A, B, keys\n    \"Key reveal handling concepts ensuring session key security\""]], "SPTHY-1/Ex1_solution.spthy": [[true, "theory Ex1_solution\n\nbuiltins: symmetric_encryption, asymmetric_encryption, signing\n\nfunctions:\n    pk/1, sk/1, enc/2, dec/2, sign/2, verify/3\n\ntypes:\n    Constant, Message\n\nrules:\n\n    // Public Key Setup Rules\n\n    rule PubKey_Alice:\n        [ Fr(~ska) ]\n      -->\n        [ Out(pk(~ska)) ]\n\n    rule Compromise_Alice:\n        [ !Compromised ]\n      -->\n        [ Out(~ska), In(~ska), !Compromised ]\n\n    // Protocol Rules\n\n    rule AliceSends:\n        [ Fr(~ma), Fr(~kAB) ]\n      -->\n        [ Out(enc(sign(~ma, ~ska), pk(bob))) ]\n\n    rule BobReceived:\n        [ In(enc(sign(~ma, ~ska), pk(bob))),\n          Fr(~mb) ]\n      -->\n        [ Out(enc(~mb, ~kAB)) ]\n\n    rule AliceReceives:\n        [ In(enc(~mb, ~kAB)),\n          In(enc(sign(~ma, ~ska), pk(bob))) ]\n      -->\n        [ // Ensure messages are fresh and distinct\n          !UniqueMessages(~ma, ~mb)\n        ]\n\nrestrictions:\n    equality: (=)\n    nequality: (/=)\n\nlemmas:\n    Executability:\n        (Exists i. Running(i, aliceSends) & Running(i, bobReceived))\n\n    SecrecyOfMessages:\n        forall msg. msg # !Activity\n        ==> Secret(msg)\n\n    Aliveness:\n        All instances of BobReceived guarantee Alice's or compromised action.\n\n    NonInjectiveAgreement:\n        If AliceReceives reached: BobReceived trace exists or compromised.\n\n    UniquenessOfFinishedStates:\n        Finished states with the same messages happen uniquely.\n\nend of theory"]], "SPTHY-1/KEA_plus_eCK.spthy": [[true, "// Protocol Description: KEA+ (Key Exchange Algorithm Plus)\n// Modeler: Cas Cremers\n// Security Property: eCK security\n\ntypes\n  Agent, Message, Key\n\nfunctions\n  longterm_key: Agent -> Key\n  ephemeral_key: Agent -> Key\n  hash: Message, Key, Message -> Message\n  sym_encrypt: Message, Key -> Message\n  sym_decrypt: Message, Key -> Message\n\ndeclarations\n  free longterm_key_reveal: Agent -> Fact\n  free ephemeral_key_reveal: Agent -> Fact\n  free session_key_reveal: Agent, Agent, Message, Key -> Fact\n\nrules\n\n[Generate_Ltk]\n  let A\n    o A -> Agent\n    r  (LongTermKeyGenerated A (longterm_key(A)))\n\n[Init_1]\n  let I, R, pkI, ekI, msg1\n    in fresh LtkI: Key\n       fresh EphkI: Key\n       if LongTermKeyGenerated(I, LtkI)\n          & not(longterm_key_reveal(I))\n       then \n           Event(Start_I(I, R, LtkI, EphkI))\n           Out(msg1, R)\n       map msg1 := (ephemeral_key(I), longterm_key(I))\n\n[Resp_1]\n  let R, I, pkR, ekR, msg1, msg2\n    in fresh LtkR: Key\n       fresh EphkR: Key\n       If In(msg1, R)\n          & LongTermKeyGenerated(R, LtkR)\n          & not(longterm_key_reveal(R))\n       Then Event(Start_R(R, I, LtkR, EphkR))\n            Out(msg2, I)\n       Map msg2 := (ephemeral_key(R), hash(I, ephemeral_key(R), ephemeral_key(R)))\n\n[Init_2]\n  let I, R, pkI, ekI, pkR, ekR, msg2, msg3, sk\n    In fresh LtkI: Key\n       fresh EphkI: Key\n       if In(msg2, I)\n          & LongTermKeyGenerated(I, LtkI)\n          & not(ephemeral_key_reveal(I))\n       Then Event(Derive_I_SessKey(I, R))\n            Out(msg3, R)\n       Map msg3 := (hash(pkI, ekI, pkR, ekR), session_key(I, R))\n\n// Security Properties\n// Ensuring session keys are derived securely for clean sessions\n\nlemma WeakSessionKeyConsensus:\n  \"forall I R sk1 sk2. Derive_I_SessKey(I, R) @ $i & Derive_R_SessKey(R, I) @ $j \n  & SessionKeyReveal(I, R, msg, sk1) @ $k => session_key_reveal(I, R, msg, sk2)\"\n\nlemma CleanSession_NoKeyLeaked:\n  \"forall I R sk. Start_I(I, R) @ $i -> not(longterm_key_reveal(I)) & not(ephemeral_key_reveal(I)) & not(session_key_reveal(I, R, msg, sk))\""]], "SPTHY-1/KEA_plus_KI_KCI_wPFS.spthy": [[true, "theory KEA_Plus\n\nbegin\n\n  // Types\n  free type Identity\n  free type SessionKey\n\n  // Functions\n  private fun g: nat\n  const Ek: nat\n  const Ltk: Identity -> nat\n  fun EphemeralPK: nat -> nat\n  fun SessionKeyGen: nat * nat * Identity * Identity -> SessionKey\n\n  // Messages\n  private fun request: EphemeralPK * Identity\n  private fun response: EphemeralPK\n\n  // Protocol roles\n  role Initiator(\n    I, R: Identity,\n    SkI: SessionKey,\n    LtkI: nat\n  )\n  played_by I\n  def=\n    local Succ: bool\n\n    // Generate ephemeral keys\n    var ekI: nat\n    let epkI = EphemeralPK(ekI)\n\n    // Initiator's first message\n    send_1(I, R, request(epkI, I))\n    \n    // Receive response\n    recv_2(R, I, response(epkR))\n    \n    // Compute session key\n    let SkI = SessionKeyGen(ekI, epkR, I, R)\n    let Succ = true\n    state_1(SkI, Succ)\n\n  role Responder(\n    R, I: Identity,\n    SkR: SessionKey,\n    LtkR: nat\n  )\n  played_by R\n  def=\n    local Succ: bool\n\n    // Generate ephemeral keys\n    var ekR: nat\n    let epkR = EphemeralPK(ekR)\n\n    // Receive initiator's message\n    recv_1(I, R, request(epkI, I))\n\n    // Responder's response\n    send_2(R, I, response(epkR))\n\n    // Compute session key\n    let SkR = SessionKeyGen(epkR, epkI, R, I)\n    let Succ = true\n    state_2(SkR, Succ)\n\n  // Security properties\n  lemma Key_Indistinguishability:\n    \"All i:\n       (State(i) & !KeyReveal(i)) ==> \n       (Ex k: \n          (k = state.sessionkey(i)) &\n          (Random(k) & RNG(s) = k))\"\n\n  lemma Key_Compromise_Impersonation:\n    \"All i, x:\n       (State(i) & !KeyReveal(i) & LongTermKeyCompromised(x)) ==> \n       not(Ex u: user(x) & session(x) = session(u) & uid(x) <> R & i = u)\"\n\n  lemma Weak_Perfect_Forward_Secrecy:\n    \"All i:\n       (State(i) & !KeyReveal(i) & LongTermKeyCompromised(i) & SessionEnd(i)) ==>\n       !Ex j: (Session(i,j) & !KeyReveal(j))\"\n\nend"]], "SPTHY-1/LD07_UK2.spthy": [[true, "theory LD07_Untraceable_RFID begin\n\nbuiltins: diffie-hellman, XOR\n\n/// Knowledge associated with readers and the tag\nfunctions: keystore/1, keyreader/2, keytag/1\n\n/// Hash function for generating responses\nfunctions: h/1\n\n/// Protocol rules begin\n\nrule Setup:\n  [Fr(r), Fr(k0), Fr(ki), Fr(ki1)]\n  ==>\n  [ !Keystore(r,k0,ki,ki1),\n    Out(ReaderInit(k0,ki,ki1)),\n    Out(TagInit(Alpha(k0,ki))) ]\n\n/// Reader initiates interaction\nrule Reader_to_Tag_Interaction:\n  let r' = Fr(r) in\n  [ !Keystore(r,k0,ki,ki1) ]\n  --[ Fr(r') ]->\n  [ In(TagRecv(r')),\n    Out(TagResponse(h(r' XOR Alpha(k0,ki)))) ]\n\n/// Tag validates and updates knowledge\nrule Challenge_and_Response:\n  let a = ki XOR ki1\n  let b = h(a XOR k0 XOR ki) in\n  [ !Keystore(r,k0,ki,ki1),\n    In(TagValidation(a, b)) ]\n  ==>\n  [ Out(TagCheck(b, h(a XOR k0 XOR ki))) ]\n\nrule Tag_Update_Knowledge:\n  let a = ki XOR ki1\n  [ In(TagCheck(b, h(a XOR k0 XOR ki))) ]  \n  ==>\n  [ !Keytag(AlphaUpdate(a)) ]\n\n/// Untraceability Security Claims\n\nlemma untraceability:\n  \"All r #i. \n    Exists r' #j. !Keytag(AlphaUpdate) & \n    r #i = r' #j\"\n\nlemma non_replay_attack:\n  \"All r #i. \n    Not (Exists r' #j. r #i = r' #j & !Keytag(AlphaUpdate))\"\n\nend"]], "SPTHY-1/mls-03.spthy": [[true, "theory MLS03\n\nbegin\n\n// Declarations\nconst Hash, Sig: function\nconst skC, pkC, skS, pkS, gx, gy, SessionKey: pub\nconst RegToken: fresh\n\nbuiltins: asymmetric-encryption, signing, hash\n\nfunctions\n    mac/2\n\n// Protocol rules\n\nrule RegisterPK:\n  [Fr(~ltk), Fr(~pkOut)]\n--[ RegisterPK(~ltk, ~pkOut) ]->\n  [!ServerPKGen(~ltk, ~pkOut), Out(~pkOut)]\n\nrule ClientInit:\n  [Fr(~gx), Fr(~cx), SpkC(~pkC), State('init)]\n  --[ ]->\n  [ Out(<~gx, Sign(<~gx, 'C'>, ~skC)>), State('waiting') ]\n\nrule ServerInit:\n  [In(<~gx, $sigCg>), !ServerPKGen(~skS, ~pkS), Fr(~gy), State('waitC')]\n  --[ verify($sigCg, <~gx, 'C'>, pkC) ]->\n  [Out(<~gy, MAC('welcome', ~skS)>), State('sending')]\n\nrule ClientFinish:\n  [In(<~gy, $macSg>), Fr(~SessionKey), State('waiting')]\n  --[ verify($macSg, 'welcome', ~skS) ]->\n  [State('done'), Secret(~SessionKey, 'eksecy')]\n\nrule ServerDone:\n  [State('sending')]\n  -->[ State('finished')]\n\n// Security Goals\n\nlemma secrecy:\n    \"All x y #i. Secret(x, y) @i ==> \n        not (Ex #j. RevealLTK() @j)\"  // Assures session key secrecy\n\nlemma liveness:\n    \"All x. ClientFinish(x) @i ==> \n        Ex #j. ServerDone(x) @j\" // Server always responds\n\nlemma injective_agreement:\n    \"All x y. ClientFinish(x) @i & ServerDone(y) @j & x = y ==> \n        (i=j)\" // Unique session keys for each client-server pair\n\nend"]], "SPTHY-1/MTI_C0.spthy": [[true, "// MTI/C0 Protocol in Tamarin\n\n// Public and Private Keys for the Initiator and Responder\nfunctions\n  KDF: Data -> Data\n  gen_ltk: -> Data\n  Pk: Data -> Data\n\n// Data types representing various entities\ntype Initiator\ntype Responder\ntype SessionKey\n\n// Variables representing keys and messages\n[ version = \"2023.4\" ]\n\n/* Facts for representing the protocol states */\nfacts\n  InitRegister(%I: Initiator, %ltkI: Data, %PkI: Data)\n  RespRegister(%R: Responder, %ltkR: Data, %PkR: Data)\n  InitiateMsg(%I: Initiator, %ekI: Data, %msgI: Data)\n  RespondMsg(%R: Responder, %ekR: Data, %msgR: Data)\n  SesskRev(%I: Initiator, %SessionKey: SessionKey) // Session Key Reveal\n  LtkRev(%I: Initiator, %R: Responder, %ltkI: Data, %ltkR: Data) // Long-term Key Reveal\n\n/* Protocol Rules */\nrules\n\n  // Public key registration for Initiator\n  rule RegisterInitiator:\n    let ltkI = gen_ltk()\n    in\n    [ ]\n    --[ InitRegister($I, ltkI, Pk(ltkI)) ]-> [ InitRegister($I, ltkI, Pk(ltkI)) ]\n\n  // Public key registration for Responder\n  rule RegisterResponder:\n    let ltkR = gen_ltk()\n    in\n    [ ]\n    --[ RespRegister($R, ltkR, Pk(ltkR)) ]-> [ RespRegister($R, ltkR, Pk(ltkR)) ]\n\n  // Initiator sends message\n  rule InitiatorPhase:\n    let ekI = rand() // Random ephemeral key\n    in\n    [ InitRegister($I, ltkI, $PkI) ]\n    --[ InitiateMsg($I, ekI, KDF(ekI)) ]-> [ InitiateMsg($I, ekI, KDF(ekI)) ]\n\n  // Responder processes message and responds\n  rule ResponderPhase:\n    let ekR = rand()\n    in\n    [ RespRegister($R, ltkR, $PkR), InitiateMsg($I, ekI, msgI) ]\n    --[ RespondMsg($R, ekR, KDF(ekR)) ]-> [ RespondMsg($R, ekR, KDF(ekR)) ]\n\n  // Rule to reveal session key after completion\n  rule RevealSessionKey:\n    [ InitiateMsg($I, ekI, msgI), RespondMsg($R, ekR, msgR) ]\n    --[ SesskRev($I, KDF(ekI)) ]-> [ ]\n\n  // Rule to reveal long-term keys\n  rule RevealLongTermKey:\n    [ InitRegister($I, ltkI, $PkI), RespRegister($R, ltkR, $PkR) ]\n    --[ LtkRev($I, $R, ltkI, ltkR) ]-> [ ]\n\n/* Security Lemmas */\nlemma Executable:\n  \"All x #i. Action(x)@i ==> Exists #j. Action(x)@j & j < i\"\n\nlemma Secrecy_Initiator:\n  \"All %I: Initiator, %SessionKey: SessionKey. \n   SesskRev(%I, %SessionKey) ==> !LtkRev(%I, $R, $ltkI, $ltkR)\"\n\nlemma Secrecy_Responder:\n  \"All %R: Responder, %SessionKey: SessionKey.\n   SesskRev($I, %SessionKey) ==> !LtkRev($I, %R, $ltkI, $ltkR)\""]], "SPTHY-1/NAXOS_eCK_PFS.spthy": [[true, "// NAXOS protocol model\n\nfunctions\n    pk: Agent -> Ltk\n    sk: Agent -> Multiset\n    KeyDerivation: Message -> SharedKey\n\n// Types\ntype Agent, Nonce, Message, SharedKey\n\n// Constants\nconst g: Message\nconst Hash : Message -> Message\n\n// Knowledge\nknowledge is a\n\n// Facts\nfact SessionKeyGenerated: Agent # Agent # SharedKey\nfact SessionKeyUsed: Agent # Agent # SharedKey\n\n// Rules\nrule GenerateLongTermKey:\n    [ Fr(ea), Fr(eb) ]\n    -->\n    [ Ltk(A, pkA = g^ea), Ltk(B, pkB = g^eb) ]\n\nrule Initiate_Protocol:\n    [ Fr(ea), Ltk(A, pkA = g^ea)]\n    -->\n    [ Out(<\"Init_1\", A, g^ea>) ]\n\nrule Respond_Protocol:\n    [ In(<\"Init_1\", A, g^ea>), Fr(eb), Ltk(B, pkB = g^eb) ]\n    -->\n    [ Out(<\"Resp_1\", B, g^eb>),\n      In(<\"Resp_1\", B, g^eb>),\n      Let skA = Hash(g^(eb*ea)),\n      SessionKeyGenerated(A, B, skA) ]\n\nrule ComputeSessionKey_Alice:\n    [ In(<\"Resp_1\", B, g^eb>), Fr(ea), Ltk(A, pkA = g^ea) ]\n    -->\n    [ Let skA = Hash(g^(ea*eb)),\n      SessionKeyUsed(A, B, skA) ]\n\nrule ComputeSessionKey_Bob:\n    [ In(<\"Init_1\", A, g^ea>), Fr(eb), Ltk(B, pkB = g^eb) ]\n    -->\n    [ Let skB = Hash(g^(eb*ea)),\n      SessionKeyUsed(B, A, skB) ]\n\n// Lemmas\nlemma key_secrecy:\n    \"All A B K. SessionKeyUsed(A, B, K) ==> \n    ! Ltk(A, pkA) & ! Ltk(B, pkB) & ! Out(K)\"\n\nlemma matching_session_acceptance:\n    \"All A B K. SessionKeyGenerated(A, B, K) &\n    SessionKeyUsed(A, B, K) ==> SessionKeyGenerated(B, A, K) &\n    ! Out(K)\""]], "SPTHY-1/NSPK3.spthy": [[true, "// Classic Needham-Schroeder Public Key Protocol (NSPK3) in Tamarin\n\n// Types\ntype nonces, keys, agents\n\n// Free variables\nfree Ni: nonces\nfree Nr: nonces\nfree I: agents\nfree R: agents\nfree skI: keys // Initiator's secret key\nfree skR: keys // Responder's secret key\nfree pkI: keys // Initiator's public key\nfree pkR: keys // Responder's public key\n\n// Functions\nfunctions senc/2, sdec/2, pk/1, sk/1\n\n// Knowledge constants for PKI\nkempi pkI = pk(I)\nkempi pkR = pk(R)\n\n// Initial knowledge for the Initiator\nknowledge I:={kempi(Ni), kempi(skI), kempi(pkR)}\n\n// Initial knowledge for the Responder\nknowledge R:={kempi(skR), kempi(pkI)}\n\n// Trace details\n\n// Message 1: Initiator -> Responder: {\u20181\u2019, Ni, I}pkR\nrule SendMessage1:\n  [ Fr(~Ni) ]\n--[ Send(I, R, senc(\u3008\u20181\u2019, ~Ni, I\u3009, pkR)) ]->\n  [ OutBox ]\n\n// Message 2: Responder -> Initiator: {\u20182\u2019, Ni, Nr}pkI\nrule SendMessage2:\n  [ !OutBox, InBox, Fr(~Nr) ]\n--[ Receive(I, R, senc(\u3008\u20181\u2019, NiTem, ITem\u3009, pkR)), Send(R, I, senc(\u3008\u20182\u2019, NiTem, ~Nr\u3009, pkI)) ]->\n  [ OutBox, kempi(NiTem), kempi(Nr) ]\n\n// Message 3: Initiator -> Responder: {\u20183\u2019, Nr}pkR\nrule SendMessage3:\n  [ !OutBox, InBox ]\n--[ Receive(R, I, senc(\u3008\u20182\u2019, NiConf, Nr\u3009, pkI)), Send(I, R, senc(\u3008\u20183\u2019, Nr\u3009, pkR)) ]->\n  [ Kempi(Nr) ]\n\n// Security properties\n// Nonce Secrecy\nlemma NonceSecrecy:\n  \"forall Ni . Secrecy(Ni, [Ni], kempi)\"\n\n// Injective Agreement\nlemma InjectiveAgreement:\n  \"forall I, R, Ni, Nr . \n    (Happens = Send(I, R, senc(\u3008\u20181\u2019, Ni, I\u3009, pkR)), \n     Happens = Receive(I, R, senc(\u3008\u20181\u2019, Ni, I\u3009, pkR)),\n     Happens = Send(R, I, senc(\u3008\u20182\u2019, Ni, Nr\u3009, pkI)), \n     Happens = Receive(R, I, senc(\u3008\u20182\u2019, Ni, Nr\u3009, pkI)),\n     Happens = Send(I, R, senc(\u3008\u20183\u2019, Nr\u3009, pkR)), \n     Happens = Receive(I, R, senc(\u3008\u20183\u2019, Nr\u3009, pkR)))\n    => (Exists = SendMessage3)\"\n\n// Session Key Setup Possible\nlemma SessionKeySetupPossible:\n  \"forall I, R . Exists(NonceSecrecy) and !Exists(BreakKey)\""]], "SPTHY-1/OTPoverSMS_MA.spthy": [[true, "theory OTP_over_SMS\n\n  // Declare sorts for agent roles and messages\n  sorts\n    Agent, Role, Msg\n\n  // Declare functions for message attributes\n  functions\n    otp_generation: Agent -> Msg\n    user_identifier: Agent -> Msg\n    authenticate_message: Msg -> Msg\n\n  // Define constants or variables for agents representing humans, devices, and servers\n  variables\n    H: Agent // Human agent\n    D: Agent // Device\n    S: Agent // Server\n    m: Msg // Message variable\n\n  // Role definitions with role distinction in agents\n  equations\n    IsHuman(H)\n    IsDevice(D)\n    IsServer(S)\n\n  // Assume each device is owned by only one human agent\n  rule Ownership\n    [ <- Device(D) ]\n    [ IsOwner(H,D) ]\n\n  // Setup phase: Initialization of states and keys\n  rule SetupInit\n    [ ]\n    [ !Setup(H), !Setup(D), !Setup(S) ]\n\n  // Message receiving rule over secure channels\n  rule SecureReceive\n    [ SecureChannel(H,D,m), !Setup(H) ]\n    [ ProcessedMessage(H,m) ]\n\n  // Message sending rule: OTP generation and transmission\n  rule SendOTP\n    [ <- Setup(S), Device(D), Human(H) ]\n    [ SecureChannel(S,D,otp_generation(S)), MessageTransmit(H, otp_generation(S)) ]\n\n  // Message authentication mechanism ensuring legitimate sender\n  rule AuthenticateMsg\n    [ MessageTransmit(H,m), !Setup(H) ]\n    [ authenticate_message(m) ]\n\n  // Security property: Functionality under infallible human assumption\n  lemma Functionality_complete\n    forall H, S, D. Exists m such that\n      Setup(H) & Setup(S) & Setup(D) &\n      MessageTransmit(H, otp_generation(S)) implies\n      ProcessedMessage(H,otp_generation(S))\n\n  // Security property: Authentication verification\n  lemma Message_authentication\n    forall H, S, m. Exists H' such that\n      AuthenticateMsg(m) implies\n      MessageTransmit(H', m) & ReceivedByServer(S,m)\n\nend theory"]], "SPTHY-1/OTYT06_UK2.spthy": [[true, "// Participants and Shared Knowledge\nactor Reader(T, k)  \nactor Tag(R, k)\n\n// Initial Setup\nrule SetupPhase:\n  let \n    k1 = fresh(), \n    k2 = fresh(), \n    r  = fresh() \n  in\n  [ !Init($R, $T, k), \n    !FutureKeySet(k, k1, k2) \n  ]\n  --> \n  [ Sent($R, r1), \n    Receives($T, r1) ]\n\n// Tag Response Phase\nrule TagResponse:\n  forall R T : Principal, r1 : Message, k : Key\n  exists h  : Hash\n  [ !Init($R, $T, k), \n    Sent($R, r1), \n    Receives($T, r1) ]\n  -->\n  [ Sent($T, h) ]\n  where\n    h = Hash(Xor(k, r1))\n\n// Key Update Phase\nrule KeyUpdate:\n  forall R T : Principal, h : Hash, k : Key, k1 : Key\n  exists kNew : Key\n  [ Sent($T, h), \n    Receives($R, h) ]\n  -->\n  [ !FutureKeySet(kNew, k), \n    Sent($R, Xor(k, k1)), \n    Receives($T, Xor(k, k1)) ]\n\n// Security Properties\nlemma RecentAliveness_Tag:\n  \"All s : Session . \n    Exists Tag . \n    In(s, Tag)\"\n\nlemma Untraceability_NotEnsured:\n  \"Exists s1, s2 : Session . \n     Not(ObsEq(s1, s2))\"\n\nlemma RecentAliveness_Reader_NotEnsured:\n  \"NotExist s : Session . \n     Exists Reader . \n     In(s, Reader)\"\n\n// Restrictions\nrestriction UniqueActionPerSession:\n  forall s : Session .\n  Unique ExistsAction(s)\n\n// Lemmas and Attack Findings\nlemma TagPresenceImpliesSetup:\n  \"All t : Tag . \n     Exists setup . \n     Init(t, setup)\"\n\nlemma ObservationalEquivalenceAttack:\n  \"All s1, s2 : Session . \n     Exists Attack . \n    (NotObsEq(s1, s2))\"\n\n// Note: The model assumes unique sessions per interaction"]], "SPTHY-1/OTYT06_UK3.spthy": [[true, "theory OTYT06\n\nbegin\n\n// Declare the messages, functions, and roles\nbuiltins: functions, asymmetric\n\n// Types\ntypes\n  Nonce\n  Key\n\n// Functions\nfunctions\n  h: (Key, Nonce) -> Hash\n  xor: (Key, Key) -> Key\n\n// Initial shared secret between Reader and Tag\nconsts\n  k: Key\n\n// Define roles: Reader and Tag\nrules\n\n  // Reader sends a challenge to Tag\n  rule Reader_Initiate:\n    let r1 = fresh() in\n    [ Fr(r1) ]\n    --[\n      !R_Sent(r1)\n    ]-->\n    [ Out(r1) ]\n\n  // Tag processes reader's challenge and replies\n  rule Tag_Respond:\n    let r1 = var, k_tag = var in\n    [ In(r1), !SharedKey(k_tag) ]\n    --[\n      !T_Processed(r1), \n      !SharedKey(k_tag)\n    ]-->\n    [ \n      Out(h(k_tag, r1))\n    ]\n\n  // Reader performs key update and informs Tag\n  rule Reader_Update:\n    let k1 = fresh(), h_r = var, k_cur = var in\n    [ In(h_r), \n      !R_Sent(r1), \n      !SharedKey(k_cur), \n      h(k_cur, r1) =? h_r \n    ]\n    --[ \n      !ValidResponse(h_r)\n    ]-->\n    [\n      Out(xor(k_cur, k1)), \n      !SharedKey(k1)\n    ]\n\n  // Tag updates its key after receiving reader's key update\n  rule Tag_Update:\n    let x = var, k_cur = var in\n    [ In(x), \n      !SharedKey(k_cur)\n    ]\n    --[\n      !T_Updated(x)\n    ]-->\n    let k1 = xor(k_cur, x) in\n    [\n      !SharedKey(k1)\n    ]\n\n// Security properties\nlemmas\n\n  // Recent Aliveness of the Tag\n  lemma recent_aliveness_tag:\n    \"All r1 #i #j. (Ex k h.\n      Run(Reader_Initiate, <r1>, i) \n      AND Received_Tag_Respond(h, j, k, r1))\n      ==> \n      Ex k1. New(k1)\"\n\nend"]], "SPTHY-1/Ex2_a_solution.spthy": [[true, "// Protocol: Authentication Protocol with Asymmetric and Symmetric Encryption\n\n// Functions and Types\nbuiltins: symmetric-encryption, asymmetric-encryption\nfunctions: h/1\n\n// Initial Knowledge\n[!Init] --> Alice(pk(~'skA'))\n[!Init] --> Server(pk(~'skS'))\n\n// Rules\n\n// 1. Server Key Initialization\nrule ServerKeyInit:\n  let \n    x = new()\n  in\n    [Init()]\n    -->\n    [ \n      Out(pk(~'skS'))\n    ]\n      \n// 2. Client Key Initialization\nrule ClientKeyInit:\n  let \n    y = new()\n  in\n    [Init()]\n    -->\n    [ \n      Out(pk(~'skA'))\n    ]\n\n// 3. Client Sends Initialization Message\nrule ClientSendInit:\n  let\n    nonce1 = new()\n  in\n    [\n      In(pk(~'skS'))\n    ]\n    -->\n    [\n      Out( aenc({nonce1}, pk(~'skS')) )\n    ]\n\n// 4. Server Receives Initialization Message\nrule ServerRecvInit:\n  let\n    nonce2 = new()\n  in\n    [\n      In( aenc({nonce1}, pk(~'skS')) )\n    ]\n    -->\n    [\n      Out( aenc({nonce1, nonce2}, pk(~'skA')) ),\n      State(h({nonce1, nonce2})) // Session key derived\n    ]\n\n// 5. Client Receives Nonce and Starts Session\nrule ClientRecvNonceStartSession:\n  let\n    skSession = h({nonce1, nonce2})\n  in\n    [\n      In( aenc({nonce1, nonce2}, pk(~'skA')) )\n    ]\n    -->\n    [\n      State(skSession), // Transition to session\n      Event(\"ClientSessionStart\")\n    ]\n\n// 6. Client Sends Payload\nrule ClientSendPayload:\n  let\n    payload = hash(new())\n  in\n    [\n      State(skSession), // Requires session state\n      Event(\"ClientSessionStart\")\n    ]\n    -->\n    [\n      Out(senc(payload, skSession)),\n      Event(\"ClientPayloadSent\")\n    ]\n\n// 7. Server Receives Payload\nrule ServerRecvPayload:\n  [\n    State(skSession),\n    Event(\"ClientSessionStart\"),\n    In(senc(payload, skSession))\n  ]\n  -->\n  [\n    Event(\"ServerPayloadReceived\")\n  ]\n\n// 8. Client Ends Session\nrule ClientEndSession:\n  [\n    State(skSession),\n    Event(\"ClientPayloadSent\")\n  ]\n  -->\n  [\n    Event(\"ClientSessionEnd\")\n  ]\n\n// Lemmas\n\nlemma ClientWellFoundedness:\n  \"All x. ClientPayloadSent(x) => Exists y. ClientSessionStart(y)\"\n\nlemma Secrecy:\n  \"All x. ClientSessionEnd(x) => !Reveal(skSession)\""]], "SPTHY-1/Phoolproof_EA.spthy": [[true, "theory Phoolproof_Voting_Protocol\n\nbegin\n\nfunctions \n    sign/2, verify/2, encrypt/2, decrypt/2, hash/1, sym_encrypt/2, sym_decrypt/2\n\ntypes\n    entity, device, server, human, role\n\nfacts\n    RoleStart/2, RoleEnd/2, SecureChannel/2, InsecureChannel/2\n    Authenticated/1, DistinctSetUp/1\n\nrules\n\n// Setup Phase - Devices are initialized with keys and pairs\nrule SetupDevice:\n    let d = dummy_device in \n    [ Fr(d_key) ]\n    --[ Output(d, senc(p, d_key)), RoleStart(Device, d) ]->\n    [ Device(d, d_key) ]\n\n// Setup Phase - Servers are initialized with keys\nrule SetupServer:\n    let s = server_instance in \n    [ Fr(s_key) ]\n    --[ RoleStart(Server, s) ]->\n    [ Server(s, s_key) ]\n\n// Secure communication rule using encryption\nrule SecureCommunication:\n    let a, b = entities, m = message in \n    [ SecureChannel(a, b), Fr(k) ]\n    --[ Output(a, enc(m, k)), RoleEnd(SecureComm, a) ]->\n    [ SecureMessage(b, m) ]\n\n// Example of Authentication Lemma\nlemma Entity_Authentication:\n    \"All a # a0. Ex b c # ( RoleStart(Human, a) \n      & RoleEnd(Server, b) \n      & Authenticated(c) ==> RoleEnd(DeviceComm, c))\"\n\nend"]], "SPTHY-1/RYY_PFS.spthy": [[true, "theory RYY\n\nbegin\n\n// Types\ntype Identity\ntype Key\ntype EphemeralKey\ntype SessionKey\n\n// Functions\nfunctions\n  kgc_master_key: -> Key\n  long_term_key: Identity -> Key\n  ephemeral_key: Identity -> EphemeralKey\n  kdf: Identity # EphemeralKey # EphemeralKey -> SessionKey\n  hp: Identity -> Identity // Hash function for identities\n\n// Free variables\nfacts\n  Fr(identity_A: Identity)\n  Fr(identity_B: Identity)\n  Fr(m: Message)\n\n// Protocol steps\nrules\n\n  // Key Generation Center Initialization\n  KGC_Setup:\n    [Fr(identity_A), Fr(identity_B)]\n    ---\n    [!Ltk(identity_A, long_term_key(identity_A)),\n     !Ltk(identity_B, long_term_key(identity_B))]\n\n  // Alice Session Initialization\n  Alice_Init:\n    [Fr(ephemeral_key(identity_A)), !Ltk(identity_A, lt_key)]\n    ---\n    [Out(<'A', ephemeral_key(identity_A)>),\n     !State('A', identity_A, ephemeral_key(identity_A), lt_key)]\n\n  // Bob Receives and Responds\n  Bob_Response:\n    [In(<'A', X: EphemeralKey>), Fr(ephemeral_key(identity_B)), !Ltk(identity_B, lt_key_B)]\n    ---\n    [Out(<'B', ephemeral_key(identity_B)>),\n     !State('B', identity_B, ephemeral_key(identity_B), lt_key_B),\n     !SessionKey('B', kdf(identity_A, X, ephemeral_key(identity_B)))]\n\n  // Key Agreement for Alice\n  Alice_Finish:\n    [In(<'B', Y: EphemeralKey>), !State('A', identity_A, X: EphemeralKey, lt_key_A)]\n    ---\n    [!SessionKey('A', kdf(identity_B, Y, X))]\n\n// Security properties\nlemmas\n    \n  Key_Agreement:\n    \"All s k. (SessionKey(s, k) & SessionKey(s', k))\n    ==> (s = 'A' & s' = 'B') | (s = 'B' & s' = 'A')\"\n\n  Key_Secrecy:\n    \"All s k. (SessionKey(s, k) & (not (Ex ikc. (ikc = kgc_master_key)) & not (Ex ikb. (ikb = long_term_key(identity_B)))))\n    ==> !(AdversaryKnowledge(k))\"\n\nend"]], "SPTHY-1/Scott_EphkRev.spthy": [[true, "theory ScottProtocol\n\n  // Types\n  type Key\n  type EphemeralKey\n  type SessionKey\n  type Id\n  type Msg\n\n  // Functions\n  function hash(Id): Msg\n  function concat(Msg, Msg): Msg\n  function deriveSessionKey(Msg, Msg): SessionKey\n  function longTermKey(Id): Key\n  function masterSecretKey(): Key\n  function ephemeralKeyGen(): EphemeralKey\n\n  // Initial Knowledge\n  [Fr(~masterSecretKey)]\n\n  // Roles\n  let KGC = Mt(masterSecretKey())\n  rule KGC_Provides_LTK:\n    [Fr(~Id)]\n    -->\n    Out(longTermKey(~Id))\n\n  rule KGC_Reveals_MSK:\n    Out(masterSecretKey())\n\n  // Initialization Phase\n  rule UserA_Init:\n    [Fr(~IdA), Fr(~IdB), Fr(~ephemeralKeyA)]\n    let ltkA = longTermKey(~IdA)\n    let hashB = hash(~IdB)\n    let valueX = concat(ltkA, hashB)\n    -->\n    Out(valueX)\n    Out(ephemeralKeyA)\n\n  // Response Phase\n  rule UserB_Response:\n    In(valueX), [Fr(~IdA), Fr(~IdB), Fr(~ephemeralKeyB)]\n    let ltkB = longTermKey(~IdB)\n    let sessionKeyB = deriveSessionKey(valueX, ephemeralKeyB)\n    let valueY = ephemeralKeyB\n    -->\n    Out(valueY)\n    Out(sessionKeyB)\n\n  // Key Derivation and Agreement\n  rule UserA_ComputeSessionKey:\n    In(valueY), In(ephemeralKeyA)\n    let sessionKeyA = deriveSessionKey(valueY, ephemeralKeyA)\n    --> Out(sessionKeyA)\n\n  // Lemmas for Security\n  lemma KeyAgreement:\n    \"All userA userB. Ex. sessionKeyA sessionKeyB.\n     UserA_Init(userA, userB, sessionKeyA) & UserB_Response(userA, userB, sessionKeyB) &\n     sessionKeyA = sessionKeyB\"\n\n  lemma KeySecrecy:\n    \"All userA userB sessionKeyA.\n     UserA_Init(userA, userB, sessionKeyA) & !(Attacker(sessionKeyA))\"\n\nend"]], "SPTHY-1/secondAttestation.spthy": [[true, "theory SecondEATImplementation\n\nbegin\n\n  /* Types */\n  datatype role = Attester | Verifier\n\n  /* Free Names */\n  free name Attester : role\n  free name Verifier : role\n  free publickey pk_att : pubkey\n  free privatekey pr_att : privkey\n\n  /* Symmetric and Asymmetric Key Predicates */\n  private fun pubkey_gen : privkey -> pubkey\n\n  /* Attester's Key Generation */\n  rule AttesterKeyGen:\n    [ Fr(~ltk) ] --[ GenKey(Attester, pk(~ltk)) ]->\n    [ !PK(Attester, pk(~ltk)) ]\n\n  /* Verifier's Key Generation */\n  rule VerifierKeyGen:\n    [ Fr(~Vltk) ] --[ GenKey(Verifier, pk(~Vltk)) ]->\n    [ !PK(Verifier, pk(~Vltk)) ]\n\n  /* Protocol Rules */\n\n  /* Nonce Request from Verifier to Attester */\n  rule NonceRequest:\n    let nonce = new()\n    in [ In(Verifier, Attester, {nonce}_~Vltk) ]\n    --[ MsgRequest(Verifier, Attester, nonce) ]->\n    [ VerifierRequest(Attester, {nonce}_~Vltk) ]\n\n  /* EAT Generation by Attester */\n  rule GenerateEAT:\n    let eat = {data}_~ltk\n    in [ VerifierRequest(Attester, {nonce}_~Vltk) ]\n    --[ MsgEAT(Attester, {eat}_~ltk) ]->\n    [ Out(Attester, Verifier, {eat}_~ltk) ]\n\n  /* EAT Verification by Verifier */\n  rule VerifyEAT:\n    [ In(Attester, Verifier, {eat}_~ltk),\n      VerifierRequest(Attester, {nonce}_~Vltk) ]\n    --[ MsgVerification(Verifier, Attester, {eat}_~ltk) ]->\n    [ VerifierResponse(Attester, Verified) ]\n\n  /* Lemmas */\n  \n  /* Lemma 1: No false verification of Attester's result by Verifier */\n  lemma no_false_verification:\n    forall V A N EATE.\n      [ MsgRequest(V, A, N) @jn, MsgEAT(A, EATE) @je, MsgVerification(V, A, EATE) @jv ]\n      ==> exists ATT:GenKey(A, pk(~_)) @jk\n         [ MsgVerification(V, ATT, EATE) ]\n\n  /* Lemma 2: Attester in bad state does not lead to successful verification */\n  lemma attester_bad_state_no_verification:\n    forall V A N EATE.\n      [ MsgRequest(V, A, N) @jn, MsgEAT(A, EATE) @je, MsgVerification(V, A, EATE) @jv ]\n      ==> not BadState(A) @jb\n         ==> not VerifierResponse(A, Verified)\n\n  /* Restrictions */\n  constmsg Attack : message\n\n  restriction nonce_integrity:\n    forall V A N.\n      [ MsgRequest(V, A, N) @ j, not Out(_, _, Attack) ]\n      ==> not In(Verifier, Attester, Attack) @ j\n\nend"]], "SPTHY-1/sigfox-R.spthy": [[true, "theory SigfoxImplementation\n\nbegin\n\n  builtins: asymmetric-encryption, signatures\n\n  types: \n    Agent\n    Nonce \n\n  functions:\n    pkA: Agent -> PubKey\n    pkB: Agent -> PubKey\n    skA: Agent -> SecKey\n    skB: Agent -> SecKey\n    sig: Message * SecKey -> Signature\n    enc: Message * PubKey -> Ciphertext\n\n  signature:\n    free a, b: Agent\n    free na: Nonce\n\n  equations:\n    enc(inv(pkA(a)), skA(a)) = pair(a, na)\n\n  rules:\n\n    // Key Registration\n    KeyRegistration:\n      [ Fr(~ltkA) ]\n      --[ PKI_Registration(a, pkA(a)) ]->\n      [ !PublicKey(a, pkA(a)), Ltk(a, ~ltkA) ]\n\n    // Role A -> B: Sending Message\n    Send_AtoB:\n      [ !PublicKey(b, pkB(b)), Fr(~na), Ltk(a, ~ltkA) ]\n      --[ SendMessage(a, b, na) ]->\n      [ Out(enc((a, ~na), pkB(b)), sig((a, ~na), skA(a))) ]\n\n    // Role B -> A: Receiving and verifying message\n    Receive_BfromA:\n      [ In(enc((a, na), pkB(b)), sig((a, na), skA(a))),\n        !PublicKey(a, pkA(a)), !PublicKey(b, pkB(b)) ]\n      --[ ReceiveMessage(b, a, na) ]->\n      [Secret(nonA, b)]\n\n  lemmas:\n\n    executable:\n      exists-trace\n\n    secret_A:\n      All x #i. Secret(x, a) @i ==> Not(bad) @i\n\n    secret_B:\n      All x #i. Secret(x, b) @i ==> Not(bad) @i\n\n    secrecy_PFS_A:\n      All x #i. (Not(RevLtk(a)) @i & Secret(x, b) @i) ==> \n                (Not(RevLtk(a)) @i & Not(Secret(x, b)) @i)\n\nend"]], "SPTHY-1/STS_MAC.spthy": [[true, "theory STS_MAC_Variant\n\nbegin\n\nfunctions\n    mac/3, kdf/3, pk/1, sk/1, epk/1, esk/1, nonce/1, sid/1, message/1\n\nbuiltins: asymmetric-encryption, hashing\n\n// State facts to track the stages of the protocol\ntype state: Init, RcvdSignature, RcvdMAC, KeyDerivation\n\nrules\n\n// Rule: Register_pk_clone\nrule Register_pk_clone:\n    let\n        A'\n    in\n    [ Fr(~A') ]\n    -->\n    [ !PublicKeyOwned(A', pk(A')), !IsCorrupt(A') ]\n\n// Rule: Init_1 (Party I)\nrule Init_1:\n    let\n        I, R, ni\n    in\n    [ Fr(~eskI), Fr(~ni), !PublicKeyOwned(I, pk(I)) ]\n  --[ InitSent($I, message(I, R, epk(~eskI), nonce(~ni))) ]->\n    [ State(Init, I, R, epk(~eskI), nonce(~ni)), Out(<pk(I), epk(~eskI), nonce(~ni)>) ]\n\n// Rule: Resp_1 (Party R)\nrule Resp_1:\n    let\n        I, R, ni, nr\n    in\n    [ State(Init, I, R, epk(~eskI), ni), !PublicKeyOwned(R, pk(R)), Fr(~eskR), Fr(~nr) ]\n  --[ ResponseSent($R, message(R, I, epk(~eskR), nonce(~nr), mac(pk(R), epk(~eskR), ni))) ]->\n    [ State(RcvdSignature, I, R, epk(~eskR), nonce(~nr)), Out(<pk(R), epk(~eskR), nonce(~nr), mac(pk(R), epk(~eskR), ni)>) ]\n\n// Rule: Init_2 (Party I verifying R's response)\nrule Init_2:\n    let\n        I, R, ni, nr, macR\n    in\n    [ State(Init, I, R, epk(~eskI), ni), In(<pk(R), epk(~eskR), nr, macR>) ]\n  --[ ReceivedSignatureR($I, message(R, I, epk(~eskR), ni)) ]->\n    [ State(RcvdMAC, I, R, epk(~eskI), epk(~eskR)), Out(<>), Fr(~k) ]\n\n// Rule: Sessionkey\nrule KeyDerivation:\n    let\n        I, R, ni, nr\n    in\n    [ State(RcvdMAC, I, R, epk(~eskI), epk(~eskR)) ]\n  --[ KeyDerived($I, $R, sid(epk(~eskI), epk(~eskR)), kdf(epk(~eskI), epk(~eskR), ni, nr)) ]->\n    [ !SessionKey(I, R, sid(epk(~eskI), epk(~eskR))), Out(<>) ]\n\n// Lemmas for PFS\nlemma PFS_1:\n    \"All I R k. (KeyDerived(I, R, _, k) & !(IsCorrupt(I) | IsCorrupt(R))) ==> not(Ex kn. !SessionKey(I, R, kn))\"\n\nend"]], "SPTHY-1/TCP.spthy": [[true, "theory TCPHandShake\nbegin\n\nrule SYN:\n  []\n  --[ Begin() ]->\n  [ St_AliceWait(), Out('SYN') ]\n\nrule SYNACK:\n  [ In('SYN') ]\n  -->\n  [ St_BobWait(), Out('SYNACK') ]\n\nrule ACK:\n  [ St_AliceWait(), In('SYNACK') ]\n  -->\n  [ Out('ACK') ]\n\nrule FIN:\n  [ St_BobWait(), In('ACK') ]\n  --[ End() ]->\n  []\n\nlemma Works:\n  exists-trace\n  \"Ex #t1 #t2. Begin() @ #t1 & End() @ #t2\"\n\nlemma BulletProof:\n  all-traces\n  \"All #t1. Begin() @ #t1 ==> Ex #t2. End() @ #t2 & #t1 < #t2\"\n\nend"]], "SPTHY-1/testConstructor.spthy": [[true, "theory Protocol_Security\n\nbegin\n\n// Functions and sorts\nfunctions\n    xor/2\n\nsorts\n    key\n\n\n// Variables\nvariables\n    x1, x2, x3, x4: key\n\n\n// Rules\nrule Test1:\n    [ Fr(x1), Fr(x2), Fr(x3), Fr(x4),\n      !Challenge1(x1, x2, x3, x4)\n    ]\n    --[\n      Out(xor(x1, x2)), \n      Out(x3), \n      Out(x4)\n    ]-->\n\nrule Test2:\n    [ Fr(x1), Fr(x2), Fr(x3), Fr(x4),\n      !Challenge2(x1, x2, x3, x4)\n    ]\n    --[\n      Out(x1), \n      Out(x2), \n      Out(x3), \n      Out(x4)\n    ]-->\n\nrule Test3:\n    [ Fr(x1), Fr(x2), Fr(x3), Fr(x4),\n      !Challenge3(x1, x2, x4)\n    ]\n    --[\n      Out(x1), \n      Out(x2), \n      Out(xor(x3, x4))\n    ]-->\n\n\n// Security Assertions\nlemma secret1:\n    \"All x1 x2 x3 x4.\n     (Challenge1(x1, x2, x3, x4) => not K(xor(x1, x2)))\"\n\nlemma secret2:\n    \"All x1 x2 x3 x4.\n     (Challenge2(x1, x2, x3, x4) => not K(x1) /\\ not K(x2) /\\ not K(x3) /\\ not K(x4))\"\n\nlemma secret3:\n    \"All x1 x2 x4.\n     (Challenge3(x1, x2, x4) => not K(x1) /\\ not K(xor(x3, x4)))\"\n\n\nend"]], "SPTHY-1/traceable.spthy": [[true, "/* Tamarin Model for RFID Unlinkability */\n\ntheory RFID_Unlinkability\n\n// Define the types for keys, nonce, and hashes\nfunctions: \n  key: type.\n  nonce: type.\n  hash: type.\n  tagID: type.\n\n// Define the setup phase: generation of keys and identifiers\nrules:\n\n  // Rule: Initialize\n  [Fr(k1), Fr(k2), Fr(readerID)]\n  -->\n  [ State(TAG1: tagID), State(TAG2: tagID), State(READER: readerID),\n    State(KEY1: key{k1}), State(KEY2: key{k2})]\n\n// Define tag selection and reader readiness\nrules:\n\n  // Rule: Tag Ready\n  [State(TAG1: tagID)]\n  -->\n  [Out(tag_ready(TAG1))]\n\n  // Rule: Reader Ready\n  [State(READER: readerID)]\n  -->\n  [Out(reader_ready(READER))]\n\n// Define the communication phase where reader sends nonce and tag responds\nrules:\n\n  // Rule: Reader Sends Nonce\n  [State(READER: readerID), Out(reader_ready(READER))]\n  -->\n  [Fr(nr), Out(nonce(nr))]\n\n  // Rule: Tag Responds\n  [Out(tag_ready(TAG1)), Out(nonce(nr)), State(KEY1: key{k1})]\n  -->\n  [Out(response(hash(nr, k1)))]\n\n  [Out(tag_ready(TAG2)), Out(nonce(nr)), State(KEY2: key{k2})]\n  -->\n  [Out(response(hash(nr, k2)))]\n\n// Define the finishing of the transaction\nrules:\n\n  // Rule: Reader Completes Transaction\n  [Out(response(hash(nr,_))), Out(reader_ready(READER))]\n  -->\n  [Out(transaction_complete(READER))]\n\n// Define the security goals for unlinkability\nlemmas:\n\n  // Lemma: Unlinkability\n  Unlinkability:\n  \"All traces ( [Out(response(hash(nr,_)))] ) ==> (Exists k. [State(KEY1: key{k}), State(TAG1: tagID)] # [State(KEY2: key{k}), State(TAG2: tagID)] )\"\n\nend RFID_Unlinkability"]], "SPTHY-1/UM_one_pass_attack.spthy": [[true, "// Participants\nfunctions\n    pkA/1, pkB/1: -> data // Public keys\n    'g'/0: data // Generator of the underlying group\n    ~ea/0, ~eb/0, ~ex/0: -> privkey // Private keys\n\n// Protocol Roles\nrules\n\n    // Key Registration by the Initiator (A)\n    Registration_A:\n        [Fr(~ea)]\n        --[ Register($A, pkA(~ea)) ]->\n\n    // Initiator Activation\n    Initiator_Activation:\n        [Fr(~ex)]\n        --[ Init($A, $B, ~ex, 'g'^~ex) ]->\n        [ State_A($A, $B, ~ex, 'g'^~ex) ]\n\n    // Initiator Completion\n    Initiator_Completion:\n        [ State_A($A, $B, ~ex, 'g'^~ex) ]\n        --[ Sends($A, $B, 'g'^~ex) ]->\n        [ Complete_A($A, $B, 'g'^~ex, pkB(~eb), 'g'^(~ex * ~eb)) ]\n\n    // Responder Completion\n    Responder_Completion:\n        [ Fr(~eb), !Register($A, pkA(~ea)), !Register($B, pkB(~eb)), Receive($A, $B, 'g'^~ex) ]\n        --[ Complete($B, $A, 'g'^~ex, pkA(~ea), 'g'^(~ea * ~ex)) ]->\n        [ Complete_B($A, $B, 'g'^~ex, pkA(~ea), 'g'^(~ea * ~ex)) ]\n\n    // Session Expiration\n    Expire_A:\n        [ Complete_A($A, $B, 'g'^~ex, pkB(~eb), 'g'^(~ex * ~eb)) ]\n        --[ Expired($A, $B) ]->\n    \n    Expire_B:\n        [ Complete_B($A, $B, 'g'^~ex, pkA(~ea), 'g'^(~ea * ~ex)) ]\n        --[ Expired($A, $B) ]->\n\n// Adversary Capabilities\nfunctions\n    Corrupt/1: data -> fact \n    Reveal_SessionKey/1: data -> fact \n\nrules\n\n    // Corruption of Participants\n    Corrupt_A:\n        [ Fr(~ea) ]\n        --[ Corrupt($A) ]->\n    \n    Corrupt_B:\n        [ Fr(~eb) ]\n        --[ Corrupt($B) ]->\n\n    // Reveal Session Keys\n    Reveal_SessionKey_A:\n        [ Complete_A($A, $B, 'g'^~ex, pkB(~eb), 'g'^(~ex * ~eb)) ]\n        --[ Reveal_SessionKey($A, $B) ]->\n\n    Reveal_SessionKey_B:\n        [ Complete_B($A, $B, 'g'^~ex, pkA(~ea), 'g'^(~ea * ~ex)) ]\n        --[ Reveal_SessionKey($A, $B) ]->\n\n// Lemmas for Security Properties\nlemmas\n\n    // Key Agreement Reachability\n    key_agreement_reachability:\n        [ Init($A, $B, ~ex, 'g'^~ex), Receive($A, $B, 'g'^~ex) ]\n        => Ex1($key). [\n            Complete_A($A, $B, 'g'^~ex, pkB(~eb), $key),\n            Complete_B($A, $B, 'g'^~ex, pkA(~ea), $key)\n        ]\n\n    // Confidentiality of Session Keys\n    confidentiality_session_keys:\n        [ !Reveal_SessionKey($A, $B) ]\n        => [ ~Expired($A, $B) => !Corrupt($A), !Corrupt($B) ]"]]}