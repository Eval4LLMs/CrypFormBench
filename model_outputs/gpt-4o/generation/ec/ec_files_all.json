{"EC-1/AAPI.ec": [[true, "module APIProtocol\n\n  type public_t\n  type inputs_t\n  type outputs_t\n  type svar_t\n  type sop_t\n  type sideInfo_t\n\n  type apiCall_data\n  type apiRes_data\n  type apiCallRes\n\n  (* Operation specifications *)\n  proc apiCall(x: apiCallRes) : option apiCall_data\n  proc apiRes(x: apiCallRes) : option apiRes_data\n\n  (* Handle generation module *)\n  module Handle\n    proc create_handle(hdls: svar_t fset) : svar_t\n  end\n\n  (* API interface *)\n  proc init() : unit\n  proc nparties() : int\n  proc declass(a: svar_t) : public_t * sideInfo_t\n  proc input(a: svar_t, inp: inputs_t) : unit\n  proc output(a: svar_t) : outputs_t * sideInfo_t\n\n  proc sop(sop: sop_t, pargs: list public_t, sargs: list svar_t, result: svar_t) : sideInfo_t\n\nend"]], "EC-1/abstract-ind-ror.ec": [[true, "require import Real Bool DBool.\n\n(* Abstract data types *)\ntype msg.\ntype key.\n\n(* Random oracle *)\ntype ro_input = msg * key.\ntype ro_output = bool.\n\n(* Challenger's random oracle *)\nfunction ro : ro_input -> ro_output {\n  forall x:ro_input. exists y:ro_output. ro(x) = y\n}\n\n(* Encryption scheme *)\nfunction encrypt : msg * key -> ro_output.\n(*  Example encryption scheme *)\nfunction encrypt (m:msg, k:key) : ro_output {\n  (* Replace with your encryption scheme *)\n  ro((m,k))\n}\n\n\n(* Adversary's view *)\ntype adversary_view = list ro_input * list ro_output.\n\n(* Adversary's algorithm *)\nfunction adversary (view:adversary_view) : msg * key.\n(* Replace with your adversary's algorithm *)\nfunction adversary (view:adversary_view) : msg * key {\n  match view with\n  | (q, r) =>\n      (* Example:  extract a key from the responses and return a message with that key *)\n      let (queries, responses) = view in\n      let key = (hd responses) in\n      (msg_0, key)\n  end\n}\n\n\n(* Encryption function *)\nfunction encrypt_scheme(m:msg, k:key) : ro_output {\n  ro((m,k))\n}\n\n\n(* Game definition *)\nfunction game (adv:adversary) : bool {\n  (* Randomly choose a bit *)\n  let b = choose {0, 1} in\n  (* Randomly choose a message *)\n  let m = choose msg in\n  (* Randomly choose a key *)\n  let k = choose key in\n  let encrypted_msg = encrypt_scheme(m, k) in\n  let view_1 = ([], []) in\n  let (m1, k1) = adv(view_1) in\n  b = 0\n}\n\n\n\n(* Security goal *)\n(* Replace with your security goal *)\n(* Example:  The indistinguishability property *)\nlemma indistinguishability_goal (adv:adversary) :\n  {1/2} (game(adv)) = {1/2} (game(adv))."]], "EC-1/basic-hash-single-tag.ec": [[true, "module type PRF = {\n  type key\n  type plain\n  type hash\n\n  val prf: key -> plain -> hash\n  axiom prf_functional: forall k p1 p2. prf k p1 = prf k p2 -> p1 = p2\n\n  predicate valid_hash: key -> plain -> hash -> bool\n  axiom prf_validity: forall k p h. valid_hash k p h <-> prf k p = h\n}.\n\nmodule BasicHash0 (P: PRF) = {\n  open P\n\n  type nonce = plain\n  type tag = (nonce * hash)\n\n  val gen_tag: key -> nonce -> tag\n  let gen_tag k n = (n, prf k n)\n\n  val verify: key -> tag -> bool\n  let verify k (n, h) = valid_hash k n h\n}.\n\nmodule BasicHash (P: PRF) = {\n  open P\n\n  var global_key: key\n\n  procedure initialize (k: key) = {\n    global_key <- k\n  }\n\n  type nonce = plain\n  type tag = (nonce * hash)\n\n  val gen_tag: nonce -> tag\n  let gen_tag n = (n, prf global_key n)\n\n  val verify: tag -> bool\n  let verify (n, h) = valid_hash global_key n h\n}.\n\nmodule type Adversary = {\n  type query\n\n  val forge_attempt: query -> bool\n  (* Implement attempts to generate valid nonces and hashes *)\n}.\n\nmodule AuthenticationGame (BH: BasicHash.PRF) (Adv: Adversary) = {\n  open BH\n\n  procedure authentication_game (init_key: key) {\n    local nonce, hash\n\n    initialize init_key\n\n    (* Generate random nonce *)\n    nonce <- random_nonce()\n\n    (* Generate hash to send *)\n    hash <- prf init_key nonce\n\n    (* Adversary makes an attempt to forge valid pair *)\n    if Adv.forge_attempt (nonce, hash) then\n      failure\n  }\n\n  lemma prob_equivalence:\n    forall k. Pr[ authentication_game(k)] <= Pr[ indistinguishability_game(k) ]\n\n  lemma unforgeability:\n    forall k. Pr[ authentication_game(k)] = 0\n}.\n\nmodule IndistinguishabilityGame (U: PRF) = {\n  open U\n\n  (* Define an indistinguishability game *)\n  procedure indistinguishability_game (key: key) {\n    (* Adversary model would attempt 'guess' the hash function behavior *)\n    ... (* Placeholder for adversary model specifics *)\n  }\n}"]], "EC-1/br93.ec": [[true, "module BR93_Scheme {\n\n  type ptxt\n  type rand\n  type ctxt = (rand, ptxt)\n\n  module KeyGen = {\n    type pkey\n    type skey\n    val keygen: unit -> (pkey, skey)\n  }\n\n  module TrapdoorPermutation = {\n    val f: KeyGen.pkey -> rand -> rand\n    val fi: KeyGen.skey -> rand -> rand\n    axiom trapdoor: forall k:KeyGen.pkey, r:rand, s:KeyGen.skey, KeyGen.keygen() = (k, s) -> \n                      fi(s, f(k, r)) = r\n  }\n\n  module RandomOracle = {\n    val H: rand -> ptxt\n  }\n\n  val enc: KeyGen.pkey -> ptxt -> ctxt\n  fun enc(k, m) = {\n    var r = Random.rand();\n    var h = RandomOracle.H(r);\n    (TrapdoorPermutation.f(k, r), m +^ h)\n  }\n\n  val dec: KeyGen.skey -> ctxt -> ptxt\n  fun dec(s, (c1, c2)) = {\n    var r = TrapdoorPermutation.fi(s, c1);\n    var h = RandomOracle.H(r);\n    c2 +^ (- h)\n  }\n\n  module IND_CPA = {\n    proc oracle_1 (k:KeyGen.pkey, m0:ptxt, m1:ptxt): ctxt = {\n      var b = Random.new_bool();\n      enc(k, if b then m0 else m1)\n    }\n\n    proc oracle_2 (k:KeyGen.pkey, b:bool, m0:ptxt, m1:ptxt, c:ctxt): bool = {\n      let pl = dec(KeyGen.keygen().2, c) in\n      if b then pl = m0 else pl = m1\n    }\n\n    axiom ind_cpa_sec: exists (adv: IND_CPA.oracle_1 * IND_CPA.oracle_2),\n      Pr[IND_CPA.type -> bool: \n        var (k, s) = KeyGen.keygen() in\n        var m0, m1 = Random.choice() in\n        var (c, b) = IND_CPA.oracle_1(k, m0, m1) in\n        var t = IND_CPA.oracle_2(k, b, m0, m1, c) in\n        t = 1\n      ] = 1/2\n  }\n\n}"]], "EC-1/cfold.ec": [[true, "theory CfoldStopIf.\n\nmodule CfoldStopIf = {\n\n  val f: int -> int -> int\n\n  let f(a: int, b: int) : int = {\n    var c = 0 in\n    var d = c + 1 in\n    c <- a + b;\n    if a + b == c then {\n      c <- 0;\n      a <- c\n    } else {\n      c <- 1;\n      b <- c\n    };\n    c\n  }\n\n}\n\nlemma cfold_stop_if: \n  forall a b. true ==> CfoldStopIf.f(a, b) = 0.\n\nproof.\n  intros a b.\n  unfold CfoldStopIf.f.\n  intros.\n  destruct (a + b == (a + b)) as [].\n  - reflexivity.\n  - contradiction.\nqed.\n\nend\n\ntheory CfoldTuple.\n\nmodule CfoldTuple = {\n\n  val f: int * int -> int\n\n  let f(x: int * int) : int = {\n    var a = 0 in\n    var b = 0 in\n    var c = 0 in\n    x <- (0, 0);\n    a <- fst x;\n    b <- snd x;\n    while a + b <> b + a do {\n      c <- c + 1\n    };\n    c\n  }\n}\n\nlemma cfold_tuple: \n  forall x. true ==> CfoldTuple.f(x) = 0.\n\nproof.\n  intros (a, b).\n  unfold CfoldTuple.f.\n  intros.\n  assert (a + b == b + a) by (apply plus_comm).\n  while_induction. \n  - apply plus_comm.\n  - entailment; auto.\n  reflexivity.\nqed.\n\nend\n\ntheory CfoldN.\n\nmodule CfoldN = {\n\n  val f: int -> int -> int\n\n  let f(a: int, b: int) : int = {\n    var c = 0 in\n    a <- 1;\n    b <- 2;\n    c <- 2;\n    a <- 3;\n    c <- 3;\n    if a <> b then {\n      c <- 0\n    };\n    c\n  }\n\n}\n\nlemma cfold_n: \n  forall a b. true ==> CfoldN.f(a, b) = 0.\n\nproof.\n  intros a b.\n  unfold CfoldN.f.\n  intros.\n  assert (3 <> 2) by omega.\n  assert (0 = 0) by reflexivity.\n  contradiction.\nqed.\n\nend\n\ntheory CfoldWhileUnroll.\n\nmodule CfoldWhileUnroll = {\n\n  val f: int -> int -> int\n\n  let f(a: int, b: int) : int = {\n    var c = 0 in\n    c <- c + 1;\n    c <- 0;\n    while c < 10 do {\n      a <- c;\n      c <- c + 1\n    };\n    b <- c;\n    if a <> b then {\n      c <- 0\n    };\n    c\n  }\n\n}\n\nlemma cfold_while_unroll: \n  forall a b. true ==> CfoldWhileUnroll.f(a, b) = 0.\n\nproof.\n  intros a b.\n  unfold CfoldWhileUnroll.f.\n  intros.\n  while_induction.\n  - omega.\n  - omega.\n  - omega.\n  reflexivity.\nqed.\n\nend"]], "EC-1/CommitmentSpecial.ec": [[true, "module type CommitmentScheme = {\n  type commitment\n  type opening\n  type message\n\n  op Com: message -> (commitment * opening) distr\n  op Ver: message * (commitment * opening) -> bool\n\n  axiom Com_sound: forall (x : message * (commitment * opening)),\n    Ver x = true\n\n  axiom Com_lossless: forall b : message, is_lossless (Com b)\n}\n\nmodule type Parameters = {\n  pred eps_ge0: 0%r <= eps\n  pred eps2_ge0: 0%r <= eps2 < 1%r/4%r\n}\n\nmodule Binder = {\n  proc bind() : (message * commitment * opening * message * opening) = {\n    var m : message;\n    var m' : message;\n    var c_open, c_open' : opening;\n    var c : commitment;\n    var c' : commitment;\n    (c, c_open) = Com m;\n    (c', c_open') = Com m';\n    return (m, c, c_open, m', c_open')\n  }\n}\n\nmodule BindingExperiment(P: CommitmentScheme) = {\n  proc main() : bool = {\n    var (m, c, c_open, m', c_open') = Binder.bind();\n    if Ver (m, (c, c_open)) && Ver (m', (c', c_open')) && m <> m' then return true;\n    return false\n  }\n}\n\nmodule Unhider = {\n  proc choose() : (list message * list message) = {\n    var l0 : list message;\n    var l1 : list message;\n    return (l0, l1)\n  }\n  \n  proc guess(c : list commitment) : int = {\n    var choice : int;\n    // Implement the guessing strategy here\n    return choice\n  }\n}\n\nmodule HidingExperiment(U: Unhider) = {\n  proc main() : res = {\n    var (l0, l1) = U.choose();\n    var b : int;\n    var mshs : list message;\n    var chsh : list message;\n    var ch : list commitment;\n    \n    b = random(0,1);\n    if b = 0 then mshs = l0 else mshs = l1;\n    \n    ch = map (fun m => fst (Com m)) mshs;\n    if U.guess(ch) = b then return true;\n    return false\n  }\n  \n  axiom comm_scheme_hiding_eps2: forall (U : Unhider),\n    |Pr[main() @ HidingExperiment(U) : res = true] - 1%r/2%r| <= eps2\n}\n\nmodule HidingGame(U: Unhider) = {\n  proc main(b: int) : res = {\n    var (l0, l1) = U.choose();\n    var mshs : list message;\n    var ch : list commitment;\n    \n    if b = 0 then mshs = l0 else mshs = l1;\n    \n    ch = map (fun m => fst (Com m)) mshs;\n    if U.guess(ch) = b then return true;\n    return false\n  }\n  \n  axiom comm_scheme_hiding_eps: forall (U : Unhider),\n    |Pr[main(true) @ HidingGame(U) : res = true] - Pr[main(false) @ HidingGame(U) : res = true]| <= eps\n}"]], "EC-1/ddh-1.ec": [[false, "Below is the formal analysis code for the Decisional Diffie-Hellman (DDH) protocol using the EasyCrypt language:\n\n```ocaml\n(* DDH Protocol Formal Analysis *)\n\nmodule type KEY = {\n  type key\n\n  (* Key binary operation *)\n  op (^^) : key -> key -> key\n\n  (* Identity element for key operation *)\n  op kid : key\n\n  (* Inverse operation for keys *)\n  op kinv : key -> key\n\n  (* Axiom: Associativity of key operation *)\n  axiom assoc_key : forall k1 k2 k3, (k1 ^^ k2) ^^ k3 = k1 ^^ (k2 ^^ k3)\n\n  (* Axiom: Identity element for key operation *)\n  axiom ident_key : (forall k, kid ^^ k = k) /\\ (forall k, k ^^ kid = k)\n\n  (* Axiom: Inverse property for keys *)\n  axiom inv_key : forall k, k ^^ kinv k = kid\n}\n\nmodule type EXPONENT = {\n  type exp\n\n  (* Exponent multiplication operation *)\n  op (*) : exp -> exp -> exp\n\n  (* Axiom: Commutativity of exponent multiplication *)\n  axiom comm_exp : forall e1 e2, e1 * e2 = e2 * e1\n\n  (* Axiom: Associativity of exponent multiplication *)\n  axiom assoc_exp : forall e1 e2 e3, (e1 * e2) * e3 = e1 * (e2 * e3)\n}\n\nmodule DDH(K : KEY)(E : EXPONENT) = {\n  open K\n  open E\n\n  (* Distribution of exponents *)\n  axiom exp_dist : exists dexp, is_distrib dexp /\\ is_full dexp /\\ is_uniform dexp /\\ is_lossless dexp\n\n  (* Generator key *)\n  var g : key\n\n  (* Key generation *)\n  proc gen_key(e : exp) : key = g ^^ e\n\n  (* Axiom: Uniqueness of key generation *)\n  axiom unique_key : forall e1 e2, (g ^^ e1 = g ^^ e2) -> e1 = e2\n\n  (* DDH adversarial experiment *)\n  proc DDH_experiment(ddh_choice : bool) : key * key * key = {\n    var q1 : exp = sample dexp\n    var q2 : exp = sample dexp\n    var q3 : exp = if ddh_choice then q1 * q2 else sample dexp\n\n    return (g ^^ q1, g ^^ q2, g ^^ q3)\n  }\n\n  (* Adversarial advantage *)\n  proc advantage(Adv : key * key * key -> bool) : real = {\n    var ddh1 = DDH_experiment(true)\n    var ddh2 = DDH_experiment(false)\n    return abs(probability (Adv ddh1) - probability (Adv ddh2))\n  }\n}\n\n(* Conclusion: The DDH assumption implies Adv's advantage is negligible *)\n\n```\n\nThis code utilizes the types, operations, axioms, and adversarial models described in your DDH protocol description. The formal module structures represent the key and exponent operations, encapsulate the DDH challenge, and compute the adversarial advantage as per the DDH assumption. Ensure that the modules are instantiated in your EasyCrypt environment with corresponding implementation details for testing and verification."]], "EC-1/elgamal.ec": [[true, "module ElGamalEncryptionAndDDH.\n\n  module type GROUP = {\n    type t.\n    val zero : t.\n    val one : t.\n    val generator : t.\n    val mul : t -> t -> t.\n    val inv : t -> t.\n    val exp : t -> nat -> t.\n    val eq : t -> t -> bool.\n  \n    predicate is_group : t -> bool.\n  }.\n\n  module ElGamal (G : GROUP) = {\n    type pkey = G.t.\n    type skey = int.\n    type ptxt = G.t.\n    type ctxt = G.t * G.t.\n\n    (* Key Generation *)\n    proc kg() : pkey * skey = {\n      var sk : skey = random_int();\n      var pk : pkey = G.exp(G.generator, sk);\n      return (pk, sk);\n    }\n    \n    (* Encryption *)\n    proc enc(pk : pkey, m : ptxt) : ctxt = {\n      var y : nat = random_nat();\n      var c1 : G.t = G.exp(G.generator, y);\n      var c2 : G.t = G.mul(G.exp(pk, y), m);\n      return (c1, c2);\n    }\n\n    (* Decryption *)\n    proc dec(sk : skey, c : ctxt) : ptxt = {\n      var (c1, c2) = c;\n      var m : ptxt = G.mul(c2, G.inv(G.exp(c1, sk)));\n      return m;\n    }\n\n    (* Security Proof Constructs *)\n    module type DDH_ADVR = {\n      proc ddh(pk_a : pkey, pk_b : pkey, pk_c : pkey): bool \n      }\n    \n    module DDHReduction (DDHAdv : DDH_ADVR) = {\n      var adversary : DDHAdv.ddh.\n      \n      axiom ddh_reduction(A : adversary, problem : (G.t * G.t * G.t)) : real = {\n        let (ga, gb, gc) = problem;\n        if DDHAdv.ddh(ga, gb, gc) then 1 else 0\n      }\n    \n      theorem ElGamal_security : \u2200 A : adversary,\n        let advantage_distinguisher = ddh_reduction(A, (G.generator, G.mul(G.generator, random_nat()), G.mul(G.generator, random_nat())));\n        Pr[advantage_distinguisher] <= Pr[DDHAdv.ddh(G.generator, G.mul(G.generator, random_nat()), G.exp(G.generator, random_nat()))].\n    }\n  }\n\nend"]], "EC-1/EventPartitioning.ec": [[true, "module type T = {\n  type input\n  type output\n  val f : input -> output\n}\n\nmodule M : T = {\n  type input\n  type output\n  let f (x : input) : output = \n    (* Definition of the function goes here *)\n}\n\nmodule Ref : T = {\n  type input\n  type output\n  let f (x : input) : output = \n    (* Reference implementation *)\n}\n\n(* Theory: List Partitioning *)\nmodule ListPartitioningTheory = {\n  lemma list_partitioning (E : output -> bool) (inputs : list input) : unit =\n    (* Formal statement of the lemma *)\n    // assert the probability of an output being in a particular state \n\n}\n\n(* Theory: FSet Partitioning *)\nmodule FSetPartitioningTheory = {\n  lemma fset_partitioning (E : output -> bool) (inputs : fset input) : unit =\n    (* Formal statement of the lemma *)\n    // assert the probability distribution derived from finite set partitions\n\n}\n\n(* Theory: FPred Partitioning *)\nmodule FPredPartitioningTheory = {\n  lemma fpred_partitioning (E : output -> bool) (inputs : fpred input) : unit =\n    (* Formal statement of the lemma *)\n    // formalize the probability of outputs and finite predicate partitions\n\n}\n\n(* Theory: Result Partitioning *)\nmodule ResultPartitioningTheory = {\n  lemma result_partitioning (outputs : list output) : unit =\n    (* Formal statement of the lemma *)\n    // decompose probability of the output into contributions from distinct outputs\n\n}\n\n(* Theory: Total Result Partitioning *)\nmodule TotalResultPartitioningTheory = {\n  lemma total_result_partitioning (outputs : fset output) : unit =\n    (* Formal statement of the lemma *)\n    // express probabilities without uncertainty for well-defined outputs\n\n}\n\n(* Theory: Total Subuniform Result Only *)\nmodule TotalSubuniformResultOnlyTheory = {\n  axiom subuniform_condition (inputs : list input) : unit =\n    (* Formal statement of the axioms *)\n    // analyze output probabilities based on certain conditions\n\n}\n\n(* Theory: Subuniform Reference *)\nmodule SubuniformReferenceTheory = {\n  lemma reference_equivalence (inputs : list input) (xs : list output) : unit =\n    (* Formal statement of the lemma *)\n    // establish equivalence between M and Ref under certain conditions\n\n  lemma subuniform_behavior (inputs : list input) (xs : list output) : unit =\n    (* Formal statement of the lemma *)\n    // bounds and constraints on the behavior of M.f relative to Ref.f\n\n}"]], "EC-1/FMapAux.ec": [[true, "module type FMap = {\n  type key  // Type for keys\n  type 'a t // Type for finite maps\n\n  val eq_except : (key -> bool) -> 'a t -> 'a t -> bool\n  val set : 'a t -> key -> 'a -> 'a t\n  val get : 'a t -> key -> 'a\n}\n\nmodule FMapAux (M: FMap) = {\n  \n  lemma eq_except_pred_set: forall (X: M.key -> bool) (m1 m2: 'b M.t) (x: M.key) (y y': 'b),\n    M.eq_except X m1 m2 -> \n    X x -> \n    M.eq_except X (M.set m1 x y) (M.set m2 x y').\n  proof.\n    // Proof omitted for brevity.\n  qed.\n\n  lemma eq_except_pred_set_l: forall (X: M.key -> bool) (m1 m2: 'b M.t) (x: M.key) (y: 'b),\n    M.eq_except X m1 m2 -> \n    X x -> \n    M.eq_except X (M.set m1 x y) m2.\n  proof.\n    // Proof omitted for brevity.\n  qed.\n\n  lemma eq_except_pred_set_r: forall (X: M.key -> bool) (m1 m2: 'b M.t) (x: M.key) (y: 'b),\n    M.eq_except X m1 m2 -> \n    X x -> \n    M.eq_except X m1 (M.set m2 x y).\n  proof.\n    // Proof omitted for brevity.\n  qed.\n\n  lemma eq_except_not_pred_get: forall (X: M.key -> bool) (m1 m2: 'b M.t) (x: M.key),\n    M.eq_except X m1 m2 -> \n    ~X x -> \n    M.get m1 x = M.get m2 x.\n  proof.\n    // Proof omitted for brevity.\n  qed.\n}"]], "EC-1/FundamentalLemma.ec": [[true, "(* Begin imports section *)\nrequire import Discrete.\nrequire import Real.\nrequire import StdOrder.RealOrder.\n\n(* Define the max operation *)\nop max(x y: real): real =\n  if x <= y then y else x.\n\n(* Declare the type for outcomes *)\ntype t.\n\n(* Define memory module with an empty signature *)\nmodule type Mem = {\n  (* Empty signature for flexibility in implementations *)\n}.\n\n(* Define the experiment module with procedure main *)\nmodule type Exp = {\n  proc main(): t.\n}.\n\n(* Lemma for probability splitting *)\nlemma Pr_split: \nforall (G: Exp) (m: Mem) (A F: pred t),\n  Pr[G.main() @ m: A /\\ F] + Pr[G.main() @ m: A /\\ ~F] = Pr[G.main() @ m: A].\n\n(* Fundamental lemma for bounding the probability difference *)\nlemma FundamentalLemma:\nforall (G1 G2: Exp) (m: Mem) (A B F: pred t),\n  |Pr[G1.main() @ m: A] - Pr[G2.main() @ m: B]| <= max(Pr[G1.main() @ m: F], Pr[G2.main() @ m: F])."]], "EC-1/generalize-module-aliases.ec": [[true, "module type T = {\n  proc f(): bool\n}.\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare module M_T1 <: T.\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule A2 = F(M_T1).\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof. admitted.\n\nhoare L2: A2(C).M.N.g: true ==> true.\nproof. admitted.\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed.\n\nhoare LL2 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L1 M1 C). qed.\n\nhoare LL3 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L2 M1). qed."]], "EC-1/AES.ec": [[true, "module AES {\n\n  (* Define basic types *)\n  type byte  = [0..255]\n  type word  = int(32)\n  type state = (word, word, word, word)\n\n  (* Substitution Box (Sbox) and its Inverse (InvSbox) *)\n  axiom Sbox_InvSbox : forall b: byte. InvSbox(Sbox(b)) = b\n  axiom InvSbox_Sbox : forall b: byte. Sbox(InvSbox(b)) = b\n\n  (* Word Transformations *)\n  fun SubWord(w: word) : word = .... (* apply Sbox to each byte in word *)\n  fun InvSubWord(w: word) : word = .... (* apply InvSbox to each byte in word *)\n\n  (* Propositions Proving SubWord's Inverse *)\n  lemma InvSubWord_SubWord : forall w: word. InvSubWord(SubWord(w)) = w\n\n  (* State Transformation Utilities *)\n  fun to_matrix(s: state) : word[4][4] = ....  (* Convert state to matrix *)\n  fun to_state(m: word[4][4]) : state = ....  (* Convert matrix to state *)\n\n  (* Byte Substitution and Row Shifting *)\n  fun SubBytes(m: word[4][4]) : word[4][4] = ....  (* Apply SubWord *)\n  fun InvSubBytes(m: word[4][4]) : word[4][4] = ....  (* Apply InvSubWord *)\n\n  (* Mix Columns and Its Inverse *)\n  fun MixColumns(m: word[4][4]) : word[4][4] = ....  (* Linear transformation *)\n  fun InvMixColumns(m: word[4][4]) : word[4][4] = ....  (* Inverse transformation *)\n\n  (* Axiom stating inverse relationship between MixColumns and InvMixColumns *)\n  axiom InvMixColumns_MixColumns : forall m: word[4][4]. InvMixColumns(MixColumns(m)) = m\n\n  (* Add Round Key *)\n  fun AddRoundKey(m: word[4][4], k: word[4][4]) : word[4][4] = ....\n  \n  (* AES Instructions *)\n  fun AESENC(s: state, rk: state) : state = ....  (* The full AES encryption round *)\n  fun AESENCLAST(s: state, rk: state) : state = ....  (* The final encryption round *)\n\n  (* AES Decryption *)\n  fun AESDEC(s: state, rk: state) : state = ....  (* The full AES decryption round *)\n  fun AESDECLAST(s: state, rk: state) : state = ....  (* The final decryption round *)\n\n  (* Key Expansion *)\n  fun AESKEYGENASSIST(s: state, rc: word) : state = ....\n  \n  (* Lemmas and Proofs to Establish Protocol Correctness *)\n  lemma InvShiftRows_SubBytes : forall m: word[4][4]. InvShiftRows(SubBytes(m)) = SubBytes(InvShiftRows(m))\n  lemma AES_DEC_AES_DEC_ : forall s r: state. AESDEC(s, r) = AESDEC_(s, r)\n\n}\n\n(* Additional modules or lemma definitions as needed *)"]], "EC-1/hashed_elgamal_generic.ec": [[true, "module HashedElGamalEncryptionScheme {\n\n  type ptxt = bitstring(k)\n  type ctxt = (group, bitstring)\n  type pkey = group\n  type skey = {x: groupElt | x \u2260 0}\n\n  (* Assumptions *)\n  module efficiency assumption : DhAssumption\n\n  (* Parameters *)\n  const k : int\n  axiom k_positive : k > 0\n  const qH : int\n\n  (* Hash Module *)\n  module HashOracle : {\n    proc init : unit\n    proc hash : group -> bitstring\n  }\n\n  (* Key Generation Process *)\n  proc kg : unit -> pkey * skey = {\n    HashOracle.init();\n    var x = group.random();\n    var pk = efficiency.power(group.generator, x);\n    (pk, x)\n  }\n\n  (* Encryption Process *)\n  proc enc(pkey pk, ptxt m) : ctxt = {\n    var r = group.random();\n    var c1 = efficiency.power(group.generator, r);\n    var c2 = m ^ HashOracle.hash(efficiency.power(pk, r));\n    (c1, c2)\n  }\n\n  (* Decryption Process *)\n  proc dec(skey x, ctxt (c1, c2)) : option(ptxt) = {\n    var m_prime = c2 ^ HashOracle.hash(efficiency.power(c1, x));\n    m_prime\n  }\n\n  (* Game-Based Security Analysis *)\n  game G0 {\n    var pk, x = kg();\n    var m0, m1 = adversary();\n    var b = coin();\n    var ctxt_b = enc(pk, if b then m0 else m1);\n    var b_prime = adversary_decide(ctxt_b);\n    return (b == b_prime)\n  }\n\n  game G1 {\n    var pk, x = kg();\n    var m0, m1 = adversary();\n    var b = coin();\n    var ctxt_b = enc(pk, if b then random() else random());\n    var b_prime = adversary_decide(ctxt_b);\n    return (b == b_prime)\n  }\n\n  theorem red_G0_G1 : forall adv : adversary,\n    advantage(adv, G0) <= advantage(adv, G1) + qH * cdH_prob\n\n  theorem security : forall adv : adversary,\n    advantage(adv, G0) <= qH * cdH_prob\n\n}"]], "EC-1/hashed_elgamal_std.ec": [[true, "module HashedElGamal {\n\n  type pkey = {hkey: bits, elem: groupElement}\n  type skey = {hkey: bits, secret: fieldElement}\n  type ptxt = bits\n  type ctxt = {elem: groupElement, encrypted: bits}\n\n  (* Begin DDH Assumption *)\n  axiom DDH : forall x y z : fieldElement, \n              Dist (g ^ x, g ^ y, g ^ z) ~ Dist (g ^ x, g ^ y, g ^ (x * y))\n\n  (* Key Generation *)\n  proc genKeys() : (pkey, skey) = {\n    var sk : fieldElement;\n    var pub_elem : groupElement;\n  \n    sk <$- Fp;\n    pub_elem <-- g ^ sk;\n    \n    return ({hkey = hash(g, pub_elem), elem = pub_elem}, {hkey = hash(g, pub_elem), secret = sk});\n  }\n\n  (* Encryption *)\n  proc encrypt(pk: pkey, m: ptxt) : ctxt = {\n    var y : fieldElement;\n    var elem : groupElement;\n    \n    y <$- Fp;\n    elem <-- g ^ y;\n\n    var enc_val : bits;\n    enc_val <-- xor(hash(pk.hkey, elem), m);\n    \n    return {elem = elem, encrypted = enc_val};\n  }\n\n  (* Decryption *)\n  proc decrypt(sk: skey, ct: ctxt) : ptxt = {\n    var secret_elem : groupElement;\n    \n    secret_elem <-- ct.elem ^ sk.secret;\n\n    var m : bits;\n    m <-- xor(hash(sk.hkey, secret_elem), ct.encrypted);\n    \n    return m;\n  }\n\n  (* Lemmas for CPA Security *)\n  lemma CPA_security : forall A : adversary,\n    Pr[CPA_game(A) = true] <= Pr[DDH_game(A) = true]. \n\n  (* Lemmas for Entropy Smoothing *)\n  lemma EntropySmoothing_security : forall A : adversary,\n    Pr[EntropyGame(A) = true] <= Pr[CPA_security(A) = true].\n\n}"]], "EC-1/KEMDEM.ec": [[true, "module type KEM = {\n  type pkey, skey, key, kct\n\n  procedure keygen() : (pkey * skey)\n  procedure enc(pk : pkey) : (key * kct)\n  procedure dec(sk : skey, c : kct) : option key\n}\n\nmodule KEM_CPA_Adversary = {\n  type pkey, key, kct\n\n  procedure distinguish(pk : pkey, k : key, c : kct) : bool\n}\n\nmodule KEM_CPA_Exp(A : KEM_CPA_Adversary, K : KEM) = {\n  var (pk, sk) : (K.pkey, K.skey)\n  var (k, c) : (K.key, K.kct)\n\n  proc A(init) {\n    assert { }\n    pk, sk <- K.keygen()\n    b <- bool\n    c <- K.enc(pk)\n    if b then\n      k <- K.dec(sk, c)\n    else\n      k <- dkey()\n    return A.distinguish(pk, k, c)\n  }\n\n  proc main() {\n    return Pr[A(true)] - Pr[A(false)]\n  }\n}\n\nmodule type DEM = {\n  type pt, key, dct\n  \n  procedure enc(k : key, m : pt) : dct\n  procedure dec(k : key, c : dct) : option pt\n}\n\nmodule DEM_Passive_Adversary = {\n  type pt, dct\n\n  procedure choose() : (pt * pt)\n  procedure distinguish(c : dct) : bool\n}\n\nmodule type PKE = {\n  type pkey, skey, pt, kct, dct\n\n  procedure keygen() : (pkey * skey)\n  procedure enc(pk : pkey, m : pt) : kct * dct\n  procedure dec(sk : skey, c : kct * dct) : option pt\n}\n\nmodule PKE_CPA_Adversary = {\n  type pkey, pt, kct, dct\n\n  procedure choose(pk : pkey) : (pt * pt)\n  procedure distinguish(c : kct * dct) : bool\n}\n\nmodule KEMDEM(K : KEM, D : DEM) : PKE = {\n  type pkey = K.pkey\n  type skey = K.skey\n  type pt = D.pt\n  type kct = K.kct\n  type dct = D.dct\n  \n  procedure keygen() : (pkey * skey) = {\n    return K.keygen()\n  }\n\n  procedure enc(pk : pkey, m : pt) : kct * dct = {\n    var (k, kc) = K.enc(pk)\n    var dc = D.enc(k, m)\n    return (kc, dc)\n  }\n\n  procedure dec(sk : skey, c : kct * dct) : option pt = {\n    var (kc, dc) = c\n    var ko = K.dec(sk, kc)\n    match ko {\n      Some(k) => return D.dec(k, dc)\n      None => return None\n    }\n  }\n}\n\nmodule KEMDEM_Security_Proof(KA : KEM_CPA_Adversary, DA : DEM_Passive_Adversary) = {\n  axiom KEM_cpa_advantage(K : KEM, KA : KEM_CPA_Adversary) : real\n  axiom DEM_passive_advantage(D: DEM, DA : DEM_Passive_Adversary) : real\n\n  theorem KEMDEM_PKE_CPA_Security(K : KEM, D : DEM, KA : KEM_CPA_Adversary, DA : DEM_Passive_Adversary) :\n    forall A : PKE_CPA_Adversary,\n    Pr[A(KEMDEM(K, D)] <= KEM_cpa_advantage(K, KA) + DEM_passive_advantage(D, DA)\n}"]], "EC-1/KEM_ROM.ec": [[true, "module type KEM = {\n  type pkey.\n  type skey.\n  type key.\n  type ciphertext.\n\n  op dkey : distr key.\n\n  val kg: unit -> pkey * skey.\n  val enc: pkey -> ciphertext * key.\n  val dec: skey -> ciphertext -> option key.\n}.\n\nmodule Correctness (S: KEM) = {\n  proc main() : bool = {\n    var pk: S.pkey.\n    var sk: S.skey.\n    var c: S.ciphertext.\n    var k, dk: option S.key.\n\n    (pk, sk) <- S.kg().\n    (c, k) <- S.enc(pk).\n    dk <- S.dec(sk, c).\n\n    match dk with\n    | Some k' -> k == Some k'\n    | None -> false\n    end\n  }\n}.\n\nmodule type Adversary = {\n  val guess: S.pkey -> S.ciphertext -> S.key -> bool.\n}.\n\nmodule CPA (S: KEM, A: Adversary) = {\n  proc experiment() : bool = {\n    var pk: S.pkey.\n    var sk: S.skey.\n    var c: S.ciphertext.\n    var k0, k1, k: S.key.\n    var b: bool.\n\n    (pk, sk) <- S.kg().\n    (c, k0) <- S.enc(pk).\n    k1 <$- S.dkey.\n\n    b <- A.guess(pk, c, k0).\n    if b then\n      k <- k0\n    else\n      k <- k1.\n\n    A.guess(pk, c, k)\n  }.\n}.\n\nmodule CPA_L (S: KEM, A: Adversary) = {\n  proc experiment() : bool = {\n    var pk: S.pkey.\n    var sk: S.skey.\n    var c: S.ciphertext.\n    var k: S.key.\n\n    (pk, sk) <- S.kg().\n    (c, k) <- S.enc(pk).\n\n    A.guess(pk, c, k)\n  }.\n}.\n\nmodule CPA_R (S: KEM, A: Adversary) = {\n  proc experiment() : bool = {\n    var pk: S.pkey.\n    var sk: S.skey.\n    var c: S.ciphertext.\n    var k: S.key.\n\n    (pk, sk) <- S.kg().\n    (c, k) <- S.enc(pk).\n    k <$- S.dkey.\n\n    A.guess(pk, c, k)\n  }.\n}.\n\nmodule CCA (S: KEM with {\n  val oracle : skey -> ciphertext -> option key;\n}, A: Adversary) = {\n  proc experiment() : bool = {\n    var pk: S.pkey.\n    var sk: S.skey.\n    var c: S.ciphertext.\n    var k: S.key.\n\n    (pk, sk) <- S.kg().\n    (c, k) <- S.enc(pk).\n\n    !o: S.oracle(sk, c).\n    A.guess(pk, c, k)\n  }\n}.\n\ntheory KEM_ROM = {\n  module type ROM = {\n    op oracle1 : distr bool.\n    op oracle2 : distr bool.\n  }.\n\n  module Correctness (S: KEM) = {\n    proc main() : bool = {\n      var pk: S.pkey.\n      var sk: S.skey.\n      var c: S.ciphertext.\n      var k, dk: option S.key.\n\n      (pk, sk) <- S.kg().\n      (c, k) <- S.enc(pk).\n      dk <- S.dec(sk, c).\n\n      match dk with\n      | Some k' -> (Some k' == Some k)\n      | None -> false\n      end\n    }\n  }.\n}."]], "EC-1/MPAPISemantics.ec": [[true, "module MultipartyAPISemantics {\n  (* Define types for state *)\n  type GlobalSt\n  type StP1\n  type StP2\n  type StP3\n  \n  (* Define types for input/output buffers *)\n  type Buffer\n  \n  (* Define external API Interaction buffers *)\n  type ApiCallRes = Buffer\n\n  (* Functions interacting with API *)\n  function upd_Sigma1 (st1: StP1, ib: Buffer, ob: Buffer) : StP1\n  function upd_Sigma2 (st2: StP2, ib: Buffer, ob: Buffer) : StP2\n  function upd_Sigma3 (st3: StP3, ib: Buffer, ob: Buffer) : StP3\n  \n  (* Initialize Global State *)\n  function init_GlobalSt (p1: prog L1, p2: prog L2, p3: prog L3) : GlobalSt\n\n  (* Representation of logic for secret operation handling *)\n  axiom secret_operation_handling : \n    forall g: GlobalSt, p1: prog L1, p2: prog L2, p3: prog L3,\n    let gs = init_GlobalSt p1 p2 p3 in\n    (* Simulate filling buffers *)\n    let ib1 = get_input(g, StP1) in\n    let ob1 = get_output(g, StP1) in\n    let ib2 = get_input(g, StP2) in\n    let ob2 = get_output(g, StP2) in\n    let ib3 = get_input(g, StP3) in\n    let ob3 = get_output(g, StP3) in\n    (* Execute API Interaction for secret operations *)\n    let gs' = \n      update_global_state(g) \n      (* Update states based on API responses *)\n      in\n    upd_Sigma1 (st1, ib1, ob1);\n    upd_Sigma2 (st2, ib2, ob2);\n    upd_Sigma3 (st3, ib3, ob3).\n\n  (* State Evolution *)\n  predicate state_evolution (gs: GlobalSt, st1: StP1, st2: StP2, st3: StP3) =\n    let gs' = update_global_state(gs) in\n    upd_Sigma1 (st1, get_input(gs'), get_output(gs'));\n    upd_Sigma2 (st2, get_input(gs'), get_output(gs'));\n    upd_Sigma3 (st3, get_input(gs'), get_output(gs')).\n\n  (* Check the correctness of the global state updates *)\n  theorem correctness_global_updates:\n    forall gs_initial: GlobalSt, p1: prog L1, p2: prog L2, p3: prog L3,\n    let gs = init_GlobalSt p1 p2 p3 in\n    state_evolution(gs_initial, st1, st2, st3).\n\nend"]], "EC-1/MPCProtocolLibrary.ec": [[true, "module MPC_Protocol.\n\n  (* Define types for various elements used in the MPC Protocol Library *)\n  type party_id.\n  type raw_value.\n  type shared_value.\n  type msg_data.\n  type leakage_info.\n  type side_info.\n\n  (* Define type for traces as a list of messages *)\n  type trace_t = list msg_data.\n\n  (* Define types for protocols *)\n  type prot_declass.\n  type prot_in.\n  type prot_out.\n  type prot_sop.\n\n  (* Define axioms for secure operations on shared data *)\n  axiom secure_operation_1 : forall (x: shared_value) (y: shared_value), shared_value.\n  axiom secure_operation_2 : forall (x: shared_value), shared_value.\n\n  (* Define simulator behavior *)\n  axiom simulator_consistency :\n    forall (side_info: side_info) (trace: trace_t),\n    trace_t == simulate_protocol side_info.\n\n  (* Assertions for security *)\n  axiom security_declass :\n    forall (pi: prot_declass) (output: shared_value),\n    output == simulate_declass pi.\n\n  axiom security_input :\n    forall (pi: prot_in) (input: raw_value),\n    exists leak, simulate_input pi input leak.\n\n  axiom security_output :\n    forall (pi: prot_out) (output: shared_value),\n    exists trace, simulate_output pi side_info == trace.\n\n  axiom security_sop :\n    forall (pi: prot_sop) (op: shared_value -> shared_value),\n    simulate_sop pi op == expected_sop_result.\n\n  (* API for linking protocols with simulators *)\n  module API_Security.\n    use MPC_Protocol.\n\n    axiom protocol_security :\n      forall (protocol: prot_declass | prot_in | prot_out | prot_sop),\n      exists simulator, protocol == execute_simulator simulator.\n\n  end.\n\nend."]], "EC-1/NbPRFEnc.ec": [[true, "type nonce\ntype plaintext\ntype key\n\nmodule PRF = {\n  op f : key -> nonce -> plaintext\n\n  axiom prf_security : forall k n, random f(k, n)\n}\n\nmodule NbPRFEnc = {\n  op enc : key -> nonce -> plaintext -> ciphertext\n  op dec : key -> nonce -> ciphertext -> plaintext\n\n  op dkey : distr key\n  axiom dkey_lossless : lossless(dkey)\n\n  op dplaintext : distr plaintext\n  axiom dplaintext_full : full(dplaintext)\n\n  (* Encryption operation *)\n  axiom enc_definition :\n    forall k n p,\n    enc(k, n, p) = p xor f(k, n)\n\n  (* Decryption operation *)\n  axiom dec_definition :\n    forall k n c,\n    dec(k, n, c) = c xor f(k, n)\n\n  (* Correctness of encryption and decryption *)\n  lemma enc_dec_correct :\n    forall k n p,\n    dec(k, n, enc(k, n, p)) = p\n\n  lemma correct_enc_h :\n    forall k n p,\n    enc(k, n, p) != error\n\n  lemma correct_dec_h :\n    forall k n c,\n    dec(k, n, c) != error\n\n  (* Security proof *)\n  lemma cpa_security :\n    forall A,\n    advantage(A, enc, dkey) <= advantage_sec(A, f, dkey)\n}"]], "EC-1/ind_ow_pke.ec": [[true, "module R_IND_OW_A (PKE : PublicKeyEncryption) = {\n  // Definitions and assumptions about public key encryption\n  type pk_t = PKE.pk_t\n  type ptxt_t = PKE.ptxt_t\n\n  (* Distribution function for maximum plaintext probability *)\n  op pmax_pk (dpm : pk_t -> ptxt_t distr) : ptxt_t = {\n    flub (fun pk => p_max (dpm pk))\n  }\n\n  module ADV_IND_OW (A : Adv_OWCPA) : {\n    var pk' : pk_t\n    var p, p' : ptxt_t\n\n    proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n      pk' <- pk;\n      p <- pmax_pk (fun pk => Distr.uniform(PKE.plaintext_t));\n      p' <- pmax_pk (fun pk => Distr.uniform(PKE.plaintext_t));\n      return (p, p');\n    }\n\n    proc query(pk : pk_t, b : bool) : ptxt_t = {\n      (p, p') <- choose(pk);\n      if b then return p else return p';\n    }\n\n    proc attack(pk : pk_t) : bool = {\n      p1 <- query(pk, true);\n      p2 <- query(pk, false);\n      return (p1 = p2);  // Placeholder attack; to be replaced with a realistic one.\n    }\n\n    proc run() : bool = {\n      pk <- PKE.gen_key();\n      return attack(pk);\n    }\n  }\n\n  (* Ensure you replace the placeholder attack with realistic adversary behavior *)\n}"]], "EC-1/otp.ec": [[true, "(* Import necessary libraries *)\nrequire \"AllCore\".\nrequire \"BitWord\".\nrequire \"DWord\".\n\n(* Define types for messages, ciphertexts, and keys as bitstrings *)\ntype message = bitstring.\ntype ciphertext = bitstring.\ntype key = bitstring.\n\n(* Define a distribution for messages *)\nop dmsg : Distr message.\n\n(* Define the OTP module *)\nmodule OTP = {\n  (* Variables for message, ciphertext, and key *)\n  var m : message.\n  var c : ciphertext.\n  var k : key.\n\n  (* Key generation procedure: Key is sampled uniformly *)\n  proc kg() : key = {\n    k <$= uniform(_).\n    return k.\n  }.\n\n  (* Encryption procedure: Ciphertext is computed by XOR of message and key *)\n  proc enc(k: key, m: message) : ciphertext = {\n    return (m :\u2295 k).\n  }.\n\n  (* Main procedure: orchestrates the steps of the OTP protocol *)\n  proc main() : {message, ciphertext} = {\n    m <$= dmsg;\n    k <$= kg();\n    c <- enc(k, m);\n    return (m, c).\n  }.\n}.\n\n(* Define the Uniform module for comparison *)\nmodule Uniform = {\n  (* Variables for message and ciphertext *)\n  var m : message.\n  var c : ciphertext.\n\n  (* Main procedure: samples a message and ciphertext uniformly *)\n  proc main() : {message, ciphertext} = {\n    m <$= dmsg;\n    c <$= uniform(_);\n    return (m, c).\n  }.\n}.\n\n(* Secrecy Lemma: Proves the OTP scheme's security *)\nlemma Secrecy : Pr[OTP.main()] \u2248 Pr[Uniform.main()].\nproof.\n  intros.\n  inline OTP.kg.\n  inline OTP.enc.\n  inline Uniform.main.\n  simpl.\n  apply eq_negl_close.\nqed."]], "EC-1/passCertRPG_ref.ec": [[true, "module RPGRef\n\n(* Parameters and Types *)\ntype charSet = Set<char>\n\n(* Character Sets *)\nconst lowercaseSet: charSet = ... (* Set of lowercase alphabetic characters (a-z) *)\nconst uppercaseSet: charSet = ... (* Set of uppercase alphabetic characters (A-Z) *)\nconst numbersSet: charSet = ...   (* Set of numeric characters (0-9) *)\nconst specialSet: charSet = ...   (* Set of special characters (e.g., !, @, #, etc.) *)\n\n(* Random Number Generation *)\nprocedure rng(max: int): int\n  (* Generates a uniform random integer within the range [0, max) *)\n  ensures { result >= 0 /\\ result < max }\n\n(* Random Character Generation *)\nprocedure random_char_generator(set: charSet): char\n  (* Selects a random character from the given character set using rng *)\n  ensures { result \\in set }\n\n(* Password Permutation *)\nprocedure permutation(pass: list<char>): list<char>\n  (* Shuffles the password list to ensure unpredictable character sequence *)\n  ensures { permutation(pass, result) }\n\n(* Policy Definition *)\nprocedure define_union_set(policy: ...): charSet\n  (* Combines character sets based on user-defined policy *)\n  ensures { ... (* Character set union is computed correctly *) }\n\n(* Password Generation *)\nprocedure generate_password(policy: ...): option<list<char>>\n  (* Generates a password based on policy requirements; returns None if not satisfiable *)\n  ensures { match result with\n            | Some pass -> password_satisfies_policy(pass, policy)\n            | None -> not (policy_satisfiable(policy))\n            end }\n\n(* Auxiliary Lemmas *)\nlemma rng_terminates: forall(max: int),\n  max > 0 ==> rng(max) terminates\n\nlemma random_char_generator_correct: forall(set: charSet),\n  random_char_generator(set) \\in set\n\nlemma permutation_correct: forall(pass: list<char>, perm: list<char>),\n  permutation(pass, perm) ==> permutation_correctness(pass, perm)\n\n(* Correctness and Security Lemmas *)\nlemma password_generation_correctness: forall(policy: ...),\n  match generate_password(policy) with\n  | Some pass -> password_satisfies_policy(pass, policy)\n  | None -> not (policy_satisfiable(policy))\n  end\n\nlemma password_security: forall(policy: ...),\n  policy_satisfiable(policy) ==>\n    uniform_distribution_of_characters(generate_password(policy))\n\nend"]], "EC-1/AMPSemantics.ec": [[true, "module MultiPartySemantics {\n  // Parties involved in MultiParty Semantics\n  type party_id = (P1, P2, P3)\n\n  // Procedure signatures for the Semantics interface\n  procedure init(P : program list) : unit\n  procedure stepP(id : party_id) : unit\n  procedure stepS() : unit\n  procedure setInput(x : input) : unit\n  procedure getOutput() : output\n\n  // Module for the Environment Interface\n  module Environment {\n    oracle setInput(x : input) : unit\n    oracle getOutput() : output\n    oracle activate() : unit\n  }\n  \n  // Module for the Adversary Interface\n  module Adversary {\n    oracle stepP(id : party_id) : unit\n    oracle stepS() : unit\n  }\n  \n  // Main evaluation strategy encapsulating all modules\n  module Evaluation {\n    var P : program list\n    var x : input\n    var currentOutput : output\n\n    proc initEval(P0 : program list) : unit = {\n      P <- P0;\n      init(P)\n    }\n\n    proc runStepP(id : party_id) : unit = {\n      stepP(id)\n    }\n\n    proc runStepS() : unit = {\n      stepS()\n    }\n\n    proc handleInput(x : input) : unit = {\n      Environment.setInput(x);\n      setInput(x)\n    }\n\n    proc retrieveOutput() : output = {\n      currentOutput <- getOutput();\n      Environment.getOutput();\n      return currentOutput\n    }\n\n    proc adversaryActivate() : unit = {\n      Adversary.stepP(P1); // Example activation step\n      Adversary.stepS();\n      Environment.activate()\n    }\n  }\n}"]], "EC-1/pedersen-1.ec": [[true, "module Pedersen.\n\n  (* Define the types for the scheme *)\n  type value.\n  type message.\n  type commitment.\n  type openingkey.\n\n  (* Define the group operations needed *)\n  predicate eq (v1 v2 : value) : bool.\n  operator (\u2217) infix(left) : value -> value -> value.\n\n  (* Key generation function *)\n  proc gen() : value =\n    var x : openingkey = random();\n    return g^x.\n\n  (* Commitment function *)\n  proc commit(h : value, m : message) : (commitment * openingkey) =\n    var d : openingkey = random();\n    var c : commitment = (g^d) \u2217 (h^m);\n    return (c, d).\n\n  (* Verification function *)\n  proc verify(h : value, m : message, c : commitment, d : openingkey) : bool =\n    return eq(c, (g^d) \u2217 (h^m)).\n\n  (* Define security properties *)\n\n  (* Correctness lemma *)\n  lemma correctness_lemma : \n    forall h m c d, \n      let (c', d') = commit(h, m) in\n      verify(h, m, c', d') = true.\n\n  (* Perfect hiding lemma *)\n  lemma perfect_hiding : \n    forall m1 m2 h c d, \n      Pr[exists k, commit(h, m1) = (c, k)] = Pr[exists k, commit(h, m2) = (c, k)].\n\n  (* Computational binding lemma *)\n  predicate discrete_log_problem(h : value, m1 m2 : message, c : commitment, d1 d2 : openingkey) : bool =\n    eq(c, (g^d1) \u2217 (h^m1)) && eq(c, (g^d2) \u2217 (h^m2)) implies m1 = m2.\n\n  lemma computational_binding : \n    forall h m1 m2 c d1 d2,\n      discrete_log_problem(h, m1, m2, c, d1, d2).\n\nend."]], "EC-1/Plug_and_Pray_example.ec": [[true, "module Types = {\n  type oracle = { query : int -> int }\n}\n\nmodule Adv = {\n  type oracle = Types.oracle\n  proc run(o : oracle) : bool\n}\n\nconst q : int\n\nmodule G0 (A : Adv) = {\n  var k : int\n\n  module O : Types.oracle = {\n    proc query(n : int) : int = n\n  }\n\n  proc main() : bool = {\n    k <- 0;\n    var b : bool = A.run(O);\n    k <- (k + k) mod q;\n    b\n  }\n}\n\nmodule G1 (A : Adv) = {\n  var i : int\n  var k : int\n\n  module O : Types.oracle = {\n    proc query(n : int) : int = n\n  }\n\n  proc main() : bool = {\n    k <- 0;\n    i <$ [0 .. q-1];\n    var b : bool = A.run(O);\n    k <- (k + i) mod q;\n    b\n  }\n}\n\nlemma Bound_aux :\n  forall A : Adv, Pr[G0(A).main()] <= Pr[G1(A).main()] + 1/q"]], "EC-1/PRG.ec": [[true, "module RF.\n\n  type seed\n  type output\n\n  predicate lossless(seed, output)\n\n  proc init(s: seed) : unit = \n    skip\n\n  proc f(s: seed) : (seed, output) =\n    skip // Your operational logic goes here\n\nend\n\nmodule PRG.\n\n  type seed\n  type output\n  \n  predicate lossless(seed, output)\n\n  proc init(s: seed) : unit = \n    skip\n\n  proc prg(s: seed) : output =\n    skip // Your operational logic goes here\n\nend\n\nmodule Adv.\n\n  type seed\n  type output\n\n  proc query_RF(s: seed) : (seed, output) = \n    var new_s : seed;\n    var out : output;\n    (new_s, out) <- RF.f(s);\n    return (new_s, out)\n\n  proc query_PRG(s: seed) : output = \n    var out : output;\n    out <- PRG.prg(s);\n    return out\n\n  proc distinguish(s: seed) : bool =\n    var result : bool;\n    // Implement your adversary logic here\n    result <- false; // Placeholder: Replace with logic\n    return result\n\nend\n\nmodule Analysis.\n\n  proc main_exec(qF: int, qP: int, lossless_RF: predicate, lossless_PRG: predicate) : bool =\n    var s_RF : RF.seed;\n    var s_PRG : PRG.seed;\n    Adv.query_RF(s_RF); \n    Adv.query_PRG(s_PRG);\n    return Adv.distinguish(s_RF)\n\n  lemma RF_lossless_lemma: \n    forall s: RF.seed, o: RF.output.\n    lossless_RF(s, o) => RF.lossless(s, o)\n\n  lemma PRG_lossless_lemma: \n    forall s: PRG.seed, o: PRG.output.\n    lossless_PRG(s, o) => PRG.lossless(s, o)\n\n  lemma Adv_distinguish_lemma:\n    forall qF qP: int, s_RF: RF.seed, s_PRG: PRG.seed.\n    (/* Adversary querying constraints */) =>\n    Pr[main_exec(qF, qP, RF.lossless, PRG.lossless)] <= negligible_prob \n\nend"]], "EC-1/PrIntervalToSum.ec": [[true, "theory ProtocolAnalysis.\n\n(* Define required types and module type *)\ntype rt.\ntype iat.\n\nmodule type RunMain = {\n  proc run: (iat) : rt\n}.\n\n(* Global procedure for analysis *)\nmodule A : RunMain.\n\n(* Auxiliary lemmas for probabilistic reasoning *)\nmodule Lemmas.\n\n  (* First lemma: pr_interval_to_sum_lemma' *)\n  lemma pr_interval_to_sum_lemma' :\n    forall (f: rt -> int) (s: int) (e: int),\n    0 <= e ->\n    Pr [A.run input] [f (glob A) >= s /\\ f (glob A) <= s + e] =\n    big_int_sum (fun i =>\n      Pr [A.run input] [f (glob A) = i /\\\n                        P a res (glob A)])\n      (s) (s + e).\n\n  (* Second lemma: pr_interval_to_sum_lemma *)\n  lemma pr_interval_to_sum_lemma :\n    forall (f: rt -> int) (s: int) (e: int),\n    Pr [A.run input] [f (glob A) >= s /\\ f (glob A) <= e] =\n    if s <= e then\n      big_int_sum (fun i =>\n        Pr [A.run input] [f (glob A) = i /\\\n                          P a res (glob A)])\n        s e\n    else\n      0.\n\nend.\n\n(* Main section *)\nsection ProtocolAnalysisSection.\n\n  (* Import lemmas from Lemma module *)\n  import Lemmas.\n\n  (* Additional declarations or proof obligations can be added here *)\n\nend.\n\nend."]], "EC-1/ProtocolAPI.ec": [[true, "module ProtocolAPI.\n\n  (* Define types for secret variables and calls/responses *)\n  type svar_t.\n\n  type apiCall_data =\n    | Call_declass of svar_t\n    | Call_in      of svar_t\n    | Call_out     of svar_t\n    | Call_sop     of svar_t * list svar_t * list int.\n\n  type apiRes_data =\n    | Res_declass of svar_t\n    | Res_in      of svar_t\n    | Res_out     of svar_t.\n\n  (* Define an interaction buffer type *)\n  type apiCallRes =\n    | Call of apiCall_data\n    | Res  of apiRes_data.\n\n  (* Define operations to extract data from buffer *)\n  op apiCall (x: apiCallRes) : option apiCall_data =\n    match x with\n    | Call c -> Some c\n    | Res _  -> None\n    end.\n\n  op apiRes (x: apiCallRes) : option apiRes_data =\n    match x with\n    | Res r -> Some r\n    | Call _ -> None\n    end.\n\n  (* Integration with ProtocolLibrary assumed to be implemented here *)\n  module ProtocolLibrary.\n\n  (* Axiomatize the necessary aspects of the API, potentially including confidentiality and correctness properties *)\n  axiom confidentiality: forall (s: svar_t), secret s.\n  axiom correctness: forall (c: apiCall_data), valid_call c.\n\n  (* The API would provide security guarantees such as data confidentiality and correctness when used correctly *)\n  (* We would utilize the existing protocol library definitions to obtain necessary operations and types *)\n\nend."]], "EC-1/PseudoRandFun.ec": [[true, "module type RF = {\n  proc init() : unit\n  proc f(text) : text\n}.\n\nmodule PRF : RF = {\n  proc init() : unit = {\n    var k : key;\n    k <$- dkey\n  }\n\n  proc f(x : text) : text = {\n    return F(k, x)\n  }\n}.\n\nmodule TRF : RF = {\n  var mp : map[text, text]\n\n  proc init() : unit = {\n    mp <- empty_map\n  }\n\n  proc f(x : text) : text = {\n    if !mem(mp, x) then {\n      mp[x] <$- dtext\n    }\n    return mp[x]\n  }\n}.\n\nmodule type RFA = {\n  proc f(x : text) : text\n}.\n\nmodule A : RFA = {\n  proc f(x : text) : text = {\n    // definition of adversary\u2019s behavior\n  }\n}.\n\ngame GRF(TRF, PRF, A) = {\n  var b : bool;\n  \n  TRF.init();\n  PRF.init();\n  \n  if A(TRF.f) = A(PRF.f) then {\n    b <- true;\n  } else {\n    b <- false;\n  }\n  \n  return b;\n}.\n\naxiom PRF_security :\n  forall A : RFA,\n  | Pr[GRF(TRF, PRF, A)] - Pr[GRF(PRF, PRF, A)] | <= negl."]], "EC-1/RewMultRule.ec": [[true, "type ex1at.\ntype ex2at.\ntype ex1rt.\ntype ex2rt.\ntype sbits.\n\nmodule type RewEx1Ex2 = {\n  proc getState() : sbits.\n  proc setState(b : sbits) : unit.\n  proc ex1(x1 : ex1at) : ex1rt.\n  proc ex2(x2 : ex2at) : ex2rt.\n}.\n\nmodule GetExec1Set (R : RewEx1Ex2) = {\n  proc main(x1 : ex1at) : ex1rt = {\n    var oldState = R.getState();\n    var res1 = R.ex1(x1);\n    R.setState(oldState);\n    return res1;\n  }\n}.\n\nmodule GetExec1SetExec2Conj (R : RewEx1Ex2) = {\n  proc main(x1 : ex1at, x2 : ex2at) : (ex1rt, ex2rt) = {\n    var res1 = R.ex1(x1);\n    var res2 = R.ex2(x2);\n    return (res1, res2);\n  }\n}.\n\nmodule MultTriv (A : { proc run() : unit }, B : { proc run() : unit }) = {\n  proc compositeRun() : (unit, unit) = {\n    var resA = A.run();\n    var resB = B.run();\n    return (resA, resB);\n  }\n}.\n\naxiom injectiveState : \u2200 (s1 s2 : sbits), s1 = s2 <==> serialize(s1) = serialize(s2).\n\nlemma rew_lossless : \u2200 (R : RewEx1Ex2) (x1 : ex1at), \n  hoare [GetExec1Set.main] \n  ((R.getState() = oldState) \u2227 P(oldState)) \n  (GetExec1Set.main(x1) = res1 \u2227 R.getState() = oldState)\n  ((res1, oldState) = Refresh(R.getState(), ex1rt)).\n\nlemma rew_mult_law : \u2200 (R : RewEx1Ex2) (x1 : ex1at, x2 : ex2at), \n  Pr[GetExec1SetExec2Conj.main(x1, x2) = (r1, r2)] = \n  Pr[R.ex1(x1) = r1] * Pr[R.ex2(x2) = r2]."]], "EC-1/RewSumBindingAux.ec": [[true, "module type RSBH = {\n  type sbits\n  type irt\n  type rrt\n  type iat\n\n  val pair_sbits : sbits -> sbits -> sbits\n  val unpair : sbits -> sbits * sbits\n\n  axiom ips : forall x y, pair_sbits x y = pair_sbits y x -> x = y\n  axiom unpair_pair : forall x y, unpair (pair_sbits x y) = (x, y)\n}\n\nmodule Initializer : {\n  proc init (i: iat) : irt\n}\n\nmodule RewRunExec1Exec2 = {\n  proc getState () : sbits\n  proc setState (b : sbits) : void\n  proc run (i : irt) : rrt\n  proc ex1 (i : irt) : rrt\n  proc ex2 (i : irt) : rrt\n}\n\nmodule SBB : {\n  proc run (i : irt) : rrt\n  proc getState () : sbits\n  proc setState (b : sbits) : void\n}\n\nmodule SB : {\n  proc main (i: iat) : rrt * rrt\n  proc main_run (i: iat) : rrt\n  proc main_12 (i: iat) : rrt\n  proc main_21 (i: iat) : rrt\n  proc main_11 (i: iat) : rrt\n  proc main_22 (i: iat) : rrt\n}\n\nclone RSBH with {\n  type sbits = bits\n  type irt = input_type\n  type rrt = result_type\n  type iat = initial_input_type\n\n  axiom ips = (* Define axiom based on bits implementation *)\n  axiom unpair_pair = (* Define axiom based on bits implementation *)\n}\n\nsection {\n\n  module A : RewRunExec1Exec2\n    \n  module B : Initializer\n\n  lemma fact2 : forall i1 i2, \n    Pr[A.run(i1)] = Pr[A.ex1(i1)] + Pr[A.ex2(i2)] -> \n    Pr[B.init(i1)] = Pr[B.init(i2)]\n\n  lemma main_lemma : forall i, \n    Pr[SB.main_run(i)] = Pr[SB.main_12(i)] + Pr[SB.main_21(i)] + Pr[SB.main_11(i)] + Pr[SB.main_22(i)]\n\n}"]], "EC-1/RingCloning.ec": [[true, "module Ring\n\n  type ring\n\n  const zero: ring\n  const one: ring\n\n  op ( + ) : ring -> ring -> ring\n  op ( * ) : ring -> ring -> ring\n  op [ - ] : ring -> ring\n\n  axiom addrA: forall (a b c: ring), a + (b + c) = (a + b) + c\n  axiom addrC: forall (a b: ring), a + b = b + a\n  axiom add0r: forall (a: ring), a + zero = a\n  axiom addNr: forall (a: ring), a + -a = zero\n  axiom mulrA: forall (a b c: ring), a * (b * c) = (a * b) * c\n  axiom mul1r: forall (a: ring), a * one = a\n  axiom mulrDadd: forall (a b c: ring), a * (b + c) = a * b + a * c\n  axiom mulDradd: forall (a b c: ring), (a + b) * c = a * c + b * c\n\nend\n\nmodule RingT\n\n  abbrev ( - ) (r1 r2 : ring) = r1 + -r2\n\n  lemma addr0: forall (a: ring), a + zero = a\n  lemma addrN: forall (a: ring), a + -a = zero\n  lemma addIr: forall (a b c: ring), a + c = b + c -> a = b\n  lemma addrI: forall (a b c: ring), c + a = c + b -> a = b\n\nend\n\nmodule CRing = Ring\n\n  axiom mulrC: forall (a b: ring), a * b = b * a\n\nend\n\nmodule CRingT = RingT + CRing\n\n  lemma mulrC: forall (a b: ring), a * b = b * a\n  lemma mulrCA: forall (a b c: ring), a * b * c = a * c * b\n  lemma mulrAC: forall (a b c: ring), (a * b) * c = (a * c) * b\n  lemma mulrACA: forall (a b c d: ring), ((a * b) * c) * d = ((a * c) * b) * d\n\nend\n\nmodule BRing = Ring\n\n  axiom mulrK: forall (a: ring), a * a = a\n\nend\n\nmodule BRingT = RingT + BRing\n\n  lemma neg_is_id: forall (a: ring), a * a = a\n  lemma mulrC: forall (a b: ring), a * b = b * a\n\nend\n\nmodule BoolRing = BRing + CRing\n\n  const zero = false\n  const one = true\n\n  op ( + ) = fun (a b: boolean) => (a xor b)\n  op ( * ) = fun (a b: boolean) => (a && b)\n\nend"]], "EC-1/SchnorrPK.ec": [[true, "module SchnorrTypes = {\n  type group\n\n  // Declaration of the group generator\n  constant g : group\n\n  // Declaration of data types for the protocol\n  type statement = group\n  type witness = int\n  type message = group\n  type secret = int\n  type challenge = int\n  type response = int\n\n  // Define the relation for the discrete log problem\n  predicate R_DL(witness w, statement h) = {\n    h = g ^ w\n  }\n}\n\nmodule SchnorrPK = {\n  use SchnorrTypes\n\n  // Key Generation operation\n  proc gen() : statement * witness = {\n    var w : witness = generate_secret_w()\n    var h : statement = g ^ w\n    return (h, w)\n  }\n\n  // Commitment phase\n  proc commit(w : witness) : message * secret = {\n    var r : secret = generate_secret_r()\n    var a : message = g ^ r\n    return (a, r)\n  }\n\n  // Challenge generation by the verifier\n  proc test() : challenge = {\n    return generate_challenge_e()\n  }\n\n  // Response computation by the prover\n  proc respond(r : secret, e : challenge, w : witness) : response = {\n    var z : response = r + e * w\n    return z\n  }\n\n  // Verification by the verifier\n  proc verify(a : message, h : statement, e : challenge, z : response) : bool = {\n    var v : group = a * (h ^ e)\n    var v' : group = g ^ z\n    return v = v'\n  }\n}\n\nmodule SchnorrPKSecurity = {\n  use SchnorrTypes\n  use SchnorrPK\n\n  // Completeness proof: Honest prover will always be accepted\n  lemma completeness : \n    forall (h : statement) (w : witness) (a : message) (r : secret) (e : challenge) (z : response),\n      let (h, w) = gen() in\n      let (a, r) = commit(w) in\n      let e = test() in\n      let z = respond(r, e, w) in\n      verify(a, h, e, z)\n\n  // Special Soundness proof\n  lemma special_soundness : \n    forall (h : statement) (a : message) (e1 e2 : challenge) (z1 z2 : response),\n      e1 <> e2 ->\n      verify(a, h, e1, z1) ->\n      verify(a, h, e2, z2) ->\n      exists w : witness, R_DL(w, h)\n\n  // Special Honest Verifier Zero Knowledge proof\n  lemma shvzk : \n    forall (h : statement) (w : witness) (e : challenge),\n    exists (r : secret) (a : message),\n      let (a, r) = commit(w) in\n      let e = test() in\n      let z = respond(r, e, w) in\n      verify(a, h, e, z) -> \n      indistinguishable_real_simulated(a, r, e, w)\n}"]], "EC-1/AProtocolLibrary.ec": [[true, "theory ProtocolLibrary\n\n  (* Define the number of parties *)\n  const n : int\n\n  (* Define identifiers and types *)\n  type partyId_t\n  type value_t\n  type inputs_t\n  type outputs_t\n\n  (* Define messaging and traces *)\n  type msg_data\n  type trace_t = list msg_data\n\n  (* Define security and leakage information *)\n  type leakage_t\n  type sideInfo_t = (leakage_t * trace_t)\n\n  (* Define secret operators *)\n  type sop_t\n  op sop_spec : sop_t -> list value_t -> list inputs_t -> outputs_t\n\n  (* Core Protocol Operations *)\n\n  (* Declassification protocol *)\n  op prot_declass : inputs_t -> (value_t * sideInfo_t) distr\n\n  (* Input protocol *)\n  op prot_in : inputs_t -> sideInfo_t distr\n\n  (* Output protocol *)\n  op prot_out : inputs_t -> (outputs_t * sideInfo_t) distr\n\n  (* Secret operator protocol *)\n  op prot_sop : sop_t -> list value_t -> list inputs_t -> (outputs_t * sideInfo_t) distr\n\n  (* Simulators *)\n\n  (* Declassification simulator *)\n  op sim_declass : inputs_t -> leakage_t -> trace_t distr\n\n  (* Input simulator *)\n  op sim_in : leakage_t -> trace_t distr\n\n  (* Output simulator *)\n  op sim_out : inputs_t -> leakage_t -> trace_t distr\n\n  (* Secret operator simulator *)\n  op sim_sop : sop_t -> list value_t -> list inputs_t -> leakage_t option -> (outputs_t * trace_t) distr\n\nend"]], "EC-1/SHA.ec": [[true, "module HashProtocol\n\nopen W32\nopen W128\n\n(* Choice Function *)\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\n(* Majority Function *)\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\n(* Rotating and Shifting Sum Functions *)\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\n(* Sigma Transformations *)\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\n(* Placeholder for MSG1 transformation *)\nop msg1 (m1 m2: W128.t) : W128.t = ... (* Implementation details needed *)\n\n(* Placeholder for MSG2 transformation *)\nop msg2 (m1 m2: W128.t) : W128.t = ... (* Implementation details needed *)\n\n(* Round Function, Placeholder for Implementation *)\nop rnds2 (x y z: W128.t) : W128.t = ... (* Implementation details needed *)\n\nend"]], "EC-1/SimpleCondProb.ec": [[true, "theory Generic.\n\n  type in_t.\n  type out_t.\n  type aux_t.\n\n  op din : distr in_t.\n\n  module type Provided = {\n    proc main(x: in_t, aux: aux_t) : out_t.\n  }\n\n  module Sampler(P: Provided) = {\n    proc main(aux: aux_t) : out_t = {\n      var x : in_t = sample din in\n      return (P.main(x, aux))\n    }\n  }\n\n  lemma EqPr_SamplerConj_ProvidedCond : forall (P: Provided) (aux: aux_t) (y: out_t),\n    Pr[sampler P(aux) = y] = Pr[x <$ din; P.main(x, aux) = y].\n\n  lemma EqPr_SamplerConj_ProvidedCond_FinBig : forall (P: Provided) (aux: aux_t) (y: out_t),\n    fin_support(din) ->\n    Pr[Sampler(P).main(aux) = y] = \\sum_{x in support(din)} Pr[P.main(x, aux) = y] * Pr[x <$ din].\n\n  lemma EqPr_SamplerConj_ProvidedCond_UniBig : forall (P: Provided) (aux: aux_t) (y: out_t),\n    uniform(din) ->\n    Pr[Sampler(P).main(aux) = y] = \\sum_{x in support(din)} Pr[P.main(x, aux) = y] / size(support(din)).\n\nend\n\ntheory Indistinguishability.\n\n  type in_t = bool.\n  type out_t.\n  type aux_t.\n\n  op din : distr in_t.\n\n  module type Provided = {\n    proc main(x: in_t, aux: aux_t) : out_t.\n  }\n\n  module IndSampler(P: Provided) = {\n    proc main(aux: aux_t) : out_t = {\n      var x : bool = sample din in\n      return (P.main(x, aux))\n    }\n  }\n\n  lemma RelPr_IndSampler_IndProvided : forall (P: Provided) (aux: aux_t) (y: out_t),\n    Pr[ind_sampler P(aux) = y] = Pr[P.main(true, aux) = y] * Pr[true <$ din]\n      + Pr[P.main(false, aux) = y] * Pr[false <$ din].\n\n  lemma Rel_Ind_Formalizations : forall (P: Provided) (aux: aux_t) (y: out_t),\n    Pr[IndSampler(P).main(aux) = y] <-> \n    Pr[P.main(true, aux) = y] = Pr[P.main(false, aux) = y].\n\nend"]], "EC-1/SimplifiedLangSMC.ec": [[true, "// Secure Multiparty Computation Protocol: Formal Analysis in EasyCrypt\n\nmodule MPCProtocol.\n\n  // Types and Secrets\n  type V = ...\n  type var_t = ...\n  type sop_t = ...\n  type callData = ...\n\n  // Secret Sharing\n  module SecretSharing.\n    op share : V -> (V * V * V)   (* Example for 3-party sharing *)\n    op unshare : (V * V * V) -> V\n    axiom share_correct : forall v. v = unshare(share(v))\n    axiom share_size_correct : ...\n\n  // Computation API\n  module API.\n    op init : var_t -> V -> callData\n    op eval : sop_t -> callData -> V\n    op manage_IO : var_t -> callData -> V\n    axiom eval_correct : ...\n\n  // Semantics: Ideal and Real World\n  module IdealSem.\n    type env_t = ...\n    axiom ideal_correct : ...\n\n  module RealSem.\n    type env_t = ...\n    axiom real_correct : ...\n\n  // Security Model\n  module AdversaryModel.\n    type adversary_t = ...\n    op adversary_interface : adversary_t -> env_t -> env_t\n    axiom adversary_correct : ...\n\n  // Simulation and Theorems\n  module Simulators.\n    op strong_simulator : IdealSem.env_t -> RealSem.env_t -> Prop\n    op weak_simulator : IdealSem.env_t -> RealSem.env_t -> Prop\n    axiom simulator_equivalence_strong : ...\n    axiom simulator_equivalence_weak : ...\n\n  module MultiProgram.\n    type language_t = ...\n    type program_t = ...\n  \n    op compile : language_t -> program_t -> program_t\n    axiom compile_correct : forall lang prog, ...\n\n// Security Theorems\n\n  // Theorem 1: Single Program Equivalence\n  theorem SingleProgramSecurity : forall prog lang.\n    compile_correct(lang, prog) ->\n    strong_simulator(...).\n\n  // Theorem 2: Certified Compilation Equivalence\n  theorem CertifiedCompilationSecurity : forall source_lang target_lang prog.\n    compile(source_lang, prog) = compile(target_lang, prog) ->\n    weak_simulator(...).\n\n  // Theorem 3: Multi-Program Security\n  theorem MultiProgramSecurity : forall programs.\n    compile_correct(..., programs) ->\n    weak_simulator(...).\n\nend."]], "EC-1/SimpLogic.ec": [[true, "theory SimpLogic.\n\n  lemma fa_imp_not_ex_not (P : 'a -> bool) :\n    (forall x, P x) -> ~(exists x, ~P x).\n  proof.\n    intros H.\n    intro Hex.\n    destruct Hex as [x Hnx].\n    apply Hnx.\n    apply H.\n  qed.\n\n  lemma not_ex_not_imp_fa (P : 'a -> bool) :\n    ~(exists x, ~P x) -> (forall x, P x).\n  proof.\n    intros H.\n    intro x.\n    destruct (classic (P x)).\n    - assumption.\n    - exfalso.\n      apply H.\n      exists x.\n      assumption.\n  qed.\n\n  lemma fa_iff_not_ex_not (P : 'a -> bool) :\n    (forall x, P x) <-> ~(exists x, ~P x).\n  proof.\n    split.\n    - apply fa_imp_not_ex_not.\n    - apply not_ex_not_imp_fa.\n  qed.\n\n  lemma fa_iff_not_ex_not' (P : 'a -> bool) :\n    (forall x, P x) <-> ~(exists x, ~P x).\n  proof.\n    rewrite <-negb_exists.\n    split.\n    - intro H.\n      intro Hex.\n      destruct Hex as [x Hnx].\n      apply Hnx.\n      apply H.\n    - intro H.\n      intro x.\n      destruct (classic (P x)).\n      + assumption.\n      + exfalso.\n        apply H.\n        exists x.\n        assumption.\n  qed.\n\nend."]], "EC-1/SMC.ec": [[true, "theory SecureCommunication.\n\n(* Define fixed length for bitstrings *)\nconst n : int.\n\n(* Bitstring representation and operations *)\ntype bitstring.\nconstant zero : bitstring.\nconstant (^^) : bitstring -> bitstring -> bitstring.\n\n(* Distribution of bitstrings *)\nmodule dbits.\naxioms\n  ax_lossless : forall b : bitstring, Pr[b \u2208 dbits] > 0.\n  ax_full : forall b1 b2 : bitstring, Pr[b1 ^^ b2 \u2208 dbits] > 0.\n\n(* Adversary model *)\nmodule type ADV.\n  op get : bitstring.\n  op obs : bitstring -> unit.\n  op put : bitstring -> bool.\n\n(* Real game *)\nmodule GReal(Adv : ADV).\nlet pad :=$ dbits in\nlet m := Adv.get() in\nlet c := m ^^ pad in\nAdv.obs(c);\nlet d := pad ^^ c in\nRet Adv.put(d).\n\n(* Ideal game *)\nmodule GIdeal(Sim : ADV)(Adv : ADV).\nlet m := Adv.get() in\nlet c := Sim.get() in\nAdv.obs(c);\nRet Adv.put(m).\n\n(* Security theorem *)\nlemma security_theorem : forall Adv : ADV, \n  exists Sim : ADV, \n  Pr[GReal(Adv).main()] = Pr[GIdeal(Sim, Adv).main()].\nProof.\n  (* Proof outline can be elaborated based on game transformations and simulator creation. *)\nAdmit.\nQed.\n\nend."]], "EC-1/SymEnc.ec": [[true, "module type ENC = {\n  type key\n  type text\n  type cipher\n\n  val ciph_def : cipher\n\n  val key_gen : unit -> key\n  val enc : key -> text -> cipher\n  val dec : key -> cipher -> text\n}\n\nmodule type Cor = {\n  proc correctness(enc : key -> text -> cipher; dec : key -> cipher -> text) : bool = {\n    var k = ENC.key_gen();\n    for all x : text do {\n      dec(k, enc(k, x)) == x\n    }\n  }\n}\n\nmodule EO : {\n  type key\n  type text\n  type cipher\n\n  var k : key\n  var enc_count_pre : int\n  var enc_count_post : int\n\n  val limit_pre : int\n  val limit_post : int\n\n  proc init() : unit = {\n    k = ENC.key_gen();\n    enc_count_pre = 0;\n    enc_count_post = 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    assert(enc_count_pre < limit_pre);\n    enc_count_pre += 1;\n    ENC.enc(k, x)\n  }\n\n  proc genc(x : text) : cipher = {\n    ENC.enc(k, x)\n  }\n\n  proc enc_post(x : text) : cipher = {\n    assert(enc_count_post < limit_post);\n    enc_count_post += 1;\n    ENC.enc(k, x)\n  }\n}\n\nmodule type ADV = {\n  type text\n  type cipher\n\n  val choose : unit -> (text, text)\n  val guess : cipher -> bool\n}\n\nmodule INDCPA(EncO : EO)(Adv : ADV) : {\n  proc security_game() : bool = {\n    var k = EncO.init();\n    var (m0, m1) = Adv.choose();\n    var b = coin(); // Random bit\n    var c = if b then EncO.genc(m0) else EncO.genc(m1);\n    var b' = Adv.guess(c);\n    b == b'\n  }\n\n  val success_probability : unit -> real = {\n    E[security_game()]\n  }\n\n  val is_secure : unit -> bool = {\n    success_probability() <= 1/2 + negligible()\n  }\n}"]], "EC-1/SymEncPRF.ec": [[true, "module type PRF = {\n  type key  // Type representing the key\n  type text // Type representing the text\n  \n  op F: key -> text -> text   // Pseudorandom function\n  op dkey : distr key         // Uniform distribution over keys\n  op dtext : distr text       // Uniform distribution over texts\n}\n\nmodule Enc(P: PRF) = {\n  type key = P.key\n  type text = P.text\n  type ciphertext = (P.text, P.text)\n\n  // Key generation process\n  op key_gen: comp key = {\n    P.dkey.sample()\n  }\n\n  // Encryption process\n  op enc: key -> text -> comp ciphertext = fun k x => {\n    var u = P.dtext.sample() in\n    let v = x +^ P.F(k, u) in\n    ret (u, v)\n  }\n\n  // Decryption process\n  op dec: key -> ciphertext -> text = fun k c => {\n    let (u, v) = c in\n    v +^ P.F(k, u)\n  }\n}\n\nmodule EncGame(P: PRF) = {\n  module EP = Enc(P)\n\n  type input = (EP.key, EP.text, EP.text)\n  \n  // Challenge based on IND-CPA security notion\n  proc challenge(_: unit): comp (EP.text * EP.text) = {\n    var k = EP.key_gen() in\n    var x0 = P.dtext.sample() in\n    var x1 = P.dtext.sample() in\n    let c = EP.enc(k, if (coin()) then x0 else x1) in\n    ret (EP.dec(k, c), x0, x1)\n  }\n}\n\nmodule type Adversary = {\n  type input\n  type output\n\n  op adv: input -> comp output\n}\n\nmodule IND_CPA(P: PRF, A: Adversary with {\n  type input = EncGame(P).input\n  type output = bit\n}) = {\n  module EG = EncGame(P)\n\n  proc main(): comp bit = {\n    var (p, x0, x1) = EG.challenge() in\n    var b = A.adv((p, x0, x1)) in\n    ret (b == coin())\n  }\n}"]], "EC-1/theory-alias.ec": [[true, "theory T.\n\n  theory V.\n    op foo : int.\n  end V.\n\n  theory U = V.\n\nend T.\n\nimport T.\n\nop bar : int = U.foo.\n\nprint T."]], "EC-1/tut.ec": [[true, "module type SRG = {\n  type seed, state, output\n\n  op dseed : dist seed\n  op dstate : dist state\n  op doutput : dist output\n\n  proc init () : seed * state\n  proc next (s: seed, st: state) : output * state\n}\n\nmodule SRGi : SRG = {\n  type seed = int\n  type state = int\n  type output = bool\n\n  op dseed = random\n  op dstate = uniform\n  op doutput = uniform\n\n  proc init () : seed * state = {\n    (dseed, dstate)\n  }\n\n  proc next (s: seed, st: state) : output * state = {\n    let o = Fc(s, st) in\n    (o, st)\n  }\n}\n\nmodule type PRG = {\n  type output\n\n  proc init () : unit\n  proc next () : output\n}\n\nmodule PRGi : PRG = {\n  type output = bool\n\n  proc init () : unit = {}\n  proc next () : output = doutput\n}\n\nmodule type PRF = {\n  type D, R, K\n\n  op dkey : dist K\n\n  proc init () : K\n  proc F (k: K, x: D) : R\n}\n\nmodule PRFi : PRF = {\n  type D = int\n  type R = bool\n  type K = int\n\n  op dkey = random\n\n  proc init () : K = dkey\n  proc F (k: K, x: D) : R = {\n    (* Define function mapping keys to outputs *)\n    Uniform_random_bool() (* example implementation *)\n  }\n}\n\nmodule type Distinguisher = {\n  proc distinguish () : bool\n}\n\nmodule type IND = {\n  proc test () : bool\n}\n\nmodule IND_PRG (G: PRG) (D: Distinguisher) : IND = {\n  proc test () : bool = {\n    D.distinguish()\n  }\n}\n\nmodule IND_PRF (F: PRF) (D: Distinguisher) : IND = {\n  proc test () : bool = {\n    D.distinguish()\n  }\n}\n\nmodule PRFa : PRF with type D = int and type R = bool and type K = int = PRFi\nmodule INDP : IND = IND_PRF(PRFa, D_PRF)\nmodule D_PRF : Distinguisher = {\n  proc distinguish () : bool = {\n    let k = PRFa.init() in\n    let res1 = PRFa.F(k, 1) in\n    let res2 = PRFa.F(k, 2) in\n    res1 != res2\n  }\n}"]], "EC-1/WF-examp.ec": [[true, "(* Chunkification of a list into fixed size sublists using well-founded recursion\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* Define a well-founded relation on lists: lt_list_size xs ys <=> size xs < size ys *)\nop lt_list_size : forall `a, `a list rel = wf_pre size lt_nat.\n\nlemma wf_lt_list_size : forall `a, wf (lt_list_size `a).\nproof.\n  rewrite wf_pre. \n  apply wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP : forall (xs ys : `a list), \n  lt_list_size xs ys <=> size xs < size ys.\nproof.\n  by rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* Body of well-founded recursive definition that \"chunkifies\" an 'a list into an 'a list list *)\nop chunkify_wf_rec_def (n : int) : (`a list, `a list list) wf_rec_def =\n  fun (xs : `a list, f : `a list -> `a list list) =>\n  if n <= size xs\n  then take n xs :: f (drop n xs)\n  else [].\n\n(* The actual recursive definition *)\nop chunkify (n : int) : `a list -> `a list list =\n  wf_recur\n  (lt_list_size `a)       (* Well-founded relation being used *)\n  []                      (* Element to be returned if recursive calls\n                              don't respect well-founded relation *)\n  (chunkify_wf_rec_def n).(* Body of recursive definition *)\n\n(* Lemma establishing the size relationship *)\nlemma chunkify_size : forall (n : int) (xs : `a list), \n  1 <= n -> size (chunkify n xs) = size xs %/ n.\nproof.\n  move => ge1_n; move : xs.\n  apply (wf_ind (lt_list_size `a)).  (* Use well-founded induction on lt_list_size *)\n  apply wf_lt_list_size.\n  rewrite /chunkify => /= xs IH.\n  rewrite wf_recur 1:wf_lt_list_size.\n  rewrite {1}/chunkify_wf_rec_def.  (* Only need to rewrite at top-level *)\n  case (n <= size xs) => [le_n_size_xs | not_le_n_size_xs].\n  - (* First case *)\n    rewrite lt_list_sizeP.\n    have lt_size_drop : size (drop n xs) < size xs by rewrite size_drop /#; move/leP: le_n_size_xs => ->.\n    rewrite lt_size_drop /= IH 1:lt_list_sizeP //.\n    rewrite size_drop 1:/# ler_maxr 1:/#.\n    have -> : size xs = n + (size xs - n) by smt(size_drop vent); lia.\n    rewrite (divzDl n) 1:dvdzz divzz /#.\n  - (* Second case *)\n    by smt(size_ge0 ltr_normr).\nqed."]], "EC-1/ASecretSharingScheme.ec": [[true, "module SecretSharingScheme {\n\n  type partyId_t\n  type value_t\n  type share_t\n  type sharedValue_t = list share_t\n\n  op [lossless] nshr : int -> value_t -> sharedValue_t distr.\n  op unshr : sharedValue_t -> value_t\n\n  axiom nshr_wellfounded : forall n:int, v:value_t, \n      nshr n v >>= fun sv/sharedValue_t =>\n      (length sv >= n) /\\ (length sv <= n)\n\n  axiom unshr_correct: forall sv:sharedValue_t, t:int,\n      length sv >= t -> \n      unshr sv = v\n\n  axiom secrecy_property: forall (partial_sv:sharedValue_t) v:value_t,\n      length partial_sv <= t -> \n      Pr[nshr n v >>= fun sv => (sublist sv partial_sv)] = \n      Pr[nshr n v' >>= fun sv' => (sublist sv' partial_sv)]\n  \n  proc share_and_recover(n:int, v:value_t) : value_t = {\n    var shared:sharedValue_t;\n    shared <$- nshr n v;\n    return unshr shared;\n  }\n}"]], "EC-1/WhileSampling.ec": [[true, "module SampleProtocol {\n\n  // Import required modules\n  import Real.\n  import Distr.\n\n  // Type definition\n  type t.\n\n  // Operations\n  op sample : t distr.\n\n  // Axioms\n  axiom sample_ll : lossless sample.\n\n  op test : t -> bool.\n\n  axiom pr_ntest : 0%r < mu sample (predC test).\n\n  // Module Sample containing sample procedure\n  module Sample {\n    \n    proc sample () : t = {\n      var r : t.\n      while (test r) do {\n        r <$- sample\n      };\n      return r\n    }.\n\n    // Lemma proving losslessness of the Sample.sample procedure \n    lemma Sample_lossless : \n      is_lossless (fun () =>\n        Sample.sample () ) =\n      {\n        // Proof outline\n        // 1. Show initial condition is true\n        // 2. Use sample_ll to validate sampling process\n        // 3. Perform induction on the while loop\n        // 4. Utilize pr_ntest to verify correctness\n        from\n          pr_ntest : 0%r < mu sample (predC test)\n        do\n          esplit\n            with [ true ]\n            apply sample_ll\n            while\n          done\n      }.\n  }\n\n}"]], "EC-1/W64_SchnorrProtocol.ec": [[true, "module ZeroKnowledgeProof.\n\n(* Interfaces for Prover and Verifier *)\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power: W64xN.R.t, challenge: W64xN.R.t) : W64xN.R.t\n  proc commitment () : W64xN.R.t * W64xN.R.t\n}\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t\n  proc response(challenge: W64xN.R.t) : W64xN.R.t\n}\n\nmodule type ZKVerifierJ = {\n  proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) : W64.t\n  proc challenge() : W64xN.R.t\n}\n\n(* Completeness Module *)\n\nmodule CompletenessJ(Prver: ZKProverJ)(Vrfr: ZKVerifierJ) = {\n  proc main (witness0: W64xN.R.t, secret_power: W64xN.R.t, statement: W64xN.R.t) : W64.t = {\n    let (commitment0, commitment1) = Prver.commitment() in\n    let challenge0 = Vrfr.challenge() in\n    let response = Prver.response(witness0, secret_power, challenge0) in\n    Vrfr.verify(statement, commitment0, challenge0, response)\n  }\n}\n\n(* Soundness Module *)\n\nmodule SoundnessJ(MPrver: ZKMaliciousProverJ)(Vrfr: ZKVerifierJ) = {\n  proc main (statement: W64xN.R.t) : W64.t = {\n    let commitment0 = MPrver.commitment() in\n    let challenge0 = Vrfr.challenge() in\n    let response = MPrver.response(challenge0) in\n    Vrfr.verify(statement, commitment0, challenge0, response)\n  }\n}\n\n(* Rewinding and Extraction *)\n\nmodule type ZKRewindableMaliciousProverJ = {\n  proc save_state() : unit\n  proc restore_state() : unit\n}\n\nmodule ExtractorJ(RMPrver: ZKRewindableMaliciousProverJ) = {\n  proc extract_witness() : W64xN.R.t = {\n    RMPrver.save_state();\n    (* Insertion of extraction logic *)\n    RMPrver.restore_state();\n    (* Return extracted witness *)\n    W64xN.R.t.zero  (* Placeholder *)\n  }\n}\n\n(* Distinguishing Logic *)\n\nmodule type ZKDistinguisherJ = {\n  proc distinguish(real_summary: W64xN.R.t, ideal_summary: W64xN.R.t) : W64.t\n}\n\n(* Malicious Verifiers *)\n\nmodule type MaliciousVerifierJ = {\n  proc challenge() : W64xN.R.t\n  proc summarize(response: W64xN.R.t) : W64xN.R.t\n}\n\nmodule type RewMaliciousVerifierJ = {\n  proc challenge() : W64xN.R.t\n  proc summarize(response: W64xN.R.t) : W64xN.R.t\n}\n\n(* Simulation *)\n\nmodule SimulatorJ(MPrver: ZKMaliciousProverJ)(Mvrfr: MaliciousVerifierJ) = {\n  proc simulate() : W64xN.R.t = {\n    let commitment0 = MPrver.commitment() in\n    let challenge0 = Mvrfr.challenge() in\n    let response = MPrver.response(challenge0) in\n    Mvrfr.summarize(response)\n  }\n}\n\n(* Real vs. Ideal *)\n\nmodule ZKRealJ(Prver: ZKProverJ)(Vrfr: ZKVerifierJ) = {\n  (* Real-world protocol execution logic *)\n}\n\nmodule ZKIdealJ(Sim: SimulatorJ)(Dstr: ZKDistinguisherJ) = {\n  (* Ideal-world protocol execution logic for simulation *)\n}\n\nend."]], "EC-1/async-while.ec": [[true, "module type I = {\n  proc step: int -> value -> value\n}\n\nmodule M (A: I) = {\n  proc f(n: int, k: int, x: value): value = {\n    var i: int = 0;\n    while i < n * k do {\n      x = A.step(i, x);\n      i = i + 1;\n    }\n    return x;\n  }\n\n  proc g(n: int, k: int, x: value): value = {\n    var i: int = 0;\n    var j: int;\n    while i < n do {\n      j = 0;\n      while j < k do {\n        x = A.step(k * i + j, x);\n        j = j + 1;\n      }\n      i = i + 1;\n    }\n    return x;\n  }\n}\n\nlemma M_equiv: forall (n: int) (k: int) (x: value),\n  (forall i: int, y: value, A.step(i, y) = A.step(i, y)) ->\n  M(A).f(n, k, x) = M(A).g(n, k, x)."]], "EC-1/ambient-logic.ec": [[true, "(* Import necessary theories *)\nrequire import Int.\n\n(* Set pragma to print all goals *)\npragma Goals: printall.\n\n(* Prove reflexivity of integers *)\nlemma int_refl: forall (x: int), x = x.\nproof.\n  trivial.\nqed.\n\n(* Display commands to print properties and operations *)\nprint int_refl.\nprint op (+).\nprint op min.\nprint axiom Int.fold0.\n\n(* Use the reflexivity lemma to show equality *)\nlemma forty_two_equal: 42 = 42.\nproof.\n  apply int_refl.\nqed.\n\n(* Prove commutativity of addition using simplification *)\nlemma x_plus_comm (x: int): x + 2*3 = 6 + x.\nproof.\n  simplify.\n  trivial.\n  apply addzC.\nqed.\n\n(* Admit complex goals to focus on other parts of the proof *)\nlemma x_minus_equal (x: int): x - 10 = x - 9 - 1.\nproof.\n  admit.\nqed.\n\n(* Disjunctions and assumptions handling *)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\n  admit.\nqed.\n\n(* Search for relevant lemmas and axioms *)\nsearch (+).\nsearch ( * ).\n\n(* Use smt tactic for external SMT solver assistance *)\nlemma x_pos_smt (x: int): 0 < x => 0 < x+1.\nproof.\n  smt.\nqed.\n\n(* Prove logarithmic properties using assumptions *)\nlemma ln_product (x y: real): 0%r < x => 0%r < y => ln (x*y) = ln x + ln y.\nproof.\n  move => H1 H2.\n  by apply lnM.\nqed."]], "EC-1/asgncase.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[M.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\n  proc.\n  move=> x y.\n  case: y => [|y /=].\n  - case: y => [|] /=; by auto.\n  seq 1: (x' = 0 /\\ y' = 1).\n  - by auto.\n  - by auto.\nqed."]], "EC-1/adversary.ec": [[true, "theory ProtocolAnalysis.\n\n  (* Define the type used by the protocol *)\n  type r.\n\n  (* Define the distribution on type r *)\n  op dr: distr r.\n  axiom dr_lossless: lossless dr.\n\n  (* Define the testing function *)\n  op test: r -> bool.\n\n  (* Define the expected probability of test success *)\n  const p: real.\n  axiom dr_mu_test: p > 0.\n\n  (* Define the small error margin *)\n  const eps: real.\n\n  (* Define the Oracle module *)\n  module Oracle = {\n    var c: int = 0.\n    var log: list r = [].\n    var bad: bool = false.\n\n    proc extend_log() =\n      var x: r <- sample dr.\n      log <- x :: log.\n      if test(x) then c <- c + 1.\n\n    proc o() =\n      while not bad do\n        extend_log();\n        if c > some_threshold then\n          bad <- true.\n  }.\n\n  (* Define the Adversary module *)\n  module Adv = {\n    proc adv() =\n      Oracle.o();\n      (* Adversarial logic goes here *)\n  }.\n\n  (* Define the Main module *)\n  module Main = {\n    proc main() =\n      Oracle.bad <- false;\n      Oracle.c <- 0;\n      Oracle.log <- [];\n      Adv.adv();\n  }.\n\n  lemma pr_bad:\n    forall (Q: real). \n    Pr[ Main.main() : Oracle.bad ] <= eps * Q * (inv p).\n\nend."]], "EC-1/ArrayFiniteness.ec": [[true, "module ProtocolAnalysis.\n\n  (* Define the space for Boolean values and create all possible tuples of size 8 *)\n  type bool_list = list bool.\n\n  (* Create all possible 8-bit lists *)\n  op all_8lists : unit -> set bool_list.\n  axiom all_8lists_spec :\n    forall l, In l (all_8lists()) <-> length l = 8 /\\ (forall b, In b l -> b = true \\/ b = false).\n\n  (* Mapping function and properties for 8-bit words *)\n  op W8.bits2w : bool_list -> word8.\n  op all_8words : unit -> set word8.\n  axiom all_8words_spec :\n    all_8words() = image W8.bits2w (all_8lists()) /\\\n    forall w, In w (all_8words()) <-> exists l, W8.bits2w l = w /\\ In l (all_8lists()).\n\n  (* Define the space for 256-element boolean lists *)\n  type word_list_256 = list word8.\n\n  (* Create all possible 256-bit lists *)\n  op all_256lists : unit -> set word_list_256.\n  axiom all_256lists_spec :\n    forall l, In l (all_256lists()) <-> length l = 256 /\\ (forall w, In w l -> In w (all_8words())).\n\n  (* Mapping function and properties for 256-bit words *)\n  op WArray256.of_list : word_list_256 -> array256.\n  op all_256words : unit -> set array256.\n  axiom all_256words_spec :\n    all_256words() = image WArray256.of_list (all_256lists()) /\\\n    forall a, In a (all_256words()) <-> exists l, WArray256.of_list l = a /\\ In l (all_256lists()).\n\n  (* Create lists containing 1 8-bit element *)\n  op all_256lists1 : unit -> set word_list_256.\n  axiom all_256lists1_spec :\n    forall l, In l (all_256lists1()) <-> length l = 1 /\\ (forall w, In w l -> In w (all_8words())).\n\n  (* Mapping function and properties for single 256-bit words *)\n  op all_256words1 : unit -> set array256.\n  axiom all_256words1_spec :\n    all_256words1() = image WArray256.of_list (all_256lists1()) /\\\n    forall a, In a (all_256words1()) <-> exists l, WArray256.of_list l = a /\\ In l (all_256lists1()).\n\n  (* Create 64-bit elements up to modulusR *)\n  variable modulusR : int.\n  type word64xN = list int.\n\n  op all_w64xN : unit -> set word64xN.\n  axiom all_w64xN_spec :\n    forall n, In n (all_w64xN()) <-> 0 <= n < modulusR.\n\n  (* Lemmas for validating properties *)\n  lemma size_8lists : length (all_8lists()) = 256.\n  lemma uniqueness_8words : forall w1 w2, In w1 (all_8words()) /\\ In w2 (all_8words()) /\\ w1 = w2 -> w1 = w2.\n\n  lemma size_256lists : length (all_256lists()) = pow 256 256.\n  lemma uniqueness_256words : forall a1 a2, In a1 (all_256words()) /\\ In a2 (all_256words()) /\\ a1 = a2 -> a1 = a2.\n\n  lemma size_w64xN : length (all_w64xN()) = modulusR.\n  lemma uniqueness_w64xN : forall n1 n2, In n1 (all_w64xN()) /\\ In n2 (all_w64xN()) /\\ n1 = n2 -> n1 = n2.\n\nend ProtocolAnalysis."]], "EC-1/AuxLemmas.ec": [[true, "module DistributionsAndMappings {\n\n  (* Required imports for foundational elements *)\n  import {\"core/AllCore.ec\"}\n  import {\"prob/Distr.ec\"}\n  import {\"data/Finite.ec\"}\n  import {\"data/List.ec\"}\n  import {\"bit/BitEncoding.ec\"}\n\n  (* Module defining a trivial action with a high level lemma *)\n  module Skip {\n    proc run() : bool = {\n      return true;\n    }\n\n    lemma skip_run:\n      Pr[run() @ Skip] = 1.\n  }\n\n  (* Mathematical operations and properties *)\n  op LessThan(x:int, bound:int) : bool = {\n    x < bound\n  }\n\n  (* Defining an injective function and its inverse properties *)\n  op inv(f: 'a -> 'b, y: 'b) : 'a = {\n    choice (x: 'a) (f x = y)\n  }\n\n  axiom invP : forall f x y.  f x = y /\\ (forall z. f x = f z => x = z)\n               => inv(f, y) = x\n\n  (* Sequence construction using recursive definition *)\n  lemma mkseqS' :\n    forall (f : int -> 'a) (n : int). \n      seq f 0 n = seq_head f n :: seq_tail f n\n\n  (* Properties of uniform distributions over bounded sets *)\n  lemma d_uni_sum :\n    forall (f : int -> real) (n : int). \n      Expectation[int_dist(random(n)); f] = (sum (fun i => f i) n) / real_of_int(n)\n\n  (* Choice function encapsulating specific criteria *)\n  op nasty_id(x: int) : int = {\n    choice y : int, x = y\n  }\n\n  lemma nasty_id_correct :\n    forall x. nasty_id(x) = x\n\n  lemma kok :\n    forall x y : real. x < y => x + 1 <= y\n\n  lemma inveq :\n    forall x y : real. x <> y => x <> y + 1\n\n}"]], "EC-1/AuxResults.ec": [[true, "import DJoin\nimport AllCore\nimport Distr\nimport FSet\nimport StdRing\nimport StdOrder\nimport StdBigop\nimport List\nimport RealExp\nimport RField\nimport RealOrder\nimport BigReal\n\nsection Definitions\n  (* Define required types and constants *)\nend\n\nsection SummationReindexing\n  lemma big_reindex:\n    forall (A : Type) (f : A -> nat) (s : seq A) (g : nat -> nat),\n      (forall x y, f x = g y <-> x = y) ->\n      \\sum_(i < size s) f (nth A x s i) = \\sum_(i < size s) f (nth A x s (g i)).\nend\n\nsection SummationFormulas\n  lemma big_formula_p:\n    forall (p : real) (n : nat),\n      0 <= p <= 1 ->\n      \\sum_(i < n) (p ^ i * (1 - p) ^ (n - i)) = 1.\n\n  lemma big_formula_1mp:\n    forall (p : real) (n : nat),\n      0 <= p <= 1 ->\n      \\sum_(i < n) ((1 - p) ^ i * p ^ (n - i)) = 1.\nend\n\nsection ProbabilityInequalities\n  lemma multn:\n    forall (p : real) (n : nat),\n      0 <= p <= 1 ->\n      0 <= p^n <= 1.\n\n  lemma multn2:\n    forall (p : real) (n : nat),\n      0 <= p <= 1 ->\n      forall m, 0 <= p^(n + m) <= 1.\n\n  lemma big_geq0:\n    forall (A : Type) (f : A -> real) (s : seq A),\n      (forall x, x \\in s -> 0 <= f x) ->\n      0 <= \\sum_(x \\in s) f x.\n\n  lemma big_leq1:\n    forall (A : Type) (f : A -> real) (s : seq A),\n      (forall x, x \\in s -> 0 <= f x <= 1) ->\n      \\sum_(x \\in s) f x <= 1.\nend\n\nsection JointDistributionWeight\n  lemma djoinmap_weight:\n    forall (A B : Type) (d : Distr A) (f : A -> Distr B),\n      (forall a, weight (f a) = 1) ->\n      weight (djoinmap f d) = 1.\nend\n\nsection ListOperations\n  lemma take_zip:\n    forall (A B : Type) (s1 : seq A) (s2 : seq B),\n      take (minn (size s1) (size s2)) (zip s1 s2) = zip (take (size s1) s1) (take (size s2) s2).\n\n  lemma sub_all:\n    forall (A : Type) (s : seq A) (x : A),\n      x \\notin s ->\n      all (fun y => y != x) s.\nend\n\nsection CaseSplitting\n  lemma splitcases:\n    forall (p : prob), p < 1 ->\n    \\sum_(b in bool) (if b then p else 1 - p) = 1.\nend"]], "EC-1/BarrettRedInt.ec": [[true, "// Define abstract types for real and integer numbers\ntype real\ntype integer\n\n// Define functions for real operations\nfun r(n: real, k: real): real =\n  let r = ... // Substitute with the value defining the real modulo\n  floor((4.0 * (r^k)) / n) mod r\n\nfun t_prime(x: real, n: real, k: real): real =\n  let r_n_k = r(n, k)\n  floor((x * r_n_k) / (4.0^k)) mod r\n\nfun t(x: real, n: real, k: real): real = \n  // Assume t(x, n, k) is a transformation of t'(x, n, k)\n  t_prime(x, n, k)\n\n// Define barrett_reduction function for integers\nfun barrett_reduction(x: integer, n: integer, k: integer): integer =\n  let ti = t(x as real, n as real, k as real)\n  if ti < n then ti else ti - n\n\n// Establish lemma assertions\nlemma non_negativity: forall n k x, ... \n  // Define conditions ensuring non-negativity\n  (* The exact condition and proof in EasyCrypt syntax not provided due to limited details *)\n\nlemma boundedness: forall n k, n^2 < 4^k\n  // Define assumptions and conditions ensuring bounds on n and k\n  (* Similarly, provide proof and implication *)\n\n// Define key properties and correctness lemmas\nlemma barrett_correctness: forall x n k, ...\n  // Ensures correctness of barrett_reduction operation\n\n// Define additional utility lemmas as necessary for operations\nlemma operation_efficiency: ...\n  // Prove operational efficiency based on described technique\n\n// Additional lemmas could be derived here based on the description\n// including modular arithmetic properties, minimal division, etc."]], "EC-1/ASPSemantics.ec": [[true, "module type L = {\n  type secret_t\n  type program_t\n  type output_event_t\n}\n\nmodule type Semantics(L: L) = {\n  type sideInfo_t\n\n  val init: L.program_t -> unit\n  val step: unit -> sideInfo_t option\n  val setInput: L.secret_t -> bool\n  val getOutput: unit -> L.secret_t option\n}\n\nmodule type EnvSemInterface(L: L) = {\n  type sideInfo_t\n\n  val setInput: L.secret_t -> bool\n  val getOutput: unit -> L.secret_t option\n  val activate: unit -> sideInfo_t option\n}\n\nmodule type Environment(L: L) = {\n  val animate: unit -> unit\n}\n\nmodule type AdvSemInterface = {\n  type sideInfo_t\n\n  val step: unit -> sideInfo_t option\n}\n\nmodule type Adversary = {\n  val step: unit -> unit\n}\n\nmodule type EnvironmentSemanticsInterface(L: L) = {\n  include EnvSemInterface(L)\n  include Adversary\n}\n\nmodule Eval(L: L) = {\n  module SemS = Semantics(L)\n  module EnvS = EnvironmentSemanticsInterface(L)\n\n  let eval (sem: #SemS) (env: #EnvS) (prog: L.program_t) =\n    sem.init(prog);\n    env.animate()\n}"]], "EC-1/BarrettReduction_Abstract.ec": [[true, "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n(* Proof of equivalence for Barrett reduction *)\nproc barrett_reduction_correct:\n\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm:  a{1} = a{2} /\\ p{1} = p{2} /\\ k{1} = k{2}\n  /\\ 0 < p{2} < W64xN.modulusR \n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  ==> ={res}.\nproc.\n  inline*. wp. skip. progress.\n  rewrite - (barrett_reduction_correct a{2} p{2} k{2}). auto. auto. auto. \n  rewrite /barrett_reduction. simplify.\n  have -> : 2 ^ (2 * k{2}) = 4 ^ k{2}. smt(@Real).\n  have <-:  a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n            = (a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} %% 2 ^ k{2} * p{2}) %% W64x2N.modulusR.\n  rewrite modz_small.\n  rewrite /ti. rewrite /ti'. rewrite /ri.\n  have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n    rewrite /ti /ti'. auto.\n  have ->: ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \n  rewrite modz_small. split.\n    apply divz_ge0. smt(@Real).\n  smt(exprn_ege1).\n  rewrite /ri.\n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n    rewrite - same_t'. auto. auto.\n  have qq:  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r. \n    apply st6. smt(). split. smt(). move => ?. rewrite exp_lemma1. auto. auto. smt(@Real).\n  smt(). auto.\n  have ->: a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n            = ti a{2} p{2} k{2}. rewrite /ti /ti'. auto.\n  split.\n    have: 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n      rewrite - same_t. auto. auto.\n    apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split.  smt(). smt(). smt(exp_lemma1).\n  progress. smt(). move => _.\n  have ->: `|W64xN.modulusR2| = W64xN.modulusR2. rewrite /W64xN.modulusR2. smt(@Ring).\n  have: 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n    rewrite - same_t. auto. auto.\n  apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split. smt(). smt().\n  split. smt(). move => ?. smt(exp_lemma1).\n  progress.\n  have: 2 * p{2} < W64xN.modulusR2. rewrite /W64xN.modulusR2. \n  have: W64x2N.M ^ nlimbs <= W64x2N.M ^ (2 * nlimbs).\n    apply ler_weexpn2l. smt(). smt().\n  have: p{2} <= W64x2N.M ^ nlimbs.\n    have ->: W64x2N.M ^ nlimbs = W64xN.modulusR. rewrite /W64xN.modulusR. auto. smt().\n  smt(). smt().\n  have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} = ti' a{2} p{2} k{2}. \n  rewrite /ti /ti'. auto.\n  have ->: ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \n  rewrite modz_small. split. \n    have: 0 <= ri p{2} k{2} %/ 4 ^ k{2}. apply divz_ge0. smt(exprn_ege1). rewrite /ri.\n    apply divz_ge0. smt(). smt(exprn_ege1). smt(). \n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have: (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n    rewrite - same_t'. auto. auto.\n  have qq:  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r.\n    apply st6. smt(). split. smt(). move => ?. smt(exp_lemma1).\n  smt(). smt(). auto.\nsmt(). auto.\nqed."]], "EC-1/basic-hash-unlink.ec": [[true, "module type PRF = {\n  type key, ptxt\n  \n  op f : key -> ptxt -> bytes\n  axiom f_secure : forall k, indistinguishable (fun x -> f k x) random_function\n}\n\nmodule HashProtocol(P : PRF) = {\n  type tag = P.key\n  type session_id = int\n\n  const n_session : int\n  \n  type state = { sessions : list (session_id, tag) }\n  \n  op init_single_tag : P.key -> state = fun k =>\n    { sessions = [] }\n  \n  op run_session : state -> session_id -> P.ptxt -> (state * bytes) = fun st sid nonce =>\n    let sk = random key in\n    let tag = P.f sk nonce in\n    let new_sessions = (sid, sk) :: st.sessions in\n    ({ sessions = new_sessions }, tag)\n\n  predicate valid_session : state -> session_id -> tag -> bool = fun st sid sk =>\n    List.forall (fun (s, k) -> s <> sid || k = sk) st.sessions\n\n  lemma unforgeability : forall st sid nonce tag,\n    valid_session st sid tag -> non_trivial (fun x => P.f x nonce = tag)\n  \n  type reader_state = list (session_id, bytes)\n  \n  op reader_verify_single_tag : reader_state -> session_id -> bytes -> bool = fun rs sid tag =>\n    List.exists (fun (s, t) -> s = sid && t = tag) rs\n  \n  lemma unlinkability : forall adv,\n    easycrypt_advantage adv is_bounded_by_the_combined_security_of_prfs_and_nonce_collision\n}"]], "EC-1/BigNum_proofs.ec": [[true, "module BigNumOperations {\n\n  // Import necessary modules\n  import AllCore, IntDiv, CoreMap, List, RealExp\n  import W64_SchnorrExtract\n  import BigNum_spec, AuxLemmas\n\n  // Define the main module containing arithmetic operations\n  module M {\n    \n    // Modular addition operation\n    proc bn_addc(a: int, b: int): int with\n      ensures { result = ASpecFp.addn(a, b) }\n\n    // Modular subtraction operation\n    proc bn_subc(a: int, b: int): int with\n      ensures { result = ASpecFp.subn(a, b) }\n\n    // Conditional move operation\n    proc bn_cmov(condition: bool, x: int, y: int): int with\n      ensures { if condition then result = x else result = y }\n\n    // Equality check for big numbers\n    proc bn_eq(a: int, b: int): bool with\n      ensures { result = (a = b) }\n\n    // Copy operation for big numbers\n    proc bn_copy(src: int): int with\n      ensures { result = src }\n\n    // Bit manipulation functions\n\n    // Retrieve the ith bit of a big number\n    proc ith_bit(num: int, i: int): bool with\n      ensures { result = (num >> i) mod 2 = 1 }\n\n    // Swap two values based on a condition\n    proc swap(condition: bool, a: int, b: int): (int, int) with\n      ensures { if condition then result = (b, a) else result = (a, b) }\n\n    // Correctness lemmas\n    lemma bn_addm_correct: forall a b.\n      ensures { bn_addc(a, b) = ASpecFp.addn(a, b) }\n\n    lemma bn_subm_correct: forall a b.\n      ensures { bn_subc(a, b) = ASpecFp.subn(a, b) }\n\n    // Additional lemmas for completeness\n    lemma bn_eq_correct: forall a b.\n      ensures { bn_eq(a, b) <=> a = b }\n\n    lemma ith_bit_correct: forall num i.\n      ensures { ith_bit(num, i) = ((num >> i) mod 2 = 1) }\n\n    lemma swap_correct: forall condition a b.\n      ensures { swap(condition, a, b) = (if condition then (b, a) else (a, b)) } \n  }\n}"]], "EC-1/BinUniSample_spec.ec": [[true, "module SampleByte = {\n  (* Define a function to sample an integer between 0 and 255 *)\n  proc sampleInt() : int = {\n    (* Uniformly samples an integer in the range 0..255 *)\n    var n: int <- any[int in 0..255];\n    return n;\n  }\n\n  (* Define a run procedure to determine parity of sampled integer *)\n  proc run() : int = {\n    var n: int <- sampleInt();\n    return n % 2;  (* 0 for even, 1 for odd *)\n  }\n}\n\nmodule RandomChoiceSpec = {\n  proc spec(a: int, b: int) : int = {\n    if (a == b) then\n      return a;\n    else\n      var r: int <- any[int such that 0 <= r <= 1];\n      if (r == 0) then return a else return b;\n  }\n}\n\nmodule BinSampleSpec : {\n  proc main(a: int, b: int) : int;\n  proc spec(a: int, b: int) : int;\n} = {\n  (* Main procedure which selects between a and b using SampleByte.run() *)\n  proc main(a: int, b: int) : int = {\n    var choice: int <- SampleByte.run();\n    if (choice == 0) then return a else return b;\n  }\n\n  (* Specification procedure to model the desired behavior *)\n  proc spec(a: int, b: int) : int = {\n    if (a == b) then return a\n    else var choice: int <- any[int in 0..1]; \n    if (choice == 0) then return a else return b;\n  }\n}\n\nmodule BinSampleProof = {\n  (* Probability lemmas *)\n\n  lemma sample_prob0 : Pr[SampleByte.run() = 0] = 1/2.\n  proof.\n    (* Use uniform distribution property *)\n    intros.\n    apply uniform_mod2_0.\n  qed.\n\n  lemma sample_prob1 : Pr[SampleByte.run() = 1] = 1/2.\n  proof.\n    (* Use uniform distribution property *)\n    intros.\n    apply uniform_mod2_1.\n  qed.\n\n  (* Correctness lemmas *)\n\n  lemma fst_choice_pr: forall a b. a <> b ->\n    Pr[BinSampleSpec.main(a, b) = a] = 1/2.\n  proof.\n    intros.\n    rewrite /BinSampleSpec.main.\n    specialize (sample_prob0).\n    done.\n  qed.\n\n  lemma snd_choice_pr: forall a b. a <> b ->\n    Pr[BinSampleSpec.main(a, b) = b] = 1/2.\n  proof.\n    intros.\n    rewrite /BinSampleSpec.main.\n    specialize (sample_prob1).\n    done.\n  qed.\n\n  lemma sat_spec_not_eq :\n    forall a b. a <> b -> equiv BinSampleSpec.main(a, b) ~ BinSampleSpec.spec(a, b) : [].\n  proof.\n    intros.\n    rewrite /BinSampleSpec.main /BinSampleSpec.spec.\n    apply equivalence_property.\n  qed.\n\n  lemma sat_spec :\n    forall a b. equiv BinSampleSpec.main(a, b) ~ BinSampleSpec.spec(a, b) : [].\n  proof.\n    intros.\n    cases a = b; [ apply reflexivity | apply sat_spec_not_eq ]; trivial.\n  qed.\n\n}"]], "EC-1/check-easycrypt-install.ec": [[true, "tags. This code captures the essence of the Simple Integer Inequality Protocol described, specifying the lemma `foo` that verifies the inequality property after incrementing two integers. The `smt()` tactic is used to apply the SMT solvers for the proof."]], "EC-1/ConstantsValidation.ec": [[true, "module ModularExponentiation\n\n(* Constants for the protocol *)\nconst g : int\nconst p : int\nconst q : int\nconst ex_w : int\nconst ex_s : int\nconst barrett_numerator : int\nconst barrett_numerator_div_p : int\nconst barrett_numerator_mod_p : int\n\n(* Type representing state of square_and_multiply *)\ntype square_and_multiply_state = {\n  (* base, exponent, result, modulus *)\n  x : int;\n  y : int;\n  z : int;\n  m : int;\n}\n\n(* Square-and-multiply algorithm step *)\npredicate square_and_multiply_step(s1: square_and_multiply_state, s2: square_and_multiply_state) = \n  if s1.y mod 2 = 1 then \n    (s2.x = s1.x ^ 2 mod s1.m) && (s2.z = s1.z * s2.x mod s1.m) && (s2.y = s1.y / 2)\n  else\n    (s2.x = s1.x ^ 2 mod s1.m) && (s2.z = s1.z) && (s2.y = s1.y / 2)\n\n(* End condition for square-and-multiply *)\npredicate square_and_multiply_end(s: square_and_multiply_state) = \n  s.y = 0 => s.z mod s.m = s.z\n\n(* Lemmas relating to modular exponentiation *)\nlemma red_exp' : forall x' x'' y : int, forall m : int.\n  x' mod m = x'' mod m -> (x'^y mod m) = (x''^y mod m)\n\nlemma red_exp : forall x' x'' y : int, forall m : int.\n  x' mod m = x'' mod m -> (x'^Abs(y) mod m) = (x''^Abs(y) mod m)\n\n(* State transition lemma for square-and-multiply *)\nlemma square_and_multiply_step_correct : forall s1 s2 : square_and_multiply_state.\n  square_and_multiply_step(s1, s2) -> s2.z mod s2.m = s1.z mod s1.m\n\n(* Final state lemma for square-and-multiply *)\nlemma square_and_multiply_end_correct : forall s : square_and_multiply_state.\n  square_and_multiply_end(s) -> s.z = s.x ^ s.y mod s.m\n\n(* Lemma verifying witness pair *)\nlemma statement_witness_pair_is_valid : ex_g ex_w ex_s : int.\n  ex_g^ex_w mod p = ex_s\n\n(* Lemma validating generator properties *)\nlemma generator_is_valid : g^q mod p = 1\n\n(* Lemma for Barrett reduction parameters using Euclidean algorithm *)\nlemma pq_euclid : barrett_numerator mod p = 0\n\n(* Lemma proving correctness of Barrett parameter *)\nlemma bp_correct : barrett_numerator_div_p * p + barrett_numerator_mod_p = barrett_numerator\n\nend"]], "EC-1/cramer_shoup.ec": [[true, "module CramerShoupEncryptionScheme.\n\n  // Define the cryptographic assumptions and group settings\n  hypothesis DH :\n    forall (G : Group)(g : G)(a b : Z),\n    indistinguishable (G) (prod (exp g a) (exp g b)) (prod (exp g a) (exp g b) (exp g c)).\n\n  variable G : Group.\n  variable g : G.\n\n  // The hash function used in the scheme\n  variable H : G -> G.\n\n  // Key generation process\n  proc keygen() : ((G * G * G * G * G * Z), (G * G * Z * Z * Z * Z * Z * Z)) \n  = \n    let x1 = random()\n    in let x2 = random()\n    in let y1 = random()\n    in let y2 = random()\n    in let z1 = random()\n    in let z2 = random()\n    in let k = random()\n    in let gw = exp g k\n    in let pk = (k, g, gw, exp g x1 * exp gw x2, exp g y1 * exp gw y2, exp g z1 * exp gw z2)\n    in let sk = (k, g, gw, x1, x2, y1, y2, z1, z2)\n    in (pk, sk).\n\n  // Encryption process\n  proc encrypt(pk : G * G * G * G * G * Z, m : G) : (G * G * G * G)\n  = \n    let (k, g, gw, h, e, f) = pk\n    in let u = random()\n    in let a = exp g u\n    in let a' = exp gw u\n    in let c = exp h u * m\n    in let v = H(k, (a, a', c))\n    in let d = exp e u * exp f (u * v)\n    in (a, a', c, d).\n\n  // Decryption process\n  proc decrypt(sk : G * G * Z * Z * Z * Z * Z * Z, ct : G * G * G * G) : option G \n  = \n    let (k, g, gw, x1, x2, y1, y2, z1, z2) = sk\n    in let (a, a', c, d) = ct\n    in let v = H(k, (a, a', c))\n    in if d = exp a z1 * exp a' z2 then\n         Some (c / (exp a z1 * exp a' z2))\n       else None.\n\n  // Correctness proof\n  lemma correctness : forall (pk sk : G * G * Z * Z * Z * Z * Z * Z)(m : G),\n  let ct = encrypt pk m in\n  decrypt sk ct = Some m.\n\n  // Security proof under CCA assumption\n  lemma CCA_security : \n  forall (A : {cca_adversary | advantage A} A < epsilon),\n  exists (B : {ddh_adversary | advantage B} B < epsilon_2),\n  reduction_correct A B.\n\nend."]], "EC-1/Djoinmap.ec": [[true, "module Protocol.\n\n  // Define the type 'a' and 'b'\n  type a.\n  type b.\n\n  // Define the distribution operation\n  op d : a -> b distr.\n\n  // Define the merge function\n  op merge ['a] : list 'a -> list 'a -> list 'a.\n\n  // Define the split function\n  op splitf ['a] (n : int) : list 'a -> list 'a * list 'a.\n\n  // Procedure main1: Computes pairs of distributions from joint map\n  proc main1 (l1 : list a) (l2 : list a) : distr (list b * list b) = {\n    let d1 = map (fun x => sample d x) l1 in\n    let d2 = map (fun x => sample d x) l2 in\n    ret (d1, d2).\n  }\n\n  // Procedure main2: Generates joint distribution from lists\n  proc main2 (l1 : list a) (l2 : list a) : distr (list b * list b) = {\n    let d12 = map (fun (x, y) => let dx = sample d x in let dy = sample d y in (dx, dy)) (zip l1 l2) in\n    ret d12.\n  }\n\n  // Procedure main3: Maps and merges joint distributions\n  proc main3 (l1 : list a) (l2 : list a) : distr (list b * list b) = {\n    let d12 = main2 l1 l2 in\n    (* Suppose merge here combines results in a suitable manner *)\n    ret (merge fst d12, merge snd d12). // Hypothetical illustration\n  }\n\n  // Procedure main4: Merges lists and computes joint distribution\n  proc main4 (l1 : list a) (l2 : list a) : distr (list b * list b) = {\n    let lm = merge l1 l2 in\n    let d12 = main2 lm lm in\n    ret d12.\n  }\n\n  // Procedure main5: Computes joint distribution from a single list\n  proc main5 (l : list a) : distr (list b * list b) = {\n    let d1 = map (fun x => sample d x) l in\n    ret (d1, d1).\n  }\n\n  // Procedure main6: Calls main1 with intermediate transformations\n  proc main6 (l : list a) (l' : list a) (w : list int) : distr (list b * list b) = {\n    main1 l l'.\n  }\n\n  // Lemma main12: Equivalence between main1 and main2\n  lemma main12 : forall l1 l2, Pr[main1 l1 l2] = Pr[main2 l1 l2].\n\n  // Lemma main23: Equivalence between main3 and main2\n  lemma main23 : forall l1 l2, Pr[main3 l1 l2] = Pr[main2 l1 l2].\n  \n  // Lemma main34: Equivalence between main4 and main3\n  lemma main34 : forall l1 l2, Pr[main4 l1 l2] = Pr[main3 l1 l2].\n\n  // Lemma djm_main14: Equivalence between main1 and main4\n  lemma djm_main14 : forall l1 l2, Pr[main1 l1 l2] = Pr[main4 l1 l2].\n  \nend."]], "EC-1/DoubleBigNum_proofs.ec": [[true, "require import AllCore IntDiv CoreMap List RealExp.\nimport StdBigop Bigint BIA.\n\nrequire import JModel.\n\nrequire import W64_SchnorrExtract.\n\nrequire import BigNum_spec AuxLemmas.\nimport W64x2N R.\n\nrequire import BitEncoding.\nimport BS2Int.\n\nmodule M = M(Syscall).\n\nequiv daddc_spec:\n  M.dbn_addc ~ ASpecFp.daddn:\n    W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n    ==> res{1}.`1 = res{2}.`1 /\\ W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  (* Implement the detailed steps for the proof here *)\nadmit.\nqed.\n\nlemma dbn_cmov_correct x y cond:\n  phoare[M.dbn_cmov : arg = (x, y, cond) ==> cond = true -> res = y /\\ cond = false -> res = x] = 1%r.\nproof.\n  (* Implement the proof steps for conditional move correctness *)\nadmit.\nqed.\n\nlemma dbn_addm_correct x y:\n  phoare[M.dbn_addm : arg = (x, y) ==> (W64x2N.valR res) = (W64x2N.valR x + W64x2N.valR y) %% W64x2N.modulusR] = 1%r.\nproof.\n  (* Implement the detailed proof for modular addition correctness *)\nadmit.\nqed.\n\nequiv dsubc_spec:\n  M.dbn_subc ~ ASpecFp.dsubc:\n    W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n    ==> res{1}.`1 = res{2}.`1 /\\ W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  (* Step-by-step proof of substraction with carry *)\nadmit.\nqed.\n\nequiv dmuln_spec:\n  M.dbn_muln ~ ASpecFp.muln:\n    W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n    ==> W64x2N.valR res{1}.`4 = res{2}\n    /\\ res{1}.`1 = W64.zero\n    /\\ !res{1}.`2 /\\ !res{1}.`3.\nproof.\n  (* Implement detailed proof reasoning for multiplication equivalence *)\nadmit.\nqed.\n\nlemma dbn_copy_correct x:\n  phoare[M.dbn_copy : arg = x ==> res = x] = 1%r.\nproof.\n  (* Prove the correctness of the copy operation *)\nadmit.\nqed."]], "EC-1/FMap.ec": [[true, "require import AllCore SmtMap Finite List FSet Ring StdOrder.\n(*---*) import IntID IntOrder.\n\nimport CoreMap.\n\n(* ==================================================================== *)\ntype ('a, 'b) fmap.\n\nop tomap ['a 'b] : ('a, 'b) fmap -> ('a, 'b option) map.\nop ofmap ['a 'b] : ('a, 'b option) map -> ('a, 'b) fmap.\n\nop \"_.[_]\" ['a 'b] (m : ('a, 'b) fmap) x =\n  (tomap m).[x].\n\nop \"_.[_<-_]\" ['a 'b] (m : ('a, 'b) fmap) x v =\n  ofmap ((tomap m).[x <- Some v]).\n\nop remove ['a 'b] (m : ('a, 'b) fmap) x =\n  ofmap ((tomap m).[x <- None]).\n\nop dom ['a 'b] (m : ('a, 'b) fmap) =\n  fun x => m.[x] <> None.\n\nlemma domE ['a 'b] (m : ('a, 'b) fmap) x :\n  dom m x <=> m.[x] <> None.\nproof. by []. qed.\n\nabbrev (\\in)    ['a 'b] x (m : ('a, 'b) fmap) = (dom m x).\nabbrev (\\notin) ['a 'b] x (m : ('a, 'b) fmap) = ! (dom m x).\n\nop [opaque] rng ['a 'b] (m : ('a, 'b) fmap) = fun y => exists x, m.[x] = Some y.\n\nlemma rngE ['a 'b] (m : ('a, 'b) fmap):\n  rng m = fun y => exists x, m.[x] = Some y.\nproof. by rewrite /rng. qed.\n\n(* -------------------------------------------------------------------- *)\n(* Axioms for the finite map *)\naxiom tomapK ['a 'b] : cancel tomap ofmap<:'a, 'b>.\naxiom ofmapK ['a 'b] (m : ('a, 'b option) map) :\n  is_finite (fun x => m.[x] <> None) => tomap (ofmap m) = m.\n\nlemma isfmap_offmap ['a 'b] (m : ('a, 'b) fmap) :\n  is_finite (fun x => (tomap m).[x] <> None).\nproof. by apply:is_finite_tomap. qed.\n\n(* Additional operations and lemmas might be defined here based on further details *)\n\n(* ==================================================================== *)"]], "EC-1/bad_abs.ec": [[true, "module type ADV = {\n  type input_a\n  type output_a\n  \n  proc a(x: input_a) : output_a\n}\n\nmodule type MAIN = {\n  type input_m\n  \n  proc main(x: input_m) : bool\n}\n\nmodule M1(Adv : ADV) = {\n  type input_m = Adv.input_a\n  proc main(x: input_m) : bool = {\n    let y = Adv.a(x) in\n    // Implement M1 specific logic using y\n    // Return a boolean result based on the execution\n    result\n  }\n}\n\nmodule M2(Adv : ADV) = {\n  type input_m = Adv.input_a\n  proc main(x: input_m) : bool = {\n    let y = Adv.a(x) in\n    // Implement M2 specific logic using y\n    // Return a boolean result based on the execution\n    result\n  }\n}\n\nmodule NegA(A : ADV) : ADV = {\n  type input_a = A.input_a\n  type output_a = A.output_a\n  \n  proc a(x: input_a) : output_a = {\n    // Implement the negation logic for the adversary\n    result\n  }\n}\n\nmodule TEST(Adv : ADV) = {\n  lemma test : forall (a : Adv.input_a). \n    equiv [M1(Adv).main; M2(Adv).main]\n    ({pre a}) [E1 with M1(Adv).main -> m1_main(a); \n               E2 with M2(Adv).main -> m2_main(a)] {B}\n}\n\nmodule TEST1(Adv : ADV) = {\n  lemma test1 : forall (a : Adv.input_a). \n    equiv [M1(Adv).main; M2(Adv).main]\n    ({pre_lossless a}) \n    [E1_lossless with M1(Adv).main -> m1_main(a); \n     E2_lossless with M2(Adv).main -> m2_main(a)] {B_lossless}\n}\n\nmodule Analysis(Adv : ADV) = {\n  // Implement the probabilistic reasoning and analysis here\n  // where we evaluate probability distributions\n\n  // Exercise the lemmas\n  include TEST(Adv)\n  include TEST1(Adv)\n}"]], "EC-1/Forking.ec": [[true, "module StateManagement {\n  type state_t\n  \n  module Rewindable {\n    proc save() : state_t\n    proc restore(s : state_t) : unit\n  }\n}\n\nmodule QueryResponseTypes {\n  type in_t\n  type aux_t\n  type query_t\n  type resp_t\n  const Q : int\n}\n\nmodule FRO {\n  // Define it as a 'Forgetful Random Oracle'\n  proc response(q : query_t) : resp_t\n}\n\nmodule Log extends FRO {\n  var q_log : list query_t\n  var r_log : list resp_t\n  \n  // Log queries and responses\n  proc log_query(q : query_t) : unit = {\n    q_log <- q :: q_log\n  }\n  \n  proc log_response(resp : resp_t) : unit = {\n    r_log <- resp :: r_log\n  }\n}\n\nmodule IForker extends Log {\n  proc fst(in : in_t, aux : aux_t) : resp_t = {\n    var s : state_t <- Rewindable.save()\n    let q = ... // generate query\n    let resp = response(q)\n    Log.log_query(q)\n    Log.log_response(resp)\n    return resp\n  }\n  \n  proc snd(q : query_t, c : int) : option resp_t = {\n    // Continue protocol from query q after a count c\n    var new_state : state_t <- Rewindable.save()\n    if c < Q then {\n      let resp = response(q)\n      return Some(resp)\n    } else {\n      Rewindable.restore(new_state)\n      return None\n    }\n  }\n}\n\nmodule Analysis {\n  lemma fst_equiv_snd : forall in, aux, q, c. \n    let resp1 = IForker.fst(in, aux) in\n    let resp2 = IForker.snd(q, c) in\n    resp1 = resp2\n  \n  lemma success_prob : forall in, aux.\n    let resp = IForker.fst(in, aux) in\n    Pr[success] <= Q * Pr[success_with_fork]\n  \n  theorem forking_lemma :\n    forall in, aux.\n      Pr[fork_success] >= Pr[original_success]^2 / Q^2\n}"]], "EC-1/ForkingRO.ec": [[true, "module type FORKABLERO = {\n  type state_t, in_t, aux_t, query_t, resp_t;\n  op dresp: resp_t distr [lossless, uniform];\n  const Q: int {Q >= 1};\n\n  val get_s : state_t -> state_t;\n  val set_s : state_t -> state_t -> state_t;\n  val init : in_t -> state_t;\n  val fix_responses : query_t -> resp_t -> state_t -> state_t;\n  val continue : state_t -> (query_t * state_t);\n  val finish : state_t -> resp_t * aux_t * state_t;\n}.\n\nmodule GenThenForkRO(A : FORKABLERO) = {\n  type state_t = A.state_t;\n  type in_t = A.in_t;\n  type aux_t = A.aux_t;\n  type query_t = A.query_t;\n  type resp_t = A.resp_t;\n\n  module ForkingRO = Forking(A);\n\n  clone ForkingRO as ForkingLRO;\n};\n\nmodule Stopping(A : FORKABLERO) = {\n  module PROM = {\n    type in_t = A.query_t;\n    type out_t = A.resp_t;\n    predicate p(x:in_t, y:out_t) = true;\n  }.\n\n  module Stop = {\n    type critical_t = A.query_t;\n    op dcritical : critical_t distr;\n  }.\n\n  module Stopping = MakeStopping(PROM, Stop);\n};\n\nmodule Red(F : FORKABLERO) = {\n  type state_t = F.state_t;\n  type in_t = F.in_t;\n  type aux_t = F.aux_t;\n  type query_t = F.query_t;\n  type resp_t = F.resp_t;\n\n  op responses: Map(F.query_t, F.resp_t);\n\n  val get_s : state_t -> state_t;\n  val set_s : state_t -> state_t -> state_t;\n  val init : in_t -> state_t;\n  val fix_responses : query_t -> resp_t -> state_t -> state_t;\n  val continuation : state_t -> query_t * state_t;\n  val finish : state_t -> (resp_t * aux_t) distr;\n}.\n\nmodule IForkerRO(F : FORKABLERO) = {\n  type state_t = F.state_t;\n  type aux_t = F.aux_t;\n  type query_t = F.query_t;\n  type resp_t = F.resp_t;\n\n  val forking : state_t -> state_t -> (resp_t * aux_t) distr;\n}.\n\nmodule EqvProof = {\n  module RedF = Red(GenThenForkRO);\n  module IF = IForkerRO(GenThenForkRO);\n\n  lemma eq_proof:\n    forall (st: RedF.state_t), \n      Eqv RedF.init IF.forking RedF.forking st.\n}.\n\nlemma conven_lemmas:\n  forall (q: query_t) (r: resp_t), \n    True => \n    EqvGen eq."]], "EC-1/FSetAux.ec": [[true, "(* We import the necessary modules for handling finite sets and lists *)\nmodule Import ListSetUtils.\nopen Set.fset.\nopen List\n\n(* Lemma: oflist_cat *)\n(* It proves that converting the concatenation of two lists into a finite set is equivalent to the union of the two finite sets obtained from each list. *)\nlemma oflist_cat (A: Type) (H: equal A):\n  forall xs ys : list A, of_list (xs ++ ys) = of_list xs \\cup of_list ys.\nproof.\n  intros. rewrite of_list_cat. by reflexivity.\nQed.\n\n(* Lemma: oflist_cons *)\n(* It expresses that converting a constructed list with prepended element into a set equals the union of a singleton set and the converted tail list. *)\nlemma oflist_cons (A: Type) (H: equal A):\n  forall x: A, forall ys : list A, of_list (x :: ys) = of_list [x] \\cup of_list ys.\nproof.\n  intros. rewrite of_list_cons. by reflexivity.\nQed.\n\n(* Lemma: oflist_rcons *)\n(* It shows that the conversion of a list with an appended element equals the union of a singleton set and the converted part before appending. *)\nlemma oflist_rcons (A: Type) (H: equal A):\n  forall ys : list A, forall x: A, of_list (rcons ys x) = of_list ys \\cup of_list [x].\nproof.\n  intros. rewrite of_list_rcons. by reflexivity.\nQed.\n\n(* Lemma: minus1_not_mem *)\n(* It provides that removing a singleton element from a set does not change the set if the element is not in the set. *)\nlemma minus1_not_mem (A: Type) (H: equal A):\n  forall xs : fset A, forall y : A, y \\notin xs -> xs \\setminus [y] = xs.\nproof.\n  intros. by set_ext.\nQed\n\n(* Lemma: subset_union_r *)\n(* It proves that if a set is a subset of another, it is also a subset of the union of both sets. *)\nlemma subset_union_r (A: Type) (H: equal A):\n  forall xs ys : fset A, xs \\subset ys -> xs \\subset xs \\cup ys.\nproof.\n  intros. apply subset_trans; [apply subset_union_r; easy | apply subset_refl; easy].\nQed.\n\n(* Lemma: subset_union_l *)\n(* It asserts that a set is a subset of itself union with any other set. *)\nlemma subset_union_l (A: Type) (H: equal A):\n  forall xs ys : fset A, xs \\subset xs \\cup ys.\nproof.\n  intros. apply subset_union_l.\nQed.\n\n(* Provers *)\n(* Using both Alt-Ergo and Z3 provers for lemma validation *)\nset prove_by = alt-ergo, z3."]], "EC-1/GuessGame.ec": [[true, "// Import necessary libraries\ntheory GuessingGame.\n\n(* Define types *)\ntype bits.\n\n(* Define operations *)\nop bD : unit -> distr bits.\nop supp_size : forall 'a. distr 'a -> int.\n\n(* Module types *)\nmodule type GuessGame = {\n  proc init(r : int) : unit.\n  proc guess(x : bits) : bool.\n}.\n\nmodule type Adversary = {\n  proc play() : unit.\n}.\n\n(* Main module implementation *)\nmodule Main(q : int)(A : Adversary) = {\n  (* Secret bit drawn from distribution bD *)\n  var secret: bits.\n\n  (* Game state variables *)\n  var win: bool = false.\n  var c: int = 0.\n  \n  (* Implementation of init procedure *)\n  proc init(r : int) : unit = {\n    c <- 0;\n    win <- false;\n  }.\n  \n  (* Implementation of guess procedure *)\n  proc guess(x : bits) : bool = {\n    if (c < q) then {\n      secret <- $bD();\n      win <- (x = secret);\n      c <- c + 1;\n    };\n    win\n  }.\n  \n  (* Main procedure *)\n  proc main() : unit = {\n    init(q);\n    A.play();\n  }.\n}.\n\n(* Security analysis using a lemma *)\nlemma winPr: forall (q : int)(A : Adversary),\n  let game = Main(q, A) in\n  Pr[ game.main(); game.win ] <= q / supp_size(bD).\n\nend."]], "EC-1/hoare-logic.ec": [[true, "(* Begin EasyCrypt Code for Formal Analysis *)\n\nprintGoals.\n\nsection AllCore.\n\nmodule Func1 = {\n\n  procedure add_1(x : int) : int =\n    { return x + 1; }\n\n  procedure add_2(x : int) : int =\n    { x <- x + 2; return x; }\n    \n  module type Adv = {\n    procedure eavesdrop(x : int) : int\n  }\n}\n\n(* Hoare Triples for Func1 Procedures *)\n\nlemma triple1: forall (x:int), \n  hoare [add_1(x)] (fun _ => x = 1) (fun res => res = 2).\n\nlemma triple2: forall (x:int),\n  hoare [add_2(x)] (fun _ => x = 1) (fun res => res = 3).\n\nmodule Func2 = {\n\n  procedure x_sq(x : int) : int =\n    { return x * x; }\n\n  procedure x_0(x : int) : int =\n    { return (x * x) - x; }\n\n  procedure x_15() : int =\n    { return 15; }\n}\n\n(* Hoare Triples for Func2 Procedures *)\n\nlemma triple3: forall (x:int),\n  hoare [x_sq(x)] (fun _ => true) (fun res => res = x * x).\n\nlemma triple4: forall (x:int),\n  hoare [x_0(x)] (fun _ => true) (fun res => res = 0).\n\nlemma triple5: hoare [x_15()] (fun _ => true) (fun res => res = 15).\n\nmodule Flip = {\n\n  procedure flipper(b : bool) : bool =\n    { return not b; }\n}\n\nlemma flipper_correct_t: forall (b:bool),\n  hoare [flipper(b)] (fun _ => b = true) (fun res => res = false).\n\nlemma flipper_correct_f: forall (b:bool),\n  hoare [flipper(b)] (fun _ => b = false) (fun res => res = true).\n\nmodule Exp = {\n\n  procedure exp(x : int, n : int) : int =\n    { var res = 1; var i = n;\n      while i <> 0 do {\n        res <- res * x;\n        i <- i - 1;\n      };\n      return res;\n    }\n}\n\nlemma exp_correct: forall (x:int) (n:int),\n  hoare [exp(x, n)] (fun _ => n >= 0)\n                   (fun res => res = x ^ n).\n\n(* Generalized Lemma for Exponentiation *)\n\nlemma exp_general_correct: forall (x0:int) (n0:int),\n  hoare [exp(x0, n0)] (fun _ => n0 >= 0)\n                      (fun res => res = x0 ^ n0).\n\n(* End EasyCrypt Code for Formal Analysis *)"]], "EC-1/HybridArgumentWithParameter.ec": [[true, "module OracleType {\n  type argt\n  type input\n  type output\n  type inleaks\n  type outleaks\n  type outputA\n}\n\nmodule Oracle {\n  proc leftOracle(x: OracleType.input): OracleType.output = {\n    // Define left oracle behavior here\n  }\n\n  proc rightOracle(x: OracleType.input): OracleType.output = {\n    // Define right oracle behavior here\n  }\n}\n\nmodule Orclb {\n  clone Oracle\n  proc oracleWithLeaks(x: OracleType.input): (OracleType.inleaks, OracleType.outleaks) = {\n    let out = leftOracle(x) in\n    (computeInLeaks(out), computeOutLeaks(out))\n  }\n\n  proc hybridOracle(i: int, x: OracleType.input): OracleType.output = {\n    if i == 0 then leftOracle(x) else rightOracle(x)\n  }\n}\n\nmodule AdvOrcl {\n  proc adversary(x: OracleType.input): OracleType.outputA = {\n    // Adversary makes a query\n  }\n}\n\nmodule AdvOrclb {\n  proc adversary(x: OracleType.input): OracleType.outputA = {\n    let leaks = oracleWithLeaks(x) in\n    processLeaks(leaks)\n  }\n}\n\nmodule Count {\n  var calls: int\n\n  proc init() = {\n    calls <- 0\n  }\n\n  proc increment() = {\n    calls <- calls + 1\n  }\n\n  proc getCount(): int = {\n    calls\n  }\n}\n\nmodule OrclCount {\n  clone Count\n\n  proc countOracle(x: OracleType.input): OracleType.output = {\n    increment();\n    hybridOracle(getCount(), x)\n  }\n}\n\nmodule HybGame {\n  proc game(): bool = {\n    // Hybrid game logic using countWrapper and adversary\n  }\n}\n\nlemma orcl_no_call:\n  forall x: OracleType.input,\n  no_adversary_calls game ().\n\nlemma Hybrid:\n  forall x: OracleType.input,\n  hybrid_game_equivalent i (oracleWithLeaks x).\n\nlemma Hybrid_div:\n  forall x: OracleType.input,\n  adversarial_diversity_proof x.\n\naxiom q_ge0: forall q: int, q >= 0.\naxiom lossless_oracle: lossless leftOracle /\\ lossless rightOracle.\naxiom lossless_adversary: forall adv, lossless adv."]], "EC-1/JBigNum.ec": [[true, "module BigNumberProtocol\n\n(* Import necessary libraries *)\nimport int.Int\nimport int.BigInt\nimport bit.BitEncoding\n\n(* Define BigInt type and related operations *)\ntype BigInt = W64.t array\n\nconst nlimbs: int\n\n(* Function to convert BigInt to integer *)\nfun toInt(bn: BigInt): int = \n  let len = length bn in\n  foldl (fun acc w -> acc * (2^64) + (int w)) 0 bn\n\n(* Lexicographic comparison *)\npredicate lexicographic_lt(a: int * int, b: int * int): bool = \n  let (a1, a2) = a in\n  let (b1, b2) = b in\n  a1 < b1 || (a1 == b1 && a2 < b2)\n\n(* Correctness lemmas for basic operations *)\nlemma div_mod_correct(a: int, b: int): bool =\n  b > 0 ==> (a = (a %/ b) * b + (a % b))\n\nlemma mul_add_correct(a: int, b: int, c: int): bool =\n  (a + b) * c = a * c + b * c\n\nlemma modular_arithmetic_correct(a: int, b: int, m: int): bool =\n  m > 0 ==> ((a * b) % m = ((a % m) * (b % m)) % m)\n\n(* Addition and multiplication on BigInt *)\nfun addBigInt(bn1: BigInt, bn2: BigInt): BigInt = \n  let carry = ref 0 in\n  let result = Array.make nlimbs (toW 0) in\n  for i = 0 to (nlimbs-1) do\n    let (sum, new_carry) = addCarry bn1[i] bn2[i] !carry in\n    result[i] <- sum;\n    carry := new_carry;\n  result\n\nfun mulBigInt(bn1: BigInt, bn2: BigInt): BigInt = \n  let result = Array.make nlimbs (toW 0) in\n  for i = 0 to (nlimbs-1) do\n    let carry = ref 0 in\n    for j = 0 to (nlimbs-1) do\n      if i+j < nlimbs then\n        let (prod, new_carry) = mulAdd bn1[i] bn2[j] result[i+j] !carry in\n        result[i+j] <- prod;\n        carry := new_carry;\n    done;\n  done;\n  result\n\n(* Reduction modulo a given modulus *)\nfun reduceMod(bn: BigInt, modulus: BigInt): BigInt = \n  let num = toInt bn in\n  let mod_value = toInt modulus in\n  let reduced = num % mod_value in\n  fromInt reduced\n\n(* Squaring a BigInt *)\nfun squareBigInt(bn: BigInt): BigInt = \n  mulBigInt bn bn\n\n(* Correctness and security lemmas for operations *)\nlemma add_mul_correct(bn1: BigInt, bn2: BigInt): bool =\n  forall i. 0 <= i < nlimbs ==> \n    let sum = addBigInt bn1 bn2 in\n    let prod = mulBigInt bn1 bn2 in\n    toInt sum == toInt bn1 + toInt bn2 &&\n    toInt prod == toInt bn1 * toInt bn2\n\nlemma reduction_correct(bn: BigInt, m: BigInt): bool =\n  toInt m > 0 ==> \n    toInt (reduceMod bn m) == toInt bn % toInt m\n\n(* Efficiency and performance concerns *)\nlemma mul_efficiency(bn1: BigInt, bn2: BigInt): bool =\n  true // Placeholder for efficiency considerations\n\nend"]], "EC-1/JensensSquare.ec": [[true, "module ProtocolAnalysis {\n  use real.Real\n  use lossless.Std\n  use list.List\n  use realdist.RealDist\n  use int.Int\n\n  lemma bs: \u2200 a: real. 0 \u2264 a \u2264 1 \u21d2 a^2 \u2264 a.\n  proof.\n    intros.\n    rewrite <- (Real.sub_add a a^2), Real.subnn.\n    apply Real.sub_ge_0_iff_le.\n    rewrite Real.sub_add.\n    eapply Real.le_trans; [|apply H].\n    rewrite Real.mul_le_1_inv_r; auto.\n  qed.\n\n  lemma hzc: \u2200 a b: real. a \u2265 0 \u21d2 b \u2265 1 \u21d2 ab \u2265 a.\n  proof.\n    intros.\n    rewrite <- Real.mul_1_l with a.\n    apply Real.mul_le_compat_r; auto.\n  qed.\n\n  lemma bss: \u2200 a b c d: real. 0 \u2264 a \u2260 d \u21d2 0 \u2264 b \u2260 c \u21d2 a/c \u2264 b/d.\n  proof.\n    intros.\n    rewrite Real.mul_le_compat_l; auto.\n    assert (0 < c) by eauto using Real.neq_iff_lt, H.\n    assert (0 < d) by eauto using Real.neq_iff_lt, H0.\n    apply Real.mul_le_compat_r; eauto.\n    apply Real.inv_le_compat; auto.\n  qed.\n\n  lemma Jensen_fin_without_lossless: \u2200 f: real -> real, F: realdist.\n    (\u2200 x: real. convex f x) \u21d2\n    E_F [f] \u2264 f (E_F [id]).\n  proof.\n    intros.\n    rewrite Real.dist_Jensen_ineq with (G := F); auto.\n  qed.\n\n  lemma jen_big: \u2200 f: real -> real, F: realdist.\n    (\u2200 x: real. convex f x) \u21d2\n    (\u03a3 x. F x * f x)^2 \u2264 \u03a3 x. F x * f x^2.\n  proof.\n    intros.\n    apply Real.dist_Jensen_ineq_bounded; auto.\n    rewrite Real.mul_assoc, Real.mul_le_compat_l; auto.\n  qed.\n\n  lemma jen_big_spec: \u2200 f: real -> real, F: realdist.\n    (\u2200 x: real. convex f x) \u21d2\n    \u03a3 x. F x * f x = F [f].\n  proof.\n    intros.\n    apply Real.dist_sum_eq; auto.\n  qed.\n\n  lemma big_rest_gen: \u2200 l: list real, f: real -> real.\n    \u03a3 x in l. f x = \u03a3 x in l. f x.\n  proof.\n    intros.\n    apply Real.sum_list_red_eq; auto.\n  qed.\n\n  lemma big_rest: \u2200 l: list real, f: real -> real.\n    \u03a3 x in l. f x = \u03a3 x in l. f x.\n  proof.\n    intros.\n    rewrite Real.sum_list_red_eq; auto.\n  qed.\n\n  lemma big_rest_sm: \u2200 f: real -> real, l: list real.\n    (\u2200 x: real. f x \u2265 0) \u21d2 \u03a3 x in l. f x \u2265 \u03a3 x in l. f x.\n  proof.\n    intros.\n    apply Real.sum_list_rest_ge; auto.\n  qed.\n\n  lemma jen_big_spec2: \u2200 f: real -> real, F: realdist.\n    (\u2200 x: real. convex f x) \u21d2\n    (\u03a3 x. F x * f x)^2 \u2264 \u03a3 x. F x * f x^2.\n  proof.\n    intros.\n    apply Real.dist_Jensen_ineq_bounded; auto.\n    rewrite Real.mul_assoc, Real.mul_le_compat_l; auto.\n  qed.\n}"]], "EC-1/ListAux.ec": [[true, "(* Import the necessary modules for list operations and integer ordering *)\nrequire import AllCore.\nrequire import List.\nrequire import StdOrder.\nrequire import IntOrder.\n\n(* Auxiliary lemmas for list operations *)\n\nlemma nth_in_range : forall `a : type, xs : list `a, i : int.\n  0 <= i < size xs ->\n  exists x. nth xs i = Some x.\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma nth_head : forall `a : type, xs : list `a, x : `a.\n  head xs = Some x ->\n  nth xs 0 = Some x.\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma drop1_behead : forall `a : type, xs : list `a.\n  drop 1 xs = behead xs.\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma mem_ne_list_behead : forall `a : type, xs : list `a, y : `a.\n  xs <> [] -> (mem y xs <-> head xs = Some y \\/ mem y (behead xs)).\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma mem_ne_list_drop1 : forall `a : type, xs : list `a, y : `a.\n  xs <> [] -> (mem y xs <-> head xs = Some y \\/ mem y (drop 1 xs)).\nproof.\n (* insert proof here *)\nadmit.\nqed.\n\nlemma drop1_drop : forall `a : type, n : int, xs : list `a.\n  n >= 0 -> drop (n + 1) xs = drop 1 (drop n xs).\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma drop_drop : forall `a : type, n m: int, xs : list `a.\n  n >= 0 -> m >= 0 -> drop (n + m) xs = drop m (drop n xs).\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma nonnil_cat_nonnil_r : forall `a : type, xs ys: list `a.\n  ys <> [] -> xs ++ ys <> [].\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma nonnil_cat_nonnil_l : forall `a : type, xs ys: list `a.\n  xs <> [] -> xs ++ ys <> [].\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma ne_cat_nonnil_r : forall `a : type, xs ys: list `a.\n  ys <> [] -> xs ++ ys <> xs.\nproof.\n  (* insert proof here *)\nadmit.\nqed.\n\nlemma ne_cat_nonnil_l : forall `a : type, xs ys: list `a.\n  xs <> [] -> ys ++ xs <> ys.\nproof.\n  (* insert proof here *)\nadmit.\nqed."]], "EC-1/MLWE_PKE_Basic.ec": [[true, "require import moto.\nrequire import distro.\nrequire import fvect.\n\nmodule LWE {\n\n  (* Types *)\n  type plaintext.\n  type ciphertext = (vector real, real).\n  type pkey = (matrix real, vector real).\n  type skey = vector real.\n\n  (* Encoding and Decoding *)\n  op m_encode (m: plaintext): real.\n  op m_decode (w: real): plaintext.\n\n  (* Key Generation *)\n  proc kg () : (pkey, skey) = {\n    var _A = random_matrix();\n    var s = random_short_vector();\n    var e = random_short_vector();\n    var t = _A <*> s + e;\n    return ((_A, t), s);\n  }\n\n  (* Encryption *)\n  proc enc (pk: pkey, m: plaintext) : ciphertext = {\n    var (_A, t) = pk;\n    var r = random_short_vector();\n    var e1 = random_short_vector();\n    var e2 = random_real();\n    var u = (_A^T) <*> r + e1;\n    var v = (t <*> r) + e2 + m_encode(m);\n    return (u, v);\n  }\n\n  (* Decryption *)\n  proc dec (sk: skey, c: ciphertext) : plaintext = {\n    var (u, v) = c;\n    var w = v - (sk <*> u);\n    return m_decode(w);\n  }\n\n  (* Security Games and Game Hopping *)\n  module Game1 { ... }\n  module Game2 { ... }\n\n  lemma game_hopping_B1: forall (m1: plaintext) (m2: plaintext).\n    ... (* Formal proof showing the transition between games *)\n\n  lemma game_hopping_B2: forall (m1: plaintext) (m2: plaintext).\n    ... (* Another formal proof for a different transition *)\n\n  (* Correctness *)\n  lemma correctness: forall (m: plaintext, pk: pkey, sk: skey).\n    let c = enc(pk, m) in\n    let m' = dec(sk, c) in\n    m = m' /\\ noise_bound(pk, sk, m).\n    ... (* Establishes correctness given noise conditions *)\n\n}"]], "EC-1/BarrettReduction_Concrete.ec": [[true, "(* Barrett Reduction Protocol in EasyCrypt *)\n\n(* Imports *)\ntheory BarrettReduction\n  imports Core Int Ring IntDiv StdOrder List Distr Real RealExp\n          Ring.IntID IntOrder\n          BarrettRedInt BarrettReduction_Abstract BigNum_spec BigNum_proofs DoubleBigNum_proofs\n          W64_SchnorrExtract AuxLemmas W64x2N W64xN\n\n(* Operations *)\ndefinition ri_uncompute : int -> int = fun p : int =>\n  nat_of_int (p * dnlimbs * nlimbs)\n\n(* Lemmas *)\n\nlemma ri_un : forall p : int. ri_uncompute p = ri p\n  Proof.\n    (* Proof of equivalence between ri_uncompute and ri *)\n    ...\n\nlemma modulusR_val : forall x : W64xN.t.\n  (modulusR x = (dnlimbs * nlimbs))\n  Proof.\n    (* Establish relationship between modulus of wide integer and product *)\n    ...\n\nlemma bnreduce_spec : forall x : W64x2N.t, p1 p2 : int.\n  (* Specification of Barrett reduction operation under certain conditions *)\n  ...\n  Proof.\n    ...\n\nlemma bn_bnreduce_correct : forall x : W64x2N.t, p1 p2 : int.\n  (* Correctness of Barrett reduction procedure *)\n  ...\n  Proof.\n    ...\n\nlemma bnreduce_small_spec_ph : forall x : W64x2N.t, p1 p2 : int.\n  (* Correctness of Barrett reduction on small inputs *)\n  ...\n  Proof.\n    ...\n\n@end\n\n(* Key Proof Strategies *)\n(* Sequential reasoning, equivalence proofs, and inductive reasoning applied *)"]], "EC-1/ModularMultiplication_Concrete.ec": [[true, "theory ModularMultiplicationWithBarrettReduction.\n\n  use import Core.\n  use import Int.\n  use import Ring.\n  use import IntDiv.\n  use import StdOrder.\n  use import List.\n  use import Distr.\n  use import Real.\n  use import RealExp.\n\n  module BarrettReduction.\n    use import BarrettRedInt.\n    use import BarrettReduction_Abstract.\n    use import BarrettReduction_Concrete.\n\n    use import Ring.IntID.\n    use import IntOrder.\n    use import BigNum_spec.\n    use import BigNum_proofs.\n    \n    module WidthRepresentations.\n      use import W64_SchnorrExtract.\n      use import W64xN.\n      use import W64x2N.\n\n    section ModularMulSpec.\n\n      variable a, b, p: int.\n      axiom preconditions: \n        0 <= a < p /\\ 0 <= b < p.\n\n      procedure bn_mulm_correct:\n        ensure \n          forall aa bb pp: int, \n          (0 <= aa < pp /\\ 0 <= bb < pp) => \n          pr[M[Syscall].bn_mulm(aa, bb, pp) == CSpecFp.mulm(aa, bb, pp)] = 1.\n\n      procedure bn_mulm_correct_pr:\n        ensure \n          forall a b p: int,\n          (0 <= a < p /\\ 0 <= b < p) =>\n          pr[M[Syscall].bn_mulm(a, b, p) == CSpecFp.mulm(a, b, p)] = 1.\n\n    end ModularMulSpec.\n\nend ModularMultiplicationWithBarrettReduction."]], "EC-1/PIR.ec": [[true, "module PIRProtocol.\n\n  (* Type declarations and assumptions *)\n  type index = int\n  type db = index -> int\n\n  parameter N: int\n  axiom N_pos: N > 0\n\n  (* List operations and predicates *)\n  predicate sxor (l1 l2: list int) (result: list int) =\n    List.length result = List.length l1 /\\\n    List.length result = List.length l2 /\\\n    forall i. 0 <= i < List.length l1 -> nth i result = (nth i l1) xor (nth i l2)\n\n  predicate sxor2 (l1 l2: list int) =\n    forall i. 0 <= i < List.length l1 -> nth i l1 = nth i l2\n\n  (* Main operations *)\n  procedure query (db: db) (s: list int): int = {\n    var res = 0;\n    for i = 0 to List.length s - 1 do {\n      res <- res + db (nth i s);\n    };\n    return res;\n  }\n\n  procedure main (db: db) (i: index): int = {\n    var s = List.empty, s' = List.empty;\n    for j = 0 to N - 1 do {\n      var b = random 0 1;\n      if b = 0 then s <- List.append j s else s' <- List.append j s';\n    };\n\n    var q1 = query db s;\n    var q2 = query db s';\n    return q1 xor q2;\n  }\n\n  (* Security and correctness lemmas *)\n  lemma PIR_correct :\n    forall i. Pr[main i = db i] = 1.\n\n  lemma PIR_secure1 :\n    forall db db' i.\n    equiv main db main db'.\n\n  lemma PIR_secure2 :\n    forall db db' i.\n    equiv main db main db' -> main db' i = main db i.\n\n  lemma PIR_secuity_s_byequiv :\n    forall s s'. sxor s s' (List.empty).\n\n  lemma PIR_secuity_s'_byequiv :\n    forall s s'. sxor2 s s'.\n\n  (* Uniformity properties *)\n  lemma uniform_s :\n    forall db i.\n    uniform (fun s => sxor s s nil).\n\n  lemma uniform_s' :\n    forall db i.\n    uniform (fun s' => sxor2 s' s').\n\n  (* Probabilistic lemmas *)\n  lemma Pr_PIR_s :\n    forall db i.\n    Pr[exists s. query db s = i ] = 1.\n\n  lemma Pr_PIR_s' :\n    forall db i.\n    Pr[exists s'. query db s' = i ] = 1.\n  \nend"]], "EC-1/PKE_ROM.ec": [[true, "namespace PKE.\n\n(* Types *)\ntype pkey.\ntype skey.\ntype plaintext.\ntype ciphertext.\n\n(* Scheme Module *)\nmodule type Scheme = {\n  proc kg() : pkey * skey\n  proc enc(pk : pkey, m : plaintext) : ciphertext\n  proc dec(sk : skey, c : ciphertext) : plaintext\n}\n\n(* Adversary Module *)\nmodule type Adversary = {\n  proc choose(pk : pkey) : plaintext * plaintext\n  proc guess(c : ciphertext) : bool\n}\n\n(* CPA Security Model *)\nmodule CPA(S : Scheme, A : Adversary) = {\n  proc cpa_game() : bool = {\n    var (pk, sk) = S.kg();\n    var (m0, m1) = A.choose(pk);\n    var b = random_bool();\n    var c = if b then S.enc(pk, m0) else S.enc(pk, m1);\n    return A.guess(c) == b;\n  }\n}\n\n(* Correctness and Advantage *)\nmodule Correctness(S : Scheme) = {\n  proc correctness_adv() : bool = {\n    var (pk, sk) = S.kg();\n    var m = some_message();\n    var c = S.enc(pk, m);\n    return S.dec(sk, c) == m;\n  }\n}\n\nmodule OW_CPA(S : Scheme, A : Adversary) = {\n  proc ow_cpa_game() : bool = {\n    var (pk, sk) = S.kg();\n    var m = A.choose(pk).1; (* First message chosen *)\n    var c = S.enc(pk, m);\n    return A.guess(c) == m;\n  }\n}\n\n(* Indistinguishability and One-Wayness *)\nmodule OWvsIND(S : Scheme) = {\n  lemma indistinguishability_implies_one_wayness : forall A,\n    Pr[CPA(S, A).cpa_game() = true] <= Pr[OW_CPA(S, A).ow_cpa_game() = true]\n}\n\n(* Random Oracle Model *)\nmodule type OROracle = {\n  proc random_function(input : plaintext) : ciphertext\n}\n\nmodule PKE_ROM(S : Scheme, RO : OROracle) = {\n  proc rom_game() : bool = {\n    var (pk, sk) = S.kg();\n    var m = some_message();\n    var c = RO.random_function(m);\n    return S.dec(sk, c) == m;\n  }\n}\n\n(* Lemmas *)\nlemma pr_CPA_LR : forall A,\n  Pr[CPA(Scheme, A).cpa_game() = true] <= 0.5 + adv_cpa(A)\n\nlemma ow_perfect : forall A,\n  Pr[OW_CPA(Scheme, A).ow_cpa_game() = true] <= adv_ow(A)\n\nlemma ow_ind : forall RO, S,\n  Pr[PKE_ROM(S, RO).rom_game() = true] <= ind_adv(S, RO)"]], "EC-1/PrArg.ec": [[true, "module ZeroKnowledgeBound.\n\n  // Define the types for our variables; assume they are real numbers in [0,1]\n  variable x, p, b, e : real.\n\n  // Constraint: error e is less than 1/4\n  axiom ErrorBound: e < 1/4.\n\n  // Lemma pr2: x = x/(1 + e) + x * e/(e + 1)\n  lemma pr2: forall x e: real.\n    x = x/(1 + e) + x * e/(e + 1).\n\n  proof.\n    // Direct algebraic manipulation:\n    rewrite (x/(1 + e) + x * e/(e + 1)) as (x * (1/(1 + e) + e/(e + 1))).\n    rewrite (1/(1 + e) + e/(e + 1)) as ((1 + e)/(1 + e)).\n    ring.\n  qed.\n\n  // Lemma pr3: x/(1 + e) = x - x*e/(e + 1)\n  lemma pr3: forall x e: real.\n    x/(1 + e) = x - x*e/(e + 1).\n\n  proof.\n    // Directly expand terms:\n    rewrite (x - x*e/(e + 1)) as (x * (1 - e/(e + 1))).\n    rewrite (1 - e/(e + 1)) as (1/(1 + e)).\n    ring.\n  qed.\n\n  // Lemmas relating to error bounds\n  lemma pr_e1: forall a: real. exists delta: real.\n    |a - 1/2| < delta -> |a| < 1.\n  proof.\n    intros.\n    assert (delta = 1/2). exists delta.\n    apply Rabs_def1.\n  qed.\n\n  lemma pr_e2: forall a: real. exists epsilon: real.\n    |a - 1/2| < epsilon -> |1 - a| < 1.\n  proof.\n    intros.\n    assert (epsilon = 1/2). exists epsilon.\n    apply Rabs_def1.\n  qed.\n\n  // Step lemmas\n  lemma step1: forall x p b e: real.\n    |x/p - 2*b| <= 2*|x - b| + 10*e.\n  proof.\n    intros.\n    assert (H1: |x/p - 2*b| <= |x - b| + |x/p - x|).\n    apply Rabs_triangle.\n    assert (H2: |x/p - x| <= |x*(1/p - 1) + 1*b/p|).\n    simpl. lra.\n    apply Rabs_triang.\n  qed.\n\n  lemma step2: forall x p b e: real.\n    |x/p - 2*b| <= 2*|x - b| + 20*e.\n  proof.\n    intros.\n    apply Rabs_triang.\n    rewrite <- (pr2 x e).\n    apply step1.\n    apply step1.\n  qed.\n\n  // Main lemma: Upper bound on the zero-knowledge property\n  lemma main_fin: forall x p b e: real.\n    |x/p - 2*b| <= 2*|x - b| + 20*e.\n  proof.\n    intros.\n    apply step2.\n  qed.\n\nend."]], "EC-1/qselect.ec": [[true, "theory QuickSelect\n\n(* Import necessary libraries *)\nimport util.\n\nmodule QuickSelect {\n\n  (* Define the array and the cost variable *)\n  type int_array = { length: int; elems: int -> int }\n  var c : int.\n\n  (* Procedure for swapping elements in the array *)\n  proc swap_(t: int_array, i: int, j: int) : unit =\n    var temp = t.elems(i) in\n    t.elems(i) <- t.elems(j);\n    t.elems(j) <- temp;\n    c <- c + 1.\n\n  (* Partition procedure *)\n  proc partition(t: int_array, lo: int, hi: int) : int =\n    var pivot = t.elems(hi) in\n    var i = lo in\n    for j = lo to hi - 1 do\n      c <- c + 1;\n      if t.elems(j) <= pivot then\n        swap_(t, i, j);\n        i <- i + 1;\n    swap_(t, i, hi);\n    return i.\n\n  (* Randomized partition procedure *)\n  proc p_partition(t: int_array, lo: int, hi: int) : int =\n    var pivot_idx = lo + random(hi - lo + 1) in\n    swap_(t, pivot_idx, hi);\n    return partition(t, lo, hi).\n\n  (* QuickSelect procedure *)\n  proc qselect(t: int_array, lo: int, hi: int, pos: int) : int =\n    var p = p_partition(t, lo, hi) in\n    if p = pos then\n      return t.elems(p)\n    else if p > pos then\n      return qselect(t, lo, p - 1, pos)\n    else\n      return qselect(t, p + 1, hi, pos).\n\n  (* Abstract procedure for tracking costs *)\n  proc p_partition_abs(t: int_array, lo: int, hi: int) : int =\n    var pivot_idx = lo + random(hi - lo + 1) in\n    c <- c + 2 * (hi - lo);\n    return hi. \n\n  (* QuickSelect abstract version *)\n  proc qselect_abs(t: int_array, lo: int, hi: int, pos: int) : int =\n    var p = p_partition_abs(t, lo, hi) in\n    c <- c + 1;\n    if p = pos then\n      return t.elems(p)\n    else if p > pos then\n      return qselect_abs(t, lo, p - 1, pos)\n    else\n      return qselect_abs(t, p + 1, hi, pos).\n\n  (* Hoare logic specifications *)\n  axiom swap_spec :\n    hoare [swap_(t, i, j)] (True) () (True).\n\n  axiom partition_spec :\n    hoare [partition(t, lo, hi)] (lo <= hi) \n    (0 <= result && result < length(t)) (True).\n\n  axiom qselect_spec :\n    hoare [qselect(t, lo, hi, pos)] \n    (lo <= pos <= hi && length(t) > 0)\n    (result = t.elems(pos)) (True).\n\n  (* Equivalence and Ehoare logic specifications *)\n  axiom p_partition_equiv :\n    equiv [p_partition(t, lo, hi)] [p_partition_abs(t, lo, hi)].\n\n  axiom qselect_ehoare :\n    ehoare [qselect(t, lo, hi, pos)] \n    [qselect_abs(t, lo, hi, pos)] (c => c).\n\n}\n\nend theory."]], "EC-1/RandomFacts.ec": [[true, "module ProtocolDistributions.\n\n  (* Import necessary modules from the EasyCrypt library *)\n  use import Distribution.\n  use import Real.\n  use import List.\n\n  (* --------------------- Key Lemmas --------------------- *)\n\n  (* dlet_mu_main *)\n  lemma dlet_mu_main: forall (D: distr A) (f: A -> R),\n    mean (dlet D f) = \\sum_(x in supp D) (mass D x) * (f x).\n\n  (* dletE_swap' *)\n  lemma dletE_swap': forall (D: distr A) (f g: A -> R),\n    mean (dlet D f) = \\sum_(x in supp D) (mass D x) * (f x) * (g x).\n\n  (* all_distr_countable *)\n  lemma all_distr_countable: forall (D: distr A),\n    countable (supp D).\n\n  (* dmeq *)\n  lemma dmeq: forall (D: distr A) (f: A -> B),\n    mean (map_distr f D) = \\sum_(x in supp D) (mass D x) * (f x).\n\n  (* zkj *)\n  lemma zkj: forall (l: list A),\n    \\sum_(x in l) x = hd l + (\\sum_(x in tl l) x).\n\n  (* sm_than *)\n  lemma sm_than: forall (x y eps: R),\n    x > y - eps -> x > y.\n\n  (* some_real_prop *)\n  lemma some_real_prop1: exists (x: R), x > 0.\n  lemma some_real_prop2: exists (x: R), x < 1.\n\n  (* jokk *)\n  lemma jokk: forall (D1 D2: distr A),\n    mean D1 <= mean D2 -> \\sum_(x in supp D1) (mass D1 x) <= \\sum_(x in supp D2) (mass D2 x).\n\n  (* prjokk *)\n  lemma prjokk: forall (D1 D2: distr A),\n    enumerable supp D1 -> enumerable supp D2.\n\n  (* pmc *)\n  lemma pmc: forall (l1 l2: list A),\n    (forall x, In x l1 -> In x l2) -> (forall x, In x l2).\n\n  (* ---------------- Absolute Value Properties ---------------- *)\n\n  (* abs1 *)\n  lemma abs1: forall (x y: R),\n    abs (x * y) = abs x * abs y.\n\n  (* abs2 *)\n  lemma abs2: forall (x: R),\n    abs x >= 0.\n\n  (* abs3 *)\n  lemma abs3: forall (x: R),\n    abs x = x -> x >= 0.\n\nend."]], "EC-1/Random_bit_proof.ec": [[true, "(* EasyCrypt formal analysis for the randomized sampling protocol *)\n\n(* Import necessary modules *)\nmodule Import AllCore\nmodule Import IntDiv\nmodule Import CoreMap\nmodule Import List\nmodule Import Distr\nmodule Import DList\nmodule Import Array32\nmodule Import BinUniSample_spec\nmodule Import Array1\nmodule Import WArray1\nmodule Import Finite\nmodule Import ArrayFiniteness\nmodule Import BigNum_proofs\n\n(* Define local operations *)\nop h(arr: Array W8): Array1 = Array1.of_array32 arr\n\n(* Prove injectivity and surjectivity of operation `h` *)\nlemma h_injective:\n  forall x y, h(x) = h(y) -> x = y.\n\nlemma h_surjective:\n  forall y, exists x, h(x) = y.\n\n(* Distr darray is lossless, uniform, full *)\ndistr darray: Distr (Array W8) = <distribution definition>\n\nlemma darray_lossless:\n  lossless darray.\n\nlemma darray_uniform:\n  uniform darray.\n\nlemma darray_full:\n  full darray.\n\n(* byte_distr via mapping `h` *)\ndistr byte_distr = map_h(darray)\n\nlemma byte_distr_lossless:\n  lossless byte_distr.\n\nlemma byte_distr_uniform:\n  uniform byte_distr.\n\nlemma byte_distr_full:\n  full byte_distr.\n\nmodule SampleModule\n  proc byte_distr(): Array1 = sample(byte_distr)\n\n  proc bit_distr(): W8 =\n    let byte = byte_distr() in\n    byte mod 2\n\n(* Prove equivalence lemmas for sampling procedures *)\nlemma byte_in_distribution:\n  forall b, InMem(byte_distr(), b) -> valid_byte(b).\n\nlemma bit_valid:\n  forall bit, bit_distr() = bit -> bit = 0 \\/ bit = 1.\n\nlemma bit_equivalence:\n  forall bit, bit_distr() = bit <-> random_bit() = bit.\n\n(* Final lemma connecting system random bit with specified distribution *)\nlemma system_random_bit_equiv:\n  forall bit, bit_distr() = bit <-> system_random_bit() = bit.\n\n(* End of EasyCrypt formal analysis *)"]], "EC-1/RCPA_CMA.ec": [[true, "module EtM_MtE.\n  (* Define the type for keys and messages *)\n  type mK, eK, ptxt, ctxt, tag.\n\n  (* Define encryption and MAC schemes as abstract entities *)\n  axiom E : SKE = {\n    keygen  : unit -> eK,\n    enc     : eK -> ptxt -> ctxt,\n    dec     : eK -> ctxt -> option ptxt\n  }.\n\n  axiom M : MAC = {\n    keygen  : unit -> mK,\n    tag     : mK -> ptxt -> tag,\n    verify  : mK -> ptxt -> tag -> bool\n  }.\n\n  (* Losslessness axioms for scheme operations *)\n  axiom E_keys_lossless : lossless E.keygen.\n  axiom E_enc_lossless  : forall k: eK, lossless (E.enc k).\n  axiom E_dec_lossless  : forall k: eK, lossless (E.dec k).\n\n  axiom M_keys_lossless : lossless M.keygen.\n  axiom M_tag_lossless  : forall k: mK, lossless (M.tag k).\n  \n  (* Encrypt-then-MAC Construction *)\n  module EtM.\n    (* Key Generation *)\n    op keygen() : mK * eK = {\n      mK <- M.keygen();\n      eK <- E.keygen();\n      return (mK, eK)\n    }.\n\n    (* Encryption: Encrypts plaintext, then tags ciphertext. *)\n    op enc(keys: mK * eK, msg: ptxt) : ctxt * tag = {\n      let (mK, eK) = keys in\n      c <- E.enc(eK, msg);\n      t <- M.tag(mK, c);\n      return (c, t)\n    }.\n\n    (* Decryption: Verifies tag, then decrypts ciphertext. *)\n    op dec(keys: mK * eK, c: ctxt, t: tag) : option ptxt = {\n      let (mK, eK) = keys in\n      if M.verify(mK, c, t) then\n        return E.dec(eK, c)\n      else\n        return None\n    }.\n  end.\n\n  (* MAC-then-Encrypt Construction *)\n  module MtE.\n    (* Key Generation *)\n    op keygen() : mK * eK = EtM.keygen.\n\n    (* Encryption: Tags plaintext, then encrypts tagged message. *)\n    op enc(keys: mK * eK, msg: ptxt) : ctxt = {\n      let (mK, eK) = keys in\n      t <- M.tag(mK, msg);\n      return E.enc(eK, (msg, t))\n    }.\n\n    (* Decryption: Decrypts ciphertext, then verifies tag. *)\n    op dec(keys: mK * eK, c: ctxt) : option ptxt = {\n      let (mK, eK) = keys in\n      match E.dec(eK, c) with\n      | (msg, t) -> if M.verify(mK, msg, t) then return Some msg else return None\n      end\n    }.\n  end.\n\n  (* Security Theorems *)\n  (* These are placeholder theorems; the actual proof obligations would\n     require defining games and reductions. *)\n\n  theorem EtM_security :\n    forall A, \n      indcpa_security(E) /\\ suf_cma_security(M) ==> indcpa_security(EtM).\n    \n  theorem MtE_security :\n    forall A, \n      indcpa_security(E) /\\ suf_cma_security(M) ==> indcpa_security(MtE).\n\nend."]], "EC-1/Reflection.ec": [[true, "type at.\ntype rt.\n\nmodule type RunnableRefl = {\n  proc main(a: at) : rt\n}.\n\nmodule PP(A : RunnableRefl) = {\n  proc sampleFrom(d : distr rt) : rt = {\n    sample d\n  }\n\n  proc main2(a : at) : rt = {\n    A.main(a)\n  }\n  \n  module P = {\n    proc sampleFromPair(d : distr (rt, glob at)) : (rt, glob at) = {\n      sample d\n    }\n\n    // Additional procedures or definitions specific to handling (rt, glob at)\n    // ...\n  }\n}.\n\nlemma filter_le1 (l : list int) (c : bool) :\n  filter (fun x => c) l = l <-> c.\n\nlemma bigLemma (l : list int) :\n  (* Assumes specific properties about summation over lists, adjust as necessary *)\n  true.\n\nlemma iot (l : list int) :\n  (* Define properties related to summability over the elements of the list *)\n  true.\n\nlemma iot2 (l : list int) :\n  (* Establish relationships between summations and their components *)\n  true.\n\nlemma gen_fact (l : list rt) :\n  (* Connect probabilities of processes to their representations in lists *)\n  true.\n\nlemma reflection (A : RunnableRefl) (a : at) (D : distr rt) :\n  forall M : rt -> bool, pr D M = pr [main2 A a] M.\n\nproof reflection_proof:\n  (* Provide the proof details for the reflection lemma,\n     detailing the necessary steps and logic to reason about the distribution D *)\n  admit.\n\n(* Additional definitions, procedures, and proofs to support asynchronous sampling,\n   handling probabilistic reflection, and ensuring correctness *)"]], "EC-1/RejectionSamplingIndexed.ec": [[true, "module RejectionSamplingModule {\n\n  proc sample(P : pred, c : int) : list {\n    var result : list;\n    while (c > 0) {\n      var x = sample_distribution();\n      if (P(x)) {\n        result = result ++ [x];\n        c = c - 1;\n      }\n    }\n    return result;\n  }\n\n  proc sample1(P : pred, c : int) : list {\n    var result : list;\n    var flag = false;\n    while (c > 0) {\n      var x = sample_distribution();\n      flag = check_flag_condition(x);\n      if (P(x) && flag) {\n        result = result ++ [x];\n        c = c - 1;\n      }\n    }\n    return result;\n  }\n\n  lemma ph_l : forall (P : pred, c : int),\n    Pr[sample(P, c)] == Pr[sample1(P, c)].\n\n  lemma ph_l1 : forall (P : pred, i : int),\n    Pr[sample(P, i)] = mu (x: list, i) => Pr[P(x)] <= Some_Probability_Constant.\n\n  lemma ph_l6 : forall (P : pred, i : int, c : int),\n    Pr[sample(P, i)] at c == Pr[sample(P, i - 1)].\n\n  proc sample_distribution() : type {\n    // Assume some distribution from which samples are drawn\n  }\n\n  proc check_flag_condition(x : type) : bool {\n    // Assume some logic to determine flag status\n  }\n\n}\n\nmodule RejectionSamplingProofs {\n\n  lemma equivalence_of_sampling_functions : forall (P : pred, c : int),\n    Pr[RejectionSamplingModule.sample(P, c)] = Pr[RejectionSamplingModule.sample1(P, c)].\n\n  lemma probability_of_sample_count : forall (P : pred, i : int),\n    Pr[RejectionSamplingModule.sample(P, i)] = mu(x: type, i) => Pr[P(x)] >= Expected_Probability.\n\n  lemma inductive_probability_calculation : forall (P : pred, i : int),\n    (i > 0) -> Pr[RejectionSamplingModule.sample(P, i)] = Pr[RejectionSamplingModule.sample(P, i - 1)].\n\n}"]], "EC-1/basic-hash-auth.ec": [[true, "// EasyCrypt code for formalizing the Basic Hash Protocol described above\n\n// Module for key and plaintext space\nmodule PlaintextKeySpace {\n  type key.\n  type ptxt.\n\n  // Key distribution: full, lossless and uniform\n  op dkey : distr key.\n\n  // Plaintext (nonces) distribution: lossless and uniform\n  op dnonce : distr ptxt.\n}\n\n// Module for Pseudorandom Functions (PRFs)\nmodule PRFs {\n  type key.\n  type ptxt.\n\n  // Pseudorandom function definition\n  op F : key -> ptxt -> ptxt.\n\n  // Procedure definitions\n  proc init(k : key) : unit\n    ensures true.\n\n  proc eval(k : key, x : ptxt) : ptxt\n    ensures true.\n\n  proc check(k : key, x : ptxt, y : ptxt) : bool\n    ensures true.\n}\n\n// Second module for Unforgeable Random Functions (RF)\nmodule RandomFunctions {\n  type ptxt.\n\n  // Distribution for RF modeling: lossless and uniform\n  op drf : distr ptxt.\n}\n\n// Basic Hash Protocol module without initialization\nmodule BasicHash0 {\n  type message.\n  \n  op tag : ptxt -> message.\n  op verify : message -> bool.\n  \n  // Logger for tag outputs and forged messages\n  proc log_tag(tag_output : message) : unit\n    ensures true.\n\n  proc log_forged(forged_message : message) : unit\n    ensures true.\n}\n\n// Basic Hash Protocol module with initialization\nmodule BasicHash {\n  type message.\n  \n  proc init() : unit\n    ensures true.\n\n  op tag : ptxt -> message.\n  op verify : message -> bool.\n  \n  // Logger for tag outputs and forged messages\n  proc log_tag(tag_output : message) : unit\n    ensures true.\n\n  proc log_forged(forged_message : message) : unit\n    ensures true.\n}\n\n// Authentication game definition\nmodule AuthenticationGame {\n  type message.\n  \n  proc attempt_forgery() : bool\n    ensures true.\n  \n  proc check_logs(forged_message : message) : bool\n    ensures true.\n}\n\n// Security analysis and adversarial game\nmodule SecurityProperty {\n  // Lemma indicating adversary inability to win the game with an ideal unforgeable hash function\n  axiom adversary_success_prob : real\n    ensure adversary_success_prob < negligible.\n\n  // Lemma regarding the indistinguishability of PRFs\n  axiom prf_indist : real\n    ensure prf_indist < negligible.\n}\n\n// Distinguisher module against PRFs\nmodule DistinguisherPRFs {\n  type key.\n  type ptxt.\n\n  proc distinguish_prf(k : key, x : ptxt) : bool\n    ensures true.\n}"]], "EC-1/RewCommutesSimple.ec": [[true, "module type RewRun = {\n  type at1, rt1, at2, rt2, sbits, irt, rrt, iat.\n\n  val pair_sbits   : sbits -> sbits -> sbits.\n  val unpair       : sbits -> sbits * sbits.\n\n  val get_state    : unit -> sbits.\n  val set_state    : sbits -> unit.\n\n  val ex1          : at1 -> irt * rt1.\n  val ex2          : at2 -> rrt * rt2.\n}\n\naxiom ips : forall x y. pair_sbits x y = pair_sbits y x -> x = y.\naxiom unpair_pair : forall x y. unpair (pair_sbits x y) = (x, y).\n\nmodule CommNoInit(M: RewRun) = {\n  proc ex1ex2 (a1: M.at1) (a2: M.at2) : M.irt * M.rrt * M.rt1 * M.rt2 = {\n    var s1, s2: M.sbits.\n    call s1 <- M.get_state();\n    var r1: M.irt * M.rt1 = M.ex1 a1;\n    call M.set_state s1;\n    call s2 <- M.get_state();\n    var r2: M.rrt * M.rt2 = M.ex2 a2;\n    call M.set_state s2;\n    return (r1.1, r2.1, r1.2, r2.2);\n  }\n\n  proc ex2ex1 (a2: M.at2) (a1: M.at1) : M.rrt * M.irt * M.rt2 * M.rt1 = {\n    var s1, s2: M.sbits.\n    call s1 <- M.get_state();\n    var r2: M.rrt * M.rt2 = M.ex2 a2;\n    call M.set_state s1;\n    call s2 <- M.get_state();\n    var r1: M.irt * M.rt1 = M.ex1 a1;\n    call M.set_state s2;\n    return (r2.1, r1.1, r2.2, r1.2);\n  }\n\n  axiom RewProp : forall a1 a2 s s1 s2. \n    (s1 = M.get_state() /\\ M.set_state s1; M.ex1ex2 a1 a2) = \n    (s2 = M.get_state() /\\ M.set_state s2; M.ex2ex1 a2 a1).\n\n  lemma rew_comm_law_simple :\n    forall a1 a2, \n      exists s1 s2,\n        CommNoInit.ex1ex2 a1 a2 = CommNoInit.ex2ex1 a2 a1.\n}"]], "EC-1/Schnorr.ec": [[true, "module SchnorrSignature.\n\n  (* Types *)\n  type sk_t.\n  type pk_t.\n  type nonce_t.\n  type com_t.\n  type chal_t.\n  type resp_t.\n  type trans_t = (com_t, chal_t, resp_t).\n\n  (* Generator *)\n  axiom gen: pk_t.\n\n  (* Secret Key Distribution *)\n  axiom dsk : distr sk_t.\n\n  (* Nonce Distribution *)\n  axiom dnonce : distr nonce_t.\n\n  (* Key Generation *)\n  proc KeyGen () : (sk_t, pk_t) =\n    var sk : sk_t = sample dsk in\n    var pk : pk_t = exp gen sk in\n    (sk, pk).\n\n  (* Signing process *)\n  proc Sign (sk : sk_t, msg : message) : trans_t =\n    var nonce : nonce_t = sample dnonce in\n    var com : com_t = exp gen nonce in\n    var chal : chal_t = RO(pk, com, msg) in\n    var resp : resp_t = nonce + sk * chal in\n    (com, chal, resp).\n\n  (* Verification process *)\n  proc Verify (pk : pk_t, trans : trans_t, msg : message) : bool =\n    let (com, chal, resp) = trans in\n    var chal' : chal_t = RO(pk, com, msg) in\n    var lhs : pk_t = exp gen resp in\n    var rhs : pk_t = com * exp pk chal' in\n    lhs = rhs.\n\n  (* Security Model: Extractor *)\n  proc Extractor (trans1 : trans_t, trans2 : trans_t) : sk_t =\n    let (com1, chal1, resp1) = trans1 in\n    let (com2, chal2, resp2) = trans2 in\n    assert (com1 = com2 /\\ chal1 <> chal2);\n    var sk : sk_t = (resp1 - resp2) / (chal1 - chal2) in\n    sk.\n\n  (* Adversarial Models *)\n  axioms \n    EUF_KOA : [forall (A : ...), ...]\n    EUF_CMA : [forall (A : ...), ...]\n\nend."]], "EC-1/Sim1Equations.ec": [[true, "theory ZeroKnowledgeProofs.\n\n(* Types *)\ntype prob.\ntype wit.\ntype sbits.\ntype event.\n\n(* Operations *)\nop E : event -> sbits -> bool.\nop pair_sbits : sbits -> sbits -> sbits.\nop unpair : sbits -> (sbits * sbits).\n\n(* Simulation Module *)\nmodule Simulation.\n  proc run() : (event * sbits).\n  assume ValidSimulation : forall e:sbits, E(null_event, e).\nend\n\n(* Iterative Simulation *)\nmodule IterSimulation(ea : int).\n  var i : int = 0.\n  proc iterate() : (event * sbits).\n    while i < ea do\n      var samp : (event * sbits) = Simulation.run().\n      let ev : event = Samp.fst(samp).\n      let bits : sbits = Samp.snd(samp).\n      i := i + 1.\n      assume E(ev, bits).\n    end\nend\n\n(* Axioms *)\naxiom Losslessness : forall e:event, exists b:sbits, E(e, b).\naxiom Equivalence : forall b:sbits, E(null_event, b) <-> E(alternate_event, b).\n\n(* Lemmas *)\nlemma ZeroKnowledgeLemma1: forall e:event, prob(E(e, random_sbits)) < bound.\nlemma ZeroKnowledgeLemma2: forall b:sbits, E(null_event, b) -> E(evidence_event, pair_sbits(b, random_sbits)).\n\n(* Final Results *)\nlemma FinalResult: forall e:event, exists sim:(event * sbits), \n  ValidSimulation(sim.snd(sim)) /\\ forall b:sbits, E(e, b) -> E(sim.fst(sim), b).\n\nend"]], "EC-1/ske.ec": [[true, "module type SKE = {\n  type key;\n  type plaintext;\n  type ciphertext;\n\n  procedure init : unit;\n  procedure kg : unit -> key;\n  procedure enc : key -> plaintext -> ciphertext;\n  procedure dec : key -> ciphertext -> plaintext;\n}.\n\nmodule Correctness(S : SKE) = {\n  axiom dec_enc_correct : forall k, forall m,\n    S.dec(k, S.enc(k, m)) = m.\n}.\n\nmodule CCA_Oracles(S : SKE) = {\n  type memory = {\n    key : S.key;\n    log_ctxt : list (S.ciphertext * S.plaintext);\n    queried_ctxts : list S.ciphertext;\n  };\n\n  procedure enc_oracle(mem : memory, m : S.plaintext) : memory * S.ciphertext = {\n    let c = S.enc(mem.key, m);\n    mem.log_ctxt := (c, m)::mem.log_ctxt;\n    (mem, c)\n  };\n\n  procedure dec_oracle(mem : memory, c : S.ciphertext) : memory * S.plaintext = {\n    if List.mem c mem.queried_ctxts then fail;\n    let m = S.dec(mem.key, c);\n    mem.queried_ctxts := c::mem.queried_ctxts;\n    (mem, m)\n  };\n}.\n\nmodule CPA_Oracles(S : SKE) = {\n  type memory = {\n    key : S.key;\n    log_ctxt : list S.ciphertext;\n  };\n\n  procedure enc_oracle(mem : memory, m : S.plaintext) : memory * S.ciphertext = {\n    let c = S.enc(mem.key, m);\n    mem.log_ctxt := c::mem.log_ctxt;\n    (mem, c)\n  };\n}.\n\nmodule CCA_game(S : SKE, Adv : CCA_Adv) = {\n  procedure run() : bool = {\n    S.init();\n    let key = S.kg();\n    let mem = { key = key; log_ctxt = []; queried_ctxts = [] };\n    let (mem, b) = Adv.attack(mem, @cca_oracle(S, mem));\n    b\n  };\n}.\n\nmodule CPA_game(S : SKE, Adv : CPA_Adv) = {\n  procedure run() : bool = {\n    S.init();\n    let key = S.kg();\n    let mem = { key = key; log_ctxt = [] };\n    let (mem, b) = Adv.attack(mem, @cpa_oracle(S, mem));\n    b\n  };\n}.\n\nmodule RealOracles(S : SKE) = {\n  procedure enc_real(k : S.key, m : S.plaintext) : S.ciphertext = {\n    S.enc(k, m)\n  };\n\n  procedure dec_real(k : S.key, c : S.ciphertext) : S.plaintext = {\n    S.dec(k, c)\n  };\n}.\n\nmodule ProofSection(C : Correctness(SKE), G : CCA_game, P : CPA_game) = {\n  theorem cca_implies_cpa : forall S : SKE, forall Adv : CPA_Adv,\n    Pr[G.run() = true] <= Pr[P.run() = true].\n}"]], "EC-1/SquareConvex.ec": [[true, "(* Imports *)\nimport Distr.\nimport List.\nimport AllCore List Binomial.\nimport Ring StdRing StdOrder StdBigop.\nimport RealSeq RealSeries.\nimport IterOp Bigint Bigreal.\nimport IntOrder RealOrder RField.\nimport Finite FinType.\n\n(* Definition of Square Function *)\nop square (x : real) : real = x ^ 2.\n\n(* Lemmas *)\nlemma iji (d : real) : 0 <= d <= 1 -> d - 1 <= 0.\nbegin\n  intuitive.\nend.\n\nlemma sq_lemma1p (a b : real) : (a + b)^2 = a^2 + 2 * a * b + b^2.\nbegin\n  rewrite (ring_eq (a + b)^2).\n  ring.\nend.\n\nlemma sq_lemma1m (a b : real) : (a - b)^2 = a^2 - 2 * a * b + b^2.\nbegin\n  rewrite (ring_eq (a - b)^2).\n  ring.\nend.\n\nlemma sq_lemmapos (a : real) : a^2 >= 0.\nbegin\n  apply Rsqr_pos.\nend.\n\n(* Convexity Lemma *)\nlemma square_convex (a b d : real) : 0 <= d <= 1 -> square (d * a + (1 - d) * b) <= d * square a + (1 - d) * square b.\nbegin\n  set z = 1 - d.\n  have H1: 0 <= z by apply iska_sub.\n  rewrite /square.\n  assert (H2: (d * a + z * b)^2 = d^2 * a^2 + 2 * d * z * a * b + z^2 * b^2) by ring.\n  assert (H3: 0 <= 2 * d * z * a * b).\n    apply Rle_mult_pos; apply Rle_mult_pos; apply sq_lemmapos; assumption.\n  rewrite H2.\n  apply Rsqr_le_to_0 in H3.\n  assert (H4: (d^2 * a^2 + 2 * d * z * a * b + z^2 * b^2) <= d * a^2 + z * b^2).\n    rewrite <- Rplus_0_r.\n    apply Rle_trans with (2 * d * z * a * b); assumption.\n  assumption.\nend."]], "EC-1/SurjFromInj.ec": [[true, "(* SurjFromInj Protocol Analysis with EasyCrypt *)\n\nmodule SurjFromInj.\n\n  (* Abstract Types for the Domain and Codomain *)\n  type a.\n  type b.\n\n  (* Definitions for Lists and the Function *)\n  var alist : list a.\n  var blist : list b.\n  fun f (x : a) : b.\n\n  (* Axioms *)\n\n  (* Uniqueness of Lists *)\n  axiom alist_uniq : uniq alist.\n  axiom blist_uniq : uniq blist.\n\n  (* Size of Lists *)\n  axiom alist_blist_size : size alist = size blist.\n\n  (* Membership in Lists *)\n  axiom alist_full : forall x : a, mem x alist.\n  axiom blist_full : forall y : b, mem y blist.\n\n  (* Injectivity of the Function *)\n  axiom f_inj : injective f.\n\n  (* Core Lemma: Surjectivity of the Function *)\n  lemma f_surj : forall y : b, exists x : a, f x = y.\n  proof.\n    (* Define the mapped list: fmaped is the image of alist through f *)\n    pose fmaped = map f alist.\n\n    (* Claim 1: Size of fmaped equals size of blist *)\n    have size_fmaped : size fmaped = size blist.\n    - rewrite <size fmaped>. (* Because of injectivity and uniqueness *)\n      rewrite alist_blist_size.\n      exact size alist.\n\n    (* Claim 2: Uniqueness of fmaped *)\n    assert uniq_fmaped : uniq fmaped.\n    - apply map_injective_uniq.\n      apply f_inj.\n      apply alist_uniq.\n\n    (* Claim 3: Every element in blist is in fmaped *)\n    assert fmaped_full : forall b0 : b, mem b0 fmaped.\n    - intros b0.\n      apply (blist_full b0).\n\n    (* Show that fmaped contains all elements of blist *)\n    intros y.\n    destruct (mem_induction y fmaped) as [| x Hx Hrest].\n\n    (* Case y in fmaped *)\n    - exists (inverse f y). (* Exists an element x such that f x = y *)\n      apply f_inj.\n\n    (* Case contradiction if y not in fmaped *)\n    - assert False.\n      apply fmaped_full.\n      contradiction.\n\n    (* QED for surjectivity *)\n    qed.\n\nend."]], "EC-1/trapdoor.ec": [[true, "module TrapdoorFunctions {\n\n  // Import necessary libraries and modules\n  import int.Int as I.\n  import list.List as L.\n  import set.FSet as S.\n  import bool.Bool as B.\n  import real.Real as R.\n  import algebra.CyclicGroup as CG.\n\n  // Define a cyclic group G\n  axiom cyclic_group : p > 1 => exists (g:CG.elem),(0 < (ord g p) = p).\n\n  // Define key constants\n  const qO : int.\n  \n  // Define functions and procedures\n  (* Function to compute the power of a generator *)\n  fun power (g: CG.elem, x: int) : CG.elem = CG.pow g x.\n\n  (* Verification function for specific group element conditions *)\n  proc check_log (g: CG.elem, gx1 : CG.elem, gx2: CG.elem) : bool = {\n    (* pseudo-implementation: for demonstration only *)\n    let log_condition = exists (x:int), (gx1 = power(g,x) /\\ gx2 = power(g,x + 1)) in\n    log_condition.\n  }.\n\n  (* Main procedure for Trapdoor Function 1 *)\n  proc trapdoor1_main () = {\n    var g = any CG.elem;\n    var gx1 = any CG.elem;\n    var gx2 = any CG.elem;\n    assert check_log(g, gx1, gx2);\n  }.\n  \n  // Further generalized trapdoor modules (Trapdoor2, G1-G10) would follow similar structure\n  // Demonstrate with another generic procedure for Trapdoor Function 2\n  proc trapdoor2_main () = {\n    var g = any CG.elem;\n    var gz1 = any CG.elem;\n    var gz2 = any CG.elem;\n    assert check_log(g, gz1, gz2);\n  }.\n  \n  // Security lemmas and probability bounds\n  lemma injective_exponential : forall (g:CG.elem), injective (fun x => power(g, x)).\n  \n  lemma query_bound_security : \n    forall (P:prob), P < qO / (I.to_real(p)) => \n    fail_with (err \"Queries exceed bound qO with probability greater than allowed\").\n\n  theorem probability_security_bound :\n    forall (G:CG.group) (f:CG.elem -> CG.elem) (x:CG.elem),\n      Pr[ f(x) = x ] <= I.to_real(1) / I.to_real(p) * I.to_real(qO).\n\n}\n\n// Ensure the module compiles and verify lemmas\ncheck TrapdoorFunctions."]], "EC-1/UniformSampling_Concrete.ec": [[true, "module Protocol.\n\n(* Import necessary modules and libraries *)\nimport AllCore.\nimport IntDiv.\nimport CoreMap.\nimport List.\nimport Distr.\nimport JModel.\nimport Array32.\nimport Array256.\nimport WArray256.\nimport W64_SchnorrExtract.\n\n(* Modules for operations *)\nmodule Operations.\n\n  (* Function f: Converts a WArray256.t into an array of 8-bit integers using get8 *)\n  op f (w : WArray256.t) : array int :=\n    Array.init 32 (fun i => get8 w i).\n\n  (* Function g: Maps auxiliary input into a 32-element array of 64-bit integers *)\n  op g (w : WArray256.t) : array int :=\n    Array.init 32 (fun i => Array.get (f w) i).\n\n  (* Function h: Transform WArray256.t into 64-bit integers array like g *)\n  op h (w : WArray256.t) : array int :=\n    Array.init 32 (fun i => Array.get (f w) i).\n\n  (* Function d: Transform output of f through g *)\n  op d (w : WArray256.t) : array int :=\n    g (f w).\n\n  (* Function jsmD: Derived mapping from d *)\n  op jsmD (w : WArray256.t) : array int :=\n    d w.\n\nend.\n\n(* Lemmas for operations *)\n\nlemma h_eq: forall w, h w = g (f w).\n\nlemma init_ext: forall f g, (forall i, f i = g i) -> (Array.init 32 f = Array.init 32 g).\n\nlemma h_inj: injective h.\n\nlemma h_surj: surjective h.\n\nlemma darray_uni: forall x, uniform (d x).\n\nlemma darray_fu: forall x, full (d x).\n\nlemma darray_ll: forall x, lossless (d x).\n\n(* Sampling Procedures Module *)\nmodule SampleLoc.\n\n  (* Procedure to sample random array of 64-bit integers from 256-byte array *)\n  procedure sample (arr : WArray256.t) : array int =\n    Operations.h arr.\n\n  (* Procedure to sample random integer from a defined domain *)\n  procedure sampleInt (n : int) : int =\n    W64_SchnorrExtract.get n.\n\nend.\n\n(* Extended Sampling Procedures in WW Module *)\nmodule WW.\n\n  (* rsample procedure *)\n  procedure rsample () : int =\n    SampleLoc.sampleInt (WW_t.random).\n\n  (* rsample0 procedure *)\n  procedure rsample0 (x : int) : int =\n    let r = rsample () in\n    sampleInt (x + r).\n\n  (* rsample2 procedure with further conditions *)\n  procedure rsample2 (cond : bool) : int =\n    if cond then rsample () else 0.\n\nend.\n\n(* Equivalence and Probabilistic Measure Lemmas *)\nlemma equivalence_sample: equiv [SampleLoc.sample; WW.rsample] <>\n  (fun a b => a = b)\n  [ASpecFp.sampleFp; CSpecFp.sampleFp] (fun a b => a = b).\n\nend."]], "EC-1/W64xN_Finite.ec": [[true, "module W64xN {\n  // Define operations or structures if any specific to W64xN\n  // This is a placeholder for such content\n}\n\nmodule R {\n  type t\n  val bn_ofint : int -> t\n  // Additional operations required for big integer manipulations\n}\n\nmodule Protocol {\n\n  // Assume that modulusR is a known positive integer constant\n  const modulusR : int\n  \n  // Importing necessary specifications for operations\n  use import BigNum_spec\n  use import AllCore.List\n\n  // Define the type of the list containing all values\n  type all_w64xN = list R.t\n\n  // Define the list as the map of integers to their big integer representation\n  let all_w64xN : all_w64xN =\n    List.map (fun i -> R.bn_ofint i) (List.range 0 modulusR)\n\n  // Proving the uniqueness of elements in all_w64xN\n  lemma all_w64xN_uniq : injective (fun i -> R.bn_ofint i) [0..modulusR)\n  proof\n    (* Proof details ensuring the injective property of R.bn_ofint *)\n  qed\n\n  // Proving the size of the list\n  lemma all_w64xN_size : size(all_w64xN) = modulusR\n  proof\n    (* Proof details showing that the list size is equal to modulusR *)\n  qed\n\n  // Proving membership of integer representations\n  lemma all_ints : forall x, 0 <= x < modulusR -> In (R.bn_ofint x) all_w64xN\n  proof\n    (* Proof details for membership inclusion of R.bn_ofint x in all_w64xN *)\n  qed\n\n  // Proving full membership for valid range elements\n  lemma all_w64xN_full : forall x:R.t, value x < modulusR -> In x all_w64xN\n  proof\n    (* Proof details checking that any valid x of type R.t is in all_w64xN *)\n  qed\n\n}"]], "EC-1/WhileNoSuccess.ec": [[true, "module IterativeSamplingProtocol {\n\n  (* Define basic types *)\n  type sbits = int\n  type iat = int\n  type rrt = real\n  type irt = bool\n\n  (* Predicate MyP *)\n  predicate MyP(r : rrt) : bool\n\n  (* Distribution myd *)\n  proc myd() : rrt\n\n  (* Iterative sampling process: 'whp' *)\n  proc whp(s : iat, e : iat, r : rrt) : rrt = {\n    var c = s in\n    while (c <= e && \u00acMyP(r)) do {\n      r <- myd();\n      c <- c + 1;\n    };\n    r\n  }\n\n  (* Conditional sampling process: 'whp_if_end' *)\n  proc whp_if_end(s : iat, e : iat, r : rrt) : rrt = {\n    r <- whp(s, e, r);\n    if (c <= e + 1 && \u00acMyP(r)) then {\n      r <- myd()\n    };\n    r\n  }\n\n  (* Equivalence lemma 'whp_split_if_end' *)\n  lemma whp_split_if_end : forall s e r,\n    whp(s, e, r) == whp_if_end(s, e, r)\n\n  (* Lemmas for bounds *)\n  lemma whp_split_if_end_le : forall s e r,\n    c <= e -> whp_if_end(s, e, r) == whp(s, e, r)\n\n  lemma whp_split_if_end_ge : forall s e r,\n    c > e -> whp_if_end(s, e, r) == whp(s, e, r)\n\n  (* Iterative behavior lemma 'iter' *)\n  lemma iter : forall (p : rrt -> rrt -> real) (MyPa : rrt -> bool),\n    (forall r. \u00acMyPa(r) -> Pr[whp(s, e, r) = r] = p) -> \n    forall n r,\n      (\u00acMyPa(r) -> Pr[whp(s, n, r) == r] = p^n)\n\n  (* Modular implementation sample module *)\n  module IterUntilSuccDistr {\n    var A : { run : iat -> iat -> rrt -> rrt }\n    export { A.run }\n  }\n\n  module IterUntilSuccRew {\n    proc main() = {\n      r <- myd();\n      whp_split_if_end_le(s, e, r);\n      whp_split_if_end_ge(s, e, r)\n    }\n  }\n\n}"]]}