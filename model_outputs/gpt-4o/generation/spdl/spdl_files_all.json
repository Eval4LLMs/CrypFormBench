{"SPDL-1/2r890-ex3-a.spdl": [[true, "// Protocol a\n\nprotocol a {\n\n  // Defining roles: Initiator (I), Responder X (X), Responder Y (Y)\n  role I {\n    // Declare secret variables\n    fresh Nx : Nonce;\n    fresh Ny : Nonce;\n    // Declare public keys\n    var Px : PublicKey;\n    var Py : PublicKey;\n\n    // Step 1: I -> X : Nx\n    send_1(Nx);\n\n    // Step 2: X -> I : {I, Nx}_Px \n    recv_2({I, Nx}_Px);\n\n    // Step 3: I -> Y : Ny\n    send_3(Ny);\n\n    // Step 4: Y -> I : {Ny, I}_Py\n    recv_4({Ny, I}_Py);\n\n    // Non-Agreement and Non-Synchronization claims\n    claim(Nisynch);\n    claim(Niagree);\n  }\n\n  role X {\n    // Declare secret variables\n    var Nx : Nonce;\n    var I : Agent;\n    var SKx : SecretKey;\n\n    // Step 1: I -> X : Nx\n    recv_1(Nx);\n\n    // Step 2: X -> I : {I, Nx}_Px\n    send_2({I, Nx}_Px);\n  }\n\n  role Y {\n    // Declare secret variables\n    var Ny : Nonce;\n    var I : Agent;\n    var SKy : SecretKey;\n\n    // Step 3: I -> Y : Ny\n    recv_3(Ny);\n\n    // Step 4: Y -> I : {Ny, I}_Py\n    send_4({Ny, I}_Py);\n  }\n\n}"]], "SPDL-1/AccessRequestEvaluation_CRCBAC.spdl": [[true, "protocol AccessRequest(Da, GW)\n{\n  // Variables\n  const IDa, cxt, c;\n  secret SKa;\n  var Rq, M, Resp, T1, T2;\n\n  // Hash function and XOR operation\n  func h;\n  func XOR;\n\n  // Fresh nonces\n  fresh T1, T2;\n\n  // Role Da (User)\n  role Da\n  {\n    fresh T1;                  // Generate fresh nonce T1\n    Rq = IDa.cxt.c;            // Construct request message Rq\n    M = XOR(Rq, h(SKa));       // Create message M by XORing Rq with hashed SKa\n    send_1(Da, GW, M, T1);     // Send M and T1 to GW\n\n    // Claims by Da\n    claim Da Secret(SKa);\n    claim Da Alive;\n  }\n\n  // Role GW (Gateway)\n  role GW\n  {\n    var Rq_M_In, T1_In;\n    const IDa, cxt, c;\n    fresh T2;                  // Generate fresh nonce T2\n\n    // Receive message from Da\n    recv_1(Da, GW, Rq_M_In, T1_In);\n    Resp = XOR(IDa.cxt.Resp.h(SKa)) // Create response using XOR and hash\n\n    send_2(GW, Da, Resp, T2);  // Respond with XOR and fresh nonce T2\n\n    // Claims by GW\n    claim GW Alive;\n    claim GW Weakagree(Da);\n    claim GW Niagree(Da, T1_In, T2);\n    claim GW Nisynch(Da, T1_In);\n  }\n}"]], "SPDL-1/boyd.spdl": [[true, "protocol BoydKeyAgreement(I, R, S)\n{\n  role Initiator {\n    var ni, nr, ks: Nonce;\n    var idI, idR: Agent;\n\n    send_1(I, S, I, R, ni);\n    recv_3(R, I, {I, R, ks}'k(I, S), m(ni, m(ks, ni, nr)), nr);\n    recv_4(I, R, m(nr, m(ks, ni, nr)));\n    claim_6(I, Secret, m(ks, ni, nr));\n  }\n\n  role Responder {\n    var ni, nr, ks: Nonce;\n    var idI, idR: Agent;\n\n    recv_2(S, R, {I, R, ks}'k(I, S), {I, R, ks}'k(R, S), ni);\n    send_3(R, I, {I, R, ks}'k(I, S), m(ni, m(ks, ni, nr)), nr);\n    claim_10(R, Secret, m(ks, ni, nr));\n  }\n\n  role Server {\n    var ni, ks: Nonce;\n    var idI, idR: Agent;\n\n    recv_1(I, S, I, R, ni);\n    send_2(S, R, {I, R, ks}'k(I, S), {I, R, ks}'k(R, S), ni);\n  }\n}"]], "SPDL-1/CapabilityRevocation_CRCBAC.spdl": [[true, "// CapabilityRevoke Protocol in Spdl\n\nprotocol CapabilityRevoke(Da, GW)\n\ntypes\n    Agent    // Agents involved in the protocol\n    Nonce    // Nonces for freshness and uniqueness\n    Message  // Messages exchanged between roles\n    Key      // Secret keys\n\nhashed_types\n    Nonce\n    Key\n\n// Initial knowledge of each role\nknowledge\n    Da: {SKa}\n    GW: {}\n\ntransition step1\n    input: \n      Da -> GW: {IDa, T1, M}\n\n    action:\n      GW derives IDa from the received message\n      GW computes M using h(SKg)\n\n    claim:\n      Da Claim_Secret(SKx)\n      Da Claim_Alive\n      Da Claim_WeakAgreement\n      Da Claim_NonInterferenceAgreement\n      Da Claim_NonSynchronization\n\ntransition step2\n    input:\n      GW -> Da: {IDg, T2, M'}\n\n    action:\n      Da derives IDg from the received message\n\n    claim:\n      GW Claim_Secret(SKg)\n      GW Claim_Alive\n      GW Claim_WeakAgreement\n      GW Claim_NonInterferenceAgreement\n      GW Claim_NonSynchronization\n\n// Macro definitions for role verification\nmacros\n    Macro_RoleVerification: {\n        Determine roles and hierarchies\n    }\n\nvariables\n    IDa, IDg: Agent\n    T1, T2: Nonce\n    M, M': Message\n    SKa, SKg: Key\n\nend protocol"]], "SPDL-1/carkey-ni.spdl": [[true, "protocol carkeyni(I, R)\n{\n    role Initiator\n    {\n        var Ni: Nonce;\n        var R: Agent;\n\n        send_1(I, R, {Ni, R}_sk(I));\n        claim_3(I, Nisynch);\n    }\n\n    role Responder\n    {\n        var Ni: Nonce;\n        var M: Message;\n        var I: Agent;\n\n        recv_1(I, R, M);\n        decryption(M, {Ni, R}_sk(I));\n        claim_2(R, Nisynch);\n    }\n}\n\nknowledge\n{\n    R has sk(R);\n    I has sk(I);\n}\n\nenvironment\n{\n    A, B: Agent;\n    session(carkeyni(A, B));\n    session(carkeyni(A, Eve));\n}"]], "SPDL-1/ccitt509-ban.spdl": [[true, "protocol ccitt509(I, R)\n{\n    role I\n    {\n        var xi, yi, ni, nr, xr, yr: Nonce;\n        var R: Agent;\n        var Data1, Data2: Data;\n\n        send_1(I, R, {ni, R, xi, {yi}pk(R)});\n\n        recv_2(R, I, {nr, I, ni, xr, {yr}pk(I)});\n\n        send_3(I, R, {R, {nr}sk(I)});\n\n        claim_I1(I, Secret, yi);\n        claim_I2(I, Secret, yr);\n        claim_I3(I, Sync, R);\n        claim_I4(I, Agree, ni, nr);\n    }\n\n    role R\n    {\n        var xi, yi, ni, nr, xr, yr: Nonce;\n        var I: Agent;\n        var Data1, Data2: Data;\n\n        recv_1(I, R, {ni, R, xi, {yi}pk(R)});\n\n        send_2(R, I, {nr, I, ni, xr, {yr}pk(I)});\n\n        recv_3(I, R, {R, {nr}sk(I)});\n\n        claim_R1(R, Secret, yi);\n        claim_R2(R, Secret, yr);\n        claim_R3(R, Sync, I);\n        claim_R4(R, Agree, ni, nr);\n    }\n}"]], "SPDL-1/cotes_de_porc-v0.spdl": [[true, "protocol myProtocol(I, R)\n{\n\t// Role definitions\n\trole I {\n\t\tfresh n1, sec; // n1 and sec are generated by I\n\t\tvar n2; // n2 will be received from R\n\t\tconst I, R;\n\n\t\tsend_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I, sec));\n\t\trecv_2(R, I, {n2}pk(I), h(sec, n1, n2));\n\t\tsend_3(I, R, n2);\n\t}\n\n\trole R {\n\t\tvar n1, sec; // n1 and sec will be received from I\n\t\tfresh n2; // n2 is generated by R\n\t\tconst I, R;\n\n\t\trecv_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I, sec));\n\t\tsend_2(R, I, {n2}pk(I), h(sec, n1, n2));\n\t\trecv_3(I, R, n2);\n\t}\n\n\t// Security properties\n\tclaims_I: secrecy(n1, sec); // Confidentiality of n1 and sec for I\n\tclaims_R: secrecy(n1, sec); // Confidentiality of n1 and sec for R\n\n\tclaims_I_auth: authentication_on(I, sec, n1, receipt(n2)); // Authentication claim for I\n\tclaims_R_auth: authentication_on(R, sec, n1, n2); // Authentication claim for R\n}"]], "SPDL-1/DHKE-1.spdl": [[true, "// Protocol: Two-Move Diffie-Hellman with Pseudo-Random Functions\nroles {\n\n  // Initiator role\n  role Initiator {\n    fresh x: Nonce;\n    var R: Principal;\n    var beta: Ticket;\n    var i: Nonce;\n    var msg1_signature: Message;\n    var msg2_signature: Message;\n    \n    send_1(I,R, alpha=g1(x), msg1_signature=sign(sk(I), (g1(x), R)));\n\n    recv_2(R,I, beta, i, msg2_signature=sign(sk(R), (beta, i, I)));\n\n    send_3(I,R, h1_conclusion=h1(beta, x));\n\n    claim_Secret(I, SKR=g2(beta, x));\n  }\n\n  // Responder role\n  role Responder {\n    fresh y: Nonce;\n    fresh i: Nonce;\n    var I: Principal;\n    var alpha: Message;\n    var msg1_signature: Message;\n    var msg2_signature: Message;\n    var h2_conclusion: Message;\n    \n    recv_1(I,R, alpha=g1(x), msg1_signature=sign(sk(I), (alpha, R)));\n\n    send_2(R,I, beta=g1(y), i, msg2_signature=sign(sk(R), (beta, i, I)));\n\n    recv_3(I,R, h2_conclusion=h1(alpha, y));\n\n    claim_Secret(R, SKR=g2(alpha, y));\n  }\n}\n\nconst g1: Function;\nconst g2: Function;\nconst h1: Function;\nmoduless {\n  secret_key(I, sk(I));\n  secret_key(R, sk(R));\n}"]], "SPDL-1/encryption2.spdl": [[true, "protocol EncryptionProtocol2(M, C, B) {\n\n    // Declare the roles\n    role Merchant {\n        const UIDm, Nm, Timestamp, Amount;\n        var IDc, Nc, MACm, EncMsg;\n\n        // Generate derived key Kcm (assumed public)\n        fresh Kcm: Nonce;\n\n        // Step 1: Initiate key exchange\n        send_1(M, C, {Nm} * MACm);\n\n        // Step 2: Receive Customer nonce\n        recv_2(C, M, {Nc} * MACc);\n\n        // Step 3: Send encrypted transaction request\n        send_3(M, C, pk(C), {IDc, Amount, Sm} * Kcm);\n\n        // Claims\n        claim_M1: Secret(Kcm, [M, C]);\n        claim_M2: Alive(M);\n        claim_M3: Weakagree(M, C, B);\n    }\n\n    role Customer {\n        var UIDc, Nm, Nc, MACc, EncMsg;\n        const TSc;\n\n        // Generate derived key Kcm\n        fresh Kcm: Nonce;\n\n        // Step 1: Receive Merchant nonce\n        recv_1(M, C, {Nm} * MACm);\n\n        // Step 2: Confirm and reply with own nonce\n        fresh Nc: Nonce;\n        send_2(C, M, {Nc} * MACc);\n\n        // Step 3: Receive transaction request and confirm it\n        recv_3(M, C, pk(C), {UIDc, Amount, Sm} * Kcm);\n\n        // Step 4: Send confirmation to Bank\n        send_4(C, B, pk(B), {UIDm, UIDc, Amount, Sm, Sc} * Kcm);\n\n        // Claims\n        claim_C1: Secret(Kcm, [C, M]);\n        claim_C2: Alive(C);\n        claim_C3: Weakagree(C, M, B);\n    }\n\n    role Bank {\n        var UIDm, UIDc, Amount, Sm, Sc, EncConfirm;\n        const Tsb;\n\n        // Step 4: Receive transaction confirmation\n        recv_4(C, B, pk(B), {UIDm, UIDc, Amount, Sm, Sc} * Kcm);\n\n        // Step 5: Send payment confirmation\n        send_5(B, M, {Tsb, UIDm, UIDc, Amount} * Kcm);\n        send_6(B, C, {Tsb, UIDm, UIDc, Amount} * Kcm);\n\n        // Claims\n        claim_B1: Alive(B);\n        claim_B2: Weakagree(B, C, M);\n        claim_B3: Secret(Tsb, [B]);\n    }\n\n    // Key and inverse key relationships\n    inversekeys(pk, sk);\n}"]], "SPDL-1/en_y-v0.spdl": [[true, "protocol myProtocol {\n\n  // Define the roles in the protocol: Initiator (I) and Responder (R)\n  role Initiator(I, R)\n  {\n    // Declare local variables\n    fresh sec: Nonce;    // The secret generated by the initiator\n    fresh n1: Nonce;     // Initiator's nonce\n    const pkI: PublicKey;  // Initiator's public key\n    const pkR: PublicKey;  // Responder's public key\n\n    // Specify the first protocol step: Initiator to Responder\n    send_1(I, R, {sec, I}pkR, h(sec), {n1}pkR);\n\n    // Specify the second protocol step: Receive message from Responder\n    recv_2(R, I, {n2, R}pkI, n1);\n\n    // Verify received message\n    secret sec;\n    \n    // Third protocol step: Send nonce back to Responder\n    send_3(I, R, n2);\n  }\n\n  role Responder(R, I)\n  {\n    // Declare local variables\n    fresh n2: Nonce;     // Responder's nonce\n    const pkI: PublicKey;  // Initiator's public key\n    const pkR: PublicKey;  // Responder's public key\n\n    // Specify the first protocol step: Receive message from Initiator\n    recv_1(I, R, {sec, I}pkR, h(sec), {n1}pkR);\n\n    // Extract 'sec' and 'n1' from the received message\n    const sec: Nonce;\n    const n1: Nonce;\n    \n    // Second protocol step: Send message back to Initiator\n    send_2(R, I, {n2, R}pkI, n1);\n\n    // Third protocol step: Receive nonce back from Initiator\n    recv_3(I, R, n2);\n  }\n}"]], "SPDL-1/exchange-hash.spdl": [[true, "protocol KeyExchange {\n    role UserI {\n        // Declare knowledge\n        var ni : Nonce;\n        var kir : Key;\n        \n        // Step 1: Initiation\n        send_1(R, {ni, I}pk(R));\n        \n        // Step 2: Receive response from User R\n        recv_2({hash(kir, ni, R), nr, kir}pk(I));\n\n        // Step 3: Finalization\n        send_3(R, {hash(nr, ni)}kir);\n\n        // Claims for User I\n        claim(UserI, Secret, kir);  // User I claims that the key kir is secret\n        claim(UserI, Nisynch, ni);  // User I claims synchronization on ni\n    }\n    \n    role UserR {\n        // Declare knowledge\n        var nr : Nonce;\n        var kir : Key;\n        \n        // Step 1: Receive initiation from User I\n        recv_1({ni, I}pk(R));\n        \n        // Generate supporting data for response\n        fresh nr;\n        fresh kir;\n\n        // Step 2: Response\n        send_2(I, {hash(kir, ni, R), nr, kir}pk(I));\n\n        // Claims for User R\n        claim(UserR, Secret, kir);  // User R claims that the key kir is secret\n        claim(UserR, Nisynch, nr);  // User R claims synchronization on nr\n    }\n}"]], "SPDL-1/five-run-bound.spdl": [[true, "protocol r5bound(I, R)\n{\n    role I\n    {\n        var ni, k1: Nonce;\n        var keyPairI: KeyPair;\n        var pkR: PublicKey;\n        var skI: SecretKey;\n\n        // Generate nonce and key pair for I\n        fresh ni;\n        fresh k1;\n        keyPairI = generateKeyPair(I);\n        skI = secretKey(keyPairI);\n\n        // Send ni to R\n        send_1(I, R, {ni});\n\n        // Wait to receive signed {ni} from R\n        recv_2(R, I, {ni}sk(R));\n\n        // Send encrypted and signed {k1}pkR, {ni}skI to R\n        send_3(I, R, {{k1}pkR, {ni}skI});\n\n        // Optional: Wait to confirm k2 exchange\n        recv_4(R, I, {k2}k1);\n    }\n\n    role R\n    {\n        var ni, k2: Nonce;\n        var keyPairR: KeyPair;\n        var pkI: PublicKey;\n        var skR: SecretKey;\n\n        // Generate nonce and key pair for R\n        fresh k2;\n        keyPairR = generateKeyPair(R);\n        skR = secretKey(keyPairR);\n\n        // Receive ni from I\n        recv_1(I, R, {ni});\n\n        // Send signed {ni} with R's secret key\n        send_2(R, I, {ni}sk(R));\n\n        // Receive encrypted and signed {k1}pkR, {ni}skI from I\n        recv_3(I, R, {{k1}pkR, {ni}skI});\n\n        // Encrypt k2 with received k1 and send back\n        send_4(R, I, {k2}k1);\n\n        // Claim that k2 is confidential\n        claim(R, Secret, k2);\n    }\n}"]], "SPDL-1/andrew-ban-1.spdl": [[true, "protocol BAN_Modified_Andrew_RPC\n{\n    // Participant roles\n    role Initiator (I, R)\n    {\n        variables\n        {\n            Ni : Nonce;\n            Nr : Nonce;\n            Nr2 : Nonce;\n            Kir : SessionKey;\n            KeyIR : SessionKey;\n        }\n        \n        send_1(I, R, {I, Ni}KeyIR);\n        recv_2(R, I, {Nr, Ni}KeyIR);\n        send_3(I, R, {Nr}KeyIR);\n        recv_4(R, I, {Kir, Nr2, Ni}KeyIR);\n\n        claim( I, Nisynch);\n        claim( I, Niagree, Ni, Nr);\n        claim( I, Secret, Kir);\n        claim( I, Empty, (Fresh, Kir));\n    }\n    \n    role Responder (R, I)\n    {\n        variables\n        {\n            Ni : Nonce;\n            Nr : Nonce;\n            Nr2 : Nonce;\n            Kir : SessionKey;\n            KeyIR : SessionKey;\n        }\n        \n        recv_1(I, R, {I, Ni}KeyIR);\n        send_2(R, I, {Nr, Ni}KeyIR);\n        recv_3(I, R, {Nr}KeyIR);\n        send_4(R, I, {Kir, Nr2, Ni}KeyIR);\n\n        claim( R, Nisynch);\n        claim( R, Niagree, Ni, Nr);\n        claim( R, Secret, Kir);\n        claim( R, Empty, (Fresh, Kir));\n    }\n}\n\n/// Intruder information and network setup\nintruder_knowledge = {KeyIR, I, R, sessionKey, nonce};"]], "SPDL-1/Fortified-Chain2.spdl": [[true, "protocol FortifiedChain2\n{\n    role DeviceA\n    {\n        fresh RN;\n        fresh RNa;\n        fresh PRa;\n        fresh PUa;\n        fresh SessionKey;\n        fresh Timestamp;\n\n        const IDdev;\n        const DIsig;\n        const MATdiv;\n        const IDa;\n        const DIsigb;\n        const PUedge;\n        \n        var P1;\n        var Q1;\n\n        send_1(Edge, {IDdev, RN}PUedge);\n        recv_2(Edge, P1);\n        send_3(DeviceB, {IDa, RNa}PUedge);\n        recv_4(DeviceB, Q1);\n\n        claim(A_secret, SessionKey);\n        claim(A_agreement, RN);\n        claim(A_synchronization, Timestamp);\n    }\n\n    role Edge\n    {\n        fresh PRedge;\n        fresh PUedge;\n        fresh PUa;\n        fresh PUb;\n        fresh RNhc;\n        fresh MATdiv;\n        fresh GIid;\n        fresh SIid;\n\n        const IDhc;\n        const RIa;\n        const IDa;\n        const RIa1;\n        const Hdev;\n        const MATdivb;\n        const RIb;\n        const IDb;\n\n        var V0;\n        var P0;\n        var P1;\n        var P2;\n        \n        recv_1(DeviceA, V0);\n        P0 = D(PRedge, V0);\n        send_2(DeviceA, P1);\n        send_3(DeviceB, P2);\n\n        claim(E_secret, PRedge);\n        claim(E_agreement, RNhc);\n        claim(E_synchronization, GIid);\n    }\n\n    role DeviceB\n    {\n        fresh PRb;\n        fresh PUedge;\n        fresh PUa;\n        fresh PUb;\n        fresh DIsigb;\n        fresh RNb;\n\n        const IDdevb;\n        const DIsigb;\n        const MATdivb;\n        const IDb;\n        \n        var P2;\n        var V1;\n        var V3;\n        var Q1;\n        var Q2;\n        var Q3;\n        var Q4;\n        \n        recv_1(Edge, P2);\n        send_2(DeviceA, V1);\n        send_3(DeviceA, V3);\n\n        claim(B_secret, PRb);\n        claim(B_agreement, RNb);\n        claim(B_synchronization, P2);\n    }\n}"]], "SPDL-1/fourway-HSDDM05.spdl": [[true, "protocol FourWayAuth(X, Y) {\n  role X {\n    fresh x;\n    var y;\n    // Step 1: Agent X -> Agent Y: x\n    send_1(X, Y, x);\n    \n    // Step 3: Agent X -> Agent Y: hash(hash(pmk(X, Y), x, y), x, msg3)\n    recv_2(Y, X, y, hash(hash(pmk(X, Y), x, y), y, _));\n    send_3(X, Y, hash(hash(pmk(X, Y), x, y), x, _));\n\n    // Claim mutual agreement on nonce x and y (Niagree)\n    claim_X(Niagree);\n  }\n  \n  role Y {\n    var x;\n    fresh y;\n    \n    // Step 2: Agent Y -> Agent X: y, hash(hash(pmk(X, Y), x, y), y, msg2)\n    recv_1(X, Y, x);\n    send_2(Y, X, y, hash(hash(pmk(X, Y), x, y), y, _));\n    \n    // Step 4: Agent Y -> Agent X: hash(hash(pmk(X, Y), x, y), msg4)\n    recv_3(X, Y, hash(hash(pmk(X, Y), x, y), x, _));\n    send_4(Y, X, hash(hash(pmk(X, Y), x, y), _));\n\n    // Claim mutual agreement on nonce x and y (Niagree)\n    claim_Y(Niagree);\n  }\n}"]], "SPDL-1/gros_pigeons-v0.spdl": [[true, "protocol myProtocol(I, R)\n{\n    // Define the roles' knowledge and secrets\n    role I\n    {\n        var sec_I: MySecret;   // Initiator's secret\n        var n_I: Nonce;        // Initiator's nonce\n        var pk_R: PublicKey;   // Responder's public key\n        var h_n_R: HashFunc;   // Hash of responder's nonce\n\n        // Initial knowledge\n        knows I { pk_R }\n\n        // Step 1: Initiator sends encrypted secret to Responder\n        send_1(I, R, {sec_I}pk_R);\n    }\n\n    role R\n    {\n        var sec_R: MySecret;   // Responder's secret (to compare with sec_I)\n        var n_R: Nonce;        // Responder's nonce\n        var pk_I: PublicKey;   // Initiator's public key\n        var h_sec_I: HashFunc; // Hash of initiator's secret\n\n        // Initial knowledge\n        knows R { pk_I }\n\n        // Step 2: Responder processes and sends hash of secret, and encrypted nonce\n        recv_1(I, R, {sec_I}pk_R);\n        h_sec_I = h(sec_I);\n        send_2(R, I, h_sec_I, {n_R}pk_I);\n    }\n\n    role I\n    {\n        var n_R: Nonce;   // Responder's nonce\n        var h_n_R: HashFunc; // Hash of responder's nonce\n\n        // Step 3: Initiator sends hash of received nonce\n        recv_2(R, I, h_sec_I, {n_R}pk_I);\n        h_n_R = h(n_R);\n        send_3(I, R, h_n_R);\n    }\n\n    role R\n    {\n        var h_n_R: HashFunc; // Hash of responder's nonce\n\n        // Step 4: Responder verifies the hashed nonce\n        recv_3(I, R, h_n_R);\n    }\n}\n\n// Security goals to analyze\ntypedef role (I, R);\n\ngoal secrecy_of sec_I, n_I, n_R;\ngoal authentication_on h(sec_I), h(n_R);"]], "SPDL-1/HMQV.spdl": [[true, "protocol HMQV_twopass(I, R) {\n    role I {\n        fresh x: Nonce;\n        var Y: Ticket;\n        \n        send_1(I, R, gexp(x));\n        recv_2(R, I, Y);\n        \n        claim_I1(I, Running, I, R, Y);\n        claim_I2(I, Weakagree, I, R, Y);\n        \n        secret(SK, [I, R], Secret);\n        \n        // Generic key derivation and computation for shared secret\n        let SK = KDF(mult(Y, x));\n    }\n    \n    role R {\n        fresh y: Nonce;\n        var X: Ticket;\n        \n        recv_1(I, R, X);\n        send_2(R, I, gexp(y));\n        \n        claim_R1(R, Running, I, R, X);\n        claim_R2(R, Weakagree, I, R, X);\n        \n        secret(SK, [I, R], Secret);\n        \n        // Generic key derivation and computation for shared secret\n        let SK = KDF(mult(X, y));\n    }\n}\n\n// Helper functions and protocols\nfunction gexp(x: Nonce) : Ticket;\nfunction mult(a, b) : Ticket;\nfunction KDF(input) : SymmetricKey;\n\n// Public Key Simulation\nprotocol @publickeys(PK) {\n    role PK {\n        fresh sk: PrivateKey;\n        var pk: PublicKey;\n\n        send_1(PK, pk);\n        let pk = gexp(sk);\n    }\n}\n\n// Exponentiation Helper\nprotocol @exponentiation(RA, RB, RC) {\n    role RA {\n        var exA: Exponentiation;\n        send_ex(RA, RC, exA);\n    }\n    \n    role RB {\n        var exB: Exponentiation;\n        send_ex(RB, RC, exB);\n    }\n    \n    role RC {\n        var exA: Exponentiation;\n        var exB: Exponentiation;\n        \n        recv_ex(RA, RC, exA);\n        recv_ex(RB, RC, exB);\n\n        let result = mult(exA, exB);\n        send_result(RC, RA, result);\n        send_result(RC, RB, result);\n    }\n}\n\n// Addition and Multiplication Protocols\nprotocol @addmult(I, R) {\n    role I {\n        var a: Value;\n        var b: Value;\n        send_addmult(I, R, add(a, b));\n    }\n    \n    role R {\n        var a: Value;\n        var b: Value;\n        recv_addmult(I, R, add(a, b));\n        send_result(R, I, mult(a, b));\n    }\n}\n\nfunction add(a, b) : Value;"]], "SPDL-1/ikev1-quick.spdl": [[true, "protocol ikev1-quick\n\n// Define the roles\nrole Initiator(I, R)\n{\n    var Ni, Nr, i, r: Nonce;\n    var Gi, Gr, k: Ticket;\n    var Algo: Function;\n    var mid: Text;\n    var list: Text;\n\n    initiate:\n        // Begin the protocol by generating nonces and tickets\n        Ni := new();\n        i := new();\n        Gi := new();\n        k(I, R) := kdf(Ni, Nr, i, r); // KDF-based key derivation\n\n    send_1(I, R):\n        // Message 1: Send to Responder\n        {Ni, hash(i), Gi, list}k(I, R)\n        // Claim running\n        claim(I, Running);\n\n    recv_2(R, I):\n        // Message 2: Receive from Responder\n        {Nr, Gr, list}k(I, R)\n\n        // Process received values\n        r := new(); // Update nonce\n\n        // Claim that the Initiator is alive and running\n        claim(I, Alive);\n        claim(I, SKR); // Successful key reception\n        claim(I, Commit); // Commitment to the exchange\n\n    send_3(I, R):\n        // Message 3: Final confirmation\n        {Nr, Gr}k(I, R)\n\n        // Claim weak agreement\n        claim(I, Weakagree);\n}\n\nrole Responder(R, I)\n{\n    var Ni, Nr, i, r: Nonce;\n    var Gi, Gr, k: Ticket;\n    var Algo: Function;\n    var mid: Text;\n    var list: Text;\n\n    initiate:\n        // Begin the protocol by generating nonces and tickets\n        Nr := new();\n        r := new();\n        Gr := new();\n        k(I, R) := kdf(Ni, Nr, i, r); // KDF-based key derivation\n\n    recv_1(I, R):\n        // Message 1: Receive from Initiator\n        {Ni, hash(i), Gi, list}k(I, R)\n\n        // Claim running\n        claim(R, Running);\n\n    send_2(R, I):\n        // Message 2: Send to Initiator\n        {Nr, Gr, list}k(I, R)\n\n        // Claim that the Responder is alive and running\n        claim(R, Alive);\n        claim(R, SKR); // Successful key reception\n        claim(R, Commit); // Commitment to the exchange\n\n    recv_3(I, R):\n        // Message 3: Receive final confirmation\n        {Nr, Gr}k(I, R)\n\n        // Claim weak agreement\n        claim(R, Weakagree);\n}"]], "SPDL-1/ikev2-mac.spdl": [[true, "protocol IKEv2(DH, SWAP, E, I, R) {\n    // Cryptographic Functions\n    function g, h, MAC, PRF, KDF;\n\n    // Nonces\n    const NiI, NiR;\n\n    role DH {\n        send_1( DH1 );\n        recv_2( DH2 );\n    }\n\n    role SWAP {\n        recv_1( SWAP1 );\n        send_2( SWAP2 );\n    }\n\n    role E {\n        recv_1( E1, I, R, MAC );\n        send_2( E2, I, R, MAC );\n        recv_3( E3, MAC );\n        send_4( E4, MAC );\n    }\n\n    role I {\n        send_1( 1, NiI, SA1 );\n        recv_2( 2, NiR, SA2 );\n        send_3( 3, MAC );\n        recv_4( 4, MAC );\n        \n        claim( I, Running );\n        claim( I, SKR );\n        claim( I, Alive );\n        claim( I, WeakAgreement );\n        claim( I, Commit );\n    }\n\n    role R {\n        recv_1( 1, NiI, SA1 );\n        send_2( 2, NiR, SA2 );\n        recv_3( 3, MAC );\n        send_4( 4, MAC );\n        \n        claim( R, Running );\n        claim( R, SKR );\n        claim( R, Alive );\n        claim( R, WeakAgreement );\n        claim( R, Commit );\n    }\n}"]], "SPDL-1/iso25-tag.spdl": [[true, "// Protocol: ISO/IEC 9798 Mutual Authentication and Key Establishment\n// Participants: A (initiator), B (responder), P (trusted third party)\n\nprotocol ISO_IEC_9798(A, B, P) {\n    const Kab;       // Session key\n    const KeyA;      // Symmetric key for A\n    const KeyB;      // Symmetric key for B\n    const TVPa;      // Nonce from A to P\n    const TNa;       // Nonce from A to B\n    const TNb;       // Nonce from B to A\n    const TNp;       // Nonce from P to A\n\n    // Step 1: A to P\n    A -> P: {TVPa, A, Text1}KeyA\n    \n    // Step 2: P to A\n    P -> A: {TVPa, Kab, TNp, Text4, Text3}KeyA\n    P -> B: {Text3, Kab, TNp}KeyB\n    \n    // Step 3: A to B\n    A -> B: {TNa, Text6, Kab}Kab\n    \n    // Step 4: B to A\n    B -> A: {TNb, Text8}Kab\n\n    // Claims for security properties\n    claim(A, Secret, Kab);   // A claims the session key is secret\n    claim(B, Secret, Kab);   // B claims the session key is secret\n    claim(A, Alive);         // A claims to be alive\n    claim(B, Alive);         // B claims to be alive\n    claim(A, Agree);         // A claims agreement on the session key and messages\n    claim(B, Agree);         // B claims agreement on the session key and messages\n}"]], "SPDL-1/isoiec-9798-2-1.spdl": [[true, "protocol keysymm21(A, B)\n{\n    role A {\n        fresh T, Text : Nonce;\n        var T, Text : Nonce;\n        \n        send_1( A, B, { T, Text }_k(A,B) );\n        recv_2( B, A, { T, Text }_k(B,A) );\n    }\n    \n    role B {\n        fresh T, Text : Nonce;\n        var T, Text : Nonce;\n\n        recv_1( A, B, { T, Text }_k(A,B) );\n        send_2( B, A, { T, Text }_k(B,A) );\n    }\n}"]], "SPDL-1/isoiec11770-2-13.spdl": [[true, "// ISO/IEC 11770-213 Protocol Description in SPDL\n\n// Roles\nrole Initiator {\n    var Ni, Nr: Nonce;\n    var Kir: SymmetricKey;\n    var T: Ticket;\n    const I, R, S: Agent;\n\n    init {\n        generate Ni;\n        send_1(I, R, {Ni});\n    }\n\n    transition {\n        label Step2;\n        recv_2(R, I, {Ni, Kir, R}SymmetricKey(S, I));\n        \n        claim(CI_Secret, Kir : Secret);\n    }\n}\n\nrole Responder {\n    var Ni, Nr: Nonce;\n    var Kir: SymmetricKey;\n    var T: Ticket;\n    const I, R, S: Agent;\n\n    init {\n        recv_1(I, R, {Ni});\n        generate Nr;\n        generate Kir;\n        send_2(R, S, {Nr, Ni, I, Kir}SymmetricKey(R, S));\n    }\n\n    transition {\n        recv_3(S, R, {Nr, I, T}SymmetricKey(S, R));\n        send_4(R, I, {T});\n        \n        claim(CR_Secret, Kir : Secret);\n    }\n}\n\nrole Server {\n    var Ni, Nr: Nonce;\n    var Kir: SymmetricKey;\n    var T: Ticket;\n    const I, R, S: Agent;\n\n    init {\n        recv_2(R, S, {Nr, Ni, I, Kir}SymmetricKey(R, S));\n        send_3(S, R, {Nr, I, T}SymmetricKey(S, R));\n        \n        // Forming the ticket T with required elements\n        T := {Ni, Kir, R}SymmetricKey(S, I);\n    }\n}\n\n// Protocol context: initial setting\nprotocol ISO_IEC_11770_213 {\n    const I, R, S: Agent;\n    concat Intruder: Agent;\n    = Intruder =!= I & Intruder =!= R & Intruder =!= S;\n}\n\n// Instantiate the protocol with three roles\nsystem {\n    Initiator[I,R,S];\n    Responder[I,R,S];\n    Server[I,R,S];\n}"]], "SPDL-1/KAS1.spdl": [[true, "// KEA+ Protocol in SPDL for Scyther\n\nprotocol KEAplus\n{\n  hashfunction h1;  // hash function for key derivation\n  hashfunction g1;  // public transformation function for nonces\n\n  role Initiator\n  {\n    var R: Agent;        // Responder's identity\n    var x: Nonce;        // fresh nonce generated by Initiator\n    var beta: Ticket;    // value received from Responder\n\n    send_1(I, I, \"compromise\");          // Step 1: compromise message to self\n    send_2(I, R, g1(x));                 // Step 2: send g1(x) to Responder\n\n    recv_3(R, I, beta);                  // Step 3: receive beta from Responder\n\n    claim(I, SKR, h1(beta, R, x));      // Claim shared key SKR based on beta, R, x\n  }\n\n  role Responder\n  {\n    var I: Agent;        // Initiator's identity\n    var y: Nonce;        // fresh nonce generated by Responder\n    var alpha: Ticket;   // value received from Initiator\n\n    recv_1(I, R, alpha);                 // Step 1: receive alpha = g1(x) from Initiator\n    send_1(R, R, \"compromise\");          // Step 2: compromise message to self\n    send_2(R, I, g1(y));                 // Step 2: send g1(y) to Initiator\n\n    claim(R, SKR, h1(I, y, alpha));      // Claim shared key SKR based on I, y, alpha\n  }\n}"]], "SPDL-1/andrew-lowe-ban.spdl": [[true, "// Protocol: Andrew Secure RPC\n\n// Define roles\nrole Initiator {\n    const I, R : Agent;\n    var ni, kir : Nonce;\n    \n    send_1(I, R, I, ni);\n    recv_2(R, I, {ni, kir, R}k(IR));\n    claim_I1(I, Nisynch);\n    claim_I2(I, Secret, kir);\n    claim_I3(I, Empty, (Fresh, kir));\n    send_3(I, R, {ni}kir);\n    recv_4(R, I, nr);\n}\n\nrole Responder {\n    const R, I : Agent;\n    var ni, nr, kir : Nonce;\n    \n    recv_1(I, R, I, ni);\n    kir = fresh();\n    send_2(R, I, {ni, kir, R}k(IR));\n    recv_3(I, R, {ni}kir);\n    claim_R1(R, Nisynch);\n    claim_R2(R, Secret, kir);\n    claim_R3(R, Empty, (Fresh, kir));\n    nr = fresh();\n    send_4(R, I, nr);\n}\n\n// Network intruder (adversary) model\nintruder_knowledge = {I, R, k(IR)};\n\n// Protocol as a set of roles\nprotocol Andrew_RPC {\n    role Initiator;\n    role Responder;\n}"]], "SPDL-1/KEA+.spdl": [[true, "protocol KEAPlus;\n\nrole Initiator\n{\n    var x; // Fresh nonce generated by Initiator\n    var alpha; // Transformed nonce\n    \n    send_1(I,R,g1(x)); // Send transformed nonce to Responder\n\n    recv_2(R,I,g1(y)); // Receive transformed nonce from Responder\n    var beta; // Ticket received from Responder\n\n    claim_skr_I(SK, h1(y, alpha)); // Claim the session key derived from Responder's nonce and ticket\n}\n\nrole Responder\n{\n    var y; // Fresh nonce generated by Responder\n    var alpha; // Transformed nonce of Initiator\n\n    recv_1(I,R,g1(x)); // Receive transformed nonce from Initiator\n\n    send_2(R,I,g1(y)); // Send transformed nonce to Initiator\n    var beta; // Send ticket beta to Initiator\n\n    claim_skr_R(SK, h1(x, beta)); // Claim the session key derived from Initiator's nonce and ticket\n}"]], "SPDL-1/kerberos-rddm.spdl": [[true, "Protocol Kerberos\n  Roles\n    Client, KDC, TGS, ServiceProvider\n\n  // Define the role Client\n  Role Client\n    Send\n      // Initial Request: C -> K : {Request, n1}\n      C -> KDC : {Request, n1}\n    Receive\n      // Ticket Granting: K -> C : {TGT, AKey, n1}kc\n      KDC -> C : {TGT, AKey, n1}kck\n    Send\n      // Service Request: C -> T : {TGT, n2, C}AKey\n      C -> TGS : {TGT, n2, C}AKey\n    Receive\n      // Service Response: T -> C : {st, SKey, n2}AKey\n      TGS -> C : {st, SKey, n2}AKey\n    Send\n      // Final Service Access: C -> S : {st, t}SKey\n      C -> ServiceProvider : {st, t}SKey\n    Receive\n      // Service Confirmation: S -> C : {t}SKey\n      ServiceProvider -> C : {t}SKey\n\n  // Define the role KDC\n  Role KDC\n    Receive\n      // Initial Request: C -> K : {Request, n1}\n      C -> KDC : {Request, n1}\n    Send\n      // Ticket Granting: K -> C : {TGT, AKey, n1}kc\n      KDC -> C : {TGT, AKey, n1}kck\n\n  // Define the role TGS\n  Role TGS\n    Receive\n      // Service Request: C -> T : {TGT, n2, C}AKey\n      C -> TGS : {TGT, n2, C}AKey\n    Send\n      // Service Response: T -> C : {st, SKey, n2}AKey\n      TGS -> C : {st, SKey, n2}AKey\n\n  // Define the role ServiceProvider\n  Role ServiceProvider\n    Receive\n      // Final Service Access: C -> S : {st, t}SKey\n      C -> ServiceProvider : {st, t}SKey\n    Send\n      // Service Confirmation: S -> C : {t}SKey\n      ServiceProvider -> C : {t}SKey\n\n  // Claims for security properties\n  Claims\n    Client Reachable\n    Client Secret AKey\n    TGS Secret AKey\n    ServiceProvider Reachable\n    ServiceProvider Secret SKey"]], "SPDL-1/localclaims-breaker.spdl": [[true, "protocol LocalclaimsBreakerProtocol(I, R)\n{\n    role I\n    {\n        var I, R: Agent;\n        var ni, nr, x: Nonce;\n        var skI: PrivateKey;\n        var pkR: PublicKey;\n\n        fresh ni;\n\n        send_1(I, R, {I, ni}pkR);\n        recv_2(R, I, {ni, nr, R}pk(I));\n        \n        claim_I1: Secret(ni, [R]);\n        claim_I2: Secret(nr, [R]);\n\n        send_3(I, R, {nr, I}pkR);\n        recv_4(R, I, {x}pk(I));\n        send_5(I, R, {x}ni);\n    }\n    \n    role R\n    {\n        var I, R: Agent;\n        var ni, nr, x: Nonce;\n        var skR: PrivateKey;\n        var pkI: PublicKey;\n\n        fresh nr, x;\n\n        recv_1(I, R, {I, ni}pkR);\n        send_2(R, I, {ni, nr, R}pkI);\n\n        claim_R1: Secret(ni, [I]);\n        claim_R2: Secret(nr, [I]);\n\n        recv_3(I, R, {nr, I}pkR);\n        send_4(R, I, {x}pkI);\n        recv_5(I, R, {x}ni);\n    }\n}"]], "SPDL-1/myProt.spdl": [[true, "protocol myProtocol(X, Y) {\n\n  // Role A Specification\n  role A {\n    fresh K : MySecret;\n    fresh W : Nonce;\n    var B : uchar;\n    var V : MySecret;\n    var n : Nonce;\n\n    send_1(X, B, h(X, K), {K}pk(B));\n    recv_2(B, X, h(B, V, n), {n}pk(X));\n\n    claim_4(X, Secret, K);\n    claim_6(X, Nisynch);\n  \n    send_3(X, B, h(n));\n  }\n\n  // Role B Specification\n  role B {\n    fresh V : MySecret;\n    fresh n : Nonce;\n    var A : uchar;\n    var K : MySecret;\n\n    recv_1(A, Y, h(A, K), {K}pk(Y));\n    send_2(Y, A, h(Y, V, n), {n}pk(A));\n  \n    recv_3(A, Y, h(n));\n\n    claim_5(Y, Secret, V);\n    claim_7(Y, Nisynch);\n  }\n}"]], "SPDL-1/NAXOS.spdl": [[true, "protocol NAXOS(I, R)\n{\n    // Types and functions\n    const g; // Generator\n    hash h1, h2;\n    func p; // Exponentiation function\n\n    // Roles and local states\n    role I {\n        const ikI, pkI;  // Private and public keys of I\n        var eskI;        // Ephemeral session key\n        var x, y;        // Computed values\n        var Ni;          // Nonce generated by I\n        var si;          // Session key\n\n        send_1(I, R, Ni, h1(ikI, eskI));\n        recv_2(R, I, x);\n        si = h2(x, y, Ni);\n\n        claim_I1(I, Secret, si);\n        claim_I2(I, Niagree, R, si);\n    }\n\n    role R {\n        const ikR, pkR;  // Private and public keys of R\n        var eskR;        // Ephemeral session key\n        var x, y;        // Computed values\n        var Nr;          // Nonce generated by R\n        var sr;          // Session key\n\n        recv_1(I, R, Nr, y);\n        x = p(g, ikR, eskR); \n        send_2(R, I, x);\n        sr = h2(x, y, Nr);\n\n        claim_R1(R, Secret, sr);\n        claim_R2(R, Niagree, I, sr);\n    }\n}"]], "SPDL-1/needham-schroeder-sk.spdl": [[true, "protocol NeedhamSchroederSymmetricKeyProtocol {\n\n    // Role: Initiator\n    role I {\n        const I, R, S : Agent;\n        var Ni, Nr : Nonce;\n        var Kir : SymmetricKey;\n\n        send_1( I, S, {I, R, Ni} );\n        \n        receive_2( S, I, {R, Ni, Kir}_Kis );\n        \n        send_3( I, R, {I, Ni, Kir}_Krs );\n        \n        receive_4( R, I, {Nr}_Kir );\n        \n        send_5( I, R, {Nr}_Kir );\n\n        // Security claims\n        claim_I: Secret(Kir);\n        claim_I: Alive;\n        claim_I: WeakAgree;\n    }\n\n    // Role: Responder\n    role R {\n        const R, S, I : Agent;\n        var Ni, Nr : Nonce;\n        var Kir : SymmetricKey;\n        \n        receive_3( I, R, {I, Ni, Kir}_Krs );\n\n        send_4( R, I, {Nr}_Kir );\n\n        receive_5( I, R, {Nr}_Kir );\n\n        // Security claims\n        claim_R: Secret(Kir);\n        claim_R: Alive;\n        claim_R: WeakAgree;\n    }\n\n    // Role: Server\n    role S {\n        const S : Agent;\n        const I, R : Agent;\n        var Ni : Nonce;\n        var Kir : SymmetricKey;\n\n        receive_1( I, S, {I, R, Ni} );\n\n        Kir = fresh();\n        \n        send_2( S, I, {R, Ni, Kir}_Kis );\n\n        // No specific claims for server in this protocol.\n    }\n}"]], "SPDL-1/nsl3.spdl": [[true, "// Needham-Schroeder-Lowe Protocol\nprotocol Needham-Schroeder-Lowe(I, R)\n{\n    role I\n    {\n        // Declaration of initial variables and keys\n        fresh ni: Nonce;  // Initiator's fresh nonce\n        const I_ID: Agent;  // Identity of the initiator\n        var nr: Nonce;  // Responder's nonce\n        const pkR: PublicKey(R);  // Public key of responder\n        const pkI: PublicKey(I);  // Public key of initiator\n\n        send_1(I, R, {I_ID, ni}pkR);  // Step 1: I -> R\n\n        recv_2(R, I, {ni, nr, R_ID}pkI);  // Step 2: R -> I\n        send_3(I, R, {nr}pkR);  // Step 3: I -> R\n\n        // Claims made by Initiator\n        claim(secret, ni);  // Claim about the secrecy of ni\n        claim(secret, nr);  // Claim about the secrecy of nr\n        claim(Niagree);  // Agreement claim between I and R\n        claim(Nisynch);  // Synchronization claim between I and R\n    }\n\n    role R\n    {\n        // Declaration of initial variables and keys\n        fresh nr: Nonce;  // Responder's fresh nonce\n        const R_ID: Agent;  // Identity of the responder\n        var ni: Nonce;  // Initiator's nonce\n        const pkR: PublicKey(R);  // Public key of responder\n        const pkI: PublicKey(I);  // Public key of initiator\n\n        recv_1(I, R, {I_ID, ni}pkR);  // Step 1: I -> R\n        send_2(R, I, {ni, nr, R_ID}pkI);  // Step 2: R -> I\n\n        recv_3(I, R, {nr}pkR);  // Step 3: I -> R\n\n        // Claims made by Responder\n        claim(secret, ni);  // Claim about the secrecy of ni\n        claim(secret, nr);  // Claim about the secrecy of nr\n        claim(Niagree);  // Agreement claim between R and I\n        claim(Nisynch);  // Synchronization claim between R and I\n    }\n}"]], "SPDL-1/nuts-auth.spdl": [[true, "// Protocol: NUTSAuth\n// Roles: Gateway Server (GS), Satellite (Sat)\n\n// Define shared functions\nfunction KDF(Ra, Rb, k) : SessionKey;\n\n// Types\nconst Cmd, SAprop, SA, Ack, Mac;\ntype Nonce;\n\n// Shared key between Gateway Server and Satellite\nconst k_GS_Sat;\n\n// Role: Gateway Server\nprotocol NUTSAuth_GS(GS, Sat)\n{\n    var Rb : Nonce;\n    var Ra : Nonce;\n    var Cmd1, Cmd2 : Cmd;\n    var Ks : SessionKey;\n    \n    secret(k_GS_Sat, [GS, Sat]);\n    generate(Rb);  // GS generates its nonce\n\n    // Key Exchange and Mutual Authentication\n    send_1(GS, Sat, {Rb, MAC(Rb, k_GS_Sat)});\n    recv_2(Sat, GS, {Ra, MAC(Ra, k_GS_Sat)});\n\n    send_3(GS, Sat, {SAprop, MAC(SAprop, k_GS_Sat)});\n    recv_4(Sat, GS, {SA, MAC(SA, k_GS_Sat)});\n\n    // Session key derivation\n    Ks = KDF(Ra, Rb, k_GS_Sat);\n    secret(Ks, [GS, Sat]);\n\n    // Command Transmission\n    send_5(GS, Sat, {Cmd1, MAC(Cmd1, Ks)});\n    recv_6(Sat, GS, {Ack, MAC(Ack, Ks)});\n\n    send_7(GS, Sat, {Cmd2, MAC(Cmd2, Ks)});\n    recv_8(Sat, GS, {Ack, MAC(Ack, Ks)});\n\n    claim(GS, Alive);\n    claim(GS, Secret(Ks));\n    claim(GS, Weakagree);\n    claim(GS, Niagree);\n    claim(GS, Nisynch);\n}\n\n// Role: Satellite\nprotocol NUTSAuth_Sat(GS, Sat)\n{\n    var Rb : Nonce;\n    var Ra : Nonce;\n    var Cmd1, Cmd2 : Cmd;\n    var Ks : SessionKey;\n\n    secret(k_GS_Sat, [GS, Sat]);\n    generate(Ra);  // Sat generates its nonce\n\n    // Key Exchange and Mutual Authentication\n    recv_1(GS, Sat, {Rb, MAC(Rb, k_GS_Sat)});\n    send_2(Sat, GS, {Ra, MAC(Ra, k_GS_Sat)});\n\n    recv_3(GS, Sat, {SAprop, MAC(SAprop, k_GS_Sat)});\n    send_4(Sat, GS, {SA, MAC(SA, k_GS_Sat)});\n\n    // Session key derivation\n    Ks = KDF(Ra, Rb, k_GS_Sat);\n    secret(Ks, [GS, Sat]);\n\n    // Command Transmission\n    recv_5(GS, Sat, {Cmd1, MAC(Cmd1, Ks)});\n    send_6(Sat, GS, {Ack, MAC(Ack, Ks)});\n\n    recv_7(GS, Sat, {Cmd2, MAC(Cmd2, Ks)});\n    send_8(Sat, GS, {Ack, MAC(Ack, Ks)});\n\n    claim(Sat, Alive);\n    claim(Sat, Secret(Ks));\n    claim(Sat, Weakagree);\n    claim(Sat, Niagree);\n    claim(Sat, Nisynch);\n}"]], "SPDL-1/oakley-a.spdl": [[true, "protocol oakley_a(I, R)\n{\n    role I\n    {\n        var\n            Ci, Ni: Nonce;\n            Gi: Ticket;\n            AlgList: Text;\n            skI: PrivateKey;\n            Cr, Nr: Nonce;\n            Gr: Ticket;\n\n        send_1(I, R, Ci, g(I, Ci), AlgList, I, R, Ni, Sign(skI, {Ci, g(I, Ci), AlgList, I, R, Ni}));\n\n        receive_2(R, I, Cr, Ci, g(R, Cr), Sign(skR, {Cr, Ci, g(R, Cr)}));\n\n        send_3(I, R, Ci, Cr, Ni, Nr, Sign(skI, {Ci, Cr, Ni, Nr}));\n        \n        claim_I(SKR, KDF(Ni, Nr, Hash(Gi, Gr)));\n        claim_I(Alive);\n        claim_I(Weakagree);\n    }\n\n    role R\n    {\n        var\n            Cr, Nr: Nonce;\n            Gr: Ticket;\n            skR: PrivateKey;\n            Ci, Ni: Nonce;\n            Gi: Ticket;\n            AlgList: Text;\n\n        receive_1(I, R, Ci, g(I, Ci), AlgList, I, R, Ni, Sign(skI, {Ci, g(I, Ci), AlgList, I, R, Ni}));\n\n        send_2(R, I, Cr, Ci, g(R, Cr), Sign(skR, {Cr, Ci, g(R, Cr)}));\n\n        receive_3(I, R, Ci, Cr, Ni, Nr, Sign(skI, {Ci, Cr, Ni, Nr}));\n\n        claim_R(SKR, KDF(Ni, Nr, Hash(Gi, Gr)));\n        claim_R(Alive);\n        claim_R(Weakagree);\n    }\n}"]], "SPDL-1/pkmv2rsacorrected.spdl": [[true, "// PKMv2-RSA protocol in SPDL for Scyther analysis\n\n// Define constants for identities\nconst MS, BS;\n\n// Protocol model with two roles: Mobile Station (MS) and Base Station (BS)\n\n// Role: Mobile Station (MS)\nrole MS {\n    // Variables\n    fresh msrand;        // Random nonce generated by MS\n    fresh said;          // Session identifier\n    const BS;            // Identity of the Base Station\n    secret skMS;         // Private key of MS\n    pubkey pkMS;         // Public key of MS\n\n    // First message: MS sends its random nonce, session ID, and identity signed\n    send_1( {msrand, said, MS}skMS );\n\n    // Second message: MS receives from BS\n    recv_2( {msrand, bsrand, {prepak}pkMS, BS}skBS );\n    \n    // Third message: MS responds to BS\n    send_3( {bsrand, BS}skMS );\n\n    // Claims by MS\n    claim_niagree(Niagree);    // Agreement on nonce\n    claim_niagree(Nisynch);    // Synchronization\n    claim_skr(SKR);            // Knowledge of pre-master secret prepak\n}\n\n// Role: Base Station (BS)\nrole BS {\n    // Variables\n    const MS;             // Identity of the Mobile Station\n    fresh msrand;         // Random nonce received from MS\n    fresh bsrand;         // New random nonce generated by BS\n    fresh prepak;         // Pre-master secret\n    secret skBS;          // Private key of BS\n    pubkey pkBS;          // Public key of BS\n\n    // First message: BS receives from MS\n    recv_1( {msrand, said, MS}skMS );\n\n    // Second message: BS sends to MS\n    send_2( {msrand, bsrand, {prepak}pkMS, BS}skBS );\n    \n    // Third message: BS receives response from MS\n    recv_3( {bsrand, BS}skMS );\n\n    // Claims by BS\n    claim_niagree(Niagree);    // Agreement on nonce\n    claim_niagree(Nisynch);    // Synchronization\n    claim_skr(SKR);            // Knowledge of pre-master secret prepak\n}\n\n// Protocol goals and security properties\ngoal {\n    authentication(MS, BS);\n    mutual_authentication(MS, BS);\n    secrecy(prepak);\n    no_replay();\n    integrity();              // Integrity of exchanged messages\n}"]], "SPDL-1/athena-breaker.spdl": [[true, "# Athena Breaker Protocol Description in SPDL\n\n# Define the agents involved in the protocol\nagent I;\nagent R;\n\n# Declare the public and private (secret) keys for each agent\nconst pkI, pkR: PublicKey;\nsecret skI, skR: SecretKey;\n\n# Define the inverse key relationships\ninversekeys(pkI, skI);\ninversekeys(pkR, skR);\n\n# Define a fresh nonce for each session initiated by the Initiator\nfresh ni: Nonce;\n\n# Role definitions\nrole Initiator\n  vars\n    T: Ticket;  # Ticket variable to store Responder's response\n  played_by I\n  {\n    send_1(I, R, {| I, ni |}pkR);\n    claim_secret(I, ni, [ni]);  # Initiator's claim of nonce secrecy\n    recv_2(R, I, T);  # Expecting response with Ticket from Responder\n  }\n\nrole Responder\n  vars\n    T: Ticket;\n  played_by R\n  {\n    recv_1(I, R, {| I, ni |}pkR);\n    # Processing received data\n    T := {I, ni};  # Generating Ticket from nonce and identity\n    send_2(R, I, T);\n  }\n\n# Protocol composition, defining how roles interconnect\ncomposition protocol\n{\n  role Initiator\n  role Responder\n}\n\n# Security claims to verify\ngoal secrecy\n{\n  secret(ni, [I, R]);  # Ensure secrecy of nonce ni from external agents\n}"]], "SPDL-1/pqr.spdl": [[true, "// PKMv2-RSA Protocol in SPDL\n\n// Role: Mobile Station (MS)\nrole MS {\n  fresh msrand : Nonce;\n  var bsrand : Nonce;\n  var prepak : Key;\n  var tek0, tek1, tek2, tek3 : Key;\n  var said : Text;\n  const c : Text;\n\n  send_1(MS, BS, {msrand, said}skMS); // Step 1\n  recv_2(BS, MS, {bsrand, prepak, skBS}pkBS); // Step 2\n  send_3(MS, BS, ack(bsrand, skBS)); // Step 3\n  recv_4(BS, MS, hash(bsrand, prepak, said, skBS)); // Step 4\n  send_5(MS, BS, hash(msrand, bsrand, akid, skMS)); // Step 5\n  recv_6(BS, MS, {tek0, tek1, tek2, tek3}hash(prepak, skBS)); // Step 6\n  send_7(MS, BS, hash(c, prepak, skMS)); // Step 7\n}\n\n// Role: Base Station (BS)\nrole BS {\n  var msrand : Nonce;\n  fresh bsrand : Nonce;\n  fresh prepak : Key;\n  var tek0, tek1, tek2, tek3 : Key;\n  var akid : Text;\n  const c : Text;\n\n  recv_1(MS, BS, {msrand, said}skMS); // Step 1\n  send_2(BS, MS, {bsrand, prepak, skBS}pkBS); // Step 2\n  recv_3(MS, BS, ack(bsrand, skBS)); // Step 3\n  send_4(BS, MS, hash(bsrand, prepak, said, skBS)); // Step 4\n  recv_5(MS, BS, hash(msrand, bsrand, akid, skMS)); // Step 5\n  send_6(BS, MS, {tek0, tek1, tek2, tek3}hash(prepak, skBS)); // Step 6\n  recv_7(MS, BS, hash(c, prepak, skMS)); // Step 7\n  send_8(BS, MS, {c, tek0, tek1, tek2, tek3}hash(prepak, skBS)); // Step 8\n}\n\n// Security claims\nclaim_MS(Niagree, prepak, tek0, tek1, tek2, tek3);\nclaim_MS(Nisynch, prepak, tek0, tek1, tek2, tek3);\n\nclaim_BS(Niagree, prepak, tek0, tek1, tek2, tek3);\nclaim_BS(Nisynch, prepak, tek0, tek1, tek2, tek3);\nclaim_BS(SKR, prepak, tek0, tek1, tek2, tek3);\n\n// End of PKMv2-RSA Protocol"]], "SPDL-1/protocol0-symm.spdl": [[true, "protocol protocol0symm(I, R)\n{\n    role I\n    {\n        const idI, idR: Text;\n        var  ni: Nonce;\n        const k: SymmetricKey;\n\n        send_1(I, R, {idI, ni}k);\n\n        claim_I1(I, Secret, ni);\n    }\n\n    role R\n    {\n        const idI, idR: Text;\n        var  ni: Nonce;\n        const k: SymmetricKey;\n\n        recv_1(I, R, {idI, ni}k);\n\n        claim_R1(R, Secret, ni);\n    }\n}"]], "SPDL-1/Signed-DH.spdl": [[true, "protocol TwoMoveDiffieHellman(UM) {\n\n  const g1, g2, h1, h2 : Function;\n\n  role Initiator {\n    fresh s, x : Nonce;\n    var y : Nonce;\n    var R : Agent;\n    const I : Agent;\n\n    send_1(I, R, s, g1(x));\n    recv_2(R, I, s, g2(y), h1(I, R, s, g2(y), g1(x)));\n    claim_i(SKR, crypto(g2(y), x));\n  }\n\n  role Responder {\n    fresh y : Nonce;\n    var s : Nonce;\n    var x : Nonce;\n    var I : Agent;\n    const R : Agent;\n\n    recv_1(I, R, s, g1(x));\n    claim_r(SID, s);\n    send_2(R, I, s, g2(y), h1(I, R, s, g2(y), g1(x)));\n    claim_r(SKR, crypto(g1(x), y));\n  }\n}"]], "SPDL-1/skeme-basic.spdl": [[true, "/*\n  SPDL Code for the SKEME Basic Protocol\n  Implemented for analysis with the Scyther tool.\n*/\n\nprotocol SKEME_Basic {\n  role Initiator {\n    // Declaration of Variables\n    var I, R : Agent\n    var Ni, i : Nonce\n    var Gr, prfResult, sessionKey : Function\n\n    // Step 1: Initiator to Responder\n    send_1(I, R, {I, Ni}_pk(R), g(i))\n\n    // Claims before step 2\n    claim_I1(I, Running, R)\n\n    // Step 2: Responder to Initiator\n    recv_2(R, I, {Nr}_pk(I), g(r), prf(Ni, Nr, Gr))\n    \n    // Step 3: Final message from Initiator\n    send_3(I, R, prf(Ni, Nr, Gr, I, R))\n\n    // Claims after step 3\n    claim_I2(I, SKR, sessionKey)\n    claim_I3(I, Alive, R)\n    claim_I4(I, WeakAgree, R)\n  }\n\n  role Responder {\n    // Declaration of Variables\n    var I, R : Agent\n    var Nr, r : Nonce\n    var Gi, prfResult, sessionKey : Function\n\n    // Step 1: Initiator to Responder\n    recv_1(I, R, {I, Ni}_pk(R), g(i))\n\n    // Step 2: Responder to Initiator \n    send_2(R, I, {Nr}_pk(I), g(r), prf(Ni, Nr, Gi))\n\t\n\t// Claims before step 3\n    claim_R1(R, Running, I)\n\n    // Step 3: Final message from Initiator\n    recv_3(I, R, prf(Ni, Nr, Gi, I, R))\n\n    // Claims after step 3\n    claim_R2(R, SKR, sessionKey)\n    claim_R3(R, Alive, I)\n    claim_R4(R, WeakAgree, I)\n  }\n}"]], "SPDL-1/soph.spdl": [[true, "/* Protocol Definition for soph Protocol */\nroles\n{\n  /* Initiator Role */\n  role I\n  {\n    fresh ni;                // Fresh nonce generated by Initiator\n    const pkR;               // Responder's public key\n    sends_1(R, {I, ni}pkR);  // Message 1: Initiator sends identity and nonce encrypted with responder's public key\n    receives_2(R, ni);       // Message 2: Initiator receives the nonce back from responder\n    claim_3(Niagree);        // Claim: Initiator claims nonce agreement with responder\n  }\n\n  /* Responder Role */\n  role R\n  {\n    const pkR;               // Responder's public key\n    receives_1(I, {I, ni}pkR); // Message 1: Responder receives identity and nonce encrypted with its public key\n    sends_2(I, ni);         // Message 2: Responder sends back the nonce received from initiator\n  }\n}"]], "SPDL-1/sts-modified.spdl": [[true, "protocol STS_Modified {\n\n  role Initiator {\n    var I, R : Agent;\n    var Gi, Gr : Ticket;\n    var i, r : Nonce;\n    var SigI, SigR : Signature;\n\n    // Claim variables\n    var KDF_I : Key;\n\n    send_1(I, R, g(i));\n    recv_2(R, I, g(r), SigR);\n    send_3(I, R, SigI);\n\n    claim(I, SKR);\n    claim(I, Alive);\n    claim(I, Weakagree);\n  }\n\n  role Responder {\n    var I, R : Agent;\n    var Gi, Gr : Ticket;\n    var i, r : Nonce;\n    var SigI, SigR : Signature;\n\n    // Claim variables\n    var KDF_R : Key;\n\n    recv_1(I, R, g(i));\n    send_2(R, I, g(r), SigR);\n    recv_3(I, R, SigI);\n\n    claim(R, SKR);\n    claim(R, Alive);\n    claim(R, Weakagree);\n  }\n\n  // Functions and claims\n  function g(Nonce) : Ticket;\n  function h(Ticket, Nonce) : Key;\n  function KDF(Key) : Key;\n\n  // Signature generation\n  function sign(Agent, List) : Signature;\n\n  // Sessions\n  session S1 (I, R, Gi, Gr, i, r);\n  session S2 (I, R, Gi, Gr, i, r);\n}"]], "SPDL-1/th-1par2.spdl": [[true, "protocol nsl3th1(I, R)\n{\n  role I {\n    send_1(I, R, {P1, I, ni}_pubKey(R));\n    recv_2(R, I, {nr}_pubKey(I));\n    recv_3(R, I, {P1, ni, nr, R}_pubKey(I));\n    send_4(I, R, {P1, nr}_pubKey(R));\n    \n    claim_Synch_I: Nisynch;\n  }\n\n  role R {\n    recv_1(I, R, {P1, I, ni}_pubKey(R));\n    send_2(R, I, {nr}_pubKey(I));\n    send_3(R, I, {P1, ni, nr, R}_pubKey(I));\n    recv_4(I, R, {P1, nr}_pubKey(R));\n    \n    claim_Synch_R: Nisynch;\n  }\n}\n\nprotocol nsl3th2(I, R)\n{\n  role I {\n    send_1(I, R, {P2, I, ni}_pubKey(R));\n    recv_2(R, I, {nr}_pubKey(I));\n    recv_3(R, I, {P2, ni, nr, R}_pubKey(I));\n    send_4(I, R, {P2, nr}_pubKey(R));\n    \n    claim_Synch_I: Nisynch;\n  }\n\n  role R {\n    recv_1(I, R, {P2, I, ni}_pubKey(R));\n    send_2(R, I, {nr}_pubKey(I));\n    send_3(R, I, {P2, ni, nr, R}_pubKey(I));\n    recv_4(I, R, {P2, nr}_pubKey(R));\n    \n    claim_Synch_R: Nisynch;\n  }\n}"]], "SPDL-1/tls-BM-1.spdl": [[false, "```\nprotocol TLS_Protocol\n{\n    role Alice\n    {\n        fresh na : Nonce;\n        fresh pmk : Key;\n        send_1( A, B, na );\n        \n        recv_2( B, A, nb );\n        \n        send_3( A, B, {pmk}pk(B), \n                      {hash(na, nb, {pmk}pk(B))}sk(A), \n                      {hash(na, nb, {pmk}pk(B), {hash(na, nb, {pmk}pk(B))}sk(A))}hash(pmk, na, nb) );\n\n        claim( A, Secret, hash(pmk, na, nb) );\n        claim( A, Nisynch );\n    }\n\n    role Bob\n    {\n        fresh nb : Nonce;\n        recv_1( A, B, na );\n\n        send_2( B, A, nb );\n        \n        recv_3( A, B, {pmk}pk(B), \n                      {hash(na, nb, {pmk}pk(B))}sk(A), \n                      {hash(na, nb, {pmk}pk(B), {hash(na, nb, {pmk}pk(B))}sk(A))}hash(pmk, na, nb) );\n                      \n        send_4( B, A, na, nb, {pmk}pk(B), \n                      {hash(na, nb, {pmk}pk(B))}sk(A), \n                      {hash(na, nb, {pmk}pk(B), {hash(na, nb, {pmk}pk(B))}sk(A))}hash(pmk, na, nb) );\n\n        claim( B, Secret, hash(pmk, na, nb) );\n        claim( B, Nisynch );\n    }\n}\n```"]], "SPDL-1/wmf-brutus.spdl": [[true, "protocol wmfbrutus\n{\n  role A\n  {\n    var S, B : Agent;\n    var kab : SesKey;\n    fresh kab : SesKey;\n\n    send_1(A,S, A, { B,kab }k(A,S));\n  }\n\n  role B\n  {\n    var S, A : Agent;\n    var kab : SesKey;\n\n    recv_2(S,B, { A, kab }k(B,S));\n    claim_3(B, Secret, kab);\n  }\n\n  role S\n  {\n    var A, B : Agent;\n    var kab : SesKey;\n\n    recv_1(A,S, A, { B,kab }k(A,S));\n    send_2(S,B, { A, kab }k(B,S));\n  }\n}"]], "SPDL-1/yahalom-ban-paulson.spdl": [[true, "// Yahalom Protocol (BAN Modified Version)\n\nprotocol YahalomBan (A, B, S)\n{\n    // Roles and their knowledge\n    role A\n    {\n        fresh na;    // Nonce generated by A\n        var nb;      // Nonce from B\n        fresh kab;   // Session key\n\n        send_1( A, B, na );\n        recv_2( S, B, na, nb, {akb, {na, nb, kab} }_kas );\n        send_3( B, {A, kab}_kbs, {nb}_kab );\n        \n        secret( kab, [A, B] );\n    }\n\n    role B\n    {\n        fresh nb;    // Nonce generated by B\n        var na;      // Nonce from A\n        var kab;     // Session key\n        \n        recv_1( A, na );\n        send_2( S, B, na, nb );\n        recv_3( A, {A,kab}_kbs, {nb}_kab );\n        \n        secret( kab, [A, B] );\n    }\n\n    role S\n    {\n        var na;        // Nonce from A\n        var nb;        // Nonce from B\n        fresh kab;     // Session key\n        \n        recv_2( B, na, nb );\n        send_2( A, {akb,{na, nb, kab}}_kas );\n    }\n}\n\n// Scenario\nusertype Agent;\n\nconst A, B, S : Agent;\nconst kbs, kas : Function;\n\n-- Keys set for encryption/decryption\npassword (A, kas);\npassword (B, kbs);"]], "SPDL-1/Authentication_CRCBAC.spdl": [[true, "// Define roles: Client and Gateway\nrole D {\n    // Declare local variables and nonces\n    fresh T1, Tr, N, Vpr: Nonce;\n    secret Krs, Ts, z, ID, PW: Variable;\n\n    // Step 1: Client generates nonces and computes verification value\n    Vpr = H(XOR(z, Ts));\n    e = XOR(Krs, Concat(Vpr, N));\n\n    // Send message to Gateway with encrypted values and nonces\n    send_1(D, GW, {e, AID, Tr, T1});\n\n    // Claim security properties\n    claim D secret(PW);          // Password secrecy\n    claim D alive;               // Client alive claim\n    claim D weakagree;           // Weak agreement on session keys\n    claim D commit(N);           // Commitment to nonce N\n    claim D running(N, Tr, T1);  // Client running claim\n}\n\nrole GW {\n    // Declare local variables and nonces\n    fresh Npr, T2: Nonce;\n\n    // Step 2: Gateway receives message and computes response values\n    recv_1(D, GW, {e, AID, Tr, T1});\n    \n    Npr = H(N);  // Compute derived nonce using hash function\n\n    // Send response message to Client\n    send_2(GW, D, {Npr, T2});\n\n    // Claim security properties\n    claim GW alive;              // Gateway alive claim\n    claim GW weakagree;          // Weak agreement on session keys\n    claim GW commit(Npr);        // Commitment to derived nonce Npr\n    claim GW running(Npr, T2);   // Gateway running claim\n}\n\n// Protocol security properties\nprotocol SecureAuthentication {\n    role D;\n    role GW;\n}"]], "SPDL-1/andrew-ban-concrete.spdl": [[true, "/*\n BAN Concrete Andrew Secure RPC Protocol Specification in SPDL\n*/\n\n// Main protocol definition\nprotocol BANConcreteAndrewSecureRPC(I, R) {\n\n    // Role: Initiator (I)\n    role I {\n        fresh ni: Nonce;          // Fresh nonce generated by I\n        var nr: Nonce;            // Nonce from R\n        var kir: SessionKey;      // Session key for communication with R\n\n        // Message 1: I -> R : I, ni\n        send_1(I, R, I, ni);\n        \n        // Message 2: R -> I : {ni, kir}_k(I,R)\n        recv_2(R, I, {ni, kir}_k(I,R));\n        \n        // Message 3: I -> R : {ni}_kir\n        send_3(I, R, {ni}_kir);\n\n        // Claim the session key is known\n        claim_I1(I, Secret, kir);\n        \n        // Claim that the session key is fresh\n        claim_I3(I, Empty, Fresh, kir);\n        \n        // Claim that the session is not synchronized\n        claim_I2(I, Nisynch);\n\n        // Message 6: R -> I : nr\n        recv_6(R, I, nr);\n    }\n\n    // Role: Responder (R)\n    role R {\n        fresh nr: Nonce;          // Fresh nonce generated by R\n        fresh kir: SessionKey;    // Fresh session key for communication with I\n        var ni: Nonce;            // Nonce from I\n\n        // Message 1: I -> R : I, ni\n        recv_1(I, R, I, ni);\n        \n        // Message 2: R -> I : {ni, kir}_k(I,R)\n        send_2(R, I, {ni, kir}_k(I,R));\n        \n        // Message 3: I -> R : {ni}_kir\n        recv_3(I, R, {ni}_kir);\n\n        // Claim the session key is known\n        claim_R1(R, Secret, kir);\n        \n        // Claim that the session key is fresh\n        claim_R3(R, Empty, Fresh, kir);\n        \n        // Claim that the session is not synchronized\n        claim_R2(R, Nisynch);\n\n        // Message 6: R -> I : nr\n        send_6(R, I, nr);\n    }\n}"]], "SPDL-1/andrew.spdl": [[true, "protocol AndrewSecureRPC(I, R) {\n    // Initial knowledge\n    role I\n    {\n        fresh ni;   \n        var nr, nr2;\n        const I, R, kir;\n        secret k(I, R);\n\n        send_1(I, R, I, {ni}_k(I, R));\n        recv_2(R, I, {succ(ni), nr}_k(I, R));\n        send_3(I, R, {succ(nr)}_k(I, R));\n        \n        // Claims\n        claim_I1(I, Secret, kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Niagree);\n        claim_I4(I, Fresh, kir);\n    }\n\n    role R\n    {\n        fresh nr, kir, nr2;   \n        var ni;\n        const I, R;\n        secret k(I, R);\n\n        recv_1(I, R, I, {ni}_k(I, R));\n        send_2(R, I, {succ(ni), nr}_k(I, R));\n        recv_3(I, R, {succ(nr)}_k(I, R));\n        send_4(R, I, {kir, nr2}_k(I, R));\n\n        // Claims\n        claim_R1(R, Secret, kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Niagree);\n        claim_R4(R, Fresh, kir);\n    }\n}"]], "SPDL-1/asymmetric-encryption.spdl": [[true, "protocol SecrecyProtocol(I, R)\n{\n    role Initiator\n    {\n        var ni: Nonce;\n        var pkR: PublicKey;\n\n        sent_message_1: ni = fresh();\n        pkR = pk(R);\n        claim_I_ni_secret: Secret(ni);\n\n        send_1(I, {I, ni}pkR);\n    }\n\n    role Responder\n    {\n        var ni: Nonce;\n        var I: Agent;\n        var skR: PrivateKey;\n\n        skR = inv(pk(R));\n\n        receive_1(I, {I, ni}pkR);\n        claim_R_ni_secret: Secret(ni);\n\n        // Decrypt the message\n        {I, ni} = decrypt({I, ni}pkR, skR);\n\n        claim secret_ni: Secret(ni);\n    }\n}"]], "SPDL-1/bakatar.spdl": [[true, "protocol Bakatar0(A, B, S)\n{\n    role A\n    {\n        fresh K: MySecret;\n        send_1(A, S, {B, K}_k(A, S));\n\n        /* Security claims by Alice */\n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n\n    role S\n    {\n        recv_1(A, S, EncryptedMsg1);\n        decrypt EncryptedMsg1 as {B, K}_k(A, S);\n        send_2(S, B, {A, K}_k(B, S));\n\n        recv_3(B, S, EncryptedMsg2);\n        decrypt EncryptedMsg2 as {A, h(K)}_k(B, S);\n        send_4(S, A, {B, h(K)}_k(A, S));\n    }\n\n    role B\n    {\n        recv_2(S, B, EncryptedMsg3);\n        decrypt EncryptedMsg3 as {A, K}_k(B, S);\n        send_3(B, S, {A, h(K)}_k(B, S));\n\n        /* Security claims by Bob */\n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n\n    consth(B, h(K));\n}"]], "SPDL-1/bke-broken.spdl": [[true, "/* Bilateral Key Exchange with Public Key (BKEPK) */\n\nprotocol BKEPK(Alice, Bob) {\n    // Agent declarations\n    role Alice {\n        var NI:Nonce;\n        var NR:Nonce;\n        var kab:SymmetricKey;\n\n        // Public and private keys of Alice and Bob\n        const pkA:PublicKey;\n        const skA:PrivateKey;\n        const pkB:PublicKey;\n        const skB:PrivateKey;\n\n        // Alice initiates the protocol\n        send_1(Alice, Bob, {NI, Bob}pkB);\n\n        // Alice receives Bob's response\n        recv_2(Bob, Alice, {hash(NI), NR, Bob, kab}pkA);\n\n        // Alice confirms key establishment\n        send_3(Alice, Bob, {hash(NR)}kab);\n\n        // Secrecy claim for shared key\n        claim(Alice, Secret, kab);\n    }\n\n    role Bob {\n        var NI:Nonce;\n        var NR:Nonce;\n        var kab:SymmetricKey;\n\n        // Public and private keys of Alice and Bob\n        const pkA:PublicKey;\n        const skA:PrivateKey;\n        const pkB:PublicKey;\n        const skB:PrivateKey;\n\n        // Bob receives Alice's initial message\n        recv_1(Alice, Bob, {NI, Bob}pkB);\n\n        // Bob responds with his nonce and a shared key\n        send_2(Bob, Alice, {hash(NI), NR, Bob, kab}pkA);\n\n        // Final confirmation message from Alice\n        recv_3(Alice, Bob, {hash(NR)}kab);\n\n        // Secrecy claim for shared key\n        claim(Bob, Secret, kab);\n    }\n}\n\n/* Define the agents involved */\nagent Alice;\nagent Bob;\nagent Eve; // Untrusted agent\n\n/* Define the environment with potential eavesdropper */\nenvironment {\n    intruder = Eve;\n}"]], "SPDL-1/boyd-1.spdl": [[true, "protocol BoydKeyAgreementProtocol(I, R, S)\n{\n  const Macseed, Sessionkey;\n  function m, unm, f;\n  \n  inversekeys(m, unm);\n  \n  // Role: Initiator (I)\n  role I\n  {\n    fresh ni: Nonce;\n    var nr: Nonce;\n    var sk: Sessionkey;\n    var mac: Macseed;\n    \n    send_1(I, S, ni);\n    recv_2(R, I, [m(nr, ni, sk, f(mac))]);\n    send_3(I, R, [unm(m(nr, sk, ni), mac)]);\n    \n    claim_i1(I, Secret, sk);\n    claim_i2(I, Agreement, ni, nr);\n    claim_i3(I, Sync, sk);\n  }\n  \n  // Role: Responder (R)\n  role R\n  {\n    fresh nr: Nonce;\n    var ni, sk: Sessionkey;\n    var mac: Macseed;\n    \n    recv_1(I, S, ni);\n    send_2(R, I, [m(nr, ni, sk, f(mac))]);\n    recv_3(I, R, [unm(m(nr, sk, ni), mac)]);\n    \n    claim_r1(R, Secret, sk);\n    claim_r2(R, Agreement, ni, nr);\n    claim_r3(R, Sync, sk);\n  }\n  \n  // Role: Server (S)\n  role S\n  {\n    var ni: Nonce;\n    var nr: Nonce;\n    var sk: Sessionkey;\n    \n    recv_1(I, S, ni);\n    send_2(S, R, [m(nr, ni, sk)]);\n    \n    claim_s1(S, Secret, sk);\n  }\n}"]], "SPDL-1/broken1-1.spdl": [[true, "//\n// Protocol: broken1\n//\n\n// Default skey function is for symmetric encryption\nskey(k)\n\n// Constants and initial knowledge\nconst PlainSight\nconst HelloWorld\nconst HelloServer\n\n// Roles\n\nrole Initiator(I, R, S)\n{\n    var I: Agent;\n    var R: Agent;\n    var S: Agent;\n\n    fresh k: SKey;    \n\n    // Message 1: I -> R: PlainSight, {HelloWorld, I, R}_k\n    send_1(I, R, PlainSight, {HelloWorld, I, R}_k);\n\n    // Message 2: I -> S: {HelloServer, I, S}_k\n    send_2(I, S, {HelloServer, I, S}_k);\n}\n\nrole Responder(I, R, S)\n{\n    var I: Agent;\n    var R: Agent;\n    var S: Agent;\n\n    fresh k: SKey;    \n\n    // Message 3: S -> R: {HelloWorld, S, I, R}_k\n    recv_3(S, R, {HelloWorld, S, I, R}_k);\n\n    // Message 1: I -> R: PlainSight, {HelloWorld, I, R}_k\n    recv_1(I, R, PlainSight, {HelloWorld, I, R}_k);\n\n    // Claim: Secret (PlainSight)\n    claim(R, Secret, PlainSight);\n}\n\nrole Server(I, R, S)\n{\n    var I: Agent;\n    var R: Agent;\n    var S: Agent;\n\n    fresh k: SKey;    \n\n    // Message 2: I -> S: {HelloServer, I, S}_k\n    recv_2(I, S, {HelloServer, I, S}_k);\n\n    // Message 3: S -> R: {HelloWorld, S, I, R}_k\n    send_3(S, R, {HelloWorld, S, I, R}_k);\n}\n\n// Protocol Executions\nexecutions\n{\n    // Instance of the protocol run\n    new I, R, S\n    run Initiator(I, R, S);\n    run Responder(I, R, S);\n    run Server(I, R, S);\n}"]], "SPDL-1/bunava-1-3.spdl": [[true, "// Scyther formal analysis code for the Buttyan Nagy Vajda Protocol\n\n// Define the protocol\nprotocol ButtyanNagyVajda(R0, R1, R2) {\n\n  // Step 1: Role R0 (Alice) sends nonce n0 to R1 (Bob)\n  send_1(R0, R1, n0)\n  \n  // Step 2: Role R1 (Bob) receives nonce n0, generates n1, and sends {R1, n0} encrypted to R2 (Charlie)\n  recv_1(R0, R1, n0)\n  send_2(R1, R2, n1, enc({R1, n0}, k(R1, R2)))\n  \n  // Step 3: Role R2 (Charlie) receives Bob's message, generates n2, and sends encrypted message back to R0\n  recv_2(R1, R2, n1, enc({R1, n0}, k(R1, R2)))\n  send_3(R2, R0, n2, enc({R2, n1, R1, n0}, k(R0, R2)))\n  \n  // Step 4: Role R0 (Alice) receives message and sends final confirmation to R1 (Bob)\n  recv_3(R2, R0, n2, enc({R2, n1, R1, n0}, k(R0, R2)))\n  send_4(R0, R1, enc({R0, n2, R2, n1}, k(R0, R1)))\n  \n  // Step 5: Role R1 (Bob) receives confirmation and sends message to R2 (Charlie)\n  recv_4(R0, R1, enc({R0, n2, R2, n1}, k(R0, R1)))\n  send_5(R1, R2, enc({R1, R0, n2}, k(R1, R2)))\n  \n  // Step 6: Role R2 (Charlie) receives the final message from R1 (Bob)\n  recv_5(R1, R2, enc({R1, R0, n2}, k(R1, R2)))\n\n  // Claims for security properties\n  claim(R0, Niagree, R1)\n  claim(R0, Nisynch, R1)\n  claim(R1, Niagree, R0)\n  claim(R1, Nisynch, R0)\n  claim(R2, Niagree, R1)\n  claim(R2, Nisynch, R1)\n}\n\n// Define the key usage in the protocol\nconst k: Function;\n\n// Define the knowledge each agent has\nknowledge(R0, k(R0, R1), k(R0, R2))\nknowledge(R1, k(R1, R0), k(R1, R2))\nknowledge(R2, k(R2, R0), k(R2, R1))\n\n// Define the message roles\nexecutions {\n  ButtyanNagyVajda(R0, R1, R2)\n}"]], "SPDL-1/carkey-broken-limited.spdl": [[true, "protocol carkeybrokenlim(I, R) {\n\n    role I {\n        var ni: Nonce;\n\n        send_1(I, R, I, R, ni);\n    }\n\n    role R {\n        recv_1(I, R, I, R, ni);\n\n        claim_2(R, Nisynch);\n    }\n\n}"]], "SPDL-1/carkey-ni2.spdl": [[true, "protocol carkeyni(I, R)\n{\n    role Initiator\n    {\n        var Ni;\n\n        send_1(I, R, {R, Ni}sk(I));\n        send_2(I, R, {R, Ni}sk(I));\n        \n        claim_I_Ni synch;\n    }\n\n    role Responder\n    {\n        var Ni;\n\n        recv_1(I, R, {R, Ni}sk(I));\n        recv_2(I, R, {R, Ni}sk(I));\n        \n        claim_R_Ni synch;\n    }\n}\n\nconst nc;\n\nkeypair(pk, sk);\n\nagent Alice, Bob, Eve;\n\nuntrusted(Eve, sk(Eve));\n\nexecsteps\n{\n    execute(carkeyni(Alice, Bob));\n    execute(carkeyni(Bob, Alice));\n    execute(carkeyni(Alice, Eve));\n    execute(carkeyni(Eve, Alice));\n}"]], "SPDL-1/base.spdl": [[true, "protocol BaseCaseProtocol(M, C, B)\n\ntypes\n  UID, Timestamp, Amount, Nonce\n\nfunctions\n  pk, sk: UID -> Sk\n  hash: {UID, Amount, Nonce} -> TransactionID\n  Sm, Sc, Sb: {UID, Amount, Nonce, Signature} -> Signature\n\nconstants\n  a: Amount\n  IDm, IDc: UID\n\nrole M\n  vars\n    r: Nonce\n    IDt: TransactionID\n    ts: Timestamp\n\n  send_1(M, C, IDm, a, r, Sm)\n  recv_3(B, M, IDt, a, r, ts, Sb)\n\n  claims\n    alive\n    nisynch\n    niagree\n\nrole C\n  vars\n    r: Nonce\n    IDt: TransactionID\n\n  recv_1(M, C, IDm, a, r, Sm)\n  send_2(C, B, IDc, IDm, a, r, Sm, Sc)\n\n  recv_3(B, C, IDt, a, r, ts, Sb)\n\n  claims\n    alive\n    nisynch\n    niagree\n\nrole B\n  vars\n    r: Nonce\n    IDt: TransactionID\n    ts: Timestamp\n\n  recv_2(C, B, IDc, IDm, a, r, Sm, Sc)\n  send_3(B, M, IDt, a, r, ts, Sb)\n  send_3(B, C, IDt, a, r, ts, Sb)\n\n  claims\n    alive\n    nisynch\n    niagree\n\nend protocol"]], "SPDL-1/ccitt509-3.spdl": [[true, "protocol CCITT_X509v3(I, R)\n{\n    role I\n    {\n        var Ta, Na, Xa, Ya : Nonce;\n        var Nb, Yb : Nonce;\n        var Tb : Timestamp;\n\n        send_1(I, R, Ta, Na, R, Xa, {Ya}pk(R), sign(I, Ta, Na, R, Xa, {Ya}pk(R)));\n\n        recv_2(R, I, Tb, Nb, I, Na, Xb, {Yb}pk(I), sign(R, Tb, Nb, I, Na, Xb, {Yb}pk(I)));\n\n        send_3(I, R, {Nb}sk(I));\n\n        claim_I1(Nisynch);\n        claim_I2(Secret, Ya);\n        claim_I3(Secret, Yb);\n    }\n\n    role R\n    {\n        var Tb, Nb, Xb, Yb : Nonce;\n        var Ta : Timestamp;\n        var Na, Xa, Ya : Nonce;\n        \n        recv_1(I, R, Ta, Na, R, Xa, {Ya}pk(R), sign(I, Ta, Na, R, Xa, {Ya}pk(R)));\n\n        send_2(R, I, Tb, Nb, I, Na, Xb, {Yb}pk(I), sign(R, Tb, Nb, I, Na, Xb, {Yb}pk(I)));\n\n        recv_3(I, R, {Nb}sk(I));\n\n        claim_R1(Nisynch);\n        claim_R2(Secret, Yb);\n        claim_R3(Secret, Ya);\n    }\n}"]], "SPDL-1/denning-sacco-lowe.spdl": [[true, "protocol DenningSaccoLowe(KIR, KI, KR, KE) {\n\n  role Initiator (I, R, S)\n  {\n    var SessionKey, TimeStamp, Nr;\n    fresh Ni;\n    \n    send_1(I, S, {I, R, Ni});\n    recv_2(S, I, {R, KIR, T, W}ek(S, I));\n    \n    send_3(I, R, W);\n    recv_4(R, I, {Nr}ek(KIR));\n    \n    send_5(I, R, {Nr}ek(KIR));\n    \n    claim_I1(I, R, \"Agree\");\n    claim_I2(I, R, \"Alive\");\n    claim_I3(I, R, \"Secret\", KIR);\n    claim_I4(I, R, \"Weakagree\");\n  }\n\n  role Responder (R, I, S)\n  {\n    var SessionKey, TimeStamp, Ni;\n    fresh Nr;\n    \n    recv_3(I, R, W);\n    \n    send_4(R, I, {Nr}ek(KIR));\n    recv_5(I, R, {Nr}ek(KIR));\n    \n    claim_R1(R, I, \"Agree\");\n    claim_R2(R, I, \"Alive\");\n    claim_R3(R, I, \"Secret\", KIR);\n    claim_R4(R, I, \"Weakagree\");\n  }\n\n  role Server (S, I, R)\n  {\n    var SessionKey, TimeStamp, Ni;\n    fresh KIR, T;\n    \n    recv_1(I, S, {I, R, Ni});\n    \n    send_2(S, I, {R, KIR, T, {Ni, I, R, KIR, T}ek(S, R)}ek(S, I));\n  }\n}"]], "SPDL-1/exchange.spdl": [[true, "protocol Protocol1(I, R) {\n\n  // Define roles\n  role I {\n    // Fresh nonce generated by Initiator\n    fresh ni : Nonce;\n\n    // Initiator sends Message 1\n    send_1(R, {R, ni}pk(R));\n\n    // Initiator receives Message 2 and decrypts\n    recv_2(R, {ni, nr, R}pk(I));\n\n    // Initiator sends Message 3\n    send_3(R, {nr}pk(R));\n\n    // Initiator Claims\n    claim_i1(I, Secret, ni);\n    claim_i2(I, Secret, nr);\n    claim_i3(I, Nisynch);\n  }\n\n  role R {\n    // Fresh nonce generated by Responder\n    fresh nr : Nonce;\n\n    // Responder receives Message 1 and decrypts\n    recv_1(I, {R, ni}pk(R));\n\n    // Responder sends Message 2\n    send_2(I, {ni, nr, R}pk(I));\n\n    // Responder receives Message 3\n    recv_3(I, {nr}pk(R));\n\n    // Responder Claims\n    claim_r1(R, Secret, ni);\n    claim_r2(R, Secret, nr);\n    claim_r3(R, Nisynch);\n  }\n}"]], "SPDL-1/f4.spdl": [[true, "protocol f4 {\n\n  /* Define roles */\n  role I {\n    sent_nonce: nonce;\n    received_nonce: nonce;\n    skI: symmetric key;\n    \n    step send_1: {\n      send_received_nonce_to_R(received_nonce)\n    }\n    \n    step send_2: {\n      encrypted_nonce = encrypt(received_nonce, skI);\n      send_encrypted_nonce_to_R(encrypted_nonce);\n    }\n    \n    claim_i1: {\n      claim(Reachable)\n    }\n  }\n  \n  role R {\n    nr: nonce;\n    skR: symmetric key;\n    received_encrypted_nonce: message;\n  \n    step send_!1: {\n      nr = generate_nonce();\n      send(nr, I);\n    }\n    \n    step recv_!3: {\n      received_encrypted_nonce = receive(I);\n      encrypted_nonce = encrypt(received_encrypted_nonce, skR);\n      nested_encrypted_nonce = encrypt(encrypted_nonce, skR);\n      nested_encrypted_nonce = encrypt(nested_encrypted_nonce, skR);\n      nested_encrypted_nonce = encrypt(nested_encrypted_nonce, skR);\n    }\n  }\n}\n\n/* Security assumptions */\n/* The protocol analysis by Scyther tool should be executed with particular parameters to uncover potential security issues, \n   especially -m2 for multiple sessions and -r4 for examining specific security properties. */"]], "SPDL-1/f5.spdl": [[true, "// Protocol f5: Formal specification in SPDL (Scyther Protocol Description Language)\n// This protocol showcases the need for extensive testing to identify vulnerabilities through challenge-response mechanics.\n\nprotocol f5 {\n\n    // Types declaration:\n    // Define agents: Initiator (I) and Responder (R)\n    role I {\n        // Using several local variables including nonces\n        var Ni: Nonce;   // Nonce used by the responder\n        var Sign: Message; // Signed message\n\n        // Private keys\n        var skiI: PrivateKey; // Private key belonging to Initiator\n\n        // Declare the state conditions\n        claim_I_Reached: Reachable;\n\n        // Protocol steps:\n        // Initiator receives a nonce from the Responder\n        recv_1(R, Ni);\n\n        // Initiator signs the received nonce using its private key\n        Sign := {Ni}skiI;\n        \n        // Sends the signed nonce back to Responder\n        send_2(R, Sign);\n\n        // Wait for the nested structure encrypted response from Responder\n        recv_3(R, EncryptedResponse);\n\n        // Assuming a function to check if EncryptedResponse is correctly nested i.e., encrypted multiple times using skR\n        // If correct, reach the desired state\n        claim_I_Reached: Reachable;\n    }\n\n    role R {\n        // Variables include generated nonce\n        var Ni: Nonce;   // Nonce generated by Responder\n        var EncryptedResponse: Message; // Nested encrypted message\n\n        // Private key\n        var skiR: PrivateKey; // Private key belonging to Responder\n\n        // Protocol steps:\n        // Responder generates a fresh nonce and sends to Initiator\n        generate Ni;\n        send_1(I, Ni);\n\n        // Wait to receive the signed nonce from Initiator\n        recv_2(I, Sign);\n\n        // Nested encryption operation using responder\u2019s secret key multiple times\n        // Sample nested response generation (test only as actual nesting logic will depend on implementation details):\n        EncryptedResponse := {{Ni}skiR{Ni}skiR};\n\n        // Sends the nested encrypted response back to Initiator\n        send_3(I, EncryptedResponse);\n    }\n}"]], "SPDL-1/gong-nonce-1.spdl": [[true, "protocol GongNonce(I, R, S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        fresh ki: KeyPart;\n        var nr, kr: Nonce;\n\n        send_1(I, R, {I, R, ni});\n        recv_2(S, I, {S, I, R, ni, kr}_k_I_S);\n        send_3(I, S, {I, S, ki, R, nr}_k_I_S);\n\n        claim_I1(I, Secret, ki);\n        claim_I2(I, Secret, kr);\n        claim_I3(I, Ni, ni, NoSync);\n        claim_I4(I, Ni, nr, NoSync);\n        claim_I5(I, Ni, ni, NoAgreement);\n        claim_I6(I, Ni, nr, NoAgreement);\n    }\n\n    role R\n    {\n        var ni : Nonce;\n        fresh nr: Nonce;\n        fresh kr: KeyPart;\n        var ki : KeyPart;\n\n        recv_1(I, R, {I, R, ni});\n        send_2(R, S, {R, S, nr, {R, kr, I, ni}_k_R_S});\n        recv_4(S, R, {S, I, ki, nr}_k_R_S);\n\n        claim_R1(R, Secret, ki);\n        claim_R2(R, Secret, kr);\n        claim_R3(R, Ni, ni, NoSync);\n        claim_R4(R, Ni, nr, NoSync);\n        claim_R5(R, Ni, ni, NoAgreement);\n        claim_R6(R, Ni, nr, NoAgreement);\n    }\n\n    role S\n    {\n        var ni : Nonce;\n        var nr : Nonce;\n        var kr : KeyPart;\n        var ki : KeyPart;\n\n        recv_2(R, S, {R, S, nr, {R, kr, I, ni}_k_R_S});\n        send_1(S, I, {S, I, R, ni, kr}_k_I_S, nr);\n        recv_3(I, S, {I, S, ki, R, nr}_k_I_S);\n        send_4(S, R, {S, I, ki, nr}_k_R_S);\n    }\n}"]], "SPDL-1/ikev1-psk-m.spdl": [[true, "protocol IKEv1-PSK-M(DH, SWAP, O)\n{\n    role DH\n    {\n        const g, h; // Hash functions\n        var I, R: Agent;\n        var i, r: Nonce;\n        fresh dhValue: Nonce; // DH value generated\n\n        send_1(DH, DH1, g(dhValue));\n        recv_2(DH, DH2, h(g(dhValue), r));\n        \n        claim_DH(Running, I, R);\n        claim_DH(Commit, I, R, dhValue);\n    }\n\n    role SWAP\n    {\n        const prf; // Pseudorandom function\n        var I, R: Agent;\n        var i, r, Ni, Nr, Ci, Cr: Nonce;\n        \n        send_1(SWAP, SWAP1, prf(Ni, Ci, I));\n        recv_2(SWAP, SWAP2, prf(Nr, Cr, R));\n        \n        claim_SWAP(Alive, I, R);\n        claim_SWAP(Weakagree, I, R, Ni, Nr);\n    }\n\n    role O\n    {\n        const prf;\n        var I, R: Agent;\n        var i, r, Ni, Nr, Ci, Cr: Nonce;\n        \n        send_1(O, O1, prf(Ni, g(i)));\n        recv_2(O, O2, prf(Nr, h(r)));\n        \n        claim_O(Alive, I, R);\n        claim_O(Commit, I, R, Ci, Cr);\n        claim_O(SKR, I, R, prf(Ni, Nr));\n    }\n}"]], "SPDL-1/ikev1-sig-a2.spdl": [[true, "// Protocol: IKEv1-SIG-A2\n// Roles: Initiator (I) and Responder (R)\n\nprotocol IKEv1_SIG_A2 {\n    // Define principal identity variables\n    I, R: Agent;\n    \n    // Define cryptographic key and public key variables\n    skI, skR: SK;\n    Gi, Gr: PublicKey;\n    \n    // Define nonce variables\n    Ci, Cr, Ni, Nr: Nonce;\n\n    // Define other cryptographic function variables\n    list: Hash;\n    prf: Function;\n    KDF: Function;\n\n    /* Initial communication step initiated by I to R */\n    send_1(I, R, Ci, list, Gi, Ni, I);\n\n    /* Response from R to I including cryptographic calculations */\n    send_2(R, I, (Ci, Cr), algo, Gr, Nr, R, {prf(Ni, Nr, h(Gr), Gr, Gi, Cr, Ci, list, R)}skR);\n\n    /* Initiator claims and sends computed values */\n    claim(I, Running, R, Ni, Nr, Gi, Gr, Ci, Cr);\n    send_3(I, R, (Ci, Cr), \n           {{prf(Ni, Nr, h(Gr), Gi, Gr, Ci, Cr, list, I)}skI}KDF(Ni, Nr, h(Gr), Ci, Cr));\n\n    /* Responder claims running state */\n    claim(R, Running, I, Ni, Nr, Gi, Gr, Ci, Cr);\n\n    // Claims for security properties\n    claim(I, SKR, {prf(Ni, Nr, h(Gr), Gi, Gr)});\n    claim(R, SKR, {prf(Ni, Nr, h(Gr), Gi, Gr)});\n    claim(I, Alive);\n    claim(R, Alive);\n    claim(I, WeakAgreement, R, Ni, Nr, Gi, Gr);\n    claim(R, WeakAgreement, I, Ni, Nr, Gi, Gr);\n    claim(I, Commit, R, Ni, Nr, Ci, Cr, list, skI);\n    claim(R, Commit, I, Ni, Nr, Ci, Cr, list, skR);\n}"]], "SPDL-1/ikev2-child-nopfs.spdl": [[true, "protocol ikev2-child-nopfs\n{\n    roles\n    {\n        role DH\n        {\n            fresh Nd;\n            var Ni, Nr: Nonce;\n            var DHval: Number;\n            var Hash: HashFunction;\n\n            send_1(DHv, Hash(Ni, Nd));\n            recv_2(Hash(Nr, Nd));\n        }\n\n        role SWAP\n        {\n            fresh Nk;\n            var K1, K2: SymmetricKey;\n\n            recv_1(K1);\n            send_2(K2);\n        }\n\n        role O\n        {\n            fresh Ni, Nr;\n            var SA3: SessionID;\n            var Key: SymmetricKey;\n\n            send_1({Ni, SA3}Key);\n            recv_2({Nr}Key);\n        }\n\n        role I\n        {\n            fresh Ni;\n            var R: Agent;\n            var SA3: SessionID;\n            var Key: SymmetricKey;\n\n            send_1({Ni, SA3}Key);\n            recv_2({Nr}Key);\n\n            claim_I_running: Running;\n            claim_I_skr: SKR;\n            claim_I_alive: Alive;\n            claim_I_weakagreement: WeakAgreement;\n            claim_I_commit: Commit;\n        }\n\n        role R\n        {\n            fresh Nr;\n            var I: Agent;\n            var SA3: SessionID;\n            var Key: SymmetricKey;\n\n            recv_1({Ni, SA3}Key);\n            send_2({Nr}Key);\n\n            claim_R_running: Running;\n            claim_R_skr: SKR;\n            claim_R_alive: Alive;\n            claim_R_weakagreement: WeakAgreement;\n            claim_R_commit: Commit;\n        }\n    }\n}"]], "SPDL-1/iso26-tag.spdl": [[true, "protocol ISO_IEC_9798_2_with_Tags\n{\n    role A\n    {\n        var Na, Nb, Kab: Nonce;\n        var A, B, P: Agent;\n\n        send_1(A, B, {Na, A}_kab(B));\n        \n        recv_2(B, A, {Nb, B}_kab(A));\n        \n        send_3(A, P, {Na, Nb, B}_kp(A));\n        \n        recv_4(P, A, {Kab, Nb}_kp(P));\n        \n        send_5(A, B, {Nb, Kab}_kab(B));\n        \n        claim_A(Running, B, Na);\n        claim_A(Commit, B, Kab);\n        claim_A(Secret, Kab, [A, B]);\n        claim_A(Alive);\n    }\n\n    role B\n    {\n        var Na, Nb, Kab: Nonce;\n        var A, B, P: Agent;\n\n        recv_1(A, B, {Na, A}_kab(B));\n        \n        send_2(B, A, {Nb, B}_kab(A));\n        \n        recv_5(A, B, {Nb, Kab}_kab(B));\n        \n        claim_B(Running, A, Nb);\n        claim_B(Commit, A, Kab);\n        claim_B(Secret, Kab, [A, B]);\n        claim_B(Alive);\n        claim_B(WeakAgree, A, Nb);\n    }\n\n    role P\n    {\n        var Na, Nb, Kab: Nonce;\n        var A, B, P: Agent;\n\n        recv_3(A, P, {Na, Nb, B}_kp(A));\n        \n        send_4(P, A, {Kab, Nb}_kp(P));\n    }\n}"]], "SPDL-1/BCNP-1.spdl": [[true, "protocol BCNP-1(I, R)\n{\n    role Initiator\n    {\n        var Kap, Kbp: Nonce;\n        var SKR: SymmetricKey;\n\n        send_1(I, R, {Kap}pk(R));\n\n        recv_2(R, I, {Kbp}pk(I));\n\n        SKR = xor(Kap, Kbp);\n\n        claim_I1(\"SessionKey\", SKR);\n    }\n\n    role Responder\n    {\n        var Kap, Kbp: Nonce;\n        var SKR: SymmetricKey;\n\n        recv_1(I, R, {Kap}pk(R));\n\n        send_2(R, I, {Kbp}pk(I));\n\n        SKR = xor(Kap, Kbp);\n\n        claim_R1(\"SessionKey\", SKR);\n    }\n}"]], "SPDL-1/isoiec-9798-2-3.spdl": [[true, "protocol keysymm-23\n{\n  role A \n  {\n    var T1, T2: Nonce;\n    var Text1, Text2: Ticket;\n    var K: Symmetric_key;\n\n    send_1(A, B, Text1.enc(K), T1);\n    receive_2(B, A, Text2.enc(K), T2);\n      \n    claim_A1: Alive;\n    claim_A2: Commit(B, T1, T2);\n  }\n\n  role B\n  {\n    var T1, T2: Nonce;\n    var Text1, Text2: Ticket;\n    var K: Symmetric_key;\n\n    receive_1(A, B, Text1.enc(K), T1);\n    send_2(B, A, Text2.enc(K), T2);\n\n    claim_B1: Alive;\n    claim_B2: Commit(A, T1, T2);\n  }\n}\n\nprotocol isoiec-9798-2-3\n{\n  role A \n  {\n    var TNA, TNB: Nonce;\n    var Text1, Text2, Text3, Text4: Ticket;\n    var KAB: Symmetric_key;\n\n    send_1(A, B, {Text1, TNA}.enc(KAB), Text2);\n    receive_2(B, A, {Text3, TNB}.enc(KAB), Text4);\n\n    claim_A1: Running(B, TNB);\n    claim_A2: Commit(B, TNA, TNB);\n  }\n\n  role B\n  {\n    var TNA, TNB: Nonce;\n    var Text1, Text2, Text3, Text4: Ticket;\n    var KBA: Symmetric_key;\n\n    receive_1(A, B, {Text1, TNA}.enc(KBA), Text2);\n    send_2(B, A, {Text3, TNB}.enc(KBA), Text4);\n\n    claim_B1: Running(A, TNA);\n    claim_B2: Commit(A, TNA, TNB);\n  }\n}"]], "SPDL-1/jfki-core.spdl": [[true, "protocol JFKICore(I, R)\n{\n    // Declarations\n    role I\n    {\n        // Nonces and cryptographic materials\n        var i, Ni: Nonce;\n        var id_I: Identity;\n        var Gi: Ticket;\n\n        var Nr: Nonce;\n        var id_R: Identity;\n        var Gr: Ticket;\n        var SigI: Signature;\n        \n        // Messages\n        send_1(I, R, {Ni, id_I, gi = g(i)});\n        recv_2(R, I, {Nr, Ni, id_R, Gr, sigR});\n        \n        // Compute the signature and session key based on received values\n        SigI = sign(Nr, Ni, id_I, id_R, Gr);\n        SKI = KDF(Ni, Nr, Gi, id_I, id_R);\n        \n        // Final message with confirmation\n        send_3(I, R, {Nr, Ni, SigI});\n        \n        // Claims\n        claim_i1(I, Alive);\n        claim_i2(I, WeakAgree);\n        claim_i3(I, SKR, SKI);\n    }\n\n    role R\n    {\n        // Nonces and cryptographic materials\n        var r, Nr: Nonce;\n        var id_R: Identity;\n        var Gr: Ticket;\n\n        var Ni: Nonce;\n        var id_I: Identity;\n        var Gi: Ticket;\n        var SigR: Signature;\n        \n        // Messages\n        recv_1(I, R, {Ni, id_I, gi});\n        \n        // Create fresh nonces and derive session key\n        Gr = g(r);\n        SigR = sign(Nr, Ni, id_R, id_I, Gi);\n        SKR = KDF(Ni, Nr, Gr, id_I, id_R);\n        \n        send_2(R, I, {Nr, Ni, id_R, Gr, SigR});\n        recv_3(I, R, {Nr, Ni, SigI});\n        \n        // Claims\n        claim_r1(R, Alive);\n        claim_r2(R, WeakAgree);\n        claim_r3(R, SKR, SKR);\n    }\n\n    const id_I, id_R: Identity;\n    const g, h: HashFunction;\n    const KDF: KeyDerivationFunction;\n}"]], "SPDL-1/kaochow-v3.spdl": [[true, "protocol KaoChowV3(I, R, S) {\n\n  // Define the necessary message fields and constants\n  const Fresh, Compromised;\n  type SessionKey, ExpiredTimeStamp, TimeStamp;\n  \n  // Message fields for each role\n  var I, R, S: Principal;\n  var ni, nr: Nonce;\n  var kir, kt, T2: SessionKey;\n  var tr: TimeStamp;\n\n  // Initiator Role\n  role I {\n    fresh ni;\n    \n    // Step 1: I sends its identity and nonce to S\n    send_1(I, S, {I, R, ni});\n\n    // Step 4: I receives a message from R\n    receive_4(R, I, {ni, nr, kir, kt, T2});\n    \n    // Step 5: I sends confirmation to R\n    send_5(I, R, {nr, kir, T2});\n\n    // Claims by the Initiator\n    claim_I1:I(NotSynchronize, R);\n    claim_I2:I(Agree, kir, kt, R);\n    claim_I3:I(Secret, kir);\n    claim_I4:I(Fresh, kir);\n  }\n\n  // Responder Role\n  role R {\n    fresh nr;\n    fresh tr;\n    \n    // Step 2: R receives a message from S\n    receive_2(S, R, {I, R, ni, kir, kt, T2});\n    \n    // Step 3: R sends a message to I \n    send_3(R, I, {ni, nr, kir, kt, T2});\n    \n    // Step 6: R receives confirmation from I\n    receive_6(I, R, {nr, kir});\n\n    // Claims by the Responder\n    claim_R1:R(NotSynchronize, I);\n    claim_R2:R(Agree, kir, kt, I);\n    claim_R3:R(Secret, kir);\n    claim_R4:R(Fresh, kir);\n  }\n\n  // Server Role\n  role S {\n    \n    // Step 1: S receives a message from I\n    receive_1(I, S, {I, R, ni});\n    \n    // Step 2: S sends a message to R\n    send_2(S, R, {I, R, ni, kir, kt, T2});\n  }\n}"]], "SPDL-1/kaochow.spdl": [[true, "// Participants of the protocol\nprotocol KaoChowAuthentication(I, R, S)\n{\n    // Knowledge: public keys and symmetric keys\n    // PKS denotes public key of the server, SKS is the symmetric key with the session key server\n    knowledge I: {pk(I), sk(I), pk(R), pk(S), SKIR}\n    knowledge R: {pk(R), sk(R), pk(I), pk(S), SKIR}\n    knowledge S: {pk(S), sk(S), pk(I), pk(R), SKIR}\n\n    // Nonces: Generated by Initiator and Responder\n    var ni: Nonce\n    var nr: Nonce\n    var kir: SessionKey\n\n    // Step 1: Initiation\n    I -> S: I, R, {ni}pk(S)\n\n    // Step 2: Response\n    S -> R: I, {ni}SKIR\n    R -> I: {T, {ni}SKIR, {nr}SKIR}pk(S)\n\n    // Step 3: Finalization\n    I -> R: {nr}pk(R)\n\n    // Claims\n    // Synchronization claim\n    claim_I: Nisynch(I, R)\n    claim_R: Nisynch(R, I)\n\n    // Agreement claim\n    claim_I: Niagree(I, R, I, ni, nr, kir)\n    claim_R: Niagree(R, I, R, ni, nr, kir)\n\n    // Secrecy and Freshness of SessionKey\n    claim_I: Secret(I, kir)\n    claim_R: Secret(R, kir)\n    claim_I: Empty(Fresh, kir)\n    claim_R: Empty(Fresh, kir)\n}"]], "SPDL-1/localclaims.spdl": [[true, "// Role definitions and key infrastructure\nrole Initiator(I, R : Agent, pkR : PublicKey)\n{\n    var ni : Nonce;\n    \n    // Generate a fresh nonce\n    fresh ni;\n    \n    // Step 1 - Initiator sends encrypted nonce to Responder\n    send_1(I, R, {ni}pkR);\n    \n    // Security claim by Initiator\n    claim_i1(I, Secret, ni);\n}\n\nrole Responder(R, I : Agent, skR : PrivateKey)\n{\n    var ni : Nonce;\n    \n    // Step 1 - Responder receives and decrypts nonce\n    recv_1(I, R, {ni}pkR);\n    ni := decrypt({ni}pkR, skR);\n    \n    // Security claim by Responder\n    claim_r1(R, Secret, ni);\n}\n\n// Protocol execution environment\nprotocol LocalClaims\n{\n    // Participants in the protocol\n    // I - Initiator, R - Responder\n    // pkR - Responder's public key, skR - Responder's private key\n  \n    role Initiator(I, R, pk(R))\n    role Responder(R, I, sk(R))\n}\n\n// Key relationships definition\nequation inversekeys(pk, sk);\n\n// Initialize the environment and roles\ninitialize\n{\n    // Declare agents and their key pairs\n    const I, R : Agent;\n    const pkI, pkR : PublicKey;\n    const skI, skR : PrivateKey;\n    \n    // Define inverse key relations\n    inversekeys(pkI, skI);\n    inversekeys(pkR, skR);\n    \n    // Bind the roles with the appropriate keys\n    role initiatorRole = Initiator(I, R, pkR);\n    role responderRole = Responder(R, I, skR);\n}"]], "SPDL-1/needham-schroeder.spdl": [[true, "// Needham-Schroeder Public Key Protocol in SPDL\n\n// Define the roles in the protocol\nrole Initiator {\n    // Initialize variables\n    fresh Ni: Nonce;  // Initiator's nonce\n    var PKR: PublicKey; // Responder's public key\n    var Nr: Nonce; // Responder's nonce\n    var S: Agent; // Server entity\n    \n    // 1. Initiation\n    send_1(S, R, {I, Ni});\n}\n\nrole Server {\n    const SKS: PrivateKey; // Server's private key\n    var PKR: PublicKey; // Responder's public key\n    const R: Agent;  // Responder entity\n    var I: Agent; // Initiator entity\n    var Ni: Nonce; // Initiator's nonce\n    \n    // 2. Key Distribution\n    recv_1(I, R, {I, Ni});\n    send_2(I, {PKR, R}SKS);\n}\n\nrole Responder {\n    const I: Agent;  // Initiator entity\n    const SKR: PrivateKey; // Responder's private key\n    var PKI: PublicKey;  // Initiator's public key\n    var Ni: Nonce; // Initiator's nonce\n    fresh Nr: Nonce;  // Responder's nonce\n    \n    // 3. Session Key Creation\n    recv_3(I, {Ni, I}PKR);\n    send_4(I, {Ni, Nr}PKI);\n}\n\nrole Initiator {\n    var PKR: PublicKey; \n    var Nr: Nonce; \n    \n    // 4. Responder's Acknowledgment\n    recv_4(R, {Ni, Nr}PKI);\n    \n    // 5. Final Confirmation\n    send_5(R, {Nr}PKR);\n    \n    claim_Synch(I, R);\n    claim_Secret(Ni, Nr);\n}\n\nrole Responder {\n    var Nr: Nonce;\n    \n    // Final receipt\n    recv_5(I, {Nr}PKR);\n    \n    claim_Synch(R, I);\n}\n\n// End of Needham-Schroeder Public Key Protocol SPDL description"]], "SPDL-1/ns3-1.spdl": [[true, "/* Needham-Schroeder Protocol in SPDL */\n\nprotocol NeedhamSchroeder(I, R)\n{\n    // Step 1: Initiator to Responder\n    message_1: I -> R : {ni, I}pk(R);\n\n    // Step 2: Responder to Initiator\n    message_2: R -> I : {ni, nr}pk(I);\n\n    // Step 3: Initiator to Responder\n    message_3: I -> R : {nr}pk(R);\n}\n\nrole Initiator(I, R)\n{\n    // Step 1\n    fresh ni;\n    send_1(I, R, {ni, I}pk(R));\n\n    // Step 2\n    recv_2(R, I, {ni, nr}pk(I));\n\n    // Step 3\n    send_3(I, R, {nr}pk(R));\n\n    // Claims for Initiator\n    claim_i1(I, Secret, ni);\n    claim_i2(I, Secret, nr);\n    claim_i4(I, Niagree);\n    claim_i5(I, Nisynch);\n}\n\nrole Responder(R, I)\n{\n    // Step 1\n    recv_1(I, R, {ni, I}pk(R));\n    \n    // Step 2\n    fresh nr;\n    send_2(R, I, {ni, nr}pk(I));\n\n    // Step 3\n    recv_3(I, R, {nr}pk(R));\n\n    // Claims for Responder\n    claim_r1(R, Secret, ni);\n    claim_r2(R, Secret, nr);\n    claim_r4(R, Niagree);\n    claim_r5(R, Nisynch);\n}"]], "SPDL-1/nsl3-broken.spdl": [[true, "Protocol Needham-Schroeder-Lowe_Broken\n\nRoles\n  Initiator\n    I : Agent\n    R : Agent\n    ni : Nonce\n    nr : Nonce\n    \n    Init\n      I = Initiator\n      R = Responder\n\n    Step 1\n      new ni\n      send to R: {I, ni}pk(R)\n      \n    Step 2\n      recv from R: {ni, nr, R}pk(I)\n      \n    Step 3\n      send to R: {nr}pk(R)\n\n    End\n      Claim Secret(ni)\n      Claim Alive\n      Claim Commit(R, ni, nr)\n      Claim Secret(nr)\n\n  Responder\n    R : Agent\n    I : Agent\n    ni : Nonce\n    nr : Nonce\n    \n    Init\n      R = Responder\n      I = Initiator\n\n    Step 1\n      recv from I: {I, ni}pk(R)\n      new nr\n\n    Step 2\n      send to I: {ni, nr, R}pk(I)\n      \n    Step 3\n      recv from I: {nr}pk(R)\n\n    End\n      Claim Secret(nr)\n      Claim Alive\n      Claim Commit(I, ni, nr)\n      Claim Secret(ni)\n\nEnd Protocol"]], "SPDL-1/onetrace-1.spdl": [[true, "protocol onetrace(I) {\n\n    role I {\n        var input : String;\n\n        // Initially, I receives a message from itself\n        recv_!1(I, I, input);\n\n        // Then, I sends a response message to itself\n        send_!2(I, I, 'Hallo');\n\n        // I receives another message from itself with updated input\n        recv_!3(I, I, input);\n\n        // Finally, I claims the input is secret\n        claim_4(I, Secret, input);\n    }\n}"]], "SPDL-1/otwayrees.spdl": [[true, "protocol OtwayReesProtocol(I, R, S)\n{\n    role I {\n        var Ni, Kir, M;\n        const I, R, S;\n\n        send_1(I, R, {I, R, Ni, M}K(S)); // Session Initialization\n\n        recv_4(R, I, {Kir, Ni}K(I)); // Key Confirmation\n        claim(I, Secret, Kir);\n        claim(I, Alive);\n        claim(I, Nisynch, R);\n    }\n\n    role R {\n        var Nr, Kir, Ni, M;\n        const I, R, S;\n\n        recv_1(I, R, {I, R, Ni, M}K(S)); // Response from Responder\n        send_2(R, S, {R, I, Ni, Nr, M}K(R)); // Forward to Server and process request\n\n        recv_3(S, R, {Kir, Nr, Ni, M}K(R)); // Receive session key from Server\n        send_4(R, I, {Kir, Ni}K(I)); // Forwarding session key to Initiator\n        claim(R, Secret, Kir);\n        claim(R, Alive);\n        claim(R, Nisynch, I);\n    }\n\n    role S {\n        var Kir, Ni, Nr, M;\n        const I, R, S;\n        \n        recv_2(R, S, {R, I, Ni, Nr, M}K(R)); // Key Generation and Sending to Initiator\n        generate(Kir); // Generate session key\n        send_3(S, R, {Kir, Nr, Ni, M}K(R)); // Forward key to Responder\n    }\n}"]], "SPDL-1/BKE-1.spdl": [[true, "protocol BKEPK(I, R)\n{\n    role I\n    {\n        var ni, nr, kir: Nonce;\n        var I, R: Agent;\n        var PK_I, PK_R: PublicKey;\n        \n        send_1(I, R, {ni, I}pk(R));\n        recv_2(R, I, {hash(ni), nr, R, kir}pk(I));\n        send_3(I, R, {hash(nr)}kir);\n        \n        claim_4(I, Secret, kir);\n    }\n    \n    role R\n    {\n        var ni, nr, kir: Nonce;\n        var I, R: Agent;\n        var PK_I, PK_R: PublicKey;\n        \n        recv_1(I, R, {ni, I}pk(R));\n        kir = fresh();\n        nr = fresh();\n        send_2(R, I, {hash(ni), nr, R, kir}pk(I));\n        recv_3(I, R, {hash(nr)}kir);\n        \n        claim_7(R, Secret, kir);\n    }\n}"]], "SPDL-1/pkmv2rsa.spdl": [[true, "protocol PKMv2_RSA {\n    // Define roles\n    role MS {\n        // Fresh nonces and session identifier\n        fresh msrand, said: Nonce;\n        role BS;\n\n        // Message 1: MS -> BS : {msrand, said, MS}_sk(MS)\n        send_1(BS, {msrand, said, MS}_sk(MS));\n\n        // Receive response from BS\n        receive_2(BS, {msrand, bsrand, prepak, MS}_sk(BS));\n\n        // Final step - send acknowledgment\n        send_3(BS, {bsrand}_sk(MS));\n\n        // Security Claims\n        claim( Niagree, BS, said );\n        claim( Nisynch, BS );\n    }\n    \n    role BS {\n        // Fresh nonce and pre-shared key\n        fresh bsrand: Nonce;\n        fresh prepak;\n        role MS;\n\n        // Receive initial message from MS\n        receive_1(MS, {msrand, said, MS}_sk(MS));\n        \n        // Message 2: BS -> MS : {msrand, bsrand, prepak, MS}_sk(BS)\n        send_2(MS, {msrand, bsrand, prepak, MS}_sk(BS));\n\n        // Final acknowledgment from MS\n        receive_3(MS, {bsrand}_sk(MS));\n\n        // Security Claims\n        claim( SKR, MS, prepak );\n        claim( Niagree, MS, said );\n    }\n}"]], "SPDL-1/pkmv2satek.spdl": [[true, "protocol PKMv2-SA-TEK(MS, BS)\n{\n  const akid;\n  const u, d;\n\n  // Hash functions declared\n  hashfunction prepak;\n  hashfunction hash;\n\n  role MS\n  {\n    // Generating fresh nonce for the session\n    fresh msrand;\n\n    // Step 1: Message received from BS\n    // Contains nonce from BS, identifier, and hash for authenticity\n    var bsrand;\n    var h;\n    recv_1(BS, msrand, {bsrand, akid, h});\n\n    // Step 2: Sending response back to BS\n    // Contains MS's nonce, nonce from BS, identifier, and a verified hash\n    send_2(BS, msrand, {msrand, bsrand, akid, h});\n\n    // Step 3: Receiving final message from BS\n    // Contains both nonces, identifier, and a hash of temporary encryption keys\n    var tek0, tek1;\n    recv_3(BS, msrand, {msrand, bsrand, akid, h, tek0, tek1});\n\n    // Security properties claimed by MS\n    claim(Niagree, msrand, bsrand);\n    claim(Nisynch);\n    claim(SKR, tek0);\n    claim(SKR, tek1);\n  }\n\n  role BS\n  {\n    // Generating fresh nonces and TEKs for the session\n    fresh bsrand, tek0, tek1;\n\n    // Step 1: Sending initial message to MS\n    // Contains BS's nonce, identifier, and hash for integrity\n    var h1;\n    send_1(MS, bsrand, {bsrand, akid, h1});\n\n    // Step 2: Receiving response from MS\n    // Validates nonce and hash for integrity\n    var msrand;\n    recv_2(MS, bsrand, {msrand, bsrand, akid, h1});\n\n    // Step 3: Sending final message to MS\n    // Includes both nonces and a hash of the TEKs\n    send_3(MS, bsrand, {msrand, bsrand, akid, h1, tek0, tek1});\n\n    // Security properties claimed by BS\n    claim(Niagree, msrand, bsrand);\n    claim(Nisynch);\n    claim(SKR, tek0);\n    claim(SKR, tek1);\n  }\n}"]], "SPDL-1/protocol0.spdl": [[true, "// Protocol: Secrecy Protocol Using Asymmetric Encryption\n// Roles: Initiator (I) and Responder (R)\n// Description: Ensures secrecy of nonce `ni` using asymmetric encryption\n\nprotocol SecrecyProtocol {\n\n  // Define the asymmetric key pair for R\n  const pkR, skR: PublicKey;\n\n  // Initiator Role\n  role I {\n    // Local variable for nonce\n    var ni: Nonce;\n\n    // Generate fresh nonce\n    ni = fresh();\n\n    // Encryption message format: {I, ni}pk(R)\n    message I1 {\n      sender: I;\n      receiver: R;\n      contents: encrypt(pkR, I, ni);\n    }\n\n    // Claim the nonce `ni` as secret after sending\n    secrecy claimI: ni;\n  }\n\n  // Responder Role\n  role R {\n    // Variable to store received nonce\n    var ni: Nonce;\n\n    // Receive message from Initiator\n    message I1 {\n      sender: I;\n      receiver: R;\n      contents: encrypt(pkR, I, ni);\n    }\n\n    // Decrypt message with private key skR\n    contents = decrypt(skR, I, ni);\n\n    // Claim the nonce `ni` as secret after receiving\n    secrecy claimR: ni;\n  }\n}"]], "SPDL-1/protocol1.spdl": [[true, "protocol protocol1(I, R)\n{\n    // Define roles\n    role Initiator\n    {\n        var ni, nr: Nonce;\n        var R: Agent;\n        \n        send_1(R, {R, ni}pk(R));\n        recv_2(R, {R, ni, nr}pk(I));\n        claim_i1(I, Secret, ni);\n        claim_i2(I, Secret, nr);\n        claim_i3(I, Nisynch);\n        send_3(R, {nr}pk(R));\n    }\n\n    role Responder\n    {\n        var ni, nr: Nonce;\n        var I: Agent;\n\n        recv_1(I, {R, ni}pk(R));\n        nr = fresh();\n        send_2(I, {R, ni, nr}pk(I));\n        claim_r1(R, Secret, ni);\n        claim_r2(R, Secret, nr);\n        claim_r3(R, Nisynch);\n        recv_3(I, {nr}pk(R));\n    }\n    \n    // Role instances binding\n    role Initiator(I, R) initiatorRole;\n    role Responder(R, I) responderRole;\n}"]], "SPDL-1/rsaplussatek.spdl": [[true, "protocol PKMv2-RSA(MS, BS) {\n\n  role MS {\n    // Initialize nonces and session parameters\n    fresh msrand, msrand': Nonce;\n    fresh said: SessionID;\n    fresh prepak: Key;\n    \n    // Step 1: MS to BS\n    send_1(MS, BS, {msrand, said, MS}sk(MS));\n\n    // Step 2: Receive response from BS\n    recv_2(BS, MS, {msrand, bsrand, {prepak, MS}pk(MS), BS}sk(BS));\n\n    // Step 3: Send back nonce bsrand\n    send_3(MS, BS, {bsrand}sk(MS));\n\n    // Step 5: Respond with integrity verification\n    fresh bsrand': Nonce;\n    openly hash_5: Hash;\n    send_5(MS, BS, msrand', bsrand', akid, hash(u, prepak, BS, MS, msrand', bsrand', akid));\n\n    // Claim agreement and synchronization\n    claim_rsai3(MS, Niagree);\n    claim_rsai4(MS, Nisynch);\n  }\n\n  role BS {\n    // Initialize nonces and session parameters\n    fresh bsrand, bsrand': Nonce;\n    fresh prepak: Key;\n\n    // Step 1: Receive initial message from MS\n    recv_1(MS, BS, {msrand, said, MS}sk(MS));\n\n    // Step 2: Response with prepak and identifier\n    send_2(BS, MS, {msrand, bsrand, {prepak, MS}pk(MS), BS}sk(BS));\n\n    // Step 4: Integrity verification using hash\n    openly hash_4: Hash;\n    send_4(BS, MS, bsrand', akid, hash(d, prepak, BS, MS, bsrand', akid));\n\n    // Step 6: Respond with temporary keys and verification hash\n    openly hash_6: Hash;\n    fresh tek0, tek1: Key;\n    send_6(BS, MS, msrand', bsrand', akid, {tek0, tek1}hash(prepak), hash(d, prepak, msrand', bsrand', akid, {tek0, tek1}hash(prepak)));\n\n    // Claim agreement and synchronization\n    claim_rsar3(BS, Niagree);\n    claim_rsar4(BS, Nisynch);\n  }\n}"]], "SPDL-1/simplest-1.spdl": [[true, "// Define the simplest authentication protocol in SPDL\n\nprotocol SimplestAuthentication {\n  // Declare the roles involved in the protocol\n  role I {\n    // Declare the variables used in the protocol\n    var x : Nonce;     // Nonce received in the initial message\n    var n : Nonce;     // Fresh nonce generated during the protocol\n    var k : SymmetricKey; // Shared secret key\n\n    // Step 1: Role I receiving a message containing nonce x from itself\n    recv_!1(I, I, x);\n\n    // Step 2: Role I generating a fresh nonce and sending an encrypted response\n    send_!2(I, I, n, {n, x}k);\n\n    // Step 3: Role I claiming that nonce n is a secret\n    claim_3(I, Secret, n);\n  }\n}"]], "SPDL-1/smartright.spdl": [[true, "protocol SmartRightViewOnly(I, R)\n{\n    role I {\n        const Vor;\n        fresh VoKey, VoR, CW, VoRi;\n\n        send_1(I, R, {VoKey, (CW XOR VoR)}_k(I,R));\n        recv_2(R, I, VoRi);\n        send_3(I, R, {H(VoRi), VoR}_VoKey);\n    }\n\n    role R {\n        const Vor;\n        fresh VoRi;\n\n        recv_1(I, R, {VoKey, M}_k(I,R));\n        match M = (CW XOR VoR);\n\n        send_2(R, I, VoRi);\n\n        recv_3(I, R, {H(VoRi), VoRa}_VoKey);\n\n        claim(R, Nisynch);\n    }\n}"]], "SPDL-1/speedtest-1.spdl": [[true, "protocol ns3speedtest(I, R)\n{\n  const I, R;\n  var ni, nr;\n  know I, R;\n  \n  // Role Initiator (I)\n  role I\n  {\n    fresh ni; // Generate nonce ni\n    send_1(I, {I, ni}pk(R)); // Message 1: Send identity and nonce ni encrypted to R\n    \n    recv_2(R, {{ni, nr}pk(I)}); // Message 2: Receive nonce nr encrypted with ni from R\n    send_3(I, {nr}pk(R)); // Message 3: Send nonce nr encrypted to R\n    \n    claim_ni_secret(nr); // Claim nr is a secret shared with R\n  }\n\n  // Role Responder (R)\n  role R\n  {\n    recv_1(I, {I, ni}pk(R)); // Message 1: Receive identity I and nonce ni encrypted from I\n    \n    fresh nr; // Generate nonce nr\n    send_2(R, {{ni, nr}pk(I)}); // Message 2: Send nonce nr and ni encrypted to I\n    \n    recv_3(I, {nr}pk(R)); // Message 3: Receive nr encrypted from I\n    \n    claim_nr_secret(ni); // Claim ni is a secret shared with I\n  }\n}\n\n// Specify runs for different scenarios\nenvironment\n{\n  run ns3speedtest.I(Alice, Bob); // Alice initiates with Bob\n  run ns3speedtest.I(Eve, Bob); // Eve initiates with Bob\n  run ns3speedtest.I(Bob, Alice); // Bob initiates with Alice\n  run ns3speedtest.I(Eve, Alice); // Eve initiates with Alice\n  run ns3speedtest.I(Bob, Bob); // Bob initiates a session to himself\n}"]], "SPDL-1/splice-as-hc.spdl": [[true, "protocol spliceAS_HC(I, S, R)\n{\n    role I {\n        send_1(I, S, R, N1);\n        recv_2(S, I, R, N1, pubkey(R));\n        send_3(I, R, N2, T, L, {N2}pubkey(R));\n\n        var N2_acked;\n        recv_6(R, I, {N2_acked}pubkey(I));\n        \n        claim_I_Secure_Secret(N2);\n        claim_I_Niagree(I, S, Niagree);\n        claim_I_Nisynch(I, S, Nisynch);\n    }\n\n    role S {\n        recv_1(I, S, R, N1);\n        send_2(S, I, R, N1, pubkey(R));\n        \n        recv_4(R, S, N3);\n        send_5(S, R, N3, I, {N3}secretkey(S));\n    }\n\n    role R {\n        recv_3(I, R, N2_enc, T, L, {N2}pubkey(R));\n        \n        var N2_dec;\n        N2_dec := decrypt(N2_enc, pubkey(R));\n        \n        send_4(R, S, N3);\n        recv_5(S, R, N3_enc);\n        \n        var N3_dec;\n        N3_dec := decrypt(N3_enc, secretkey(S));\n        \n        send_6(R, I, {N2_dec}inc as N2_acked, pubkey(I));\n        \n        claim_R_Secure_Secret(N2_dec);\n        claim_R_Niagree(R, I, Niagree);\n        claim_R_Nisynch(R, I, Nisynch);\n    }\n}"]], "SPDL-1/SR3.spdl": [[true, "protocol SR3 {\n\n    role V {\n        const V;\n        var S;\n        fresh Nv, D;\n        const kVS;\n        \n        send_1(V, S, {D, Nv}kVS, H(Nv), V);\n        recv_2(S, V, Nv, V);\n\n        claim_V1(V, Running);\n        claim_V2(V, Secret, D);\n        claim_V3(V, Secret, kVS);\n        claim_V4(V, Synchronization);\n        claim_V5(V, Secret, Nv);\n    }\n\n    role S {\n        var V;\n        const S;\n        const kVS;\n        var D, Nv;\n        \n        recv_1(V, S, {D, Nv}kVS, H(Nv), V);\n        send_2(S, V, Nv, V);\n\n        claim_S1(S, Running);\n        claim_S2(S, Secret, D);\n        claim_S3(S, Secret, kVS);\n        claim_S4(S, Synchronization);\n        claim_S5(S, Secret, Nv);\n    }\n}"]], "SPDL-1/bkepk-ce-1.spdl": [[true, "protocol bkeCE {\n    \n    // Definitions of roles\n    role Alice {\n        const A, B: Agent;\n        var na, nb: Nonce;\n        var kab: Key;\n        \n        // Step 1: Alice generates nonce `na` and session key `kab`\n        generate na;\n        generate kab;\n        \n        // Step 2: Alice receives message containing Bob's nonce `nb` and Bob's identifier, encrypted with Alice's public key\n        recv({ B, nb }_pk(A));\n        \n        // Step 3: Alice sends message containing hash of `nb`, nonce `na`, her identifier, and session key `kab`, encrypted with Bob's public key\n        send({ hash(nb), na, A, kab }_pk(B));\n        \n        // Step 4: Alice receives confirmation message from Bob containing hash of her nonce `na`, encrypted with the session key `kab`\n        recv({ hash(na) }_kab);\n        \n        // Security Claims\n        claim(A, Secret, na);\n        claim(A, Secret, nb);\n    }\n    \n    role Bob {\n        const A, B: Agent;\n        var na, nb: Nonce;\n        \n        // Step 1: Bob generates nonce `nb`\n        generate nb;\n        \n        // Step 2: Bob sends message containing his nonce `nb` and his identifier, encrypted with Alice's public key\n        send({ B, nb }_pk(A));\n        \n        // Step 3: Bob receives message from Alice with hash of `nb`, Alice's nonce `na`, her identifier, and session key, encrypted with Bob's public key\n        recv({ hash(nb), na, A, kab }_pk(B));\n        \n        // Step 4: Bob sends confirmation back to Alice containing hash of her nonce `na`, encrypted with the session key `kab`\n        send({ hash(na) }_kab);\n        \n        // Security Claims\n        claim(B, Secret, na);\n        claim(B, Secret, nb);\n    }\n}"]], "SPDL-1/sts-mac.spdl": [[true, "protocol STS_MAC {\n    role Initiator {\n        const i: Nonce;\n        var Gr: Ticket, R_SK: SecretKey;\n        fresh k_i: Nonce;\n\n        send_1( g(i) );\n        recv_!2( Gr, {Gr, g(i)}_R_SK, MAC(h(Gr,i), Gr, g(i)) );\n        send_!3( {g(i), Gr}_I_SK, MAC(h(Gr,i), g(i), Gr) );\n\n        claim(SKR, KDF(h(Gr,i)));\n        claim(Alive);\n        claim(Weakagree);\n    }\n\n    role Responder {\n        const r: Nonce;\n        var Gi: Ticket, I_SK: SecretKey;\n        fresh k_r: Nonce;\n\n        recv_1( Gi );\n        send_!2( Gi, {g(r), Gi}_R_SK, MAC(h(Gi,r), g(r), Gi) );\n        recv_!3( {Gi, g(r)}_I_SK, MAC(h(Gi,r), Gi, g(r)) );\n\n        claim(SKR, KDF(h(Gi,r)));\n        claim(Alive);\n        claim(Weakagree);\n    }\n\n    role Oracle {\n        // Assuming Oracle handles cryptographic operations\n        var kdf_in: Value;\n        claim(SKR, KDF(kdf_in));\n    }\n\n    role DH {\n        fresh Xi: Nonce, Xr: Nonce;\n        const g: HashFunction;\n\n        send_1( g(Xi) );\n        recv_2( g(Xr) );\n\n        // Diffie-Hellman shared secret calculation\n    }\n\n    role SWAP {\n        var msg: Value;\n        send(msg);\n    }\n}"]], "SPDL-1/th-1seq2.spdl": [[true, "protocol nsl3th3;\n\nconst P1, P2;\n\n// Functions for keys\nfunction pk;\nfunction sk;\ninversekeys(pk, sk);\n\n// Initiator Role\nrole I {\n    var R, ni, ni2, nr, nr2: Nonce;\n    \n    // Generate fresh nonces\n    fresh ni; fresh ni2;\n    \n    // Step 1: Send the first message with P1\n    send_1(I, R, {P1, I, ni}pk(R));\n    \n    // Step 2: Receive nonce nr, encrypted with I's public key\n    recv_2(R, I, {nr}pk(I));\n    \n    // Step 3: Receive P1 confirmation message\n    recv_3(R, I, {P1, ni, nr, R}pk(I));\n    \n    // Step 4: Send back confirmation with nonce nr\n    send_4(I, R, {P1, nr}pk(R));\n    \n    // First claim of sync (after first series of exchanges)\n    claim_i(I, Nisynch);\n    \n    // Step 5: Send second message with P2\n    send_5(I, R, {P2, I, ni2}pk(R));\n    \n    // Step 6: Receive nonce nr2, encrypted with I's public key\n    recv_6(R, I, {nr2}pk(I));\n    \n    // Step 7: Receive P2 confirmation message\n    recv_7(R, I, {P2, ni2, nr2, R}pk(I));\n    \n    // Step 8: Send back confirmation with nonce nr2\n    send_8(I, R, {P2, nr2}pk(R));\n    \n    // Second claim of sync (after second series of exchanges)\n    claim_i(I, Nisynch);\n}\n\n// Responder Role\nrole R {\n    var I, ni, ni2, nr, nr2: Nonce;\n    \n    // Generate fresh nonces\n    fresh nr; fresh nr2;\n    \n    // Step 1: Receive the first message with P1\n    recv_1(I, R, {P1, I, ni}pk(R));\n    \n    // Step 2: Send nonce nr, encrypted with I's public key\n    send_2(R, I, {nr}pk(I));\n    \n    // Step 3: Send P1 confirmation message\n    send_3(R, I, {P1, ni, nr, R}pk(I));\n    \n    // Step 4: Receive confirmation with nonce nr\n    recv_4(I, R, {P1, nr}pk(R));\n    \n    // First claim of sync (after first series of exchanges)\n    claim_r(R, Nisynch);\n    \n    // Step 5: Receive second message with P2\n    recv_5(I, R, {P2, I, ni2}pk(R));\n    \n    // Step 6: Send nonce nr2, encrypted with I's public key\n    send_6(R, I, {nr2}pk(I));\n    \n    // Step 7: Send P2 confirmation message\n    send_7(R, I, {P2, ni2, nr2, R}pk(I));\n    \n    // Step 8: Receive confirmation with nonce nr2\n    recv_8(I, R, {P2, nr2}pk(R));\n    \n    // Second claim of sync (after second series of exchanges)\n    claim_r(R, Nisynch);\n}"]], "SPDL-1/tmn-2.spdl": [[true, "// SPDL code for TMN protocol\n\n// Protocol roles\nrole Alice {\n    // Variables\n    fresh Ka: symmetric_key;\n    const pkS: public_key;\n    var Kb: symmetric_key;\n\n    // Alice sends encrypted key Ka to Simon.\n    send_1(Alice, Simon, {Ka}pkS);\n\n    // Wait to receive key Kb from Simon encrypted with Ka.\n    recv_2(Simon, Alice, {Kb}Ka);\n\n    // Security claim: Ka is a secret only known to Alice.\n    claim(Alice, Secret, Ka);\n}\n\nrole Bob {\n    // Variables\n    fresh Kb: symmetric_key;\n    const pkS: public_key;\n\n    // Bob receives notification from Simon.\n    recv_3(Simon, Bob, Notification);\n\n    // Bob sends encrypted key Kb to Simon.\n    send_4(Bob, Simon, {Kb}pkS);\n\n    // Security claim: Kb is a secret only known to Bob.\n    claim(Bob, Secret, Kb);\n}\n\nrole Simon {\n    // Variables\n    var Ka: symmetric_key;\n    var Kb: symmetric_key;\n    const pkS: public_key;\n    \n    // Simon receives encrypted key Ka from Alice.\n    recv_1(Alice, Simon, {Ka}pkS);\n\n    // Simon sends notification to Bob about Alice's intention to communicate.\n    send_3(Simon, Bob, Notification);\n\n    // Simon receives encrypted key Kb from Bob.\n    recv_4(Bob, Simon, {Kb}pkS);\n\n    // Simon sends key Kb encrypted with Ka to Alice.\n    send_2(Simon, Alice, {Kb}Ka);\n\n    // Security claim: Ka is a secret known only to Simon.\n    claim(Simon, Secret, Ka);\n}\n\n// Define the protocol\nprotocol TMN {\n    role Alice;\n    role Bob;\n    role Simon;\n}"]], "SPDL-1/unknown2.spdl": [[true, "protocol unknown2;\n\nrole Initiator {\n    fresh ni: Nonce;\n    sent_message_1(ni);\n\n    receive_message_3({I, R, kir, ni, nr}_kIS);\n    witness(I, R, nr, Nisynch);\n    witness(I, R, kir, Secret);\n    witness(I, R, ni, Niagree);\n\n    send_message_4({nr}_kir);\n}\n\nrole Responder {\n    fresh nr: Nonce;\n    receive_message_1(ni);\n    \n    sent_message_2({I, R, ni, nr}_kRS);\n\n    receive_message_4({nr}_kir);\n    witness(R, I, nr, Nisynch);\n    witness(R, I, kir, Secret);\n    witness(R, I, ni, Niagree);\n}\n\nrole Server {\n    receive_message_2({I, R, ni, nr}_kRS);\n    sent_message_3({I, R, kir, ni, nr}_kIS);\n}"]], "SPDL-1/void.spdl": [[true, "protocol void-0(A, B, S) {\n    const MySecret, SessionKey;  // Constants for secret keys\n    const tA, tB;                // Nonces generated by A and B\n    const pk;                    // Public key function\n    const h;                     // Hash function\n    secret MySecret;\n    role A {\n        fresh tA;                // Fresh nonce\n        var KeyA;\n\n        send_1(A, S, pk(A), pk(B), {tA, A, B, pk(A), h(tA, A, B, pk(A))}_(k(A,S)));\n        recv_2(S, {B, {tA, pk(B)}_(k(A,S)), h(B, tA, pk(B))}_(k(A,S)));\n\n        gen KeyA;                // Generate a session key\n        send_3(A, B, {tA, KeyA}_(pk(B)));\n        recv_4(B, {h(tA, KeyA)}_(pk(A)));\n        \n        claim(A, Secret, KeyA);\n        claim(A, Niagree, B, KeyA);\n    }\n\n    role S {\n        recv_1(A, {tA, A, B, pk(A), h(tA, A, B, pk(A))}_(k(A,S)));\n        send_2(A, {B, {tA, pk(B)}_(k(A,S)), h(B, tA, pk(B))}_(k(A,S)));\n\n        recv_3(B, {B, tA, pk(B), h(tA, B, pk(B))}_(k(B,S)));\n        send_3(B, {A, {tA, A, pk(A), h(tA, A, pk(A))}_(k(B,S))});\n    }\n\n    role B {\n        recv_2(S, {A, {tA, pk(A)}_(k(B,S)), h(A, tA, pk(A))}_(k(B,S)));\n        send_3(S, {B, tA, pk(B), h(tA, B, pk(B))}_(k(B,S)));\n\n        recv_3(A, {tA, KeyB}_(pk(B)));\n        send_4(A, {h(tA, KeyB)}_(pk(A)));\n\n        claim(B, Secret, KeyB);\n        claim(B, Niagree, A, KeyB);\n    }\n\n}"]], "SPDL-1/wmf.spdl": [[true, "protocol WideMouthedFrog(I, R, S) {\n\n  // Defining the roles\n  role I {\n    const Ni;\n    fresh Ti; \n    fresh Kir;\n\n    // Encryption using key derived from I and S\n    send_1( I, S, {I, Ti, R, Kir}k(I,S) );\n\n    claim_1( Secret, Kir );\n    claim_2( Fresh, Kir );\n  }\n\n  role R {\n    fresh Ts; \n\n    recv_2( S, {I, Ti, R, Kir}k(I,S) );\n    send_3( R, S, {S, Ts, I, Kir}k(R,S) );\n\n    claim_1( Secret, Kir );\n    claim_2( Nisynch );\n    claim_3( Fresh, Kir );\n  }\n\n  role S {\n    recv_4( I, {I, Ti, R, Kir}k(I,S) );\n    send_5( S, {I, Ti, R, Kir}k(I,S) );\n\n    recv_6( R, {S, Ts, I, Kir}k(R,S) );\n    send_7( S, {S, Ts, I, Kir}k(R,S) );\n  }\n}"]], "SPDL-1/woo-lam.spdl": [[true, "// Woo and Lam Mutual Authentication Protocol\n\n/* Entities */\nprincipal I;\nprincipal R;\nprincipal S;\n\n/* Nonces and Keys */\nvariable Ni;\nvariable Nr;\nvariable Kir;\nsecret k_IS, k_RS;\n\n/* Protocol Steps */\n\nprotocol WooLam(I, R, S)\n{\n  // Step 1: Initiation by Initiator\n  send_1(I, R, I, Ni);\n\n  // Step 2: Response by Responder\n  recv_2(R, I, R, Nr);\n  \n  // Step 3: Session Key Request from Initiator to Server\n  send_3(I, S, {I, R, Ni, Nr}k_IS);\n\n  // Step 4: Ticket Generation by Server\n  recv_4(S, R, {R, Ni, Nr, Kir}k_RS);\n  send_5(S, I, {Ni, Nr}Kir); // Ticket sent by Server to Initiator\n  \n  // Step 5: Final Response by Responder to Initiator\n  send_6(R, I, {Nr}Kir);\n}\n\n/* Claims - Security assertions about the protocol */\nattack I1 = secret(Kir); // Claim that the initiator I establishes a secret session key\nattack I2 = ni_synchronization(Ni); // Claim initiator I has no synchronization issue\nattack I3 = freshness(Kir); // Claim initiator I maintains the freshness of the session key\n\nattack R1 = secret(Kir); // Claim that the responder R establishes a secret session key\nattack R2 = nr_synchronization(Nr); // Claim responder R has no synchronization issue\nattack R3 = freshness(Kir); // Claim responder R maintains the freshness of the session key\n\n/* Annotations */\nrole I {\n  Step1: send_1(I, R, I, Ni);\n  Step2: recv_6(I, R, {Nr}Kir);\n  claim_i: claim(I1); claim(I2); claim(I3);\n}\n\nrole R {\n  Step2: recv_2(R, I, R, Nr);\n  Step4: recv_4(R, S, {R, Ni, Nr, Kir}k_RS);\n  send_6(R, I, {Nr}Kir);\n  claim_r: claim(R1); claim(R2); claim(R3);\n}\n\nrole S {\n  Step3: recv_3(S, I, {I, R, Ni, Nr}k_IS);\n  send_5(S, I, {Ni, Nr}Kir);\n}\n\n/* End of Protocol */"]], "SPDL-1/woolam-pi-f.spdl": [[true, "// Woo-lam Protocol from Spore, Pi f\n\n// Define the roles in the protocol\nrole A {\n  // Declare local variables\n  fresh Na: Nonce;\n  var Nb: Nonce;\n  var T: Ticket;\n  const A, B, S: Agent;\n\n  // Step 1: Initialization\n  send_1(A, B, A);\n\n  // Step 2: Nonce Generation\n  recv_2(B, A, Nb);\n\n  // Step 3: Secure Message Sending\n  send_3(A, B, {A, B, Nb}k(A, S));\n}\n\nrole B {\n  // Declare local variables\n  fresh Nb: Nonce;\n  var Na: Nonce;\n  var T: Ticket;\n  const A, B, S: Agent;\n\n  // Step 2: Receive Initialization Message\n  recv_1(A, B, A);\n\n  // Step 2: Nonce Generation\n  send_2(B, A, Nb);\n\n  // Step 4: Ticket Generation\n  recv_3(A, B, {A, B, Nb}k(A, S));\n  send_4(B, S, {A, B, Nb, T}k(B, S));\n\n  // Step 6: Claims\n  claim_B_Niagree: Niagree(Nb);\n  claim_B_Nisynch: Nisynch(Na, Nb);\n}\n\nrole S {\n  // Declare local variables\n  var Na: Nonce;\n  var Nb: Nonce;\n  var T: Ticket;\n  const A, B, S: Agent;\n\n  // Step 4: Receive Ticket and Message\n  recv_4(B, S, {A, B, Nb, T}k(B, S));\n\n  // Step 5: Server Verification\n  send_5(S, B, {A, B, Nb}k(B, S));\n}\n\n// Define the secret function\nsecret(k, [A, S], SymmetricKey);\nsecret(k, [B, S], SymmetricKey);"]], "SPDL-1/yahalom-ban-1.spdl": [[true, "protocol YahalomBAN(I, R, S) {\n\n  // Define roles for Initiator, Responder, and Server\n  role I {\n    // Declare local variables and knowledge\n    var Ni;\n    var Nr, Kir;\n    fresh Ni;\n    const I, R, S;\n\n    // Protocol actions\n    send_1(I, Ni);\n    recv_3(Nr, Kir, {Ni}_Kir);\n    send_4(T, {Nr}_Kir);\n\n    // Security claims\n    claim_I(Kir, Secret);\n    claim_I(Ni, Sync);\n    claim_I(Kir, Fresh);\n  }\n\n  role R {\n    // Declare local variables and knowledge\n    var Ni, Nr;\n    var Kir;\n    fresh Nr;\n    const I, R, S;\n\n    // Protocol actions\n    recv_1(I, Ni);\n    send_2(S, Nr, {I, Ni}_Kir);\n    recv_4(I, {Nr}_Kir);\n\n    // Security claims\n    claim_R(Kir, Secret);\n    claim_R(Nr, Sync);\n    claim_R(Kir, Fresh);\n  }\n\n  role S {\n    // Declare local variables and knowledge\n    var Ni, Nr;\n    var Kir;\n    fresh Kir;\n    const I, R, S;\n\n    // Protocol actions\n    recv_2(R, Nr, {I, Ni}_Kir);\n    send_3(I, Nr, Kir, {Ni}_Kir);\n\n    // Security claims\n    claim_S(Kir, Fresh);\n  }\n}"]], "SPDL-1/yahalom.spdl": [[true, "protocol yahalom(I, R, S) {\n    role I {\n        fresh Ni;\n        send_1(R, I, Ni);\n        // Expect to receive the session key Kir and nonce Nr encrypted with Kir\n        receive_4(R, {I, Kir}_k(R,S), {Nr}_Kir);\n        claim_i1(Kir, secret);\n    }\n\n    role R {\n        fresh Nr;\n        send_2(S, R, {I, Ni, Nr}_k(R,S));\n        receive_3(S, {R, Kir, Ni, Nr}_k(I,S), T);\n        send_4(I, {I, Kir}_k(R,S), {Nr}_Kir);\n        claim_r1(Kir, secret);\n    }\n\n    role S {\n        receive_2(R, {I, Ni, Nr}_k(R,S));\n        fresh Kir;\n        // Respond with the encrypted session key and ticket\n        send_3(R, {R, Kir, Ni, Nr}_k(I,S), T);\n        claim_s1(Kir, secret);\n        claim_n1(Ni, secret);\n        claim_n2(Nr, secret);\n    }\n}"]]}