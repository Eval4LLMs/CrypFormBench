{"HLPSL-1/20172001_Assign_3.hlpsl": [[true, "% Protocol: User Registration and Authentication with Gateway Node and Smart Device\n\nrole user(Ui, RA, GWN, SDj)\n  % Parameters\n  const Uid: agent\n  const PWi, BIOi, TIDi, Kgwnui, Kgwnsdj: text\n  % Randoms\n  fresh Rui, T1: text\n\n  % Initial state\n  init\n    step1.0: state := 0\n\n  transition\n\n    % Registration Phase\n    step1.0 -> step1.1: \n      send(Ui, RA, {Uid, PWi, BIOi})\n    \n    step1.1 -> step1.2: \n      recv(RA, Ui, {TIDi, Kgwnui, Kgwnsdj})\n      \n    % Login Phase\n    step1.2 -> step1.3: \n      send(Ui, GWN, {Uid, Rui, T1})\n\nend role\n\nrole registration_authority(RA, Ui, GWN, SDj)\n  % Parameters\n  const RAid: agent\n  const TIDi, Kgwnui, Kgwnsdj: text\n\n  % Transition handling\n  init\n    step2.0: state := 0\n\n  transition\n\n    step2.0 -> step2.1:\n      recv(Ui, RA, {Uid, PWi, BIOi})\n    \n    step2.1 -> step2.2:\n      send(RA, Ui, {TIDi, Kgwnui, Kgwnsdj})\n\nend role\n\nrole gateway_node(GWN, Ui, RA, SDj)\n  % Parameters\n  const GWNid: agent\n  const Rgwn, Rsdj: text\n  const TIDi: text\n\n  % Transition handling\n  init\n    step3.0: state := 0\n\n  transition\n\n    % Login Phase\n    step3.0 -> step3.1: \n      recv(Ui, GWN, {Uid, Rui, T1})\n    \n    step3.1 -> step3.2: \n      send(GWN, SDj, {Uid, Rsdj, Rgwn, TIDi})\n\nend role\n\nrole smart_device(SDj, Ui, RA, GWN)\n  % Parameters\n  const SDjid: agent\n\n  % Transition handling\n  init\n    step4.0: state := 0\n\n  transition\n\n    step4.0 -> step4.1:\n      recv(GWN, SDj, {Uid, Rsdj, Rgwn, TIDi})\n    \n    step4.1 -> step4.2:\n      send(SDj, GWN, {Rsdj, Rgwn})\n\nend role\n\n% Intruder Declaration\nrole environment()\n  const Ui, RA, GWN, SDj: agent\n  composition\n    user(Ui, RA, GWN, SDj) \n    registration_authority(RA, Ui, GWN, SDj) \n    gateway_node(GWN, Ui, RA, SDj)\n    smart_device(SDj, Ui, RA, GWN)\nend role\n\ngoal\n  secrecy_of Kgwnui, Kgwnsdj\n  authentication_on TIDi\n\nend goal\n\nenvironment()\n% Define the session and security properties"]], "HLPSL-1/2019202008.hlpsl": [[true, "/* HLPSL protocol description for Mutual Authentication and Key Agreement Protocol */\n\nrole credential_generator(Gen, User, Gwn, PWD: plaintext, SND, RCV: channel (dy)) \nplayed_by Gen {\n\n  /* Step 1: Initial password distribution */\n  init state := pwd_distribution.\n  \n  transition\n    pwd_distribution -> user_registration\n      message := {PWD}_\n      event :=(send User.PWD);\n      \n  end role\n\nrole user(User, Gen, Gwn, PWD: plaintext, SND, RCV: channel (dy)) \nplayed_by User {\n\n  state user_registration:\n    transition\n      user_registration -> user_registration_completed\n        event := recv(Gen.PWD);\n        request(uid: uid_type, vi: vi_type) := compute(req(PWD, TS1));\n        proof := {uid, TS1, req(PWD, TS1)}_\n        event := send Gwn.proof;\n    \n  state user_authentication:\n    transition\n      user_authentication -> user_authenticated\n        event := recv(Gwn.res);\n        verify(Gwn.res);\n        session_key := compute_session_key();\n        event := send Sensor.session_key;\n    \n  end role\n\nrole gateway_node(Gwn, User, Sensor, PWD: plaintext, SND, RCV: channel (dy)) \nplayed_by Gwn {\n\n  init state := gwn_ready.\n  \n  transition\n    gwn_ready -> user_request_received\n      event := recv(User.proof);\n      verify(User.proof);\n      \n    user_request_received -> authentication_completed\n      res := {auth_details}_Gwn;\n      session_key := generate_session_key();\n      event := send User.res;\n      \n  end role\n\nrole sensor(Sensor, Gwn, session_key: session_key_type, SND, RCV: channel (dy)) \nplayed_by Sensor {\n\n  init state := sensor_registration.\n  \n  transition\n    sensor_registration -> sensor_registered\n      event := recv(Gwn.verify_details);\n      send Gwn.sensor_id, verify_id;\n      \n    sensor_registered -> secure_communication\n      event := recv(User.session_key);\n      confirm(session_key);\n  \n  end role\n\nrole environment()\n{\n  role_set env_user : user( ) {\n    transition\n\n    }\n}\n\ngoal\n  secrecy_of PWD, session_key\n  authentication_on auth_generated\n\nend goal\n\nenvironment()"]], "HLPSL-1/A_Secure_and_Efficient_Smart_Card-based_UCSSO_Scheme_Using_Extended_Chebyshev_Chaotic_Maps_for_Telemedicine_Systems.hlpsl": [[true, "/* HLPSL code for the Registration and Mutual Authentication Protocol */\n\n/* Common declarations */\nconst\n  g1, g2, g3, g4, g5, g6: secret;\n  Kus: symmetric_key;\n  Hash, T: hash_function;\n\n/* User role definition */\nrole user(U, S: agent, Kus: symmetric_key)\n  const\n    IDi, SIDj: text;\n    PWi, Yi: text;\n  var\n    Ai, Aii, PiPrime, MiPrime: text;\n    State: nat;\n  init\n    State := 0\n  transition\n    1. State=0 /\\ rec_msg=begin_registration -> send_msg= {Ai, Aii, SIDj, IDi}'_Kus /\\ State:=1;\n    2. State=1 /\\ rec_msg= {Bii, Bjj}'_Kus -> send_msg= {PiPrime, MiPrime}'_Kus /\\ State:=2;\nend role\n\n/* Server role definition */\nrole server(S, U: agent, Kus: symmetric_key)\n  vars\n    Bii, Bjj: text;\n    State: nat;\n  init\n    State := 1\n  transition\n    1. State=1 /\\ rec_msg= {Ai, Aii, SIDj, IDi}'_Kus -> send_msg= {Bii, Bjj}'_Kus /\\ State:=2;\n    2. State=2 /\\ rec_msg= {PiPrime, MiPrime}'_Kus -> send_msg= acknowledgment /\\ State:=0;\nend role\n\n/* Intruder knowledge */\nenvironment()\n  const\n    begin_registration: text;\n  intruder_knowledge = {begin_registration, Kus, Hash, T}\n  composition\n    user(U, S, Kus) /\\ server(S, U, Kus)\n  end composition\n\n/* Security Goals */\ngoal\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_pi\n  authentication_on s_u_sj\nend goal\n\n/* Environment configuration */\nenvironment_config()\n  const\n    U, S: agent;\n    Kus: symmetric_key;\n  intruder_knowledge = {begin_registration, Kus}\nend environment_config"]], "HLPSL-1/BRSKI.hlpsl": [[true, "role pledge(P, R, M: agent, PkR: public_key)\n  played_by P\n  def= \n    local\n      State: nat\n      NonceP, NonceR: text\n      SessionKey: text\n      iDevID: text\n      Voucher: text\n\n    init \n      State := 0\n\n    transition\n      0 -> 1\n      % Initial Connection\n      msg:= {NonceP}iDevID.P\n      =|> R\n      State := 1\n\n      1 -> 2 \n      % Receipt of Registrar's response\n      R.msg':= {NonceR}.{PkR}CA \n      =|> P \n      State := 2\n\n      2 -> 3\n      % Key Exchange\n      SessionKey := new () \n      msg:= {SessionKey}NonceP.NonceR\n      =|> R\n      State := 3\n\n      3 -> 4\n      % Voucher Request\n      msg:= {NonceP.iDevID}P\n      =|> R\n      State := 4\n\n      5 -> 6\n      % Final Authentication\n      R.msg':= {Voucher}MASA \n      =|> P\n      State := 6\n\nend role\n\nrole registrar(R, P, M: agent, PkP, PkM: public_key)\n  played_by R\n  def= \n    local\n      State: nat\n      NonceP, NonceR: text\n      SessionKey: text\n      VoucherRequest: text\n      Voucher: text\n\n    init \n      State := 0\n\n    transition\n      0 -> 1\n      % Receiving connection from Pledge\n      P.msg:= {NonceP}iDevID.P\n      =|> R\n      State := 1\n      \n      1 -> 2\n      % Respond to Pledge with own nonce and public key\n      NonceR := new ()\n      msg:= {NonceR}.{PkR}CA \n      =|> P \n      State := 2\n\n      2 -> 3\n      % Key Exchange\n      P.msg:= {SessionKey}NonceP.NonceR\n      =|> R\n      State := 3\n\n      3 -> 4\n      % Forward Voucher Request\n      P.msg:= {NonceP.iDevID}P\n      =|> R\n      msg := {VoucherRequest}R\n      =|> M\n      State := 4\n\n      4 -> 5\n      % Receiving voucher from MASA\n      M.msg:= {Voucher}MASA \n      =|> R\n      State := 5\n\n      5 -> 6\n      % Forwarding the voucher to the Pledge\n      msg:= {Voucher}MASA \n      =|> P\n      State := 6\n\nend role\n\nrole masa(M, R, P: agent)\n  played_by M\n  def= \n    local\n      State: nat\n      Voucher: text\n\n    init \n      State := 0\n\n    transition\n      0 -> 1\n      % Receiving Voucher Request\n      R.msg:= {VoucherRequest}R\n      =|> M\n      State := 1\n\n      1 -> 2\n      % Issue and sign the Voucher\n      Voucher := new ()\n      msg:= {Voucher}MASA\n      =|> R\n      State := 2\n\nend role\n\nrole environment()\n  def=\n    const\n      P, R, M: agent\n      PkP, PkR, PkM: public_key\n\n    init\n      % Session Initialization\n      PkP := pk(P)\n      PkR := pk(R)\n      PkM := pk(M)\n\n      % Protocol Initiation\n      create_role(pledge(P, R, M, PkR))\n      create_role(registrar(R, P, M, PkP, PkM))\n      create_role(masa(M, R, P))\n\n    goal\n      % Secrecy of nonces and session key\n      secrecy_of SessionKey, NonceP, NonceR\n\n      % Authentication goals\n      authentication_on P, R, M\n\nend role\n\ngoal secrecy_of NonceP, NonceR, SessionKey\ngoal authentication_on(P, R, M)"]], "HLPSL-1/calp-v3.hlpsl": [[true, "role badgeuse(B: agent, S: agent, PKs: public_key, PKb: public_key, skB: private_key, IdBadgeuse: text, IdEmploye: text, TypeAction: text)\n\n    played_by B\n\n    def= local\n        State: nat\n        SessionKey: text\n        ActionHash: hash\n        Msg1, Msg2, Msg3, Msg4: message\n\n    init\n        State := 0\n\n    transition\n\n        1. State = 0 /\\ evnt(send_start) -->\n        (* Send Initial Request: B -> S: {IdBadgeuse, IdEmploye}_PKs *)\n        State' := 1 /\\ Msg1 := {IdBadgeuse, IdEmploye}'_PKs /\\ send(Msg1)\n\n        2. State = 1 /\\ RcvdMsg = {SessionKey}'_PKb /\\ recv(S, Msg2) -->\n        (* Receive Session Key: S -> B: {ClefSession}_PKb *)\n        State' := 2 /\\ SessionKey' := SessionKey\n\n        3. State = 2 /\\ evnt(send_action) -->\n        (* Send Action Request: B -> S: {TypeAction}_SessionKey *)\n        State' := 3 /\\ Msg3 := {TypeAction}'_SessionKey /\\ send(S, Msg3)\n\n        4. State = 3 /\\ RcvdMsg = {ok.H(TypeAction)}/\\'_SessionKey /\\ recv(S, Msg4) -->\n        (* Receive Confirmation: S -> B: {ok.H(Action')}_SessionKey *)\n        State' := 4 /\\ ActionHash' := H(TypeAction)\n\nend role\n\nrole serveur(S: agent, B: agent, PKs: public_key, PKb: public_key, skS: private_key)\n\n    played_by S\n\n    def= local\n        State: nat\n        IdBadgeuse, IdEmploye, TypeAction: text\n        SessionKey, ActionHash: text\n        Msg1, Msg2, Msg3, Msg4: message\n\n    init\n        State := 0\n\n    transition\n\n        1. State = 0 /\\ RcvdMsg = {IdBadgeuse, IdEmploye}'_PKs /\\ recv(B, Msg1) -->\n        (* Receive Initial Request: B -> S: {IdBadgeuse, IdEmploye}_PKs *)\n        State' := 1 /\\ IdBadgeuse' := IdBadgeuse /\\ IdEmploye' := IdEmploye\n\n        2. State = 1 /\\ evnt(generate_session_key) -->\n        (* Send Session Key: S -> B: {ClefSession}_PKb *)\n        State' := 2 /\\ SessionKey' := new() /\\ Msg2 := {SessionKey}'_PKb /\\ send(B, Msg2)\n\n        3. State = 2 /\\ RcvdMsg = {TypeAction}'_SessionKey /\\ recv(B, Msg3) -->\n        (* Receive Action Request: B -> S: {TypeAction}_SessionKey *)\n        State' := 3 /\\ TypeAction' := TypeAction\n\n        4. State = 3 /\\ evnt(send_confirmation) -->\n        (* Send Confirmation: S -> B: {ok.H(Action')}_SessionKey *)\n        State' := 4 /\\ ActionHash' := H(TypeAction) /\\ Msg4 := {ActionHash}'_SessionKey /\\ send(B, Msg4)\n\nend role\n\nrole session(B: agent, S: agent, PKs: public_key, PKb: public_key, skB: private_key, skS: private_key, IdBadgeuse: text, IdEmploye: text, TypeAction: text)\n\n    def=\n    composition\n      badgeuse(B, S, PKs, PKb, skB, IdBadgeuse, IdEmploye, TypeAction)\n      serveur(S, B, PKs, PKb, skS)\n\nend role\n\nrole environment()\n\n    def= local\n        B, S: agent\n        PKs, PKb: public_key\n        skB, skS: private_key\n        IdBadgeuse, IdEmploye, TypeAction: text\n\n    composition\n        session(B, S, PKs, PKb, skB, skS, IdBadgeuse, IdEmploye, TypeAction)\n\n    knowledge\n        B, S, intruder_knowledge\n\n    intruder_knowldge = {B, S, PKs, PKb, IdBadgeuse}\n\n    goals\n\n        secrecy_of SessionKey\n        secrecy_of IdEmploye, TypeAction\n\n        authentication_on B S\n        authentication_on S B\n\nend role\n\ngoal\n    secrecy_of SessionKey\n    secrecy_of IdEmploye, TypeAction\n\n    authentication_on B S\n    authentication_on S B\nend goal"]], "HLPSL-1/CHAPv2.hlpsl": [[true, "/* HLPSL code for the CHAPv2 Protocol */\n\nrole chap_Init(A, B: agent, k: function) \nplayed_by A\ndef=\n   local \n      State : nat\n      Na, Nb : text\n      HashInit : hash\n   init \n      State := 0\n  \n   transition\n   1. State = 0 -> State := 1 \n      /\\ printf(\"Step 1: Initialization by Client\\n\")\n      /\\ new(Na)\n      /\\ A -> B: Na\n\n   2. State = 1 /\\ B =| Nb -> State := 2 \n      /\\ printf(\"Step 2: Challenge from Server\\n\")\n      /\\ HashInit := h(k, (Na, Nb, A))\n      /\\ A -> B: {Na, HashInit}\n\nend role\n\nrole chap_Resp(B, A: agent, k: function) \nplayed_by B\ndef=\n   local \n      State : nat\n      Na, Nb : text\n      HashResp : hash\n   init \n      State := 0\n  \n   transition\n   1. State = 0 /\\ A =| Na -> State := 1 \n      /\\ printf(\"Step 1: Receive Init from Client\\n\")\n      /\\ new(Nb)\n      /\\ B -> A: Nb\n\n   2. State = 1 /\\ A =| {Na', HashInit'} -> State := 2\n      /\\ printf(\"Step 2: Receive Response from Client\\n\")\n      /\\ HashResp := h(k, (Na', Nb, A))\n      /\\ HashInit' = HashResp\n      /\\ B -> A: HashResp\n\nend role\n\nrole session(A, B: agent, k: function)\ndef=\n  local\n    Na, Nb : text\n  composition\n     chap_Init(A, B, k)\n     chap_Resp(B, A, k)\nend role\n\nenvironment chapv2_environment\ndef=\n  const\n    A, B : agent\n    k : function\n  composition\n    session(A, B, k)\nend environment"]], "HLPSL-1/chebyshev_final.hlpsl": [[true, "// HLPSL script for Secure Registration and Authentication Protocol\n\n// Role: User\nrole user(Ui, Sj, RC, RPKeyi, Hash, BH) {\n\n  // Parameters of the user role\n  const IDi, PWi, Bi: text\n  var UIDi, RN1, RN2: text\n\n  // State declarations\n  init state := State_0\n\n  // Transitions\n  transition\n  \n    // Registration phase\n    State_0 -> State_1\n      verification_mode\n      [\n        RC.init_register_rec(IDi, PWi, Bi)\n      ]\n      parameters\n      [\n        RC]\n      send\n      (\n        IDi, PWi, Bi\n      )\n  \n    State_1 -> State_2\n      verification_mode\n      [\n        RC.register_user()\n      ]\n      parameters\n      [\n        RC]\n      receive\n      (\n        UIDi = RC.hash(IDi, PWi, Bi)\n      )\n\n    // Login phase\n    State_2 -> State_3\n      verification_mode\n      [\n        Sj.login_verify()\n      ]\n      send\n      (\n        Hash, UIDi, RN1\n      )\n  \n    State_3 -> State_4\n      verification_mode\n      [\n        Sj.challenge()\n      ]\n      receive\n      (\n        RN2\n      )\n\n    // Authentication phase\n    State_4 -> State_5\n      verification_mode\n      [\n        Sj.authenticate_user()\n      ]\n      send\n      (\n        BH, Hash(RN2)\n      )\n\n}\n\n// Role: Server\nrole server(Sj, Ui, RC, RPKeyj, Hash) {\n\n  // Parameters of the server role\n  const PublicKeyj, SecretKeyj: text\n  var RN1, RN2: text\n\n  // State declarations\n  init state := State_0\n\n  // Transitions\n  transition\n\n    // Registration phase\n    State_0 -> State_1\n      verification_mode\n      [\n        RC.init_register_server(PublicKeyj, SecretKeyj)\n      ]\n      send\n      (\n        PublicKeyj, SecretKeyj\n      )\n  \n    State_1 -> State_2\n      verification_mode\n      [\n        RC.register_server()\n      ]\n      receive\n\n    // Login phase\n    State_2 -> State_3\n      protocol_entity\n      [\n        Ui.login()\n      ]\n      receive\n      (\n        Hash, UIDi, RN1\n      )\n  \n    State_3 -> State_4\n      send\n      (\n        RN2\n      )\n    \n    // Authentication phase\n    State_4 -> State_5\n      receive\n      (\n        BH(Hash(RN2))\n      )\n\n}\n\n// Role: Registration Server\nrole registration_server(RC) {\n\n  // Parameters and constants\n  const IDi, PWi, Bi: text\n  const PublicKeyj, SecretKeyj: text\n  var UIDi: text\n\n  // State declarations\n  init state := State_0\n    \n  // Transitions\n  transition\n\n    // User Registration\n    State_0 -> State_1\n      receive\n      (\n        IDi, PWi, Bi\n      )\n      send\n      (\n        UIDi = Hash(IDi, PWi, Bi)\n      )\n    \n    // Server Registration\n    State_1 -> State_2\n      receive\n      (\n        PublicKeyj, SecretKeyj\n      )\n\n    State_2 -> State_3\n\n}\n\n// Session role\nrole session(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH) {\n  composition\n  user(Ui, Sj, RC, RPKeyi, Hash, BH) |\n  server(Sj, Ui, RC, RPKeyj, Hash) |\n  registration_server(RC)\n}\n\n// Environment role\nrole environment() {\n\n  // Agents declarations\n  const RPKeyi, RPKeyj: text\n  const Ui, Sj, RC: agent\n\n  // Intruder capabilities\n  const intruderCapability: text\n\n  intruder_knowledge = {RPKeyi, RPKeyj, Hash, BH}\n\n  composition\n  session(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH)\n  \n  // Security goals\n  goals\n    secrecy_of RPKeyi, RPKeyj\n    authentication_on UIDi\n    authentication_on IDi\n    \n}\n\n// End of HLPSL script"]], "HLPSL-1/CRAM-MD5.hlpsl": [[true, "role client(A, S: agent, SK: symmetric_key, F: hash_func) \nplayed_by A\ndef=\n  local\n    Na: nonce\n    T: text\n    H: hash\n  init\n    state_0\n  transition\n    1. state_0 -> state_1 \n      /\\\n        begin_session\n      /\\ \n        send(A, S, {A})\n\n    2. state_1 -> state_2\n      /\\ \n        recv(S, A, {Na, T, S})\n      /\\ \n        H := F(SK, Na, T)\n      /\\ \n        send(A, S, {H})\n  end role\n\nrole server(S, A: agent, SK: symmetric_key, F: hash_func) \nplayed_by S\ndef=\n  local\n    Na: nonce\n    T: text\n    H: hash\n  init\n    state_0\n  transition\n    1. state_0 -> state_1\n      /\\ \n        recv(A, S, {A})\n      /\\ \n        Na := new()\n      /\\ \n        T := new()\n      /\\ \n        send(S, A, {Na, T, S})\n    \n    2. state_1 -> state_2\n      /\\ \n        recv(A, S, {H})\n      /\\ \n        H =:= F(SK, Na, T)\n      /\\ \n        end_session\n  end role\n\nrole session(A, S: agent, SK: symmetric_key, F: hash_func)\ndef=\n  composition\n    client(A, S, SK, F)\n    server(S, A, SK, F)\n  end composition\nend role\n\nrole environment()\ndef=\n  const\n    A, S: agent\n    SK: symmetric_key\n    F: hash_func := md5\n  intruder_knowledge = {A, S, F}\n  composition\n    session(A, S, SK, F)\n    session(S, A, SK, F)\n  end composition\nend role\n\ngoal\n  secrecy_of SK\n  authentication_on H_for S\nend goal\n\nenvironment()"]], "HLPSL-1/crocus.hlpsl": [[true, "role alice(A, B: agent, Ya, Yb: public_key, Ka: symmetric_key, SND, RCV: channel (dy)) \nplayed_by A\ndef=\n  local\n    State: nat\n    Na, T1: text\n    Msg, SigA: message\n  init\n    State := 0\n  transition\n    0 -> 1 \n    given\n      Na := new()\n      T1 := new()\n    composed_by\n      Msg := {Na, T1}\n      SigA := sign(Msg, inv(Ya))\n      SND(A.B.{Na, T1, SigA})\n    and\n    1 -> 2\n    provided\n      RCV(B.A.{Nb, T2, SigB'})\n      is_signature_valid({Nb, T2, Na, T1}, SigB', Yb)\n    given\n      Ka := new()\n    composed_by\n      Msg := {KEX(Ka, Ya, Yb)}\n      SigA := sign(Msg, inv(Ya))\n      SND(A.B.{Msg, SigA})\n    and\n    2 -> 3\n    provided\n      RCV(B.A.{KDF(...), SigB''})\n      is_signature_valid({KDF(...)}, SigB'', Yb)\n    composed_by\n      SigA := sign(Confirmation, inv(Ya))\n      SND(A.B.SigA)\n\nend role\n\nrole bob(B, A: agent, Yb, Ya: public_key, Kb: symmetric_key, SND, RCV: channel (dy))\nplayed_by B\ndef=\n  local\n    State: nat\n    Nb, T2: text\n    Msg, SigB: message\n  init\n    State := 0\n  transition\n    0 -> 1\n    provided\n      RCV(A.B.{Na, T1, SigA'})\n      is_signature_valid({Na, T1}, SigA', Ya)\n    given\n      Nb := new()\n      T2 := new()\n    composed_by\n      Msg := {Nb, T2, Na, T1}\n      SigB := sign(Msg, inv(Yb))\n      SND(B.A.{Nb, T2, SigB})\n    and\n    1 -> 2\n    provided\n      RCV(A.B.{KEX(...), SigA''})\n      is_signature_valid({KEX(...)}, SigA'', Ya)\n    composed_by\n      Msg := {KDF(...)}\n      SigB := sign(Msg, inv(Yb))\n      SND(B.A.{Msg, SigB})\n\nend role\n\nrole session(A, B: agent, Ya, Yb: public_key, Ka, Kb: symmetric_key)\ndef=\n  composition\n    alice(A, B, Ya, Yb, Ka, SND, RCV)\n    bob(B, A, Yb, Ya, Kb, RCV, SND)\nend role\n\ngoal\n  secrecy_of Ka, Kb\n  authentication_on Na\n  authentication_on Nb\nend goal\n\nenvironment\nrole environment()\ndef=\n  const\n    Alice, Bob: agent\n    Ya, Yb: public_key\n    Ka, Kb: symmetric_key\n  composition\n    session(Alice, Bob, Ya, Yb, Ka, Kb)\n  end composition\nend role\nend environment"]], "HLPSL-1/device6g.hlpsl": [[true, "/* HLPSL code for Secure Communication Protocol between Device (DEV) and Key Manager (KM) */\n\nrole DEV(D, KM : agent, sec_1, sec_2 : text, H, H4B : hash_func, SND, RCV : channel(dy))\n    const ProtocolID : text\n    fresh Nonce : text\n    state State := 0\n\n    transition\n        1. State = 0\n            /\\ RCV({KM}_ProtocolID)\n            --> State := 1\n            /\\ Nonce := new()\n            /\\ SND({D, Nonce, H(Nonce, sec_1, ProtocolID), H4B(Nonce, sec_2)}_KM)\n\nrole KM(KM, D : agent, sec_1, sec_2 : text, H, H4B : hash_func, SND, RCV : channel(dy))\n    const ProtocolID : text\n    state State := 0\n\n    transition\n        1. State = 0\n            /\\ RCV({D, Nonce, HND, HM}_ProtocolID)\n            --> State := 1\n            /\\ SND(H(HND, sec_1, ProtocolID), H4B(HM, sec_2))\n\ncomposition session(DEV, KM)\n    const ProtocolID : text\n    const H, H4B : hash_func\n    const sec_1, sec_2 : text\n    \n    channel(D_SND, D_RCV : dy)\n    channel(KM_SND, KM_RCV : dy)\n    \n    execute DEV(D, KM, sec_1, sec_2, H, H4B, D_SND, KM_RCV)\n    execute KM(KM, D, sec_1, sec_2, H, H4B, KM_SND, D_RCV)\n\nenvironment()\n    const sec_1, sec_2 : text\n    const H, H4B : hash_func\n    const ProtocolID : text\n    const D, KM : agent\n    \n    knowledge = {sec_1, sec_2, H, H4B, ProtocolID, D, KM}\n    composition session(DEV, KM)\n\ngoal\n    secrecy_of sec_1, sec_2\n    authentication_on D\n\nend"]], "HLPSL-1/device_registration.hlpsl": [[true, "// HLPSL code for the described protocol\n\n// ---- Specification of the Protocol Roles ----\n\n// Role for the Device (SD)\nrole device(SD, AS: agent, PS: symmetric_key) \nplayed_by SD\n\n// Local state variables declaration\ndef= \n  const secret(D): protocol_id\n\t\n// Intrinsic variables declaration\ndef= \n  var R1, R2, DS: text\n  \n  // Here, SD is going to initialize with a nonce\n  init state = initial_state\n\ntransition\n\n  // Initial state: Message 1 from SD to AS\n  initial_state -> awaiting_response_from_AS\n  R1 := new()\n  send(SD, AS, {R1, h(PS)}_inv(PS))\n\n  // State after receiving response from AS\n  awaiting_response_from_AS -> prepare_confirmation_response\n  receive(AS, SD, {R2, DS, h(PS)}_inv(PS))\n  send(SD, AS, {R2}_DS)\n\nend role\n\n// Role for the Authentication Server (AS)\nrole authentication_server(SD, AS: agent, PS: symmetric_key)\nplayed_by AS\n\ndef= \n  const secret(AS): protocol_id\n\ndef= \n  var R1, R2, R3, DS: text\n  \n  init state = awaiting_initial_request\n\ntransition\n\n  // State after receiving initial request from SD\n  awaiting_initial_request -> awaiting_device_confirmation\n  receive(SD, AS, {R1, h(PS)}_inv(PS))\n  R2 := new()\n  DS := new()\n  send(AS, SD, {R2, DS, h(PS)}_inv(PS))\n\n  // State after receiving confirmation from SD\n  awaiting_device_confirmation -> secure_communication_established\n  receive(SD, AS, {R2}_DS)\n  R3 := new()\n  send(AS, SD, {R3}_DS)\n\nend role\n\n// ---- Environment Definition ----\nrole session_environment()\ndef= \n  const secret_env: protocol_id\n  var SD, AS: agent\n  var PS: symmetric_key\n\n  // Setting the test environment where instances of Device and AS interact\n  composition \n    device(SD, AS, PS) && authentication_server(SD, AS, PS)\n\nend role\n\n// ---- Goals Definition ----\ngoal \n  secrecy_of DS\n  authentication_on R2\n  authentication_on R3\n\n// ---- Session Block ----\nenvironment()\ndef= \n  composition \n    session_environment()\nend environment\n\n// Setting initial knowledge for participants\nknowledge(SD: agent, AS: agent, PS: symmetric_key)  \nend knowledge"]], "HLPSL-1/DHCP-delayed-auth.hlpsl": [[true, "// Roles, Environment, and Session Definitions for DHCP-Delayed-Auth\n\nrole dhcp_Delayed_Client(C, S: agent, K: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by C\ndef=\n  local State_C, Time1: text\n  init State_C := 0\n\n  transition\n\n  // Client initial request, including the nonce or timestamp\n  State_C = 0 /\\ Rcv(start) =|>\n  State_C' := 1\n  /\\ Snd(C, delayedAuthReq, Time1)\n\n  // Client receives server response with authentication details\n  State_C = 1 /\\ Rcv(S, delayedAuthReq, succ(Time1), KeyID(K), H(S, delayedAuthReq, succ(Time1), K)) =|>\n  State_C' := 2\nend role\n\nrole dhcp_Delayed_Server(S, C: agent, K: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by S\ndef=\n  local State_S, Time1, KeyID: text\n  init State_S := 0\n\n  transition\n\n  // Server receives a delayed authentication request\n  State_S = 0 /\\ Rcv(C, delayedAuthReq, Time1) =|>\n  State_S' := 1\n  /\\ KeyID := KeyID(K)\n  /\\ Snd(S, delayedAuthReq, succ(Time1), KeyID, H(S, delayedAuthReq, succ(Time1), K))\n\nend role\n\nrole session(C, S: agent, K: symmetric_key)\ndef=\n  // Communication channels between client and server\n  composition\n\n  dhcpClient: dhcp_Delayed_Client(C, S, K, dhcp_std, dhcp_rcv)\n  dhcpServer: dhcp_Delayed_Server(S, C, K, dhcp_rcv, dhcp_std)\nend role\n\nrole environment()\ndef=\n  const delayedAuthReq: text\n  const succ: text -> text\n  const KeyID: symmetric_key -> text\n\n  intruder_knowledge = {delayedAuthReq}\n  \n  composition\n    dhcp_Session: session(Client, Server, K)\nend role\n\ngoal\n  secrecy_of K\n  authentication_on H\nend goal\n\nenvironment()"]], "HLPSL-1/AAAMobileIP.hlpsl": [[true, "role MobileNode(MN, FA, AAAL, AAAH: agent, SND, RCV: channel(dy))\n  def=\n    local\n      Key_MN_FA, Key_MN_HA: session_key\n      Nonce_MN: text\n      ID_MN: agent\n  init\n    0. (* Step 1: Initial Registration *)\n    send_!1(MN, FA, {ID_MN'.Nonce_MN}_Key_MN_FA);\n  \n  transition\n    1. (* Step 2: Intermediary Authentication *)\n    state 0 ->\n    state 1\n    recv_!2(FA, MN, {ID_MN.Nonce_MN}_Key_MN_FA) /\\\n    send_!3(FA, AAAL, {ID_MN.Nonce_MN}_Key_MN_FA);\n    \n  transition\n    2. (* Steps 3 & 4: Key Generation and Distribution *)\n    state 1 ->\n    state 2\n    recv_!4(AAAL, MN, {ID_MN, Key_MN_FA, Key_MN_HA}_Key_MN_FA) /\\\n    send_!5(MN, FA, {Key_MN_FA}_Key_MN_FA);\nend role\n\nrole ForeignAgent(FA, MN, AAAL, AAAH: agent, SND, RCV: channel(dy))\n  def=\n    local\n      Key_MN_FA: session_key\n      Nonce_FA: text\n  init\n    0. (* Step 1: Initial Registration *)\n    send_!1(FA, MN, {Nonce_FA}_Key_MN_FA);\n  \n  transition\n    1. (* Step 2: Intermediary Authentication *)\n    state 0 ->\n    state 1\n    recv_!2(MN, FA, {ID_MN.Nonce_MN}_Key_MN_FA) /\\\n    send_!3(FA, AAAL, {ID_MN.Nonce_MN}_Key_MN_FA);\n\n  transition\n    2. (* Step 4: Completion of Registration *)\n    state 1 ->\n    state 2\n    recv_!5(MN, FA, {Key_MN_FA}_Key_MN_FA);\nend role\n\nrole AAAL(AAAL, FA, MN, AAAH: agent, SND, RCV: channel(dy))\n  def=\n  transition\n    1. (* Step 3: Forward MN info to AAAH *)\n    state 0 ->\n    state 1\n    recv_!3(FA, AAAL, {ID_MN.Nonce_MN}_Key_MN_FA) /\\\n    send_!4(AAAL, AAAH, {ID_MN.Nonce_MN}_Key_MN_FA);\nend role\n\nrole AAAH(AAAH, FA, MN, AAAL: agent, SND, RCV: channel(dy))\n  def=\n    local\n      Key_MN_FA, Key_MN_HA: session_key\n  transition\n    1. (* Step 3: Authenticate and provide session keys *)\n    state 0 ->\n    state 1\n    recv_!4(AAAL, AAAH, {ID_MN.Nonce_MN}_Key_MN_FA) /\\\n    new(Key_MN_HA) /\\\n    new(Key_MN_FA) /\\\n    send_!4(AAAH, AAAL, {ID_MN, Key_MN_FA, Key_MN_HA}_Key_MN_FA);\nend role\n\nrole Environment()\n  def=\n    const\n      a, b, aaali, aaah: agent\n    composition\n      session(MobileNode, ForeignAgent, AAAL, AAAH);\nend role\n\ngoal\n  secrecy_of Key_MN_FA, Key_MN_HA\n  weak_authentication_on ID_MN\nend goal\n\nenvironment()"]], "HLPSL-1/DPP-I.hlpsl": [[true, "role configurator(C, E : agent, SKey, BootstrappingKey_C, ProtoKey_C : public_key,\n                  SKey_CT : symmetric_key, N1, N2: text)\n\ninit state := 0\n\ntransition\n  state = 0 ->      state' := 1\n                     /\\\n                     request(C, E, {N1}BootstrappingKey_C)\n                     \n  state = 1 /\\ recv(E, C, {N2}BootstrappingKey_C, N1) =|> state' := 2\n                     /\\\n                     send(C, E, {N2}SKey_CT)\n      \n  state = 2 /\\ recv(E, C, {config_request}SKey_CT) =|> state' := 3\n                     /\\\n                     send(C, E, {config_credential}SKey_CT)\nend role\n\nrole enrollee(E, C : agent, SKey, BootstrappingKey_E, ProtoKey_E : public_key,\n              SKey_CT : symmetric_key, N1, N2: text)\n\ninit state := 0\n\ntransition\n  state = 0 /\\ recv(C, E, {N1}BootstrappingKey_E) =|> state' := 1\n                     /\\\n                     send(E, C, {N2, N1}BootstrappingKey_E)\n                     \n  state = 1 /\\ recv(C, E, {N2}SKey_CT) =|> state' := 2\n                     /\\\n                     send(E, C, {config_request}SKey_CT)\nend role\n\nrole session(C, E: agent, SKey, BootstrappingKey_C, BootstrappingKey_E,\n             ProtoKey_C, ProtoKey_E : public_key, SKey_CT : symmetric_key, N1, N2: text)\n\ncomposition\n  configurator(C, E, SKey, BootstrappingKey_C, ProtoKey_C, SKey_CT, N1, N2) \n  /\\ \n  enrollee(E, C, SKey, BootstrappingKey_E, ProtoKey_E, SKey_CT, N1, N2)\n  \nend role\n\nrole environment()\n\nconst SKey: protocol_id, N1, N2: text, config_request, config_credential: text\nagent C, E, I: agent\nintruder_knowledge = {C, E, I, SKey, config_request, config_credential, N1, N2}\n\ncomposition\n  session(C, E, SKey, pk(C), pk(E), pk(C), pk(E), SKey_CT, N1, N2)\n  \nend role\n\ngoal\n  secrecy_of SKey, SKey_CT\n  authentication_on N1, N2\nend goal\n\nenvironment()"]], "HLPSL-1/drone_to_gss_protocol.hlpsl": [[true, "// HLPSL Specification for Blockchain-based Access Control Scheme in IoT-enabled Internet of Drones Deployment\n\nrole controlRoom(CR, DRj, GSS: agent, Skey: symmetric_key, Pub: public_key)\nplayed_by CR\n\n  def= \n    local\n      State: nat, \n      Id_CR, Cert_DRj, Cert_GSS: text,\n      Kat_DRj, Kat_GSS: text\n\n    init\n      State := 0\n  \n    transition\n      State = 0 /\\ channel(broadcast, Access_Request) with {CR, Id_CR, Cert_DRj, Cert_GSS}\n      =|> \n      State := 1\\\n      /\\ CR -> DRj: {Id_CR, Cert_DRj}_Skey\\\n      /\\ CR -> GSS: {Id_CR, Cert_GSS}_Skey\n\nend role\n\nrole drone(DRj, CR, GSS: agent, Skey: symmetric_key, Pub: public_key)\nplayed_by DRj\n\n  def=\n    local \n      State: nat,\n      Id_DRj, Token: text,\n      ReqData_DRj: text\n\n    init\n      State := 0\n\n    transition\n      State = 0 /\\ channel(receive_only) with {CR, Id_CR, Cert_DRj} =|>\n      State := 1\\\n      /\\ DRj -> GSS: {Id_DRj, Token, ReqData_DRj}_Skey\\\n      /\\ channel(secure, authentication_phase) with {Id_DRj, Token, ReqData}\n\nend role\n\nrole groundServer(GSS, CR, DRj: agent, Skey: symmetric_key, Pub: public_key)\nplayed_by GSS\n\n  def=\n    local\n      State: nat,\n      Id_GSS, Ack: text,\n      SessState: text\n\n    init\n      State := 0\n\n    transition\n      State = 0 /\\ channel(receive_only) with {CR, Id_CR, Cert_GSS}=|>\n      State := 1\\\n      /\\ channel(authorization, secure) with {Id_DRj, Token, ReqData}\\\n      /\\ GSS -> DRj: {Id_GSS, Ack, SessState}_Skey\n\nend role\n\nrole session(CR, DRj, GSS: agent, Skey: symmetric_key, Pub: public_key)\nplayed_by environment\n\n  def=\n    composition\n      controlRoom(CR, DRj, GSS, Skey, Pub)\n      drone(DRj, CR, GSS, Skey, Pub)\n      groundServer(GSS, CR, DRj, Skey, Pub)\n\nend role\n\ngoal\n  authentication_on authentication_phase\n  secrecy_of Skey\n\nend goal\n\nenvironment()\n\nend environment"]], "HLPSL-1/Dynamic_group_key_distribution_scheme_with_three-factor_identification_for_IoT_environments.hlpsl": [[true, "role user(U, S: agent, SU: symmetric_key, P, Bio: text, G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11: message) \nplayed_by U\nconst N: text\nvars E, BBi, W, Nj, Yij, K, B, IDinew, SKij, GkiAT: message\nstate 0\ntransition\n\n    0 -> 1 \n    !Role_U\n    := (U.ID = ID, E := new() , W := h(P.Bio) , BBi := h(P+B) , K := h(ID, P, Bio, SU) )\n    .send_1(S'ID'.W'.SU'.BBi'.E)\n\n    1 -> 2 \n    |recv_2(S.Nj.Yij)\n    := (Nj := N' , K := h(ID, P, Bio, SU) , B := h(ID, P, Bio) )\n    .send_3(Nj'Yij'K)\n\ngoal\n   secrecy_of G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11\n   authentication_on ID, U, S\nend role\n\nrole server(U, S: agent, SU: symmetric_key, G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11: message)\nplayed_by S\nvars Nj, Yij, K, B, IDinew, SKij, E: message\nconst N: text\nstate 0\ntransition\n\n    0 -> 1 \n    |recv_1(U.ID.W'.BBi'.E)\n    := (Nj := N', Yij := h(ID, Nj, W, BBi), K := h(ID, W, Bb))\n    .send_2(U.Nj'.Yij)\n\n    1 -> 2 \n    !Role_S\n    := (IDinew := h(ID,Yij,K), SKij := h(ID,Yij,K,B))\n    .send_3(B.Yij.K'*IDinew'*SKij'GkiAT')\n\ngoal\n   secrecy_of G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11\n   authentication_on ID, U, S\nend role\n\nenvironment()\nconst P, Bio: text\nagent U, S: agent\nsymmetric_key SU: symmetric_key\ncomposition\n  user(U, S, SU, P, Bio, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11) \n  server(U, S, SU, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11)\nend composition\n\ngoal\n  secrecy_of G1, G2, G3, G4, G5, G6, G7, G8, G9, G10, G11\n  authentication_on ID, U, S\nend goal\n\nspecification()\n  environment()\nend specification"]], "HLPSL-1/eap-lorawan.hlpsl": [[true, "// HLPSL code for Secure Device Authentication and Session Management Protocol\n\n// Basic Definitions for Cryptographic Functions\nconst AuthKey, NwkKey: symmetric_key;\n\n// Definitions of Roles\nrole end_device(ED, GNB, AMF, SMF, AUSF, UDM, AAA: agent,\n                JoinEUI, DevEUI, DevNonce: text,\n                AuthKey: symmetric_key,\n                SND, RCV: channel(dy)) \n\nplayed_by ED\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 / \n\n  send_1(ED,GNB,{DevNonce', DevEUI, JoinEUI})\n\n  2. State=1 -> State=2 /\n\n  recv_2(GNB,ED,{DevNonce', NwkKey}) \n\n  3. State=2 -> State=3 /\n\n  send_3(ED,GNB,{AuthKey'})\n\nend role\n\nrole gnodeb(GNB, ED, AMF, SMF, AUSF, UDM, AAA: agent,\n            JoinEUI, DevEUI, DevNonce: text,\n            AuthKey, NwkKey: symmetric_key,\n            SND, RCV: channel(dy))\n\nplayed_by GNB\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(ED,GNB,{DevNonce, DevEUI, JoinEUI})\n\n  2. State=1 -> State=2 /\n\n  send_2(GNB,AUSF,{DevNonce, DevEUI})\n\n  3. State=2 -> State=3 /\n\n  recv_3(AUSF,GNB,{DevNonce, NwkKey})\n\n  4. State=3 -> State=4 /\n\n  send_4(GNB,ED,{DevNonce, NwkKey})\n\nend role\n\nrole ausf(AUSF, GNB, AMF, SMF, ED, UDM, AAA: agent,\n           JoinEUI, DevEUI, DevNonce: text,\n           AuthKey, NwkKey: symmetric_key,\n           SND, RCV: channel(dy))\n\nplayed_by AUSF\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(GNB,AUSF,{DevNonce, DevEUI})\n\n  2. State=1 -> State=2 /\n\n  send_2(AUSF,GNB,{DevNonce, NwkKey})\n\nend role\n\nrole session_management(SMF, ED, GNB, AMF, AUSF, UDM, AAA: agent,\n                        JoinEUI, DevEUI, DevNonce: text,\n                        AuthKey, NwkKey: symmetric_key,\n                        SND, RCV: channel(dy))\n\nplayed_by SMF\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(AUSF,SMF,{DevNonce', NwkKey})\n\n  2. State=1 -> State=2 /\n\n  send_2(SMF,AMF,{AuthKey'})\n\nend role\n\nrole access_management(AMF, ED, GNB, SMF, AUSF, UDM, AAA: agent,\n                       JoinEUI, DevEUI, DevNonce: text,\n                       AuthKey, NwkKey: symmetric_key,\n                       SND, RCV: channel(dy))\n\nplayed_by AMF\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(SMF,AMF,{AuthKey})\n\n  2. State=1 -> State=2 /\n\n  send_2(AMF,AAA,{DevNonce'})\n\nend role\n\nrole accounting_authorization(AAA, ED, GNB, SMF, AMF, AUSF, UDM: agent,\n                              JoinEUI, DevEUI, DevNonce: text,\n                              AuthKey, NwkKey: symmetric_key,\n                              SND, RCV: channel(dy))\n\nplayed_by AAA\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(AMF,AAA,{DevNonce'})\n\n  2. State=1 -> State=2 /\n\n  send_2(AAA,ED,{AuthKey'})\n\nend role\n\nrole data_management(UDM, ED, GNB, SMF, AMF, AUSF, AAA: agent,\n                     JoinEUI, DevEUI, DevNonce: text,\n                     AuthKey, NwkKey: symmetric_key,\n                     SND, RCV: channel(dy))\n\nplayed_by UDM\n\ndef= \n  local State: nat\n  init State := 0\n\n  transition\n\n  1 -> State=1 /\n\n  recv_1(AAA,UDM,{AuthKey'})\n\n  2. State=1 -> State=2 /\n\n  send_2(UDM,AUSF,{NwkKey'})\n\nend role\n\n// Environment\n\nenvironment env\n\nconst JoinEUI, DevEUI, DevNonce: text\n\nagent ED, GNB, AMF, SMF, AUSF, UDM, AAA\n\nsession_roles(r1, r2) = (ED, GNB, AMF, SMF, AUSF, UDM, AAA)\n\nrole instances =\n\n  session_management(SMF, ED, GNB, AMF, AUSF, UDM, AAA, JoinEUI, DevEUI, DevNonce, AuthKey, NwkKey, SND, RCV)\n\n=>\n  access_management(AMF, ED, GNB, SMF, AUSF, UDM, AAA, JoinEUI, DevEUI, DevNonce, AuthKey, NwkKey, SND, RCV)\n\ngoal\n\nsecrecy_of AuthKey\nauthentication_on JoinEUI\n\nend environment"]], "HLPSL-1/EKE2.hlpsl": [[true, "role alice(A, B : agent, K : symmetric_key, g : text, SND, RCV : channel(dy)) \n\nplayed_by A\n\ndefs  \n   X, MK : random\n   expAB : text\n   H_MAC_2 : hash\n   SessionKey : text\n\ninit  \n   new X\n  \ntransition  \n\n  0 -> 1 \n   msg1 := {exp(g, X)}_K \n   SND ! msg1\n\n  1 -> 2 \n   RCV ? msg2\n   derive(MK, {Alice, exp(g, X), exp(g, msg2)})\n\n   if check_hash({MK, 1}, msg2) then\n       H_MAC_2 := H(MK, 2)\n       msg3 := H_MAC_2\n       SND ! msg3\n   endif\n\n  2 -> 3 \n   SessionKey := H(MK, 0) \n\nend role\n\nrole bob(B, A : agent, K : symmetric_key, g : text, SND, RCV : channel(dy)) \n\nplayed_by B\n\ndefs  \n   Y, MK : random\n   expBA : text\n   H_MAC_1 : hash\n   SessionKey : text\n\ninit  \n   new Y\n  \ntransition  \n\n  0 -> 1 \n   RCV ? msg1\n   derive(MK, {Bob, exp(g, msg1), exp(g, Y)})\n\n   H_MAC_1 := H(MK, 1)\n   msg2 := {exp(g, Y)}_K, H_MAC_1\n   SND ! msg2\n\n  1 -> 2 \n   RCV ? msg3\n\n   if check_hash({MK, 2}, msg3) then\n       SessionKey := H(MK, 0) \n   endif\n\nend role\n\nrole session(A, B : agent, K : symmetric_key) \n\ncomposition \n   alice(A, B, K, g, SND, RCV) \n   bob(B, A, K, g, SND, RCV)\n\nend role \n\ngoal\n\n  secrecy_of MK\n\n  authentication_on MK\n\nend goal\n\nenvironment() \n\nconst \n   a, b : agent \n   g : text \n   k_ab : symmetric_key \n\nrole session(a, b, k_ab) \n\nend environment \n\nend"]], "HLPSL-1/EVauthenticate.hlpsl": [[true, "// HLPSL code for the described protocol\n\nrole ev(A, GNB, SMF : agent, C1 : text, PUF1, H : hash_func, SK : symmetric_key) \nplayed_by A\ndef= \n local \n  State : nat\n  N2, N3 : nonce\n  R1, N2M : text\n  SK' : symmetric_key\n init \n  State := 0\n transition\n  1. State = 0 /\\ RCV(GNB, {|N2|}) =|> \n     State' := 1 /\\ \n     N3' := new() /\\ \n     N2M' := H(N2) /\\ \n     R1' := PUF1(C1) /\\\n     SND(GNB, {|R1', N3'|}_N2M')\n\n  2. State = 1 /\\ RCV(SMF, {|Z|}) =|>\n     State' := 2 /\\ \n     check(Z', R1', N3') /\\ \n     SK' := H(R1', N3') \n\nend role\n\nrole gnb(GNB, A, SMF : agent, C2 : text, PUF2 : hash_func) \nplayed_by GNB\ndef= \n local \n  State : nat\n  N1, N2 : nonce\n  R2 : text\n init \n  State := 0\n transition\n  1. State = 0 /\\ start =|>\n     State' := 1 /\\ \n     N1' := new() /\\ \n     R2' := PUF2(C2) /\\\n     SND(SMF, {|R2', N1'|})\n\n  2. State = 1 /\\ RCV(SMF, {|N2|}) =|>\n     State' := 2 /\\\n     SND(A, {N2'})\n\nend role\n\nrole smf(SMF, GNB, A : agent, PRNG : hash_func, SK : symmetric_key) \nplayed_by SMF\ndef= \n local \n  State : nat\n  N2 : nonce\n  SK' : symmetric_key\n init \n  State := 1\n transition\n  1. State = 1 /\\ RCV(GNB, {|R2, N1|}) =|>\n     State' := 2 /\\ \n     verify(N1', R2') /\\ \n     N2' := PRNG(N1') /\\\n     SND(GNB, {N2'})\n\n  2. State = 2 /\\ RCV(A, {|R1, N3|}_sk) =|>\n     State' := 3 /\\ \n     verify(R1', N3') /\\ \n     SK' := H(R1', N3') /\\\n     SND(A, {|Z|}_SK')\n\nend role\n\nrole environment()\ndef= \n const C1, C2 : text\n var SK, SK' : symmetric_key\n init\n transition\n  1. Start -> \n     new_session(ev, A | A, GNB, SMF, C1, PUF1, H, SK)\n     new_session(gnb, GNB | GNB, A, SMF, C2, PUF2)\n     new_session(smf, SMF | SMF, GNB, A, PRNG, SK)\n\nend role\n\ngoal\n secrecy_of SK, R1, R2, N1, N2M, N3\n authentication_of A_GNB_N2, GNB_SMF_N1, SMF_GNB_N2, EV_SMF_R1, EV_SMF_N3\n\nenvironment()"]], "HLPSL-1/GetServAuth.hlpsl": [[true, "/* Define the Client Role */\nrole client(C, W: agent, Kc: symmetric_key, sec_1, sec_2: secret, hash: function) {\n    const QR: protocol_id\n    fresh N': nonce\n    variables\n      State: nat\n\n    transitions\n      State = 0 -> accept(start) =|> State' = 1.\n      State = 1 -> send_1(C, W, {QR, hash(QR)}.C) =|> State' = 2\n}\n\n/* Define the Worker Role */\nrole worker(W, C: agent, Kc: symmetric_key, sec_1, sec_2: secret, hash: function) {\n    fresh N: nonce\n    variables\n      State: nat\n\n    transitions\n      State = 0 -> receive_1(C, W, {QR, hash(QR)}.C) =|> State' = 1.\n      State = 1 -> send_2(W, C, {N'.W}.Kc) =|> State' = 2\n}\n\n/* Session Definitions */\nsession session1(C: agent, W: agent, Kc: symmetric_key) {\n  role client(C, W, Kc, sec_1, sec_2, hash)\n  role worker(W, C, Kc, sec_1, sec_2, hash)\n}\n\nsession session2(C: agent, W: agent, Kc: symmetric_key) {\n  role client(C, W, Kc, sec_1, sec_2, hash)\n  role worker(W, C, Kc, sec_1, sec_2, hash)\n}\n\nsession session3(C: agent, W: agent, Kc: symmetric_key) {\n  role client(C, W, Kc, sec_1, sec_2, hash)\n  role worker(W, C, Kc, sec_1, sec_2, hash)\n}\n\n/* Environment Definition */\nenvironment() {\n  const i: agent\n  const miner, client: agent\n  intruder_knowledge = {i}\n\n  composition\n    session1(client, miner, Kc) \n    session2(client, miner, Kc) \n    session3(client, miner, Kc)\n}\n\n/* Goal Definitions */\ngoal\n  secrecy_of sec_1\n  secrecy_of sec_2\n}"]], "HLPSL-1/h.530-fix.hlpsl": [[true, "role MT(AuF, VGK, MT)\n  const G: exp, X: rand, CH1, CH2, CH3: text\n  var SK_MT_VGK: session_key\n  fresh Nonce_MT: text\n  init\n    state_1\n\n  transition\n    state_1 -> state_2\n      * Ch(MT, VGK, {Nonce_MT, exp(G, X), hash({Nonce_MT, exp(G, X)})})\n      =+> {CH1, exp(G, X), hash({CH1, exp(G, X)})}\n\n  role VGK(AuF, VGK, MT)\n    const G: exp, Y: rand, CH1, CH2, CH3: text\n    var SK_VGK_MT: session_key\n    fresh Nonce_VGK: text\n    init\n      state_1\n\n    transition\n      state_1 -> state_2\n        * Ch(MT, VGK, {CH1, exp(G, X), hash({CH1, exp(G, X)})})\n        =+> Ch(VGK, AuF, {CH1, exp(G, X), hash({CH1, exp(G, X)})})\n\n      state_2 -> state_3\n        * Ch(AuF, VGK, {exp(G, Y), hash({exp(G, Y)})})\n        =+> {exp(G, Y), hash({exp(G, Y)})}\n\n    transition\n      state_3 -> state_4\n        * Ch(VGK, MT, {CH2, CH3, exp(G, XY), hash({CH2, CH3, exp(G, XY)})})\n        =+> {CH2, CH3, SK_VGK_MT := exp(G, XY), hash({CH2, CH3, SK_VGK_MT})}\n\n    transition\n      state_4 -> state_5\n        * Ch(MT, VGK, {Acknowledge, hash({Acknowledge})})\n        =+> {Acknowledge, hash({Acknowledge})}\n\n      state_5 -> state_6\n        * Ch(VGK, MT, {Confirmation, hash({Confirmation})})\n        =+> {Confirmation, hash({Confirmation})}\n\nrole AuF(VGK, AuF, MT)\n  const CH1, CH2: text\n  var Y: rand\n  init\n    state_1\n\n  transition\n    state_1 -> state_2\n      * Ch(VGK, AuF, {CH1, exp(G, X), hash({CH1, exp(G, X)})})\n      =+> Ch(AuF, VGK, {exp(G, Y), hash({exp(G, Y)})})\n\ngoal\n  secrecy_of SK_MT_VGK, SK_VGK_MT\n  authentication_on CH1\n  authentication_on CH2\n\nenvironment Env(MT, VGK, AuF)\n  composition\n    MT(MT, VGK, AuF) | VGK(MT, VGK, AuF) | AuF(VGK, AuF, MT)\n\nend role"]], "HLPSL-1/hash_n_single.hlpsl": [[true, "// HLPSL Code for Secure Password Authentication Protocol\n\n// Role: User\nrole user(U, S: agent, PW: text, F: hash_func)\nplayed_by U\ndef= \n  local\n    State: nat\n    HashedPW: text\n    Witness: text\n  init\n    State := 0\n  transition\n    step1. State=0 /\\ RCV(start) =|> State:=1 /\\ \n            HashedPW:=F(F(F(F(PW)))) /\\ \n            Witness:=F(HashedPW) /\\ \n            SND({HashedPW, Witness})\nend role\n\n// Role: Server\nrole server(U, S: agent, F: hash_func)\nplayed_by S\ndef= \n  local\n    State: nat\n    ReceivedPW: text\n    ReceivedWitness: text\n  init\n    State := 1\n  transition\n    step1. State=1 /\\ RCV({ReceivedPW, ReceivedWitness}) =|> State:=3 /\\ \n            (ReceivedWitness=F(ReceivedPW)) // Ensure authenticity\nend role\n\n// Role: Session\nrole session(U, S: agent, PW: text, F: hash_func)\ndef=\n  composition\n    user(U, S, PW, F)\n    server(U, S, F)\nend role\n\n// Role: Environment\nrole environment()\ndef=\n  const\n    U, S: agent\n    F: hash_func\n    PW: text\n  intruder_knowledge = {U, S, F, PW}  // Intruder knowledge\n  composition\n    session(U, S, PW, F)\n    session(i, S, PW, F)  // Intruder impersonating User\n    session(U, i, PW, F)  // Intruder impersonating Server\nend role\n\n// Goals\ngoal\n  authentication_on HashedPW\n  secrecy_of PW\nend goal"]], "HLPSL-1/IIOT.hlpsl": [[true, "// HLPSL code generated for IIoT Authentication and Message Exchange Protocol\n\n/*=============================\n  Role Definitions\n=============================*/\n\nrole nodeU(U, Gw: agent, Usk: session_key, Gpk: public_key,\n           Ucert, sub1: text, Uid: agent, Hmac: hash_func)\nplayed_by U\ndef=\n  local State: nat, N1: text, M5: message\n\n  init State := 0\n\n  transition\n\n    1. State = 0 /\\ received(start) \n       -> State' := 1 \n          /\\ N1' := new() \n          /\\ M5' := {Uid, Ucert, N1, Hmac(sub1)}_Usk \n          /\\ send(U, Gw, M5')\n\nend role\n\n\nrole gateway(Gw, U: agent, Gsk: session_key, Upk: public_key, \n             Gcert, nodeU_info: text, Hmac: hash_func) \nplayed_by Gw\ndef=\n  local State: nat, N2: text, M6: message\n\n  init State := 0\n\n  transition\n\n    1. State = 0 /\\ received(U, Gw, M5) \n       -> State' := 2 \n          /\\ N2' := new()\n          /\\ if verify_signature(M5, Upk) then\n               M6' := {Gw, Gcert, N2, Hmac(nodeU_info)}_Gsk\n               /\\ send(Gw, U, M6')\n          endif\n\nend role\n\n\nrole session(U, Gw: agent, Usk, Gsk: session_key, \n             Upk: public_key, Gpk: public_key,\n             Ucert, Gcert, sub1, nodeU_info: text,\n             Hmac: hash_func)\ndef=\n  composition\n    nodeU(U, Gw, Usk, Gpk, Ucert, sub1, U, Hmac)\n    gateway(Gw, U, Gsk, Upk, Gcert, nodeU_info, Hmac)\n\nend role\n\n\nrole environment()\ndef=\n  const\n     sub1: text, nodeU_info: text \n     U, Gw, I: agent \n     Ucert, Gcert: text \n     Usk, Gsk, Isk: session_key \n     Upk, Gpk, Ipk: public_key\n     Hmac: hash_func \n\n  intruder_knowledge = {U, Gw, I, Upk, Gpk, Ipk, Hmac}\n\n  composition\n    session(U, Gw, Usk, Gsk, Upk, Gpk, Ucert, Gcert, sub1, nodeU_info, Hmac)\n    session(I, Gw, Isk, Gsk, Ipk, Gpk, Ucert, Gcert, sub1, nodeU_info, Hmac)\n\n  knowledge\n    Gw knows Gw, Gsk, Upk, Gpk, Gcert, Hmac, sub1, nodeU_info\n    U knows U, Usk, Gpk, Gsk, Ucert, Hmac, sub1\n\n  goals\n    secrecy_of sub1\n    authentication_on nodeU_gateway_n5\n    authentication_on nodeU_gateway_lt1\n\nend role\n\n/*=============================\n  End of Protocol Definition\n=============================*/"]], "HLPSL-1/AKS.hlpsl": [[true, "// HLPSL code generation for OBU1, OBU2, and SN roles following the protocol description\n\n// Role for OBU1\nrole OBU1(OBU1_ID, OBU2_ID, SN_ID : agent, Q1, Q2 : public_key, c_Q2 : public_key, SND1, RCV1 : channel(dy))\n  \n  const A1 : agent, OBU1_secret : secret\n  secret A1, R1 : secret\n  composition\n    Q1, MAC(A1_Q1_OBU1_OBU2) := createMAC(Q1, A1, OBU1_ID, OBU2_ID)\n    \n  state 0\n    transition\n      0 -> 1 [rcv($Q2.P($OBU2_ID))]\n      state 1\n      transition\n        1 -> 2 [send(SND1, {A1, Q1, MAC(A1_Q1_OBU1_OBU2)})]\n\nstate 3\n  transition\n    2 -> 3 [recv(RCV1, {OBU2_ID, Q2, C1,$H21.P($OBU2_ID)})]\n    \n  state 4\n  transition\n    3 -> 4 [send(SND1, {H12_Hashed_Resp($OBU1_ID)})]\n\nend role\n\n// Role for OBU2\nrole OBU2(OBU1_ID, OBU2_ID, SN_ID : agent, R2 : secret, Q1 : public_key, SND2, RCV2 : channel(dy))\n\n  const A2 : agent, OBU2_secret : secret\n  secret A2, R2 : secret\n\n  composition\n    Q2, C1 := newChallenge(R2)\n\nstate 0\n  transition\n    0 -> 1 [recv(RCV2, {A1, Q1, MAC(A1_Q1_OBU1_OBU2)})]\n    \nstate 2\n  transition\n    1 -> 2 [send(SND2, {OBU2_ID, Q2, C1, H21(P($OBU2_ID))})]\n\nend role\n\n// Role for SN\nrole SN(OBU1_ID, OBU2_ID, SN_ID : agent, R1, R2 : secret, H21 : hashFunc, SND_SN_O1, RCV_SN_O2 : channel(dy))\n  const Q1, Q2 : public_key\n  \n  composition\n    SN_ID, H21 := newHash(R1, R1, Q1, Q2)\n \n  state 0\n  transition\n    0 -> 1 [recv(SND_SN_O1, {A1, MAC(A1_Q1_OBU1_OBU2)})]\n    \nstate 2\n  transition\n    1 -> 2 [recv(RCV_SN_O2, {OBU2_ID, Q2, C1, H21})]\n\nend role\n\n// Goal Specification with secrecy and authentication properties\ngoal\n  secrecy_of R1, R2, A1, A2\n  authentication_on o1_o2_h12\n\nend goal"]], "HLPSL-1/IKEv2-MAC.hlpsl": [[true, "// HLPSL Code for IKEv2-MAC Protocol\n\nrole alice(A, B, S: agent, PSK, SK: symmetric_key, g: text)\nconst SAa1, SAa2: text\nconst Na: text\nconst KEa: nat\n\n// Alice's knowledge: B, S, PSK\ninit\n  state := 0\n\ntransition\n\n  1. state = 0 /\\ recv_1(B, {SAa1, KEa, Na}) =|> \n    send_1(B, {SAb1, KEb, Nb})\n\n  2. state = 1 /\\ recv_2(B, {B, AUTHb, SAb2}SK) =|>\n    send_2(B, {A, AUTHa, SAa2}SK)\n\nend role\n\nrole bob(B, A, S: agent, PSK, SK: symmetric_key, g: text)\nconst SAb1, SAb2: text\nconst Nb: text\nconst KEb: nat\n\n// Bob's knowledge: A, S, PSK\ninit\n  state := 0\n\ntransition\n\n  1. state = 0 /\\ recv_1(A, {SAa1, KEa, Na}) =|> \n    send_1(A, {SAb1, KEb, Nb})\n\n  2. state = 1 /\\ recv_2(A, {A, AUTHa, SAa2}SK) =|>\n    send_2(A, {B, AUTHb, SAb2}SK)\n\nend role\n\nrole session(A, B, S: agent)\nvar PSK, SK: symmetric_key\nvar g: text\n\ncomposition\n  alice(A, B, S, PSK, SK, g) \n  bob(B, A, S, PSK, SK, g)\n\nend role\n\nenvironment()\nconst alice, bob, server: agent\nconst PSK, SK: symmetric_key\nconst g: text\n\nrole_sess(session(alice, bob, server))\n\nend environment"]], "HLPSL-1/InitialAuth.hlpsl": [[true, "// HLPSL Specification for Cluster Node Authentication Protocol\n\n/* Define the sets of roles involved in the protocol. */\nrole Newnode(N, CA, OCA, Knc, Kn)\n  const Challenge, Solution, AuthRequest, Success: text\n  const R: text // Random value/nonce generated for Challenge\n  secret Knc: symmetric_key\n  const Kn: public_key\n  var S, C: text\n  goals\n    authentication_on_success\n\n  transitions\n    // Step 1: Send AuthRequest to ClusterAdmin\n    state 0\n      if true then\n        send_1(N, CA, {AuthRequest}_Knc) // Send AuthRequest\n        goto 1\n\n    // Step 3: Receive Challenge and send Solution\n    state 1\n      upon receipt_2(CA, N, {C}_Knc) then\n        S := compute_solution(C, R) // Compute the solution using the challenge and nonce\n        send_3(N, CA, {Solution, S}_Knc) // Send Solution\n        goto 2\n\n    // Step 5: Receive Success from ClusterAdmin\n    state 2\n      upon receipt_4(CA, N, {Success}_Knc) then\n        request success authentication_on_success // Declare that authentication was successful\n        goto 3\n\n    state 3\nend role\n\nrole ClusterAdmin(N, CA, OCA, Knc, Kcc, Kn)\n  const Challenge, Solution, AuthRequest, Success: text\n  const R: text // Random value/nonce generated for Challenge\n  secret Knc: symmetric_key\n  secret Kcc: symmetric_key\n  const Kn: public_key\n  var C, S: text\n  goals\n    authentication_on_success\n\n  transitions\n    // Step 2: Generate and send Challenge\n    state 0\n      upon receipt_1(N, CA, {AuthRequest}_Knc) then\n        C := generate_random() // Generate a new random challenge value\n        send_2(CA, N, {Challenge, C}_Knc) // Send Challenge back to Newnode\n        goto 1\n\n    // Step 4: Verify Solution and notify OtherClusterAdmins\n    state 1\n      upon receipt_3(N, CA, {Solution, S}_Knc) then\n        if verify_solution(S, C, R) then\n          send_4(CA, N, {Success}_Knc) // Send Success message if Solution is valid\n          send_5(CA, OCA, {Success}_Kcc) // Notify OtherClusterAdmins\n          request success authentication_on_success // Declare successful authentication\n          goto 2\n        else\n          // Handle invalid solution scenario\n          goto 3\n\n    state 2 // Successful authentication state\n    state 3 // Failed authentication state\nend role\n\nrole OtherClusterAdmins(N, CA, OCA, Kcc)\n  const Success: text\n  secret Kcc: symmetric_key\n\n  transitions\n    // Observe the Success message sent by ClusterAdmin\n    state 0\n      upon receipt_5(CA, OCA, {Success}_Kcc) then\n        // Process or log the success information\n        goto 1\n\n    state 1\nend role\n\nenvironment()\n  const N, CA, OCA: agent\n  const Knc, Kcc: symmetric_key\n  const Kn: public_key\n  intruder_knowledge = {Knc, Kn, Kcc}\n\n  composition\n    Newnode(N, CA, OCA, Knc, Kn) /\\ \n    ClusterAdmin(N, CA, OCA, Knc, Kcc, Kn) /\\\n    OtherClusterAdmins(N, CA, OCA, Kcc)\nend environment\n\ngoal\n  authentication_on_success: Newnode authenticates CA\nend goal"]], "HLPSL-1/IoT-HAN.hlpsl": [[true, "role nodeU(U, V : agent, KU, KV : public_key, Ks1 : symmetric_key, sub1 : text, R : channel(dy)) % U is implictly the identity of the player\nplayed_by U\n\n  local \n    State : nat\n    Nu, Token1 : text\n    Key1 : symmetric_key\n    CertU : text\n\n  init \n    State := 0\n\n  transition\n\n    0 -> 1 : start\n    (R, start) =|> begin\n      Nu := new()\n      Key1 := h(CertU.U.Nu)\n      Token1 := h(Key1.U)\n      Z1 := {CertU.Nu.U,V} _ Ks1\n      State := 1\n    end.\n\n    1 -> 2 : (R, Token1.Z1)\n    (R, (Token2'))\n      let CertV, Nu2, _,_ = dec(Z2, Key1),\n          Key2 := h(CertV.Nu2),\n          _ = h(Key2.V)\n    in\n      (CertV = V)\n      /\\ (sub1 => secrecy_of(U))\n      /\\ (secrecy_of(sub1))\n    provided\n\nend role\n\nrole nodeV(V, U : agent, KU, KV : public_key, Ks1 : symmetric_key, sub2 : text, R : channel(dy))\nplayed_by V\n\n  local \n    State : nat\n    Nu2, Token2 : text\n    Key2 : symmetric_key\n    CertV : text\n\n  init \n    State := 0\n\n  transition\n\n    0 -> 1 : (R, Token1.Z1)\n    (R, Token1) =|>\n      let CertU, Nu, _ = enc(Z1, Ks1),\n          Key1 := h(CertU.Nu),\n          _ = h(Key1.U)\n      in \n        (CertU = U)\n        /\\ (sub2 => secrecy_of(V))\n        /\\ (secrecy_of(sub2))\n      provided\n\n    1 -> 2 : (R, Token2.Z2)\n    (R, (Token1'))\n      begin\n        Nu2 := new()\n        Key2 := h(CertV.Nu2)\n        Token2 := h(Key2.V)\n        Z2 := {CertV.Nu2.V,U} _ Key1\n        State := 1\n      end.\n\nend role\n\nrole session(U, V : agent, KU, KV : public_key, Ks1, sub1, sub2 : text)\ncomposed_of nodeU(U, V, KU, KV, Ks1, sub1, !1) \n            nodeV(V, U, KU, KV, Ks1, sub2, !1)\n\nend role\n\nrole environment()\n  const\n    KU, KV : public_key\n    Ks1 : symmetric_key\n    sub1, sub2 : text\n  intruder_knowledge = {KU, KV}\n\n  composition\n    session(U, V, KU, KV, Ks1, sub1, sub2)\n\n  goal\n    secrecy_of sub1\n    secrecy_of sub2\n    authentication_on nodeU_nodeV_lt\n    authentication_on nodeV_nodeU_lt\n\nend role"]], "HLPSL-1/ISO2.hlpsl": [[true, "// ISO2 Public Key Unilateral Authentication Protocol in HLPSL\n\n// Declare constants\nconst na, nb, text1, text2: text \n\n// Declare basic types for agents and public keys\ntypes agent, public_key\n\n// Declare variables\nagent A, B\npublic_key PKa, PKs\n\n// Intruder knowledge declaration\nintruder_knowledge = {text1, text2, PKa, PKs}\n\n// Alice's role\nrole iso2_Resp(A, B: agent, PKa, PKs: public_key)\n  played_by A\n  local\n    Rak, Rbk: text\n  init \n    // Initial state\n    state_0\n  transition\n    // Transition from receiving Bob's nonce and text1 to sending the signed response\n    state_0 -> state_1\n      event receive(Rak, text1) from B\n      actions\n        // Generate a new nonce Ra\n        Ra := fresh()\n        // Compose the message and signature\n        Sigma := {Ra, Rak, B, text1}inv(PKa)\n      event send({PKa, A}inv(PKs), Ra, Rak, B, text2, Sigma) to B\n  end role\n\n// Bob's role\nrole iso2_Init(A, B: agent, PKa, PKs: public_key)\n  played_by B\n  local\n    Rak: text\n  init\n    // Initial state\n    state_0\n  transition\n    // Transition from sending initial nonce and text1 to receiving Alice's response\n    state_0 -> state_1\n      event send(Rbk, text1) to A\n      actions\n        // Generate a nonce Rb\n        Rb := fresh()\n    state_1 -> state_2\n      event receive({PKa, A}inv(PKs), Ra, Rbk, B, text2, {Ra, Rbk, B, text1}inv(PKa)) from A\n      actions\n        // Verification step, omitted for clarity here as it would depend on external logic\n  end role\n\n// Session role to bind the roles\nrole session(A, B: agent, PKa, PKs: public_key)\n  composition\n    iso2_Init(A, B, PKa, PKs)\n    iso2_Resp(A, B, PKa, PKs)\n  end role\n\n// Environment\nenvironment()\n  const A, B: agent\n  const PKa, PKs: public_key\n\n  knowledge = intruder_knowledge // Defines what the intruder knows\n\n  composition\n    session(A, B, PKa, PKs) // Run a session between Alice and Bob\n  end role\n\n// Define goals related to authenticity (G1, G2)\ngoal\n  secrecy_of Ra\n  authentication_on A_to_B\nend goal"]], "HLPSL-1/ISO4.hlpsl": [[true, "role alice(A, B: agent, PKa, PKb, PKs, SKa: public_key, invSKa: private_key, Text3: text, Na, Nb: nonce) \nplayed_by A \ndef= \nlocal \n  Nb: nonce \n  S: session_key \ninit \n  state_0 \ntransition \n  1. state_0 -> state_1 \n  recv_1(B, {Nb', Text1'}_PKb) \n  /\\ Nb = Nb' \n  /\\ S = new nonce \n  /\\ event(begin_A) \n  \n  2. state_1 -> state_2 \n  send_2(B, {PKa, Na, Nb, Text3}_PKs) \n  /\\ Na = new nonce \n  /\\ event(middle_A) \n\ngoal \n  authentication_on Nb \n\nend role\n\nrole bob(B, A: agent, PKb, PKa, PKs, SKb: public_key, invSKb: private_key, Text5: text, Nb, Na: nonce) \nplayed_by B \ndef= \nlocal \n  Na: nonce \n  S: session_key \ninit \n  state_0 \ntransition \n  1. state_0 -> state_1 \n  send_1(A, {Nb, Text1}_PKa) \n  /\\ Nb = new nonce\n  /\\ event(begin_B) \n\n  2. state_1 -> state_2 \n  recv_2(A, {PKa', Na', Nb', Text3'}_PKs) \n  /\\ Na = Na' \n  /\\ Nb = Nb' \n  /\\ event(middle_B) \n  \n  3. state_2 -> state_3\n  send_3(A, {PKb, Na, Nb, Text5}_PKs) \n  /\\ event(end_B) \n\ngoal \n  authentication_on Na \n\nend role\n\nrole session(A, B: agent, PKa, PKb, PKs: public_key, SKa, SKb: private_key) \ndef= \nlocal \n  S: session_key \n  Na, Nb: nonce \n  Text3, Text5: text \ncomposition \n  alice(A, B, PKa, PKb, PKs, SKa, invSKa, Text3, Na, Nb) \n  bob(B, A, PKb, PKa, PKs, SKb, invSKb, Text5, Nb, Na) \n\nend role\n\nenvironment() \ndef= \nconstant \n  A, B: agent \n  PKa, PKb, PKs: public_key \n  SKa, SKb: private_key \ninit \n  1. alice(A, B, PKa, PKb, PKs, SKa, invSKa, Text3, Na, Nb) \n  /\\ bob(B, A, PKb, PKa, PKs, SKb, invSKb, Text5, Nb, Na) \n\nend environment\n\ngoal \n  secrecy_of Na \n  secrecy_of Nb \n\nend goal"]], "HLPSL-1/Ju(2024)protocol.hlpsl": [[true, "/* HLPSL Specification for User-Drone Server Authentication and Key Agreement Protocol */\n\n/* Roles */\nrole user(U, CS, SndKeySet: message, RecKeySet: message, HashF: hash_func)\nplayed_by U\n\n  /* Parameters */\n  const key_u_cs : message\n  const cert_u : message\n  const id_u : message\n  \n  /* State variables */\n  secret auth_key: message\n  fresh nonce_u: message\n\n  /* State */\n  state U_init:\n    transition\n      1. U -> CS: id_u, start_signal\n      2. CS -> U: {id_u, nonce_u}_SndKeySet\n      3. U -> CS: {cert_u}_SndKeySet\n\n  init state := U_init\nend role\n\nrole drone(D, CS, RecKeySet: message, SndKeySet: message, HashF: hash_func)\nplayed_by D\n\n  /* Parameters */\n  const key_d_cs : message\n  const cert_d : message\n  const id_d : message\n\n  /* State variables */\n  secret credential_d: message\n  fresh nonce_d: message\n\n  /* State */\n  state D_init:\n    transition\n      1. D -> CS: id_d, credential_d\n      2. CS -> D: {id_d, nonce_d}_RecKeySet\n      3. D -> CS: {cert_d}_SndKeySet\n\n  init state := D_init\nend role\n\nrole server(CS)\nplayed_by CS\n\n  /* Parameters */\n  const key_set_u_cs : message\n  const key_set_cs_u : message\n  const key_set_cs_d : message\n\n  /* State variables */\n  secret cs_shared_key: message\n\n  /* State */\n  state CS_user_reg:\n    transition\n      1. U -> CS: id_u, start_signal\n      2. CS -> U: {id_u, nonce_u}_key_set_u_cs\n      3. U -> CS: {cert_u}_key_set_u_cs\n      4. CS -> U: {auth_key}_key_set_cs_u\n\n  state CS_drone_reg:\n    transition\n      1. D -> CS: id_d, credential_d\n      2. CS -> D: {id_d, nonce_d}_key_set_cs_d\n      3. D -> CS: {cert_d}_key_set_cs_d\n      4. CS -> D: {cs_shared_key}_key_set_cs_d\n\n  state CS_authentication:\n    transition\n      1. U -> CS: {hash(id_u, nonce_u)}_HashF\n      2. D -> CS: {hash(credential_d)}_HashF\n      3. CS -> U: {auth_confirm}_key_set_cs_u\n      4. CS -> D: {auth_confirm}_key_set_cs_d\n\n  init state := CS_user_reg, CS_drone_reg, CS_authentication\nend role\n\n/* Goal */\ngoal\n  secrecy_of auth_key\n  secrecy_of credential_d\n  authentication_on {id_u, id_d}\n  key_agreement_on cs_shared_key\nend goal\n\n/* Environment Configuration */\nrole session(U, CS, D)\n  composition\n    user(U, CS, Key_set_U_CS, Key_set_CS_U, HashAlgo) \n    server(CS) \n    drone(D, CS, Key_set_CS_D, Key_set_CS_U, HashAlgo)\nend role\n\nenvironment(env)\n  const U, CS, D : agent\n  const Key_set_U_CS, Key_set_CS_U, Key_set_CS_D : message\n  const start_signal : message\n  const HashAlgo : hash_func\n\nfriend U, CS, D \n\n  composition\n    session(U, CS, D)\nend environment"]], "HLPSL-1/Kerberos.hlpsl": [[true, "// HLPSL Specification of Kerberos V5 Protocol\n\nrole Client(C, A, G, S : agent, K_CA, K_CS, K_CG : symmetric_key, \n            NONCE_1, NONCE_2 : text)\n\n  const service, req_lifetime : text\n\n  vars \n    Ticket_1, Ticket_2, K_CG, K_CS : text\n  \n  // Step 1: Client Request to Authentication Server\n  init\n    0 -> State\n  transition\n  \n  0 -> 1\n      (State' = 1) \n      /\\ (msg' = {C, G, service, req_lifetime, NONCE_1})\n      /\\ (sechan' = K_CA)\n      /\\ (ch' = a)\n      \n  // Step 2: Authentication Server response\n  1 -> 2\n      (State' = 2) \n      /\\ (msg = {service, {K_CG, Ticket_1}'sechan})\n      /\\ (ch = C)\n  \n  // Step 3: Request to Ticket Granting Server\n  2 -> 3\n     (State' = 3) \n     /\\ (msg' = {C, S, service, Ticket_1, NONCE_2})\n     /\\ (sechan' = K_CG)\n     /\\ (ch' = g)\n\n  // Step 4: Ticket Granting Server Response\n  3 -> 4\n      (State' = 4) \n      /\\ (msg = {service, {K_CS, Ticket_2}'sechan})\n      /\\ (ch = G)\n \n  // Step 5: Service Request to Server\n  4 -> 5\n      (State' = 5) \n      /\\ (msg' = {C, service, Ticket_2})\n      /\\ (sechan' = K_CS)\n      /\\ (ch' = s)\n\n  // Step 6: Server Response\n  5 -> 6\n      (State' = 6) \n      /\\ (msg = {ack}'sechan)\n      /\\ (ch = S)\n\nend role\n\nrole AS(A, C, G : agent, K_CA, K_AG : symmetric_key, NONCE_1 : text)\n\n  const service, req_lifetime : text\n\n  vars\n    Ticket_1, K_CG : text\n    b: channel\n\n  /* Step 1: Receive request from Client */\n  transition\n  \n  0 -> 1\n      (State' = 1) \n      /\\ (msg = {C, G, service, req_lifetime, NONCE_1}'K_CA)\n      /\\ (ch = a)\n  \n\n  /* Step 2: Send response to Client */\n  1 -> 2\n      (State' = 2) \n      /\\ (msg' = {service, {K_CG, Ticket_1}'K_CA})\n      /\\ (ch' = C)\n\nend role\n\nrole TGS(G, A, S : agent, K_CG, K_GS : symmetric_key, NONCE_2 : text)\n\n  const service : text\n\n  vars\n    Ticket_2, K_CS : text\n    f: channel\n\n  /* Step 3: Receive request from Client */\n  transition\n  0 -> 1\n      (State' = 1) \n      /\\ (msg = {C, S, service, Ticket_1, NONCE_2}'K_CG)\n      /\\ (ch = g)\n\n  /* Step 4: Send response to Client */\n  1 -> 2\n      (State' = 2) \n      /\\ (msg' = {service, {K_CS, Ticket_2}'K_GS})\n      /\\ (ch' = G)\n\nend role\n\nrole Server(S, G, C : agent, K_CS : symmetric_key)\n\n  const service : text\n\n  // Step 5: Receive request from Client\n  init\n    0 -> State\n  transition\n\n  0 -> 1\n      (State' = 1) \n      /\\ (msg = {C, service, Ticket_2}'K_CS)\n      /\\ (ch = s)\n  \n  // Step 6: Send response to Client\n  1 -> 2\n      (State' = 2) \n      /\\ (msg' = {ack}'K_CS)\n      /\\ (ch' = S)\n  \nend role\n\ngoal\n  secrecy_of(K_CG, K_CS)\n\n  authentication_on(Client, AS, TGS, Server)\n\nenvironment\n\n  // Declare intruder constraints\n  intruder_knowledge = {C, A, G, S}\n\nend environment\n\nspecification\n  goal\n    secrecy(...)\nend specification"]], "HLPSL-1/KEY_EXCHANGE.hlpsl": [[true, "// HLPSL Code for Secure Communication Protocol\n\nrole Smart_Meter (SM, DS: agent, S1: protocol_id, i: agent)\n{\n    const H: hash_func, Cu: text\n    const IDu: text, Aa: text\n    \n    vars \n        State: nat, I1: text\n        SKs: symmetric_key, Msg: message\n\n    transition\n        step1: \n            State=0 /\\ Rcv(start) =|>\n            State' := 1\n            S1 := H(IDu.a.Cu)\n            I1 := H(Aa.IDu)\n            Msg := {S1, I1}_SKs\n            Send(Msg)\n\n}\n\nrole Distributed_Server (DS, SM: agent, SKs: symmetric_key, i: agent)\n{\n    const Xa: text\n    \n    vars \n        State: nat, Xi1: text\n        Msg: message\n\n    transition\n        step1:\n            State=0 /\\ Rcv({S1, I1}_SKs) =|>\n            State' := 1\n            Xi1 := H(Msg.Xa)\n            Msg := {Xi1}_SKs\n            Send(Msg)\n}\n\nrole session(SM, DS: agent, SKs: symmetric_key, S1: protocol_id)\n{\n    composition\n        Smart_Meter(SM, DS, S1, i) \n        Distributed_Server(DS, SM, SKs, i)\n}\n\nrole environment()\n{\n    const i: agent\n    const SM, DS: agent\n    const kp_SM, kp_DS, ks_i: public_key\n    const S1: protocol_id\n    const SKs: symmetric_key\n\n    intruder_knowledge = {kp_SM, kp_DS, i}\n\n    composition\n        session(SM, DS, SKs, S1)\n\n    const sec_1: goal\n    const auth_1: goal\n\n    goal\n        secrecy_of SKs\n        authentication_on SM_to_DS\n}\n\nenvironment()"]], "HLPSL-1/L-3.hlpsl": [[true, "// HLPSL code for the described protocol\n\nrole alice(A, B: agent, Ka: public_key, K_a: symmetric_key, SND, RCV: channel(dy)) \nplayed_by A {\n    const certA: public_key\n    secret secka: symmetric_key\n    \n    vars\n        Kb: symmetric_key\n        K_b: symmetric_key\n        macAB: message\n        macBA: message\n        receivedCertB: public_key\n    }\n\n    init\n        0 -> State\n\n    transition\n        1. State = 0 /\\ RCV(start) =|> \n           SND({A, certA, Ka}) /\\ \n           State' = 1\n\n        2. State = 1 /\\ RCV({B, receivedCertB, K_b, macAB}) =|>\n           // Verification of Bob's certificate\n           Kb := shared_key(K_a, K_b) /\\\n           verify(macAB) /\\\n           SND({macAB}) /\\\n           State' = 2\n\n        3. State = 2 /\\ RCV({macBA}) =|>\n           verify(macBA) /\\\n           SND({secka}) /\\\n           State' = 3\n\n    end role\n\nrole bob(B, A: agent, Kb: public_key, K_b: symmetric_key, SND, RCV: channel(dy)) \nplayed_by B {\n    const certB: public_key\n    secret seckb: symmetric_key\n    \n    vars\n        Ka: symmetric_key\n        K_a: symmetric_key\n        macAB: message\n        macBA: message\n        receivedCertA: public_key\n    }\n\n    init\n        0 -> State\n\n    transition\n        1. State = 0 /\\ RCV({A, receivedCertA, K_a}) =|>\n           verify(receivedCertA) /\\\n           Ka := shared_key(K_a, K_b) /\\\n           macAB := mac(K_a, B, certB) /\\\n           SND({B, certB, K_b, macAB}) /\\\n           State' = 1\n\n        2. State = 1 /\\ RCV({macAB}) =|>\n           verify(macAB) /\\\n           macBA := mac(K_b, A, certA) /\\\n           SND({macBA}) /\\\n           State' = 2\n\n        3. State = 2 /\\ RCV({secka}) =|>\n           verify(secka) /\\\n           SND({seckb}) /\\\n           State' = 3\n\n    end role\n\nrole session(A, B: agent, Ka, Kb: public_key, K_a, K_b: symmetric_key) {\n    composition\n        alice(A, B, Ka, K_a, SND_A_B, RCV_B_A)\n        bob(B, A, Kb, K_b, SND_B_A, RCV_A_B)\n}\n\nenvironment() {\n    const Ka, Kb: public_key\n    const K_a, K_b: symmetric_key\n    const secka, seckb: symmetric_key\n    intruder_knowledge = {Ka, Kb}\n    \n    composition\n        session(Alice, Bob, Ka, Kb, K_a, K_b)\n}\n\ngoal\n    authentication_on secka\n    authentication_on seckb\n    secrecy_of secka\n    secrecy_of seckb\n}\n\nattack_state\nend goal"]], "HLPSL-1/lipkey-spkm-known-initiator.hlpsl": [[true, "// HLPSL specification of the SPKM-LIPKEY protocol\n\n// Role definitions\nrole init(A, S: agent, Ka, Ks: public_key, G: text, X: text,\n          Na: text, pwd: text, exp: function,\n          inv: inverse_function) \n\nplayed_by A\n\n  local State: nat\n  const Nb: text\n\n  init_know = {S, Ka, G, X, Na, pwd, exp, inv}\n\n  transition \n\n    // Start: Initiator sends a message to the server\n    step1. State = 0 /\\ Rcv(Start) =|>\n    State' = 1 /\\ Snd(A.S.Na.exp(G,X).{A.S.Na.exp(G,X)}_inv(Ka))\n\n    // Receive server's response message (Step 2)\n    step2. State = 1 /\\ Rcv(A.S.Na.Nb.exp(G,Y).{A.S.Na.Nb.exp(G,Y)}_inv(Ks)) =|>\n    State' = 2 /\\ Snd({login.pwd}_exp(exp(G,Y),X))\n\nend role\n\nrole responder(S, A: agent, Ka, Ks: public_key, G: text,\n               X: text, Nb: text, exp: function,\n               inv: inverse_function) \n\nplayed_by S\n\n  local State: nat\n  const Na: text\n\n  init_know = {A, Ks, G, X, Nb, exp, inv}\n\n  transition \n\n    // Receive initiator's message and respond (Step 1)\n    step1. State = 0 /\\ Rcv(A.S.Na.exp(G,X).{A.S.Na.exp(G,X)}_inv(Ka)) =|>\n    State' = 1 /\\ Snd(A.S.Na.Nb.exp(G,Y).{A.S.Na.Nb.exp(G,Y)}_inv(Ks))\n\n    // Receive the login message (Step 3)\n    step2. State = 1 /\\ Rcv({login.pwd}_exp(exp(G,Y),X)) =|>\n    State' = 2 \n\nend role\n\n// Environment role\nrole session(A, S: agent, Ka, Ks: public_key, G: text, X, Y: text,\n             Na, Nb: text, pwd: text, exp: function,\n             inv: inverse_function) \n\nplayed_by env\n\n  const a, s: agent\n  const ka, ks: public_key\n  const g, x, y: text\n  const na, nb: text\n  const pw: text\n\n  composition \n    init(a, s, ka, ks, g, x, na, pw, exp, inv)\n    responder(s, a, ka, ks, g, y, nb, exp, inv)\n\nend role\n\n// Goals for security verification\ngoal\n\n  authentication_on Na\n  authentication_on Nb\n  secrecy_of pwd\n\nend goal\n\n// Main HLPSL specification\nenvironment \n\n  const A, S: agent\n  const Ka, Ks: public_key\n  const G: text\n  const X, Y: text\n  const Na, Nb: text\n  const pwd: text\n  const exp: function\n  const inv: inverse_function\n\n  session(A, S, Ka, Ks, G, X, Y, Na, Nb, pwd, exp, inv)\n\nend environment"]], "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl": [[true, "/*  \n * HLPSL code for Mutual Authentication and Key Exchange Protocol\n */\nrole user(U, S: agent, Kus, Rus: symmetric_key, Ks: public_key, H, Mul: hash_function)\n\nplayed_by U\n  \n  def= local\n          State: nat, \n          Nu: text, // Nonce used by User\n          Gu: text  // Secret value used in Generation of session key\n        const\n          start: text \n        \n  init\n    State := 0 \n    \n  transition\n    1. State = 0 /\\ RCV(start) =|> State' := 1 /\\ Nu' := new() /\\ SND({U, Nu'}_Kus)\n    \n    2. State = 1 /\\ RCV({S, hash(S, Nu, Rus)}_Ks) =|> State' := 2 /\\ \n         Gu' := compute_secret(Nu') /\\ SND({U, Gu'}_Rus)\n  \nend role\n\nrole server(S, U: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_function)\n\nplayed_by S\n\n  def= local\n          State: nat, \n          Ns: text, // Nonce used by Server\n          Gs: text  // Secret value used in Generation of session key\n        const\n          start: text \n          \n  init\n    State := 0 \n  \n  transition\n    1. State = 0 /\\ RCV({U, Nu'}_Kus) =|> State' := 1 /\\ Ns' := new() /\\ \n         SND({S, hash(S, Nu', Rus)}_Ks)\n         \n    2. State = 1 /\\ RCV({U, Gu'}_Rus) =|> State' := 2 /\\ \n         Gs' := compute_secret(Ns') /\\ \n         SND({S, Mul(Gu', Gs')}_Kas)\n    \nend role\n\nrole foreign_agent(F, U: agent, Kus, Rus: symmetric_key, Ks: public_key, H: hash_function)\n\nplayed_by F\n\n  def= local\n          State: nat\n\n  init\n    State := 0 \n\n  transition\n    1. State = 0 /\\ RCV(X) =|> SND(X)\n    \nend role\n\n// Environment to manage scenarios and goals\nrole environment()\n\n  def= const\n          U, S, F: agent,\n          Kus, Rus, Kas: symmetric_key, \n          Ks: public_key,\n          H, Mul: hash_function,\n          start: text\n        var\n          M: message\n\n  init \n    nil \n  \n  composition\n    user(U, S, Kus, Rus, Ks, H, Mul) \n    server(S, U, Kus, Rus, Kas, Ks, H, Mul)\n    foreign_agent(F, U, Kus, Rus, Ks, H)\n\nend role\n\ngoal\n  secrecy_of Gu, Gs\n  authentication_on U_S_auth\n  authentication_on S_U_auth\nend goal\n\nenvironment()"]], "HLPSL-1/liteCrypto.hlpsl": [[true, "/* HLPSL code for the Authentication and Key Exchange Protocol between Drone and Ground Station */\n\nrole drone(A, B: agent, Snd, Rcv: channel(dy), Ha: hash_func)\nplayed_by A\ndef=\n  local \n    State: nat,\n    Che: text,   // Nonce\n    Res: text,   // Response\n    PID: text,   // Session Identifier\n    S: secret,   // Shared Secret\n    Ts: text,    // Timestamp\n    MAC: text,   // Message Authentication Code\n    Sig: text,   // Digital Signature\n    M1: message  // Message to be sent\n  init\n    State := 0\n  transition\n    1. State = 0 /\\ Rcv(start) =|> \n       State := 1 /\\ \n       Che := new() /\\ \n       PID := hash(A.B.S) /\\\n       Res := Ha(Che) /\\\n       Ts := new() /\\\n       MAC := Ha(Res.Ts) /\\\n       Sig := Ha(A.B.MAC) /\\\n       M1 := (Ts.MAC.Sig) /\\\n       Snd({PID.S.M1}'_A_B)\nend role\n\nrole ground_station(A, B: agent, Snd, Rcv: channel(dy), Ha: hash_func)\nplayed_by B\ndef=\n  local\n    State: nat,\n    PID: text,   // Session Identifier\n    S: text,     // Shared Secret\n    Ts, Ts2: text, // Timestamps\n    MAC: text,   // Message Authentication Code\n    Sig: text,   // Digital Signature\n    SAC: secret, // Session Authentication Code\n    M1: message  // Message received\n  init\n    State := 1\n  transition\n    1. State = 1 /\\ Rcv({PID.S.M1}'_A_B) =|>\n       State := 2 /\\\n       Ts2 := new() /\\\n       SAC := Ha(PID.S.Ts2) /\\\n       Snd(Ts.Ts2.SAC)\nend role\n\nrole session(A, B: agent)\ndef=\n  local\n    S: secret\n  composition\n    drone(A, B, Snd, Rcv, Ha) /\\ \n    ground_station(A, B, Snd, Rcv, Ha)\nend role\n\nrole environment()\ndef=\n  const \n    Drone, GroundStation: agent\n    H: hash_func\n  intruder_knowledge = {Drone, GroundStation, H}\n  composition\n    session(Drone, GroundStation) /\\ session(GroundStation, Drone)\n  goals\n    secrecy_of sec_1\n    secrecy_of sec_2\n    secrecy_of sec_3\n    authentication_on auth_1\n    authentication_on auth_2\n    authentication_on auth_3\nend role\n\ngoal\n  secrecy_of sec_1, sec_2, sec_3\n  authentication_on auth_1, auth_2, auth_3\nend goal\n\nenvironment(Environment)"]], "HLPSL-1/LPD-IMSR.hlpsl": [[true, "role base_station(B, M : agent, PKb : public_key, SKb : private_key, Cert_B : text)\nplayed_by B\n\n  def= \n    local State : nat\n    local Nb : text\n    local X : text\n    local SCm : text -- Secret Certificate for Mobile\n    state 0\n    init\n      transition\n        0 -> 1\n        send_1(B, M, Nb, PKb, Cert_B)\n    end role\n\nrole mobile_device(M, B : agent, SKm : private_key, PKb : public_key, Cert_B : text)\nplayed_by M\n\n  def= \n    local State : nat\n    local Nb : text\n    local X : text\n  state 0\n  init\n    transition\n      0 -> 1\n      recv_1(B, M, Nb, PKb, Cert_B)\n      new X -- Generate a symmetric key\n      transition\n        1 -> 2\n        send_2(M, B, {X}_PKb) -- Encrypt symmetric key with base station's public key\n\n      transition\n        2 -> 3\n        send_3(M, B, {<Nb, M, SCm>}_X) -- Encrypt nonce, identity and secret certificate with symmetric key\n    end role\n\nrole session(M, B : agent, SKm : private_key, PKb : public_key, Cert_B : text, SCm : text)\n\n  def=\n\n    composition\n      session_base_station(base_station(B, M, PKb, SKb, Cert_B))\n      session_mobile_device(mobile_device(M, B, SKm, PKb, Cert_B))\n    end role\n\n\ngoal\n\n  secrecy_of X\n\n  authentication_on Nb\n\nenvironment\n\n  const B, M : agent\n  const PKb : public_key\n  const SKb, SKm : private_key\n  const Cert_B, SCm : text\n\n  protocol_role(Alice, Bob : agent, session_keys : public_key_pair)\n\n  session(session(Alice, Bob, SKm, PKb, Cert_B, SCm))\n\nend environment"]], "HLPSL-1/main.hlpsl": [[true, "role RegistrationAuthority_RA(\n    const PRVRa: private_key,\n    const PUBRa: public_key,\n    const PRVCon: private_key,\n    const PUBCon: public_key,\n    const PRVSw: private_key,\n    const PUBSw: public_key,\n    certificate CERTCon: message\n)\n\nplayed_by RA\n\ntransition\n  state_RA1 -> state_RA2\n  label: Generating_Keys\n  event: KeyGen\n  actions:\n    generated(PRVRa, PUBRa);\n    generated(PRVCon, PUBCon);\n    generated(PRVSw, PUBSw);\n    CERTCon := {PUBCon, IDCon, IDCluster}_inv(PRVRa);\n\ntransition\n  state_RA2 -> state_RA3\n  label: Sending_Registration_Message\n  event: SendMsg\n  actions:\n    RAChannel!{CERTCon, PUBCon};\n\nend role\n\nrole Controller_SC(\n    const IDCon: message,\n    const PRVCon: private_key,\n    const CERTCon: message\n)\n\nplayed_by SC\n\ntransition\n  state_SC1 -> state_SC2\n  label: Accepting_Registration_Message\n  event: ReceiveMsg\n  actions:\n    SCChannel?{CERTCon, PUBCon};\n\ntransition\n  state_SC2 -> state_SC3\n  label: Generating_Access_Control_Values\n  event: GenerateValues\n  actions:\n    R1 := fresh();\n    TS1 := fresh();\n    ACON := h(PUBCon, R1, TS1);\n    BCON := h(PUBCon, CERTCon);\n\ntransition\n  state_SC3 -> state_SC4\n  label: Sending_Message_To_Switch\n  event: SendMsg\n  actions:\n    SCChannel!{IDCon, ACON, BCON};\n\nend role\n\nrole Switch_SSW(\n    const IDSw: message,\n    const PRVSw: private_key\n)\n\nplayed_by SSW\n\ntransition\n  state_SSW1 -> state_SSW2\n  label: Accepting_Registration_Message\n  event: ReceiveMsg\n  actions:\n    SSWChannel?{CERTCon, PUBSw};\n\ntransition\n  state_SSW2 -> state_SSW3\n  label: Generating_Access_Control_Values\n  event: GenerateValues\n  actions:\n    R2 := fresh();\n    TS2 := fresh();\n    ASW := h(PUBSw, R2, TS2);\n    BSW := h(PUBSw, CERTSw);\n\ntransition\n  state_SSW3 -> state_SSW4\n  label: Sending_Message_Back_To_Controller\n  event: SendMsg\n  actions:\n    SSWChannel!{IDSw, ASW, BSW};\n\nend role\n\nrole SessionRole\n\ncomposition\n  RA: RegistrationAuthority_RA /\\\\ SC: Controller_SC /\\\\ SSW: Switch_SSW\n\nend role\n\nrole EnvironmentRole\n\nconst IDCluster: message, IDCon: message, IDSw: message\n\nintruder_knowledge = {IDCluster, IDCon, IDSw}\nintruder_knowledge = {PRVRa, PRVCon, PRVSw} -- Making keys confidential\n\nagents = {ra, sc, ssw}\n\nsession\n  RA.IDCon := sc.IDCon\n  RA.IDCluster := IDCluster\n  SC.IDCon := sc.IDCon\n  SC.PRVRa := ra.PRVRa\n  SC.CERTCon := ra.CERTCon\n  SSW.IDSw := ssw.IDSw\n\nend role\n\ngoal\n  secrecy_of_prvRa_auth: secrecy_of PRVRa\n  secrecy_of_prvCon_auth: secrecy_of PRVCon\n  secrecy_of_prvSw_auth: secrecy_of PRVSw\n  authenticity_roleConSw: authentication(Controller_SC, Switch_SSW)\n\nend goal"]], "HLPSL-1/migration.hlpsl": [[true, "role PreviousParent(P, PB, hash: agent, Kbp: symmetric_key, Uniqid: text)\nplayed_by P\ndef=\n  local\n    Idrequest1, Idresponse: text\n  init\n    0\n  transition\n    0 -> 1 \u02c6 \n      recv(PB, P, {Idrequest1}Kbp)\n      =\u02c6 Idrequest1 := Uniqid\n    1 -> 2 \u02c6 \n      send(P, PB, {Idresponse}Kbp)\ngoal\nend role\n\nrole ParentB(PB, N, B, P: agent, Knb, Kbc, Kbp: symmetric_key, Uniqid: text)\nplayed_by PB\ndef=\n  local\n    Idrequest1, Idrequest2, Idresponse, Success: text\n  init\n    0\n  transition\n    0 -> 1 \u02c6 \n      recv(N, PB, {Idrequest2}Knb)\n      =\u02c6 Idrequest1 := Idrequest2\n    1 -> 2 \u02c6 \n      send(PB, B, {Idrequest1}Kbc)\n    2 -> 3 \u02c6 \n      recv(B, PB, {Idresponse}Kbc)\n    3 -> 4 \u02c6 \n      send(PB, N, {Success}Knb)\ngoal\nend role\n\nrole Blockchain(B, PB: agent, Kbc: symmetric_key)\nplayed_by B\ndef=\n  local\n    Idrequest, Idresponse: text\n  init\n    0\n  transition\n    0 -> 1 \u02c6 \n      recv(PB, B, {Idrequest}Kbc)\n    1 -> 2 \u02c6 \n      send(B, PB, {Idresponse}Kbc)\ngoal\nend role\n\nrole NodeN(N, PB, sec_1: agent, Knb: symmetric_key, Uniqid: text)\nplayed_by N\ndef=\n  local\n    Idrequest, Success: text\n  init\n    0\n  transition\n    0 -> 1 \u02c6 \n      send(N, PB, {Idrequest}Knb)\n    1 -> 2 \u02c6 \n      recv(PB, N, {Success}Knb)\ngoal\nend role\n\nrole Environment()\ndef=\n  const\n    sec_1, Uniqid: text\n    nodeN, parentB, blockchain, prevParent, i: agent\n    Knb, Kbp, Kbc: symmetric_key\n  intruder_knowledge = {i, Kbc, Kbp, Knb, nodeN, parentB, blockchain, prevParent}\n  composition\n    session_1(nodeN, parentB, blockchain, prevParent, sec_1, Knb, Kbc, Kbp, Uniqid) \u02c6\n    session_2(nodeN, parentB, blockchain, prevParent, sec_1, Knb, Kbc, Kbp, Uniqid)\nend role\n\ngoal\n  secrecy_of sec_1\nend goal\n\nenvironment()"]], "HLPSL-1/NSPK-fix.hlpsl": [[true, "// HLPSL code for Needham-Schroeder Public-Key Protocol (NSPK)\n\nrole Alice(A, B : agent, Ka, Kb : public_key) \nplayed_by A\n  vars\n    Na, Nb : text\n  init\n    // Initial state for Alice\n    state 0\n  transition\n    // Step 1: Alice sends nonce Na to Bob\n    0 -> 2 \n    label Send_Alice_1\n    event\n      request(A, B, init)\n    action\n      Na := new()\n      send(A, B, {Na.A}_Kb)\n\n    // Step 3: Alice receives Nb from Bob and confirms authentication\n    2 -> 4\n    label Receive_Bob_2\n    event\n      recv(B, A, {Na.Nb.B}_Ka)\n    action\n      send(A, B, {Nb}_Kb)\nend role\n\nrole Bob(B, A : agent, Kb, Ka : public_key) \nplayed_by B\n  vars\n    Na, Nb : text\n  init\n    // Initial state for Bob\n    state 1\n  transition\n    // Step 2: Bob receives Na, generates Nb, and responds\n    1 -> 3\n    label Receive_Alice_1\n    event\n      recv(A, B, {Na.A}_Kb)\n    action\n      Nb := new()\n      send(B, A, {Na.Nb.B}_Ka)\n\n    // Final state for Bob receiving Nb from Alice\n    3 -> 5\n    label Receive_Alice_3\n    event\n      recv(A, B, {Nb}_Kb)\nend role\n\nrole environment()\n  const\n    a, b : agent\n    ka, kb : public_key\n  intruder_knowledge = {ka, kb}\n  composition\n    alice: Alice(a, b, ka, kb)\n    bob: Bob(b, a, kb, ka)\nend role\n\ngoal\n  secrecy of Na, Nb\n  authentication_on init\nend goal\n\nenvironment()"]], "HLPSL-1/optimised_protocol.hlpsl": [[true, "/* Define the roles of the Key Exchange Protocol */\nrole alice(A, B, T: agent, K_at: symmetric_key, SND, RCV: channel(dy)) {\n  var K_ab: symmetric_key;\n  var Nb: nonce;\n  local State: nat;\n\n  init State := 0; \n\n  transition 1. State = 0 /\\ RCV(T.{B, K_ab}_K_at) =|> \n    State := 1 /\\ \n    send(SND, {(B, Nb)}_K_ab);\n\n  transition 2. State = 1 /\\ RCV({Nb}_K_ab) =|> \n    State := 2; \n}\n\nrole bob(B, A, T: agent, K_bt: symmetric_key, SND, RCV: channel(dy)) {\n  var K_ab: symmetric_key;\n  var Nb: nonce;\n  local State: nat;\n\n  init State := 0;\n\n  transition 1. State = 0 /\\ RCV(T.{A, K_ab}_K_bt) =|> \n    State := 1 /\\\n    gen(Nb) /\\\n    send(SND, {(B, Nb)}_K_ab);\n\n  transition 2. State = 1 /\\ RCV({Nb}_K_ab) =|>\n    State := 2;\n}\n\nrole trusted_server(T, A, B: agent, K_at, K_bt: symmetric_key, SND_A, RCV_A, SND_B, RCV_B: channel(dy)) {\n  var K_ab: symmetric_key;\n  local State: nat;\n\n  init State := 0;\n\n  transition 1. State = 0 /\\ RCV_A(A.{B, K_ab}_K_at) =|> \n    State := 1 /\\\n    send(SND_B, {(A, K_ab)}_K_bt);\n}\n\nrole environment() {\n  const A, B, T: agent;\n  const K_at, K_bt: symmetric_key;\n\n  vars\n    Ri_a, Ri_b, Ni_b: message;\n\n  intruder_knowledge = {A, B, T, K_at, K_bt};\n\n  composition\n    alice(A, B, T, K_at, alice_SND, alice_RCV)\n    /\\ bob(B, A, T, K_bt, bob_SND, bob_RCV)\n    /\\ trusted_server(T, A, B, K_at, K_bt, trusted_SND_A, trusted_RCV_A, trusted_SND_B, trusted_RCV_B)\n\n  // Define security goals\n  goals\n    secrecy_of K_ab\n    authentication_on Nb\n}\n\n/* Main composition */\nenvironment()"]], "HLPSL-1/PBK-fix-weak-auth.hlpsl": [[true, "// HLPSL specification for \"Purpose Built Keys Framework\" protocol with weak authentication.\n\nprotocol PBK_Weak_Authentication\n  // Declare participants\n  role Alice(A, B: agent, PK_A: public_key) \n  played_by A\n  const tag1, tag2: text\n  const hash: hash_func, inv: inverse_func\n\n  // Local variables\n  var Msg: text\n  var Nb: text\n  \n  // Initial state\n  init\n    0. State := 0\n\n  transition\n    // Alice sends her identity, public key and hash of public key\n    1. State = 0 /\\ RCV(<A>) ->\n       State' := 1\n       SND(<A, PK_A, hash(PK_A)>) \n\n    // Alice sends first message with Tag1 and nonce\n    2. State = 1 /\\ RCV(<B, Nb>) ->\n       Msg' := new()\n       State' := 2\n       SND(<tag1, {Msg'}_inv(PK_A)>)\n\n    // Alice validates the nonce and responds with Tag2 and nonce\n    3. State = 2 /\\ RCV({Nb}_inv(PK_A)) ->\n       State' := 3\n       SND(<tag2, {Nb}_PK_A>)\n\n  end role\n\n  role Bob(A, B: agent, PK_B: public_key)\n  played_by B\n  const tag1, tag2: text\n  const hash: hash_func\n\n  // Local variables\n  var MsgHash: text\n  var Nb: text\n\n  init\n    0. State := 0\n\n  transition\n    // Bob receives Alice's identity and public key hash\n    1. State = 0 /\\ RCV(<A, PK_A, MsgHash>) ->\n       MsgHash' := hash(PK_A)\n       State' := 1\n       SND(<B, Nb'>)\n\n    // Bob checks the message hashed and sends nonce\n    2. State = 1 /\\ RCV(<tag1, {MsgHash}_inv(PK_B)>) ->\n       Nb' := new()\n       State' := 2\n       SND({Nb'}_inv(PK_A))\n\n    // Bob verifies the final message\n    3. State = 2 /\\ RCV(<tag2, {Nb}_PK_B>) -> \n       State' := 3\n       // Protocol conclusion, handles security properties\n\n  end role\n\ngoal\n  secrecy_of Nb\n\n  weak_authentication_on Msg\n\nend goal\n\nenvironment\n  const tag1, tag2: text\n  const hash: hash_func\n  intruder_knowledge = {tag1, tag2, hash}\n\n  role_alice(Alice)\n  role_bob(Bob)\n\n  composition\n    Alice(A, B, PK_A) | Bob(A, B, PK_A)\n\nend environment\n\nsection environment\nend section"]], "HLPSL-1/PMAP_D2D.hlpsl": [[true, "// PMAP_D2D Protocol Model\nrole drone_A(A, B, Z: agent, CRP: symmetric_key, Na: text, SND, RCV: channel(dy))\nplayed_by A\n\nvars\n  Nz: text\n  Na2: text\n  Ca: text\n\nconst\n  dummy: text\n\ninit\n  0\n\ntransition\n  // Drone A initiates the protocol\n  step1: state(0) -> state(1)\n  message := {A.B.Na}'CRP\n  SND(message)\n\n  // Drone A receives challenge from Ground Station\n  step2: state(1) -> state(2)\n  RCV({A.B.Nz}'CRP)\n\n  Nz := comp(Nz) // exchange nonce\n  Ca := hash(Nz.dummy) // confirmation message\n\n  // Drone A sends response to Ground Station\n  step3: state(2) -> state(3)\n  Na2 := new()\n  message := {Na2.Ca.Na.Nz}'CRP\n  SND(message)\n\nend role\n\nrole drone_B(B, A, Z: agent, CRPb: symmetric_key, Nb: text, SND, RCV: channel(dy))\nplayed_by B\n\nvars\n  Nz2: text\n\nconst\n  dummy: text\n\ninit\n  0\n\ntransition\n  // Drone B receives challenge from Ground Station\n  step1: state(0) -> state(1)\n  RCV({A.B.Na2.Nz2}'CRPb)\n\n  Nz2 := comp(Nz2) // confirmation\n\n  // Drone B sends response to Ground Station\n  step2: state(1) -> state(2)\n  message := {Nb.Nz2}'CRPb\n  SND(message)\n\nend role\n\nrole ground_station(Z, A, B: agent, CRP: symmetric_key, CRPb: symmetric_key, SNDa, RCVa, SNDb, RCVb: channel(dy))\nplayed_by Z\n\nvars\n  Na: text\n  Nz: text\n  Na2: text\n  Ca: text\n  Nb: text\n  Nz2: text\n\nconst\n  dummy: text\n\ninit\n  0\n\ntransition\n  // Ground Station receives initial message from Drone A\n  step1: state(0) -> state(1)\n  RCVa({A.B.Na}'CRP)\n\n  Nz := new() // generate nonce\n  message := {A.B.Nz}'CRP\n  SNDa(message)\n\n  // Ground Station receives response from Drone A\n  step2: state(1) -> state(2)\n  RCVa({Na2.Ca.Na.Nz}'CRP)\n\n  // Forward challenge to Drone B\n  step3: state(2) -> state(3)\n  Nz2 := new() // generate new nonce\n  message := {A.B.Na2.Nz2}'CRPb\n  SNDb(message)\n\n  // Ground Station receives response from Drone B\n  step4: state(3) -> state(4)\n  RCVb({Nb.Nz2}'CRPb)\n\n  // Ground Station sends final confirmation to Drone A\n  step5: state(4) -> state(5)\n  message := {Na.Na2.Nz.Nz2.Nb}'CRP\n  SNDa(message)\n\nend role\n\ngoal\n  secrecy_of Na, Na2, Nz, Nb, Nz2\n  authentication_on message_A_to_Z1, message_G_to_A5\n\nenvironment env()\nbalance\n  new(A, B, Z: agent)\n  new(CRP, CRPb: symmetric_key)\n  new(Na, Nb: text)\n\ncomposition\n  drone_A(A, B, Z, CRP, Na, SNDa, RCVa) |\n  drone_B(B, A, Z, CRPb, Nb, SNDb, RCVb) |\n  ground_station(Z, A, B, CRP, CRPb, SNDa, RCVa, SNDb, RCVb)\n\nend environment\n\nsession\n  protocol_session(env)\nend session"]], "HLPSL-1/practice3.hlpsl": [[true, "role alice(Client, AuthServer, ServiceServer : agent,\n           Ka : symmetric_key, Kb : symmetric_key)\n\nplayed_by Client\n\ndef= \n  local\n    Na, Nb, Ns : text\n    K' : symmetric_key\n    state : nat\n  init\n    state := 0\n  transition\n    0 -> 1 \n      * msg(1) = ServiceServer.start \n      =|> nonce(Na) \n      \t /\\ send_1(Client, AuthServer, {Na, Client, ServiceServer}'_Ka)\n    1 -> 2\n      * received_2(AuthServer, Client, {Na, K', Ns, {Na, K', Client}_Kb}'_Ka)\n      =|> send_2(Client, ServiceServer, {Na, K', Client}_Kb)\n\nend role\n\nrole authserver(Client, ServiceServer, AuthServer: agent,\n                Ka : symmetric_key, Kb : symmetric_key)\n\nplayed_by AuthServer\n\ndef= \n  local\n    Na, Nb, Ns : text \n    K' : symmetric_key\n    state : nat\n  transition\n    1 -> 1\n      * received_1(Client, AuthServer, {Na, Client, ServiceServer}'_Ka)\n\t  * new(K') /\\ new(Ns)\n      =|> send_1(AuthServer, Client, {Na, K', Ns, {Na, K', Client}_Kb}'_Ka)\nend role\n\nrole bob(ServiceServer, AuthServer, Client: agent,\n         Kb : symmetric_key)\n\nplayed_by ServiceServer\n\ndef= \n  local\n    Na, Nb, Ns : text\n    K' : symmetric_key\n    state : nat\n  init\n    state := 0\n  transition\n    0 -> 1\n      * recv_1(Client, ServiceServer, {Na, K', Client}_Kb)\n      =|> send_1(ServiceServer, Client, {Na, Nb, Ns, K'}_Kb)\n\nend role\n\ngoal\n  secrecy_of  K'\n  authentication_on K'\nend goal\n\nenvironment(env)\n\ndef= \n  const\n    Ka, Kb : symmetric_key\n    A, B, S : agent\n  intruder_knowledge = {A, B, S, i, Ka, Kb}\n  composition\n    alice(A, S, B, Ka, Kb) /\\ \n    authserver(A, B, S, Ka, Kb) /\\ \n    bob(B, S, A, Kb)\nend environment"]], "HLPSL-1/Project1Protocol.hlpsl": [[true, "// Role Alice\nrole Alice(A, B, S: agent, K_AS: symmetric_key)\nplayed_by A\n\n  // Variables\n  nonce Na, Nb: text\n  session_key K_AB: symmetric_key\n  const A, B, S: agent\n\n  // State initialization\n  init\n    0 -> State \n    new Na\n\n  // Transitions\n  transition\n\n    1. State -> State'\n      send_1(A, B)\n\n    2. State -> State'\n      receive_2(B, A, {A, Nb'}_K_BS)\n      send_3(A, S, {A, B, Na, {A, Nb'}_K_BS}_K_AS)\n\n    3. State -> State'\n      receive_4(S, A, {K_AB, Na, B}_K_AS)\n      send_5(A, B, {Na}_K_AB)\n\n    4. State -> State'\n      receive_6(B, A, {Nb'}_K_AB)\n      end\nend role\n\n// Role Bob\nrole Bob(B, A, S: agent, K_BS: symmetric_key)\nplayed_by B\n\n  // Variables\n  nonce Nb': text\n  session_key K_AB: symmetric_key\n  const A, B, S: agent\n\n  // State initialization\n  init\n    0 -> State \n    new Nb'\n\n  // Transitions\n  transition\n\n    1. State -> State'\n      receive_1(A, B)\n      send_2(B, A, {A, Nb'}_K_BS)\n\n    2. State -> State'\n      receive_5(A, B, {Na}_K_AB)\n      send_6(B, A, {Nb'}_K_AB)\n      end\nend role\n\n// Role Server\nrole Server(S, A, B: agent, K_AS, K_BS: symmetric_key)\nplayed_by S\n\n  // Variables\n  nonce Na, Nb': text\n  session_key K_AB: symmetric_key\n  const A, B, S: agent\n\n  // State initialization\n  init\n    0 -> State \n\n  // Transitions\n  transition\n\n    1. State -> State'\n      receive_3(A, S, {A, B, Na, {A, Nb'}_K_BS}_K_AS)\n      new K_AB\n      send_4(S, A, {K_AB, Na, B}_K_AS)\n      send_4(S, B, {K_AB, Nb'}_K_BS)\n      end\nend role\n\n// Environment role\nrole environment()\n\n  // Agents\n  const A, B, S: agent\n  composition\n    Alice(A, B, S, K_AS) \n    Bob(B, A, S, K_BS)\n    Server(S, A, B, K_AS, K_BS)\nend role\n\n// Goals\ngoal\n  authentication_on Na\n  authentication_on Nb'\n  secrecy_of K_AB\n\n// Specification\nspecification\n  A, B, S: agent\n  K_AS, K_BS: symmetric_key\n  session_key K_AB: symmetric_key\n  environment()\nend specification"]], "HLPSL-1/An_Anonymous_Key_Distribution_Scheme_for_Group_Healthcare_Services_in_5G-Enabled_Multi-Server_Environments.hlpsl": [[true, "// HLPSL code for Secure User Authentication Protocol\n\nrole user(U, S: agent, Kus, SKij: symmetric_key, Ks: public_key,\n          H, H4, H5: hash_func, Sub, Add, Mul: nat) {\n\n  const IDU, PW, Bi: text;\n  var V, g1, g2, g3: text;\n  var U_S_V: message;\n\n  init {\n    V := new();\n  }\n\n  transition\n  1. State_0 -> State_1\n    // User sends registration info to server\n    send_1( (IDU, PW, Bi) );\n\n  2. State_1 -> State_2\n    // User receives encrypted response from server\n    receive_2( {g1}Kus );\n\n  3. State_2 -> State_3\n    // User sends login credentials and nonce to server\n    send_3( (IDU, PW, V, g1) );\n\n  4. State_3 -> State_4\n    // User receives server confirmation and session key\n    receive_4( {U_S_V, SKij}Kus );\n\n  sectrans goals\n  goal\n    secrecy_of g1\n}\n\n// Server role\nrole server(U, S: agent, Kus: symmetric_key, Ks: public_key,\n            H, H4, H5: hash_func, Sub, Add, Mul: nat) {\n\n  const IDU, PW, Bi: text;\n  var g1, g2, g3, g4, g5: text;\n  var U_S_V, S_U_TS: message;\n\n  transition\n  1. State_0 -> State_1\n    // Server receives registration info from user\n    receive_1( (IDU, PW, Bi) );\n\n  2. State_1 -> State_2\n    // Server sends back encrypted response with generated key\n    send_2( {g1}Kus );\n\n  3. State_2 -> State_3\n    // Server receives login credentials and nonce from user\n    receive_3( (IDU, PW, V, g1) );\n\n  4. State_3 -> State_4\n    // Server sends confirmation and session key\n    send_4( {U_S_V, SKij}Kus );\n\n  sectrans goals\n  goal\n    secrecy_of g2\n\n}\n\n// Environment role\nrole environment() {\n\n  const KU, KS: public_key;\n  const SKij: symmetric_key;\n  const H, H4, H5: hash_func;\n  const Sub, Add, Mul, V: nat;\n\n  composition\n    user(U, S, KU, SKij, KS, H, H4, H5, Sub, Add, Mul)\n    server(U, S, KU, KS, H, H4, H5, Sub, Add, Mul)\n\n  intruder_knowledge = {KU, KS}\n\n  goal\n    secrecy_of g3, g4, g5\n    authentication_on U_S_V\n    authentication_on S_U_TS\n}\n\n// Bind agent identities\ntutorial(env_hlr1:\n  session(U, S, KU, SKij, KS, H, H4, H5, Sub, Add, Mul)\n)\n\n// Run protocol analysis\nrole goal() {\n\n  environment()\n\n  goal\n    secrecy_of g1, g2, g3, g4, g5\n    authentication_on U_S_V\n    authentication_on S_U_TS\n}\n\nspecification goal"]], "HLPSL-1/Projet.hlpsl": [[true, "// HLPSL Specification for Automated Toll Badge Management Protocol\n\n// Environment roles\nrole database()\nplayed_by DB\n\nconst PKs, PKc, IDSmartPhone : public_key\nconst ClefSession : symmetric_key\n\nvars\n    Balance : numeric\n\nend role\n\n// Roles\nrole client(C, S, PKs: public_key, PKc: public_key)\nplayed_by C\n\nconst Bonjour : message\nvar Ns, Nc : message\nfresh Nonce_C : message\n\ninit\n    step1: sent(Bonjour)\n\ntransition\n\n  1. State1 -> State2\n   {\n       send_1(C,S): {Bonjour}_PKs\n   }\n\n  2. State2 -> State3\n   {\n       recv_2(S,C): {Ns}_PKc\n       send_3(C,S): {Nonce_C.Ns}_PKs\n   }\n\n  3. State3 -> State4\n   {\n       recv_4(S,C): {Nc.ClefSession}_PKc\n       send_5(C,S): {IDSmartPhone}_ClefSession\n   }\n\n  4. State4 -> State5\n   {\n       recv_6(S,C): {Ack}_ClefSession\n       send_7(C,S): {End}_ClefSession\n   }\nend role\n\nrole server(S, C, PKs: public_key, PKc: public_key, DB: agent)\nplayed_by S\n\nvar Ns, Nc : message\nfresh Nonce_S : message\ninit\n    step1: expect({Bonjour}_PKs)\n\ntransition\n\n  1. State1 -> State2\n   {\n       recv_1(C,S): {Bonjour}_PKs\n       send_2(S,C): {Nonce_S}_PKc\n   }\n\n  2. State2 -> State3\n   {\n       recv_3(C,S): {Nc.Ns}_PKs\n       fresh ClefSession: message\n       send_4(S,C): {Nc.ClefSession}_PKc\n   }\n\n  3. State3 -> State4\n   {\n       recv_5(C,S): {IDSmartPhone}_ClefSession\n       get_balance(DB, IDSmartPhone):Balance\n       if (Balance > 0) then\n           send_6(S,C): {Ack}_ClefSession\n       else\n           send_6(S,C): {AckFail}_ClefSession\n       end if\n   }\nend role\n\n// HLPSL Goals\ngoal\n  secrecy_of Nc, Ns, ClefSession, IDSmartPhone\n  authentication_on Bonjour\n\n// HLPSL Session\nrole session()\nconst PKs, PKc : public_key\ncomposition\n    client(C,S,PKs,PKc) /\\\n    server(S,C,PKs,PKc,DB) /\\\n    database()\nend role\n\nenvironment()\ncomposition\n    session()\nend role"]], "HLPSL-1/protocol.hlpsl": [[true, "/////////////////////////////////////////////////////////////////\n// HLPSL Specification for Blockchain-based Access Control Scheme\n/////////////////////////////////////////////////////////////////\n\n// Hash functions\nhash_function H, EccMul, Add;\n\n// Basic types\ntype simple_type;\n\n// Channels\nchannel(SND, Snd), channel(RCV, Rcv);\n\n// Agents\nrole control_room(CR, DR1, DR2: agent,\n                  PK_CR, PK_DR1, PK_DR2: public_key, \n                  SK_CR: private_key, \n                  SND, RCV: channel(dy)) {\n\n  sent_PK_DR1 := false;\n  sent_PK_DR2 := false;\n\n  init: \n    state := 0\n\n  transition\n\n    0 -> 1  // Start registration with DR1\n    // CR to DR1: <PK_CR, Certificate_DR1>\n      CR.RCV(?PK_CR, !Certificate_DR1) / sent_PK_DR1 := true -> Snd\n      ({DR1, CR, PK_CR, Certificate_DR1}'', SK_CR)\n    \n    1 -> 2  // Start registration with DR2\n    // CR to DR2: <PK_CR, Certificate_DR2>\n      CR.RCV(?PK_CR, !Certificate_DR2) / sent_PK_DR2 := true -> Snd\n      ({DR2, CR, PK_CR, Certificate_DR2}'', SK_CR)\n\n    2 -> 3  // Await acknowledgement of completion\n    // Expect successful registration messages from DR1 & DR2\n      CR.RCV(!Acknowledgement_DR1, !Acknowledgement_DR2)\n}\n\n// Role for Drone 1\nrole drone_1(DR1, CR, DR2: agent, PK_DR1: public_key, SK_DR1: private_key, SND, RCV: channel(dy)) {\n\n  secret1: simple_type\n  processed_Msgd1d2 := false\n  processed_Msgd2d3 := false\n\n  init:\n    state := 0\n\n  transition\n\n    0 -> 1  // Register with CR\n    // Receive from CR: <PK_DR1, Certificate_DR1>\n      DR1.RCV(!PK_DR1, !Certificate_DR1) -> Snd\n      ({DR1, Certificate_DR1}'', SK_DR1)\n\n    1 -> 2  // Compute own keys\n      witness(DR1, CR, PK_DR1)\n      secret1 := EccMul(PK_DR1, SK_DR1)\n\n    2 -> 3  // Initiate communication with DR2\n    // Send to DR2: Msgd2d1 with secret1\n      DR1.RCV(!Packet_DR2) -> Snd\n      (Msgd2d1, {secret1}'', SK_DR1) \n    \n    3 -> 4  // Process acknowledgment from DR2 (Msgd1d2)\n      processed_Msgd1d2 := true\n\n    4 -> 5  // Final message to DR2 (Msgd2d3)\n    // Final processing\n      processed_Msgd2d3 := true\n}\n\n// Role for Drone 2\nrole drone_2(DR2, CR, DR1: agent, PK_DR2: public_key, SK_DR2: private_key, SND, RCV: channel(dy)) {\n\n  secret2: simple_type\n  processed_Msgd2d1 := false\n  \n  init:\n    state := 0\n\n  transition\n\n    0 -> 1  // Register with CR\n    // Receive from CR: <PK_DR2, Certificate_DR2>\n      DR2.RCV(!PK_DR2, !Certificate_DR2) -> Snd\n      ({DR2, Certificate_DR2}'', SK_DR2)\n\n    1 -> 2  // Compute own keys\n      witness(DR2, CR, PK_DR2)\n      secret2 := EccMul(PK_DR2, SK_DR2)\n\n    2 -> 3  // Receive message from DR1 (Msgd2d1)\n      secret_packet := {secret2}''\n      DR2.RCV(!Msgd2d1, secret_packet) -> Snd\n      (Msgd1d2, {secret2}'', SK_DR2)\n\n    3 -> 4  // Send acknowledgment to DR1 (Msgd1d2)\n      processed_Msgd2d1 := true\n}\n\n////////////////////////////////////////////////////////////////////\n// Environment\n////////////////////////////////////////////////////////////////////\n\nrole environment() {\n\n  const PK_CR, PK_DR1, PK_DR2: public_key\n  const SK_CR, SK_DR1, SK_DR2: private_key\n\n  composition\n    session_1: control_room(CR, DR1, DR2, PK_CR, PK_DR1, PK_DR2, SK_CR, SND, RCV)\n    session_2: drone_1(DR1, CR, DR2, PK_DR1, SK_DR1, SND, RCV)\n    session_3: drone_2(DR2, CR, DR1, PK_DR2, SK_DR2, SND, RCV)\n\n  const intruder_knowledge = {SK_DR1, SK_DR2, PK_CR} // Assume keys known to intruder are only public keys\n\n}\n\n///////////////////\n// Goal\n///////////////////\n\ngoal\n\n  secrecy_of secret1, secret2\n  authentication_on PK_DR1, PK_DR2, Acknowledgement_DR1, Acknowledgement_DR2\n\nend goal\n///////////////////\n// ///////////////\n\n// Main role for execution\ngoal\n  secrecy_of secret1, secret2\n  authentication_on PK_DR1, PK_DR2, Acknowledgement_DR1, Acknowledgement_DR2\nend goal\n\nenvironment\n\n  session(compose principal; composition)\n\nend environment"]], "HLPSL-1/RegVBNS.hlpsl": [[true, "role client(C, M: agent, Kc: symmetric_key, Kp: public_key, SND, RCV: channel(dy))\n    var Na, Pd: text\n    init\n        state := 0\n    transition\n        0 -> 1  /* Step 1: Client Initiation */\n        label: Client_Initiation\n        send_1(SND, {Na'.Pd}_Kc)\n\nrole miner(M, C: agent, Kc: symmetric_key, SND, RCV: channel(dy))\n    var Na, Nm: text\n    init\n        state := 0\n    transition\n        0 -> 1  /* Step 2: Response from Miner */\n        label: Miner_Response\n        recv_1(RCV, {Na.Pd}_Kc)\n        Nm := new()\n        send_2(SND, {hash(Pd).Na}_Kc)\n\n        1 -> 2  /* Step 3: Key Exchange */\n        label: Key_Exchange\n        send_3(SND, {Kp}_Kc)\n      \ngoal\n    secrecy_of Na, Pd\n\nenvironment()\n    const\n        Kc: symmetric_key\n        Kp: public_key\n        C, M: agent\n        sec_1, sec_2: protocol_id\n\n    intruder_knowledge = {C, M, Kc, Kp}\n\n    composition\n        session1: client(C, M, Kc, Kp, SND, RCV)\n        session2: miner(M, C, Kc, SND, RCV)\n\n    end role\nend environment"]], "HLPSL-1/safe_new_syntax.hlpsl": [[true, "role alice(A, B : agent, Ka, Kb : public_key, SndMsgFormat : text) \nplayed_by A \ndef= \n  local \n    State : nat, \n    Na, PMS, SessionKey : text, \n    Sid : protocol_id \n  init \n    State := 0 \n  transition \n    0 -> 1 \n      * receive(SndMsgFormat = SndMsgFormat) \n      =|> \n      Na' := new() \n      Sid' := new() \n      send(A, B, {A, Na', Sid', SndMsgFormat}) \n    \n    1 -> 2 \n      * receive(B, A, {Nb', {Sid', SndMsgFormat'}}) \n      =|> \n      PMS' := new() \n      SessionKey' := PRF(PMS', Na', Nb') \n      send(A, B, {enc(PMS', Kb)}) \n    \n    2 -> 3 \n      * receive(B, A, {verify}) \n      =|> \n      send(A, B, {finish}) \nend role \n\nrole bob(A, B : agent, Ka, Kb : public_key)\nplayed_by B\ndef= \n  local \n    State : nat, \n    Nb, Sid, PMS, SessionKey : text \n  init \n    State := 0 \n  transition \n    0 -> 1 \n      * receive(A, B, {A, Na', Sid', SndMsgFormat'}) \n      =|> \n      Nb' := new() \n      Sid' := Sid' // Reuse same Sid \n      send(B, A, {Nb', {Sid', SndMsgFormat'}}) \n    \n    1 -> 2 \n      * receive(A, B, {enc(PMS', Kb)}) \n      =|> \n      SessionKey' := PRF(PMS', Na', Nb') \n      send(B, A, {verify}) \n    \n    2 -> 3 \n      * receive(A, B, {finish}) \n      =|> \n      send(B, A, {finish})\nend role \n\nrole session_alice_bob(A, B : agent) \ncomponents: alice(A, B, Ka, Kb, SndMsgFormat), bob(A, B, Ka, Kb) \nend role \n\nrole environment() \nconst \n  Ka, Kb, Ks : public_key, \n  SndMsgFormat : text \nintruder_knowledge = {Ka, Kb, Ks} \ncomposition \n  session_alice_bob(A, B) \nend role \n\ngoal \nsecrecy_of_session_key(SessionKey) \nauthentication_on alice_bob_na_nb \nauthentication_on bob_alice_na_nb \nend goal \n\nenvironment()"]], "HLPSL-1/SmartCard.hlpsl": [[true, "/* HLPSL Specification for Secure User Authentication Protocol */\n\n/* Role Definitions */\nrole user(A, B: agent, S: symmetric_key, H: hash_func)\ndef=\n  local\n    UID, PW: text        /* User ID and Password */\n    NONCE_A, TID: text   /* Nonce generated by User and Ticket ID */\n    MSG1, MSG5: message  /* Messages exchanged between User and Server */\n  const\n    h: hash_func \n  init\n    state_0\n  transition\n    state_0 -> state_1 \n    /* User initiates registration with Server by sending ID and Nonce */\n      msg := {UID, NONCE_A}\n      snd(A,B,msg)\n\n    state_1 -> state_2 \n    /* User receives a smart card */\n      rcv(B,A,MSG1)\n      secret(S, {A,B})\n\n    state_2 -> state_3 \n    /* User attempts login */\n      hashedPW := h(PW)\n      msg := {UID, hashedPW}\n      snd(A,B,msg)\n\n    state_3 -> state_4 \n    /* User generates ticket */\n      TID := h(UID, NONCE_A)\n      msg := {UID, TID, NONCE_A}\n      snd(A,B,msg)\n\n    state_4 -> state_5 \n    /* User and Server exchange confirmation messages */\n      rcv(B,A,MSG5)\n      msg := h(S, TID, NONCE_A)\n      snd(A,B,msg)\n\nend role\n\nrole server(A,B: agent, S: symmetric_key, H: hash_func)\ndef=\n  local\n    UID, NONCE_B: text    /* Server-managed User ID and Nonce */\n    TID, SK: text         /* Generated Ticket ID and Session Key */\n    MSG2, MSG3, MSG4: message /* Messages exchanged between User and Server */\n  const\n    h: hash_func\n  init\n    state_0\n  transition\n    state_0 -> state_1 \n    /* Server receives registration information */\n      rcv(A,B,MSG2)\n      NONCE_B := h(MSG2)\n      secret(S, {A,B})\n\n    state_1 -> state_2 \n    /* Server sends the smart card to User */\n      msg := {UID, ~S}\n      snd(B,A,msg)\n\n    state_2 -> state_3 \n    /* Server verifies login attempt */\n      rcv(A,B,MSG3)\n      hashedCred := h(UID, MSG3)\n      SK := h(S, UID)\n\n    state_3 -> state_4 \n    /* Server verifies ticket and computes session key */\n      rcv(A,B,MSG4)\n      TID := h(UID, NONCE_B)\n      msg := {SK, TID, NONCE_B}\n      snd(B,A,msg)\n\n    state_4 -> state_5 \n    /* Confirmation message exchange */\n      msg := h(SK, TID, NONCE_A)\n      snd(B,A,msg)\n\nend role\n\nrole session(A,B: agent, S: symmetric_key, H: hash_func)\ndef=\n  composition\n    user(A, B, S, H)\n    server(A, B, S, H)\nend role\n\nrole environment()\ndef=\n  const\n    A, B: agent\n    S: symmetric_key\n    H: hash_func\n  intruder_knowledge = {A, B, H}\n  composition\n    session(A, B, S, H)\n  end composition\nend role\n\n/* Goals */\ngoal\n  secrecy_of S\n  authentication_on TID\n  weak_authentication_on VID\n  authentication_on SK\n\nenvironment()"]], "HLPSL-1/SMC-5-Party.hlpsl": [[true, "// Define the protocol roles\n\nrole roleA(A, B, C, D, E: agent, A_pk, B_pk, C_pk, D_pk, E_pk: public_key, sec_1: secret) \nplayed_by A\nfresh Xa, Ya: nonce\ndef=\n   step1. A -> {B, C, D, E}: {Xa, Ya}pk(B), {Xa, Ya}pk(C), {Xa, Ya}pk(D), {Xa, Ya}pk(E);\n   step2. B -> A: {Xb, hash(Xb, Yb)}pk(A);\n   step3. C -> A: {Xc, hash(Xc, Yc)}pk(A);\n   step4. D -> A: {Xd, hash(Xd, Yd)}pk(A);\n   step5. E -> A: {Xe, hash(Xe, Ye)}pk(A)\n\nend role\n\nrole roleB(B, A, C, D, E: agent, B_pk, C_pk, D_pk, E_pk: public_key) \nplayed_by B\nfresh Xb, Yb: nonce\ndef=\n   step1. A -> B: {Xa, Ya}pk(B);\n   step2. B -> A: {Xb, hash(Xb, Yb)}pk(A);\n   step3. B -> {C, D, E}: {Xb, Yb}pk(C), {Xb, Yb}pk(D), {Xb, Yb}pk(E)\n\nend role\n\nrole roleC(C, A, B, D, E: agent, C_pk, D_pk, E_pk: public_key) \nplayed_by C\nfresh Xc, Yc: nonce\ndef=\n   step1. A -> C: {Xa, Ya}pk(C);\n   step2. C -> A: {Xc, hash(Xc, Yc)}pk(A);\n   step3. C -> {D, E}: {Xc, Yc}pk(D), {Xc, Yc}pk(E)\n\nend role\n\nrole roleD(D, A, B, C, E: agent, D_pk, E_pk: public_key) \nplayed_by D\nfresh Xd, Yd: nonce\ndef=\n   step1. A -> D: {Xa, Ya}pk(D);\n   step2. D -> A: {Xd, hash(Xd, Yd)}pk(A);\n   step3. D -> E: {Xd, Yd}pk(E)\n\nend role\n\nrole roleE(E, A, B, C, D: agent, E_pk: public_key) \nplayed_by E\nfresh Xe, Ye: nonce\ndef=\n   step1. A -> E: {Xa, Ya}pk(E);\n   step2. E -> A: {Xe, hash(Xe, Ye)}pk(A);\nend role\n\n// Define the goal of the protocol\ngoal\n   secrecy_of sec_1\n   authentication_on Xb, Xc, Xd, Xe\nend goal\n\n// Define the environment where the roles are instantiated\nenvironment roles_environment\ndef=\n   const sec_1: secret\n   \n   agent A, B, C, D, E\n   \n   :-\n      roleA(A, B, C, D, E, A.pk, B.pk, C.pk, D.pk, E.pk, sec_1)\n      roleB(B, A, C, D, E, B.pk, C.pk, D.pk, E.pk)\n      roleC(C, A, B, D, E, C.pk, D.pk, E.pk)\n      roleD(D, A, B, C, E, D.pk, E.pk)\n      roleE(E, A, B, C, D, E.pk)\nend environment"]], "HLPSL-1/SPEKE.hlpsl": [[true, "/* SPEKE Protocol in HLPSL */\n\nrole Alice(A, B: agent, S: symmetric_key) \nplayed_by A \n\ndef= \nlocal \n    Na, Nb: random; \n    Ca, Cb: text;\n    K: session_key; \ninit \n    state_0: \n        /* Start the protocol. */\n        send_1(A, B, {exp(S, Na)}); \n\ntransition \n    state_0 -> state_1 \n        recv_1(B, A, {exp(S, Nb)}) \n    / \n        /* Compute the shared session key. */\n        K := exp(exp(S, Nb), Na) \n    -> \n        send_2(A, B, {Ca} symmetric_encrypt K); \n\n    state_1 -> state_2 \n        recv_2(B, A, {Cb, Ca} symmetric_encrypt K) \n    / \n        /* Verify the challenge from Bob. */\n        =_ in Cb \n    -> \n        send_3(A, B, {Cb} symmetric_encrypt K);\n\nend role\n\nrole Bob(B, A: agent, S: symmetric_key) \nplayed_by B \n\ndef= \nlocal \n    Na, Nb: random; \n    Ca, Cb: text; \n    K: session_key; \ninit \n    state_0: \n        /* Waiting for Alice\u2019s initiation */\n        recv_1(A, B, {exp(S, Na)}); \n\ntransition \n    state_0 -> state_1 \n        send_1(B, A, {exp(S, Nb)}) \n    / \n        /* Compute the shared session key. */\n        K := exp(exp(S, Na), Nb) \n    -> \n        recv_2(A, B, {Ca} symmetric_encrypt K); \n\n    state_1 -> state_2 \n        send_2(B, A, {Cb, Ca} symmetric_encrypt K) \n    / \n        /* Verify the challenge from Alice. */\n        =_ in Ca \n    -> \n        recv_3(A, B, {Cb} symmetric_encrypt K); \n\nend role\n\ngoal \n    secrecy_of Ca, Cb \n    authentication_on Ca, Cb \n\nenvironment env \n\ndef= \n    Alice(A, B, S) \n    Bob(B, A, S) \nend environment\n\ncomposition \n    A, B, S, env \nend composition\n\n/* Specification of the Initial Intruder Knowledge */\nintruder_knowledge = {A, B, S}"]], "HLPSL-1/SRP.hlpsl": [[true, "/* \n   SRP (Secure Remote Passwords) Protocol\n   Modelers: Haykal Tej, Siemens CT IC 3, 2003\n             Sebastian M\u00f6dersheim, ETH Z\u00fcrich\n*/\n\n/****************** Roles *******************/\n\n/* Role for the client (Alice) */\nrole alice(A, B, p: agent, passwd: text, SND, RCV: channel (dy))\nplayed_by A\ndef=\n    local\n        Na: random_nonce,\n        X: text,\n        G_Na: text,\n        M: text,\n        K: text,\n        H: hash\n    init\n        state_0\n    transition\n        1. state_0 -> state_1\n            * new(Na);\n            * X := A;\n            * G_Na := exp(g, Na, p);\n            * send_!1(A, B, X, G_Na) to B\n    \n        2. state_1 -> state_2\n            * receive_!2(B, A, s, G_Nb_V) from B;\n            * M := compute_m(G_Nb_V, s, Na, passwd);\n            * send_!3(A, B, M) to B\n    \n        3. state_2 -> state_3\n            * receive_!4(B, A, H) from B;\n            * K := hash(Na, M, H, passwd);\n            * secret(K, sec_i_K, {A, B})\nend role\n\n/* Role for the server (Bob) */\nrole bob(B, A, p: agent, passwd: text, SND, RCV: channel (dy))\nplayed_by B\ndef=\n    local\n        Nb: random_nonce,\n        s: text,\n        G_Nb_V: text,\n        M: text,\n        K: text,\n        H: hash\n    init\n        state_0\n    transition\n        1. state_0 -> state_1\n            * receive_!1(A, B, X, G_Na) from A;\n            * new(Nb);\n            * new(s);\n            * G_Nb_V := exp(g, Nb, passwd) * verifier(V, passwd, s);\n            * send_!2(B, A, s, G_Nb_V) to A\n    \n        2. state_1 -> state_2\n            * receive_!3(A, B, M) from A;\n            * verify(M, G_Na, s, passwd);\n            * H := compute_h(Nb, M, passwd);\n            * send_!4(B, A, H) to A\n    \n        3. state_2 -> state_3\n            * K := hash(Nb, M, H, passwd);\n            * secret(K, sec_r_K, {A, B})\nend role\n\n/****************** Environment *******************/\n\nrole session()\ndef=\n    local\n        A, B: agent,\n        P: text,\n        S, V: public_key\n    init\n        state_0\n    transition\n        state_0 -> state_1\n            * new(A, B);\n            * new(P);\n            * new(S);\n            * witness(A, B, authentication)\n            * begin role alice(A, B, P, P, AliceChannel, BobChannel) \n            * begin role bob(B, A, P, P, BobChannel, AliceChannel)\nend role\n\nenvironment()\ndef=\n    composition\n        session()\nend role"]], "HLPSL-1/strongAuthentication_assym.hlpsl": [[true, "role alice(A, B: agent, Ka, Kb: public_key, sec_1: text)\nplayed_by A\ndef=\n    local\n        Na, Na_prime: text\n    init\n        state_0\n    transition\n\n        1. state 0 -> state 1 \n        received(Start) /\n        Na := new() \n        := {Na}'Kb\n        .send_1(A, B, {Na}'Kb)\n\n        2. state 1 -> state 2\n        received({Na, sec_1}'Ka) /\n        Na_prime := Na\n        .verify(Na_prime = Na)\nend role\n\nrole bob(B, A: agent, Ka, Kb: public_key, sec_2: text)\nplayed_by B\ndef=\n    local\n        Na: text\n    init\n        state_0\n    transition\n\n        1. state 0 -> state 1\n        received(A, {Na}'Kb) /\n        := {Na, sec_2}'Ka\n        .send_2(B, A, {Na, sec_2}'Ka)\n\nend role\n\nrole session(A, B: agent, Ka, Kb: public_key)\ndef=\n    composition\n        alice(A, B, Ka, Kb, sec_1)\n        bob(B, A, Ka, Kb, sec_2)\nend role\n\nrole environment()\ndef=\n    const\n        a, b: agent\n        k(a), k(b): public_key\n        i: agent\n    intruder_knowledge = {i, k(a), k(b), text}\n    composition\n        session(a, b, k(a), k(b))\n        session(b, a, k(b), k(a))\ngoal\n    secrecy_of sec_1\n    secrecy_of sec_2\n    authentication_on A\nend role\nenvironment"]], "HLPSL-1/strongAuthentication_symm.hlpsl": [[true, "// Basic Authentication Protocol with Nonce\n\n// Role for Alice\nrole role_A(A, B: agent, Sk: symmetric_key, sec_1: secret) \nplayed_by A\ndef= \n  local \n    Na: nonce\n  init\n    0\n  transitions\n    // Transition 1: Initial message from environment\n    0 -> 1 \n        !start ->\n        new Na \n        send({Na'}_Sk)\n    // Transition 2: Receive Bob's nonce and secret\n    1 -> 2 \n        recv({Na, Nb, S}_Sk) \n        check A == peer(B)\n        secret S\nend role\n\n// Role for Bob\nrole role_B(A, B: agent, Sk: symmetric_key, sec_1: secret) \nplayed_by B\ndef= \n  local \n    Nb: nonce\n  init\n    0\n  transitions\n    // Transition 1: Receive Alice's nonce\n    0 -> 1 \n        recv({Na'}_Sk) -> \n        new Nb\n        send({Na', Nb, sec_1}_Sk)\n    // Transition: Authentication check\n    1 -> 2 \n        !recv({Na, Nb, S}_Sk) \n        check B == peer(A)\n        secret S\nend role\n\n// Session Role\nrole session(A, B: agent, Sk: symmetric_key, sec_1: secret) \ndef= \n  composition\n    role_A(A, B, Sk, sec_1)\n    role_B(A, B, Sk, sec_1)\nend role\n\n// Environment Role\nrole environment()\ndef= \n  const \n    A, B: agent\n    Sk: symmetric_key\n    sec_1, sec_2: secret\n  intruder_knowledge = {A, B, Sk}\n  composition\n    session(A, B, Sk, sec_1)\n    session(A, B, Sk, sec_2)  // Replay attack scenario\nend role\n\n// Goals\ngoal\n  secrecy_of sec_1  // Secrecy of sec_1\n  secrecy_of sec_2  // Secrecy of sec_2\n  authentication_on A_to_B_nonce // Authentication on Alice's nonce\n  authentication_on B_to_A_nonce // Authentication on Bob's nonce\nend goal\n\n// Specification\nspecification basic_authentication\ndef= \n  environment()\nend specification"]], "HLPSL-1/An_Autonomous_Log_Storage_Management_Protocol_with_Blockchain_Mechanism_and_Access_Control_for_the_Internet_of_Things.hlpsl": [[true, "role user(U, A, S)\n  const start_message: message\n  keyword: message\n  sk: symmetric_key\n  \n  vars\n    IDi, IDi_prime: message\n    Alpha_prime: message\n    SK_prime: symmetric_key\n    C: message\n  \n  defs\n    new_IDi:=(exp(IDi_prime, 1)*exp(SK_prime, 1)) mod p\n\n  init\n    0\n\n  transition\n    1. Start_U_start ::= {start_message} -> U\n    2. U -> A: {start_message}\n  \n  transition    \n    3. U -> A: {request_log}  \n    4. A -> U: {IDi_prime, Alpha_prime, SK_prime}\n  \n  transition   \n    5. S -> U: {Ys_prime, C}\n    6. U -> S: {request_verification, keyword}\n  \nend role\n\nrole authority(A, U)\n  vars\n    IDi_prime, Alpha_prime, SK_prime: message\n  \n  transition\n    step1. A -> U: {IDi_prime, Alpha_prime, SK_prime}\n  \n  transition   \n    step2. U -> A: {request_log}\n  \nend role\n\nrole sensor(S, U)\n  const start_message: message\n  keyword: message\n  ss: symmetric_key\n\n  vars\n    Ss_prime, C_prime: message\n    {Ys_prime, log_signature} : message\n\n  defs\n    new_signature := sign(hmac(ss, log_signature), ss)\n  \n  transition\n    start_S_start  ::= {start_message} -> S\n\n  transition  \n    step1. U -> S: {Ss_prime, log_signature}\n    step2. S -> U: {Ss_prime, C_prime}\n  \nend role\n\nrole session(User, Authority, Sensor)\n  composition\n    user(User, Authority, Sensor)\n    authority(Authority, User)\n    sensor(Sensor, User)\n\nend role\n\ngoal\n  secrecy_of sk, alpha, ss\n  authentication_on Ss_prime\n\nenvironment()\nend environment\n\ncomposition()\nsession(user_instance, authority_instance, sensor_instance)\nend composition\n\nbounded_reachability\nend bounded_reachability \n\nreachable\nend reachable"]], "HLPSL-1/Three-factor_fast_authentication_scheme_for_e-health_systems_in_5G_wireless_sensor_network.hlpsl": [[true, "// HLPSL Description for Secure Communication Protocol\n\n// Definition of the symmetric and asymmetric keys\nconst Kus: symmetric_key;\nconst Ks: public_key;\n\n// Hash Functions\nconst H, H1, H2, H6, H7, H14, H16: hash_func;\n\n// Nonces and secrets\nconst Nj, N, E, BBi, W, A, B, Ay: random;\nconst g1, g2, g3, g4, g5, g6, g7: random;\n\n// Basic roles for each entity\n\n// User Role\nrole User(U, S: agent, Kus: symmetric_key, Ks: public_key)\nplayed_by U\nrequests Shared_Secret(U, S, g1, g2, g3, g4, g5, g6, g7)\nreads_username U\nreads_password_password HashOfPassword(U)\nreads_biometric_info HashOfBiometric()\nmemory Constants: H, H1, H2, H6, H7, H14, H16;\n\nconst start_reg: text\nconst start_login_auth: text\nconst start_fast_auth: text\n\ninit\n  state_0\ntransition\n\n  // Registration Phase\n  state_0 -> state_1\n  label \"registration_start\"\n  step\n    action\n      Send(U, S, {start_reg, E, BBi, W}_Kus);\n  end_step\n\n  state_1 -> state_2\n  label \"registration_response\"\n  step\n    action\n      Recv(S, U, {Nj}_Kus);\n  end_step\n\n  // Login and Initial Authentication Phase\n  state_2 -> state_3\n  label \"login_start\"\n  step\n    action\n      Send(U, S, {start_login_auth, N, HashOfPassword(U), HashOfBiometric()}_Ks);\n  end_step\n\n  state_3 -> state_4\n  label \"login_response\"\n  step\n    action\n      Recv(S, U, {A, B}_Ks);\n  end_step\n\n  // Fast Authentication Phase\n  state_4 -> state_5\n  label \"fast_authentication_request\"\n  step\n    action\n      Send(U, S, {start_fast_auth, Ay}_Ks);\n  end_step\n\nend role\n\n// Server Role\nrole Server(S, U: agent, Kus: symmetric_key, Ks: public_key)\nplayed_by S\nrequests Shared_Secret(S, U, g1, g2, g3, g4, g5, g6, g7)\nreads_server_id S\nmemory Constants: H, H1, H2, H6, H7, H14, H16;\n\ntransition\n\n  // Registration Phase\n  state_0 -> state_1\n  label \"registration_receive\"\n  step\n    action\n      Recv(U, S, {start_reg, E, BBi, W}_Kus);\n  end_step\n\n  state_1 -> state_2\n  label \"registration_respond\"\n  step\n    action\n      Send(S, U, {Nj}_Kus);\n  end_step\n\n  // Login and Initial Authentication Phase\n  state_2 -> state_3\n  label \"login_receive\"\n  step\n    action\n      Recv(U, S, {start_login_auth, N, HashOfPassword(U), HashOfBiometric()}_Ks);\n  end_step\n\n  state_3 -> state_4\n  label \"login_respond\"\n  step\n    action\n      Send(S, U, {A, B}_Ks);\n  end_step\n\n  // Fast Authentication Phase\n  state_4 -> state_5\n  label \"fast_authentication_receive\"\n  step\n    action\n      Recv(U, S, {start_fast_auth, Ay}_Ks);\n  end_step\n\nend role\n\n// Environment Role\nrole session_environment()\nconst U, S: agent\nconst Kus: symmetric_key\nconst Ks: public_key\n\ncomposition\n  User(U, S, Kus, Ks)\n  Server(S, U, Kus, Ks)\n\nend role\n\n// Intruder Knowledge\nintruder_knowledge = {U, S, Kus, {(start_login_auth,N.hash(H6),)}_Ks, {(start_fast_auth,)}_Ks}\n\n// Specification of the initial session and goals\ngoal\n  secrecy_shared_secret: Shared_Secret(U, S, g1, g2, g3, g4, g5, g6, g7);\n  authentication_U_to_S: u_s_v, u_s_tu;\n  authentication_S_to_U: s_u_ts;\n\nenvironment()\nsession_environment()\nend goal"]], "HLPSL-1/Three-Factor_UCSSO_Scheme_With_Fast_Authentication_and_Privacy_Protection_for_Telecare_Medicine_Information_Systems.hlpsl": [[true, "// HLPSL Specification for the Protocol\n\n// Environment role where all sessions are executed\nrole env()\n  \n  // Declare additional constants required for the protocol \n  const IDi, PWi, Bi: text\n  const SKj, Nij, Kij, KijNew: symmetric_key\n  const R, Xi, Y, Tu, Ts, A1, A2, C1, M1: text\n  \n  // Composition of the user (U) and TMIS sessions\n  composition \n    session(user, tmis, session)\n\nend role\n\n// Role for the User (U)\nrole user(U: agent, TMIS: agent, SKj: symmetric_key, K: public_key)\n\n  // Variables for registration and authentication\n  var IDi, PWi, Bi: text\n  var Xi, Y, R, Nij: text\n  \n  // State declarations for the user\n  state State_0, State_1, State_2, State_3\n\n  // Initial state\n  init\n    State_0\n  \n  // Transitions \n\n  // Registration initiation\n  transition\n    State_0 -> State_1 \n    label register_request\n    event start_registration\n    action \n      R := new()\n      Xi := h(PWi, R)\n      Y := h(Bi, Xi)\n      send(TMIS, {IDi, Xi, Y, R})\n     \n  // Login request\n  transition\n    State_1 -> State_2 \n    label login_request\n    event start_login\n    action \n      Xi := h(PWi, R)\n      Y := h(Bi, Xi)\n      Tu := new()\n      A1 := h(IDi, Xi, Y, Tu)\n      C1 := h(K, A1)\n      send(TMIS, {C1, Nij})\n    \n  // Fast authentication initiation\n  transition\n    State_2 -> State_3 \n    label fast_auth_request\n    event start_fast_authentication\n    action \n      M1 := h(Kij, new())\n      send(TMIS, {M1})\n    \n  // Successful authentication\n  transition\n    State_3 -> State_3\n    label authenticated\n    event session_established\n    end state\n\nend role\n\n// Role for TMIS\nrole tmis(TMIS: agent, U: agent, SKj: symmetric_key, K: public_key)\n\n  // Variables for registration and authentication\n  var IDi, Xi, Y, R, Nij, Ts, A1, A2, Kij, KijNew: text\n  var Bi: text\n  \n  // State declarations for TMIS\n  state State_0, State_1, State_2, State_3, State_4\n  \n  // Initial state\n  init\n    State_0\n  \n  // Transitions\n  \n  // Registration acknowledgment\n  transition\n    State_0 -> State_1\n    label registration_ack\n    event start_registration\n    receive(U, {IDi, Xi, Y, R})\n    action\n      SKj := new()\n      Nij := h(Xi, IDi, SKj)\n      send(U, {Nij, SKj})\n\n  // Login verification\n  transition\n    State_1 -> State_2\n    label verify_login\n    event start_login\n    receive(U, {C1, Nij})\n    action\n      Ts := new()\n      A2 := h(C1, Nij, Ts)\n      send(U, {A2, Ts})\n\n  // Fast authentication response\n  transition\n    State_2 -> State_3\n    label verify_fast_auth\n    event start_fast_authentication\n    receive(U, {M1})\n    action\n      KijNew := h(Kij, new())\n      send(U, {KijNew})\n      \n  // Session establishment\n  transition\n    State_3 -> State_4\n    label session_established\n    event fast_authentication_complete\n    end state\n\nend role\n\n// Session role combining user and TMIS interactions\nrole session(U: agent, TMIS: agent)\n\n  // Symmetric keys and public keys \n  const SKj: symmetric_key\n  const K: public_key\n\n  composition\n    user(U, TMIS, SKj, K) \n    tmis(TMIS, U, SKj, K)\n    end role\n\ngoal\n  secrecy_of IDi, PWi, Bi, SKj, Kij\n  authentication_on IDi, SKj\n\nend goal"]], "HLPSL-1/TLS.hlpsl": [[true, "role alice(A, B: agent, Pa, Pb: public_key, Sid: text, Na: nonce)\n\n  played_by A\n  \n  def=\n    local \n      State: nat, \n      Nb, PMS, ClientK: text\n  \n  init\n    State := 0\n    \n  transition\n  \n    1. State = 0  -> \n       State' := 1 \n       /\\ send_1(A, B, {Na, Sid, Pa})\n       /\\ State' := 1\n\n    2. State = 1 /\\ recv_2(B, A, {Nb, Sid, {B, Na, Nb}'_Pa}) -> \n       State' := 2 \n       /\\ PMS := new()\n       /\\ ClientK := KDF(A, B, PMS, Na, Nb)\n       /\\ witness(A, B, na_nb2, Na)\n       /\\ send_3(A, B, hash({Na, Nb, ClientK}))\n\nend role\n\nrole bob(A, B: agent, Pa, Pb: public_key, Sid: text, Nb: nonce)\n\n  played_by B\n  \n  def=\n    local \n      State: nat, \n      Na, PMS, ServerK: text\n  \n  init\n    State := 0\n    \n  transition\n  \n    1. State = 0 /\\ recv_1(A, B, {Na, Sid, Pa})  -> \n       State' := 1 \n       /\\ Nb := new()\n       /\\ send_2(B, A, {Nb, Sid, {B, Na, Nb}'_Pa})\n       /\\ State' := 1\n\n    2. State = 1 /\\ recv_3(A, B, hash({Na, Nb, ClientK})) -> \n       State' := 2 \n       /\\ PMS := new()\n       /\\ ServerK := KDF(A, B, PMS, Na, Nb)\n       /\\ request(B, A, na_nb2, Na)\n       /\\ send_4(B, A, {Na, Nb}'_ServerK)\n\nend role\n\nrole session(A, B: agent, Pa, Pb: public_key)\n\n  composition\n    alice(A, B, Pa, Pb, Sid, Na)\n    bob(A, B, Pa, Pb, Sid, Nb)\n\nend role\n\nrole environment()\n\n  const  \n    a, b: agent\n    pa, pb: public_key \n    sid: text\n    na, nb: nonce\n\n  intruder_knowledge = {a, b, pa, pb}\n  \n  composition\n    session(a, b, pa, pb)\n\n  knowledge_minus = {pa', pb'}\n\nend role\n\ngoal\n\n  secrecy_of sec_clientk, sec_serverk\n  authentication_on na_nb1\n  authentication_on na_nb2\n\nend goal\n\nenvironment()"]], "HLPSL-1/total.hlpsl": [[true, "/* HLPSL code starts here */\n\nrole user(Ui, GWN, RA, SDj: agent, Ui_scard, Ui_pass: text, \n          hust, hu: hash_func, sek: symmetric_key) played_by Ui\n  \n  const identity_ui: text\n\n  fresh n_ui: text\n  \n  vars\n    sk_ui: symmetric_key\n    hash_pass_ui: text\n    m_ui, ack_ui: text\n  \n  init\n    state := 0 /* Initial state for the user */\n  \n  transition\n  \n    step1: state = 0 /\\ Rcv(start) =|> \n      State := 1 /\\ \n      hash_pass_ui' := hu(hash_pass_ui, Ui_pass) /\\ \n      Snd(Ui, RA, {identity_ui, hash_pass_ui'}_hust)\n\n    step2: state = 1 /\\ Rcv(RA, {m_ui}_sek) =|>\n      State := 2 /\\ \n      sk_ui' := sek /\\ \n      Snd(Ui, GWN, {identity_ui, n_ui}_sek)\n\nend role\n\nrole ra(Ui: agent, RA, GWN: agent, hust: hash_func, \n         sek: symmetric_key) played_by RA\n\n  const identity_ra: text\n  \n  vars\n    hash_pass_ui: text\n    sk_ui: symmetric_key\n    m_ra: text\n  \n  init\n    state := 0\n  \n  transition\n  \n    step1: state = 0 /\\ Rcv(Ui, {identity_ui, hash_pass_ui}_hust) =|> \n      State := 1 /\\ \n      Snd(RA, Ui, {m_ra}_sek) /\\ \n      sk_ui' := sek\n\nend role\n\nrole gateway(Ui, SDj, GWN: agent, sek: symmetric_key) played_by GWN\n\n  const identity_gwn: text\n\n  fresh n_gwn: text\n  \n  vars\n    ack_gwn, r_gwn: text\n  \n  init\n    state := 0\n  \n  transition\n  \n    step1: state = 0 /\\ Rcv(Ui, {identity_ui, n_ui}_sek) =|> \n      State := 1 /\\ \n      Snd(GWN, SDj, {identity_gwn, n_gwn}_sek)\n\nend role\n\nrole smart_device(GWN, SDj: agent, sek: symmetric_key) played_by SDj\n\n  const identity_sdj: text\n  \n  fresh rnd_sdj: text\n  \n  vars\n    resp_sdj: text\n  \n  init\n    state := 0\n  \n  transition\n  \n    step1: state = 0 /\\ Rcv(GWN, {identity_gwn, n_gwn}_sek) =|> \n      State := 1 /\\ \n      Snd(SDj, GWN, {identity_sdj, rnd_sdj}_sek)\n\nend role\n\ngoal\n  authentication_on sk_ui\n  confidentiality_of sk_ui\n\nenvironment() compositions\n  user(Ui, GWN, RA, SDj)\n  ra(Ui, RA, GWN)\n  gateway(Ui, SDj, GWN)\n  smart_device(GWN, SDj)\nend role\n\n/* HLPSL code ends here */"]], "HLPSL-1/UMTS_AKA.hlpsl": [[true, "/* HLPSL Model for UMTS-AKA Protocol */\n\nrole alice(A, B: agent, SM: channel(dy), SIK, SR: nat, K: symmetric_key) \nplayed_by A {\n    local \n        State: nat,\n        RA: text,\n        SU: text,\n        CK, IK: text,\n        AUTH, RES: text\n\n    init State := 0\n\n    transition \n\n    0. State = 0 /\\ SM(A, B, start_m) =\n    >\n    State' := 1 /\\ \n    RA' := new() /\\ \n    SM(A, B, {A}_K)\n\n    1. State = 1 /\\ SM(B, A, {RA, AUTH_B}_K) =\n    >\n    CK' := f3(K, RA) /\\ \n    IK' := f4(K, RA) /\\ \n    STATE' := 2\n\n    2. State = 2 /\\ AUTH_B = f1(K, SR; RA) = \n    >\n    AUTH' := f1(K, SU, RA) /\\ \n    RES' := f2(K, RA) /\\ \n    SM(A, B, RES) /\\ \n    State' := 3\n}\n\nrole bob(A, B: agent, SM: channel(dy), SIK, SR: nat, K: symmetric_key) \nplayed_by B {\n    local \n        State: nat,\n        RA: text,\n        CK, IK: text,\n        AUTH: text,\n        RES: text\n\n    init State := 0\n\n    transition \n\n    0. State = 0 /\\ SM(A, B, {A}_K) =\n    >\n    RA' := new() /\\\n    CK' := f3(K, RA) /\\ \n    IK' := f4(K, RA) /\\ \n    AUTH' := f1(K, SR, RA) /\\ \n    SM(B, A, {RA, AUTH}_K) /\\ \n    State' := 1\n\n    1. State = 1 /\\ SM(A, B, RES) = \n    >\n    RES = f2(K, RA) /\\ \n    State' := 2\n}\n\nrole session(A, B: agent, SM: channel(dy), K: symmetric_key) {\n    composition \n    alice(A, B, SM, SU, SR, K)\n    bob(A, B, SM, SU, SR, K)\n}\n\nrole environment() {\n    const\n        a, b: agent\n        k: symmetric_key\n    intruder_knowledge = {a, b, k}\n\n    composition\n    session(a, b, SM, k)\n    session(a, i, SM, k)\n\n    /* Verification goals */\n    goal\n        secrecy_of CK, IK\n        authentication_on CK\n        authentication_on IK\n\n    environment()\n}"]], "HLPSL-1/update_simple(final).hlpsl": [[true, "// HLPSL code for secure communication between OBU and SN\n\n// Define the roles and the keys\nrole obu(OBOU)\nplayed_by OBU {\n\n  // Declaring knowledge and state of the OBU\n  local\n    var PID, PUF, r1, r2: text\n    s_o_res: text\n    o_s_h12, o_s_h11, o_s_key1, o_s_key2: text\n\n  const SN: agent\n\n  init \n    state0\n\n  // State 0: OBU waits for start message\n  transition\n    state0 -> state1\n    SN.OBOU: start\n    =| | PID \n    /\\ =| | OBOU.SN: PID\n\n  // State 2: OBU receives encrypted message, validates and computes session keys\n  transition\n    state1 -> state2\n    SN.OBOU: {s_o_res', o_s_h11'}_PUF\n    /\\ check(s_o_res' = hash(PID, sn_nonce))\n    /\\ r1, r2 := secret_session_keys(s_o_res', o_s_h11')\n    /\\ o_s_h12 := hash(r1, r2, PID)\n    /\\ =| | OBOU.SN: {o_s_h12}_PUF\n    /\\ o_s_key1, o_s_key2 := derive_keys(r1, r2)\n\n  // State 4: OBU receives response, completes session key establishment\n  transition\n    state2 -> state3\n    SN.OBOU: {confirmation}_PUF\n    /\\ check(confirmation = hash(o_s_h12, sn_pid))\n    /\\ =| | OBOU.SN: ack\n\n}\n\nrole sn(SNOS)\nplayed_by SN {\n\n  // Declaring knowledge and state of SN\n  local\n    var PID, sn_nonce: text\n    s_o_res: text\n    o_s_h12, o_s_h11, o_s_key1, o_s_key2: text\n\n  const OBU: agent\n\n  init \n    state1\n\n  // State 1: SN receives PID and sends encrypted response\n  transition\n    state1 -> state2\n    OBU.SN: PID\n    /\\ sn_nonce, := new_nonce()\n    /\\ s_o_res := hash(PID, sn_nonce)\n    /\\ =| | SN.OBU: {s_o_res, hash(PID, sn_nonce, SN)}_PUF\n\n  // State 3: SN receives OBU's message, computes response\n  transition\n    state2 -> state3\n    OBU.SN: {o_s_h12'}_PUF\n    /\\ o_s_h12 := hash(PID, s_o_res, SN)\n    /\\ check(o_s_h12' = o_s_h12)\n    /\\ =| | SN.OBU: {hash(o_s_h12, sn_pid)}_PUF\n\n  // State 5: Confirmation of successful session initialization\n  transition\n    state3 -> state4\n    OBU.SN: ack\n}\n\nrole environment() {\n\n  // Intruder knowledge\n  const OBU, SN: agent\n  intruder_knowledge = {OBU, SN, PUF, PID}\n\n  composition\n    obu(OBOU)\n    sn(SNOS)\n\n  // Session setup\n  session(obu(SN), sn(OBU))\n\n  // Security goals\n  authentication_on(s_o_res)\n  secrecy_of(r1, r2)\n  authentication_on(o_s_h11, o_s_h12)\n\n}\n\ngoal\n  secrecy_of r1\n  secrecy_of r2\n  authentication_on s_o_res\n  authentication_on o_s_h11\n  authentication_on o_s_h12\n\n// End of the HLPSL code"]], "HLPSL-1/usglight.hlpsl": [[true, "role user(Ui, GW, Sj: agent, Kdi, Kei, P, IDi, SIDj: text, SND_UG, RCV_UG: channel(dy))  \nplayed_by Ui\n  def= \n    local\n      State: nat \n      NewKey: text\n      shared_key: text\n      Nonce: text\n    init\n      State := 0\n    transition\n      State = 0  /\\ RCV_UG(start) =|> \n      State' := 1 /\\ NewKey' := new()\n                   /\\ Nonce' := new()\n                   /\\ SND_UG( {IDi, NewKey', H(IDi, P, Nonce')}_Kdi )\n\n      State = 7 /\\ RCV_UG({NewKey, shared_key'}_Kdi) =|> \n      State' := 8\nend role\n\nrole sensor(Sj, GW, Ui: agent, Kxj, SIDj, P: text, SND_SG, RCV_SG: channel(dy))\nplayed_by Sj\n  def=\n    local\n      State: nat \n      NewKey: text\n      shared_key: text\n      Nonce: text\n    init\n      State := 4\n    transition\n      State = 4 /\\ RCV_SG({IDi, NewKey, H(IDi, P, Nonce)}_Kdi) =|> \n      State' := 5 /\\ NewKey' := new()\n                   /\\ SND_SG({SIDj, NewKey', H(SIDj, P, Nonce)}_Kxj)\n\n      State = 6 /\\ RCV_SG({shared_key}_Kxj) =|>\n      State' := 7 /\\ shared_key' := shared_key\nend role\n\nrole gateway(GW, Ui, Sj: agent, Xgwn, P: text, SND_UG, RCV_UG, SND_SG, RCV_SG: channel(dy))\nplayed_by GW\n  def=\n    local\n      State: nat \n      NewKey: text\n      shared_key: text\n      Nonce: text\n    init\n      State := 2\n    transition\n      State = 2 /\\ RCV_UG({IDi, NewKey, H(IDi, P, Nonce)}_Kdi) =|> \n      State' := 3 /\\ NewKey' := new()\n                   /\\ SND_SG({SIDj, NewKey, H(SIDj, P, Nonce)}_Kxj)\n\n      State = 5 /\\ RCV_SG({SIDj, NewKey', H(SIDj, P, Nonce)}_Kxj) =|> \n      State' := 6 /\\ shared_key' := new()\n                   /\\ SND_UG({NewKey', shared_key'}_Kdi)\nend role\n\ngoal\n  secrecy_of sc_user_id, sc_sensor_id\n  authentication_on shared_key\nend goal\n\nenvironment(user, sensor, gateway)\n  def=\n    const sc_user_id, sc_sensor_id, shared_key: protocol_id\n    intruder_knowledge = {sc_user_id, sc_sensor_id, shared_key, Ui, GW, Sj}\n    composition \n      session1: user(Ui1, GW1, Sj1, ..., SND_UG1, RCV_UG1) /\\\n      session2: sensor(Sj2, GW2, Ui2, ..., SND_SG2, RCV_SG2) /\\\n      session3: gateway(GW3, Ui3, Sj3, ..., SND_UG3, RCV_UG3, SND_SG3, RCV_SG3)\n    end composition\nend environment\n\nrole session1 initialization includes\n  session1 \nend role\n\nrole session2 initialization includes\n  session2 \nend role\n\nrole session3 initialization includes\n  session3 \nend role"]], "HLPSL-1/woolamProtocolFixed.hlpsl": [[true, "// Role for Alice\nrole alice(A, B, S: agent, Kas: symmetric_key, RCVA, SNDA: channel(dy))\n  var Na, Nb: text\n      Kab: symmetric_key\n\n  init\n    0: state := 0\n    Na := new()\n    \n  transition\n    // Alice sends Na to the server along with identities\n    0 -> 1\n      SNDA.{A, B, Na, Nb} := {A, B, Na, Nb}_Kas\n    \n    // Await server response and decrypt to obtain Kab\n    1 -> 2\n      RCVA.{B, Na, Nb, Kab} := {B, Na, Nb, Kab}_Kas\n      where is_symmetric(Kab)\nend role\n\n// Role for Bob\nrole bob(B, A, S: agent, Kbs: symmetric_key, RCVB, SNDB: channel(dy))\n  var Na, Nb: text\n      Kab: symmetric_key\n\n  transition\n    // Bob receives server message, decrypts, and sends back a confirmation\n    0 -> 1\n      RCVB.{A, Na, Nb, Kab} := {A, Na, Nb, Kab}_Kbs\n      SNDB.{B, Na, Nb} := {B, Na, Nb}_Kbs\nend role\n\n// Role for Server\nrole server(S, A, B: agent, Kas, Kbs: symmetric_key, RCVS, SNDS: channel(dy))\n  var Na, Nb: text\n      Kab: symmetric_key\n\n  init\n    0: state := 0\n\n  transition\n    // Receive from Alice and generate a response to Bob\n    0 -> 1\n      RCVS.{A, B, Na, Nb} := {A, B, Na, Nb}_Kas\n      Nb := new()\n      Kab := new()\n      SNDS.{B, Na, Nb, Kab} := {B, Na, Nb, Kab}_Kbs\n      \n    // Forward final confirmatory message to Alice\n    1 -> 2\n      SNDS.{A, Na, Nb, Kab} := {A, Na, Nb, Kab}_Kas\nend role\n\n// Environment that defines the initial setup and communication\nrole env\n  const Kas, Kbs: symmetric_key\n  const Alice, Bob, Server: agent\n\n  composition\n    alice(Alice, Bob, Server, Kas, RCVA, SNDA) \n    bob(Bob, Alice, Server, Kbs, RCVB, SNDB)\n    server(Server, Alice, Bob, Kas, Kbs, RCVS, SNDS)\nend role\n\n// Specification of security goals\ngoal\n  auth_id(Alice, Bob, Bob, Na) // Alice authenticates Bob\n  auth_id(Bob, Alice, Alice, Nb) // Bob authenticates Alice\nend goal\n\n// Simulation of the protocol\nenvironment(env)"]], "HLPSL-1/XorNSPK_1.hlpsl": [[true, "// HLPSL Code for NSPKxor Protocol in AVISPA\n\n// Declare the basic types: agent, public_key, and text\ntypes\n  agent, public_key, text\n\n// Declare the protocol identifiers\nprotocol_id NSPKxor\n\n// Declare symmetric encryption function and exclusive-OR function\nfunctions\n  xor_func/2, conj/1\n\n// Define the role for Alice\nrole alice(A, B: agent, Ka, Kb: public_key, SND, RCV: channel(dy))\n  const Na: text\n  vars Nb: text\n  state\n    State0, State1\n  init\n    State0\n  transition\n\n    // Transition 1: Alice generates a nonce Na and sends it encrypted to Bob\n    State0 -> State1\n      rcv_start\n      new(Na)\n      snd(SND, {Na, A}_Kb)\n\n    // Transition 2: Alice receives Nb and sends it encrypted to Bob\n    State1 -> State0\n      rcv(RCV, {Nb, xor_func(Na, B)}_Ka)\n      snd(SND, {Nb}_Ka)\nend role\n\n// Define the role for Bob\nrole bob(B, A: agent, Kb, Ka: public_key, SND, RCV: channel(dy))\n  const Nb: text\n  vars Na: text\n  state\n    State0, State1\n  init\n    State0\n  transition\n\n    // Transition 1: Bob receives Na and generates a nonce Nb\n    State0 -> State1\n      rcv(RCV, {Na, A}_Kb)\n      new(Nb)\n      snd(SND, {Nb, xor_func(Na, B)}_Ka)\n\n    // Transition 2: Bob receives Nb\n    State1 -> State0\n      rcv(RCV, {Nb}_Ka)\nend role\n\n// Define the session role\nrole session()\n  const A, B, I: agent\n  const Ka, Kb, Ki: public_key\n  composition\n    alice(A, B, Ka, Kb, SND_A, RCV_A) | bob(B, A, Kb, Ka, SND_B, RCV_B) | bob(I, A, Ki, Ka, SND_I, RCV_I)\nend role\n\n// Define the environment role\nrole environment()\n  const A, B, I: agent\n  const Ka, Kb, Ki: public_key\n  const secret_na: text\n  intruder_knowledge = {I, Ki, secret_na}\n  composition\n    session()\n  end role\n\n// Define security goals\ngoal\n  secrecy_of secret_na\nend goal\n\nenvironment()"]], "HLPSL-1/xvrabe07.hlpsl": [[true, "role alice(A, B, S : agent, Kas: symmetric_key, sec_1: message) \nplayed_by A\ndef=\n  local\n    Na: nonce,\n    X: text\n  init\n    state_0\n  transition\n    state_0 -> state_1 \n      received(start) \n      /\\ Na := new()\n      /\\ send(A, B, {Na}Kas)\n\n    state_1 -> state_2 \n      received({Na, X}Kab)\n      /\\ request(A, secrecy_sec_1, sec_1)\n\nend role\n\nrole bob(A, B, C, S : agent, Kas, Kbs: symmetric_key, sec_1, sec_2: message) \nplayed_by B\ndef=\n  local\n    Na, Nb: nonce,\n    X: text\n  init\n    state_0\n  transition\n    state_0 -> state_1\n      received({Na}Kas)\n      /\\ Nb := new()\n      /\\ send(B, C, {{Na, Nb}Kbs}Kbs)\n\n    state_1 -> state_2 \n      received({{Na, Nb, X}Kbc}Kbc)\n      /\\ send(B, A, {Na, X}Kab)\n      /\\ request(B, secrecy_sec_2, sec_2)\n\nend role\n\nrole carl(B, C, S : agent, Kbs, Kcs: symmetric_key, sec_2: message) \nplayed_by C\ndef=\n  local\n    Na, Nb, Nc: nonce,\n    X: text\n  init\n    state_0\n  transition\n    state_0 -> state_1\n      received({{Na, Nb}Kbs}Kbs)\n      /\\ Nc := new()\n      /\\ send(C, B, {{Na, Nb, Nc}Kcs}Kcs)\n\n    state_1 -> state_2 \n      received({{Na, Nc, X}Kbc}Kbc)\n\nend role\n\nrole server(S: agent) \ndef= \n  local\n    X: message\n  init\n    state_0\n  transition\n    state_0 -> state_0 \n      received(X) \n      /\\ send(S, X)\n\nend role\n\ngoal\n  secrecy_of sec_1\n  secrecy_of sec_2\nend goal\n\nenvironment()\ndef=\n  const\n    alice, bob, carl, server: agent,\n    kas, kbs, kab, kcs, kbc: symmetric_key,\n    sec_1, sec_2: message\n\n  intruder_knowledge = {sec_1, sec_2, kas, kbs, kcs}\n\n  composition\n    alice(alice, bob, server, kas, sec_1) \n    bob(alice, bob, carl, server, kas, kbs, sec_1, sec_2)\n    carl(bob, carl, server, kbs, kcs, sec_2)\n    server(server)\nend environment"]], "HLPSL-1/Auth-protocol.hlpsl": [[true, "role ed(A, NAD, SKus) \nplayed_by A\nuses\n  var IDu, PWu, Bu, Du, M, TW, Quj, session_key, nonceA, nonceNAD: text, hash: text\n  SKus: symmetric_key\n  const H: hash_func\n\ntransition\n  step1.0: \n    // User Registration Phase\n    state := 0; \n    sent_message := {IDu, M, SKus(TW)};\n    send_1(A,NAD, sent_message);\n    \n    step2.0: \n    // Authentication and Key Exchange Phase\n    state := 1;\n    nonceA := new();\n    receive_2(NAD}:{Du, SKus(h(valX))});\n    sent_message := {IDu, nonceA, h(Du, PWu, Bu)};\n    send_2(A,NAD, sent_message);\n\n    step3.0: \n    // Mutual Authentication\n    state := 2;\n    receive_3(NAD}:{nonceNAD, Quj});\n    session_key := h(nonceA, nonceNAD, SKus, Quj);\n    witness(A, NAD, session_key);\n\nend role\n\nrole nad(NAD, A, SKus) \nplayed_by NAD\nuses \n  var IDu, PWu, Bu, Du, M, TW, Quj, session_key, nonceNAD, nonceA: text, hash: text\n  SKus: symmetric_key\n  const H: hash_func\n\ntransition\n  step1.1: \n    // Receiving User Registration Phase\n    state := 0;\n    receive_1(A}: {IDu, M, SKus(TW)});\n    decrypt SKus(TW);\n    Du := h(IDu, PWu, Bu); // Generate a temporary identifier\n    \n    send_2(NAD,A, {Du, SKus(h(M))});\n  \n    step2.1: \n    // Respond to Authentication and Key Exchange Phase\n    state := 1;\n    nonceNAD := new();\n    receive_2(A}:{IDu, nonceA, h(Du, PWu, Bu)});\n    Quj := h(PWu, Du, nonceNAD);\n    session_key := h(nonceA, nonceNAD, SKus, Quj);\n    witness(NAD, A, session_key);\n    send_3(NAD,A, {nonceNAD, Quj});\n\nend role\n\nrole session(ed, nad)\ncomposition\n  ed(A, NAD, SKus) /\\\n  nad(NAD, A, SKus)\n\nend role\n\ngoal\n  secrecy_of SKus\n  authentication_on session_key\n\nattack_intruder(trudy)\n\nenvironment\n  role_session := session(ed, nad)\n  role_attacker := intruder(trudy)\n\nend goal"]], "HLPSL-1/addNewSession.hlpsl": [[true, "role Alice(A, B: agent, Ka, Kb: public_key, sna, snb: nonce, SND, RCV: channel(dy))\nplayed_by A\ndef=\n  local\n    Na, Nb: nonce\n  init\n    state 0\n  transition\n    0 -> 1\n      % Start the protocol\n      received(start) / \n      begin\n        Na := new()\n      end\n      =^=>\n      send(SND, {Na.A}_Kb')\n      secret(Na, sna, {A, B})\n\n    1 -> 2\n      % Receive response from Bob\n      received(RCV, {Nb'.xor(Na, B)}_Ka') / \n      witness(A, B, sna, Na) \n      =^=>\n      send(SND, {Nb'}_Kb')\n\nend role\n\nrole Bob(B, A: agent, Ka, Kb: public_key, sna, snb: nonce, SND, RCV: channel(dy))\nplayed_by B\ndef=\n  local\n    Na, Nb: nonce\n  init\n    state 0\n  transition\n    0 -> 1\n      % Receive the message from Alice\n      received(RCV, {Na'.A}_Kb') / \n      begin\n        Nb := new()\n      end\n      =^=>\n      send(SND, {Nb.xor(Na', B)}_Ka')\n      secret(Nb, snb, {B, A})\n\n    1 -> 2\n      % Receive confirmation from Alice\n      received(RCV, {Nb}_Kb') / \n      =^=>\n      request(B, A, sna, Na)\n\nend role\n\nrole session(A, B: agent, Ka, Kb: public_key, sna, snb: nonce)\ndef=\n  composition\n    Alice(A, B, Ka, Kb, sna, snb, SND, RCV)\n    Bob(B, A, Ka, Kb, sna, snb, SND, RCV)\nend role\n\nrole environment()\ndef=\n  const\n    alice, bob, intruder: agent\n    ka, kb: public_key\n    sna, snb: protocol_id\n  intruder_knowledge = {intruder, ka, kb}\n  composition\n    session(alice, bob, ka, kb, sna, snb)\n    session(intruder, bob, ka, kb, sna, snb)\n    session(alice, intruder, ka, kb, sna, snb)\n  end composition\nend role\n\ngoal\n  secrecy_of sna\n  secrecy_of snb\n  authentication_on sna\n\nenvironment(animation) = environment\n\nend goal"]], "HLPSL-1/Basic1.hlpsl": [[true, "/*  HLPSL Specification for the described protocol */\n\nrole admin_role(SA, SN, HN, SK: agent, hash_func: hash)\nplayed_by SA\ndef=\n  local\n    State: nat\n    AN', BN': text\n  init\n    State := 0\n  transition\n    1. State = 0 /\\ start(SN, SA) =|> State':=1 /\\ \n       AN' := hash_func(SN.ID) /\\ BN' := hash_func(SN.ID) /\\\n       send_1(SA, SN, {|SN.ID, AN', BN'|}_SK)\n      \nend role\n\nrole sensor_node_role(SN, SA, HN, SK: agent, hash_func: hash)\nplayed_by SN\ndef=\n  local\n    State: nat\n    RN', TN', XN', YN', TIDN', ALPHA', BETA', ETA', MU': text\n  init\n    State := 0\n  transition\n    1. State = 0 /\\ recv_1(SA, SN, {|ID, AN', BN'|}_SK) =|> \n       RN' := random() /\\ TN' := random() /\\\n       XN':= hash_func(AN' | RN') /\\\n       YN':= hash_func(BN' | TN') /\\\n       TIDN' := hash_func(XN' | YN') /\\\n       State':=1 /\\ \n       send_2(SN, HN, {TIDN', YN', AN', BN', TN'})\n    \n    2. State = 1 /\\ recv_3(HN, SN, {ALPHA', BETA', ETA', MU'}) =|>\n       RN'' := hash_func(ALPHA' | BETA') /\\\n       State':=2\nend role\n\nrole home_node_role(HN, SA, SN, SK: agent, hash_func: hash)\nplayed_by HN\ndef=\n  local\n    State: nat\n    TIDN', YN', AN', BN', TN', ALPHA', BETA', ETA', MU': text\n  init\n    State := 0\n  transition\n    1. State = 0 /\\ recv_2(SN, HN, {TIDN', YN', AN', BN', TN'}) =|>\n       KN' := hash_func(TIDN' | YN') /\\\n       IDN' := hash_func(KN') /\\\n       RN' := hash_func(id | TN') /\\\n       TIDN' := hash_func(KN' | RN') /\\\n       State':=1 /\\\n       send_3(HN, SN, {ALPHA', BETA', ETA', MU'})\nend role\n\nrole session(SA, SN, HN, SK: agent, hash_func: hash)\ndef=\n  local\n    secKHN, secKN, secIDN: protocol_id\n  composition\n    admin_role(SA, SN, HN, SK, hash_func)\n    sensor_node_role(SN, SA, HN, SK, hash_func)\n    home_node_role(HN, SA, SN, SK, hash_func)\nend role\n\nenvironment()\ndef=\n  const\n    a, sn, hn: agent\n    sk: symmetric_key\n    hash_func: hash_function\n  intruder_knowledge = {a, sn, hn, sk}\n  composition\n    session(a, sn, hn, sk, hash_func)\n  end_composition\n  security_goals\n    secrecy_of secKHN, secKN, secIDN\n    authentication_on sn_hn_beta\n    authentication_on hn_sn_tidn\nend environment\n\ngoal\nauthentication_on sn_hn_beta\nauthentication_on hn_sn_tidn\nsecrecy_of secKHN, secKN, secIDN\nend goal"]], "HLPSL-1/calp-v1.hlpsl": [[true, "role BadgeReader(B, S: agent,\n                 PKs: public_key, SKb: symmetric_key, \n                 IdBadge: text, IdEmploye: text)\nplayed_by B\ndef= \nlocal\n  State: nat\n  Ok: text\nconst\n  PKb: public_key\ninit\n  State := 0\ntransition\n  0 -> 1\n  !({IdBadge, IdEmploye}_PKs)\n  =|> \n  State := 1\n    \n  1 -> 2\n  ?({Ok}_PKb) /\\\n  !({Ok}_PKs)\n  =|>\n  State := 2\nend role\n\nrole Server(S, B: agent,\n            PKb: public_key, SKs: symmetric_key)\nplayed_by S\ndef=\nlocal\n  IdBadge: text\n  IdEmploye: text\n  State: nat\n  Ok: text\nconst\n  PKs: public_key\ntransition\n  0 -> 1\n  ?({IdBadge, IdEmploye}_PKs) /\\\n  !({Ok}_PKb)\n  =|>\n  State := 1\nend role\n\nrole session(B, S: agent,\n             PKb, PKs: public_key)\ndef=\ncomposition\n  const Ok: text\n  \n  // Instantiate roles\n  B0: role BadgeReader(B, S, PKs, SKb, IdBadgeuse, IdEmploye)\n  S0: role Server(S, B, PKb, SKs)\nend role\n\nrole environment()\ndef=\nconst\n  B, S: agent\n  PKb, PKs: public_key\n  intruder: agent\n\ncomposition\n  session_role: session(B, S, PKb, PKs)\n\nknowledge\n  intruder_has(PKb)\n  intruder_has(PKs)\n\nintruder_know_keys\n  intruder_has(SKb)\nend role\n\ngoal\n  secrecy_of IdEmploye\n\nend goal"]], "HLPSL-1/DH.hlpsl": [[true, "role roleA(A, B, G: agent, SND, RCV: channel(dy))\n  vars\n    State: nat\n    X, N: text\n    sec_1: text\n  init\n    State := 0\n  transitions\n    // Transition 1\n    State = 0 /\\ RCV(start) =|> \n    State := 1 /\\ X := new() /\\ \n    SND(exp(G, X'))\n    // Transition 2\n    State = 1 /\\ RCV(exp(G, Y')) =|> \n    State := 2 /\\ N := new() /\\ \n    sec_1 := exp(exp(G, X), Y') /\\ \n    SND({N}_sec_1)\nend role\n\nrole roleB(A, B, G: agent, SND, RCV: channel(dy))\n  vars\n    State: nat\n    Y, N: text\n    sec_1: text\n  init\n    State := 0\n  transitions\n    // Transition 1\n    State = 0 /\\ RCV(exp(G, X')) =|> \n    State := 1 /\\ Y := new() /\\ \n    SND(exp(G, Y'))\n    // Transition 2\n    State = 1 /\\ RCV({N'}_exp(exp(G, X), Y)) =|> \n    State := 2 /\\\n    sec_1 := exp(exp(G, X), Y)\nend role\n\nrole session1(A, B, G: agent)\n  composition\n    roleA(A, B, G, SND, RCV)\n    roleB(A, B, G, SND, RCV)\nend role\n\nrole environment()\n  const\n    a, b, g: agent\n  intruder_knowledge = {a, b, g}\n  composition\n    session1(a, b, g)\n  knowledge\n    iknows({a, b, g, start})\nend role\n\ngoal\n  secrecy_of sec_1\nend goal\n\nenvironment()"]], "HLPSL-1/DH_with_Forward_Secrecy_(Vulnerable).hlpsl": [[true, "// Roles Definitions\nrole role_A(A, B, S: agent, Kas: symmetric_key)\nplayed_by A\n\n  // Local variables\n  var Na: nonce;\n  var Kab: symmetric_key;\n\n  // Initialisms\n  init_A\n    state_agent(A)\n    state_agent(B)\n    state_agent(S)\n    state_skey(Kas)\n  \n  // Transition function\n  transition\n\n    // Step 1: Alice sends start message to the server\n    0 -> 1\n      msg(a_start,A,B) to S\n\n    // Step 2: Receive \"start\" message and proceed to generate nonce\n    1 -> 2\n    receive_msg(s_start) from S\n\n    // Step 3: Generate nonce Na and compute key Kab\n    2 -> 3\n    gen_random(Na)\n    gen_random(Kab)\n    msg(A, B, enc({Kab, Na},Kas)) to B\n\nend role\n\n\nrole role_B(B, A, S: agent, Kab: symmetric_key)\nplayed_by B\n\n  // Local variables\n  var Nb: nonce;\n\n  // Initialisms\n  init_B\n    state_agent(A)\n    state_agent(B)\n    state_agent(S)\n    state_skey(Kab)\n\n  // Transition function\n  transition\n\n    // Step 1: Bob receives message from Alice\n    0 -> 1\n    receive_msg(A,B,enc({Kab, Na},Kas)) from A\n\n    // Step 2: Generate nonce Nb and encrypt key Kab\n    1 -> 2\n    gen_random(Nb)\n    msg(B, enc({Kab, Nb},Kab)) to A\n\nend role\n\n\n role session\nperformed_by role_A(A, B, S, Kas), role_B(B, A, S, Kab)\n\nend role\n\nrole environment()\n  const secretAB: protocol_id;\n\n  intruder_knowledge=(A, B, S, secretAB)\n  \n  init_prot\n    session role_sessions()\n\nend role\n\ngoal\n  secrecy_of secretAB\n\nend goal"]], "HLPSL-1/EKE.hlpsl": [[true, "// Encrypted Key Exchange (EKE) Protocol in HLPSL\n\nrole Alice(RoleID: agent, A: agent, B: agent, E_a: pubkey, K_ab: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RoleID\ndef=\n  local\n    SecK, K_prime: symmetric_key,\n    N_a, N_b: nonce\n  composition\n    Step1_1\n    Step1_2\n    Step1_3\n    Step1_4\n    Step1_5\n  transition\n    0.  State == Step1_1 /\\ Rcv(start) =|>\n        Snd(crypt(K_ab, E_a')) /\\ State' = Step1_2\n\n    1.  State == Step1_2 /\\ Rcv(crypt(K_ab, crypt(A', new(K_prime)))) =|>\n        Snd(crypt(K_prime, new(N_a))) /\\ State' = Step1_3\n\n    2.  State == Step1_3 /\\ Rcv(crypt(K_prime, (N_a', N_b'))) =|>\n        Snd(crypt(K_prime, N_b')) /\\ State' = Step1_4\n\n    3.  State == Step1_4 /\\ Rcv(end) =|>\n        State' = Step1_5\n\nend role\n\nrole Bob(RoleID: agent, A: agent, B: agent, E_a: pubkey, K_ab: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RoleID\ndef=\n  local\n    SecK, K_prime: symmetric_key,\n    N_a, N_b: nonce\n  composition\n    Step2_1\n    Step2_2\n    Step2_3\n    Step2_4\n    Step2_5\n  transition\n    0.  State == Step2_1 /\\ Rcv(crypt(K_ab, E_a')) =|>\n        Snd(crypt(K_ab, crypt(A', new(K_prime)))) /\\ State' = Step2_2\n\n    1.  State == Step2_2 /\\ Rcv(crypt(K_prime, N_a')) =|>\n        Snd(crypt(K_prime, (N_a', new(N_b)))) /\\ State' = Step2_3\n\n    2.  State == Step2_3 /\\ Rcv(crypt(K_prime, N_b')) =|>\n        Snd(end) /\\ State' = Step2_4\n\n    3.  State == Step2_4 /\\ Rcv(end) =|>\n        State' = Step2_5\n\nend role\n\nrole session(AliceID, BobID: agent,\n             E_a: pubkey,\n             K_ab: symmetric_key)\ndef=\n  local\n    SA, SB: channel(dy)\n  composition\n    Alice(AliceID, A, B, E_a, K_ab, SA, SB)\n    Bob(BobID, A, B, E_a, K_ab, SB, SA)\nend role\n\ngoal\n  secrecy_of K_prime\n  authentication_on nonce\nend goal\n\nenvironment(Env)\ndef=\n  const a, b: agent,\n        k_ab: symmetric_key,\n        e_a: pubkey\n\n  intruder_knowledge = {a, b, e_a}\n\n  composition\n    session(a, b, e_a, k_ab)\nend environment"]], "HLPSL-1/Ex3_A.hlpsl": [[true, "// HLPSL Code for Secure Session Establishment Protocol\n\nrole agent_A(\n    A, B: agent,\n    Kb: public_key, Ka_priv: private_key,\n    Msg: msg\n)\n\nplayed_by A\n\ninit\n    state1\n\ntransition\n\n    state1 -> state2 \n    label \"Initiation\"\n    A -> B: {Na}_Kb\n\n    state2 -> state3 \n    label \"Session Key Creation\"\n    B -> A: {Na.Nb}_Ka\n    =|> SKey := NoncePair(Na, Nb)\n    A -> B: {zero, Msg}_SKey\n\nend role\n\nrole agent_B(\n    A, B: agent,\n    Ka: public_key, Kb_priv: private_key,\n    Msg: msg\n)\n\nplayed_by B\n\ninit\n    state1\n\ntransition\n\n    state1 -> state2 \n    label \"Response\"\n    A -> B: {Na}_Kb\n    =|> Nb := new();\n\n    state2 -> state3\n    label \"Acknowledgment\"\n    B -> A: {Na.Nb}_Ka\n    |==> SKey := NoncePair(Na, Nb)\n    B -> A: {one, Msg}_SKey\n\nend role\n\nrole session_establishment_environment()\nconst\n    zero, one: protocol_id\n    Msg: msg\n    Ka, Kb: public_key\n    Ka_priv, Kb_priv: private_key\n\ncomposition\n    knowledge A, B, intruder: Kb, Ka\n\n  scenario_with_intruder\n      session_A_to_B: agent_A(A, B, Kb, Ka_priv, Msg)\n      session_B_to_A: agent_B(A, B, Ka, Kb_priv, Msg)\n\nintruder_knowledge = {Kb, Ka}\n\nend role\n\ngoal\n  secrecy_of Secret: naNb\nend goal\n\nenvironment(\n    session_establishment_environment\n)\n\nspec\n  session_establishment_environment\n\nend environment"]], "HLPSL-1/full-sample.hlpsl": [[true, "role key_server(K: public_key)\nplayed_by KS\ndef=\n  local\n     State : nat\n     A, B : agent\n     PKa, PKb : public_key\n   init\n      State := 0\n   transition\n      0 -> 1\n      % Key Request from Alice\n      %! The server receives a request for Bob's public key\n      recv_1( A, K.bk(A) ) =|> send_1( A, {| B, PKb |} )\n\n      1 -> 2\n      % Key Request from Bob\n      %! The server receives a request for Alice's public key\n      recv_2( B, K.bk(B) ) =|> send_2( B, {| A, PKa |} )\nend role\n\nrole alice(A: agent, B: agent, S: agent, PKb: public_key)\nplayed_by A\ndef=\n  local\n    Na, Nb : text\n    State  : nat\n  init\n    State := 0\n  transition\n    0 -> 1\n    % Step 1: Request Bob's public key from the Key Server\n    send_1( S, K.bk(A) ) // Sending public key request for B\n    recv_1( S, {| B, PKb |} ) // Receiving public key of B\n\n    1 -> 2\n    % Step 2: Generate nonce Na and send it to Bob\n    Na := new()\n    send_2( B, {| Na |}pk (PKb) )\n\n    2 -> 3\n    % Step 4: Receive message from Bob containing Na and Nb\n    recv_3( B, {| Na, Nb |}pk (K.pk(A)) )\n    send_3( B, {| Nb |}pk (PKb) )\nend role\n\nrole bob(B: agent, A: agent, S: agent, PKa: public_key)\nplayed_by B\ndef=\n  local\n    Na, Nb : text\n    State  : nat\n  init\n    State := 0\n  transition\n    0 -> 1\n    % Step 3: Bob receives message from Alice\n    recv_2( A, {| Na |}pk (K.pk(B)) )\n    \n    % If Bob does not have Alice's public key, request it\n    send_1( S, K.bk(B) ) // Sending public key request for A\n    recv_1( S, {| A, PKa |} ) // Receiving public key of A\n    \n    Nb := new()\n    send_2( A, {| Na, Nb |}pk (PKa) )\n\n    1 -> 2\n    % Step 5: Wait for Nb from Alice\n    recv_3( A, {| Nb |}pk (K.pk(B)) )\nend role\n\nrole session(A, B, S : agent, Pka, PKb, PKs: public_key)\ndef=\n  composition\n    alice(A, B, S, PKb)\n    bob(B, A, S, Pka)\n    key_server(PKs)\nend role\n\nrole environment()\ndef=\n  const\n    a, b, s : agent\n    pka, pkb, pks : public_key\n  intruder_knowledge = {s, pks}\n  composition\n    session(a, b, s, pka, pkb, pks)\n  end composition\n  goals\n    confidentiality_of Na, Nb\n    authentication_on a_to_b_auth(A, B)\n    authentication_on b_to_a_auth(B, A)\n  end goals\nend role\n\ngoal\n  secrecy_of Na, Nb\n  authentication_on a_to_b_auth(A, B)\n  authentication_on b_to_a_auth(B, A)\nend goal"]], "HLPSL-1/h.530.hlpsl": [[true, "% HLPSL Specification for H.530 Protocol\n\nrole init_mt(mt, vgk, auf: agent)\n  played_by mt\n\n  const G: nat\n  var X, Y, K: nat\n  var DH_mt, nonce_mt: text\n  var msg_vgk, msg_auf: text\n\n  symmetric_key SK_mt_vgk: agent\n\n  init\n    % Initial state\n    step1.0 := true\n\n  transitions\n    step1.0 -> step1.1\n      msg_vgk := {|nonce_mt, exp(G, X)|}\n      sends_2(vgk, msg_vgk)\n\n    step1.1 -> step1.2\n      msg_auf := recv_2(auf)\n      new K: nat\n      DH_mt := exp(G, K)\n      msg_vgk := {|msg_auf, DH_mt|}\n      sends_2(vgk, msg_vgk)\n\nend role\n\n\nrole init_vgk(vgk, mt, auf: agent)\n  played_by vgk\n\n  const ZZ, M2: nat\n  var Y, K: nat\n  var DH_vgk, nonce_vgk: text\n  var msg_mt1, msg_mt2, msg_auf: text\n\n  symmetric_key SK_vgk_mt: agent\n\n  init\n    % Initial state\n    step2.0 := true\n\n  transitions\n    step2.0 -> step2.1\n      msg_mt1 := recv_2(mt)\n      new K: nat\n      DH_vgk := exp(G, K)\n      msg_auf := {|msg_mt1, F(ZZ, M2)|}\n      sends_2(auf, msg_auf)\n\n    step2.1 -> step2.2\n      msg_mt2 := recv_2(mt)\n      sends_2(mt, {|DH_vgk, msg_auf|})\n\nend role\n\n\nrole init_auf(auf, mt, vgk: agent)\n  played_by auf\n\n  const ZZ, M2: nat\n  var Z: nat\n  var DH_auf, nonce_auf: text\n  var msg_mt1, msg_vgk1, msg_vgk2: text\n\n  init\n    % Initial state\n    step3.0 := true\n\n  transitions\n    step3.0 -> step3.1\n      msg_vgk1 := recv_2(vgk)\n      new Z: nat\n      DH_auf := exp(G, Z)\n      sends_2(vgk, {|DH_auf, msg_vgk1|})\n\nend role\n\n\nrole environment()\n  const mt, vgk, auf: agent\n  const sk_mt_vgk, sk_vgk_mt: symmetric_key\n  const g: nat\n\n  intruder_knowledge = {mt, vgk, auf, g}\n\n  composition\n    init_mt(mt, vgk, auf)\n    init_vgk(vgk, mt, auf)\n    init_auf(auf, mt, vgk)\n\nend role\n\n\ngoal\n  secrecy_of sk_mt_vgk\n  secrecy_of sk_vgk_mt\n  authentication_on mt\n  authentication_on vgk\n\nenvironment(\n  roles := (init_mt, init_vgk, init_auf)\n)\n\nend environment"]], "HLPSL-1/hash_n_multi.hlpsl": [[true, "role user(U, S: agent, U_pw: text, sec_pw: text, hash_func: hash_func)\ndefinitions\n  state: nat\n  Nah4, Nah3: text\n  Nb': text\n  channel: (dy)\nend definitions\n\ntransition\n  step1.0: state = 0 /\\ rcv(start) =>\n    send( U.S, hash_func(U_pw) )\n    state := 2\n\n  step2.0: state = 2 /\\ rcv(S.U, Nb') =>\n    Nah3 := hash_func(Nb' | U_pw)\n    witness(U, S, user_server_nah3, Nah3)\n    send( U.S, Nah3 )\n    state := 4\nend role\n\nrole server(S, U: agent, hash_func: hash_func)\ndefinitions\n  state: nat\n  Nah4, Nah3: text\n  Nb': text\n  sec_pw: text\n  channel: (dy)\nend definitions\n\ntransition\n  step1.1: state = 1 /\\ rcv(U.S, Nah4) =>\n    Nb' := new()\n    Nah3 := hash_func(Nb' | Nah4)\n    send(S.U, Nb')\n    state := 3\n\n  step2.1: state = 3 /\\ rcv(U.S, Nah3) =>\n    check_authentication(S, U, user_server_nah3, Nah3)\n    sec_pw := derive_secret(Nah3)\n    state := 5\nend role\n\nrole session(U, S: agent, U_pw: text, sec_pw: text, hash_func: hash_func)\ndefinitions\n  user_role: user\n  server_role: server\nend definitions\n\ncomposition\n  user_role(U, S, U_pw, sec_pw, hash_func) /\\ server_role(S, U, hash_func)\nend role\n\nrole environment()\ndefinitions\n  U, S, I: agent\n  U_pw, sec_pw: text\n  hash_func: hash_func\nchannel: (dy)\nend definitions\n\nknowledge\n  I: {U, S, U_pw, hash_func}\nend knowledge\n\ncomposition\n  session(U, S, U_pw, sec_pw, hash_func) /\\ \n  session(U, I, U_pw, sec_pw, hash_func)\nend composition\n\ngoal\n  secrecy_of sec_pw\n  authentication_on user_server_nah3\nend goal\nend role"]], "HLPSL-1/authenticationWPA.hlpsl": [[true, "role authenticator(A, S: agent, PSK: session_key, NonceA: text)\nplayed_by A\ndef=\n  local\n    State: nat,\n    AuthRequest, AuthResponse, ReAuthResponse, ReplayCounter, GNonce, PTK, GTK: text\n  init\n    State := 1\n  transition\n    1.  State = 1 /\\ channel(chan_in, S, A) := AuthRequest' \n        =|> channel(chan_out, A, S) := AuthResponse'\n        /\\ State := 3\n    3.  State = 3 /\\ channel(chan_in, S, A) := ReAuthRequest'\n        =|> channel(chan_out, A, S) := {ReAuthResponse', ReplayCounter', GNonce'}_PSK\n        /\\ State := 5\n    5.  State = 5 /\\ channel(chan_in, S, A) := {ReplayCounter', SNonce'}_PSK \n        =|> (PTK := KDF(PSK, NonceA, GNonce', SNonce'), GTK := generate_key())\n        /\\ State := 7\nend role\n\nrole supplicant(S, A: agent, PSK: session_key, NonceS: text)\nplayed_by S\ndef=\n  local\n    State: nat,\n    AuthRequest, AuthResponse, ReAuthRequest, ReplayCounter, SNonce, PTK, GTK: text\n  init\n    State := 1\n  transition\n    1.  State = 1\n        =|> channel(chan_out, S, A) := AuthRequest'\n        /\\ State := 2\n    2.  State = 2 /\\ channel(chan_in, A, S) := AuthResponse' \n        =|> channel(chan_out, S, A) := ReAuthRequest'\n        /\\ State := 4\n    4.  State = 4 /\\ channel(chan_in, A, S) := {ReAuthResponse', ReplayCounter', GNonce'}_PSK\n        =|> (SNonce' := generate_nonce(), channel(chan_out, S, A) := {ReplayCounter', SNonce'}_PSK)\n        /\\ State := 6\n    6.  State = 6 /\\ PTK := KDF(PSK, NonceS, GNonce', SNonce')\n        =|> GTK := derive_key()\n        /\\ State := 7\nend role\n\nrole session(A, S: agent, PSK: session_key)\ndef=\n  local\n    Na, Ns: text\n  composition\n    authenticator(A, S, PSK, Na) /\\ supplicant(S, A, PSK, Ns)\nend role\n\ngoal\n  secrecy_of GTK  // Ensuring GTK remains secret\n\nenvironment()\ndef=\n  const a, s: agent\n  const psk: session_key\n  composition\n    session(a, s, psk)\n  attacker(a) // allowing AVISPA to see elements through an attacker\nend environment"]], "HLPSL-1/IKEv2-DS.hlpsl": [[true, "// HLPSL code for IKEv2-DS protocol analysis using AVISPA\n\nrole alice(A, B: agent, Ka, K: pubkey, SND, RCV: channel(dy)) {\n    const Na: text\n    vars Nb, KEa, KEb, AUTHa, SAa2, SK: text\n    vars receive_SK: protocol_message\n\n    macro Initiator = A\n    macro Responder = B\n\n    init {\n        // Initial value for nonce and half key\n        Na := new()\n\n        // Step 1: IKE_SA_INIT message from Alice to Bob\n        send_1(A, B, Na, KEa)\n    }\n\n    transition {\n        // Step 2: Bob responds to Alice's IKE_SA_INIT message\n        1. State == 1 /\\ RCV( Nb, KEb ) =\n        =|> State' = 2 /\\ // Exchange and establish shared secret SK\n            SK' = dh(KEa, KEb) /\\ AUTHa' = sign({Na, Nb}, Ka)\n\n        // Step 3: IKE_SA_AUTH message from Alice to Bob\n        2. State == 2 /\\ SND( A, AUTHa, SAa2 ) =\n        =|> State' = 3\n    }\n\n    goal {\n        secrecy_of SK\n        authentication_on Nb\n    }\n}\n\nrole bob(A, B: agent, Kb, K: pubkey, SND, RCV: channel(dy)) {\n    const Nb: text\n    vars Na, KEa, KEb, AUTHb, SAb2, SK: text\n    \n    macro Initiator = A\n    macro Responder = B\n\n    init {\n        // Initial value for Bob's nonce and half key\n        Nb := new()\n\n        // Step 2: IKE_SA_INIT response message from Bob to Alice\n        send_1(B, A, Nb, KEb)\n    }\n\n    transition {\n        // Step 3: Alice sends IKE_SA_AUTH message\n        1. State == 1 /\\ RCV( A, AUTHa, SAa2 ) =\n        =|> State' = 2 /\\ // Exchange and derive shared secret SK\n            SK' = dh(KEb, KEa) /\\ AUTHb' = sign({Nb, Na}, Kb)\n\n        // Step 4: IKE_SA_AUTH response message from Bob to Alice\n        2. State == 2 /\\ SND( B, AUTHb, SAb2 ) =\n        =|> State' = 3\n    }\n\n    goal {\n        secrecy_of SK\n        authentication_on Na\n    }\n}\n\nrole environment() {\n    const A, B, I: agent\n    const Ka, Kb, SK: pubkey\n\n    composition {\n        alice(A, B, Ka, SK, A_channel, B_channel)\n        bob(A, B, Kb, SK, B_channel, A_channel)\n    }\n\n    intruder_knowledge = {Ka, Kb}\n}\n\ngoal {\n    authentication_on Nb\n    authentication_on Na\n    secrecy_of SK\n}\n\nenvironment role {\n    composition {\n        alice(A, B, Ka, SK, A_channel, B_channel)\n        bob(A, B, Kb, SK, B_channel, A_channel)\n    }\n}"]], "HLPSL-1/ISO1.hlpsl": [[true, "role alice(A, B : agent, PKa, PKs : public_key, SKa : secret, Text : text) \nplayed_by A\ndef= \n   local \n      Na : random_nonce\n   const \n      server_identity : text\n   init\n      0.   server_identity := B \n   transition \n      1.  (A, B, Na, Text) := new()\n      2.  A -> B : {PKa, A}inv(PKs), Na, server_identity, Text, {Na, server_identity, Text}inv(PKa)\nend role\n\nrole bob(A, B : agent, PKa, PKs : public_key, SKs : secret) \nplayed_by B\ndef= \n   local \n      Na : random_nonce\n   init\n      0.  \n   transition \n      1.  B ?= {PKa', A'}inv(PKs), Na', server_identity', Text', Sig'\n      2.  verify(Sig', {Na', server_identity', Text'}inv(PKa'))\nend role\n\nrole session(A, B : agent, PKa, PKs : public_key, SKa, SKs : secret, Text : text) \ndef= \n   composition \n      alice(A, B, PKa, PKs, SKa, Text)\n      bob(A, B, PKa, PKs, SKs)\nend role\n\nrole environment()\ndef=\n   const alice, bob : agent\n   const ctext : text\n   vars\n      PKa, PKs : public_key\n      SKa, SKs : secret\n      Text : text\n   composition\n      session(alice, bob, PKa, PKs, SKa, SKs, ctext)\nend role\n\ngoal\n   authentication_on Na\n   secrecy_of ctext\nend goal\n\nenvironment()"]], "HLPSL-1/ISO3.hlpsl": [[true, "role iso3_Init(A, B : agent, PKa, PKb, PKs, inv_PKa : public_key, SND, RCV : channel(dy))\nplayed_by A\ndef= local\n    Na : random_nonce,\n    Nb : nonce,\n    Na_B : text,\n    Text2 : text,\n    Ta : text,\n    T1 : text\ninit\n    0. state := 0\n\ntransition\n    1. state = 0 -> state := 1 \n       /\\ Na := new()\n       /\\ send_1 := {PKa, A, sign(PKa, inv(PKs)), Na, B, Text2} \n       /\\ SND!send_1\n\n    2. state = 1 /\\\n       RCV?{PKb, B, sign(PKb, inv(PKs)), Nb, A, Text4}\n       -> state := 2\n       /\\ witness(A, B, Na)   // Trust chain established\n       /\\ Na_B := Na._.A\n       /\\ send_2 := {Nb, A} \n       /\\ SND!publickey_encrypt(PKb, send_2, inv(PKa))\nend role\n\nrole iso3_Resp(B, A : agent, PKa, PKb, PKs, inv_PKb : public_key, SND, RCV : channel(dy))\nplayed_by B\n\ndef= local\n    Nb : random_nonce,\n    Na : nonce,\n    Nb_A : text,\n    Text4 : text,\n    Tb : text,\n    T2 : text\n\ninit\n    0. state := 0\n\ntransition\n    1. state = 0 /\\\n       RCV?{PKa, A, sign(PKa, inv(PKs)), Na, B, Text2}\n       -> state := 1\n       /\\ witness(B, A, Nb)   // Trust chain established\n       /\\ Nb := new()\n       /\\ Text4 := \"SomeText4\" \n       /\\ Nb_A := Nb._.B\n       /\\ send_1 := {PKb, B, sign(PKb, inv(PKs)), Nb, A, Text4}\n       /\\ SND!send_1\n\n    2. state=1 /\\\n       RCV?publickey_encrypt(PKb, {Na, A}, inv(PKa))\n       -> state := 2\nend role\n\nrole session(A, B : agent, PKa, PKb, PKs : public_key)\ndef=\nlocal\n    SND, RCV : channel(dy)\ncomposition\n    iso3_Init(A, B, PKa, PKb, PKs, inv(PKa), SND, RCV) \n    /\\ iso3_Resp(B, A, PKa, PKb, PKs, inv(PKb), RCV, SND)\nend role\n\nrole environment()\ndef=\n    const \n        a, b, c : agent\n        pka, pkb, pks : public_key\n        inv_pka, inv_pkb : public_key_inv\n\n    intruder_knowledge = {a, b, c, pka, pkb, pks, inv_pka, inv_pkb}\n\n    composition\n        session(a, b, pka, pkb, pks)\n\nend role\n\ngoal\n    weak_authentication_on Na\n    weak_authentication_on Nb\nend goal\n\nenvironment() end environment"]], "HLPSL-1/LPD-MSR.hlpsl": [[true, "// LPD MSR Protocol in HLPSL for AVISPA\n\nrole base_station(B, M: agent, PKb: public_key, SCm: text, SND, RCV: channel(dy))\nplayed_by B {\n\n    key_pair (PKb, SKb) \n\n    state start\n    transition\n        1. B -> M: PKb\n        --> state receive_msg\n    end role\n\nrole mobile_device(B, M: agent, PKb: public_key, SCm, X: text, SND, RCV: channel(dy))\nplayed_by M {\n\n    fresh X: symmetric_key\n    state start\n    transition\n        1. M -> B: {X}_PKb\n        --> state send_identity\n        2. M -> B: {| M, SCm |}_X\n        --> state end\n    end role\n\ngoal\n\n  secrecy_of X\n  authentication_on M\n\nenvironment()\n\n  const B, M : agent\n  const PKb: public_key\n  const SCm, X: text\n  protocol: session_id\n  intruder_knowledge = {PKb}\n\n  composition session1 (B, M, PKb, SCm, SND, RCV)\n              session2 (B, M, PKb, SCm, X, SND, RCV)\n\nend environment"]], "HLPSL-1/NSPK_2.hlpsl": [[true, "/* HLPSL Specification for Nonce Exchange Protocol */\n\n/* Define the Alice role */\nrole alice(A, B: agent, Ka, Kb: public_key, SND, RCV: channel(dy))\nplayed_by A\ndef=\n    local\n        State: nat\n        Na, Nb: nonce\n        NB_received: text\n    init\n        State := 0\n    transition\n        0 -> 2\n        % Alice initiates the protocol\n        SND! {Na, A}^Kb /\\\n        State' := 2\n\n        2 -> 4\n        (RCV? {Na, Nb}^Ka) /\\\n        NB_received := Nb /\\\n        SND! {Nb}^Kb /\\\n        State' := 4\nend role\n\n/* Define the Bob role */\nrole bob(A, B: agent, Ka, Kb: public_key, SND, RCV: channel(dy))\nplayed_by B\ndef=\n    local\n        State: nat\n        Na, Nb: nonce\n        NA_received: text\n    init\n        State := 1\n    transition\n        1 -> 3\n        (RCV? {Na, A}^Kb) /\\\n        NA_received := Na /\\\n        SND! {Na, Nb}^Ka /\\\n        State' := 3\n\n        3 -> 5\n        (RCV? {Nb}^Kb) /\\\n        State' := 5\nend role\n\n/* Define the session role */\nrole session\ndef=\n    local\n        A, B: agent\n        Ka, Kb: public_key\n        SND, RCV: channel (dy)\n    init\n    transition\n        % Assigning Alice and Bob's roles\n        role_A: alice(A, B, Ka, Kb, SND, RCV)\n        role_B: bob(A, B, Ka, Kb, RCV, SND)\nend role\n\n/* Define the environment role */\nrole environment()\ndef=\n    const\n        alice, bob: agent\n        ka, kb: public_key\n    intruder_knowledge = {alice, bob, ka, kb}\n    composition\n        session(alice, bob, ka, kb, SND, RCV)\n    security_goal\n        secrecy_of Na\n        secrecy_of Nb\nend role\n\n/* Define the goal for AVISPA */\ngoal\n    secrecy_of Na, Nb\nend goal\n\nenvironment()"]], "HLPSL-1/PBK.hlpsl": [[true, "// HLPSL Specification for Purpose Built Keys Framework (PBK) Protocol\n// Variants: Original Version\n// Authors: Daniel Plasto, Siemens CT IC 3, 2004; Sebastian M\u00f6dersheim, ETH Z\u00fcrich\n\n// Protocol Roles\nrole alice(A, B: agent, PK_A, SK_A: public_key, hash_pk_A: hash_func) \nplayed_by alice {\n\n  // Local variables\n  state == 0\n  msg_to_sign: message\n\n  transition\n\n    0 -> 1: {\n      // Alice sends her identity, public key and hash of her public key to Bob\n      msg_to_sign := {A, PK_A, hash_pk_A}\n    }\n\n    1 -> 2: {\n      // Alice sends a signed message with the hash of her public key\n      msg_to_sign := sign(msg_to_sign, SK_A)\n      send_1(A, B, msg_to_sign)\n    }\n\n    2 -> 3: {\n      // Await nonce from Bob and respond with a signed version of this nonce\n      receive_3(B, A, nonce(N))\n      send_4(A, B, sign(hash(N), SK_A))\n    }\n\n}\n\nrole bob(B, A: agent) \nplayed_by bob {\n\n  // Local variables\n  nonce_received, challenge_nonce: random\n\n  transition\n\n    0 -> 1: {\n      // Bob receives Alice's message and sends back a nonce\n      receive_1(A, B, msg_received)\n      challenge_nonce := new()\n      send_3(B, A, nonce(challenge_nonce))\n    }\n\n    1 -> 2: {\n      // Bob awaits the response from Alice, confirming the received challenge\n      receive_4(A, B, signed_response)\n      msg_received := check_signature(signed_response)\n    }\n\n}\n\n// Sessions and Environment\nrole session(A, B: agent, SK_A: public_key)\ndef={\n  // Compose the protocol interaction with Alice and Bob\n  alice(A, B, PK_A, SK_A, hash(PK_A)) \n  bob(B, A)\n}\n\nrole environment()\nconst {\n  i, alice, bob: agent\n  sk_alice, sk_intruder: public_key\n}\nintruder_knowlege = {sk_intruder}\n\n// Run the protocol with the environment\ngoal {\n  secrecy_of sk_alice\n  authentication_of alice, bob\n}\n\ncomposition {\n  session(alice, bob, sk_alice)\n  session(i, bob, sk_intruder)\n}\n\nenvironment()"]], "HLPSL-1/protocol_v2.hlpsl": [[true, "// HLPSL code for Synchronization between Two Servers protocol\n# Role declarations\nrole shell(S, C, M: agent, PKs, PKc, PKm: public_key, \n           SKs: private_key, Ns: text) \nplayed_by S\n    \n   def= \n    local State0, State1, State2: nat\n    local Mess1, OK, Mess2: text\n  \n    transition\n  \n    1. State0 = State0 -> State1 = State1 /\\\n       out( {Mess1.Ns.S}_PKc )\n  \n    2. State1 = State1 -> State2 = State2 /\\\n       in( {Mess1.Mess2.Ns.Nc}_PKs ) /\\\n       out( {OK.Mess1.Mess2.Nc}_PKc ) \n\n    3. State2 = State2 -> /\\\n       out( {Mess1.Mess2}_PKm ) /\\\n       in( {OK.rep}_PKs )\n       \nend role\n\nrole code(C, S: agent, PKc, PKs: public_key, \n          SKc: private_key, Nc, Ns: text) \nplayed_by C\n    \n   def= \n    local State0, State1: nat\n    local Mess1, Mess2: text\n  \n    transition\n  \n    1. State0 = State0 -> State1 = State1 /\\\n       in( {Mess1.Ns.S}_PKc ) /\\\n       out( {Mess1.Mess2.Ns.Nc}_PKs ) \n  \nend role\n\nrole master(M, S: agent, PKm, PKs: public_key, SKm: private_key) \nplayed_by M\n    \n   def= \n    local State0, State1: nat\n    local OK, Mess1, Mess2, rep : text\n  \n    transition\n  \n    1. State0 = State0 -> State1 = State1 /\\\n       in( {Mess1.Mess2}_PKm ) /\\\n       out( {OK.rep}_PKs )\n\nend role\n\n# Environment declaration\nrole environment()\n    \n   def= \n    const Mess1, Mess2, OK, rep : text\n    const Ns, Nc: text\n    const S, C, M: agent\n    const PKs, PKc, PKm: public_key\n    const SKs, SKc, SKm: private_key\n  \n    composition\n       shell(S, C, M, PKs, PKc, PKm, SKs, Ns) \n       code(C, S, PKc, PKs, SKc, Nc, Ns)\n       master(M, S, PKm, PKs, SKm)\n      \n    end composition\n  \nend role\n\ngoal\n  secrecy_of Nc, Ns\n  \nend goal\n\nenvironment()"]], "HLPSL-1/simple-sample.hlpsl": [[true, "// Needham-Schroeder Public-Key Protocol (NSPK)\n\nrole alice(A, B: agent, SND, RCV: channel(dy))\n    const pkb: public_key\n    const Ka: symmetric_key\n    const S: text\n    state 0\n    const Na: text\n    init\n        Na := new()\n    transition\n        0 -> 1\n        1 -> 2\n        2 -> 3\n    end role\n\nrole bob(B, A: agent, SND, RCV: channel(dy))\n    const pka: public_key\n    const Nb: symmetric_key\n    const S: text\n    state 0\n    const Na, Nb': text\n    init\n        Nb' := new()\n    transition\n        0 -> 1\n        1 -> 2\n        2 -> 3\n    end role\n\ngoal\n    authentication_on Na\n    authentication_on Nb'\n\nenvironment\n    composition session\n    intruder_knowledge = {pkb, pka}\nend environment"]], "HLPSL-1/simple_protocol.hlpsl": [[true, "role Alice(A, B, T: agent, Kat: symmetric_key, SND1, RCV1: channel(dy))\n    const Kab: symmetric_key\n    composition\n        knowledge_A := {Kat}\n        init\n            State := 0\n        transition\n            State = 0 /\\ RCV1(start) =|> State' := 1\n            [] State = 1 =|> State' := 2 /\\ SND1({Kab'}_Kat)\nend role\n\nrole TrustedServer(A, B, T: agent, Kat, Kbt: symmetric_key, RCV1, SND2: channel(dy))\n    composition\n        knowledge_T := {Kat, Kbt}\n        init\n            State := 0\n        transition\n            State = 0 /\\ RCV1({Kab'}_Kat) =|> State' := 1 /\\ SND2({Kab'}_Kbt)\nend role\n\nrole Bob(A, B, T: agent, Kbt: symmetric_key, RCV2: channel(dy))\n    composition\n        knowledge_B := {Kbt}\n        init\n            State := 0\n        transition\n            State = 0 /\\ RCV2({Kab'}_Kbt) =|> State' := 1\nend role\n\ngoal\n    secrecy_of Kab\n\nenvironment()\n    const Kab': symmetric_key\n    agent A, B, T\n    symmetric_key Kat, Kbt\n    channel(dy) SND1, RCV1, RCV2, SND2\n\n    composition\n        Alice(A, B, T, Kat, SND1, RCV1)\n        TrustedServer(A, B, T, Kat, Kbt, RCV1, SND2)\n        Bob(A, B, T, Kbt, RCV2)\n\n    intruder_knowledge = {RCV1, SND2, Kat, Kbt} \nend environment"]], "HLPSL-1/strengthen_protocol.hlpsl": [[true, "// HLPSL code for the Key Exchange Protocol\n\n// Environment\nenvironment(env)\n\n// Protocol Roles\nrole alice(A, B, T: agent, Kat, Kab: symmetric_key, Na: nonce)\ndefinitions\n    State0, State1, State2, State3: nat\n    State: nat\n    Nb: nonce\nbody\n    transition\n        // Alice initiates protocol\n        State = State0 /\\ new(Na) ->\n        send_1(T, {A, B, Kab, Na}_Kat)\n\n        // Await response from Bob via T\n        State = State1 /\\ recv_2(B, {A, B, Na, Nb}_Kab) ->\n        State := State2\n\n        // Send final confirmation to Bob\n        State = State2 ->\n        send_3(B, {A, B, Nb}_Kab)\nend role\n\nrole trusted_party(T, A, B: agent, Kat, Kbt: symmetric_key)\ndefinitions\n    State0, State1: nat\n    State: nat\n    Na, Kab: nonce\nbody\n    transition\n        // Receive message from Alice\n        State = State0 /\\ recv_1(A, {A, B, Kab, Na}_Kat) ->\n        State := State1\n\n        // Forward message to Bob\n        State = State1 ->\n        send_2(B, {B, A, Kab, Na}_Kbt)\nend role\n\nrole bob(B, A, T: agent, Kbt, Kab: symmetric_key)\ndefinitions\n    State0, State1, State2: nat\n    State: nat\n    Na, Nb: nonce\nbody\n    transition\n        // Await message from Trusted Party\n        State = State0 /\\ recv_2(T, {B, A, Kab, Na}_Kbt) ->\n        new(Nb)\n        send_2(A, {A, B, Na, Nb}_Kab)\n        State := State1\n\n        // Process final confirmation from Alice\n        State = State1 /\\ recv_3(A, {A, B, Nb}_Kab) ->\n        State := State2\nend role\n\n// Goals\ngoal\n    secrecy_of Kab\n    authentication_on Nb\nend goal\n\n// Session\nrole session(A, B, T: agent)\ndefinitions\n    Kat, Kbt, Kab: symmetric_key\nbody\n    composition\n        alice(A, B, T, Kat, Kab, Na) \n            /\\ trusted_party(T, A, B, Kat, Kbt) \n            /\\ bob(B, A, T, Kbt, Kab)\nend role\n\n// Environment\nenvironment(env)\ndefinitions\n    A, B, T: agent\n    Kat, Kbt: symmetric_key\nbody\n    composition\n        session(A, B, T)\n    intruder_knowledge = {A, B, T, Kat, Kbt}\nend environment"]], "HLPSL-1/AVISPAProject.hlpsl": [[true, "role alice(A, S, B: agent, Ka: symmetric_key, K: session_key, Na, Nb: nonce)\nplayed_by A\ndef= local State: nat\n     const NbSent: bool\ninit  State := 0 \ntransition\n\n  0 -> 1 \t* State := 0, NbSent := false \n   /\\ send_1(A, S, crypt(Ka, {A, B, Na}))\n\n  1 -> 2 \t* State := 1\n   /\\ recv_2(S, A, crypt(Ka, {K, Na}), MsgK)\n   /\\ SndToB := MsgK\n\n  2 -> 3 \t* State := 2\n   /\\ send_3(A, B, SndToB)\n\n  3 -> 4 \t* State := 3\n   /\\ recv_4(B, A, crypt(K, {Na, Nb}))\n   /\\ NbSent := true\n\n  4 -> 5 \t* State := 4\n   /\\ NbSent\n   /\\ send_5(A, B, crypt(K, {Nb, Na}))\nend role\n\nrole server(S, A, B: agent, Ka, Kb: symmetric_key, K: session_key, Na: nonce)\nplayed_by S\ndef= local State: nat\n     nonces GenNa, GenK: fresh\ninit  State := 0 \ntransition\n\n  0 -> 1 \t* State := 0\n   /\\ recv_1(A, S, crypt(Ka, {A, B, Na}))\n   /\\ new(GenK)\n   /\\ K := GenK\n\n  1 -> 2 \t* State := 1\n   /\\ send_2(S, A, (crypt(Ka, {K, Na}), crypt(Kb, {K, Na, A})))\nend role\n\nrole bob(B, A, S: agent, Kb: symmetric_key, K: session_key, Na, Nb: nonce)\nplayed_by B\ndef= local State: nat\ninit  State := 0 \ntransition\n\n  0 -> 1 \t* State := 0\n   /\\ recv_3(A, B, crypt(Kb, {K, Na, A}))\n\n  1 -> 2 \t* State := 1\n   /\\ new(Nb)\n   /\\ send_4(B, A, crypt(K, {Na, Nb}))\n\n  2 -> 3 \t* State := 2\n   /\\ recv_5(A, B, crypt(K, {Nb, Na}))\nend role\n\nenvironment()\ndef=\nconst Ka, Kb: symmetric_key\n      K: session_key\n      Na, Nb: nonce\n      A, B, S, I: agent\nintruder_knowledge = {A, B, S, I, Ka, Kb}\n\ncomposition\n  alice(A, S, B, Ka, K, Na, Nb)\n  server(S, A, B, Ka, Kb, K, Na)\n  bob(B, A, S, Kb, K, Na, Nb)\nend composition\n\ngoal\n  secrecy_of K\n  authentication_on K\n  authentication_on K\nend goal\n\nenvironment()\nend environment"]], "HLPSL-1/StrongAuthenticationPropertyofAlicetoBob.hlpsl": [[true, "role alice(A, B: agent, Ka, Kb: public_key, Snd, Rcv: channel(dy))\n  const sna: text\n  var Na, Nb: text\n  init\n    State0:\n\n  transition\n    1. State0 -> State1\n      Rcv(start) =|> Na' := new() . sna := secret(Na') .\n      Snd({Na'.A}_Kb)\n\n    2. State1 -> State2\n      Rcv({Nb'.xor(Na,B)}_Ka) =|> Snd({Nb'}_Ka) .\n      witness(A, B, bob_alice_NA, Nb')\n\nend role\n\nrole bob(A, B: agent, Ka, Kb: public_key, Snd, Rcv: channel(dy))\n  const snb: text\n  var Na', Nb': text\n  init\n    State0:\n\n  transition\n    1. State0 -> State1\n      Rcv({Na'.A}_Kb) =|> Nb' := new() . snb := secret(Nb') .\n      Snd({Nb'.xor(Na',B)}_Ka)\n\n    2. State1 -> State2\n      Rcv({Nb'}_Ka) =|> request(B, A, bob_alice_NA, Nb')\n\nend role\n\nrole session(A, B: agent, Ka, Kb: public_key)\n  composition\n    alice(A, B, Ka, Kb, Snd, Rcv)\n    bob(A, B, Ka, Kb, Rcv, Snd)\nend role\n\nrole environment()\n  const i: agent\n  const a, b: agent\n  const ka, kb, ki: public_key\n  intruder_knowledge = {i, ki, ka, kb}\n  composition\n    session(a, b, ka, kb)\n    session(a, i, ka, ki)\nend role\n\ngoal\n  secrecy_of sna\n  secrecy_of snb\n  authentication_on bob_alice_NA\n\nenvironment()"]], "HLPSL-1/strongAuthentication_xor.hlpsl": [[true, "// HLPSL code for the described protocol\n\n// Role of Alice\nrole Alice(A, B: agent, Na: text, S: text, sec_1: text) \nplayed_by A\nconst sec_2: text\nvars Na': text, Nb: text\ninit\n  // Initial state of Alice\n  State_A1 := 0 // Start state\ntransition\n  1. State_A1 = 0 -> State_A1' := 1 // Transition from State_A1 to State_A2 by sending Na'\n    send_1(A, B, Na')\n\n  2. State_A1 = 1 /\\ received(Nb) -> State_A1' := 2 /\\ Nb = xor(Na', S) // Check nonce received is expected\n    request(A, B, auth_1)\nend role\n\n// Role of Bob\nrole Bob(B, A: agent, S: text) \nplayed_by B\nvars Na: text, Na': text, Nb': text\nconst sec_1: text\ninit\n  // Initial state of Bob\n  State_B1 := 0 // Start state\ntransition\n  1. State_B1 = 0 /\\ received(Na') -> State_B1' := 1 // Transition from State_B1 to State_B2 by receiving Na\n    Nb' := xor(Na', S)\n    witness(B, A, auth_1)\n    send_2(B, A, Nb')\nend role\n\n// Session combining Alice and Bob\nrole session(A, B: agent, Na: text, S: text, sec_1: text) \ncomposition\n  Alice(A, B, Na, S, sec_1) and\n  Bob(B, A, S)\nend role\n\n// Protocol environment\nrole environment() \nconst Na: text, S: text, sec_1: text, sec_2: text\nintruder_knowledge = {Na, S, sec_1, sec_2}\ncomposition\n  session(A, B, Na, S, sec_1) and\n  session(A, B, Na, S, sec_2) // introduces potential replay attack with the second session\nend role\n\n// Security goals\ngoal\n  secrecy_of sec_1\n  secrecy_of sec_2\n  authentication_on auth_1\nend goal"]], "HLPSL-1/typedvariableNA.hlpsl": [[true, "// Fixed NSPK Protocol with XOR\n\nrole alice(A, B: agent, Kb: public_key, Snd, Rcv: channel(dy))\nplayed_by A\ndef=\n    local\n        Na, Nb: text\n    const\n        state: nat := 0\n    init\n        state := 0\n    transition\n        1. state = 0 /\\ Rcv(start) =|> \n           Na := new()\n           /\\ Snd({Na}Kb)\n           /\\ state := 1\n\n        2. state = 1 /\\ Rcv({Nb xor Na}Kb) =|> \n           Snd({Nb}Kb)\n           /\\ state := 2\n\nend role\n\n\nrole bob(B, A: agent, Ka: public_key, Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n    local\n        Na, Nb: text\n    const\n        state: nat := 0\n    init\n        state := 0\n    transition\n        1. state = 0 /\\ Rcv({Na}Ka) =|> \n           Nb := new()\n           /\\ Snd({Na xor Nb}Ka)\n           /\\ state := 1\n        \n        2. state = 1 /\\ Rcv({Nb}Ka) =|> \n           state := 2\n\nend role\n\n\nrole session(A, B: agent, Ka, Kb: public_key)\ndef=\n    composition\n        alice(A, B, Kb, Snd_A, Rcv_A)\n        bob(B, A, Ka, Snd_B, Rcv_B)\n    end composition\nend role\n\n\nrole environment()\ndef=\n    const\n        a, b, i: agent\n        ka, kb, k_ai, k_bi: public_key\n    intruder_knowledge = {a, b, i, ka, kb, k_ai, k_bi}\n    composition\n        session(a, b, ka, kb)\n        session(a, i, ka, k_ai)\n        session(i, b, k_bi, kb)\n    end composition\nend role\n\ngoal\n    secrecy_of Na, Nb\n    authentication_on Na\n    authentication_on Nb\nend goal\n\nenvironment()"]], "HLPSL-1/unsafe_one_sym_key.hlpsl": [[true, "/* HLPSL Specification of the described protocol for AVISPA */\n\n/*******************************\n *  Roles Definition\n *******************************/\n\nrole alice(A, B: agent, Ks: public_key, SEnc, Hash: function) \nplayed_by A\ndef=\n  local\n    Na, Nb: text,\n    Sid: text,\n    Pa, PMS: text,\n    Kb: message,\n    Finished: message\n  init\n    state := 0\n  transition\n\n    1. state = 0 /\\ ev_active(A) =|> \n       state' := 1 /\\ witness(A, B, na, Na) /\\\n       Na' := new() /\\ Sid' := new() /\\\n       send_1(A, B, {A, Na, Sid, Pa})\n\n    2. state = 1 /\\ recv_2(B, A, {Nb, Sid, Kb}SEnc(Ks)) =|> \n       state' := 2 /\\ witness(A, B, nb, Nb) /\\\n       claim(A, confidentiality_bob_certificate, Kb)\n       \n    3. state = 2 /\\ SEnc =/= null /\\ recv_3(B, A, {B, Kb}inv(Ks)) =|>\n       state' := 3\n\n    4. state = 3 /\\ SEnc =/= null /\\ send_4(A, B, {A, Ka}inv(Ks)) \n\n    5. state = 3 /\\ SEnc = null /\\ \n       state = 4 /\\Ssend_5(A, B, {PMS}Kb) =|> \n       state' := 5\n\n    6. state = 5 /\\ send_6(A, B, {Hash(Nb, B, PMS)}inv(Ka)) =|>\n       state' := 6 \n\n    7. state = 6 /\\ send_7(A, B, {Finished}KeyGen(Na, Nb, PMS)) =|>\n       state' := 7 /\\\n       claim(A, secrecyClientServerK, {Finished}KeyGen(Na, Nb, PMS))\n\nend role\n\nrole bob(A, B: agent, Ks: public_key, SEnc, Hash: function) \nplayed_by B\ndef=\n  local\n    Na, Nb: text,\n    Sid: text,\n    Pa, PMS: text,\n    Kb: public_key,\n    Finished: message\n  init\n    state := 0\n  transition\n\n    1. state = 0 /\\ recv_1(A, B, {A, Na, Sid, Pa}) =|> \n       state' := 1 /\\ witness(B, A, na, Na) /\\\n       Nb' := new() /\\ Kb' := new() /\\\n       send_2(B, A, {Nb, Sid, Kb}SEnc(Ks))\n\n    2. state = 1 /\\ SEnc =/= null /\\ send_3(B, A, {B, Kb}inv(Ks))\n\n    3. state = 1 /\\ SEnc = null /\\ send_4(B, A, {A, Ka}inv(Ks)) \n\n    4. state = 1 /\\ recv_5(A, B, {PMS}Kb) =|>\n       state' := 2 /\\\n       witness(B, A, pms, PMS)\n\n    5. state = 2 /\\ recv_6(A, B, {Hash(Nb, B, PMS)}inv(Ka)) =|>\n       state' := 3\n\n    6. state = 3 /\\ recv_7(A, B, {Finished}KeyGen(Na, Nb, PMS)) =|>\n       state' := 4 /\\\n       send_8(B, A, {Finished}KeyGen(Na, Nb, PMS)) /\\\n       claim(B, secrecyClientServerK, {Finished}KeyGen(Na, Nb, PMS))\n\nend role\n\n/*******************************\n *  Environment Definition\n *******************************/\n\nrole session(A, B: agent, Ks: public_key, SEnc, Hash: function)\ndef=\n  composition\n    alice(A, B, Ks, SEnc, Hash)\n    bob(A, B, Ks, SEnc, Hash)\nend role\n\nrole environment()\ndef=\n  const\n    alice, bob, key_authority: agent\n    kas, kase: keyset\n  composition\n    session(alice, bob, pk(key_authority), {Display.notation}, {Hash.notation});\n\n  state\n    /* Adversary's knowledge */\n    init := _ /\\\n    kas := inv(pk(key_authority)) /\\\n    kase := kas\n    \nend role\n\n/********************************\n * Protocol Goals\n ********************************/\n\ngoal secrecy_of secrecyClientServerK\nend goal\n\ngoal\n  authentication_on alice_bob_na_nb\nend goal\n\ngoal\n  authentication_on bob_alice_na_nb\nend goal"]], "HLPSL-1/unsafe_wo_cert_check.hlpsl": [[true, "// HLPSL Code for Secure Communication Protocol between Alice and Bob\n\nrole alice(A, B: agent, Ka, Kb: public_key, invKa: private_key, Sid, Pa: text) \nplayed_by A\n  \n  var Na, Nb, PMS: text \n\n  fresh Na: nonce\n  fresh PMS: text\n\n  protocol_state: \n    // Define local state variables\n    state_0, state_1, state_2: nat\n  \n  transition\n\n    // Step 1: Initiation\n    step1.1: state_0 -> state_1 \n      send_1(A,B, {A, Na, Sid, Pa})\n\n    // Step 2: Receive Response\n    step2.1: state_1 -> state_2 \n      recv_2(B,A, {Nb, Sid, Pb})\n\n    // Step 3: Receive Server Certificate\n    step3.1: state_2 -> state_3 \n      recv_3(B,A, {B, Kb}inv(Ks))\n\n    // Step 4: Send Client Certificate\n    step4.1: state_3 -> state_4 \n      send_4(A,B, {A, Ka}inv(Ks))\n\n    // Step 5: Send Premaster Secret\n    step5.1: state_4 -> state_5 \n      send_5(A,B, {PMS}Kb)\n\n    // Step 6: Certificate Verification\n    step6.1: state_5 -> state_6 \n      send_6(A,B, {H(Nb, B, PMS)}invKa)\n\n    // Step 7: Send Finished Message\n    step7.1: state_6 -> state_7\n      send_7(A,B, {Finished}Keygen(A, Na, Nb, PMS))\n\n  end role\n\n\nrole bob(B, A: agent, Kb, Ka: public_key, invKb: private_key, Sid, Pb: text) \nplayed_by B\n  \n  var Nb, PMS: text\n  fresh Nb: nonce\n\n  protocol_state:\n    // Define local state variables\n    state_0, state_1, state_2: nat\n\n  transition\n\n    // Step 1: Receive Initiation\n    step1.1: state_0 -> state_1\n      recv_1(A,B, {A, Na, Sid, Pa})\n\n    // Step 2: Send Response\n    step2.1: state_1 -> state_2\n      send_2(B,A, {Nb, Sid, Pb})\n\n    // Step 3: Send Server Certificate\n    step3.1: state_2 -> state_3\n      send_3(B,A, {B, Kb}inv(Ks))\n\n    // Step 8: Receive Finished Message\n    step8.1: state_3 -> state_4\n      recv_8(A,B, {Finished}Keygen(A, Na, Nb, PMS))\n\n    // Step 9: Send Finished Acknowledgment\n    step9.1: state_4 -> state_5\n      send_9(B,A, {Finished}Keygen(B, Na, Nb, PMS))\n\n  end role\n\ngoal\n  secrecy_of PMS \n  authentication_on Nb\n\n  authentication_on Sid\n\nend goal\n\n\nenvironment()\n\n  const Sid, Na, Nb, Pa, Pb, A, B: text\n\n\n  composition\n    alice(A, B, Ka, Kb, invKa, Sid, Pa)\n      bob(B, A, Kb, Ka, invKb, Sid, Pb)\n\nend environment\n\nsession()\n  role alice(A,B,Ka,Kb,invKa,Sid,Pa) at alice\n  role bob(B,A,Kb,Ka,invKb,Sid,Pb) at bob\nend session"]], "HLPSL-1/untypedvariableNa.hlpsl": [[true, "role alice(A, B: agent, Ka, Kb: public_key, snd, rcv: channel(dy))\nplayed_by A\n\nconst Na: text\n\nvars state: nat\n     Na': text\n     Nb': text\n\ninitially\n  state := 0\n  \ntransition\n\n  step1. state = 0 /\\ rcv(start) =|>\n    Na' := new()\n    snd({Na', A}_Kb)\n    state := 1\n\n  step2. state = 1 /\\ rcv({Nb' XOR Na', Nb'}_Ka) =|>\n    snd({Nb'}_Kb)\n    witness(A, B, Na', Nb')  // Record successful exchange\n    state := 2\n\nend role\n\nrole bob(B, A: agent, Ka, Kb: public_key, snd, rcv: channel(dy))\nplayed_by B\n\nconst Nb: text\n\nvars state: nat\n     Na': text\n     Nb': text\n\ninitially\n  state := 0\n\ntransition\n\n  step1. state = 0 /\\ rcv({Na', A}_Kb) =|>\n    Nb' := new()\n    snd({Nb' XOR Na', Nb'}_Ka)\n    request(A, B, Na', Nb')  // Request verification\n    state := 1\n\n  step2. state = 1 /\\ rcv({Nb'}_Kb) =|>\n    state := 2\n\nend role\n\nrole environment()\n\nconst A, B: agent\n      Ka, Kb: public_key\n      sna, snb: text\n\nintruder_knowledge = {A, B, Ka, Kb}\n\ncomposition\n  alice(A, B, Ka, Kb, snd, rcv) /\\ bob(B, A, Ka, Kb, snd, rcv)\n\nend role\n\ngoal\n\n  authentication_on A_witness\n  secrecy_of sna\n  secrecy_of snb\n\nend goal\n\nenvironment()"]], "HLPSL-1/weakAuthenticationfromAlicetoBob.hlpsl": [[true, "// Fixed NSPK Protocol with XOR operator in HLPSL \n\nrole alice(A, B: agent, Ka, Kb: public_key, SnA: protocol_id)\nplayed_by A\ndef=\n    local\n        Na, Nb: text\n        State: nat\n    init\n        State := 0\n    transition\n    1. State = 0 /\\ RCV(start) =|> \n       State' := 1 /\\ Na' := new() /\\ \n       SND({Na'}_Kb)\n\n    2. State = 1 /\\ RCV({Na.Nb'}_Ka) /\\ Nb' XOR Na = Nb =|> \n       State' := 2 /\\ \n       SND({Nb'}_Kb)\nend role\n\nrole bob(B, A: agent, Ka, Kb: public_key, SnB: protocol_id)\nplayed_by B\ndef=\n    local\n        Na, Nb: text\n        State: nat\n    init\n        State := 0\n    transition\n    1. State = 0 /\\ RCV({Na'}_Kb) =|>\n       State' := 1 /\\ Nb' := new() /\\ \n       SND({Na'.(Nb' XOR Na')}_Ka)\n    \n    2. State = 1 /\\ RCV({Nb'}_Kb) /\\ Nb = Nb' =|> \n       State' := 2\nend role\n\nrole session(A, B: agent, Ka, Kb: public_key)\ndef=\n    composition\n        alice(A, B, Ka, Kb, sn(a))\n        bob(B, A, Ka, Kb, sn(b))\nend role\n\nenvironment()\ndef=\n    const\n        a, b: agent\n        ka, kb: public_key\n    intruder_knowledge = {a, b, ka, inv(kb)} \n    composition\n        session(a, b, ka, kb)\n    end composition\n    \n    goal\n        secrecy_of sn(a), sn(b)\n        weak_authentication_on bob_alice_NA\n    end goal\nend environment\n\ngoal\n    secrecy_of sn(a), sn(b)\n    weak_authentication_on bob_alice_NA\nend goal"]], "HLPSL-1/woolamProtocol.hlpsl": [[true, "// HLPSL Specification for Woo-Lam Protocol\n\n// Environment Section\nenvironment()\n\n// Built-in session identifiers\nconst Nil, A, B, S : agent\nconst Kab : symmetric_key\nconst Na, Nb : text\n\n// Role Alice\nrole Alice(A, B, S: agent, Kab, Ka : symmetric_key, Na : text)\n  \n  const Nb_received : text\n  intruder_knowledge = {A, B, S, Ka}\n\n  // Alice's State Transition\n  transition\n  \n  // Step 1: Alice initiates the protocol by sending Na to the server\n  0 -> 1 : {Na}_Ka\n\n  // Step 3: Alice receives Nb and Kab from server, then sends Na, Nb, Kab to Bob\n  1 -> 2 : {Kab, Na, Nb}_Ka =|> {Na, Nb, Kab}_Ka\n  \nend role\n\n// Role Bob\nrole Bob(B, A, S: agent, Kab, Kb : symmetric_key, Nb: text)\n  \n  const Na_received : text\n  intruder_knowledge = {A, B, S, Kb}\n\n  // Bob's State Transition\n  transition\n  \n  // Step 2: Bob receives Na from the server, issues Nb\n  0 -> 1 : Na_received := Na\n\n  // Step 4: Bob receives {Na, Nb, Kab} from Alice, confirms reception to Alice\n  1 -> 2 : {Na, Nb, Kab}_Kb =|> {Kab}_Kb\n  \nend role\n\n// Role Server\nrole Server(S, A, B : agent, Kab, Ka, Kb: symmetric_key, Nb : text)\n  \n  const Na_received, Nb_generated : text\n  intruder_knowledge = {A, B, S, Ka, Kb}\n\n  // Server's State Transition\n  transition\n  \n  // Step 2: Server receives Na from Alice and generates Nb then forwards Na, Nb, Kab\n  0 -> 1 : Na_received := Na\n\n  // Step 2: Forward Na, Nb, Kab to Alice\n  1 -> 2 : {Kab, Na, Nb_generated}_Ka\n\n  // Step 4: After Bob issues Nb, forwards Na, Nb, Kab to Bob\n  2 -> 3 : {Kab, Na_received, Nb_generated}_Kb\n  \nend role\n\n// Goals\ngoal\n\n  // Authentication\n  unsure(Alice, Nb_received)\n  unsure(Bob, Na_received)\n\n  // Confidentiality of Kab\n  secrecy_of Kab\n  \nend goal\n\n// Session\nsession()\n  const Na, Nb : text\n  const Kab : symmetric_key\n\n  // Initialize\n  init(A, B, S : agent, Ka, Kb, Kab : symmetric_key, Na, Nb: text)\n\n  // Bind Roles to Agents\n  composition\n  Alice(A, B, S, Kab, Ka, Na)\n  Bob(B, A, S, Kab, Kb, Nb)\n  Server(S, A, B, Kab, Ka, Kb, Nb)\n\nend session"]], "HLPSL-1/XorNSPK_2.hlpsl": [[true, "/* HLPSL Code for NSPKxor Protocol */\n\ninterpretation\n\n% Constant Definitions\nconst Alice, Bob: agent\nconst Na, Nb: text\nconst Ka, Kb: public_key\nconst X: text\n\nsecret Na, Nb\nsecret_attr Na, Nb\n\n% Role specifications\n\nrole alice(A, B: agent, Ka, Kb: public_key, Na: text)\nplayed_by A\n\ndef=\n  local State: nat\n\n% Initial State\n  init State := 0\n\n% Transition rules\n  transition\n\n  1. State = 0 /\\ Rcv(B, {Nb, Na XOR B}_Ka) =|> State:=1 /\\ Snd(B, {Na.A}_Kb)\n\n  2. State = 1 /\\ Rcv(B, {Nb}_Kb) =|> State:=2\n\nend role\n\nrole bob(A, B: agent, Ka, Kb: public_key, Nb: text)\nplayed_by B\n\ndef=\n  local State: nat\n\n% Initial State\n  init State := 0\n\n% Transition rules\n  transition\n\n  1. State = 0 /\\ Rcv(A, {Na.A}_Kb) =|> State:=1 /\\ Snd(A, {Nb, Na XOR B}_Ka)\n\n  2. State = 1 /\\ Rcv(A, {Nb}_Kb) =|> State:=2\n\nend role\n\n% Intruder and Environment\n\nrole session(A, B: agent, Ka, Kb: public_key, Na, Nb: text, X: text)\ndef=\n  composition\n    alice(A, B, Ka, Kb, Na)\n    bob(A, B, Ka, Kb, Nb)\nend role\n\nenvironment()\ndef=\n  const ki: asymmetric_key\n\n  intruder_knowledge = {Alice, Bob, Ka, Kb, ki}\n\n  composition\n    session(Alice, Bob, Ka, Kb, Na, Nb, X)\nend environment\n\ngoal\n  secrecy_of Na\n  secrecy_of Nb\nend goal\n\n% Specification\nspecification\nend specification"]], "HLPSL-1/xsulak04.hlpsl": [[true, "/*------------- Roles Definition -------------*/\nrole alice(A, B, S: agent, ASKU: text, SK: text)\nplayed_by A\ndef=\n  local State, NA: nat\n  init\n    State := 0\n\n  transition\n    State = 0 /\\ RCV(start) =|>\n    State' := 1 /\\ SND({ASKU, NA}_SK)\n\n    State = 1 /\\ RCV({_, NA'}_SK) =|>\n    State' := 2 /\\ SND({NA}_SK)\n\n    State = 2 /\\ RCV(NA') =|>\n    State' := 3\n\nend role\n\nrole bob(B, A, S: agent, BSK: text, SK: text)\nplayed_by B\ndef=\n  local State, NB: nat\n  init\n    State := 0\n\n  transition\n    State = 0 /\\ RCV({ASKU, NA}_SK) =|>\n    State' := 1 /\\ SND({SK, NB}_BSK)\n\n    State = 1 /\\ RCV({NB}_SK) =|>\n    State' := 2\n\nend role\n\nrole server(S, A, B: agent, SKA, SKB: text)\nplayed_by S\ndef=\n  local State, TS: nat\n  init\n    State := 0\n\n  transition\n    State = 0 /\\ RCV({ASKU}_SKA) =|>\n    State' := 1 /\\ SND({SKB, TS}_SKB)\n\nend role\n\n/*------------- Composition Definition -------------*/\nrole session(A, B, S: agent, SKA, SKB: text)\ndef=\n  composition\n    alice(A, B, S, ASKU, SKA)\n    bob(B, A, S, BSK, SKB)\n    server(S, A, B, SKA, SKB)\nend role\n\n/*------------- Goals Definition -------------*/\ngoal\n  secrecy_of sec_1\nend goal\n\n/*------------- Environment Definition -------------*/\nenvironment()\ndef=\n  const sec_1: protocol_id\n  agent A, B, S, I\n  intruder_knowledge = {I}\n\n  composition\n    session(A, B, S, SKA, SKB)\nend environment\n\n/*------------- End Of HLPSL Code -------------*/"]]}