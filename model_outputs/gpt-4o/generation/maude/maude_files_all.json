{"MAUDE-1/Denning-Sacco.maude": [[true, "mod DENNING-SACCO is\n    protecting ALL-CRYPTO .\n\n    *** Sorts for the different kinds of data we are handling\n    sorts Principal Nonce Term Key Msg .\n\n    *** Operations for encryption and decryption\n    ops mkey seskey : Principal Principal -> Key .\n    ops e : Key Msg -> Msg .\n    ops d : Key Msg -> Msg .\n\n    *** Variables\n    vars A B S : Principal .\n    vars Na Nb : Nonce .\n    vars K : Key .\n    vars M : Msg .\n\n    *** Declarations of the nonces\n    sort Nonce .\n    op n : Nat -> Nonce [ctor] .\n\n    *** Protocol steps and intruder knowledge\n    ops msg1 msg2 msg3 msg4 : -> Msg .\n\n    *** Protocol definition\n    msg msg1 : A ; B .\n    eq msg2 = e(mkey(A, S), seskey(A, B, n(1)) ; B ; e(mkey(B, S), seskey(A, B, n(1)) ; A)) .\n    eq msg3 = e(mkey(B, S), seskey(A, B, n(1)) ; A) .\n    eq msg4 = e(seskey(A, B, n(1)), M) .\n\n    *** Protocol rules\n    rl [initiate] : msg1 => msg2 .\n    rl [server-response] : msg2 => msg3 .\n    rl [bob-receive] : d(mkey(B, S), msg3) => seskey(A, B, n(1)) .\n    rl [alice-bob-communication] : msg4 => d(seskey(A, B, n(1)), msg4) .\n\n    *** Initial intruder knowledge\n    op i : -> Principal .\n    vars X : Principal .\n    var N : Nonce .\n    var Q : Msg .\n\n    rl [ik-init] : ~ i ; A ; B .\n    rl [ik-beyond] : forall X : Principal . ~ X , ~ i ; X .\n    rl [ik-learn] : forall N : Nonce . ( e(mkey(i, S), seskey(A, B, N)) , ~ i ; msg1 ) => ~ i ; msg2 .\n\n    *** Define the goals to check confidentiality, authentication, and freshness\n    goals\n      non secret e(seskey(A, B, N), M) .\n      non secret e(seskey(A, B, n(1)), M) .\nendm"]], "MAUDE-1/maa-crc.maude": [[true, "mod PROTOCOL-ANALYSIS is\n  --- Sorts Definitions ---\n  sort Bit Octet Block Message Key Segment.\n\n  --- Bits are represented either as 0 or 1. ---\n  ops x0 x1 : -> Bit [ctor].\n\n  --- Constructing octet from bits ---\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet.\n\n  --- Constructing block from octets ---\n  op buildBlock : Octet Octet Octet Octet -> Block.\n\n  --- Message constructors ---\n  op unitMessage : Block -> Message.\n  op consMessage : Block Message -> Message.\n\n  --- Key construction ---\n  op buildKey : Block -> Key.\n\n  --- Arithmetic operations ---\n  ops addBit andBit orBit xorBit : Bit Bit -> Bit.\n  ops addOctet : Octet Octet -> Octet.\n  ops addBlock : Block Block -> Block.\n\n  --- Equations for bit operations ---\n  eq addBit(x0, x0) = x0.\n  eq addBit(x0, x1) = x1.\n  eq addBit(x1, x0) = x1.\n  eq addBit(x1, x1) = x0. --- Assuming addition modulo 2\n\n  eq andBit(x0, x0) = x0.\n  eq andBit(x0, x1) = x0.\n  eq andBit(x1, x0) = x0.\n  eq andBit(x1, x1) = x1.\n\n  eq orBit(x0, x0) = x0.\n  eq orBit(x0, x1) = x1.\n  eq orBit(x1, x0) = x1.\n  eq orBit(x1, x1) = x1.\n\n  eq xorBit(x0, x0) = x0.\n  eq xorBit(x0, x1) = x1.\n  eq xorBit(x1, x0) = x1.\n  eq xorBit(x1, x1) = x0.\n\n  --- Equations for octet and block operations ---\n  ceq addOctet(buildOctet(B1, B2, B3, B4, B5, B6, B7, B8), buildOctet(C1, C2, C3, C4, C5, C6, C7, C8)) = \n    buildOctet(addBit(B1, C1), addBit(B2, C2), addBit(B3, C3), addBit(B4, C4), addBit(B5, C5), addBit(B6, C6), addBit(B7, C7), addBit(B8, C8)) if isOctet(buildOctet(B1, B2, B3, B4, B5, B6, B7, B8)) /\\ isOctet(buildOctet(C1, C2, C3, C4, C5, C6, C7, C8)) .\n\n  ceq addBlock(buildBlock(O1, O2, O3, O4), buildBlock(P1, P2, P3, P4)) = buildBlock(addOctet(O1, P1), addOctet(O2, P2), addOctet(O3, P3), addOctet(O4, P4)) if isBlock(buildBlock(O1, O2, O3, O4)) /\\ isBlock(buildBlock(P1, P2, P3, P4)) .\n\n  --- Message handling equations ---\n  eq consMessage(B, unitMessage(M)) = consMessage(B, consMessage(M, unitMessage(B))).\n\n  --- Cryptographic function: Message Authentication Code ---\n  op MAA : Key Message -> Message.\n\n  --- Example of writing equations for MAA operation ---\n  ceq MAA(K, unitMessage(B)) = consMessage(B, unitMessage(B)) if isBlock(B) /\\ isKey(K).\n\n  blk(Block, Octet, Bit) [protecting NAT].\n\nendm"]], "MAUDE-1/AU_and_A_UnificationEdgeCases.maude": [[true, "mod ASSOC-LIST-EX1 is\n  sort Element Pair List .\n  subsort Element < Pair < List .\n  \n  op _:_ : Element Element -> Pair .\n  op _:_ : Pair List -> List [assoc] .\n  op nil : -> List [ctor] .\n  \n  vars A B P : List .\n  \n  --- Unification example to test the algorithm's handling of constrained variables.\n  ceq A:((_~>P_ )~>B ) = A:(((E))~>B ) if match(P,List) .\nendm\n\nmod ASSOC-LIST-EX2 is\n  sort Element Triple List .\n  subsort Element < Triple < List .\n  \n  op _:_ : Element Element Element -> Triple .\n  op _:_ : Triple List -> List [assoc] .\n  op nil : -> List [ctor] .\n  \n  vars X T A B C : List .\n  \n  --- Demonstrates constraint tightening in systems of equations\n  ceq X:(T:(X:Y:(A:C))) = X:(Y:((B)):((A:C))) if tightenConstraints(A, B, C) .\nendm\n\nmod FOO-EX3 is\n  sort Foo .\n  \n  op _*_ : Foo Foo -> Foo [assoc comm id: 1] .\n  op id : -> Foo [ctor] .\n  \n  vars X Y : Foo .\n  \n  --- Avoiding identity assignments with Alpha133 optimization\n  ceq X * id = X .\n  ceq irred Y * X = (X) .\nendm\n\nmod FOO2-EX4 is\n  sort Lo Hi .\n  \n  op \u2295 : Lo Hi -> Hi .\n  op \u2295 : Hi Hi -> Hi [assoc] .\n  \n  vars X Y Z : Hi .\n  \n  --- Examining the optimization that avoids equality steps\n  ceq (X \u2295 Y) = Z if X = Z /\\ Y = Z .\nendm\n\nmod FOO3-EX5 is\n  sort Hi Lo .\n  \n  op \u2299 : Hi Lo -> Hi .\n  op \u2299 : Lo Lo -> Lo [assoc] .\n  op \u2295 : Hi Hi -> Hi [assoc comm] .\n  \n  vars A B : Hi .\n  vars C D : Lo .\n  \n  --- Impact of mixed sorts on optimization strategy\n  ceq A \u2299 C = A \u2299 D if A = B /\\ C = D .\nendm"]], "MAUDE-1/AU_IrredUnification.maude": [[true, "load npa.\n\nmod AU is\n  sorts Foo Elt List Nat .\n  \n  ops 1 : -> Foo .\n  ops a b c : -> Foo .\n  ops nil : -> List .\n  ops __ : Foo Foo -> Foo [assoc comm id: 1] .\n  ops __ : Elt List -> List [assoc id: nil] .\n  \n  vars A B C X Y Z : Foo .\n  vars N M : Nat .\n  vars L : List .\n\n  eq X X = 1 .\n  eq X A = X .\n  eq (X __ Y) A = X B .\n  eq (a __ b) = 1 .\n\n  --- Order-sorted unification example for lists\n  eq (a Elt nil) = a L .\n  eq (X Elt (Y Elt L)) = Z .\n  \n  --- Cycle breaking example with Nat\n  ceq N M = N if N = M .\n  eq (X __ N) N = X .\n\n  --- Handling theory conflicts example\n  eq (X __ X) = 1 .\n  eq (X __ (Y __ Z)) = Z .\n  \nendm"]], "MAUDE-1/bank.maude": [[true, "mod BANKING-PROTOCOL is\n  --- Sorts\n  sorts Account Status Message State .\n\n  --- Subsorts\n  subsort Status < Bool .\n  \n  --- Operations and Constructors\n  op active : -> Status .\n  op blocked : -> Status .\n  op Account : Int Int Status -> Account .\n  op credit : Int Int -> Message .\n  op debit : Int Int -> Message .\n  op transfer : Int Int Int -> Message .\n  op init1 : -> State .\n  op init2 : -> State .\n  op init3 : -> State .\n\n  --- Variables\n  vars Id M N : Int .\n  var AC : Account .\n  vars S S1 S2 : State .\n\n  --- Rules for Account Operations\n  --- Credit operation increases the balance\n  rl [credit] : credit(Id, M) S => Account(Id, Balance + M, Status) S .\n\n  --- Debit operation decreases the balance and may block the account\n  rl [debit] : debit(Id, M) S => \n    if (Balance - M < 0) \n    then Account(Id, Balance - M, blocked) S \n    else Account(Id, Balance - M, Status) S fi .\n\n  --- Transfer operation between accounts\n  rl [transfer] : transfer(Id1, Id2, M) S =>\n    Account(Id1, Balance1 - M, Status1) Account(Id2, Balance2 + M, Status2) S .\n\n  --- Update the status based on account balance\n  rl [updateStatus] : updateStatus(Account(Id, Balance, Status)) =>\n    if (Balance < 0)\n    then Account(Id, Balance, blocked)\n    else Account(Id, Balance, active) fi .\n\n  --- Initial states\n  eq init1 = Account(1, 500, active) Account(2, 300, active) ... .\n  eq init2 = Account(1, 1000, active) Account(3, 200, active) ... .\n  eq init3 = Account(4, 750, active) Account(5, 120, blocked) ... .\n\n  --- Account limitations rules\n  rl [limitAccounts] : S =>\n    (if (countActiveAccounts(S) <= 10) \n    then S \n    else error) fi .\n\n  rl [closeAccount] : (Account(Id, Balance, blocked) S) => \n    if (Balance < -limit)\n    then removeAccount(Id) S \n    else (Account(Id, Balance, blocked) S) fi .\nendm"]], "MAUDE-1/bike.maude": [[true, "mod BIKE-PROTOCOL is\n  including STRING .\n\n  --- Define sorts for participants, keys, and messages\n  sorts Participant Key Message Polynomial Pair .\n\n  subsorts String < Participant Key Message Polynomial Pair .\n\n  --- Define operations for polynomials\n  op _+_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n  op _*_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n\n  --- Define participants\n  ops Alice Bob Eve : -> Participant .\n\n  --- Define messages with participants, states and content\n  op msg : Participant Participant String Content -> Message .\n\n  --- Define content as polynomials or pairs\n  subsorts Polynomial Pair < Content .\n\n  --- Define keys as polynomials\n  op key : Polynomial -> Key .\n\n  --- Define rules for key generation\n  rl [key-gen]:\n    msg(P, Q, \"requestKey\", null)\n    =>\n    msg(Q, P, \"responseKey\", key(P1)) .\n\n  --- Rule for encryption: Alice sends a ciphertext to Bob\n  rl [encrypt]:\n    msg(Alice, Bob, \"requestEncryption\", key(P1))\n    =>\n    msg(Alice, Bob, \"sendCiphertext\", P2) .\n\n  --- Rule for decryption: Bob reconstructs shared key\n  rl [decrypt]:\n    msg(Bob, Alice, \"sendCiphertext\", P2)\n    =>\n    msg(Bob, Alice, \"sharedKey\", P1) .\n\n  --- Intruder can intercept messages and alter them\n  rl [intruder-intercept]:\n    msg(P, Q, S, C)\n    =>\n    msg(Eve, Q, S, alter(C)) .\n\n  --- Intruder can attempt identity attacks\n  rl [identity-attack]:\n    msg(P, Q, S, C)\n    =>\n    msg(Eve, Q, S, C) .\n\nendm\n\nmod ALTERATION is\n  including BIKE-PROTOCOL .\n\n  --- Define an operation to alter message content\n  op alter : Content -> Content .\n\n  --- Dummy implementation of alteration (could be extended)\n  eq alter(C) = C .\n\nendm\n\n--- Define the initial state\nmod INITIAL-STATE is\n  including BIKE-PROTOCOL .\n\n  --- Define initial states with empty keys\n  ops P1 P2 : -> Polynomial [ctor] .\n\n  --- Initial distribution of messages\n  var A B E : Participant .\n  var PK : Polynomial .\n\n  irl [init-state]:\n    messageList\n    =>\n    msg(Alice, Bob, \"requestKey\", null) \n    msg(Bob, Alice, \"requestKey\", null) .\n\nendm"]], "MAUDE-1/closeSocketFeb2020.maude": [[true, "set show timing off .\nset show advisories off .\n\nmod SERVER-SOCKET-SHUTDOWN is\n    protecting SATISFACTION .\n\n    sorts Server State SocketId .\n    subsorts Server < Cid .\n    subsorts SocketId < Oid .\n    \n    ops init closing : -> State [ctor] .\n    op accepting : SocketId -> State [ctor] .\n\n    op createServerTcpSocket : Oid Cid Nat Nat -> Msg [ctor] .\n    op acceptClient : Oid Cid -> Msg [ctor] .\n    op closeSocket : Oid Cid -> Msg [ctor] .\n    op closedSocket : -> Msg [ctor] .\n\n    vars SSkt : SocketId . SCid : Cid . Reason : String .\n\n    rl [createdSocket] :\n        { createServerTcpSocket(socketManager, SCid, 1234, 5) }\n        < SCid : Server | state: init >\n        =>\n        < SCid : Server | state: accepting(SSkt) >\n        { acceptClient(SSkt, SCid) } .\n\n    rl [close] :\n        { closeSocket(SSkt, SCid) }\n        < SCid : Server | state: accepting(SSkt) >\n        =>\n        < SCid : Server | state: closing > .\n\n    rl [closedSocket] :\n        { closedSocket }\n        < SCid : Server | state: closing >\n        =>\n        < SCid : Server | state: init > .\n\n    op initial : -> Configuration .\n    eq initial = { createServerTcpSocket(socketManager, SCid, 1234, 5) } < SCid : Server | state: init > .\nendm\n\nrew initial ."]], "MAUDE-1/complexParserSyncApril2020.maude": [[true, "mod NAT-Authentication-Protocol is\n  protecting NAT .\n  protecting CRYPTO .  % Assume CRYPTO provides basic cryptographic operations.\n\n  sorts Participant Msg Nat Key Nonce AuthToken State .\n\n  ops Client Server : -> Participant .\n  ops authReq authResp : Participant Nat -> Msg .\n  ops publicKey privateKey : Participant -> Key .\n  ops nonce : Nat -> Nonce .\n  ops authToken : Nat Key Nonce -> AuthToken .\n  ops keyExchange : Participant Key -> Msg .\n\n  vars N N' : Nat .\n  vars Kpub Kpriv : Key .\n  vars Non : Nonce .\n  vars AToken : AuthToken .\n  var P : Participant .\n\n  *** Key exchange phase\n  rl [key-exchange] :\n    {Client(P) | state(client-init) } \n  => \n    {Client(P) | state(client-wait-key)}\n    {Server(P) | keyExchange(Client(P), publicKey(Client(P)))} .\n\n  rl [receive-key] :\n    {Server(P) | keyExchange(Client(P), publicKey(Client(P)))} \n  => \n    {Server(P) | state(server-sent-nonce)}\n    {Client(P) | authReq(Server(P), encrypt(nonce(N), publicKey(Client(P))))} .\n\n  *** Authentication phase\n  rl [generate-token]:\n    {Client(P) | authReq(Server(P), encrypt(nonce(N'), publicKey(Client(P)))) } \n  => \n    {Client(P) | state(client-sent-token)}\n    {Server(P) | authToken(N', privateKey(Client(P)), nonce(N'))} .\n\n  rl [validate-token]:\n    {Server(P) | authToken(N', Kpriv, Non) }\n  =>\n    if validate(N', Kpriv, Non) then\n      {Server(P) | state(server-auth-success)}\n      {Client(P) | authResp(Server(P), success)}\n    else\n      {Server(P) | state(server-auth-failure)}\n      {Client(P) | authResp(Server(P), failure)}\n    fi .\n\n  *** Helper function to validate authentication token\n  op validate : Nat Key Nonce -> Bool .\n  eq validate(N', Kpriv, nonce(N)) = \n    (N' == N and Kpriv == privateKey(Client(P))) .\n\nendm"]], "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude": [[true, "fmod NONEXEC is\n  sorts Foo Bar .\n  \n  --- Constructors\n  ops a b : -> Foo .\n  op <_> : Foo -> Bar .\n  \n  --- Variables\n  vars F G : Foo .\n\n  --- Conditional Rewrite Rules\n  --- This rule states that < F > rewrites to < G > if F rewrites to G and F is not equal to G.\n  crl [transform] : < F > => < G > if F => G /\\ F =/= G .\n\n  --- Non-executable Rule\n  --- This rule states a rewrites to b, marked as non-executable.\n  rl [ab] : a => b [nonexec] .\n\nendfm\n\n--- Strategy to test rewriting process\nstrategies\n  strats srew := try(all) ; ab .\n\n--- Initial term for execution\n--- This command simulates rewriting and observation of interactions using defined rules.\nrew < a > using srew ."]], "MAUDE-1/CUIbug12-22-09.maude": [[true, "mod CUI-BUG2-NPA is\n  --- Basic Declarations for the protocol ---\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\n  op g : Foo -> Foo .\n\n  --- Transition Rules for Protocol Actions ---\n  rl b => c .\n  rl g(c) => d .\n\n  --- Intruder Capabilities ---\n  ops i : -> Agent .  --- Intruder identity\n  op spy : Foo -> Foo . --- Intruder's knowledge extraction\n  op encrypt : Foo Foo -> Foo . --- Sample encryption operation\n  op decrypt : Foo Foo -> Foo . --- Sample decryption operation\n\n  --- Public and Shared Knowledge---\n  vars X Y : Foo .\n  rl [sharing] : spy(a) => a .\n  rl [sharing] : spy(b) => b .\n  rl [intruder-receive] : spy(encrypt(X, Y)) => decrypt(X, Y) .\n  rl [intruder-intercept] : spy(f(X, Y)) => f(spy(X), spy(Y)) .\n\n  --- Rewrite Commands for Debugging ---\n  rew f(a, g(b)) .\n\nendm"]], "MAUDE-1/CUI_OccursCheckSeptember2020.maude": [[true, "set show timing off .\nset show advisories off .\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\n  vars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [comm id: 1] .\n  vars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) ."]], "MAUDE-1/CU_Unification.maude": [[true, "set show timing off .\n\n*** Module FOO (Ul Theory)\nfmod FOO is\n    protecting NAT-LIST .\n\n    sort Foo .\n    op f : Foo Foo -> Foo [assoc id: 1f] .\n    op 1f : -> Foo .\n\n    var X : Foo .\n\n    *** Left Identity Property\n    eq f(1f, X) = X .\nendfm\n\n*** Module FOO2 (Ur Theory)\nfmod FOO2 is\n    protecting NAT-LIST .\n\n    sort Foo .\n    op f : Foo Foo -> Foo [assoc id: 1f] .\n    op 1f : -> Foo .\n\n    var X : Foo .\n\n    *** Right Identity Property\n    eq f(X, 1f) = X .\nendfm\n\n*** Module FOO3 (U Theory)\nfmod FOO3 is\n    protecting NAT-LIST .\n\n    sort Foo .\n    op f : Foo Foo -> Foo [id: 1f] .\n    op 1f : -> Foo .\n\n    var X : Foo .\n\n    *** Neutral Identity Property\n    eq f(1f, X) = X .\n    eq f(X, 1f) = X .\nendfm\n\n*** Module FOO4 (CU Theory)\nfmod FOO4 is\n    protecting NAT-LIST .\n\n    sort Foo .\n    op f : Foo Foo -> Foo [comm id: 1f] .\n    op 1f : -> Foo .\n\n    var X Y : Foo .\n\n    *** Commutative Identity Property\n    eq f(1f, X) = X .\n    eq f(X, 1f) = X .\n\n    *** Commutativity Property\n    eq f(X, Y) = f(Y, X) .\nendfm\n\n*** Unification examples\nunify f(U,V) =? f(X,Y) .\nvariant unify f(U,V) =? f(X,Y) .\n\nunify f(U,V) =? U .\nvariant unify f(U,V) =? U .\n\nunify f(U,V) =? V .\nvariant unify f(U,V) =? V ."]], "MAUDE-1/Needham_Schroeder_Lowe.maude": [[true, "mod NSL-MODIFIED is\n  including STRAND-DSL .\n  \n  sort Principal Nonce Key Msg .\n\n  subsort Principal Nonce < Term .\n  subsort Key Msg < Term .\n  \n  op a b i : -> Principal .\n  op na nb : -> Nonce .\n  op pkey skey : Principal -> Key .\n\n  op pk : Key Msg -> Msg .\n  op ; : Msg Msg -> Msg [assoc comm id: null] .\n  \n  vars M N N' : Msg .\n\n  eq {A} pk(pkey(A), skey(A, M)) = M .\n  eq {B} pk(skey(B), pkey(B, M)) = M .\n\n  --- Define Alice's protocol strand\n  protostr A-Strand: (alice(A, B, na))\n    begin\n      send (pk(pkey(B), A ; na))\n      recv (pk(pkey(A), na ; nb ; B))\n      send (pk(pkey(B), nb))\n    end\n\n  --- Define Bob's protocol strand\n  protostr B-Strand: (bob(A, B, nb))\n    begin\n      recv (pk(pkey(B), A ; na))\n      send (pk(pkey(A), na ; nb ; B))\n      recv (pk(pkey(B), nb))\n    end\n\n  --- Define Intruder strand\n  protostr I-Strand: (intruder(i))\n    begin\n      send (pk(pkey(C), X)) \n      recv (pk(pkey(D), Y))\n    end\n\n  --- Security goals in terms of state properties\n  goal alice_knows(Na, Nb) :=\n    (secret_na in alice(A, B, na)) and\n    (secret_nb in bob(A, B, nb))\n    \n  goal bob_knows(Na, Nb) :=\n    (secret_na in bob(A, B, na)) and\n    (secret_nb in alice(A, B, nb))\n  \n  --- Initial state configuration\n  initial state\n    a[List] /\n      <[empty]</List>\n    b[List] /\n      <[empty]</List>\n    i[List] /\n      <[empty]</List>\n  end\n\n  --- Analysis\n  analyzing\n    alice_knows (Na, Nb)\n    bob_knows (Na, Nb)\n  end\nendm"]], "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude": [[true, "mod NAT-UNIFIER-TEST is\n  protecting NAT .\n  *** This module tests the unification and filtering mechanism of Maude-NPA for natural numbers.\n\n  *** No additional operations or sorts are needed as NAT already provides the required infrastructure.\nendm\n\nfmod PROTOCOL-UNIFIER-FILTERING-TEST is\n  protecting NAT-UNIFIER-TEST .\n\n  *** Define any protocol-specific operations or messages if necessary\n  *** This example focuses on the unification of the natural number 1 with itself\n\n  ops scenario : -> Configuration .\n  eq scenario = unify-test(1, 1) .\n\n  *** This function will start the unification test\n  op unify-test : Nat Nat -> Result .\n  ceq unify-test(N:Nat, M:Nat) = if (N == M) then success else failure fi \n  if N == M .\n\n  op success : -> Result [ctor] .\n  op failure : -> Result [ctor] .\n\nendfm\n\n*** Run the unifier filtering test\n\nset show timing off .\nset show advisories off .\n\nsearch scenario =>* success ."]], "MAUDE-1/dekker.maude": [[true, "--- begin of Maude-NPA code for Dekker's Algorithm\n\nmod DEKKERS-ALGORITHM is\n\n  --- Define sorts and declarations\n  sorts Qid Pid State Memory ProcessFlag.\n\n  --- Define operations\n  ops c1 c2 turn : -> Qid .  --- Shared memory locations (Qids)\n  ops p1 p2 : -> Pid .      --- Process identifiers (Pids)\n\n  --- Define the state and its components\n  op <_, _, _, _> : Pid Memory Bool State -> State .  --- State with process, memory, flag, next state\n\n  --- Memory operations\n  vars X Y : Int .\n  var Q : Qid .\n  \n  eq X := (Q := Y) = updateMemory(Q, Y, X).  --- Assign value Y to memory location Q in X\n\n  --- Initial memory settings for Dekker's algorithm\n  op initMem : -> Memory .\n  eq initMem = ((c1 := 0), (c2 := 0), (turn := 1)) .  --- Initial conditions: c1 = 0, c2 = 0, turn = 1\n\n  --- Process configurations\n  ops crit rem : -> Bool .   --- Critical and remainder section indicators\n  ops enterCrit : Pid -> Bool .  --- Predicate for entering critical section\n\n  eq enterCrit(p1) = (mem(c1) == 1) and (mem(turn) == 1) .\n  eq enterCrit(p2) = (mem(c2) == 1) and (mem(turn) == 2) .\n\n  --- Define process execution semantics\n  op exec : Pid State -> State .\n  vars P : Pid .\n  var S : State .\n\n  eq exec(P, S) =\n    if P == p1 and (mem(c1) == 0)\n    then updateMemory(c1, 1, S)\n    else if P == p2 and (mem(c2) == 0)\n    then updateMemory(c2, 1, S)\n    else if crit and P == p1 and turn == 1 \n    then <p1, updateMemory(turn, 2, S), rem, wait(P, S)> \n    else if crit and P == p2 and turn == 2 \n    then <p2, updateMemory(turn, 1, S), rem, wait(P, S)>\n    else S fi .\n\n  --- Predicate for mutual exclusion safety property\n  pred mutualExclusion : State -> Bool .\n  eq mutualExclusion(S) = \n    not (enterCrit(p1) and enterCrit(p2)) .\n\n  --- Analysis tasks\n  op analyze : -> Result .\n  \n  eq analyze =\n    check mutualExclusion initMem .\n\nendm"]], "MAUDE-1/deleteTimerMarch2021.maude": [[true, "mod TIMER-MANAGEMENT is\n  pr NAT .\n  \n  sorts Oid Cid State Configuration .\n\n  ops me timeManager : -> Oid .\n  op myClass : -> Cid .\n  op none : -> State .\n\n  ops createTimer deleteTimer createdTimer : Oid Oid Oid -> State .\n\n  ops <_ : _ | _> : Oid Cid State -> Configuration .\n\n  vars O O2 O3 : Oid .\n\n  rl [create-delete] : < O : myClass | none > createTimer(O2, O)\n    => createdTimer(O, O2, O3) deleteTimer(O3, O) .\n\n  endm\n\nmod INITIAL-STATE is\n  including TIMER-MANAGEMENT .\n\n  vars O O2 O3 : Oid .\n\n  eq < me : myClass | none > = createTimer(timeManager, me) .\n\n  endm"]], "MAUDE-1/dining-philosophers5.maude": [[true, "set show timing off .\nset show advisories off .\nset verbose on .\n\nfmod TIME is\n    sorts Time NzTime .\n    subsort NzTime < Time .\n\n    op zero : -> Time .\n    op _plus_ : Time Time -> Time [assoc comm prec 33 gather (E e)] .\n    op _monus_ : Time Time -> Time [prec 33 gather (E e)] .\n    op _le_ : Time Time -> Bool [prec 37] .\n    op _lt_ : Time Time -> Bool [prec 37] .\n    op _ge_ : Time Time -> Bool [prec 37] .\n    op _gt_ : Time Time -> Bool [prec 37] .\n\n    eq zero plus R:Time = R:Time .\n    eq R:Time le R':Time = (R:Time lt R':Time) or (R:Time == R':Time) .\n    eq R:Time ge R':Time = R':Time le R:Time .\n    eq R:Time gt R':Time = R':Time lt R:Time .\nendfm\n\nfmod DINING-PHILOSOPHERS is\n    protecting TIME .\n    \n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    class Chopstick .\n\n    vars I J N : Nat .\n    vars Conf : Configuration .\n    vars T : Time .\n\n    rl [get-hungry] :\n        < I : Philosopher | status : thinking, timer : 0 > \n        => < I : Philosopher | status : hungry > .\n\n    crl [grab-stick] :\n        < I : Philosopher | status : hungry, chopsticks : N >\n        < J : Chopstick | >\n        => < I : Philosopher | chopsticks : s N >\n        if I == J or (s I == J or (I == 4 and J == 0)) .\n\n    rl [eat] :\n        < I : Philosopher | status : hungry, chopsticks : 2 >\n        => < I : Philosopher | status : eating, timer : EATING-TIME > .\n\n    crl [stop-eating] :\n        < I : Philosopher | status : eating, chopsticks : 2, timer : 0 >\n        => < I : Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME >\n        if true .\n\n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n        = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\n\nendfm\n\nred initState .\nsearch [1] initState =>! S:System ."]], "MAUDE-1/diophantine.maude": [[true, "--- Maude-NPA Formal Analysis Code for Solving Systems of Linear Equations ---\n\nmod LINEAR-SYSTEM-SOLVE is\n  --- Sorts ---\n  sorts Matrix Equation ZeroVector Identifier SolutionMethod .\n  \n  --- Operations ---\n  ops _|->_ : Matrix Matrix -> Equation .\n  ops natSystemSolve : Equation ZeroVector Identifier -> SolutionMethod .\n  \n  --- Example Systems ---\n  vars M1 M2 M3 M4 M5 M6 : Matrix .\n  vars Z : ZeroVector .\n  vars ID : Identifier .\n  \n  --- Example 1: Domenjoud's 10 Solution System ---\n  var E1 : Equation .\n  eq E1 = ( (0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n            (1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5 ) .\n           \n  --- Specify zero vector and solving method ---\n  eq Z = ZeroVector .\n  eq ID = \"cd\" . --- Column-Decomposition method\n  \n  --- Solve the system ---\n  op solveExample1 : -> SolutionMethod .\n  eq solveExample1 = natSystemSolve(E1, Z, ID) .\n  \n  --- Example 2: Sailors and Monkey ---\n  var E2 : Equation .\n  eq E2 = ( (0,0) |-> 1 ; (0,1) |-> -5 ;\n            (1,1) |-> 4 ; (1,2) |-> -5 ;\n            (2,2) |-> 4 ; (2,3) |-> -5 ;\n            (3,3) |-> 4 ; (3,4) |-> -5 ;\n            (4,4) |-> 4 ; (4,5) |-> -5 ;\n            (5,5) |-> 4 ; (5,6) |-> -5 ) .\n            \n  --- Specify zero vector and solving another method ---\n  eq ID = \"gcd\" . --- Greatest Common Divisor method\n  \n  --- Solve the system ---\n  op solveExample2 : -> SolutionMethod .\n  eq solveExample2 = natSystemSolve(E2, Z, ID) .\n  \n  --- Evaluation ---\n  red solveExample1 .\n  red solveExample2 .\nendm"]], "MAUDE-1/doubleAttributeFebruary2023.maude": [[true, "fmod FOO-PROTOCOL is\n  sort Foo .   -- Define the basic data type\n\n  -- Define the operation 'f' with double iteration, allowing nested applications\n  op f : Foo -> Foo [iter iter] .\n\n  -- Additional axioms and rules can be defined here if required\n  -- for specific analysis purposes.\n\n  -- Example: Defining equations if needed\n  -- eq f(f(X:Foo)) = X:Foo [nonexec] .   -- This is an example and can differ\n  \nendfm\n\n-- Maude-NPA configuration for protocol analysis\n\nmod NPA-FOO-PROTOCOL is  \n  pr FOO-PROTOCOL .   -- Import the FOO protocol module\n\n  -- Define the protocol's initial state, goals, and intruder knowledge here.\n  -- You can add further analysis configurations if needed.\n\n  -- For instance, specifying initial states or potential goals to analyze\n  -- can be useful in understanding the iterative effects.\n  \n  -- Example placeholders for states and goals\n  -- var X : Foo .\n  \n  -- Initial knowledge of the intruder\n  -- stratification [constant] :\n  --   op i-knows : Foo -> Fact [ctor] .\n  \nendm"]], "MAUDE-1/Example1.maude": [[true, "mod EXAMPLE1 is\n  protecting PLEXILITE-PREDS .\n\n  including INT .\n\n  sorts State Node Variable .\n\n  ops N : -> Node .\n  ops X x : -> Variable .\n  \n  ops Sigma : Int Variable -> Int .\n\n  vars i j : Int .\n  vars Y Z : Variable .\n  \n  --- Node's behavior: lookup and assignment\n  ops LookUpNow : Variable -> Int .\n  eq LookUpNow(Y) = Sigma(i, Y) .\n\n  --- Example State representation\n  ops stateN : -> State .\n\n  op waiting : -> Bool .\n  op active : Node -> Bool .\n  op none : -> Bool .\n\n  --- Memory management\n  ops memory : Variable -> Bool .\n  ops initValue activeValue : Variable -> Int .\n\n  --- Representation of the node's execution context\n  ceq Example1(State) = \n    if active(N) and waiting() and not none()\n    then x := LookUpNow(X)\n    else\n    fi\n    if memory(x)\n    then state(stateN)\n    else\n    fi\n    if x == Sigma(i, X) \n    then true\n    else false\n    fi\n  if true then true fi .\n\n  --- Definition of the state of node N\n  eq stateN = \n    state(\n      N |-> < waiting : none : active(N)(true) : memory(x) : initValue(X)(Sigma(i, X)) : activeValue(X)(Sigma(i, X)) >\n    ) .\n\nendm\n\n--- Execution command\nsrew stateN using micro ! ."]], "MAUDE-1/Example3.maude": [[true, "mod Example3-Protocol is\n  --- Sorts and Subsorts ---\n  sort Variable State TimeUnit Value .\n  \n  --- Operations ---\n  op gamma : TimeUnit Variable -> Value .\n  op sigma : TimeUnit Variable -> Value .\n  op LookUpOnChange : Variable TimeUnit -> Value .\n  op LookUpNow : Variable -> Value .\n  \n  --- Variables ---\n  vars X : Variable . \n  vars i : TimeUnit . \n  var v : Value .\n\n  --- Initial State ---\n  eq gamma(i-1, X) = 11 .\n  eq sigma(i, X) = 8 .\n  eq sigma(i, X) = 1 .  --- Real value of X \n  \n  --- Execution Rules ---\n  --- Monitor Evaluation ---\n  op whichGamma : TimeUnit Variable -> Value .\n  eq LookUpOnChange(X, 5) = whichGamma(i, X) .\n  eq LookUpNow(X) = whichGamma(i, X) .\n  \n  --- Condition Check ---\n  ceq whichGamma(i, X) = gamma(i-1, X) if (LookUpOnChange(X, 5) >= 9) == false .\n  eq whichGamma(i, X) = gamma(i, X) .\n\n  --- Values Transition ---\n  rl[change-monitor] : < X : Variable | state : S, value : gamma(i-1, X) >\n                   ==> < X : Variable | state : S , value : whichGamma(i, X) >\n\nendm"]], "MAUDE-1/fakeParameterConstant.maude": [[true, "(load-file \"maude-npa.maude\")\n\nfth T is\n  sort Elt .\n  op c : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> X$Elt [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nprove init of BAR{T} in BAR .\nshow all ."]], "MAUDE-1/fakeParameterSort.maude": [[true, "mod PROTOCOL-ANALYSIS is\n  --- Import the necessary theory and module with parameterized sorts\n  protecting T .\n  protecting FOO{X :: T} .\n  protecting BAR{Y :: T} .\n\n  --- Define attacker knowledge and actions\n  --- Here we define the sorts and how an attacker might model interactions or misuse\n  sorts AttackerKnowledge .\n\n  --- Define attack goals related to modular sorts\n  --- Ensure that the fake parameter sort is not mistakenly validated or used\n  op legitimateSort : -> Bool .\n  vars x : X$Elt .\n  vars y : Y$Foo .\n  \n  --- Set up a rule/predicate to check sort integrity\n  eq legitimateSort = true if (x :: X$Elt) and not (y :: X$Foo) .\n\n  --- Here could be an example rule where attacker tries to exploit sort integrity\n  rl [sort-exploit] : x => y if legitimateSort = false .\n\n  --- Initialize states or conditions needed to perform the analysis\n  --- No initial state is provided in the example; define appropriately based on protocol needs\n  \nendm\n\n--- Perform analysis commands\n--- Display sorts relationships and analysis results\n--- These can be used to prove whether the parameter sort meets the conditions or if vulnerabilities exist\nshow sorts .\nshow all ."]], "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude": [[true, "mod MODIFIED-NEEDHAM-SCHROEDER-LOWE-PROTOCOL is\n\n  including STRING .\n\n  sorts Nonce Identity Key .\n\n  --- Subsorts\n  subsort Identity < Key .\n\n  --- Function declarations for public and private keys\n  op pk : Key Msg -> Msg .\n  op sk : Key Msg -> Msg .\n  op sconcat : Msg Msg -> Msg .\n\n  --- Variables declaration\n  vars A B : Identity .\n  vars N_A N_B : Nonce .\n  vars M : Msg .\n\n  --- Axioms governing encryption and decryption\n  eq pk(K, sk(K, M)) = M .\n  eq sk(K, pk(K, M)) = M .\n  eq sconcat(M, M') = M M' .\n\n  --- Protocol strand for Alice\n  strand alice(A, B, N_A) is\n    send(pk(B, sconcat(A, N_A))) .\n    recv(pk(A, sconcat(N_A, N_B, B))) .\n    send(pk(B, N_B)) .\n\n  --- Protocol strand for Bob\n  strand bob(A, B, N_A, N_B) is\n    recv(pk(B, sconcat(A, N_A))) .\n    send(pk(A, sconcat(N_A, N_B, B))) .\n    recv(pk(B, N_B)) .\n\n  --- Intruder capabilities\n  strand intruder(I, M) is\n    --- Intruder intercepts a message and replays it\n    recv(M) .\n    send(M) .\n\nendm\n\n--- Initial state setup\nprotecting MODIFIED-NEEDHAM-SCHROEDER-LOWE-PROTOCOL .\n\n--- Example initial state\n--- Alice initiates communication with Bob, nonce N_A generated\ninit-state initAlice is\n  alice('Alice, 'Bob, 'N_A) .\n\n--- Bob responds and nonce N_B generated\ninit-state initBob is\n  bob('Alice, 'Bob, 'N_A, 'N_B) .\n\n--- Intruder attempts to replay messages\ninit-state initIntruder is\n  intruder('Intruder, M) .\n\nend-protecting"]], "MAUDE-1/filteredVariantUnifyJune2023.maude": [[true, "mod SUB-STACK is\n  including NAT .\n\n  sorts Stk .\n\n  subsorts Stk < Nat .\n\n  ops 0 : -> Nat .\n  op s : Nat -> Nat .\n  \n  ops emp : -> Stk .\n  op mk : Nat -> Stk .\n\n  op _*_ : Stk Stk -> Stk [assoc id: emp] .\n  op _+_ : Stk Stk -> Stk [assoc comm] .\n\n  vars X Y : Stk .\n\n  eq (X * Y) + X = X .\n\nendm\n\n--- Maude-NPA module for formal analysis\nmod SUB-STACK-NPA is\n  protecting SUB-STACK .\n\n  --- Define properties for further analysis using Maude-NPA\n  \n  --- Unification example\n  eq R:Stk =? S:Stk + T:Stk .\n\n  --- Filter variant example\n  --- Employ variant operations and analyze for termination and substitutions\n\nendm"]], "MAUDE-1/generatedByFebruary2023.maude": [[true, "load NPA .\n\nfmod FOO-NPA is\n  including NAT .\n\n  ops nonce : -> Principal .\n  ops a b : -> Principal .\n\n  --- A simplification for demonstration, considering `a` and `b` could be symbols\n  --- in a protocol-related context, though here it's purely illustrative.\n\n  --- Reachability equation in NPA context using NAT for demonstration\n  eq a = b .\n\nendfm\n\n--- NPA commands typically follow\nreduce in FOO-NPA : SecurityGoal ."]], "MAUDE-1/hf-sets.maude": [[true, "mod HF-SETS is\n  --- Sort Definitions\n  sorts Magma Set .\n\n  --- Operator Definitions\n  op {} : -> Set [ctor] .\n  op {_} : Magma -> Set [ctor] .\n  op _U_ : Set Set -> Set [assoc comm] .\n  op _in_ : Magma Set -> Bool .\n  op _eq_ : Set Set -> Bool .\n  op _subset_ : Set Set -> Bool .\n  op P : Set -> Set .\n\n  --- Equations\n\n  --- Set Constructor Idempotency\n  eq S U S = S [nonexec] .\n\n  --- Membership Equations\n  vars M : Magma . vars S T : Set .\n  eq M in {} = false [nonexec] .\n  eq M in {M'} = (M eq M') [nonexec] .\n  eq M in (S U T) = (M in S) or (M in T) [nonexec] .\n\n  --- Union and Equality\n  eq S eq T = (S subset T and T subset S) [nonexec] .\n  eq S subset T = (forall M : Magma . (M in S implies M in T)) [nonexec] .\n  eq P({}) = {{}} [nonexec] .\n  eq P({M}) = {{}, {M}} [nonexec] .\n  eq P(S U T) = P(S) U P(T) [nonexec] .\n\n  --- Intersection Equations\n  eq S _inter_ T = {M :  Magma | M in S and M in T} [nonexec] .\n\n  --- Critical Pairs Handling in Extended Modules\n  --- HF-SETS-1, HF-SETS-2, HF-SETS-3 can be defined similarly\nendm\n\nmod HF-SETS::HF-SETS-1 is\n  protecting HF-SETS .  \n  --- Additional equations dealing with critical pairs\nendm\n\nmod HF-SETS::HF-SETS-2 is\n  protecting HF-SETS::HF-SETS-1 .  \n  --- Additional equations dealing with critical pairs\nendm\n\nmod HF-SETS::HF-SETS-3 is\n  protecting HF-SETS::HF-SETS-2 .  \n  --- Additional equations dealing with critical pairs\nendm\n\n--- Analysis Code Entry Point for Maude-NPA\nreduce in HF-SETS : M in {_M} .\nreduce in HF-SETS : {} eq {M U N} .\nreduce in HF-SETS : (S U T) eq (T U S) by any inclusion rule ."]], "MAUDE-1/identityUnificationMay2020.maude": [[true, "mod UNIFICATION-TEST is\n  pr META-LEVEL .\n  \n  sort Foo .\n  sort Small < Foo .\n  \n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\n  op g : Foo -> Foo .\n\n  vars X Y Z : Foo .\n  var S : Small .\n\n  eq Z = f(X, Y) .\n  eq g(Z) = g(S) .\n  \nendm\n\nmod VARIANT-TEST is\n  pr UNIFICATION-TEST .\n\n  --- Define properties related to variants and their unification\n  --- This could involve defining further equations or rules that help\n  --- test the behavior of unification under various conditions\n  --- ensuring no infinite descent in computations.\n  \nendm"]], "MAUDE-1/instantiatedViewInternalNameOctober2022.maude": [[true, "set show advisories off .\n\nfmod FOO{X :: STRICT-WEAK-ORDER} is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{X}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{X}} .\nendfm\n\nshow kinds .\n\nfmod BAR is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\nendfm\n\nshow kinds ."]], "MAUDE-1/instantiationJuly2019.maude": [[true, "set show timing off .\nset show advisories off .\n\n--- Signature and initial algebra for module FOO\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\n--- Module BAR, depends on module FOO\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  vars x : Big .\n  eq f(x) = (x == a) .\nendfm\n\n--- Module BAZ defines new sorts and operations\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n--- View to map definitions from FOO to BAZ\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\n--- Module TEST incorporates module BAR with specialization view V\nfmod TEST is\n  inc BAR{V} .\nendfm\n\n--- Evaluation command to execute and check output for operation `b`\nred b ."]], "MAUDE-1/initialEqualityPredicate.maude": [[true, "set show timing off .\nset show advisories off .\n\nfmod DECOMPOSE is\n  sorts Nat String .\n  op 0 : -> Nat .\n  ops f g : Nat Nat -> Nat [ctor] .\n  ops h i : Nat Nat -> String [ctor] .\n  op c : Nat Nat -> Nat [ctor comm] .\n  ops b : Nat Nat -> Nat [assoc comm id: 0] .\n  op s : Nat -> Nat [iter ctor] .\n\n  vars W X Y Z : Nat .\n  vars A B : Nat .\n  \n  eq c(X, Y) = c(Y, X) .\n  eq c(X, X) = X .\n  eq c(c(X, Y), Z) = c(X, c(Y, Z)) .\n  \n  eq s^0(X) = X .\n  eq s^n+1(X) = s(s^n(X)) .\n  \n  eq f(X, Y) = f(Y, X) .\n  eq f(f(X, Y), Z) = f(X, f(Y, Z)) .\n  eq f(X, X) = X .\n\n  eq g(g(X, Y), Z) = g(X, g(Y, Z)) .\n  eq g(X, X) = X .\n  \n  eq h(X, Y) = h(Y, X) .\n  eq h(h(X, Y), Z) = h(X, h(Y, Z)) .\n\n  eq b(X, Y) = b(Y, X) .\n  eq b(X, 0) = X .\n\n  eq s^100(X) = s^40(X) .\n  eq s^100(X) = s^40(Y) .\n  eq s^10(X) = s^10(Y) .\n\nendfm\n\nfmod FOO is\n  sorts Foo .\n  ops a b c : -> Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc] .\n  op _+_ : Foo Foo -> Foo [assoc comm] .\n  op s : Foo Foo -> Foo [comm] .\n  op f : Foo Foo -> Foo [assoc comm id: 1] .\n  ops g h p : Foo -> Foo .\n\n  vars X Y Z : Foo .\n  vars A B C D E : Foo .\n\n  eq p(X) = g(h(X)) .\n  eq g(g(X)) = g(g(X, Y)) .\n  eq g(g(X), Y) = g(X, g(Y)) .\n  \n  eq f(a, g(b), c) = h(X) .\n  eq s(g(X), Z) = s(Y, g(X)) .\n  eq (g(A) + g(B) + g(C)) = (g(A) + B + h(C)) .\n  eq (g(A) + g(B) + g(C)) = (g(A) + B) .\n  eq ((g(A) __ b) X) h(A) Y h(b) = (h(a) g(X) g(A) __ X h(b)) .\n  eq (g(A) __ b X) Y h(b) = (g(X) g(A) __ g(A) __ X h(b)) .\n\nendfm"]], "MAUDE-1/irredUnifyFeb2021.maude": [[true, "mod ASSOC-LIST is\n  --- *** Sorts ***\n  sort Elt Pair Triple List .\n\n  --- *** Subsorts ***\n  subsort Pair Triple < List .\n\n  --- *** Operators ***\n  op __ : List List -> List [assoc id: none] .\n  op __ : Elt Elt -> Pair [assoc id: none] .\n  op __ : Elt Pair -> Triple [assoc id: none] .\n  op __ : Pair Elt -> Triple [assoc id: none] .\n  op rev : List -> List .\n\n  --- *** Variables ***\n  var A B C X Y Z : List .\n  var P Q R : Pair .\n  var E F G : Elt .\n  var S T U V : Triple .\nendm\n\nmod UNIFICATION-TEST is\n  pr ASSOC-LIST .\n\n  --- Tests for unification\n  op unify : Triple Triple -> List List .\n  op irred : List List -> List List .\n\n  --- Define unification for elements S and T\n  --- Unification expression: unify(S T) =? A B\n  --- Irredundant unification check: irred(unify(S T)) =? A B\n\n  --- The unification operations can be explored using the filter mechanism\n  --- This is used to simulate potential bug in unification filter related to irredundancy\n\nendm\n\n--- Configuration for Maude-NPA analysis\nmod PROTOCOL-ANALYSIS is\n  pr UNIFICATION-TEST .\n  \n  --- Test module for unification\n  --- It probes S and T into unification expression to check for loss of irredundant unifiers\nendm"]], "MAUDE-1/kindNameDecember2022.maude": [[true, "mod SAFE-FOO{X :: TRIV} is\n  including FOO{X} .\n\n  vars A B : X$Elt .\n  vars S1 S2 : S{X} .\n  vars T1 T2 : T{X} .\n\n  *** Attacker capabilities ***\n  ops a : -> X$Elt [ctor] .\n  ops s1 s2 : -> S{X} [ctor] .\n  ops t1 t2 : -> T{X} [ctor] .\n\n  *** Network declarations ***\n\n  ops send receive : [X$Elt] -> Message .\n  vars Msg : Message .\n\n  *** Operation rules ***\n  rl [send-receive] : send(A) => receive(A) .\n  rl [operation-f] : f([S1, T1]) => f([S2, T2]) .\n\n  *** Initial knowledge of the attacker ***\n  ops initKnowledge : -> Knowledge .\n  rl [initial-knowledge] : initKnowledge => t1 t2 .\n\n  *** Assertion for verification ***\n  ops attack : -> Prop .\n  rl [potential-attack] : attack => false [nonexec] .\n\nendm\n\n*** Assertions ***\ngoal SafeGoal : attack = false ."]], "MAUDE-1/lattice.maude": [[true, "mod LATTICE is\n  protecting NAT .\n\n  --- Declaration of sorts\n  sorts Lat .\n  \n  --- Declaration of operators\n  op 0 : -> Lat [ctor] .\n  op 1 : -> Lat [ctor] .\n  op _\\/_ : Lat Lat -> Lat .\n  op _\\_ : Lat Lat -> Lat .\n  op c : Lat -> Lat .\n\n  --- Equational Axioms for the Lattice Properties\n\n  --- Idempotency\n  eq X \\/ X = X .   --- LAT-01\n  eq X \\ X = X .    --- LAT-02\n\n  --- Identity Elements\n  eq X \\/ 0 = X .   --- LAT-05\n  eq X \\ 1 = X .    --- LAT-06\n\n  --- Absorption Laws\n  eq 1 \\/ X = 1 .   --- LAT-07\n  eq 0 \\ X = 0 .    --- LAT-08\n  eq X \\ (X \\/ Y) = X .   --- LAT-09\n  eq X \\/ (X \\ Y) = X .   --- LAT-10\n\n  --- Extensions of Properties\n  eq Z \\ X \\ (X \\/ Y) = Z \\ X .   --- LAT-11\n  eq Z \\/ X \\/ (X \\ Y) = Z \\/ X . --- LAT-12\n\n  --- Modular Lattice Axiom\n  eq (X \\ Z = X) implies (Z \\ (X \\/ Y) = X \\/ (Y \\ Z)) . --- LAT-13\n\n  --- Complement Axioms\n  eq X \\/ c(X) = 1 .   --- LAT-14\n  eq X \\ c(X) = 0 .    --- LAT-15\n  \n  --- Additional Complement Properties\n  eq c(0) = 1 .        --- LAT-18\n  eq c(1) = 0 .        --- LAT-19\n  eq c(X \\ Y) \\/ X = 1 .   --- LAT-20\n  eq c(X \\/ Y) \\ X = 0 .   --- LAT-21\n\nendm"]], "MAUDE-1/nsl-db-dc.maude": [[true, "mod NSL-DB-PROTOCOL is\n  pr NPA-CRYPTO .\n  \n  sorts Principal Nonce Msg .\n  \n  ops A B I : -> Principal .  --- Define principals: Alice, Bob, Intruder\n  ops pk : Principal -> KeyPair . --- Function to represent public key of a principal\n  ops sk : Principal -> KeyPair . --- Function to represent private key of a principal\n  \n  vars M N : Msg .\n  vars NA NB : Nonce .\n  vars K : KeyPair .\n  \n  ops enc dec : Msg KeyPair -> Msg .  --- Encryption and decryption functions\n  ops id : Principal -> Msg .  --- Function to get principal's identity\n  ops nonce : Nonce -> Msg .  --- Function to represent a nonce\n  \n  --- Protocol messages\n  ops initMsg responseMsg challengeMsg verifyMsg : -> Msg .\n\n  --- Initialization strand (Alice sends first message)\n  ops initStrand : Principal Nonce -> Strand .\n  eq initStrand(A, NA) = send(enc((nonce(NA), id(A)), pk(B))) .\n  \n  --- Response strand (Bob responds)\n  ops responseStrand : Principal Nonce -> Strand .\n  eq responseStrand(B, NB) = recv(enc((nonce(NA), id(A)), pk(B)))\n                             send(enc((nonce(NB), id(B)), pk(A))) .\n  \n  --- Challenge-response strand (Alice responds with challenge)\n  ops challengeStrand : Principal Nonce Nonce -> Strand .\n  eq challengeStrand(A, NA, NB) = recv(enc((nonce(NB), id(B)), pk(A)))\n                                  send(enc((nonce(NA), id(A)), pk(B))) .\n  \n  --- Verification strand (Bob verifies Alice's response)\n  ops verifyStrand : Principal Nonce Nonce -> Strand .\n  eq verifyStrand(B, NA, NB) = recv(enc((nonce(NA), id(A)), pk(B))) .\n  \n  --- Intrusion prevention patterns\n  ops attackPattern : Strand Strand -> Bool .\n  \n  --- Define potential attack scenarios (intruder strands)\n  --- These strands can be developed further to simulate possible attacks\n  ops intruderStrand : Principal Nonce -> Strand .\n  eq intruderStrand(I, NA) = recv(enc((nonce(NA), id(A)), pk(B)))\n                             send(enc((nonce(NA), id(I)), pk(A))) .\n  \nendm"]], "MAUDE-1/legacyMetaGetVariant.maude": [[true, "mod XOR is\n  protecting BOOLEAN .\n  \n  sort XOR .\n  subsort XOR < Elem .\n\n  op cst1 : -> Elem .\n  op cst2 : -> Elem .\n  op cst3 : -> Elem .\n  op cst4 : -> Elem .\n\n  op _+_ : XOR XOR -> XOR [assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X Y : XOR .\n\n  eq Y + 0 = Y .\n  eq X + X = 0 .\n  eq X + X + Y = Y .\nendm\n\nmod TEST is\n  including XOR .\n  including META-LEVEL .\n\n  pr META-NPA .\n\n  var X : XOR .\n  var Y : XOR .\n\n  red metaGetVariant(X + cst1, {}, {}, {}) .\n  red metaGetVariant(X + cst2, {}, {}, {}) .\n  red metaGetVariant(X + cst3, {}, {}, {}) .\n  red metaGetVariant(X + X, {}, {}, {}) .\n  red metaGetVariant(cst1 + cst2, {}, {}, {}) .\nendm"]], "MAUDE-1/mapToParameterTheory.maude": [[true, "set show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\nendfth\n\nfmod M{X :: T} is\n  sort Foo{X} .\n  op f : X$Elt -> Foo{X} .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\nendv\n\nfmod C is\n  sort Bar .\n  op a : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nendv\n\nfmod M2{Y :: T2} is\n  sort Baz{Y} .\n  op g : Y$Elt2 -> Baz{Y} .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***************************************\n*** implicit-explicit sort mapping ***\n***************************************\n\nfth ImplicitTheory is\n  sort ImplicitElt .\nendfth\n\nfmod ImplicitModule{X :: ImplicitTheory} is\n  sort ImplicitSort{X} .\n  op implicitOp : X$ImplicitElt -> ImplicitSort{X} .\nendfm\n\nview ImplicitExplicitView{A :: T} from T2 to ImplicitModule{A} is\n  sort Elt2 to A$ImplicitElt .\nendv\n\nfmod TEST2 is\n  inc ImplicitModule{ImplicitExplicitView{V2}} .\nendfm\n\nshow all .\n\n****************************************\n*** explicit-implicit sort mapping ***\n****************************************\n\nview ExplicitImplicitView{B :: T2} from T to M{B} is\n  sort Elt to B$Elt2 .\nendv\n\nfmod TEST3 is\n  inc M{ExplicitImplicitView{V}} .\nendfm\n\nshow all .\n\n******************************************\n*** implicit-implicit sort mapping ***\n******************************************\n\nview ImplicitImplicitView{C :: T2} from ImplicitTheory to M{C} is\n  sort ImplicitElt to C$Elt2 .\nendv\n\nfmod TEST4 is\n  inc M{ImplicitImplicitView{V}} .\nendfm\n\nshow all .\n\n**************************************\n*** explicit-explicit operator mapping ***\n**************************************\n\nfth OpTheory is\n  sort OpElt .\n  op explicitOp : OpElt OpElt -> OpElt .\nendfth\n\nfmod OpModule{X :: OpTheory} is\n  sort OpSort{X} .\n  op opTransform : X$OpElt -> OpSort{X} .\nendfm\n\nview OpView{D :: OpTheory} from T2 to OpModule{D} is\n  sort Elt2 to D$OpElt .\n  op explicitOp to opTransform .\nendv\n\nfmod TEST5 is\n  inc OpModule{OpView{V2}} .\nendfm\n\nshow all .\n\n***************************************\n*** implicit-explicit operator mapping ***\n***************************************\n\nview ImplicitExplicitOpView{E :: OpTheory} from T to OpModule{E} is\n  sort Elt to E$OpElt .\n  op explicitOp to opTransform .\nendv\n\nfmod TEST6 is\n  inc OpModule{ImplicitExplicitOpView{V}} .\nendfm\n\nshow all .\n\n********************************************\n*** op->term-explicit and explicit-op->term operator mappings ***\n********************************************\n\nfmod TermModule is\n  sort TermSort .\n  op termOp : -> TermSort .\nendfm\n\nview TermView from T2 to TermModule is\n  sort Elt2 to TermSort .\n  op explicitOp to termOp .\nendv\n\nfmod TEST7 is\n  inc TermModule .\nendfm\n\nshow all .\n\n***************************************\n*** polymorphic operator mapping ***\n***************************************\n\nfth PolymorphicTheory is\n  sort PolyElt .\n  op polyOp : PolyElt PolyElt -> PolyElt .\nendfth\n\nfmod PolyModule{X :: PolymorphicTheory} is\n  sort PolySort{X} .\n  op polyTransform : X$PolyElt -> PolySort{X} .\nendfm\n\nview PolyView{F :: PolymorphicTheory} from T2 to PolyModule{F} is\n  sort Elt2 to F$PolyElt .\n  op polyOp to polyTransform .\nendv\n\nfmod TEST8 is\n  inc PolyModule{PolyView{V2}} .\nendfm\n\nshow all ."]], "MAUDE-1/metaApplyNov2018.maude": [[true, "mod SIMPLE-PROTOCOL is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n\n  ops a c : -> Bar .\n  op b : -> Foo .\n  op f : Foo Foo -> Foo .\n\n  vars X Y : Foo .\n\n  eq a = c .\n\n  rl f(X, Y) => X .\n\n  --- Meta-level operations\n  op metaApply : OpName Foo Foo Label Foo Nat -> Term .\n  op metaXapply : OpName Foo Foo Label Foo Nat Nat Nat -> Term .\n\n  vars 'Y 'k : Foo .\n  vars 'n1 'n2 'n3 : Nat .\n\n  eq metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0) =\n      f(b, a) .\n\n  eq metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0) =\n      f(b, a) .\n\nendm"]], "MAUDE-1/metaAutoOoIncludeFebruary2023.maude": [[true, "set show timing off .\n\n***\n***\tTesting Object-Oriented Inclusion in Maude\n***\n\noth FOO is\nendoth\n\nred in META-LEVEL : upModule('FOO, false) ."]], "MAUDE-1/metaIntMatchOct2018.maude": [[true, "mod MATCH is\n  sort Foo Bar .\n  subsort Foo < Bar .\n\n  ops a b c d e : -> Foo . \n  ops g h : Foo -> Foo .\n  op f : Bar Bar -> Bar [comm] .\n\n  var X : Foo .\n  var Y : Bar .\n\n  eq g(a) = c .\n  eq h(b) = d .\n  eq f(X, X) = X .\n  eq f(g(X), h(X)) = e .\nendm\n\nmod MATCH-TEST is\n  protecting MATCH .\n\n  sort User .\n  ops me : -> User .\n  ops soln_ : Bar -> User .\n\n  var U : User .\n  var B : Bar .\n\n  rl [init] : me => soln_(B) .\nendm\n\nmod XMATCH-TEST is\n  protecting MATCH .\n  protecting MATCH-TEST .\n\n  rl [init] : me => soln_(f(g(a), h(b))) .\nendm\n\n--- Analysis using Maude-NPA\nmod PROTOCOL-ANALYSIS is\n  protecting MATCH .\n  protecting MATCH-TEST .\n  protecting XMATCH-TEST .\n\n  vars U : User .\n  vars F1 F2 : Foo .\n  vars S1 S2 : Bar .\n\n  eq init(U, F1, F2) = soln_(f(S1, S2)) .\n  rl [testMatch] : U => soln_(B) .\n  rl [testXMatch] : U => soln_(f(g(F1), h(F2))) .\nendm"]], "MAUDE-1/multiset-algebra.maude": [[true, "fmod MULTISET-NAT-PROTOCOL is\n  --- Definition of sorts\n  sorts Nat Multiset .\n\n  --- Definition of operators for natural numbers\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  --- Definition of operators for multisets\n  op mt : -> Multiset [ctor] .\n  op _,_ : Multiset Multiset -> Multiset [assoc comm ctor] .\n\n  --- Multiset operations\n  op _\\_ : Multiset Multiset -> Multiset .\n  op _C=_ : Multiset Multiset -> Bool .\n  op in : Nat Multiset -> Bool .\n  op _/\\_ : Multiset Multiset -> Multiset .\n  op |_| : Multiset -> Nat .\n  op [_] : Multiset -> Nat .\n  op rem : Nat Multiset -> Multiset .\n  op _==_ : Multiset Multiset -> Bool .\n\n  --- Equations for the multiset operations\n  vars M N : Multiset .\n  var E : Nat .\n\n  --- Union is associative and commutative\n  eq (M, N) = (N, M) .\n  eq ((M, N), E) = (M, (N, E)) .\n\n  --- Multiset difference\n  eq M \\ mt = M .\n  eq (E, M) \\ (E, N) = M \\ N .\n  eq (E, M) \\ N = E, (M \\ N) [owise] .\n\n  --- Multiset containment\n  eq mt C= N = true .\n  eq M C= E, N = true if M C= N .\n  eq M C= N = false [owise] .\n\n  --- Membership\n  eq E in mt = false .\n  eq E in (E, M) = true .\n  eq E in (N, M) = E in M [owise] .\n\n  --- Intersection\n  eq M /\\ mt = mt .\n  eq mt /\\ N = mt .\n  eq (E, M) /\\ N = (E, (M /\\ N)) if E in N .\n  eq (E, M) /\\ (E, N) = (E, (M /\\ N)) [owise] .\n  eq (E, M) /\\ (N, M) = M /\\ N [owise] .\n\n  --- Cardinality\n  eq |mt| = 0 .\n  eq |E, M| = s(|M|) .\n\n  --- Distinct count\n  eq [mt] = 0 .\n  eq [E, M] = s([rem(E, M)]) if not E in M .\n  eq [E, M] = [rem(E, M)] if E in M .\n\n  --- Element removal\n  eq rem(E, mt) = mt .\n  eq rem(E, E, M) = rem(E, M) .\n  eq rem(E, N, M) = N, rem(E, M) [owise] .\n\n  --- Equality\n  eq M == N = (M C= N) and (N C= M) .\n\nendfm\n\n--- Examples to validate the functionality\n\nred (0, s(0), s(s(0))) \\ (s(0), s(0)) .  --- Example of multiset difference\nred (0, s(0)) C= (0, s(0), s(0)) .       --- Example of multiset containment\nred |0, 0, s(0), s(s(0))| .              --- Example of cardinality calculation\nred [0, s(0), s(0), s(s(0))] .           --- Example of distinct count"]], "MAUDE-1/numbers-ACU-proofs.maude": [[true, "mod RATIONAL-ARITHMETIC-GCD is\n  sorts NzNat Int Bool .\n  subsort NzNat < Int .\n\n  op 1 : -> NzNat [ctor] .\n  op tt : -> Bool [ctor] .\n  \n  op gcd : NzNat NzNat -> NzNat .\n  op quot : Int NzNat -> Int .\n  op _+_ : NzNat NzNat -> NzNat [comm assoc id: 0] .\n  op -_ : Int -> Int .\n  op _/_ : Int NzNat -> Int .\n  \n  var N' M' : NzNat .\n  var I J : Int .\n  \n  eq gcd(1, N') = 1 .\n  eq gcd(N', M') > 1 = tt .\n  \n  eq quot(N', 1) = N' .\n  eq -(I / J) = -I / J .\n  eq - (- I) = I .\n\n  rl [rule1] : \n    -(quot(1, gcd(@2: NzNat, 1)) / quot(@2: NzNat, gcd(@2: NzNat, 1)))\n    => -1 / @2: NzNat .\n  \n  rl [rule2] : \n    -(quot(N' + M', gcd(@2: NzNat, N' + M')) / quot(@2: NzNat, gcd(@2: NzNat, N' + M')))\n    => -(N' + M') / @2: NzNat .\n  \n  rl [rule3] : \n    -(quot(-N', gcd(@2: NzNat, -N')) / quot(@2: NzNat, gcd(@2: NzNat, -N')))\n    => -(-N') / @2: NzNat .\n\nendm"]], "MAUDE-1/objectMessageOct2018.maude": [[true, "mod FOO is\n  pr CONFIGURATION .\n\n  sort Cid Oid Msg AttributeSet .\n  \n  ops User : Cid -> Oid .\n  ops me, other : -> Oid .\n  ops no-op : Oid Oid -> Msg .\n  \n  vars X Y : Oid .\n  vars AS : AttributeSet .\n\n  rl [no-op-rule] : no-op(X, Y) => no-op(X, Y) .\n\nendm\n\n--- Debugging and profiling setup\nset break { select('__ .) } .\ntrace on .\nprofile on .\n\n--- Fake rewrite operation triggering debugger\nrew no-op(me, other) .\n\n--- Resume execution\nresume .\n\n--- Display profiling information\nprofile show ."]], "MAUDE-1/opRenamingParseErrorMarch2023.maude": [[true, "*** Formal analysis using Maude-NPA for operations renaming with sort \"to\". ***\n\nmod PROTOCOL-ANALYSIS is\n  *** Define the sorts used in the protocol ***\n\n  sorts Foo to .\n\n  *** Define the operations and their semantics ***\n\n  ops f : Foo to -> Foo .\n  vars X : Foo .\n  vars Y : to .\n\n  *** Define the behavior of operation f ***\n\n  *** Axioms representing transformation rules or desired properties ***\n  eq f(X Y) = X .\n\nendm\n\nmod BAR is\n  *** Include the previous module FOO with operation renaming ***\n\n  inc as PROTOCOL-ANALYSIS * (op f : Foo to -> Foo to g) .\n\n  *** Additional definitions or properties for BAR could go here ***\n\nendm\n\n*** Perform analysis or verification steps ***\n\nshow desugared ."]], "MAUDE-1/operatorNames.maude": [[true, "fmod T is\n  sort Elt .\n\n  op (_:_) : Elt Elt -> Elt .\n  op {_}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op [:] : -> Elt .\nendfm\n\nfmod M is\n  sort Elt .\n\n  op term{_,_} : Elt Elt -> Elt .\n  op {_}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  sort Elt -> Elt .\n\n  op (_:_) -> term{_,_} .\n  op {_}to{_} -> {_}.{_} .\n  op two to -> term{} .\n  op [:] -> }.{ .\nendv\n\nfth T2 : T + \n  ops customOp1 customOp2 : Elt Elt -> Elt .\nendfth\n\nfmod OP-HOOK-TEST is\n  sort Nat .\n\n  op zero : -> Nat .\n  op s : Nat -> Nat .\n  op _+_ : Nat Nat -> Nat .\n\n  var N M : Nat .\n  \n  eq (N + zero) = N [metadata \"hook\": \"+\" ] .\n  eq (zero + N) = N [metadata \"hook\": \"+\" ] .\nendfm\n\nfmod OP-HOOK-TEST2 is\n  sort Nat .\n\n  op zero : -> Nat .\n  op s : Nat -> Nat .\n  op _+_ : Nat Nat -> Nat .\n\n  var A B : Nat .\n  \n  eq (A + (s B)) = s(A + B) [metadata \"rewriting\"] .\nendfm\n\nomod FOO is\n  sort Item .\n\n  op newItem : Item -> Item .\n  op compItem : Item Item -> Item .\nendom"]], "MAUDE-1/signed_dh.maude": [[true, "mod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting KEYS-AND-MESSAGES .\n  sorts Name Nonce Generator .\n  *** Key sorts\n  op pk : Name -> Key [ctor] .\n  op sk : Name -> Key [ctor] .\n  *** Message constructor operations\n  op exp : Generator Nat -> Message [ctor] .\n  op sign : Name Message -> Message [ctor] .\n  *** Participants\n  op A B i : -> Name [ctor] .\n  *** Nonce\n  op N_A N_B : -> Nonce [ctor] .\n  *** Generator\n  op g : -> Generator [ctor] .\nendm\n\nmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  var X : Generator .\n  var Y Z : Nat .\n  var K M : Message .\n  *** Exponentiation property\n  eq exp(exp(X, Y), Z) = exp(X, Y * Z) .\n  *** Encryption and decryption properties\n  eq e(K, d(K, M)) = M .\n  eq d(K, e(K, M)) = M .\nendm\n\nmod PROTOCOL-SPECIFICATION is\n  pr PROTOCOL-EXAMPLE-SYMBOLS .\n  pr PROTOCOL-EXAMPLE-ALGEBRAIC .\n  pr STRANDS-AND-NODES .\n\n  *** Protocol strands\n  strand A-to-B is\n    State(1) | A ; B ; exp(g, N_A) ; sign(A, B ; exp(g, N_A)) .\n    State(2) | A ; B ; exp(g, N_B) ; sign(B, A ; exp(g, N_B)) .\n\n  strand B-to-A is\n    State(1) | A ; B ; exp(g, N_A) ; sign(A, B ; exp(g, N_A)) .\n    State(2) | A ; B ; exp(g, N_B) ; sign(B, A ; exp(g, N_B)) .\n  \n  *** Intruder capabilities\n  intruder-caps .\n    *** Intercept messages\n    op intercept : Message -> Action [ctor] .\n    *** Forge signatures\n    op forge-sign : Name Message -> Action [ctor] .\n    *** Exploit algebraic properties\n    op exploit-exp : Generator Nat Nat -> Action [ctor] .\n  \n  *** Attack state\n  attack-state is\n    < a | State(2) | exp(exp(g, N_B), N_A) = exp(g, N_B * N_A) >\nendm"]], "MAUDE-1/orphanedViewInstantiationFebruary2023.maude": [[true, "*** This Maude-NPA script is designed to test the garbage collection of orphaned view instantiations. ***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nrs FOO is\n  vars N : Nat .\n  vars S : Set{Nat} .  \n  rl [garbage-collection]: FOO(N, S) => null .\nendrs\n\nshow modules .\nshow views ."]], "MAUDE-1/parallel-maude-npa.maude": [[true, "mod META-INTERPRETER-MANAGER is\n  including NAT .\n  including BOOL .\n\n  -- Declarations for sorts and operations\n  sorts Manager Worker Job Status Module .\n  subsort Nat < Worker .\n\n  ops initManager : Nat Nat -> Manager [ctor] . -- Number of Workers, Number of Jobs\n  ops job : Nat -> Job [ctor] .\n  ops worker : Nat Job -> Worker [ctor] .\n  ops running idle : -> Status [ctor] .\n\n  -- Variables\n  vars W J : Nat .\n  vars M N : Manager .\n\n  -- Initialization rules\n  rl [init] : initManager(W, J) => < M : Manager | workers: createWorkers(W), jobs: createJobs(J), status: idle >\n\n  --- Creating workers\n  op createWorkers : Nat -> Configuration .\n  eq createWorkers(0) = none .\n  eq createWorkers(s(W)) = createWorkers(W) < worker(W, none) : Worker | status: idle > .\n\n  --- Creating jobs\n  op createJobs : Nat -> Configuration .\n  eq createJobs(0) = none .\n  eq createJobs(s(J)) = createJobs(J) < job(J) : Job | > .\n\n  -- Rule for assigning jobs to workers\n  rl [assignJob] :\n    < M : Manager | workers: < W : Worker | status: idle > , jobs: < job(J) : Job | >, status: R > =>\n    < M : Manager | workers: < W : Worker | status: running > , jobs: none, status: R > .\n\n  -- Termination rules\n  rl [terminate] :\n    < M : Manager | workers: < W : Worker | status: running >, status: R > =>\n    < M : Manager | workers: none, status: R > .\n\n\n  --- Define the dynamic loading of modules (simplified representation)\n  op loadModules : Manager -> Manager .\n  eq loadModules(M) = M .\n\n  --- Cleanup after all workers have finished\n  rl [cleanup] :\n    < M : Manager | workers: none, status: idle > => none .\n\nendm"]], "MAUDE-1/parameterizedPolymorphicConstantMarch2023.maude": [[true, "mod PROTOCOL-ANALYSIS is\n  protecting TRIV .\n\n  --- Import FOO with some actual type, such as TRIV or a specific instantiation if needed.\n  fmod FOO2 is\n    inc FOO{TRIV} .\n  endfm\n\n  --- Import BAR similarly with a specific type instantiation.\n  fmod BAR2 is\n    inc BAR{TRIV} .\n  endfm\n\n  --- Define initial state, goals, or assumptions you want to check.\n  --- Since this is a generic example without specific goals, you would replace this with your particular aim, such as state reachability.\n\n  --- Here we illustrate a basic check, typically your focus would be on data integrity, confidentiality, etc., in a real protocol setting.\n  --- Initial state example.\n  op initState : -> State .\n  eq initState =  B:initState .\n\n  --- Define an example problem: checking for equality.\n  eq B:initState = c{TRIV} .\n\n  -- If this were an actual protocol, you would define the attack model and properties to check like so.\n  --- op attackModel : ... .\n  --- define the attack scenario or property\n  --- var X : TRIV .\n  --- eq attackModel = ... .\n\nendm\n\n--- Example run configuration if this was a full protocol.\n--- show all -- shows information, normally not part of Maude-NPA focus.\n--- search initState =>* attackModel ."]], "MAUDE-1/physArgIndexOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\nmod VENDING-MACHINE is\n  sorts Coin Item Place Marking .\n  subsorts Coin Item < Place < Marking .\n  op __ : Marking Marking -> Marking [ctor assoc comm id: null] .\n  op null : -> Marking [ctor] .\n  op $ : -> Coin [ctor format (r! o)] .\n  op q : -> Coin [ctor format (r! o)] .\n  op a : -> Item [ctor format (b! o)] .\n  op c : -> Item [ctor format (b! o)] .\n\n  rl [buy-c] : $ => c .\n  rl [buy-a] : $ => a  q .\n  rl [change]: q  q  q  q => $ .\nendm\n\n*** Demonstrating that three coins can be rewritten using defined rules\nsrewrite in VENDING-MACHINE : $ $ $ .\n\n*** Exploring the state space to show three coins can lead to two items\nsearch in VENDING-MACHINE : $ $ $ =>! a a M:Marking .\n\nmod FOO is\n  sort Foo .\n  op __ : Foo Foo -> Foo [assoc comm] .\n  ops a b c : -> Foo .\n\n  rl b => c .\nendm\n\n*** Using `rew` command on terms in module FOO\nrew in FOO : a a b ."]], "MAUDE-1/polymorphicParsingBugsNovember2020.maude": [[true, "fmod POLY-ASSOC is\n  sorts Poly .\n  op f : Poly Poly -> Poly [assoc] .\n  vars X Y Z : Poly .\n  eq f(X, Y, Z) = X .\nendfm\n\nfmod POLY-ITER is\n  sorts Poly .\n  op f : Poly -> Poly .\n  var X : Poly .\n  eq f(X) = X .\nendfm\n\nred in POLY-ASSOC : f(X:Bool, Y:Bool, Z:Bool) .\nred in POLY-ITER : f^12345(X:Bool) ."]], "MAUDE-1/quotedTokenMarch2023.maude": [[true, "set show timing off .\n\n***\n*** Protocol FOO: Demonstrating operations on Natural Numbers\n***\n\nfmod FOO is\n  pr NAT .\n  \n  *** Declare operations with iterable attributes\n  op \"s\" : Nat -> Nat [iter] .\n  op \"f\"g : Nat -> Nat [iter] .\n  \n  *** Define reductions for demonstration purposes\n  rl \"X\":Nat => Nat .\n  rl \"X:Y\":NzNat => NzNat .\n  rl \"X:Y\"Z:NzNat => NzNat .\n  rl \"X\":[Nat] => Nat .\n\nendfm\n\n*** Examples of operation evaluations\nred \"s\"^42(0) .\nred \"f\"g^2(0) ."]], "MAUDE-1/pseudoParameterTheoryConstantMarch2023.maude": [[true, "*** Maude-NPA Protocol Analysis for Parameterized Constants Instantiation Test ***\n\nmod Elt is \n  sorts Elt .\nendm\n\nmod ConstantsInst is\n  sorts Elt .\n  op c{X} : -> Elt .\nendm\n\nmod FOO{X :: ConstantsInst} is\n  pr Elt .\n  eq c{X} = c{X} .\nendm\n\nmod BAR{Y :: ConstantsInst} is\n  pr FOO{Y} .\nendm\n\nops shows : -> Elt .\n\neq shows = shows .\n\n*** Commands for analysis ***\n\nshow all ."]], "MAUDE-1/RAT-ACU-original.maude": [[true, "mod BOOL-FVP is\n  sorts Bool .\n  ops tt ff : -> Bool .\n  ops _/\\_ _\\/_ ~_ : Bool Bool -> Bool .\n  vars B1 B2 : Bool .\n\n  eq tt /\\ B1 = B1 .\n  eq B1 /\\ tt = B1 .\n  eq ff /\\ B1 = ff .\n  eq B1 /\\ ff = ff .\n  eq B1 /\\ B1 = B1 .\n  eq B1 /\\ B2 = B2 /\\ B1 .\n  \n  eq tt \\/ B1 = tt .\n  eq B1 \\/ tt = tt .\n  eq ff \\/ B1 = B1 .\n  eq B1 \\/ ff = B1 .\n  eq B1 \\/ B1 = B1 .\n  eq B1 \\/ B2 = B2 \\/ B1 .\n\n  eq ~ tt = ff .\n  eq ~ ff = tt .\nendm\n\nmod NAT-FVP is\n  sorts Nat NzNat Zero .\n  subsorts Zero < Nat .\n  \n  ops 0 : -> Zero .\n  ops s : Nat -> NzNat .\n  ops _+_ pred : Nat NzNat -> Nat .\n  \n  vars N1 N2 : Nat .\n  \n  eq 0 + N1 = N1 .\n  eq N1 + 0 = N1 .\n  eq s(N1) + N2 = s(N1 + N2) .\n\n  eq pred(0) = 0 .\n  eq pred(s(N1)) = N1 .\nendm\n\nmod NAT-ACU is\n  including NAT-FVP .\n\n  ops _/_ gcd : Nat NzNat -> Nat .\n\n  vars N1 N2 : Nat .\n  \n  eq N1 / s(N2) = N1 .\n  eq gcd(N1, N2) = 1 .\nendm\n\nmod INT-FVP is\n  sorts Int .\n  subsorts Zero NzNat < Int .\n  \n  ops neg : Int -> Int .\n  ops _+_ : Int Int -> Int .\n\n  vars I1 I2 : Int .\n  \n  eq I1 + I2 = I1 + I2 .\n  eq neg(0) = 0 .\n  eq neg(s(I1)) = s(neg(I1)) .\nendm\n\nmod INT-ACU is\n  including INT-FVP .\n\n  ops _*_ gcd : Int Int -> Int .\n\n  vars I1 I2 : Int .\n\n  eq I1 * I2 = I2 * I1 .\n  eq gcd(I1, I2) = 1 .\nendm\n\nmod RAT-ACU is\n  sorts Rat .\n  ops _/_ _*_ : Rat Rat -> Rat .\n  \n  vars R1 R2 : Rat .\n\n  eq R1 * R2 = R2 * R1 .\n  eq R1 / R2 = R1 / R2 .\nendm"]], "MAUDE-1/redBlackNGA_April2023.maude": [[true, "mod FOO1 is\n  including SET.\n  \n  sorts Nat Set .\n  subsorts Nat < Set .\n  \n  vars N M : Nat .\n  var S : Set .\n\n  ops f : Set Set -> Set [assoc comm] .\n  ops g : Nat -> Set .\n  ops h : Set -> Set .\n  \n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n  \n  ceq h(f(N, S, i(M))) = 0 if N > 0 .\nendm\n\nmod FOO2 is\n  including SET.\n  \n  sorts Nat Set .\n  subsorts Nat < Set .\n  \n  vars N M : Nat .\n  var S : Set .\n\n  ops f : Set Set -> Set [assoc comm] .\n  ops g : Nat -> Set .\n  ops h : Set -> Set .\n\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n  \n  ceq h(f(N, S, i(M))) = M if N > 0 .\nendm\n\nred h(g(7)) .\nred h(g(8)) ."]], "MAUDE-1/redBlackNonLinearApril2023.maude": [[true, "set show timing off .\n***\n***    Test that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod RED-BLACK-ACU is\n  pr NAT .\n  sort Set .\n  subsort Nat < Set .\n\n  vars N : Nat .\n  var S : Set .\n\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(6))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) ."]], "MAUDE-1/abstract-bakeryAC-checks.maude": [[true, "mod NAT is\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  op _+_ : Nat Nat -> Nat [comm assoc id: 0] .\n  op _<_ : Nat Nat -> Bool .\n  var N M : Nat .\n\n  eq 0 + N = N .\n  eq s(N) + M = s(N + M) .\n  eq 0 < s(N) = true .\n  eq s(N) < 0 = false .\n  eq s(N) < s(M) = N < M .\nendm\n\nmod BAKERY is\n  protecting NAT .\n  sorts State Proc .\n  ops sleep wait crit : -> State .\n  op <_ , _> : Nat State -> Proc .\n\n  vars C1 C2 : Nat .\n  vars P Q : Proc .\n  vars S1 S2 : State .\n\n  rl [start] : < C1, sleep > => < s(C1), wait > .\n  crl [enter] : < C1, wait > < C2, wait >\n                => < C1, crit > < C2, wait >\n                if C1 < C2 or (C1 == C2 and P == Q) .\n  rl [exit] : < C1, crit > => < 0, sleep > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  subsort State < Aspect .\n  op InCrit : Proc -> Aspect .\n  pred InCrit(< C, crit >) .\n\n  pred MutualExclusion(P, Q) if not InCrit(P) or not InCrit(Q) .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n  \n  eq (C1 == C2 and InCrit(< C1, wait >) and InCrit(< C2, crit >)) = false .\n  eq InCrit(< 0, S >) = false .\n  eq InCrit(< C, sleep >) = false .\nendm"]], "MAUDE-1/redBlackTooFewSubjectsApril2023.maude": [[true, "mod RED-BLACK-ACU-STRIPPER-COLLECTOR is\n  protecting NAT .\n\n  *** Sorts and subsorts\n  sort Set .\n  subsort Nat < Set .\n\n  *** Operators\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  op h : Set -> Set .\n\n  *** Equations for the operator `g`\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\n  *** Conditional equations for the operator `h`\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, 0, N, S)) = 0 if N > 0 .\n\nendm\n\n*** Execution example\nred h(f(g(7), 0)) ."]], "MAUDE-1/renamingInstantiationMarch2023.maude": [[true, "-- Maude-NPA Formal Analysis Code for Parameterized Constants and Renamings Protocol\n\nmod FOO{X :: TRIV} is\n  --- Defining a parameterized sort Foo{X}\n  sort Foo{X} .\n\n  --- Operation f{X} returns an instance of Foo{X} with no arguments\n  op f{X} : -> Foo{X} .\nendm\n\nmod BAR{X :: TRIV} is\n  --- Importing module FOO{X}\n  including FOO{X} .\n\n  --- Renaming operation f{X} to g\n  op g : -> Foo{X} .\n  \n  --- Equation showing g is equivalent to itself (identity relation)\n  eq g = f{X} .\nendm\n\nmod TEST is\n  --- Instantiating BAR with X as Nat\n  including BAR{Nat} .\n\n  --- Simple operations and tests can be added here to verify functionalities\nendm"]], "MAUDE-1/rent-a-car-store.maude": [[true, "mod CAR-RENTAL-STORE is\n  --- Sort definitions\n  sorts Customer Car Rental Calendar Thing Bool Date Cash Debt Rate Suspended Status.\n\n  --- Subsorts\n  subsort Thing < Customer Car Rental Calendar.\n  \n  --- Constants\n  ops C1 C2 : -> Customer .\n  ops EconomyCar MidSizeCar FullSizeCar : -> Car .\n  ops false true : -> Bool .\n  \n  --- Attributes\n  ops cash debt : Customer -> Cash .\n  ops suspended : Customer -> Suspended .\n  ops available : Car -> Bool .\n  ops rate : Car -> Rate .\n  ops deposit : Rental -> Cash .\n  ops dueDate pickUpDate : Rental -> Date .\n  ops customer : Rental -> Customer .\n  ops car : Rental -> Car .\n  ops date : Calendar -> Date .\n\n  --- Initial Configuration\n  eq cash(C1) = 5000 .\n  eq cash(C2) = 5000 .\n  eq debt(C1) = 0 .\n  eq debt(C2) = 0 .\n  eq suspended(C1) = false .\n  eq suspended(C2) = false .\n  \n  --- Car's Availability and Rate\n  eq available(EconomyCar) = true .\n  eq available(MidSizeCar) = true .\n  eq available(FullSizeCar) = true .\n  eq rate(EconomyCar) = 100 .\n  eq rate(MidSizeCar) = 200 .\n  eq rate(FullSizeCar) = 300 .\n  \n  --- Calendar\n  eq date(Calendar) = 0 .\n\n  --- New Day Rule\n  rl [new-day] : Calendar => Calendar with date(date(Calendar) + 1) .\n\n  --- Car Rental Rule\n  rl [rent-car] :\n    (C:Customer, Car, Calendar, R:Rental) =>\n    (\n      C:Customer with cash(cash(C:Customer) - (rate(Car) * (dueDate(R:Rental) - pickUpDate(R:Rental)))),\n      Car with available(false),\n      R:Rental with customer(C:Customer), car(Car), deposit(rate(Car)), dueDate(date(Calendar) + 1)\n      if not suspended(C:Customer) and available(Car) and cash(C:Customer) >= rate(Car)\n    ) .\n\n  --- On-Date Car Return Rule\n  rl [return-car-on-time] : \n    (C:Customer, Car, R:Rental) =>\n    (\n      C:Customer with cash(cash(C:Customer) + deposit(R:Rental)),\n      Car with available(true)\n      if customer(R:Rental) == C:Customer and car(R:Rental) == Car and dueDate(R:Rental) >= date(Calendar)\n    ) .\n\n  --- Late Car Return Rule\n  rl [return-car-late] :\n    (C:Customer, Car, R:Rental) =>\n    (\n      C:Customer with debt(debt(C:Customer) + (date(Calendar) - dueDate(R:Rental)) * rate(Car)),\n      C:Customer with suspended(true),\n      Car with available(true)\n      if customer(R:Rental) == C:Customer and car(R:Rental) == Car and dueDate(R:Rental) < date(Calendar)\n    ) .\n\n  --- Pay Debt Rule\n  rl [pay-debt] :\n    (C:Customer, Calendar) =>\n    (\n      C:Customer with cash(cash(C:Customer) - debt(C:Customer)),\n      C:Customer with debt(0),\n      C:Customer with suspended(false),\n      Calendar\n      if cash(C:Customer) >= debt(C:Customer)\n    ) .\n\n  --- Suspend Late Payers Rule\n  crl [suspend-late-payers] :\n    (C:Customer) =>\n    (C:Customer with suspended(true))\n    if debt(C:Customer) > 0 .\n\n  --- Suspend Late Returns Rule\n  crl [suspend-late-returns] :\n    (C:Customer, R:Rental) =>\n    (C:Customer with suspended(true))\n    if customer(R:Rental) == C:Customer and dueDate(R:Rental) < date(Calendar) .\n\nendm"]], "MAUDE-1/showModuleJune2018.maude": [[true, "(fmod PROTOCOL-MODULE is\n  protecting STRING .\n\n  sorts User Interpreter State Module Action Transition Bool .\n\n  subsort String < User .\n\n  ops FOO BAR : -> Module .\n  op none : -> Interpreter .\n\n  ops a b : -> Foo .\n\n  vars Z Y X : User .\n\n  ops state1 state2 state3 state4 : -> State .\n\n  op createInterpreter : User User Interpreter -> Action .\n  op insertModule : User User Module -> Action .\n  op showModule : User User Module Bool -> Action .\n\n  ops transition : State Action -> State .\n\n  eq transition(state1, createInterpreter(interpreterManager, ME, none)) = state2 [nonexec] .\n  eq transition(state2, insertModule(Z, X, FOO)) = state3 .\n  eq transition(state3, insertModule(Y, X, BAR)) = state4 .\n  eq transition(state4, showModule(Y, X, BAR, false)) = state4 .\n  \n  rl [create-interpreter] : < ME : User | state : state1 > =>\n                           < ME : User | state : state2 >\n                           createInterpreter(interpreterManager, ME, none) .\n\n  rl [insert-FOO] : < ME : User | state : state2 > =>\n                   < ME : User | state : state3 >\n                   insertModule(Z, ME, FOO) .\n\n  rl [insert-BAR] : < ME : User | state : state3 > =>\n                   < ME : User | state : state4 >\n                   insertModule(Y, ME, BAR) .\n\n  rl [show-info] : < ME : User | state : state4 > =>\n                  < ME : User | state : state4 >\n                  showModule(Y, ME, BAR, false) .\n\nendfm)"]], "MAUDE-1/smodStrategyNameJanuary2023.maude": [[true, "*** Test for bad strategy name in advisory. ***\n\nsth T is\n  sorts Prop State .\n  strat expand : Prop @ State .\nendsth\n\nsmod M{X :: T} is\nendsm\n\nsmod TEST{X :: T} is\n  inc M{X} * (strat expand : Prop @ State to expand') .\nendsm"]], "MAUDE-1/sortCollapseMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n*** \n***    Test for bug that we weren't warning about a collapse \n***    up the sort hierarchy for declarations at the kind level.\n***\n\nfmod FOO is\n  sort Foo .\n  op f : Foo [Foo] -> Foo [id: e] .\n  op e : -> Foo .\nendfm\n\nparse f(e, X:[Foo]) .\nred f(e, X:[Foo]) ."]], "MAUDE-1/specificOpMappingPrintFebruary2023.maude": [[true, "mod FOO is\n  sorts Foo Bar .\n  op f : Foo -> Bar .\nendm"]], "MAUDE-1/staleViewJune2018.maude": [[true, "---\nmod SYSTEM is\n  --- sorts ---\n  sort Bool .\n  \n  --- operations ---\n  op true : -> Bool .\n  op false : -> Bool .\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\n  \n  --- axioms ---\n  eq (false + false) = false .\n  eq (false + true) = true .\n  eq (true + false) = true .\n  eq (true + true) = true .\n  \n  eq p(false) = true .\n  eq p(true) = false .\n  \nendm\n\n---\nmod ORDER is\n  --- sorts ---\n  sort Elt .\n  \n  --- operations ---\n  op _<_: Elt Elt -> Bool .\n  \nendm\n\n---\nview V from ORDER to SYSTEM is\n  --- sorts mapping ---\n  sort Elt to Bool .\n  \n  --- operations mapping ---\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\n---\nmod META-LEVEL-CHECK is\n  inc SYSTEM .\n  inc ORDER .\n  inc META-LEVEL .\n  \n  --- meta-level operation ---\n  op upView: View -> Bool .\n  \nendm\n\n--- Enabling meta-level checks for views and operations ---\nred in META-LEVEL-CHECK : upView('V) ."]], "MAUDE-1/stringToRatConversionMarch2024.maude": [[true, "mod RATIONAL-CONVERSION-TEST is\n    ------------------------------\n    *** Rational Number Conversion Test ***\n    ------------------------------\n\n    *** FIX: Define types for rational numbers and conversions ***\n    sorts Rational String .\n    ops rat : String -> Rational .\n    \n    *** Select the conversion module ***\n    select CONVERSION .\n\n    *** Test Cases ***\n    var S : String .\n\n    eq rat(\"-0\") = -0 .\n    eq rat(\"0/1\") = 0 .\n    eq rat(\"-0/1\") = -0 .\n\n    *** Verification ***\n    --- Test Case 1: Negative Zero ---\n    mb rat(\"-0\") == -0 .\n    --- Test Case 2: Zero Fraction ---\n    mb rat(\"0/1\") == 0 .\n    --- Test Case 3: Negative Fraction ---\n    mb rat(\"-0/1\") == -0 .\nendm"]], "MAUDE-1/stripperCollectorSwitchMay2023.maude": [[true, "mod EXAMPLE-PROTOCOL is\n\n  protecting NAT .\n  \n  *** Sort declarations\n  sort Set Elt .\n  \n  *** Subsort declarations\n  subsort Elt < Set .\n  \n  *** Variable declarations\n  var S : Set .\n  var N : Nat .\n  var E : Elt .\n  \n  *** Operator declarations\n  op dummy : Set -> Set .\n  op z : -> Elt .\n  op p_ : Elt -> Elt .\n  op g : Nat Set -> Set .\n  op f : Set Set -> Set [assoc comm] .\n  op h : Elt -> Bool .\n  \n  *** Equation: defining 'g'\n  eq g(0, E) = E .\n  eq g(s N, E) = f(g(N, E), E) .\n  \n  *** Conditional equation: defining 'h'\n  ceq h(g(N, S)) = true if S == z .\n  \nendm\n\n*** Example reductions\nreduce h(g(7, z)) .\nreduce h(g(8, z)) .\nreduce h(g(20, z)) ."]], "MAUDE-1/ACU_MissingUnifiersMay2020.maude": [[true, "mod ADDITION-NATURAL-NUMBERS is\n  --- Declaring sorts for natural numbers\n  sort Zero NzNat Nat .\n\n  --- Defining subsorts: Zero and NzNat are subsorts of Nat\n  subsort Zero NzNat < Nat .\n\n  --- Declaring operations\n  op _+_ : Nat NzNat -> NzNat [assoc comm id: 0] .  --- Addition operation with an identity element\n  op _+_ : Nat Nat -> Nat [assoc comm] .           --- Addition operation for general natural numbers\n\n  --- Declaring the constant zero\n  op 0 : -> Zero .                                --- Representation of zero\n\n  --- Declaring function g\n  op g : Zero -> Nat .                            --- Function demonstrating relation between Zero and Nat\n\n  --- Example of a unification test case\n  var M : Nat .\n  var N : Nat .\n  var Z : Zero .\n\n  --- Test unification: N == g(M + Z)\n  eq N = g(M + Z) .\n\nendm\n\n--- Initial goal state for Maude-NPA unification test\nred in ADDITION-NATURAL-NUMBERS : N == g(M + 0) ."]], "MAUDE-1/uninitIterExtSeptember2021.maude": [[true, "fmod UNINITIALIZED-BUG is\n  protecting NAT .\n\n  *** Declare the operators and variables\n  sort Term .\n\n  var N : Nat .\n  var M : Nat .\n\n  op s : Nat -> Term .\n\n  rl [rwc] : s(N) => s(M) [nonexec] .\n\nendfm\n\n--- Execution Command for Maude-NPA Analysis\nred srew 3 in UNINITIALIZED-BUG using rwc{idle} ."]], "MAUDE-1/upTheoryJanuary2023.maude": [[true, "set show timing off .\nset show advisories off .\n\n*** Test for automatic imports being included in upModule() of theories. ***\n\nfth FOO is\n  sort Foo .\nendfth\n\nshow desugared FOO .\n\nred in META-LEVEL : upModule('FOO, false) ."]], "MAUDE-1/variantUnifyJune2020.maude": [[true, "mod A-UNIF is\n  sorts List Elt .\n\n  ops f j : List List -> List .\n  ops 1 : -> List .\n\n  vars A B C D G H I S U V W X Y Z : List .\n  var E : Elt .\n\n  equations\n    assoc f .\n    assoc comm idem j .\n    eq j(A, f(B, E, C), f(D, E, j(G, H), I)) =? j(U, f(V, W), f(X, j(Y, Z), S)) .\n\nendm"]], "MAUDE-1/renaming.maude": [[true, "--- Maude Code for Protocol Analysis ---\n\n--- 1. Module FOO\nmod FOO is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\nendm\n\n--- 2. Module BAR\nmod BAR is\n  including FOO .\n  sorts Baz Quux .\nendm\n\n--- 3. Module ONE\nmod ONE is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\nendm\n\n--- 4. Module TWO\nmod TWO is\n  including ONE .\n  sorts Baz Quux .\nendm\n\n--- 5. Module THREE\nmod THREE is\n  including TWO .\n  sorts Jaz .\n  subsorts Jaz < Baz .\nendm\n\n--- 6. Module FOO (with operations)\nmod FOO with operations is\n  sorts Foo .\n  op a : -> Foo .\nendm\n\n--- 7. Module BAR (with operations)\nmod BAR with operations is\n  including FOO with operations .\n  op b : -> Foo .\n  --- Operation b replaces operation a, thus a is excluded\nendm\n\n--- 8. Module FOO' (with enhanced operations)\nmod FOO' with enhanced operations is\n  sorts Baz Foo .\n  ops a : -> Baz .\n  ops _+_ : Foo Foo -> Foo [assoc comm id: a] .\n  ops _+_ : Baz Baz -> Baz [assoc comm id: a] .\nendm\n\n--- 9. Module BAR' (with new operations)\nmod BAR' with new operations is\n  including FOO' with enhanced operations .\n  --- Redefine addition operation with precedence handling\nendm\n\n--- 10. Module BAR'' (with modified operations)\nmod BAR'' with modified operations is\n  including FOO' with enhanced operations .\n  --- Redefine the addition operation differently\nendm\n\n--- 11. Module DIFF\nmod DIFF is\n  sorts Foo Bar .\n  op f : Foo -> Foo .\n  op f : Bar -> Bar .\nendm\n\n--- 12. Module BASH\nmod BASH is\n  including DIFF .\n  subsorts Foo < Bar .\nendm\n\n--- 13. Module TEST\nmod TEST is\n  including BASH .\n  op g : Foo -> Foo .\n  --- Operation g replaces function f\nendm\n\n--- Execution Commands\nshow mod .\nshow all .\nred a ."]], "MAUDE-1/Carlsen_Secret_Key_Initiator.maude": [[true, "mod CARLSEN-SK-INITIATOR-PROTOCOL is\n\n  *** Sorts ***\n  sorts Msg User Nonce Key EncMsg;\n\n  *** Operators ***\n  op Alice Bob Server : -> User [ctor] .\n  op MKey : User -> Key [ctor] .\n  op SK : User User -> Key [ctor] .\n  op n : User Nat -> Nonce [ctor] .\n  op enc : EncMsg Key -> Msg [ctor] .\n  op dec : Msg Key -> EncMsg [ctor] .\n  vars A B S : User .\n  vars NA NB : Nonce .\n  vars MKA MKB : Key .\n  vars SKAB SKBS : Key .\n  vars P : Placeholder .\n\n  *** Protocol Steps ***\n  *** Step 1: Alice generates N and encrypts SK and N using her master key ***\n  rl [A -> B] :\n    enc(NA SKAB(A B) B, MKey(A)) => enc(NA SKAB(A B), MKey(B)) .\n\n  *** Step 2: Bob decrypts the message using his master key ***\n  rl [B receives] :\n    enc(NA SKAB(A B), MKey(B)) => dec(enc(NA), SKAB(A B)) .\n\n  *** Step 3: Bob sends response with his nonce & session key using his master key ***\n  rl [B -> A] :\n    dec(enc(NA), SKAB(A B)) => enc(NB SKBS(B A) A, MKey(B)) .\n\n  *** Step 4: Alice decrypts Bob's response using session key ***\n  rl [A receives] :\n    enc(NB SKBS(B A) A, MKey(B)) => dec(enc(NB), SKBS(B A)) .\n\n  *** Server facilitates key distribution ***\n  rl [Server's Role] :\n    P => P .\n\n  *** Security Goals ***\n  rl [Confidentiality] :\n    enc(Msg, Key) => enc(Msg, Key) .\n\n  rl [Integrity] :\n    Msg => Msg .\n\n  rl [Authentication] :\n    User => User .\n\nendm"]], "MAUDE-1/ltv-F-tmn.maude": [[true, "mod LTV09-ProtocolF is\n  --- Sorts ---\n  sort Message Principal Key Encrypted.\n\n  --- Operations ---\n  op alice : -> Principal .\n  op bob : -> Principal .\n  op server : -> Principal .\n  op intruder : -> Principal .\n  \n  op ka : -> Key .\n  op kb : -> Key .\n  op pkS : -> Key .\n  op ki : -> Key . --- Intruder's key\n  \n  op encrypt : Key Message -> Encrypted .\n  op xor : Key Key -> Key . --- XOR operation\n  \n  op b : -> Message . --- Bob's identity\n  op a : -> Message . --- Alice's identity\n  \n  --- Message strands ---\n  vardec M Message .\n  vardec K Key .\n  \n  --- Alice's strand ---\n  strand alice-strand is\n    (, , b, encrypt(pkS, ka)) ;\n    (, a, , ) .\n  \n  --- Bob's strand ---\n  strand bob-strand is\n    (, , a, encrypt(pkS, kb)) ;\n    (, b, xor(kb, ka), ) .\n  \n  --- Server's strand ---\n  strand server-strand is\n    (, b, encrypt(pkS, ka) , ) ;\n    (, , a, ) ;\n    (, a, encrypt(pkS, kb), ) ;\n    (, b, xor(kb, ka) , ) .\n  \n  --- Intruder's strand ---\n  strand intruder-strand is\n    (, b, encrypt(pkS, ka)) ; --- Intercept message from Alice to Server\n    (, , a, ) ; --- Server reveals Alice's identity to Intruder\n    (, a, encrypt(pkS, ki)) ; --- Intruder as Bob sends message with own symmetric key\n    (, b, xor(ki, ka), ) . --- Server reveals the response\n  \n  --- Knowledge and rules ---\n  var A B : Principal .\n  var KA KB KI : Key .\n  var PKS : Key .\n\n  --- Intruder knows all public keys and identities ---\n  intruder-knowledge : crypt(pkS) .\n  intruder-knowledge : crypt(b) .\n  intruder-knowledge : crypt(a) .\n\n  --- Decryption and attack ---\n  op decrypt : Encrypted Key -> Message .\n  eq decrypt(encrypt(K, M), K) = M .\n\n  attack-trace : decrypt(encrypt(pkS, ka), pkS) = ka, decrypt(xor(ki, ka), ki) = ka .\nendm"]], "MAUDE-1/ltv-F-tmn2-asy.maude": [[true, "fmod LTV09-PROTOCOL-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n  subsort Null < Msg .\n\n  op pair : Msg Msg -> Msg [frozen] .\n  op enc : Msg -> Msg [frozen] .\n  \n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op s : -> Name . --- Server\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod LTV09-PROTOCOL-ALGEBRAIC is\n  protecting LTV09-PROTOCOL-SYMBOLS .\n  \n  --- Exclusive or properties\n  eq null * X:Msg = X:Msg [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq X:Msg * X:Msg = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\nendfm\n\nfmod LTV09-PROTOCOL-SPECIFICATION is\n  protecting LTV09-PROTOCOL-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  vars X Y : Msg .\n  vars r r' : Fresh .\n  vars N N' NA NB : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-PROTOCOL\n  = *** Alice's strand\n    new r \n    [ nil | +(pair(B, enc(KA)), -(pair(B, n(A,r) * NB)), nil ] \n    &\n    *** Server's strand\n    [ nil | -(pair(B, enc(NA))), +(A), -(pair(A, enc(NB))), +(pair(B, KB * KA)), nil ] \n    &\n    *** Bob's strand\n    new r'\n    [ nil | -(A), +(pair(A, enc(KB)), nil ] \n    \n    [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    *** Alice sends initial message to Server\n    new r \n    [ nil |  +(pair(b, enc(KA)), -(pair(b, n(a,r) * NB)) | nil ]\n    || n(a,r) inI, empty\n    || *** Intruder intercepts and sends false message\n    nil\n    || *** Intruder waits for response containing xor of keys\n    nil\n    || *** Final state expected\n    nil\n\n  [nonexec] .\n\nendfm\n\n--- THIS MUST BE THE LAST LOADED MODULE\nselect MAUDE-NPA ."]], "MAUDE-1/dh.maude": [[true, "mod PROTOCOL is\n\n  *** Sorts for protocol entities ***\n  sorts Principal Nonce Key Generator Message .\n\n  *** Operators for protocol participants ***\n  op A : -> Principal .\n  op B : -> Principal .\n  op I : -> Principal .\n\n  *** Operators for nonces and keys ***\n  op N_A : -> Nonce .\n  op N_B : -> Nonce .\n  op secret : Principal Principal -> Key .\n\n  *** Operators for cryptographic functions ***\n  op exp : Generator Nonce -> Message .\n  op enc : Message Key -> Message .\n  \n  *** Operators for messages ***\n  op m1 : Principal Principal Message -> Message .\n  op m2 : Principal Principal Message -> Message .\n  op m3 : Message Key -> Message .\n\n  vars X Y : Generator .\n  vars Z : Nonce .\n  vars M : Message .\n  vars K : Key .\n  vars P Q : Principal .\n  \n  *** Message definitions ***\n  eq m1(A, B, exp(g, N_A)) = A ; B ; exp(g, N_A) .\n  eq m2(B, A, exp(g, N_A)) = A ; B ; exp(g, N_A) .\n  eq m3(exp(exp(g, N_B), N_A), secret(A, B)) = enc(exp(exp(g, N_B), N_A), secret(A, B)) .\n\n  *** Algebraic properties ***\n  eq exp(exp(X, Y), Z) = exp(X, Y * Z) .\n  eq enc(d(K, M), K) = M .\n  eq d(enc(M, K), K) = M .\n\nendm"]], "MAUDE-1/esorics12-asy.maude": [[true, "mod EXAMPLE-PROTOCOL is\n  protecting STRING .\n  including NAT .\n\n  *** sorts for protocol principals and nonces\n  sorts Name Nonce NNSet Msg Null .\n\n  *** principal identities\n  ops Alice Bob Intruder : -> Name .\n\n  *** nonce operation and its set representation\n  op n : Name Fresh -> Nonce .\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n\n  *** public and private key operations\n  op pk : Name Msg -> Msg .\n  op sk : Name Msg -> Msg .\n\n  *** null value\n  op null : -> NNSet .\n\n  *** Attacker model: Dolev-Yao\n  vars M N : Msg .\n  var X : NNSet .\n  vars Na Nb : Nonce .\n  var P : Name .\n\n  *** protocol rules specifying strands\n\n  rl [AliceStrand] :\n    receive(pk(Alice, Na))\n      . send(pk(Bob, Na *_ Nb)) .\n\n  rl [BobStrand] :\n    receive(pk(Bob, Nb))\n      . send(pk(Alice, Nb *_ Na)) .\n\n  *** Intruder's capability to decrypt messages using known private keys\n  rl [IntruderDecrypt] :\n    receive(sk(Intruder, pk(P, M)))\n      . send(M) .\n\n  rl [IntruderCombineNonce] :\n    receive(Na)\n      . send(Na *_ Nb) .\n\n  *** Attack state to represent intruder's behavior and potential attacks\n\n  op attackState : NNSet -> Msg .\n  rl [AttemptReplay] :\n    receive(pk(Alice, Na *_ Nb))\n      . send(attackState(Na *_ Nb)) .\n\nendm\n\n--- Test environment for Maude-NPA\nmod TEST-ENVIRONMENT is\n  including EXAMPLE-PROTOCOL .\n\n  *** initial intruder knowledge\n  vars InitKnowledge : NNSet .\n\n  op initKnowledge : -> NNSet .\n  eq initKnowledge = Na *_ Nb .\n\n  *** Specification of attack state for analysis\n  op initialAttackState : -> attackState .\n  eq initialAttackState = attackState(Na *_ Nb) .\n\nendm\n\n--- Additional analysis settings and configurations required by Maude-NPA should be placed here, including search commands or reachability queries."]], "MAUDE-1/esorics12-variant.maude": [[true, "load npa.maude\n\nmod EXAMPLE-PROTOCOL is\n  including CRYPTO-MODEL .\n\n  *** Sorts\n  sort Name Nonce NNSet Null .\n\n  *** Operators\n  ops A B i : -> Name [ctor] .  \n  op pk : Name Message -> Message .\n  op sk : Name Message -> Message .\n  op n : -> Nonce [ctor] .\n  op xor : NNSet NNSet -> NNSet [assoc comm] .\n  op null : -> Null [ctor] .\n\n  *** Messages\n  subsort Null < NNSet .\n  ops m1 m2 m3 : -> Message [ctor] .\n\n  *** Actions\n  vars N N1 N2 : Nonce .\n  vars X X1 X2 : NNSet .\n  op msg1 : Name Nonce -> Message .\n  op msg2 : Name Nonce NNSet -> Message .\n  op msg3 : Name -> Message .\n\n  *** XOR properties\n  eq xor(X, null) = X .\n  eq xor(X, X) = null .\n\n  *** Intruder knowledge\n  vars P : Name .\n  eq pk(i, msg1(P, N)) = msg1(P, N) .\n  eq sk(i, pk(P, M)) = M .\n\n  *** Protocol strands\n  *** Alice strand - initiation\n  vars Y : Message .\n  strand alice-init(P : Name, N : Nonce) :=\n    < + { msg1(i, N) }\n      - { msg1(P, sk(P, pk(P, N))) } > .\n\n  *** Bob strand - response\n  strand bob-response(P : Name, N : Nonce, X : NNSet) :=\n    < + { msg2(P, N, xor(n, X)) }\n      - { msg3(B) } > .\n\n  *** Intruder strand - attack scenario\n  vars Z : Message .\n  strand intruder-attack(P : Name, M : Message) :=\n    < + { M }\n      - { msg1(B, xor(n, sk(P, pk(i, M)))) } > .\n\nendm"]], "MAUDE-1/ACU_TreeVariableSubproblem.maude": [[true, "mod ACU_TREE_VARIABLE_SUBPROBLEM is\n    protecting NAT .\n\n    sort Set .\n    subsort Nat < Set .\n\n    op f : Set Set -> Set [assoc comm] .\n    op g : Nat -> Set .\n    op h : Set Set -> Set .\n\n    var N : Nat .\n    var M : Nat .\n    var T : Set .\n    var S : Set .\n\n    --- The definitions below assume certain equivalence conditions for the operation `h`,\n    --- based on the conditions described in the protocol description.\n\n    --- Bound Collector Case\n    eq h(N > 10 ? g(N), T) = f(M) .\n    eq h(N < 2 ? g(N), T) = f(M) .\n    eq h(N == 5 ? g(N), T) = f(M) .\n\n    --- Bound Stripper Case\n    eq h(S, N > 10 ? g(N)) = f(S, T) .\n    eq h(S, N < 2 ? g(N)) = f(S, T) .\n    eq h(S, N == 5 ? g(N)) = f(S, T) .\n\n    --- Both Bound Case\n    eq h(N > 10 ? g(N), S) = f(S) .\n    eq h(N < 2 ? g(N), S) = f(S) .\n    eq h(N == 5 ? g(N), S) = f(S) .\n\n    --- Example Reductions\n    --- The following reductions demonstrate the handling of multiplicity and equivalence conditions:\n    --- Uncomment the lines below to evaluate the reductions in the Maude environment. \n\n    --- red h(g(11), g(11)) .\n    --- red h(f(g(11), g(9)), f(g(11), g(9))) .\n\nendm"]], "MAUDE-1/homo-hpc.maude": [[true, "mod SECURE_COMPUTATION is\n  inc BOOL .\n  inc STRING .\n  inc NAT .\n  inc SET{STRING} . --- for names\n  inc INTEGER . --- for nonces\n  inc MAP{STRING, STRING} . --- for keys\n\n  sorts Agent Data Key Msg Nonce .\n  subsort Nonce < Data .\n\n  --- Agents\n  ops A B s i : -> Agent . --- Alice, Bob, Server, Intruder\n  ops nA nB nIA : -> Nonce . --- Nonces for ensuring freshness\n\n  --- Keys\n  op pk : Agent -> Key . --- Public key\n  op sk : Agent -> Key . --- Secret key\n  op k  : Agent Agent -> Key . --- Homomorphic encryption key\n\n  --- Data\n  ops DA DB : -> Data . --- Secret data of Alice and Bob\n  op Enc : Data Key -> Data . --- Regular encryption function\n  op HEnc : Data Key -> Data . --- Homomorphic encryption function\n  op Sign : Agent Nonce Msg -> Msg . --- Signature\n\n  --- Protocol Steps\n  vars M : Msg . vars N N1 N2 : Nonce .\n\n  eq Sign(A, N, M) = (sign(A; N; M, A)) .\n  eq Sign(B, N, M) = (sign(B; N; M, B)) .\n  eq Enc(M, pk(s)) = pke(M, s) .\n  eq HEnc(D, k(A, B)) = hpke(D, k(A, B)) .\n\n  --- Initial State\n  rl [init] :\n    {A, B, s, DA, DB}\n    =>\n    {[A ; B ; sign(B; nA; Enc(HEnc(DA, k(A, B)), pk(s)), A)]}\n\n  --- Step 1: A -> B\n  rl [step1] :\n    {[A ; B ; sign(B; nA; Enc(HEnc(DA, k(A, B)), pk(s)), A)]}\n    =>\n    {[B ; A ; sign(nA; nB; Enc(HEnc(DB, k(A, B)), pk(s)), B)]}\n\n  --- Step 2: B -> A\n  rl [step2] : \n    {[B ; A ; sign(nA; nB; Enc(HEnc(DB, k(A, B)), pk(s)), B)]}\n    =>\n    {[A ; s ; Sign(A, nA, pke(HEnc(DA, k(A, B)), pk(s))) ; Sign(B, nB, pke(HEnc(DB, k(A, B)), pk(s)))]}\n\n  --- Step 3: A -> s\n  rl [step3] : \n    {[A ; s ; Sign(A; B; nA; nB; Enc(HEnc(DA, k(A, B)), pk(s))); Sign(B; nB; Enc(HEnc(DB, k(A, B)), pk(s)))]}\n    =>\n    {[s ; A ; B ; Sign(A; B; nA; nB; f(HEnc(DA, k(A, B)), HEnc(DB, k(A, B))), s)]}\n\n  --- Intruder capabilities\n  --- Assuming the intruder i can intercept and replay messages\n  op intrude : Msg -> Msg .\n  eq intrude(M) = M .\n\n  --- Example Flaw Analysis with Intermediary I_B\n  rl [flaw] :\n    {[A ; I_B ; Sign(B; nA; Enc(HEnc(DA, k(A, B)), pk(s)), A)]}\n    =>\n    {[I_B ; B ; Sign(i; nA; X; i)]}\n\nendm\n\n--- END OF SECURE_COMPUTATION"]], "MAUDE-1/homo-nsl.maude": [[true, "mod PROTOCOL is\n  pr NAT .\n  pr STRING .\n  pr CRYPTO .\n\n  ops A B : -> Principal .\n  ops Na Nb : -> Nonce .\n  \n  ops PK SK : Principal -> Key .\n\n  vars A B : Principal .\n  vars Na Nb : Nonce .\n  var M : Message .\n  var K : Key .\n\n  -- Role Alice\n  role Alice {\n    step 1.0 : M := enc(Na; A, PK(B))\n    - -> { M }\n    step 3.0 : M := {Nb}\n    - -> enc(Nb, PK(B))\n  }\n\n  -- Role Bob\n  role Bob {\n    step 2.0 : {Na; A}_SK(B) <- M\n    - -> enc(Na; Nb, B, PK(A))\n  }\n\n  -- Protocol specification\n  specification {\n    role Alice initiated by A .\n    role Bob initiated by B .\n\n    initial knowledge for Alice : A .\n    initial knowledge for Bob : B .\n    \n    trace property Na ephemeral for Alice; Nb ephemeral for Bob .\n\n    disjoint A B .\n  }\n\n  -- Security goals\n  goal MutualAuthentication ,\n  goal NoReplayAttack .\n\nendm"]], "MAUDE-1/Kao-Chow_Repeated_Authentication.maude": [[true, "---- The Kao Chow Repeated Authentication Protocol\n\nfmod KAOCHEW-PROTOCOL-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  -- Sort Information \n  sorts UName SName Name Key Nonce Masterkey Sessionkey Msg Public .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  -- Nonce operators\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  -- User names\n  ops a b : -> UName .\n\n  -- Server name\n  op s : -> SName . \n\n  -- Master key operation\n  op mkey : Name Name -> Masterkey [frozen] .\n\n  -- Session key operation\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  -- Encryption and Decryption operations\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  -- Concatenation operation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod KAOCHEW-PROTOCOL-ALGEBRAIC is\n  protecting KAOCHEW-PROTOCOL-SYMBOLS .\n\n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod KAOCHEW-PROTOCOL-SPECIFICATION is\n  protecting KAOCHEW-PROTOCOL-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B : UName .  \n  var D : Name .\n  var r r' r'' : Fresh .\n  vars NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-PROTOCOL =\n    -- Alice's Strand\n    :: r ::\n    [ nil | \n            -- Alice starts by sending her identity, Bob's identity, and her nonce\n            +(e(mkey(A,s), A ; B ; n(A,r))), \n            -- Alice expects back a message containing her nonce and session key, then Bob's nonce\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB), \n            -- Alice sends back Bob's nonce encrypted with the session key\n            +(e(SK, NB)), \n            nil ]\n    &\n    -- Bob's Strand\n    :: r ::\n    [ nil | \n            -- Bob receives Alice's message encapsulated with the info from server\n            -(MA ; e(mkey(B,s), A ; B ; NA ; SK)), \n            -- Bob sends back Alice's nonce and his own nonce encrypted with the session key\n            +(MA ; e(SK, NA) ; n(B,r)),\n            -- Bob gets Alice's response with his nonce\n            -(e(SK, n(B,r))), \n            nil ]\n    &\n    -- Server's Strand \n    :: r ::\n    [ nil | \n            -- The server receives Alice's initial message\n            -(A ; B ; NA),\n            -- The server replies back with encrypted session key messages for both Alice and Bob\n            +(e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), \n            nil ]\n  [nonexec] .\n\nendfm\n\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Handshake_Key.maude": [[true, "mod KAO-CHOW-PROTOCOL is\n  --- Sorts\n  sort Msg .\n  sort Name .\n  sort Key .\n  sort Nonce .\n\n  --- Operators\n  op alice : -> Name .                --- Alice's identity\n  op bob : -> Name .                  --- Bob's identity\n  op server : -> Name .               --- Server's identity\n\n  op mk : Name Name -> Key .          --- Master Key\n  op sk : Nonce -> Key .              --- Session Key\n\n  op n : Name Fresh -> Nonce .        --- Nonce Generation\n  op e : Key Msg -> Msg .             --- Message Encryption\n  op d : Key Msg -> Msg .             --- Message Decryption\n  \n  op _ , _ : Msg Msg -> Msg [assoc comm] .  --- Message Concatenation\n\n  --- Protocol Roles\n  ops A B S : -> Principal .          --- Alice, Bob, Server\n\n  --- Protocol Knowledge\n  vars Na Nb : Nonce .\n  vars Kma Kmb : Key .\n  vars MsgA MsgB : Msg .\n  \n  --- Initial Knowledge of Participants\n  eq init(A) = alice , bob , server , mk(alice, server) , mk(bob, server) .\n  eq init(B) = bob , alice , server , mk(bob, server) .\n  eq init(S) = server , alice , bob .\n\n  --- Alice's Strand\n  rl [Alice1] : alice , bob , Na => alice , bob , e(mk(alice, server), sk(Na)) .\n  rl [Alice2] : MsgA , e(Kmb, sk(Na)) => MsgA , e(mk(bob, server), Nb) .\n\n  --- Bob's Strand\n  rl [Bob1] : MsgA , e(Kma, sk(Nb)) => MsgA , e(mk(alice, server), sk(Nb)) .\n\n  --- Server's Strand\n  rl [Server1] : alice , bob , Na => e(mk(alice, server), sk(Na)) , e(mk(bob, server), sk(Na)) .\n\n  --- Encrypt-Decrypt Axioms\n  eq d(K:Key, e(K:Key, M:Msg)) = M:Msg .\n\n  --- Goal: Security Properties\n  --- Goals such as confidentiality and authenticity can be expressed here\n\nendm"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Ticket.maude": [[true, "fmod KA0-CHOW-PROTOCOL is\n  including NATURAL-NUMBER .\n\n  sorts User Server Nonce Key Msg .\n  subsort User Server < Msg .\n\n  ops A B : -> User [ctor] .\n  ops s : -> Server .\n\n  op n : User Nat -> Nonce [ctor] .\n  op mkey : Msg Msg -> Key [ctor] .\n  op seskey : Msg Msg Nonce -> Key [ctor] .\n\n  ops Na Nb Kt Kab : -> Nonce [ctor] .\n\n  ops < _ , _ > : Msg Msg -> Msg [ctor] .\n  op e : Key Msg -> Msg [ctor] .\n  op d : Key Msg -> Msg [ctor] .\n\n  vars U V : User .\n  vars N X : Msg .\n  vars K : Key .\n  vars R : Nat .\n\n  --- Initial knowledge of the intruder\n  ops a s b : -> Name .\n  op ik : -> Msg .\n  var M : Msg .\n\n  --- *** Protocol Steps ***\n\n  --- Step 1: Alice \u2192 Server : {A, B, Na}k(A,s)\n  rl [s1] : < A ; s ; e(mkey(A, s), < A , B , n(A, R) >) > \n\n  --- Step 2: Server \u2192 Alice, Bob : {Na, Kab, {A, B, Kab, Kt}k(A,B)}k(s,B)\n  rl [s2] : < s ; A ; e(mkey(s, B), < Na , seskey(A, B, Kab) , e(mkey(A, B), < A , B , seskey(A, B, Kab) , Kt >) >) > \n\n  --- Step 3: Bob \u2192 Alice : {A, Kab, Nb}k(A,B)\n  rl [s3] : < B ; A ; e(mkey(A, B), < A , seskey(A, B, Kab) , n(B, R) >) > \n\n  --- Step 4: Verification and usage of session keys for secure communication\n\n  --- *** Intruder Model ***\n\n  rl [i-know1] : ik => M .\n  \n  *** Additional intruder capabilities can be added here ***\n\nendfm"]], "MAUDE-1/mpOTR_connect.maude": [[false, "```\nmod MPOTR-SETUP is\n  pr CRYPTO-ALGEBRA .   --- Import necessary cryptographic and protocol mechanisms\n  \n  --- Define sorts for Clients and Messages\n  sorts Client Msg FixedMessage .\n  \n  --- Define the fixed message content as constant\n  op fxMess : -> FixedMessage .\n  \n  --- Define client identifiers as constants\n  ops client1 client2 client3 : -> Client .\n  \n  --- Define constructor for message concatenation\n  op _;_ : Client FixedMessage -> Msg [ctor] .\n  \n  --- Define initial knowledge for each client\n  ops know1 know2 know3 : -> Knowledge .\n  \n  --- Intruder knowledge setup; initially nothing\n  var I : Knowledge .  --- Intruder's knowledge\n  \n  --- Knowledge initial state for clients\n  eq know1 = {client1 ; fxMess} .\n  eq know2 = {client2 ; fxMess} .\n  eq know3 = {client3 ; fxMess} .\n\n  --- Representation of the communication setup phase\n  --- Client-1 sends message to Client-2\n  rl [send1-2] : client1 ; fxMess => client2 ; fxMess .\n  \n  --- Client-1 sends message to Client-3\n  rl [send1-3] : client1 ; fxMess => client3 ; fxMess .\n  \n  --- Client-2 sends message to Client-1\n  rl [send2-1] : client2 ; fxMess => client1 ; fxMess .\n  \n  --- Client-2 sends message to Client-3\n  rl [send2-3] : client2 ; fxMess => client3 ; fxMess .\n  \n  --- Client-3 sends message to Client-1\n  rl [send3-1] : client3 ; fxMess => client1 ; fxMess .\n  \n  --- Client-3 sends message to Client-2\n  rl [send3-2] : client3 ; fxMess => client2 ; fxMess .\n\n  --- Intruder capabilities handling; e.g., intercept and generate messages\n  --- Here we define intruder's possible actions if needed\n  --- Since no algebraic properties, keep this simple or extend as needed\n\nendm\n```\n\nThis Maude-NPA module skeleton sets up the foundational states for an analysis of the mpOTR protocol's communication setup phase. Each client has initial knowledge representing their received messages. The rewrite rules model message exchanges between clients. Intruder actions can be expanded based on the necessity of security analysis."]], "MAUDE-1/mpOTR_dh.maude": [[true, "mod PROTOCOL is\n  protecting STRING .\n  sorts Principal Nonce Key ExpM EncM Msg SharedSecret .\n  \n  subsorts Principal Nonce Key ExpM EncM SharedSecret < Msg .\n  \n  ops A B i : -> Principal .\n  ops N_A N_B : -> Nonce .\n  ops g : -> ExpM .\n  ops sec : Principal Principal -> SharedSecret .\n  ops enc d : Key Msg -> Msg .\n  op exp : ExpM Nonce -> ExpM .\n\n  vars P Q : Principal .\n  vars NA NB : Nonce .\n  vars M : Msg .\n\n  eq enc(K, d(K, M)) = M .\n  eq d(K, enc(K, M)) = M .\n  eq exp(exp(X, Y), Z) = exp(X, Y * Z) .\n\n  rl [AtoB]: \n    A ; B ; exp(g, N_A) => B ; A ; exp(g, N_A) .\n\n  rl [BtoA]: \n    B ; A ; exp(g, N_A) => A ; B ; enc(exp(exp(g, N_B), N_A), sec(A, B)) .\n\n  *** Intruder model ***\n  prot Intruder is\n    vars M1 M2 : Msg .\n    vars N : Nonce .\n    rl [intercept]: M1 => i ; M1 .\n    rl [replay]: i ; M1 => M2 .\n    rl [decrypt]: i ; d(K, enc(K, M)) => i ; M .\n    rl [encrypt]: i ; enc(K, M) => i ; enc(K, M) .\n\n    *** Intruder knows own identity ***\n    rl [intruderIdentity]: i => i .\n\n    *** Intruder knows the generator information ***\n    rl [intruderGenerator]: i ; g => i ; g .\n\n    *** Intruder can perform exponentiation with known nonces ***\n    rl [intruderExp]: i ; exp(g, N) => i ; exp(g, N) .\n  endprot\n\n  prot A_B_Comm is\n    rl [strands A]: A ; B ; exp(g, N_A) => \n                    B ; A ; exp(g, N_A) => \n                    A ; B ; enc(exp(exp(g, N_B), N_A), sec(A, B)) .\n\n    rl [strands B]: B ; A ; exp(g, N_A) => \n                    A ; B ; enc(exp(exp(g, N_B), N_A), sec(A, B)) .\n  endprot\n\nendm"]], "MAUDE-1/Needham_Schroeder.maude": [[true, "mod PROTOCOL is\n  sorts Agent Msg Nonce Key .\n  \n  subsort Nonce < Msg .\n\n  op alice bob intruder : -> Agent .  --- Define agents: Alice, Bob, Intruder.\n  op N_A N_B : -> Nonce .               --- Define nonces: N_A from Alice and N_B from Bob.\n  \n  op pk : Agent Msg -> Msg .  --- Public key encryption.\n  op sk : Agent Msg -> Msg .  --- Private key encryption.\n\n  vars M : Msg .\n  vars A B I : Agent .\n  vars N_A N_B : Nonce .\n  \n  --- Algebraic properties for encryption and decryption.\n  eq pk(A, sk(A, M)) = M .\n  eq sk(A, pk(A, M)) = M .\n\n  --- Define the message exchange strands.\n  op Alice-init : -> Strand .\n  eq Alice-init = < alice, [pk(bob, alice; N_A)], [pk(alice, N_A; N_B)], [pk(bob, N_B)] > .\n\n  op Bob-init : -> Strand .\n  eq Bob-init = < bob, [pk(bob, alice; N_A)], [pk(alice, N_A; N_B)], [pk(bob, N_B)] > .\n\nendm"]], "MAUDE-1/Needham_Schroeder_Lowe_ECB.maude": [[true, "mod SIMPLE-AUTHENTICATION is\n  including BOOL .\n  including NAT .\n  including STRING .\n\n  sorts Agent Nonce Message Key .\n  subsort Agent < Message .\n\n  op Na : -> Nonce [ctor] .\n  op Nb : -> Nonce [ctor] .\n  op A B : -> Agent [ctor] .\n  op PK : Agent -> Key [ctor] .\n  op encrypt : Message Key -> Message [ctor] .\n\n  vars M M' : Message .\n  vars A B : Agent .\n  vars Na Nb Ni : Nonce .\n\n  eq encrypt(M, PK(A)) = encrypt(M', PK(A)) = false .\n\n  --- Initial message from Alice to Bob ---\n  rl [InitialMessage] :\n    A -> B : encrypt((Na, A), PK(B)) =>\n    A <- B : encrypt((Na, Nb, B), PK(A)) .\n\n  --- Response from Bob to Alice ---\n  rl [ResponseMessage] :\n    B <- A : encrypt((Na, Nb, B), PK(A)) =>\n    B -> A : encrypt(Na, Nb, B, PK(A)) .\n\n  --- Final message from Alice to Bob ---\n  rl [FinalMessage] :\n    A <- B : encrypt(Nb, PK(A)) =>\n    A -> B : encrypt(Nb, PK(B)) .\n\n  --- Intruder knowledge ---\n  ops I : -> Agent [ctor] .\n  rl [IntruderCapture] :\n    I <- A : encrypt(M, PK(B)) =>\n    I -> B : encrypt(M', PK(B)) .\n  \n  --- Properties Specification ---\n  op IsFresh : Nonce -> Bool [ctor] .\n  op ExpectedEq : forall M encrypt(M, PK(A)) = encrypt(M', PK(A)) .\n\n  --- Ensure freshness ---\n  ceq IsFresh(N) = true if N == Na or N == Nb .\n\n  --- Authentication check ---\n  crl [AuthCheck] :\n    A -> B : encrypt(Na, A, PK(B)) =>\n    A <- B : encrypt(Na, Nb, B, PK(A)) if IsFresh(Na) /\\ IsFresh(Nb) .\n\nendm"]], "MAUDE-1/Needham_Schroeder_Lowe_Modified.maude": [[true, "mod LOWES_FIX_EXOR is\n  including PROTOCOL .\n\n  sorts A B N Nat Key Msg .\n  subsort A B N Nat Key < Msg .\n\n  op a : -> A .\n  op b : -> B .\n  op i : -> A [ctor] .  --- Intruder can be treated as a participant\n  ops nA nB : -> N [ctor] .\n  op pk : B Msg -> Msg [ctor] .\n  op sk : B Msg -> Msg [ctor] .\n  op * : Msg Msg -> Msg [ctor assoc comm id: 0] .\n\n  var A B : A .\n  vars NA NB : N .\n\n  --- Encryption and Decryption Properties\n  eq sk(B_, pk(B_, M_)) = M_ .\n  eq pk(B_, sk(B_, M_)) = M_ .\n\n  --- XOR Properties\n  eq (X : Msg) * X = 0 .\n  eq (X : Msg) * 0 = X .\n  eq X * X * Y = Y .\n\n  rl [step1] : A => B : pk(b, NA ; a) .\n  \n  rl [step2] : B <= A : pk(b, NA ; a) => A : pk(a, NA ; b * NB) .\n  \n  rl [step3] : A <= B : pk(a, NA ; b * NB) => B : pk(b, NB) .\n\n  --- Intruder Capabilities\n  rl [intruder-intercept] : I <= A : pk(b, NA ; a) => I .\n  \n  rl [intruder-craft] : I <= pk(a, NA ; b * YN) => B .\n  \n  rl [intruder-reply] : I <= pk(b, NB) => I .\nendm"]], "MAUDE-1/ascentFunctionsJanuary2020.maude": [[true, "--- Maude-NPA formal analysis for Non-Existent Module Handling Protocol\n\n--- Module BAD declaration\nmod BAD is\n  --- Importing non-existent module\n  protecting NON-EXISTENT . \nendm\n\n--- Main module to conduct metalevel reductions\nmod MAIN is\n  including META-LEVEL .\n\n  ops badModule : -> ModuleName .\n  eq badModule = 'BAD .\n\n  --- Attempts to access metalevel constructs from 'BAD \n  --- These should all result in errors or empty results\n\n  var BOOL : Bool .\n  var M : Module .\n\n  --- Attempt to pull up the module to the metalevel\n  red upModule(badModule, BOOL) .\n\n  --- Attempt to access imports\n  red upImports(badModule) .\n\n  --- Attempt to pull up sorts\n  red upSorts(badModule, BOOL) .\n\n  --- Attempt to access subsort declarations\n  red upSubsortDecls(badModule, BOOL) .\n\n  --- Attempt to pull up operation declarations\n  red upOpDecls(badModule, BOOL) .\n\n  --- Attempt to access modules from the module\n  red upMbs(badModule, BOOL) .\n\n  --- Attempt to pull up equations\n  red upEqs(badModule, BOOL) .\n\n  --- Attempt to access rewrite rules\n  red upRls(badModule, BOOL) .\n\n  --- Attempt to pull up strategy declarations\n  red upStratDecls(badModule, BOOL) .\n\n  --- Attempt to access structural definitions\n  red upSds(badModule, BOOL) .\n\nendm\n\nload NPA .\n\nreduce in MAIN : \n  upModule('BAD, false) .\n\nreduce in MAIN : \n  upImports('BAD) .\n\nreduce in MAIN :\n  upSorts('BAD, false) .\n\nreduce in MAIN :\n  upSubsortDecls('BAD, false) .\n\nreduce in MAIN :\n  upOpDecls('BAD, false) .\n\nreduce in MAIN :\n  upMbs('BAD, false) .\n\nreduce in MAIN :\n  upEqs('BAD, false) .\n\nreduce in MAIN :\n  upRls('BAD, false) .\n\nreduce in MAIN :\n  upStratDecls('BAD, false) .\n\nreduce in MAIN :\n  upSds('BAD, false) ."]], "MAUDE-1/Needham_Schroeder_Lowe_XOR.maude": [[true, "mod LOWES_FIX_XOR is\n  pr CRYPTO .\n\n  sorts Agent Nonce Key Msg .\n  subsort Agent < Key .\n\n  op a : -> Agent .\n  op b : -> Agent .\n  op i : -> Agent .  --- Intruder\n\n  op n_a : -> Nonce .\n  op n_b : -> Nonce .\n\n  op pk : Key Msg -> Msg .  --- Public key encryption\n  op sk : Key Msg -> Msg .  --- Private key decryption\n  op _*_: Msg Msg -> Msg [assoc comm] .  --- XOR operation\n\n  eq pk(K, sk(K, M)) = M .\n  eq sk(K, pk(K, M)) = M .\n\n  vars X Y M : Msg .\n\n  eq X * X = 0 .\n  eq X * 0 = X .\n  eq X * X * Y = Y .\n\n  --- Protocol roles\n  rl [step1] : msg(a, i, pk(b, n_a ; a)) .\n\n  rl [step2] : msg(b, a, pk(a, n_a ; b * n_b)) .\n\n  rl [step3] : msg(a, b, pk(b, n_b)) .\n\n  --- Intruder capabilities\n  rl [intruder-capture1] : msg(i, b, M) => msg(i, a, M) .\n  rl [intruder-capture2] : msg(i, a, M) => msg(i, b, M) .\n\n  --- Intruder knowledge\n  b : Agent @ i : Agent @ n_a : Nonce @ n_b : Nonce .\n\n  --- Intruder initial knowledge\n  init[i | pk | sk(a, M) ] .\n\nendm\n\n--- Execution strategy for initial attack analysis\nsearch in LOWES_FIX_XOR :\n  {i, a, b, n_a, n_b} | (i|- msg(a, b, pk(b, n_b))) / ."]], "MAUDE-1/nspk.maude": [[true, "mod PROTOCOL-EXAMPLE is\n  --- Sort declarations\n  sorts Name Nonce Key Msg Fresh .\n  subsorts Name Nonce Key < Msg .\n\n  --- Operators for message manipulation\n  op pk : Key Msg -> Msg .\n  op sk : Key Msg -> Msg .\n  op n  : Name Fresh -> Nonce .\n  op _;_ : Msg Msg -> Msg [assoc comm] .\n\n  --- Define constants for participants\n  ops a b i : -> Name .\n\n  --- Protocol strands definition\n  var N1 N2 : Nonce .\n  var K1 K2 KA KB : Key .\n  var M : Msg .\n\n  --- Dolev-Yao strand: Initial setup and communication\n  strand STRAND-DOLEVYAO is\n    ( a,b,i,{ pk(KA, a ; pk(KB, b ; M)), pk(KB, n(a, Fresh)) },{} )\n  end strand \n\n  --- Protocol strand: Main communication process\n  strand STRAND-PROTOCOL is\n    ( a,b,i,{\n        pk(KB, n(a, Fresh) ; pk(KA, N1)),\n        pk(KA, n(b, Fresh) ; pk(KB, N2))\n      },{} )\n  end strand \n\n  --- Attack states demonstrating potential vulnerabilities\n  --- Attack state 0: Intruder possesses certain messages\n  attack ATTACK-STATE(0) is\n    ( i,a,b,{\n        M ; pk(KB, n(a, Fresh))\n      },{} )\n  end attack\n\n  --- Attack state 1: Intruder manipulates nonce values and pretends to be a participant\n  attack ATTACK-STATE(1) is\n    ( i,a,b,{\n        pk(KB, n(i, Fresh)),\n        pk(KA, n(b, Fresh) ; M)\n      },{} )\n  end attack\n\nendm"]], "MAUDE-1/secret06.maude": [[true, "mod SECURE-COMMUNICATION-PROTOCOL is\n  pr STRING .\n  pr HASH .\n  pr CRYPTO .\n\n  sorts Role Nonce Msg .\n\n  subsorts Role Nonce < Msg .\n\n  ops S A B : -> Role [ctor] .\n  ops NS NA NB : -> Nonce [ctor] .\n  \n  --- Message constructors for encryption\n  op sk : Role Msg -> Msg [ctor] .\n  op pk : Role Msg -> Msg [ctor] .\n  \n  --- Concatenation operation\n  op _;_ : Msg Msg -> Msg [assoc comm ctor] .\n\n  --- Initial role-specific facts\n  vars X Y Z : Msg .\n  vars N : Nonce .\n\n  --- Initial message facts\n  eq pk(R, sk(R, X)) = X [variant] .\n  eq sk(R, pk(R, Y)) = Y [variant] .\n\n  --- Associative properties limitation\n  ops NA NS NB : -> Msg [ctor] .\n\n  eq X ; (Y ; Z) = (X ; Y) ; Z .\n\n  --- STRANDS\n\n  --- Server strand\n  op server-strand : -> Strand .\n  eq server-strand =\n     strand(< S | ! (S, A, < NS >) >) .\n\n  --- Initiator strand\n  op initiator-strand : -> Strand .\n  eq initiator-strand =\n     strand(< A | +(S, A, < NS >) ,\n                  ! (A, B, < sk(A, NS ; S) >),\n                  ! (A, B, < sk(A, B ; NA ; S) >) >) .\n\n  --- Responder strand\n  op responder-strand : -> Strand .\n  eq responder-strand =\n     strand(< B | +(A, B, < sk(A, B ; NA ; S) >) >) .\n  \n  --- Intruder strand (capabilities of the intruder)\n  op intruder-strand : -> Strand .\n  eq intruder-strand =\n     strand(< i | ! (X ; Y), +(X ; Y ; Z) >) .\n\n  --- PROTOCOL GOALS\n  goal secrecy : Msg .\n  var M : Msg .\n  eq M in roles implies actor(M) in {A, B, S} .\n\nendm"]], "MAUDE-1/secret07.maude": [[true, "mod EXPONENTIAL-COMMUNICATION-PROTOCOL is \n\n  pr PROTOCOL .\n\n  sort Message .\n\n  op g : -> Name .  **{Public generator name}**\n\n  ** Participants ** \n  op A : -> Agent .\n  op B : -> Agent .\n  \n  ** Nonce identifiers **\n  op N_A : Agent -> Nonce .\n  op N_B : Agent -> Nonce .\n\n  ** Fresh Nonce generator declarations **\n  op fresh : Agent -> Nonce .\n\n  ** Exponentiation operation **\n  op exp : Key, Nonce -> Message .\n  \n  *** Protocol Role A ***\n\n  vars NA : Nonce .\n\n  rl [RoleA] :\n    < A ; {A} pk(B) ; exp(g, NA) ; exp(g, fresh(A)) / NA > =>\n    < A ; {B} pk(B) ; exp(g, fresh(A)) ; NA > .\n\n  *** Protocol Role B ***\n\n  vars NB : Nonce .\n\n  rl [RoleB] :\n    < B ; {B} pk(A) ; exp(g, NB) ; exp(g, fresh(B)) / NB > =>\n    < B ; {A} pk(A) ; exp(g, fresh(B)) ; NB > .\n\n  *** Intruder Capabilities ***\n\n  vars I : Agent .\n  \n  rl [IntruderKnowledge] :\n    I; {X} ; Message => \n    I; {Y} ; Message .\n\n  rl [InterceptMessage] :\n    < I ; {M} ; Message > =>\n    < I ; kintruder ; M > .\n\n  rl [InjectMessage] :\n    < I ; kintruder ; M > =>\n    < B ; Message ; M > .\n\nendm\n\nload NPA .\n\nreduce in EXPONENTIAL-COMMUNICATION-PROTOCOL : attack(?A, ?B) ."]], "MAUDE-1/Wide_Mouthed_Frog.maude": [[true, "mod WIDE-MOUTHED-FROG is\n  pr NAT .\n\n  *** Sort declarations ***\n  sorts Key Msg Agent Nonce .\n\n  *** Subsorts ***\n  subsort Agent < Msg .\n  subsort Key < Msg .\n\n  *** Operations ***\n  ops a b s : -> Agent [ctor] .  *** Alice, Bob, Server ***\n  op n : Agent -> Nonce [ctor] .  *** Nonce generation ***\n\n  ops mkey seskey : Agent Agent -> Key [ctor] .  *** Master and session keys ***\n  op e : Key Msg -> Msg [ctor] .  *** Encryption ***\n  op d : Key Msg -> Msg [ctor] .  *** Decryption ***\n\n  *** Equations ***\n  eq d(K, e(K, M)) = M .  *** Decrypting the encrypted message with the same key ***\n\n  *** Protocol strands ***\n\n  --- Alice's strand ---\n  ops AliceMsg1 : -> Msg .\n  var N1 : Nonce .\n  rl [AliceInit] : A:Agent => n(A) .\n  rl [AliceSend] : n(A) => e(mkey(A, S), concat(A, concat(B, n(A)))) .\n\n  --- Server's strand ---\n  ops ServerMsg1 : -> Msg .\n  var M1 M2 : Msg .\n  var K_AB : Key .\n  rl [ServerReceiveAlice] : e(mkey(A, S), M1) => M1 .\n  rl [ServerSendBob] : M1 => e(mkey(B, S), concat(M1, K_AB)) .\n\n  --- Bob's strand ---\n  ops BobMsg1 : -> Msg .\n  rl [BobReceive] : e(mkey(B, S), M2) => M2 .\n  var Skey : Key .\n  rl [BobAck] : concat(concat(A, B), concat(n(A), Skey)) => e(Skey, n(B)) .\n\n  *** Initial State ***\n  op initState : -> Msg .\n  eq initState = (AliceMsg1 ; ServerMsg1 ; BobMsg1) .\n\nendm"]], "MAUDE-1/Woo-Lam_Authentication.maude": [[true, "mod WOOLam is\n  protecting NAT .\n\n  *** Sorts ***\n  sort UName SName Nonce Key Msg .\n\n  subsort UName SName Key < Msg .\n\n  *** Operators ***\n  op alice bob : -> UName .\n  op server : -> SName .\n  op n : UName -> Nonce .\n  op n(B,r) : -> Nonce .\n  op mkey : Key .\n  op e : Key Msg -> Msg .\n  op d : Key Msg -> Msg .\n  op txt : UName UName Nonce -> Msg .\n  op enc : Msg Msg Nonce -> Msg .\n\n  *** Variables ***\n  vars A B : UName .\n  var K : Key .\n  vars N M : Nonce .\n  vars MSG MSG1 MSG2 : Msg .\n\n  *** Equations ***\n  eq d(K, e(K, MSG)) = MSG .\n\n  *** Strands Definitions ***\n\n  *** Alice's Strand ***\n  op alice-strand : -> Strand .\n  eq alice-strand = \n    begin\n      send txt(alice, server, n(alice)) .\n      recv enc(txt(alice, bob, N), txt(bob, alice, n(B,r)), n(B,r)) .\n    end .\n\n  *** Bob's Strand ***\n  op bob-strand : -> Strand .\n  eq bob-strand = \n    begin\n      recv txt(alice, server, N) .\n      send enc(txt(alice, bob, N), txt(bob, alice, n(B,r)), n(B,r)) .\n      recv enc(txt(bob, alice, n(B,r)), A, M) .\n    end .\n\n  *** Server's Strand ***\n  op server-strand : -> Strand .\n  eq server-strand = \n    begin\n      recv txt(alice, server, N) .\n      send enc(txt(alice, bob, N), txt(bob, alice, n(B,r)), n(B,r)) .\n    end .\n\nendm\n\n--- Initial Knowledge ---\nmod WOOLam-IKE is\n  protecting WOOLam .\n\n  vars A B : UName .\n  vars N M : Nonce .\n  vars K : Key .\n  var MSG : Msg .\n\n  *** Initial Knowledge for Alice, Bob, and Server ***\n  eq initialKnowledge =\n    PKSet{alice, bob, server}\n    MYKeySet{mkey}\n    ReceiverNonceSet{n(alice), n(B,r)}\n    SenderNonceSet{n(alice)}\n    Msg{txt(alice, server, n(alice)), enc(txt(alice, bob, N), txt(bob, alice, n(B,r)), n(B,r)), enc(txt(bob, alice, n(B,r)), alice, M)}\n  .\n\nendm"]], "MAUDE-1/xor-nsl.maude": [[true, "mod LOWE_XOR_PROTOCOL is\n  including STRING .\n  including LIST{String} .\n\n  sorts Nonce Identity Message PublicKey PrivateKey .\n  subsort Identity < PublicKey .\n  subsort String < Nonce Identity Message PublicKey PrivateKey .\n\n  op pk : PublicKey Message -> Message [ctor] .\n  op sk : PrivateKey Message -> Message [ctor] .\n  op _*_: Message Message -> Message [ctor assoc comm] .\n\n  vars A B : Identity .\n  vars NA NB : Nonce .\n  vars M : Message .\n\n  eq pk(B, sk(B, M)) = M .\n  eq sk(A, pk(A, M)) = M .\n\n  eq X * X = '' .\n  eq X * '' = X .\n  eq X * X * Y = Y .\n\n  vars X Y : Message .\n\n  ops alice bob intruder : -> Identity .\n\n  rl [1] : \n    < alice : A | state: init, kn: none > =>\n    < alice : A | state: sent-N1-A, kn: set(NA) > \n    if NA := freshNoncePair(A) .\n\n  rl [2] : \n    < bob : B | state: init, kn: none > =>\n    < bob : B | state: sent-N2-B, kn: set(NB) > \n    if NB := freshNoncePair(B) .\n\n  rl [alice-to-bob] : \n    msg(A, pk(B, NA ; A))\n  => \n    msg(B, pk(A, NA ; B * NB)) .\n\n  rl [bob-to-alice] : \n    msg(B, pk(A, NA ; B * NB))\n  => \n    msg(A, pk(B, NB)) .\n\n  rl [alice-final] : \n    < alice : A | state: sent-NB, kn: none > =>\n    < alice : A | state: completed, kn: none > .\n\n  rl [intruder] :\n    msg(B, M)\n  => \n    msg(intruder, M) .\n\n  rl [replay-intruder] : \n    msg(intruder, M'), msg(intruder, M'') =>\n    msg(B, M') [in msg(A, M'')] .\n\nendm"]], "MAUDE-1/Yahalom.maude": [[true, "mod YAHALOM is\n  protecting STRING .\n  protecting ENCRYPTION .\n\n  sorts User Key Nonce SessionKey Msg .\n  \n  subsorts User Key Nonce SessionKey < Msg .\n\n  ops A B S : -> User .\n  op Na : -> Nonce .\n  op Nb : -> Nonce .\n\n  op mkey : User -> Key .\n  ops sk : User User -> SessionKey .\n  \n  vars U V : User .\n  vars K K1 K2 : Key .\n  vars N N1 N2 : Nonce .\n  vars SK : SessionKey .\n  var M : Msg .\n\n  *** Encryption operations\n  op encrypt : Msg Key -> Msg .\n  op decrypt : Msg Key -> Msg .\n\n  *** Protocol messages\n  ops initMsg replyServer replyAlice confirm : Msg .\n\n  eq initMsg = concat(A, Na) .\n  eq replyServer = encrypt(concat(A, Na, Nb), mkey(A)) .\n  eq replyAlice = concat(encrypt(concat(SK, Na, Nb), mkey(B)), encrypt(concat(SK, Nb), mkey(A))) .\n  eq confirm = encrypt(Nb, SK) .\n\nendm\n\nmod YAHALOM-SYMDEC is\n  protecting YAHALOM .\n\n  *** Decryption axioms\n  var Msg : Msg .\n  \n  eq decrypt(encrypt(Msg, K), K) = Msg .\n  eq decrypt(encrypt(Msg, K1), K2) = encrypt(Msg, K1) [owise] .\n\nendm\n\nmod YAHALOM-PROT is\n  protecting YAHALOM-SYMDEC .\n  protecting ORDERED-STATE .\n\n  ops alice bob server : -> Principal .\n\n  vars M1 M2 M3 M4 : Msg .\n  vars SesKey : SessionKey .\n\n  *** Define Alice's strand\n  obj alice_strand {\n    inputs : A Na .\n    outputs : M1 M2 M3 .\n    actions :\n    (initMsg, send, A), \n    (receive, M1), \n    (replyAlice, M2), \n    (receive, M3), \n    (confirm, send, confirm) .\n  }\n\n  *** Define Bob's strand\n  obj bob_strand {\n    inputs : A Na Nb .\n    outputs : M1 M2 M3 M4 .\n    actions :\n    (initMsg, receive, A), \n    (Nb, generate), \n    (replyServer, send, M1), \n    (replyAlice, receive, M2), \n    (confirm, receive, M4) .\n  }\n\n  *** Define Server's strand\n  obj server_strand {\n    inputs : A Na Nb .\n    outputs : M2 M3 .\n    actions :\n    (replyServer, receive, A), \n    (sk(A,B), generate), \n    (replyAlice, send, M2), \n    (replyAlice, send, M3) .\n  }\n\nendm"]], "MAUDE-1/ISO_5_Pass_Authentication.maude": [[true, "mod ISO-Five-Pass is\n  including PROTOCOL .\n\n  *** Sort declarations ***\n\n  sorts UserName ServerName Nonce MasterKey SessionKey Msg .\n\n  *** Constant declarations ***\n\n  op a : -> UserName [ctor] .  *** Alice's identifier ***\n  op b : -> UserName [ctor] .  *** Bob's identifier ***\n  op s : -> ServerName [ctor] .  *** Server's identifier ***\n\n  *** Cryptographic operation declarations ***\n\n  ops ka kb ks : -> Key [ctor] .  *** Master keys for Alice, Bob, and Server ***\n\n  *** Nonce declarations ***\n\n  op ra : -> Nonce [ctor] .  *** Nonce by Alice ***\n  op rb1 rb2 : -> Nonce [ctor] .  *** Nonces by Bob ***\n\n  *** Message and key declarations ***\n\n  ops m1 m2 : -> Msg [ctor] .\n  op kab : -> SessionKey [ctor] .  *** Session key ***\n\n  *** Encryption and decryption function declarations ***\n\n  op enc : Key Msg -> Msg [ctor] .\n  op dec : Key Msg -> Msg [ctor] .\n\n  *** Protocol Rules ***\n\n  rl [A->B] :\n    < a : State | net(A, B), nonce(ra) >\n    => < a : State | net(B) := m1 : Msg >\n    if m1 := 'A, 'RA(ra) .\n\n  rl [B->S] :\n    < b : State | net(B, S), nonce(rb1) >\n    => < b : State | net(S) := 'A, 'RA(ra), 'B, 'RB1(rb1) : Msg >\n    if < a : State | msg = m1 : Msg > .\n\n  rl [S->B] :\n    < s : State | net(S, B) >\n    => < s : State | net(B) := enc(kb, kab 'B 'RB1(rb1)), enc(ka, kab 'A) : Msg >\n    if msg := 'A, 'RA(ra), 'B, 'RB1(rb1) .\n\n  rl [B->A] :\n    < b : State | net(B, A) >\n    => < b : State | net(A) := enc(ka, kab 'A 'RA(ra)) : Msg >\n    if msg := enc(kb, kab 'B 'RB1(rb1)) .\n\n  rl [A->B] :\n    < a : State | net(A, B) >\n    => < a : State | net(B) := enc(kab, 'RA(ra) 'RB2(rb2)) : Msg >\n    if msg := enc(ka, kab 'A 'RA(ra)) .\n\n  *** Attack Scenarios ***\n\n  ops intruder : -> UserName [ctor] .\n\n  rl [MITM] :\n    < intruder : State | net(B, intruder) >\n    => < intruder : State | net(b) := enc(kab, 'RA(ra) 'RB2(rb2)) : Msg >\n    if msg := enc(ka, kab 'A 'RA(ra)) .\n\nendm"]], "MAUDE-1/Otway-Rees.maude": [[true, "mod OTWAY-REES-PROTOCOL is\n  --- sorts declaration for users, keys, nonces, and messages\n  sorts User Server Key Nonce Message .\n\n  --- operators for user ids, server id, master keys, session keys, and nonces\n  op Alice : -> User .\n  op Bob   : -> User .\n  op Server: -> Server .\n\n  op mkey  : User Server -> Key [metadata key] .\n  op seskey: User User -> Key [metadata key session] .\n\n  op nonce : User -> Nonce [metadata nonce] .\n  op enc   : Key Message -> Message [metadata encrypt] .\n  op dec   : Key Message -> Message [metadata decrypt] .\n\n  --- variables declaration\n  vars U V : User .\n  vars K   : Key .\n  vars N   : Nonce .\n  vars M   : Message .\n\n  --- Encrypted messages cannot be decrypted unless the correct key is used\n  --- enca and deca define how encryption and decryption interact algebraically\n  eq dec(K, enc(K, M)) = M .\n\n  --- Protocol strands definition\n  --- Each strand represents a sequence of message exchanges\n  --- 1. Alice Initiates the Protocol\n  ops AliceInit : -> Message .\n  eq AliceInit = enc(mkey(Alice, Server), (Alice, Bob, nonce(Alice))) .\n\n  --- 2. Server Processes Alice Request\n  ops ServerProcessForAlice : -> Message .\n  eq ServerProcessForAlice = enc(mkey(Alice, Server), (nonce(Alice), seskey(Alice, Bob))) \n                            enc(mkey(Bob, Server), (nonce(Alice), seskey(Alice, Bob))) .\n\n  --- 3. Alice Forwards to Bob\n  ops AliceForward : -> Message .\n  eq AliceForward = enc(mkey(Bob, Server), (nonce(Alice), seskey(Alice, Bob))) .\n\n  --- 4. Bob Confirms Session Key with Server\n  ops BobConfirm : -> Message .\n  eq BobConfirm = enc(mkey(Bob, Server), (seskey(Alice, Bob), nonce(Bob))) .\n\n  --- 5. Server Acknowledges to Bob\n  ops ServerAcknowledge : -> Message .\n  eq ServerAcknowledge = enc(mkey(Bob, Server), (seskey(Alice, Bob), nonce(Bob))) .\n\n  --- 6. Bob Confirms to Alice\n  ops BobToAlice : -> Message .\n  eq BobToAlice = enc(seskey(Alice, Bob), nonce(Bob)) .\n\nendm"]]}