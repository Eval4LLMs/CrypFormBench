{"PV-1/AugmentedEKE2.pv": [[true, "(* Protocol: Augmented EKE Protocol *)\n\n(* Define types for the protocol *)\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\ntype key.\ntype bitstring.\n\n(* Functions and cryptographic primitives *)\nfun g: G.\nfun exp: G * exponent -> G.\nfun enc: key * bitstring -> bitstring.\nfun dec: key * bitstring -> bitstring.\nfun h: passwd -> key.\nfun F: passwd * key -> bitstring.\n\n(* Constants *)\nconst A: host.\nconst B: host.\n\n(* Free variables *)\nfree passwordA: passwd [private].\nfree passwordB: passwd [private].\nfree RA, RB: exponent [private].\nfree NA, NB: nonce [private].\nfree K: key [private].\n\n(* Knowledge *)\nlet SharedKey(pwdA, pwdB) =\n  let KA = h(pwdA) in\n  let KB = h(pwdB) in\n  out(c, KA);\n  out(c, KB).\n\n(* Diffie-Hellman)\nlet DHExchange(g, RA, RB) =\n  let gRA = exp(g, RA) in\n  let gRB = exp(g, RB) in\n  out(c, gRA);\n  out(c, gRB);\n  let sharedKeyA = exp(gRB, RA) in\n  let sharedKeyB = exp(gRA, RB) in\n  sharedKeyA, sharedKeyB.\n\n(* Host A sends initial message *)\nprocess\nnew RA: exponent;\nnew passwordA: passwd;\nlet KA = h(passwordA) in\nlet gRA = exp(g, RA) in\n(* Encrypt message with hash of password *)\nlet encryptedMsgA = enc(KA, gRA) in\nout(c, encryptedMsgA);\nin(c, responseB);\nlet gRB = dec(K, responseB) in\nlet sharedKeyA = exp(gRB, RA) in\nlet encryptedChallengeB = enc(sharedKeyA, NA) in\nout(c, encryptedChallengeB);\nin(c, responseChallengeB);\nlet decryptedChallengeB = dec(sharedKeyA, responseChallengeB) in\nif decryptedChallengeB = NB then\n  out(c, confirmationA)\nelse\n  event abort.\n\n(* Host B responds *)\nprocess\nnew RB: exponent;\nnew passwordB: passwd;\ninput(c, encryptedMsgA);\nlet KA = h(passwordB) in\nlet gRA = dec(KA, encryptedMsgA) in\nlet gRB = exp(g, RB) in\nlet sharedKeyB = exp(gRA, RB) in\nlet nonceChallenge = enc(sharedKeyB, NB) in\nout(c, nonceChallenge);\ninput(c, encryptedChallengeB);\nlet decryptedChallengeB = dec(sharedKeyB, encryptedChallengeB) in\nif decryptedChallengeB = NA then\n  let confirmationB = enc(sharedKeyB, F(passwordB, sharedKeyB)) in\n  out(c, confirmationB)\nelse\n  event abort.\n\n(* Security Goals *)\nquery attacker(K).\nquery weaksecret NA.\nquery weaksecret NB."]], "PV-1/basic1-1.pv": [[true, "(* Simple Hashing Protocol *)\n\n(* Declaration of the hash function. *)\nfun hash(bitstring): bitstring.\n\n(* Declaration of the public channel. *)\nfree c: channel.\n\n(* Declaration of private bitstrings for x and n. *)\nfree x, n: bitstring [private].\n\n(* Specification of the non-interference property.\n   The goal is to prove that x is non-interfering with respect to n and hash(n). *)\nnoninterf x among (n, hash(n)).\n\n(* Process definition where x is sent over the public channel c. *)\nprocess\n    out(c, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\nEND *)"]], "PV-1/E2IBS.pv": [[true, "(* Define the communication channels *)\nfree c_pkg_bs, c_bs_ue : channel.\n\n(* Declare data types and functions *)\ntype public_key.\ntype secret_key.\ntype ID.\ntype message.\n\nfun get_public_key(secret_key): public_key.\nfun generate_secret_key(secret_key, ID): secret_key.\nfun generate_public_key(secret_key): public_key.\nfun E2IBS_sign(message, secret_key): message.\n\n(* Destructors for signature and public key verification *)\nreduc forall m: message, sk: secret_key;\n  E2IBS_sign(m, sk) = m if verify_signature(m, get_public_key(sk)).\n\nreduc forall sk: secret_key;\n  generate_public_key(sk) = get_public_key(sk).\n\n(* Security goals *)\nquery secret secret_key_pkg.\nquery secret secret_key_bs.\n\nquery attacker(message) ==> event(trusted_bs_sib1_reception).\n\n(* Define the Core_PKG process *)\nlet Core_PKG(secret_key_pkg: secret_key, ID_pk: ID) =\n    let sk_bs = generate_secret_key(secret_key_pkg, ID_pk) in\n    out(c_pkg_bs, (ID_pk, generate_public_key(sk_bs))).\n\n(* Define the BS process *)\nlet BS(message_sib1: message) =\n    in(c_pkg_bs, (ID_bs, pub_key_bs: public_key));\n    let sk_bs = generate_secret_key(secret_key_bs, ID_bs) in\n    let signed_sib1 = E2IBS_sign(message_sib1, sk_bs) in\n    out(c_bs_ue, (ID_bs, pub_key_bs, signed_sib1)).\n\n(* Define the UE process *)\nlet UE = \n    in(c_bs_ue, (ID_ue, pub_key_ue: public_key, signed_message: message));\n    if verify_signature(signed_message, pub_key_ue) then\n        event(trusted_bs_sib1_reception).\n\n(* Main process *)\nprocess\n    let secret_key_pkg = new secret_key in\n    let message_sib1 = new message in\n    (!Core_PKG(secret_key_pkg, new ID) | !BS(message_sib1) | !UE)"]], "PV-1/eid_auth.pv": [[true, "(* Types *)\ntype userCert.  (* User certificate *)\ntype serverCert. (* Server certificate *)\ntype pin.        (* PIN type *)\ntype hash.       (* Hash type *)\ntype signature.  (* Signature type *)\ntype dnsName.    (* DNS name *)\n\n(* Public functions *)\nfun hash: bitstring -> hash.         (* Hashing function *)\nfun sign: hash -> pin -> signature.  (* Signature function by Smart Card *)\nfun verifyCert: userCert -> bool.    (* Certificate verification *)\nfun checkOCSP: userCert -> bool.     (* OCSP status check *)\n\n(* Channels *)\nfree publicChannel: channel.\nfree tlsChannel: channel.\n\nprivate channel User_JS_Channel.\nprivate channel JS_EID_Channel.\nprivate channel User_EID_Channel.\nprivate channel EID_SCard_Channel.\n\n(* Events *)\nevent honest(dnsName).\nevent endUser(userCert, serverCert).\nevent endServer(userCert, serverCert).\nevent signedBySCard(userCert, signature).\nevent fakeServerCert(serverCert).\nevent dnsPoisonedName(dnsName).\n\n(* Processes *)\nprocess\n\n(* User Process *)\nnew userPin: pin;\nnew userHash: hash;\nlet userCert = new userCert in\nout(User_JS_Channel, userCert);\nout(User_EID_Channel, userPin);\nin(tlsChannel, serverCert);\nevent endUser(userCert, serverCert).\n\n(* JS Process *)\nin(User_JS_Channel, receivedUserCert: userCert);\nout(JS_EID_Channel, receivedUserCert).\nout(tlsChannel, receivedUserCert).\nin(tlsChannel, serverCert).\nevent endServer(receivedUserCert, serverCert).\n\n(* EID Process *)\nin(JS_EID_Channel, eidUserCert: userCert);\nin(User_EID_Channel, userPin: pin);\nlet sig = sign(eidUserCert, userPin) in\nout(EID_SCard_Channel, sig);\nevent signedBySCard(eidUserCert, sig).\n\n(* SCard Process *)\nin(EID_SCard_Channel, receivedSig: signature).\n\n(* Server Process *)\nin(tlsChannel, serverUserCert: userCert);\nin(tlsChannel, serverServerCert: serverCert);\nif verifyCert(serverUserCert) && checkOCSP(serverUserCert) then\n    out(tlsChannel, serverServerCert)\nelse\n    event fakeServerCert(serverServerCert).\n\n(* Malicious User Process *)\n(* This simulates attempts to generate fake identities, interacting with public channels *)\n(* Attack Processes would go here, demonstrating impersonation, certificate forgery, etc. *)\n\n(* Queries *)\nquery attack: endUser(userCert, serverCert).\nquery attack: endServer(userCert, serverCert).\nquery secret(userPin, [User_EID_Channel]).\nquery secret(signature, [EID_SCard_Channel]).\n\n(* Honest DNS Process *)\nevent honest(dnsName).\n\n(* Poisoned DNS Process *)\nevent dnsPoisonedName(dnsName)."]], "PV-1/EKE-DH.pv": [[true, "(* Define types *)\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\n\n(* Define free names *)\nfree c : channel.  (* Communication channel *)\n\n(* Cryptographic functions *)\nfun g : G.             (* Generator for Diffie-Hellman *)\nfun expDH : G * exponent -> G.  (* Diffie-Hellman exponentiation *)\nfun enc : passwd * G -> G.      (* Encryption with password *)\nfun dec : passwd * G -> G.      (* Decryption with password *)\nfun senc : nonce * G -> G.      (* Symmetric encryption *)\nfun sdec : nonce * G -> G.      (* Symmetric decryption *)\n\n(* Predicate for correct decryption *)\nequation dec(x, enc(x, y)) = y.\nequation sdec(x, senc(x, y)) = y.\n\n(* Host roles *)\nprocess\n  (! new RA: exponent; new Na: nonce; (* Initiator process *)\n     let A = hostA in\n     let B = hostB in\n     let PAA = passwd in\n     out(c, enc(PAA, expDH(g, RA)));  (* Step 1: A -> B: enc(g^RA, PAA) *)\n     in(c, (let encryptedResp = ?v in\n            let enc_nonceB = ?w in\n            (let gRB = dec(PAA, v) in   (* Decrypt g^RB *)\n             let K = expDH(gRB, RA) in  (* Compute session key K = (g^RA)^RB *)\n             let nonceB = sdec(K, enc_nonceB) in\n             out(c, senc(K, (Na, nonceB)))   (* Step 3: A -> B: senc((Na, nonceB), K) *)\n            )\n           ))\n  ) |\n  (! new RB: exponent; new Nb: nonce; (* Responder process *)\n     let A = hostA in\n     let B = hostB in\n     let PBB = passwd in\n     in(c, (let v = ?x in\n           (let gRA = dec(PBB, x) in   (* Step 2: Decrypt g^RA *)\n            let K = expDH(gRA, RB) in  (* Compute session key K = (g^RB)^RA *)\n            let enc_nonceA = senc(K, (Nb, gRA)) in\n            out(c, (enc(PBB, expDH(g, RB)), enc_nonceA))  (* B -> A: enc(g^RB, PBB), senc((Nb, gRA), K) *)\n           )\n         ));\n     in(c, (let enc_nonceAck = ?z in\n            let (Na, nonceAck) = sdec(K, enc_nonceAck) in\n            (* Verify nonces match *)\n            if (nonceAck = Nb) then\n              out(c, nonceAck)   (* Send confirmation *)\n            else\n              0 (* If match fails, end process *)\n           ))\n  ).\n\n(* Security goals *)\nquery attacker(K).   (* Check if an attacker can obtain the session key *)\nquery attacker(Na).  (* Check if an attacker can obtain nonce from A *)\nquery attacker(Nb).  (* Check if an attacker can obtain nonce from B *)"]], "PV-1/EKE.pv": [[true, "(* Protocol Participants *)\nfree hostA, hostB : name.\n\n(* Cryptographic primitives - Types and Functions *)\nfree PKE, SE : type. \nfun pubkey : PKE -> PKE.\nfun symenc : bitstring -> bitstring -> SE.\nfun symdec : bitstring -> bitstring -> bitstring.\nfun pkeenc : bitstring -> PKE -> bitstring.\nfun pkedec : bitstring -> bitstring -> bitstring.\n\n(* Shared secret *)\nfree PAB : bitstring.\n\n(* Nonce generation *)\nfun new_nonce : SE.\n\n(* Protocol Events for Verification *)\nevent startA(hostA, hostB).\nevent startB(hostB, hostA).\nevent endA(hostA, hostB, bitstring). (* Ends when challengeB received *)\nevent endB(hostB, hostA, bitstring). (* Ends when challengeA received *)\n\n(* Protocol Description *)\n\nprocess\n    (* Host A *)\n    (!new sEA: PKE;\n    let EA = pubkey(sEA) in\n    out(ch, pkeenc(EA, PAB));\n    event startA(hostA, hostB);\n    in(ch, x:bitstring);\n    let R = pkedec(x, sEA) in\n    new challengeA: SE;\n    out(ch, symenc(challengeA, R));\n    in(ch, y:bitstring);\n    let challengeB = symdec(y, R) in\n    event endA(hostA, hostB, challengeB))\n\n    (* Host B *)\n    | (!in(ch, x:bitstring);\n    let EA = pkedec(x, PAB) in\n    new R: SE;\n    out(ch, pkeenc(R, EA));\n    event startB(hostB, hostA);\n    in(ch, y:bitstring);\n    let challengeA = symdec(y, R) in\n    new challengeB: SE;\n    out(ch, symenc(challengeB, R));\n    event endB(hostB, hostA, challengeA))"]], "PV-1/event.pv": [[true, "(* Protocol Analysis with Proverif *)\n\nchannel c. (* Declare the communication channel *)\nfree Cocks : bitstring[private]. (* Declare the specific value 'Cocks' *)\nfree RSA : bitstring[private]. (* Declare the message 'RSA' *)\n\nevent evCocks. (* Declare the event for receiving 'Cocks' *)\nevent evRSA. (* Declare the event for processing 'RSA' *)\n\n(* Queries for verifying the protocol properties *)\nquery event(evCocks) ==> event(evRSA). (* Check if evCocks implies evRSA *)\nquery event(evCocks). (* Check the occurrence of evCocks *)\n\n(* Process definition according to the protocol steps *)\nprocess\n    out(c, RSA); (* Sender A sends the message 'RSA' over channel 'c' *)\n    in(c, x:bitstring); (* Receiver B receives a message 'x' from channel 'c' *)\n    if x = Cocks then (* Conditional check if 'x' is 'Cocks' *)\n        event evCocks; (* Trigger evCocks event *)\n        event evRSA (* Trigger evRSA event *)\n    else\n        event evRSA (* Trigger evRSA event only if 'x' is not 'Cocks' *)"]], "PV-1/handshake.pv": [[true, "(* ProVerif model for the symmetric and asymmetric encryption-based communication protocol *)\n\n(* Free names and channels *)\nfree c: channel. (* Public channel *)\n\n(* Types for symmetric and asymmetric keys *)\ntype key.\ntype skey. (* Private key for asymmetric encryption *)\ntype pkey. (* Public key for asymmetric encryption *)\ntype sskey. (* Private signing key *)\ntype spkey. (* Public signing key *)\n\n(* Functions *)\nfun pk(s: skey): pkey. (* Derive public key from private key *)\nfun spk(ss: sskey): spkey. (* Derive public signing key from signing key *)\nfun senc(m: bitstring, k: key): bitstring. (* Symmetric encryption *)\nreduc forall m k. sdec(senc(m, k), k) = m. (* Symmetric decryption *)\nfun aenc(m: bitstring, pk: pkey): bitstring. (* Asymmetric encryption *)\nreduc forall m s. adec(aenc(m, pk(s)), s) = m. (* Asymmetric decryption *)\nfun sign(m: bitstring, sk: sskey): bitstring. (* Digital signature *)\nreduc forall m ss. checksign(sign(m, ss), spk(ss)) = m. (* Signature verification *)\n\n(* Events to represent protocol states *)\nevent acceptsClient(key).\nevent acceptsServer(key, pkey).\nevent termClient(key, pkey).\nevent termServer(key).\n\n(* Protocol roles *)\nlet client(pkB: pkey, spA: spkey, ssA: sskey) =\n    (* Generate client's private key and public key *)\n    new sA: skey;\n    let pkA = pk(sA) in\n    out(c, pkA); (* Send client's public key *)\n\n    (* Receive server's public key, session key signature, session key *)\n    in(c, (pkB': pkey, sigB: bitstring, encKey: bitstring));\n    \n    (* Decrypt the session key and verify signature *)\n    let k = aenc(encKey, pkB) in\n    let sKey = adec(k, sA) in\n    let _ = checksign(sigB, spA) in\n\n    (* Acknowledge the acceptance of the session key *)\n    event acceptsClient(sKey);\n\n    (* Send encrypted message to server *)\n    let message = senc(\"Hello Server!\", sKey) in\n    out(c, message);\n\n    (* Termination of the session *)\n    event termClient(sKey, pkB).\n\nlet server(pkA: pkey, spB: spkey, ssB: sskey) =\n    (* Generate server's private key and public key *)\n    new sB: skey;\n    let pkB = pk(sB) in\n    out(c, pkB); (* Send server's public key *)\n\n    (* Wait for client's public key *)\n    in(c, pkA: pkey);\n\n    (* Generate session key *)\n    new sKey: key;\n    let encryptedKey = aenc(sKey, pkA) in\n\n    (* Sign the session key *)\n    let sigSKey = sign(encryptedKey, ssB) in\n\n    (* Send back session data *)\n    out(c, (pkB, sigSKey, encryptedKey));\n    \n    (* Event marking acceptance of the session key *)\n    event acceptsServer(sKey, pkA);\n\n    (* Receive and check encrypted message from client *)\n    in(c, message: bitstring);\n    let decryptedMessage = sdec(message, sKey) in\n\n    (* Verify integrity of the message *)\n    if decryptedMessage = \"Hello Server!\" then\n        event termServer(sKey)\n\n(* Process initialization *)\nprocess\n    new ssA: sskey; new spA: spkey;\n    new ssB: sskey; new spB: spkey;\n    (\n        !client(pk(pk(ssB)), spB, ssA) |\n        !server(pk(pk(ssA)), spA, ssB)\n    )"]], "PV-1/induction_nat.pv": [[true, "(* Simple example illustrating induction and the setting nounifIgnoreAFewTimes. *)\n\nfree d: channel[private].\n\nset nounifIgnoreAFewTimes = auto.\n\nquery x:nat, y:nat;\n  mess(d, x) ==> is_nat(x) [induction].\n\nprocess\n  out(d, 0) | ! in(d, x:nat); out(d, x+1)\n\n(* EXPECTPV\nRESULT mess(d[], x_1) ==> is_nat(x_1) is true.\n0.010s (user 0.005s + system 0.005s), max rss 8620K\nEND *)"]], "PV-1/JFKr-coresec.pv": [[true, "free c, d0, pub, genprinc, getexponential, init0, getprinc0 : channel.\n\ntype G.\ntype texponent.\ntype skey.\ntype pkey.\ntype key.\ntype tag.\ntype nonce.\ntype grpinfo.\ntype sainfo.\n\nfun G_to_key(G): key.\nfun exp(G, texponent): G.\nfun S(skey, bitstring): bitstring.\nfun Pk(skey): pkey.\nfun E(key, bitstring): bitstring.\nfun D(key, bitstring): bitstring.\nfun H(key, bitstring): bitstring.\n\nconst g: G.\nconst tagE, tagA, tagV: tag.\nconst constI, constR: bitstring.\nconst saR: sainfo.\n\nprivate free skey_I, skey_R : skey.\nfree nonce_I, nonce_R : nonce.\n\nprocess\n    let processI =\n        in(c, (exp_I: texponent, msgI: bitstring));\n        let grp_I = exp(g, exp_I) in\n        let nonceI = new(nonce) in\n        out(c, (nonceI, grp_I));\n        in(c, (nonce_O: nonce, grp_O: G));\n        let keyI = G_to_key(exp(grp_O, exp_I)) in\n        out(c, E(keyI, msgI))\n    in\n\n    let processR =\n        in(c, (exp_R: texponent, msgR: bitstring));\n        let grp_R = exp(g, exp_R) in\n        in(c, (nonceR: nonce, grpR_I: G));\n        let nonce_R = new(nonce) in\n        out(c, (nonce_R, grp_R));\n        let keyR = G_to_key(exp(grpR_I, exp_R)) in\n        out(c, E(keyR, msgR));\n        in(c, encrypted_msg);\n        let decrypted_msg = D(keyR, encrypted_msg) in\n        (* Process the decrypted message *)\n    in\n\n    (! processI) | (! processR).\n\n(* Predicate to analyze secrecy *)\nquery attacker(keyI).\nquery attacker(keyR).\nquery attacker(S(skey_I, constI)).\nquery attacker(S(skey_R, constR))."]], "PV-1/key-registration-locked.pv": [[true, "(* Free names and communication channels *)\nfree c, d: channel.\nfree renew, confirm, error: bitstring.\nfree attackerKey: bitstring.  (* A key the attacker knows *)\n\n(* Cryptographic functions *)\nprivate free ssk: bitstring[secret]. (* server's secret key *)\nfree sign, checksign: bitstring -> bitstring -> bitstring.\nfree pk: bitstring -> bitstring.\n\n(* Database Queries *)\npred db_server_valid(bitstring).\npred db_server_revoked(bitstring).\n\n(* Events for tracking protocol state *)\nevent Revoked(bitstring).\nevent Honest(bitstring).\nevent InValid(bitstring).\nevent InRevoked(bitstring).\nevent TestValid(bitstring).\nevent TestRevoked(bitstring).\n\n(* Protocol Processes *)\n\n(* Server Process *)\nlet server = \n    in(c, (pubKey: bitstring, msg: bitstring));\n    if msg = renew then\n        let sigmsg = sign pubKey ssk in\n        if checksign sigmsg (pk pubKey) then\n            event Honest(pubKey);\n            out(c, confirm);\n            insert db_server_valid(pubKey);\n            event InValid(pubKey);\n        else\n            out(c, error)\n    else if msg = error then\n        out(c, error).\n\n(* Registration Process to insert new valid key *)\nlet registration =\n    new agentKey: bitstring; (* Generate new key for agent *)\n    insert db_server_valid(agentKey);\n    out(d, agentKey).\n\n(* Client Process *)\nlet client(pubKey: bitstring) =\n    out(c, (pubKey, renew));\n    in(c, confirmation: bitstring);\n    if confirmation = confirm then\n        event TestValid(pubKey)\n    else\n        event TestRevoked(pubKey).\n\n(* Threat Model: Attacker may try to register or renew keys *)\nlet attacker =\n    in(c, (attackerKey, renew));\n    out(c, error).\n\n(* Starting Points of the System *)\nprocess\n    (!server) | (!registration) | (!client(attackerKey)) | (!attacker)"]], "PV-1/macs.pv": [[true, "type key.\ntype block.\ntype bitstring.\n\nfun mac(key, bitstring): bitstring.\nfun impl(key, bitstring): bitstring [private].\nfun f(key, bitstring): bitstring.\nfun h(bitstring, block): bitstring.\n\nequation impl(k, x) = f(k, x).\nequation impl(k, x) = f(k, f(k, x)).\nequation h(f(x, y), z) = f(x, (y, z)).\n\nchannel c.\nchannel c1.\nchannel c2.\n\nprocess\n    new k: key;\n    ! (\n        in(c1, x: bitstring);\n        out(c, (x, impl(k, x)))\n      |\n        in(c, (x: bitstring, m: bitstring));\n        if m = impl(k, x) then out(c2, x)\n      )"]], "PV-1/basicweaksecret.pv": [[true, "(* Basic weak secret example *)\n\ntype skey.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption functions *)\nfun pk(skey): pkey.\nfun penc(bitstring, pkey, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall x: bitstring, y: skey, z: seed;  pdec(penc(x, pk(y), z), y) = x.\n\n(* Hash function for passwords *)\nfun h(passwd): bitstring.\n\n(* Communication and confidential elements *)\nfree c: channel.\nfree w: passwd [private].\n\n(* Declare the weak secret *)\nweaksecret w.\n\n(* Protocol process definition *)\nprocess\n    new s: skey;                (* Generate new secret key *)\n    new a: seed;                (* Generate new random seed *)\n    out(c, pk(s));              (* Send the public key on the channel *)\n    out(c, penc(h(w), pk(s), a)) (* Encrypt and send hashed password *)\n\n(* EXPECTPV\nRESULT Weak secret w is true.\nEND *)"]], "PV-1/myProverif.pv": [[true, "free DataA, DataB, DataC, DataD, DataE, DataF, DataG, r1, r2, skA, skB, G: bitstring.\nfree A2RC, B2RC, A2GWN_PRIVATE, B2GWN_PRIVATE, A2GWN, B2GWN: channel.\n\nfun XOR(bitstring, bitstring): bitstring.\nfun Concat(bitstring, bitstring): bitstring.\nfun Hash1(bitstring): bitstring.\nfun Hash2(bitstring): bitstring.\nfun Hash3(bitstring): bitstring.\nfun Hash4(bitstring): bitstring.\nfun Hash5(bitstring): bitstring.\nfun Response(bitstring): bitstring.\nfun a_mul_G(bitstring): bitstring.\nfun CH(bitstring): bitstring.\n\nevent BeginCommunicationAtoB(bitstring).\nevent EndCommunicationAtoB(bitstring).\nevent CommunicationWithGWN(bitstring).\nevent DataTransfer(bitstring, bitstring).\n\nquery attacker(DataA).\nquery attacker(DataB).\nquery attacker(DataC).\nquery attacker(DataD).\nquery attacker(DataE).\nquery attacker(DataF).\nquery attacker(DataG).\n\nprocess\n  !RC_Process(A2RC, B2RC)\n\nlet RC_Process(A2RC, B2RC) =\n  in(A2RC, skA);\n  let idA = CH(skA) in\n  out(A2RC, idA);\n  in(B2RC, skB);\n  let idB = CH(skB) in\n  out(B2RC, idB);\n  0\n| \n!NodeA_Process(A2RC, A2GWN_PRIVATE, A2GWN)\n| \nlet NodeA_Process(A2RC, A2GWN_PRIVATE, A2GWN) =\n  out(A2RC, skA);\n  in(A2RC, idA);\n  let secretA = Hash1(DataA) in\n  event BeginCommunicationAtoB(secretA);\n  out(A2GWN_PRIVATE, Concat(idA, DataA));\n  out(A2GWN, Concat(secretA, r1));\n  event EndCommunicationAtoB(secretA);\n  0\n|\n!NodeB_Process(B2RC, B2GWN_PRIVATE, B2GWN)\n| \nlet NodeB_Process(B2RC, B2GWN_PRIVATE, B2GWN) =\n  out(B2RC, skB);\n  in(B2RC, idB);\n  in(A2GWN_PRIVATE, receivedData);\n  let hDataB = Hash2(receivedData) in\n  event CommunicationWithGWN(hDataB);\n  out(B2GWN_PRIVATE, Concat(idB, DataB));\n  out(B2GWN, Concat(hDataB, Response(receivedData)));\n  event EndCommunicationAtoB(hDataB);\n  0\n|\n!Gateway_Process(A2GWN, B2GWN)\n|\nlet Gateway_Process(A2GWN, B2GWN) = \n  in(A2GWN, receivedA);\n  in(B2GWN, receivedB);\n  event DataTransfer(receivedA, receivedB);\n  0"]], "PV-1/nde-pk.pi": [[true, "(* Non-deterministic Public-Key Encryption Protocol *)\n\n(* Types *)\ntype key.\ntype nonce.\ntype message.\n\n(* Functions *)\nfun pk(key): key.  (* Public key function *)\nfun enc(message, key, nonce): message.  (* Encryption function *)\nfun dec(message, key): message.  (* Decryption function *)\n\n(* Channels *)\nfree c: channel.  (* Receiver channel *)\nfree c2: channel.  (* Sender input channel *)\n\n(* Process: Sender *)\nlet sender =\n    (* Key generation *)\n    new s: key;\n    out(c, pk(s));  (* Send public key *)\n\n    (* Input reception & message preparation *)\n    in(c2, x: message);\n    new a: nonce;\n    \n    (* Non-deterministic encryption action *)\n    if Random.bool() then\n        out(c, enc(x, pk(s), a))  (* Send encrypted message *)\n    else\n        out(c, a)  (* Send nonce *)\n    \n    (* Continuation for observational equivalence demonstration *)\n    nil.\n\n(* Process: Receiver *)\nlet receiver =\n    in(c, y: message);  (* Receive message *)\n    if dec(y, s) = y then\n        (* Successfully decrypted message *)\n        event Success\n    else\n        (* Failed decryption *)\n        event Fail.\n\n(* Main process that runs sender and receiver *)\n(!sender | !receiver)"]], "PV-1/needham.horn": [[true, "(* Secure Message Exchange Protocol *)\n\n(* Free variables declarations for participants and cryptographic operations *)\nfree alice, bob, pkA, skA, pkB, skB, na, nb.\n\n(* Functions used in the protocol *)\nfun pk(sk: privkey): pubkey.\nfun encrypt(msg: message, key: pubkey): ciphertext.\nfun decrypt(ct: ciphertext, key: privkey): message.\n\n(* Predicates representing events in the protocol *)\npred beginAlice(x: message).\n\n(* Queries representing security goals *)\nquery attacker(msg: message).\n\n(* Rules for protocol representation *)\n\n(* Alice generates a nonce and initiates communication with Bob *)\nlet beginAlice(na).\nnew na.\nout(chAlice, encrypt((na, alice), pkB)).\nbeginAlice(alice).\n\n(* Bob receives Alice's message and responds, proving he has received Alice's nonce *)\nin(chAlice, encrypt((na, alice), pkB)).\nnew nb.\nlet response = encrypt((na, nb, bob), pkA).\nout(chBob, response).\n\n(* Alice receives Bob's response *)\nin(chBob, encrypt((na, nb, bob), pkA)).\nout(chAlice, encrypt((na, nb), pkB)).\n\n(* Declare the attacker model *)\nquery attacker(encrypt(_, _)).\n\n(* Security properties *)\n(* Query ensuring confidentiality of nonces *)\nquery attacker(na).\nquery attacker(nb)."]], "PV-1/NeedhamSchroederSK.pv": [[true, "(* Types *)\ntype host.\ntype key.\ntype nonce.\n\n(* Free names - Global constants *)\nfree A, B, S: host [private].\nfree Kas, Kbs: key [private].\n\n(* Functions *)\nfun newkey: nonce, host, host -> key.\nfun encrypt: key, nonce, host -> bitstring.\nfun decrypt: bitstring, key -> (nonce, host).\nfun secretA: bitstring.\nfun secretB: bitstring.\n\n(* Nonces *)\nprivate free Na, Nb: nonce.\n\n(* Events *)\nevent begin_init_A_B(nonce, host).\nevent end_response_A_B(nonce, host).\nevent reveal_A.\nevent begin_response_B_A(host, nonce).\nevent end_response_B_A(host, nonce).\nevent reveal_B.\n\n(* Protocol roles *)\n\n(* Initiator *)\nprocess \n    let Na = new noncetype in\n    event begin_init_A_B(Na, B);\n    (* A -> S: A, B, Na *)\n    out(S, (A, B, Na));\n    (* S -> A: {Na, B, Kab}Kas *)\n    in(S, (Na, B, Kab: key));\n    let msg1 = encrypt(Kab, Na, B) in\n    (* A -> B: {Na, B}Kab *)\n    out(B, msg1);\n    in(B, response: bitstring);\n    (* Decrypt B's response *)\n    let (Nb_received, A_received:host) = decrypt(response, Kab) in\n    event end_response_A_B(Na, B);\n    (* A sends secretA *)\n    out(B, secretA).\n\n(* Responder *)\nprocess \n    in(S, (A_received:host, B, Kab: key));\n    let Nb = new noncetype in\n    event begin_response_B_A(A_received, Nb);\n    (* B -> A: {Nb, A}Kab *)\n    let response = encrypt(Kab, Nb, A_received) in\n    out(A_received,response);\n    in(A_received, secret: bitstring);\n    event end_response_B_A(A_received, Nb); \n    (* B sends secretB *)\n    out(A_received, secretB).\n\n(* Server *)\nprocess\n    in(A, (A_store:host, B_store:host, Na_process:nonce));\n    let Kab = newkey(Na_process, A_store, B_store) in\n    (* S -> A: {Na, B, Kab}Kas *)\n    out(A_store, (Na_process, B_store, Kab));\n    in(B_store, kab_store:key).\n\n(* Security Goals *)\nquery attacker(secretA) => false.\nquery attacker(secretB) => false."]], "PV-1/NS-CBC-secrecy.pv": [[true, "free c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun succ(bitstring) : bitstring [data].\n\nfun cbc_enc_1(bitstring, bitstring) : bitstring.\nfun cbc_enc_2(bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_3(bitstring, bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_4(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\n\nfun cbc_dec_1(bitstring, bitstring) : bitstring.\nfun cbc_dec_2(bitstring, bitstring) : bitstring.\nfun cbc_dec_3(bitstring, bitstring) : bitstring.\nfun cbc_dec_4(bitstring, bitstring) : bitstring.\n\nfun cbc_2_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_1_prefixes(bitstring) : bitstring.\nfun cbc_4_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_3_prefixes(bitstring) : bitstring.\n\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_2_get_1_prefixes(cbc_enc_2(x0, x1, k)) = cbc_enc_1(x0, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_1_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_2_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_2(x0, x1, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_1_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_2_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_2(x0, x1, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_3_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_3(x0, x1, x2, k).\n\nequation forall x0:bitstring, k:bitstring;\n  cbc_dec_1(cbc_enc_1(x0, k), k) = x0.\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_dec_2(cbc_enc_2(x0, x1, k), k) = (x0, x1).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_dec_3(cbc_enc_3(x0, x1, x2, k), k) = (x0, x1, x2).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_dec_4(cbc_enc_4(x0, x1, x2, x3, k), k) = (x0, x1, x2, x3).\n\nquery attacker(new Kab).\n\nlet client_A(Kas : bitstring) =\n  new Na : bitstring;\n\n  out(c, (A, B, Na));                                     (* 1 *)\n  in(c, enc_Na_B_enc_Kab_A : bitstring);                  (* 2 *)\n  let (=Na, =B, Kab : bitstring, enc_Kab_A : bitstring) =\n    cbc_dec_4(enc_Na_B_enc_Kab_A, Kas) in\n  out(c, enc_Kab_A);                                      (* 3 *)\n  in(c, enc_Nb : bitstring);                              (* 4 *)\n  let Nb = cbc_dec_1(enc_Nb, Kab) in\n  out(c, cbc_enc_1(succ(Nb), Kab))                        (* 5 *)\n\nlet client_B(Kbs : bitstring) =\n  new Nb : bitstring;\n  in(c, enc_Kab_A : bitstring);                            (* 3 *)\n  let (Kab : bitstring, =A) = cbc_dec_2(enc_Kab_A, Kbs) in\n  out(c, cbc_enc_1(Nb, Kab));                              (* 4 *)\n  in(c, enc_succ_Nb : bitstring);                          (* 5 *)\n  let (=succ(Nb)) = cbc_dec_1(enc_succ_Nb, Kab) in\n  0\n\nlet server_S(Kas : bitstring, Kbs : bitstring) =\n  new Kab : bitstring;\n  in(c, (A : bitstring, B : bitstring, Na : bitstring));   (* 1 *)\n  out(c, cbc_enc_4(Na, B, Kab, cbc_enc_2(Kab, A, Kbs), Kas)) (* 2 *)\n\nprocess\n  new Kas : bitstring;\n  new Kbs : bitstring;\n\n    (! client_A(Kas))\n  | (! client_B(Kbs))\n  | (! server_S(Kas, Kbs))"]], "PV-1/ns-example.pv": [[true, "(* --- Types --- *)\ntype privkey.\ntype pubkey.\ntype nonce.\n\nfree skA: privkey.    (* Alice's private key *)\nfree skB: privkey.    (* Bob's private key *)\nfun pk: privkey -> pubkey.    (* Public key function (derives public key from private key) *)\n\n(* --- Cryptographic Primitives --- *)\nfun aenc: bitstring * pubkey -> bitstring.\nreduc adec(aenc(m, pkK), skK) = m.\n\nfun senc: bitstring * bitstring -> bitstring.\nfun sdec: bitstring * bitstring -> bitstring.\n\n(* --- Nonce Generation --- *)\nfun gen_nonce: privkey -> nonce.\n\n(* --- Messages and Processes --- *)\n(* Alice's Process *)\nprocess(new Na: nonce;\n        let pkA = pk(skA) in\n        out(c, pkA);   (* Alice publishes her public key *)\n        in(c, pkB: pubkey); (* Alice receives Bob's public key *)\n\n        let encMsgToBob = aenc(Na, pkB) in\n        out(c, encMsgToBob);   (* Alice sends encrypted message to Bob *)\n\n        in(c, encResFromBob);   (* Alice receives response from Bob *)\n        let response = adec(encResFromBob, skA) in\n        let (Na_resp, Nb) = response in\n\n        (* Alice verifies if Na_resp matches Na *)\n        if Na = Na_resp then\n            (* Alice sends encrypted Nonce Nb to Bob for verification *)\n            let encFinalMsg = aenc(Nb, pkB) in\n            out(c, encFinalMsg)\n        else\n            event failA())\n\n(* Bob's Process *)\nprocess(in(c, pkA: pubkey);  (* Bob receives Alice's public key *)\n        out(c, pkB);   (* Bob publishes his public key *)\n\n        let skB_priv = skB in\n        in(c, encMsgFromAlice: bitstring); \n        let (Na, _) = adec(encMsgFromAlice, skB_priv) in\n\n        new Nb: nonce;\n        let response = (Na, Nb) in\n        let encResponseToAlice = aenc(response, pkA) in\n        out(c, encResponseToAlice);   (* Bob responds with encrypted message *)\n\n        in(c, encFinalFromAlice: bitstring);\n        let Nb_resp = adec(encFinalFromAlice, skB_priv) in\n\n        (* Bob verifies if Nb_resp matches Nb *)\n        if Nb = Nb_resp then\n            event end_protocol()\n        else\n            event failB())\n\n(* --- Security Goals --- *)\nquery attacker(Na).\nquery attacker(Nb).\nquery end_protocol."]], "PV-1/NSLPK-agree-A-to-B.pv": [[true, "(* Proverif model for the described protocol *)\n\n(* Types *)\ntype identity.\ntype nonce.\ntype pubkey.\ntype privkey.\n\n(* Free names: public constants and attacker knowledge *)\nfree c : channel.                    (* Secure communication channel *)\nfree server_pubkey : pubkey.         (* Public key of the server *)\nfree clientA : identity.\nfree clientB : identity.\nfree server : identity.\n\n(* Nonces and generated keys *)\nfun genpubkey(privkey): pubkey.\nfun encrypt(pubkey, message): bitstring.\nfun decrypt(privkey, bitstring): message.\nfun sign(privkey, message): bitstring.\nfun verify(pubkey, bitstring): bool.\n\nhash h : identity, message -> message.\nreduc forall x: identity, y: message; h(x, y) = y.\n\n(* Table to store registered public keys *)\ntable keys: identity * pubkey.\n\n(* Queries *)\nquery attacker(h(clientA, nonce)).\nquery attacker(h(clientB, nonce)).\n\n(* Protocol processes *)\n(* Client A process *)\nprocess\n    let pkA = genpubkey(skA) in\n    out(c, (clientA, pkA));  (* Register public key with server *)\n    in(c, (src, dst, pkI));  (* Retrieve public key of Client I *)\n    let Na = new nonce() in\n    out(c, encrypt(pkI, (Na, clientA)));\n    in(c, (Ni, encrypted_response));  (* Wait for encrypted message from B *)\n    if verify(pkI, encrypted_response) then\n        out(c, encrypt(pkI, Ni))\n    else\n        0.\n\n(* Client B process *)\nprocess\n    let pkB = genpubkey(skB) in\n    out(c, (clientB, pkB));  (* Register public key with server *)\n    in(c, (src, dst, pkA));  (* Retrieve public key of Client A *)\n    let Nb = new nonce() in\n    in(c, encrypted_message);  (* Receive message from A *)\n    let (Na, IdA) = decrypt(skB, encrypted_message) in\n    let response = (Na, Nb, clientB) in\n    out(c, sign(skB, response));\n    in(c, encrypted_nonce_response);\n    if verify(pkA, encrypted_nonce_response) then\n        0\n    else\n        0.\n\n(* Key Server Process *)\nprocess\n    in(c, (src: identity, pk: pubkey));\n    insert keys(src, pk);\n    out(c, (src, dst, pk)).\n\n(* Combined process model *)\nlet protocol = !ClientA | !ClientB | !Server.  (* Parallel composition *)"]], "PV-1/NSLPK-secrecy.pv": [[true, "free c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun pkey(bitstring) : bitstring.\ntable keys(bitstring, bitstring).\n\nfun sign(bitstring, bitstring) : bitstring.\nfun checksign(bitstring, bitstring) : bitstring.\nfun getmess(bitstring) : bitstring.\n\nequation forall m:bitstring, k:bitstring;\n  checksign(sign(m,k), pkey(k)) = m.\nequation forall m:bitstring, k:bitstring;\n  getmess(sign(m,k)) = m.\n\nfun dec(bitstring, bitstring) : bitstring.\nfun enc(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  dec(enc(m, k), k) = m.\n\nfun aenc(bitstring, bitstring) : bitstring.\nfun adec(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  adec(aenc(m, pkey(k)), k) = m.\n\nquery attacker(new Nb).\n\nlet client_A(skA : bitstring, pkS : bitstring) =\n  new Na : bitstring;\n  out(c, (A, I));\n  in(c, sign_I_pkI : bitstring);\n  let (=I, pkI : bitstring) = checksign(sign_I_pkI, pkS) in\n  out(c, aenc((Na, A), pkI));\n  in(c, aenc_Na_Ni_I : bitstring);\n  let (=Na, Ni : bitstring, =I) = adec(aenc_Na_Ni_I, skA) in\n  out(c, aenc(Ni, pkI));\n  \nlet client_B(skB : bitstring, pkS : bitstring) =\n  new Nb : bitstring;\n  out(c, (B, A));\n  in(c, sign_A_pkA : bitstring);\n  let (=A, pkA : bitstring) = checksign(sign_A_pkA, pkS) in\n  in(c, aenc_Na_A : bitstring);\n  let (Na : bitstring, =A) = adec(aenc_Na_A, skB) in\n  out(c, aenc((Na, Nb, B), pkA));\n  in(c, aenc_Nb : bitstring);\n  let (=Nb) = adec(aenc_Nb, skB) in\n  0.\n\nlet key_retrieval_server(skS : bitstring) =\n  in(c, (src : bitstring, dst : bitstring));\n  get keys(=dst, pkDst) in\n  out(c, sign((dst, pkDst), skS)).\n\nlet key_register_server =\n  in(c, (host : bitstring, pk : bitstring));\n  if host <> A && host <> B then (\n    insert keys(host, pk)\n  ).\n\nprocess\n  new skA : bitstring;\n  new skB : bitstring;\n  new skS : bitstring;\n\n  let pkA = pkey(skA) in\n  let pkB = pkey(skB) in\n  let pkS = pkey(skS) in\n\n  insert keys(A, pkA);\n  insert keys(B, pkB);\n\n  out(c, pkA);\n  out(c, pkB);\n  out(c, pkS);\n\n  (! client_A(skA, pkS))\n  | (! client_B(skB, pkS))\n  | (! key_retrieval_server(skS))\n  | (! key_register_server)"]], "PV-1/otrv4_idake_deniable.pv": [[true, "free c: channel.\ntype shared_secret.\ntype ring_signature.\ntype client_profile.\n\n(* Public key and private key types *)\ntype pub_key.\ntype priv_key.\n\n(* Functions representing cryptographic primitives *)\nfun ECDH(pub_key, priv_key): shared_secret.\nfun EdDSA_signature(priv_key, client_profile): ring_signature.\nfun KDF(shared_secret): pub_key. (* Key derivation function *)\n\n(* Axioms for cryptographic functions *)\nequation ECDH(pk1, sk1) = ECDH(pk2, sk2) if pk1 = pk2 && sk1 = sk2.\n\n(* Protocol participants: Alice and Bob *)\nprocess\n  let AlicePrivKey = new priv_key in\n  let AlicePubKey = KDF(ECDH(AlicePrivKey, AlicePrivKey)) in\n  out(c, AlicePubKey);\n\n  let BobPrivKey = new priv_key in\n  let BobPubKey = KDF(ECDH(BobPrivKey, BobPrivKey)) in\n  out(c, BobPubKey);\n\n  in(c, BobPubKey);\n  let sharedSecretA = ECDH(BobPubKey, AlicePrivKey) in\n\n  (* Generate client profile and sign it using ring signatures *)\n  let aliceClientProfile = new client_profile in\n  let aliceRingSignature = EdDSA_signature(AlicePrivKey, aliceClientProfile) in\n  out(c, aliceRingSignature);\n\n  (* Derive session key using shared secret *)\n  let sessionKeyA = KDF(sharedSecretA) in\n\n  (* Authentication using the session key *)\n  let authenticatorA = EdDSA_signature(AlicePrivKey, sessionKeyA) in\n  out(c, authenticatorA);\n\n  (* Bob's side of the protocol *)\n  in(c, AlicePubKey);\n  let sharedSecretB = ECDH(AlicePubKey, BobPrivKey) in\n\n  (* Generate client profile and sign it using ring signatures *)\n  let bobClientProfile = new client_profile in\n  let bobRingSignature = EdDSA_signature(BobPrivKey, bobClientProfile) in\n  out(c, bobRingSignature);\n\n  (* Derive session key using shared secret *)\n  let sessionKeyB = KDF(sharedSecretB) in\n\n  (* Authentication using the session key *)\n  let authenticatorB = EdDSA_signature(BobPrivKey, sessionKeyB) in\n  out(c, authenticatorB).\n\n(* Queries to validate security properties *)\nquery attacker(shared_secret).\nquery attacker(sessionKeyA).\nquery attacker(sessionKeyB).\n(* Check for offline deniability *)\nquery attacker(client_profile).\nquery attacker(ring_signature)."]], "PV-1/OtwayRees-key.pv": [[true, "(*\n  Otway-Rees Protocol in ProVerif\n*)\n\n(* Types *)\ntype agent.\ntype nonce.\ntype key.\n\n(* Free names *)\nfree A, B, S: agent.  (* Participants *)\nfree Kas, Kbs: key.   (* Keys shared with the server *)\nfree k: key.          (* Session key *)\n\n(* Functions *)\nfun encrypt: bitstring * key -> bitstring.\nfun decrypt: bitstring * key -> bitstring.\n\n(* Protocol events *)\nevent startA(agent, agent, nonce).\nevent startB(agent, agent, nonce, nonce).\nevent startS(agent, agent, nonce, nonce, key).\nevent endA(agent, agent, nonce, key).\n\n(* Queries *)\nquery attacker(k).\nquery attacker(Na).\nquery attacker(Nb).\n\n(* Protocol roles *)\n\n(* Initiator A *)\nprocess\n  let Na = new nonce in\n  out(channel, (A, B, Na, encrypt((Na, A, B), Kas)));\n  in(channel, (Na, encrypted_msgBbits));\n  let (Nb) = decrypt(encrypted_msgBbits, Kbs) in\n  event endA(A, B, Na, k).\n\n(* Responder B *)\nprocess\n  in(channel, (A, B, Na, encrypted_msgAbits));\n  let (Na) = decrypt(encrypted_msgAbits, Kas) in\n  let Nb = new nonce in\n  out(channel, (Na, encrypt((Nb, Na, A, B), Kbs)));\n  in(channel, encrypted_msgSbits);\n  event startB(A, B, Na, Nb).\n\n(* Server S *)\nprocess\n  in(channel, encrypted_msgSbits);\n  let (Nb, Na, A, B) = decrypt(encrypted_msgSbits, Kbs) in\n  out(channel, encrypt((Na, k), Kas));\n  out(channel, encrypt((Nb, k), Kbs));\n  event startS(A, B, Na, Nb, k).\n\n(* Key Registration (Optional) *)\nprocess\n  let newKey = new key in\n  out(channel, newKey)."]], "PV-1/bull_simplified.pv": [[true, "% Proverif code for Secure Communication Protocol\n\n(* Types *)\ntype nonce.\ntype message.\ntype hash.\n\n(* Functions *)\nfun enc(message, symmetric_key): message.\nfun dec(message, symmetric_key): message.\nfun h(message): hash.\nfun xor(message, message): message.\n\n(* Constants *)\nconst idA: message.\nconst idB: message.\nconst idC: message.\nconst idS: message.\n\n(* Keys *)\nfree Kab: symmetric_key.\nfree Kbc: symmetric_key.\nfree Kas: symmetric_key.\nfree Kbs: symmetric_key.\nfree Kcs: symmetric_key.\n\n(* Private Nonces *)\nprivate Na: nonce.\nprivate Nb: nonce.\nprivate Nc: nonce.\n\n(* Channels *)\nchannel cA, cB, cC, cS: message.\n\n(* Security Queries *)\nquery attacker(Kab).\nquery attacker(Kbs).\nquery attacker(Kcs).\n\n(* Protocol Definitions *)\nprocess\n  (* Initiator A *)\n  let A = \n    (* Generate nonce and compute hash *)\n    new Na: nonce;\n    let messageA = (idA, Na) in\n    let hashA = h(messageA) in\n    (* Encrypt and send message to B *)\n    let encryptedA = enc((messageA, hashA), Kab) in\n    out(cA, encryptedA);\n\n    (* Receive final response from B *)\n    in(cA, encryptedResponseA);\n    let decryptedResponseA = dec(encryptedResponseA, Kab) in\n    (* Verify response *)\n    (* Assume some verification process here *)\n    event \"Comm_A_success\";\n\n    0 \n  in\n\n  (* Intermediate B *)\n  let B =\n    (* Receive message from A *)\n    in(cA, encryptedMessageB);\n    let decryptedMessageB = dec(encryptedMessageB, Kab) in\n    let (idA', Na' as messageB, hashA') = decryptedMessageB in\n    (* Validate identity and hash *)\n    if h((idA', Na') as messageB) = hashA' then\n      new Nb: nonce;\n      let messageBtoC = (idB, Nb, hashA') in\n      let encryptedBtoC = enc(messageBtoC, Kbc) in\n      (* Forward message to C *)\n      out(cB, encryptedBtoC);\n\n      (* Receive response from C *)\n      in(cB, encryptedResponseB);\n      let decryptedResponseB = dec(encryptedResponseB, Kbc) in\n      (* Forward response to A *)\n      let encryptedFinalResponseB = enc(decryptedResponseB, Kab) in\n      out(cA, encryptedFinalResponseB);\n\n      event \"Comm_B_success\";\n    0\n  in\n\n  (* Final C *)\n  let C =\n    (* Receive message from B *)\n    in(cB, encryptedMessageC);\n    let decryptedMessageC = dec(encryptedMessageC, Kbc) in\n    let (idB', Nb', hashA') = decryptedMessageC in\n    (* Validate identity and hash *)\n    if h((idB', Nb') as messageC) = hashA' then\n      new Nc: nonce;\n      let responseC = (idC, Nc) in\n      let encryptedResponseC = enc(responseC, Kbc) in\n      (* Send response to B *)\n      out(cB, encryptedResponseC);\n\n      event \"Comm_C_success\";\n    0\n  in\n\n  (* Facilitator S *)\n  let S =\n    0\n  in\n\n  (* Concurrent execution *)\n  (A | B | C | S)"]], "PV-1/pidenning-sacco3.pi": [[true, "(* Define the cryptographic primitives and types *)\ntype key.\ntype nonce.\ntype sessionKey.\n\nfun pk(key): key.\nfun sk(key): key.\nfun encrypt(key, bitstring): bitstring.\nfun decrypt(key, bitstring): bitstring.\nfun sign(key, bitstring): bitstring.\nfun verify(key, bitstring): bitstring.\nfun enc(sessionKey, bitstring): bitstring.\nfun dec(sessionKey, bitstring): bitstring.\nfun generateNonce(): nonce.\nfun generateSessionKey(): sessionKey.\n\n(* Define the free names for public/private keys and secret keys *)\nfree pkA, pkB: key [public].\nfree skA, skB: key [private].\nfree secretA, secretB: key [secret].\n\n(* Ensure that skA is matched with pkA, skB with pkB *)\nequation decrypt(skA, encrypt(pkA, x)) = x.\nequation verify(pkA, sign(skA, x)) = x.\nequation decrypt(skB, encrypt(pkB, x)) = x.\nequation verify(pkB, sign(skB, x)) = x.\n\n(* Protocol role for Process A *)\nprocess \n    (* Step 1: Process A sends its public key *)\n    new sa: key; new pkA = pk(sa);\n    out (channel, pkA);\n\n    (* Step 2: Receive public key from Process B *)\n    in (channel, pkB: key);\n    \n    let rA = generateNonce() in\n    let k = generateSessionKey() in\n    (* Sign the keys and session key *)\n    let signMsg = sign(skA, (pkA, pkB, k)) in\n    (* Encrypt using Process B's public key and send *)\n    let encMsg = encrypt(pkB, signMsg) in\n    out (channel, encMsg);\n\n    (* Continue with secure communication phase *)\n    ... (* Placeholder for Secure message exchange *)\n\n(* Protocol role for Process B *)\nprocess\n    (* Step 1: Process B waits to receive a public key *)\n    in (channel, pkA: key);\n    new sb: key; new pkB = pk(sb);\n    \n    (* Send its public key back to A *)\n    out (channel, pkB);\n\n    (* Step 3: Receive encrypted, signed message *)\n    in (channel, msgB: bitstring);\n    let decMsg = decrypt(skB, msgB) in\n    \n    (* Verify the signature *)\n    let (pkA', pkB', k') = verify(pkA, decMsg) in \n    (* Check key consistency *)\n    if pkA' = pkA && pkB' = pkB then\n        (* Continue with secure communication phase *)\n        ... (* Placeholder for Secure message exchange *)\n\n(* Security goals *)\nquery attacker: bitstring.\nquery secretA().\nquery secretB()."]], "PV-1/pineedham-shr-orig4.pi": [[true, "(* Types *)\ntype nonce.\ntype key.\n\n(* Functions *)\nfun encrypt: key * nonce -> bitstring.\nfun decrypt: key * bitstring -> nonce.\nfun keygen: nonce -> key.\n\n(* Free names *)\nfree Kas: key.   (* A's secret key *)\nfree Kbs: key.   (* B's secret key *)\nfree S: channel. (* Server's channel *)\nfree A: channel. (* A's channel *)\nfree B: channel. (* B's channel *)\n\n(* Queries *)\nquery attacker: secretA.\nquery attacker: secretB.\nquery event end_exchange.\n\n(* Protocol roles *)\nprocess\n  (* Server role *)\n  let server =\n    in(S, (A_ID: nonce, B_ID: nonce, Na: nonce));\n    let k = keygen(Na) in\n    out(A, (Na, B_ID, k, encrypt(Kbs, (k, A_ID))))\n\n  (* A's role *)\n  in(A, (Na: nonce, B_ID: nonce, k: key, encrypted_msg: bitstring));\n  let (session_key, A_ID) = decrypt(Kbs, encrypted_msg) in\n  let Nb = new nonce in\n  out(B, (Nb, session_key))\n\n  (* B's role *)\n  in(B, (Nb: nonce, session_key: key));\n  let verified_nonce = decrypt(Kbs, encrypt(Kbs, Nb)) in\n  out(A, verified_nonce);\n  event end_exchange.\n\n(* Protocol initialization *)\nevent begin_init.\nbegin_init;\nserver | process"]], "PV-1/piotwayrees-key.pi": [[true, "(* Define functions for encryption and decryption *)\nfun encrypt(bitstring, key): bitstring.\nfun decrypt(bitstring, key): bitstring.\n\n(* Define the free constants representing the participants and server *)\nfree A: bitstring.\nfree B: bitstring.\nfree S: bitstring.\n\n(* Define the free constants representing the keys *)\nfree kA: key.\nfree kB: key.\n\n(* Define predicates to ensure secrecy and authentication *)\npredicate secret_key/1.\npredicate authenticated/2.\n\n(* Define process for Alice *)\nlet alice_process(a: bitstring, b: bitstring, nA: bitstring, kA: key) =\n  (* Generate nonce Na *)\n  new Na: bitstring;\n  (* Create and send message to Bob *)\n  out(net, (a, b, encrypt((Na, a, b), kA))) |\n  (* Wait to receive message from Bob with encrypted nonce and session key from S *)\n  in(net, (b, encrypt((Na, k), kA)));\n  (* Secret key should remain confidential *)\n  secret_key(k).\n\n(* Define process for Bob *)\nlet bob_process(a: bitstring, b: bitstring, nB: bitstring, kB: key) =\n  (* Receive message from Alice *)\n  in(net, (a, b, m1));\n  (* Decrypt with Bob's key kB and create nonce Nb *)\n  let (nA', _, _) = decrypt(m1, kB) in\n  new Nb: bitstring;\n\n  (* Forward the encrypted message to Server along with new nonce Nb *)\n  out(net, (a, b, S, m1, encrypt((Nb, a, b), kB))) |\n  (* Receive from Server encrypted session key and nonce reply *)\n  in(net, (S, encrypt((nA, k), kA), encrypt((Nb, k), kB)));\n\n  (* Forward to Alice the encrypted session key part *)\n  out(net, (a, encrypt((nA, k), kA)));\n\n  (* Represent Bob's receipt of the key *)\n  secret_key(k).\n\n(* Define process for Server *)\nlet server_process(a: bitstring, b: bitstring, kA: key, kB: key) =\n  (* Receive message from Bob *)\n  in(net, (a, b, S, mA, mB));\n  (* Decrypt the Alice message using kA *)\n  let (nA, _, _) = decrypt(mA, kA) in\n  (* Decrypt Bob's message using kB *)\n  let (nB, _, _) = decrypt(mB, kB) in\n  (* Generate session key *)\n  new k: key;\n  (* Send encrypted nA, k to Bob for Alice *)\n  out(net, (b, encrypt((nA, k), kA), encrypt((nB, k), kB))).\n\n(* System composition *)\nlet system =\n  (* Generate principal identities *)\n  new a: bitstring; new b: bitstring;\n  (* Instantiate the processes for Alice, Bob, and Server *)\n  (alice_process(a, b, Na, kA) | bob_process(a, b, Nb, kB) | server_process(a, b, kA, kB))."]], "PV-1/piterm.pi": [[true, "free c: channel.\nfree hash: bitstring -> bitstring.\nfree encrypt: bitstring * bitstring -> bitstring.\nfree decrypt: bitstring * bitstring -> bitstring.\n\nconst pw: bitstring.\n\n(* Equational theory for decryption *)\nequation decrypt(encrypt(x, y), y) = x.\n\n(* Weak secret predicate for password *)\npredicate weak_secret(bitstring).\n\n(* Event declarations *)\nevent begin_handshake(bitstring).\nevent end_handshake(bitstring).\n\nprocess\n\n(* Principle 1: Initiator *)\nnew N: bitstring;                    (* Generate a new nonce *)\nout(c, encrypt(N, pw));              (* Encrypt the nonce with pw and send over channel *)\nevent begin_handshake(N).\n\n(* Principle 2: Attacker's perspective *)\nlet attacker_try_guessing =\n  in(c, x: bitstring);               (* Listen to the channel for messages *)\n  if decrypt(x, pw) = N then         (* Attempt decryption with guessed pw *)\n    event end_handshake(N)           (* Raise event if successful *)\n  else\n    0                                (* Otherwise, do nothing *)\nin\n(attacker_try_guessing)!\n\n(* Security property *)\nquery attacker(pw).\nquery weak_secret(pw)."]], "PV-1/piwoolampk.pi": [[true, "(* Define shared channels *)\nchannel c, cA, cB, cS.\n\n(* Secrecy assumptions: secret keys *)\nfree skA, skB, skS: sk.\nfree pkA, pkB, pkS: pk.\n\n(* Hostname derivation with public key *)\nfun host(pk: pk): string.\n\n(* Pairing and signing functions *)\nfun pair(x, y: bitstring): bitstring.\nfun sign(x: bitstring, sk: sk): bitstring.\nfun verify(x: bitstring, pk: pk): bool.\n\n(* Nonce generation *)\nfree N: bitstring.\n\n(* Events *)\nevent beginBparam(hostB0: string).\nevent endBparam(hostB0: string).\nevent beginBfull(hostA: string, n: bitstring, hostB: string).\nevent endBfull(hostA: string, n: bitstring, hostB: string).\n\n(* Process for initiator A *)\nprocess\n  let hostA = host(pkA) in\n  out(cA, hostA);\n  in(cA, N);\n  let signature = sign(pair(pair(hostA, host(pkB)), N), skA) in\n  out(cB, signature).\n\n(* Process for responder B *)\nprocess\n  let hostB = host(pkB) in\n  event beginBparam(hostB);\n  in(cB, hostA);\n  out(cB, N);\n  in(cB, signature);\n  \n  (* Forward hostA to server *)\n  out(cS, hostA);\n  \n  (* Verification from server *)\n  in(cS, (hostA, serverSig));\n  if verify(serverSig, pkS) then\n    \n    (* Verify A's signature *)\n    if verify(signature, pkA) then\n      event endBfull(hostA, N, hostB)\n    else\n      out(c, \"Verification failed\")\n  else\n    out(c, \"Server verification failed\").\n\n(* Process for server S *)\nprocess\n  in(cS, hostA);\n  let serverSig = sign(pair(hostA, pkA), skS) in\n  out(cS, (hostA, serverSig))."]], "PV-1/piyahalom.pi": [[true, "(* Pi-Calculus Code for Formal Verification in Proverif *)\n\n(* Protocol Participants *)\nfree A, B, S: name\n\n(* Shared Keys *)\nlet K_as = newkey() in\nlet K_bs = newkey() in\n\n(* Session Key *)\nlet K_ab: key in\n\n(* Nonces *)\nlet N_a: nonce in\nlet N_b: nonce in\n\n(* Globals *)\nfree secretA, secretB: bitstring\n\n(* Events *)\nevent begin_session(A, B, N_a, N_b, K_ab)\nevent end_session(A, B, N_a, N_b, K_ab)\n\n(* Protocol Initiation by Alice *)\nprocess\n  new N_a; (* Generate new nonce *)\n  out(c, (A, N_a)); (* A -> B: (A, N_a) *)\n\n  (* Response from Bob *)\n  in(c, (A', N_a));\n  new N_b; (* Generate new nonce *)\n  out(c, (B, N_b, senc((A', N_a), K_bs))); (* B -> S: (B, N_b, {A, N_a}_Kbs) *)\n\n  (* Server's Response *)\n  in(c, (B', N_b', senc((A', N_a'), K_bs)));\n  let K_ab = newkey() in\n  out(c, (N_b', senc((B, K_ab, N_a'), K_as), senc((A, K_ab, N_b'), K_bs))); (* S -> A: (N_b, {...}_Kas, {...}_Kbs) *)\n\n  (* Finalization by Alice *)\n  in(c, (N_b'', senc((B'', K_ab'', N_a''), K_as), senc((A'', K_ab'', N_b''), K_bs)));\n  if N_a = N_a'' then \n    begin_session(A, B, N_a, N_b, K_ab);\n    out(c, senc((A, K_ab, N_b''), K_bs), senc(N_b'', K_ab)); (* A -> B: {...}_Kbs, {...}_Kab *)\n    \n    (* Finalization by Bob *)\n    in(c, (senc((A'', K_ab'', N_b'''), K_bs), senc(N_b''', K_ab'')));\n    if N_b = N_b''' then\n      out(c, senc(secretB, K_ab)); (* B -> A: encrypt(secretB, K_ab) *)\n      end_session(A, B, N_a, N_b, K_ab);\n      \n(* Security Properties *)\nquery secretA =: bitstring()\nquery secretB =: bitstring()\nquery attacker(K_ab) == false"]], "PV-1/pptm.pv": [[true, "(* --- UAV Communication Protocol in ProVerif --- *)\n\n(* Free variables *)\nfree c: channel.        (* Channel for communication *)\n\n(* Types *)\ntype N.                 (* RSA modulus type *)\ntype radius.            (* Type for radius *)\ntype length.            (* Type for length *)\ntype angle.             (* Type for angle *)\ntype origin.            (* Type for origin *)\ntype nonce.             (* Type for nonce *)\ntype vector.            (* Type for vector *)\ntype index.             (* Type for index *)\n\n(* Secrets *)\nprivate free dA_i: bitstring. (* Weak secret, capsule identifier for UAV A *)\nprivate free dB_i_k: bitstring. (* Weak secret, capsule identifier for UAV B *)\n\n(* Cryptographic functions *)\nfun hash(bitstring): bitstring.\nfun exp_mod(bitstring, N): bitstring. (* RSA encryption *)\nfun inv_mod(bitstring, N): bitstring. (* RSA decryption *)\nfun append(bitstring, bitstring): bitstring.\nfun mod(bitstring, N): bitstring.     (* Modular arithmetic *)\n\n(* Events *)\nevent end_UAV_A().\nevent end_UAV_B().\n\n(* Process for UAV A *)\nlet process_UAV_A =\n  new originA: origin;\n  new angleA: angle;\n  new radiusA: radius;\n  new lengthA: length;\n  new nonceA: nonce;\n  let cA_i = exp_mod(nonceA, N) in\n  out(c, (cA_i, originA, angleA, radiusA, lengthA));\n  in(c, vectorB: vector);\n  let check = hash(vectorB) in\n  if check = hash(nonceA) then\n    let finalHash = hash(append(nonceA, angleA)) in\n    out(c, finalHash);\n    event end_UAV_A()\n  else \n    0.\n\n(* Process for UAV B *)\nlet process_UAV_B =\n  in(c, (cA_i: bitstring, originB: origin, angleB: angle, radiusB: radius, lengthB: length));\n  let trajectory = append(originB, angleB) in\n  let decryptedValue = inv_mod(cA_i, N) in\n  let hashValue = hash(decryptedValue) in\n  out(c, hashValue);\n  in(c, finalHashUAV_A: bitstring);\n  if finalHashUAV_A = hash(append(decryptedValue, angleB)) then\n    event end_UAV_B()\n  else\n    0.\n\n(* Security properties queries *)\nquery attacker: dA_i.\nquery attacker: dB_i_k.\n\n(* Protocol execution *)\nprocess \n  (!process_UAV_A | !process_UAV_B)."]], "PV-1/private_authentication_bounded_processes.pv": [[true, "free c: channel [private].\n\n(* Types *)\nfree pk: bitstring -> bitstring.  (* Public key function *)\nfree aenc: bitstring * bitstring -> bitstring.  (* Asymmetric encryption *)\nfree adec: bitstring * bitstring -> bitstring.  (* Asymmetric decryption *)\nfree fail: bitstring.  (* Failure message *)\n\n(* Secrets *)\nfree sk_a, sk_b: bitstring [private].  (* Secret keys for Alice and Bob *)\n\n(* Nonces *)\nnew n_a: bitstring.  (* Nonce generated by Alice *)\nnew n_b: bitstring.  (* Nonce generated by Bob *)\n\n(* Public keys derived from the secret keys *)\nlet pk_a = pk(sk_a).\nlet pk_b = pk(sk_b).\n\n(* Alice's process *)\nprocess \n  new n_a: bitstring;  (* Generate a new nonce n_a *)\n  out(c, aenc((n_a, pk_a), pk_b));  (* Encrypt (n_a, pk_a) with pk_b and send *)\n\n(* Bob's process *)\nprocess\n  in(c, x: bitstring);\n  let y = adec(x, sk_b) in  (* Decrypt the received message with sk_b *)\n  let (n_a_received, pub_a_received) = y in\n  if pub_a_received = pk_a then  (* Verify if pub_a_received matches pk_a *)\n    new n_b: bitstring;  (* Generate a new nonce n_b *)\n    out(c, aenc((n_a_received, n_b, pk_b), pk_a))  (* Encrypt and send response *)\n  else\n    out(c, aenc(fail, pk_a)).  (* Send failure response *)\n\n(* Objectives: security properties *)\n(* We want to ensure that if Alice and Bob complete the protocol, \n   they must have done it with the legitimate keys and nonces.\n   Thus, we can express this by checking equivalence properties \n   or using correspondence assertions when applicable. *)"]], "PV-1/private_messaging.pv": [[true, "# Define types\ntype G.\ntype exponent.\ntype hmac_key.\ntype sym_key.\ntype nonce.\ntype sk.\ntype pk.\n\n# Constants\nconst c: channel.\nconst skA, skB, skC: sk.\nconst m1, m2, m3: bitstring.\nconst failmsg: bitstring.\nconst zero: sym_key.\nconst nonce0: nonce.\nconst recipients: bitstring.\n\n# Cryptographic primitives and key functions\nfun get_pk(sk): pk.\nfun exp(pk, sk): sym_key.\nfun dhexp(pk, sk): G.\nfun valid(sk): bitstring.\nfun weak(sk): bitstring.\n\n# Symmetric encryption and related functions\nfun enc(bitstring, sym_key): bitstring.\nfun aeadenc(sym_key, nonce, bitstring): bitstring.\n\n# HMAC and signatures\nfun hmac(bitstring, hmac_key): bitstring.\nfun sign(bitstring, sk): bitstring.\nfun checksign(bitstring, pk, bitstring): bitstring.\n\n# Events\nevent Sentmessage(pk, pk, bitstring).\nevent Receivedmessage(pk, pk, bitstring).\n\n# Protocol processes\nlet EncryptM42 = \n  new nonceM42: nonce;\n  let keyA_G = get_pk(skA) in\n  let keyB_G = get_pk(skB) in\n  let shared_key = exp(keyA_G, skB) in\n  let signed_message = sign(m1, skA) in\n  let encrypted_message = aeadenc(shared_key, nonceM42, signed_message) in\n  out(c, encrypted_message);\n  event Sentmessage(keyA_G, keyB_G, encrypted_message).\n\nlet DecryptM42 = \n  in(c, encrypted_message);\n  let keyB_G = get_pk(skB) in\n  let received_key = exp(keyB_G, skA) in\n  let decrypted = aeaddec(received_key, nonceM42, encrypted_message) in\n  if checksign(decrypted, keyA_G, m1) then\n  event Receivedmessage(keyB_G, keyA_G, encrypted_message)\n  else out(c, failmsg).\n\nlet EncryptM41 = \n  new nonceM41: nonce;\n  let keyA_G = get_pk(skA) in\n  let keyC_G = get_pk(skC) in\n  let shared_key = exp(keyA_G, skC) in\n  let signed_message = sign(m2, skA) in\n  let encrypted_message = aeadenc(shared_key, nonceM41, signed_message) in\n  out(c, encrypted_message);\n  event Sentmessage(keyA_G, keyC_G, encrypted_message).\n\nlet DecryptM41 = \n  in(c, encrypted_message);\n  let keyC_G = get_pk(skC) in\n  let received_key = exp(keyC_G, skA) in\n  let decrypted = aeaddec(received_key, nonceM41, encrypted_message) in\n  if checksign(decrypted, keyA_G, m2) then\n  event Receivedmessage(keyC_G, keyA_G, encrypted_message)\n  else out(c, failmsg).\n\n# Security queries\nquery attacker(m1).\nquery attacker(m2).\nquery attacker(m3).\nquery event(Sentmessage(pk1, pk2, bitstring)) ==> event(Receivedmessage(pk2, pk1, bitstring)).\n\n# Start the protocol execution\nprocess\n  !EncryptM42 | !DecryptM42 | !EncryptM41 | !DecryptM41"]], "PV-1/proba-pk.pv": [[true, "free c, c2: channel.\nfree skey, seed, block, encblock: type.\nfree s: skey.\nprivate choice: bitstring.\n\n(* Function Definitions *)\nfun pk(skey): pkey.\nfun enc(block, pkey, seed): encblock.\nfun dec(encblock, skey): block.\n\n(* Equation ensuring encryption/decryption coherence *)\nequation forall x: block, y: skey, z: seed; dec(enc(x, pk(y), z), y) = x.\n\n(* Sender Process *)\nlet sender =\n  new s: skey;\n  let pkey = pk(s) in\n  out(c, pkey);\n  in(c2, x: block);\n  new a: seed;\n  let r = enc(x, pkey, a) in\n  out(c, choice);\n\n(* Receiver Process *)\nlet receiver =\n  in(c, pkey: pkey);\n  out(c2, x: block);\n\nprocess\n  !(sender | receiver)"]], "PV-1/cca2.pv": [[true, "datatype message\n\n(* Types definition *)\ntype public_key\ntype secret_key\ntype signature\ntype nizk_proof\ntype encrypted_message\ntype random_value\n\n(* Channels *)\nfree ch: channel.\nprivate free ttp_ch: channel.\nprivate free ua_ch: channel.\n\n(* Constructors *)\nfun pub_key_gen(): public_key.\nfun priv_key_gen(): secret_key.\nfun sign(secret_key, message): signature.\nfun verify_signature(public_key, signature, message): bool.\nfun encrypt(public_key, message): encrypted_message.\nfun decrypt(secret_key, encrypted_message): message.\nfun generate_nizk(random_value): nizk_proof.\nfun verify_nizk(nizk_proof, message): bool.\n\n(* Events *)\nevent sig_verified(public_key, signature, message).\nevent sig_open(secret_key, encrypted_message, message).\n\n(* Processes *)\nprocess\n  // Setup Phase\n  let spk = pub_key_gen() in\n  let ssk = priv_key_gen() in\n  out(ua_ch, (spk, ssk));\n  out(ttp_ch, (spk, ssk));\n\n  // User Process: UA\n  new rand_value: random_value;\n  let em = encrypt(spk, rand_value) in\n  let sig = sign(ssk, em) in\n  let nizk = generate_nizk(rand_value) in\n  out(ch, (em, sig, nizk));\n\n  // TTP Process\n  in(ch, (em_received, sig_received, nizk_received):\n    encrypted_message * signature * nizk_proof);\n  if verify_signature(spk, sig_received, em_received) & verify_nizk(nizk_received, em_received) then\n    let ttp_sig = sign(ssk, em_received) in\n    event sig_verified(spk, sig_received, em_received);\n    out(ch, ttp_sig)\n  else\n    0;\n\n  // Open Phase\n  in(ch, ttp_sig_received: signature);\n  let decrypted_msg = decrypt(ssk, em_received) in\n  event sig_open(ssk, em_received, decrypted_msg).\n\n(* Security Queries *)\nquery attacker(em_received).\nquery attacker(rand_value).\nquery sig_verified(spk, sig_received, em_received) ==> ev:sig_open(ssk, em_received, decrypted_msg)."]], "PV-1/ProVerif-Code.pv": [[true, "/* Types */\ntype pubKey.\ntype secKey.\ntype bitstring.\n\n/* Channels */\nchannel sch (private).\nchannel usch.\n\n/* Functions */\nfun f(bitstring, bitstring): bitstring.\nfun f1(bitstring, bitstring): bitstring.\nfun f2(bitstring, bitstring): bitstring.\nfun f3(bitstring, bitstring): bitstring.\nfun f4(bitstring, bitstring): bitstring.\nfun f5(bitstring, bitstring): bitstring.\nfun SHA(bitstring): bitstring.\nfun pk(secKey): pubKey.\nfun senc(bitstring, pubKey): bitstring.\nfun sdec(bitstring, secKey): bitstring.\nfun Encaps(pubKey): bitstring.\nfun DecapsKey(bitstring, secKey): bitstring.\n\n/* Events */\nevent UESendConSN(bitstring, bitstring).\nevent UERecResSN(bitstring).\nevent SNRecReqUE(bitstring).\nevent SNSendReqHN(bitstring, bitstring).\nevent HNRecConSN(bitstring).\nevent SNRecResHN(bitstring).\n\n/* Private Keys */\nprivate free k: bitstring.\nprivate free skHN: secKey.\npublic free pkHN: pubKey = pk(skHN).\nprivate free SUPI: bitstring.\n\n/* Processes */\nprocess\n  (* UE process *)\n  let ru = new random: bitstring in\n  let USUCI = Encaps(pkHN) in\n  let MACu = f(SUPI, USUCI) in\n  out(usch, (USUCI, MACu));\n  in(sch, res: bitstring);\n  let verified = f5(res, k) = MACu in\n  if verified then\n    let response = f5(res, k) in\n    emit UESendConSN(response, ru)\n  else\n    0.\n\n| (* SN process *)\n  in(usch, (USUCI: bitstring, MACu: bitstring));\n  emit SNRecReqUE(USUCI);\n  let rSN = new random: bitstring in\n  out(sch, (USUCI, MACu));\n  in(sch, resHN: bitstring);\n  emit SNRecResHN(resHN);\n  let AV = f4(resHN, rSN) in\n  out(sch, AV);\n  emit UERecResSN(AV).\n\n| (* HN process *)\n  in(sch, (USUCI: bitstring, MACu: bitstring));\n  emit HNRecConSN(USUCI);\n  let raw_key = DecapsKey(USUCI, skHN) in\n  let verified = f3(raw_key, SUPI) = MACu in\n  if verified then\n    let responseHN = sdec(USUCI, skHN) in\n    out(sch, responseHN)\n  else\n    0.\n\n/* Security Queries */\nquery attacker(skHN).\nquery attacker(k).\nquery secret SUPI [untrusted]."]], "PV-1/racd.pv": [[true, "(* Declarations of types and free names *)\ntype bitstring.\ntype G. (* Group element type for elliptic curve operations *)\nfree secureboot: bitstring. (* Start of the secure boot process event *)\nfree requestAttestation: bitstring -> bitstring. (* Nonce request event *)\nfree acceptAttestationRequest: bitstring -> bitstring. (* Acknowledge request *)\nfree sendAttestationResult: bitstring -> bitstring -> bitstring. (* Attestation results *)\nfree requestpartialVerification: bitstring -> bitstring. (* Partial verification request *)\nfree verifiedAttestationResult: bitstring -> G -> bool -> bitstring. (* Verification result *)\nfree trustable: bitstring. (* Trustable event *)\n\n(* Cryptographic primitives *)\nfun pair: bitstring * bitstring -> bitstring.\nreduc forall x, y: bitstring; injbot: pair(x, y) = pair(x, y).\n\nfun enc: bitstring * bitstring -> bitstring.\nfun dec: bitstring * bitstring -> bitstring.\nequation forall k, m: bitstring; dec(enc(m, k), k) = m.\n\nfun sign: bitstring * bitstring -> bitstring.\nfun verify: bitstring * bitstring * bitstring -> bool.\n\nfun hash: bitstring -> bitstring.\n\n(* Secret and public keys *)\nfun pk: bitstring -> bitstring. \nconst skattester: bitstring.\nconst skverifier: bitstring.\nconst skpartialverifier: bitstring.\n\n(* Attestation process *)\nprocess\n  (* Verifier process *)\n  let Verifier = \n    new nonce: bitstring;\n    out(c, requestAttestation(nonce));\n    in(c, secureboot);\n    in(c, sendAttestationResult(mes, result));\n    if verify(sign(hash(pair(nonce, mes)), skattester), mes, pk(skattester)) && ... then\n      event trustable()\n    else\n      0\n\n  (* Attester process *)\n  and Attester =\n    in(c, requestAttestation(nonce));\n    event acceptAttestationRequest(nonce);\n    let eventHash = hash(nonce); (* Simplification *)\n    let mes = pair(eventHash, \"data\");\n    let signedMes = sign(hash(mes), skattester);\n    out(c, sendAttestationResult(signedMes, \"resultList\"))\n\n  (* Partial Verifier process *)\n  and PartialVerifier =  \n    in(c, verify(mes, signedMes));\n    if verify(signedMes, mes, pk(skattester)) then\n      event verifiedAttestationResult(signedMes, \"GroupElement\", true)\n    else\n      0\nin Verifier | Attester | PartialVerifier\n\n(* Security properties *)\nquery attacker(skattester).\nquery attacker(nonce).\nquery attacker(result)."]], "PV-1/rdp.pv": [[true, "(* Declaration of free names corresponding to participant identities and operations *)\nfree client_identity: name.\nfree valid_client_identity: name.\nfree invalid_client_identity: name.\nfree org_identity: name.\nfree aff_identity: name.\nfree operation: name.\n\n(* Declaration of message channels *)\nchannel cout, cin, orgin, orgout, affin, affout, pub.\n\n(* Declaration of events *)\nevent clientSendName(name, name).\nevent clientReceiveResponse(name, name).\nevent orgOK(name, name).\nevent affReceivesMsg(name, name).\nevent rdpWasSuccessful(name, name).\n\n(* Functions *)\nfun findPolicy(name, name): name.\n\n(* Processes *)\nprocess\n  let client = \n    out(cout, (valid_client_identity, operation));\n    event clientSendName(valid_client_identity, operation);\n    in(cin, x);\n    event clientReceiveResponse(valid_client_identity, x)\n  in\n\n  let client_invalid =\n    out(cout, (invalid_client_identity, operation));\n    event clientSendName(invalid_client_identity, operation);\n    in(cin, x);\n    event clientReceiveResponse(invalid_client_identity, x)\n  in\n\n  let rdp =\n    in(cout, (c_name, c_op));\n    out(orgin, (c_name, c_op));\n    in(orgout, policy_response);\n    event orgOK(c_name, policy_response);\n    if policy_response = findPolicy(c_name, c_op) then\n      out(affin, (c_op, policy_response));\n      event affReceivesMsg(c_op, policy_response);\n      in(affout, aff_response);\n      event rdpWasSuccessful(c_op, aff_response);\n      out(cin, aff_response)\n    else\n      out(cin, \"Unauthorized\")\n  in\n\n  let organization =\n    in(orgin, (c_name, c_op));\n    let policy_result = findPolicy(c_name, c_op) in\n    out(orgout, policy_result);\n    event orgOK(c_name, policy_result)\n  in\n\n  let affiliate =\n    in(affin, (op, policy));\n    out(affout, \"Success\");\n    event affReceivesMsg(op, policy)\n  in\n\n  (* Queries for security goals *)\n\n  query attacker(c_name).\n  query event(clientSendName(valid_client_identity, operation)) ==> event(clientReceiveResponse(valid_client_identity, x)).\n  query event(orgOK(valid_client_identity, policy_response)) ==> event(affReceivesMsg(operation, policy_response))\n\n(* Start the interactions *)\ninit: client | client_invalid | rdp | organization | affiliate."]], "PV-1/secure-device.pv": [[false, "```\npv\n\n# Free names\nfree c : channel.\nfree cell : channel.\nfree init, left, right : bitstring.\n\n# Cryptographic functions\nfun pk(bitstring) : bitstring.\nfun aenc(bitstring, bitstring) : bitstring.\nfun adec(bitstring, bitstring) : bitstring.\n\n# Events\nevent Attack.\nevent Counter(timestamp).\nevent VCell_bitstring(bitstring).\n\n# Implementation of Conf process\nlet Conf(x : bitstring, y : bitstring) =\n  if y = init then\n    if x = left || x = right then\n      out(cell, x)\n    else\n      out(cell, y)\n  else\n    out(cell, y).\n\n# Implementation of Decrypt process\nlet Decrypt(x : bitstring, y : bitstring, k : bitstring) =\n  let dec_x = adec(k, x) in\n  if y = left then\n    out(c, dec_x)\n  else if y = right then\n    out(c, dec_x)\n  else\n    out(cell, y).\n\n# Implementation of Device process\nprocess\n  let k = newbitstring in\n  let pk_k = pk(k) in\n  out(c, pk_k);\n  out(c, init);\n  !in(c, x : bitstring);\n  (\n    Conf(x, init) |\n    Decrypt(x, init, k) |\n    !in(c, x : bitstring); out(c, x) |\n    (let enc_msg = aenc(pk_k, init) in out(c, enc_msg); if adec(k, enc_msg) = init then event Attack)\n  ).\n\n# Queries\nquery event(Attack).\n```"]], "PV-1/SignedAugmentedEKE1.pv": [[true, "(* Free names *)\nfree passwd : bitstring [private].\nfree g, pk : bitstring.\n\n(* Types *)\ntype nonce.\ntype exp : nonce -> bitstring.\n\n(* Functions *)\nfun exp : bitstring * nonce -> exp.\nfun enc : bitstring * bitstring -> bitstring.\nfun dec : bitstring * bitstring -> bitstring.\nfun senc : bitstring * bitstring -> bitstring.\nfun sdec : bitstring * bitstring -> bitstring.\nfun sign : bitstring * bitstring -> bitstring.\nfun verif : bitstring * bitstring * bitstring -> bool.\n\n(* Events *)\nevent startA(pk : bitstring, RA : nonce).\nevent startB(RB : nonce).\nevent authenticatedA(pk : bitstring, RB : nonce).\nevent authenticatedB(RA : nonce).\n\n(* Main process *)\nprocess\n  (* Host A *)\n  let RA = new nonce in\n  let msgA = enc(exp(g, RA), pk(passwd)) in\n  out(c, (msgA, pk));\n  in(c, (msgB, sigB));  \n  let RB = dec(msgB, pk) in\n  if verif(sigB, pk, exp(g, RB)) then\n    event authenticatedA(pk, RB);\n    let challenge = exp(g, RA) in\n    let msgC = senc(challenge, exp(g, RB)) in\n    out(c, msgC);\n    in(c, msgD);\n    let response = sdec(msgD, exp(g, RA)) in\n    if response = RB then\n      event authenticatedB(RA)\n  else 0.\n\n(* Host B *)\nprocess\n  in(c, (msgA, pkA));  \n  let RA = dec(msgA, pkA) in\n  let RB = new nonce in\n  let K = exp(g, RB) in\n  let sigB = sign(exp(g, RA), passwd) in\n  let msgB = enc(exp(g, RB), pkA) in\n  out(c, (msgB, sigB));\n  in(c, msgC);\n  let challenge = sdec(msgC, exp(g, RB)) in\n  if challenge = exp(g, RA) then\n    let response = senc(RB, exp(g, RA)) in\n    out(c, response);\n    event authenticatedA(pkA, RB)\n  else 0.\n\n(* Security properties *)\nquery eavesdrop = false.\nquery secret nonce RA with specified.\nquery secret nonce RB with specified.\nquery event authenticatedA(pk, RB) ==> event startA(pk, RA).\nquery event authenticatedB(RA) ==> event startB(RB)."]], "PV-1/signedDH.pv": [[true, "// Define cryptographic primitives\nconst g: bitstring.\nfun exp(bitstring, bitstring): bitstring.\nfun pk(key): bitstring.\nfun sign(bitstring, key): bitstring.\nfun enc(bitstring, key): bitstring.\nfun dec(bitstring, key): bitstring.\n\n// Types of keys and shared secrets\ntype skey, pkey, shared_key.\n\nprivate free skA: skey.  // Secret key for Alice\nprivate free skB: skey.  // Secret key for Bob\nlet pkA = pk(skA).\nlet pkB = pk(skB).\n\n// Channels\nfree c: channel.  // Insecure channel\n\n// Protocol Roles\n\n// Role A - Alice\nlet alice(s, pkB: bitstring, c: channel) =\n    // Generate nonce n0\n    new n0: bitstring;\n    let g_n0 = exp(g, n0) in\n    let signed_g_n0 = sign(g_n0, skA) in\n    out(c, (signed_g_n0, pkA));\n    \n    in(c, signed_g_n1: bitstring);\n    if dec(signed_g_n1, pkB) = exp(g, n1) then\n        // Compute shared key k\n        let k = exp(g_n1, n0) in\n        // Send encrypted secret message s\n        let enc_s = enc(s, k) in\n        out(c, enc_s)\n    else\n        // Verification failed\n        0.\n\n// Role B - Bob\nlet bob(pkA: bitstring, c: channel) =\n    in(c, (signed_g_n0: bitstring, pkX: bitstring));\n    if pkX = pkA then\n        if dec(signed_g_n0, pkX) = exp(g, n0) then\n            new n1: bitstring;\n            let g_n1 = exp(g, n1) in\n            let signed_g_n1 = sign(g_n1, skB) in\n            out(c, signed_g_n1);\n            \n            in(c, enc_s: bitstring);\n            let k = exp(exp(g, n0), n1) in\n            if dec(enc_s, k) = s then\n                // Successfully received secret message s\n                0\n            else\n                // Decryption failed\n                0\n        else\n            // Verification failed\n            0\n    else\n        // Incorrect public key\n        0.\n\n// Security goals\nquery attacker(s).\nquery attacker(enc_s).\n\n// Main process execution\nprocess\n    new s: bitstring;\n    alice(s, pkB, c) | bob(pkA, c)"]], "PV-1/simpleryahalom-auth.horn": [[true, "% Define constants to represent participants and keys\nconst A, B, S: bitstring.\nconst Kas, Kbs: bitstring. % Symmetric keys shared with the server\nconst Kab: bitstring.      % Session key between A and B\n\n% Define fresh nonces for A and B\nconst Na, Nb: bitstring.\n\n% Define predicates for channels\nfree c1, c2, c3: channel.\n\n% Define encryption function\nconst encrypt: bitstring * bitstring -> bitstring.\n\n% Define host functions (for participant identities)\nconst host_A, host_B, host_S: bitstring.\n\n% Define messages exchanged in the protocol\nconst M1: bitstring = pair(A, Na).\nconst M2: bitstring = pair(B, Nb, encrypt(pair(A, Na), Kbs)).\nconst M3: bitstring = pair(Nb, encrypt(pair(B, Kab, Na), Kas), encrypt(pair(A, Kab, Nb), Kbs)).\nconst M4: bitstring = pair(encrypt(pair(A, Kab, Nb), Kbs), encrypt(Nb, Kab)).\n\n% Protocol steps\n[ ] c1(M1) -> [ c2(M2) ].\n[ c2(M2) ] -> [ c3(M3) ].\n[ c3(M3) ] -> [ c1(M4) ].\n\n% Attacker capabilities\nfree attacker: action.\nattacker(M1) :- c1(M1). % Attacker can read M1\nattacker(M2) :- c2(M2). % Attacker can read M2\nattacker(M3) :- c3(M3). % Attacker can read M3\nattacker(M4) :- c1(M4). % Attacker can read M4\nattacker(encrypt(X, K)) :- attacker(X). % Attacker can encrypt known X with K\n\n% Initial knowledge of the attacker\nattacker(Kas).\nattacker(Kbs).\n\n% Queries\nquery attacker(Kab). % Query to verify if the attacker can obtain the session key Kab\nquery attacker(pair(A, Nb)). % Query to check if the attacker can connect A to Nb\nquery attacker(pair(B, Na)). % Query to check if the attacker can connect B to Na\n\n% Host security assumptions\nnot attacker(A).\nnot attacker(B).\nnot attacker(S).\n\n% Key secrecy assumptions\nnot attacker(Kab). % Assuming Kab should remain secret\n\n% Define deduction rules for nonces and encryption\ndeduce(X, Y) :- pair(X, Y). % Pair deduction\ndeduce(X, Y) :- encrypt(X, Y). % Encryption deduction"]], "PV-1/sissi_unforgeable_VC.pv": [[true, "(* SISSI Architecture Protocol Representation in ProVerif *)\n\n(* Types and Functions *)\ntype secretKey.\ntype publicKey.\ntype did.\n\nfun pk(secretKey): publicKey.     (* Public Key derivation *)\nfun aenc(bitstring, publicKey): bitstring.  (* Asymmetric encryption *)\nfun adec(bitstring, secretKey): bitstring.  (* Asymmetric decryption *)\nfun sig(bitstring, secretKey): bitstring.   (* Digital signature *)\nfun verify(bitstring, bitstring, publicKey): bool. (* Verify signature *)\nfun genDID(publicKey, secretKey): did.  (* DID generation *)\n\n(* Credentials *)\ntype claim.\ntype credential = (claim, bitstring). (* Pair of claims and their signature *)\n\n(* Events *)\nevent auth_VerifierSendsLastMessageToProver().\nevent auth_ProverCompletesProtocol().\nevent auth_HolderSendsLastMessageToIssuer().\nevent auth_IssuerCompletesProtocol().\n\n(* Processes for Roles *)\n\n(* Issuer Role *)\nlet Issuer(skI: secretKey, pkH: publicKey, pkP: publicKey, c: claim) =\n    let cred : credential = (c, sig(c, skI)) in\n    event auth_IssuerCompletesProtocol();\n    output(ch_Issuer_Holder, aenc(cred, pkH)).\n\n(* Holder Role *)\nlet Holder(skH: secretKey, pkI: publicKey, c: claim) =\n    in(ch_Issuer_Holder, enc_cred: bitstring);\n    let cred = adec(enc_cred, skH) in\n    let valid = verify(fst(cred), snd(cred), pkI) in\n    if valid then\n        event auth_HolderSendsLastMessageToIssuer();\n        (* Further actions such as presenting to Verifier *)\n\n(* Verifier Role *)\nlet Verifier(pkH: publicKey, pkP: publicKey) =\n    (* Implement challenge-response mechanism with Holder *)\n\n(* Prover Role *)\nlet Prover(pkV: publicKey) =\n    (* Engage in the protocol with Verifier and complete it *)\n    event auth_ProverCompletesProtocol().\n\n(* Initializations and Protocol Execution *)\n\nnew skI: secretKey.\nnew skH: secretKey.\nnew skP: secretKey.\nlet pkI = pk(skI).\nlet pkH = pk(skH).\nlet pkP = pk(skP).\nlet didI = genDID(pkI, skI).\nlet didH = genDID(pkH, skH).\n\n(* Role Deployment *)\nparallel\n    (Issuer(skI, pkH, pkP, claim1) | Holder(skH, pkI, claim1))"]], "PV-1/sissy_multiparty_agreement_dh.pv": [[true, "(* Declare types for keys and identifiers *)\ntype SecretKey.\ntype PublicKey.\ntype SymmetricKey.\ntype DID.\ntype Credential.\ntype AccessToken.\n\n(* Declare functions for cryptographic operations *)\nfun enc(bitstring, SymmetricKey): bitstring.\nfun dec(bitstring, SymmetricKey): bitstring.\nfun asymEnc(bitstring, PublicKey): bitstring.\nfun asymDec(bitstring, SecretKey): bitstring.\nfun sign(bitstring, SecretKey): bitstring.\nfun verify(bitstring, bitstring, PublicKey): bool.\n\n(* Declare hash functions *)\nfun h1(bitstring): bitstring.\nfun h2(bitstring): bitstring.\n\n(* Declare constants for secret data *)\nfree sk_issuer: SecretKey.\nfree pk_issuer: PublicKey.\nfree sk_holder: SecretKey.\nfree pk_holder: PublicKey.\nfree sk_verifier: SecretKey.\nfree pk_verifier: PublicKey.\n\n(* Define the attacker *)\nfree c: channel [private].\n\n(* Roles *)\n\n(* Holder/Prover Process *)\nprocess\n    let prover(did: DID; symKey: SymmetricKey) =\n        (* Message 1: Send handshake request to Issuer *)\n        out(c, (did, symKey));\n\n        (* Receive handshake response from Issuer *)\n        in(c, (challenge: bitstring, signature: bitstring));\n\n        (* Validate signature *)\n        if verify(challenge, signature, pk_issuer) then\n            (* Generate a signed DID and send with credential *)\n            let signed_did = sign(did, sk_holder) in\n            out(c, (signed_did, challenge));\n            \n            (* Receive access token from Verifier *)\n            in(c, access_token: AccessToken)\n        else\n            (* Abort if verification fails *)\n            0\n    in\n    prover(nil, newkey).\n\n(* Issuer Process *)\nprocess\n    let issuer(secretKey: SecretKey; publicKey: PublicKey) =\n        (* Receive handshake request *)\n        in(c, (req_did: DID, symKey: SymmetricKey));\n\n        (* Generate challenge and sign it *)\n        let challenge = h1(req_did) in\n        let signed_challenge = sign(challenge, sk_issuer) in\n\n        (* Message 2: Send response with challenge and signature *)\n        out(c, (challenge, signed_challenge))\n    in\n    issuer(sk_issuer, pk_issuer).\n\n(* Verifier Process *)\nprocess\n    let verifier(secretKey: SecretKey; publicKey: PublicKey) =\n        (* Message 3: Receive signed credential and DID from Holder *)\n        in(c, (signed_did: bitstring, credential: Credential));\n\n        (* Verify the signature on the DID *)\n        if verify(signed_did, h1(credential), pk_holder) then\n            (* Generate and send an access token *)\n            let access_token = h2(signed_did) in\n            out(c, access_token)\n        else\n            (* Fail if verification is not correct *)\n            0\n    in\n    verifier(sk_verifier, pk_verifier).\n\n(* Queries for secrecy and authentication *)\nquery attacker: bitstring.\nquery attacker: SymmetricKey.\nquery attacker: SecretKey.\nquery attacker: PublicKey.\nquery attacker: DID.\nquery commit(Holder, Verifier, did: DID, signed_did: bitstring).\nquery inj-event(Begin(did)) ==> inj-event(End(did)."]], "PV-1/Skeme-proba.pv": [[true, "(* PV Formal Analysis Code for Secure Key Exchange Protocol *)\n\n(* Types *)\nfree type public_key.\nfree type secret_key.\nfree type nonce.\nfree type exponent.\nfree type shared_secret.\nfree type encrypted_message.\n\n(* Constants *)\nconst g: public_key.  (* Common base for Diffie-Hellman *)\n\n(* Functions *)\nfun pk(gen: secret_key): public_key.\nfun sk(): secret_key.\nfun exp(gen: exponent, b: public_key): public_key.\nfun enc(key: public_key, msg: encrypted_message): encrypted_message.\nfun dec(key: secret_key, msg: encrypted_message): encrypted_message.\nfun hash(msg: encrypted_message): nonce.\nfun keyed_hash(k: shared_secret, msg: encrypted_message): nonce.\nfun derive_key(exp1: exponent, exp2: exponent): shared_secret.\nfun enc_shared_secret(key: shared_secret, msg: encrypted_message): encrypted_message.\nfun dec_shared_secret(key: shared_secret, msg: encrypted_message): encrypted_message.\n\n(* Channel *)\nchannel c.\n\n(* Queries *)\nquery attacker(secretA).\nquery attacker(secretB).\nquery attacker(secretA, secretB).\n\n(* Protocol *)\nprocess\n  (* Initialization *)\n  let skA = sk() in\n  let pkA = pk(skA) in\n  let skB = sk() in\n  let pkB = pk(skB) in\n\n  out(c, (pkA, pkB));\n  \n  (* Alice's Actions *)\n  in(c, (pkB': public_key));\n  let x = sk() in\n  let gx = exp(x, g) in\n  let Ka = hash(pkA) in\n  let msgA = enc(pkB', (pkA, Ka, gx)) in\n  \n  out(c, msgA);\n  \n  (* Bob's Actions *)\n  in(c, msgA': encrypted_message);\n  let (pkA'', Ka', gx') = dec(skB, msgA') in\n  let y = sk() in\n  let gy = exp(y, g) in\n  let Kb = hash(pkB) in\n  let shared_key = derive_key(x, y) in\n  let hashB = keyed_hash(shared_key, msgA') in\n  let msgB = enc(pkA'', (Kb, gy, hashB)) in\n  \n  out(c, msgB);\n  \n  (* Alice Key Derivation and Secret Sending *)\n  in(c, msgB': encrypted_message);\n  let (Kb', gy', hashB') = dec(skA, msgB') in\n  if hashB' = keyed_hash(shared_key, msgA') then\n    let sh = derive_key(x, y) in\n    let secretA = sk() in\n    let msgSecretA = enc_shared_secret(sh, secretA) in\n    \n    out(c, msgSecretA);\n    \n    (* Bob Secret Verification and Sending *)\n    in(c, msgSecretA': encrypted_message);\n    let secretA' = dec_shared_secret(shared_key, msgSecretA') in\n    let secretB = sk() in\n    let msgSecretB = enc_shared_secret(sh, secretB) in\n    \n    out(c, msgSecretB)\n  else\n    (* Abort if hash does not match *)\n    0"]], "PV-1/cpa.pv": [[true, "free channelSetup, channelJoin, channelSign, channelVerify, channelOpen.\n\n(* Constants for cryptography *)\nconst secretUAKey : skey.\nconst publicUAKey : pkey.\nconst secretTTPKey : skey.\nconst publicTTPKey : pkey.\nconst spseq_pkey : pkey.\n\n(* Functions for cryptographic operations *)\nfun encrypt(m : bitstring, pk : pkey) : bitstring.\nfun decrypt(c : bitstring, sk : skey) : bitstring.\nfun sign(m : bitstring, sk : skey) : bitstring.\nfun verify(sig : bitstring, m : bitstring, pk : pkey) : bool.\nfun hash(m : bitstring) : bitstring.\nfun nizk_proof(data : bitstring) : bitstring.\nfun nizk_verify(proof : bitstring, data : bitstring) : bool.\n\n(* Events for tracking protocol actions *)\nevent sig_verified(spseq_pkey : pkey).\nevent sig_open(spseq_pkey : pkey).\n\n(* Protocol roles *)\nprocess !setupServer(channelSetup)\n    let spseq = spseq_pkey in\n    out(channelSetup, spseq);\n    out(channelSetup, (secretUAKey, publicUAKey));\n    out(channelSetup, (secretTTPKey, publicTTPKey)).\n\nprocess !userAgent(channelJoin, channelSign)\n    in(channelJoin, spseq);\n    let commitment = encrypt(\"random_data\", publicTTPKey) in\n    let signature = sign(commitment, secretUAKey) in\n    let proof = nizk_proof(\"random_data\") in\n    out(channelJoin, (commitment, signature, proof));\n    in(channelSign, ttpSignature);\n    let msg = \"message\" in\n    let signedMessage = sign(hash(msg), secretUAKey) in\n    out(channelSign, (msg, signedMessage)).\n\nprocess !trustedThirdParty(channelVerify, channelOpen)\n    in(channelVerify, (commitment, uaSignature, proof));\n    if (verify(uaSignature, commitment, publicUAKey) && nizk_verify(proof, \"random_data\")) then\n        out(channelVerify, sign(\"random_data\", secretTTPKey));\n        event sig_verified(spseq_pkey);\n    in(channelOpen, (msg, signedMessage));\n    if verify(signedMessage, hash(msg), publicUAKey) then\n        let decryptedMessage = decrypt(commitment, secretTTPKey) in\n        event sig_open(spseq_pkey).\n\n(* Safety properties as queries *)\nquery sig_verified(spseq_pkey) ==> attacker:msg : not true.\nquery attacker:msg : not sig_open(spseq_pkey)."]], "PV-1/sqrl.pv": [[true, "(* ProVerif model for the SQRL (Secure Quick Reliable Login) protocol *)\n\n(* Types *)\ntype credential.\ntype cookie.\ntype key.\ntype nonce.\n\n(* Cryptographic primitives *)\nfun senc(message: bitstring, key: key): bitstring.\nreduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.\n\nfun aenc(message: bitstring, publicKey: key): bitstring.\nreduc forall m: bitstring, privK: key; adec(aenc(m, pk(privK)), privK) = m.\n\nfun sign(message: bitstring, signingKey: key): bitstring.\nreduc forall m: bitstring, sKey: key; checksign(sign(m, sKey), spk(sKey)) = m.\n\nfun gencookie(credential: credential, nonce: nonce): cookie.\nreduc forall c: credential, n: nonce; getsecret(gencookie(c, n)) = n.\n\n(* Events *)\nevent CredentialSubmitted(credential).\nevent SessionAccepted(cookie).\nevent NonceForwarded(nonce).\n\n(* Processes *)\nprocess\n    (* User process *)\n    let user(cred: credential, nonce_u: nonce) =\n        out(c, senc(cred, symKey));  (* Encrypt credentials and send *)\n        event CredentialSubmitted(cred);\n        in(c, cookie_u: cookie);     (* Receive cookie from web service *)\n        out(c, cookie_u)             (* Send cookie to browser *)\n    in\n\n    (* Browser process *)\n    let browser() =\n        new nonce_b: nonce;          (* Generate nonce *)\n        event NonceForwarded(nonce_b);\n        in(c, encCred: bitstring);\n        out(c, encCred, nonce_b);    (* Forward encrypted credential and nonce *)\n        in(c, cookie_b: cookie);     (* Receive cookie from website *)\n        out(c, cookie_b)             (* Forward cookie to user *)\n    in\n\n    (* Website process *)\n    let website() =\n        in(c, encCred: bitstring, nonce_w: nonce);\n        let cred_w = sdec(encCred, symKey) in\n        let cookie_w = gencookie(cred_w, nonce_w) in\n        event SessionAccepted(cookie_w);\n        out(c, cookie_w)\n    in\n\n    (* Main process *)\n    (new symKey: key;      (* Shared symmetric key *)\n    (!user(cred, nonce_u) | !browser() | !website()))."]], "PV-1/ssb_handshake.pv": [[true, "// ProVerif Protocol Analysis Code\n\n// Declare our types\ntype hmac_key.\ntype sym_key.\ntype nonce.\ntype pk.\ntype sk.\n\n// Free variables and constants\nfree nonce0: nonce.\nfree failmsg: bitstring.\nconst zero: bitstring.\n\n// Define functions for key generation\nfun GenHMACKey(sk: sk, nonce: nonce): hmac_key.\nfun GenSymKey(ephemeral_sk: sk, ephemeral_pk: pk): sym_key.\nfun HashFunction(data: bitstring): bitstring.\nfun SignatureFunction(sk: sk, msg: bitstring): bitstring.\nfun HMAC(key: hmac_key, msg: bitstring): bitstring.\n\n// Declare channels\nchannel c.\n\n// Declare events\nevent ClientAccept(pk: pk).\nevent ServerAccept(pk: pk).\nevent ClientEndSession(pk: pk, hmac_key: hmac_key).\nevent ServerEndSession(pk: pk, hmac_key: hmac_key).\nevent ClientConfirmNetwork(hmac_key: hmac_key).\nevent ServerConfirmNetwork(hmac_key: hmac_key).\nevent Sentmessage(pk: pk, msg: bitstring).\nevent Receivedmessage(pk: pk, msg: bitstring).\n\n// Define Alice's process\nlet processAlice(skA: sk, pkA: pk, pkB: pk) =\n    let ephemeral_skA = new sk in\n    let ephemeral_pkA = new pk in\n    let hmacA = HMAC(GenHMACKey(skA, nonce0), ephemeral_pkA) in\n    out(c, (ephemeral_pkA, hmacA));\n    in(c, (ephemeral_pkB: pk, hmacB: bitstring));\n    if hmacB = HMAC(GenHMACKey(skB, zero), ephemeral_pkB) then\n        let sym_keyA = GenSymKey(ephemeral_skA, ephemeral_pkB) in\n        let msg_to_sign = HashFunction(sym_keyA) in\n        let signed_msg = SignatureFunction(skA, msg_to_sign) in\n        out(c, (signed_msg, sym_keyA));\n        in(c, confirmation: bitstring);\n        if confirmation = HashFunction(sym_keyA) then\n            event ClientEndSession(pkB, GenHMACKey(skA, nonce0))\n        else\n            event ClientAccept(pkB)\n    else\n        event ClientAccept(failmsg).\n\n// Define Bob's process\nlet processBob(skB: sk, pkB: pk, pkA: pk) =\n    in(c, (ephemeral_pkA: pk, hmacA: bitstring));\n    if hmacA = HMAC(GenHMACKey(skA, nonce0), ephemeral_pkA) then\n        let ephemeral_skB = new sk in\n        let ephemeral_pkB = new pk in\n        let hmacB = HMAC(GenHMACKey(skB, zero), ephemeral_pkB) in\n        out(c, (ephemeral_pkB, hmacB));\n        let sym_keyB = GenSymKey(ephemeral_skB, ephemeral_pkA) in\n        in(c, (signed_msg: bitstring, received_sym_key: sym_key));\n        if received_sym_key = sym_keyB && signed_msg = SignatureFunction(skA, HashFunction(sym_keyB)) then\n            event ServerEndSession(pkA, GenHMACKey(skB, zero));\n            let confirmation = HashFunction(sym_keyB) in\n            out(c, confirmation)\n        else\n            event ServerAccept(failmsg)\n    else\n        event ServerAccept(failmsg).\n\n// Full protocol composition\nprocess\n    new skA: sk; new pkA: pk;\n    new skB: sk; new pkB: pk;\n    (processAlice(skA, pkA, pkB) | processBob(skB, pkB, pkA)).\n\n// Security Queries\nquery attacker(skA).\nquery attacker(skB).\nquery attacker(hmac_key).\nquery attacker(sym_key).\nquery attacker(nonce0)."]], "PV-1/ssh-transport.pv": [[true, "(* --- Simplified SSH Protocol in Proverif --- *)\n\n(* Cryptographic primitives *)\nfun DHGenSecret(): DHSecret [data].\nfun DHGenPublic(DHSecret): DHPublic [data].\nfun DHSharedSecret(DHSecret, DHPublic): DHShared [data].\nfun SymmetricEncrypt(Key, Message): EncMsg [data].\nfun SymmetricDecrypt(Key, EncMsg): Message [data].\nfun MAC(Key, Message): Tag [data].\nfun Hash(Message): HashValue [data].\n\n(* Channels *)\nfree c: channel.\n\n(* Secret Data *)\nprivate free secretC: bitstring.\n\n(* Client Process *)\nlet processClient() =\n  (* Generate client DH secret and public key *)\n  new dhSecC: DHSecret;\n  let dhPubC = DHGenPublic(dhSecC) in\n  (* Send client's DH public key *)\n  out(c, dhPubC);\n  \n  (* Wait for server's response *)\n  in(c, (dhPubS: DHPublic, sigS: Tag));\n  \n  (* Compute shared secret and derive keys *)\n  let sharedSecretC = DHSharedSecret(dhSecC, dhPubS) in\n  let encKeyC = Hash(sharedSecretC) in\n  let macKeyC = Hash(Hash(sharedSecretC)) in\n  \n  (* Secure message exchange *)\n  let encSecretC = SymmetricEncrypt(encKeyC, secretC) in\n  let macSecretC = MAC(macKeyC, secretC) in\n  out(c, (encSecretC, macSecretC));\n\n  (* Verify server's authenticity (model as potential check) *)\n  (* Assume sigS is verified by some means, focusing on secrecy. *)\n\n  0.\n\n(* Server Process *)\nlet processServer() =\n  (* Receive client's DH public key *)\n  in(c, dhPubC: DHPublic);\n  \n  (* Generate server DH secret and public key *)\n  new dhSecS: DHSecret;\n  let dhPubS = DHGenPublic(dhSecS) in\n  (* Send server's DH public key and signature *)\n  let sigS = MAC(Hash(dhPubS), dhPubC) in\n  out(c, (dhPubS, sigS));\n  \n  (* Compute shared secret and derive keys *)\n  let sharedSecretS = DHSharedSecret(dhSecS, dhPubC) in\n  let encKeyS = Hash(sharedSecretS) in\n  let macKeyS = Hash(Hash(sharedSecretS)) in\n  \n  (* Secure message handling *)\n  in(c, (encSecretC: EncMsg, macSecretC: Tag));\n  let secretReceivedC = SymmetricDecrypt(encKeyS, encSecretC) in\n\n  (* Verify message authenticity *)\n  if macSecretC = MAC(macKeyS, secretReceivedC) then\n    (* Proceed with authenticated message *)\n    0\n  else\n    (* Abort on failure *)\n    0.\n\n(* Main process *)\nprocess\n  ( (!processClient()) | (!processServer()) ).\n\n(* Security Queries *)\nquery secretC: bitstring."]], "PV-1/tokenlemma.pv": [[true, "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n\n(* Types for keys and nonces *)\ntype key.\ntype nonce.\ntype nonce_G.\n\n(* Definition of a keyed hash function *)\nfun H(key, bitstring): key.\n\n(* Definition of the public communication channel *)\nfree c: channel. \n\n(* The main process that represents the described protocol logic *)\nprocess\n  new KR: key;  (* Generates a secret key *)\n  !\n  in(c, V: nonce_G);  (* Receiver waits for global nonce V from sender *)\n  new N: nonce;  (* Generates new nonce N *)\n  new t: key;  (* Generates a new key t *)\n  (* Sends either the new key or the hashed nonce pair *)\n  out(c, choice[t, H(KR, (N,V))])  \n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.016s (user 0.010s + system 0.005s), max rss 10052K\nEND *)"]], "PV-1/toy-counter.pv": [[true, "(* Counter-based Communication Protocol *)\n\nfree c: channel.\nfree s: bitstring [private].\n\nfun h(nat, bitstring): bitstring.\n\ntype stamp.\n\nfree id: stamp [private].\n\nevent Counter(channel, stamp, stamp, nat).\n\naxiom i: nat, i1: nat, st: stamp, st1: stamp, st2: stamp, d: channel;\n  event(Counter(d, st2, st, i1)) && event(Counter(d, st2, st, i)) ==> i1 = i;\n  event(Counter(d, st2, st, i1)) && event(Counter(d, st2, st1, i1)) ==> st = st1.\n\nquery attacker(s).\n\nprocess\n  new d: channel;\n  new k: bitstring;\n  (\n    !(\n      in(d, i: nat);\n      new st: stamp;\n      event Counter(d, id, st, i);\n      out(c, h(i, k));\n      out(d, i + 1)\n    ) | !(\n      in(d, i: nat);\n      new st: stamp;\n      event Counter(d, id, st, i);\n      in(c, y: bitstring);\n      if h(i, k) = y then\n        out(c, s);\n        out(d, i + 1)\n      else\n        out(d, i + 1)\n    )\n    | out(d, 0)\n    | ! in(d, x: nat); out(d, x)\n  )"]], "PV-1/toy-one-dec.pv": [[true, "(*************************************************************\n * Confidential Key Exchange Protocol\n *************************************************************)\n\n(* Free definitions for the channel and private variables *)\nfree c: channel.\nfree s: bitstring [private].  // Secret intended to be kept confidential\n\n(* Define cryptographic operations *)\nfun enc(bitstring, bitstring): bitstring.  // Encryption function\nreduc forall x: bitstring, y: bitstring; dec(enc(x, y), y) = x. // Decryption reduction rule\n\n(* Security query: Check if attacker can learn the secret `s` *)\nquery attacker(s).\n\n(* Process describing the protocol execution *)\nprocess\n  new k: bitstring;    // Session key generation\n  new k1: bitstring;   // First encryption key\n  new k2: bitstring;   // Second encryption key\n\n  (* Sender sends encrypted messages *)\n  out(c, enc(k1, k));  // Send session key `k` encrypted with key `k1`\n  out(c, enc(k2, k));  // Send session key `k` encrypted with key `k2`\n  out(c, enc(s, (k1, k2)));  // Send keys `k1` and `k2` encrypted with secret `s`\n\n  (* Receiver listens and processes the encrypted message *)\n  in(c, y: bitstring) [precise];  // Receive message on channel `c`\n  out(c, dec(y, k))              // Decrypt received message `y` using session key `k`"]], "PV-1/wmf-auth.pv": [[false, "```\npv\n(* Wide Mouth Frog Protocol in ProVerif *)\n\n(* Define types for keys and messages *)\ntype key.\ntype bitstring.\n\n(* Declare symmetric encryption and decryption functions *)\nfun encrypt(bitstring, key): bitstring.\nfun decrypt(bitstring, key): bitstring.\n\n(* Private channels for communication *)\nprivate channel c.\nprivate channel e.\n\n(* Predicates for keys *)\nfree private predicate new_key(key).\nprivate predicate valid_session_key(key, key).\n\n(* Free names for initial keys *)\nfree Kas: key.\nfree Ksb: key.\n\n(* Processes *)\n\nlet processA(Kas: key, M: bitstring) =\n    (* Generate session key *)\n    new Kab: key; \n    new_key(Kab) & \n    (* Encrypt message with session key *)\n    let EM = encrypt(M, Kab) in\n    (* Encrypt session key with Kas *)\n    let EKab = encrypt(Kab, Kas) in\n    (* Send encrypted session key and message to server *)\n    out(c, EKab);\n    out(c, EM).\n\nlet processS(Kas: key, Ksb: key) = \n    (* Receive encrypted session key from Alice *)\n    in(c, EKab: bitstring);\n    let Kab = decrypt(EKab, Kas) in\n    valid_session_key(Kab, Kas) &\n    (* Encrypt session key with Ksb for Bob *)\n    let EKabBob = encrypt(Kab, Ksb) in\n    out(c, EKabBob).\n\nlet processB(Ksb: key, M: bitstring) = \n    (* Receive encrypted session key from Server *)\n    in(c, EKabBob: bitstring);\n    let Kab = decrypt(EKabBob, Ksb) in \n    valid_session_key(Kab, Ksb) &\n    (* Receive encrypted message *)\n    in(c, EM: bitstring);\n    let decryptedM = decrypt(EM, Kab) in\n    (* Output choice between decrypted message and original *)\n    out(e, decryptedM).\n\n(* Main process to orchestrate protocol execution *)\nprocess main = \n    (* Receive initial message *)\n    in(c, M: bitstring);\n    (* Execute Alice's, Server's, and Bob's processes concurrently *)\n    (processA(Kas, M) | processS(Kas, Ksb) | processB(Ksb, M)).\n```"]], "PV-1/WooLamSK.pv": [[true, "free c, Kas, Kbs: channel.\n\n(* Types *)\ntype nonce.\ntype key.\ntype identity.\n\n(* Nonces *)\nnew Na: nonce.\nnew Nb: nonce.\n\n(* Shared keys *)\nlet keyKas = Kas in\nlet keyKbs = Kbs in\n\n(* Functions *)\nfun enc(m, k): bitstring.\nfun dec(m, k): bitstring.\n\n(* Events *)\nevent beginBparam(identity, identity).\nevent endBparam(identity, identity).\nevent beginBfull(identity, identity, nonce).\nevent endBfull(identity, identity, nonce).\n\n(* Queries *)\nquery inj-event(endBparam(x, y)) ==> inj-event(beginBparam(x, y)).\nquery inj-event(endBfull(x, y, z)) ==> inj-event(beginBfull(x, y, z)).\n\n(* Process Definitions *)\nlet processInitiator(A, B: identity) =\n    out(c, A);         (* Initiation: A sends its identity to B *)\n    in(c, Nb: nonce);  (* A receives nonce from B *)\n    let message = enc((A, B, Nb), keyKas) in\n    out(c, message).\n\nlet processResponder(B, S: identity) =\n    in(c, A: identity);              (* B receives A's identity *)\n    event beginBparam(A, B);\n    let Nb = new() in\n    out(c, Nb);                      (* Challenge: B sends nonce to A *)\n    in(c, encryptedMsg) >>           (* B receives encrypted message from A *)\n    let message = enc((A, B, encryptedMsg), keyKbs) in\n    out(c, message);                 (* Forward to server *)\n    event endBparam(A, B);\n    in(c, serverResponse);\n    let decryptedMsg = dec(serverResponse, keyKbs) in\n    if decryptedMsg == (A, B, Nb) then \n      event beginBfull(A, B, Nb);\n      event endBfull(A, B, Nb)\n\nlet processServer(S: identity) =\n    in(c, serverMsg) >> \n    let decryptedMsg = dec(serverMsg, keyKbs) in\n    let (A, B, innerEncMsg) = decryptedMsg in\n    let confirmMsg = dec(innerEncMsg, keyKas) in\n    out(c, enc(confirmMsg, keyKbs))\n\n(* Main process *)\nprocess\n    (new Kas: key;\n     new Kbs: key;\n     (!processInitiator(A, B) | !processResponder(B, S) | !processServer(S)))"]], "PV-1/yubikey.pv": [[true, "(* YubiKey Authentication Protocol Model in ProVerif *)\n\n(* Channels *)\nfree c, d_usr, d_srv: channel.\n\n(* Functions *)\nfun senc(bitstring, bitstring): bitstring.\nfun sdec(bitstring, bitstring): bitstring.\n\n(* Events *)\nevent Login(bitstring, bitstring, bitstring, bitstring).\nevent YubiPress(bitstring, bitstring, bitstring, bitstring).\n\n(* Free names: Keys and Identifiers *)\nfree k_usr, k_srv: bitstring.  (* User and Server symmetric keys *)\nfree uid: bitstring.           (* User ID *)\nfree secretid: bitstring.      (* Secret ID for YubiKey *)\n\n(* Processes *)\n\n(* Server Process *)\nprocess\n  let P_Server =\n    in(d_srv, (uid', OTP', ts'));                (* Receive from client: userID, OTP, timestamp *)\n    let msg = sdec(OTP', k_srv) in\n    let (nonce', tok') = msg in\n    if nonce' <= ts' then (\n      let counter' = increment(nonce') in\n      event Login(uid', k_srv, counter', ts');\n      out(d_srv, (counter', \"success\"))\n    ) else (\n      out(d_srv, (nonce', \"fail\"))\n    ).\n\n(* Button Press Process *)\nlet P_ButtonPress =\n  new nonce: bitstring;                     (* Generate a new nonce *)\n  new rand: bitstring;                      (* Generate a random number for the OTP *)\n  let OTP = senc((nonce, rand), k_usr) in\n  event YubiPress(uid, secretid, k_usr, nonce);\n  out(d_usr, OTP);\n  out(d_usr, nonce).\n\n(* YubiKey Process that coordinates the above *)\nlet P_Yubikey =\n  !(\n    in(c, uid);                             (* Initialize with user ID *)\n    in(c, secretid);                        (* Initialize with YubiKey secret ID *)\n    P_ButtonPress |\n    P_Server\n  ).\n\n(* Queries for Security Properties *)\n\n(* Property 1: If a login event occurs, a corresponding button press event should also occur. *)\nquery event(Login(x, y, z, w)) ==> event(YubiPress(x, secretid, y, z)).\n\n(* Property 2: No two successful authentication attempts should have the same attempt counter. *)\nquery not (inj-event(Login(x1, y1, z1, w1)) && inj-event(Login(x2, y2, z2, w2)) && (z1 = z2)).\n\n(* Run the protocol *)\nP_Yubikey."]], "PV-1/attack.pv": [[true, "(* Define a channel for communication *)\nfree c: channel.\n\n(* Define types for keys and seed *)\ntype pkey.\ntype skey.\ntype seed.\n\n(* Define deterministic public key encryption and decryption functions *)\nfun pk(skey): pkey.\nfun encrypt(bitstring, pkey): bitstring.\nreduc forall x: bitstring, y: skey; decrypt(encrypt(x, pk(y)), y) = x.\n\n(* Define a hash function *)\nfun hash(bitstring): bitstring.\n\n(* Declare the weak secret and its properties *)\nfree w: bitstring [private].\nweaksecret w.\n\n(* Define the process for key generation, encryption, and transmission *)\nprocess\n    new s: skey;\n    let pk = pk(s) in\n    out(c, pk);\n    out(c, encrypt(hash(w), pk))"]], "PV-1/denning-sacco-orig.horn": [[true, "(* Declaration of Types, Functions, and Tables *)\nfree channel c.\nprivate free skA, skB, skS: privkey.\nconst pkA: pubkey.\nconst pkB: pubkey.\nconst pkS: pubkey.\nfun encrypt(bitstring, pubkey): bitstring.\nfun sign(bitstring, privkey): bitstring.\n\n(* Axioms *)\naxiom forall x: bitstring, y: pubkey; decrypt(encrypt(x, y), y) = x.\naxiom forall x: bitstring, y: privkey; verify(x, sign(x, y), y) = true.\n\n(* Roles and Processes *)\n(* Client A Process *)\nprocess\n  new nonceA: bitstring;\n  out(c, (pkA, sign(nonceA, skA), encrypt(nonceA, pkS))); \n  in(c, x: bitstring);\n  verify(x, sign(x, skS), pkS);\n\n(* Client B Process *)\nprocess\n  new nonceB: bitstring;\n  out(c, (pkB, sign(nonceB, skB), encrypt(nonceB, pkS)));\n  in(c, y: bitstring);\n  verify(y, sign(y, skS), pkS);\n\n(* Server Process *)\nprocess\n  in(c, (pka: pubkey, sga: bitstring, encNa: bitstring));\n  let Na = decrypt(encNa, pka) in\n  if verify(Na, sga, pkA) then\n    new k: bitstring;\n    let secret = encrypt(k, pka) in\n    out(c, sign(secret, skS));\n\n  in(c, (pkb: pubkey, sgb: bitstring, encNb: bitstring));\n  let Nb = decrypt(encNb, pkb) in\n  if verify(Nb, sgb, pkB) then\n    let secretB = encrypt(k, pkb) in\n    out(c, sign(secretB, skS)).\n\n(* Security Goals *)\nquery attacker(k).\nquery attacker(nonceA).\nquery attacker(nonceB).\n\n(* End of Protocol Description *)"]], "PV-1/basicweaksecret-attack.pv": [[true, "(* Basic Weak Secret Protocol: Proverif Analysis *)\n\n(* Declarations of free names: *)\nfree skey, pkey, passwd, c.\nfree channel c.\n\n(* Type declarations *)\ntype skey.\ntype pkey.\ntype passwd.\ntype bitstring.\n\n(* Function declarations *)\nfun h(passwd): bitstring.\nfun pk(skey): pkey.\nfun penc(bitstring, pkey): bitstring.\nfun pdec(bitstring, skey): bitstring.\n\n(* Axioms for encryption and decryption *)\nequation pdec(penc(x, pk(y)), y) = x.\n\n(* Process definitions *)\n\n(* Protocol for generating and sending keys *)\nlet weak_secret_protocol = \n    new s: skey;            (* Generate new secret key *)\n    let pub_key = pk(s) in  (* Derive public key from secret key *)\n    out(c, pub_key);        (* Send public key over channel *)\n\n    new w: passwd;          (* Generate a weak secret: password *)\n    let hashed_passwd = h(w) in\n    let encrypted_passwd = penc(hashed_passwd, pub_key) in\n    out(c, encrypted_passwd)(* Send encrypted hashed password over channel *)\n    .\n\n(* Security analysis: weak secret w *)\nweaksecret w.\n\n(* Execution of the protocol *)\nprocess weak_secret_protocol."]], "PV-1/chebyshev_auth.pv": [[true, "(* Protocol Specification *)\n\n(* Types *)\ntype identity.\ntype password.\ntype biometric.\ntype nonce.\n\n(* Channels *)\nprivate channel ca.\nprivate channel cb.\nchannel cc.\n\n(* Constants for parties *)\nconst ID_i: identity.\nconst PW_i: password.\nconst Bio_i: biometric.\nconst SID_j: identity.\n\n(* Cryptographic Functions *)\nfun bhash(biometric): bitstring.\nfun hash(bitstring): bitstring.\nfun cheb(bitstring, sid_j: identity): bitstring.\nfun discheb(bitstring, sid_j: identity): bitstring.\n\n(* Events *)\nevent beginUi(id: identity).\nevent endUi(id: identity).\nevent beginSj(id: identity).\nevent endSj(id: identity).\n\n(* User Process *)\nprocessU(ca, cc) =\n    (* Registration *)\n    let nonce = new(nonce) in\n    let BioHash = bhash(Bio_i) in\n    let challengeC_i = hash(pair(PW_i, BioHash)) in\n    out(ca, pair(hash(ID_i), pair(challengeC_i, BioHash)));\n    \n    (* Login/Authentication *)\n    in(cc, sid_j: identity);\n    let sessionVal = cheb(ID_i, sid_j) in\n    out(cc, sessionVal);\n\n    (* Mutual Authentication *)\n    in(cc, response: bitstring);\n    let sessionKey = discheb(response, sid_j) in\n    event beginUi(ID_i);\n    out(cc, sessionKey);\n    event endUi(ID_i).\n\n(* Server Process *)\nprocessS(ca, cc) =\n    (* Authentication *)\n    in(ca, user_data: pair(bitstring, pair(bitstring, bitstring)));\n    let HID_i, pair(C_i, V_i) = user_data in\n    let expectedID = hash(ID_i) in\n    if HID_i = expectedID then\n        let serverChallenge = hash(pair(SID_j, V_i)) in\n        out(cc, serverChallenge);\n    (* Session Key Establishment *)\n    in(cc, userSessionValue: bitstring);\n    let sessionKeyS = discheb(userSessionValue, ID_i) in\n    out(cc, sessionKeyS);\n    event beginSj(SID_j);\n    event endSj(SID_j).\n\n(* Attacker Process Prototypes *)\nprocessRC(cb) =\n    (* Registration Attack *)\n    out(cb, pair(hash(\"fakeID\"), pair(\"fakeC_i\", \"fakeV_i\"))).\n\nprocessRCS(cb) =\n    (* Verification Attack *)\n    in(cb, integrityChallenge: bitstring);\n    out(cb, hash(pair(\"fakeSID_j\", integrityChallenge))).\n\n(* Security Queries *)\nquery attacker(ID_i).\nquery attacker(PW_i).\nquery attacker(Bio_i).\nquery attacker(sessionValue).\nquery endUi(ID_i) ==> beginUi(ID_i).\nquery endSj(SID_j) ==> beginSj(SID_j).\n\n(* Main Process *)\nprocess !processU(ca, cc) | !processS(ca, cc) | !processRC(cb) | !processRCS(cb)."]], "PV-1/conventional.pv": [[true, "(* Types *)\ntype name.\ntype bitstring.\n\n(* Channels *)\nfree pub: channel. // Public channel\nprivate orgout, affin, affout: channel.\n\n(* Functions *)\nfun hash: bitstring -> bitstring.\n\n(* Events *)\nevent clientSendName(name, bitstring).\nevent clientReceiveResponse(bitstring).\nevent orgOK(name).\nevent affReceivesMsg(bitstring).\n\n(* Security Goals *)\nquery attacker(name). // Confidentiality of Client Names\nquery clientSendName(name, bitstring) ==> clientReceiveResponse(bitstring). // Response Guarantee\nquery clientSendName(name, bitstring) ==> orgOK(name). // Message Integrity\n\n(* Process Definitions *)\nlet client(cName: name, valid: bool, op: bitstring) =\n  new n: name;\n  out(pub, cName);\n  if valid then\n    event clientSendName(cName, op);\n    out(affin, (n, op));\n    in(affout, n_r: bitstring);\n    event clientReceiveResponse(n_r)\n  else\n    event clientSendName(cName, op);\n    out(affin, (n, op)).\n\nlet organization(validName: name, op: bitstring) =\n  in(affin, msg: bitstring);\n  let (cName, opReq) = msg in\n  if cName = validName && opReq = op then\n    event orgOK(cName);\n    out(orgout, cName)\n  else\n    out(orgout, \"no policy found\").\n\nlet affiliate() =\n  in(orgout, policy: bitstring);\n  in(affin, msg: bitstring);\n  let (cName, op) = msg in\n  event affReceivesMsg(msg);\n  if policy = cName then\n    out(affout, \"success\")\n  else\n    out(affout, \"failure\").\n\n(* Initialization *)\nlet init() =\n  new op: bitstring;\n  new orgName: name;\n  new validName: name;\n  new invalidName: name;\n  ( !client(validName, true, op) | !client(invalidName, false, op) | !organization(validName, op) | !affiliate() ).\n\nprocess\n  init()"]], "PV-1/Denning-Sacco-CBC-alive.pv": [[true, "free c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun cbc_enc_1(bitstring, bitstring) : bitstring.\nfun cbc_enc_2(bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_3(bitstring, bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_4(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\n\nfun cbc_dec_1(bitstring, bitstring) : bitstring.\nfun cbc_dec_2(bitstring, bitstring, bitstring) : bitstring.\nfun cbc_dec_3(bitstring, bitstring, bitstring, bitstring) : bitstring.\nfun cbc_dec_4(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\n\nfun cbc_2_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_1_prefixes(bitstring) : bitstring.\nfun cbc_4_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_3_prefixes(bitstring) : bitstring.\n\nequation forall x, y; cbc_dec_1(cbc_enc_1(x, y), y) = x.\nequation forall x, y, z; cbc_dec_2(cbc_enc_2(x, y, z), y, z) = x.\nequation forall x, y, z, u; cbc_dec_3(cbc_enc_3(x, y, z, u), y, z, u) = x.\nequation forall x, y, z, u, v; cbc_dec_4(cbc_enc_4(x, y, z, u, v), y, z, u, v) = x.\n\nfree objective : bitstring [private].\n\nquery attacker(objective).\n\nlet client_B(Kbs : bitstring) =\n  new Nb : bitstring;\n  out(c, A);\n  in(c, M_enc : bitstring);\n  let M_dec = cbc_dec_3(M_enc, Kbs, Nb, I) in\n  let (A_received, Kab, T) = (cbc_3_get_1_prefixes(M_dec), cbc_3_get_2_prefixes(M_dec), M_dec) in\n  if A_received = A then\n    out(c, objective).\n\nlet server_S(Kas : bitstring, Kbs : bitstring) =\n  in(c, A_req : bitstring);\n  if A_req = A then\n    new Kab : bitstring;\n    new T : bitstring;\n    new Nb_rep : bitstring;\n    let M_enc = cbc_enc_3(A_req, Kab, T, Kbs) in\n    out(c, M_enc)\n  else\n    out(c, B).\n\nprocess\n  new Kas : bitstring;\n  new Kbs : bitstring;\n  ( client_B(Kbs)\n  | ! server_S(Kas, Kbs) )"]], "PV-1/DH.pv": [[true, "free c: channel.\nfree G, P: bitstring [public].  // Public Parameters\ntype message.\n\n(* Private values *)\nprivate Na: bitstring.  // A's private value\nprivate Nb: bitstring.  // B's private value\nprivate objective: message. // Objective message\n\n(* Cryptographic functions *)\nfun exp(bitstring, bitstring): bitstring.\nfun mod(bitstring, bitstring): bitstring.\nfun enc(message, bitstring): bitstring.\nfun dec(bitstring, bitstring): message.\n\n(* Attacker's abilities *)\nlet attacker = (new x: bitstring; out(c, x)).\n\n(* Protocol definition *)\n\nprocess\n  // Participant A\n  new Na: bitstring;\n  out(c, (P, G));\n  let A_value = mod(exp(G, Na), P) in\n  out(c, A_value);\n\n  // Participant B\n  in(c, (P, G));\n  new Nb: bitstring;\n  let B_value = mod(exp(G, Nb), P) in\n  out(c, B_value);\n\n  // A computes session key and sends encrypted objective\n  in(c, B_value);\n  let s_A = mod(exp(B_value, Na), P) in\n  let enc_obj = enc(objective, s_A) in\n  out(c, enc_obj);\n\n  // B computes session key but no further communication\n  in(c, A_value);\n  let s_B = mod(exp(A_value, Nb), P) in\n  out(c, ()).\n\n(* Security objective: confidentiality of the objective message *)\nquery attacker(c).\nquery attacker(objective).\nquery attacker(enc_obj)."]], "PV-1/dualneedham.horn": [[true, "/* Defining the cryptographic primitives used */\nfree public_key : sk -> pk.\nfree crypt : pk * message -> ciphertext.\nfree decrypt : sk * ciphertext -> message.\n\n/* Types for secrets and nonces */\ntype secret.\ntype nonce.\n\n/* Participants */\nconst Alice, Bob : agent.\nconst Attacker : attacker.\n\n/* Secret sharing predicates */\npred secret_shared_A_to_B : nonce * nonce * secret.\npred secret_shared_B_to_A : nonce * nonce * secret.\n\n/* Protocol's messages */\nmodule protocol.\n  /* Initialization of public keys */\n  new sA : sk; event alice_key_gen.\n  new sB : sk; event bob_key_gen.\n  let pkA = public_key(sA).\n  let pkB = public_key(sB).\n\n  /* Attacker can access public keys */\n  out (Attacker, pkA).\n  out (Attacker, pkB).\n\n  /* Protocol Steps */\n  step Initialization.\n    in (Alice, pkA).\n    in (Bob, pkB).\n  \n  step A_to_B.\n    new Na : nonce; event a_nonce_gen.\n    out (Alice, crypt(pkB, (Na, pkA))).\n  \n  step B_to_A.\n    in (Bob, crypt(pkB, (Na, pkA))).\n    new Nb : nonce; event b_nonce_gen.\n    out (Bob, crypt(pkA, (Nb, pkB))).\n    let shared_secret = secret_shared_A_to_B(Na, Nb, secret).\n  \n  step A_to_B_Final.\n    in (Alice, crypt(pkA, (Nb, pkB))).\n    out (Alice, crypt(pkB, (Na, Nb, shared_secret))).\n  \n  step B_to_A_Final.\n    in (Bob, crypt(pkB, (Na, Nb, shared_secret))).\n    out (Bob, crypt(pkA, (Nb, shared_secretb))).\n    let secret_confirmed = secret_shared_B_to_A(Nb, Na, secretb).\n\n/* Security queries */\nquery secret_shared_A_to_B(Na, Nb, secret) ==> not attacker(secret).\nquery secret_shared_B_to_A(Nb, Na, secretb) ==> not attacker(secretb)."]], "PV-1/epassportUK_processes.pv": [[true, "(* ePassport Protocol in ProVerif *)\n\n(* Free names *)\nfree c : channel. (* Public channel for communication *)\nfree c_k : channel [private]. (* Private session channel *)\nfree d_k : channel [private]. (* Key management channel *)\n\n(* Types *)\ntype bitstring.\n\n(* Cryptographic primitives *)\nfun enc(bitstring, bitstring): bitstring. (* Symmetric encryption *)\nfun mac(bitstring, bitstring): bitstring. (* Message authentication code *)\n\n(* Symmetric decryption reduction *)\nreduc decrypt(enc(m, k), k) = m.\n\n(* Predefined messages *)\nconst get_challenge : bitstring.\nconst error_6A80 : bitstring.\nconst error : bitstring. (* Private error message *)\n\n(* Variables *)\nlet reader(nr: bitstring, kr: bitstring, ke: bitstring) =\n    c_k(get_challenge); (* Send challenge *)\n    in(c_k, nt: bitstring); (* Receive nonce from passport *)\n    let enc_data = enc(pair(pair(nr, kr), nt), ke) in\n    let mac_data = mac(enc_data, ke) in\n    c_k(pair(enc_data, mac_data)). (* Send encrypted message and MAC *)\n\nlet passport(nt: bitstring, kt: bitstring, ke: bitstring) =\n    out(c_k, nt); (* Send nonce response *)\n    in(c_k, pair(enc_data: bitstring, mac_data: bitstring));\n    let mac_check = mac(enc_data, ke) in\n    if mac_data = mac_check then\n      let pair(pair(nr: bitstring, kr: bitstring), nt_check: bitstring) = decrypt(enc_data, ke) in\n      if nt_check = nt then\n          let response_enc = enc(pair(pair(nr, kr), kt), ke) in\n          let response_mac = mac(response_enc, ke) in\n          c_k(pair(response_enc, response_mac)) (* Send new session details *)\n      else out(d_k, error_6A80)\n    else out(d_k, error).\n\n(* Process *)\nlet reader_proc =\n    new nr: bitstring; (* Generate nonce *)\n    new kr: bitstring; (* Generate key *)\n    new ke: bitstring; (* Generate session key *)\n    reader(nr, kr, ke).\n\nlet passport_proc =\n    new nt: bitstring; (* Generate nonce *)\n    new kt: bitstring; (* Generate session key *)\n    new ke: bitstring; (* Generate session key *)\n    passport(nt, kt, ke).\n\nprocess\n    (!reader_proc | !passport_proc)"]], "PV-1/Forward.pv": [[true, "(* Protocol Description *)\n\n(* Types *)\ntype pubKey.\ntype secKey.\ntype random.\ntype ciphertext.\ntype sharedKey.\n\n(* Functions *)\nfun Encaps(pubKey, random): ciphertext.\nfun DecapsKey(secKey, ciphertext): sharedKey.\nfun KEMkey(sharedKey): sharedKey.\nfun KEMCipher(ciphertext): ciphertext.\n\n(* Channels *)\nprivate channel sch.\nchannel usch.\n\n(* Events *)\nevent UESendConSN().\nevent UERecResSN().\nevent SNRecReqUE().\nevent SNSendReqHN().\nevent HNRecConSN().\n\n(* User Equipment Process *)\nlet proc_UE(pubKeyHN: pubKey, secretUE: secKey, pubKeySN: pubKey) =\n  new r: random;\n  let c = Encaps(pubKeyHN, r) in\n  out(usch, (c, pubKeySN, pubKeyHN));\n  in(usch, (c2: ciphertext, mac: sharedKey));\n  let k = DecapsKey(secretUE, c2) in\n  if k = mac then\n    let sessionKey = KEMkey(k) in\n    event UERecResSN();\n    out(usch, sessionKey);\n    event UESendConSN()\n  else\n    0.\n\n(* Serving Network Process *)\nlet proc_SN(secretSN: secKey, pubKeyHN: pubKey) =\n  in(usch, (c: ciphertext, pubKeySN: pubKey, pubKeyHN2: pubKey));\n  event SNRecReqUE();\n  out(sch, (c, pubKeySN, pubKeyHN2));\n  in(sch, (c2: ciphertext, mac: sharedKey));\n  out(usch, (c2, mac)).\n\n(* Home Network Process *)\nlet proc_HN(secretHN: secKey) =\n  in(sch, (c: ciphertext, pubKeySN: pubKey, pubKeyHN: pubKey));\n  let k = DecapsKey(secretHN, c) in\n  let mac = KEMkey(k) in\n  event HNRecConSN();\n  out(sch, (c, mac)).\n\n(* Protocol Execution *)\nprocess\n  new secretHN: secKey;\n  new secretSN: secKey;\n  new secretUE: secKey;\n  new pubKeyHN: pubKey;\n  new pubKeySN: pubKey;\n  proc_UE(pubKeyHN, secretUE, pubKeySN) |\n  proc_SN(secretSN, pubKeyHN) |\n  proc_HN(secretHN).\n\n(* Queries *)\nquery attacker(secretUE).\nquery attacker(secretHN).\nquery attacker(secretSN).\nquery attacker(pubKeySN).\nquery attacker(pubKeyHN).\n\nquery event(UERecResSN()) ==> event(SNRecReqUE()).\nquery event(SNRecReqUE()) ==> event(SNSendReqHN()).\nquery event(SNSendReqHN()) ==> event(HNRecConSN()).\nquery event(HNRecConSN()) ==> event(UERecResSN())."]], "PV-1/handshake-3.pv": [[true, "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Handshake protocol.\n   Inspired by Delaune, Jacquemard, CSFW'04\n*)\n\ntype passwd.\ntype nonce.\n\n(* Cryptographic functions and equations *)\n\nfun encrypt(nonce, passwd): nonce.\nfun decrypt(nonce, passwd): nonce.\nequation forall x: nonce, y: passwd; decrypt(encrypt(x,y),y) = x.\nequation forall x: nonce, y: passwd; encrypt(decrypt(x,y),y) = x.\n\n(* Function to increment nonce *)\n\nfun incr(nonce): nonce.\n\n(* Communication channel *)\n\nfree c: channel.\nfree pw: passwd [private].\nweaksecret pw.\n\n(* Process A (Alice): Generates nonce, encrypts it, sends over channel *)\n\nlet processA = \n  new N: nonce;\n  out(c, encrypt(N, pw)).\n\n(* Process B (Bob): Receives, decrypts, increments nonce, sends back *)\n\nlet processB = \n  in(c, x: nonce);\n  let n = decrypt(x, pw) in\n  let n' = incr(n) in\n  out(c, encrypt(n', pw)).\n    \n(* Define the parallel composition of processes *)\n\nprocess\n  (!processA)\n  |\n  (!processB)\n\n(* Security analysis result expectation *)\n\n(* EXPECTPV\nRESULT Weak secret pw is false.\n0.016s (user 0.012s + system 0.004s), max rss 10296K\nEND *)"]], "PV-1/handshake_smallsubgroup.pv": [[true, "(* ProVerif code for Scuttlebutt Handshake Protocol *)\n\n(* Types *)\ntype hmac_key.\ntype sym_key.\ntype nonce.\ntype sk.\ntype pk.\n\n(* Free names and variables *)\nfree skA: sk [private].\nfree skB: sk [private].\nfree pkA: pk.\nfree pkB: pk.\nfree c: channel.\n\nprivate free attackerSk: sk.\n\n(* Functions *)\nfun dhexchange(sk, pk): pk.\nfun hmac(nonce, pk, hmac_key): hmac_key.\nfun sign(sk, nonce, pk): hmac_key.\n\n(* Events *)\nevent StartHandshake(nonce: nonce).\nevent NetworkConfirm(nonce: nonce, pkA: pk, pkB: pk).\nevent MessageVerified(nonce: nonce, pkA: pk, pkB: pk).\n\n(* Process definitions *)\nlet alice(skA: sk, pkA: pk, nonce: nonce) = \n  new ephemeral_skA: sk;\n  let ephemeral_pkA = dhexchange(ephemeral_skA, pkB) in\n  let message_1 = (ephemeral_pkA, hmac(nonce, ephemeral_pkA, skA)) in \n  output(c, message_1);\n  input(c, message_2);\n  let (ephemeral_pkB, hmacResponse) = message_2 in\n  if hmacResponse = hmac(nonce, ephemeral_pkB, skA) then\n    event NetworkConfirm(nonce, pkA, pkB);\n    let shared_key = dhexchange(ephemeral_skA, ephemeral_pkB) in\n    let signature_A = sign(skA, nonce, pkB) in\n    let encrypted_signature = sym_encrypt(signature_A, pkA, shared_key) in\n    output(c, encrypted_signature)\n  else\n    0.\n\nlet bob(skB: sk, pkB: pk, nonce: nonce) =\n  input(c, message_1);\n  let (ephemeral_pkA, hmacRequest) = message_1 in\n  if hmacRequest = hmac(nonce, ephemeral_pkA, skB) then\n    new ephemeral_skB: sk;\n    let ephemeral_pkB = dhexchange(ephemeral_skB, pkA) in\n    let message_2 = (ephemeral_pkB, hmac(nonce, ephemeral_pkB, skB)) in \n    output(c, message_2);\n    input(c, encrypted_signature);\n    let shared_key = dhexchange(ephemeral_skB, ephemeral_pkA) in\n    let signature_A = sym_decrypt(encrypted_signature, pkA, shared_key) in\n    if verify(signature_A, pkA, nonce, pkB) then\n      event MessageVerified(nonce, pkA, pkB)\n    else\n      0.\n  else\n    0.\n\nprocess\n  (!alice(skA, pkA, N) | !bob(skB, pkB, N))"]], "PV-1/denning-sacco-orig.horntype": [[true, "% Type Definitions\ntype host [data].\ntype pkey [data].\ntype skey [data].\ntype key [data].\n\n% Function Definitions\nfun key_to_bitstring : key -> bitstring.\nfun encrypt : bitstring, pkey -> bitstring.\nfun sencrypt : bitstring, key -> bitstring.\nfun sign : bitstring, skey -> bitstring.\nfun verify : bitstring, bitstring, pkey -> bitstring.\n\n% Participants\nconst Alice : host.\nconst Bob : host.\nconst Server : host.\n\n% Public and Secret Keys\nconst pkA : pkey.\nconst pkB : pkey.\nconst pkS : pkey.\nconst skA : skey.\nconst skB : skey.\nconst skS : skey.\n\n% Confidential Value (Secret)\nconst secret : bitstring.\n\n% Actor\ntable knows_host : host.\ntable knows_pkey : pkey.\ntable knows_skey : skey.\n\n% Initial Knowledge\nclause knows_pkey(Alice, pkA).\nclause knows_pkey(Bob, pkB).\nclause knows_pkey(Server, pkS).\nclause knows_host(Alice).\nclause knows_host(Bob).\nclause knows_host(Server).\n\n% Protocol Steps\n\n% Alice Authentication\nclause knows(Alice, sign(key_to_bitstring(pkA), skA)) ==> knows(Server, sign(key_to_bitstring(pkA), skA)).\n\n% Server Verification and Forwarding\nclause knows(Server, sign(key_to_bitstring(pkA), skA)) \n    && knows_pkey(Alice, pkA) \n    && verify(sign(key_to_bitstring(pkA), skA), key_to_bitstring(pkA), pkA) = result \n    && result == true \n    ==> knows(Server, sign(key_to_bitstring(pkB), skS)).\n\n% Bob Authentication\nclause knows(Server, sign(key_to_bitstring(pkB), skS)) \n    ==> knows(Bob, sign(key_to_bitstring(pkB), skS)).\n\n% Bob Verification\nclause knows(Bob, sign(key_to_bitstring(pkB), skS))\n    && knows_pkey(Server, pkS)\n    && verify(sign(key_to_bitstring(pkB), skS), key_to_bitstring(pkB), pkS) = result \n    && result == true \n    ==> knows(Bob, sencrypt(secret, xk)).\n\n% Server sends secret securely\nclause knows(Server, sencrypt(secret, xk)) \n    ==> knows(Bob, sencrypt(secret, xk)).\n\n% Security Goals\n\n% Confidentiality of secret\nquery attacker(secret) => false.\n\n% Authentication of Alice to Bob and Bob to Alice\nquery knows(Bob, sign(key_to_bitstring(pkA), skA)) => knows(Bob, pkA).\nquery knows(Alice, sign(key_to_bitstring(pkB), skB)) => knows(Alice, pkB).\n\n% Integrity\nquery knows(Alice, result) => knows(Server, result).\nquery knows(Bob, result) => knows(Server, result)."]], "PV-1/hash.pv": [[true, "(* Name: OTP Protocol Analysis *)\n\n(* Types *)\ntype natural [large]\ntype bitstring\n\n(* Constants *)\nconst seed: bitstring\nconst initial_value: natural = 3\n\n(* Function symbols *)\nfun hash(bitstring): bitstring\n\n(* Channels *)\nprivate channel t1: natural\nprivate channel t2: natural * bitstring\n\n(* Events *)\nevent COL\n\n(* Processes *)\n\n(* Process Initialization *)\nlet process_initialization =\n  out(t1, initial_value)\n\n(* Process Key Generation *)\nlet rec process_key_generation(seed: bitstring) =\n  in(t1, x2:natural);\n  let x3 = x2 - 1 in\n  if x3 != 0 then\n    out(t1, x3);\n    in(t2, x4:natural, sk:bitstring);\n    if x4 = x3 then\n      let otp3 = hash(sk) in\n      if otp3 = hash(hash(hash(seed))) then\n        event COL\n      else\n        0\n    else\n      let otp_seed = hash(seed) in\n      out(t2, x2, otp_seed)\n  else\n    0\n\n(* Execution *)\nlet main =\n  process_initialization |\n  !process_key_generation(seed)\n\n(* Queries *)\nquery event(COL)"]], "PV-1/hello.pv": [[true, "(* protocol.pv *)\n\nfree c : channel .\n\nfree Cocks : bitstring [ private ] .\nfree RSA : bitstring [ private ] .\n\nquery attacker(RSA) .\nquery attacker(Cocks) .\n\nprocess\n  out(c, RSA);  (* Outputting RSA key to channel c *)\n  0             (* Termination of protocol *)"]], "PV-1/invites.pv": [[true, "free c: channel.\nfree skA, skB: skey.\nfree pkA, pkB: pkey.\nfree hmac_key: bitstring.\nfree secret1, secret2: bitstring.\nfree N: nonceType.\n\n(* Cryptographic primitives *)\nfun pk(skey): pkey.\nfun hmac(bitstring, bitstring): bitstring.\nfun hash(bitstring, bitstring, nonceType): bitstring.\nfun sign(bitstring, skey): bitstring.\nfun verify(bitstring, bitstring, pkey): bool.\nfun encrypt(bitstring, bitstring): bitstring.\nfun decrypt(bitstring, bitstring): bitstring.\n\n(* Events *)\nevent ServerConfirmNetwork.\nevent ServerAccept.\nevent ClientEndSession.\nevent ServerEndSession.\n\n(* Alice's behavior *)\nlet alice =\n  new ephemeral_skA: skey;\n  let ephemeral_pkA = pk(ephemeral_skA) in\n  let m1 = (ephemeral_pkA, hmac(ephemeral_pkA, N)) in\n  out(c, m1);\n  in(c, (pkB_respond: pkey, signature_respond: bitstring));\n  if verify(signature_respond, N, pkB_respond) then\n    event ServerConfirmNetwork;\n    let key1 = hash(shared_secret(ephemeral_skA, pk(ephemeral_skB)), N) in\n    let key2 = hash(shared_secret(ephemeral_skA, pkB), N) in\n    let encrypted_message = encrypt((N, pkB, secret1), key1) in\n    let signed_and_encrypted_message = encrypt(sign(encrypted_message, skA), key1) in\n    out(c, signed_and_encrypted_message);\n    event ClientEndSession.\n\n(* Bob's behavior *)\nlet bob =\n  in(c, (ephemeral_pkA: pkey, hmac_received: bitstring));\n  if hmac(ephemeral_pkA, N) = hmac_received then\n    let key_response = hash(shared_secret(skB, ephemeral_pkA), N) in\n    let ephemeral_skB = new skey in\n    let ephemeral_pkB = pk(ephemeral_skB) in\n    let signature_response = sign(N, skB) in\n    let response_message = (ephemeral_pkB, signature_response) in\n    out(c, response_message);\n    event ServerAccept;\n    let encrypted_message_received = decrypt(in(c, _), key_response) in\n    let (nonce_received, pkB_received, shared_secret_received) = decrypt(encrypted_message_received, key_response) in\n    if nonce_received = N then\n      event ServerEndSession.\n\nprocess\n  (!alice | !bob)"]], "PV-1/jfktest.pi": [[true, "(* JFKr Protocol in Proverif *)\n\n(* Types *)\ntype key.\ntype message.\n\n(* Functions *)\nfun exp(g: key, x: key): key.\nfun S(k: key, m: message): message.  (* Signature function *)\nfun Pk(k: key): key.                 (* Public key derivation *)\nfun E(k: key, m: message): message.  (* Encryption *)\nfun D(k: key, c: message): message.  (* Decryption *)\nfun H(m: message): key.              (* Hash function *)\n\n(* Events *)\nevent begin_initiator(A: name, B: name).\nevent end_initiator(A: name, B: name).\nevent begin_responder(B: name, A: name).\nevent end_responder(B: name, A: name).\n\n(* Private key of Alice and Bob *)\nprivate free Ka : key.\nprivate free Kr : key.\n\n(* Protocol roles *)\nprocess\n  (* Initiator *)\n  let initiator(A: name, B: name, kI: key) =\n    out(c, (A, B, Pk(kI)));        (* Send public identity *)\n    in(c, (B, nB: key, XB: key));\n    let NA = new() in\n    let YA = exp(g, NA) in\n    let KA = H(XB, YA) in\n    let sigA = S(kI, (A, B, NA, XB)) in\n    out(c, (YA, sigA, E(KA, NA))).\n\n  (* Responder *)\n  let responder(B: name, A: name, kR: key) =\n    in(c, (A, B, XA: key));\n    let NB = new() in\n    let YB = exp(g, NB) in\n    let KB = H(XA, YB) in\n    let sigB = S(kR, (B, A, NB, XA)) in\n    out(c, (B, NB, YB, sigB));\n    in(c, (YA: key, sigA: message, cA: message));\n    let KA = H(XA, YA) in\n    let decNA = D(KA, cA) in\n    let sigCheck = S(Pk(kR), (A, B, decNA, XA)) =? sigA in\n    if sigCheck then\n      event end_responder(B, A)\n    else\n      0.\n\n(* Initial processes *)\nprocess\n  !new A: name; new B: name; \n  (!initiator(A, B, Ka) | !responder(B, A, Kr))  (* Parallel composition of roles *)"]], "PV-1/kerberos-gl3.pi": [[true, "// Declaration of free names\nfree c: channel.\nfree pk_S: public_key.\nfree sk_S: secret_key.\nfree pk_A: public_key.\nfree sk_A: secret_key.\nfree pk_B: public_key.\nfree sk_B: secret_key.\n\n// Declaration of cryptographic primitives\nlet enc(x: bitstring, k: symmetric_key) = symmetric_encryption(x, k).\nlet dec(x: bitstring, k: symmetric_key) = symmetric_decryption(x, k).\nlet penc(x: bitstring, pk: public_key) = public_key_encryption(x, pk).\nlet pdec(x: bitstring, sk: secret_key) = public_key_decryption(x, sk).\nlet pair(x: bitstring, y: bitstring) = pair(x, y).\nlet triple(x: bitstring, y: bitstring, z: bitstring) = triple(x, y, z).\n\n// Client A process\nprocess hostA = \n  in(c, x: bitstring);\n  new N1: bitstring;\n  new N2: bitstring;\n  let messageA = triple(\"ClientA\", \"hostX\", pair(N1, N2)) in\n  let encryptedMessage = penc(messageA, pk_S) in\n  out(c, encryptedMessage);\n  in(c, encryptedResponse: bitstring);\n  let decryptedResponse = pdec(encryptedResponse, sk_A) in\n  if decryptedResponse = pair(N1, \"SessionKey\") then\n    let K = \"SessionKey\" in\n    out(c, enc(\"Completed\", K))\n  else\n    out(c, enc(\"Failure\", \"Error\")).\n\n// Client B process\nprocess hostB = \n  in(c, encryptedMessageB: bitstring);\n  let messageB = pdec(encryptedMessageB, sk_B) in\n  let (hostInfo, sessionKey) = pair(messageB) in\n  if hostInfo = \"ClientA\" then\n    out(c, enc(\"Acknowledged\", sessionKey))\n  else\n    out(c, enc(\"Failure\", \"Error\")).\n\n// Server S process\nprocess processS = \n  in(c, encryptedMessageS: bitstring);\n  let messageS = pdec(encryptedMessageS, sk_S) in\n  let (\"ClientA\", \"hostX\", (N1, N2)) = triple(messageS) in\n  new K: symmetric_key;\n  let responseA = pair(N1, K) in\n  let encryptedResponseA = penc(responseA, pk_A) in\n  out(c, encryptedResponseA);\n  let responseB = pair(\"ClientA\", K) in\n  let encryptedResponseB = penc(responseB, pk_B) in\n  out(c, encryptedResponseB).\n\n// Security properties\nquery attacker(weak_secret_PA).\nquery attacker(weak_secret_PB)."]], "PV-1/key-server.pv": [[true, "free A, pkT: bitstring.\nfree secret_bitstring: bitstring [private].\nprivate free skA, skS: bitstring.\nlet pkA = pk(skA).\nlet pkS = pk(skS).\n\n(* Cryptographic Functions *)\nfun sign(bitstring, bitstring): bitstring.\nfun checksign(bitstring, bitstring): bitstring.\nfun getmess(bitstring): bitstring.\nfun enc(bitstring, bitstring): bitstring.\nfun dec(bitstring, bitstring): bitstring.\nfun aenc(bitstring, bitstring): bitstring.\nfun adec(bitstring, bitstring): bitstring.\n\n(* Communication Channels *)\nchannel c.\n\n(* Tables *)\ntable keys: bitstring, bitstring.\n\n(* Protocol Description *)\n\nprocess\n  (* Initialization *)\n  out(keys, (A, pkA)) |\n\n  (* Client A's Communication *)\n  in(c, (A, T: bitstring));\n  new sigA: bitstring;\n  let signedMessage = sign((pkT, T), skS) in\n  out(c, signedMessage) |\n\n  (* Key Retrieval and Registration *)\n  in(c, (PK_dest: bitstring, ID_dest: bitstring));\n  if ID_dest <> A then\n    insert keys(ID_dest, PK_dest);\n    let signedKey = sign((PK_dest, ID_dest), skS) in\n    out(c, signedKey)\n  else\n    event identity_conflict(ID_dest) |\n\n  (* Security Objectives *)\n  query attacker(secret_bitstring)."]], "PV-1/keygen.pv": [[true, "(* Types *)\ntype StreamKey.\ntype CipherStream.\ntype SkipDone.\ntype Receiving_FS_AEAD_State.\n\n(* Channels *)\nprivate channel skip_chan(bitstring, bitstring, bitstring).\nchannel skip_done_chan(SkipDone).\n\n(* Functions *)\nfun con(bitstring, bitstring): bitstring.\nfun divhead(bitstring): bitstring.\nfun divrest(bitstring): bitstring.\nfun to_stream_key(bitstring): StreamKey.\nfun prg(StreamKey): bitstring.\n\n(* Events *)\nevent SkipDoneEvent().\n\n(* Tables *)\ntable fs_aead_table(nat, bitstring).\n\n(* Process Definitions *)\nlet skip() =\n  in(skip_chan, (i:bitstring, U:bitstring, st:bitstring));\n  if i <> 0 then\n    let s = prg(to_stream_key(st)) in\n    let new_st = divhead(s) in\n    let raw_key = divrest(s) in\n    insert fs_aead_table(i, raw_key);\n    out(skip_chan, (i - 1, U, new_st))\n  else\n    new doneInstance:SkipDone;\n    out(skip_done_chan, doneInstance);\n    event SkipDoneEvent().\n\n(* Initial Process *)\nlet init() =\n  new st:bitstring;\n  out(skip_chan, (3, 1, st));\n  skip().\n\n(* Queries *)\nquery event(SkipDoneEvent()).\n\nprocess\n  init()"]], "PV-1/NeedhamSchroederPK.pv": [[true, "(* Declaration of free names and channels *)\nfree pkA, pkB, skA, skB, skS: bitstring.\nfree A, B: bitstring.\nfree Na, Nb: bitstring.\nfree chA, chB, chS: channel.\n\n(* Declaration of cryptographic primitives *)\nfun encrypt/2.\nfun decrypt/2.\nfun sign/2.\nfun verify/2.\n\n(* Knowledge of the adversary: public keys and identities *)\n[=!pub]\nlet attackerKnowledge = [pkA, pkB, A, B].\n\n(* Processes *)\n\n(* Alice's process (Initiator) *)\nlet aliceProcess =\n    out(chS, (A, B));\n    in(chA, sign(pkB, B, skS));\n    let encryptedMessage = encrypt(Na, A, pkB) in\n    out(chB, encryptedMessage);\n    in(chA, encrypt(Na, Nb, pkA));\n    let decryptedNb = decrypt(encryptedMessage, skA) in\n    out(chB, encrypt(decryptedNb, pkB)).\n\n(* Bob's process (Responder) *)\nlet bobProcess =\n    in(chB, encrypt(Na, A, pkB));\n    out(chS, (B, A));\n    in(chB, sign(pkA, A, skS));\n    let encryptedMessage = encrypt(Na, Nb, pkA) in\n    out(chA, encryptedMessage);\n    in(chB, encrypt(Nb, pkB)),\n    let decryptedNb = decrypt(encryptedMessage, skB) in\n    event(secretEstablished(B, decryptedNb)).\n\n(* Server's process (Trusted third party) *)\nlet serverProcess =\n    in(chS, (A, B));\n    let signedReplyToAlice = sign(pkB, B, skS) in\n    out(chA, signedReplyToAlice);\n    in(chS, (B, A));\n    let signedReplyToBob = sign(pkA, A, skS) in\n    out(chB, signedReplyToBob).\n\n(* Parallel execution of Alice, Bob, and the Server processes *)\nprocess\n    (\n        !aliceProcess\n\t| !bobProcess\n\t| !serverProcess\n    )\n\n(* Security queries *)\n\nquery attacker(=Na).\nquery attacker(=Nb).\nquery event(secretEstablished(B, Nb))."]], "PV-1/nontermex.horn": [[true, "% Define the predicates and functions\npredicate c/1.\nfun f/1.\nfun g/1.\n\n% Initial fact\nfact c:f(s[]).\n\n% Specify no unification on specific term\nnounif c:f(x).\n\n% Reduction rule\nrule c:f(x) ==> c:f(g(x)).\n\n% Query to check reachability\nquery false.\n\n% Practical goal establishing that c:s[] is unreachable\ngoal not(c:s[])"]], "PV-1/NS-CBC-alive-known-key.pv": [[true, "(* Secure Communication Protocol *)\n\n(* Types *)\ntype nonce.\ntype key.\ntype identity.\ntype ciphertext.\n\n(* Functions for encryption and decryption *)\nfun enc(key, nonce): ciphertext.\nfun dec(key, ciphertext): nonce.\nfun cbc_enc_1(nonce, key): ciphertext.\nfun cbc_enc_2(key, identity): ciphertext.\nfun cbc_enc_4(nonce, identity, key, ciphertext, key): ciphertext.\nfun cbc_dec_1(ciphertext, key): nonce.\n\n(* Protocol Participants *)\nconst A: identity.\nconst B: identity.\nconst S: identity.\n\n(* Free names as public knowledge *)\nfree Kas: key.\nfree Kbs: key.\n\n(* Secret values *)\nprivate free Kab: key.\nprivate free Kab': key.\n\n(* Nonces *)\nprivate free Na: nonce.\nprivate free Nb: nonce.\n\n(* Events *)\nevent startA(identity, identity).\nevent receiveS(ciphertext).\n\nevent commitA(nonce, identity, key).\nevent commitB(nonce, key).\n\n(* Initial Process *)\nprocess\n  (* Client A initiates communication *)\n  let Na = new nonce in\n  out(ch, (A, B, Na));\n  event startA(A, B);\n  \n  (* Server processes the message *)\n  in(ch, (A, B, Na));\n  let kabCipher = cbc_enc_4(Na, B, Kab, cbc_enc_2(Kab, A, Kbs), Kas) in\n  out(ch, kabCipher);\n  event receiveS(kabCipher);\n\n  (* Client A decrypts server response *)\n  in(ch, kabCipher);\n  let (Na', B', Kab, enc_Kab_A) = cbc_dec_1(kabCipher, Kas) in\n  if Na' = Na && B' = B then (\n    event commitA(Na, B, Kab);\n    out(ch, enc_Kab_A)\n  );\n\n  (* Client B receives session key and sends nonce *)\n  in(ch, enc_Kab_A);\n  let Nb = new nonce in\n  let enc_Nb = cbc_enc_1(Nb, Kab) in\n  out(ch, enc_Nb);\n  event commitB(Nb, Kab);\n\n  (* Client A receives and processes B's nonce *)\n  in(ch, enc_Nb);\n  let Nb' = cbc_dec_1(enc_Nb, Kab) in\n  if Nb' = Nb then (\n    let enc_succNb = cbc_enc_1(succ(Nb'), Kab) in\n    out(ch, enc_succNb)\n  );\n\n  (* Client B receives incremented nonce and confirms *)\n  in(ch, enc_succNb);\n  let succNb = cbc_dec_1(enc_succNb, Kab) in\n  if succNb = succ(Nb) then event commitB(succNb, Kab)"]], "PV-1/DenningSacco3.pv": [[true, "(* Define types *)\ntype host.\ntype key.\ntype msg.\n\n(* Channels *)\nfree c : channel.\n\n(* Cryptographic Keys *)\nfree pkA, skA : key.\nfree pkB, skB : key.\n\n(* Cryptographic Functions *)\nfun encrypt(msg, key): msg.\nfun decrypt(msg, key): msg.\nfun sign(msg, key): msg.\nfun checksign(msg, key): bool.\n\n(* Secrets *)\nfree secretA, secretB : msg.\n\n(* Processes *)\nlet initiator(pk2 : key, pkA : key, skA : key) =\n  new k: key;  (* Generate a new shared key *)\n  let signed = sign((pkA, pk2, k), skA) in\n  let enc_msg = encrypt(signed, pk2) in\n  out(c, enc_msg);\n  in(c, x);\n  let dec_x = decrypt(x, k) in\n  if pk2 = pkB then\n    out(c, dec_x)  (* Send decrypted message *)\n  else\n    let enc_secretA = encrypt(secretA, k) in\n    out(c, enc_secretA).\n\nlet responder(pkA : key, pkB : key, skB : key) =\n  in(c, y);\n  let dec_y = decrypt(y, skB) in\n  let signed_content = snd(dec_y) in\n  if checksign(signed_content, pkA) then\n    let k = snd(signed_content) in\n    out(c, encrypt(secretB, k))  (* Send encrypted secretB *)\n  else\n    out(c, dec_y).\n\n(* Main Process *)\nprocess\n  out(c, pkA);\n  out(c, pkB);\n  (!initiator(pkB, pkA, skA) | !responder(pkA, pkB, skB))\n\n(* Security Queries *)\nquery secret secretA.\nquery secret secretB.\nquery attacker(pkA).\nquery attacker(pkB).\n\n(* Honest assumptions *)\nquery attacker(skA).\nquery attacker(skB)."]], "PV-1/NS-CBC-alive.pv": [[true, "(* ProVerif model for the described secure communication protocol *)\n\n(* Declaration of free variables for identities and keys *)\nfree c: channel.\nfree A, B, S: bitstring.  (* Identities *)\nfree Kas, Kbs: symmetric_key.  (* Session keys for Clients A and B *)\n\n(* Nonces generated by Clients A and B *)\nnew Na, Nb: bitstring.\n\n(* Shared session key established during the protocol *)\nnew Kab: symmetric_key.\n\n(* Encryption and decryption functions *)\nfun enc(bitstring, symmetric_key): bitstring.\nreduc forall m: bitstring, k: symmetric_key; dec(enc(m, k), k) = m.\n\n(* CBC encryption/decryption and prefix extraction functions *)\nfun cbc_enc_1(bitstring, symmetric_key): bitstring.\nfun cbc_enc_2(bitstring, bitstring, symmetric_key): bitstring.\nfun cbc_dec_1(bitstring, symmetric_key): bitstring.\nfun cbc_dec_2(bitstring, symmetric_key): bitstring * bitstring.\nfun cbc_2_get_1_prefixes(bitstring): bitstring.\n\n(* Successor function *)\nfun succ(bitstring): bitstring.\n\n(* Communication process for Client A *)\nlet clientA =\n    out(c, (A, B, Na));  (* Send identity and nonce to Server *)\n    in(c, (KabEnc: bitstring, NaPlus));  (* Receive encrypted session key and ack nonce *)\n    let Kab = dec(KabEnc, Kas) in  (* Decrypt to obtain shared session key *)\n    let Na' = succ(Na) in\n    if NaPlus = Na' then  (* Verify nonce acknowledgment *)\n      out(c, enc(Na', Kab))  (* Send incremented nonce back to server to confirm *)\n    else\n      0.\n\n(* Communication process for Client B *)\nlet clientB =\n    in(c, (KabEnc: bitstring, NbPlus));  (* Receive encrypted session key and ack nonce *)\n    let Kab = dec(KabEnc, Kbs) in  (* Decrypt to obtain shared session key *)\n    let Nb' = succ(Nb) in\n    if NbPlus = Nb' then  (* Verify nonce acknowledgment *)\n      out(c, enc(Nb', Kab))  (* Send incremented nonce back to server to confirm *)\n    else\n      0.\n\n(* Communication process for Server S *)\nlet serverS =\n    in(c, (A_id, B_id, NaRec));  (* Receive message from Client A *)\n    let KabEnc = enc(Kab, Kas) in  (* Encrypt session key with Kas *)\n    let NaPlus = succ(NaRec) in\n    out(c, (KabEnc, NaPlus));  (* Send encrypted key and ack nonce to Client A *)\n\n    in(c, (NaAck));  (* Receive nonce acknowledgment from Client A *)\n    if NaAck = enc(succ(NaPlus), Kab) then\n      out(c, (KabEnc, succ(Nb)));  (* Forward encrypted key and ack nonce to Client B *)\n    else\n      0.\n\n(* Main process initiating the protocol *)\nprocess\n    clientA | serverS | clientB\n\n(* Security queries *)\nquery attacker: Kab.  (* Ensure that the key Kab is not revealed to the attacker *)\nquery attacker: Na.  (* Ensure that nonce Na is not revealed to the attacker *)\nquery attacker: Nb.  (* Ensure that nonce Nb is not revealed to the attacker *)"]], "PV-1/NSPK-agree-A-to-B-secrecy.pv": [[true, "(* Free Names *)\nfree cA, cB, s: channel.\nfree m: message.\n\n(* Types *)\ntype client.\ntype server.\n\n(* Functions *)\nfun pkey(privkey: skey): pkey.\nfun sign(privkey: skey, message: message): signature.\nfun checksign(pubkey: pkey, signature: signature, message: message): bool.\nfun getmess(signature: signature): message.\nfun enc(pubkey: pkey, message: message): ciphertext.\nfun dec(privkey: skey, ciphertext: ciphertext): message.\nfun aenc(pubkey: pkey, message: message): aciphertext.\nfun adec(privkey: skey, aciphertext: aciphertext): message.\n\n(* Key Definitions *)\nprivate free skA, skB: skey.\nlet pkA = pkey(skA).\nlet pkB = pkey(skB).\n\n(* Nonce for Clients *)\nprivate free Na, Nb: nonce.\n\n(* Table: Stores public keys of clients *)\ntable keys(client, pkey).\n\n(* Key Server Process *)\nlet key_server() =\n  in(cA, request_key_from_A);\n  out(cA, sign(skS, pkB));\n  in(cB, request_key_from_B);\n  out(cB, sign(skS, pkA)).\n\n(* Client A Process *)\nlet client_A() =\n  new Na;\n  out(s, request_key(cB));\n  in(s, signed_pkB);\n  if checksign(pkS, signed_pkB, pkB) then\n    let ciphertext1 = aenc(pkB, pair(Na, cA)) in\n    out(cB, ciphertext1);\n    in(cB, ciphertext_response);\n    let message2 = adec(skA, ciphertext_response) in\n    let (resNa, Nb) = message2 in\n    if resNa = Na then\n      let ciphertext3 = aenc(pkB, Nb) in\n      out(cB, ciphertext3).\n\n(* Client B Process *)\nlet client_B() =\n  new Nb;\n  out(s, request_key(cA));\n  in(s, signed_pkA);\n  if checksign(pkS, signed_pkA, pkA) then\n    in(cA, ciphertext1);\n    let message1 = adec(skB, ciphertext1) in\n    let (Na, idA) = message1 in\n    let ciphertext_response = aenc(pkA, pair(Na, Nb)) in\n    out(cA, ciphertext_response);\n    in(cA, ciphertext3);\n    let message3 = adec(skB, ciphertext3) in\n    if message3 = Nb then\n      out(cB, confirmation).\n\n(* Main Process *)\nprocess\n  key_server()\n  | client_A()\n  | client_B()\n\n(* Security Queries *)\nquery attacker(m).\nquery @alice_authenticates_b(Nb). (* A authenticates B *)\nquery @bob_authenticates_a(Na).   (* B authenticates A *)\nquery attacker(ciphertext1).      (* Confidentiality of Communication A->B *)\nquery attacker(ciphertext_response). (* Confidentiality of Communication B->A *)\nquery attacker(ciphertext3).      (* Confidentiality of Communication A->B *)"]], "PV-1/ntor.pv": [[true, "(* Proverif specification for the Elliptic Curve Diffie-Hellman-based protocol *)\n\n(* Types declaration *)\ntype id.\ntype scalar.\ntype point.\ntype hashkey.\ntype hashout.\ntype string.\n\n(* Constants declaration *)\nconst G: point.\nconst PROTOID: string.\nconst Server: id.\nconst t_mac: hashkey.\nconst t_key: hashkey.\nconst t_verify: hashkey.\n\n(* Functions declaration *)\nfun SMUL(scalar, point): point.\nfun smul(scalar, point): point.\nfun s2p(scalar): point.\nfun EXP(point, scalar): point.\nfun H(bitstring, hashkey): hashout.\nfun concat1(string, point, point, point): bitstring.\nfun concat2(string, point, point, hashout): bitstring.\n\n(* Messages format declaration *)\nfun CREATE(id, point, point): bitstring.\nfun CREATED(point, hashout): bitstring.\n\n(* Events declaration *)\nevent ServerKey(id, point).\nevent ClientAccept(id, point, point, point, hashout).\nevent ServerAccept(id, point, point, point, hashout).\n\n(* Queries declaration *)\nquery attacker:key_seed.\nquery ClientAccept(id, X, B, Y, mac) ==> ServerAccept(id, B, X, Y, mac).\n\n(* Client process *)\nlet client(ID: id, B: point) =\n    new x: scalar;\n    let X = s2p(x) in\n    out(c, CREATE(ID, B, X));\n    in(c, CREATED(Y, mac));\n    let key_seed = EXP(Y, x) in\n    let mac' = H(concat2(PROTOID, ID, Y, key_seed), t_verify) in\n    if mac' = mac then\n        event ClientAccept(ID, X, B, Y, mac)\n    else\n        0.\n\n(* Server process *)\nlet serveur(ID: id, b: scalar, B: point) =\n    in(c, CREATE(ID, B, X));\n    new y: scalar;\n    let Y = s2p(y) in\n    let key_seed = EXP(X, y) in\n    let mac = H(concat2(PROTOID, ID, X, key_seed), t_verify) in\n    out(c, CREATED(Y, mac));\n    event ServerAccept(ID, B, X, Y, mac).\n\n(* Main process *)\nprocess\n    in(c, ID: id);\n    new b: scalar;\n    let B = s2p(b) in\n    event ServerKey(ID, B);\n    (client(ID, B) | serveur(ID, b, B))."]], "PV-1/otway-rees-fctshr.horn": [[true, "# Declarations\nfree channel c.\nfree channel shrA.\nfree channel shrB.\nprivate free nonce Na.\nprivate free nonce Nb.\nprivate free skA.\nprivate free skB.\nprivate free secretKey.\nprivate free keyAB.\n\n# Processes\nprocess\n  # Step 1: Alice sends her nonce and identity\n  let AliceStep1 = out(c, encrypt((Na, \"Alice\", c), skA)).\n\n  # Step 2: Server processes Alice's request and responds\n  let ServerStep2 = in(c, encrypt((Na', \"Alice\", c), skA)) ;\n                    new Nb ;\n                    out(c, encrypt((Na', Nb, secretKey), skA)).\n\n  # Step 3: Alice forwards session key to Bob\n  let AliceToBob = in(c, encrypt((Na'', Nb', secretKey'), skA)) ;\n                   out(c, encrypt((Na'', Nb', secretKey'), skB)).\n\n  # Step 4: Bob sends confirmation to Alice\n  let BobStep4 = in(c, encrypt((Na''', Nb'', secretKey''), skB)) ;\n                 out(c, encrypt((Nb'', \"Alice\"), skA)).\n\n  # Composition of processes\n  AliceStep1 | ServerStep2 | AliceToBob | BobStep4\n\n# Security Queries\nquery attacker(skA).\nquery attacker(skB)."]], "PV-1/OtwayRees.pv": [[true, "(* Types *)\ntype key.\ntype nonce.\ntype session_key.\ntype participant.\n\n(* Free names *)\nfree A, B, S: participant.\nfree secretA, secretB: private.\n\n(* Functions *)\nfun encrypt(key; nonce, session_key, participant, participant): bitstring.\nfun decrypt(key; bitstring): bitstring.\nfun generate_session_key(nonce, nonce): session_key.\n\n(* Predicates (queries) *)\nquery attacker(secretA).\nquery attacker(secretB).\n\n(* Protocol *)\nlet process_a = \n    new Na: nonce;\n    out(A, (A, B, encrypt(Kas, Na, C, A, B))).\n\nlet process_b = \n    in(B, (A, B, encrypt_message: bitstring));\n    let (Na, C, A1, B1) = decrypt(Kbs, encrypt_message) in\n    new Nb: nonce;\n    out(S, (C, A1, B1, encrypt(Kbs, Nb, C, A1, B1))).\n\nlet process_s = \n    in(S, (C, A2, B2, encrypted_message: bitstring));\n    let (Nb, C1, A3, B3) = decrypt(Kbs, encrypted_message) in\n    let session_key = generate_session_key(Na, Nb) in\n    out(B2, (C, encrypted_message, encrypt(Kas, Na, session_key, A3, B3), encrypt(Kbs, Nb, session_key, A3, B3))).\n\nlet process_b_final =\n    in(B, (C, encrypted_message, key_message_A: bitstring, key_message_B: bitstring));\n    let session_key = decrypt(Kbs, key_message_B) in\n    out(A, (C, key_message_A)).\n\nlet process_a_final = \n    in(A, (C, key_message_A_final: bitstring));\n    let session_key = decrypt(Kas, key_message_A_final) in\n    success.\n\n(* Channel assumptions *)\nfree c_A_B, c_B_S: channel.\n\n(* Processes *)\nprocess\n    ((! process_a) | (! process_b) | (! process_s) | (! process_b_final) | (! process_a_final))."]], "PV-1/piclauses4.pi": [[true, "(* Cryptographic primitives *)\nfree pkA, pkB: public_key.\nfree skA, skB: secret_key.\nfun sign/2.\nfun pk/1.\nfun checksign/2.\n\n(* Shared secret keys initial values *)\nprivate secretA, secretB: bitstring.\n\n(* Utility predicate definitions *)\npredicate member/2.\npredicate membernew/2.\n\n(* Process A *)\nprocess\n  let listA = [identityA] in\n  (* Verification of identity *)\n  if member(identityA, listA) then\n    (* Generate keys for Process A *)\n    new skA: secret_key; \n    let pkA = pk(skA) in\n    \n    (* Send signed message with Process A's identity *)\n    out(channel, (identityA, sign(identityA, skA)));\n\n    (* Receive and verify signed message from Process B *)\n    in(channel, (msgB, signatureB));\n    if checksign(signatureB, pkB) then\n      (* Send back the secret to Process B *)\n      out(channel, secretA);\n\n(* Process B *)\nprocess\n  (* Generate keys for Process B *)\n  new skB: secret_key; \n  let pkB = pk(skB) in\n  \n  (* Send signed message with Process B's public key *)\n  out(channel, (pkB, sign(pkB, skB)));\n\n  (* Receive signed message from Process A *)\n  in(channel, (msgA, signatureA));\n  if checksign(signatureA, pkA) then\n    (* Verify authenticity and send back secret *)\n    out(channel, secretB);\n\n(* Security goals *)\nquery attacker: secretA.\nquery attacker: secretB.\nquery not attacker(pkA).\nquery not attacker(pkB)."]], "PV-1/pihandshake-1.pi": [[true, "(* ProVerif model for the Handshake Protocol *)\n\n(* Channel for communication *)\nfree c: channel.\n\n(* Cryptographic functions *)\nfun encrypt(bitstring, bitstring): bitstring.\nfun decrypt(bitstring, bitstring): bitstring.\nequation decrypt(encrypt(x, y), y) = x.\n\n(* Utility function f representing a transformation *)\nfun f(bitstring): bitstring.\n\n(* Variables *)\nprivate free pw: bitstring.  (* Shared secret password *)\n\n(* Process A - Alice *)\nlet process_A = \n    new N: bitstring;  (* Generate freshness with nonce *)\n    out(c, encrypt(N, pw)).  (* Send encrypted nonce over channel *)\n\n(* Process B - Bob *)\nlet process_B =\n    in(c, x: bitstring);  (* Receive encrypted message *)\n    let y = decrypt(x, pw) in  (* Decrypt the message *)\n    let fy = f(y) in  (* Apply function f *)\n    out(c, encrypt(fy, pw)).  (* Send result back encrypted *)\n\n(* Main process *)\nprocess\n    (! process_A | ! process_B)  (* Parallel execution of both processes *)"]], "PV-1/piskeme.pi": [[true, "(* Define free names *)\nfree skA, skB : privkey.\nfree pkA, pkB : pubkey.\nfree A, B : names.\n\n(* Functions *)\n(* Public Key Encryption *)\nfun encrypt(pubkey, message) : ciphertext.\nfun decrypt(privkey, ciphertext) : message.\n\n(* Shared Key Encryption *)\nfun sencrypt(sharedkey, message) : secmessage.\nfun sdecrypt(sharedkey, secmessage) : message.\n\n(* Hashing Functions *)\nfun hash(message) : hash.\nfun keyhash(sharedkey, message) : hash.\n\n(* Diffie-Hellman Functions *)\nfun f(privkey, pubkey) : dhvalue.\nfun g(privkey) : dhvalue.\n\n(* Shared session key derivation *)\nfun derive_shared_key(dhvalue1, dhvalue2) : sharedkey.\n\n(* Message exchange channels *)\nchannel public : channel.\nchannel secure : channel.\n\n(* Alice's process *)\nlet Alice =\n  new x : privkey;            (* Generate Alice's secret key *)\n  let gx = g(x) in            (* Compute g(x) *)\n  let Ka = derive_shared_key(gx, f(skA, pkB)) in\n  out(public, pkA);           (* Send public key over insecure channel *)\n  in(public, pkB : pubkey);   (* Receive Bob's public key *)\n  \n  let m1 = encrypt(pkB, (Ka, gx)) in\n  out(public, m1);            (* Send encrypted message to Bob *)\n\n  in(public, m2 : ciphertext);\n  let (Kb, gy, hashB) = decrypt(skA, m2) in  (* Decrypt Bob's message *)\n  if hashB = keyhash(Ka, (Kb, gy)) then      (* Verify integrity *)\n    let sh = derive_shared_key(gx, gy) in    (* Compute shared session key *)\n    let sA = sencrypt(sh, secretA) in\n    out(secure, sA)                          (* Send encrypted secretA *)\n  else\n    out(public, \"Error: Integrity failed\").  (* Handle verification failure *)\n\n(* Bob's process *)\nlet Bob =\n  new y : privkey;            (* Generate Bob's secret key *)\n  let gy = g(y) in            (* Compute g(y) *)\n  let Kb = derive_shared_key(gy, f(skB, pkA)) in\n  out(public, pkB);           (* Send public key over insecure channel *)\n  in(public, pkA : pubkey);   (* Receive Alice's public key *)\n  \n  in(public, m1 : ciphertext);\n  let (Ka, gx) = decrypt(skB, m1) in         (* Decrypt Alice's message *)\n  let hashA = keyhash(Kb, (Ka, gx)) in\n  let m2 = encrypt(pkA, (Kb, gy, hashA)) in\n  out(public, m2);                           (* Send response to Alice *)\n\n  in(secure, sA : secmessage);\n  let secretA = sdecrypt(derive_shared_key(gx, gy), sA) in\n  out(public, \"Exchange completed\").         (* Handle successful exchange *)\n\n(* Initiate Processes *)\nprocess Alice | Bob"]], "PV-1/send.pv": [[true, "(* Proverif analysis code for the described protocol *)\n\n(* Free channel declaration *)\nfree c : channel.\n\n(* Private data declaration *)\nprivate free Cocks : bitstring.\nprivate free RSA : bitstring.\n\n(* Security Queries *)\nquery attacker(RSA).   (* Check if attacker can obtain the RSA message *)\nquery attacker(Cocks).  (* Check if attacker can obtain the Cocks value *)\n\n(* Protocol Process *)\nprocess\n    out(c, RSA)  (* Participant A sends RSA to B over channel c *)"]], "PV-1/Shamir-Rivest-Adleman-Three-Pass.pv": [[true, "free c: channel.\nfree Ka, Kb: bitstring.   // secret keys\nfree objective: bitstring.\n\ntype message.\ntype commitment.\n\n(* Cryptographic Functions *)\nfun comm_enc(bitstring, bitstring): commitment.\nfun comm_dec(commitment, bitstring): bitstring.\nfun enc(bitstring, bitstring): bitstring.\nfun dec(bitstring, bitstring): bitstring.\n\n(* Cryptographic Properties *)\nequation dec(enc(m, k), k) = m for m: bitstring, k: bitstring.\nequation comm_dec(comm_enc(m, k), k) = m for m: message, k: bitstring.\n\n(* A's Process *)\nlet process_A =\n    new m: message;  // Generate random message\n    out(c, comm_enc(m, Ka));  // Step 1: Send committed message to B\n    in(c, msg1: commitment);  // Step 2: Wait for commitment from B\n    let msg2 = comm_dec(msg1, Ka) in  // Step 3: Decrypt received message\n    out(c, msg2);  // Send the decrypted result to B\n    out(c, enc(objective, m)).  // Step 4: Send encrypted objective message\n\n(* B's Process *)\nlet process_B =\n    in(c, msg1: commitment);  // Step 5: Receive committed message from A\n    out(c, comm_enc(msg1, Kb));  // Step 6: Send back committed message\n    in(c, msg2: message);  // Step 7: Receive the decrypted result from A\n    let original_message = comm_dec(comm_enc(msg1, Kb), Kb) in  // Decrypt\n    0.  // End of process\n\n(* Security Queries *)\nquery attacker(objective).  // Goal: Ensure confidentiality of objective\nquery sessionKey(m).        // Optional: Ensure session key m is secure\n\n(* Main Process *)\nprocess\n    (!process_A | !process_B)"]], "PV-1/dh-fs.pv": [[true, "(* Diffie-Hellman Key Exchange with Choices *)\n\n(* Types representing the group and exponents *)\ntype G.\ntype exponent.\n\n(* Constant generator of group G *)\nconst g: G.\n\n(* Function for exponentiation in the group G *)\nfun exp(G, exponent): G.\n\n(* Channel for communication *)\nchannel c.\n\n(* Private exponents generated by participants *)\nnew a1: exponent.\nnew a2: exponent.\nnew a3: exponent.\n\n(* Public keys computed by participants *)\nlet pkey1 = exp(g, a1).\nlet pkey2 = exp(g, a2).\n\n(* Sending choices over the communication channel *)\nout(c, (pkey1, pkey2, choice(exp(exp(g, a1), a2), exp(g, a3)))).\n\n(* Security assumption: Exponentiation is commutative *)\nequation exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Security property: Observational equivalence between choices *)\nquery equiv(exp(exp(g, a1), a2), exp(g, a3)).\n\nprocess\n\t(* Protocol Execution *)\n\t!new a1: exponent;\n\t!new a2: exponent;\n\t!new a3: exponent;\n\n\t(* Compute participant public keys *)\n\tlet pkey1 = exp(g, a1) in\n\tlet pkey2 = exp(g, a2) in\n\n\t(* Send exchanged values and choice outcome *)\n\tout(c, (pkey1, pkey2, choice(exp(pkey1, a2), exp(g, a3))));\n\n\t(* Ensure observational equivalence *)\n\tquery equiv(exp(exp(g, a1), a2), exp(g, a3))."]], "PV-1/piotwayrees.pi": [[true, "/* Otway-Rees Protocol Proverif Model */\n\n/* Declarations */\nfree cA, cB, cS : channel.  // Communication channels for A, B, and server S\n\nfun encrypt(bitstring, bitstring): bitstring.  // Encryption function\nfun decrypt(bitstring, bitstring): bitstring.  // Decryption function\nconst kA, kB : bitstring.  // Shared keys between A-S and B-S\n\n/* Nonce generation */\nnew Na : bitstring.  // Nonce generated by A\nnew Nb : bitstring.  // Nonce generated by B\n\n/* Protocol roles */\nprocess A_init = \n  out(cB, (cS, A, B, encrypt((Na, A, B), kA))).\n\nprocess B_receiveA = \n  in(cB, (cS', A', B', enc_msg)).\n  let (Na', A'', B'') = decrypt(enc_msg, kB) in\n  new Nb.\n  out(cS, (cS', A', B', encrypt((Na', Nb, A', B'), kB))).\n\nprocess S_response = \n  in(cS, (cS'', A', B', enc_msg)).\n  let (Na'', Nb', A''', B''') = decrypt(enc_msg, kA) in\n  new k : bitstring.  // Session key\n  out(cB, (encrypt((Na'', k), kA), encrypt((Nb', k), kB))).\n\nprocess B_acknowledge = \n  in(cB, (enc_msg1, enc_msg2)).\n  let (Na''', k') = decrypt(enc_msg1, kA) in\n  let (Nb'', k'') = decrypt(enc_msg2, kB) in\n  out(cA, Nb'').\n\nprocess A_secureComm = \n  in(cA, Nb''').\n  // A now uses the session key `k` for secure communication\n  /* Here, implement further secure communication as needed */\n\n/* Security goals */\nquery attacker(kA).  // Check if the attacker can know A's key\nquery attacker(kB).  // Check if the attacker can know B's key\nquery attacker(Na).  // Check if the nonce generated by A is secure\nquery attacker(Nb).  // Check if the nonce generated by B is secure\nquery attacker(k).  // Check if the session key is secure"]], "PV-1/pivote.pi": [[true, "free c: channel.    (* Communication channel *)\nfree pub: channel.  (* Public channel for distributing public keys *)\n\n(* Types for keys and messages *)\ntype key.\ntype message.\n\n(* Function symbols for cryptographic operations *)\nfun pk(key): key.\nreduc forall sk:key; decrypt(encrypt(m, pk(sk)), sk) = m.\n\n(* Private key of the server: generated fresh by server *)\nnew skS: key.\n\n(* Public key of the server: derived from the private key *)\nlet pkS = pk(skS).\n\n(* Server process: wait for a vote, decrypt it, and process the vote *)\nprocess\n  (* Server publishes its public key *)\n  out(pub, pkS) |\n  \n  (* Server waits to receive an encrypted vote, then decrypts it *)\n  in(c, x: message);\n  let v = decrypt(x, skS) in\n  event \"VoteReceived\"(v).\n\n(* Voter process: encrypt and send a vote *)\nlet voter(v: message) = \n  in(pub, pkS: key);\n  let encrypted_vote = encrypt(v, pkS) in\n  out(c, encrypted_vote).\n\n(* Main process simulating multiple voters *)\nprocess\n  !new v1: message, v2: message;\n  (\n    voter(v1) |\n    voter(v2)\n  )"]], "PV-1/piwoolam.pi": [[true, "(* WooLam Shared-Key Authentication Protocol *)\n\n(* Declaration of types *)\ntype identity\ntype key\ntype nonce\n\n(* Declaration of functions *)\nfun encrypt: message * key -> message.\nfun decrypt: message * key -> message.\nfun verify: message -> message -> bool.\n\n(* Declaration of free names *)\nfree a, b: identity.\nfree kAS, kBS: key.\n\n(* Main process *)\nprocess\n  (* A: Initiator *)\n  let A_process = \n    (* Step 1: Send identity to B *)\n    out(c, a);\n    in(c, n: nonce);\n\n    (* Step 3: Send encrypted message to B using kAS *)\n    let message_to_B = encrypt((a, b, n), kAS) in\n    out(c, message_to_B)\n  in\n\n  (* B: Responder *)\n  let B_process =\n    (* Step 2: Receive identity from A and send nonce *)\n    in(c, a_received: identity);\n    new nB: nonce;\n    out(c, nB);\n\n    (* Step 4: Receive message from A and forward encrypted message to S using kBS *)\n    in(c, message_from_A: message);\n    let forward_to_S = encrypt((a_received,b, message_from_A), kBS) in\n    out(c, forward_to_S);\n\n    (* Step 6: Receive message from S and verify *)\n    in(c, message_from_S: message);\n    let decrypted_from_S = decrypt(message_from_S, kBS) in\n    if verify(decrypted_from_S, (a_received,b, nB)) then\n      event endBparam();\n      event endBfull()\n    else\n      0\n  in\n\n  (* S: Server *)\n  let S_process = \n    (* Step 5: Receive forwarded message from B, decrypt and send back *)\n    in(c, message_from_B: message);\n    let decrypted_from_B = decrypt(message_from_B, kBS) in\n    let (_, _, encrypted_from_A) = decrypted_from_B in (* Extract the encrypted message from A *)\n    let message_to_B = encrypt(decrypt(encrypted_from_A, kAS), kBS) in\n    out(c, message_to_B)\n  in\n\n  (* Running the processes for each participant *)\n  !((A_process | B_process | S_process))\n\n(* ProVerif queries *)\nquery attacker(endBparam).\nquery attacker(endBfull)."]], "PV-1/sissy_dh.pv": [[true, "(* Declaration of free names *)\nfree c : channel. (* Communication channel *)\nfree g : G. (* Generator for group G *)\n\n(* Types *)\ntype G. (* Group type for Diffie-Hellman *)\ntype exponent. (* Type for exponents *)\ntype SymmetricKey. (* Type for symmetric keys *)\ntype SecretKey. (* Type for secret keys *)\ntype PublicKey. (* Type for public keys *)\n\n(* Functions *)\nfun pk(SecretKey) : PublicKey. (* Public key corresponding to a secret key *)\nfun exp(G, exponent) : G. (* Exponentiation in group G *)\nfun GtoSymK(G) : SymmetricKey. (* Convert group element to symmetric key *)\n\n(* Encryption and decryption functions *)\nfun enc(bitstring, SymmetricKey) : bitstring.\nreduc forall m: bitstring, k:SymmetricKey; dec(enc(m, k), k) = m.\nfun aenc(bitstring, PublicKey) : bitstring.\nreduc forall m: bitstring, sk:SecretKey; adec(aenc(m, pk(sk)), sk) = m.\n\n(* Signature and verification functions *)\nfun sign(bitstring, SecretKey) : bitstring.\nfun auth(bitstring, PublicKey) : bitstring.\n\n(* Protocol roles *)\nprocess\n  (* Alice process *)\n  let x = new exponent in\n  let gx = exp(g, x) in\n  out(c, gx);\n  in(c, (gy: G, enc_msg: bitstring));\n  let K = GtoSymK(exp(gy, x)) in\n  let signed_msg = sign((gy, gx), x) in\n  let encrypted_msg = enc((gx, gy, signed_msg), K) in\n  out(c, encrypted_msg)\n\n| (* Bob process *)\n  in(c, gx: G);\n  let y = new exponent in\n  let gy = exp(g, y) in\n  let K = GtoSymK(exp(gx, y)) in\n  let signed_msg = sign((gy, gx), y) in\n  let encrypted_msg = enc((gy, gx, signed_msg), K) in\n  out(c, (gy, encrypted_msg));\n  in(c, received_enc: bitstring);\n  get payload = dec(received_enc, K) in\n  let (gx_rec, gy_rec, _) = payload in\n  if gx_rec = gx && gy_rec = gy then\n    (* Verified that the received values match *)\n    0\n  else\n    (* Abort *)\n    0\n\n(* Security goals *)\nquery attacker: exponent.\nquery secret(gx, [Alice]).\nquery secret(gy, [Bob]).\nquery secret(K, []).\n\n(* Authentication query *)\nquery ev: event(end_Alice(gx, gy)) ==> ev: event(begin_Bob(gx, gy)).\nquery ev: event(end_Bob(gx, gy)) ==> ev: event(begin_Alice(gx, gy))."]], "PV-1/Skeme.pv": [[true, "(* Protocol: Secure Key Exchange and Communication Protocol *)\n\n(* Types *)\ntype bitstring.\ntype key.\n\n(* Functions *)\nfun encrypt(bitstring, key): bitstring.\nfun decrypt(bitstring, key): bitstring.\nfun hash(bitstring): key.\nfun exp(bitstring, bitstring): bitstring.\nfun keyhash(bitstring, key): bitstring.\nfun sencrypt(bitstring, key): bitstring.\nfun sdecrypt(bitstring, key): bitstring.\n\n(* Constants *)\nconst g: bitstring.\n\n(* Free names *)\nfree skA: key. (* Alice's secret key *)\nfree skB: key. (* Bob's secret key *)\n\n(* Public keys *)\nlet pkA = hash(skA).\nlet pkB = hash(skB).\n\n(* Queries *)\nquery secretAlice: bitstring.\nquery secretBob: bitstring.\n\n(* Alice's process *)\n(* Alice generates nonce and ephemeral exponent *)\nlet processAlice =\n  let Ka = hash(new()) in\n  let x = new() in\n  let gx = exp(g, x) in\n  out(c, (pkA, Ka, gx));\n  in(c, (encrKb, encry, hashKb));\n  let Kb = decrypt(encrKb, skA) in\n  let gy = decrypt(encry, skA) in\n  let sharedSecretA = exp(gy, x) in\n  let verifyA = keyhash((Ka, Kb, gx, gy), sharedSecretA) in\n  if verifyA = hashKb then\n    let encryptedSecretA = sencrypt(secretAlice, sharedSecretA) in\n    out(c, encryptedSecretA)\n  else\n    event attack_detected.\n\n(* Bob's process *)\n(* Bob generates nonce and ephemeral exponent *)\nlet processBob =\n  in(c, (encrPKA, encrKa, gx));\n  let (pkA, Ka) = decrypt(encrPKA, skB) in\n  let (pkA, gx) = decrypt(encrKa, skB) in\n  let Kb = hash(new()) in\n  let y = new() in\n  let gy = exp(g, y) in\n  let sharedSecretB = exp(gx, y) in\n  let hashKb = keyhash((Ka, Kb, gx, gy), sharedSecretB) in\n  out(c, (encrypt(Kb, pkA), encrypt(gy, pkA), hashKb));\n  in(c, encryptedSecretB);\n  let secretB = sdecrypt(encryptedSecretB, sharedSecretB) in\n  event secret_revealed(secretB).\n\n(* Main process *)\nprocessAlice | processBob."]], "PV-1/skeme-pfs2.horn": [[true, "(* Public Key Cryptography Functions *)\nfun pkA: privkey -> pubkey.\nfun pkB: privkey -> pubkey.\nfun encrypt: pubkey, message -> ciphertext.\nfun decrypt: privkey, ciphertext -> message.\n\n(* Hash Functions *)\nfun hash: message -> hvalue.\nfun keyhash: symkey, message -> hvalue.\n\n(* Channels *)\nfree cA, cB: channel.  (* Communication channels *)\n\n(* Secrets *)\nprivate free skA: privkey.  (* Alice's private key *)\nprivate free skB: privkey.  (* Bob's private key *)\n\nfree secretA: message.\nfree secretB: message.\n\n(* Queries *)\nquery attacker(secretA).\nquery attacker(secretB).\n\n(* Rules/Processes *)\nprocess\n  (* Alice sends secretA encrypted for Bob *)\n  let pkB_value = pkB(skB) in\n  let ctA = encrypt(pkB_value, secretA) in\n  out(cA, ctA);\n\n  (* Bob receives and decrypts secretA *)\n  in(cA, ctA_received);\n  let m1 = decrypt(skB, ctA_received) in\n  if m1 = secretA then\n    event secretA_received\n  else\n    event error_detected;\n\n  (* Bob sends secretB encrypted for Alice *)\n  let pkA_value = pkA(skA) in\n  let ctB = encrypt(pkA_value, secretB) in\n  out(cB, ctB);\n\n  (* Alice receives and decrypts secretB *)\n  in(cB, ctB_received);\n  let m2 = decrypt(skA, ctB_received) in\n  if m2 = secretB then\n    event secretB_received\n  else\n    event error_detected."]], "PV-1/up.pv": [[true, "(* Cryptographic primitives *)\ntype sk, pk, nonce, shared_secret, message, ciphertext.\n\n(* Functions *)\nfun crypto_box_keypair(sk): pk.\nfun crypto_box(message, nonce, pk, sk): ciphertext.\nfun crypto_box_open(ciphertext, nonce, pk, sk): message.\n\n(* Constants *)\nconst n0: nonce.\n\n(* Channels *)\nchannel c.\n\n(* Alice's process *)\nprocess\n  let alice_sk = new sk in\n  let alice_pk = crypto_box_keypair(alice_sk) in\n  out(c, n0);\n  out(c, alice_pk);\n  in(c, bob_shared_secret);\n  let alice_shared_secret = crypto_box_open(bob_shared_secret, n0, alice_pk, alice_sk) in\n  event shared_secret_established(alice_shared_secret).\n\n(* Bob's process *)\nprocess\n  let bob_sk = new sk in\n  let bob_pk = crypto_box_keypair(bob_sk) in\n  in(c, alice_nonce);\n  in(c, alice_pk);\n  let bob_shared_secret = crypto_box(\"shared_message\", alice_nonce, alice_pk, bob_sk) in\n  out(c, bob_shared_secret).\n\n(* Security Assumptions and queries *)\nquery attacker(asecret)."]], "PV-1/WooLamPK.pv": [[true, "// Woo and Lam Public-Key Authentication Protocol (1992) in Proverif\n\ntypedef nonce.\ntypedef message.\n\nfree skA, skB, skS: message.\nfree pkA, pkB, pkS: message.\nconst c: channel.\n\nprivate fun encrypt(message, message): message.\nprivate fun decrypt(message, message): message.\nprivate fun sign(message, message): message.\nprivate fun verify(message, message): message.\n\n// A generates nonce N and sends identity to B\nlet processA = \n    new N: nonce;\n    out(c, A);\n    in(c, nb: nonce);\n    let msg = sign(N, skA) in\n    out(c, msg).\n\n// B receives A's identity, generates nonce, and interacts with the server\nlet processB =\n    in(c, na: message);\n    new N: nonce;\n    out(c, N);\n    in(c, sigN_A: message);\n    let verifyA = verify(sigN_A, pkA) in\n    if verifyA = N then\n        out(c, na);\n        in(c, resp_msg: message);\n        event Authenticated_B(na, pkA).\n\n// Trusted server S provides A's public key\nlet processS =\n    in(c, ida: message);\n    let resp_msg = sign((ida, pkA), skS) in\n    out(c, resp_msg).\n\nprocess\n    ( (!processA) | (!processB) | (!processS) )"]], "PV-1/Yahalom.pv": [[true, "(* Define the types for the participants and shared keys *)\nfree name A, B : bitstring.\nfree name Kab, Kas, Kbs : symmetric_key.\n(* Define public channels *)\nprivate channel c.\n\n(* Define the nonces *)\nnew Na, Nb : bitstring.\n\n(* Intruder's knowledge *)\nlet intruder_knowledge = [A; B].\n\n(* Define secret facts for secrecy goals *)\nquery secretA, secretB : bitstring. \n\n(* Process definitions *)\n\n(* Initiator process for host A *)\nprocess processInitiator =\n  (* Step 1: Host A sends its identity and nonce to Host B *)\n  out(c, (A, Na));\n  (* Step 4: Host A receives a message from Server S *)\n  in(c, {B, Kab, Na', Nb'}pkas);\n  if Na' = Na then \n    let message_to_B = {A, Kab}pkbs in\n    out(c, message_to_B, {Nb'}Kab)\n  else\n    0.\n\n(* Responder process for host B *)\nprocess processResponder =\n  (* Step 1: Host B receives A's message *)\n  in(c, (A', Na'));\n  (* Step 2: Host B sends a message to Server S *)\n  out(c, (B, {A'; Na'; Nb}pkbs));\n  (* Step 4: Host B receives message from A *)\n  in(c, {A'', Kab'}pkbs, {Nb}Kab');\n  if Kab' = Kab then\n    event secretB(Nb)\n  else\n    0.\n\n(* Server process *)\nprocess processServer =\n  (* Step 3: Server receives a message from B *)\n  in(c, (B', {A'', Na'', Nb''}pkbs));\n  if B = B' then\n    let message_to_A = {B, Kab, Na'', Nb''}pkas in\n    let message_to_B = {A'', Kab}pkbs in\n    out(c, message_to_A);\n    out(c, message_to_B)\n  else\n    0.\n\n(* Compose the protocol *)\nprocess processYahalomProtocol =\n  processInitiator | processResponder | processServer.\n\n(* Security goals: secrecy *)\nquery secretA(Na).\nquery secretB(Nb)."]], "PV-1/vote.pv": [[true, "(* Naive Voting Protocol in ProVerif *)\n\n(* Types *)\ntype voter.\ntype bitstring.\n\n(* Free names *)\nfree c: channel.\n\n(* Functions *)\nfun generate_skey(): bitstring.\nfun derive_pkey(bitstring): bitstring.\nfun encrypt(bitstring, bitstring): bitstring.\nfun decrypt(bitstring, bitstring): bitstring.\n\n(* Predicates *)\n(* Declare a predicate to express the confidentiality goal *)\npredicate secret_vote(voter, bitstring).\n\n(* Queries *)\nquery secret_vote(voter, v).\n\n(* Protocol Implementation *)\n\nprocess\n  in(c, voter);\n  let skS = generate_skey() in\n  let pkS = derive_pkey(skS) in\n  out(c, pkS);\n  choice\n    [ let v = (* vote value *) in\n      let enc_vote = encrypt(v, pkS) in\n      out(c, enc_vote)\n    | let w = (* alternative value *) in\n      out(c, w)\n    ];\n  (* Ensure that the decrypted message matches the vote *)\n  let dec_vote = decrypt(enc_vote, skS) in\n  if dec_vote = v then\n    secret_vote(voter, v)\n  else\n    zero.\n\n(* Observational Equivalence *)\nquery attacker(observer)."]]}