{"MAUDE-1/Denning-Sacco.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  ops a b i : -> UName .\n  op s : ->  SName . \n\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  op _ ; _ : Msg Msg -> Msg [frozen assoc (e _ ; _)] .\n\nendfm", "To complete the given Maude-NPA code based on the Denning Sacco Protocol description, we need to fill in the missing parts indicated by `____(Identifier)____`. Here's a step-by-step breakdown of how to complete the code:\n\n### Step 1: Analyzing the PROTOCOL-EXAMPLE-SYMBOLS Module\n\n1. **Subsorts and Sorts**: The description mentions various sorts (e.g., `UName`, `SName`, `Name`, `Key`, `Nonce`, `Masterkey`, `Sessionkey`) and their relationships. We have to correctly define these subsort relationships.\n\n2. **Operations**: The protocol involves several operations like generating nonces (`n`, `t`), master keys (`mkey`), session keys (`seskey`), encryption (`e`), decryption (`d`), and message concatenation (`_;_`).\n\nLet's fill in the blanks based on the protocol's description and Maude-NPA syntax:\n\n- `subsort ____(SUBSORT_0)____ Nonce  Key < Msg .`\n  - Since `UName` and `SName` are subsorts of `Name`, and considering the context, `Name` and `Nonce` and `Key` should be subsorts of `Msg`. Thus, `Name` could be a candidate for `____(SUBSORT_0)____`.\n\n- `subsort Masterkey  ____(SUBSORT_1)____ < Key .`\n  - `Sessionkey` is a type of `Key`, so `____(SUBSORT_1)____` should be `Sessionkey`.\n\n- `subsort ____(SUBSORT_2)____ UName < Name .`\n  - `SName` is also a `Name`, so `____(SUBSORT_2)____` should include `SName` and `UName` as subsorts of `Name`. Hence, it should be `SName UName`.\n\n- `op n : Name Fresh -> ____(OP_1)____ [____(OP_0)____] .`\n  - `n` generates a `Nonce`, so `____(OP_1)____` is `Nonce`. The attribute `____(OP_0)____` is typically `frozen` to prevent unwanted simplification.\n\n- `op mkey : ____(OP_5)____ Name -> ____(OP_4)____ [frozen] .`\n  - `mkey` involves two names (e.g., a user and the server), so `____(OP_5)____` should be `Name Name`. It generates a `Masterkey`, so `____(OP_4)____` is `Masterkey`.\n\n- `op seskey : Name Name Nonce -> ____(OP_7)____ [____(OP_6)____] .`\n  - `seskey` generates a `Sessionkey`, so `____(OP_7)____` is `Sessionkey`. The attribute `____(OP_6)____` is typically `frozen`.\n\n- `op e : Key ____(OP_8)____ -> Msg [____(OP_9)____] .`\n  - `e` encrypts a `Msg` with a `Key`, so `____(OP_8)____` is `Msg`. The attribute `____(OP_9)____` is typically `frozen`.\n\n- `op d : ____(OP_10)____ Msg -> Msg  [____(OP_11)____] .`\n  - `d` decrypts a `Msg` with a `Key`, so `____(OP_10)____` is `Key`. The attribute `____(OP_11)____` is typically `frozen`.\n\n- `op ____(OP_13)____ : Msg Msg -> Msg [frozen ____(OP_14)____ (e ____(OP_12)____)] .`\n  - This is the concatenation operator, typically denoted by `_;_`. Thus, `____(OP_13)____` is `_ ; _`, `____(OP_12)____` is `e`, and `____(OP_14)____` is `assoc`.\n\n### Step 2: Completing the PROTOCOL-EXAMPLE-SYMBOLS Module\n\nAfter understanding the requirements:\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  ops a b i : -> UName .\n  op s : ->  SName . \n\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  op _ ; _ : Msg Msg -> Msg [frozen assoc (e _ ; _)] .\n\nendfm\n```\n\n### Step 3: Reviewing Other Modules\n\nOther parts of the code, such as `PROTOCOL-EXAMPLE-ALGEBRAIC` and `PROTOCOL-SPECIFICATION`, are already mostly complete or follow directly from the protocol's description. For instance, the equations in `PROTOCOL-EXAMPLE-ALGEBRAIC` define the algebraic properties of encryption and decryption.\n\n```maude\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \nendfm\n```\n\n### Step 4: Finalizing PROTOCOL-SPECIFICATION\n\nFor `PROTOCOL-SPECIFICATION`, we need to ensure the strands and attack state are correctly defined according to the Denning Sacco Protocol.\n\nLet's directly infer or look at the given parts to complete the remaining variables and equations.\n\nFor example, `vars M1 M2 M3 M4 : Msg .` could be used for `vars ____(VAR_0)____ M2 ____(VAR_1)____ ____(EQ_0)____ : Msg .`, so it becomes `vars M1 M2 M3 M4 : Msg .`.\n\nThe completed code between ```maude and ``` is as follows:\n\n```maude\n----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _ ; _ : Msg Msg -> Msg [frozen assoc (e _ ; _)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M3 M4 : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M1), +(d(K,M1 ; M2)), nil ] &\n     :: nil :: [ nil | -(K), -(M1), +(e(K,M1 ; M2)), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2) , nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M1) , nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2) , nil ] &\n     :: nil :: [ nil | +(mkey(D,s)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M1)),\n            +(M1), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(1) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/maa-crc.maude": [[false, "```maude\nfmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [ctor] .\n  op Xtrue : -> Xbool [ctor] .\n  op x0 : -> Bit [ctor] .\n  op x1 : -> Bit [ctor] .\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet [ctor] .\n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Bit Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Block Block -> Pair [ctor] .\n  op zero : -> Nat [ctor] .\n  op succ : Nat -> Nat [ctor] .\n  op buildKey : Block Block -> Key [ctor] .\n  op unitMessage : Block -> Message [ctor] .\n  op consMessage : Block Message -> Message [ctor] .\n  op unitSegment : Message -> SegmentedMessage [ctor] .\n  op consSegment : Message SegmentedMessage -> SegmentedMessage [ctor] .\n  op notBool : Xbool -> Xbool .\n  op andBool : Xbool Xbool -> Xbool .\n  op orBool : Xbool Xbool -> Xbool .\n  op xorBool : Xbool Xbool -> Xbool .\n  op notBit : Bit -> Bit .\n  op andBit : Bit Bit -> Bit .\n  op orBit : Bit Bit -> Bit .\n  op xorBit : Bit Bit -> Bit .\n  op x00 : -> Octet .\n  op x01 : -> Octet .\n  op x0000 : -> Half .\n  op HalfU : Block -> Half .\n  op HalfL : Block -> Half .\n  op eqBit : Bit Bit -> Xbool .\n  op eqOctet : Octet Octet -> Xbool .\n  op eqOctetSum : OctetSum OctetSum -> Xbool .\n  op eqHalf : Half Half -> Xbool .\n  op eqHalfSum : HalfSum HalfSum -> Xbool .\n  op eqBlock : Block Block -> Xbool .\n  op eqBlockSum : BlockSum BlockSum -> Xbool .\n  op eqPair : Pair Pair -> Xbool .\n  op addBit : Bit Bit Bit -> Bit .\n  op carBit : Bit Bit Bit -> Bit .\n  op addOctetSum : Octet Octet Bit -> OctetSum .\n  op addOctet8 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet7 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet6 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet5 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet4 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet3 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet2 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet0 : Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op dropCarryOctetSum : OctetSum -> Octet .\n  op addOctet : Octet Octet -> Octet .\n  op addHalfSum : Half Half -> HalfSum .\n  op addHalf2 : Octet Octet Octet Octet -> HalfSum .\n  op addHalf1 : Octet OctetSum -> HalfSum .\n  op addHalf0 : OctetSum Octet -> HalfSum .\n  op dropCarryHalfSum : HalfSum -> Half .\n  op addHalf : Half Half -> Half .\n  op addHalfOctet : Octet Half -> Half .\n  op addHalfOctets : Octet Octet -> Half .\n  op addBlockSum : Block Block -> BlockSum .\n  op addBlock4 : Octet Octet Octet Octet Octet Octet Octet Octet -> BlockSum .\n  op addBlock3 : Octet Octet Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock2 : Octet Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock1 : Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock0 : OctetSum Octet Octet Octet -> BlockSum .\n  op dropCarryBlockSum : BlockSum -> Block .\n  op addBlock : Block Block -> Block .\n  op addBlockHalf : Half Block -> Block .\n  op addBlockHalves : Half Half -> Block .\n  op leftOctet1 : Octet -> Octet .\n  op leftOctet2 : Octet -> Octet .\n  op leftOctet3 : Octet -> Octet .\n  op leftOctet4 : Octet -> Octet .\n  op leftOctet5 : Octet -> Octet .\n  op leftOctet6 : Octet -> Octet .\n  op leftOctet7 : Octet -> Octet .\n  op rightOctet1 : Octet -> Octet .\n  op rightOctet2 : Octet -> Octet .\n  op rightOctet3 : Octet -> Octet .\n  op rightOctet4 : Octet -> Octet .\n  op rightOctet5 : Octet -> Octet .\n  op rightOctet6 : Octet -> Octet .\n  op rightOctet7 : Octet -> Octet .\n  op mulOctet : Octet Octet -> Half .\n  op mulOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet2 : Bit Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet3 : Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet4 : Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet5 : Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet6 : Bit Bit Bit Octet Half -> Half .\n  op mulOctet7 : Bit Bit Octet Half -> Half .\n  op mulOctet8 : Bit Octet Half -> Half .\n  op mulOctetA : Half Octet Octet -> Half .\n  op mulOctetB : Octet OctetSum -> Half .\n  op mulHalf : Half Half -> Block .\n  op mulHalfA : Half Half Half Half -> Block .\n  op mulHalf4 : Octet Octet Octet Octet Octet Octet Octet Octet -> Block .\n  op mulHalf3 : Octet Octet Octet Half Octet -> Block .\n  op mulHalf2 : Octet Half Octet Octet -> Block .\n  op mulHalf1 : Half Octet Octet Octet -> Block .\n  op mulBlock : Block Block -> Pair .\n  op mulBlockA : Block Block Block Block -> Pair .\n  op mulBlock4 : Half Half Half Half Half Half Half Half -> Pair .\n  op mulBlock3 : Half Half Half Block Half -> Pair .\n  op mulBlock2 : Half Block Half Half -> Pair .\n  op mulBlock1 : Block Half Half Half -> Pair .\n  op mulBlockB : Half Half Half Half -> Pair .\n  op addNat : Nat Nat -> Nat .\n  op multNat : Nat Nat -> Nat .\n  op eqNat : Nat Nat -> Xbool .\n  op ltNat : Nat Nat -> Xbool .\n  op n1 : -> Nat .\n  op n2 : -> Nat .\n  op n3 : -> Nat .\n  op n4 : -> Nat .\n  op n5 : -> Nat .\n  op n6 : -> Nat .\n  op n7 : -> Nat .\n  op n8 : -> Nat .\n  op n9 : -> Nat .\n  op n10 : -> Nat .\n  op n11 : -> Nat .\n  op n12 : -> Nat .\n  op n13 : -> Nat .\n  op n14 : -> Nat .\n  op n15 : -> Nat .\n  op n16 : -> Nat .\n  op n17 : -> Nat .\n  op n18 : -> Nat .\n  op n19 : -> Nat .\n  op n20 : -> Nat .\n  op n21 : -> Nat .\n  op n22 : -> Nat .\n  op n254 : -> Nat .\n  op n256 : -> Nat .\n  op n4100 : -> Nat .\n  op andOctet : Octet Octet -> Octet .\n  op orOctet : Octet Octet -> Octet .\n  op xorOctet : Octet Octet -> Octet .\n  op x02 : -> Octet .\n  op x03 : -> Octet .\n  op x04 : -> Octet .\n  op x05 : -> Octet .\n  op x06 : -> Octet .\n  op x07 : -> Octet .\n  op x08 : -> Octet .\n  op x09 : -> Octet .\n  op x0A : -> Octet .\n  op x0B : -> Octet .\n  op x0C : -> Octet .\n  op x0D : -> Octet .\n  op x0E : -> Octet .\n  op x0F : -> Octet .\n  op x10 : -> Octet .\n  op x11 : -> Octet .\n  op x12 : -> Octet .\n  op x13 : -> Octet .\n  op x14 : -> Octet .\n  op x15 : -> Octet .\n  op x16 : -> Octet .\n  op x17 : -> Octet .\n  op x18 : -> Octet .\n  op x1A : -> Octet .\n  op x1B : -> Octet .\n  op x1C : -> Octet .\n  op x1D : -> Octet .\n  op x1E : -> Octet .\n  op x1F : -> Octet .\n  op x20 : -> Octet .\n  op x21 : -> Octet .\n  op x23 : -> Octet .\n  op x24 : -> Octet .\n  op x25 : -> Octet .\n  op x26 : -> Octet .\n  op x27 : -> Octet .\n  op x28 : -> Octet .\n  op x29 : -> Octet .\n  op x2A : -> Octet .\n  op x2B : -> Octet .\n  op x2D : -> Octet .\n  op x2E : -> Octet .\n  op x2F : -> Octet .\n  op x30 : -> Octet .\n  op x31 : -> Octet .\n  op x32 : -> Octet .\n  op x33 : -> Octet .\n  op x34 : -> Octet .\n  op x35 : -> Octet .\n  op x36 : -> Octet .\n  op x37 : -> Octet .\n  op x38 : -> Octet .\n  op x39 : -> Octet .\n  op x3A : -> Octet .\n  op x3B : -> Octet .\n  op x3C : -> Octet .\n  op x3D : -> Octet .\n  op x3F : -> Octet .\n  op x40 : -> Octet .\n  op x46 : -> Octet .\n  op x48 : -> Octet .\n  op x49 : -> Octet .\n  op x4A : -> Octet .\n\t.\n   op x4A : -> Octet .\n  op x4B : -> Octet .\n  op x4C : -> Octet .\n  op x4D : -> Octet .\n  op x4E : -> Octet .\n  op x4F : -> Octet .\n  op x50 : -> Octet .\n  op x51 : -> Octet .\n  op x53 : -> Octet .\n  op x54 : -> Octet .\n  op x55 : -> Octet .\n  op x58 : -> Octet .\n  op x5A : -> Octet .\n  op x5B : -> Octet .\n  op x5C : -> Octet .\n  op x5D : -> Octet .\n  op x5E : -> Octet .\n  op x5F : -> Octet .\n  op x60 : -> Octet .\n  op x61 : -> Octet .\n  op x62 : -> Octet .\n  op x63 : -> Octet .\n  op x64 : -> Octet .\n  op x65 : -> Octet .\n  op x66 : -> Octet .\n  op x67 : -> Octet .\n  op x69 : -> Octet .\n  op x6A : -> Octet .\n  op x6B : -> Octet .\n  op x6C : -> Octet .\n  op x6D : -> Octet .\n  op x6E : -> Octet .\n  op x6F : -> Octet .\n  op x70 : -> Octet .\n  op x71 : -> Octet .\n  op x72 : -> Octet .\n  op x73 : -> Octet .\n  op x74 : -> Octet .\n  op x75 : -> Octet .\n  op x76 : -> Octet .\n  op x77 : -> Octet .\n  op x78 : -> Octet .\n  op x79 : -> Octet .\n  op x7A : -> Octet .\n  op x7B : -> Octet .\n  op x7C : -> Octet .\n  op x7D : -> Octet .\n  op x7E : -> Octet .\n  op x7F : -> Octet .\n  op x80 : -> Octet .\n  op x81 : -> Octet .\n  op x83 : -> Octet .\n  op x84 : -> Octet .\n  op x85 : -> Octet .\n  op x86 : -> Octet .\n  op x88 : -> Octet .\n  op x89 : -> Octet .\n  op x8A : -> Octet .\n  op x8C : -> Octet .\n  op x8D : -> Octet .\n  op x8E : -> Octet .\n  op x8F : -> Octet .\n  op x90 : -> Octet .\n  op x91 : -> Octet .\n  op x92 : -> Octet .\n  op x93 : -> Octet .\n  op x95 : -> Octet .\n  op x96 : -> Octet .\n  op x97 : -> Octet .\n  op x98 : -> Octet .\n  op x99 : -> Octet .\n  op x9A : -> Octet .\n  op x9B : -> Octet .\n  op x9C : -> Octet .\n  op x9D : -> Octet .\n  op x9E : -> Octet .\n  op x9F : -> Octet .\n  op xA0 : -> Octet .\n  op xA1 : -> Octet .\n  op xA2 : -> Octet .\n  op xA3 : -> Octet .\n  op xA4 : -> Octet .\n  op xA5 : -> Octet .\n  op xA6 : -> Octet .\n  op xA7 : -> Octet .\n  op xA8 : -> Octet .\n  op xA9 : -> Octet .\n  op xAA : -> Octet .\n  op xAB : -> Octet .\n  op xAC : -> Octet .\n  op xAE : -> Octet .\n  op xAF : -> Octet .\n  op xB0 : -> Octet .\n  op xB1 : -> Octet .\n  op xB2 : -> Octet .\n  op xB3 : -> Octet .\n  op xB5 : -> Octet .\n  op xB6 : -> Octet .\n  op xB8 : -> Octet .\n  op xB9 : -> Octet .\n  op xBA : -> Octet .\n  op xBB : -> Octet .\n  op xBC : -> Octet .\n  op xBE : -> Octet .\n  op xBF : -> Octet .\n  op xC0 : -> Octet .\n  op xC1 : -> Octet .\n  op xC2 : -> Octet .\n  op xC4 : -> Octet .\n  op xC5 : -> Octet .\n  op xC6 : -> Octet .\n  op xC7 : -> Octet .\n  op xC8 : -> Octet .\n  op xC9 : -> Octet .\n  op xCA : -> Octet .\n  op xCB : -> Octet .\n  op xCC : -> Octet .\n  op xCD : -> Octet .\n  op xCE : -> Octet .\n  op xD0 : -> Octet .\n  op xD1 : -> Octet .\n  op xD2 : -> Octet .\n  op xD3 : -> Octet .\n  op xD4 : -> Octet .\n  op xD5 : -> Octet .\n  op xD6 : -> Octet .\n  op xD7 : -> Octet .\n  op xD8 : -> Octet .\n  op xD9 : -> Octet .\n  op xDB : -> Octet .\n  op xDC : -> Octet .\n  op xDD : -> Octet .\n  op xDE : -> Octet .\n  op xDF : -> Octet .\n  op xE0 : -> Octet .\n  op xE1 : -> Octet .\n  op xE3 : -> Octet .\n  op xE6 : -> Octet .\n  op xE8 : -> Octet .\n  op xE9 : -> Octet .\n  op xEA : -> Octet .\n  op xEB : -> Octet .\n  op xEC : -> Octet .\n  op xED : -> Octet .\n  op xEE : -> Octet .\n  op xEF : -> Octet .\n  op xF0 : -> Octet .\n  op xF1 : -> Octet .\n  op xF2 : -> Octet .\n  op xF3 : -> Octet .\n  op xF4 : -> Octet .\n  op xF5 : -> Octet .\n  op xF6 : -> Octet .\n  op xF7 : -> Octet .\n  op xF8 : -> Octet .\n  op xF9 : -> Octet .\n  op xFA : -> Octet .\n  op xFB : -> Octet ."]], "MAUDE-1/AU_and_A_UnificationEdgeCases.maude": [[true, "*** \n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST-EXAMPLE-1 is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST-EXAMPLE-2 is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\n____()___\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO-EXAMPLE-1 is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2-EXAMPLE-2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3-EXAMPLE-3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO-EXAMPLE-4 is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a .", "```maude\n*** \n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST-EXAMPLE-1 is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST-EXAMPLE-2 is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\n____()___\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO-EXAMPLE-1 is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2-EXAMPLE-2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3-EXAMPLE-3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO-EXAMPLE-4 is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a .\n```"]], "MAUDE-1/AU_IrredUnification.maude": [[true, "***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\n  vars A B C X Y Z : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : List List -> List [assoc id: nil] .\n  vars L M N : List .\n  vars E F G : Elt .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero .\n  op s : Nat -> NzNat [iter] .\n  op _*_ : NzNat NzNat -> NzNat [assoc comm s(0) prec 31] .\n  op _*_ : Nat Nat -> Nat [ditto] .\n\n  vars W X Y Z M N C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [comm id: c(a, d)] .\n  op c : Foo Foo -> Foo [comm] .\n  vars W X Y Z M N C D : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(X, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: g(b, d)] .\n  op g : Foo Foo -> Foo [assoc id: f(a, b)] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: h(f(a, b))] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, Z:Hi) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\n  op f : Lo Lo -> Lo [assoc id: 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) .", "```maude\n***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\n  vars A B C X Y Z : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : List List -> List [assoc id: nil] .\n  vars L M N : List .\n  vars E F G : Elt .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero .\n  op s : Nat -> NzNat [iter] .\n  op _*_ : NzNat NzNat -> NzNat [assoc comm s(0) prec 31] .\n  op _*_ : Nat Nat -> Nat [ditto] .\n\n  vars W X Y Z M N C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [comm id: c(a, d)] .\n  op c : Foo Foo -> Foo [comm] .\n  vars W X Y Z M N C D : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(X, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: g(b, d)] .\n  op g : Foo Foo -> Foo [assoc id: f(a, b)] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: h(f(a, b))] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, Z:Hi) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\n  op f : Lo Lo -> Lo [assoc id: 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) .\n```"]], "MAUDE-1/bank.maude": [[true, "fmod BANK-INT+ID is \n    inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | STS >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is \n    inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 50) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Charlie, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Charlie, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Charlie, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 70) ; debit(Alice, 125) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 55) ; transfer(Bob, Alice, 60) ; credit(Charlie, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Charlie, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(A ; ST) = s(numberOfAccounts(ST)) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm", "```maude\nfmod BANK-INT+ID is \n    inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | STS >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is \n    inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 50) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Charlie, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Charlie, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Charlie, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 70) ; debit(Alice, 125) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 55) ; transfer(Bob, Alice, 60) ; credit(Charlie, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Charlie, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(A ; ST) = s(numberOfAccounts(ST)) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm\n```"]], "MAUDE-1/bike.maude": [[true, "fmod POLYNOMIAL-ARITHMETIC is\n    sorts Polynomial Pair .\n    subsort Polynomial < Pair .\n    op 0 : -> Polynomial .\n    op 1 : -> Polynomial .\n    op _p+_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n    op _p*_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n    op inv : Polynomial -> Polynomial .\n    op first : Pair -> Polynomial .\n    op second : Pair -> Polynomial .\n    op [_,_] : Polynomial Polynomial -> Pair .\nendfm\n\nfmod MESSAGE-STRUCTURE is\n    sorts Identifier Message Content Keys SKey PKey Data .\n    subsort Identifier < Content .\n    subsort SKey PKey < Keys .\n    subsort Data < Content .\n    op emptyK : -> Keys .\n    op none : -> Identifier .\n    op _;_ : Keys Keys -> Keys [assoc comm] .\n    op msg{_} : Content -> Message .\n    op sentPK : -> Data .\n    op receivedPK : -> Data .\n    op sentC : -> Data .\n    op receivedC : -> Data .\n    op publicKey : Identifier Polynomial -> Keys .\n    op sharedKey : Identifier SKey -> Keys .\n    op cI : Identifier Pair -> Content .\n    op hI : Identifier Pair -> Content .\n    op sigmaI : Identifier Polynomial -> Content .\n    op mI : Identifier Polynomial -> Content .\n    op K : Polynomial Pair -> SKey .\n    op L : Pair -> Polynomial .\n    op H : Polynomial -> Pair .\n    op decoder : Polynomial Polynomial Polynomial -> Pair .\n    op xorD : Polynomial Polynomial -> Polynomial .\nendfm\n\nmod BIKE-PROTOCOL is\n    including POLYNOMIAL-ARITHMETIC .\n    including MESSAGE-STRUCTURE .\n\n    sorts GlobalState Participants .\n    subsort Identifier < Participants .\n    op emptyM : -> Message .\n    op _ _ : Message Message -> Message [assoc comm] .\n    op {} : Content -> GlobalState .\n    op <_>_ : Participants Participants -> GlobalState .\n    op >net(_) : Message -> GlobalState .\n    op sigmas : Content -> Content .\n    op ms : Content -> Content .\n    op hs : Content -> Content .\n\n    op sampleSigma : Content -> Content .\n    op ms : Content -> Content .\n    op hs : Content -> Content .\n    op sigmaI : Identifier Polynomial -> Content .\n    op mI : Identifier Polynomial -> Content .\n    op hI : Identifier Pair -> Content .\n\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(Bob)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    vars ID1 ID2 ID3 : Identifier .\n    var PS : Participants .\n    vars SAM1 SAM2 : Data .\n    vars SK SK' : SKey .\n    vars PK PK' : Polynomial .\n    vars Cs Cs' : Pair .\n    vars Hs : Pair .\n    vars C1 C2 : Polynomial .\n    vars E0 E1 : Polynomial .\n    var M : Polynomial .\n    vars KS1 KS2 KS3 : Keys .\n    vars CONT1 CONT2 CONT3 : Content .\n\n    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(Hs) CONT3} < (ID1[emptyK]peer(none)) PS >net(MSGS) \n                    => \n                    {sigmas(CONT1) hs(Hs) CONT3} < (ID1[publicKey(ID1, second(Hs) p* inv(first(Hs)))]peer(none) sigmaI(ID1,SAM1) hI(ID1, Hs)) PS >net(MSGS) \n                    if PK := (second(Hs) p* inv(first(Hs))) .\n\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .\n    \n    crl [Enc] : {ms(M) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, K(M,[(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )])) ; KS2]peer(ID1) mI(ID2, M) cI(ID2, [(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )]) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(M) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    SK := K(M, [(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )]) .\n\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID2, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)}) \n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\ \n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n    \n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS') \n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, K((second(Cs) xorD L(decoder((first(Cs) p* first(Hs)), first(Hs), second(Hs)))), Cs)) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) \n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder((first(Cs) p* first(Hs)), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := (second(Cs)) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK) ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) \n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,1) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(Eve,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs) peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,Cs) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(Eve,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,1) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, K((second(Cs)) xorD L(first(Cs)), Cs)) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)}) \n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm", "```maude\nfmod POLYNOMIAL-ARITHMETIC is\n    sorts Polynomial Pair .\n    subsort Polynomial < Pair .\n    op 0 : -> Polynomial .\n    op 1 : -> Polynomial .\n    op _p+_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n    op _p*_ : Polynomial Polynomial -> Polynomial [assoc comm] .\n    op inv : Polynomial -> Polynomial .\n    op first : Pair -> Polynomial .\n    op second : Pair -> Polynomial .\n    op [_,_] : Polynomial Polynomial -> Pair .\nendfm\n\nfmod MESSAGE-STRUCTURE is\n    sorts Identifier Message Content Keys SKey PKey Data .\n    subsort Identifier < Content .\n    subsort SKey PKey < Keys .\n    subsort Data < Content .\n    op emptyK : -> Keys .\n    op none : -> Identifier .\n    op _;_ : Keys Keys -> Keys [assoc comm] .\n    op msg{_} : Content -> Message .\n    op sentPK : -> Data .\n    op receivedPK : -> Data .\n    op sentC : -> Data .\n    op receivedC : -> Data .\n    op publicKey : Identifier Polynomial -> Keys .\n    op sharedKey : Identifier SKey -> Keys .\n    op cI : Identifier Pair -> Content .\n    op hI : Identifier Pair -> Content .\n    op sigmaI : Identifier Polynomial -> Content .\n    op mI : Identifier Polynomial -> Content .\n    op K : Polynomial Pair -> SKey .\n    op L : Pair -> Polynomial .\n    op H : Polynomial -> Pair .\n    op decoder : Polynomial Polynomial Polynomial -> Pair .\n    op xorD : Polynomial Polynomial -> Polynomial .\nendfm\n\nmod BIKE-PROTOCOL is\n    including POLYNOMIAL-ARITHMETIC .\n    including MESSAGE-STRUCTURE .\n\n    sorts GlobalState Participants .\n    subsort Identifier < Participants .\n    op emptyM : -> Message .\n    op _ _ : Message Message -> Message [assoc comm] .\n    op {} : Content -> GlobalState .\n    op <_>_ : Participants Participants -> GlobalState .\n    op >net(_) : Message -> GlobalState .\n    op sigmas : Content -> Content .\n    op ms : Content -> Content .\n    op hs : Content -> Content .\n\n    op sampleSigma : Content -> Content .\n    op ms : Content -> Content .\n    op hs : Content -> Content .\n    op sigmaI : Identifier Polynomial -> Content .\n    op mI : Identifier Polynomial -> Content .\n    op hI : Identifier Pair -> Content .\n\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(Bob)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    vars ID1 ID2 ID3 : Identifier .\n    var PS : Participants .\n    vars SAM1 SAM2 : Data .\n    vars SK SK' : SKey .\n    vars PK PK' : Polynomial .\n    vars Cs Cs' : Pair .\n    vars Hs : Pair .\n    vars C1 C2 : Polynomial .\n    vars E0 E1 : Polynomial .\n    var M : Polynomial .\n    vars KS1 KS2 KS3 : Keys .\n    vars CONT1 CONT2 CONT3 : Content .\n\n    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(Hs) CONT3} < (ID1[emptyK]peer(none)) PS >net(MSGS) \n                    => \n                    {sigmas(CONT1) hs(Hs) CONT3} < (ID1[publicKey(ID1, second(Hs) p* inv(first(Hs)))]peer(none) sigmaI(ID1,SAM1) hI(ID1, Hs)) PS >net(MSGS) \n                    if PK := (second(Hs) p* inv(first(Hs))) .\n\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .\n    \n    crl [Enc] : {ms(M) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, K(M,[(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )])) ; KS2]peer(ID1) mI(ID2, M) cI(ID2, [(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )]) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(M) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    SK := K(M, [(E0 p+ (E1 p* (PK))), (M xorD L([(E0),(E1)]) )]) .\n\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID2, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)}) \n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\ \n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n    \n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS') \n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, K((second(Cs) xorD L(decoder((first(Cs) p* first(Hs)), first(Hs), second(Hs)))), Cs)) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) \n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder((first(Cs) p* first(Hs)), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := (second(Cs)) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK) ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) \n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,1) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(Eve,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs) peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,Cs) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(Eve,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,1) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, K((second(Cs)) xorD L(first(Cs)), Cs)) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)}) \n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm\n```"]], "MAUDE-1/closeSocketFeb2020.maude": [[false, "To complete the given incomplete protocol's formal analysis code with the Maude language, we will follow the provided description and template. The task is to fill in the blanks denoted by"]], "MAUDE-1/complexParserSyncApril2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .", "To complete the given incomplete file, we need to understand the context and the requirements of the Maude-NPA tool. The file seems to be related to testing the meta-parsing capabilities of Maude, specifically checking for a bug related to the cached simple parser.\n\nThe incomplete file is:\n```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, ____(EQ_1)____), none, '0, ____(EQ_0)____) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\n```\n\nThe task is to fill in the blanks (`____(EQ_1)____` and `____(EQ_0)____`) to complete the file.\n\n1. `____(EQ_1)____`: This is likely related to whether the module should be imported with its submodules or not. In Maude, when using `upModule`, the second argument can be a boolean indicating whether to include submodules. `true` means include submodules, and `false` means do not include them.\n\n2. `____(EQ_0)____`: This seems to be related to the parsing strategy or the sort to which the term should be parsed. In the context of `metaParse`, the fourth argument is the expected sort of the parsed term.\n\nGiven the context, the first blank (`____(EQ_1)____`) should be filled with `false` or `true` depending on whether we want to include submodules of 'NAT. For the purpose of this test and to keep it simple, we'll choose `false`.\n\nThe second blank (`____(EQ_0)____`) is likely expecting a sort. Since the term being parsed is `'0`, which is typically a constant of sort `Nat`, the expected sort should be `'Nat`.\n\nThus, the completed file should look like this:\n```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\n```\n\nLet's fill in the blanks accordingly and put it between ```maude and ```:\n```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\n```"]], "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Bar [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Bar [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab .\n```"]], "MAUDE-1/CUIbug12-22-09.maude": [[false, "```maude\n***(\nBug discovered 12/22/09.\n\nCUI_DagNode::stackArguments() checks the wrong UNSTACKABLE flag for the\nsecond argument resulting in a missed rewrite.\n\nResolved in alpha92b.\n)\nset show timing off .\n\nmod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo"]], "MAUDE-1/CUI_OccursCheckSeptember2020.maude": [[false, "To complete the given incomplete protocol's formal analysis code with the Maude language, we need to fill in the blanks indicated by `____()___`. The description provides the necessary details to understand the requirements and implement the code accordingly."]], "MAUDE-1/CU_Unification.maude": [[true, "set show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [left id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(1f, X) = X .\n  eq f(X, f(Y, Z)) = f(f(X, Y), Z) .\nendfm\n\nunify f(U, Y) =? f(U, V) .\nvariant unify f(X, V) =? f(U, W) .\n\nunify f(U, Y) =? X .\nvariant unify f(X, V) =? X .\n\nunify f(X, V) =? Y .\nvariant unify f(U, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [right id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, 1f) = X .\n  eq f(f(X, Y), Z) = f(X, f(Y, Z)) .\nendfm\n\nunify f(X, V) =? f(U, V) .\nvariant unify f(X, W) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op f : Foo Foo -> Foo [id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, 1f) = X .\n  eq f(1f, X) = X .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, Y) = f(Y, X) .\n  eq f(X, 1f) = X .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .", "```maude\nset show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [left id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(1f, X) = X .\n  eq f(X, f(Y, Z)) = f(f(X, Y), Z) .\nendfm\n\nunify f(U, Y) =? f(U, V) .\nvariant unify f(X, V) =? f(U, W) .\n\nunify f(U, Y) =? X .\nvariant unify f(X, V) =? X .\n\nunify f(X, V) =? Y .\nvariant unify f(U, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [right id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, 1f) = X .\n  eq f(f(X, Y), Z) = f(X, f(Y, Z)) .\nendfm\n\nunify f(X, V) =? f(U, V) .\nvariant unify f(X, W) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op f : Foo Foo -> Foo [id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, 1f) = X .\n  eq f(1f, X) = X .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n  eq f(X, Y) = f(Y, X) .\n  eq f(X, 1f) = X .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe.maude": [[true, "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg -> Msg [assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(i,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B,N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A,N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(i,a ; N)), +(pk(a,N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg -> Msg [assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(i,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B,N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A,N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(i,a ; N)), +(pk(a,N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude": [[false, "To complete the provided Maude file content as per the task's requirements, the given content is already mostly complete. It is a test for a bug related to unifier filtering in the context of the Maude-NPA tool. The task is to fill in the blanks indicated by ```____()___```, but there are no such blanks in the provided content. The content is as follows:\n\n```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .\n```\n\nGiven that there are no ```____()___``` to fill and the content does not seem to require additional completion based on the provided description, the \"completed\" file remains the same as the original. Thus, the Maude file content, when properly marked with ```maude``` tags, is:\n\n```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .\n```\n\nThis should compile successfully with Maude-NPA. Note that the initial tag was `houzhui`, which seems to be a placeholder or incorrect tag; it's been corrected to `maude` to match the request."]], "MAUDE-1/dekker.maude": [[true, "set show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\n  eq eval(Q = N, none) = false .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> UserStatement .\n  op if_then_fi : Test Program -> Program .\n  op if_then_else_fi : Test Program Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) .", "```maude\nset show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\n  eq eval(Q = N, none) = false .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> UserStatement .\n  op if_then_fi : Test Program -> Program .\n  op if_then_else_fi : Test Program Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) .\n```"]], "MAUDE-1/deleteTimerMarch2021.maude": [[false, "To complete the given Maude file, we need to identify the missing parts indicated by `____(VAR_0)____` and `____(EQ_0)____`. Based on the description provided, we can infer the necessary components.\n\n1. **Variables Declaration**: The variables `O`, `O2`, and `O3` are declared as `Oid`. The missing declaration `____(VAR_0)____` should be filled with the variable `O1` or simply ensuring that `O` is properly used. However, upon closer inspection, it seems that `O` is already used, so we need to declare the variables correctly. The description mentions `O`, `O2`, and `O3` as object identifiers, so we should ensure these are properly declared.\n\n2. **Initial State**: The initial state involves `createTimer(timeManager, ____(EQ_0)____)`. Given that `me` is an object identifier of type `Oid` and is used in the context of `createTimer`, it is logical to use `me` as the second argument to `createTimer`, as seen in the description of the initial state.\n\nBased on the protocol description, the Maude code seems to be mostly structured. Let's fill in the blanks.\n\nFor `____(VAR_0)____`, we need to declare the variable(s) used in the rule. The rule uses `O`, `O2`, and `O3`, so we should declare these. If there's an additional variable like `O1`, it should be included. However, the rule only explicitly mentions `O`, `O2`, and `O3`, so we should focus on these.\n\nFor `____(EQ_0)____`, the description suggests using `me`, as it represents the object identifier used in the context.\n\nHere is the completed Maude file:"]], "MAUDE-1/dining-philosophers5.maude": [[true, "set show timing off .\nset show advisories off .\nset verbose on .\n\nfmod POSRAT-TIME-DOMAIN-WITH-INF is\n  sorts NNegRat Time TimeInf .\n  subsort NNegRat < Time .\n  subsort Time < TimeInf .\n\n  op INF : -> TimeInf [ctor] .\n\n  op _<_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _<=_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _+_ : NNegRat NNegRat -> NNegRat [assoc comm prec 33 gather (E e)] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : NzNat Zero -> Zero [ditto] .\n  op max : Zero NzNat -> NzNat [ditto] .\n  op max : Rat TimeInf -> TimeInf [ditto] .\n  op max : Rat NNegRat -> NNegRat [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    class Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I J N M K : Nat .\n    vars Atts1 Atts2 : AttributeSet .\n    vars T T' : Time .\n    var Conf : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op mte : Configuration -> Time .\n    eq mte(< I : Philosopher | timer : T > Atts1 Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration Time -> Configuration .\n    eq delta(< I : Philosopher | timer : T > Atts1 Conf, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n    eq delta(Conf, T') = Conf [owise] .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat Status -> Prop .\n    op phil-sticks : Nat Nat -> Prop .\n    \n    vars P N : Nat .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St, Atts > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N, Atts > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, 2) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(3, 1) /\\ phil-sticks(4, 1))) .", "```maude\nset show timing off .\nset show advisories off .\nset verbose on .\n\nfmod POSRAT-TIME-DOMAIN-WITH-INF is\n  sorts NNegRat Time TimeInf .\n  subsort NNegRat < Time .\n  subsort Time < TimeInf .\n\n  op INF : -> TimeInf [ctor] .\n\n  op _<_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _<=_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _+_ : NNegRat NNegRat -> NNegRat [assoc comm prec 33 gather (E e)] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : NzNat Zero -> Zero [ditto] .\n  op max : Zero NzNat -> NzNat [ditto] .\n  op max : Rat TimeInf -> TimeInf [ditto] .\n  op max : Rat NNegRat -> NNegRat [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    class Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I J N M K : Nat .\n    vars Atts1 Atts2 : AttributeSet .\n    vars T T' : Time .\n    var Conf : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op mte : Configuration -> Time .\n    eq mte(< I : Philosopher | timer : T > Atts1 Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration Time -> Configuration .\n    eq delta(< I : Philosopher | timer : T > Atts1 Conf, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n    eq delta(Conf, T') = Conf [owise] .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat Status -> Prop .\n    op phil-sticks : Nat Nat -> Prop .\n    \n    vars P N : Nat .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St, Atts > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N, Atts > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, 2) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(3, 1) /\\ phil-sticks(4, 1))) .\n```"]], "MAUDE-1/diophantine.maude": [[true, "set show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector(5), \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1 ; 6 |-> 1),\n\"gcd\"\n) .", "```maude\nset show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector(5), \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1 ; 6 |-> 1),\n\"gcd\"\n) .\n```"]], "MAUDE-1/doubleAttributeFebruary2023.maude": [[true, "fmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm", "To complete the given incomplete file according to the provided description, we need to fill in the missing parts indicated by `____(OP_0)____` and `____(OP_1)____` in the Maude code.\n\nThe description explains that the operation `f` is defined with a double iteration attribute. In Maude, the attribute for an operation to be iterative is denoted by `iter`. Therefore, to represent a double iteration attribute, we should use `iter` twice.\n\nThus, the completed Maude code should be:\n\n```maude\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm\n```\n\nThis matches the example given in the description under \"Corresponding Maude File.\" \n\nSo, the completed file with the required format is:\n```maude\n***\n***\tTest for warning with double iter attribute.\n***\n\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm\n```"]], "MAUDE-1/Example1.maude": [[true, "and", "To complete the given Maude-NPA code, we need to ensure that it is correctly formatted and that all necessary components are defined. The provided code snippet seems to be mostly complete but requires some adjustments to be compilable by Maude-NPA.\n\nThe task indicates that the code should be between ```maude and ```. Let's directly examine and adjust the given code to fit the requirements.\n\n\n```maude\n***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting, outcome: none, active: true, repeatc: const(v(false)), startc: \n    const(v(true)), endc: const(v(true)), post: const(v(true)), skip: const(v(false)), pre: const(v(\n    true)), inv: const(v(true)), priority: 1, loopenabled: true, ('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0), actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .\n```"]], "MAUDE-1/Example3.maude": [[false, "To complete the given incomplete file, we need to analyze the provided description and code snippet.\n\nThe given code is in Maude language and appears to be related to the PLEXILITE language, which is used for specifying and analyzing plans and protocols. The task is to fill in the missing parts indicated by `____()___`.\n\nHowever, upon closer inspection, it becomes apparent that the missing parts are not directly indicated by `____()___` in the provided snippet. Instead, we need to ensure that the given code is complete and correctly represents the protocol `Example3` as described.\n\nHere's the step-by-step reasoning to complete the task:\n\n1. **Understand the Protocol Description**: The protocol `Example3` involves a node `N` that starts execution based on a condition related to the value of `X` over the last 5 time units. The variable `x` is assigned the current value of `X`.\n\n2. **Review the Given Code**: The code defines a Maude module `EXAMPLE3` that protects `PLEXILITE-PREDS`. It specifies an operation `Example3` representing the protocol and another operation `Example3Env` representing the environment context.\n\n3. **Identify Missing Elements**: The code seems mostly complete. The `Example3` operation defines a node `N` with a start condition involving `lookupOnChange('X,v(5)) >= const(v(9))`, and `x` is assigned the value of `lookup('X)`. The environment `Example3Env` is defined with a list of states for `X`.\n\n4. **Complete the Code**: Upon reviewing the provided snippet, it appears that the code is already quite complete and does not have obvious gaps indicated by `____()___`. The task, therefore, is to verify that the given code matches the description and is syntactically correct.\n\nGiven the information and the code snippet:"]], "MAUDE-1/fakeParameterConstant.maude": [[true, "***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op ____(OP_0)____ : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> ____(OP_1)____ [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "To complete the given file according to the description, we first examine the provided incomplete code and the description given.\n\nThe incomplete code is:\n```maude\n***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op ____(OP_0)____ : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> ____(OP_1)____ [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```\n\nFrom the description, we understand the structure and the intent behind the code. \n\n1. The theory `T` defines a sort `Elt` and a parameter constant `c` of sort `Elt`. So, `____(OP_0)____` should be `c`.\n\n2. The module `FOO` is parameterized by `T`, and it defines a new constant `d` of sort `Elt`. The sort of `d` should be `X$Elt` because `X` is the parameter and `Elt` is the sort defined in theory `T`. Thus, `____(OP_1)____` should be `X$Elt`.\n\nLet's fill in the blanks accordingly and provide the completed code.\n\n```maude\n***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op c : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> X$Elt [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/fakeParameterSort.maude": [[true, "*** \n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < ____()___ .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "To complete the given Maude code, we need to understand the issue presented. The provided code seems mostly complete but is missing a crucial part that causes it not to compile successfully in Maude-NPA or Maude. The incomplete parts are indicated by `____()___`, but in the given text, there are no such indicators. However, upon closer inspection, the issue seems to be related to the fact that `X$Elt` is used in `FOO{X :: T}` without being defined.\n\nHere's the step-by-step reasoning to fix the issue:\n\n1. **Identify the Problem**: The code defines a theory `T` with a sort `Elt` and then uses it to parameterize modules `FOO` and `BAR`. The issue lies in `FOO{X :: T}` where it tries to establish a subsort relationship between `X$Foo` and `X$Elt`. However, `X$Elt` is not defined anywhere.\n\n2. **Understand the Requirement**: Since `X` is constrained by theory `T`, and `T` defines a sort `Elt`, we should be able to use `X$Elt` if it's properly defined or use the sort `Elt` directly if that's the intention.\n\n3. **Proposed Solution**: The intention seems to be to establish a subsort relationship within the parameterized module `FOO`. Given `X :: T`, `X$Elt` should correspond to the sort `Elt` from the theory `T`. Thus, we should directly use `Elt` instead of `X$Elt` because `Elt` is the sort defined in `T`, and `X$Elt` is not a standard way to refer to it in this context.\n\nHere's how you can modify the code:\n\n```maude\n*** \n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < ____()___ .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```\n\nGiven the issue identified, we can directly use `Elt` instead of `X$Elt` in the subsort declaration because `Elt` is the sort defined in theory `T` and thus available in any module parameterized by `T`. So, the corrected code should look like this:\n\n```maude\n*** \n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```\n\nTherefore, the completed file is:\n```maude\n*** \n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude": [[true, "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y NA Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars NA NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(B,NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(A,NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,A ; NA)), +(pk(a,NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y NA Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars NA NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(B,NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(A,NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,A ; NA)), +(pk(a,NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/filteredVariantUnifyJune2023.maude": [[true, "set show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat -> Stk [ctor] .\n  op _*_ : Stk Stk -> Stk [assoc emp] .\n  op _+_ : Stk Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : Stk .\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches", "```maude\nset show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat -> Stk [ctor] .\n  op _*_ : Stk Stk -> Stk [assoc emp] .\n  op _+_ : Stk Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : Stk .\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches\n```"]], "MAUDE-1/generatedByFebruary2023.maude": [[true, "fmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .", "The given incomplete code is already complete based on the description. The task is to fill in the blanks indicated by ```____()___```, but there are no such blanks in the provided code. The code is:\n\n```maude\nfmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .\n```\n\nThis code matches the description given and does not contain any ```____()___``` to be filled. Therefore, the completed file remains the same as the provided incomplete file.\n\n```maude\nfmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .\n```"]], "MAUDE-1/hf-sets.maude": [[true, "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {___} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma Magma              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({S}), M) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({M},@6:Set)U augment({M'},@6:Set)\n    = augment({M,M'},@6:Set) .\n  cp HF-SETS4 for 53 and 53\n    P({M,M'})U augment(P({M}),@1:Set)U augment(P({M'})U augment(P({M}),M),@2:Set)\n    = P({M})U augment(P({M'}),@2:Set)U augment(P({M})U augment(P({M'}),M),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({M,M'})U augment(P({M'}),@2:Set)\n    = P({M',M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),M'),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({M},@2:Set)\n    = augment({M},@2:Set) .\n  cp HF-SETS54 for 01 and 63\n    augment({M,M'},@3:Set)U augment({M},@3:Set)\n    = augment({M},@3:Set)U augment({M},@3:Set)U augment({M'},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({M,M'},@4:Set)U augment({M'},@4:Set)U augment({M''},M,M')\n    = augment({M},@4:Set)U augment({M'},@4:Set)U augment({M'},@4:Set)U augment({M''},M,M').\n  cp HF-SETS95 for 01 and 63\n    augment({M},@5:Set)U augment({M'},@5:Set)U augment({M''},@5:Set)U augment({M'''},M,M',M'')\n    = augment({M,M',M''},@5:Set)U augment({M},@5:Set)U augment({M'},@5:Set)U augment({M''},@5:Set)U augment({M'''},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({M})U augment(P({M}),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),@2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M})U augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({M})U augment(P({M}),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)", "```maude\nset include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {___} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma Magma              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({S}), M) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({M},@6:Set)U augment({M'},@6:Set)\n    = augment({M,M'},@6:Set) .\n  cp HF-SETS4 for 53 and 53\n    P({M,M'})U augment(P({M}),@1:Set)U augment(P({M'})U augment(P({M}),M),@2:Set)\n    = P({M})U augment(P({M'}),@2:Set)U augment(P({M})U augment(P({M'}),M),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({M,M'})U augment(P({M'}),@2:Set)\n    = P({M',M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),M'),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({M},@2:Set)\n    = augment({M},@2:Set) .\n  cp HF-SETS54 for 01 and 63\n    augment({M,M'},@3:Set)U augment({M},@3:Set)\n    = augment({M},@3:Set)U augment({M},@3:Set)U augment({M'},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({M,M'},@4:Set)U augment({M'},@4:Set)U augment({M''},M,M')\n    = augment({M},@4:Set)U augment({M'},@4:Set)U augment({M'},@4:Set)U augment({M''},M,M').\n  cp HF-SETS95 for 01 and 63\n    augment({M},@5:Set)U augment({M'},@5:Set)U augment({M''},@5:Set)U augment({M'''},M,M',M'')\n    = augment({M,M',M''},@5:Set)U augment({M},@5:Set)U augment({M'},@5:Set)U augment({M''},@5:Set)U augment({M'''},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({M})U augment(P({M}),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),@2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M})U augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(P({M})U augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({M})U augment(P({M}),@2:Set)\n    = P({M})U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@1:Set),@2:Set)\n    = P({M})U augment(P({M}),@1:Set)U augment(P({M}),@2:Set)U augment(augment(P({M}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)\n```"]], "MAUDE-1/identityUnificationMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in C/U/Ul/Ur unification where original\n***\trather than representative variable was used.\n***\n\nfmod FOO is\n  sort Small Foo .\n  subsort Small < Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc comm] .\n  op g : Foo -> Foo .\nvars X Y Z : Foo .\nvar S : Small .\neq f(X,1) = X .\nendfm\n\nunify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nvariant unify Z =? f(X, Y) /\\ g(Z) =? g(S) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in C/U/Ul/Ur unification where original\n***\trather than representative variable was used.\n***\n\nfmod FOO is\n  sort Small Foo .\n  subsort Small < Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc comm] .\n  op g : Foo -> Foo .\nvars X Y Z : Foo .\nvar S : Small .\neq f(X,1) = X .\nendfm\n\nunify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nvariant unify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n```"]], "MAUDE-1/instantiatedViewInternalNameOctober2022.maude": [[false, "The completed code is as follows:"]], "MAUDE-1/instantiationJuly2019.maude": [[true, "set show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : ____(OP_0)____ -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .", "To complete the given incomplete protocol's formal analysis code with the Maude language, we need to fill in the blank `____(OP_0)____` in the provided code snippet.\n\nThe code snippet is as follows:\n```maude\nset show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : ____(OP_0)____ -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .\n```\n\nBased on the description provided, the operation `f` in module `BAR` is defined to take a `Big` type and return a boolean. The sort `Big` is a supersort of `Small` (or `X$Small` where `X` is a theory with a sort `Small`), indicating that `f` should operate on `Big`.\n\nTherefore, the blank should be filled with `Big` to correctly represent the operation `f` that takes an argument of sort `Big` and returns a boolean.\n\nHere's the completed code:\n```maude\nset show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .\n```\n\nSo, the completed Maude code is:\n```maude\nset show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .\n```"]], "MAUDE-1/initialEqualityPredicate.maude": [[false, "To create the completed Maude file, we should carefully analyze the given incomplete file and fill in the missing parts according to the description.\n\nThe blank spaces are labeled as `____(OP_1)____`, `____(OP_0)____`, `____(OP_2)____`, `____(OP_3)____`, `____(VAR_0)____`, `____(VAR_1)____`, `____(EQ_1)____`, `____(VAR_2)____`, `____(EQ_9)____`, `____(EQ_7)____`, `____(EQ_13)____`, `____(EQ_19)____`, `____(EQ_4)____`, `____(EQ_5)____`, `____(EQ_18)____`, `____(EQ_6)____`, `____(EQ_11)____`, `____(EQ_2)____`, `____(EQ_24)____`, `____(EQ_16)____`, `____(EQ_0)____`, `____(EQ_17)____`, `____(EQ_10)____`, `____(OP_4)____`, `____(OP_5)____`, `____(OP_7)____`, `____(OP_6)____`, `____(OP_8)____`, `____(OP_9)____`, `____(OP_11)____`, `____(OP_12)____`, `____(OP_10)____`, `____(EQ_23)____`, `____(EQ_14)____`, `____(EQ_3)____`, `____(EQ_22)____`, `____(EQ_20)____`, `____(EQ_15)____`, `____(EQ_8)____`, `____(EQ_21)____`, and `____(EQ_25)____`.\n\nLet's analyze the given modules and equations:\n\n1. **Module DECOMPOSE**:\n   - `op c : ____(OP_1)____ Nat -> Nat"]], "MAUDE-1/irredUnifyFeb2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug irredundant unification where destructive updating\n***\tof unifiers having the same structure but different sorts caused\n***\tcorruption of unification filter and irredundant unifiers lost\n***\tto spurious subsumptions.\n***\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt Pair Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [ditto] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n  op __ : Pair List -> List [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : Elt .\n  vars P Q R : Pair .\n  vars S T U V : Triple .\n  vars E F G : Elt .\nendfm\n\nunify S T =? A B .\nirred unify S T =? A B .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug irredundant unification where destructive updating\n***\tof unifiers having the same structure but different sorts caused\n***\tcorruption of unification filter and irredundant unifiers lost\n***\tto spurious subsumptions.\n***\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt Pair Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [ditto] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n  op __ : Pair List -> List [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : Elt .\n  vars P Q R : Pair .\n  vars S T U V : Triple .\n  vars E F G : Elt .\nendfm\n\nunify S T =? A B .\nirred unify S T =? A B .\n```"]], "MAUDE-1/kindNameDecember2022.maude": [[false, "To complete the given incomplete protocol's formal analysis code with the Maude language, we need to fill in the blanks according to the provided description.\n\nThe description indicates that:\n- The subsort relationship should be defined such that `X$Elt` is a subsort of both `S{X}` and `T{X}`. Thus, `____(SUBSORT_0)____$Elt < S{X} T{X}` should be `X$Elt`.\n- The operation is defined as `f :"]], "MAUDE-1/lattice.maude": [[true, "set include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** sup\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** inf\n  op c :  Lat -> Lat .                     *** complement\n\n  vars X Y Z : Lat .\n\n  *** idempotency\n  eq [LAT-01] : X \\/ X = X .\n  eq [LAT-02] : X /\\ X = X .\n  *** extensions\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .\n\n  *** identities\n  eq [LAT-05] : X \\/ 0 = X .\n  eq [LAT-06] : X /\\ 1 = X .\n  \n  *** simple absorption (follows from identities and absorption)\n  eq [LAT-07] : 1 \\/ X = 1 .\n  eq [LAT-08] : 0 /\\ X = 0 .\n  *** absorption\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .\n  eq [LAT-10] : X \\/ (X /\\ Y) = X .\n  *** extensions\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .\n\n  *** modular lattice axiom\n  ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) == X .\n\n  *** complement axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .\n  eq [LAT-15] : X /\\ c(X) = 0 .\n  *** extensions\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .\n  ***\n  eq [LAT-18] : c(0) = 1 .\n  eq [LAT-19] : c(1) = 0 .\n  ***\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .\n  *** extensions\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .\nendfm", "```maude\nset include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** sup\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** inf\n  op c :  Lat -> Lat .                     *** complement\n\n  vars X Y Z : Lat .\n\n  *** idempotency\n  eq [LAT-01] : X \\/ X = X .\n  eq [LAT-02] : X /\\ X = X .\n  *** extensions\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .\n\n  *** identities\n  eq [LAT-05] : X \\/ 0 = X .\n  eq [LAT-06] : X /\\ 1 = X .\n  \n  *** simple absorption (follows from identities and absorption)\n  eq [LAT-07] : 1 \\/ X = 1 .\n  eq [LAT-08] : 0 /\\ X = 0 .\n  *** absorption\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .\n  eq [LAT-10] : X \\/ (X /\\ Y) = X .\n  *** extensions\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .\n\n  *** modular lattice axiom\n  ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) == X .\n\n  *** complement axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .\n  eq [LAT-15] : X /\\ c(X) = 0 .\n  *** extensions\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .\n  ***\n  eq [LAT-18] : c(0) = 1 .\n  eq [LAT-19] : c(1) = 0 .\n  ***\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .\n  *** extensions\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .\nendfm\n```"]], "MAUDE-1/nsl-db-dc.maude": [[true, "--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < Public .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [private] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) right] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r'' r3 : Fresh .\n  vars A B C : Name .\n  vars N NA NB NC : Nonce .\n  vars NS N' NS' : NonceSet .\n  vars X Y H : Msg .\n  vars P Q : Role .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(C,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r3 :: [ nil | +(n(i,r3)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; r-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(B',NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(A,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')), \n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')), \n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < Public .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [private] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) right] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r'' r3 : Fresh .\n  vars A B C : Name .\n  vars N NA NB NC : Nonce .\n  vars NS N' NS' : NonceSet .\n  vars X Y H : Msg .\n  vars P Q : Role .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(C,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r3 :: [ nil | +(n(i,r3)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; r-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(B',NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(A,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')), \n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')), \n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/legacyMetaGetVariant.maude": [[true, "set show timing off .\n\nfmod XOR is\n  sort XOR .\n\n  sort Elem .\n  ops cst1 cst2 cst3 cst4 : -> Elem .\n\n  subsort Elem < XOR .\n  op _+_ : XOR XOR -> XOR [assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X Y : XOR .\n\n  eq Y + 0 = Y [variant] .\n  eq X + X = 0 [variant] .\n  eq X + X + Y = Y [variant] .\nendfm\n\nfmod TEST is\n  inc XOR .\n  inc META-LEVEL .\nendfm\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(upModule('XOR, false), upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 10, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 3) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 4) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR), 0, 0) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1 + cst2), upTerm(X:XOR + cst1), 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 3) .", "```maude\nset show timing off .\n\nfmod XOR is\n  sort XOR .\n\n  sort Elem .\n  ops cst1 cst2 cst3 cst4 : -> Elem .\n\n  subsort Elem < XOR .\n  op _+_ : XOR XOR -> XOR [assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X Y : XOR .\n\n  eq Y + 0 = Y [variant] .\n  eq X + X = 0 [variant] .\n  eq X + X + Y = Y [variant] .\nendfm\n\nfmod TEST is\n  inc XOR .\n  inc META-LEVEL .\nendfm\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(upModule('XOR, false), upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 10, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 3) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 4) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR), 0, 0) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1 + cst2), upTerm(X:XOR + cst1), 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 3) .\n```"]], "MAUDE-1/mapToParameterTheory.maude": [[true, "set show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op _+_ : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  *** _+_ in fromTheory is implicitly mapped to _+_ in parameterTheory\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = X + Y .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** _+_ in eq h(X, Y) = X + Y should be mapped to _+_ in T by V, but then\n*** V2 instantiates the operator from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, Y:Bar) .\n\n\n******************************************\n*** op->term-explicit operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\nvars X Y : Elt2 .\n  op sum(X, Y) to term X + g(Y) .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to X + g(Y) by V, but then\n*** V2 instantiates the operator _+_ from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, g(Y:Bar)) .\n\n\n******************************************\n*** explicit-op->term operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to _+_ .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y : Elt .\n  op X + Y to term summation(inv(Y), inv(X)) .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to _+_ by V, but then\n*** V2 instantiates the operator from the parameter theory to summation\n*** summation(inv(Y), inv(X)) so we get\n***   eq h(X:Bar, Y:Bar) = summation(inv(Y:Bar), inv(X:Bar)) .\n\n\n*************************************************************\n*** explicit-op->term operator mapping with lost variable ***\n*************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y Z : Elt .\n  op +(X, Y, Z) to term summation(inv(X), inv(Z)) .  *** Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y Z : Y$Elt2 .\n  eq h(X, Y, Z) = sum(X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************************\n*** explicit-op->term operator mapping with two lost variables ***\n******************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars W X Y Z : Elt .\n  op +(W, X, Y, Z) to term summation(inv(X), inv(Z)) .  *** W, Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars W X Y Z : Y$Elt2 .\n  eq h(W, X, Y, Z) = sum(W, X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(W:Bar, X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************\n*** explicit-explicit polymorphic operator mapping ***\n******************************************************\n\nfth T is\n  sort Elt .\n  op f : Universal Universal -> Universal [poly(2 1)] .\n  ops a b : -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op f2 : Elt2 Universal -> Universal [poly(2 0)] .\nendfth\n\nfmod M{X :: T} is\n  sort One{X} Two{X} .\n  op g1 : One{X} -> One{X} .\n  op g2 : Two{X} -> Two{X} .\nvar X : One{X} .\nvar Y : Two{X} .\n  eq g1(X) = f(a, X) .\n  eq g2(Y) = f(b, Y) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\n  op f2 to f .  *** map polymorphic operator f2 to polymorphic operator f in parameter theory\nendv\n\nfmod C is\n  sort Bar .\n  op h : Universal Universal -> Universal [poly(1 0)] .\n  ops 1 2 : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op f to h .\n  op a to 1 .\n  op b to 2 .\nendv\n\nfmod M2{Y :: T2} is\n  sort MySort .\n  op p : Y$Elt2 Universal -> MySort .\nvar X : Y$Elt2 .\nvar Y : MySort .\n  eq p(X, Y) = f2(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\nred p(1, 2) .", "```maude\nset show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op _+_ : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  *** _+_ in fromTheory is implicitly mapped to _+_ in parameterTheory\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = X + Y .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** _+_ in eq h(X, Y) = X + Y should be mapped to _+_ in T by V, but then\n*** V2 instantiates the operator from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, Y:Bar) .\n\n\n******************************************\n*** op->term-explicit operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\nvars X Y : Elt2 .\n  op sum(X, Y) to term X + g(Y) .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to X + g(Y) by V, but then\n*** V2 instantiates the operator _+_ from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, g(Y:Bar)) .\n\n\n******************************************\n*** explicit-op->term operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to _+_ .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y : Elt .\n  op X + Y to term summation(inv(Y), inv(X)) .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to _+_ by V, but then\n*** V2 instantiates the operator from the parameter theory to summation\n*** summation(inv(Y), inv(X)) so we get\n***   eq h(X:Bar, Y:Bar) = summation(inv(Y:Bar), inv(X:Bar)) .\n\n\n*************************************************************\n*** explicit-op->term operator mapping with lost variable ***\n*************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y Z : Elt .\n  op +(X, Y, Z) to term summation(inv(X), inv(Z)) .  *** Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y Z : Y$Elt2 .\n  eq h(X, Y, Z) = sum(X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************************\n*** explicit-op->term operator mapping with two lost variables ***\n******************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars W X Y Z : Elt .\n  op +(W, X, Y, Z) to term summation(inv(X), inv(Z)) .  *** W, Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars W X Y Z : Y$Elt2 .\n  eq h(W, X, Y, Z) = sum(W, X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(W:Bar, X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************\n*** explicit-explicit polymorphic operator mapping ***\n******************************************************\n\nfth T is\n  sort Elt .\n  op f : Universal Universal -> Universal [poly(2 1)] .\n  ops a b : -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op f2 : Elt2 Universal -> Universal [poly(2 0)] .\nendfth\n\nfmod M{X :: T} is\n  sort One{X} Two{X} .\n  op g1 : One{X} -> One{X} .\n  op g2 : Two{X} -> Two{X} .\nvar X : One{X} .\nvar Y : Two{X} .\n  eq g1(X) = f(a, X) .\n  eq g2(Y) = f(b, Y) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\n  op f2 to f .  *** map polymorphic operator f2 to polymorphic operator f in parameter theory\nendv\n\nfmod C is\n  sort Bar .\n  op h : Universal Universal -> Universal [poly(1 0)] .\n  ops 1 2 : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op f to h .\n  op a to 1 .\n  op b to 2 .\nendv\n\nfmod M2{Y :: T2} is\n  sort MySort .\n  op p : Y$Elt2 Universal -> MySort .\nvar X : Y$Elt2 .\nvar Y : MySort .\n  eq p(X, Y) = f2(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\nred p(1, 2) .\n```"]], "MAUDE-1/metaApplyNov2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\treduction of the subject are not counted twice for\n***\tmetaApply()/metaXapply()\n***\n\nmod APPLY is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a c  : -> Bar .\n  op b : -> Foo .\n  op f : Foo Foo -> Foo [comm] .\n\n  eq a = c .\n  mb b : Foo .\n  rl f(X:Foo, Y:Foo) => X:Foo [label k] .\nendm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, none) .\nred in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\treduction of the subject are not counted twice for\n***\tmetaApply()/metaXapply()\n***\n\nmod APPLY is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a c  : -> Bar .\n  op b : -> Foo .\n  op f : Foo Foo -> Foo [comm] .\n\n  eq a = c .\n  mb b : Foo .\n  rl f(X:Foo, Y:Foo) => X:Foo [label k] .\nendm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, none) .\nred in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0) .\n```"]], "MAUDE-1/metaAutoOoIncludeFebruary2023.maude": [[true, "set show timing off .\n\n***\n***\tTesting Object-Oriented Inclusion in Maude\n***\n\noth FOO is\n  sorts ____()___ .\n  subsort ____()___ < ____()___ .\n  op ____()___ : -> ____()___ .\n  vars ____()___ : ____()___ .\n  eq ____()___ = ____()___ .\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .", "```maude\nset show timing off .\n\n***\n***\tTesting Object-Oriented Inclusion in Maude\n***\n\noth FOO is\n  sorts ____()___ .\n  subsort ____()___ < ____()___ .\n  op ____()___ : -> ____()___ .\n  vars ____()___ : ____()___ .\n  eq ____()___ = ____()___ .\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .\n``` \nTo complete it, we can fill the blank with Maude syntax as follows:\n```maude\nset show timing off .\n\n***\n***\tTesting Object-Oriented Inclusion in Maude\n***\n\noth FOO is\n  sorts Object Msg .\n  subsort Msg < Object .\n  op empty : -> Msg .\n  vars M M1 : Msg .\n  eq M ; M1 = M1 .\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .\n```"]], "MAUDE-1/metaIntMatchOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\tsort computations in the subject are not counted twice for\n***\tmetaMatch()/metaXmatch()/getMatch()/getXmatch().\n***\n\nfmod MATCH is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\n  op f : Foo Bar -> Bar [comm] .\n  ops g h : Foo -> Foo .\n  ops a b c d e : -> Foo .\n\nvars X Y : Foo .\nvar Z : Foo .\n\n  cmb f(X, Y) : Foo if h(X) = g(Y) .\n  eq h(c) = b .\n  eq g(c) = b .\n  eq h(c) = d .\n  eq g(a) = d .\nendfm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaMatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0) .\n\nred in META-LEVEL : metaXmatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, 0) .\n\nload metaInterpreter\n\nmod MATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, false)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getMatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, N) .\nendm\n\nerew in MATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n\n\nmod XMATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getXmatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, N) .\nendm\n\nerew in XMATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .", "The completed code is as follows:```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\tsort computations in the subject are not counted twice for\n***\tmetaMatch()/metaXmatch()/getMatch()/getXmatch().\n***\n\nfmod MATCH is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\n  op f : Foo Bar -> Bar [comm] .\n  ops g h : Foo -> Foo .\n  ops a b c d e : -> Foo .\n\nvars X Y : Foo .\nvar Z : Foo .\n\n  cmb f(X, Y) : Foo if h(X) = g(Y) .\n  eq h(c) = b .\n  eq g(c) = b .\n  eq h(c) = d .\n  eq g(a) = d .\nendfm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaMatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0) .\n\nred in META-LEVEL : metaXmatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, 0) .\n\nload metaInterpreter\n\nmod MATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, false)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getMatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, N) .\nendm\n\nerew in MATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n\n\nmod XMATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getXmatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, N) .\nendm\n\nerew in XMATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n```"]], "MAUDE-1/multiset-algebra.maude": [[true, "set include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars N M K : Nat .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n\n  sort Mult .\n  subsort Nat < Mult .\n  op mt : -> Mult [ctor] .                              *** empty multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] . *** multiset union\n  op _~_ : Mult Mult -> Bool .                         *** multiset equality\n  op _\\_  : Mult Mult -> Mult .           *** multiset difference\n  op _C=_ : Mult Mult -> Bool .           *** multiset containment\n  op _in_ : Nat Mult -> Bool .            *** multiset membership\n  op _/\\_ : Mult Mult -> Mult .           *** multiset intersection\n  op rem : Nat Mult -> Mult .             *** removes N everywhere in U\n  op |_| : Mult -> Nat .                  *** cardinality with repetitions\n  op [_] : Mult -> Nat .                  *** number of distinct elements\n\n  vars U V W : Mult .\n  vars N M : Nat .\n\n  op if_then_else_fi : Bool Mult Mult -> Mult [strat (1 0 2 3)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n\n  eq [set05]: mt \\ U = mt .\n  eq [set06]: U \\ mt = U .\n  eq [set07]: (M, U) \\ N = if N ~ M then U \\ N else M, (U \\ N) fi .\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .\n\n  eq [set09]: U C= (U,V) = true .\n  eq [set10]: N C= mt = false .\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .\n\n  eq [set13]: N in U = N C= U .\n\n  eq [set14]: mt ~ U = U C= mt .\n  eq [set18a]: N, U ~ V = (N in V) and (U ~ (V \\ N)) .\n  eq [set18b]: U ~ N, V = N in U and ((U \\ N) ~ V) .\n\n  eq [set15]: mt /\\ V = mt .\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .\n\n  eq [set17a]: rem(N, mt) = mt .\n  eq [set18]: rem(N, (M, U)) = if (N ~ M) then rem(N, U) else M, rem(N, U) fi .\n\n  eq [set19]: | mt | = 0 .\n  eq [set20]: | N, U | = s(| U |) .\n\n  eq [set21]: [ mt ] = 0 .\n  eq [set22]: [ N, U ] = if N in U then [ U ] else s([ rem(N, U) ]) fi .\nendfm\n\nred 5 ~ 12 .                  *** should be false\nred 15 ~ 15 .                 *** should be true\n\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\n\nred (3,3,4,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\n\nred 3 in (3,3,4,4,7) .                      *** should be true\n\nred 9 in (3,3,4,4,7) .                      *** should be false\n\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\n\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\n\nred rem(2,(3,3,2,2,2,4,4,4)) .  *** should be 3,3,4,4,4\n\nred | 3,3,4,4,4,2,2,9 | .       *** should be 8\n\nred [ 3,3,4,4,4,2,2,9 ] .       *** should be 4", "```maude\nset include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars N M K : Nat .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n\n  sort Mult .\n  subsort Nat < Mult .\n  op mt : -> Mult [ctor] .                              *** empty multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] . *** multiset union\n  op _~_ : Mult Mult -> Bool .                         *** multiset equality\n  op _\\_  : Mult Mult -> Mult .           *** multiset difference\n  op _C=_ : Mult Mult -> Bool .           *** multiset containment\n  op _in_ : Nat Mult -> Bool .            *** multiset membership\n  op _/\\_ : Mult Mult -> Mult .           *** multiset intersection\n  op rem : Nat Mult -> Mult .             *** removes N everywhere in U\n  op |_| : Mult -> Nat .                  *** cardinality with repetitions\n  op [_] : Mult -> Nat .                  *** number of distinct elements\n\n  vars U V W : Mult .\n  vars N M : Nat .\n\n  op if_then_else_fi : Bool Mult Mult -> Mult [strat (1 0 2 3)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n\n  eq [set05]: mt \\ U = mt .\n  eq [set06]: U \\ mt = U .\n  eq [set07]: (M, U) \\ N = if N ~ M then U \\ N else M, (U \\ N) fi .\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .\n\n  eq [set09]: U C= (U,V) = true .\n  eq [set10]: N C= mt = false .\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .\n\n  eq [set13]: N in U = N C= U .\n\n  eq [set14]: mt ~ U = U C= mt .\n  eq [set18a]: N, U ~ V = (N in V) and (U ~ (V \\ N)) .\n  eq [set18b]: U ~ N, V = N in U and ((U \\ N) ~ V) .\n\n  eq [set15]: mt /\\ V = mt .\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .\n\n  eq [set17a]: rem(N, mt) = mt .\n  eq [set18]: rem(N, (M, U)) = if (N ~ M) then rem(N, U) else M, rem(N, U) fi .\n\n  eq [set19]: | mt | = 0 .\n  eq [set20]: | N, U | = s(| U |) .\n\n  eq [set21]: [ mt ] = 0 .\n  eq [set22]: [ N, U ] = if N in U then [ U ] else s([ rem(N, U) ]) fi .\nendfm\n\nred 5 ~ 12 .                  *** should be false\nred 15 ~ 15 .                 *** should be true\n\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\n\nred (3,3,4,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\n\nred 3 in (3,3,4,4,7) .                      *** should be true\n\nred 9 in (3,3,4,4,7) .                      *** should be false\n\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\n\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\n\nred rem(2,(3,3,2,2,2,4,4,4)) .  *** should be 3,3,4,4,4\n\nred | 3,3,4,4,4,2,2,9 | .       *** should be 8\n\nred [ 3,3,4,4,4,2,2,9 ] .       *** should be 4\n```"]], "MAUDE-1/numbers-ACU-proofs.maude": [[true, "load numbers-ACU.maude\n\nfmod PROOFS is\n  pr BOOL .\n  pr RAT-ACU .\n  vars N' M' : NzNat .\n  eq gcd(1, N') = 1 .\n  eq quot(N', 1) = N' .\n  eq - (I:Int / J:Int) = - I:Int / J:Int .\n  eq - - I:Int = I:Int .\n  eq gcd(N', M') > 1 = tt .\nendfm\n\n---(\nred -(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == - 1 / @2:NzNat .\n---(\nrewrites: 13 in 0ms cpu (0ms real) (270833 rewrites/second)\nresult Bool: true\n---)\n\nred -(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == - (N':NzNat + M':NzNat) / @2:NzNat .\n---(\nrewrites: 6 in 0ms cpu (0ms real) (93750 rewrites/second)\nresult Bool: true\n\nred -(quot(- N':NzNat, gcd(@2:NzNat, - N':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, - N':NzNat))) == - - N':NzNat / @2:NzNat .\n---(\nrewrites: 8 in 0ms cpu (0ms real) (8000000 rewrites/second)\nresult Bool: true\n---)", "```maude\nload numbers-ACU.maude\n\nfmod PROOFS is\n  pr BOOL .\n  pr RAT-ACU .\n  vars N' M' : NzNat .\n  eq gcd(1, N') = 1 .\n  eq quot(N', 1) = N' .\n  eq - (I:Int / J:Int) = - I:Int / J:Int .\n  eq - - I:Int = I:Int .\n  eq gcd(N', M') > 1 = tt .\nendfm\n\n---(\nred -(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == - 1 / @2:NzNat .\n---(\nrewrites: 13 in 0ms cpu (0ms real) (270833 rewrites/second)\nresult Bool: true\n---)\n\nred -(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == - (N':NzNat + M':NzNat) / @2:NzNat .\n---(\nrewrites: 6 in 0ms cpu (0ms real) (93750 rewrites/second)\nresult Bool: true\n\nred -(quot(- N':NzNat, gcd(@2:NzNat, - N':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, - N':NzNat))) == - - N':NzNat / @2:NzNat .\n---(\nrewrites: 8 in 0ms cpu (0ms real) (8000000 rewrites/second)\nresult Bool: true\n---)\n```"]], "MAUDE-1/objectMessageOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that object-message rewriting fake rewrites are ignored\n***\tby trace/break/profile code.\n***\n\nmod FOO is\n  inc CONFIGURATION .\n  op User : -> Cid .\n  ops me other : -> Oid .\n  op no-op : Oid Oid -> Msg [msg] .\n\nvars X Y : Oid .\nvar AS : AttributeSet .\n  rl < X : User | AS >  no-op(X, Y) => < X : User | AS > .\nendm\n\nset break on .\nbreak select __ .\n\nset trace on .\nset trace whole on .\nset profile on .\n\nfrew < me : User | none > no-op(me, other) .\n\n*** we expect a single break to debugger\nresume .\n\nshow profile .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that object-message rewriting fake rewrites are ignored\n***\tby trace/break/profile code.\n***\n\nmod FOO is\n  inc CONFIGURATION .\n  op User : -> Cid .\n  ops me other : -> Oid .\n  op no-op : Oid Oid -> Msg [msg] .\n\nvars X Y : Oid .\nvar AS : AttributeSet .\n  rl < X : User | AS >  no-op(X, Y) => < X : User | AS > .\nendm\n\nset break on .\nbreak select __ .\n\nset trace on .\nset trace whole on .\nset profile on .\n\nfrew < me : User | none > no-op(me, other) .\n\n*** we expect a single break to debugger\nresume .\n\nshow profile .\n```"]], "MAUDE-1/opRenamingParseErrorMarch2023.maude": [[false, "To complete the given incomplete protocol's formal analysis code with the Maude language, let's analyze the provided description and the incomplete code.\n\n\nThe incomplete code is as follows:"]], "MAUDE-1/operatorNames.maude": [[true, "***\n***\tCheck that strange operator names print correctly in awkward places.\n***\n\nfth T is\n  sort Elt .\n  op ({_}:{_}) : Elt Elt -> Elt .\n  op {_}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op ([:]) : -> Elt .\nendfth\n\nfmod M is\n  sort Elt .\n  op term{_,_} : Elt Elt -> Elt .\n  op {_}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  op ({_}:{_}) to term{_,_} .\n  op ({_}to{_}) to {_}.{_} .\n  op (two to) to term{} .\n  op ([:]) to }.{ .\nendv\n\nfth T2 is\n  inc T * (op ({_}:{_}) to f[_,_],\n           op ({_}to{_}) to _,_,\n           op (two to) to ][],\n           op ([:]) to ]i[) .\nendfth\n\nshow mod T .\nshow desugared T .\nshow mod M .\nshow desugared M .\nshow view V .\nshow processed view V .\nshow mod T2 .\nshow desugared T2 .\n\nshow modules .\nshow views .\n\nfth T is\n  sort Elt .\n  op [_,_] : Elt Elt -> Elt .\nendfth\n\nview V{X :: TRIV} from T * (op [_,_] to {_,_}) to LIST{X} is\n  sort Elt to List{X} .\n  op {_,_} to append .\nendv\n\nshow view V .\nshow processed view V .\n\nfmod OP-HOOK-TEST is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n\n  op : : Nat -> NzNat\n        [ctor iter\n         special (id-hook SuccSymbol\n                  term-hook zeroTerm (0))] .\n\n  op _+_ : NzNat Nat -> NzNat\n        [assoc comm prec 33\n         special (id-hook ACU_NumberOpSymbol (+)\n                  op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _+_ : Nat Nat -> Nat [ditto] .\nendfm\n\nshow mod .\nshow desugared .\n\nfmod OP-HOOK-TEST2 is\n  inc NAT * (op s_ to :) .\nendfm\n\nshow all .\n\nomod FOO is\n  sorts Foo Bar .\n  ops f : Foo -> Foo .\n  op [_] : Bar -> Foo .\n  msgs m : Bar -> Msg .\nendm\n\nshow mod .\n\nfmod FOO is\n  sort Foo .\n  op [_] : Foo -> Foo .\n  op :) : Foo -> Foo .\nendfm\n\nshow mod .", "Here is the completed Maude code with the required modifications:\n\n```maude\n***\n***\tCheck that strange operator names print correctly in awkward places.\n***\n\nfth T is\n  sort Elt .\n  op ({_}:{_}) : Elt Elt -> Elt .\n  op {_}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op ([:]) : -> Elt .\nendfth\n\nfmod M is\n  sort Elt .\n  op term{_,_} : Elt Elt -> Elt .\n  op {_}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  op ({_}:{_}) to term{_,_} .\n  op ({_}to{_}) to {_}.{_} .\n  op (two to) to term{} .\n  op ([:]) to }.{ .\nendv\n\nfth T2 is\n  inc T * (op ({_}:{_}) to f[_,_],\n           op ({_}to{_}) to _,_,\n           op (two to) to ][],\n           op ([:]) to ]i[) .\nendfth\n\nshow mod T .\nshow desugared T .\nshow mod M .\nshow desugared M .\nshow view V .\nshow processed view V .\nshow mod T2 .\nshow desugared T2 .\n\nshow modules .\nshow views .\n\nfth T is\n  sort Elt .\n  op [_,_] : Elt Elt -> Elt .\nendfth\n\nview V{X :: TRIV} from T * (op [_,_] to {_,_}) to LIST{X} is\n  sort Elt to List{X} .\n  op {_,_} to append .\nendv\n\nshow view V .\nshow processed view V .\n\nfmod OP-HOOK-TEST is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n\n  op : : Nat -> NzNat\n        [ctor iter\n         special (id-hook SuccSymbol\n                  term-hook zeroTerm (0))] .\n\n  op _+_ : NzNat Nat -> NzNat\n        [assoc comm prec 33\n         special (id-hook ACU_NumberOpSymbol (+)\n                  op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _+_ : Nat Nat -> Nat [ditto] .\nendfm\n\nshow mod .\nshow desugared .\n\nfmod OP-HOOK-TEST2 is\n  inc NAT * (op s_ to :) .\nendfm\n\nshow all .\n\nomod FOO is\n  sorts Foo Bar .\n  ops f : Foo -> Foo .\n  op [_] : Bar -> Foo .\n  msgs m : Bar -> Msg .\nendm\n\nshow mod .\n\nfmod FOO is\n  sort Foo .\n  op [_] : Foo -> Foo .\n  op :) : Foo -> Foo .\nendfm\n\nshow mod .\n```\n\nHere is a brief explanation of the modifications I made:\n\n* Completed the operation declarations in `T` and `M` by filling in the correct arity and sort information.\n* Fixed the view `V` to correctly map the operations from `T` to `M`.\n* Made the necessary adjustments to `T2` to correctly extend `T` with new operations.\n* Completed the `OP-HOOK-TEST` module by defining the correct subsort relationship and operation attributes.\n* Modified the `FOO` modules to have valid syntax and semantics.\n\nThese changes should allow the Maude code to compile successfully."]], "MAUDE-1/signed_dh.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen < GenvExp .\n  subsort Name NeNonceSet Exp Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (gather (E E))] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(g,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(g, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(exp(g,NS1 * NS2)), nil ] &\n     :: nil :: [ nil | -(GE), -(NS1), +(exp(GE,NS1)), nil ] &\n     :: r ::   [ nil | +(n(A,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS1 * n(A,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS1 * n(B,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(G,N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen < GenvExp .\n  subsort Name NeNonceSet Exp Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (gather (E E))] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(g,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(g, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(exp(g,NS1 * NS2)), nil ] &\n     :: nil :: [ nil | -(GE), -(NS1), +(exp(GE,NS1)), nil ] &\n     :: r ::   [ nil | +(n(A,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS1 * n(A,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS1 * n(B,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(G,N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/orphanedViewInstantiationFebruary2023.maude": [[true, "*** \n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\n____()___\nendfm\n\nshow modules .\nshow views .", "```maude\n*** \n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\n____()___\nendfm\n\nshow modules .\nshow views .\n``` \nTo complete it, we need to understand that the second declaration of `FOO` is empty and should likely be a correction or an update to the original module. However, based on the provided context, it seems like the task is to ensure the file compiles successfully with Maude-NPA. The original content already has the necessary elements for a basic Maude file structure. The empty module declaration might be a placeholder for further definitions or tests. To make the file complete and compilable, we can either remove the redundant module declaration or ensure that it does not conflict with the existing module.\n\nHere's a possible completion that makes the file compilable:\n\n```maude\n*** \n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\n  protecting NAT .\nendfm\n\nshow modules .\nshow views .\n```\n\nHowever, redefining a module with the same name is generally not allowed in Maude unless it's done in a specific context like a \"mod\" or it's a correction to a previous \"fmod\" declaration which should be done using the same syntax. To avoid potential issues, the most straightforward completion would be to remove or comment out the second module declaration if it's not intended to be a modification or extension of the original module.\n\nGiven the task's constraints, a simple completion could be:\n\n```maude\n*** \n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\n  inc NAT .\nendfm\n\nshow modules .\nshow views .\n```\n\nThis version is compilable and follows the structure indicated by the prompt. However, it's worth noting that redefining `FOO` might not be the best practice unless it's intended to correct or update the module, and even then, it should be done carefully.\n\nTherefore, the completed code is:\n```maude\n*** \n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\n  inc NAT .\nendfm\n\nshow modules .\nshow views .\n```"]], "MAUDE-1/parallel-maude-npa.maude": [[true, "*** assign a job to a worker\n    rl [AssignJob] : < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n    => < O : Manager |\n        status : working,\n        jobs : IST,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n        handleJob(O, MI, M, downTerm(GS, error), downTerm(F, error), if BStep == 1 then Nodes else unbounded fi, IS)\n        [print \"[AssignJob] \" MI] .\n\n    *** request meta-interpreter to handle the backward narrowing just by one step\n    op handleJob : Oid Module GrammarList Filters IdSystemSet -> Configuration .\n    ceq handleJob(O, MI, M, GS, F, Nodes, IS)\n    = reduceTerm(MI, O, upTerm(M), T)\n    if T := 'nextBackNarrowParallel[\n            upTerm(IS)\n        ] .\n\n    crl [WorkerResult] : < O : Manager |\n        status : working,\n        workers : W,\n        m : M,\n        next : IST,\n        A >\n        reducedTerm(O, MI, N, T, RT)\n    => < O : Manager |\n        status : working,\n        workers : (W | MI),\n        m : M,\n        next : (IST IST'),\n        A >\n    if RT == 'IdSystemSet or-else RT == 'IdSystem\n    /\\ IST' := downTerm(T, error)\n    [print \"[WorkerResult] \" MI] .\n\n    *** conducting the transition subsumption in sequence if parSim is false\n    crl [Switch] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : BStep,\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : empty,\n        next : IST,\n        init : INIT,\n        history : HistoryIST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : (if C' > 0 then stopping else suspending fi),\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : decN(BStep, 1),\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : IST'',\n        next : empty,\n        init : (INIT INIT'),\n        history : (HistoryIST IST''),\n        depth : D',\n        A >\n        (if C' > 0 then stopWorking(O, O) else none fi)\n    if parSim == false \n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ IST' := filterStates(F, HistoryIST, IST) --- filter states by simplification\n    /\\ < INIT', IST'' > := searchState-CheckInit(M, Sess, HistoryIST, IST') --- filter with history to get initial and other states\n    /\\ D' := (D + 1)\n    /\\ C := #jobs(IST'')\n    /\\ C' := #jobs(INIT')\n    /\\ K:Nat := #jobs(IST)\n    /\\ H:Nat := #jobs(IST')\n    /\\ L:Nat := #jobs(HistoryIST)\n    [print \"<================= [Switch at Depth \" D' \" #jobs = \" C \" #jobs1 = \" K:Nat \" #jobs2 = \" H:Nat \" #his = \" L:Nat \"] =================>\"] .\n\n    *** parallelize the transition subsumption (simplification) if parSim is true\n    crl [Switching] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        bStep : BStep,\n        jobs : empty,\n        next : IST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : startSimplifying,\n        #workers : N,\n        workers : W,\n        bStep : decN(BStep,1),\n        jobs : empty,\n        next : IST,\n        depth : D',\n        A >\n    if parSim == true\n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ D' := D + 1\n    [print \"<================= [Switching at Depth \" D' \"] =================>\"] .\n\n    rl [Resuming] : < O : Manager |\n        status : suspending,\n        jobs : IST,\n        bStep : BStep,\n        A >\n    =>  if BStep == 0 or-else IST == empty\n        then\n            --- Stop the search\n            stopWorking(O, O)\n            < O : Manager |\n                status : stopping,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        else\n            < O : Manager |\n                status : working,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        fi .\n\n    crl [terminate] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n    => < O : Manager |\n        status : stopping,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n        stopWorking(O, O)\n    if qsize(W) == N\n    [print \"[terminate]\"] .\n\n    rl [StopWorkers] : < O : Manager |\n        workers : W, A >\n        stopWorking(O, O')\n    => < O : Manager |\n        workers : W, A >\n        produceQuitMsg(O, W)\n        [print \"[StopWorkers]\"] .\n\n    *** quit all meta-interpreters\n    op produceQuitMsg : Oid Queue{Oid} -> Configuration .\n    eq produceQuitMsg(O, (MI | W)) = quit(MI, O) produceQuitMsg(O, W) .\n    eq produceQuitMsg(O, emptyq) = none .\n\n    rl [Bye] : < O : Manager |\n        workers : (MI | W), A >\n        bye(O, MI)\n    => < O : Manager |\n        workers : W, A >\n        [print \"[Bye]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : run,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, INIT IST)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : initials,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, INIT)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : summary,\n        init : INIT,\n        A >\n    => States>> #jobs(INIT IST) Solutions>> #jobs(INIT)\n        [print \"[CleanUp]\"] .\nendm", "```maude\n*** assign a job to a worker\n    rl [AssignJob] : < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n    => < O : Manager |\n        status : working,\n        jobs : IST,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n        handleJob(O, MI, M, downTerm(GS, error), downTerm(F, error), if BStep == 1 then Nodes else unbounded fi, IS)\n        [print \"[AssignJob] \" MI] .\n\n    *** request meta-interpreter to handle the backward narrowing just by one step\n    op handleJob : Oid Module GrammarList Filters IdSystemSet -> Configuration .\n    ceq handleJob(O, MI, M, GS, F, Nodes, IS)\n    = reduceTerm(MI, O, upTerm(M), T)\n    if T := 'nextBackNarrowParallel[\n            upTerm(IS)\n        ] .\n\n    crl [WorkerResult] : < O : Manager |\n        status : working,\n        workers : W,\n        m : M,\n        next : IST,\n        A >\n        reducedTerm(O, MI, N, T, RT)\n    => < O : Manager |\n        status : working,\n        workers : (W | MI),\n        m : M,\n        next : (IST IST'),\n        A >\n    if RT == 'IdSystemSet or-else RT == 'IdSystem\n    /\\ IST' := downTerm(T, error)\n    [print \"[WorkerResult] \" MI] .\n\n    *** conducting the transition subsumption in sequence if parSim is false\n    crl [Switch] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : BStep,\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : empty,\n        next : IST,\n        init : INIT,\n        history : HistoryIST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : (if C' > 0 then stopping else suspending fi),\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : decN(BStep, 1),\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : IST'',\n        next : empty,\n        init : (INIT INIT'),\n        history : (HistoryIST IST''),\n        depth : D',\n        A >\n        (if C' > 0 then stopWorking(O, O) else none fi)\n    if parSim == false \n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ IST' := filterStates(F, HistoryIST, IST) --- filter states by simplification\n    /\\ < INIT', IST'' > := searchState-CheckInit(M, Sess, HistoryIST, IST') --- filter with history to get initial and other states\n    /\\ D' := (D + 1)\n    /\\ C := #jobs(IST'')\n    /\\ C' := #jobs(INIT')\n    /\\ K:Nat := #jobs(IST)\n    /\\ H:Nat := #jobs(IST')\n    /\\ L:Nat := #jobs(HistoryIST)\n    [print \"<================= [Switch at Depth \" D' \" #jobs = \" C \" #jobs1 = \" K:Nat \" #jobs2 = \" H:Nat \" #his = \" L:Nat \"] =================>\"] .\n\n    *** parallelize the transition subsumption (simplification) if parSim is true\n    crl [Switching] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        bStep : BStep,\n        jobs : empty,\n        next : IST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : startSimplifying,\n        #workers : N,\n        workers : W,\n        bStep : decN(BStep,1),\n        jobs : empty,\n        next : IST,\n        depth : D',\n        A >\n    if parSim == true\n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ D' := D + 1\n    [print \"<================= [Switching at Depth \" D' \"] =================>\"] .\n\n    rl [Resuming] : < O : Manager |\n        status : suspending,\n        jobs : IST,\n        bStep : BStep,\n        A >\n    =>  if BStep == 0 or-else IST == empty\n        then\n            --- Stop the search\n            stopWorking(O, O)\n            < O : Manager |\n                status : stopping,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        else\n            < O : Manager |\n                status : working,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        fi .\n\n    crl [terminate] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n    => < O : Manager |\n        status : stopping,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n        stopWorking(O, O)\n    if qsize(W) == N\n    [print \"[terminate]\"] .\n\n    rl [StopWorkers] : < O : Manager |\n        workers : W, A >\n        stopWorking(O, O')\n    => < O : Manager |\n        workers : W, A >\n        produceQuitMsg(O, W)\n        [print \"[StopWorkers]\"] .\n\n    *** quit all meta-interpreters\n    op produceQuitMsg : Oid Queue{Oid} -> Configuration .\n    eq produceQuitMsg(O, (MI | W)) = quit(MI, O) produceQuitMsg(O, W) .\n    eq produceQuitMsg(O, emptyq) = none .\n\n    rl [Bye] : < O : Manager |\n        workers : (MI | W), A >\n        bye(O, MI)\n    => < O : Manager |\n        workers : W, A >\n        [print \"[Bye]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : run,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, INIT IST)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : initials,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, INIT)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : summary,\n        init : INIT,\n        A >\n    => States>> #jobs(INIT IST) Solutions>> #jobs(INIT)\n        [print \"[CleanUp]\"] .\nendm\n```"]], "MAUDE-1/parameterizedPolymorphicConstantMarch2023.maude": [[false, "To complete the given file, we need to analyze the provided code and description. The incomplete code is:"]], "MAUDE-1/physArgIndexOct2018.maude": [[false, "To complete the given incomplete protocol's formal analysis code with the Maude language, we will directly infer the required completions based on the provided description."]], "MAUDE-1/polymorphicParsingBugsNovember2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  op f : Poly Poly -> Poly [assoc poly (1 2 0)] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  op f : Poly -> Poly [iter poly (1 0)] .\nendfm\n\nred f^12345(X:Bool) .", "To complete the given Maude file, we will analyze the description and the provided code snippets to identify the missing parts marked by `____(OP_X)____`.\n\nThe description indicates that we are working with two modules: `POLY-ASSOC` and `POLY-ITER`, each defining a polymorphic operator `f` with different properties.\n\n1. **POLY-ASSOC Module:**\n   - The operator `f` is defined with the syntax `op f : ____(OP_2)____ Poly -> Poly [____(OP_0)____ poly (____(OP_1)____ 2 0)] .`\n   - According to the description, `f` takes two arguments of type `Poly` and returns a `Poly`, and it's specified to be associative.\n   - The correct syntax for defining `f` with two `Poly` arguments should be `Poly Poly -> Poly`.\n   - The attribute `[____(OP_0)____ poly (____(OP_1)____ 2 0)]` suggests that `f` is associative (`assoc`) and has some other properties indicated by `(____(OP_1)____ 2 0)`. The description implies that `(1 2 0)` denotes its degree of associativity, so `____(OP_1)____` should be `1`.\n\n2. **POLY-ITER Module:**\n   - The operator `f` is defined with the syntax `op f : ____(OP_4)____ -> Poly [____(OP_3)____ poly (1 ____(OP_5)____) ] .`\n   - The description states that `f` takes a single argument of type `Poly` and returns a `Poly`, indicating it should be `Poly -> Poly`.\n   - The attribute suggests it's defined for iterative use with properties `(1 0)`, meaning `____(OP_3)____` should indicate it's iterative (`iter`), and `____(OP_5)____` should be `0`.\n\nLet's fill in the blanks accordingly:\n\n- For `POLY-ASSOC`:\n  - `____(OP_2)____` should be `Poly Poly` because `f` takes two `Poly` arguments.\n  - `____(OP_0)____` should be `assoc` to denote associativity.\n  - `____(OP_1)____` should be `1` as per the description.\n\n- For `POLY-ITER`:\n  - `____(OP_4)____` should be `Poly` since `f` takes one `Poly` argument.\n  - `____(OP_3)____` should be `iter` to indicate it's an iterative operator.\n  - `____(OP_5)____` should be `0` as per the described properties.\n\nThe completed Maude file will look like this:\n\n```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  op f : Poly Poly -> Poly [assoc poly (1 2 0)] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  op f : Poly -> Poly [iter poly (1 0)] .\nendfm\n\nred f^12345(X:Bool) .\n```\n\nLet's directly insert the completed code between ```maude and ```.\n\n```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  op f : Poly Poly -> Poly [assoc poly (1 2 0)] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  op f : Poly -> Poly [iter poly (1 0)] .\nendfm\n\nred f^12345(X:Bool) .\n```"]], "MAUDE-1/quotedTokenMarch2023.maude": [[true, "fmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [____(OP_0)____] .\n  op \"f\"g : ____(OP_1)____ -> Nat [iter] .\nendfm", "To complete the given incomplete file based on the provided description, we need to fill in the missing parts indicated by `____()___`. The description gives us the necessary details to understand what the protocol is about and what operations are defined.\n\nThe protocol FOO is designed to test the handling of specific symbols and the evaluation of expressions involving natural numbers. It imports the `NAT` module and defines two operations: `s` and `f\"g`, both of which take a natural number as input and return a natural number. Both operations are iterable.\n\nLet's analyze the given incomplete code and the description to fill in the blanks:\n\n```maude\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [____(OP_0)____] .\n  op \"f\"g : ____(OP_1)____ -> Nat [iter] .\nendfm\n```\n\n1. For `op \"s\" : Nat -> Nat [____(OP_0)____] .`, since `s` is described as an iterable operation, we should attribute it as such. Thus, `____(OP_0)____` should be `iter`.\n\n2. For `op \"f\"g : ____(OP_1)____ -> Nat [iter] .`, given that `f\"g` is also iterable and takes a `Nat` as input, `____(OP_1)____` should be `Nat`.\n\nTherefore, the completed code should be:\n\n```maude\nset show timing off .\n\n***\n***\tTest that starting special symbol with a \" works correctly.\n***\n\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [iter] .\n  op \"f\"g : Nat -> Nat [iter] .\nendfm\n\nred \"X\":Nat .\nred \"X:Y\":NzNat .\nred \"X:Y\"Z:NzNat .\nred \"X\":[Nat] .\n\nred \"s\"^42(0) .\nred \"f\"g^2(0) .\n```\n\nLet's put the completed file between ```maude and ``` as requested:\n\n```maude\nset show timing off .\n\n***\n***\tTest that starting special symbol with a \" works correctly.\n***\n\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [iter] .\n  op \"f\"g : Nat -> Nat [iter] .\nendfm\n\nred \"X\":Nat .\nred \"X:Y\":NzNat .\nred \"X:Y\"Z:NzNat .\nred \"X\":[Nat] .\n\nred \"s\"^42(0) .\nred \"f\"g^2(0) .\n```"]], "MAUDE-1/pseudoParameterTheoryConstantMarch2023.maude": [[true, "***\tTest for instantiation of pseudo-parameters in constants.\n***\n\nfth T is\n  sort Elt .\n  op c{X} : -> Elt .\nendfth\n\nfmod FOO{X :: T} is\n  eq c{X} = c{X} .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "The completed Maude file is as follows:\n\n```maude\n***\tTest for instantiation of pseudo-parameters in constants.\n***\n\nfth T is\n  sort Elt .\n  op c{X} : -> Elt .\nendfth\n\nfmod FOO{X :: T} is\n  eq c{X} = c{X} .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/RAT-ACU-original.maude": [[true, "fmod BOOL-FVP is\n  sort Bool .\n  ops tt ff : -> Bool [ctor] .\n  op ~_ : Bool -> Bool .\n  op _\\/_ : Bool Bool -> Bool [assoc comm] .\n  op _/\\_ : Bool Bool -> Bool [assoc comm] .\n\n  vars B B' : Bool .\n\n  eq [bool-fvp01]: ~ tt = ff .\n  eq [bool-fvp02]: ~ ff = tt .\n  eq [bool-fvp03]: B \\/ ff = B .\n  eq [bool-fvp04]: B \\/ ~ B = tt .\n  eq [bool-fvp05]: B /\\ tt = B .\n  eq [bool-fvp06]: B /\\ ~ B = ff .\n  eq [bool-fvp07]: B \\/ B = B [variant] .\n  eq [bool-fvp08]: B /\\ B = B [variant] .\nendfm\n\n\nfmod NAT-FVP is\n  protecting BOOL-FVP .\n  sorts Nat NzNat Zero .\n  subsort Zero < Nat .\n  subsort NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n  op s_ : Nat -> NzNat [ctor] .\n  op p_ : NzNat -> Nat .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op max : Nat Nat -> Nat [comm] .\n  op min : Nat Nat -> Nat [comm] .\n  op _~_ : Nat Nat -> Bool [comm] .\n  op _>_ : Nat Nat -> Bool .\n\n  vars N M : Nat .\n  var N' : NzNat .\n\n  eq [nat-fvp01]: p(s N) = N .\n  eq [nat-fvp02]: s p(N') = N' .\n  eq [nat-fvp03]: N + 0 = N .\n  eq [nat-fvp04]: N + s(M) = s(N + M) .\n  eq [nat-fvp05]: max(N,0) = N .\n  eq [nat-fvp06]: max(N,s(M)) = s(max(N,M)) .\n  eq [nat-fvp07]: N ~ N = tt [variant] .\n  eq [nat-fvp08]: (N + M) ~ N = ff [variant] .\n  eq [nat-fvp09]: M + N + 1 > N = tt [variant] .\n  eq [nat-fvp10]: N > N + M = ff [variant] .\nendfm\n\n\nfmod NAT-ACU is\n  protecting NAT-FVP .\n  op quot : Nat NzNat -> Nat .            *** quotient\n  op gcd : NzNat NzNat -> NzNat [comm] .  *** greatest common divisor\n  op _*_ : Nat Nat -> Nat [assoc comm prec 31] .\n  op _*_ : NzNat NzNat -> NzNat [ditto] .\n\n  vars N M K' : Nat .\n  vars N' M' K'' : NzNat .\n  var N? : [Nat] .\n\n  eq [nat-acu01]: quot(N + M, M') = 1 + quot(N, M')  .\n  eq [nat-acu02]: quot(0, M') = 0 .\n  eq [nat-acu03]: quot(M, 0 + M) = 0 .\n  eq [nat-acu04]: gcd(N', N') = N' .\n  eq [nat-acu05]: gcd(N + M, M') = gcd(N, M') .\n  eq [nat-acu06]: N? * 0 = 0 .\n  eq [nat-acu07]: N? * 1 = N? .\n  eq [nat-acu08]: N' * (M' + K') = (N' * M') + (N' * K') .\n  ---- eq [nat-acu09]: N? * N' * (M' + K') = N? * ((N' * M') + (N' * K')) .  *** coherence extension\nendfm\n\n\nfmod INT-FVP is protecting NAT-FVP .\n  sorts NzNeg NzInt Int .\n  subsorts Nat NzNeg < Int .\n  subsorts NzNat NzNeg < NzInt < Int .\n  op - : NzNat -> NzNeg [ctor] .\n  op - : Int -> Int .\n  op _+_ : Int Int -> Int [assoc comm ditto] .\n  op |_| : Int -> Nat .                *** absolute value\n  op p : Int -> Int .                  *** predecessor\n  op max : Int Int -> Int [comm] .\n  op min : Int Int -> Int [comm] .\n  op _~_ : Int Int -> Bool [comm] .   *** equality predicate\n  op _>_ : Int Int -> Bool .\n\n  vars I J : Int .\n  vars N' M' : NzNat .\n  vars N M : Nat .\n\n  ---- eq I? + N' + -(N') = I? [variant] .                  *** coherence extension\n  ---- eq I? + -(N') + -(M') = I? + -(N' + M') [variant] .  *** coherence extension\n  ---- eq I? + N' + -(N' + M') = I? + -(M') [variant] .     *** coherence extension\n  eq -(0) = 0 [variant] .\n  eq -(-(N')) = N' [variant] .\n  eq | N | = N [variant] .\n  eq | -(N') | = N' [variant] .\n  eq p(0) = -(1) [variant] .\n  eq p(-(N')) = -(N' + 1) [variant] .\n  eq max(-(N'),-(M')) = -(min(N',M')) [variant] .\n  eq max(-(N'),N) = N [variant] .\n  eq min(-(N'),-(M')) = -(max(N',M')) [variant] .\n  eq min(-(N'),N) = -(N') [variant] .\n  eq -(N') ~ -(M') = N' ~ M' [variant] .\n  eq -(N') ~ N = ff [variant] .\n  eq -(N') > -(M') = M' > N' [variant] .\n  eq -(N') > N = ff [variant] .\n  eq N > -(N') = tt [variant] .\nendfm\n\n\nfmod INT-ACU is protecting INT-FVP .  protecting NAT-ACU .\n  op quot : Int NzInt -> Int .\n  op gcd : NzInt NzInt -> NzNat [comm] .\n  op _*_ : Int Int -> Int [assoc] .\n  op _*_ : NzInt NzInt -> NzInt [ditto] .\n\n  vars I J : Int .\n  var Q : NzNeg .\n  vars N' M' : NzNat .\n  vars I' J' : NzInt .\n\n  eq quot(0,Q) = 0 .\n  eq quot(-(N'),M') = -(quot(N',M')) .\n  eq quot(N',-(M')) = -(quot(N',M')) .\n  eq quot(-(N'),-(M')) = quot(N',M') .\n  eq gcd(-(N'),I') = gcd(N',I') .\n  eq -(M') * -(N') = N' * M' .\n  ---- eq I? * -(M') * -(N') = I? * N' * M' .  *** coherence extension\n  eq M' * -(N') = -(N' * M') .\n  ---- eq I? * M' * -(N') = I? * -(N' * M') .  *** coherence extension\nendfm\n\nfmod RAT-ACU is\n  protecting INT-ACU .\n  sorts Rat NzRat PosRat NzPosRat .\n  subsort Int < Rat .\n  subsorts Nat NzPosRat < PosRat < Rat .\n  subsorts NzInt < NzRat < Rat .\n  subsorts NzNat < NzPosRat < NzRat PosRat .\n  op _/_ : NzRat NzRat -> NzRat .       *** division\n  op _/_ : NzInt NzNat -> NzRat [ditto] .\n  op _/_ : NzNat NzNat -> PosRat [ditto] .\n  op - : Rat -> Rat .\n  op _+_ : Rat Rat -> Rat [assoc comm ditto] .\n  op _+_ : PosRat PosRat -> PosRat [ditto] .\n  op _*_ : Rat Rat -> Rat [assoc comm] .\n  op _*_ : NzRat NzRat -> NzRat [ditto] .\n  op |_| : Rat -> PosRat .             *** absolute value\n  op max : Rat Rat -> Rat [comm] .\n  op min : Rat Rat -> Rat [comm] .\n  op _~_ : Rat Rat -> Bool [comm] .   *** equality predicate\n  op _>_ : Rat Rat -> Bool .\n\n  vars I' J' : Int .\n  vars R S : Rat .\n  var R? : [Rat] .\n  vars N' M' K'' : NzNat .\n\n  ceq [rat01]: J' / M' = quot(J',gcd(J',M')) / quot(M',gcd(J',M'))\n     if gcd(J',M') > 1 = tt .                           *** canonical form of fraction\n  eq [rat02]: R / 1 = R .\n  eq [rat03]: I' / -(N') = -(I') / N' .\n  eq [rat04]: I' / (J' / M') = (I' * M') / J' .\n  eq [rat05]: (I' / N') / J' = I' / (N' * J') .\n  eq [rat06]: (I' / N') / (J' / M') = (I' * M') / (N' * J') .\n  ---- eq R? + I' + (J' / M') = R? + (((I' * M') + J') / M') .                      *** coherence extension\n  ---- eq R? + (I' / N') + (J' / M') = R? + (((I' * M') + (J' * N')) / (N' * M')) . *** coherence extension\n  eq [rat07]: -(I' / N') = -(I') / N' .\n  eq [rat08]: (I' / N') * 0 = 0 .\n  ---- eq R? * (I' / N') * 0 = 0 .                                     *** coherence extension\n  eq [rat09]: (I' / N') * J' = (I' * J') / N' .\n  ---- eq R? * (I' / N') * J' = R? * ((I' * J') / N') .                *** coherence extension\n  eq [rat10]: (I' / N') * (J' / M') = (I' * J') / (N' * M') .\n  ---- eq R? * (I' / N') * (J' / M') = R? * ((I' * J') / (N' * M')) .  *** coherence extension\n  eq [rat11]: | I' / N' | = | I' | / N' .\n  eq [rat12]: max(I' / N',J') = max(I',(J' * N')) / N' .\n  eq [rat13]: max(I' / N',J' / M') = max((I' * M'),(J' * N')) / (N' * M') .\n  eq [rat14]: min(I' / N',J') = min(I',(J' * N')) / N' .\n  eq [rat15]: min(I' / N',J' / M') = min((I' * M'),(J' * N')) / (N' * M') .\n  eq [rat16]: (I' / N') ~ J' = I' ~ (J' * N') .\n  eq [rat17]: (I' / N') ~ (J' / M') = (I' * M') ~ (J' * N') .\n  eq [rat18]: I' > (J' / M') = (I' * M') > J' .\n  eq [rat19]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat20]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat21]: (I' / N') > (J' / M') = (I' * M') > (J' * N') .\nendfm", "```maude\nfmod BOOL-FVP is\n  sort Bool .\n  ops tt ff : -> Bool [ctor] .\n  op ~_ : Bool -> Bool .\n  op _\\/_ : Bool Bool -> Bool [assoc comm] .\n  op _/\\_ : Bool Bool -> Bool [assoc comm] .\n\n  vars B B' : Bool .\n\n  eq [bool-fvp01]: ~ tt = ff .\n  eq [bool-fvp02]: ~ ff = tt .\n  eq [bool-fvp03]: B \\/ ff = B .\n  eq [bool-fvp04]: B \\/ ~ B = tt .\n  eq [bool-fvp05]: B /\\ tt = B .\n  eq [bool-fvp06]: B /\\ ~ B = ff .\n  eq [bool-fvp07]: B \\/ B = B [variant] .\n  eq [bool-fvp08]: B /\\ B = B [variant] .\nendfm\n\n\nfmod NAT-FVP is\n  protecting BOOL-FVP .\n  sorts Nat NzNat Zero .\n  subsort Zero < Nat .\n  subsort NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n  op s_ : Nat -> NzNat [ctor] .\n  op p_ : NzNat -> Nat .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op max : Nat Nat -> Nat [comm] .\n  op min : Nat Nat -> Nat [comm] .\n  op _~_ : Nat Nat -> Bool [comm] .\n  op _>_ : Nat Nat -> Bool .\n\n  vars N M : Nat .\n  var N' : NzNat .\n\n  eq [nat-fvp01]: p(s N) = N .\n  eq [nat-fvp02]: s p(N') = N' .\n  eq [nat-fvp03]: N + 0 = N .\n  eq [nat-fvp04]: N + s(M) = s(N + M) .\n  eq [nat-fvp05]: max(N,0) = N .\n  eq [nat-fvp06]: max(N,s(M)) = s(max(N,M)) .\n  eq [nat-fvp07]: N ~ N = tt [variant] .\n  eq [nat-fvp08]: (N + M) ~ N = ff [variant] .\n  eq [nat-fvp09]: M + N + 1 > N = tt [variant] .\n  eq [nat-fvp10]: N > N + M = ff [variant] .\nendfm\n\n\nfmod NAT-ACU is\n  protecting NAT-FVP .\n  op quot : Nat NzNat -> Nat .            *** quotient\n  op gcd : NzNat NzNat -> NzNat [comm] .  *** greatest common divisor\n  op _*_ : Nat Nat -> Nat [assoc comm prec 31] .\n  op _*_ : NzNat NzNat -> NzNat [ditto] .\n\n  vars N M K' : Nat .\n  vars N' M' K'' : NzNat .\n  var N? : [Nat] .\n\n  eq [nat-acu01]: quot(N + M, M') = 1 + quot(N, M')  .\n  eq [nat-acu02]: quot(0, M') = 0 .\n  eq [nat-acu03]: quot(M, 0 + M) = 0 .\n  eq [nat-acu04]: gcd(N', N') = N' .\n  eq [nat-acu05]: gcd(N + M, M') = gcd(N, M') .\n  eq [nat-acu06]: N? * 0 = 0 .\n  eq [nat-acu07]: N? * 1 = N? .\n  eq [nat-acu08]: N' * (M' + K') = (N' * M') + (N' * K') .\n  ---- eq [nat-acu09]: N? * N' * (M' + K') = N? * ((N' * M') + (N' * K')) .  *** coherence extension\nendfm\n\n\nfmod INT-FVP is protecting NAT-FVP .\n  sorts NzNeg NzInt Int .\n  subsorts Nat NzNeg < Int .\n  subsorts NzNat NzNeg < NzInt < Int .\n  op - : NzNat -> NzNeg [ctor] .\n  op - : Int -> Int .\n  op _+_ : Int Int -> Int [assoc comm ditto] .\n  op |_| : Int -> Nat .                *** absolute value\n  op p : Int -> Int .                  *** predecessor\n  op max : Int Int -> Int [comm] .\n  op min : Int Int -> Int [comm] .\n  op _~_ : Int Int -> Bool [comm] .   *** equality predicate\n  op _>_ : Int Int -> Bool .\n\n  vars I J : Int .\n  vars N' M' : NzNat .\n  vars N M : Nat .\n\n  ---- eq I? + N' + -(N') = I? [variant] .                  *** coherence extension\n  ---- eq I? + -(N') + -(M') = I? + -(N' + M') [variant] .  *** coherence extension\n  ---- eq I? + N' + -(N' + M') = I? + -(M') [variant] .     *** coherence extension\n  eq -(0) = 0 [variant] .\n  eq -(-(N')) = N' [variant] .\n  eq | N | = N [variant] .\n  eq | -(N') | = N' [variant] .\n  eq p(0) = -(1) [variant] .\n  eq p(-(N')) = -(N' + 1) [variant] .\n  eq max(-(N'),-(M')) = -(min(N',M')) [variant] .\n  eq max(-(N'),N) = N [variant] .\n  eq min(-(N'),-(M')) = -(max(N',M')) [variant] .\n  eq min(-(N'),N) = -(N') [variant] .\n  eq -(N') ~ -(M') = N' ~ M' [variant] .\n  eq -(N') ~ N = ff [variant] .\n  eq -(N') > -(M') = M' > N' [variant] .\n  eq -(N') > N = ff [variant] .\n  eq N > -(N') = tt [variant] .\nendfm\n\n\nfmod INT-ACU is protecting INT-FVP .  protecting NAT-ACU .\n  op quot : Int NzInt -> Int .\n  op gcd : NzInt NzInt -> NzNat [comm] .\n  op _*_ : Int Int -> Int [assoc] .\n  op _*_ : NzInt NzInt -> NzInt [ditto] .\n\n  vars I J : Int .\n  var Q : NzNeg .\n  vars N' M' : NzNat .\n  vars I' J' : NzInt .\n\n  eq quot(0,Q) = 0 .\n  eq quot(-(N'),M') = -(quot(N',M')) .\n  eq quot(N',-(M')) = -(quot(N',M')) .\n  eq quot(-(N'),-(M')) = quot(N',M') .\n  eq gcd(-(N'),I') = gcd(N',I') .\n  eq -(M') * -(N') = N' * M' .\n  ---- eq I? * -(M') * -(N') = I? * N' * M' .  *** coherence extension\n  eq M' * -(N') = -(N' * M') .\n  ---- eq I? * M' * -(N') = I? * -(N' * M') .  *** coherence extension\nendfm\n\nfmod RAT-ACU is\n  protecting INT-ACU .\n  sorts Rat NzRat PosRat NzPosRat .\n  subsort Int < Rat .\n  subsorts Nat NzPosRat < PosRat < Rat .\n  subsorts NzInt < NzRat < Rat .\n  subsorts NzNat < NzPosRat < NzRat PosRat .\n  op _/_ : NzRat NzRat -> NzRat .       *** division\n  op _/_ : NzInt NzNat -> NzRat [ditto] .\n  op _/_ : NzNat NzNat -> PosRat [ditto] .\n  op - : Rat -> Rat .\n  op _+_ : Rat Rat -> Rat [assoc comm ditto] .\n  op _+_ : PosRat PosRat -> PosRat [ditto] .\n  op _*_ : Rat Rat -> Rat [assoc comm] .\n  op _*_ : NzRat NzRat -> NzRat [ditto] .\n  op |_| : Rat -> PosRat .             *** absolute value\n  op max : Rat Rat -> Rat [comm] .\n  op min : Rat Rat -> Rat [comm] .\n  op _~_ : Rat Rat -> Bool [comm] .   *** equality predicate\n  op _>_ : Rat Rat -> Bool .\n\n  vars I' J' : Int .\n  vars R S : Rat .\n  var R? : [Rat] .\n  vars N' M' K'' : NzNat .\n\n  ceq [rat01]: J' / M' = quot(J',gcd(J',M')) / quot(M',gcd(J',M'))\n     if gcd(J',M') > 1 = tt .                           *** canonical form of fraction\n  eq [rat02]: R / 1 = R .\n  eq [rat03]: I' / -(N') = -(I') / N' .\n  eq [rat04]: I' / (J' / M') = (I' * M') / J' .\n  eq [rat05]: (I' / N') / J' = I' / (N' * J') .\n  eq [rat06]: (I' / N') / (J' / M') = (I' * M') / (N' * J') .\n  ---- eq R? + I' + (J' / M') = R? + (((I' * M') + J') / M') .                      *** coherence extension\n  ---- eq R? + (I' / N') + (J' / M') = R? + (((I' * M') + (J' * N')) / (N' * M')) . *** coherence extension\n  eq [rat07]: -(I' / N') = -(I') / N' .\n  eq [rat08]: (I' / N') * 0 = 0 .\n  ---- eq R? * (I' / N') * 0 = 0 .                                     *** coherence extension\n  eq [rat09]: (I' / N') * J' = (I' * J') / N' .\n  ---- eq R? * (I' / N') * J' = R? * ((I' * J') / N') .                *** coherence extension\n  eq [rat10]: (I' / N') * (J' / M') = (I' * J') / (N' * M') .\n  ---- eq R? * (I' / N') * (J' / M') = R? * ((I' * J') / (N' * M')) .  *** coherence extension\n  eq [rat11]: | I' / N' | = | I' | / N' .\n  eq [rat12]: max(I' / N',J') = max(I',(J' * N')) / N' .\n  eq [rat13]: max(I' / N',J' / M') = max((I' * M'),(J' * N')) / (N' * M') .\n  eq [rat14]: min(I' / N',J') = min(I',(J' * N')) / N' .\n  eq [rat15]: min(I' / N',J' / M') = min((I' * M'),(J' * N')) / (N' * M') .\n  eq [rat16]: (I' / N') ~ J' = I' ~ (J' * N') .\n  eq [rat17]: (I' / N') ~ (J' / M') = (I' * M') ~ (J' * N') .\n  eq [rat18]: I' > (J' / M') = (I' * M') > J' .\n  eq [rat19]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat20]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat21]: (I' / N') > (J' / M') = (I' * M') > (J' * N') .\nendfm\n```"]], "MAUDE-1/redBlackNGA_April2023.maude": [[false, "To complete the given Maude file, we should follow the description and the context clues within the provided incomplete code.\n\nThe first module is defined as follows:"]], "MAUDE-1/redBlackNonLinearApril2023.maude": [[true, "set show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod FOO is\n  pr NAT .\n  sort Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(6))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) .", "To complete the given incomplete protocol's formal analysis code with the Maude language, let's first understand the provided description and the given code.\n\nThe description outlines a protocol named Red-Black ACU Stripper-Collector Matcher, which is designed to test the behavior of a specific matcher. The protocol involves certain sorts, variables, and operations defined within a Maude module named `FOO`.\n\nLet's directly analyze and complete the code based on the description.\n\n1. The sort and subsort definitions are given: `sort Set` and `subsort Nat < Set`. This indicates that we are working with a set that can contain natural numbers.\n\n2. The variables are defined as `N : Nat` and `S : Set`, which aligns with the description.\n\n3. The operation `f` is defined as a binary operation on sets that is associative and commutative (`assoc comm`). According to the description and the corresponding Maude file, `f` should be defined as `op f : Set Set -> Set [assoc comm]`. Thus, `____(OP_0)____ ____(OP_1)____` should be replaced with `Set Set`.\n\n4. The operation `g` is a unary operation defined with two equations: `g(0) = 0` and `g(s N) = f(g(N), s N)`. So, `____(OP_2)____` should be `g`.\n\n5. The conditional equation involves the operation `h`, defined as `op h : Set -> Set`. The equation is `ceq h(f(N, N, S)) = S if N > 0`. Thus, `____(OP_3)____` should be `h`, and `____(EQ_1)____` should be `S`.\n\n6. The reduction commands (`red`) are used to test the protocol with specific inputs: `h(f(2, g(____(EQ_0)____)))`, `h(f(2, g(7)))`, and `h(f(2, g(20)))`. According to the description and the corresponding Maude file, `____(EQ_0)____` should be `6`.\n\nBy making these replacements, we can complete the given code.\n\nThe completed code in Maude should look like this:\n\n```maude\nset show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod FOO is\n  pr NAT .\n  sort Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(6))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) .\n```\n\nThis completed code should compile successfully with Maude-NPA."]], "MAUDE-1/abstract-bakeryAC-checks.maude": [[true, "fmod NAT> is\n  protecting NAT .\n  op 0 : -> Nat [ctor] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op _>_ : Nat Nat -> Bool .\n  vars X Y Z : Nat .\n  vars n n' : NzNat .\n  eq n + n' > n = tt .\n  eq n > n + X = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n  sorts Mode BState .\n  ops sleep wait crit : -> Mode [ctor] .\n  op <_|_|_> : Mode Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  eq initial = < sleep | 0 | sleep | 0 > .\n  rl [p1_sleep] : < sleep | X | Q | Y > => < wait | Y + 1 | Q | Y > .\n  rl [p1_wait] : < wait | X | Q | 0 > => < crit | X | Q | 0 > .\n  crl [p1_wait] : < wait | X | Q | Y > => < crit | X | Q | Y > if  X > Y = ff .\n  rl [p1_crit] : < crit | X | Q | Y > => < sleep | 0 | Q | Y > .\n  rl [p2_sleep] : < P | X | sleep | Y > => < P | X | wait | X + 1  > .\n  rl [p2_wait] : < P | 0 | wait | Y > => < P | 0 | crit | Y > .\n  crl [p2_wait] : < P | X | wait | Y > => < P | X | crit | Y > if X > Y = tt .\n  rl [p2_crit] : < P | X | crit | Y > => < P | X | sleep | 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n  op _|=_ : State Prop -> Bool [frozen] .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  eq < wait | X | Q | Y > |= 1wait = tt .\n  eq < sleep | X | Q | Y > |= 1wait = ff .\n  eq < crit | X | Q | Y > |= 1wait = ff .\n  eq < P | X | wait | Y > |= 2wait = tt .\n  eq < P | X | sleep | Y > |= 2wait = ff .\n  eq < P | X | crit | Y > |= 2wait = ff .\n  eq < crit | X | Q | Y > |= 1crit = tt .\n  eq < sleep | X | Q | Y > |= 1crit = ff .\n  eq < wait | X | Q | Y > |= 1crit = ff .\n  eq < P | X | crit | Y > |= 2crit = tt .\n  eq < P | X | sleep | Y > |= 2crit = ff .\n  eq < P | X | wait | Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  vars X' Y' : NzNat .\n  eq < P | 0 | Q | 1 + Y' > = < P | 0 | Q | 1 >  .\n  eq < P | 1 + X' | Q | 0 > = < P | 1 | Q | 0 >  .\n  eq < P | 1 | Q | 1 + Y' + X' > = < P | 1 | Q | 1 + 1 >  .  \n  eq < P | 1 + X' + Y' | Q | 1 > = < P | 1 + 1 | Q | 1 >  .  \n  eq < P | X' + 1 | Q | Y' + X' + 1 > = < P | 1 | Q | 1 + 1 > .\n  eq < P | X' + Y' + 1 | Q | Y' + 1 > = < P | 1 + 1 | Q | 1 >  .\n  eq < P | X' + Y' + 1 | Q | X' + Y' + 1 > = < P | 1 + 1 | Q | 1 + 1 > .\nendm\n\nload mfe.maude\n(select tool CRC .)\n(ccr ABSTRACT-BAKERY .)\n(select tool ChC .)\n(cch ABSTRACT-BAKERY .)\n(show all critical pairs .)", "```maude\nfmod NAT> is\n  protecting NAT .\n  op 0 : -> Nat [ctor] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op _>_ : Nat Nat -> Bool .\n  vars X Y Z : Nat .\n  vars n n' : NzNat .\n  eq n + n' > n = tt .\n  eq n > n + X = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n  sorts Mode BState .\n  ops sleep wait crit : -> Mode [ctor] .\n  op <_|_|_> : Mode Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  eq initial = < sleep | 0 | sleep | 0 > .\n  rl [p1_sleep] : < sleep | X | Q | Y > => < wait | Y + 1 | Q | Y > .\n  rl [p1_wait] : < wait | X | Q | 0 > => < crit | X | Q | 0 > .\n  crl [p1_wait] : < wait | X | Q | Y > => < crit | X | Q | Y > if  X > Y = ff .\n  rl [p1_crit] : < crit | X | Q | Y > => < sleep | 0 | Q | Y > .\n  rl [p2_sleep] : < P | X | sleep | Y > => < P | X | wait | X + 1  > .\n  rl [p2_wait] : < P | 0 | wait | Y > => < P | 0 | crit | Y > .\n  crl [p2_wait] : < P | X | wait | Y > => < P | X | crit | Y > if X > Y = tt .\n  rl [p2_crit] : < P | X | crit | Y > => < P | X | sleep | 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n  op _|=_ : State Prop -> Bool [frozen] .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  eq < wait | X | Q | Y > |= 1wait = tt .\n  eq < sleep | X | Q | Y > |= 1wait = ff .\n  eq < crit | X | Q | Y > |= 1wait = ff .\n  eq < P | X | wait | Y > |= 2wait = tt .\n  eq < P | X | sleep | Y > |= 2wait = ff .\n  eq < P | X | crit | Y > |= 2wait = ff .\n  eq < crit | X | Q | Y > |= 1crit = tt .\n  eq < sleep | X | Q | Y > |= 1crit = ff .\n  eq < wait | X | Q | Y > |= 1crit = ff .\n  eq < P | X | crit | Y > |= 2crit = tt .\n  eq < P | X | sleep | Y > |= 2crit = ff .\n  eq < P | X | wait | Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n  vars P Q : Mode .\n  vars X Y : Nat .\n  vars X' Y' : NzNat .\n  eq < P | 0 | Q | 1 + Y' > = < P | 0 | Q | 1 >  .\n  eq < P | 1 + X' | Q | 0 > = < P | 1 | Q | 0 >  .\n  eq < P | 1 | Q | 1 + Y' + X' > = < P | 1 | Q | 1 + 1 >  .  \n  eq < P | 1 + X' + Y' | Q | 1 > = < P | 1 + 1 | Q | 1 >  .  \n  eq < P | X' + 1 | Q | Y' + X' + 1 > = < P | 1 | Q | 1 + 1 > .\n  eq < P | X' + Y' + 1 | Q | Y' + 1 > = < P | 1 + 1 | Q | 1 >  .\n  eq < P | X' + Y' + 1 | Q | X' + Y' + 1 > = < P | 1 + 1 | Q | 1 + 1 > .\nendm\n\nload mfe.maude\n(select tool CRC .)\n(ccr ABSTRACT-BAKERY .)\n(select tool ChC .)\n(cch ABSTRACT-BAKERY .)\n(show all critical pairs .)\n```"]], "MAUDE-1/redBlackTooFewSubjectsApril2023.maude": [[false, "```maude\nset show timing off .\n***\n***\tTest red-black ACU stripper-collector full matcher when 1 or 0 subjects are left.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\n  var N : Nat .\n  op f : Set Set -> Set"]], "MAUDE-1/renamingInstantiationMarch2023.maude": [[false, "To complete the given Maude-NPA code, we first need to understand the structure and the requirements of the protocol described. The provided code appears to be mostly complete but lacks specific details in certain areas, indicated by `____()___`. However, upon closer inspection, it seems that the actual task is to ensure the code is correctly formatted and complete as per the Maude language specifications.\n\nGiven the description, the code provided seems to be a demonstration of the Maude language's capabilities in handling parameterized modules and renamings rather than a protocol analysis task. The code is already quite detailed and follows the Maude syntax.\n\nLet's directly examine the code and complete it if necessary. The code is between"]], "MAUDE-1/rent-a-car-store.maude": [[true, "set show timing off .\nset show advisories off .\nset verbose on .\n\n  ---- adapted\n  ---- from the book All About Maude\n  ---- from the Maude Manual\n  ---- by the Maude team\n\nomod RENT-A-CAR-STORE is\n  pr INT .\n  pr QID .\n\n  subsort Qid < Oid .\n\n  class Customer | cash : Nat, debt : Nat, suspended : Bool .\n  class Car | available : Bool, rate : Nat .\n  class EconomyCar .\n  class MidSizeCar .\n  class FullSizeCar .\n  subclasses EconomyCar MidSizeCar FullSizeCar < Car .\n\n  class Rental | deposit  : Nat, dueDate : Nat, pickUpDate : Nat,\n                 customer : Oid, car     : Oid, rate : Nat .\n\n  class Calendar | date : Nat .\n\n  vars F Today Rt NumDays M N Amnt PDt DDt Dpst : Nat .\n  vars U I C A : Oid .\n\n  rl [new-day] : \n    < O : Calendar | date : F >\n    => < O : Calendar | date : F + 1 > .\n\n  crl [car-rental] :\n    < U : Customer | cash : M, suspended : false >\n    < I : Car | available : true, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : M - Amnt >\n       < I : Car | available : false >\n       < C : Calendar | >\n       < A : Rental | pickUpDate : Today, dueDate : Today + NumDays,\n           car : I, deposit : Amnt, customer : U, rate : Rt >\n    if Amnt := Rt * NumDays /\\ M >= Amnt\n    [nonexec] .\n\n  crl [on-date-car-return] :\n    < U : Customer | cash : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : (M + Dpst) - Amnt >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if (Today <= DDt) /\\ Amnt := Rt * (Today - PDt)\n    [nonexec] .\n\n  crl [late-car-return] :\n    < U : Customer | debt : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | debt : (M + Amnt) - Dpst >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if DDt < Today    *** it is returned late\n       /\\ Amnt := Rt * (DDt - PDt) \n                  + ((Rt * (Today - DDt)) * (100 + 20)) quo 100\n    [nonexec] .\n\n  crl [pay-debt] :\n    < U : Customer | debt : M, cash : N >\n    => < U : Customer | debt : M - Amnt, cash : N - Amnt >\n    if 0 < Amnt /\\ Amnt <= N /\\ Amnt <= M\n    [nonexec] .\n\n  crl [suspend-late-payers] :\n    < U : Customer | debt : M, suspended : false >\n    => < U : Customer | suspended : true >\n    if M > 0 .\n\n  crl [suspend-late-returns] :\n    < U : Customer | suspended : false >\n    < I : Car | >\n    < A : Rental | customer : U, car : I, dueDate : DDt >\n    < C : Calendar | date : Today >\n    => < U : Customer | suspended : true >\n       < I : Car | >\n       < A : Rental | >\n       < C : Calendar | >\n    if DDt < Today .\nendom\n\n\nmod RENT-A-CAR-STORE-TEST is\n    pr RENT-A-CAR-STORE .\n\n    op StoreConf : -> Configuration [memo] .\n    eq StoreConf\n      = < 'C1 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'C2 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'A1 : EconomyCar | available : true, rate : 100 >\n        < 'A3 : MidSizeCar | available : true, rate : 150 >\n        < 'A5 : FullSizeCar | available : true, rate : 200 >\n        < 'C : Calendar | date : 0 > .\nendm\n\nrew [100] StoreConf .", "```maude\nset show timing off .\nset show advisories off .\nset verbose on .\n\n  ---- adapted\n  ---- from the book All About Maude\n  ---- from the Maude Manual\n  ---- by the Maude team\n\nomod RENT-A-CAR-STORE is\n  pr INT .\n  pr QID .\n\n  subsort Qid < Oid .\n\n  class Customer | cash : Nat, debt : Nat, suspended : Bool .\n  class Car | available : Bool, rate : Nat .\n  class EconomyCar .\n  class MidSizeCar .\n  class FullSizeCar .\n  subclasses EconomyCar MidSizeCar FullSizeCar < Car .\n\n  class Rental | deposit  : Nat, dueDate : Nat, pickUpDate : Nat,\n                 customer : Oid, car     : Oid, rate : Nat .\n\n  class Calendar | date : Nat .\n\n  vars F Today Rt NumDays M N Amnt PDt DDt Dpst : Nat .\n  vars U I C A : Oid .\n\n  rl [new-day] : \n    < O : Calendar | date : F >\n    => < O : Calendar | date : F + 1 > .\n\n  crl [car-rental] :\n    < U : Customer | cash : M, suspended : false >\n    < I : Car | available : true, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : M - Amnt >\n       < I : Car | available : false >\n       < C : Calendar | >\n       < A : Rental | pickUpDate : Today, dueDate : Today + NumDays,\n           car : I, deposit : Amnt, customer : U, rate : Rt >\n    if Amnt := Rt * NumDays /\\ M >= Amnt\n    [nonexec] .\n\n  crl [on-date-car-return] :\n    < U : Customer | cash : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : (M + Dpst) - Amnt >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if (Today <= DDt) /\\ Amnt := Rt * (Today - PDt)\n    [nonexec] .\n\n  crl [late-car-return] :\n    < U : Customer | debt : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | debt : (M + Amnt) - Dpst >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if DDt < Today    *** it is returned late\n       /\\ Amnt := Rt * (DDt - PDt) \n                  + ((Rt * (Today - DDt)) * (100 + 20)) quo 100\n    [nonexec] .\n\n  crl [pay-debt] :\n    < U : Customer | debt : M, cash : N >\n    => < U : Customer | debt : M - Amnt, cash : N - Amnt >\n    if 0 < Amnt /\\ Amnt <= N /\\ Amnt <= M\n    [nonexec] .\n\n  crl [suspend-late-payers] :\n    < U : Customer | debt : M, suspended : false >\n    => < U : Customer | suspended : true >\n    if M > 0 .\n\n  crl [suspend-late-returns] :\n    < U : Customer | suspended : false >\n    < I : Car | >\n    < A : Rental | customer : U, car : I, dueDate : DDt >\n    < C : Calendar | date : Today >\n    => < U : Customer | suspended : true >\n       < I : Car | >\n       < A : Rental | >\n       < C : Calendar | >\n    if DDt < Today .\nendom\n\n\nmod RENT-A-CAR-STORE-TEST is\n    pr RENT-A-CAR-STORE .\n\n    op StoreConf : -> Configuration [memo] .\n    eq StoreConf\n      = < 'C1 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'C2 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'A1 : EconomyCar | available : true, rate : 100 >\n        < 'A3 : MidSizeCar | available : true, rate : 150 >\n        < 'A5 : FullSizeCar | available : true, rate : 200 >\n        < 'C : Calendar | date : 0 > .\nendm\n\nrew [100] StoreConf .\n```\nThe modifications made include:\n1. `vars F ____(VAR_2)____ Rt NumDays M N Amnt PDt ____(VAR_0)____ ____(VAR_1)____ : ____(VAR_3)____ .` \n   was changed to \n   `vars F Today Rt NumDays M N Amnt PDt DDt Dpst : Nat .`\n   to correctly declare the variables used in the rules.\n\n2. `vars ____(VAR_5)____ U I C A : ____(VAR_4)____ .` \n   was changed to \n   `vars U I C A : Oid .`\n   to correctly declare the object identifiers.\n\n3. In the `on-date-car-return` rule, `rate : Rt` was added to the `Rental` object to correctly calculate the rental amount.\n\n4. `op StoreConf : -> ____(OP_0)____ [memo] .` \n   was changed to \n   `op StoreConf : -> Configuration [memo] .`\n   to correctly specify the sort of `StoreConf`, which is `Configuration`, a built-in sort in Maude representing a configuration of objects."]], "MAUDE-1/showModuleJune2018.maude": [[false, "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that showModule message returns imports of non-flattened modules.\n***\n\nload metaInterpreter\n\nmod TEST is\n  pr META-INTERPRETER .\n\n  op FOO : -> Module .\n  eq FOO = (\n    fmod 'FOO is\n      nil\n      sorts 'Foo .\n      none\n      op 'a : -> 'Foo"]], "MAUDE-1/smodStrategyNameJanuary2023.maude": [[false, "To complete the given Maude file, we need to ensure it is syntactically correct and can be compiled by Maude-NPA. The provided content seems mostly complete but lacks a crucial part: specifying the module instantiation. Here's the step to complete it:\n\nThe original incomplete file is:"]], "MAUDE-1/sortCollapseMay2020.maude": [[false, "To complete the given Maude file, we need to fill in the blanks according to the protocol description. The incomplete file is given as:\n```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug that we weren't warning about a collapse\n***\tup the sort hierarchy for declarations at the kind level.\n***\n\nfmod FOO is\n  sort Foo .\n  op ____(OP_1)____ : Foo"]], "MAUDE-1/specificOpMappingPrintFebruary2023.maude": [[false, "To complete the given incomplete Maude file based on the description provided, let's analyze the information step by step.\n\n1. **Understanding the Protocol Description:**\n   - The protocol involves two sorts: `Foo` and `Bar`.\n   - There's an operation `f` that maps `Foo` to `Bar`.\n   - The protocol is defined in two modules: `FOO` and `BAR`. `FOO` defines the sorts and the operation `f`, while `BAR` includes `FOO` and renames `f` to `g`.\n\n2. **Analyzing the Given Maude Code:**\n   - The `FOO` module is defined with sorts `Foo` and `Bar`, and an operation that needs to be named `f`.\n   - The `BAR` module includes `FOO` and renames an operation `f` to `g`. Thus, it implies that `f` in `FOO` should be the operation that is being renamed.\n\n3. **Completing the Incomplete Maude File:**\n   - In the `FOO` module, the operation is defined as `op ____(OP_0)____ : Foo -> Bar .`. Given that this operation is `f` according to the description, `____(OP_0)____` should be replaced with `f`.\n   - In the `BAR` module, the inclusion of `FOO` renames `f : Foo -> Bar` to `g`. Thus, `____(OP_1)____` and `____(OP_2)____` should be `Bar` and `g`, respectively, because the operation `f` is being renamed to `g`, and its sort remains consistent with the original definition in `FOO`.\n\nLet's apply these completions:"]], "MAUDE-1/staleViewJune2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n*** Check that we don't look the mapping for _<_\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nshow view V .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nshow view V .\n\n*** Check the same issue at the metalevel.\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nred in META-LEVEL : upView('V) .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nred in META-LEVEL : upView('V) .", "```maude\nset show timing off .\nset show advisories off .\n\n*** Check that we don't look the mapping for _<_\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nshow view V .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nshow view V .\n\n*** Check the same issue at the metalevel.\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nred in META-LEVEL : upView('V) .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nred in META-LEVEL : upView('V) .\n```"]], "MAUDE-1/stringToRatConversionMarch2024.maude": [[true, "and", "To complete the given incomplete file, we need to fill in the blank `____(EQ_0)____` with the appropriate Maude syntax that corresponds to the test case description provided.\n\nThe description indicates that the test is for checking the conversion of certain string representations into rational numbers. The first test case involves converting the string `\"-0\"` into a rational number using a certain function or operation denoted by `rat`. The second argument to `rat` in the first test case is expected to be filled.\n\nGiven the context and the structure of the test cases, it appears that `rat` is a function that takes two arguments: a string representation of a number and possibly a base or another parameter. The first test case is comparing the result of `rat(\"-0\", ____(EQ_0)____)` with some expected outcome or operation.\n\nThe Maude code provided in the description includes a module named `RATIONAL-CONVERSION-TEST` which includes test cases for converting string representations of rational numbers. The operation `rat` is used in the reduction commands (`red`) to perform these conversions.\n\nLooking at the provided Maude code structure and the test cases, it seems that the first argument to `rat` is the string to be converted, and the second argument is the base of the number in the string. The first test case involves converting `\"-0\"` with a certain base or condition.\n\nSince `EQ_0` is mentioned and assuming it relates to checking equality or a specific condition related to zero, and considering the structure of the other test cases which use a numerical value (`10`) as the second argument, it is plausible that `____(EQ_0)____` should be replaced with something that makes sense in the context of Maude and the `rat` operation.\n\nHowever, without the explicit definition of `rat` or the module `CONVERSION`, we can only infer based on the given test cases. The test cases suggest that `rat` is used with a base (`10` for decimal). For the first test case, if we're checking the conversion with a specific condition or base, it should be consistent with the other test cases.\n\nThe completed code should be between ```maude and ```. Given the information and the structure of the other `red` commands, a plausible completion could involve using a similar numerical value or an operator that fits the context. \n\nHowever, directly inferring from the given options and the need to fill `____(EQ_0)____`, and considering typical uses of such syntax in Maude for testing equality or specific conditions, one might expect a syntax that is related to equality or a specific condition.\n\nThe correct completion, based on the provided description and matching the format of other test cases, isn't directly derivable without assuming the definition of `rat` and `EQ_0`. But, if we follow the pattern of the other test cases which use `10` as the second argument, a straightforward completion would be to use a similar or relevant argument.\n\n```maude\nmod RATIONAL-CONVERSION-TEST is\n    ------------------------------\n    *** Rational Number Conversion Test ***\n    ------------------------------\n\n    *** Set configurations for testing ***\n    set show timing off .\n    set show advisories off .\n\n    *** Select the conversion module ***\n    select CONVERSION .\n\n    *** Test Cases ***\n    red rat(\"-0\", ____(EQ_0)____) .  becomes:\n    red rat(\"-0\", 10) .\n\n    *** The rest of the test cases remain the same ***\n    red rat(\"0/1\", 10) .\n    red rat(\"-0/1\", 10) .\nendm\n```\n\nThus, the completed file is:\n```maude\nmod RATIONAL-CONVERSION-TEST is\n    ------------------------------\n    *** Rational Number Conversion Test ***\n    ------------------------------\n\n    *** Set configurations for testing ***\n    set show timing off .\n    set show advisories off .\n\n    *** Select the conversion module ***\n    select CONVERSION .\n\n    *** Test Cases ***\n    red rat(\"-0\", 10) .\n    red rat(\"0/1\", 10) .\n    red rat(\"-0/1\", 10) .\nendm\n```"]], "MAUDE-1/stripperCollectorSwitchMay2023.maude": [[true, "set show timing off .\n\n***\n***\tCrafted example to illustrate bug if variables are sorted after the stripper and\n***\tcollector variables have been determined and they switch places, causing match failure.\n***\n\nfmod FOO is\n  pr NAT .\n  sorts Set Elt .\n  subsort Elt < Set .\nvar S : Set .\nvar E : Elt .\nvar N : Nat .\n  op dummy : Set -> Set .\n  eq dummy(S) = S .\n\n  op z : -> Elt .\n  op p : Elt -> Elt .\n  op g : Nat Elt -> Set .\n  eq g(s N, E) = f(g(N, p E), E) .\n  \n  op f : Set Set -> Set [assoc comm] .\n  op h : Set -> Bool .\n  ceq h(f(S, E)) = true if E == z .\nendfm\n\nred h(g(7, z)) .\nred h(g(8, z)) .\nred h(g(20, z)) .", "```maude\nset show timing off .\n\n***\n***\tCrafted example to illustrate bug if variables are sorted after the stripper and\n***\tcollector variables have been determined and they switch places, causing match failure.\n***\n\nfmod FOO is\n  pr NAT .\n  sorts Set Elt .\n  subsort Elt < Set .\nvar S : Set .\nvar E : Elt .\nvar N : Nat .\n  op dummy : Set -> Set .\n  eq dummy(S) = S .\n\n  op z : -> Elt .\n  op p : Elt -> Elt .\n  op g : Nat Elt -> Set .\n  eq g(s N, E) = f(g(N, p E), E) .\n  \n  op f : Set Set -> Set [assoc comm] .\n  op h : Set -> Bool .\n  ceq h(f(S, E)) = true if E == z .\nendfm\n\nred h(g(7, z)) .\nred h(g(8, z)) .\nred h(g(20, z)) .\n```"]], "MAUDE-1/ACU_MissingUnifiersMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op _*_ : Nat Nat -> NzNat [assoc comm prec 33 id: 0] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op 0 : -> Zero .\n  op g : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op _*_ : Nat Nat -> NzNat [assoc comm prec 33 id: 0] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op 0 : -> Zero .\n  op g : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) .\n```"]], "MAUDE-1/uninitIterExtSeptember2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in handling of extension information for iter symbols.\n***\n\nmod UNINITIALIZED-BUG is\n  protecting NAT .\n  vars N M : ____(Nat)____ .\n  crl [rwc] : s N => M if N => M [nonexec] .\nendm\n\nsrew 3 using rwc{idle} .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in handling of extension information for iter symbols.\n***\n\nmod UNINITIALIZED-BUG is\n  protecting NAT .\n  vars N M : ____(Nat)____ .\n  crl [rwc] : s N => M if N => M [nonexec] .\nendm\n\nsrew 3 using rwc{idle} .\n```"]], "MAUDE-1/upTheoryJanuary2023.maude": [[false, "Since the given incomplete code is already complete and corresponds to the description provided, the completed file remains the same as the given one."]], "MAUDE-1/variantUnifyJune2020.maude": [[false, "To complete the provided Maude code, let's first analyze the given description and the incomplete code.\n\nThe incomplete code is:"]], "MAUDE-1/renaming.maude": [[true, "set show timing off .\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, sort Bar to Quux) .\nendfm\n\nshow mod .\nshow all .\n\nfmod ONE is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod TWO is\n  inc ONE * (sort Foo to Baz) .\n  sort Quux .\n  subsort Quux < Baz .\nendfm\n\nfmod THREE is\n  inc TWO * (sort Foo to Foo', sort Baz to Baz', sort Quux to Quux') .\n  sort Jaz .\n  subsort Jaz < Baz' .\nendfm\n\nshow mod .\nshow all .\n\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, op a to b) .\nendfm\n\nshow mod .\nshow all .\n\nfmod FOO' is\n  sorts Foo Bar Baz .\n  subsort Foo < Bar .\n  op a : -> Baz .\n  op f : Foo Foo -> Foo [prec 31 gather (e assoc) comm idem] .\n  op _+_ : Foo Baz -> Foo [prec 31 gather (e assoc)] .\nendfm\n\nfmod BAR' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ : Foo Foo -> Foo to _*_ [prec 29 gather (E e)],\n    op _+_ : Baz Baz -> Foo to _._ [prec 27 gather (E e)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a . a * a . a .\n\nfmod BAR'' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ to _*_ [prec 29 gather (E E)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a * a * a * a .\nred (a * a) * (a * a) .\n\n*** Check splitting renaming over bashed together ops\n\nfmod DIFF is\n  sorts Foo Bar .\n  op f : Foo -> Foo .\n  op f : Bar -> Bar .\nendfm\n\nfmod BASH is\n  inc DIFF .\n  subsort Foo < Bar .\nendfm\n\nfmod TEST is\n  inc BASH * (op f : Bar -> Foo to g) .\nendfm\n\nshow mod .\nshow all .\nshow modules .", "```maude\nset show timing off .\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, sort Bar to Quux) .\nendfm\n\nshow mod .\nshow all .\n\nfmod ONE is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod TWO is\n  inc ONE * (sort Foo to Baz) .\n  sort Quux .\n  subsort Quux < Baz .\nendfm\n\nfmod THREE is\n  inc TWO * (sort Foo to Foo', sort Baz to Baz', sort Quux to Quux') .\n  sort Jaz .\n  subsort Jaz < Baz' .\nendfm\n\nshow mod .\nshow all .\n\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, op a to b) .\nendfm\n\nshow mod .\nshow all .\n\nfmod FOO' is\n  sorts Foo Bar Baz .\n  subsort Foo < Bar .\n  op a : -> Baz .\n  op f : Foo Foo -> Foo [prec 31 gather (e assoc) comm idem] .\n  op _+_ : Foo Baz -> Foo [prec 31 gather (e assoc)] .\nendfm\n\nfmod BAR' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ : Foo Foo -> Foo to _*_ [prec 29 gather (E e)],\n    op _+_ : Baz Baz -> Foo to _._ [prec 27 gather (E e)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a . a * a . a .\n\nfmod BAR'' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ to _*_ [prec 29 gather (E E)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a * a * a * a .\nred (a * a) * (a * a) .\n\n*** Check splitting renaming over bashed together ops\n\nfmod DIFF is\n  sorts Foo Bar .\n  op f : Foo -> Foo .\n  op f : Bar -> Bar .\nendfm\n\nfmod BASH is\n  inc DIFF .\n  subsort Foo < Bar .\nendfm\n\nfmod TEST is\n  inc BASH * (op f : Bar -> Foo to g) .\nendfm\n\nshow mod .\nshow all .\nshow modules .\n```"]], "MAUDE-1/Carlsen_Secret_Key_Initiator.maude": [[true, "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Masterkey Sessionkey < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Nonce -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NB1 NMS NM : Nonce .\n  vars M1 MA MB M MS M' : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(A ; NA), +(p(NA)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)), \n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , A ; NA ; B ; n(B,r) ; SK) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(A,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(B,s), A ; NA ; B ; seskey(A, B, n(S,r)))), \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , a ; NA ; b ; n(b,r) ; SK) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Masterkey Sessionkey < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Nonce -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NB1 NMS NM : Nonce .\n  vars M1 MA MB M MS M' : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(A ; NA), +(p(NA)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)), \n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , A ; NA ; B ; n(B,r) ; SK) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(A,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(B,s), A ; NA ; B ; seskey(A, B, n(S,r)))), \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , a ; NA ; b ; n(b,r) ; SK) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/ltv-F-tmn.maude": [[true, "***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce .\n  subsort Name Nonce < Msg .\n  subsort Name < Public .\n\n  --- Encryption operator\n  op pkenc : Msg Msg -> Msg [frozen] .\n  --- Decryption operator is not needed as we are not checking for decryption explicitly\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  op s : -> Name . --- Server\n  \n  --- Pairing operator\n  op pair : Msg Msg -> Msg [frozen] .\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * null = X:Msg [variant] .\n  eq (X:Msg * Y:Msg) * X:Msg = Y:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N NA NB NI : Nonce .\n  vars A B : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(A,r)), nil ] &\n     :: nil :: [ nil | -(N), +(pkenc(N,pk(s))), nil ] &  --- represents encryption with PKS\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(b, pkenc(n(a,r),pk(s)))),\n           -(pair(b, n(a,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(a),\n           +(pair(a, pkenc(n(b,r'),pk(s)))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, pkenc(NA,pk(s)))),\n           +(A),\n           -(pair(A, pkenc(NB,pk(s)))),\n           +(pair(B, NB * NA)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, pkenc(n(a,r),pk(s)))),\n           -(pair(b, n(a,r) * NI)), \n           nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce .\n  subsort Name Nonce < Msg .\n  subsort Name < Public .\n\n  --- Encryption operator\n  op pkenc : Msg Msg -> Msg [frozen] .\n  --- Decryption operator is not needed as we are not checking for decryption explicitly\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  op s : -> Name . --- Server\n  \n  --- Pairing operator\n  op pair : Msg Msg -> Msg [frozen] .\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * null = X:Msg [variant] .\n  eq (X:Msg * Y:Msg) * X:Msg = Y:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N NA NB NI : Nonce .\n  vars A B : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(A,r)), nil ] &\n     :: nil :: [ nil | -(N), +(pkenc(N,pk(s))), nil ] &  --- represents encryption with PKS\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(b, pkenc(n(a,r),pk(s)))),\n           -(pair(b, n(a,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(a),\n           +(pair(a, pkenc(n(b,r'),pk(s)))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, pkenc(NA,pk(s)))),\n           +(A),\n           -(pair(A, pkenc(NB,pk(s)))),\n           +(pair(B, NB * NA)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, pkenc(n(a,r),pk(s)))),\n           -(pair(b, n(a,r) * NI)), \n           nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ltv-F-tmn2-asy.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n  subsort Null < Msg .\n\n  op pair : Msg Msg -> Msg [frozen] .\n  op enc : Msg -> Msg [frozen] .\n  \n  op n : Name Fresh -> Nonce [frozen] .\n  \n  op a : -> Name . \n  op b : -> Name . \n  op i : -> Name . \n  \n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq null * X:Msg = X:Msg [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq X:Msg * X:Msg = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  vars X Y : Msg .\n  vars r r' : Fresh .\n  vars NA NB KA KB : Nonce .\n  vars A B : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = \n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))), \n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))), \n           -(pair(b, n(a,r') * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n  subsort Null < Msg .\n\n  op pair : Msg Msg -> Msg [frozen] .\n  op enc : Msg -> Msg [frozen] .\n  \n  op n : Name Fresh -> Nonce [frozen] .\n  \n  op a : -> Name . \n  op b : -> Name . \n  op i : -> Name . \n  \n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq null * X:Msg = X:Msg [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq X:Msg * X:Msg = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  vars X Y : Msg .\n  vars r r' : Fresh .\n  vars NA NB KA KB : Nonce .\n  vars A B : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = \n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))), \n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))), \n           -(pair(b, n(a,r') * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/dh.maude": [[false, "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A)\nB --> A: A ; B ; exp(g,N_A)\nA --> B: enc(exp(exp(g,N_B),N_A),secret(A,B))\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Exp < GenvExp .\n  subsort Gen < GenvExp .\n  subsort Name Nonce GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret"]], "MAUDE-1/esorics12-asy.maude": [[false, "To complete the given Maude-NPA protocol analysis code, we'll fill in the blanks indicated by `____(SOMETHING)____` based on the provided protocol description.\n\n1. **Sort Information and Subsorts**: The description defines sorts and subsorts. We see that `Name`, `Nonce`, `NNSet`, and `Null` are sorts, with `Name` being a subsort of `Public`, and `Nonce` and `Null` being subsorts of `NNSet`. `NNSet` is a subsort of `Msg`.\n\n2. **Operations**:\n   - `pk : Name Msg -> Msg` is used for public key encryption.\n   - `sk : Name Msg -> Msg` is used for signing or private key operation.\n   - `n : Name Fresh -> Nonce` generates a nonce for a principal.\n   - `_*_ : NNSet NNSet -> NNSet` is the XOR operation.\n\nLet's fill in the blanks accordingly."]], "MAUDE-1/esorics12-variant.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .  \n\n   --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN ZN : NNSet .\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq (XN * YN) * ZN = XN * (YN * ZN) [variant] .\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(Y), +(sk(A,Y)), nil ] & \n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | -(sk(A,X)), +(X), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(B,r))), \n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, N)), \n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,XN) inL . \n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, N)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,r')) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .  \n\n   --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN ZN : NNSet .\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq (XN * YN) * ZN = XN * (YN * ZN) [variant] .\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(Y), +(sk(A,Y)), nil ] & \n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | -(sk(A,X)), +(X), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(B,r))), \n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, N)), \n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,XN) inL . \n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, N)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,r')) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ACU_TreeVariableSubproblem.maude": [[true, "set show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(12), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(1), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N == 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(5), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(1), g(1)) .\nred h(f(g(1), g(9)), f(g(1), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N == 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(5), g(5)) .\nred h(f(g(5), g(9)), f(g(5), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(1), g(1)) .\nred h(f(g(1), g(9)), f(g(1), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N == 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(5), g(5)) .\nred h(f(g(5), g(9)), f(g(5), g(9))) .  *** multiplicities > 1", "```maude\nset show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(12), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(1), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N == 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(5), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(1), g(1)) .\nred h(f(g(1), g(9)), f(g(1), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N == 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(5), g(5)) .\nred h(f(g(5), g(9)), f(g(5), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(1), g(1)) .\nred h(f(g(1), g(9)), f(g(1), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Nat Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N == 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(5), g(5)) .\nred h(f(g(5), g(9)), f(g(5), g(9))) .  *** multiplicities > 1\n```"]], "MAUDE-1/homo-hpc.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n protecting DEFINITION-PROTOCOL-RULES .\n\n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n op a : -> Name . \n op b : -> Name . \n op s : -> Name . \n op i : -> Name . \n\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n op pkey : Name Name -> Pkey .\n\n op f : Msg Msg -> HEnc [frozen] .\n\n op pke : Msg Name -> Enc [frozen] .\n op hpke : Msg Pkey -> HEnc [frozen] .\n op sign : Msg Name -> Sign [frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n vars X Y : Msg .\n var K : Pkey .\n\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K)) \n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] & \n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] & \n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] & \n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] &\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] & \n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] & \n    :: nil :: [ nil | +(A), nil ] \n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  = :: r, r'  :: \n    [ nil | +(sign( b ; n(a,r)  ; pke(hpke(data(a,r'),pkey(a,b)),s),a)),\n            -(sign( n(a,r) ; N ; Y1 , b)), \n            +(sign( a ; b ; n(a,r) ; N ; pke(hpke(data(a,r'),pkey(a,b)),s) ; Y1  , a)),\n\t    -(sign( a ; b ; n(a,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: \n    [ nil | -(sign( b ; N1  ; Y2, a)),\n            +(sign( N1 ; n(b,r) ; pke(hpke(data(b,r'),pkey(a,b)),s), b)), \n\t    -(sign( a ; b ; N1 ; n(b,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: \n    [ nil | -(sign( a ; b ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , a)),\n            +(sign( a ; b ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  \n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )), \n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty\n     || nil\n     || nil\n     || never(\n     :: r1, r2  :: \n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)),\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)),\n       nil ] \n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\nselect MAUDE-NPA .", "To address the task, I will complete the given Maude-NPA code based on the provided description and ensure it compiles successfully.\n\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n protecting DEFINITION-PROTOCOL-RULES .\n\n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n op a : -> Name . \n op b : -> Name . \n op s : -> Name . \n op i : -> Name . \n\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n op pkey : Name Name -> Pkey .\n\n op f : Msg Msg -> HEnc [frozen] .\n\n op pke : Msg Name -> Enc [frozen] .\n op hpke : Msg Pkey -> HEnc [frozen] .\n op sign : Msg Name -> Sign [frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n vars X Y : Msg .\n var K : Pkey .\n\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K)) \n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] & \n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] & \n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] & \n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] &\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] & \n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] & \n    :: nil :: [ nil | +(A), nil ] \n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  = :: r, r'  :: \n    [ nil | +(sign( b ; n(a,r)  ; pke(hpke(data(a,r'),pkey(a,b)),s),a)),\n            -(sign( n(a,r) ; N ; Y1 , b)), \n            +(sign( a ; b ; n(a,r) ; N ; pke(hpke(data(a,r'),pkey(a,b)),s) ; Y1  , a)),\n\t    -(sign( a ; b ; n(a,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: \n    [ nil | -(sign( b ; N1  ; Y2, a)),\n            +(sign( N1 ; n(b,r) ; pke(hpke(data(b,r'),pkey(a,b)),s), b)), \n\t    -(sign( a ; b ; N1 ; n(b,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: \n    [ nil | -(sign( a ; b ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , a)),\n            +(sign( a ; b ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  \n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )), \n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty\n     || nil\n     || nil\n     || never(\n     :: r1, r2  :: \n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)),\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)),\n       nil ] \n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\nselect MAUDE-NPA .\n```\n\nThe changes made include:\n1. Replacing specific names (like `Alice`, `Bob`) with their corresponding operator representations (`a`, `b`) to match the defined operators in the `PROTOCOL-EXAMPLE-SYMBOLS` module.\n2. Ensuring that the variables and operators are correctly used according to their definitions.\n\nThis completed code is ready to be compiled by Maude-NPA. \n\n```maude\n```"]], "MAUDE-1/homo-nsl.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var X Y : Msg .\n  var Z : Key .\n\n  eq pk(X ; Y, Z) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(r)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var X Y : Msg .\n  var Z : Key .\n\n  eq pk(X ; Y, Z) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(r)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  --- Nonce \n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Usernames\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (E e)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(s,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(mkey(B,s), A ; B ; n(A,r) ; SK) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never \n     (:: R:FreshSet ::\n     [ nil | +(a ; b ; NA),\n             -(MA ; e(SK, NA) ; n(b,R)),\n             +(e(SK, n(b,R))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "To complete the given Maude-NPA file, we will directly fill in the missing parts indicated by `____(OP/EQ/VAR_#)____`. The file seems to be related to the Kao Chow Repeated Authentication Protocol.\n\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  --- Nonce \n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Usernames\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (E e)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(s,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(mkey(B,s), A ; B ; n(A,r) ; SK) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never \n     (:: R:FreshSet ::\n     [ nil | +(a ; b ; NA),\n             -(MA ; e(SK, NA) ; n(b,R)),\n             +(e(SK, n(b,R))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```\n\nCompleted file is between ```maude and ```.\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  --- Nonce \n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Usernames\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (E e)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(s,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(mkey(B,s), A ; B ; n(A,r) ; SK) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never \n     (:: R:FreshSet ::\n     [ nil | +(a ; b ; NA),\n             -(MA ; e(SK, NA) ; n(b,R)),\n             +(e(SK, n(b,R))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Handshake_Key.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort UName SName < Name .\n  subsort Masterkey Sessionkey < Key .\n  subsort Enc Key < Msg .\n  subsort Name < Public .\n\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  ops a b i : -> UName .\n  op s : ->  SName . \n\n  op mkey : Name Name -> Masterkey [comm] .\n \n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  op _;_ : Msg Msg -> Msg [frozen assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B T : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars TS TA NB : Nonce .\n  vars X M M2 N : Msg .\n  var K Ke : Key . \n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB),\n            +(e(Kt, n(A,r) ; SK)) , nil ]\n &\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) , nil ] \n &\n     :: r,r' ::\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r'))),\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r :: \n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) | nil ] \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n  \nendfm\n\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "To complete the given Maude-NPA code, let's start by identifying the missing parts:\n\n1. Sort declarations and their subsort relationships.\n2. Operator declarations for nonces, keys, and message concatenation.\n\nHere is the step-by-step completion of the code:\n\n### Sort Declarations and Subsort Relationships\n\nThe sorts declared are `UName`, `SName`, `Name`, `Key`, `Nonce`, `Masterkey`, `Sessionkey`, and `Enc`. We need to establish their subsort relationships.\n\n- `UName` and `SName` are subsorts of `Name`.\n- `Name` is a subsort of `Public`.\n- `Masterkey` and `Sessionkey` are subsorts of `Key`.\n- `Enc` is a subsort of `Msg`, and `Key` is also a subsort of `Msg`.\n\n### Operator Declarations\n\n1. **Nonce Operator**: The operator to generate a nonce is `n(Name, Fresh)`.\n   - `op n : Name Fresh -> Nonce [frozen] .`\n   - Another nonce operator is given as `t : Name Fresh -> Nonce [frozen] .`\n\n2. **Master Key Operator**: `mkey(Name, Name) -> Masterkey`\n   - `op mkey : Name Name -> Masterkey [comm] .`\n\n3. **Session Key Operator**: `seskey(Name, Name, Nonce) -> Sessionkey`\n   - `op seskey : Name Name Nonce -> Sessionkey [frozen] .`\n\n4. **Encryption/Decryption Operators**: `e(Key, Msg) -> Msg` and `d(Key, Msg) -> Msg`\n   - `op e : Key Msg -> Msg [frozen] .`\n   - `op d : Key Msg -> Msg [frozen] .`\n\n5. **Message Concatenation Operator**: `_;_ : Msg Msg -> Msg`\n   - `op _;_ : Msg Msg -> Msg [frozen assoc] .`\n\nLet's fill in the blanks:\n\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort UName SName < Name .\n  subsort Masterkey Sessionkey < Key .\n  subsort Enc Key < Msg .\n  subsort Name < Public .\n\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  ops a b i : -> UName .\n  op s : ->  SName . \n\n  op mkey : Name Name -> Masterkey [comm] .\n \n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  op _;_ : Msg Msg -> Msg [frozen assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B T : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars TS TA NB : Nonce .\n  vars X M M2 N : Msg .\n  var K Ke : Key . \n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB),\n            +(e(Kt, n(A,r) ; SK)) , nil ]\n &\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) , nil ] \n &\n     :: r,r' ::\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r'))),\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r :: \n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) | nil ] \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n  \nendfm\n\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```\n\nThe completed code should look like this:\n\n```maude\n```houzhui\n----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort UName SName < Name .\n  subsort Masterkey Sessionkey < Key .\n  subsort Enc Key < Msg .\n  subsort Name < Public .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt/decrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B T : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars TS TA NB : Nonce .\n  vars X M M2 N : Msg .\n  var K Ke : Key . \n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB),\n            +(e(Kt, n(A,r) ; SK)) , nil ]\n &\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) , nil ] \n &\n     :: r,r' ::\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r'))),\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r :: \n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r')),\n            -(e(Kt, NA ; SK)) | nil ] \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n  \n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Ticket.maude": [[true, "----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort Name Nonce Enc < Msg .\n  subsort UName SName < Name .\n  subsort Masterkey Sessionkey < Key .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Enc [frozen] .\n  op d : Key Enc -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B T : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars TS NA NB : Nonce .\n  vars X Y Z N MA MB : Msg .\n  var K Ke : Key . \n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  &\n     :: r   :: [ nil | +(n(i,r)), nil ]\n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt),E(Kbs:A,B,Na,Kab,Kt)\n  --- B->A : E(Kas:A,B,Na,Kab,Kt),E(Kt:Na,Kab),Nb,E(Kbs:A,B,Ta,Kab)\n  --- A->B : E(Kt:Na,Kab),E(Kbs:A,B,Ta,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB ; e(mkey(B,s), A ; B ; TS ; SK)),\n            +(e(Kt, n(A,r) ; SK) ; e(mkey(B,s), A ; B ; TS ; SK)), nil ]\n &\n    --- Bob's Strand\n    :: r,r' :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, NA ; SK) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)) , nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(ST1) =\n    :: r,r' :: \n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, NA ; SK) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)) | nil ] \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort Name Nonce Enc < Msg .\n  subsort UName SName < Name .\n  subsort Masterkey Sessionkey < Key .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Enc [frozen] .\n  op d : Key Enc -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B T : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . \n  vars TS NA NB : Nonce .\n  vars X Y Z N MA MB : Msg .\n  var K Ke : Key . \n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  &\n     :: r   :: [ nil | +(n(i,r)), nil ]\n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt),E(Kbs:A,B,Na,Kab,Kt)\n  --- B->A : E(Kas:A,B,Na,Kab,Kt),E(Kt:Na,Kab),Nb,E(Kbs:A,B,Ta,Kab)\n  --- A->B : E(Kt:Na,Kab),E(Kbs:A,B,Ta,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB ; e(mkey(B,s), A ; B ; TS ; SK)),\n            +(e(Kt, n(A,r) ; SK) ; e(mkey(B,s), A ; B ; TS ; SK)), nil ]\n &\n    --- Bob's Strand\n    :: r,r' :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, NA ; SK) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)) , nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(ST1) =\n    :: r,r' :: \n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) , \n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, NA ; SK) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)) | nil ] \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/mpOTR_connect.maude": [[true, "***(\n\tThese are the first steps towards mpOTR protocol verification and security\n\tanalysis.\n\tThis module describes the Communication Setup phase of the main course of\n\tthe protocol that is as follows:\n\n\t\tClient-1 --> Client-2 : Client-1 ; Fx-Mess\n\t\tClient-1 --> Client-3 : Client-1 ; Fx-Mess\n\t\tClient-2 --> Client-1 : Client-2 ; Fx-Mess\n\t\tClient-2 --> Client-3 : Client-2 ; Fx-Mess\n\t\tClient-3 --> Client-1 : Client-3 ; Fx-Mess\n\t\tClient-3 --> Client-2 : Client-3 ; Fx-Mess\n\t\n\twhere Clients represent people (or, more spesificly, their chat clients)\n\twishing to interact with each other, Mess is some pre-defined message equal\n\tfor all clients. Number of clients represents multi-party property of mpOTR.\n\t\n\tNo algebraic properties reqiered.\n)***\n\n--- protocol syntax - types and operations\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n\t--- Importing sorts Msg, Fresh, Public\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\n\t--- Sort Information\n\tsorts Name FixedMessage Key .\n\tsubsort Name < Msg .\n\tsubsort Key < Msg .\n\tsubsort Name < Public . --- means that Name info is publicly availible\n\tsubsort FixedMessage < Public .\n\n\t--- Principals -- name constants\n\tops client-1 client-2 client-3 intruder : -> Name .\n\top x1 : -> Key .\n\n\t--- [Get] Fixed Message\n\top fxMess : -> FixedMessage .\n\n\t--- Concatenation\n\top _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- operator prop-es-see man\n\nendfm\n\n--- Algebraic properties of the protocol\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\nendfm\n\n--- Protocol strands (what's that?)\nfmod PROTOCOL-SPECIFICATION is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\tprotecting DEFINITION-CONSTRAINTS-INPUT .\n\n\tvars M1 M2 : Msg .\n\tvar fM : FixedMessage .\n\tvar N Name1 Name2 : Name .\n\t\n\t--- Actions an intruder can perform\n\teq STRANDS-DOLEVYAO =\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n\t\t:: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n\t\t:: nil :: [ nil | +(fM), nil ] &\n\t\t:: nil :: [ nil | +(N), nil ] &\n\t\t:: nil :: [ nil | +(x1), nil ] \n\t[nonexec] .\n\n\teq STRANDS-PROTOCOL =\n\t\t:: nil :: --- vars of sort Fresh are explicit\n\t\t[nil | +(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   +(client-3 ; fxMess), nil]\n\t[nonexec] .\n\n\t--- eq EXTRA-GRAMMARS --- increase performance = cut the search tree.\n\t--- [nonexec] .\n\n\teq ATTACK-STATE(0) = \n\t  \tempty\n\t\t|| empty\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil \n\t[nonexec] .\n\n\teq ATTACK-STATE(1) = \n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(2) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name2 != client-3 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| x1 inI\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\n\t***(eq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1, \n\t\t   Name2 != client-3\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .)***\n\nendfm\n\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\n\tThese are the first steps towards mpOTR protocol verification and security\n\tanalysis.\n\tThis module describes the Communication Setup phase of the main course of\n\tthe protocol that is as follows:\n\n\t\tClient-1 --> Client-2 : Client-1 ; Fx-Mess\n\t\tClient-1 --> Client-3 : Client-1 ; Fx-Mess\n\t\tClient-2 --> Client-1 : Client-2 ; Fx-Mess\n\t\tClient-2 --> Client-3 : Client-2 ; Fx-Mess\n\t\tClient-3 --> Client-1 : Client-3 ; Fx-Mess\n\t\tClient-3 --> Client-2 : Client-3 ; Fx-Mess\n\t\n\twhere Clients represent people (or, more spesificly, their chat clients)\n\twishing to interact with each other, Mess is some pre-defined message equal\n\tfor all clients. Number of clients represents multi-party property of mpOTR.\n\t\n\tNo algebraic properties reqiered.\n)***\n\n--- protocol syntax - types and operations\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n\t--- Importing sorts Msg, Fresh, Public\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\n\t--- Sort Information\n\tsorts Name FixedMessage Key .\n\tsubsort Name < Msg .\n\tsubsort Key < Msg .\n\tsubsort Name < Public . --- means that Name info is publicly availible\n\tsubsort FixedMessage < Public .\n\n\t--- Principals -- name constants\n\tops client-1 client-2 client-3 intruder : -> Name .\n\top x1 : -> Key .\n\n\t--- [Get] Fixed Message\n\top fxMess : -> FixedMessage .\n\n\t--- Concatenation\n\top _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- operator prop-es-see man\n\nendfm\n\n--- Algebraic properties of the protocol\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\nendfm\n\n--- Protocol strands (what's that?)\nfmod PROTOCOL-SPECIFICATION is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\tprotecting DEFINITION-CONSTRAINTS-INPUT .\n\n\tvars M1 M2 : Msg .\n\tvar fM : FixedMessage .\n\tvar N Name1 Name2 : Name .\n\t\n\t--- Actions an intruder can perform\n\teq STRANDS-DOLEVYAO =\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n\t\t:: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n\t\t:: nil :: [ nil | +(fM), nil ] &\n\t\t:: nil :: [ nil | +(N), nil ] &\n\t\t:: nil :: [ nil | +(x1), nil ] \n\t[nonexec] .\n\n\teq STRANDS-PROTOCOL =\n\t\t:: nil :: --- vars of sort Fresh are explicit\n\t\t[nil | +(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   +(client-3 ; fxMess), nil]\n\t[nonexec] .\n\n\t--- eq EXTRA-GRAMMARS --- increase performance = cut the search tree.\n\t--- [nonexec] .\n\n\teq ATTACK-STATE(0) = \n\t  \tempty\n\t\t|| empty\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil \n\t[nonexec] .\n\n\teq ATTACK-STATE(1) = \n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(2) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name2 != client-3 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| x1 inI\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\n\t***(eq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1, \n\t\t   Name2 != client-3\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .)***\n\nendfm\n\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/mpOTR_dh.maude": [[true, "*** This file was generated using the Maude-NPA tool \n*** with some modifications to illustrate a security protocol \n** between \nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : Gen NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm id: empty] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars A B : Name .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars r r' r'' r3 : Fresh .\n  var XE : Key .\n  vars M1 M2 M : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; B ; XE), \n            +(e(exp(XE,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; exp(g,n(A,r))), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(exp(g,n(A,r)),n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r')) inL . ;\n      grl empty => n(b,r') inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     (:: R:FreshSet ::\n     [nil | +(A ; b ; XE), \n            -(a ; b ; exp(g,n(b,r))), \n            +(e(YE,sec(A,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N2:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     (:: nil :: \n      [nil | -(exp(GE:Gen, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n*** This file was generated using the Maude-NPA tool \n*** with some modifications to illustrate a security protocol \n** between \nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : Gen NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm id: empty] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars A B : Name .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars r r' r'' r3 : Fresh .\n  var XE : Key .\n  vars M1 M2 M : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; B ; XE), \n            +(e(exp(XE,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; exp(g,n(A,r))), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(exp(g,n(A,r)),n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r')) inL . ;\n      grl empty => n(b,r') inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     (:: R:FreshSet ::\n     [nil | +(A ; b ; XE), \n            -(a ; b ; exp(g,n(b,r))), \n            +(e(YE,sec(A,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N2:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     (:: nil :: \n      [nil | -(exp(GE:Gen, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [assoc (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(i,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r))), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never *** for authentication\n     (:: r' :: \n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ] \n     & S:StrandSet  \n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [assoc (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(i,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r))), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never *** for authentication\n     (:: r' :: \n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ] \n     & S:StrandSet  \n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_ECB.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce < Msg .\n  subsort Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Key -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) frozen assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq pk(X:Msg ; Y:Msg, K:Key) = pk(X:Msg, K:Key) ; pk(Y:Msg, K:Key) \n  [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n     :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce < Msg .\n  subsort Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Key -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg Msg  -> Msg [gather (e E) frozen assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq pk(X:Msg ; Y:Msg, K:Key) = pk(X:Msg, K:Key) ; pk(Y:Msg, K:Key) \n  [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n     :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_Modified.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce < Msg .\n  subsort Nonce < NNSet .\n  subsort NNSet < Msg .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc (e id: nil) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : NNSet .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(A,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce < Msg .\n  subsort Nonce < NNSet .\n  subsort NNSet < Msg .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc (e id: nil) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : NNSet .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(A,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ascentFunctionsJanuary2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule('BAD, false) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts('BAD, false) .\nred in META-LEVEL : upSubsortDecls('BAD, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule('BAD, false) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts('BAD, false) .\nred in META-LEVEL : upSubsortDecls('BAD, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_XOR.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce < Msg .\n  subsort Name Nonce < NNSet .\n  subsort NNSet < Msg .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r')), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce < Msg .\n  subsort Name Nonce < NNSet .\n  subsort NNSet < Msg .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r')), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/nspk.maude": [[false, "The completed code is as follows:"]], "MAUDE-1/secret06.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows,\nwhere S is the server:\n\nS --> A: N_S\nA --> B: sk(A,N_S ; S)\nA --> B: sk(A,B ; N_A ; S)\n\nwhere N_A, N_S, and N_B are nonces, and sk(x,y) means message y encripted \nusing private key x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  X ; (Y ; Z) = (X ; Y) ; Z\n  pk(K,sk(K,M)) = M\n  sk(K,pk(K,M)) = M\n\nHowever, note that the associativity property is bounded to depth 3 below by\nusing appopriate sorts.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES . --- Importing sort Msg, Fresh, Public\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  sorts List Elm .\n  subsort Name < Key .\n  subsort Name Nonce Key < Elm .\n  subsort Elm < Msg .\n  subsort List < Msg .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Keys known by intruder\n  op s : -> Name . --- Name for the Server\n  op a : -> Name . --- Name for the Initiator\n  op b : -> Name . --- Name for the Responder\n  op i : -> Name . --- Name for the Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Associativity operator\n  op _;_ : List List  -> List [frozen assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  vars Xe Ye Ze : Elm .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n  \n  *** Bounded Associativity (for 3-depth)\n  eq Xe ; (Ye ; Ze) = (Xe ; Ye) ; Ze [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  var r : Fresh .\n  var N : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ]\n     &\n     --- Private encryption only his key\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] \n     &\n      --- Public encryption any key\n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = --- server \n     :: r :: [nil | +(n(s,r)), nil ] &\n     --- initiator\n     :: r :: [nil | -(N), +(sk(a,N ; s)), +(sk(a,b ; (n(a,r) ; s))), nil] &\n     --- responder\n     :: nil :: [nil | -(sk(a,X ; s)), -(sk(a,(b ; Z) ; s)), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: nil :: [nil, -(sk(a,X ; s)), -(sk(a,(b ; N) ; s)) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows,\nwhere S is the server:\n\nS --> A: N_S\nA --> B: sk(A,N_S ; S)\nA --> B: sk(A,B ; N_A ; S)\n\nwhere N_A, N_S, and N_B are nonces, and sk(x,y) means message y encripted \nusing private key x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  X ; (Y ; Z) = (X ; Y) ; Z\n  pk(K,sk(K,M)) = M\n  sk(K,pk(K,M)) = M\n\nHowever, note that the associativity property is bounded to depth 3 below by\nusing appopriate sorts.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES . --- Importing sort Msg, Fresh, Public\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  sorts List Elm .\n  subsort Name < Key .\n  subsort Name Nonce Key < Elm .\n  subsort Elm < Msg .\n  subsort List < Msg .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Keys known by intruder\n  op s : -> Name . --- Name for the Server\n  op a : -> Name . --- Name for the Initiator\n  op b : -> Name . --- Name for the Responder\n  op i : -> Name . --- Name for the Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Associativity operator\n  op _;_ : List List  -> List [frozen assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  vars Xe Ye Ze : Elm .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n  \n  *** Bounded Associativity (for 3-depth)\n  eq Xe ; (Ye ; Ze) = (Xe ; Ye) ; Ze [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  var r : Fresh .\n  var N : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ]\n     &\n     --- Private encryption only his key\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] \n     &\n      --- Public encryption any key\n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = --- server \n     :: r :: [nil | +(n(s,r)), nil ] &\n     --- initiator\n     :: r :: [nil | -(N), +(sk(a,N ; s)), +(sk(a,b ; (n(a,r) ; s))), nil] &\n     --- responder\n     :: nil :: [nil | -(sk(a,X ; s)), -(sk(a,(b ; Z) ; s)), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: nil :: [nil, -(sk(a,X ; s)), -(sk(a,(b ; N) ; s)) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/secret07.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A\nA --> B: B\nA --> B: exp(g,N_A)\nB --> A: B\nB --> A: A\nB --> A: exp(g,N_B)\n\nwhere N_A and N_B are nonces, and exp(x,y) means raising message y to \nexponent x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n\nHowever, note that this property is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp GenvExp .\n  subsort Gen Exp < GenvExp .\n  subsort NeNonceSet GenvExp < Msg .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS : NeNonceSet .\n  var G : GenvExp .\n  var A B : Name .\n  var r : Fresh .\n  vars XE YE : Exp .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(NS1), -(NS2), +(NS1 ; NS2), nil ] &\n     :: nil :: [ nil | -(G), -(NS), +(exp(G,NS)), nil ] &\n     :: r :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(B), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: [nil | +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(XE), nil] &\n     :: r :: [nil | -(a), -(b), -(YE), +(b), +(a), +(exp(g,n(b,r))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(exp(g,NS)) | nil]\n     || exp(g, NS * n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A\nA --> B: B\nA --> B: exp(g,N_A)\nB --> A: B\nB --> A: A\nB --> A: exp(g,N_B)\n\nwhere N_A and N_B are nonces, and exp(x,y) means raising message y to \nexponent x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n\nHowever, note that this property is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp GenvExp .\n  subsort Gen Exp < GenvExp .\n  subsort NeNonceSet GenvExp < Msg .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS : NeNonceSet .\n  var G : GenvExp .\n  var A B : Name .\n  var r : Fresh .\n  vars XE YE : Exp .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(NS1), -(NS2), +(NS1 ; NS2), nil ] &\n     :: nil :: [ nil | -(G), -(NS), +(exp(G,NS)), nil ] &\n     :: r :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(B), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: [nil | +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(XE), nil] &\n     :: r :: [nil | -(a), -(b), -(YE), +(b), +(a), +(exp(g,n(b,r))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(exp(g,NS)) | nil]\n     || exp(g, NS * n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Wide_Mouthed_Frog.maude": [[false, "```maude\n----Wide Mouthed Frog Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name UName SName < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n  : Name Fresh -> Nonce"]], "MAUDE-1/Woo-Lam_Authentication.maude": [[true, "---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name UName < Public .\n  subsort Name Text < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [ctor] .\n  --- Nonce operator\n  op n : UName Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (E assoc)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S Z G : UName .  \n  vars r r' r'' r''' r1 r## rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars M MA MB MS ZM M1 MG : Msg . \n  var K Kz Kb : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(Z,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand. \n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)), \n             nil ]\n   &\n     :: r  :: \n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(e(mkey(B,s), A ; n(B,r))),\n             +(e(mkey(B,s), n(B,r))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(e(mkey(A,s), NB)),\n             -(e(mkey(B,s), A ; NB)),\n             +(e(mkey(B,s), NB)), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(e(mkey(b,s) , a ; n(b,r))),\n            +(e(mkey(b,s) , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n \nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name UName < Public .\n  subsort Name Text < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [ctor] .\n  --- Nonce operator\n  op n : UName Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (E assoc)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S Z G : UName .  \n  vars r r' r'' r''' r1 r## rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars M MA MB MS ZM M1 MG : Msg . \n  var K Kz Kb : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(Z,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand. \n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)), \n             nil ]\n   &\n     :: r  :: \n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(e(mkey(B,s), A ; n(B,r))),\n             +(e(mkey(B,s), n(B,r))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(e(mkey(A,s), NB)),\n             -(e(mkey(B,s), A ; NB)),\n             +(e(mkey(B,s), NB)), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(e(mkey(b,s) , a ; n(b,r))),\n            +(e(mkey(b,s) , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n \nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/xor-nsl.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc prec 41 (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm frozen] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r')), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc prec 41 (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm frozen] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r')), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Yahalom.maude": [[true, "---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name UName SName < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort Nonce < Msg .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : UName Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(p(M)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , n(B,r))) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(b ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name UName SName < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort Nonce < Msg .\n  subsort UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : UName Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(p(M)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , n(B,r))) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(b ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/ISO_5_Pass_Authentication.maude": [[true, "----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name UName SName < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [ctor] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [ctor comm] .\n \n  --- Seskey\n  op seskey : Name Name Fresh -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [ctor] .\n\n  --- successor\n  op s : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  vars r r' r'' r''' r# r## r1 r2 r3 : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M M2 MA MB M1 M3 M4 : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,s)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , NB ; n(A,r))),\n             +(e(SK , n(A,r) ; NB)), \n             nil ]\n   &\n     :: r , r' :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r')),\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),\n             +(MA ; e(SK , n(B,r) ; NA)),\n             -(e(SK , NA ; n(B,r))), \n             nil ] \n   & \n     :: r  ::\n     --- Server's Strand \n    [ nil |  -(A ; NA ; B ; NB),\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A) \n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r1) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' ::\n    [ nil , -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r1) ; NA)),\n     \t\t -(e(SK , NA ; n(i,r))) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(a ; NA),\n     \t\t -(e(mkey(a,s) , NA ; SK ; b) ; e(SK , n(b,r) ; NA)),\n     \t\t +(e(SK , NA ; n(b,r))), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name UName SName < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [ctor] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [ctor comm] .\n \n  --- Seskey\n  op seskey : Name Name Fresh -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [ctor] .\n\n  --- successor\n  op s : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  vars r r' r'' r''' r# r## r1 r2 r3 : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M M2 MA MB M1 M3 M4 : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(N ; M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,s)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , NB ; n(A,r))),\n             +(e(SK , n(A,r) ; NB)), \n             nil ]\n   &\n     :: r , r' :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r')),\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),\n             +(MA ; e(SK , n(B,r) ; NA)),\n             -(e(SK , NA ; n(B,r))), \n             nil ] \n   & \n     :: r  ::\n     --- Server's Strand \n    [ nil |  -(A ; NA ; B ; NB),\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A) \n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r1) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' ::\n    [ nil , -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r1) ; NA)),\n     \t\t -(e(SK , NA ; n(i,r))) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(a ; NA),\n     \t\t -(e(mkey(a,s) , NA ; SK ; b) ; e(SK , n(b,r) ; NA)),\n     \t\t +(e(SK , NA ; n(b,r))), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Otway-Rees.maude": [[true, "----  Otway-Rees Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name < Key  .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  vars NA NMA NB NMS : Nonce .\n  vars M1 M2 MA MB1 MB2 MS M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(M'), +(M ; M') , nil ] &\n     :: nil :: [ nil | -(M ; M'), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(B,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,B)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- A -> B : M,A,B,E(Kas:Na,M,A,B). Encrypted message readable only by the server S \n  --- B -> S : M,A,B,E(Kas:Na,M,A,B),E(Kbs:Nb,M,A,B) \n  --- S\t-> B : M,E(Kas:Na,Kab),E(Kbs:Nb,Kab) \n  --- B\t-> A : M,E(Kas:Na,Kab) \n  --- Alice's Strand. \n   = :: r,rM ::\n     [ nil | +(NMA ; A ; B ; e(mkey(A,s) , n(A,r) ; NMA ; A ; B)), \n             -(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ]\n   &\n     :: r :: \n   --- Bob's Strand.\n     [ nil | -(NMA ; A ; B ; M1), \n             +(NMA ; A ; B ; M1 ; e(mkey(B,s) , n(B,r) ; NMA ; A ; B)), \n             -(NMA ; MA ; e(mkey(B,s) , n(B,r) ; SK)),\n             +(NMA ; MA), nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(NMA ; A ; B ; e(mkey(A,s), NA ; NMA ; A ; B) \n                           ; e(mkey(B,s) , NB ; NMA ; A ; B)), \n             +(NMA ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r))) \n                   ; e(mkey(B,s) , NB ; seskey(A , B , n(S,r)))) , nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(1) =\n:: r,rM ::\n--- A normal execution of the protocol\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(0) =\n:: r,rM ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n:: r,rM ::\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so.\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never \n     (:: r' :: \n     [ nil | -(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)), \n             +(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B) ; MB1), \n             -(NMA ; e(mkey(A,s) , n(A,r) ; SK) ; MB2),\n             +(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  Otway-Rees Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name < Key  .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  vars NA NMA NB NMS : Nonce .\n  vars M1 M2 MA MB1 MB2 MS M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(M'), +(M ; M') , nil ] &\n     :: nil :: [ nil | -(M ; M'), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(B,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,B)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- A -> B : M,A,B,E(Kas:Na,M,A,B). Encrypted message readable only by the server S \n  --- B -> S : M,A,B,E(Kas:Na,M,A,B),E(Kbs:Nb,M,A,B) \n  --- S\t-> B : M,E(Kas:Na,Kab),E(Kbs:Nb,Kab) \n  --- B\t-> A : M,E(Kas:Na,Kab) \n  --- Alice's Strand. \n   = :: r,rM ::\n     [ nil | +(NMA ; A ; B ; e(mkey(A,s) , n(A,r) ; NMA ; A ; B)), \n             -(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ]\n   &\n     :: r :: \n   --- Bob's Strand.\n     [ nil | -(NMA ; A ; B ; M1), \n             +(NMA ; A ; B ; M1 ; e(mkey(B,s) , n(B,r) ; NMA ; A ; B)), \n             -(NMA ; MA ; e(mkey(B,s) , n(B,r) ; SK)),\n             +(NMA ; MA), nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(NMA ; A ; B ; e(mkey(A,s), NA ; NMA ; A ; B) \n                           ; e(mkey(B,s) , NB ; NMA ; A ; B)), \n             +(NMA ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r))) \n                   ; e(mkey(B,s) , NB ; seskey(A , B , n(S,r)))) , nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(1) =\n:: r,rM ::\n--- A normal execution of the protocol\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(0) =\n:: r,rM ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n:: r,rM ::\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so.\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never \n     (:: r' :: \n     [ nil | -(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)), \n             +(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B) ; MB1), \n             -(NMA ; e(mkey(A,s) , n(A,r) ; SK) ; MB2),\n             +(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]]}