{"HLPSL-1/20172001_Assign_3.hlpsl": [[true, "role user (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by Ui\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai, Sigmai': text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4: text, Gen, Rep: hash_func\nconst ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n0. State = 0 /\\ Rcv(start) =|>\n% Registration phase\nState' := 1\n/\\ Sigmai' := Gen(BIOi)\n/\\ Snd({IDi.PWi.Sigmai'.H(PWi.Sigmai'.IDi)}_SKuira)\n\n1. State = 1 /\\ Rcv({xor(H(IDi.Kgwnui),xor(H(PWi.Sigmai'.A'),R')).TIDi'}_SKuira)=|>\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()\n/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') \n/\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ Snd(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,ui_gwn_t1, T1')\n/\\ secret(Rui',ui_gwn_rui,Rui')\n\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3\n/\\ request(GWN,Ui,gwn_ui_t4, T4')\n/\\ request(GWN,Ui,gwn_ui_tidinew,TIDinew')\nend role\n\nrole registrationauthority (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RA\ndef=\nlocal State: nat, IDi, PWi, Sigmai, A', TIDi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDinew: text,\nM2, M3, T3, T4: text, Gen, Rep: hash_func\nconst sr3: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi'.PWi'.Sigmai''}_SKuira) =|>\nState' := 1 \n/\\ Kgwnui' := new()\n/\\ secret({Kgwnui',RA,GWN,Ui},sr3)\n/\\ secret({IDi'.PWi'.Sigmai''},sr3,{RA,GWN,Ui})\n/\\ A' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ Snd({A'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4: text, Gen, Rep: hash_func\nconst gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(TIDi'.M2'.M3'.T1') =|>\nState' := 1 \n/\\ M4' := H(IDi.Kgwnui)\n/\\ request(Ui,GWN,ui_gwn_t1,T1')\n/\\ request(Ui,GWN,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ Snd(M7'.M8'.T2')\n/\\ witness(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n/\\ witness(GWN,SDj,gwn_sdj_t2,T2')\n\n2. State = 1 /\\ Rcv(M10'.M11'.M12'.T3') =|>\nState' := 2 \n/\\ TIDi' := new() \n/\\ Rgwn' := new() \n/\\ Rui' := new() \n/\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ request(SDj,GWN,sdj_gwn_t3,T3')\n/\\ request(SDj,GWN,sdj_gwn_rsdj,Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ witness(GWN,Ui,gwn_ui_t4,T4')\n/\\ witness(GWN,Ui,gwn_ui_tidinew,TIDinew')\n\nend role\n\n\n\nrole smartdevice (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4: text, Gen, Rep: hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(M4')}_M6'.M8'.T2') =|>\nState' := 1 \n/\\ Kgwnsdj' := new()\n/\\ request(GWN,SDj,gwn_sdj_t2,T2')\n/\\ request(GWN,SDj,gwn_sdj_rgwn,Rgwn')\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ Snd(M10'.M11'.M12'.T3')\n/\\ witness(SDj,GWN,sdj_gwn_t3,T3')\n/\\ witness(SDj,GWN,sdj_gwn_rsdj,Rsdj')\n\nend role\n\nrole session (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key)\ndef=\nlocal S1, R1, S2, R2, S3, R3, S4, R4: channel (dy)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S4, R4)\nend role\n\nrole environment()\ndef=\nconst ui, ra, gwn, sdj, i: agent, h: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3, gwn_ui_t4, gwn_ui_tidinew: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\nsecrecy_of sr1, sr2, sr3\nauthentication_on ui_gwn_t1\nauthentication_on ui_gwn_rui\nauthentication_on gwn_sdj_t2\nauthentication_on gwn_sdj_rgwn\nauthentication_on sdj_gwn_t3\nauthentication_on sdj_gwn_rsdj\nauthentication_on gwn_ui_t4\nauthentication_on gwn_ui_tidinew\nend goal\nenvironment()", "```hlpsl\nrole user (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by Ui\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai, Sigmai': text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4: text, Gen, Rep: hash_func\nconst ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n0. State = 0 /\\ Rcv(start) =|>\n% Registration phase\nState' := 1\n/\\ Sigmai' := Gen(BIOi)\n/\\ Snd({IDi.PWi.Sigmai'.H(PWi.Sigmai'.IDi)}_SKuira)\n\n1. State = 1 /\\ Rcv({xor(H(IDi.Kgwnui),xor(H(PWi.Sigmai'.A'),R')).TIDi'}_SKuira)=|>\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()\n/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') \n/\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ Snd(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,ui_gwn_t1, T1')\n/\\ secret(Rui',ui_gwn_rui,Rui')\n\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3\n/\\ request(GWN,Ui,gwn_ui_t4, T4')\n/\\ request(GWN,Ui,gwn_ui_tidinew,TIDinew')\nend role\n\nrole registrationauthority (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RA\ndef=\nlocal State: nat, IDi, PWi, Sigmai, A', TIDi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDinew: text,\nM2, M3, T3, T4: text, Gen, Rep: hash_func\nconst sr3: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi'.PWi'.Sigmai''}_SKuira) =|>\nState' := 1 \n/\\ Kgwnui' := new()\n/\\ secret({Kgwnui',RA,GWN,Ui},sr3)\n/\\ secret({IDi'.PWi'.Sigmai''},sr3,{RA,GWN,Ui})\n/\\ A' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ Snd({A'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4: text, Gen, Rep: hash_func\nconst gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(TIDi'.M2'.M3'.T1') =|>\nState' := 1 \n/\\ M4' := H(IDi.Kgwnui)\n/\\ request(Ui,GWN,ui_gwn_t1,T1')\n/\\ request(Ui,GWN,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ Snd(M7'.M8'.T2')\n/\\ witness(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n/\\ witness(GWN,SDj,gwn_sdj_t2,T2')\n\n2. State = 1 /\\ Rcv(M10'.M11'.M12'.T3') =|>\nState' := 2 \n/\\ TIDi' := new() \n/\\ Rgwn' := new() \n/\\ Rui' := new() \n/\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ request(SDj,GWN,sdj_gwn_t3,T3')\n/\\ request(SDj,GWN,sdj_gwn_rsdj,Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ witness(GWN,Ui,gwn_ui_t4,T4')\n/\\ witness(GWN,Ui,gwn_ui_tidinew,TIDinew')\n\nend role\n\n\n\nrole smartdevice (Ui, RA, GWN, SDj: agent, H: hash_func,\nSKuira: symmetric_key, Snd, Rcv: channel(dy))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Sigmai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4: text, Gen, Rep: hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(M4')}_M6'.M8'.T2') =|>\nState' := 1 \n/\\ Kgwnsdj' := new()\n/\\ request(GWN,SDj,gwn_sdj_t2,T2')\n/\\ request(GWN,SDj,gwn_sdj_rgwn,Rgwn')\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ Snd(M10'.M11'.M12'.T3')\n/\\ witness(SDj,GWN,sdj_gwn_t3,T3')\n/\\ witness(SDj,GWN,sdj_gwn_rsdj,Rsdj')\n\nend role\n\nrole session (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key)\ndef=\nlocal S1, R1, S2, R2, S3, R3, S4, R4: channel (dy)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S4, R4)\nend role\n\nrole environment()\ndef=\nconst ui, ra, gwn, sdj, i: agent, h: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3, gwn_ui_t4, gwn_ui_tidinew: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\nsecrecy_of sr1, sr2, sr3\nauthentication_on ui_gwn_t1\nauthentication_on ui_gwn_rui\nauthentication_on gwn_sdj_t2\nauthentication_on gwn_sdj_rgwn\nauthentication_on sdj_gwn_t3\nauthentication_on sdj_gwn_rsdj\nauthentication_on gwn_ui_t4\nauthentication_on gwn_ui_tidinew\nend goal\nenvironment()\n```"]], "HLPSL-1/2019202008.hlpsl": [[true, "role user(\n    Gen,User,Gwn,Sensor : agent,\n    SNDU,RCVU : channel(dy),\n    H     : hash_func\n)\n\nplayed_by User def=\n\n    local\n        State : nat,\n        Tgwn,Tdel,Tchcku,Ti : nat,\n        PWD,UID,TE,PTC,VI,VI1,TC,P : text,\n        Kj,KEYij : text\n\n    const\n        u_g_te,u_g_ts1,u_g_ts4,u_g_k,g_u_te : protocol_id,\n        s_u_kj : protocol_id\n\n    init\n        State := 1\n\n    transition\n\n    %%User registration phase\n        0. State = 1 /\\ RCV(start) =|>\n           State':= 2 /\\ UID' := new() /\\ TE' := new()\n                      /\\ PWD' := new()\n                      /\\ VI' := H(UID'.H(PWD'))\n                      /\\ SND({PWD'}_Kgwnu)\n                      /\\ SND(TS1'.UID'.VI')\n                      /\\ secret({PWD'}, u_g_te, {User, Gwn})\n                      /\\ witness(User,Gwn,u_g_ts1,TS1')\n\n        1. State  = 2 /\\ RCV(TS4'.TE'.PTC') =|>\n           State':= 3 /\\ PWD' := new() /\\ TC' := xor(PTC',H(PWD'))\n                      /\\ UID' := new()\n                      /\\ TE' := new()\n                      /\\ TC' := H(Kgwnu.UID'.TE')\n                      /\\ P' := H(UID'.TE')\n                      /\\ DID' := xor(UID',H(H(inv(Kgwnu).P'.TE').TS4'))\n                      /\\ C' := H(xor(H(UID'.TS4'),TC'))\n                      /\\ PKS' := xor(K',H(TC'.TS4'.0))\n                      /\\ SND(DID'.C'.PKS'.TS4'.TE'.P')\n                      /\\ request(User,Gwn,u_g_ts4,TS4')\n                      /\\ witness(User,Gwn,u_g_k,K')\n\n    %%Receive session key from gateway through public channel\n        2. State = 3 /\\ RCV(H(xor(K', Kj'))) =|>\n           State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n    Gen,User,Gwn,Sensor    : agent,\n    SNDG,RCVG : channel(dy),\n    H     : hash_func\n%   Kgwnu, Kgwns    : public_key,\n)\n\nplayed_by Gwn def=\n\n    local\n        State : nat,\n        SKgwnu,SKgenu,SKgeng : symmetric_key,\n        Tdel,Tchckgwn,Ti,Tgwn    : nat,\n        PWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij    : text\n\n\n    const\n        g_u_te,u_g_ts1,s_g_ts2,g_s_ts3,u_g_ts4,g_s_ts5,s_g_ts6,s_g_kj : protocol_id\n\n    init\n        State := 0\n\n    transition\n\n    %% REceive request for registration from user\n\n        1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n           State':= 1 /\\ TE' := new()\n\n        2. State  = 1 /\\ RCV(TS1'.UID'.VI') =|>\n           State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n                      /\\ TE' := new()\n                      /\\ P' := H(UID'.TE')\n                      /\\ TC' := H(Kgwnu.P'.TE')\n                      /\\ PTC' := xor(TC', H(PWD'))\n                      /\\ secret({PWD'}, sp2, {Gwn})\n                      /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n                      /\\ SND(TS4'.TE'.PTC')\n                      /\\ request(User,Gwn,u_g_ts1,TS1') \n\n    %%Receive request for registration from Sensor\n        3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n           State':= 3 /\\ PWS' := new() /\\ secret({PWS'}, sp3, {Sensor, Gwn})\n                      /\\ VI3' := H(TS2'.H(PWS'))\n                      /\\ TC1' := H(Kgwns.SId')\n                      /\\ TS3' := new()\n                      /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n                      /\\ SND(TS3'.REG')\n                      /\\ secret({Kgwns}, sp4, {Gwn})\n                      /\\ witness(Gwn,Sensor,g_s_ts3,TS3')\n                      /\\ request(Sensor,Gwn,s_g_ts2,TS2')\n\n    %%Login and authentication phase\n        4. State  = 3 /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n           State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n                      /\\ TC' := H(Kgwnu.UID')\n                      /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n                      /\\ K' := xor(PKS', H(TC'.TS4'.0))\n                      /\\ TC1' := H(Kgwns.SId') \n                      /\\ TS5' := new()\n                      /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n                      /\\ Cgwn' := H(UID'.TC1'.TS5')\n                      /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n                      /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n                      /\\ witness(Gwn,Sensor,g_s_ts5,TS5')\n                      /\\ request(User,Gwn,u_g_ts4,TS4')\n                      /\\ witness(User,Gwn,u_g_k, K')\n\n    %% send session key via public channel to user and sensor\n        5. State  = 4 /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n           State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n                      /\\ KEYij' := H(xor(K',Kj'))\n                      /\\ SND(KEYij)\n                      /\\ request(Sensor,Gwn,s_g_ts6, TS6')\n                      /\\ witness(Sensor,Gwn,s_g_kj, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n    Gen,User,Gwn,Sensor    : agent,\n    SNDS,RCVS : channel(dy),\n    H     : hash_func\n)\n\nplayed_by Sensor def=\n\n    local\n        State : nat,\n        Tgwn,Tdel,Tchckj: nat,\n        PWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij     : text\n\n    const\n        sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj : protocol_id\n\n    init\n        State := 2\n\n    transition\n\n    %%Sensor Node registration\n        \n        1. State  = 2 /\\ RCV(start) =|> \n           State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n                      /\\ VI' := H(TS2'.H(PWS'))\n                      /\\ SND(SId'.TS2'.VI')\n                      /\\ secret({PWS'}, sp3, {Sensor, Gwn})\n                      /\\ witness(Sensor,Gwn,s_g_ts2,TS2')\n\n        2. State  = 3 /\\ RCV(TS3'.REG') =|>\n           State':= 4 /\\ PWS' := new() /\\ secret({PWS'}, sp4, {Sensor})\n                      /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n                      /\\ request(Gwn,Sensor,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n        3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n           State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n                      /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n                      /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n                      /\\ TS6' := new()\n                      /\\ Kj' := new()\n                      /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n                      /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n                      /\\ SND(SId'.TS6'.C1'.PKS1')\n                      /\\ witness(Sensor,User,s_u_ts6,TS6')\n                      /\\ witness(Sensor,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n        4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n           State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n                      /\\ witness(Sensor,Gwn,s_g_ts6, TS6')\n                      /\\ witness(Sensor,Gwn,s_g_kj, Kj')\nend role\n\n%%Session role\nrole session(\n    Gen,User,Gwn,Sensor : agent,\n    H:hash_func)\n\n    def=\n        \n    local \n        SNDU,RCVU,SNDG,RCVG,SNDS,RCVS : channel (dy)\n\n    composition\n        user(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n        /\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n        /\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n    \n    def=\n\n    const \n        a,b,c,d: agent,\n        u_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n        h:hash_func,\n        t1,t2,t3:text\n        %Kgwnu,Kgwns:public_key\n\n\n    intruder_knowledge = {a,b,c,t1,t2,t3}\n\n    composition\n        session(a,b,c,d,h)\n        /\\ session(a,i,c,d,h) \n        /\\ session(a,b,i,d,h)\n        /\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n    secrecy_of sp2, sp3, sp4\n\n    authentication_on u_g_ts1, g_u_te, u_g_ts4, u_g_k\n    authentication_on g_s_ts3, g_s_ts5, s_g_ts2, s_g_ts6, s_g_kj\n    authentication_on s_u_ts6, s_u_kj\nend goal\n\nenvironment()", "```hlpsl\nrole user(\n    Gen,User,Gwn,Sensor : agent,\n    SNDU,RCVU : channel(dy),\n    H     : hash_func\n)\n\nplayed_by User def=\n\n    local\n        State : nat,\n        Tgwn,Tdel,Tchcku,Ti : nat,\n        PWD,UID,TE,PTC,VI,VI1,TC,P : text,\n        Kj,KEYij : text\n\n    const\n        u_g_te,u_g_ts1,u_g_ts4,u_g_k,g_u_te : protocol_id,\n        s_u_kj : protocol_id\n\n    init\n        State := 1\n\n    transition\n\n    %%User registration phase\n        0. State = 1 /\\ RCV(start) =|>\n           State':= 2 /\\ UID' := new() /\\ TE' := new()\n                      /\\ PWD' := new()\n                      /\\ VI' := H(UID'.H(PWD'))\n                      /\\ SND({PWD'}_Kgwnu)\n                      /\\ SND(TS1'.UID'.VI')\n                      /\\ secret({PWD'}, u_g_te, {User, Gwn})\n                      /\\ witness(User,Gwn,u_g_ts1,TS1')\n\n        1. State  = 2 /\\ RCV(TS4'.TE'.PTC') =|>\n           State':= 3 /\\ PWD' := new() /\\ TC' := xor(PTC',H(PWD'))\n                      /\\ UID' := new()\n                      /\\ TE' := new()\n                      /\\ TC' := H(Kgwnu.UID'.TE')\n                      /\\ P' := H(UID'.TE')\n                      /\\ DID' := xor(UID',H(H(inv(Kgwnu).P'.TE').TS4'))\n                      /\\ C' := H(xor(H(UID'.TS4'),TC'))\n                      /\\ PKS' := xor(K',H(TC'.TS4'.0))\n                      /\\ SND(DID'.C'.PKS'.TS4'.TE'.P')\n                      /\\ request(User,Gwn,u_g_ts4,TS4')\n                      /\\ witness(User,Gwn,u_g_k,K')\n\n    %%Receive session key from gateway through public channel\n        2. State = 3 /\\ RCV(H(xor(K', Kj'))) =|>\n           State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n    Gen,User,Gwn,Sensor    : agent,\n    SNDG,RCVG : channel(dy),\n    H     : hash_func\n%   Kgwnu, Kgwns    : public_key,\n)\n\nplayed_by Gwn def=\n\n    local\n        State : nat,\n        SKgwnu,SKgenu,SKgeng : symmetric_key,\n        Tdel,Tchckgwn,Ti,Tgwn    : nat,\n        PWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij    : text\n\n\n    const\n        g_u_te,u_g_ts1,s_g_ts2,g_s_ts3,u_g_ts4,g_s_ts5,s_g_ts6,s_g_kj : protocol_id\n\n    init\n        State := 0\n\n    transition\n\n    %% REceive request for registration from user\n\n        1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n           State':= 1 /\\ TE' := new()\n\n        2. State  = 1 /\\ RCV(TS1'.UID'.VI') =|>\n           State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n                      /\\ TE' := new()\n                      /\\ P' := H(UID'.TE')\n                      /\\ TC' := H(Kgwnu.P'.TE')\n                      /\\ PTC' := xor(TC', H(PWD'))\n                      /\\ secret({PWD'}, sp2, {Gwn})\n                      /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n                      /\\ SND(TS4'.TE'.PTC')\n                      /\\ request(User,Gwn,u_g_ts1,TS1') \n\n    %%Receive request for registration from Sensor\n        3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n           State':= 3 /\\ PWS' := new() /\\ secret({PWS'}, sp3, {Sensor, Gwn})\n                      /\\ VI3' := H(TS2'.H(PWS'))\n                      /\\ TC1' := H(Kgwns.SId')\n                      /\\ TS3' := new()\n                      /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n                      /\\ SND(TS3'.REG')\n                      /\\ secret({Kgwns}, sp4, {Gwn})\n                      /\\ witness(Gwn,Sensor,g_s_ts3,TS3')\n                      /\\ request(Sensor,Gwn,s_g_ts2,TS2')\n\n    %%Login and authentication phase\n        4. State  = 3 /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n           State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n                      /\\ TC' := H(Kgwnu.UID')\n                      /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n                      /\\ K' := xor(PKS', H(TC'.TS4'.0))\n                      /\\ TC1' := H(Kgwns.SId') \n                      /\\ TS5' := new()\n                      /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n                      /\\ Cgwn' := H(UID'.TC1'.TS5')\n                      /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n                      /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n                      /\\ witness(Gwn,Sensor,g_s_ts5,TS5')\n                      /\\ request(User,Gwn,u_g_ts4,TS4')\n                      /\\ witness(User,Gwn,u_g_k, K')\n\n    %% send session key via public channel to user and sensor\n        5. State  = 4 /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n           State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n                      /\\ KEYij' := H(xor(K',Kj'))\n                      /\\ SND(KEYij)\n                      /\\ request(Sensor,Gwn,s_g_ts6, TS6')\n                      /\\ witness(Sensor,Gwn,s_g_kj, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n    Gen,User,Gwn,Sensor    : agent,\n    SNDS,RCVS : channel(dy),\n    H     : hash_func\n)\n\nplayed_by Sensor def=\n\n    local\n        State : nat,\n        Tgwn,Tdel,Tchckj: nat,\n        PWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij     : text\n\n    const\n        sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj : protocol_id\n\n    init\n        State := 2\n\n    transition\n\n    %%Sensor Node registration\n        \n        1. State  = 2 /\\ RCV(start) =|> \n           State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n                      /\\ VI' := H(TS2'.H(PWS'))\n                      /\\ SND(SId'.TS2'.VI')\n                      /\\ secret({PWS'}, sp3, {Sensor, Gwn})\n                      /\\ witness(Sensor,Gwn,s_g_ts2,TS2')\n\n        2. State  = 3 /\\ RCV(TS3'.REG') =|>\n           State':= 4 /\\ PWS' := new() /\\ secret({PWS'}, sp4, {Sensor})\n                      /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n                      /\\ request(Gwn,Sensor,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n        3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n           State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n                      /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n                      /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n                      /\\ TS6' := new()\n                      /\\ Kj' := new()\n                      /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n                      /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n                      /\\ SND(SId'.TS6'.C1'.PKS1')\n                      /\\ witness(Sensor,User,s_u_ts6,TS6')\n                      /\\ witness(Sensor,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n        4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n           State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n                      /\\ witness(Sensor,Gwn,s_g_ts6, TS6')\n                      /\\ witness(Sensor,Gwn,s_g_kj, Kj')\nend role\n\n%%Session role\nrole session(\n    Gen,User,Gwn,Sensor : agent,\n    H:hash_func)\n\n    def=\n        \n    local \n        SNDU,RCVU,SNDG,RCVG,SNDS,RCVS : channel (dy)\n\n    composition\n        user(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n        /\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n        /\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n    \n    def=\n\n    const \n        a,b,c,d: agent,\n        u_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n        h:hash_func,\n        t1,t2,t3:text\n        %Kgwnu,Kgwns:public_key\n\n\n    intruder_knowledge = {a,b,c,t1,t2,t3}\n\n    composition\n        session(a,b,c,d,h)\n        /\\ session(a,i,c,d,h) \n        /\\ session(a,b,i,d,h)\n        /\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n    secrecy_of sp2, sp3, sp4\n\n    authentication_on u_g_ts1, g_u_te, u_g_ts4, u_g_k\n    authentication_on g_s_ts3, g_s_ts5, s_g_ts2, s_g_ts6, s_g_kj\n    authentication_on s_u_ts6, s_u_kj\nend goal\n\nenvironment()\n```"]], "HLPSL-1/A_Secure_and_Efficient_Smart_Card-based_UCSSO_Scheme_Using_Extended_Chebyshev_Chaotic_Maps_for_Telemedicine_Systems.hlpsl": [[true, "role user (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(IDi',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ witness(U,S,g4,PWi') /\\ secret(PWi',g3,{U})\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,S,u_s_pi,Pi')\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ request(U,S,s_u_sj,Sj')\n\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',g5,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Aii,g6,{U,S})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(S,U,s_u_sj,Sj')\n/\\ request(S,U,u_s_pi,Pi')\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\nauthentication_on u_s_pi, s_u_sj\n\nend goal\n\n\nenvironment()", "```hlpsl\nrole user (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(IDi',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ witness(U,S,g4,PWi') /\\ secret(PWi',g3,{U})\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,S,u_s_pi,Pi')\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ request(U,S,s_u_sj,Sj')\n\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',g5,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Aii,g6,{U,S})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(S,U,s_u_sj,Sj')\n/\\ request(S,U,u_s_pi,Pi')\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (U, S: agent, Kus: symmetric_key, T: hash_func, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\nauthentication_on u_s_pi, s_u_sj\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/BRSKI.hlpsl": [[true, "role pledge(P, S, M, Kp, Km, Kca : agent,\n            KeyGen, PRF    : hash_func,\n            Sn      \t    : text, %serial Number \n            Issuer    \t    : text,\n            Aki\t            : text,  %authorityKeyIdentifier\n            Sln\t    \t    : text,  %subjectAltName\t\n            SND_P, RCV_P, SND_M, RCV_M   : channel (dy))\nplayed_by P def=\n  \n  local Np, Na, Nb, Pms, Nc, Nd, Pmsm, Mm, Sidm, Pam, Finishedm, Crdate, Rcrdate : text,\n        Kr \t        : public_key,\n        State           : nat,\n\tClientKm, ServerKm : hash(agent.text.text.hash(text.text.text)),\n\tAssr            : agent\n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 2\n\n  transition\n\n  2. State  = 2 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = 11 \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ secret(ClientKm,tls_registrarrmk,{M,R})\n\t/\\ secret(ServerKm,sec_np_rm,{R,M})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(Np,sec_np_pr,{P,R})\n\t/\\ request(M,P,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(M,P,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole registrar(P, S, M, Kr, Km, Kca : agent,\n\t       KeyGen, PRF    : hash_func,\n\t       SND_R, RCV_R, SND_M, RCV_M   : channel (dy))\nplayed_by R def=\n\n  local Np, Na, Nb, Pms, Nc, Nd, Pmsm, Mm, Sidm, Pam, Finishedm, Crdate, Rcrdate : text,\n        Kp \t        : public_key,\n\tState           : nat,\n\tClientKm, ServerKm : hash(agent.text.text.hash(text.text.text)),\n\tAssr            : agent\n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 0\n\n  transition\n\n  0. State  = 0 \n     /\\ RCV_R(P.Np'.{P.Kp}_inv(Kca)) =|> \n     State':= 2 \n\t/\\ Na' := new() \n\t/\\ Nb' := new() \n\t/\\ SND_R({{Assr.Np'.Sn.Crdate.{P.Kp}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na'.Nb')))\n     /\\ witness(R,P,auth_np,Np')\n\n  2. State  = 2 \n     /\\ RCV_R(R.Nc'.Sidm'.Pam') =|> \n     State':= 4 \n\t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     /\\ witness(R,M,auth_nc_nd,Nc'.Nd')\n\n  4. State  = 4 \n     /\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n     /\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n     /\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 6 \n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n     /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n     /\\ request(R,M,auth_nc_nd2,Nc.Nd)\n     /\\ secret(ServerKm,tls_registrarrmk,{R,M})\n\n  6. State  = 6 \n     /\\ RCV_R({{Assr'.Np'.Sn'.Rcrdate'.Issuer'.({Assr'.Np'.Sn'.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|> \n     State':= 8 \n\t/\\ SND_R({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n     /\\ request(R,P,auth_np1,Np')\n     /\\ request(R,M,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, S, M, Km, Kp, Kca : agent,\n\t   KeyGen, PRF    : hash_func,\n\t   Sn      \t    : text, %serial Number \n           Issuer    \t    : text,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t    : text,  %subjectAltName\t\n\t   SND_R, RCV_R, SND_M, RCV_M   : channel (dy))\nplayed_by M def=\n\n  local SeID, Assr , Np, Nc, Nd, Pmsm, Mm, Sidm, Pam : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,R,auth_nc_nd,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = 19 \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ witness(M,P,auth_np1,Np')\n\t/\\ witness(M,R,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n \nend role\n\n\nrole session(P, R, M        : agent,\n             Kp, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: hash_func,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: text,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local SP, RP, SR, SM, MR, RM  : channel (dy)\n\n  composition\n\tpledge(P,R,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,R,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,R,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,r,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\ngoal\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm %confidentiality of Np\t\n\tweak_secrecy_of tls_registrarrmk,tls_masarmk\n\tauthentication_on auth_np\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\tweak_authentication_on auth_na_nb2        \n\tauthentication_on auth_reg_certchain \n\tauthentication_on auth_reg_cert1 \t\n\tauthentication_on auth_nc_nd\t\n\tauthentication_on auth_nc_nd2\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()", "```hlpsl\nrole pledge(P, S, M, Kp, Km, Kca : agent,\n            KeyGen, PRF    : hash_func,\n            Sn      \t    : text, %serial Number \n            Issuer    \t    : text,\n            Aki\t            : text,  %authorityKeyIdentifier\n            Sln\t    \t    : text,  %subjectAltName\t\n            SND_P, RCV_P, SND_M, RCV_M   : channel (dy))\nplayed_by P def=\n  \n  local Np, Na, Nb, Pms, Nc, Nd, Pmsm, Mm, Sidm, Pam, Finishedm, Crdate, Rcrdate : text,\n        Kr \t        : public_key,\n        State           : nat,\n\tClientKm, ServerKm : hash(agent.text.text.hash(text.text.text)),\n\tAssr            : agent\n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 2\n\n  transition\n\n  2. State  = 2 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = 11 \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ secret(ClientKm,tls_registrarrmk,{M,R})\n\t/\\ secret(ServerKm,sec_np_rm,{R,M})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(Np,sec_np_pr,{P,R})\n\t/\\ request(M,P,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(M,P,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole registrar(P, S, M, Kr, Km, Kca : agent,\n\t       KeyGen, PRF    : hash_func,\n\t       SND_R, RCV_R, SND_M, RCV_M   : channel (dy))\nplayed_by R def=\n\n  local Np, Na, Nb, Pms, Nc, Nd, Pmsm, Mm, Sidm, Pam, Finishedm, Crdate, Rcrdate : text,\n        Kp \t        : public_key,\n\tState           : nat,\n\tClientKm, ServerKm : hash(agent.text.text.hash(text.text.text)),\n\tAssr            : agent\n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 0\n\n  transition\n\n  0. State  = 0 \n     /\\ RCV_R(P.Np'.{P.Kp}_inv(Kca)) =|> \n     State':= 2 \n\t/\\ Na' := new() \n\t/\\ Nb' := new() \n\t/\\ SND_R({{Assr.Np'.Sn.Crdate.{P.Kp}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na'.Nb')))\n     /\\ witness(R,P,auth_np,Np')\n\n  2. State  = 2 \n     /\\ RCV_R(R.Nc'.Sidm'.Pam') =|> \n     State':= 4 \n\t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     /\\ witness(R,M,auth_nc_nd,Nc'.Nd')\n\n  4. State  = 4 \n     /\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n     /\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n     /\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 6 \n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n     /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n     /\\ request(R,M,auth_nc_nd2,Nc.Nd)\n     /\\ secret(ServerKm,tls_registrarrmk,{R,M})\n\n  6. State  = 6 \n     /\\ RCV_R({{Assr'.Np'.Sn'.Rcrdate'.Issuer'.({Assr'.Np'.Sn'.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|> \n     State':= 8 \n\t/\\ SND_R({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n     /\\ request(R,P,auth_np1,Np')\n     /\\ request(R,M,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, S, M, Km, Kp, Kca : agent,\n\t   KeyGen, PRF    : hash_func,\n\t   Sn      \t    : text, %serial Number \n           Issuer    \t    : text,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t    : text,  %subjectAltName\t\n\t   SND_R, RCV_R, SND_M, RCV_M   : channel (dy))\nplayed_by M def=\n\n  local SeID, Assr , Np, Nc, Nd, Pmsm, Mm, Sidm, Pam : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,R,auth_nc_nd,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = 19 \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ witness(M,P,auth_np1,Np')\n\t/\\ witness(M,R,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n \nend role\n\n\nrole session(P, R, M        : agent,\n             Kp, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: hash_func,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: text,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local SP, RP, SR, SM, MR, RM  : channel (dy)\n\n  composition\n\tpledge(P,R,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,R,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,R,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,r,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\ngoal\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm %confidentiality of Np\t\n\tweak_secrecy_of tls_registrarrmk,tls_masarmk\n\tauthentication_on auth_np\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\tweak_authentication_on auth_na_nb2        \n\tauthentication_on auth_reg_certchain \n\tauthentication_on auth_reg_cert1 \t\n\tauthentication_on auth_nc_nd\t\n\tauthentication_on auth_nc_nd2\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/calp-v3.hlpsl": [[true, "%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), un lecteur de badge (LB)\n%% Deux cas de figures :  - une demande d'acc\u00e8s normal (1)\n%%\t\t\t  - une demande d'acc\u00e8s exceptionnel (2)\n%% B_S:\n%% Badgeuse -> Serveur : {IdBageuse, IdEmploye}_PKs\n%%Serveur -> Badgeuse : { ClefSession}_PKb\n%%Badgeuse -> Serveur: { Msg}_ClefSession\n%%Serveur -> Badgeuse: { ok.H(Msg)}_ClefSession\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n            TypeAction : protocol_id,            \n            PKb, PKs: public_key,\n\t    H: hash_func,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat,\n  Action: text,\n  ClefSession : symmetric_key\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(B,S,badgeuse_serveur,IdEmploye.IdBadgeuse)\n    1.  State=1 /\\ RCV({ClefSession'.IdServeur}_PKb) =|> \n\tState':=2 /\\ SND({TypeAction}_ClefSession') /\\ secret(ClefSession',sessionkey,{B,S})\n    2.  State=2 /\\ RCV({TypeAction.Action'}_ClefSession') =|>\n        State':=3 /\\ SND({ok.H(Action')}_ClefSession') /\\ request(B,S,serveur_badgeuse, Action')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n\t    TypeAction: protocol_id,\n\t    Action: text,\n\t    PKs,PKb: public_key,\n\t    H: hash_func,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat,\n  ClefSession: symmetric_key\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ ClefSession':=new() /\\ secret(ClefSession',sessionkey,{B,S}) /\\ SND({ClefSession'.IdServeur}_PKb) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(S,B,serveur_badgeuse,IdEmploye.IdBadgeuse)\n\n    2.  State=1 /\\ RCV({TypeAction}_ClefSession') =|>\n        State':=2 /\\ Action':=new() /\\ SND({TypeAction.Action'}_ClefSession') /\\ secret(Action',act,{B,S})\n\n    3.  State=2 /\\ RCV({ok.H(Action')}_ClefSession') =|>\n        State':=3 /\\ request(S,B,badgeuse_serveur, IdEmploye.IdBadgeuse)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse,IdServeur,TypeAction : protocol_id,H:hash_func,Action:text) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,PKb,PKs,H,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,Action,PKs,PKb,H,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const b,s,i : agent,\n\t  pks, pkb, pki: public_key,\n          h:hash_func,\n          idemploye, idbadgeuse, badgeuse_serveur,typeaction, serveur_badgeuse,act,sessionkey,idserveur: protocol_id,\n          idemployei:protocol_id,\n          action :text,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki),h,typeaction,idemployei}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemploye,idserveur, idbadgeuse,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemployei,idserveur, idbadgeuse,typeaction,h,action)\n\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sessionkey,act\t\n\tweak_authentication_on badgeuse_serveur\n\tauthentication_on serveur_badgeuse\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()", "```hlpsl\n%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), un lecteur de badge (LB)\n%% Deux cas de figures :  - une demande d'acc\u00e8s normal (1)\n%%\t\t\t  - une demande d'acc\u00e8s exceptionnel (2)\n%% B_S:\n%% Badgeuse -> Serveur : {IdBageuse, IdEmploye}_PKs\n%%Serveur -> Badgeuse : { ClefSession}_PKb\n%%Badgeuse -> Serveur: { Msg}_ClefSession\n%%Serveur -> Badgeuse: { ok.H(Msg)}_ClefSession\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n            TypeAction : protocol_id,            \n            PKb, PKs: public_key,\n\t    H: hash_func,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat,\n  Action: text,\n  ClefSession : symmetric_key\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(B,S,badgeuse_serveur,IdEmploye.IdBadgeuse)\n    1.  State=1 /\\ RCV({ClefSession'.IdServeur}_PKb) =|> \n\tState':=2 /\\ SND({TypeAction}_ClefSession') /\\ secret(ClefSession',sessionkey,{B,S})\n    2.  State=2 /\\ RCV({TypeAction.Action'}_ClefSession') =|>\n        State':=3 /\\ SND({ok.H(Action')}_ClefSession') /\\ request(B,S,serveur_badgeuse, Action')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n\t    TypeAction: protocol_id,\n\t    Action: text,\n\t    PKs,PKb: public_key,\n\t    H: hash_func,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat,\n  ClefSession: symmetric_key\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ ClefSession':=new() /\\ secret(ClefSession',sessionkey,{B,S}) /\\ SND({ClefSession'.IdServeur}_PKb) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(S,B,serveur_badgeuse,IdEmploye.IdBadgeuse)\n\n    2.  State=1 /\\ RCV({TypeAction}_ClefSession') =|>\n        State':=2 /\\ Action':=new() /\\ SND({TypeAction.Action'}_ClefSession') /\\ secret(Action',act,{B,S})\n\n    3.  State=2 /\\ RCV({ok.H(Action')}_ClefSession') =|>\n        State':=3 /\\ request(S,B,badgeuse_serveur, IdEmploye.IdBadgeuse)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse,IdServeur,TypeAction : protocol_id,H:hash_func,Action:text) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,PKb,PKs,H,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,Action,PKs,PKb,H,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const b,s,i : agent,\n\t  pks, pkb, pki: public_key,\n          h:hash_func,\n          idemploye, idbadgeuse, badgeuse_serveur,typeaction, serveur_badgeuse,act,sessionkey,idserveur: protocol_id,\n          idemployei:protocol_id,\n          action :text,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki),h,typeaction,idemployei}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemploye,idserveur, idbadgeuse,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemployei,idserveur, idbadgeuse,typeaction,h,action)\n\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sessionkey,act\t\n\tweak_authentication_on badgeuse_serveur\n\tauthentication_on serveur_badgeuse\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()\n```"]], "HLPSL-1/CHAPv2.hlpsl": [[true, "%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole chap_Init (A, B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, Rcv: channel(dy))\nplayed_by A\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)\n\n   2. State   = 1 /\\ Rcv(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.{Na'.Nb'.A}))\n\t          /\\ witness(A,B,nb,Nb') \n\t\t  /\\ secret(Kab,sec_kab1,{A,B})\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na')) =|> \n      State' := 3 /\\ request(A,B,na,Na') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH : hash_func,\n                Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab2 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')\n\t          /\\ witness(B,A,nb,Nb')\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.{Na'.Nb'.A'})) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))\n\t          /\\ request(B,A,na,Na') \n\t\t  /\\ secret(Kab,sec_kab2,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(i,b,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole chap_Init (A, B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, Rcv: channel(dy))\nplayed_by A\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)\n\n   2. State   = 1 /\\ Rcv(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.{Na'.Nb'.A}))\n\t          /\\ witness(A,B,nb,Nb') \n\t\t  /\\ secret(Kab,sec_kab1,{A,B})\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na')) =|> \n      State' := 3 /\\ request(A,B,na,Na') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH : hash_func,\n                Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab2 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')\n\t          /\\ witness(B,A,nb,Nb')\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.{Na'.Nb'.A'})) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))\n\t          /\\ request(B,A,na,Na') \n\t\t  /\\ secret(Kab,sec_kab2,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(i,b,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/chebyshev_final.hlpsl": [[true, "role user(\n\tUi, Sj, RC : agent, RPkeyi : symmetric_key, % used for registration phase(secure channel)\n\tRPkeyi : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Ui def=\n\n\tlocal\n\tState : nat,\n\tPubj : (agent.text.message) set,\t\n\tCi, EHIDi : message,\n\tVi : hash(text.text.hash(text).text),\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTsj, Tri : message,\n\tIDi, PWi, Bi, Ri, RNi, RN1: text,\n\tXj, Trisj, TRN1, RN2: text,\n\tRN3: text.text, \t\n\t\n\tBhi : hash(text)\n\n\tinit\n\tState := 0\n\t/\\ Pubj := {}\n\n\ttransition\n\t% Registration phase\n\t0. State = 0 /\\ Rcv(Sj.Xj'.Tsj')\n\t=|> State' := 2 /\\ Pubj' := cons(Sj.Xj'.Tsj', Pubj)\n\t/\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new()\n\t/\\ secret(IDi', idi, Ui) /\\ secret(PWi', pwi, Ui)\n\t/\\ secret(Bi', bi, Ui) % secrecy test\n\t/\\ Bhi' := BH(Bi') /\\ Ri' := new()\n\t/\\ Ci' := xor(Ri', Hash(IDi'.PWi'.Bhi'))\n\t/\\ Vi' := Hash(IDi'.PWi'.Bhi'.Ri')\n\t/\\ HIDi' := Hash(IDi'.Bhi')\n\t% check identity traceability\t\n\t/\\ request(Ui, RC, hidi, HIDi)\t\n\t/\\ Snd({HIDi'.Ci'.Vi'}_RPkeyi)\n\t\n\t2. State = 2 /\\ Rcv({UIDi'}_RPkeyi) /\\ in(Sj.Xj'.Tsj', Pubj)\n\t=|> State' := 4\n\t% login phase\n\t/\\ RNi' := new() /\\ RN1' := new()\n\t/\\ Tri' := exp(Xj, RNi')\n\t% encryption instead of multiplication\t\n\t/\\ EHIDi' := {HIDi}_exp(Tsj',RNi') \n\t% symmetric encryption instead of chebyshev polynomial\n\t/\\ TRN1' := {RN1'}_UIDi %T_{RN1'}(UIDi)\n\t%/\\ Snd(Sj.Tri'.EHIDi'.TRN1')\n\t/\\ Snd(Sj.Tri'.EHIDi')\n\t/\\ Snd(Sj.TRN1')\n\t% authentication property\n\t/\\ witness(Ui, Sj, rn1, RN1')\n\t/\\ RN3' := HIDi.RN1\n\t% authentication phase\n\n\t4. State = 4 /\\ Rcv({RN2'}_RN3)\n\t=|> State' := 6\n\t/\\ request(Ui, Sj, rn2, RN2')\n\nend role\n\nrole server(\n\tUi, Sj, RC: agent,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Sj def=\n\n\tlocal\n\tState : nat,\n\tRN1, RN2 : text,\t\n\tRN3 : text.text,\t\n\tKeyRing: (hash(hash(text.hash(text)).text).hash(hash(text.hash(text)).text)) set,\n\tPKeyj : text, %public key(x_j) of discrete chebyshev\n\tTPKeyj : message, %public key (T_{x_j}(x_j)) of discrete chebyshev\n\tSKeyj : text, %secret key\n\tHIDi : hash(text.hash(text)),\n\tUIDi, XIDi: hash(hash(text.hash(text)).text),\n\tTri, Ex1 : message\n\n\tinit\n\tState := 0\n\t/\\ KeyRing := {}\n\n\ttransition\n\t% Server Registration phase\n\t0. State = 0 /\\ Rcv(start)\n\t=|> State' := 1 /\\ Snd({Sj}_RPKeyj)\n\t\n\t1. State = 1 /\\ Rcv({Xj'.TXj'.SKeyj'}_RPKeyj)\n\t=|> State' := 2\n\t/\\ Snd(Sj.Xj'.TXj')\t% release public key\n\n\t% Registration phase\n\t2. State = 2 /\\ Rcv({HIDi'.UIDi'}_RPKeyj) /\\ not(in(XIDi'.UIDi', KeyRing))\n\t=|> State' := 3\n\t/\\ XIDi' := Hash(HIDi'.SKeyj)\n\t/\\ KeyRing' := cons(XIDi'.UIDi', KeyRing)\n\n\t% Login phase\n\t%3. State = 3 /\\ Rcv(Sj.Tri'.{HIDi'}_Ex1'.{RN1'}_UIDi')  /\\ Ex1' = exp(Tri',SKeyj) /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)\n\t3. State = 3 /\\ Rcv(Sj.Tri')  /\\ Ex1' = exp(Tri',SKeyj) /\\ Rcv(Sj.{HIDi'}_Ex1') /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)/\\ Rcv(Sj.{RN1'}_UIDi')\n\t=|> State' := 5\n\t/\\ RN2' := new()\n\t/\\ RN3' := HIDi.RN1\n\t/\\ Snd({RN2'}_RN3')\n\t/\\ request(Sj, Ui, rn1, RN1')\n\t/\\ witness(Sj, Ui, rn2, RN2')\t\n\t%/\\ request(Sj, Ui, rn2, RN2)\n\t\n\t\nend role\n\n% Registration Server\nrole regserver(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key, % secure channel w/ Ui\n\tRPKeyj : symmetric_key, % secure channel w/ Sj\n\tHash : hash_func,\n\tBH : hash_func, % biohash function\n\tSndi, Sndj, Rcvj : channel(dy))\nplayed_by RC def=\n\n\tlocal\n\tState : nat,\n\tUri  : text,\n\tCi : message,\n\tVi : hash(text.text.hash(text).text),\n\tXj, SKj : text,\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTXj : message\n\n\tinit\n\tState := 0\n\t\n\ttransition\n\t% Server Registration\n\t0. State = 0 /\\ Rcvj({Sj}_RPKeyj)\n\t=|> State' := 1\n\t/\\ Xj' := new()\n\t/\\ SKj' := new()\n\t/\\ TXj' := exp(Xj', SKj')\n\t%/\\ Sndi(Sj.Xj'.TXj')\n\t/\\ Sndj({Xj'.TXj'.SKj'}_RPKeyj)\n\t/\\ secret(SKj', skj, {Sj, RC}) \n\t\n\t% User Registration\t\n\t1. State = 1 /\\ Rcv({HIDi'.Ci'.Vi'}_RPKeyi)\n\t=|> State' := 1\n\t/\\ Uri' := new()\n\t/\\ UIDi' := Hash(HIDi'.Uri')\n\t/\\ Sndi({UIDi'}_RPKeyi)\n\t/\\ Sndj({HIDi'.UIDi'}_RPKeyj)\nend role\n\nrole session(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\t%Pubj : (agent.message.message) set,\n\t%PKeyj : text,\n\t%SKeyj : message, % secret key of server\n\tHash : hash_func,\n\tBH : hash_func)\ndef=\n\tlocal SI, SJ, SRI, SRJ, RR : channel(dy)\n\n\tcomposition\n\tuser(Ui, Sj, RC, RPKeyi, Hash, BH, SI, SJ)\n\t/\\ server(Ui, Sj, RC, RPKeyj, Hash, BH, RI, RJ)\n\t/\\ regserver(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH, SRI, SRJ, RR)\nend role\n\nrole environment()\ndef=\n\tconst\n\thidi, pwi, bi, rn1, rn2, skj : protocol_id,\n\ta1, a2, b, r : agent,\n\tkar1, kar2, kir, kbr : symmetric_key,\n\tskeyj : text,\n\tpkeyj : text,\n\th : hash_func,\n\tbh : hash_func\n\n\tintruder_knowledge = {a1, a2, b, r, kir, h, bh}\n\t\n\tcomposition\n\tsession(a1, b, r, kar1, kbr, h, bh)\n\t%/\\ session(a2, b, r, kar2, kbr, h, bh)\n\t%/\\ session(i, b, r, kir, kbr, h, bh)\nend role\n\ngoal\n\tsecret(IDi, idi, Ui) /\\ secret(PWi, pwi, Ui) /\\ secret(Bi, bi, Ui) /\\ secret(SKj, skj, {Sj, RC})\n\tauthentication_on rn1, rn2\nend goal\n\nenvironment()", "```hlpsl\nrole user(\n\tUi, Sj, RC : agent, RPkeyi : symmetric_key, % used for registration phase(secure channel)\n\tRPkeyi : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Ui def=\n\n\tlocal\n\tState : nat,\n\tPubj : (agent.text.message) set,\t\n\tCi, EHIDi : message,\n\tVi : hash(text.text.hash(text).text),\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTsj, Tri : message,\n\tIDi, PWi, Bi, Ri, RNi, RN1: text,\n\tXj, Trisj, TRN1, RN2: text,\n\tRN3: text.text, \t\n\t\n\tBhi : hash(text)\n\n\tinit\n\tState := 0\n\t/\\ Pubj := {}\n\n\ttransition\n\t% Registration phase\n\t0. State = 0 /\\ Rcv(Sj.Xj'.Tsj')\n\t=|> State' := 2 /\\ Pubj' := cons(Sj.Xj'.Tsj', Pubj)\n\t/\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new()\n\t/\\ secret(IDi', idi, Ui) /\\ secret(PWi', pwi, Ui)\n\t/\\ secret(Bi', bi, Ui) % secrecy test\n\t/\\ Bhi' := BH(Bi') /\\ Ri' := new()\n\t/\\ Ci' := xor(Ri', Hash(IDi'.PWi'.Bhi'))\n\t/\\ Vi' := Hash(IDi'.PWi'.Bhi'.Ri')\n\t/\\ HIDi' := Hash(IDi'.Bhi')\n\t% check identity traceability\t\n\t/\\ request(Ui, RC, hidi, HIDi)\t\n\t/\\ Snd({HIDi'.Ci'.Vi'}_RPkeyi)\n\t\n\t2. State = 2 /\\ Rcv({UIDi'}_RPkeyi) /\\ in(Sj.Xj'.Tsj', Pubj)\n\t=|> State' := 4\n\t% login phase\n\t/\\ RNi' := new() /\\ RN1' := new()\n\t/\\ Tri' := exp(Xj, RNi')\n\t% encryption instead of multiplication\t\n\t/\\ EHIDi' := {HIDi}_exp(Tsj',RNi') \n\t% symmetric encryption instead of chebyshev polynomial\n\t/\\ TRN1' := {RN1'}_UIDi %T_{RN1'}(UIDi)\n\t%/\\ Snd(Sj.Tri'.EHIDi'.TRN1')\n\t/\\ Snd(Sj.Tri'.EHIDi')\n\t/\\ Snd(Sj.TRN1')\n\t% authentication property\n\t/\\ witness(Ui, Sj, rn1, RN1')\n\t/\\ RN3' := HIDi.RN1\n\t% authentication phase\n\n\t4. State = 4 /\\ Rcv({RN2'}_RN3)\n\t=|> State' := 6\n\t/\\ request(Ui, Sj, rn2, RN2')\n\nend role\n\nrole server(\n\tUi, Sj, RC: agent,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Sj def=\n\n\tlocal\n\tState : nat,\n\tRN1, RN2 : text,\t\n\tRN3 : text.text,\t\n\tKeyRing: (hash(hash(text.hash(text)).text).hash(hash(text.hash(text)).text)) set,\n\tPKeyj : text, %public key(x_j) of discrete chebyshev\n\tTPKeyj : message, %public key (T_{x_j}(x_j)) of discrete chebyshev\n\tSKeyj : text, %secret key\n\tHIDi : hash(text.hash(text)),\n\tUIDi, XIDi: hash(hash(text.hash(text)).text),\n\tTri, Ex1 : message\n\n\tinit\n\tState := 0\n\t/\\ KeyRing := {}\n\n\ttransition\n\t% Server Registration phase\n\t0. State = 0 /\\ Rcv(start)\n\t=|> State' := 1 /\\ Snd({Sj}_RPKeyj)\n\t\n\t1. State = 1 /\\ Rcv({Xj'.TXj'.SKeyj'}_RPKeyj)\n\t=|> State' := 2\n\t/\\ Snd(Sj.Xj'.TXj')\t% release public key\n\n\t% Registration phase\n\t2. State = 2 /\\ Rcv({HIDi'.UIDi'}_RPKeyj) /\\ not(in(XIDi'.UIDi', KeyRing))\n\t=|> State' := 3\n\t/\\ XIDi' := Hash(HIDi'.SKeyj)\n\t/\\ KeyRing' := cons(XIDi'.UIDi', KeyRing)\n\n\t% Login phase\n\t%3. State = 3 /\\ Rcv(Sj.Tri'.{HIDi'}_Ex1'.{RN1'}_UIDi')  /\\ Ex1' = exp(Tri',SKeyj) /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)\n\t3. State = 3 /\\ Rcv(Sj.Tri')  /\\ Ex1' = exp(Tri',SKeyj) /\\ Rcv(Sj.{HIDi'}_Ex1') /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)/\\ Rcv(Sj.{RN1'}_UIDi')\n\t=|> State' := 5\n\t/\\ RN2' := new()\n\t/\\ RN3' := HIDi.RN1\n\t/\\ Snd({RN2'}_RN3')\n\t/\\ request(Sj, Ui, rn1, RN1')\n\t/\\ witness(Sj, Ui, rn2, RN2')\t\n\t%/\\ request(Sj, Ui, rn2, RN2)\n\t\n\t\nend role\n\n% Registration Server\nrole regserver(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key, % secure channel w/ Ui\n\tRPKeyj : symmetric_key, % secure channel w/ Sj\n\tHash : hash_func,\n\tBH : hash_func, % biohash function\n\tSndi, Sndj, Rcvj : channel(dy))\nplayed_by RC def=\n\n\tlocal\n\tState : nat,\n\tUri  : text,\n\tCi : message,\n\tVi : hash(text.text.hash(text).text),\n\tXj, SKj : text,\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTXj : message\n\n\tinit\n\tState := 0\n\t\n\ttransition\n\t% Server Registration\n\t0. State = 0 /\\ Rcvj({Sj}_RPKeyj)\n\t=|> State' := 1\n\t/\\ Xj' := new()\n\t/\\ SKj' := new()\n\t/\\ TXj' := exp(Xj', SKj')\n\t%/\\ Sndi(Sj.Xj'.TXj')\n\t/\\ Sndj({Xj'.TXj'.SKj'}_RPKeyj)\n\t/\\ secret(SKj', skj, {Sj, RC}) \n\t\n\t% User Registration\t\n\t1. State = 1 /\\ Rcv({HIDi'.Ci'.Vi'}_RPKeyi)\n\t=|> State' := 1\n\t/\\ Uri' := new()\n\t/\\ UIDi' := Hash(HIDi'.Uri')\n\t/\\ Sndi({UIDi'}_RPKeyi)\n\t/\\ Sndj({HIDi'.UIDi'}_RPKeyj)\nend role\n\nrole session(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\t%Pubj : (agent.message.message) set,\n\t%PKeyj : text,\n\t%SKeyj : message, % secret key of server\n\tHash : hash_func,\n\tBH : hash_func)\ndef=\n\tlocal SI, SJ, SRI, SRJ, RR : channel(dy)\n\n\tcomposition\n\tuser(Ui, Sj, RC, RPKeyi, Hash, BH, SI, SJ)\n\t/\\ server(Ui, Sj, RC, RPKeyj, Hash, BH, RI, RJ)\n\t/\\ regserver(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH, SRI, SRJ, RR)\nend role\n\nrole environment()\ndef=\n\tconst\n\thidi, pwi, bi, rn1, rn2, skj : protocol_id,\n\ta1, a2, b, r : agent,\n\tkar1, kar2, kir, kbr : symmetric_key,\n\tskeyj : text,\n\tpkeyj : text,\n\th : hash_func,\n\tbh : hash_func\n\n\tintruder_knowledge = {a1, a2, b, r, kir, h, bh}\n\t\n\tcomposition\n\tsession(a1, b, r, kar1, kbr, h, bh)\n\t%/\\ session(a2, b, r, kar2, kbr, h, bh)\n\t%/\\ session(i, b, r, kir, kbr, h, bh)\nend role\n\ngoal\n\tsecret(IDi, idi, Ui) /\\ secret(PWi, pwi, Ui) /\\ secret(Bi, bi, Ui) /\\ secret(SKj, skj, {Sj, RC})\n\tauthentication_on rn1, rn2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/CRAM-MD5.hlpsl": [[true, "%% PROTOCOL: CRAM-MD5 Challenge-Response Authentication Mechanism\n%% PURPOSE:\n%% CRAM-MD5 is intended to provide an authentication extension to\n%% IMAP4 that neither transfers passwords in cleartext nor requires\n%% significant security infrastructure in order to function.  To this end,\n%% the protocol assumes a shared password (which we model, without loss of\n%% generality, as a shared cryptographic key) between the IMAP4 server\n%% (called S in our model) and each client A.  Only a hash value of\n%% the shared password is ever sent over the network, thus precluding\n%% plaintext transmission.\n%% \n%% REFERENCE:\n%% RFC 2195~\\cite{RFC2195}\n%% MODELER:\n%% Paul Hankes Drielsma, ETH Z\\\"urich, July 2004\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% Alice-Bob Notation:\n%%  1. A -> S: A\n%%  2. S -> A: Ns.T.S\n%%  3. A -> S: F(SK.T)\n%%  where\n%%      Ns is a nonce generated by the server;\n%%      T is a timestamp (currently abstracted with a nonce)\n%%      SK is the shared key between A and S\n%%      F is a cryptographic hash function (MD5 in practice, but this is\n%%       unimportant for our purposes).  The use of F\n%%       is intended to ensure that only a digest of the shared\n%%       key is transmitted, with T assuring freshness of the \n%%       generated hash value.\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item We abstract away from the timestamp \\verb|T| using a \n%% standard nonce.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%% NOTES:\n%% RFC 2195~\\cite{RFC2195} states that the first message from the \n%% server S begins with a \"presumptively arbitrary string of random \n%% digits\"; that is, a nonce.  Unspecified, however, is what the \n%% client should do with this nonce.  It does not appear in subsequent\n%% protocol message.  We therefore presume it is intended to\n%% ensure replay protection, but our HLPSL specification at present does not \n%% explicitly model that the client should maintain a list of nonces\n%% previously received from the server.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole client(A: agent, S: agent,\n\t    SK: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local  State : nat, \n         T, Ns : text\n\n  const  sec_SK : protocol_id\n\n  init   State := 0\n\n  transition \n\n  1. State = 0   /\\ RCV(start) \n     =|>\n     State' := 1 /\\ SND(A)\n\n  2. State = 1   /\\ RCV(Ns'.T'.S)\n     =|>\n     State' := 2 /\\ SND(F(SK.A.S.T')) \n                 /\\ witness(A,S,auth,F(SK.A.S.T')) \n                 /\\ secret(SK,sec_SK,{A,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole server(S: agent,\n\t    K: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        A     : agent,\n        T, Ns : text,\n        Auth  : hash(hash(agent.agent).text)\n\n  init  State := 0\n\n  transition \n   1. State = 0   /\\ RCV(A') \n      =|>\n      State' := 1 /\\ Ns' := new()\n                  /\\ T' := new()\n                  /\\ SND(Ns'.T'.S)\n\n   2. State = 1   /\\ RCV(F(K(A'.S).T)) \n      =|>\n      State' := 2 /\\ Auth' := F(K(A'.S).T) \n                  /\\ request(S,A',auth,F(K(A'.S).T))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, S: agent,\n             K, F: hash_func)\ndef=\n\n  local SK: hash(agent.agent),\n        SNDA, SNDS, RCVA, RCVS: channel (dy)\n\n  init SK := K(A.S)\n\n  composition\n       client(A,S,SK,F,SNDA,RCVA)\n    /\\ server(S,K,F,SNDS,RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n const a, s, i : agent,\n       k, f : hash_func,\n       auth : protocol_id\n\n intruder_knowledge = {a,s,i,f}\n\n composition\n      session(a,s,k,f)\n   /\\ session(i,s,k,f)\n   /\\ session(a,s,k,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_SK  % Addresses G12\n\n  %Server authenticates Client on auth\n  authentication_on auth  % Addresses G1, G2, G3\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: CRAM-MD5 Challenge-Response Authentication Mechanism\n%% PURPOSE:\n%% CRAM-MD5 is intended to provide an authentication extension to\n%% IMAP4 that neither transfers passwords in cleartext nor requires\n%% significant security infrastructure in order to function.  To this end,\n%% the protocol assumes a shared password (which we model, without loss of\n%% generality, as a shared cryptographic key) between the IMAP4 server\n%% (called S in our model) and each client A.  Only a hash value of\n%% the shared password is ever sent over the network, thus precluding\n%% plaintext transmission.\n%% \n%% REFERENCE:\n%% RFC 2195~\\cite{RFC2195}\n%% MODELER:\n%% Paul Hankes Drielsma, ETH Z\\\"urich, July 2004\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% Alice-Bob Notation:\n%%  1. A -> S: A\n%%  2. S -> A: Ns.T.S\n%%  3. A -> S: F(SK.T)\n%%  where\n%%      Ns is a nonce generated by the server;\n%%      T is a timestamp (currently abstracted with a nonce)\n%%      SK is the shared key between A and S\n%%      F is a cryptographic hash function (MD5 in practice, but this is\n%%       unimportant for our purposes).  The use of F\n%%       is intended to ensure that only a digest of the shared\n%%       key is transmitted, with T assuring freshness of the \n%%       generated hash value.\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item We abstract away from the timestamp \\verb|T| using a \n%% standard nonce.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%% NOTES:\n%% RFC 2195~\\cite{RFC2195} states that the first message from the \n%% server S begins with a \"presumptively arbitrary string of random \n%% digits\"; that is, a nonce.  Unspecified, however, is what the \n%% client should do with this nonce.  It does not appear in subsequent\n%% protocol message.  We therefore presume it is intended to\n%% ensure replay protection, but our HLPSL specification at present does not \n%% explicitly model that the client should maintain a list of nonces\n%% previously received from the server.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole client(A: agent, S: agent,\n\t    SK: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local  State : nat, \n         T, Ns : text\n\n  const  sec_SK : protocol_id\n\n  init   State := 0\n\n  transition \n\n  1. State = 0   /\\ RCV(start) \n     =|>\n     State' := 1 /\\ SND(A)\n\n  2. State = 1   /\\ RCV(Ns'.T'.S)\n     =|>\n     State' := 2 /\\ SND(F(SK.A.S.T')) \n                 /\\ witness(A,S,auth,F(SK.A.S.T')) \n                 /\\ secret(SK,sec_SK,{A,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole server(S: agent,\n\t    K: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        A     : agent,\n        T, Ns : text,\n        Auth  : hash(hash(agent.agent).text)\n\n  init  State := 0\n\n  transition \n   1. State = 0   /\\ RCV(A') \n      =|>\n      State' := 1 /\\ Ns' := new()\n                  /\\ T' := new()\n                  /\\ SND(Ns'.T'.S)\n\n   2. State = 1   /\\ RCV(F(K(A'.S).T)) \n      =|>\n      State' := 2 /\\ Auth' := F(K(A'.S).T) \n                  /\\ request(S,A',auth,F(K(A'.S).T))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, S: agent,\n             K, F: hash_func)\ndef=\n\n  local SK: hash(agent.agent),\n        SNDA, SNDS, RCVA, RCVS: channel (dy)\n\n  init SK := K(A.S)\n\n  composition\n       client(A,S,SK,F,SNDA,RCVA)\n    /\\ server(S,K,F,SNDS,RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n const a, s, i : agent,\n       k, f : hash_func,\n       auth : protocol_id\n\n intruder_knowledge = {a,s,i,f}\n\n composition\n      session(a,s,k,f)\n   /\\ session(i,s,k,f)\n   /\\ session(a,s,k,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_SK  % Addresses G12\n\n  %Server authenticates Client on auth\n  authentication_on auth  % Addresses G1, G2, G3\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/crocus.hlpsl": [[true, "role alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tNa,Nb,Ra,Rb,T1,T2,T3,T4,H1,H2,H4,H3,H5,H6,REPLY,REQ:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 \n/\\ H1' := new() \n/\\ Na' := new()\n/\\ T1' := new()\n/\\ S1' := {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n/\\ SND(H1'.Na'.T1'.S1') /\\ witness(A,B,aut1,H1'.Na'.T1'.S1')\n\n2. State = 1 /\\ RCV(H2'.Nb'.T2'.S2') /\\ S2' = {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n=|> State' := 2 \n/\\ Ka' := new()\n/\\ H3':= new()\n/\\ S3' := {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n/\\ SND(H3'.KEX(Ka').S3') /\\ request(A,B,aut2,H3'.KEX(Ka').S3') /\\ witness(A,B,aut3,H3'.KEX(Ka').S3')\n\n3. State = 2 /\\ RCV(H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) \n=|> State' := 3 \n/\\ H5' := new()\n/\\ T4' := new()\n/\\ REQ' := new()\n/\\ ET2' := {T4'.REQ'}_KDF(ECP(Ka,KEX(Kb')))\n/\\ S5' := {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ')}_inv(Ya)\n/\\ SND(H5'.ET2'.S5') /\\ request(A,B,aut4,H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) /\\ witness(A,B,aut5,H5'.ET2'.S5')\n/\\ secret(REQ',sec1,A)\n/\\ secret(REQ',sec1,B)\n\n4. State = 3 /\\ RCV(H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb))\n=|>\nState' := 4 /\\ witness(A,B,aut6,H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)) /\\ secret(REPLY,sec2,A) /\\ secret(REPLY,sec2,B) /\\ request(A,B,aut7,REPLY)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tNa,Ra,SID,Nb,Rb,T2,T3,H1,H2,H3,H4,H5,H6,T4,REQ,REPLY,T1,TT:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6,CK:message,\n\tState:nat\ninit State := 0\ntransition\n\n1. State =0 /\\ RCV(H1'.Na'.T1'.S1') /\\ S1' = {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n=|> State' := 1\n/\\ H2' := new() \n/\\ Nb' := new()\n/\\ T2' := new()\n/\\ S2' := {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n/\\ SND(H2'.Nb'.T2'.S2') /\\ request(B,A,aut1,H1'.Na'.T1'.S1') /\\ witness(B,A,aut2,H2'.Nb'.T2'.S2')\n\n2. State = 1 /\\ RCV(H3'.KEX(Ka').S3') /\\ S3' = {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n=|> State' := 2 \n/\\ H4' :=new() \n/\\ Kb' := new()\n/\\ T3' := new()\n/\\ S4' := {Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)\n/\\ ET1' := {T3'}_KDF(ECP(Kb'.KEX(Ka')).A.B)\n/\\ SND(H4'.KEX(Kb').ET1'.S4') /\\ request(B,A,aut3,H3'.KEX(Ka').S3') /\\ witness(B,A,aut4,H4'.KEX(Kb').ET1'.S4')\n\n3. State = 2 /\\ RCV(H5'.ET2'.S5') /\\ S5' = {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3'.T4'.REQ')}_inv(Ya)\n%%%%{T4'.REQ'}_KDF(ECP(Ka,KEX(Kb)) \n=|> State':=3 \n/\\ REPLY' := new()\n/\\ H6' := new()\n/\\ ET3' := {REPLY'}_KDF(ECP(Kb,KEX(Ka)))\n/\\ S6' := {Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)\n/\\ SND(H6'.ET3'.S6') \n/\\ secret(REPLY',sec2,B)\n/\\ secret(REPLY',sec2,A)\n/\\ secret(REQ',sec1,A)\n/\\ secret(REQ',sec1,B)\n/\\ request(B,A,aut6,H6'.ET3'.S6') /\\ witness(B,A,aut5,REQ')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session ( A,B:agent,Ya,Yb:public_key,Sign,KDF,ECP,KEX:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SA,RA) \n/\\ bob(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nsec1,sec2,aut1,aut2,aut3,aut4,aut5,aut6,aut7: protocol_id,\nya,yb:public_key,\nsign:hash_func,\nkdf:hash_func,\necp:hash_func,\nkex:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,ecp,kex}\n\ncomposition\n\nsession(a,b,ya,yb,sign,kdf,ecp,kex)\n\nend role\n\ngoal\n\tstrong authentication_on aut1\n\tauthentication_on aut2\n\tauthentication_on aut3\n\tauthentication_on aut4\n\tstrong authentication_on aut5\n\tstrong authentication_on aut6\n\tsecrecy_of sec1\n\tsecrecy_of sec2\nend goal\n\n\nenvironment()", "```hlpsl\nrole alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tNa,Nb,Ra,Rb,T1,T2,T3,T4,H1,H2,H4,H3,H5,H6,REPLY,REQ:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 \n/\\ H1' := new() \n/\\ Na' := new()\n/\\ T1' := new()\n/\\ S1' := {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n/\\ SND(H1'.Na'.T1'.S1') /\\ witness(A,B,aut1,H1'.Na'.T1'.S1')\n\n2. State = 1 /\\ RCV(H2'.Nb'.T2'.S2') /\\ S2' = {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n=|> State' := 2 \n/\\ Ka' := new()\n/\\ H3':= new()\n/\\ S3' := {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n/\\ SND(H3'.KEX(Ka').S3') /\\ request(A,B,aut2,H3'.KEX(Ka').S3') /\\ witness(A,B,aut3,H3'.KEX(Ka').S3')\n\n3. State = 2 /\\ RCV(H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) \n=|> State' := 3 \n/\\ H5' := new()\n/\\ T4' := new()\n/\\ REQ' := new()\n/\\ ET2' := {T4'.REQ'}_KDF(ECP(Ka,KEX(Kb')))\n/\\ S5' := {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ')}_inv(Ya)\n/\\ SND(H5'.ET2'.S5') /\\ request(A,B,aut4,H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) /\\ witness(A,B,aut5,H5'.ET2'.S5')\n/\\ secret(REQ',sec1,A)\n/\\ secret(REQ',sec1,B)\n\n4. State = 3 /\\ RCV(H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb))\n=|>\nState' := 4 /\\ witness(A,B,aut6,H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)) /\\ secret(REPLY,sec2,A) /\\ secret(REPLY,sec2,B) /\\ request(A,B,aut7,REPLY)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tNa,Ra,SID,Nb,Rb,T2,T3,H1,H2,H3,H4,H5,H6,T4,REQ,REPLY,T1,TT:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6,CK:message,\n\tState:nat\ninit State := 0\ntransition\n\n1. State =0 /\\ RCV(H1'.Na'.T1'.S1') /\\ S1' = {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n=|> State' := 1\n/\\ H2' := new() \n/\\ Nb' := new()\n/\\ T2' := new()\n/\\ S2' := {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n/\\ SND(H2'.Nb'.T2'.S2') /\\ request(B,A,aut1,H1'.Na'.T1'.S1') /\\ witness(B,A,aut2,H2'.Nb'.T2'.S2')\n\n2. State = 1 /\\ RCV(H3'.KEX(Ka').S3') /\\ S3' = {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n=|> State' := 2 \n/\\ H4' :=new() \n/\\ Kb' := new()\n/\\ T3' := new()\n/\\ S4' := {Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)\n/\\ ET1' := {T3'}_KDF(ECP(Kb'.KEX(Ka')).A.B)\n/\\ SND(H4'.KEX(Kb').ET1'.S4') /\\ request(B,A,aut3,H3'.KEX(Ka').S3') /\\ witness(B,A,aut4,H4'.KEX(Kb').ET1'.S4')\n\n3. State = 2 /\\ RCV(H5'.ET2'.S5') /\\ S5' = {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3'.T4'.REQ')}_inv(Ya)\n%%%%{T4'.REQ'}_KDF(ECP(Ka,KEX(Kb)) \n=|> State':=3 \n/\\ REPLY' := new()\n/\\ H6' := new()\n/\\ ET3' := {REPLY'}_KDF(ECP(Kb,KEX(Ka)))\n/\\ S6' := {Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)\n/\\ SND(H6'.ET3'.S6') \n/\\ secret(REPLY',sec2,B)\n/\\ secret(REPLY',sec2,A)\n/\\ secret(REQ',sec1,A)\n/\\ secret(REQ',sec1,B)\n/\\ request(B,A,aut6,H6'.ET3'.S6') /\\ witness(B,A,aut5,REQ')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session ( A,B:agent,Ya,Yb:public_key,Sign,KDF,ECP,KEX:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SA,RA) \n/\\ bob(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nsec1,sec2,aut1,aut2,aut3,aut4,aut5,aut6,aut7: protocol_id,\nya,yb:public_key,\nsign:hash_func,\nkdf:hash_func,\necp:hash_func,\nkex:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,ecp,kex}\n\ncomposition\n\nsession(a,b,ya,yb,sign,kdf,ecp,kex)\n\nend role\n\ngoal\n\tstrong authentication_on aut1\n\tauthentication_on aut2\n\tauthentication_on aut3\n\tauthentication_on aut4\n\tstrong authentication_on aut5\n\tstrong authentication_on aut6\n\tsecrecy_of sec1\n\tsecrecy_of sec2\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/device6g.hlpsl": [[true, "role device (DEV:agent, KM:agent, \n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by DEV\ndef=\nlocal Nonce: nat,  \nNonce_msg, HM, HM1, HNWS, HND:message\n\n\tconst\n\tsec_1, sec_2, auth_dev_km_nonce: protocol_id\n\n\tinit State:=0\n\n\ttransition\n\n\t1. State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ D':=new()\n\t/\\ Nonce':=new()\n\t/\\ HNWS':=H(NWS)\n\t/\\ HND':=H4B(ND)\n\t/\\ HM':=H4B(NWS.ND.Nonce'.D')\n\t/\\ SND(HNWS'.HND'.Nonce'.HM'.D')\n\t/\\ secret(DEV,sec_1,{DEV,KM})\n\t/\\ secret(ND,sec_2,{DEV,KM})\n\t%%/\\ witness(DEV,KM,auth_dev_km_hm1,HM')\n\nend role\n\n\nrole keymanager (KM,DEV:agent,\n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by KM\n\ndef=\nlocal State:nat,\nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\n\tsec_1, sec_2, auth_dev_km_nonce: protocol_id\n\n\tinit State:=0\n\ttransition\n\n\t1. State=0 /\\ RCV(HNWS'.HND'.Nonce'.HM'.D') =|>\n\tState':=1 /\\ HM1':=H4B(NWS.ND.Nonce'.D')\n\t%%/\\ request(DEV,KM,auth_dev_km_hm1,HM1')\n\nend role\n\n\nrole session(DEV:agent, KM:agent,\n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text)\n\ndef=\nlocal SND1,RCV1,SND2,RCV2:channel(dy)\n\tcomposition\n\tdevice (DEV,KM,H,H4B,D,ND,NWS,SND1,RCV1)\n\t/\\ keymanager (KM,DEV,H,H4B,D,ND,NWS,SND2,RCV2)\n\nend role\n\nrole environment()\ndef=\n\tconst\n\tdev, km: agent,\n\th,h4b:hash_func,\n\td,nd,nws:text,\n\tnonce, hm, hm1, hnws, hnd : message,\n\tsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\n\tintruder_knowledge = {dev, km, h, h4b, d}\n\n\tcomposition\n\t\tsession(dev,km,h,h4b,d,nd,nws)\n\t\t/\\ session(km,dev,h,h4b,d,nd,nws) \n\t\t\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\t%%authentication_on auth_dev_km_hm1\nend goal\nenvironment()", "```hlpsl\nrole device (DEV:agent, KM:agent, \n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by DEV\ndef=\nlocal Nonce: nat,  \nNonce_msg, HM, HM1, HNWS, HND:message\n\n\tconst\n\tsec_1, sec_2, auth_dev_km_nonce: protocol_id\n\n\tinit State:=0\n\n\ttransition\n\n\t1. State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ D':=new()\n\t/\\ Nonce':=new()\n\t/\\ HNWS':=H(NWS)\n\t/\\ HND':=H4B(ND)\n\t/\\ HM':=H4B(NWS.ND.Nonce'.D')\n\t/\\ SND(HNWS'.HND'.Nonce'.HM'.D')\n\t/\\ secret(DEV,sec_1,{DEV,KM})\n\t/\\ secret(ND,sec_2,{DEV,KM})\n\t%%/\\ witness(DEV,KM,auth_dev_km_hm1,HM')\n\nend role\n\n\nrole keymanager (KM,DEV:agent,\n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by KM\n\ndef=\nlocal State:nat,\nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\n\tsec_1, sec_2, auth_dev_km_nonce: protocol_id\n\n\tinit State:=0\n\ttransition\n\n\t1. State=0 /\\ RCV(HNWS'.HND'.Nonce'.HM'.D') =|>\n\tState':=1 /\\ HM1':=H4B(NWS.ND.Nonce'.D')\n\t%%/\\ request(DEV,KM,auth_dev_km_hm1,HM1')\n\nend role\n\n\nrole session(DEV:agent, KM:agent,\n\tH:hash_func, H4B:hash_func,\n\tD,ND,NWS:text)\n\ndef=\nlocal SND1,RCV1,SND2,RCV2:channel(dy)\n\tcomposition\n\tdevice (DEV,KM,H,H4B,D,ND,NWS,SND1,RCV1)\n\t/\\ keymanager (KM,DEV,H,H4B,D,ND,NWS,SND2,RCV2)\n\nend role\n\nrole environment()\ndef=\n\tconst\n\tdev, km: agent,\n\th,h4b:hash_func,\n\td,nd,nws:text,\n\tnonce, hm, hm1, hnws, hnd : message,\n\tsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\n\tintruder_knowledge = {dev, km, h, h4b, d}\n\n\tcomposition\n\t\tsession(dev,km,h,h4b,d,nd,nws)\n\t\t/\\ session(km,dev,h,h4b,d,nd,nws) \n\t\t\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\t%%authentication_on auth_dev_km_hm1\nend goal\nenvironment()\n```\nThe modifications made include:\n\n1. Replacing `____(ROLE_1)____` with `role`.\n2. Filling the parameters and local variables according to the protocol description.\n3. Replacing `____(STATE_0)____` with `0`.\n4. Replacing `____(EVENT_1)____` and `____(EVENT_3)____` with `secret` to match the secrecy goals.\n5. Replacing `____(EVENT_0)____` and `____(EVENT_2)____` with `DEV` to match the secrecy goals.\n6. Replacing `____(VARIABLE_3)____` and `____(VARIABLE_0)____` with `nat` to represent the state and nonce variables.\n7. Replacing `____(PARAM_7)____`, `____(PARAM_1)____`, and other similar placeholders with the corresponding types and values according to the protocol description.\n8. Replacing `____(ROLE_0)____` with `goal`.\n9. Replacing `____(GOAL_8)____` and `____(GOAL_9)____` with `sec_1` and `sec_2` to match the secrecy goals defined in the protocol description.\n\nThe completed HLPSL code is provided above, and it should compile successfully with AVISPA."]], "HLPSL-1/device_registration.hlpsl": [[true, "%%% activation  \n%%% 1. device -> AS: SD.R1.{Hash(SD.R1)}_PS               SD,R1,En(PS,SD||R1)    \n%%% 2. AS -> device: SD.R2.{DS}_PS.{Hash(SD.R2.{DS}_PS)}_PS       SD,R2,En(PS,DS),HMAC(PS,SD||R2||En(PS,DS))\n%%% 3. device -> AS: SD.R3.{R2}_DS                         SD,R3,En(DS,R2)\n%%% 4. AS -> device: {R3}_DS                                En(DS,R3)\n\nrole device(SD,AS:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by SD\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(start) =|>\n           State':=1 /\\ R1':=new() /\\ SND(SD.R1'.{Hash(SD.R1')}_PS)  \n\n        2. State=1 /\\ RCV(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) =|>\n           State':=2 /\\ R3':=new() /\\ SND(SD.R3'.{R2'}_DS') /\\ witness(SD,AS,auth_r2,R2')\n\n        3. State=2 /\\ RCV({R3}_DS) =|>\n\t   State':=3 /\\ request(SD,AS,auth_r3,R3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authserver(AS,SD:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by AS\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(SD.R1'.{Hash(SD.R1')}_PS) =|>\n           State':=1 /\\ DS':=new() /\\ R2':=new() /\\ SND(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) /\\ secret(DS',sec_ds,{AS,SD}) \n\n        2. State=1 /\\ RCV(SD.R3'.{R2}_DS) =|>\n           State':=2 /\\ SND({R3'}_DS) /\\ witness(AS,SD,auth_r3,R3') /\\ request(AS,SD,auth_r2,R2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(SD,AS:agent,PS:symmetric_key,Hash:hash_func)\ndef=\n    local\n        SND2,RCV2,SND1,RCV1:channel(dy)\n    composition\n        device(SD,AS,PS,Hash,SND1,RCV1) /\\\n        authserver(AS,SD,PS,Hash,SND2,RCV2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n    const\n        sd1,as,sd2:agent,\n        ps:symmetric_key,\n        myhash:hash_func,\n        sec_ds,auth_r2,auth_r3:protocol_id\n\n        intruder_knowledge = {sd1, sd2, as, myhash}\n        composition\n            session(sd1,as,ps,myhash)\n            /\\ session(sd2,as,ps,myhash)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    secrecy_of sec_ds\n    authentication_on auth_r2\n    authentication_on auth_r3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%%% activation  \n%%% 1. device -> AS: SD.R1.{Hash(SD.R1)}_PS               SD,R1,En(PS,SD||R1)    \n%%% 2. AS -> device: SD.R2.{DS}_PS.{Hash(SD.R2.{DS}_PS)}_PS       SD,R2,En(PS,DS),HMAC(PS,SD||R2||En(PS,DS))\n%%% 3. device -> AS: SD.R3.{R2}_DS                         SD,R3,En(DS,R2)\n%%% 4. AS -> device: {R3}_DS                                En(DS,R3)\n\nrole device(SD,AS:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by SD\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(start) =|>\n           State':=1 /\\ R1':=new() /\\ SND(SD.R1'.{Hash(SD.R1')}_PS)  \n\n        2. State=1 /\\ RCV(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) =|>\n           State':=2 /\\ R3':=new() /\\ SND(SD.R3'.{R2'}_DS') /\\ witness(SD,AS,auth_r2,R2')\n\n        3. State=2 /\\ RCV({R3}_DS) =|>\n\t   State':=3 /\\ request(SD,AS,auth_r3,R3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authserver(AS,SD:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by AS\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(SD.R1'.{Hash(SD.R1')}_PS) =|>\n           State':=1 /\\ DS':=new() /\\ R2':=new() /\\ SND(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) /\\ secret(DS',sec_ds,{AS,SD}) \n\n        2. State=1 /\\ RCV(SD.R3'.{R2}_DS) =|>\n           State':=2 /\\ SND({R3'}_DS) /\\ witness(AS,SD,auth_r3,R3') /\\ request(AS,SD,auth_r2,R2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(SD,AS:agent,PS:symmetric_key,Hash:hash_func)\ndef=\n    local\n        SND2,RCV2,SND1,RCV1:channel(dy)\n    composition\n        device(SD,AS,PS,Hash,SND1,RCV1) /\\\n        authserver(AS,SD,PS,Hash,SND2,RCV2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n    const\n        sd1,as,sd2:agent,\n        ps:symmetric_key,\n        myhash:hash_func,\n        sec_ds,auth_r2,auth_r3:protocol_id\n\n        intruder_knowledge = {sd1, sd2, as, myhash}\n        composition\n            session(sd1,as,ps,myhash)\n            /\\ session(sd2,as,ps,myhash)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    secrecy_of sec_ds\n    authentication_on auth_r2\n    authentication_on auth_r3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/DHCP-delayed-auth.hlpsl": [[true, "role dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ witness(C,S,sig,Sig') \n      /\\ request(C,S,sec_k,K) \n      /\\ secret(K,sec_k,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ witness(C,S,sig,Sig') \n      /\\ request(C,S,sec_k,K) \n      /\\ secret(K,sec_k,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/AAAMobileIP.hlpsl": [[true, "role aaa_MIP_FA (FA, AAAL, AAAH, MN : agent,\n           Snd, Rcv : channel(dy),\n           K_FaAAAL : symmetric_key)\nplayed_by FA\ndef=\n  local  State                 : nat,\n\t K_MnFa,K_FaHa : symmetric_key,\n         KeyMnFaKeyMnHa,SignedKeyMnFaKeyMnHa : {symmetric_key.symmetric_key}_symmetric_key\n\n  const  secFAMN, k_mnfa1, k_mnfa2   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH')\n      =|> \n      State' := 1\n\n   2. State = 1\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_MnAAAH)\n      /\\ secret(K_MnFa',secFAMN,{FA,MN})\n      /\\ wrequest(FA,AAAH,k_mnfa1,K_MnFa')\n      /\\ wrequest(FA,AAAH,k_mnfa2,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAL (AAAL, AAAH, FA, MN : agent,\n           Snd, Rcv : channel(dy),\n           K_FaAAAL,\n           K_AAAHAAAL : symmetric_key)\nplayed_by AAAL\ndef=\n  local  State                 : nat\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_MnAAAH)\n      =|> \n      State' := 1\n\n   2. State = 1\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n              KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n               KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_AAAHAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAH (AAAH,AAAL,HA,FA,MN : agent,\n           Snd, Rcv : channel(dy),\n           K_MnAAAH,\n           K_AAAHAAAL,\n           KAAAHHa : symmetric_key)\nplayed_by AAAH\ndef=\n\n  local  N1                : nat,\n\t K_FaHa,K_MnHa,K_MnFa : symmetric_key\n\n  const  secFAHA, k_faha1, k_faha2   : protocol_id,\n         k_mnfa1, k_mnha1, k_mnha2   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State   = 0\n      /\\ Rcv(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH)\n      =|> \n      State' := 1\n      /\\ K_MnHa' := new()\n      /\\ K_MnFa' := new()\n      /\\ K_FaHa' := new()\n      /\\ Snd( MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                 {K_MnFa'.K_MnHa'}_K_MnAAAH.\n                 {MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                     {K_MnFa'.K_MnHa'}_K_MnAAAH}_KAAAHHa)\n      /\\ witness(AAAH,FA,k_faha1,K_FaHa')\n      /\\ witness(AAAH,FA,k_mnfa1,K_MnFa')\n      /\\ witness(AAAH,MN,k_mnha2,K_MnHa')\n      /\\ request(AAAH,HA,k_mnha1,K_MnHa')\n      /\\ request(AAAH,HA,k_faha2,K_FaHa')\n\n   2. State = 1\n      /\\ Rcv( {K_MnFa.K_MnHa}_K_MnAAAH.\n              {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n               {{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_KAAAHHa)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n\t     {FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_K_AAAHAAAL)\t\n      /\\ secret(K_FaHa,secFAHA,{FA,HA}) \n      /\\ secret(K_MnFa,k_mnfa2,{FA,MN})\n      /\\ secret(K_MnHa,secMNHA,{MN,HA})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_HA (HA,AAAH,MN : agent,\n                 Snd, Rcv : channel(dy),\n                 K_AAAHHa: symmetric_key)\nplayed_by HA\ndef=\n\n  local\n    State                 : nat,\n    K_MnFa,K_FaHa, K_MnHa : symmetric_key,\n    KeyMnFaKeyMnHa        : {symmetric_key.symmetric_key}_symmetric_key\n\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv( MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'.\n             {MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'}_K_AAAHHa) \n      =|> \n      State' := 1\n      /\\ Snd( KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'.\n             {KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'}_K_AAAHHa)\n      /\\ wrequest(HA,AAAH,k_faha2,K_FaHa')\n      /\\ wrequest(HA,AAAH,k_mnha1,K_MnHa')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(MN,FA,AAAL,AAAH,HA: agent,\n\t     Kmn3ah,Kfa3al,K3ah3al,Kha3ah: symmetric_key) def=\n\n   local     MNs,MNr,\n\t     FAs,FAr,\n\t     Ls, Lr,\n\t     Hs, Hr,\n\t     HAs, HAr: channel(dy)\n\n   composition\n\n           aaa_MIP_MN(MN,AAAH,FA,MNs,MNr,Kmn3ah)\n\n        /\\ aaa_MIP_FA(FA,AAAL,AAAH,MN,FAs,FAr,Kfa3al)\n  \n        /\\ aaa_MIP_AAAL(AAAL,AAAH,FA,MN,Ls,Lr,Kfa3al,K3ah3al)\n\n        /\\ aaa_MIP_AAAH(AAAH,AAAL,HA,FA,MN,Hs,Hr,Kmn3ah,K3ah3al,Kha3ah)\n         \n        /\\ aaa_MIP_HA(HA,AAAH,MN,HAs,HAr,Kha3ah)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const k_mnha1, k_mnfa1, k_faha1                    : protocol_id,\n        k_mnha2, k_mnfa2, k_faha2                    : protocol_id,\n        mn, fa, aaal, aaah, ha                       : agent,\n        k_mn_aaah, k_fa_aaal, k_aaah_aaal, k_ha_aaah : symmetric_key,\n        secFAMN, secFAHA, secMNHA                    : protocol_id\n\n  intruder_knowledge = {mn,fa,aaal,aaah,ha}\n\n  composition\n\n\tsession(mn,fa,aaal,aaah,ha,\t                    %%% Agents\n\t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%\t/\\ session(i,mn,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_i_aaah,k_mn_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%     intruder_knowledge += {k_i_aaah}\n%%%\t/\\ session(mn,i,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_mn_aaah,k_i_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,i,aaah,ha,\t              %%% Agents\n%%% % \t\tk_mn_aaah,k_fa_i,k_aaah_i,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,aaal,i,ha,\t           %%% Agents\n%%% % \t\tk_mn_i,k_fa_aaal,k_i_aaal,k_ha_i)  %%% Shared Keys\n%%%\t/\\ session(mn,fa,aaal,aaah,i,\t                   %%% Agents\n%%% \t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_i_aaah)  %%% Shared Keys\n\nend role\n\ngoal\n\n  %secrecy_of K_MnFa, K_FaHa, K_MnFa\n  secrecy_of secFAHA, secFAMN, secMNHA % addresses G12\n\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_faha1\n  weak_authentication_on k_faha1 % addresses G1,G7,G10\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_mnfa1\n  weak_authentication_on k_mnfa1 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_faha2\n  weak_authentication_on k_faha2 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_mnha1\n  weak_authentication_on k_mnha1 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnha2\n  weak_authentication_on k_mnha2 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnfa2\n  weak_authentication_on k_mnfa2 % addresses G1,G7,G10\n\nend goal\n\nenvironment()", "```hlpsl\nrole aaa_MIP_FA (FA, AAAL, AAAH, MN : agent,\n           Snd, Rcv : channel(dy),\n           K_FaAAAL : symmetric_key)\nplayed_by FA\ndef=\n  local  State                 : nat,\n\t K_MnFa,K_FaHa : symmetric_key,\n         KeyMnFaKeyMnHa,SignedKeyMnFaKeyMnHa : {symmetric_key.symmetric_key}_symmetric_key\n\n  const  secFAMN, k_mnfa1, k_mnfa2   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH')\n      =|> \n      State' := 1\n\n   2. State = 1\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_MnAAAH)\n      /\\ secret(K_MnFa',secFAMN,{FA,MN})\n      /\\ wrequest(FA,AAAH,k_mnfa1,K_MnFa')\n      /\\ wrequest(FA,AAAH,k_mnfa2,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAL (AAAL, AAAH, FA, MN : agent,\n           Snd, Rcv : channel(dy),\n           K_FaAAAL,\n           K_AAAHAAAL : symmetric_key)\nplayed_by AAAL\ndef=\n  local  State                 : nat\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {MN.{K_MnFa'.K_FaHa'}_K_MnAAAH.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_MnAAAH)\n      =|> \n      State' := 1\n\n   2. State = 1\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n              KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n               KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_AAAHAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAH (AAAH,AAAL,HA,FA,MN : agent,\n           Snd, Rcv : channel(dy),\n           K_MnAAAH,\n           K_AAAHAAAL,\n           KAAAHHa : symmetric_key)\nplayed_by AAAH\ndef=\n\n  local  N1                : nat,\n\t K_FaHa,K_MnHa,K_MnFa : symmetric_key\n\n  const  secFAHA, k_faha1, k_faha2   : protocol_id,\n         k_mnfa1, k_mnha1, k_mnha2   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State   = 0\n      /\\ Rcv(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH)\n      =|> \n      State' := 1\n      /\\ K_MnHa' := new()\n      /\\ K_MnFa' := new()\n      /\\ K_FaHa' := new()\n      /\\ Snd( MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                 {K_MnFa'.K_MnHa'}_K_MnAAAH.\n                 {MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                     {K_MnFa'.K_MnHa'}_K_MnAAAH}_KAAAHHa)\n      /\\ witness(AAAH,FA,k_faha1,K_FaHa')\n      /\\ witness(AAAH,FA,k_mnfa1,K_MnFa')\n      /\\ witness(AAAH,MN,k_mnha2,K_MnHa')\n      /\\ request(AAAH,HA,k_mnha1,K_MnHa')\n      /\\ request(AAAH,HA,k_faha2,K_FaHa')\n\n   2. State = 1\n      /\\ Rcv( {K_MnFa.K_MnHa}_K_MnAAAH.\n              {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n               {{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_KAAAHHa)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n\t     {FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_K_AAAHAAAL)\t\n      /\\ secret(K_FaHa,secFAHA,{FA,HA}) \n      /\\ secret(K_MnFa,k_mnfa2,{FA,MN})\n      /\\ secret(K_MnHa,secMNHA,{MN,HA})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_HA (HA,AAAH,MN : agent,\n                 Snd, Rcv : channel(dy),\n                 K_AAAHHa: symmetric_key)\nplayed_by HA\ndef=\n\n  local\n    State                 : nat,\n    K_MnFa,K_FaHa, K_MnHa : symmetric_key,\n    KeyMnFaKeyMnHa        : {symmetric_key.symmetric_key}_symmetric_key\n\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv( MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'.\n             {MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'}_K_AAAHHa) \n      =|> \n      State' := 1\n      /\\ Snd( KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'.\n             {KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'}_K_AAAHHa)\n      /\\ wrequest(HA,AAAH,k_faha2,K_FaHa')\n      /\\ wrequest(HA,AAAH,k_mnha1,K_MnHa')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(MN,FA,AAAL,AAAH,HA: agent,\n\t     Kmn3ah,Kfa3al,K3ah3al,Kha3ah: symmetric_key) def=\n\n   local     MNs,MNr,\n\t     FAs,FAr,\n\t     Ls, Lr,\n\t     Hs, Hr,\n\t     HAs, HAr: channel(dy)\n\n   composition\n\n           aaa_MIP_MN(MN,AAAH,FA,MNs,MNr,Kmn3ah)\n\n        /\\ aaa_MIP_FA(FA,AAAL,AAAH,MN,FAs,FAr,Kfa3al)\n  \n        /\\ aaa_MIP_AAAL(AAAL,AAAH,FA,MN,Ls,Lr,Kfa3al,K3ah3al)\n\n        /\\ aaa_MIP_AAAH(AAAH,AAAL,HA,FA,MN,Hs,Hr,Kmn3ah,K3ah3al,Kha3ah)\n         \n        /\\ aaa_MIP_HA(HA,AAAH,MN,HAs,HAr,Kha3ah)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const k_mnha1, k_mnfa1, k_faha1                    : protocol_id,\n        k_mnha2, k_mnfa2, k_faha2                    : protocol_id,\n        mn, fa, aaal, aaah, ha                       : agent,\n        k_mn_aaah, k_fa_aaal, k_aaah_aaal, k_ha_aaah : symmetric_key,\n        secFAMN, secFAHA, secMNHA                    : protocol_id\n\n  intruder_knowledge = {mn,fa,aaal,aaah,ha}\n\n  composition\n\n\tsession(mn,fa,aaal,aaah,ha,\t                    %%% Agents\n\t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%\t/\\ session(i,mn,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_i_aaah,k_mn_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%     intruder_knowledge += {k_i_aaah}\n%%%\t/\\ session(mn,i,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_mn_aaah,k_i_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,i,aaah,ha,\t              %%% Agents\n%%% % \t\tk_mn_aaah,k_fa_i,k_aaah_i,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,aaal,i,ha,\t           %%% Agents\n%%% % \t\tk_mn_i,k_fa_aaal,k_i_aaal,k_ha_i)  %%% Shared Keys\n%%%\t/\\ session(mn,fa,aaal,aaah,i,\t                   %%% Agents\n%%% \t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_i_aaah)  %%% Shared Keys\n\nend role\n\ngoal\n\n  %secrecy_of K_MnFa, K_FaHa, K_MnFa\n  secrecy_of secFAHA, secFAMN, secMNHA % addresses G12\n\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_faha1\n  weak_authentication_on k_faha1 % addresses G1,G7,G10\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_mnfa1\n  weak_authentication_on k_mnfa1 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_faha2\n  weak_authentication_on k_faha2 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_mnha1\n  weak_authentication_on k_mnha1 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnha2\n  weak_authentication_on k_mnha2 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnfa2\n  weak_authentication_on k_mnfa2 % addresses G1,G7,G10\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/DPP-I.hlpsl": [[true, "role configurator(C, E : agent,\n\t   Mx, Nx, Lx: symmetric_key,  \n           H : hash_func,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local Ni, Nc, Nr, Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, sec_nr, sec_ne, auth_nr : protocol_id,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ secret(K1,sec_k1,{C,E})\n\t\t/\\ witness(C,E,auth_ni,Ni)\n\t\t/\\ witness(C,E,auth_nr,Nr)\n\n  3.  State = 3\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi'.Pr'.Bi'.Br'.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr'.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr'.Ni'.Pr'.Pi'.Br'.Bi'.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ secret(Iauth,sec_iauth,{C,E})\n\t\t/\\ request(C,E,auth_nr,Nr')\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{C,E})\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n        \n\nend role\n\n\n\nrole enrollee(C, E : agent,\n\t Mx, Nx, Lx: symmetric_key,\n         H : hash_func,\n         Br, Pr, Kca: public_key,\n         SND, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local Ni, Na, Nr, Ne, Sid, Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, sec_ne, auth_ni, sec_iauth : protocol_id,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ SND(H(chirp.Br))\n   2. State = 2 /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi'.Pr'.Bi'.Br'.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr'.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr'.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(Nr,sec_nr,{E,C})\n\t\t/\\ witness(E,C,auth_nr,Nr)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr'.Ni'.Pr'.Pi'.Br'.Bi'.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{E,C})\n\t\t/\\ request(E,C,auth_ni,Ni)\n\t\n\n  6.  State = 6 /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(C,E: agent,\n\t     Mx, Nx, Lx: symmetric_key,\n             H : hash_func,\n             Bi, Pi, Br, Pr, Kca: public_key)\ndef=\n\n   local  SC, RC, SR, RR: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, sec_iauth      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n\nend role\n\n\n\ngoal\n\n  secrecy_of sec_k1, sec_k2, sec_ne, sec_nr, sec_iauth  \n  witness(C,E,auth_ni,Ni)  \n  authentication_on auth_ni  \n  witness(E,C,auth_nr,Nr)  \n  authentication_on auth_nr  \n  \nend goal\n\n\n\nenvironment()", "```hlpsl\nrole configurator(C, E : agent,\n\t   Mx, Nx, Lx: symmetric_key,  \n           H : hash_func,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local Ni, Nc, Nr, Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, sec_nr, sec_ne, auth_nr : protocol_id,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ secret(K1,sec_k1,{C,E})\n\t\t/\\ witness(C,E,auth_ni,Ni)\n\t\t/\\ witness(C,E,auth_nr,Nr)\n\n  3.  State = 3\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi'.Pr'.Bi'.Br'.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr'.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr'.Ni'.Pr'.Pi'.Br'.Bi'.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ secret(Iauth,sec_iauth,{C,E})\n\t\t/\\ request(C,E,auth_nr,Nr')\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{C,E})\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n        \n\nend role\n\n\n\nrole enrollee(C, E : agent,\n\t Mx, Nx, Lx: symmetric_key,\n         H : hash_func,\n         Br, Pr, Kca: public_key,\n         SND, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local Ni, Na, Nr, Ne, Sid, Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, sec_ne, auth_ni, sec_iauth : protocol_id,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ SND(H(chirp.Br))\n   2. State = 2 /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi'.Pr'.Bi'.Br'.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr'.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr'.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(Nr,sec_nr,{E,C})\n\t\t/\\ witness(E,C,auth_nr,Nr)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr'.Ni'.Pr'.Pi'.Br'.Bi'.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{E,C})\n\t\t/\\ request(E,C,auth_ni,Ni)\n\t\n\n  6.  State = 6 /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(C,E: agent,\n\t     Mx, Nx, Lx: symmetric_key,\n             H : hash_func,\n             Bi, Pi, Br, Pr, Kca: public_key)\ndef=\n\n   local  SC, RC, SR, RR: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, sec_iauth      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n\nend role\n\n\n\ngoal\n\n  secrecy_of sec_k1, sec_k2, sec_ne, sec_nr, sec_iauth  \n  witness(C,E,auth_ni,Ni)  \n  authentication_on auth_ni  \n  witness(E,C,auth_nr,Nr)  \n  authentication_on auth_nr  \n  \nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/drone_to_gss_protocol.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Role Drone %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole drone(CR, DR, GSS: agent,\n    H: hash_func,\n    Snd, Rcv: channel(dy))\n% Player: DRj\nplayed_by DR\ndef=\nlocal State: nat,\n    SKcrdr: symmetric_key,\n    %%% F is ECC point mutiplication operation\n    F, Add, Poly: hash_func,\n    G, MKdrj, Rdrj, Pubdrj : text,\n    IDdrj, IDgss, IDcr, RTSdrj, Rcr, Rdr, TSdr, Adr: text,\n    Adr1, Rgss, RTSgss, TSgss, Bgss, Rgss1: text,\n    TSdr1, ACKdrgss: text\nconst dr_gss_rdr, gss_dr_rgss1, dr_gss_tsdr, gss_dr_tsgss, dr_gss_tsdr1 : protocol_id\n\ninit State := 0\ntransition\n%%%Drone registration phase\n%%%Receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss.H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdrj'.RTSdrj').\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr')}_SKcrdr) =|>\nState' := 2 /\\ secret({Rdrj',RTSdrj'}, sp1, {CR})\n\n%%% Access control phase\n    /\\ Rdr' := new() /\\ TSdr' := new()\n    /\\ Adr' := H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr')\n    /\\ Adr1' := F(Adr'.G)\n\n%%% Send message Msg1 to GSS via public channel\n    /\\ Snd(IDdrj.Adr1'.Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')\n\n%% DRj has freshly generated the values rdrk and TSdrk for GSS that are induded in Msg1\n    /\\ witness(DR, GSS, dr_gss_rdr, Rdr')\n    /\\ witness(DR, GSS, dr_gss_tsdr, TSdr')\n\n%%% Receive message Msg2 from the GSS via public channel\n2. State = 2 /\\ Rcv(IDgss.F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).\n                H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr).\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'. TSgss').\n                F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).TSgss'.IDgss).\n                TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')) =|>\n\nState' := 4 /\\ TSdr1' := new()\n        /\\ ACKdrgss' := H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G)).\n            Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n            Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr').TSdr'.TSgss').TSdr1')\n\n%%% Send message Msqg3 to GSS via public channel\n        /\\ Snd(ACKdrgss'.TSdr1')\n\n%% DRj has freshly generated the value TSdr1 for GSS that is included in Msg3\n        /\\ witness(DR, GSS, dr_gss_tsdr1, TSdr1')\n\n% DRj's acceptance of the values rgss1, TSgss (message Msq2) for GSS by DRj\n        /\\ request(GSS, DR, gss_dr_rgss1, Rgss1')\n        /\\ request(GSS, DR, gss_dr_tsgss, TSgss')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GSS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole groundserver(CR, DR, GSS: agent,\n        H: hash_func,\n        Snd, Rcv: channel(dy))\n\n% Player: GSS\nplayed_by GSS\ndef=\nlocal State: nat,\n            SKcrgss: symmetric_key,\n%%% F is ECC point mutiplication operation\n            F, Add: hash_func,\n            Poly: hash_func,\n            G, MKdrj, Rdrj, Pubdrj : text,\n            IDdrj, IDgss, IDcr, Rgss, RTSgss, Rcr: text,\n            RTSdrj, Rdr, TSdr, Rgss1, TSgss, DKgss, Bgss, Bgss12: text,\n            SKgssdr, SKVgssdr, TSdr1: text\n\nconst sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\ninit State := 0\ntransition\n%%% GSS registration phase\n%%% receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss. H(IDgss.IDcr.Rgss'.RTSgss').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')}_SKcrgss) =|>\nState' := 3 /\\ secret({RTSgss',Rgss'}, sp2, {CR})\n\n%%% Access control phase\n%%% Receive message Msq1 from the DRj via public channel\n2. State = 3 /\\ Rcv(IDdrj.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')=|>\nState' := 5 /\\ Rgss1' := new() /\\ TSgss' := new() /\\ RTSgss' := new() /\\ Rgss' := new()\n            /\\ Bgss' := H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss')\n            /\\ Bgss12' := F(Bgss'.G)\n            /\\ DKgss' := F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G))\n            /\\ SKgssdr' := H(DKgss'.Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss')\n\n            /\\ SKVgssdr' := H(SKgssdr'.Bgss12'.TSgss'.IDgss)\n%%% Send message Msg? to the drone via public channel\n            /\\ Snd(IDgss.Bgss12'.SKVgssdr'.TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'))\n%% GSS has freshly generated the values rgss1 and TSgss for DRj that are induded in Msg2\n            /\\ witness(GSS, DR, gss_dr_rgss1, Rgss1')\n            /\\ witness(GSS, DR, gss_dr_tsgss, TSgss')\n\n%%% Receive message Msg3 from the drone via public channel\n3. State = 5 /\\ Rcv(H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss').TSdr1').TSdr1') =|>\n\n% GSS's acceptance of the values rdr, TSdr (message Msg1) and TSdr1 (message Msg3) for GSS by DRj\n\nState' := 7 /\\ request(DR, GSS, dr_gss_rdr, Rdr')\n        /\\ request(DR, GSS, dr_gss_tsdr, TSdr')\n        /\\ request(DR, GSS, dr_gss_tsdr1, TSdr1')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(CR, DR, GSS: agent,\n            H: hash_func)\ndef=\n    local Sn1, Sn2, Sn3, Rv1, Rv2, Rv3: channel (dy)\n    composition\n        controlroom (CR, DR, GSS, H, Sn1, Rv1)\n        /\\ drone (CR, DR, GSS, H, Sn2, Rv2)\n        /\\ groundserver (CR, DR, GSS, H, Sn3, Rv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n    const cr, dr, gss: agent,\n        h, f, add, poly: hash_func,\n        tsdr, tsdr1, tsgss: text,\n        sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\n    intruder_knowledge = {cr, dr, gss, h, f, add, poly, tsdr, tsdr1, tsgss}\n\n    composition\n        session(cr, dr, gss, h)\n        /\\ session(cr, i, gss, h)\n        /\\session(cr, dr, i, h)\n    end role\n\ngoal\n\n%%% Authentication\nauthentication_on dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1\nauthentication_on gss_dr_rgss1, gss_dr_tsgss\n\n%%% Confidentiality\nsecrecy_of sp1, sp2\n\nend goal\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Role Drone %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole drone(CR, DR, GSS: agent,\n    H: hash_func,\n    Snd, Rcv: channel(dy))\n% Player: DRj\nplayed_by DR\ndef=\nlocal State: nat,\n    SKcrdr: symmetric_key,\n    %%% F is ECC point mutiplication operation\n    F, Add, Poly: hash_func,\n    G, MKdrj, Rdrj, Pubdrj : text,\n    IDdrj, IDgss, IDcr, RTSdrj, Rcr, Rdr, TSdr, Adr: text,\n    Adr1, Rgss, RTSgss, TSgss, Bgss, Rgss1: text,\n    TSdr1, ACKdrgss: text\nconst dr_gss_rdr, gss_dr_rgss1, dr_gss_tsdr, gss_dr_tsgss, dr_gss_tsdr1 : protocol_id\n\ninit State := 0\ntransition\n%%%Drone registration phase\n%%%Receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss.H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdrj'.RTSdrj').\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr')}_SKcrdr) =|>\nState' := 2 /\\ secret({Rdrj',RTSdrj'}, sp1, {CR})\n\n%%% Access control phase\n    /\\ Rdr' := new() /\\ TSdr' := new()\n    /\\ Adr' := H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr')\n    /\\ Adr1' := F(Adr'.G)\n\n%%% Send message Msg1 to GSS via public channel\n    /\\ Snd(IDdrj.Adr1'.Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')\n\n%% DRj has freshly generated the values rdrk and TSdrk for GSS that are induded in Msg1\n    /\\ witness(DR, GSS, dr_gss_rdr, Rdr')\n    /\\ witness(DR, GSS, dr_gss_tsdr, TSdr')\n\n%%% Receive message Msg2 from the GSS via public channel\n2. State = 2 /\\ Rcv(IDgss.F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).\n                H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr).\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'. TSgss').\n                F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).TSgss'.IDgss).\n                TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')) =|>\n\nState' := 4 /\\ TSdr1' := new()\n        /\\ ACKdrgss' := H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G)).\n            Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n            Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr').TSdr'.TSgss').TSdr1')\n\n%%% Send message Msqg3 to GSS via public channel\n        /\\ Snd(ACKdrgss'.TSdr1')\n\n%% DRj has freshly generated the value TSdr1 for GSS that is included in Msg3\n        /\\ witness(DR, GSS, dr_gss_tsdr1, TSdr1')\n\n% DRj's acceptance of the values rgss1, TSgss (message Msq2) for GSS by DRj\n        /\\ request(GSS, DR, gss_dr_rgss1, Rgss1')\n        /\\ request(GSS, DR, gss_dr_tsgss, TSgss')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GSS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole groundserver(CR, DR, GSS: agent,\n        H: hash_func,\n        Snd, Rcv: channel(dy))\n\n% Player: GSS\nplayed_by GSS\ndef=\nlocal State: nat,\n            SKcrgss: symmetric_key,\n%%% F is ECC point mutiplication operation\n            F, Add: hash_func,\n            Poly: hash_func,\n            G, MKdrj, Rdrj, Pubdrj : text,\n            IDdrj, IDgss, IDcr, Rgss, RTSgss, Rcr: text,\n            RTSdrj, Rdr, TSdr, Rgss1, TSgss, DKgss, Bgss, Bgss12: text,\n            SKgssdr, SKVgssdr, TSdr1: text\n\nconst sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\ninit State := 0\ntransition\n%%% GSS registration phase\n%%% receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss. H(IDgss.IDcr.Rgss'.RTSgss').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')}_SKcrgss) =|>\nState' := 3 /\\ secret({RTSgss',Rgss'}, sp2, {CR})\n\n%%% Access control phase\n%%% Receive message Msq1 from the DRj via public channel\n2. State = 3 /\\ Rcv(IDdrj.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')=|>\nState' := 5 /\\ Rgss1' := new() /\\ TSgss' := new() /\\ RTSgss' := new() /\\ Rgss' := new()\n            /\\ Bgss' := H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss')\n            /\\ Bgss12' := F(Bgss'.G)\n            /\\ DKgss' := F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G))\n            /\\ SKgssdr' := H(DKgss'.Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss')\n\n            /\\ SKVgssdr' := H(SKgssdr'.Bgss12'.TSgss'.IDgss)\n%%% Send message Msg? to the drone via public channel\n            /\\ Snd(IDgss.Bgss12'.SKVgssdr'.TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'))\n%% GSS has freshly generated the values rgss1 and TSgss for DRj that are induded in Msg2\n            /\\ witness(GSS, DR, gss_dr_rgss1, Rgss1')\n            /\\ witness(GSS, DR, gss_dr_tsgss, TSgss')\n\n%%% Receive message Msg3 from the drone via public channel\n3. State = 5 /\\ Rcv(H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss').TSdr1').TSdr1') =|>\n\n% GSS's acceptance of the values rdr, TSdr (message Msg1) and TSdr1 (message Msg3) for GSS by DRj\n\nState' := 7 /\\ request(DR, GSS, dr_gss_rdr, Rdr')\n        /\\ request(DR, GSS, dr_gss_tsdr, TSdr')\n        /\\ request(DR, GSS, dr_gss_tsdr1, TSdr1')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(CR, DR, GSS: agent,\n            H: hash_func)\ndef=\n    local Sn1, Sn2, Sn3, Rv1, Rv2, Rv3: channel (dy)\n    composition\n        controlroom (CR, DR, GSS, H, Sn1, Rv1)\n        /\\ drone (CR, DR, GSS, H, Sn2, Rv2)\n        /\\ groundserver (CR, DR, GSS, H, Sn3, Rv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n    const cr, dr, gss: agent,\n        h, f, add, poly: hash_func,\n        tsdr, tsdr1, tsgss: text,\n        sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\n    intruder_knowledge = {cr, dr, gss, h, f, add, poly, tsdr, tsdr1, tsgss}\n\n    composition\n        session(cr, dr, gss, h)\n        /\\ session(cr, i, gss, h)\n        /\\session(cr, dr, i, h)\n    end role\n\ngoal\n\n%%% Authentication\nauthentication_on dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1\nauthentication_on gss_dr_rgss1, gss_dr_tsgss\n\n%%% Confidentiality\nsecrecy_of sp1, sp2\n\nend goal\nenvironment()\n```"]], "HLPSL-1/Dynamic_group_key_distribution_scheme_with_three-factor_identification_for_IoT_environments.hlpsl": [[true, "role user (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, SND, RCV, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message, Hash: (message, message) -> message, New: () -> message)\nplayed_by U def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ E' := new()\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(IDi,g1,{U})\n/\\ secret(PWi,g2,{U,S})\n/\\ secret(Bi,g4,{U})\n/\\ secret(E,g3,{U,S})\n\n2.  State = 1 /\\ RCV({IDi.Nj.({H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj)}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\n% Login and authentication procedure\n\n3.  State = 2 /\\ RCV(start) =|>\nState':= 1\n/\\ V' := new()\n/\\ N' := H(H(H(V')))\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n/\\ Tu' := new()\n/\\ A' := xor(xor(BBi',W'),Tu')\n/\\ Yij' := xor(E,Ej)\n/\\ K' := {IDj.IDi.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g12,{U,S})\n/\\ secret(PWi,g3,{U})\n/\\ secret(Ej,g5,{U,S})\n\n4.  State = 3 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n/\\ Hi' := H5(SKij'.Ts')\n/\\ Gki' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ GkiAT' := H(H1(H6(H(Xj.As))).H2(H14(H(Xj.Bs))))\n/\\ request(S,U,s_u_ts,Ts')\n\n% Dynamic key derivation procedure\n\n5. State = 0 /\\ RCV({H6(H(Xj.As.M')).H14(H(Xj.Bs.M'))}_GkiAT') =|>\nState':= 1\n/\\ GkiAT' := H(H2(H6(H(Xj.As))).H1(H14(H(Xj.Bs))))\n/\\ GkiATNew' := H(H2(H6(H(Xj.As.M'))).H1(H14(H(Xj.Bs.M'))))\n/\\ request(S,U,s_u_m,M')\n\nend role\n\n\nrole server (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, SND, RCV, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message, Hash: (message, message) -> message)\nplayed_by S def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, X, Y, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n/\\ SND({Nj.Yij'}_Kus)\n/\\ secret(Nj,g5,{S,U})\n\n% Login and authentication procedure\n\n2. State = 0 /\\ RCV({IDj.IDi.{H(Xj).IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj.H(H(H(V'))).xor(xor(H(PWi.Bi),H(H(PWi.E).xor(h(xor(IDi,IDj)),E))),Tu').Tu'}_Ks) =|>\nState':= 1\n/\\ Ts' := new()\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n/\\ IDinew' := H(Yij.IDi.H(Xj))\n/\\ SKij' := H(xor(H(H(H(V'))),Yij))\n/\\ As' := new() /\\ Bs' := new()\n/\\ Ti1' := new() /\\ Ti2' := new()\n/\\ ATia' := H6(H(Xj.As'))\n/\\ ATib' := H14(H(Xj.Bs'))\n/\\ Gki' := (ATia'.ATib'.Ti1'.Ti2')\n/\\ Hi' := H5(SKij'.Ts')\n/\\ C1' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C2').Mul(Hi'.C3'))).Hi')\n/\\ C2' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C3'))).Hi')\n/\\ C3' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C2'))).Hi')\n/\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ secret(Ti1',g8,{U,S})\n/\\ secret(Ti2',g9,{U,S})\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_tu,Tu')\n\n% Dynamic key derivation procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ M' := new()\n/\\ ATia' := H6(H(Xj.As.M'))\n/\\ ATib' := H14(H(Xj.Bs.M'))\n/\\ GkiAT' := H(H8(H(Xj.As)).H15(H(Xj.Bs)))\n/\\ Q1' := {ATia'.ATib'}_GkiAT'\n/\\ SND (Q1')\n/\\ witness(S,U,s_u_m,M')\n/\\ secret(M',g11,{S,U})\n\nend role\n\nrole session (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message)\ndef=\n\nlocal SU, RU, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,SU,RU,XOR,Mul,Add,Sub,Div,H)\n/\\ server (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,RS,RU,XOR,Mul,Add,Sub,Div,H)\n\nend role\n\nrole environment() def=\n\nconst u, s: agent,\nkus, skij, gkiat: symmetric_key,\nks: public_key,\nh, h1, h2, h4, h5, h6, h8, h14, h15: hash_func,\nxor: (message, message) -> message,\nmul, add, sub, div: (message, message) -> message,\ng1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11: protocol_id,\nu_s_tu, s_u_ts, s_u_m: protocol_id\n\nintruder_knowledge = {u,s,ks}\n\ncomposition\n\nsession(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,xor,mul,add,sub,div)\n/\\ session(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,xor,mul,add,sub,div)\n\nend role\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6, g8, g9, g11, g12 \nauthentication_on u_s_tu, s_u_ts, s_u_m\n\nend goal\n\nenvironment()", "```hlpsl\nrole user (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, SND, RCV, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message, Hash: (message, message) -> message, New: () -> message)\nplayed_by U def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ E' := new()\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(IDi,g1,{U})\n/\\ secret(PWi,g2,{U,S})\n/\\ secret(Bi,g4,{U})\n/\\ secret(E,g3,{U,S})\n\n2.  State = 1 /\\ RCV({IDi.Nj.({H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj)}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\n% Login and authentication procedure\n\n3.  State = 2 /\\ RCV(start) =|>\nState':= 1\n/\\ V' := new()\n/\\ N' := H(H(H(V')))\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n/\\ Tu' := new()\n/\\ A' := xor(xor(BBi',W'),Tu')\n/\\ Yij' := xor(E,Ej)\n/\\ K' := {IDj.IDi.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g12,{U,S})\n/\\ secret(PWi,g3,{U})\n/\\ secret(Ej,g5,{U,S})\n\n4.  State = 3 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n/\\ Hi' := H5(SKij'.Ts')\n/\\ Gki' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ GkiAT' := H(H1(H6(H(Xj.As))).H2(H14(H(Xj.Bs))))\n/\\ request(S,U,s_u_ts,Ts')\n\n% Dynamic key derivation procedure\n\n5. State = 0 /\\ RCV({H6(H(Xj.As.M')).H14(H(Xj.Bs.M'))}_GkiAT') =|>\nState':= 1\n/\\ GkiAT' := H(H2(H6(H(Xj.As))).H1(H14(H(Xj.Bs))))\n/\\ GkiATNew' := H(H2(H6(H(Xj.As.M'))).H1(H14(H(Xj.Bs.M'))))\n/\\ request(S,U,s_u_m,M')\n\nend role\n\n\nrole server (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, SND, RCV, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message, Hash: (message, message) -> message)\nplayed_by S def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, X, Y, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n/\\ SND({Nj.Yij'}_Kus)\n/\\ secret(Nj,g5,{S,U})\n\n% Login and authentication procedure\n\n2. State = 0 /\\ RCV({IDj.IDi.{H(Xj).IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj.H(H(H(V'))).xor(xor(H(PWi.Bi),H(H(PWi.E).xor(h(xor(IDi,IDj)),E))),Tu').Tu'}_Ks) =|>\nState':= 1\n/\\ Ts' := new()\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n/\\ IDinew' := H(Yij.IDi.H(Xj))\n/\\ SKij' := H(xor(H(H(H(V'))),Yij))\n/\\ As' := new() /\\ Bs' := new()\n/\\ Ti1' := new() /\\ Ti2' := new()\n/\\ ATia' := H6(H(Xj.As'))\n/\\ ATib' := H14(H(Xj.Bs'))\n/\\ Gki' := (ATia'.ATib'.Ti1'.Ti2')\n/\\ Hi' := H5(SKij'.Ts')\n/\\ C1' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C2').Mul(Hi'.C3'))).Hi')\n/\\ C2' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C3'))).Hi')\n/\\ C3' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C2'))).Hi')\n/\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ secret(Ti1',g8,{U,S})\n/\\ secret(Ti2',g9,{U,S})\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_tu,Tu')\n\n% Dynamic key derivation procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ M' := new()\n/\\ ATia' := H6(H(Xj.As.M'))\n/\\ ATib' := H14(H(Xj.Bs.M'))\n/\\ GkiAT' := H(H8(H(Xj.As)).H15(H(Xj.Bs)))\n/\\ Q1' := {ATia'.ATib'}_GkiAT'\n/\\ SND (Q1')\n/\\ witness(S,U,s_u_m,M')\n/\\ secret(M',g11,{S,U})\n\nend role\n\nrole session (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15: hash_func, XOR: (message, message) -> message, Mul, Add, Sub, Div: (message, message) -> message)\ndef=\n\nlocal SU, RU, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,SU,RU,XOR,Mul,Add,Sub,Div,H)\n/\\ server (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,RS,RU,XOR,Mul,Add,Sub,Div,H)\n\nend role\n\nrole environment() def=\n\nconst u, s: agent,\nkus, skij, gkiat: symmetric_key,\nks: public_key,\nh, h1, h2, h4, h5, h6, h8, h14, h15: hash_func,\nxor: (message, message) -> message,\nmul, add, sub, div: (message, message) -> message,\ng1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11: protocol_id,\nu_s_tu, s_u_ts, s_u_m: protocol_id\n\nintruder_knowledge = {u,s,ks}\n\ncomposition\n\nsession(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,xor,mul,add,sub,div)\n/\\ session(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,xor,mul,add,sub,div)\n\nend role\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6, g8, g9, g11, g12 \nauthentication_on u_s_tu, s_u_ts, s_u_m\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/eap-lorawan.hlpsl": [[true, "role end_device (ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey : agent, H : hash_func, SND,RCV : channel(dy))\nplayed_by ED \ndef=\n\tlocal \n\t\tState : nat,\n\t\tPSUCCESS : message,\n\t\tMICAAA : message\n\n\tinit\n\t\tState  := 0\n\n\ttransition\n\n\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\tState' := 1 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') =|>\n\t\t\tState' := 3 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA')\n\n\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authentication_server_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AUSF \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse, EAPLoRaWANCN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationResponse.{NwkKey'}_SK) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANCN.EAPRQST.ED) \n\t\t\t\t\t\t\t\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') \n\t\t\t\t\t\t\t/\\ MICJR'=H(JoinEUI'.DevEUI'.DevNonce'.NwkKey) =|>\t\t\t\t\t\n\t\t\t\tState' := 2 /\\ MICJA':=H(JoinNonce'.NwkKey)\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\t\t\t\t\t\t\t/\\ request(AUSF,ED,auth_cn_ed,NwkKey)\n\t\t\t\t\t\t\t/\\ witness(AUSF,ED,auth_ed_cn,NwkKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole unified_data_management (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, K,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by UDM \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ SND(AuthenticationResponse.{NwkKey'}_SK)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_server (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, AppKey : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AAA \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tSessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') /\\ MICAAA' = H(JoinEUI'.DevEUI'.DevNonce'.AppKey) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\t\t\t\t\t\t\t/\\ secret(ED,auth_dn_ed,AppKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, JoinEUI, DevEUI : nat, K,AppKey,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\n\tdef=\n\t\tcomposition\t\n\t\t\tend_device(ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey,H,SND,RCV)\n\t\t\t/\\\n\t\t\tg_node_b(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\taccess_and_mobility_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tsession_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tauthentication_server_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\tunified_data_management(ED,GNB,AMF,SMF,AUSF,UDM,AAA,K,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\taaa_server(ED,GNB,AMF,SMF,AUSF,UDM,AAA,AppKey,H,SND,RCV)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole enviroment() \n\n\tdef=\n\n\t\tconst\t\n\t\t\ted,gnb,amf,smf,ausf,udm,aaa : agent,\n\t\t\tjoineui,deveui : nat,\n\t\t\th : hash_func,\n\t\t\tk,appkey,sk : symmetric_key,\n\t\t\tsnd,rcv\t: channel(dy),\n\t\t\t\n\t\t\tauth_cn_ed, auth_ed_cn, auth_dn_ed : protocol_id\n\n\t\tintruder_knowledge = {ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,h,k}\n\n\t\tcomposition\n\t\t\tsession(ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,k,appkey,sk,h,snd,rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n\tauthentication_on auth_ed_cn\n\tsecret(ed,auth_dn_ed,AppKey)\n\tauthentication_on auth_cn_ed\n\nend goal\n\nenviroment()\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "```hlpsl\nrole end_device (ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey : agent, H : hash_func, SND,RCV : channel(dy))\nplayed_by ED \ndef=\n\tlocal \n\t\tState : nat,\n\t\tPSUCCESS : message,\n\t\tMICAAA : message\n\n\tinit\n\t\tState  := 0\n\n\ttransition\n\n\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\tState' := 1 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') =|>\n\t\t\tState' := 3 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA')\n\n\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authentication_server_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AUSF \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse, EAPLoRaWANCN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationResponse.{NwkKey'}_SK) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANCN.EAPRQST.ED) \n\t\t\t\t\t\t\t\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') \n\t\t\t\t\t\t\t/\\ MICJR'=H(JoinEUI'.DevEUI'.DevNonce'.NwkKey) =|>\t\t\t\t\t\n\t\t\t\tState' := 2 /\\ MICJA':=H(JoinNonce'.NwkKey)\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\t\t\t\t\t\t\t/\\ request(AUSF,ED,auth_cn_ed,NwkKey)\n\t\t\t\t\t\t\t/\\ witness(AUSF,ED,auth_ed_cn,NwkKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole unified_data_management (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, K,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by UDM \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ SND(AuthenticationResponse.{NwkKey'}_SK)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_server (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, AppKey : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AAA \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tSessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') /\\ MICAAA' = H(JoinEUI'.DevEUI'.DevNonce'.AppKey) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\t\t\t\t\t\t\t/\\ secret(ED,auth_dn_ed,AppKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, JoinEUI, DevEUI : nat, K,AppKey,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\n\tdef=\n\t\tcomposition\t\n\t\t\tend_device(ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey,H,SND,RCV)\n\t\t\t/\\\n\t\t\tg_node_b(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\taccess_and_mobility_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tsession_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tauthentication_server_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\tunified_data_management(ED,GNB,AMF,SMF,AUSF,UDM,AAA,K,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\taaa_server(ED,GNB,AMF,SMF,AUSF,UDM,AAA,AppKey,H,SND,RCV)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole enviroment() \n\n\tdef=\n\n\t\tconst\t\n\t\t\ted,gnb,amf,smf,ausf,udm,aaa : agent,\n\t\t\tjoineui,deveui : nat,\n\t\t\th : hash_func,\n\t\t\tk,appkey,sk : symmetric_key,\n\t\t\tsnd,rcv\t: channel(dy),\n\t\t\t\n\t\t\tauth_cn_ed, auth_ed_cn, auth_dn_ed : protocol_id\n\n\t\tintruder_knowledge = {ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,h,k}\n\n\t\tcomposition\n\t\t\tsession(ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,k,appkey,sk,h,snd,rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n\tauthentication_on auth_ed_cn\n\tsecret(ed,auth_dn_ed,AppKey)\n\tauthentication_on auth_cn_ed\n\nend goal\n\nenviroment()\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/EKE2.hlpsl": [[true, "%% PROTOCOL*: EKE2\n%% VARIANT: EKE2 (with mutual authentication)\n%% PURPOSE: Encrypted key exchange with mutual authentication\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : A.{exp(g,X)}_K(A,B)\n%%\n%%     B computes master key MK\n%%     MK = H(A,B,exp(g,X),exp(g,Y),exp(g,XY))\n%%\n%% 2. B -> A : {exp(g,Y)}_K(A,B), H(MK,1)\n%%\n%%      A computes master key MK\n%%\n%% 3. A -> B : H(MK,2)\n%%\n%%      Session key K = H(MK,0)\n%%\n%% H : hash function\n%% K(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%         \n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%%\n%% NOTES: For information, this protocol is an example of  \n%% the proposition done in \n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html} showing that\n%% any secure AKE (Authentication Key Exchange) protocol can be easily \n%% improved to also provide MA (Mutual Authentication).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke2_Init(A,B : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n             \tSnd,Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State     : nat, \n\tX         : text, \n\tGY        : message,\n        MK_A,MK_B : message\n\n  const one,two,zero : text,\n        sec_i_MK_A : protocol_id,\n        mk_a,mk_b : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(start) =|> \n      State':= 1 /\\ X' := new()\n                 /\\ Snd(A.{exp(G,X')}_Kab) \n\n   2. State = 1  /\\ Rcv({GY'}_Kab.H(H(A.B.exp(G,X).GY'.exp(GY',X)).one)) =|> \n      State':= 2 /\\ MK_A' := H(A.B.exp(G,X).GY'.exp(GY',X))\n\t\t /\\ MK_B' := MK_A'\n\t\t /\\ Snd(H(H(MK_A').two)) \n\t\t /\\ secret(MK_A',sec_i_MK_A,{A,B})\n\t\t /\\ request(A,B,mk_a,MK_A')\n\t\t /\\ witness(A,B,mk_b,MK_B') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke2_Resp (B,A : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n                Snd,Rcv : channel(dy))\nplayed_by B\ndef=% Message authentication (G2)\n\n  local State     : nat, \n\tY         : text,\n\tGX        : message,\n        MK_A,MK_B : message\n\n  const one,two,zero : text,\n        sec_r_MK_B : protocol_id,\n        mk_a,mk_b : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(A.{GX'}_Kab) =|> \n      State':= 1 /\\ Y' := new()\n                 /\\ MK_B' := H(A.B.GX'.exp(G,Y').exp(GX',Y'))\n                 /\\ MK_A' := MK_B'\n\t\t /\\ Snd({exp(G,Y')}_Kab.H(H(MK_B').one))\n\t\t /\\ secret(MK_B',sec_r_MK_B,{A,B})% Message authentication (G2)\n\t \t /\\ witness(B,A,mk_a,MK_A')\n\n   2. State = 1  /\\ Rcv(H(H(MK_B).two)) =|> \n      State':= 2 /\\ request(B,A,mk_b,MK_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n              G: text,\n\t      H: hash_func,\n\t      Kab: symmetric_key) def=\n\n   local   SA,RA,SB,RB: channel(dy)\n\n   composition\n\n           eke2_Init(A,B,G,H,Kab,SA,RB)  /\\\n           eke2_Resp(B,A,G,H,Kab,SB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Message authentication (G2)\n\nrole environment() def=\n\n  const sec_i_MK_A, sec_r_MK_B  : protocol_id,\n        a,b,c       : agent,\n        kab,kai,kib : symmetric_key,\n        g           : text,\n        h           : hash_func,\n        mk_a,mk_b   : protocol_id\n\n  intruder_knowledge  = {a,b,c,kai,kib,g,h}\n\n  composition\n\n\tsession(a,b,g,h,kab) /\\\n\tsession(a,c,g,h,kai) /\\\n\tsession(c,b,g,h,kib)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  % secrecy_of MK\n  secrecy_of sec_i_MK_A, sec_r_MK_B\n\n  % Message authentication (G2)\n  % Eke2_Init authenticates Eke2_Resp on mk_a\n  authentication_on mk_a\n\n  % Message authentication (G2)\n  % Eke2_Resp authenticates Eke2_Init on mk_b\n  authentication_on mk_b\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL*: EKE2\n%% VARIANT: EKE2 (with mutual authentication)\n%% PURPOSE: Encrypted key exchange with mutual authentication\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : A.{exp(g,X)}_K(A,B)\n%%\n%%     B computes master key MK\n%%     MK = H(A,B,exp(g,X),exp(g,Y),exp(g,XY))\n%%\n%% 2. B -> A : {exp(g,Y)}_K(A,B), H(MK,1)\n%%\n%%      A computes master key MK\n%%\n%% 3. A -> B : H(MK,2)\n%%\n%%      Session key K = H(MK,0)\n%%\n%% H : hash function\n%% K(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%         \n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%%\n%% NOTES: For information, this protocol is an example of  \n%% the proposition done in \n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html} showing that\n%% any secure AKE (Authentication Key Exchange) protocol can be easily \n%% improved to also provide MA (Mutual Authentication).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke2_Init(A,B : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n             \tSnd,Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State     : nat, \n\tX         : text, \n\tGY        : message,\n        MK_A,MK_B : message\n\n  const one,two,zero : text,\n        sec_i_MK_A : protocol_id,\n        mk_a,mk_b : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(start) =|> \n      State':= 1 /\\ X' := new()\n                 /\\ Snd(A.{exp(G,X')}_Kab) \n\n   2. State = 1  /\\ Rcv({GY'}_Kab.H(H(A.B.exp(G,X).GY'.exp(GY',X)).one)) =|> \n      State':= 2 /\\ MK_A' := H(A.B.exp(G,X).GY'.exp(GY',X))\n\t\t /\\ MK_B' := MK_A'\n\t\t /\\ Snd(H(H(MK_A').two)) \n\t\t /\\ secret(MK_A',sec_i_MK_A,{A,B})\n\t\t /\\ request(A,B,mk_a,MK_A')\n\t\t /\\ witness(A,B,mk_b,MK_B') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke2_Resp (B,A : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n                Snd,Rcv : channel(dy))\nplayed_by B\ndef=% Message authentication (G2)\n\n  local State     : nat, \n\tY         : text,\n\tGX        : message,\n        MK_A,MK_B : message\n\n  const one,two,zero : text,\n        sec_r_MK_B : protocol_id,\n        mk_a,mk_b : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(A.{GX'}_Kab) =|> \n      State':= 1 /\\ Y' := new()\n                 /\\ MK_B' := H(A.B.GX'.exp(G,Y').exp(GX',Y'))\n                 /\\ MK_A' := MK_B'\n\t\t /\\ Snd({exp(G,Y')}_Kab.H(H(MK_B').one))\n\t\t /\\ secret(MK_B',sec_r_MK_B,{A,B})% Message authentication (G2)\n\t \t /\\ witness(B,A,mk_a,MK_A')\n\n   2. State = 1  /\\ Rcv(H(H(MK_B).two)) =|> \n      State':= 2 /\\ request(B,A,mk_b,MK_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n              G: text,\n\t      H: hash_func,\n\t      Kab: symmetric_key) def=\n\n   local   SA,RA,SB,RB: channel(dy)\n\n   composition\n\n           eke2_Init(A,B,G,H,Kab,SA,RB)  /\\\n           eke2_Resp(B,A,G,H,Kab,SB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Message authentication (G2)\n\nrole environment() def=\n\n  const sec_i_MK_A, sec_r_MK_B  : protocol_id,\n        a,b,c       : agent,\n        kab,kai,kib : symmetric_key,\n        g           : text,\n        h           : hash_func,\n        mk_a,mk_b   : protocol_id\n\n  intruder_knowledge  = {a,b,c,kai,kib,g,h}\n\n  composition\n\n\tsession(a,b,g,h,kab) /\\\n\tsession(a,c,g,h,kai) /\\\n\tsession(c,b,g,h,kib)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  % secrecy_of MK\n  secrecy_of sec_i_MK_A, sec_r_MK_B\n\n  % Message authentication (G2)\n  % Eke2_Init authenticates Eke2_Resp on mk_a\n  authentication_on mk_a\n\n  % Message authentication (G2)\n  % Eke2_Resp authenticates Eke2_Init on mk_b\n  authentication_on mk_b\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/EVauthenticate.hlpsl": [[true, "role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SND,RCV) role_EV(\n  EV,GNB,SMF                 : agent,\n  C1                         : text,\n  H,PUF1,PRNG                : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by EV def=\n  \n  local\n    State         :nat,\n\tN2,N3         :text,\n\tR1,N2M,N3M    :hash(text),\n\tSK            :hash(hash(text).hash(text).text),\n\tZ             :message\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(N2') =|>\n     State' := 2 /\\ N2M' := PRNG(N2') /\\ R1':= PUF1(C1) /\\ N3' := new() /\\ SND({R1'.N3'}_N2M')\n\t\t\t\t /\\ witness(EV,SMF,ev_smf_r1,R1') /\\ witness(EV,SMF,ev_smf_n3,N3')\n  2. State = 2 /\\ RCV(Z') /\\ R1 = xor(Z',N3)=|>\n     State' := 4 /\\ SK' := H(N2M.N3)\n\t\t\t\t /\\ request(EV,GNB,gnb_ev_n2,N2)\n\t\t\t\t /\\ request(SMF,EV,smf_ev_z,Z')\n\t\t\t\t /\\ secret(sk,sk,{EV,SMF})\n\nend role\n\nrole role_GNB(\n  EV,GNB,SMF                    : agent,\n  C2                            : text,\n  H,PUF2                        : hash_func,\n  SND,RCV                       : channel(dy))\nplayed_by GNB def=\n  \n  local\n    State             :nat,\n\tN1,N2             :text,\n\tR2                :hash(text)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ N1' := new() /\\ R2':= PUF2(C2) /\\ SND({N1'}_R2')\n\t             /\\ witness(GNB,SMF,gnb_smf_n1,N1)\n  2. State = 2 /\\ RCV({N2'}_N1) =|>\n     State' := 4 /\\ SND(N2')\n\t             /\\ witness(GNB,SMF,smf_gnb_n2,N2') \n\t\t\t\t /\\ witness(GNB,EV,gnb_ev_n2,N2')\n\nend role\n\n\n\nrole role_SMF(\n  EV,GNB,SMF                 : agent,\n  C1,C2                      : text,\n  H,PUF1,PUF2,PRNG           : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by SMF def=\n  \n  local\n    State                     :nat,\n\tN1,N2,N3               :text,\n\tR1,R2,N2M,N3M,N4M             :hash(text),\n\tSK                        :hash(hash(text).hash(text).text),\n\tZ                         :message\n\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV({N1'}_R2') /\\ R2' = PUF2(C2) =|>\n     State' := 3 /\\ N2' := new() /\\ N2M' := PRNG(N2') /\\ SND({N2'}_N1')\n\t\t\t\t /\\ witness(SMF,GNB,smf_gnb_n2,N2')\n  2. State = 3 /\\ RCV({R1'.N3'}_N2M) /\\  R1' = PUF1(C1) =|>\n     State' := 5 /\\ SK' := H(N2M.N3') /\\ Z' := xor(R1',N3') /\\ SND(Z')\n\t\t\t\t /\\ request(SMF,GNB,gnb_smf_n1,N1) /\\ witness(SMF,EV,smf_ev_z,Z') \n\t\t\t\t /\\ request(EV,SMF,ev_smf_n3,N3') /\\ request(EV,SMF,ev_smf_r1,R1') \n\t\t\t\t /\\ secret(r1,r1,{EV,SMF})/\\ secret(r2,r2,{GNB,SMF})/\\ secret(n1,n1,{GNB,SMF})\n\t\t\t\t /\\ secret(n2m,n2m,{EV,SMF})/\\ secret(n3,n3,{EV,SMF})\n\n\nend role\n\n\nrole session(\n  EV,GNB,SMF               : agent,\n  C1,C2                    : text,\n  H,PUF1,PUF2,PRNG         : hash_func)\ndef=\n  local SEV,SSMF,SGNB,REV,RSMF,RGNB : channel(dy)\n  \n  composition\n    role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SEV,REV) /\\ role_GNB(EV,GNB,SMF,C2,H,PUF2,SGNB,RGNB) /\\ role_SMF(EV,GNB,SMF,C1,C2,H,PUF1,PUF2,PRNG,SSMF,RSMF) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    n1,n2m,n3,r1,r2,ev_smf_r1,ev_smf_n3,gnb_smf_n1,smf_gnb_n2,gnb_ev_n2,smf_ev_z   : protocol_id,\n    sm,gw,sp                                            : agent,\n    c1,c2,sk0                                           : text,\n    h,puf1,puf2,puf3,puf4,prng1,prng2                                    : hash_func\n  intruder_knowledge = {sm,gw,sp,h,sk0} \n  \n  composition\n    session(sm,gw,sp,c1,c2,h,puf1,puf2,prng1) /\\ session(sm,gw,sp,c1,c2,h,puf3,puf4,prng2)\n\nend role\n\ngoal \n  secrecy_of sk\n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of n1\n  secrecy_of n2m\n  secrecy_of n3\n  authentication_on ev_smf_r1\n  authentication_on ev_smf_n3\n  authentication_on gnb_smf_n1\n  authentication_on smf_gnb_n2\n  authentication_on gnb_ev_n2\n  authentication_on smf_ev_z\n\nend goal\n\nenvironment()", "```hlpsl\nrole_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SND,RCV) role_EV(\n  EV,GNB,SMF                 : agent,\n  C1                         : text,\n  H,PUF1,PRNG                : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by EV def=\n  \n  local\n    State         :nat,\n\tN2,N3         :text,\n\tR1,N2M,N3M    :hash(text),\n\tSK            :hash(hash(text).hash(text).text),\n\tZ             :message\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(N2') =|>\n     State' := 2 /\\ N2M' := PRNG(N2') /\\ R1':= PUF1(C1) /\\ N3' := new() /\\ SND({R1'.N3'}_N2M')\n\t\t\t\t /\\ witness(EV,SMF,ev_smf_r1,R1') /\\ witness(EV,SMF,ev_smf_n3,N3')\n  2. State = 2 /\\ RCV(Z') /\\ R1 = xor(Z',N3)=|>\n     State' := 4 /\\ SK' := H(N2M.N3)\n\t\t\t\t /\\ request(EV,GNB,gnb_ev_n2,N2)\n\t\t\t\t /\\ request(SMF,EV,smf_ev_z,Z')\n\t\t\t\t /\\ secret(sk,sk,{EV,SMF})\n\nend role\n\nrole role_GNB(\n  EV,GNB,SMF                    : agent,\n  C2                            : text,\n  H,PUF2                        : hash_func,\n  SND,RCV                       : channel(dy))\nplayed_by GNB def=\n  \n  local\n    State             :nat,\n\tN1,N2             :text,\n\tR2                :hash(text)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ N1' := new() /\\ R2':= PUF2(C2) /\\ SND({N1'}_R2')\n\t             /\\ witness(GNB,SMF,gnb_smf_n1,N1)\n  2. State = 2 /\\ RCV({N2'}_N1) =|>\n     State' := 4 /\\ SND(N2')\n\t             /\\ witness(GNB,SMF,smf_gnb_n2,N2') \n\t\t\t\t /\\ witness(GNB,EV,gnb_ev_n2,N2')\n\nend role\n\n\n\nrole role_SMF(\n  EV,GNB,SMF                 : agent,\n  C1,C2                      : text,\n  H,PUF1,PUF2,PRNG           : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by SMF def=\n  \n  local\n    State                     :nat,\n\tN1,N2,N3               :text,\n\tR1,R2,N2M,N3M,N4M             :hash(text),\n\tSK                        :hash(hash(text).hash(text).text),\n\tZ                         :message\n\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV({N1'}_R2') /\\ R2' = PUF2(C2) =|>\n     State' := 3 /\\ N2' := new() /\\ N2M' := PRNG(N2') /\\ SND({N2'}_N1')\n\t\t\t\t /\\ witness(SMF,GNB,smf_gnb_n2,N2')\n  2. State = 3 /\\ RCV({R1'.N3'}_N2M) /\\  R1' = PUF1(C1) =|>\n     State' := 5 /\\ SK' := H(N2M.N3') /\\ Z' := xor(R1',N3') /\\ SND(Z')\n\t\t\t\t /\\ request(SMF,GNB,gnb_smf_n1,N1) /\\ witness(SMF,EV,smf_ev_z,Z') \n\t\t\t\t /\\ request(EV,SMF,ev_smf_n3,N3') /\\ request(EV,SMF,ev_smf_r1,R1') \n\t\t\t\t /\\ secret(r1,r1,{EV,SMF})/\\ secret(r2,r2,{GNB,SMF})/\\ secret(n1,n1,{GNB,SMF})\n\t\t\t\t /\\ secret(n2m,n2m,{EV,SMF})/\\ secret(n3,n3,{EV,SMF})\n\n\nend role\n\n\nrole session(\n  EV,GNB,SMF               : agent,\n  C1,C2                    : text,\n  H,PUF1,PUF2,PRNG         : hash_func)\ndef=\n  local SEV,SSMF,SGNB,REV,RSMF,RGNB : channel(dy)\n  \n  composition\n    role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SEV,REV) /\\ role_GNB(EV,GNB,SMF,C2,H,PUF2,SGNB,RGNB) /\\ role_SMF(EV,GNB,SMF,C1,C2,H,PUF1,PUF2,PRNG,SSMF,RSMF) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    n1,n2m,n3,r1,r2,ev_smf_r1,ev_smf_n3,gnb_smf_n1,smf_gnb_n2,gnb_ev_n2,smf_ev_z   : protocol_id,\n    sm,gw,sp                                            : agent,\n    c1,c2,sk0                                           : text,\n    h,puf1,puf2,puf3,puf4,prng1,prng2                                    : hash_func\n  intruder_knowledge = {sm,gw,sp,h,sk0} \n  \n  composition\n    session(sm,gw,sp,c1,c2,h,puf1,puf2,prng1) /\\ session(sm,gw,sp,c1,c2,h,puf3,puf4,prng2)\n\nend role\n\ngoal \n  secrecy_of sk\n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of n1\n  secrecy_of n2m\n  secrecy_of n3\n  authentication_on ev_smf_r1\n  authentication_on ev_smf_n3\n  authentication_on gnb_smf_n1\n  authentication_on smf_gnb_n2\n  authentication_on gnb_ev_n2\n  authentication_on smf_ev_z\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/GetServAuth.hlpsl": [[true, "role role_C(C:agent, W:agent, QR:text, Kc:symmetric_key, Y:text, SND, RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tN:nat, N':nat, F:hash_func\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N':=new() /\\ secret(N',sec_1,{C,W}) /\\ SND({C.QR.N'.Y'}_Kc)\n\t\t2. State=1 /\\ RCV({C.F(QR.N').Y'}_Kc) =|> State':=2 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N' := new() /\\ secret(N',sec_1,{C,W})\nend role\n\nrole role_W(C:agent, W:agent, Kc:symmetric_key, QR:text, RCV:channel(dy))\nplayed_by W\ndef=\n\tlocal\n\t\tN':nat, N'1:nat, F:hash_func, Y':text, Y'1:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.QR.N'.Y'}_Kc) =|> State':=1 /\\ secret(Y',sec_2,{C,W}) /\\ secret(N',sec_1,{C,W}) /\\ SND({C.F(QR.N').Y'}_Kc)\nend role\n\nrole session1(Y:text, QR:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session2(Y:text, QR:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session3(QR:text, Y:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tsec_1:protocol_id, y:text, i:agent, hash_0:hash_func, qr:text, client:agent, miner:agent, kc:symmetric_key, sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(qr,y,i,miner,kc) /\\ session2(y,qr,client,i,kc) /\\ session1(y,qr,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()", "```hlpsl\nrole role_C(C:agent, W:agent, QR:text, Kc:symmetric_key, Y:text, SND, RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tN:nat, N':nat, F:hash_func\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N':=new() /\\ secret(N',sec_1,{C,W}) /\\ SND({C.QR.N'.Y'}_Kc)\n\t\t2. State=1 /\\ RCV({C.F(QR.N').Y'}_Kc) =|> State':=2 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N' := new() /\\ secret(N',sec_1,{C,W})\nend role\n\nrole role_W(C:agent, W:agent, Kc:symmetric_key, QR:text, RCV:channel(dy))\nplayed_by W\ndef=\n\tlocal\n\t\tN':nat, N'1:nat, F:hash_func, Y':text, Y'1:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.QR.N'.Y'}_Kc) =|> State':=1 /\\ secret(Y',sec_2,{C,W}) /\\ secret(N',sec_1,{C,W}) /\\ SND({C.F(QR.N').Y'}_Kc)\nend role\n\nrole session1(Y:text, QR:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session2(Y:text, QR:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session3(QR:text, Y:text, C:agent, W:agent, Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND1, RCV2, SND2, RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,QR,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tsec_1:protocol_id, y:text, i:agent, hash_0:hash_func, qr:text, client:agent, miner:agent, kc:symmetric_key, sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(qr,y,i,miner,kc) /\\ session2(y,qr,client,i,kc) /\\ session1(y,qr,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/h.530-fix.hlpsl": [[true, "role mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key1,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key2,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,MT})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(VGK,MT,key1,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ request(VGK,MT,key2,Key)\n                /\\ secret(Key,sec_v_Key,{MT,VGK})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf                    : agent,\n    f                          : hash_func,\n    key1,key2                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text,\n    i                          : agent\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf,nil,g,i}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  authentication_on key1\n  authentication_on key2\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key1,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key2,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,MT})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(VGK,MT,key1,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ request(VGK,MT,key2,Key)\n                /\\ secret(Key,sec_v_Key,{MT,VGK})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf                    : agent,\n    f                          : hash_func,\n    key1,key2                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text,\n    i                          : agent\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf,nil,g,i}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  authentication_on key1\n  authentication_on key2\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/hash_n_single.hlpsl": [[true, "role user (\n    U,S : agent,\n    SU,RU : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Nah4      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\t       /\\ witness(U,S,user_server_nah4,Nah4')\n\t\t\t   \nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ request(S,U,user_server_nah4,F(F(F(F(PW)))))\n\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s,i      : agent,\n    f            : hash_func,\n    user_server_nah4     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,i,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah4\n\nend goal\n\n\nenvironment()", "```hlpsl\nrole user (\n    U,S : agent,\n    SU,RU : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Nah4      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\t       /\\ witness(U,S,user_server_nah4,Nah4')\n\t\t\t   \nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ request(S,U,user_server_nah4,F(F(F(F(PW)))))\n\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s,i      : agent,\n    f            : hash_func,\n    user_server_nah4     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,i,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah4\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/IIOT.hlpsl": [[true, "%IIoT\n\nrole nodeU (U,Gw: agent,\n            Hmac: hash_func,\n       Qca,Qg,Qu: public_key,\n       Dg,Du,Kug: symmetric_key,\n         SND,RCV: channel (dy))\nplayed_by U def=\nlocal\nState: nat,\nIdu,Idg,Certu,Certg,Su,Sg,Ts0,\nTs1,Lt0,Lt1,N5,Au,Ag,H4:text,\nM5: message\ninit State:= 0\ntransition\n1. State = 0 /\\ RCV(start) =|>\n  State':= 1 /\\ N5' := new()\n             /\\ Ag' := {Idg.Certg.Sg.Ts0.Lt0}_Qca\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ M5' := {Idg.N5.Au.H4}_Qg\n             /\\ SND(M5')\n             /\\ secret({Idg,N5},sub1,{Gw,U})\nend role\n\nrole gateway (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key,\n           SGw,RCV: channel (dy))\nplayed_by Gw def=\nlocal\nState :nat,\nIdu,Idg,Certu,Su,\nTs1,Lt1,N5,Au,H4:text,\nM5: message\ninit State:= 1\ntransition\n1. State = 1 /\\ RCV(M5') =|>\n  State':= 2 /\\ M5' := {Idg.N5'.Au'.H4'}_Dg\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5'.Au')\n             /\\ request(Gw,U,nodeU_gateway_n5,N5')\n             /\\ witness(Gw,U,nodeU_gateway_lt1,Lt1) \nend role\n\nrole session (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key)\ndef=\nlocal SU,RU,SGw,RGw: channel(dy)\ncomposition\n  nodeU(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SU,RU)\n/\\gateway(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SGw,RGw)\nend role\n\nrole environment ()\ndef=\nconst    nodeU,gateway: agent,\n             qca,qg,qu: public_key,\ndg,du,kug,dgi,dui,kugi:symmetric_key,\nidu,idg,certu,certg,su,sg,\nts0,ts1,lt0,lt1,n5,au,ag,h4: text,\nhmac: hash_func,\nnodeU_gateway_n5,nodeU_gateway_lt1,sub1: protocol_id\nintruder_knowledge = {nodeU,gateway,hmac,dgi,dui,qca,qg,qu}\ncomposition\n  session(nodeU,gateway,hmac,qca,qg,qu,dg,du,kug)\n/\\session(nodeU,i,hmac,qca,qg,qu,dgi,dui,kugi)\n/\\session(i,gateway,hmac,qca,qg,qu,dgi,dui,kugi)\nend role\n\ngoal\nsecrecy_of sub1\nauthentication_on nodeU_gateway_n5\nauthentication_on nodeU_gateway_lt1\nend goal\nenvironment ()", "```hlpsl\n%IIoT\n\nrole nodeU (U,Gw: agent,\n            Hmac: hash_func,\n       Qca,Qg,Qu: public_key,\n       Dg,Du,Kug: symmetric_key,\n         SND,RCV: channel (dy))\nplayed_by U def=\nlocal\nState: nat,\nIdu,Idg,Certu,Certg,Su,Sg,Ts0,\nTs1,Lt0,Lt1,N5,Au,Ag,H4:text,\nM5: message\ninit State:= 0\ntransition\n1. State = 0 /\\ RCV(start) =|>\n  State':= 1 /\\ N5' := new()\n             /\\ Ag' := {Idg.Certg.Sg.Ts0.Lt0}_Qca\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ M5' := {Idg.N5.Au.H4}_Qg\n             /\\ SND(M5')\n             /\\ secret({Idg,N5},sub1,{Gw,U})\nend role\n\nrole gateway (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key,\n           SGw,RCV: channel (dy))\nplayed_by Gw def=\nlocal\nState :nat,\nIdu,Idg,Certu,Su,\nTs1,Lt1,N5,Au,H4:text,\nM5: message\ninit State:= 1\ntransition\n1. State = 1 /\\ RCV(M5') =|>\n  State':= 2 /\\ M5' := {Idg.N5'.Au'.H4'}_Dg\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5'.Au')\n             /\\ request(Gw,U,nodeU_gateway_n5,N5')\n             /\\ witness(Gw,U,nodeU_gateway_lt1,Lt1) \nend role\n\nrole session (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key)\ndef=\nlocal SU,RU,SGw,RGw: channel(dy)\ncomposition\n  nodeU(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SU,RU)\n/\\gateway(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SGw,RGw)\nend role\n\nrole environment ()\ndef=\nconst    nodeU,gateway: agent,\n             qca,qg,qu: public_key,\ndg,du,kug,dgi,dui,kugi:symmetric_key,\nidu,idg,certu,certg,su,sg,\nts0,ts1,lt0,lt1,n5,au,ag,h4: text,\nhmac: hash_func,\nnodeU_gateway_n5,nodeU_gateway_lt1,sub1: protocol_id\nintruder_knowledge = {nodeU,gateway,hmac,dgi,dui,qca,qg,qu}\ncomposition\n  session(nodeU,gateway,hmac,qca,qg,qu,dg,du,kug)\n/\\session(nodeU,i,hmac,qca,qg,qu,dgi,dui,kugi)\n/\\session(i,gateway,hmac,qca,qg,qu,dgi,dui,kugi)\nend role\n\ngoal\nsecrecy_of sub1\nauthentication_on nodeU_gateway_n5\nauthentication_on nodeU_gateway_lt1\nend goal\nenvironment ()\n```"]], "HLPSL-1/AKS.hlpsl": [[true, "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,sec_a1,{OBU1,OBU2,SN}) /\\ secret(R1,r1,{OBU1,OBU2,SN})\n\nend role_OBU1\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,SN,s_o2_hs2,Hs2')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\ secret(A2,sec_a2,{OBU1,OBU2,SN}) /\\ witness(OBU2,OBU1,o2_o1_h21,H21') /\\ request(OBU2,SN,s_o2_hs2,Hs2') /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role_OBU2\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SND1,SND2                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND1(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role_SN\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,RO,SS,RS,RS1 : channel(dy)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS1) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    sec_a1,sec_a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2,r1,r2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of sec_a1\n  secrecy_of sec_a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()", "```hlpsl\nrole role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,sec_a1,{OBU1,OBU2,SN}) /\\ secret(R1,r1,{OBU1,OBU2,SN})\n\nend role_OBU1\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,SN,s_o2_hs2,Hs2')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\ secret(A2,sec_a2,{OBU1,OBU2,SN}) /\\ witness(OBU2,OBU1,o2_o1_h21,H21') /\\ request(OBU2,SN,s_o2_hs2,Hs2') /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role_OBU2\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SND1,SND2                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND1(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role_SN\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,RO,SS,RS,RS1 : channel(dy)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS1) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    sec_a1,sec_a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2,r1,r2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of sec_a1\n  secrecy_of sec_a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/IKEv2-MAC.hlpsl": [[true, "role alice(A, B: agent, G: text, F: hash_func, PSK: symmetric_key, SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, Nr: text, KEr: message, SK: hash(text.text.text.message), State: nat, AUTH_B: message\n\n  const sk2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has indeed sent the same nonce in SAr1, and then sends the first message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B, A: agent, G: text, F: hash_func, PSK: symmetric_key, SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, Nr, DHY: text, SK: hash(text.text.text.message), KEi: message, State: nat, AUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk1,AUTH_A')\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A: agent, B: agent, PSK: symmetric_key, G: text, F: hash_func)\ndef=\n\n  local RA, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,RA,RB)\n\t/\\ bob(B,A,G,F,PSK,RB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : protocol_id,\n        a, b, i          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func,\n\tsec_a_SK, sec_b_SK : protocol_id\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi}\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()", "```hlpsl\nrole alice(A, B: agent, G: text, F: hash_func, PSK: symmetric_key, SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, Nr: text, KEr: message, SK: hash(text.text.text.message), State: nat, AUTH_B: message\n\n  const sk2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has indeed sent the same nonce in SAr1, and then sends the first message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B, A: agent, G: text, F: hash_func, PSK: symmetric_key, SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, Nr, DHY: text, SK: hash(text.text.text.message), KEi: message, State: nat, AUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk1,AUTH_A')\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A: agent, B: agent, PSK: symmetric_key, G: text, F: hash_func)\ndef=\n\n  local RA, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,RA,RB)\n\t/\\ bob(B,A,G,F,PSK,RB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : protocol_id,\n        a, b, i          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func,\n\tsec_a_SK, sec_b_SK : protocol_id\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi}\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()\n```"]], "HLPSL-1/InitialAuth.hlpsl": [[true, "role Newnode(Newnode:agent,ClusterAdmin:agent,AuthRequest:text,Knc:symmetric_key,Kn:public_key,SND,RCV:channel(dy))\nplayed_by Newnode\ndef=\n\tlocal\n\t\tT:nat,Challenge:text,Uniqid:text,Solution:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({AuthRequest}_Knc)\n\t\t2. State=1 /\\ RCV({Challenge'.T'}_Knc) =|> State':=2 /\\ Solution':=new() /\\ SND({Solution'.inv(Kn)}_Knc)\n\t\t4. State=2 /\\ RCV({Uniqid'.Success'}_inv(Kn)) =|> State':=3 /\\ witness(Newnode,ClusterAdmin,auth_1,AuthRequest)\nend role\n\nrole ClusterAdmin(Newnode:agent,ClusterAdmin:agent,OtherClusterAdmins:agent,Kn:public_key,Knc:symmetric_key,Kcc:symmetric_key,T:text,SND,RCV:channel(dy))\nplayed_by ClusterAdmin\ndef=\n\tlocal\n\t\tState:nat,AuthRequest:text,Challenge:text,Solution:text,Uniqid:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({AuthRequest'}_Knc) =|> State':=1 /\\ Challenge':=new() /\\ SND({Challenge'.T}_Knc)\n\t\t3. State=1 /\\ RCV({Solution'.inv(Kn)}_Knc) =|> State':=2 /\\ Success':=new() /\\ Uniqid':=new() /\\ request(ClusterAdmin,Newnode,auth_1,AuthRequest) /\\ SND({Uniqid'.Success'}_inv(Kn)) /\\ SND({Uniqid'}_Kcc)\nend role\n\nrole OtherClusterAdmins(OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key,SND,RCV:channel(dy))\nplayed_by OtherClusterAdmins\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t5. State=0 /\\ RCV({Uniqid'}_Kcc) =|> State':=1\nend role\n\nrole session1(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole session2(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkcc:symmetric_key,clusteradmin:agent,knc:symmetric_key,newnode:agent,authrequest:text,hash_0:hash_func,otherclusteradmins:agent,kn:public_key,kic:symmetric_key,t:text\n\tintruder_knowledge = {newnode,clusteradmin,kic,kn}\n\tcomposition\n\t\tsession2(t,authrequest,otherclusteradmins,i,clusteradmin,kn,kcc,kic) /\\ session1(t,authrequest,otherclusteradmins,newnode,clusteradmin,kn,kcc,knc)\nend role\n\ngoal\n\tauthentication_on auth_1\nend goal\n\nenvironment()", "```hlpsl\nrole Newnode(Newnode:agent,ClusterAdmin:agent,AuthRequest:text,Knc:symmetric_key,Kn:public_key,SND,RCV:channel(dy))\nplayed_by Newnode\ndef=\n\tlocal\n\t\tT:nat,Challenge:text,Uniqid:text,Solution:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({AuthRequest}_Knc)\n\t\t2. State=1 /\\ RCV({Challenge'.T'}_Knc) =|> State':=2 /\\ Solution':=new() /\\ SND({Solution'.inv(Kn)}_Knc)\n\t\t4. State=2 /\\ RCV({Uniqid'.Success'}_inv(Kn)) =|> State':=3 /\\ witness(Newnode,ClusterAdmin,auth_1,AuthRequest)\nend role\n\nrole ClusterAdmin(Newnode:agent,ClusterAdmin:agent,OtherClusterAdmins:agent,Kn:public_key,Knc:symmetric_key,Kcc:symmetric_key,T:text,SND,RCV:channel(dy))\nplayed_by ClusterAdmin\ndef=\n\tlocal\n\t\tState:nat,AuthRequest:text,Challenge:text,Solution:text,Uniqid:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({AuthRequest'}_Knc) =|> State':=1 /\\ Challenge':=new() /\\ SND({Challenge'.T}_Knc)\n\t\t3. State=1 /\\ RCV({Solution'.inv(Kn)}_Knc) =|> State':=2 /\\ Success':=new() /\\ Uniqid':=new() /\\ request(ClusterAdmin,Newnode,auth_1,AuthRequest) /\\ SND({Uniqid'.Success'}_inv(Kn)) /\\ SND({Uniqid'}_Kcc)\nend role\n\nrole OtherClusterAdmins(OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key,SND,RCV:channel(dy))\nplayed_by OtherClusterAdmins\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t5. State=0 /\\ RCV({Uniqid'}_Kcc) =|> State':=1\nend role\n\nrole session1(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole session2(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkcc:symmetric_key,clusteradmin:agent,knc:symmetric_key,newnode:agent,authrequest:text,hash_0:hash_func,otherclusteradmins:agent,kn:public_key,kic:symmetric_key,t:text\n\tintruder_knowledge = {newnode,clusteradmin,kic,kn}\n\tcomposition\n\t\tsession2(t,authrequest,otherclusteradmins,i,clusteradmin,kn,kcc,kic) /\\ session1(t,authrequest,otherclusteradmins,newnode,clusteradmin,kn,kcc,knc)\nend role\n\ngoal\n\tauthentication_on auth_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/IoT-HAN.hlpsl": [[true, "%Formal Verification of RLAS\nrole nodeU (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by U def= \nlocal \nState\t\t\t\t   :nat,\nIdu,Certu,Lt,Idca,Nv,Certv,Nu,Idv  :text, \nToken1,Token2,Z1,Z2\t           :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(start)  =|>\n  State':= 1  /\\ Nu' := new()\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu'.Idu.Idca)\n\t      /\\ Z1' := {Certu.Lt.Nu'.Idu.Idca}_Ks1\n              /\\ SND(Token1',Z1')\n              /\\ secret ({Nu',Idu},sub1,{U,V})\n\n\n2. State = 1  /\\ RCV(Token2',Z2') =|>\n   State':= 2 /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ request(U,V,nodeV_nodeU_lt,Lt)\n              /\\ witness(U,V,nodeU_nodeV_lt,Lt)\nend role\n\nrole nodeV (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by V def= \nlocal \nState\t\t\t           :nat,\nIdu,Certu,Lt,Idca,Nv,Nu,Certv,Idv,E:text, \nToken1,Token2,Z1,Z2\t\t   :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(Token1',Z1')  =|>\n   State':= 1 /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n              /\\ Nv' := new()\n              /\\ Key2' := xor(Nv',xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv'.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv'.Idv.Idca}_Key2'\n              /\\ SND (Token2',Z2')\n              /\\ secret ({Nv',Idv},sub2,{U,V})\n              /\\ witness(V,U,nodeV_nodeU_lt,Lt)\n              /\\ request(V,U,nodeU_nodeV_lt,Lt)\nend role\n\nrole session (U,V: agent,\n\t     Hash: hash_func,\n\t      Qca: public_key,\n    Key1,Key2,Ks1: symmetric_key)\ndef=\nlocal SU,RU,SV,RV: channel(dy)\ncomposition\n   nodeU(U,V,Hash,Qca,Key1,Key2,Ks1,SU,RU) \n/\\ nodeV(U,V,Hash,Qca,Key1,Key2,Ks1,SV,RV)\nend role\n\nrole environment ()\ndef=\nconst nodeU,nodeV: agent,\nqca: public_key,\nkey1,key2,ks1,key1i,key2i,ks1i: symmetric_key,\nidu,certu,lt,idca,e,nv,nu,certv,idv: text,\nh: hash_func,\nnodeU_nodeV_lt,nodeV_nodeU_lt,sub1,sub2: protocol_id\n\nintruder_knowledge={nodeU,nodeV,h,key1i,key2i,ks1i,qca}\n\ncomposition\nsession(nodeU,nodeV,h,qca,key1,key2,ks1)\n/\\session(nodeU,i,h,qca,key1i,key2i,ks1i)\n/\\session(i,nodeV,h,qca,key1i,key2i,ks1i)     \n\nend role\n\ngoal\nsecrecy_of sub1\nsecrecy_of sub2\nauthentication_on nodeU_nodeV_lt\nauthentication_on nodeV_nodeU_lt\nend goal\n\nenvironment ()", "```hlpsl\n%Formal Verification of RLAS\nrole nodeU (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by U def= \nlocal \nState\t\t\t\t   :nat,\nIdu,Certu,Lt,Idca,Nv,Certv,Nu,Idv  :text, \nToken1,Token2,Z1,Z2\t           :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(start)  =|>\n  State':= 1  /\\ Nu' := new()\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu'.Idu.Idca)\n\t      /\\ Z1' := {Certu.Lt.Nu'.Idu.Idca}_Ks1\n              /\\ SND(Token1',Z1')\n              /\\ secret ({Nu',Idu},sub1,{U,V})\n\n\n2. State = 1  /\\ RCV(Token2',Z2') =|>\n   State':= 2 /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ request(U,V,nodeV_nodeU_lt,Lt)\n              /\\ witness(U,V,nodeU_nodeV_lt,Lt)\nend role\n\nrole nodeV (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by V def= \nlocal \nState\t\t\t           :nat,\nIdu,Certu,Lt,Idca,Nv,Nu,Certv,Idv,E:text, \nToken1,Token2,Z1,Z2\t\t   :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(Token1',Z1')  =|>\n   State':= 1 /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n              /\\ Nv' := new()\n              /\\ Key2' := xor(Nv',xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv'.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv'.Idv.Idca}_Key2'\n              /\\ SND (Token2',Z2')\n              /\\ secret ({Nv',Idv},sub2,{U,V})\n              /\\ witness(V,U,nodeV_nodeU_lt,Lt)\n              /\\ request(V,U,nodeU_nodeV_lt,Lt)\nend role\n\nrole session (U,V: agent,\n\t     Hash: hash_func,\n\t      Qca: public_key,\n    Key1,Key2,Ks1: symmetric_key)\ndef=\nlocal SU,RU,SV,RV: channel(dy)\ncomposition\n   nodeU(U,V,Hash,Qca,Key1,Key2,Ks1,SU,RU) \n/\\ nodeV(U,V,Hash,Qca,Key1,Key2,Ks1,SV,RV)\nend role\n\nrole environment ()\ndef=\nconst nodeU,nodeV: agent,\nqca: public_key,\nkey1,key2,ks1,key1i,key2i,ks1i: symmetric_key,\nidu,certu,lt,idca,e,nv,nu,certv,idv: text,\nh: hash_func,\nnodeU_nodeV_lt,nodeV_nodeU_lt,sub1,sub2: protocol_id\n\nintruder_knowledge={nodeU,nodeV,h,key1i,key2i,ks1i,qca}\n\ncomposition\nsession(nodeU,nodeV,h,qca,key1,key2,ks1)\n/\\session(nodeU,i,h,qca,key1i,key2i,ks1i)\n/\\session(i,nodeV,h,qca,key1i,key2i,ks1i)     \n\nend role\n\ngoal\nsecrecy_of sub1\nsecrecy_of sub2\nauthentication_on nodeU_nodeV_lt\nauthentication_on nodeV_nodeU_lt\nend goal\n\nenvironment ()\n```"]], "HLPSL-1/ISO2.hlpsl": [[true, "%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso2_Init (A,B    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ Snd(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,A,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,B,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()", "```hlpsl\n%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso2_Init (A,B    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ Snd(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,A,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,B,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/ISO4.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso4_Resp (A,B: agent,\n                 Pka,Pks: public_key, \n                 SB,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State         : nat,\n         Pkb           : public_key,\n         Nb            : text,\n         Na,Text2,Text3: text\n\n  const ctext1,ctext4,ctext5: text\n\n  init State := 0 \n\n%%%  knowledge(B)={A,B,Pkb,inv(Pkb),Pks,ctext1,ctext4,ctext5,{Pkb.B}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start) \n      =|> \n      State' := 1\n      /\\ Nb' := new() \n      /\\ Snd(Nb'.ctext1) \n      /\\ witness(B,A,nb,Nb')\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.Nb.B.Text3'.\n             {Na'.Nb.B.Text2'}_inv(Pka'))\n      =|> \n      State' := 2\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb.Na'.A.ctext5.{Nb.Na'.A.ctext4}_inv(Pkb))\n%%%   /\\ witness(B,A,nb,Nb)\n      /\\ request(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso4_Init (B,A: agent,\n                 Pkb,Pks: public_key, \n                 SA,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State               : nat,\n         Pka                 : public_key,\n         Na                  : text,\n         Nb,Text1,Text4,Text5: text\n\n  const ctext2,ctext3: text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,inv(Pka),Pks,ctext2,ctext3,{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Nb'.Text1') \n      =|>\n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).\n             Na'.Nb'.B.ctext3.{Na'.Nb'.B.ctext2}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\n   2. State = 1\n      /\\ Rec(Pkb'.B.{Pkb'.B}_inv(Pks).\n             Nb.Na.A.Text5'.{Nb.Na.A.Text4'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ request(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B:agent,\n\t      Pka,Pkb,Pks: public_key) def=       \n\n  local SA,RA,SB,RB: channel (dy)\n\n  composition\n\n          iso4_Init(A,B,Pkb,Pks,SA,RA)\n       /\\ iso4_Resp(B,A,Pka,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n const a, b, i            : agent,\n       pka, pkb, pks, pki : public_key,\n       na, nb             : protocol_id,\n       ctext1, ctext2, ctext3, ctext4, ctext5 : text\n\n intruder_knowledge={a,b,pki,inv(pki),pks,\n                     ctext1,ctext4,ctext5,{pki.i}_inv(pks),  %%% 2nd session\n                     ctext2,ctext3,{pki.i}_inv(pks)}         %%% 3rd session\n\n composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,i,pka,pki,pks)\n     /\\\tsession(i,b,pki,pkb,pks)\n%%%     /\\\tsession(b,a,pkb,pka,pks,sa4,ra4,sb4,rb4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO4_Resp authenticates ISO4_Init on nb\n   authentication_on nb % addressess G1 and G2\n\n   %ISO4_Init authenticates ISO4_Resp on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso4_Resp (A,B: agent,\n                 Pka,Pks: public_key, \n                 SB,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State         : nat,\n         Pkb           : public_key,\n         Nb            : text,\n         Na,Text2,Text3: text\n\n  const ctext1,ctext4,ctext5: text\n\n  init State := 0 \n\n%%%  knowledge(B)={A,B,Pkb,inv(Pkb),Pks,ctext1,ctext4,ctext5,{Pkb.B}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start) \n      =|> \n      State' := 1\n      /\\ Nb' := new() \n      /\\ Snd(Nb'.ctext1) \n      /\\ witness(B,A,nb,Nb')\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.Nb.B.Text3'.\n             {Na'.Nb.B.Text2'}_inv(Pka'))\n      =|> \n      State' := 2\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb.Na'.A.ctext5.{Nb.Na'.A.ctext4}_inv(Pkb))\n%%%   /\\ witness(B,A,nb,Nb)\n      /\\ request(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso4_Init (B,A: agent,\n                 Pkb,Pks: public_key, \n                 SA,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State               : nat,\n         Pka                 : public_key,\n         Na                  : text,\n         Nb,Text1,Text4,Text5: text\n\n  const ctext2,ctext3: text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,inv(Pka),Pks,ctext2,ctext3,{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Nb'.Text1') \n      =|>\n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).\n             Na'.Nb'.B.ctext3.{Na'.Nb'.B.ctext2}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\n   2. State = 1\n      /\\ Rec(Pkb'.B.{Pkb'.B}_inv(Pks).\n             Nb.Na.A.Text5'.{Nb.Na.A.Text4'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ request(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B:agent,\n\t      Pka,Pkb,Pks: public_key) def=       \n\n  local SA,RA,SB,RB: channel (dy)\n\n  composition\n\n          iso4_Init(A,B,Pkb,Pks,SA,RA)\n       /\\ iso4_Resp(B,A,Pka,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n const a, b, i            : agent,\n       pka, pkb, pks, pki : public_key,\n       na, nb             : protocol_id,\n       ctext1, ctext2, ctext3, ctext4, ctext5 : text\n\n intruder_knowledge={a,b,pki,inv(pki),pks,\n                     ctext1,ctext4,ctext5,{pki.i}_inv(pks),  %%% 2nd session\n                     ctext2,ctext3,{pki.i}_inv(pks)}         %%% 3rd session\n\n composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,i,pka,pki,pks)\n     /\\\tsession(i,b,pki,pkb,pks)\n%%%     /\\\tsession(b,a,pkb,pka,pks,sa4,ra4,sb4,rb4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO4_Resp authenticates ISO4_Init on nb\n   authentication_on nb % addressess G1 and G2\n\n   %ISO4_Init authenticates ISO4_Resp on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/Ju(2024)protocol.hlpsl": [[true, "role_U(U:agent,CS:agent,D:agent,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by U\ndef=\n\tlocal\n\t\tState:nat,IDuj:text,IDcsk:text,PIDuj:text,M1:text,M3:text,M2:text,V1:text,V3:text,TS1:text,TS3:text,TIDuj:text,TIDdri:text,SK:text,RPWuj:text,Key_1:symmetric_key,PWuj:text,RR3:text,CERTuj:text,ECujj:text,RR4:text,PIDdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t\n\t\t%%% User registration\n\t\t2. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RPWuj':=h(IDuj.PWuj) \n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_U_CS':=cons(Key_1',Key_set_U_CS) \n\t\t/\\ SND({IDuj}_Key_1')\n\n\n\t\t3. State=1 /\\ in(Key_3',Key_set_CS_U) \n\t\t/\\ RCV({PIDuj'.ECuj'.IDcsk}_Key_3') =|> State':=2 \n\t\t/\\ Key_set_CS_U':=delete(Key_3',Key_set_CS_U) \n\t\t/\\ RR3':=new()\n\t\t/\\ CERTuj':=xor(ECuj',h(RR3',PWuj))\n\t\t\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t/\\ ECujj':=xor(CERTuj',h(RR3',PWuj))\n\t\t/\\ RR4':=new()\n\t\t/\\ TS1':=new()\n\t\t/\\ M1':= xor(h(IDcsk.TS1'),PIDuj)\n\t\t/\\ M2':= xor(h(PIDuj'.ECuj'.TS1'),PIDdri)\n\t\t/\\ M3':= xor(h(PIDuj'.IDcsk.ECuj'.TS1'),TIDuj)\n\t\t/\\ V1':=h(PIDuj'.PIDdri.ECuj'.TS1')\n\t\t/\\ SND(M1'.M2'.M3'.V1'.TS1')\n\t\t/\\ secret(ECujj',sec_ECujj,{U,CS}) \n\t\t/\\ witness(U,CS,u_cs_TS1,TS1')\n\n\n\t\t6. State=2 /\\ RCV(M6'.V3'.TS3') =|> State':=3\n\t\t/\\ request(U,D,d_u_TS3,TS3')\n\t\t/\\ TIDdri':=xor(M6',h(TIDuj,PIDdri,TS3'))\n\t\t/\\ SK':= h(TIDuj,TIDdri,TS3')\nend role_U\n\n\n\n\n\nrole_CS(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by CS\ndef=\n\tlocal\n\t\tState:nat,RTSdri:text,IDdri:text,XXcsk:text,RR1:text,IDuj:text,ECuj:text,PIDuj:text,TS1:text,M2:text,V1:text,M1:text,M4:text,V2:text,Key_2:symmetric_key,Key_3:symmetric_key,Key_1:symmetric_key,\nCCdri:text,PIDdri:text,ECdri:text,ECtdri:text,RR2:text,RTSuj:text,ECtuj:text,IDsck:text,TIDuj:text,CRdri:text,CRtdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RR1':=new()\n\t\t/\\ CCdri':=new()\n\t\t/\\ RTSdri':=new()\n\t\t/\\ PIDdri':=h(IDdri,RTSdri')\n\t\t/\\ ECdri':=h(IDdri,XXcsk,RR1',RTSdri')\n\t\t/\\ secret(ECdri',sec_ECdri,{CS,D}) \n\t\t/\\ ECtdri':=xor(ECdri',h(XXcsk,RTSdri'))\n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_CS_D':=cons(Key_1',Key_set_CS_D) \n\t\t/\\ SND({IDdri.CCdri'.ECdri'}_Key_1')\n\n\n\t\t%% Users registration\n\t\t2. State=1 /\\ in(Key_2',Key_set_U_CS) \n\t\t/\\ RCV({IDuj}_Key_2') =|> State':=2 \n\t\t/\\ Key_set_U_CS':=delete(Key_2',Key_set_U_CS) \t\t\t\n\t\t/\\ RR2':=new()\n\t\t/\\ PIDuj':=h(IDuj,RTSuj,XXcsk)\n\t\t/\\ ECuj':=h(PIDuj', RTSuj,RR2',XXcsk)\n\t\t/\\ secret(ECuj',sec_ECuj,{U,CS}) \n\t\t/\\ ECtuj':=xor(ECuj,h(XXcsk,RTSuj))\n\t\t/\\ Key_3':=new() \n\t\t/\\ Key_set_CS_U':=cons(Key_3',Key_set_CS_U) \n\t\t/\\ SND({PIDuj'.ECuj'.IDcsk}_Key_3')\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t4. State=2 /\\ RCV(M1'.M2'.M3'.V1'.TS1') =|> State':=3 \n\t\t/\\ request(CS,U,u_cs_TS1,TS1')\n\t\t/\\ PIDuj':=xor(M1',h(IDsck,TS1'))\n\t\t/\\ ECuj':=xor(ECtuj,h(XXcsk,RTSuj))\n\t\t/\\ PIDdri':=xor(M2',h(PIDuj',ECuj',TS1'))\n\t\t/\\ TIDuj':=xor(h(PIDuj',IDcsk,ECuj',TS1'),M3)\n\t\t/\\ CRdri':= xor(CRtdri,h(XXcsk,RTSdri))\n\t\t/\\ TS2':=new()\n\t\t/\\ M4':= xor(h(CRdri,PIDdri',TS2'),TIDuj)\n\t\t/\\ V2':=h(CRdri,PIDdri',TIDuj,TS2')\n\t\t/\\ SND(M4'.V2'.TS2')\n\t\t/\\ secret(CRdri',sec_CRdri,{CS,D}) \n\t\t/\\ witness(CS,D,cs_d_TS2,TS2')\nend role_CS\n\nrole role_D(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,IDdri:text,CCdri:text,ECdri:text,TS2:text,M4:text,V2:text,M6:text,V3:text,Key_1:symmetric_key,\nCERTdri:text,CRdri:text,TIDuj:text,PIDdri:text,RR5:text,TIDdri:text,SK:text,TS3:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ in(Key_1',Key_set_CS_D) \n\t\t/\\ RCV({IDdri.CCdri'.ECdri'}_Key_1') =|> State':=1 \n\t\t/\\ Key_set_CS_D':=delete(Key_1',Key_set_CS_D)\n\t\t/\\ CRdri':=h(CCdri')\n\t\t/\\ CERTdri':=xor(ECdri',h(CRdri',IDdri))\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t5. State=1 /\\ RCV(M4'.V2'.TS2') =|> State':=2 \n\t\t/\\ request(D,CS,cs_d_TS2,TS2')\n\t\t/\\ CRdri':= h(CCdri)\n\t\t/\\ TIDuj':=xor(M4',h(CRdri',PIDdri,TS2'))\n\t\t/\\ RR5':=new()\n\t\t/\\ TIDdri':= h(CRdri',RR5',TIDuj')\n\t\t/\\ TS3':=new()\n\t\t/\\ SK':= h(TIDuj',TIDdri,TS3')\n\t\t/\\ M6':=xor(h(TIDuj',PIDdri,TS3'), TIDdri')\n\t\t/\\ V3':=h(TIDuj',TIDdri',SK',PIDdri,TS3')\n\t\t/\\ SND(M6'.V3'.TS3')\n\t\t/\\ witness(D,U,d_u_TS3,TS3')\nend role_D\n\nrole session(U:agent,CS:agent,D:agent,Key_set_CS_U:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_D:(symmetric_key) set)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND3,RCV3,SND2,RCV2:channel(dy)\n\tcomposition\n\t\trole_U(U,CS,D,Key_set_U_CS,Key_set_CS_U,SND1,RCV1)\n\t\t/\\ role_CS(U,CS,D,Key_set_CS_D,Key_set_U_CS,Key_set_CS_U,SND2,RCV2) \n\t\t/\\ role_D(U,CS,D,Key_set_CS_D,SND3,RCV3)  \nend role\n \nrole environment()\ndef=\n\tconst\n\t\tusers,server,i,drone:agent,sec_ECdri,sec_ECuj,sec_ECujj,sec_CRdri,u_cs_TS1,d_u_TS3,cs_d_TS2:protocol_id,h:hash_func\n\tintruder_knowledge = {users,server,drone}\n\tcomposition\n\t\tsession(users,server,drone,{},{},{})\n\t\t/\\ session(users,server,drone,{},{},{})\n\t\t/\\ session(i,server,drone,{},{},{})\n\t\t/\\ session(users,i,drone,{},{},{})\n\t\t/\\ session(users,server,i,{},{},{})\nend role\n\ngoal\n\tsecrecy_of sec_ECdri % secrecy of Drone's ephemeral credential\n\tsecrecy_of sec_ECuj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_ECujj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_CRdri % secrecy of Drone's CRdri\n\tauthentication_on u_cs_TS1\n\tauthentication_on d_u_TS3\n\tauthentication_on cs_d_TS2\n\nend goal\n\nenvironment()", "```hlpsl\nrole_U(U:agent,CS:agent,D:agent,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by U\ndef=\n\tlocal\n\t\tState:nat,IDuj:text,IDcsk:text,PIDuj:text,M1:text,M3:text,M2:text,V1:text,V3:text,TS1:text,TS3:text,TIDuj:text,TIDdri:text,SK:text,RPWuj:text,Key_1:symmetric_key,PWuj:text,RR3:text,CERTuj:text,ECujj:text,RR4:text,PIDdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t\n\t\t%%% User registration\n\t\t2. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RPWuj':=h(IDuj.PWuj) \n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_U_CS':=cons(Key_1',Key_set_U_CS) \n\t\t/\\ SND({IDuj}_Key_1')\n\n\n\t\t3. State=1 /\\ in(Key_3',Key_set_CS_U) \n\t\t/\\ RCV({PIDuj'.ECuj'.IDcsk}_Key_3') =|> State':=2 \n\t\t/\\ Key_set_CS_U':=delete(Key_3',Key_set_CS_U) \n\t\t/\\ RR3':=new()\n\t\t/\\ CERTuj':=xor(ECuj',h(RR3',PWuj))\n\t\t\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t/\\ ECujj':=xor(CERTuj',h(RR3',PWuj))\n\t\t/\\ RR4':=new()\n\t\t/\\ TS1':=new()\n\t\t/\\ M1':= xor(h(IDcsk.TS1'),PIDuj)\n\t\t/\\ M2':= xor(h(PIDuj'.ECuj'.TS1'),PIDdri)\n\t\t/\\ M3':= xor(h(PIDuj'.IDcsk.ECuj'.TS1'),TIDuj)\n\t\t/\\ V1':=h(PIDuj'.PIDdri.ECuj'.TS1')\n\t\t/\\ SND(M1'.M2'.M3'.V1'.TS1')\n\t\t/\\ secret(ECujj',sec_ECujj,{U,CS}) \n\t\t/\\ witness(U,CS,u_cs_TS1,TS1')\n\n\n\t\t6. State=2 /\\ RCV(M6'.V3'.TS3') =|> State':=3\n\t\t/\\ request(U,D,d_u_TS3,TS3')\n\t\t/\\ TIDdri':=xor(M6',h(TIDuj,PIDdri,TS3'))\n\t\t/\\ SK':= h(TIDuj,TIDdri,TS3')\nend role_U\n\n\n\n\n\nrole_CS(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by CS\ndef=\n\tlocal\n\t\tState:nat,RTSdri:text,IDdri:text,XXcsk:text,RR1:text,IDuj:text,ECuj:text,PIDuj:text,TS1:text,M2:text,V1:text,M1:text,M4:text,V2:text,Key_2:symmetric_key,Key_3:symmetric_key,Key_1:symmetric_key,\nCCdri:text,PIDdri:text,ECdri:text,ECtdri:text,RR2:text,RTSuj:text,ECtuj:text,IDsck:text,TIDuj:text,CRdri:text,CRtdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RR1':=new()\n\t\t/\\ CCdri':=new()\n\t\t/\\ RTSdri':=new()\n\t\t/\\ PIDdri':=h(IDdri,RTSdri')\n\t\t/\\ ECdri':=h(IDdri,XXcsk,RR1',RTSdri')\n\t\t/\\ secret(ECdri',sec_ECdri,{CS,D}) \n\t\t/\\ ECtdri':=xor(ECdri',h(XXcsk,RTSdri'))\n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_CS_D':=cons(Key_1',Key_set_CS_D) \n\t\t/\\ SND({IDdri.CCdri'.ECdri'}_Key_1')\n\n\n\t\t%% Users registration\n\t\t2. State=1 /\\ in(Key_2',Key_set_U_CS) \n\t\t/\\ RCV({IDuj}_Key_2') =|> State':=2 \n\t\t/\\ Key_set_U_CS':=delete(Key_2',Key_set_U_CS) \t\t\t\n\t\t/\\ RR2':=new()\n\t\t/\\ PIDuj':=h(IDuj,RTSuj,XXcsk)\n\t\t/\\ ECuj':=h(PIDuj', RTSuj,RR2',XXcsk)\n\t\t/\\ secret(ECuj',sec_ECuj,{U,CS}) \n\t\t/\\ ECtuj':=xor(ECuj,h(XXcsk,RTSuj))\n\t\t/\\ Key_3':=new() \n\t\t/\\ Key_set_CS_U':=cons(Key_3',Key_set_CS_U) \n\t\t/\\ SND({PIDuj'.ECuj'.IDcsk}_Key_3')\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t4. State=2 /\\ RCV(M1'.M2'.M3'.V1'.TS1') =|> State':=3 \n\t\t/\\ request(CS,U,u_cs_TS1,TS1')\n\t\t/\\ PIDuj':=xor(M1',h(IDsck,TS1'))\n\t\t/\\ ECuj':=xor(ECtuj,h(XXcsk,RTSuj))\n\t\t/\\ PIDdri':=xor(M2',h(PIDuj',ECuj',TS1'))\n\t\t/\\ TIDuj':=xor(h(PIDuj',IDcsk,ECuj',TS1'),M3)\n\t\t/\\ CRdri':= xor(CRtdri,h(XXcsk,RTSdri))\n\t\t/\\ TS2':=new()\n\t\t/\\ M4':= xor(h(CRdri,PIDdri',TS2'),TIDuj)\n\t\t/\\ V2':=h(CRdri,PIDdri',TIDuj,TS2')\n\t\t/\\ SND(M4'.V2'.TS2')\n\t\t/\\ secret(CRdri',sec_CRdri,{CS,D}) \n\t\t/\\ witness(CS,D,cs_d_TS2,TS2')\nend role_CS\n\nrole role_D(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,IDdri:text,CCdri:text,ECdri:text,TS2:text,M4:text,V2:text,M6:text,V3:text,Key_1:symmetric_key,\nCERTdri:text,CRdri:text,TIDuj:text,PIDdri:text,RR5:text,TIDdri:text,SK:text,TS3:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ in(Key_1',Key_set_CS_D) \n\t\t/\\ RCV({IDdri.CCdri'.ECdri'}_Key_1') =|> State':=1 \n\t\t/\\ Key_set_CS_D':=delete(Key_1',Key_set_CS_D)\n\t\t/\\ CRdri':=h(CCdri')\n\t\t/\\ CERTdri':=xor(ECdri',h(CRdri',IDdri))\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t5. State=1 /\\ RCV(M4'.V2'.TS2') =|> State':=2 \n\t\t/\\ request(D,CS,cs_d_TS2,TS2')\n\t\t/\\ CRdri':= h(CCdri)\n\t\t/\\ TIDuj':=xor(M4',h(CRdri',PIDdri,TS2'))\n\t\t/\\ RR5':=new()\n\t\t/\\ TIDdri':= h(CRdri',RR5',TIDuj')\n\t\t/\\ TS3':=new()\n\t\t/\\ SK':= h(TIDuj',TIDdri,TS3')\n\t\t/\\ M6':=xor(h(TIDuj',PIDdri,TS3'), TIDdri')\n\t\t/\\ V3':=h(TIDuj',TIDdri',SK',PIDdri,TS3')\n\t\t/\\ SND(M6'.V3'.TS3')\n\t\t/\\ witness(D,U,d_u_TS3,TS3')\nend role_D\n\nrole session(U:agent,CS:agent,D:agent,Key_set_CS_U:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_D:(symmetric_key) set)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND3,RCV3,SND2,RCV2:channel(dy)\n\tcomposition\n\t\trole_U(U,CS,D,Key_set_U_CS,Key_set_CS_U,SND1,RCV1)\n\t\t/\\ role_CS(U,CS,D,Key_set_CS_D,Key_set_U_CS,Key_set_CS_U,SND2,RCV2) \n\t\t/\\ role_D(U,CS,D,Key_set_CS_D,SND3,RCV3)  \nend role\n \nrole environment()\ndef=\n\tconst\n\t\tusers,server,i,drone:agent,sec_ECdri,sec_ECuj,sec_ECujj,sec_CRdri,u_cs_TS1,d_u_TS3,cs_d_TS2:protocol_id,h:hash_func\n\tintruder_knowledge = {users,server,drone}\n\tcomposition\n\t\tsession(users,server,drone,{},{},{})\n\t\t/\\ session(users,server,drone,{},{},{})\n\t\t/\\ session(i,server,drone,{},{},{})\n\t\t/\\ session(users,i,drone,{},{},{})\n\t\t/\\ session(users,server,i,{},{},{})\nend role\n\ngoal\n\tsecrecy_of sec_ECdri % secrecy of Drone's ephemeral credential\n\tsecrecy_of sec_ECuj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_ECujj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_CRdri % secrecy of Drone's CRdri\n\tauthentication_on u_cs_TS1\n\tauthentication_on d_u_TS3\n\tauthentication_on cs_d_TS2\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/Kerberos.hlpsl": [[true, "role kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local Lifetime_2, Tstart, Texpire, T, N2 : text,\n        K_CG, K_CS                               : symmetric_key,\n        Tstart2, Texpire2                  : text\n\n  const t1, k_cg, k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.{C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG) \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{C,G,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 S_S, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2b, t2a : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2b,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2a,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, R_C   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia}\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n/\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2b\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local Lifetime_2, Tstart, Texpire, T, N2 : text,\n        K_CG, K_CS                               : symmetric_key,\n        Tstart2, Texpire2                  : text\n\n  const t1, k_cg, k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.{C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG) \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{C,G,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 S_S, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2b, t2a : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2b,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2a,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, R_C   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia}\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n/\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2b\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/KEY_EXCHANGE.hlpsl": [[true, "%% key exchange\n\nrole role_SM(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tCu:text,\n\t\tIDu,Cu,Aa,Bu,T1:text,\n\t\tI1,S1:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ S1' := H(IDu.Aa.Cu) /\\ I1' := xor(IDu,(xor(H(Aa),Aa))) /\\ SND({Bu.Aa.S1'.Cu}_PKs,I1',T1)\nend role\n\nrole role_DS(DS:agent,SM:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tSKs:symmetric_key,\n\t\tAa,Bu,Cu,IDu,IDs,Bb,Gg,T1,T3,Xi,Cs:text,\n\t\tI1,S1,Xi1,Eta:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Bu.Aa.S1'.Cu}_PKs,I1',T1) =|> State':=1 /\\ SKs' := new() /\\ Xi1' := xor(Xi,H(Cu.IDu.Sigmau)) /\\ Eta' := xor(IDs,H(Bb.Cs.Cu)) /\\ SND({Eta'.Xi1'.Cs.Bb}_Sigmau,T3) /\\ secret(SKs',sec_1,{SM,DS}) /\\ witness(DS,SM,auth_1,SKs')\nend role\n\nrole session(SM:agent,DS:agent,Sigmau:symmetric_key,SKs:symmetric_key,PKs:public_key,H:hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_SM(SM,DS,Sigmau,PKs,H,SND1,RCV1) /\\\n\t\trole_DS(DS,SM,Sigmau,PKs,H,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tpks,pki:public_key,\n\t\tsigmau,sigmai,sks:symmetric_key,\n\t\th:hash_func,\n                smart_meter,distributed_server,i:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {smart_meter,distributed_server,pki,pks}    %% ... and we give it to the intruder\n\tcomposition\n                  %% We run the regular session\n\t\tsession(smart_meter,distributed_server,sigmau,sks,pks,h) \n                  %% in parallel with another regular session\n                /\\ session(distributed_server,smart_meter,sigmau,sks,pks,h) \n\n                  %% and a session between the intruder (with key kit) and bob\n                /\\ session(i,distributed_server,sigmai,sks,pks,h) \n                  %% and a session between alice and the intruder (with key kit)\n                /\\ session(smart_meter,i,sigmau,sks,pki,h) \nend role\n\ngoal\n    secrecy_of sec_1\n\tauthentication_on auth_1\nend goal\n\nenvironment()", "```hlpsl\n%% key exchange\n\nrole role_SM(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tCu:text,\n\t\tIDu,Cu,Aa,Bu,T1:text,\n\t\tI1,S1:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ S1' := H(IDu.Aa.Cu) /\\ I1' := xor(IDu,(xor(H(Aa),Aa))) /\\ SND({Bu.Aa.S1'.Cu}_PKs,I1',T1)\nend role\n\nrole role_DS(DS:agent,SM:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tSKs:symmetric_key,\n\t\tAa,Bu,Cu,IDu,IDs,Bb,Gg,T1,T3,Xi,Cs:text,\n\t\tI1,S1,Xi1,Eta:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Bu.Aa.S1'.Cu}_PKs,I1',T1) =|> State':=1 /\\ SKs' := new() /\\ Xi1' := xor(Xi,H(Cu.IDu.Sigmau)) /\\ Eta' := xor(IDs,H(Bb.Cs.Cu)) /\\ SND({Eta'.Xi1'.Cs.Bb}_Sigmau,T3) /\\ secret(SKs',sec_1,{SM,DS}) /\\ witness(DS,SM,auth_1,SKs')\nend role\n\nrole session(SM:agent,DS:agent,Sigmau:symmetric_key,SKs:symmetric_key,PKs:public_key,H:hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_SM(SM,DS,Sigmau,PKs,H,SND1,RCV1) /\\\n\t\trole_DS(DS,SM,Sigmau,PKs,H,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tpks,pki:public_key,\n\t\tsigmau,sigmai,sks:symmetric_key,\n\t\th:hash_func,\n                smart_meter,distributed_server,i:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {smart_meter,distributed_server,pki,pks}    %% ... and we give it to the intruder\n\tcomposition\n                  %% We run the regular session\n\t\tsession(smart_meter,distributed_server,sigmau,sks,pks,h) \n                  %% in parallel with another regular session\n                /\\ session(distributed_server,smart_meter,sigmau,sks,pks,h) \n\n                  %% and a session between the intruder (with key kit) and bob\n                /\\ session(i,distributed_server,sigmai,sks,pks,h) \n                  %% and a session between alice and the intruder (with key kit)\n                /\\ session(smart_meter,i,sigmau,sks,pki,h) \nend role\n\ngoal\n    secrecy_of sec_1\n\tauthentication_on auth_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/L-3.hlpsl": [[true, "role alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIa: nat,\n\tM1,Q1: nat,\n\tP2,M2,Q2: nat,\n\tH2,H3: hash_func,\n\tMUL,PI: hash_func,\n\tCERT: hash_func,\n\tKDF: hash_func,\n\tLOW,HIG: hash_func,\n\tMAC: hash_func,\n\tSND,RCV: channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tIb,K_a,K_b: nat, \n\tKa,Kb,CertificateB,Qba,Rba,Tba,TagB,TagA,Kba,Mba,CertificateA: message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 /\\ \nK_a' := new() /\\\nKa' := MUL(K_a'.P2) /\\\nCertificateA' := CERT(Ia.Ya) /\\\nSND(Ia.CertificateA'.Ka') /\\ witness(A,B,ss1,Ia.CertificateA'.Ka')\n\n\n2. State = 1 /\\ RCV(Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib'))) \n/\\ CertificateB' = CERT(Ib.Yb) \n=|>\nState' := 2 /\\\nQba' := MUL(M1.Q1.inv(Ya).Kb') /\\\nRba' := MUL(M2.Q2.K_a.Yb) /\\\nTba' := KDF(PI(Qba').PI(Rba').Ia.Ib') /\\\nKba' := LOW(Tba') /\\\nMba' := HIG(Tba') /\\\nTagA' := {MAC(H3.PI(Ka).PI(Kb').Ia.Ib')}_Mba' /\\\nSND(TagA') \n/\\ secret(K_a, secka, A)\n/\\ request(A,B,ss2,Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib')))\n/\\ witness(A,B,ss3,TagA')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIb: nat,\n\tP1,M1,Q1: nat,\n\tP2,M2,Q2: nat,\n\tH2,H3: hash_func,\n\tSign,KDF: hash_func,\n\tCERT,MUL: hash_func,\n\tPI,LOW: hash_func,\n\tHIG,MAC: hash_func,\n\tSND,RCV: channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tIa: nat,\n\tK_b,K_a: nat,\n\tKa,Kb,Qab,Rab,Tab,Kab,Mab,TagA,TagB,CertificateB,CertificateA: message,\n\tState: nat\ninit State := 10\ntransition\n\n10. State = 10 /\\ RCV(Ia'.CertificateA'.Ka') /\\ CertificateA' = CERT(Ia.Ya)\n=|> State' := 20 /\\ \nK_b' := new() /\\\nKb' := MUL(K_b'.P1) /\\\nQab' := MUL(M1.Q1.K_b.Ya) /\\\nRab' := MUL(M2.Q2.inv(Yb).Ka') /\\\nTab' := KDF(PI(Qab').PI(Rab').Ia'.Ib) /\\\nKab' := LOW(Tab') /\\\nMab' := HIG(Tab') /\\\nTagB' := {MAC(H2.PI(Kb').PI(Ka').Ib.Ia')}_Mab' /\\\nCertificateB' := CERT(Ib.Yb) /\\\nSND(Ib.CertificateB'.Kb'.TagB') \n/\\ secret(K_b, seckb, B) \n/\\ request(B,A,ss1,Ia'.CertificateA'.Ka') \n/\\ witness(B,A,ss2,Ib.CertificateB'.Kb'.TagB')\n\n\n\n20. State = 20 /\\ RCV({MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n=|>\nState' := 40 /\\ Ka' := new() /\\ SND(Ka') /\\ request(B,A,ss3,{MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n\n% End\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B:agent,Ya,Yb:public_key,Ia,Ib:nat,P1,M1,Q1,P2,M2,Q2:nat,H2,H3:hash_func,Sign:hash_func,KDF:hash_func,CERT:hash_func,MUL:hash_func,PI:hash_func,LOW:hash_func,HIG:hash_func,MAC:hash_func)\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Ia,P1,M1,Q1,P2,M2,Q2,H2,H3,MUL,PI,CERT,KDF,LOW,HIG,MAC,SA,RA) \n/\\ bob(A,B,Ya,Yb,Ib,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nss1,ss2,ss3,secka,seckb: protocol_id,\nya,yb:public_key,\nia,ib:nat,\np1,m1,q1:nat,\np2,m2,q2:nat,\nh2,h3:hash_func,\nsign:hash_func,\nkdf:hash_func,\ncert:hash_func,\nmul:hash_func,\npi:hash_func,\nlow:hash_func,\nhig:hash_func,\nmac:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,cert,mul,pi,low,hig,mac,p1,m1,q1,p2,m2,q2,h2,h3}\n\ncomposition\n\nsession(a,b,ya,yb,ia,ib,p1,m1,q1,p2,m2,q2,h2,h3,sign,kdf,cert,mul,pi,low,hig,mac)\n\nend role\n\ngoal\n\tauthentication_on ss1\n\tauthentication_on ss2\n\tauthentication_on ss3\n\tsecrecy_of secka\n\tsecrecy_of seckb\nend goal\n\nenvironment()", "```hlpsl\nrole alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIa: nat,\n\tM1,Q1: nat,\n\tP2,M2,Q2: nat,\n\tH2,H3: hash_func,\n\tMUL,PI: hash_func,\n\tCERT: hash_func,\n\tKDF: hash_func,\n\tLOW,HIG: hash_func,\n\tMAC: hash_func,\n\tSND,RCV: channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tIb,K_a,K_b: nat, \n\tKa,Kb,CertificateB,Qba,Rba,Tba,TagB,TagA,Kba,Mba,CertificateA: message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 /\\ \nK_a' := new() /\\\nKa' := MUL(K_a'.P2) /\\\nCertificateA' := CERT(Ia.Ya) /\\\nSND(Ia.CertificateA'.Ka') /\\ witness(A,B,ss1,Ia.CertificateA'.Ka')\n\n\n2. State = 1 /\\ RCV(Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib'))) \n/\\ CertificateB' = CERT(Ib.Yb) \n=|>\nState' := 2 /\\\nQba' := MUL(M1.Q1.inv(Ya).Kb') /\\\nRba' := MUL(M2.Q2.K_a.Yb) /\\\nTba' := KDF(PI(Qba').PI(Rba').Ia.Ib') /\\\nKba' := LOW(Tba') /\\\nMba' := HIG(Tba') /\\\nTagA' := {MAC(H3.PI(Ka).PI(Kb').Ia.Ib')}_Mba' /\\\nSND(TagA') \n/\\ secret(K_a, secka, A)\n/\\ request(A,B,ss2,Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib')))\n/\\ witness(A,B,ss3,TagA')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIb: nat,\n\tP1,M1,Q1: nat,\n\tP2,M2,Q2: nat,\n\tH2,H3: hash_func,\n\tSign,KDF: hash_func,\n\tCERT,MUL: hash_func,\n\tPI,LOW: hash_func,\n\tHIG,MAC: hash_func,\n\tSND,RCV: channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tIa: nat,\n\tK_b,K_a: nat,\n\tKa,Kb,Qab,Rab,Tab,Kab,Mab,TagA,TagB,CertificateB,CertificateA: message,\n\tState: nat\ninit State := 10\ntransition\n\n10. State = 10 /\\ RCV(Ia'.CertificateA'.Ka') /\\ CertificateA' = CERT(Ia.Ya)\n=|> State' := 20 /\\ \nK_b' := new() /\\\nKb' := MUL(K_b'.P1) /\\\nQab' := MUL(M1.Q1.K_b.Ya) /\\\nRab' := MUL(M2.Q2.inv(Yb).Ka') /\\\nTab' := KDF(PI(Qab').PI(Rab').Ia'.Ib) /\\\nKab' := LOW(Tab') /\\\nMab' := HIG(Tab') /\\\nTagB' := {MAC(H2.PI(Kb').PI(Ka').Ib.Ia')}_Mab' /\\\nCertificateB' := CERT(Ib.Yb) /\\\nSND(Ib.CertificateB'.Kb'.TagB') \n/\\ secret(K_b, seckb, B) \n/\\ request(B,A,ss1,Ia'.CertificateA'.Ka') \n/\\ witness(B,A,ss2,Ib.CertificateB'.Kb'.TagB')\n\n\n\n20. State = 20 /\\ RCV({MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n=|>\nState' := 40 /\\ Ka' := new() /\\ SND(Ka') /\\ request(B,A,ss3,{MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n\n% End\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B:agent,Ya,Yb:public_key,Ia,Ib:nat,P1,M1,Q1,P2,M2,Q2:nat,H2,H3:hash_func,Sign:hash_func,KDF:hash_func,CERT:hash_func,MUL:hash_func,PI:hash_func,LOW:hash_func,HIG:hash_func,MAC:hash_func)\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Ia,P1,M1,Q1,P2,M2,Q2,H2,H3,MUL,PI,CERT,KDF,LOW,HIG,MAC,SA,RA) \n/\\ bob(A,B,Ya,Yb,Ib,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nss1,ss2,ss3,secka,seckb: protocol_id,\nya,yb:public_key,\nia,ib:nat,\np1,m1,q1:nat,\np2,m2,q2:nat,\nh2,h3:hash_func,\nsign:hash_func,\nkdf:hash_func,\ncert:hash_func,\nmul:hash_func,\npi:hash_func,\nlow:hash_func,\nhig:hash_func,\nmac:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,cert,mul,pi,low,hig,mac,p1,m1,q1,p2,m2,q2,h2,h3}\n\ncomposition\n\nsession(a,b,ya,yb,ia,ib,p1,m1,q1,p2,m2,q2,h2,h3,sign,kdf,cert,mul,pi,low,hig,mac)\n\nend role\n\ngoal\n\tauthentication_on ss1\n\tauthentication_on ss2\n\tauthentication_on ss3\n\tsecrecy_of secka\n\tsecrecy_of seckb\nend goal\n\nenvironment()\n```"]], "HLPSL-1/lipkey-spkm-known-initiator.hlpsl": [[true, "role initiator (\n        G: nat,\n\tA: agent,             \n        S: agent,\n\tH: hash_func,\n\tKa: public_key,\n\tKs: public_key,\n\tLogin_A_S: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : nat,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const ktrgtint, sec_i_Pwd, sec_i_Log: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = 0 /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = 1 /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ witness(A,S,sec_i_Log,Login_A_S) \n\t      \t /\\ witness(A,S,sec_i_Pwd,Pwd_A_S)  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,S,ktrgtint,K') \n\t         /\\ secret(Login_A_S,sec_i_Log,{A,S}) \n\t         /\\ secret(Pwd_A_S,sec_i_Pwd,{A,S}) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,S           : agent,      \n\tG             : nat,\n\tH             : hash_func,\n\tKa,Ks         : public_key,\n\tLogin,Pwd    : hash_func,\n        SND, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : nat,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: protocol_id\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ witness(S,A,sec_t_Log,Login(A.S)) \n\t        /\\ secret(Pwd(A.S),sec_t_Pwd,{A,S}) \n\t\t/\\ witness(S,A,k,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ request(S,A,k,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\t  A,S : agent,\n\t  Login, Pwd: hash_func,\n\t  Ka: public_key,\n          Ks: public_key,\n\t  H: hash_func,\n\t  G: nat)\ndef=  \n\n  local   SndI, RcvI,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a,s,i,b: agent,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k \n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint \n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, \n             sec_t_Log, sec_t_Pwd  \n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole initiator (\n        G: nat,\n\tA: agent,             \n        S: agent,\n\tH: hash_func,\n\tKa: public_key,\n\tKs: public_key,\n\tLogin_A_S: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : nat,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const ktrgtint, sec_i_Pwd, sec_i_Log: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = 0 /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = 1 /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ witness(A,S,sec_i_Log,Login_A_S) \n\t      \t /\\ witness(A,S,sec_i_Pwd,Pwd_A_S)  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,S,ktrgtint,K') \n\t         /\\ secret(Login_A_S,sec_i_Log,{A,S}) \n\t         /\\ secret(Pwd_A_S,sec_i_Pwd,{A,S}) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,S           : agent,      \n\tG             : nat,\n\tH             : hash_func,\n\tKa,Ks         : public_key,\n\tLogin,Pwd    : hash_func,\n        SND, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : nat,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: protocol_id\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ witness(S,A,sec_t_Log,Login(A.S)) \n\t        /\\ secret(Pwd(A.S),sec_t_Pwd,{A,S}) \n\t\t/\\ witness(S,A,k,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ request(S,A,k,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\t  A,S : agent,\n\t  Login, Pwd: hash_func,\n\t  Ka: public_key,\n          Ks: public_key,\n\t  H: hash_func,\n\t  G: nat)\ndef=  \n\n  local   SndI, RcvI,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a,s,i,b: agent,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k \n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint \n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, \n             sec_t_Log, sec_t_Pwd  \n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl": [[true, "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SU, RU: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ witness(U,S,g2,{SAim'})\n\t\t   /\\ witness(U,S,g3,{SPWim'})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 2 /\\ RCV(start) =|>\n\t\t   State':= 3\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ witness(U,S,u_s_tim,Tim')\n\n\t4.  State = 3 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 4\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SS, RS: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 1 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 2\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SF, RF: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ witness(U,F,g5,{Nfp'})\n\t\t   /\\ witness(F,U,g6,{Nfp1'})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local RU, SS, RS, RF, SU, SF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f, i: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()", "```hlpsl\nrole user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SU, RU: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ witness(U,S,g2,{SAim'})\n\t\t   /\\ witness(U,S,g3,{SPWim'})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 2 /\\ RCV(start) =|>\n\t\t   State':= 3\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ witness(U,S,u_s_tim,Tim')\n\n\t4.  State = 3 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 4\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SS, RS: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 1 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 2\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SF, RF: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ witness(U,F,g5,{Nfp'})\n\t\t   /\\ witness(F,U,g6,{Nfp1'})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local RU, SS, RS, RF, SU, SF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f, i: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/liteCrypto.hlpsl": [[true, "%%% 1. A -> B : PID, S\n%%% 2. A -> B : M1, MAC, Sig\n%%% 3. B -> A : A, B, SAC\n\nrole role_A(A: agent, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND: channel(dy), RCV: channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tChe,Ts,Ts2:text,\n\t\tRes,S,PID,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Che':=new() /\\ Res':=Ha(Che') /\\ S':=Hb(Res') /\\ PID':=Ha(A.S')\n\t\t/\\ SND({A.B.PID'.S'}_Pubkey)\n\t\t/\\ Ts':=new() /\\ M1':={A.B.PID'.Ts'}_Pubkey /\\ MAC1':=Ha(M1') /\\ SIG1':={Hb(M1').Ha(S'.PID')}\n\t\t/\\ SND({M1'.MAC1'.SIG1'.Ts'}_Pubkey)\n\n\t\t/\\ secret(S',sec_2,{A,B})\n\t\t/\\ secret(Res',sec_1,{A,B})\n\n\t\t2. State=2 /\\ RCV({A.B.Ts.Ts2'.SAC'}_Pubkey) =|>\n\t\tState':=4\n\n\t\t/\\ witness(A,B,auth_1,MAC1)\n\t\t/\\ request(A,B,auth_2,SIG1)\n\t\t/\\ request(A,B,auth_3,SAC)\nend role\n\nrole role_B(A: agent, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND: channel(dy), RCV: channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tTs,Ts2:text,\n\t\tPID,S,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.B.PID'.S'}_Pubkey) /\\ RCV({M1'.MAC1'.SIG1'.Ts'}_Pubkey) =|>\n\t\tState':=3 /\\ Key':=Ha(PID'.S') /\\ Ts2':=new() /\\ SAC':=Ha(Key,A,B)\n\t\t/\\ SND({A.B.Ts'.Ts2'.SAC'}_Pubkey)\n\n\t\t/\\ secret(SAC',sec_3,{A,B})\n\n\t\t/\\ witness(B,A,auth_1,MAC1')\n\t\t/\\ witness(B,A,auth_2,SIG1')\n\t\t/\\ witness(B,A,auth_3,M1')\nend role\n\nrole session(A:agent,B:agent, PubA: public_key, PubB: public_key, Ha:hash_func, Hb: hash_func)\ndef=\n\tlocal\n\t\tSND1,RCV2,SND2,RCV1:channel(dy)\n\tcomposition\n\t\trole_A(A,B,PubB,Ha,Hb,SND1,RCV1) /\\ \n\t\trole_B(A,B,PubA,Ha,Hb,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone,groundstation,i:agent,\n\t\tpubA:public_key,\n\t\tpubB:public_key,\n\t\tha:hash_func,\n\t\thb:hash_func,\n\t\tsec_1,sec_2,sec_3,auth_1,auth_2,auth_3:protocol_id\n\tintruder_knowledge = {drone,groundstation,ha,hb}\n\n\tcomposition\n\t\tsession(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(i,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,i,pubA,pubB,ha,hb)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\tsecrecy_of sec_3\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\nend goal\n\nenvironment()", "```hlpsl\n%%% 1. A -> B : PID, S\n%%% 2. A -> B : M1, MAC, Sig\n%%% 3. B -> A : A, B, SAC\n\nrole role_A(A: agent, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND: channel(dy), RCV: channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tChe,Ts,Ts2:text,\n\t\tRes,S,PID,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Che':=new() /\\ Res':=Ha(Che') /\\ S':=Hb(Res') /\\ PID':=Ha(A.S')\n\t\t/\\ SND({A.B.PID'.S'}_Pubkey)\n\t\t/\\ Ts':=new() /\\ M1':={A.B.PID'.Ts'}_Pubkey /\\ MAC1':=Ha(M1') /\\ SIG1':={Hb(M1').Ha(S'.PID')}\n\t\t/\\ SND({M1'.MAC1'.SIG1'.Ts'}_Pubkey)\n\n\t\t/\\ secret(S',sec_2,{A,B})\n\t\t/\\ secret(Res',sec_1,{A,B})\n\n\t\t2. State=2 /\\ RCV({A.B.Ts.Ts2'.SAC'}_Pubkey) =|>\n\t\tState':=4\n\n\t\t/\\ witness(A,B,auth_1,MAC1)\n\t\t/\\ request(A,B,auth_2,SIG1)\n\t\t/\\ request(A,B,auth_3,SAC)\nend role\n\nrole role_B(A: agent, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND: channel(dy), RCV: channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tTs,Ts2:text,\n\t\tPID,S,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.B.PID'.S'}_Pubkey) /\\ RCV({M1'.MAC1'.SIG1'.Ts'}_Pubkey) =|>\n\t\tState':=3 /\\ Key':=Ha(PID'.S') /\\ Ts2':=new() /\\ SAC':=Ha(Key,A,B)\n\t\t/\\ SND({A.B.Ts'.Ts2'.SAC'}_Pubkey)\n\n\t\t/\\ secret(SAC',sec_3,{A,B})\n\n\t\t/\\ witness(B,A,auth_1,MAC1')\n\t\t/\\ witness(B,A,auth_2,SIG1')\n\t\t/\\ witness(B,A,auth_3,M1')\nend role\n\nrole session(A:agent,B:agent, PubA: public_key, PubB: public_key, Ha:hash_func, Hb: hash_func)\ndef=\n\tlocal\n\t\tSND1,RCV2,SND2,RCV1:channel(dy)\n\tcomposition\n\t\trole_A(A,B,PubB,Ha,Hb,SND1,RCV1) /\\ \n\t\trole_B(A,B,PubA,Ha,Hb,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone,groundstation,i:agent,\n\t\tpubA:public_key,\n\t\tpubB:public_key,\n\t\tha:hash_func,\n\t\thb:hash_func,\n\t\tsec_1,sec_2,sec_3,auth_1,auth_2,auth_3:protocol_id\n\tintruder_knowledge = {drone,groundstation,ha,hb}\n\n\tcomposition\n\t\tsession(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(i,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,i,pubA,pubB,ha,hb)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\tsecrecy_of sec_3\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\nend goal\n\nenvironment()\n```"]], "HLPSL-1/LPD-IMSR.hlpsl": [[true, "%% PROTOCOL*: LPD IMSR\n%% VARIANT: IMSR: Improved Modulo Square Root\n%% LPD (Low-Powered Devices) Improved MSR (Modulo Square Root) protocol\n%% is a key establishment protocol for secure mobile communications. It\n%% has been designed by Beller, Chang, and Yacobi in 1990s as an\n%% improvement of MSR. Namely IMSR overcomes a major weakness of MSR by\n%% including a certificate of the base station in the first\n%% message. Apart from this feature it is identical to the basic MSR\n%% protocol, and therefore does not address the problem of replay\n%% \n%% PURPOSE: \n%% Key establishment protocol for secure mobile communications.\n%%   \n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[pages 5-6]{MutAuthLPD}\n%% \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M    : agent\n%% PKb     : public key\n%% SCm     : text\n%% Nb      : text (fresh)\n%% Cert(B) : message\n%% X       : symmetric key (fresh)\n%%\n%% 1. B -> M : B, Nb, PKb, Cert(B)\n%% 2. M -> B : {X}PKb\n%% 3. M -> B : {Nb, M, SCm}X\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% {\\texttt{M}} which is issued by a trusted central\n%% authority. {\\texttt{Cert(B)}} is the public certificate previously\n%% issued by some server for {\\texttt{B}}.  \n%% We assume \\verb|Cert(B) = {B.PKb}inv(PKs)|.\n%%\n%% Notice that wrt MSR there is a\n%% twofold increase in the complexity of this protocol as compared to the\n%% basic MSR protocol. The mobile now calculates an additional modulo\n%% square to verify the base's certificate on receiving message 1. Upon\n%% receiving the final message, {\\texttt{B}} decrypts it using the\n%% session key {\\texttt{X}}, and checks that the value {\\texttt{Nb}} is\n%% the same as the random challenge sent in message 1.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%% \n%% CLASSIFICATION: G1, G2, G12\n%% \n%% ATTACKS: None\n%% \n%% NOTES:\n%% \n%% The added public certificate and nonce exchange give some more\n%% protection. Boyd et al.~\\cite{MutAuthLPD} recommend moving the nonce\n%% and {\\texttt{M}} into message 2. \\\\\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole imsr_Base(B, M     : agent,\n               SCm      : text,\n               PKb      : public_key, \n               PKs      : public_key, \n               Snd, Rcv : channel (dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        X       : symmetric_key,\n        Nb      : text,\n        Package : message\t\n\n  const  secx, x : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(B.Nb'.PKb.{B.PKb}_inv(PKs))\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{Nb.M.SCm}_X')\n      =|> \n      State' := 2 \n      /\\ request(B,M,x,X')\n      /\\ secret(X',secx,{B,M})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole imsr_Mobile(B, M     : agent,\n                 SCm      : text, \n                 PKs      : public_key,\n                 Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n        PKb    : public_key,\n        X      : symmetric_key,\n        Nb     : text,\n        Cert   : message\n\n  const  secx, x : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.Nb'.PKb'.Cert')\n      /\\ Cert' = {B.PKb'}_inv(PKs)  \n      =|> \n      State':=1\n      /\\ X' := new()\n      /\\ Snd({X'}_PKb'.{Nb'.M.SCm}_X')\n      /\\ witness(M,B,x,X')\n      /\\ secret(X',secx,{B,M}) \t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n             SCm            : text,\t\n             PKb, PKs       : public_key) def=\n\n  local SA, RA, SB, RB : channel (dy)\n\n\n  composition\n\t\n       imsr_Base(B,M,SCm,PKb,PKs,SA,RA)\n    /\\ imsr_Mobile(B,M,SCm,PKs,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n  const b, m, i                                   : agent,\n        kb, ki, ks                             : public_key,\n        scm1, scm2, scm3                       : text\n\n  intruder_knowledge = {b,m,scm2,scm3,i,ki,ks,inv(ki),\n                        m,{i.ki}_inv(ks)         \n                       }\n\n  composition\n\n\tsession(b,m,scm1,kb,ks) \n    /\\  session(b,i,scm2,kb,ks) \n    /\\  session(i,m,scm3,ki,ks) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %IMSR_Base weakly authenticates IMSR_Mobile on x\n  authentication_on x % addresses G1, G2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL*: LPD IMSR\n%% VARIANT: IMSR: Improved Modulo Square Root\n%% LPD (Low-Powered Devices) Improved MSR (Modulo Square Root) protocol\n%% is a key establishment protocol for secure mobile communications. It\n%% has been designed by Beller, Chang, and Yacobi in 1990s as an\n%% improvement of MSR. Namely IMSR overcomes a major weakness of MSR by\n%% including a certificate of the base station in the first\n%% message. Apart from this feature it is identical to the basic MSR\n%% protocol, and therefore does not address the problem of replay\n%% \n%% PURPOSE: \n%% Key establishment protocol for secure mobile communications.\n%%   \n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[pages 5-6]{MutAuthLPD}\n%% \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M    : agent\n%% PKb     : public key\n%% SCm     : text\n%% Nb      : text (fresh)\n%% Cert(B) : message\n%% X       : symmetric key (fresh)\n%%\n%% 1. B -> M : B, Nb, PKb, Cert(B)\n%% 2. M -> B : {X}PKb\n%% 3. M -> B : {Nb, M, SCm}X\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% {\\texttt{M}} which is issued by a trusted central\n%% authority. {\\texttt{Cert(B)}} is the public certificate previously\n%% issued by some server for {\\texttt{B}}.  \n%% We assume \\verb|Cert(B) = {B.PKb}inv(PKs)|.\n%%\n%% Notice that wrt MSR there is a\n%% twofold increase in the complexity of this protocol as compared to the\n%% basic MSR protocol. The mobile now calculates an additional modulo\n%% square to verify the base's certificate on receiving message 1. Upon\n%% receiving the final message, {\\texttt{B}} decrypts it using the\n%% session key {\\texttt{X}}, and checks that the value {\\texttt{Nb}} is\n%% the same as the random challenge sent in message 1.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%% \n%% CLASSIFICATION: G1, G2, G12\n%% \n%% ATTACKS: None\n%% \n%% NOTES:\n%% \n%% The added public certificate and nonce exchange give some more\n%% protection. Boyd et al.~\\cite{MutAuthLPD} recommend moving the nonce\n%% and {\\texttt{M}} into message 2. \\\\\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole imsr_Base(B, M     : agent,\n               SCm      : text,\n               PKb      : public_key, \n               PKs      : public_key, \n               Snd, Rcv : channel (dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        X       : symmetric_key,\n        Nb      : text,\n        Package : message\t\n\n  const  secx, x : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(B.Nb'.PKb.{B.PKb}_inv(PKs))\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{Nb.M.SCm}_X')\n      =|> \n      State' := 2 \n      /\\ request(B,M,x,X')\n      /\\ secret(X',secx,{B,M})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole imsr_Mobile(B, M     : agent,\n                 SCm      : text, \n                 PKs      : public_key,\n                 Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n        PKb    : public_key,\n        X      : symmetric_key,\n        Nb     : text,\n        Cert   : message\n\n  const  secx, x : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.Nb'.PKb'.Cert')\n      /\\ Cert' = {B.PKb'}_inv(PKs)  \n      =|> \n      State':=1\n      /\\ X' := new()\n      /\\ Snd({X'}_PKb'.{Nb'.M.SCm}_X')\n      /\\ witness(M,B,x,X')\n      /\\ secret(X',secx,{B,M}) \t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n             SCm            : text,\t\n             PKb, PKs       : public_key) def=\n\n  local SA, RA, SB, RB : channel (dy)\n\n\n  composition\n\t\n       imsr_Base(B,M,SCm,PKb,PKs,SA,RA)\n    /\\ imsr_Mobile(B,M,SCm,PKs,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n  const b, m, i                                   : agent,\n        kb, ki, ks                             : public_key,\n        scm1, scm2, scm3                       : text\n\n  intruder_knowledge = {b,m,scm2,scm3,i,ki,ks,inv(ki),\n                        m,{i.ki}_inv(ks)         \n                       }\n\n  composition\n\n\tsession(b,m,scm1,kb,ks) \n    /\\  session(b,i,scm2,kb,ks) \n    /\\  session(i,m,scm3,ki,ks) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %IMSR_Base weakly authenticates IMSR_Mobile on x\n  authentication_on x % addresses G1, G2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/main.hlpsl": [[true, "role registrationAuth(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by RA def=\nlocal\n    State : nat,\n    Skcon, Sksw: symmetric_key,\n    F, Add: hash_func,\n    G, IDCon, IDClus, PUBRa, PRVRa, PRVCon, PUBCon, CERTCon, IDSw, PRVSw, PUBSw, CERTSw: message\n\ninit\n    State := 0\n\ntransition\n\n%%% Controller Registration\n1. State = 0 /\\ Rcv(start) =|> State':= 1 /\\\n\n%%% Generate private key and public key for Registration Authority \nPRVRa' := new() /\\ PUBRa' := F(PRVRa'.G) /\\\n\n%%% Generate private key and public key for Controller\nPRVCon' := new() /\\ PUBCon' := F(PRVCon'.G) /\\\n\n%%% Generate certificate for controller\nCERTCon' := Add(PRVCon'.H(IDCon.IDClus.PUBCon'.PUBRa').PRVRa') /\\\n\n%%% Send Registration message via secure channel\nSnd({IDCon.PRVCon'.CERTCon'}_Skcon) /\\\nsecret({PRVRa'}, prvra, RA) /\\\nwitness(RA, SC, rcvprvra, PRVRa') /\\\nwitness(RA, SC, rcvcertcon, CERTCon') /\\\n\n%%% Switch Registration\nPRVSw' := new() /\\ PUBSw' := F(PRVSw'.G) /\\\nCERTSw' := Add(PRVSw'.H(IDSw.IDClus.PUBSw'.PUBRa').PRVRa') /\\\n\n%%% Send Registration via secure channel(offline registration)\nSnd({IDSw.PRVSw'.CERTSw'}_Sksw) /\\\nsecret({PRVSw'}, prvsw, {RA, SSW})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Controller\nrole controller(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by SC def=\nlocal\n    State : nat,\n    Skcon: symmetric_key,\n    F, Add, Poly: hash_func,\n    G, IDCon, IDSw, PRVCon, IDClus, PRVRa, R1, R2, TS1, FCONSWI, ACON, BCON: message,\n    TS2, PRVSw: message\n\ninit\n    State := 0\n    \ntransition\n\n%%% Registration phase acceptance\n1. State = 0 /\\ Rcv({IDCon.PRVCon'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')}_Skcon)\n=|> State' := 2 /\\ request(RA, SC, rcvprvra, PRVRa') /\\ secret(PRVCon', prvcon, {RA, SC}) /\\\n\n%%% Access control phase\nR1' := new() /\\ TS1' := new() /\\ FCONSWI':= Poly(IDCon.IDSw) /\\\nACON' := H(R1'.TS1').xor(H(FCONSWI'.TS1')) /\\\nBCON' := H(IDCon.IDSw.ACON'.TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').FCONSWI')\n/\\\n\n%%% Send message over public channel\nSnd(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').ACON'.BCON'.TS1') /\\\n\n%%% SC has freshly generated the values R1' and TS1' for SSW\nwitness(SC, SSW, scsswr1, R1') /\\\nwitness(SC, SSW, scsswts1, TS1')\n\n2. State = 2 /\\ Rcv(IDCon'.IDSw'.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa').\n(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).H(H(Poly(IDSw'.IDCon').((H(R1'.TS1').\nxor(H(Poly(IDCon'.IDSw').TS1'))).xor(H(Poly(IDSw'.IDCon').TS1'))).H(R2'.TS2').\nAdd(PRVCon'.H(IDCon'.IDClus'.F(PRVCon'.G').F(PRVRa'.G')).PRVRa')\n.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa'))\n.(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G')\n.F(PRVRa'.G')).PRVRa').IDCon'.IDSw'.TS2').TS2') =|>\nState' := 5 /\\\nrequest(SSW, SC, sswscr2, R2') /\\\nrequest(SSW, SC, sswscts2, TS2')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Switch\nrole switch(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by SSW def=\nlocal\n    State : nat,\n    Sksw: symmetric_key,\n    F, Add, Poly: hash_func,\n    IDCon, IDSw, PRVSw, IDClus, G, PRVRa, R2, TS2, ASWI, SKswicon, R1 : message,\n    TS1, PRVCon, SKVswicon: message\n    \ninit\n    State := 0\n\ntransition\n\n% Registration acceptance phase\n1. State = 0 /\\ Rcv({IDSw.PRVSw'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')}_Sksw) =|>\nState' := 3 /\\ request(RA, SSW, rcvprvra, PRVRa') /\\ secret(PRVSw', prvsw, {RA, SSW})\n\n% Access Control Phase\n\n2. State = 3 /\\ Rcv(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').\n        H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1')).\n        H(IDCon.IDSw.H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))\n        .TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').Poly(IDCon.IDSw))\n        .TS1') =|>\nState' := 4 /\\\nR2' := new() /\\ TS2' := new() /\\\nASWI' := H(R2'.TS2').xor(H(Poly(IDSw.IDCon).TS2')) /\\\nPRVSw' := new() /\\\nSKswicon' := H(Poly(IDSw.IDCon).((H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))).xor(H(Poly(IDSw.IDCon).TS1'))).H(R2'.TS2').\n            Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')\n            .Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')) /\\\nSKVswicon' := H(SKswicon'.ASWI'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').IDCon.IDSw.TS2') /\\\nSnd(IDCon.IDSw.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').ASWI'.SKVswicon'.TS2') /\\ % \n\nwitness(SSW, SC, sswscr2, R2') /\\\nwitness(SSW, SC, sswscts2, TS2') /\\\nrequest(SC, SSW, scsswr1, R1') /\\\nrequest(SC, SSW, scsswts1, TS1')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define session role\nrole session(RA, SC, SSW: agent, H: hash_func)\ndef=\nlocal\n    RASND, RARCV, SCSND, SCRCV, SSWSND, SSWRCV: channel(dy)\ncomposition\n    registrationAuth(RA, SC, SSW, H, RASND, RARCV) /\\\n    controller(RA, SC, SSW, H, SCSND, SCRCV) /\\\n    switch(RA, SC, SSW, H, SSWSND, SSWRCV)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define environment role\nrole environment() def= \nconst \n    ra, sc, ssw: agent,\n    h, f, add, poly: hash_func,\n    prvra, prvcon, prvsw: protocol_id,\n    scsswts1, scsswr1 : protocol_id,\n    sswscr2, sswscts2 : protocol_id\nintruder_knowledge = {ra, sc, ssw, h, f, add, poly}\n\ncomposition\n    session(ra, sc, ssw, h) /\\\n    session(ra, sc, i, h) /\\\n    session(ra, i, ssw, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n% Confidentiality of Private Keys\nsecrecy_of prvra\nsecrecy_of prvcon\nsecrecy_of prvsw\n\n% Authentication\nauthentication_on scsswr1 \nauthentication_on scsswts1\nauthentication_on sswscr2\nauthentication_on sswscts2\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()", "```hlpsl\nrole registrationAuth(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by RA def=\nlocal\n    State : nat,\n    Skcon, Sksw: symmetric_key,\n    F, Add: hash_func,\n    G, IDCon, IDClus, PUBRa, PRVRa, PRVCon, PUBCon, CERTCon, IDSw, PRVSw, PUBSw, CERTSw: message\n\ninit\n    State := 0\n\ntransition\n\n%%% Controller Registration\n1. State = 0 /\\ Rcv(start) =|> State':= 1 /\\\n\n%%% Generate private key and public key for Registration Authority \nPRVRa' := new() /\\ PUBRa' := F(PRVRa'.G) /\\\n\n%%% Generate private key and public key for Controller\nPRVCon' := new() /\\ PUBCon' := F(PRVCon'.G) /\\\n\n%%% Generate certificate for controller\nCERTCon' := Add(PRVCon'.H(IDCon.IDClus.PUBCon'.PUBRa').PRVRa') /\\\n\n%%% Send Registration message via secure channel\nSnd({IDCon.PRVCon'.CERTCon'}_Skcon) /\\\nsecret({PRVRa'}, prvra, RA) /\\\nwitness(RA, SC, rcvprvra, PRVRa') /\\\nwitness(RA, SC, rcvcertcon, CERTCon') /\\\n\n%%% Switch Registration\nPRVSw' := new() /\\ PUBSw' := F(PRVSw'.G) /\\\nCERTSw' := Add(PRVSw'.H(IDSw.IDClus.PUBSw'.PUBRa').PRVRa') /\\\n\n%%% Send Registration via secure channel(offline registration)\nSnd({IDSw.PRVSw'.CERTSw'}_Sksw) /\\\nsecret({PRVSw'}, prvsw, {RA, SSW})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Controller\nrole controller(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by SC def=\nlocal\n    State : nat,\n    Skcon: symmetric_key,\n    F, Add, Poly: hash_func,\n    G, IDCon, IDSw, PRVCon, IDClus, PRVRa, R1, R2, TS1, FCONSWI, ACON, BCON: message,\n    TS2, PRVSw: message\n\ninit\n    State := 0\n    \ntransition\n\n%%% Registration phase acceptance\n1. State = 0 /\\ Rcv({IDCon.PRVCon'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')}_Skcon)\n=|> State' := 2 /\\ request(RA, SC, rcvprvra, PRVRa') /\\ secret(PRVCon', prvcon, {RA, SC}) /\\\n\n%%% Access control phase\nR1' := new() /\\ TS1' := new() /\\ FCONSWI':= Poly(IDCon.IDSw) /\\\nACON' := H(R1'.TS1').xor(H(FCONSWI'.TS1')) /\\\nBCON' := H(IDCon.IDSw.ACON'.TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').FCONSWI')\n/\\\n\n%%% Send message over public channel\nSnd(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').ACON'.BCON'.TS1') /\\\n\n%%% SC has freshly generated the values R1' and TS1' for SSW\nwitness(SC, SSW, scsswr1, R1') /\\\nwitness(SC, SSW, scsswts1, TS1')\n\n2. State = 2 /\\ Rcv(IDCon'.IDSw'.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa').\n(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).H(H(Poly(IDSw'.IDCon').((H(R1'.TS1').\nxor(H(Poly(IDCon'.IDSw').TS1'))).xor(H(Poly(IDSw'.IDCon').TS1'))).H(R2'.TS2').\nAdd(PRVCon'.H(IDCon'.IDClus'.F(PRVCon'.G').F(PRVRa'.G')).PRVRa')\n.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa'))\n.(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G')\n.F(PRVRa'.G')).PRVRa').IDCon'.IDSw'.TS2').TS2') =|>\nState' := 5 /\\\nrequest(SSW, SC, sswscr2, R2') /\\\nrequest(SSW, SC, sswscts2, TS2')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Switch\nrole switch(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by SSW def=\nlocal\n    State : nat,\n    Sksw: symmetric_key,\n    F, Add, Poly: hash_func,\n    IDCon, IDSw, PRVSw, IDClus, G, PRVRa, R2, TS2, ASWI, SKswicon, R1 : message,\n    TS1, PRVCon, SKVswicon: message\n    \ninit\n    State := 0\n\ntransition\n\n% Registration acceptance phase\n1. State = 0 /\\ Rcv({IDSw.PRVSw'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')}_Sksw) =|>\nState' := 3 /\\ request(RA, SSW, rcvprvra, PRVRa') /\\ secret(PRVSw', prvsw, {RA, SSW})\n\n% Access Control Phase\n\n2. State = 3 /\\ Rcv(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').\n        H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1')).\n        H(IDCon.IDSw.H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))\n        .TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').Poly(IDCon.IDSw))\n        .TS1') =|>\nState' := 4 /\\\nR2' := new() /\\ TS2' := new() /\\\nASWI' := H(R2'.TS2').xor(H(Poly(IDSw.IDCon).TS2')) /\\\nPRVSw' := new() /\\\nSKswicon' := H(Poly(IDSw.IDCon).((H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))).xor(H(Poly(IDSw.IDCon).TS1'))).H(R2'.TS2').\n            Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')\n            .Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')) /\\\nSKVswicon' := H(SKswicon'.ASWI'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').IDCon.IDSw.TS2') /\\\nSnd(IDCon.IDSw.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').ASWI'.SKVswicon'.TS2') /\\ % \n\nwitness(SSW, SC, sswscr2, R2') /\\\nwitness(SSW, SC, sswscts2, TS2') /\\\nrequest(SC, SSW, scsswr1, R1') /\\\nrequest(SC, SSW, scsswts1, TS1')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define session role\nrole session(RA, SC, SSW: agent, H: hash_func)\ndef=\nlocal\n    RASND, RARCV, SCSND, SCRCV, SSWSND, SSWRCV: channel(dy)\ncomposition\n    registrationAuth(RA, SC, SSW, H, RASND, RARCV) /\\\n    controller(RA, SC, SSW, H, SCSND, SCRCV) /\\\n    switch(RA, SC, SSW, H, SSWSND, SSWRCV)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define environment role\nrole environment() def= \nconst \n    ra, sc, ssw: agent,\n    h, f, add, poly: hash_func,\n    prvra, prvcon, prvsw: protocol_id,\n    scsswts1, scsswr1 : protocol_id,\n    sswscr2, sswscts2 : protocol_id\nintruder_knowledge = {ra, sc, ssw, h, f, add, poly}\n\ncomposition\n    session(ra, sc, ssw, h) /\\\n    session(ra, sc, i, h) /\\\n    session(ra, i, ssw, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n% Confidentiality of Private Keys\nsecrecy_of prvra\nsecrecy_of prvcon\nsecrecy_of prvsw\n\n% Authentication\nauthentication_on scsswr1 \nauthentication_on scsswts1\nauthentication_on sswscr2\nauthentication_on sswscts2\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()\n```"]], "HLPSL-1/migration.hlpsl": [[true, "role PreviousParent(PreviousParent:agent,Kbp:symmetric_key,Kbc:symmetric_key,Knb:symmetric_key,UniqidI:text,SND,RCV:channel(dy))\nplayed_by PreviousParent\ndef=\n\tlocal\n\t\tUniqid: text,Uniqid': text,Idrequest:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t4. State=0 /\\ RCV({Uniqid'.Idrequest'}_Kbp) =|> State':=1 /\\ SND({UniqidI}_Kbp)\nend role\n\nrole ParentB(ParentB:agent,NodeN:agent,Blockchain:agent,Knb:symmetric_key,Kbp:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by ParentB\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text,PreviousParentID:text,Idrequest:text,Uniqid':text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Uniqid'}_Knb) =|> State':=1 /\\ SND({Uniqid'}_Kbc)\n\t\t3. State=1 /\\ RCV({Uniqid.PreviousParentID'}_Kbc) =|> State':=2 /\\ Idrequest':=new() /\\ SND({Uniqid.Idrequest'}_Kbp)\n\t\t5. State=2 /\\ RCV({UniqidI'}_Kbp) =|> State':=3 /\\ Success':=new() /\\ witness(NodeN,ParentB,sec_1,Success') /\\ SND({Success'}_Knb)\nend role\n\nrole role_Blockchain(Blockchain:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by Blockchain\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV({Uniqid'}_Kbc) =|> State':=1 /\\ SND({Uniqid'.PreviousParentID}_Kbc)\nend role\n\nrole role_NodeN(NodeN:agent,PreviousParent:agent,ParentB:agent,Uniqid:text,Knb:symmetric_key,SND,RCV:channel(dy))\nplayed_by NodeN\ndef=\n\tlocal\n\t\tState:nat,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({Uniqid}_Knb)\n\t\t6. State=1 /\\ RCV({Success'}_Knb) =|> State':=2 /\\ secret(Success',sec_1,{NodeN,ParentB})\nend role\n\nrole session1(UniqidI:text,Knb:symmetric_key,Kbp:symmetric_key,Uniqid:text,NodeN:agent,Blockchain:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_Blockchain(Blockchain,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,Blockchain,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole session2(UniqidI:text,Kib:symmetric_key,Kbp:symmetric_key,Uniqid:text,NodeN:agent,i:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_Blockchain(i,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,i,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkbp:symmetric_key,blockchain:agent,previousParent:agent,knb:symmetric_key,nodeN:agent,kib:symmetric_key,parentB:agent,kbc:symmetric_key,sec_1:protocol_id\n\tintruder_knowledge = {nodeN,parentB,previousParent,kib}\n\tcomposition\n\t\tsession2(const_1,kib,kbp,const_1,i,blockchain,parentB,previousParent,const_1,kbc) /\\ session1(const_1,knb,kbp,const_1,nodeN,blockchain,parentB,previousParent,const_1,kbc)\nend role\n\ngoal\n\tsecrecy_of sec_1\nend goal\n\nenvironment()", "```hlpsl\nrole PreviousParent(PreviousParent:agent,Kbp:symmetric_key,Kbc:symmetric_key,Knb:symmetric_key,UniqidI:text,SND,RCV:channel(dy))\nplayed_by PreviousParent\ndef=\n\tlocal\n\t\tUniqid: text,Uniqid': text,Idrequest:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t4. State=0 /\\ RCV({Uniqid'.Idrequest'}_Kbp) =|> State':=1 /\\ SND({UniqidI}_Kbp)\nend role\n\nrole ParentB(ParentB:agent,NodeN:agent,Blockchain:agent,Knb:symmetric_key,Kbp:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by ParentB\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text,PreviousParentID:text,Idrequest:text,Uniqid':text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Uniqid'}_Knb) =|> State':=1 /\\ SND({Uniqid'}_Kbc)\n\t\t3. State=1 /\\ RCV({Uniqid.PreviousParentID'}_Kbc) =|> State':=2 /\\ Idrequest':=new() /\\ SND({Uniqid.Idrequest'}_Kbp)\n\t\t5. State=2 /\\ RCV({UniqidI'}_Kbp) =|> State':=3 /\\ Success':=new() /\\ witness(NodeN,ParentB,sec_1,Success') /\\ SND({Success'}_Knb)\nend role\n\nrole role_Blockchain(Blockchain:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by Blockchain\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV({Uniqid'}_Kbc) =|> State':=1 /\\ SND({Uniqid'.PreviousParentID}_Kbc)\nend role\n\nrole role_NodeN(NodeN:agent,PreviousParent:agent,ParentB:agent,Uniqid:text,Knb:symmetric_key,SND,RCV:channel(dy))\nplayed_by NodeN\ndef=\n\tlocal\n\t\tState:nat,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({Uniqid}_Knb)\n\t\t6. State=1 /\\ RCV({Success'}_Knb) =|> State':=2 /\\ secret(Success',sec_1,{NodeN,ParentB})\nend role\n\nrole session1(UniqidI:text,Knb:symmetric_key,Kbp:symmetric_key,Uniqid:text,NodeN:agent,Blockchain:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_Blockchain(Blockchain,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,Blockchain,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole session2(UniqidI:text,Kib:symmetric_key,Kbp:symmetric_key,Uniqid:text,NodeN:agent,i:agent,ParentB:agent,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_Blockchain(i,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,i,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkbp:symmetric_key,blockchain:agent,previousParent:agent,knb:symmetric_key,nodeN:agent,kib:symmetric_key,parentB:agent,kbc:symmetric_key,sec_1:protocol_id\n\tintruder_knowledge = {nodeN,parentB,previousParent,kib}\n\tcomposition\n\t\tsession2(const_1,kib,kbp,const_1,i,blockchain,parentB,previousParent,const_1,kbc) /\\ session1(const_1,knb,kbp,const_1,nodeN,blockchain,parentB,previousParent,const_1,kbc)\nend role\n\ngoal\n\tsecrecy_of sec_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/NSPK-fix.hlpsl": [[true, "%% PROTOCOL*: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: fix by Lowe (of 1995) without key server\n%% PURPOSE: Two-party mutual autentication\n%% MODELER: David von Oheimb, Siemens CT IC 3, January 2005\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% 1. A  - {Na.A}_Kb ----> B\n%% 2. A <- {Na.Nb.B}_Ka -  B\n%% 3. A  - {Nb}_Kb ------> B\n%%\\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A, B: agent, Ka: public_key,             \n            Kb: public_key, SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',na,{A,B}) \n\t\t   /\\ witness(A,B,alice_bob_nb,Na')\n\n    2.  State  = 2 /\\ RCV({Na.Nb'.B}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\t\t   /\\ request(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'.B}_Ka)\n\t\t   /\\ secret(Nb',nb,{A,B}) \n\t\t   /\\ witness(B,A,bob_alice_na,Na')\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b, i\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  na, nb,\n\t  alice_bob_nb,\n\t  bob_alice_na : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of na, nb\n  authentication_on alice_bob_nb\n  authentication_on bob_alice_na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL*: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: fix by Lowe (of 1995) without key server\n%% PURPOSE: Two-party mutual autentication\n%% MODELER: David von Oheimb, Siemens CT IC 3, January 2005\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% 1. A  - {Na.A}_Kb ----> B\n%% 2. A <- {Na.Nb.B}_Ka -  B\n%% 3. A  - {Nb}_Kb ------> B\n%%\\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A, B: agent, Ka: public_key,             \n            Kb: public_key, SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',na,{A,B}) \n\t\t   /\\ witness(A,B,alice_bob_nb,Na')\n\n    2.  State  = 2 /\\ RCV({Na.Nb'.B}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\t\t   /\\ request(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'.B}_Ka)\n\t\t   /\\ secret(Nb',nb,{A,B}) \n\t\t   /\\ witness(B,A,bob_alice_na,Na')\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b, i\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  na, nb,\n\t  alice_bob_nb,\n\t  bob_alice_na : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of na, nb\n  authentication_on alice_bob_nb\n  authentication_on bob_alice_na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/optimised_protocol.hlpsl": [[true, "%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (optimized)\n%%% 1. A -> T : {B,Kab}_Kat\n%%% 2. T -> B : {A,Kab}_Kbt\n%%% 3. B -> A : {B,Nb}_Kab\n%%% 4. A -> B : {Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({B.Kab'}_Kat) /\\ secret(Kab',sec_1,{A,B,T})\n\n\t\t2. State=1 /\\ RCV({B.Nb'}_Kab) =|> State':=2  /\\ SND({Nb'}_Kab) \n                   \n                   %% A checks that B uses the same key\n                   %% that he sent at step 1.\n                   /\\ witness(A,B,auth_1,Kab)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ request(A,B,auth_2,Nb')\nend role_A\n\nrole role_T(T:agent,A:agent,B:agent,Kat,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Kab':text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.Kab'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({A.Kab'}_Kbt) \nend role_T\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.Kab'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({B.Nb'}_Kab')\n\n                   %% B hopes that Kab will permit to authenticate him\n                   /\\ witness(B,A,auth_1,Kab')\n\n                2. State=1 /\\ RCV({Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(B,A,auth_2,Nb)\nend role_B\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,i,kit}    %% ... and we give it to the intruder\n\tcomposition\n                      %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n                      %% in parallel with another regular session\n                  /\\ session(alice,bob,trusted,kat,kbt) \n\n                      %% and a session between the intruder (with key kit) and bob\n                  /\\ session(i,bob,trusted,kit,kbt) \n                      %% and a session between alice and the intruder (with key kit)\n                  /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of sec_1\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n\nenvironment()", "```hlpsl\n%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (optimized)\n%%% 1. A -> T : {B,Kab}_Kat\n%%% 2. T -> B : {A,Kab}_Kbt\n%%% 3. B -> A : {B,Nb}_Kab\n%%% 4. A -> B : {Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({B.Kab'}_Kat) /\\ secret(Kab',sec_1,{A,B,T})\n\n\t\t2. State=1 /\\ RCV({B.Nb'}_Kab) =|> State':=2  /\\ SND({Nb'}_Kab) \n                   \n                   %% A checks that B uses the same key\n                   %% that he sent at step 1.\n                   /\\ witness(A,B,auth_1,Kab)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ request(A,B,auth_2,Nb')\nend role_A\n\nrole role_T(T:agent,A:agent,B:agent,Kat,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Kab':text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.Kab'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({A.Kab'}_Kbt) \nend role_T\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.Kab'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({B.Nb'}_Kab')\n\n                   %% B hopes that Kab will permit to authenticate him\n                   /\\ witness(B,A,auth_1,Kab')\n\n                2. State=1 /\\ RCV({Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(B,A,auth_2,Nb)\nend role_B\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,i,kit}    %% ... and we give it to the intruder\n\tcomposition\n                      %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n                      %% in parallel with another regular session\n                  /\\ session(alice,bob,trusted,kat,kbt) \n\n                      %% and a session between the intruder (with key kit) and bob\n                  /\\ session(i,bob,trusted,kit,kbt) \n                      %% and a session between alice and the intruder (with key kit)\n                  /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of sec_1\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/PBK-fix-weak-auth.hlpsl": [[true, "%% PROTOCOL*: PBK: Purpose Built Keys Framework\n%% VARIANT: fixed version with weak authentication\n%% PURPOSE: Sender invariance (authentication assuming that the first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {***tag1***,Msg}inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {***tag2***,Nonce}inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: None\n%% NOTES:\n%% Same as before, but specifying only weak authentication.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(dy),\n            Hash       : hash_func,\n            PK_A       : public_key,\n            Tag1,Tag2  : text)\nplayed_by A\ndef=\n\n  local\n    State      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND(A.PK_A.Hash(PK_A))\n               /\\ SND({Tag1.Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A,B,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Tag2.Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole bob (B,A        : agent,\n          SND,RCV    : channel(dy),\n          Hash       : hash_func,\n          PK_A       : public_key,\n          Tag1,Tag2  : text)\nplayed_by B\ndef=\n\n  local\n    State      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV(A.PK_A.Hash(PK_A')) /\\ RCV({Tag1.Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 3 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 3 /\\ RCV({Tag2.Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ request(A,B,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session(A,B        : agent,\n             Hash       : hash_func,\n             PK_A       : public_key,\n             Tag1,Tag2  : text)\ndef=\n\n  local SND,RCV,SNDA,RCVA  : channel (dy)\n\n  composition\n\n     alice(A,B,SND,RCV,Hash,PK_A,Tag1,Tag2)\n  /\\ bob(B,A,SNDA,RCVA,Hash,PK_A,Tag1,Tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment()\ndef=\n\n  const\n    a,b,i          : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key,\n    tag1,tag2      : text\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n     session(a,b,f,pk_a,tag1,tag2)\n  /\\ session(b,a,f,pk_b,tag1,tag2)\n  /\\ session(i,b,f,pk_i,tag1,tag2)\n  /\\ session(a,i,f,pk_a,tag1,tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n  % Sender Invariance (G16)\n  authentication_on msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()", "```hlpsl\n%% PROTOCOL*: PBK: Purpose Built Keys Framework\n%% VARIANT: fixed version with weak authentication\n%% PURPOSE: Sender invariance (authentication assuming that the first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {***tag1***,Msg}inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {***tag2***,Nonce}inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: None\n%% NOTES:\n%% Same as before, but specifying only weak authentication.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(dy),\n            Hash       : hash_func,\n            PK_A       : public_key,\n            Tag1,Tag2  : text)\nplayed_by A\ndef=\n\n  local\n    State      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND(A.PK_A.Hash(PK_A))\n               /\\ SND({Tag1.Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A,B,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Tag2.Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole bob (B,A        : agent,\n          SND,RCV    : channel(dy),\n          Hash       : hash_func,\n          PK_A       : public_key,\n          Tag1,Tag2  : text)\nplayed_by B\ndef=\n\n  local\n    State      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV(A.PK_A.Hash(PK_A')) /\\ RCV({Tag1.Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 3 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 3 /\\ RCV({Tag2.Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ request(A,B,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session(A,B        : agent,\n             Hash       : hash_func,\n             PK_A       : public_key,\n             Tag1,Tag2  : text)\ndef=\n\n  local SND,RCV,SNDA,RCVA  : channel (dy)\n\n  composition\n\n     alice(A,B,SND,RCV,Hash,PK_A,Tag1,Tag2)\n  /\\ bob(B,A,SNDA,RCVA,Hash,PK_A,Tag1,Tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment()\ndef=\n\n  const\n    a,b,i          : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key,\n    tag1,tag2      : text\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n     session(a,b,f,pk_a,tag1,tag2)\n  /\\ session(b,a,f,pk_b,tag1,tag2)\n  /\\ session(i,b,f,pk_i,tag1,tag2)\n  /\\ session(a,i,f,pk_a,tag1,tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n  % Sender Invariance (G16)\n  authentication_on msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/PMAP_D2D.hlpsl": [[true, "%%% PMAP_D2D, a privacy-preserving mutual authentication and key agreement protocol for internet of drones \n%%% between drone and drone\n%%% 1. A -> Z : {A,Z,Na}_CRPa, {A,Z,Na,B}_CRPa\n%%% 2. Z -> A : {A,Z,B,Na,Nz}_CRPa\n%%% 3. A -> Z : {A,Z,B,Nz,Na2}_CRPa, {A,Z,B,Nz,Na2,Ra}_CRPa\n%%% 4. Z -> B : {B,Z,Nz2}_CRPb, {B,Z,Nz2,Na2}_CRPb, {B,Z,Nz2,Na2,A}_CRPb\n%%% 5. B -> Z : {B,Z,A,Nz2,Nb}_CRPb, {B,Z,A,Nz2,Nb,Rb}_CRPb\n%%% 6. Z -> A : {A,Z,B,Na2,Nb}_CRPa\n\nrole role_A(A:agent,B:agent,Z:agent,CRP:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC11,Ca,Ra,K:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n\t\tState':=2 /\\ Na':=new() /\\ MAC12':= Hash({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.Na'.B)\n\t\t/\\ SND({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12')\n\n\t\t2. State=2 /\\ RCV({A.Z.B.Na.Nz'}_CRP.MAC3') =|>\n\t\tState':=6 /\\ Na2':=new() /\\ Ca':={Nz'.Na2'}_CRP /\\ Ra':=Hash(Ca')\n\t\t/\\ MAC45':= Hash({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.Na2'.Ra')\n\t\t/\\ SND({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.MAC45')\n\t\t/\\ secret(Na',sec_1,{A,Z}) /\\ secret(Ra',sec_6,{A,Z})\n\n\t\t/\\ request(A,Z,auth_1,Na') \n\t\t/\\ witness(A,Z,auth_2,Nz')\n\n\t\t3. State=6 /\\ RCV({A.Z.B.Na2.Nb'}_CRP.MAC11') =|>\n\t\tState':=9 /\\ K':= xor(Hash(Na2),Hash(Nb'))\n\n\t\t/\\ request(A,Z,auth_4,Na2)\nend role\n\nrole role_Z(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by Z\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nz2,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC678,MAC910,MAC11,Ca,Ra,Cb,Rb:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12') =|>\n\t\tState':=3 /\\ Nz':=new() /\\ Nz2':=new() /\\ MAC3':=Hash({A.Z.B.Na'.Nz'}_CRP.Na'.Nz')\n\t\t/\\ SND({A.Z.B.Na'.Nz'}_CRP.MAC3')\n\t\t/\\ secret(Na',sec_1,{A,Z})\n\n\t\t/\\ witness(Z,A,auth_1,Na')\n\n\t\t2. State=3 /\\ RCV({A.Z.B.Nz.Na2'}_CRP.{A.Z.B.Nz.Na2'.Ra'}_CRP.MAC45') =|>\n\t\tState':=5 /\\ MAC678':=Hash({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.Nz2.Na2'.A)\n\t\t/\\ SND({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.MAC678')\n\t\t/\\ secret(Na2',sec_3,{B,Z})\n\n\t\t/\\ request(Z,A,auth_2,Nz')\n\n\t\t\n\t\t3. State=5 /\\ RCV({B.Z.A.Nz2.Nb'}_CRPb.{B.Z.A.Nz2.Nb'.Rb'}_CRPb.MAC910') =|>\n\t\tState':=7 /\\ Cb':= {Nz2.Nb'}_CRPb\n\t\t/\\ MAC11':= Hash({A.Z.B.Na2.Nb'}_CRP.Na2.Nb')\n\t\t/\\ SND({A.Z.B.Na2.Nb'}_CRP.MAC11')\n\n\t\t/\\ witness(Z,B,auth_3,Nz2)\n\t\t/\\ witness(Z,A,auth_4,Na2)\nend role\n\nrole role_B(A:agent,B:agent,Z:agent,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa2,Nz2,Nb:text,\n\t\tMAC678,MAC910,Cb,Rb,K:message\n\tinit\n\t\tState := 4\n\ttransition\n\t\t1. State=4 /\\ RCV({B.Z.Nz2'}_CRPb.{B.Z.Nz2'.Na2'}_CRPb.{B.Z.Nz2'.Na2'.A}_CRPb.MAC678') =|>\n\t\tState':=8 /\\ Nb':=new() /\\ Cb':={Nz2'.Nb'}_CRPb /\\ Rb':=Hash(Cb')\n\t\t/\\ MAC910':= Hash({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.Nb'.Rb')\n\t\t/\\ K':= xor(Hash(Nb'),Hash(Na2'))\n\t\t/\\ SND({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.MAC910')\n\t\t/\\ secret(Nb',sec_5,{A,B,Z}) /\\ secret(Rb',sec_5,{B,Z})\n\n\t\t/\\ request(B,Z,auth_3,Nz2')\n\nend role\n\nrole session(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\n\t\trole_A(A,B,Z,CRP,Hash,SND1,RCV1) /\\\n\t\trole_Z(A,B,Z,CRP,CRPb,Hash,SND2,RCV2) /\\\n\t\trole_B(A,B,Z,CRPb,Hash,SND3,RCV3)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone1,drone2,groundstation:agent,\n\t\tcrp,crpb:symmetric_key,\n\t\th:hash_func,\n\t\tsec_1,sec_2,sec_3,sec_4,sec_5,sec_6,auth_1,auth_2,auth_3,auth_4:protocol_id\n\tintruder_knowledge = {drone1,drone2,groundstation,h}\n\n\tcomposition\n\t\tsession(drone1,drone2,groundstation,crp,crpb,h)\n\t\t/\\ session(drone1,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(i,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,i,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,drone2,i,crp,crpb,h)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_3\n\tsecrecy_of sec_5\n\tsecrecy_of sec_6\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\n\tauthentication_on auth_4\nend goal\n\nenvironment()", "```hlpsl\n%%% PMAP_D2D, a privacy-preserving mutual authentication and key agreement protocol for internet of drones \n%%% between drone and drone\n%%% 1. A -> Z : {A,Z,Na}_CRPa, {A,Z,Na,B}_CRPa\n%%% 2. Z -> A : {A,Z,B,Na,Nz}_CRPa\n%%% 3. A -> Z : {A,Z,B,Nz,Na2}_CRPa, {A,Z,B,Nz,Na2,Ra}_CRPa\n%%% 4. Z -> B : {B,Z,Nz2}_CRPb, {B,Z,Nz2,Na2}_CRPb, {B,Z,Nz2,Na2,A}_CRPb\n%%% 5. B -> Z : {B,Z,A,Nz2,Nb}_CRPb, {B,Z,A,Nz2,Nb,Rb}_CRPb\n%%% 6. Z -> A : {A,Z,B,Na2,Nb}_CRPa\n\nrole role_A(A:agent,B:agent,Z:agent,CRP:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC11,Ca,Ra,K:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n\t\tState':=2 /\\ Na':=new() /\\ MAC12':= Hash({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.Na'.B)\n\t\t/\\ SND({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12')\n\n\t\t2. State=2 /\\ RCV({A.Z.B.Na.Nz'}_CRP.MAC3') =|>\n\t\tState':=6 /\\ Na2':=new() /\\ Ca':={Nz'.Na2'}_CRP /\\ Ra':=Hash(Ca')\n\t\t/\\ MAC45':= Hash({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.Na2'.Ra')\n\t\t/\\ SND({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.MAC45')\n\t\t/\\ secret(Na',sec_1,{A,Z}) /\\ secret(Ra',sec_6,{A,Z})\n\n\t\t/\\ request(A,Z,auth_1,Na') \n\t\t/\\ witness(A,Z,auth_2,Nz')\n\n\t\t3. State=6 /\\ RCV({A.Z.B.Na2.Nb'}_CRP.MAC11') =|>\n\t\tState':=9 /\\ K':= xor(Hash(Na2),Hash(Nb'))\n\n\t\t/\\ request(A,Z,auth_4,Na2)\nend role\n\nrole role_Z(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by Z\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nz2,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC678,MAC910,MAC11,Ca,Ra,Cb,Rb:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12') =|>\n\t\tState':=3 /\\ Nz':=new() /\\ Nz2':=new() /\\ MAC3':=Hash({A.Z.B.Na'.Nz'}_CRP.Na'.Nz')\n\t\t/\\ SND({A.Z.B.Na'.Nz'}_CRP.MAC3')\n\t\t/\\ secret(Na',sec_1,{A,Z})\n\n\t\t/\\ witness(Z,A,auth_1,Na')\n\n\t\t2. State=3 /\\ RCV({A.Z.B.Nz.Na2'}_CRP.{A.Z.B.Nz.Na2'.Ra'}_CRP.MAC45') =|>\n\t\tState':=5 /\\ MAC678':=Hash({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.Nz2.Na2'.A)\n\t\t/\\ SND({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.MAC678')\n\t\t/\\ secret(Na2',sec_3,{B,Z})\n\n\t\t/\\ request(Z,A,auth_2,Nz')\n\n\t\t\n\t\t3. State=5 /\\ RCV({B.Z.A.Nz2.Nb'}_CRPb.{B.Z.A.Nz2.Nb'.Rb'}_CRPb.MAC910') =|>\n\t\tState':=7 /\\ Cb':= {Nz2.Nb'}_CRPb\n\t\t/\\ MAC11':= Hash({A.Z.B.Na2.Nb'}_CRP.Na2.Nb')\n\t\t/\\ SND({A.Z.B.Na2.Nb'}_CRP.MAC11')\n\n\t\t/\\ witness(Z,B,auth_3,Nz2)\n\t\t/\\ witness(Z,A,auth_4,Na2)\nend role\n\nrole role_B(A:agent,B:agent,Z:agent,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa2,Nz2,Nb:text,\n\t\tMAC678,MAC910,Cb,Rb,K:message\n\tinit\n\t\tState := 4\n\ttransition\n\t\t1. State=4 /\\ RCV({B.Z.Nz2'}_CRPb.{B.Z.Nz2'.Na2'}_CRPb.{B.Z.Nz2'.Na2'.A}_CRPb.MAC678') =|>\n\t\tState':=8 /\\ Nb':=new() /\\ Cb':={Nz2'.Nb'}_CRPb /\\ Rb':=Hash(Cb')\n\t\t/\\ MAC910':= Hash({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.Nb'.Rb')\n\t\t/\\ K':= xor(Hash(Nb'),Hash(Na2'))\n\t\t/\\ SND({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.MAC910')\n\t\t/\\ secret(Nb',sec_5,{A,B,Z}) /\\ secret(Rb',sec_5,{B,Z})\n\n\t\t/\\ request(B,Z,auth_3,Nz2')\n\nend role\n\nrole session(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\n\t\trole_A(A,B,Z,CRP,Hash,SND1,RCV1) /\\\n\t\trole_Z(A,B,Z,CRP,CRPb,Hash,SND2,RCV2) /\\\n\t\trole_B(A,B,Z,CRPb,Hash,SND3,RCV3)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone1,drone2,groundstation:agent,\n\t\tcrp,crpb:symmetric_key,\n\t\th:hash_func,\n\t\tsec_1,sec_2,sec_3,sec_4,sec_5,sec_6,auth_1,auth_2,auth_3,auth_4:protocol_id\n\tintruder_knowledge = {drone1,drone2,groundstation,h}\n\n\tcomposition\n\t\tsession(drone1,drone2,groundstation,crp,crpb,h)\n\t\t/\\ session(drone1,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(i,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,i,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,drone2,i,crp,crpb,h)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_3\n\tsecrecy_of sec_5\n\tsecrecy_of sec_6\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\n\tauthentication_on auth_4\nend goal\n\nenvironment()\n```"]], "HLPSL-1/practice3.hlpsl": [[true, "%%%ESPECIFICATIONS OF THE PROBLEM%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%Agents:A Client,B Service Delivery Server, S Authentication Server%%%%%\n\n%Objectives/Goals:establishing a session key between A and B,mutual authentication between A and B\n\n%Assumptions and Restrictions:A has a symmetric key shared with S,B has a symmetric key shared with S,only S can generate session keys,do not use timestamps,efficiency in the messages structure and their number\n\n\n%role of cliente interpreted by alice%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A,S,B :agent,\n\t   Ka \t\t: symmetric_key,\n\t   SND_SA, RCV_SA, SND_BA, RCV_BA :channel(dy))\n\nplayed_by A\ndef=\n\tlocal State\t: nat,\n\tNa,Ns,Nb\t: text,\n\tK\t\t:symmetric_key,\n\tX\t\t:{symmetric_key.text.text.text}_symmetric_key\n\ninit State :=0\n\ntransition\n\n\t1. State =0     /\\ RCV_BA(start)=|>\n\t   State':=2    /\\ Na':=new()\n\t    \t        /\\ SND_SA(A.B.{Na'}_Ka)\n\n\t2. State =2\t/\\ RCV_SA(A.B.{K'.Na.Ns'}_Ka.X')=|>\n\t   State' :=4\t/\\ SND_BA(A.B.X'.{Na.Ns'}_K')\n\n\t3. State =4\t/\\ RCV_BA(A.B.{Ns.Nb.Na}_K)=|>\n\t   State' :=6\t/\\ request(A,B,alice_bob_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%role of the server authenticator %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole server(A,B,S \t:agent,\n\t   Ka,Kb\t:symmetric_key,\n\t   SND_AS, RCV_AS, RCV_BS :channel(dy))\n\nplayed_by S\ndef=\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State :=1\n\ntransition\n\n\t1. State =1 \t/\\ RCV_AS(A.B.{Na'}_Ka)\n\t\t\t/\\ RCV_BS(A.B.{Nb'}_Kb)=|>\n\t   State':=3\t/\\ Ns':=new()/\\K':=new()\n\t\t\t/\\ SND_AS(A.B.{K'.Na'.Ns'}_Ka.{K'.Na'.Nb'.Ns'}_Kb)\n\t\t\t/\\ secret(K',k,{A,B,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of service server interpreted by bob%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole bob(A,S,B\t:agent,\n\t   Kb\t:symmetric_key,\n\t   SND_AB, RCV_AB, SND_BS :channel(dy))\n\nplayed_by B\ndef=\n\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State:=0\n\ntransition\n\n\t1.State =0 \t/\\ RCV_AB(start)=|>\n\t  State':=2\t/\\Nb':=new()\n\t\t\t/\\ SND_BS(A.B.{Nb'}_Kb)\n\t\n\n\t\n\t3.State =5 \t/\\ RCV_AB(A.B.{K'.Na'.Nb'.Ns'}_Kb.{Na'.Ns'}_K')=|>\n\t  State' :=7 \t/\\ SND_AB(A.B.{Ns'.Nb.Na'}_K')\n\t\t\t/\\ witness(B,A,alice_bob_na,Na')\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of session to allow only S can generate sessions%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,S,B : agent,\n\t     Ka,Kb\t:symmetric_key)\n\ndef=\n\tlocal\n\t  SSA,RSA,\n\t  SBA,RBA,\n\t  SAS,RAS,\n\t  SAB,RAB,\n\t  SBS,RBS: channel(dy)\n\t\n\tcomposition\n\t\n\t\talice (A,S,B,Ka,SSA,RSA,SBA,RBA)\n\t     /\\ server(A,S,B,Ka,Kb,SAS,RAS,RBS)\n\t     /\\ bob   (A,S,B,Kb,SAB,RAB,SBS)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\tconst a,b,s\t:agent,\n\t      ka,kb,ki  :symmetric_key,\t\n\t      alice_bob_na, k :protocol_id\n\n\tintruder_knowledge={a,b,s,ki}\n\n\tcomposition\n\t\t\n\t\t   session(a,s,b,ka,kb)\n\t\t/\\ session(a,s,i,ka,ki)\n\t\t/\\ session(i,s,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal \n  secrecy_of k\n  authentication_on alice_bob_na\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()", "```hlpsl\n%%%ESPECIFICATIONS OF THE PROBLEM%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%Agents:A Client,B Service Delivery Server, S Authentication Server%%%%%\n\n%Objectives/Goals:establishing a session key between A and B,mutual authentication between A and B\n\n%Assumptions and Restrictions:A has a symmetric key shared with S,B has a symmetric key shared with S,only S can generate session keys,do not use timestamps,efficiency in the messages structure and their number\n\n\n%role of cliente interpreted by alice%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A,S,B :agent,\n\t   Ka \t\t: symmetric_key,\n\t   SND_SA, RCV_SA, SND_BA, RCV_BA :channel(dy))\n\nplayed_by A\ndef=\n\tlocal State\t: nat,\n\tNa,Ns,Nb\t: text,\n\tK\t\t:symmetric_key,\n\tX\t\t:{symmetric_key.text.text.text}_symmetric_key\n\ninit State :=0\n\ntransition\n\n\t1. State =0     /\\ RCV_BA(start)=|>\n\t   State':=2    /\\ Na':=new()\n\t    \t        /\\ SND_SA(A.B.{Na'}_Ka)\n\n\t2. State =2\t/\\ RCV_SA(A.B.{K'.Na.Ns'}_Ka.X')=|>\n\t   State' :=4\t/\\ SND_BA(A.B.X'.{Na.Ns'}_K')\n\n\t3. State =4\t/\\ RCV_BA(A.B.{Ns.Nb.Na}_K)=|>\n\t   State' :=6\t/\\ request(A,B,alice_bob_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%role of the server authenticator %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole server(A,B,S \t:agent,\n\t   Ka,Kb\t:symmetric_key,\n\t   SND_AS, RCV_AS, RCV_BS :channel(dy))\n\nplayed_by S\ndef=\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State :=1\n\ntransition\n\n\t1. State =1 \t/\\ RCV_AS(A.B.{Na'}_Ka)\n\t\t\t/\\ RCV_BS(A.B.{Nb'}_Kb)=|>\n\t   State':=3\t/\\ Ns':=new()/\\K':=new()\n\t\t\t/\\ SND_AS(A.B.{K'.Na'.Ns'}_Ka.{K'.Na'.Nb'.Ns'}_Kb)\n\t\t\t/\\ secret(K',k,{A,B,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of service server interpreted by bob%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole bob(A,S,B\t:agent,\n\t   Kb\t:symmetric_key,\n\t   SND_AB, RCV_AB, SND_BS :channel(dy))\n\nplayed_by B\ndef=\n\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State:=0\n\ntransition\n\n\t1.State =0 \t/\\ RCV_AB(start)=|>\n\t  State':=2\t/\\Nb':=new()\n\t\t\t/\\ SND_BS(A.B.{Nb'}_Kb)\n\t\n\n\t\n\t3.State =5 \t/\\ RCV_AB(A.B.{K'.Na'.Nb'.Ns'}_Kb.{Na'.Ns'}_K')=|>\n\t  State' :=7 \t/\\ SND_AB(A.B.{Ns'.Nb.Na'}_K')\n\t\t\t/\\ witness(B,A,alice_bob_na,Na')\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of session to allow only S can generate sessions%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,S,B : agent,\n\t     Ka,Kb\t:symmetric_key)\n\ndef=\n\tlocal\n\t  SSA,RSA,\n\t  SBA,RBA,\n\t  SAS,RAS,\n\t  SAB,RAB,\n\t  SBS,RBS: channel(dy)\n\t\n\tcomposition\n\t\n\t\talice (A,S,B,Ka,SSA,RSA,SBA,RBA)\n\t     /\\ server(A,S,B,Ka,Kb,SAS,RAS,RBS)\n\t     /\\ bob   (A,S,B,Kb,SAB,RAB,SBS)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\tconst a,b,s\t:agent,\n\t      ka,kb,ki  :symmetric_key,\t\n\t      alice_bob_na, k :protocol_id\n\n\tintruder_knowledge={a,b,s,ki}\n\n\tcomposition\n\t\t\n\t\t   session(a,s,b,ka,kb)\n\t\t/\\ session(a,s,i,ka,ki)\n\t\t/\\ session(i,s,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal \n  secrecy_of k\n  authentication_on alice_bob_na\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()\n```"]], "HLPSL-1/Project1Protocol.hlpsl": [[true, "% 1. A -> B: A\n% 2. B -> A: {A,Nb'})_Kbs\n% 3. A -> S: A,B,Na,{A,Nb'}_Kbs\n% 4. S -> A: {Na,Kab,B,{Kab,A,Nb'}Kbs}Kas\n% 5. A -> B: {Kab,A,Nb'}_Kbs, {Na',A}_Kab\n% 6. B -> A: {Nb'.B}_Kab\n\nrole alice(ROLE_1) role alice (A,B,S : agent,\n            K_AS : symmetric_key,\n            Snd,Rcv : channel(dy)) \n        \nplayed_by A def=     \n\n    local State: nat,\n          Na,Nb: text,\n          K_AB, K_BS:symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=0 /\\ Rcv(start)\n            =|> State':=1 /\\ Snd(A)\n\n        2. State=1 /\\ Rcv({A.Nb'}_K_BS')\n            =|> State':=2 /\\ Na':=new() \n                          /\\ Snd({A.B.Na'.{A.Nb'}_K_BS'}_K_AS)\n\n        3. State=2 /\\ Rcv({Na.K_AB'.B.{K_AB'.A.Nb'}_K_BS}_K_AS)\n            =|> State':=3 /\\ Snd({K_AB'.A.Nb'}_K_BS.{Na'.A}_K_AB')\n\n        4. State=3 /\\ Rcv({Nb'.B}_K_AB')\n            =|> State':=4 /\\ Na':=new()   \n                          /\\ secret(Na', sna, {A,B,S})   \n\n        5. State=2 /\\ Rcv({Nb'.B}_K_AB')\n            =|> State':=5 /\\ request(A,B,bob_alice_nb, Nb')\nend role\n\nrole bob (B,A,S: agent,\n          K_BS: symmetric_key,\n          Snd,Rcv: channel(dy)) \n\nplayed_by B def=\n\n    local State: nat,\n          Na,Nb: text,\n          K_AB: symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=0 /\\ Rcv(A')\n            =|> State':=1 /\\ Nb':=new()\n                          /\\ Snd({A'.Nb'}_K_BS)\n\n        2. State=1 /\\ Rcv({K_AB'.A'.Nb'}_K_BS) \n            =|> State':=2 /\\ Snd(B)\n            \n        3. State=2 /\\ Rcv({Na'.A}_K_AB')                \n            =|> State':=3 /\\ Nb':=new() \n                          /\\ Snd({Nb'.B}_K_AB')  \n                          /\\ request(B,A,alice_bob_na,Na')\n                          /\\ witness(B,A,alice_bob_na,Na') \nend role\n\nrole server (S: agent,\n             K_AS,K_BS: symmetric_key,\n             Snd, Rcv: channel(dy))\n              \nplayed_by S def=\n    \n    local A,B : agent,\n          Na,Nb : text,\n          K_AB : symmetric_key\n\n    transition\n     1. Rcv({A'.B'.Na'.{A'.Nb'}_K_BS'}_K_AS)\n        =|> K_AB':=new() /\\ Snd({K_AB'.Na.B.{K_AB'.A'.Nb'}_K_BS}_K_AS)\n                         /\\ secret(K_AB', skab, {A,B,S})\n        \nend role\n\nrole securityProtocol(A,B,S: agent,\n                      K_AS,K_BS: symmetric_key,\n                      Snd,Rcv : channel(dy)) def=\n    \n    composition\n        alice(A,B,S,K_AS,Snd,Rcv) /\\\n        server(S,K_AS,K_BS,Snd,Rcv) /\\\n        bob(B,A,S,K_BS,Snd,Rcv) \n                      \nend role\n\nrole environment() def=\n\n    local Snd, Rcv: channel(dy)\n\n    const a, b, s, i: agent,\n          k_as, k_bs, k_is: symmetric_key,\n          ki: public_key,\n          sna,snb,alice_bob_na, skab,bob_alice_nb: protocol_id\n\n    intruder_knowledge = {a,b,s,i,k_is,inv(ki)}\n\n    composition\n        securityProtocol(a,b,s,k_as,k_bs,Snd,Rcv) /\\\n        % securityProtocol(i,b,s,k_is,k_bs,Snd,Rcv) /\\\n        securityProtocol(a,i,s,k_as,k_is,Snd,Rcv) \n\nend role\n\ngoal\n    %weak_authentication_on alice_bob_na\n    % works like this\n    %weak_authentication_on bob_alice_nb\n    secrecy_of skab\nend goal\n\nenvironment()", "```hlpsl\n% 1. A -> B: A\n% 2. B -> A: {A,Nb'})_Kbs\n% 3. A -> S: A,B,Na,{A,Nb'}_Kbs\n% 4. S -> A: {Na,Kab,B,{Kab,A,Nb'}Kbs}Kas\n% 5. A -> B: {Kab,A,Nb'}_Kbs, {Na',A}_Kab\n% 6. B -> A: {Nb'.B}_Kab\n\nrole alice(ROLE_1) role alice (A,B,S : agent,\n            K_AS : symmetric_key,\n            Snd,Rcv : channel(dy)) \n        \nplayed_by A def=     \n\n    local State: nat,\n          Na,Nb: text,\n          K_AB, K_BS:symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=0 /\\ Rcv(start)\n            =|> State':=1 /\\ Snd(A)\n\n        2. State=1 /\\ Rcv({A.Nb'}_K_BS')\n            =|> State':=2 /\\ Na':=new() \n                          /\\ Snd({A.B.Na'.{A.Nb'}_K_BS'}_K_AS)\n\n        3. State=2 /\\ Rcv({Na.K_AB'.B.{K_AB'.A.Nb'}_K_BS}_K_AS)\n            =|> State':=3 /\\ Snd({K_AB'.A.Nb'}_K_BS.{Na'.A}_K_AB')\n\n        4. State=3 /\\ Rcv({Nb'.B}_K_AB')\n            =|> State':=4 /\\ Na':=new()   \n                          /\\ secret(Na', sna, {A,B,S})   \n\n        5. State=2 /\\ Rcv({Nb'.B}_K_AB')\n            =|> State':=5 /\\ request(A,B,bob_alice_nb, Nb')\nend role\n\nrole bob (B,A,S: agent,\n          K_BS: symmetric_key,\n          Snd,Rcv: channel(dy)) \n\nplayed_by B def=\n\n    local State: nat,\n          Na,Nb: text,\n          K_AB: symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=0 /\\ Rcv(A')\n            =|> State':=1 /\\ Nb':=new()\n                          /\\ Snd({A'.Nb'}_K_BS)\n\n        2. State=1 /\\ Rcv({K_AB'.A'.Nb'}_K_BS) \n            =|> State':=2 /\\ Snd(B)\n            \n        3. State=2 /\\ Rcv({Na'.A}_K_AB')                \n            =|> State':=3 /\\ Nb':=new() \n                          /\\ Snd({Nb'.B}_K_AB')  \n                          /\\ request(B,A,alice_bob_na,Na')\n                          /\\ witness(B,A,alice_bob_na,Na') \nend role\n\nrole server (S: agent,\n             K_AS,K_BS: symmetric_key,\n             Snd, Rcv: channel(dy))\n              \nplayed_by S def=\n    \n    local A,B : agent,\n          Na,Nb : text,\n          K_AB : symmetric_key\n\n    transition\n     1. Rcv({A'.B'.Na'.{A'.Nb'}_K_BS'}_K_AS)\n        =|> K_AB':=new() /\\ Snd({K_AB'.Na.B.{K_AB'.A'.Nb'}_K_BS}_K_AS)\n                         /\\ secret(K_AB', skab, {A,B,S})\n        \nend role\n\nrole securityProtocol(A,B,S: agent,\n                      K_AS,K_BS: symmetric_key,\n                      Snd,Rcv : channel(dy)) def=\n    \n    composition\n        alice(A,B,S,K_AS,Snd,Rcv) /\\\n        server(S,K_AS,K_BS,Snd,Rcv) /\\\n        bob(B,A,S,K_BS,Snd,Rcv) \n                      \nend role\n\nrole environment() def=\n\n    local Snd, Rcv: channel(dy)\n\n    const a, b, s, i: agent,\n          k_as, k_bs, k_is: symmetric_key,\n          ki: public_key,\n          sna,snb,alice_bob_na, skab,bob_alice_nb: protocol_id\n\n    intruder_knowledge = {a,b,s,i,k_is,inv(ki)}\n\n    composition\n        securityProtocol(a,b,s,k_as,k_bs,Snd,Rcv) /\\\n        % securityProtocol(i,b,s,k_is,k_bs,Snd,Rcv) /\\\n        securityProtocol(a,i,s,k_as,k_is,Snd,Rcv) \n\nend role\n\ngoal\n    %weak_authentication_on alice_bob_na\n    % works like this\n    %weak_authentication_on bob_alice_nb\n    secrecy_of skab\nend goal\n\nenvironment()\n```"]], "HLPSL-1/An_Anonymous_Key_Distribution_Scheme_for_Group_Healthcare_Services_in_5G-Enabled_Multi-Server_Environments.hlpsl": [[true, "role user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new() /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(g2,sec_2,{U}) /\\ witness(U,S,id_i,g2) /\\ secret(biometric,g3,{U}) /\\ witness(U,S,bi,g3) /\\ witness(U,S,pw,g3)\n2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi & Bi in the smart card %/\\ Store Ej', IDj, & Nj in the USB\n% Login and authentication phase\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card %/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose bij = 3\n/\\ N' := H(H(H(V'))) /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) /\\ Yij' := xor(E,Ej) /\\ Tu' := new() /\\ A' := xor(xor(BBi',W'),Tu') /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_tu,Tu') /\\ witness(U,S,id_i,g2) /\\ witness(U,S,pw,g3) /\\ witness(U,S,bi,g3)\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts' %/\\ Confirm B %/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts') /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ request(S,U,s_u_ts,Ts')\nend role\n\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, X, Y, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({IDi.Nj.Yij'}_Kus)\n/\\ secret(x_j,g5,{S})\n% Login and authentication phase\n2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu' %/\\ Use Xj to decrypt Yij %/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi.W).Tu')\n%/\\ Confirm A\n/\\ Ts' := new() /\\ B' := xor(H(H(H(H(V')))),Ts') /\\ IDinew' := H(Yij.IDi.H(Xj)) /\\ SKij' := H(xor(H(H(H(V'))),Yij)) /\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion. The server calculates ck0 and hide it into the following multiple equations, in which C1, C2 and C3 are predetermined, and Hj is equal to H4(skij||T2).\n/\\ C1' := new() /\\ C2' := new() /\\ C3' := new() /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3'))) /\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_tu,Tu') /\\ request(U,S,id_i,g2)\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func) def=\nlocal SU, US, RS: channel (dy)\ncomposition\nuser (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SU,US) /\\ server (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SS,RS)\nend role\n\nrole environment() def=\nconst u, s, i: agent,\nkus, skij, kui: symmetric_key,\nks, ki: public_key,\nh, h4, h5, sub, add, mul: hash_func,\nu_s_v, u_s_tu, s_u_ts, id_i, id_j, pw, bi, x_j, sec_2, sec_3, sec_5: protocol_id\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\ncomposition\nsession(u,s,kus,skij,ks,h,h4,h5,sub,add,mul) /\\ session(u,i,kui,kui,ks,h,h4,h5,sub,add,mul) /\\ session(i,s,kui,kui,ks,h,h4,h5,sub,add,mul)\nend role\n\ngoal\nsecrecy_of id_i, sec_2, sec_3, x_j, sec_5\nauthentication_on u_s_tu, s_u_ts\nend goal\n\nenvironment()", "```hlpsl\nrole user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new() /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(g2,sec_2,{U}) /\\ witness(U,S,id_i,g2) /\\ secret(biometric,g3,{U}) /\\ witness(U,S,bi,g3) /\\ witness(U,S,pw,g3)\n2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi & Bi in the smart card %/\\ Store Ej', IDj, & Nj in the USB\n% Login and authentication phase\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card %/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose bij = 3\n/\\ N' := H(H(H(V'))) /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) /\\ Yij' := xor(E,Ej) /\\ Tu' := new() /\\ A' := xor(xor(BBi',W'),Tu') /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_tu,Tu') /\\ witness(U,S,id_i,g2) /\\ witness(U,S,pw,g3) /\\ witness(U,S,bi,g3)\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts' %/\\ Confirm B %/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts') /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ request(S,U,s_u_ts,Ts')\nend role\n\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, X, Y, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({IDi.Nj.Yij'}_Kus)\n/\\ secret(x_j,g5,{S})\n% Login and authentication phase\n2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu' %/\\ Use Xj to decrypt Yij %/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi.W).Tu')\n%/\\ Confirm A\n/\\ Ts' := new() /\\ B' := xor(H(H(H(H(V')))),Ts') /\\ IDinew' := H(Yij.IDi.H(Xj)) /\\ SKij' := H(xor(H(H(H(V'))),Yij)) /\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion. The server calculates ck0 and hide it into the following multiple equations, in which C1, C2 and C3 are predetermined, and Hj is equal to H4(skij||T2).\n/\\ C1' := new() /\\ C2' := new() /\\ C3' := new() /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3'))) /\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_tu,Tu') /\\ request(U,S,id_i,g2)\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func) def=\nlocal SU, US, RS: channel (dy)\ncomposition\nuser (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SU,US) /\\ server (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SS,RS)\nend role\n\nrole environment() def=\nconst u, s, i: agent,\nkus, skij, kui: symmetric_key,\nks, ki: public_key,\nh, h4, h5, sub, add, mul: hash_func,\nu_s_v, u_s_tu, s_u_ts, id_i, id_j, pw, bi, x_j, sec_2, sec_3, sec_5: protocol_id\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\ncomposition\nsession(u,s,kus,skij,ks,h,h4,h5,sub,add,mul) /\\ session(u,i,kui,kui,ks,h,h4,h5,sub,add,mul) /\\ session(i,s,kui,kui,ks,h,h4,h5,sub,add,mul)\nend role\n\ngoal\nsecrecy_of id_i, sec_2, sec_3, x_j, sec_5\nauthentication_on u_s_tu, s_u_ts\nend goal\n\nenvironment()\n```"]], "HLPSL-1/Projet.hlpsl": [[true, "%%Purpose : Gestion d'un \"badge\" automatique pour les p\u00e9ages autoroutiers via le smartphone du client\n\n\n%% 1. Client -> Server : {Bonjour.C}_PKs\n\n%% (Server <--> BDD : get Pkc(C) )\n\n%% 2. Server -> Client : {Ns.Server}_PKc\n%% 3. Client -> Server : {Nc.Ns}_PKs\n%% 4. Server -> Client : {Nc.ClefSession}_PKc\n%% 5. Client -> Server : {IDSmartPhone}_ClefSession\n\n%% (Server <--> BDD : get solde(IDSmpartphone)\n%% if soldeClient > 0 ? ack\n%% else\n%% refuse)\n\n%% 6. Server -> Client : {Ack}_ClefSession\n%% 7. Client -> Server : {End}_ClefSession\n\n\n\n%% PKc, PKs respectivement les clefs publiques de Client et Serveur\n%% ClefSession une clef sym\u00e9trique fra\u00eeche\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le client, initiant le protocole\nrole client (Client, Server: agent,\n              PKc, PKs: public_key,\n              SND, RCV: channel(dy),\n              Bonjour, Ack, IDSmartPhone : text)\n\n\nplayed_by Client def=\n  local State: nat,\n          Nc, Ns: text,\n          ClefSession: symmetric_key\n\n  init State:=0\n\n  transition\n\n  0.  State=0 /\\ RCV(start) =|>\n\tState':=1 /\\ SND({Bonjour.Client}_PKs)\n\n  1. State=1 /\\ RCV({Ns'.Server}_PKc) =|>\n\tState':=2 /\\ Nc':=new() /\\ witness(Client, Server, server_client_nc, {Nc', ns, {Nc', Server}}) /\\ SND({Nc'.Ns'}_PKs) /\\ request(Client, Server, client_server_ns, Ns')\n\n  2. State=2 /\\ RCV({Nc.ClefSession'}_PKc)=|>\n  State':=3 /\\ secret(IDSmartPhone, idsmart, {Client, Server}) /\\ SND({IDSmartPhone}_ClefSession')\n\n  3. State=3 /\\ RCV({Ack}_ClefSession)=|>\n  State':=4 /\\ SND({End}_ClefSession) /\\ request(Client, Server, client_server_ns, Ns)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le server\nrole server (Server: agent,\n              PKs: public_key,\n              SND, RCV: channel(dy),\n\t\t\t        Ack, Bonjour: text,\n\t\t\t        Database_users: (agent.public_key) set,\n\t\t\t        Database_solde: (text.nat) set)\n\n\nplayed_by Server def=\n  local State: nat,\n          ClefSession: symmetric_key,\n        \tNs,Nc, IDSmartPhone: text,\n        \tPKc: public_key,\n\t\t\tClient: agent,\n\t\t\tSoldeClient : nat\n\n  init State:=0\n\n  transition\n\n  0. State=0 /\\ RCV({Bonjour.Client'}_PKs) /\\ in(Client'.PKc', Database_users) =|>\n\tState':=1 /\\ Ns':=new() /\\ secret(Ns', ns, {Client', Server}) /\\ witness(Server, Client', server_client_ns, Ns') /\\ SND({Ns'.Server}_PKc')\n\n  1. State=1 /\\ RCV({Nc'.Ns}_PKs) =|>\n  State':=2 /\\ ClefSession':=new() /\\ secret(ClefSession', clefsession, {Client, Server}) /\\ SND({Nc'.ClefSession'}_PKc)\n\n  2. State=2 /\\ RCV({IDSmartPhone'}_ClefSession) /\\ in(IDSmartPhone'.SoldeClient', Database_solde) /\\ not(SoldeClient=0) =|>\n  State':=3 /\\ SND({Ack}_ClefSession) /\\ request(Server, Client, client_server_nc, Nc)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(Client,\n              Server: agent,\n              PKc, PKs: public_key,\n              SND, RCV: channel(dy),\n              Bonjour, Ack, IDSmartPhone: text,\n              Database_users: (agent.public_key) set,\n              Database_solde: (text.nat) set) def=\n\n  local Sc, Ss, Rc, Rs: channel(dy)\n\n  composition\n\n\tclient(Client, Server, PKc, PKs, Sc, Rc, Bonjour, Ack, IDSmartPhone)\n     /\\ server(Server, PKs, Ss, Rs, Ack, Bonjour, Database_users, Database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n  local\n    Database_users: (agent.public_key) set,\n    Database_solde: (text.nat) set\n\n  const\n    a1, a2, i, b: agent,\n    pk1, pk2, pkb, pki: public_key,\n    bonjour, ack, idsmartphone1, idsmartphone2, idsmartphonei: text,\n    solde1, solde2, soldei: nat,\n    idsmart, clefsession, ns, nc, client_server_ns, server_client_nc, server_client_ns: protocol_id\n\n\n  init Database_users:={a1.pk1, a2.pk2, i.pki, b.pkb}\n      /\\ Database_solde:={idsmartphone1.solde1, idsmartphone2.solde2, idsmartphonei.soldei}\n\n  intruder_knowledge = {a1, a2, b, i, pk1, pk2, pkb, pki, inv(pki), idsmartphonei, soldei }\n\n  composition\n\n\tsession(a1, b, pk1, pkb, bonjour, ack, idsmartphone1, database_users, database_solde)\n    /\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, database_users, database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, database_users, database_solde)\n\t/\\ session(a2, b, pk2, pkb, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, database_users, database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, database_users, database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% GOAL section\n\ngoal\n  authentication_on client_server_ns\n  authentication_on server_client_nc\n\n  secrecy_of ns,\n              nc,\n              clefsession,\n              idsmart\nend goal\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()", "```hlpsl\n%%Purpose : Gestion d'un \"badge\" automatique pour les p\u00e9ages autoroutiers via le smartphone du client\n\n\n%% 1. Client -> Server : {Bonjour.C}_PKs\n\n%% (Server <--> BDD : get Pkc(C) )\n\n%% 2. Server -> Client : {Ns.Server}_PKc\n%% 3. Client -> Server : {Nc.Ns}_PKs\n%% 4. Server -> Client : {Nc.ClefSession}_PKc\n%% 5. Client -> Server : {IDSmartPhone}_ClefSession\n\n%% (Server <--> BDD : get solde(IDSmpartphone)\n%% if soldeClient > 0 ? ack\n%% else\n%% refuse)\n\n%% 6. Server -> Client : {Ack}_ClefSession\n%% 7. Client -> Server : {End}_ClefSession\n\n\n\n%% PKc, PKs respectivement les clefs publiques de Client et Serveur\n%% ClefSession une clef sym\u00e9trique fra\u00eeche\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le client, initiant le protocole\nrole client (Client, Server: agent,\n              PKc, PKs: public_key,\n              SND, RCV: channel(dy),\n              Bonjour, Ack, IDSmartPhone : text)\n\n\nplayed_by Client def=\n  local State: nat,\n          Nc, Ns: text,\n          ClefSession: symmetric_key\n\n  init State:=0\n\n  transition\n\n  0.  State=0 /\\ RCV(start) =|>\n\tState':=1 /\\ SND({Bonjour.Client}_PKs)\n\n  1. State=1 /\\ RCV({Ns'.Server}_PKc) =|>\n\tState':=2 /\\ Nc':=new() /\\ witness(Client, Server, server_client_nc, {Nc', ns, {Nc', Server}}) /\\ SND({Nc'.Ns'}_PKs) /\\ request(Client, Server, client_server_ns, Ns')\n\n  2. State=2 /\\ RCV({Nc.ClefSession'}_PKc)=|>\n  State':=3 /\\ secret(IDSmartPhone, idsmart, {Client, Server}) /\\ SND({IDSmartPhone}_ClefSession')\n\n  3. State=3 /\\ RCV({Ack}_ClefSession)=|>\n  State':=4 /\\ SND({End}_ClefSession) /\\ request(Client, Server, client_server_ns, Ns)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le server\nrole server (Server: agent,\n              PKs: public_key,\n              SND, RCV: channel(dy),\n\t\t\t        Ack, Bonjour: text,\n\t\t\t        Database_users: (agent.public_key) set,\n\t\t\t        Database_solde: (text.nat) set)\n\n\nplayed_by Server def=\n  local State: nat,\n          ClefSession: symmetric_key,\n        \tNs,Nc, IDSmartPhone: text,\n        \tPKc: public_key,\n\t\t\tClient: agent,\n\t\t\tSoldeClient : nat\n\n  init State:=0\n\n  transition\n\n  0. State=0 /\\ RCV({Bonjour.Client'}_PKs) /\\ in(Client'.PKc', Database_users) =|>\n\tState':=1 /\\ Ns':=new() /\\ secret(Ns', ns, {Client', Server}) /\\ witness(Server, Client', server_client_ns, Ns') /\\ SND({Ns'.Server}_PKc')\n\n  1. State=1 /\\ RCV({Nc'.Ns}_PKs) =|>\n  State':=2 /\\ ClefSession':=new() /\\ secret(ClefSession', clefsession, {Client, Server}) /\\ SND({Nc'.ClefSession'}_PKc)\n\n  2. State=2 /\\ RCV({IDSmartPhone'}_ClefSession) /\\ in(IDSmartPhone'.SoldeClient', Database_solde) /\\ not(SoldeClient=0) =|>\n  State':=3 /\\ SND({Ack}_ClefSession) /\\ request(Server, Client, client_server_nc, Nc)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(Client,\n              Server: agent,\n              PKc, PKs: public_key,\n              SND, RCV: channel(dy),\n              Bonjour, Ack, IDSmartPhone: text,\n              Database_users: (agent.public_key) set,\n              Database_solde: (text.nat) set) def=\n\n  local Sc, Ss, Rc, Rs: channel(dy)\n\n  composition\n\n\tclient(Client, Server, PKc, PKs, Sc, Rc, Bonjour, Ack, IDSmartPhone)\n     /\\ server(Server, PKs, Ss, Rs, Ack, Bonjour, Database_users, Database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n  local\n    Database_users: (agent.public_key) set,\n    Database_solde: (text.nat) set\n\n  const\n    a1, a2, i, b: agent,\n    pk1, pk2, pkb, pki: public_key,\n    bonjour, ack, idsmartphone1, idsmartphone2, idsmartphonei: text,\n    solde1, solde2, soldei: nat,\n    idsmart, clefsession, ns, nc, client_server_ns, server_client_nc, server_client_ns: protocol_id\n\n\n  init Database_users:={a1.pk1, a2.pk2, i.pki, b.pkb}\n      /\\ Database_solde:={idsmartphone1.solde1, idsmartphone2.solde2, idsmartphonei.soldei}\n\n  intruder_knowledge = {a1, a2, b, i, pk1, pk2, pkb, pki, inv(pki), idsmartphonei, soldei }\n\n  composition\n\n\tsession(a1, b, pk1, pkb, bonjour, ack, idsmartphone1, database_users, database_solde)\n    /\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, database_users, database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, database_users, database_solde)\n\t/\\ session(a2, b, pk2, pkb, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, database_users, database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, database_users, database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, database_users, database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% GOAL section\n\ngoal\n  authentication_on client_server_ns\n  authentication_on server_client_nc\n\n  secrecy_of ns,\n              nc,\n              clefsession,\n              idsmart\nend goal\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()\n```"]], "HLPSL-1/protocol.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Control Room %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole controlroom(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by CR\ndef=\nlocal State: nat,\n    MKdrj, Rdrj, RTSdrj, Rcr: text,\n    IDdrj1, IDdrj2, IDgss, IDcr: text,\n    Key1, Key2: symmetric_key\nconst dr1_cr_rdrj, cr_dr1_rdrj, dr2_cr_rdrj, cr_dr2_rdrj, secret1, secret2: protocol_id\n\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(start) =|>\nState' := 1 /\\ Rdrj' := new() /\\ Rcr' := new()\n    /\\ RTSdrj' := H(Rdrj'.Rcr')\n    /\\ Key1' := new() /\\ Key2' := new()\n    /\\ Snd({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1)\n    /\\ Snd({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2)\n    /\\ secret({Rcr'.Rdrj'.RTSdrj'.MKdrj}, secret1, {CR})\n    /\\ witness(CR, DR1, cr_dr1_rdrj, Rdrj')\n    /\\ witness(CR, DR2, cr_dr2_rdrj, Rdrj')\n\n2. State = 1 /\\ Rcv(IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1') =|>\nState' := 2 /\\ witness(CR, DR1, dr1_cr_rdrj, Rdrj')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone1(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by DR1\ndef=\nlocal State: nat,\n    Key1: symmetric_key,\n    EccMul, Add, Poly: hash_func,\n    G, MKdrj, Rj1, Rdrj, TSj1, IDdrj1, IDdrj2, IDgss, IDcr, RTSdrj, Rcr, Aj1, AAj1, Rdr, Msgd2d1: text,\n    Rj2, TSj2, TSj3, Bj2, ACKj1j2, Msgd2d3: text\nconst dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\ninit State := 0\ntransition\n\n%%%Receive registration message from CR\n\n1. State = 0 /\\ Rcv({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1) =|>\nState' := 1 /\\ Rdr' := new() /\\ Rj1' := new() /\\ TSj1' := new()\n    /\\ Aj1' := H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1')\n    /\\ AAj1' := EccMul(Aj1'.G)\n    /\\ Msgd2d1' := IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).IDgss.EccMul(Rcr'.G)).Rcr').TSj1'\n\n%%% Send message Msgd2d1 to DR2\n    /\\ Snd(Msgd2d1')\n\n%%% Receive message Msgd2d2 from the DR2\n2. State = 1 /\\ Rcv(IDdrj2.EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).\n                H(H(EccMul(Bj2'.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G)).\n                Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr).\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'. TSj2').\n                EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).TSj2'.IDdrj2).\n                TSj2'.Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')) =|>\n\nState' := 3 /\\ TSj3' := new()\n        /\\ ACKj1j2' := H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n            Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n            Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3')\n        /\\ Msgd2d3' := ACKj1j2'.TSj3'\n\n%%% Send message Msgd2d3 to DR2\n        /\\ Snd(Msgd2d3')\n        \n        /\\ witness(DR1, DR2, dr1_dr2_rj1, Rj1')\n        /\\ witness(DR1, DR2, dr1_dr2_tsj1, TSj1')\n        /\\ witness(DR1, DR2, dr1_dr2_tsj3, TSj3')\n\n        /\\ request(DR1, DR2, dr2_dr1_rj2, Rj2')\n        /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone2(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by DR2\ndef=\nlocal State: nat,\n    Key2: symmetric_key,\n    EccMul, Add, Poly: hash_func,\n    G, MKdrj, Rj1, Rdrj, IDdrj1, IDdrj2, IDgss, IDcr, Rcr, DKj2j1, SKj2j1: text,\n    TSj2, TSj3, Bj2, Bsmallj2, Rj2, Rdr, Msgd1d2, MKdrj1, RTSdrj, SKVj2j1, TSj1: text\nconst dr1_dr2_rj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\ninit State := 0\ntransition\n\n%%%Receive registration message CR\n\n1. State = 0 /\\ Rcv({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2) =|>\nState' := 2 /\\ secret({Rcr',Rdrj',RTSdrj',MKdrj}, secret1, {CR})\n\n%%% Receive message Msgd2d1 from the DR1\n2. State = 2 /\\ Rcv(IDdrj1.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1').G).\n                Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1')=|>\nState' := 4 /\\ Rj1' := new() /\\ Rj2' := new() /\\ TSj2' := new()\n            /\\ Bsmallj2' := H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2')\n            /\\ Bj2' := EccMul(Bsmallj2'.G)\n            /\\ DKj2j1' := EccMul(Bsmallj2'.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G))\n            /\\ SKj2j1' := H(DKj2j1'.Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'.TSj2')\n\n            /\\ SKVj2j1' := H(SKj2j1'.Bj2'.TSj2'.IDdrj2)\n            /\\ Msgd1d2' := IDdrj2.Bj2'.SKVj2j1'.TSj2'.Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')\n\n%%% Send message Msgd2d2 to DR1\n            /\\ Snd(Msgd1d2')\n\n%%% Receive message Msgd2d3 from DR1\n3. State = 4 /\\ Rcv(H(H(EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3') =|>\n\nState' := 5 /\\ TSj3' := new() /\\ witness(DR2, DR1, dr2_dr1_rj2, Rj2')\n            /\\ witness(DR2, DR1, dr2_dr1_tsj2, TSj2')\n\n            /\\ request(DR2, DR1, dr1_dr2_rj1, Rj1')\n            /\\ request(DR2, DR1, dr1_dr2_tsj3, TSj3')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (CR, DR1, DR2: agent, H: hash_func)\ndef=\nlocal Snd1, Rcv1, Snd2, Rcv2, Snd3, Rcv3: channel (dy)\ncomposition\n    controlroom (CR, DR1, DR2, H, Snd1, Rcv1)\n    /\\ drone1 (CR, DR1, DR2, H, Snd2, Rcv2)\n    /\\ drone2 (CR, DR1, DR2, H, Snd3, Rcv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\nconst cr, dr1, dr2, i: agent,\n    h, eccMul, add, poly, g: hash_func,\n    tsj1, tsj2, tsj3: text,\n    secret1, secret2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\nintruder_knowledge = {cr, dr1, dr2, i, h, eccMul, add, poly, g, tsj1, tsj2, tsj3}\n\ncomposition\n    session(cr, dr1, dr2, h)\n    /\\ session(cr, dr1, i, h)\n    /\\ session(cr, i, dr2, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Goal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n%%% Authentication\n    secrecy_of dr1_dr2_rj1, dr2_dr1_rj2, dr1_dr2_tsj1, dr2_dr1_tsj2, dr1_dr2_tsj3\n\n%%% Confidentiality\n    secrecy_of secret1, secret2\nend goal\n\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Control Room %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole controlroom(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by CR\ndef=\nlocal State: nat,\n    MKdrj, Rdrj, RTSdrj, Rcr: text,\n    IDdrj1, IDdrj2, IDgss, IDcr: text,\n    Key1, Key2: symmetric_key\nconst dr1_cr_rdrj, cr_dr1_rdrj, dr2_cr_rdrj, cr_dr2_rdrj, secret1, secret2: protocol_id\n\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(start) =|>\nState' := 1 /\\ Rdrj' := new() /\\ Rcr' := new()\n    /\\ RTSdrj' := H(Rdrj'.Rcr')\n    /\\ Key1' := new() /\\ Key2' := new()\n    /\\ Snd({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1)\n    /\\ Snd({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2)\n    /\\ secret({Rcr'.Rdrj'.RTSdrj'.MKdrj}, secret1, {CR})\n    /\\ witness(CR, DR1, cr_dr1_rdrj, Rdrj')\n    /\\ witness(CR, DR2, cr_dr2_rdrj, Rdrj')\n\n2. State = 1 /\\ Rcv(IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1') =|>\nState' := 2 /\\ witness(CR, DR1, dr1_cr_rdrj, Rdrj')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone1(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by DR1\ndef=\nlocal State: nat,\n    Key1: symmetric_key,\n    EccMul, Add, Poly: hash_func,\n    G, MKdrj, Rj1, Rdrj, TSj1, IDdrj1, IDdrj2, IDgss, IDcr, RTSdrj, Rcr, Aj1, AAj1, Rdr, Msgd2d1: text,\n    Rj2, TSj2, TSj3, Bj2, ACKj1j2, Msgd2d3: text\nconst dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\ninit State := 0\ntransition\n\n%%%Receive registration message from CR\n\n1. State = 0 /\\ Rcv({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1) =|>\nState' := 1 /\\ Rdr' := new() /\\ Rj1' := new() /\\ TSj1' := new()\n    /\\ Aj1' := H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1')\n    /\\ AAj1' := EccMul(Aj1'.G)\n    /\\ Msgd2d1' := IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).IDgss.EccMul(Rcr'.G)).Rcr').TSj1'\n\n%%% Send message Msgd2d1 to DR2\n    /\\ Snd(Msgd2d1')\n\n%%% Receive message Msgd2d2 from the DR2\n2. State = 1 /\\ Rcv(IDdrj2.EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).\n                H(H(EccMul(Bj2'.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G)).\n                Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr).\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'. TSj2').\n                EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).TSj2'.IDdrj2).\n                TSj2'.Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')) =|>\n\nState' := 3 /\\ TSj3' := new()\n        /\\ ACKj1j2' := H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n            Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n            Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3')\n        /\\ Msgd2d3' := ACKj1j2'.TSj3'\n\n%%% Send message Msgd2d3 to DR2\n        /\\ Snd(Msgd2d3')\n        \n        /\\ witness(DR1, DR2, dr1_dr2_rj1, Rj1')\n        /\\ witness(DR1, DR2, dr1_dr2_tsj1, TSj1')\n        /\\ witness(DR1, DR2, dr1_dr2_tsj3, TSj3')\n\n        /\\ request(DR1, DR2, dr2_dr1_rj2, Rj2')\n        /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone2(CR, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\nplayed_by DR2\ndef=\nlocal State: nat,\n    Key2: symmetric_key,\n    EccMul, Add, Poly: hash_func,\n    G, MKdrj, Rj1, Rdrj, IDdrj1, IDdrj2, IDgss, IDcr, Rcr, DKj2j1, SKj2j1: text,\n    TSj2, TSj3, Bj2, Bsmallj2, Rj2, Rdr, Msgd1d2, MKdrj1, RTSdrj, SKVj2j1, TSj1: text\nconst dr1_dr2_rj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\ninit State := 0\ntransition\n\n%%%Receive registration message CR\n\n1. State = 0 /\\ Rcv({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2) =|>\nState' := 2 /\\ secret({Rcr',Rdrj',RTSdrj',MKdrj}, secret1, {CR})\n\n%%% Receive message Msgd2d1 from the DR1\n2. State = 2 /\\ Rcv(IDdrj1.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1').G).\n                Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1')=|>\nState' := 4 /\\ Rj1' := new() /\\ Rj2' := new() /\\ TSj2' := new()\n            /\\ Bsmallj2' := H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2')\n            /\\ Bj2' := EccMul(Bsmallj2'.G)\n            /\\ DKj2j1' := EccMul(Bsmallj2'.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G))\n            /\\ SKj2j1' := H(DKj2j1'.Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'.TSj2')\n\n            /\\ SKVj2j1' := H(SKj2j1'.Bj2'.TSj2'.IDdrj2)\n            /\\ Msgd1d2' := IDdrj2.Bj2'.SKVj2j1'.TSj2'.Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')\n\n%%% Send message Msgd2d2 to DR1\n            /\\ Snd(Msgd1d2')\n\n%%% Receive message Msgd2d3 from DR1\n3. State = 4 /\\ Rcv(H(H(EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3') =|>\n\nState' := 5 /\\ TSj3' := new() /\\ witness(DR2, DR1, dr2_dr1_rj2, Rj2')\n            /\\ witness(DR2, DR1, dr2_dr1_tsj2, TSj2')\n\n            /\\ request(DR2, DR1, dr1_dr2_rj1, Rj1')\n            /\\ request(DR2, DR1, dr1_dr2_tsj3, TSj3')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (CR, DR1, DR2: agent, H: hash_func)\ndef=\nlocal Snd1, Rcv1, Snd2, Rcv2, Snd3, Rcv3: channel (dy)\ncomposition\n    controlroom (CR, DR1, DR2, H, Snd1, Rcv1)\n    /\\ drone1 (CR, DR1, DR2, H, Snd2, Rcv2)\n    /\\ drone2 (CR, DR1, DR2, H, Snd3, Rcv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\nconst cr, dr1, dr2, i: agent,\n    h, eccMul, add, poly, g: hash_func,\n    tsj1, tsj2, tsj3: text,\n    secret1, secret2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\nintruder_knowledge = {cr, dr1, dr2, i, h, eccMul, add, poly, g, tsj1, tsj2, tsj3}\n\ncomposition\n    session(cr, dr1, dr2, h)\n    /\\ session(cr, dr1, i, h)\n    /\\ session(cr, i, dr2, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Goal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n%%% Authentication\n    secrecy_of dr1_dr2_rj1, dr2_dr1_rj2, dr1_dr2_tsj1, dr2_dr1_tsj2, dr1_dr2_tsj3\n\n%%% Confidentiality\n    secrecy_of secret1, secret2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/RegVBNS.hlpsl": [[true, "role_C(C:agent,M:agent,Na:text,Pd:text,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tPd_hash:hash_func,P:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({C.Na.Pd}_Kc)\n\t\t2. State=1 /\\ RCV({Na.Pd.F(Pd)}_Kc) =|> State':=2 /\\ P':=new() /\\ secret(P',sec_1,{C}) /\\ SND({Na.F(P'.F(Pd))}_Kc)\n\t\t4. State=2 /\\ RCV({C.Kp'.inv(Kp')}_Kc) =|> State':=3 /\\ witness(C,M,kp_sec,Kp')\nend role\n\nrole role_M(C:agent,M:agent,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by M\ndef=\n\tlocal\n\t\tState:nat,Pd_hash:hash_func,Pd:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.Na'.Pd'}_Kc) =|> State':=1 /\\ SND({Na'.Pd'.F(Pd')}_Kc)\n\t\t3. State=1 /\\ RCV({Na.F(P'.F(Pd))}_Kc) =|> State':=2 /\\ secret(P',sec_1,{C,M}) /\\ Kp':=new() /\\ secret(Kp',sec_2,{C,M}) /\\ SND({C.Kp'.inv(Kp')}_Kc)\nend role\n\nrole session1(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session2(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session3(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tminer:agent,pd:text,client:agent,na:text,kc:symmetric_key,hash_0:hash_func,kp_sec:protocol_id,sec_1,sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(pd,na,i,miner,kc) /\\ session2(pd,na,client,i,kc) /\\ session1(pd,na,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()", "```hlpsl\nrole_C(C:agent,M:agent,Na:text,Pd:text,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tPd_hash:hash_func,P:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({C.Na.Pd}_Kc)\n\t\t2. State=1 /\\ RCV({Na.Pd.F(Pd)}_Kc) =|> State':=2 /\\ P':=new() /\\ secret(P',sec_1,{C}) /\\ SND({Na.F(P'.F(Pd))}_Kc)\n\t\t4. State=2 /\\ RCV({C.Kp'.inv(Kp')}_Kc) =|> State':=3 /\\ witness(C,M,kp_sec,Kp')\nend role\n\nrole role_M(C:agent,M:agent,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by M\ndef=\n\tlocal\n\t\tState:nat,Pd_hash:hash_func,Pd:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.Na'.Pd'}_Kc) =|> State':=1 /\\ SND({Na'.Pd'.F(Pd')}_Kc)\n\t\t3. State=1 /\\ RCV({Na.F(P'.F(Pd))}_Kc) =|> State':=2 /\\ secret(P',sec_1,{C,M}) /\\ Kp':=new() /\\ secret(Kp',sec_2,{C,M}) /\\ SND({C.Kp'.inv(Kp')}_Kc)\nend role\n\nrole session1(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session2(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session3(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tminer:agent,pd:text,client:agent,na:text,kc:symmetric_key,hash_0:hash_func,kp_sec:protocol_id,sec_1,sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(pd,na,i,miner,kc) /\\ session2(pd,na,client,i,kc) /\\ session1(pd,na,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/safe_new_syntax.hlpsl": [[true, "% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(A, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text)\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Nb'.Pa.Sid)\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(M'.A.B.Na.Nb'.Pa.Sid)_ClientK'}) % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ witness(A,B,alice_bob_na_nb,Na.Nb')\n\n   4.  State = 4   /\\ RCV({H(PRF(PMS.Na.Nb).A.B.Na.Pa.Sid)_KeyGen(B.Na.Nb.PRF(PMS.Na.Nb))}) =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(B,A,bob_alice_na_nb,Na.Nb)\n       \t\t   /\\ secret(ClientK,secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK,secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key,\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text.text),\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n        M: hash(text.text.text)\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,bob_alice_na_nb,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb.A.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb).A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na'.Nb.PRF(PMS'.Na'.Nb))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ M' := PRF(PMS'.Na'.Nb)\n       \t\t   /\\ SND({H(M'.A.B.Na'.Pa'.Sid') % 7. B -> A: {Finished\n              \t\t}_KeyGen(B.Na'.Nb.M')) % }Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(A,B,alice_bob_na_nb,Na'.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, RA, SB, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(A, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text)\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Nb'.Pa.Sid)\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(M'.A.B.Na.Nb'.Pa.Sid)_ClientK'}) % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ witness(A,B,alice_bob_na_nb,Na.Nb')\n\n   4.  State = 4   /\\ RCV({H(PRF(PMS.Na.Nb).A.B.Na.Pa.Sid)_KeyGen(B.Na.Nb.PRF(PMS.Na.Nb))}) =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(B,A,bob_alice_na_nb,Na.Nb)\n       \t\t   /\\ secret(ClientK,secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK,secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key,\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text.text),\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n        M: hash(text.text.text)\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,bob_alice_na_nb,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb.A.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb).A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na'.Nb.PRF(PMS'.Na'.Nb))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ M' := PRF(PMS'.Na'.Nb)\n       \t\t   /\\ SND({H(M'.A.B.Na'.Pa'.Sid') % 7. B -> A: {Finished\n              \t\t}_KeyGen(B.Na'.Nb.M')) % }Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(A,B,alice_bob_na_nb,Na'.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, RA, SB, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/SmartCard.hlpsl": [[true, "% Author -\t@Nagaraj Poti\n% Roll\t-\t20162010\n% --------------------------------------------------------------------------------\n\n% User role\n% --------------------------------------------------------------------------------\n\nrole user (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n\t% Dolev Yao model channels \n)\n\nplayed_by A \n\ndef=\n\nlocal\n\tState : nat,\t% Transition state\n\tNu : text,\t\t% Secret nonce\n\tID : text, \t\t% User ID chosen randomly\n\tPs : text,\t\t% Public key of the server\n\tC : text,\t\t% Smart card UID\n\tG : nat,\t\t\t% Server generator nonce\n\tP : nat,\t\t\t% Random prime nonce\n\tPWD : text,\t\t% User password\n\tQ1 : text,\t\t% Smart card UID - Part I\n\tQ2 : text,\t\t% Smart card UID - Part II \n\tCnew : text,\t% Login computed C\n\tAnew : text,\t% Login computed check\n\tN1 : nat,\t\t% Random nonce n1\n\tN2 : nat,\t\t% Random nonce alpha\n\tV : text,\t\t% V corresponding to K1 computation\n\tX : text,\t\t% Message\n\tVs : text, \t\t% V corresponding to computation at server\n\tSK : text,\t\t% Session key client side\n\tTID : text\t\t% Ticket generated by user\n\ninit \n\tState := 0\n\ntransition\n\n% Registration initiated by user - sends ID to server along with secret nonce \n0.\tState = 0 /\\ RCV(start) =|> \n\t\tState' := 2 /\\ Nu' := new() /\\ ID' := new() /\\ SND(ID'.{ID'.Nu'}_S)\n\t\t/\\ witness(A, B, nua, Nu')\n\n% User receives smartcard from the server and stores it locally along with password\n2.\tState = 2 /\\ RCV({C'.Ps'.G'.P'}_S) =|> \n\t\tState' := 4 /\\ PWD' := new() /\\ Q1' := xor(C', H(PWD'.ID)) \n\t\t/\\ Q2' := H(C'.PWD'.ID) /\\ secret(ID, cid, {A, B}) \n\t\t\n% User enters uid and pwd and waits for verification from smart card\n4. State = 4 /\\ RCV(start) =|> \n\t\tState' := 6 /\\ Cnew' := xor(Q1, H(PWD.ID)) /\\ Anew' := H(Cnew'.PWD.ID)\n\t\t\n% User sends verified ticket to server by binding it with public key\n6. State = 6 /\\ Anew = Q2 /\\ RCV(start) =|> \n\t\tState' := 8 /\\ N1' := new() /\\ N2' := new() /\\ V' := exp(G, H(N2'.C))  \n\t\t/\\ TID' := xor(ID.N1', H(exp(Ps, H(N2'.C)))) \n\t\t/\\ SND(xor(ID.N1', H(exp(Ps, H(N2'.C)))).V') \n\t\t/\\ witness(A, B, user_server_tid, TID') \n\t\t/\\ witness(A, B, user_server_v, V') \n\n% User receives response message from the server via public channel\t\t\n10. State = 8 /\\ RCV(Vs'.X') =|>\n\t\tState' := 10 /\\ SK' := exp(Vs', H(N2.C))\n\t\n% User sends confirmation message to server via public channel\n12. State = 10 /\\ H(V.C.Vs'.SK'.N1') = X' /\\ RCV(start) =|>\n\t\tState' := 12 /\\ SND(H(SK'.Vs'.C.N1')) /\\ witness(A, B, user_server_v2, Vs')\n\t\t/\\ request(A, B, user_server_conf, X')  \t\n\t\t\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Server role\n% --------------------------------------------------------------------------------\n\nrole server (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n)\n\nplayed_by B\n\ndef=\n\nlocal \n\tState : nat,\t% Transition state\n\tID : text,\t\t% Client ID\n\tNu : text,\t\t% User identifier and validator token\n\tSD : text, \t\t% Smart card ID\n\tKs : text,\t\t% Server secret key\n\tG : nat, \t\t% Generator of the class\n\tP : nat,\t\t\t% Random prime nonce\n\tTID : text,\t\t% Ticket from user\n\tV : text,\t\t% V corresponding to K1 computation at user end\n\tK2 : text,\t\t% K2 computation\n\tU : text,\t\t% Incoming user tid - ID + Ks combo\n\tQ : nat, \t\t% Random nonce at the server\n\tSK : text,\t\t% Session key server side\n\tVs : text, \t\t% V corresponding to computation at server \n\tX : text,\t\t% Message\n\tConf : text,\t% Final confirmation message\n\tACK : text,\t\t% Final acknowledgment sent to user\n\tC : text\t\t\t% Smart card UID client\n\ninit\n\tState := 1\n\ntransition\n\n% Server receives request from user for authentication and new smart card \n% if the user does not exist in the database\n1.\tState = 1 /\\ RCV(ID'.{ID'.Nu'}_S) =|> \n\t\tState' := 3 /\\ SD' := new() /\\ Ks' := new() /\\ G' := new() /\\ P' := new() /\\ C' := H(ID'.Ks'.SD') /\\ SND({C'.Ps.G'.P'}_S) \n\t\t/\\ witness(B, A, reg_nonce, SD')\n\n% Server verifies whether user is properly authenticated\n7. State = 3 /\\ RCV(TID'.V') =|>\n\t\tState' := 5 /\\ K2' := exp(V', Ks) /\\ U' := xor(TID', K2')\n\n% Server computes decryption key and after computation sends response message\t\t\n9. State = 5 /\\ U = ID /\\ RCV(start) =|>\n\t\tState' := 7 /\\  Q' := new() /\\ SK' := exp(V, H(Ks.Q')) \n\t\t/\\ Vs' := exp(G, H(Ks.Q')) /\\ C' := H(ID.Ks.SD) \n\t\t/\\ X' := H(V.H(ID.Ks.SD).Vs'.SK'.Nu)\t/\\ SND(Vs'.X') \n\n% If confirmation message is received well and successfully, successive \n% communication is done with the session key\n13. State = 7 /\\ RCV(Conf') /\\ H(SK'.Vs'.C.Nu) = Conf' =|> SND({ACK}_SK')\n\t\t/\\ request(B, A, server_user_ack, ACK)\n\t\t\t\t\t\t\nend role\t\n\n% --------------------------------------------------------------------------------\n\n\n% Session role\n% --------------------------------------------------------------------------------\n\nrole session (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func\n\t% H is a cryptographic hash function\n)\n\ndef=\n\nlocal \n\tSAB, RAB, SBA, RBA : channel(dy)\n\ncomposition\n\tuser(A, B, S, H, SAB, RAB) /\\ server(A, B, S, H, SBA, RBA)\n\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Environment role\n% --------------------------------------------------------------------------------\n\nrole environment()\n\ndef=\n\nconst \n\tnua, cid, user_server_tid, reg_nonce, server_user_sid,\n\tuser_server_v2, user_server_conf, server_user_ack : protocol_id,\n\ta, b, i : agent,\n\tsab, sai, sib : symmetric_key,\n\th : hash_func,\n\tps : text \n\t\nintruder_knowledge = {a, b, i, sai, sib, h, ps}\n\ncomposition\n\tsession(a, b, sab, h)  \n\t/\\ session(a, b, sab, h) \n\t/\\ session(a, i, sai, h) \n\t/\\ session(i, b, sib, h)\n\t \nend role\n\n% --------------------------------------------------------------------------------\n\n% Goals\n% --------------------------------------------------------------------------------\n\ngoal\n\tauthentication_on nua\t% User nonce generated during registration is weak auth\n\tauthentication_on reg_nonce % Registration nonce\n\tsecrecy_of cid\t\t\t\t% Smart card must remain secret to user\n\tweak_authentication_on user_server_tid\t% Ticket identifies user issuing request\n\tweak_authentication_on user_server_v\t% Identifies user issuing request\n\tauthentication_on user_server_v2\t\t\t% Final confirmation of session establishment\n\tauthentication_on user_server_conf\t\t% Final confirmation of session establishment\n\tweak_authentication_on server_user_sid\t% Smart card id associated with user\n\tauthentication_on server_user_ack\t\t% Final confirmation before session establishment\nend goal\n\n% --------------------------------------------------------------------------------\n\nenvironment()", "```hlpsl\n% Author -\t@Nagaraj Poti\n% Roll\t-\t20162010\n% --------------------------------------------------------------------------------\n\n% User role\n% --------------------------------------------------------------------------------\n\nrole user (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n\t% Dolev Yao model channels \n)\n\nplayed_by A \n\ndef=\n\nlocal\n\tState : nat,\t% Transition state\n\tNu : text,\t\t% Secret nonce\n\tID : text, \t\t% User ID chosen randomly\n\tPs : text,\t\t% Public key of the server\n\tC : text,\t\t% Smart card UID\n\tG : nat,\t\t\t% Server generator nonce\n\tP : nat,\t\t\t% Random prime nonce\n\tPWD : text,\t\t% User password\n\tQ1 : text,\t\t% Smart card UID - Part I\n\tQ2 : text,\t\t% Smart card UID - Part II \n\tCnew : text,\t% Login computed C\n\tAnew : text,\t% Login computed check\n\tN1 : nat,\t\t% Random nonce n1\n\tN2 : nat,\t\t% Random nonce alpha\n\tV : text,\t\t% V corresponding to K1 computation\n\tX : text,\t\t% Message\n\tVs : text, \t\t% V corresponding to computation at server\n\tSK : text,\t\t% Session key client side\n\tTID : text\t\t% Ticket generated by user\n\ninit \n\tState := 0\n\ntransition\n\n% Registration initiated by user - sends ID to server along with secret nonce \n0.\tState = 0 /\\ RCV(start) =|> \n\t\tState' := 2 /\\ Nu' := new() /\\ ID' := new() /\\ SND(ID'.{ID'.Nu'}_S)\n\t\t/\\ witness(A, B, nua, Nu')\n\n% User receives smartcard from the server and stores it locally along with password\n2.\tState = 2 /\\ RCV({C'.Ps'.G'.P'}_S) =|> \n\t\tState' := 4 /\\ PWD' := new() /\\ Q1' := xor(C', H(PWD'.ID)) \n\t\t/\\ Q2' := H(C'.PWD'.ID) /\\ secret(ID, cid, {A, B}) \n\t\t\n% User enters uid and pwd and waits for verification from smart card\n4. State = 4 /\\ RCV(start) =|> \n\t\tState' := 6 /\\ Cnew' := xor(Q1, H(PWD.ID)) /\\ Anew' := H(Cnew'.PWD.ID)\n\t\t\n% User sends verified ticket to server by binding it with public key\n6. State = 6 /\\ Anew = Q2 /\\ RCV(start) =|> \n\t\tState' := 8 /\\ N1' := new() /\\ N2' := new() /\\ V' := exp(G, H(N2'.C))  \n\t\t/\\ TID' := xor(ID.N1', H(exp(Ps, H(N2'.C)))) \n\t\t/\\ SND(xor(ID.N1', H(exp(Ps, H(N2'.C)))).V') \n\t\t/\\ witness(A, B, user_server_tid, TID') \n\t\t/\\ witness(A, B, user_server_v, V') \n\n% User receives response message from the server via public channel\t\t\n10. State = 8 /\\ RCV(Vs'.X') =|>\n\t\tState' := 10 /\\ SK' := exp(Vs', H(N2.C))\n\t\n% User sends confirmation message to server via public channel\n12. State = 10 /\\ H(V.C.Vs'.SK'.N1') = X' /\\ RCV(start) =|>\n\t\tState' := 12 /\\ SND(H(SK'.Vs'.C.N1')) /\\ witness(A, B, user_server_v2, Vs')\n\t\t/\\ request(A, B, user_server_conf, X')  \t\n\t\t\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Server role\n% --------------------------------------------------------------------------------\n\nrole server (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n)\n\nplayed_by B\n\ndef=\n\nlocal \n\tState : nat,\t% Transition state\n\tID : text,\t\t% Client ID\n\tNu : text,\t\t% User identifier and validator token\n\tSD : text, \t\t% Smart card ID\n\tKs : text,\t\t% Server secret key\n\tG : nat, \t\t% Generator of the class\n\tP : nat,\t\t\t% Random prime nonce\n\tTID : text,\t\t% Ticket from user\n\tV : text,\t\t% V corresponding to K1 computation at user end\n\tK2 : text,\t\t% K2 computation\n\tU : text,\t\t% Incoming user tid - ID + Ks combo\n\tQ : nat, \t\t% Random nonce at the server\n\tSK : text,\t\t% Session key server side\n\tVs : text, \t\t% V corresponding to computation at server \n\tX : text,\t\t% Message\n\tConf : text,\t% Final confirmation message\n\tACK : text,\t\t% Final acknowledgment sent to user\n\tC : text\t\t\t% Smart card UID client\n\ninit\n\tState := 1\n\ntransition\n\n% Server receives request from user for authentication and new smart card \n% if the user does not exist in the database\n1.\tState = 1 /\\ RCV(ID'.{ID'.Nu'}_S) =|> \n\t\tState' := 3 /\\ SD' := new() /\\ Ks' := new() /\\ G' := new() /\\ P' := new() /\\ C' := H(ID'.Ks'.SD') /\\ SND({C'.Ps.G'.P'}_S) \n\t\t/\\ witness(B, A, reg_nonce, SD')\n\n% Server verifies whether user is properly authenticated\n7. State = 3 /\\ RCV(TID'.V') =|>\n\t\tState' := 5 /\\ K2' := exp(V', Ks) /\\ U' := xor(TID', K2')\n\n% Server computes decryption key and after computation sends response message\t\t\n9. State = 5 /\\ U = ID /\\ RCV(start) =|>\n\t\tState' := 7 /\\  Q' := new() /\\ SK' := exp(V, H(Ks.Q')) \n\t\t/\\ Vs' := exp(G, H(Ks.Q')) /\\ C' := H(ID.Ks.SD) \n\t\t/\\ X' := H(V.H(ID.Ks.SD).Vs'.SK'.Nu)\t/\\ SND(Vs'.X') \n\n% If confirmation message is received well and successfully, successive \n% communication is done with the session key\n13. State = 7 /\\ RCV(Conf') /\\ H(SK'.Vs'.C.Nu) = Conf' =|> SND({ACK}_SK')\n\t\t/\\ request(B, A, server_user_ack, ACK)\n\t\t\t\t\t\t\nend role\t\n\n% --------------------------------------------------------------------------------\n\n\n% Session role\n% --------------------------------------------------------------------------------\n\nrole session (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func\n\t% H is a cryptographic hash function\n)\n\ndef=\n\nlocal \n\tSAB, RAB, SBA, RBA : channel(dy)\n\ncomposition\n\tuser(A, B, S, H, SAB, RAB) /\\ server(A, B, S, H, SBA, RBA)\n\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Environment role\n% --------------------------------------------------------------------------------\n\nrole environment()\n\ndef=\n\nconst \n\tnua, cid, user_server_tid, reg_nonce, server_user_sid,\n\tuser_server_v2, user_server_conf, server_user_ack : protocol_id,\n\ta, b, i : agent,\n\tsab, sai, sib : symmetric_key,\n\th : hash_func,\n\tps : text \n\t\nintruder_knowledge = {a, b, i, sai, sib, h, ps}\n\ncomposition\n\tsession(a, b, sab, h)  \n\t/\\ session(a, b, sab, h) \n\t/\\ session(a, i, sai, h) \n\t/\\ session(i, b, sib, h)\n\t \nend role\n\n% --------------------------------------------------------------------------------\n\n% Goals\n% --------------------------------------------------------------------------------\n\ngoal\n\tauthentication_on nua\t% User nonce generated during registration is weak auth\n\tauthentication_on reg_nonce % Registration nonce\n\tsecrecy_of cid\t\t\t\t% Smart card must remain secret to user\n\tweak_authentication_on user_server_tid\t% Ticket identifies user issuing request\n\tweak_authentication_on user_server_v\t% Identifies user issuing request\n\tauthentication_on user_server_v2\t\t\t% Final confirmation of session establishment\n\tauthentication_on user_server_conf\t\t% Final confirmation of session establishment\n\tweak_authentication_on server_user_sid\t% Smart card id associated with user\n\tauthentication_on server_user_ack\t\t% Final confirmation before session establishment\nend goal\n\n% --------------------------------------------------------------------------------\n\nenvironment()\n```"]], "HLPSL-1/SMC-5-Party.hlpsl": [[true, "role role_A(A,B,C,D,E:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV(start) =|> State':=1 /\\ Xa':=new() /\\ Ya':=new()                   \n      /\\ SND({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb) /\\ SND({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc) \n      /\\ SND({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) /\\ SND({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) \n      /\\ secret(Xa'.Ya',sec_1,{A}) /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,B}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,C}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,D}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,E})  \n\n      2. State=1 /\\ RCV({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xa')}_Kb.{SHA256(Ya')}_Kb}_Ka) \n                 =|> State':=2 /\\ witness(A,B,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{A,B})  \n\n      3. State=2 /\\ RCV({C.A.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xa')}_Kc.{SHA256(Ya')}_Kc}_Ka) \n                 =|> State':=3 /\\ witness(A,C,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{A,C})  \n\n      4. State=3 /\\ RCV({D.A.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xa')}_Kd.{SHA256(Ya')}_Kd}_Ka) \n                 =|> State':=4 /\\ witness(A,D,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{A,D})  \n\n      5. State=4 /\\ RCV({E.A.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xa')}_Ke.{SHA256(Ya')}_Ke}_Ka) \n                 =|> State':=5 /\\ witness(A,E,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xe').SHA256(Ye'),sec_1,{A,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B,C,D,E,A:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n     1. State=0 /\\ RCV({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb) =|> State':=1 /\\ Xb':=new() /\\ Yb':=new()                   \n     /\\ SND({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xa')}_Kb.{SHA256(Ya')}_Kb}_Ka) \n     /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{A,B}) \n     /\\ witness(B,A,auth_1,Xb'.Yb') /\\ SND({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc) \n     /\\ SND({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd) /\\ SND({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke)\n\n    2. State=1 /\\ RCV({C.B.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xb')}_Kc.{SHA256(Yb')}_Kc}_Kb) \n                =|> State':=2 /\\ request(B,C,auth_1,Xb'.Yb') \n     /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{B,C})  \n\n    3. State=2 /\\ RCV({D.B.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xb')}_Kd.{SHA256(Yb')}_Kd}_Kb) \n                =|> State':=3 /\\ request(B,D,auth_1,Xb'.Yb') \n     /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{B,D})  \n\n    4. State=3 /\\ RCV({E.B.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xb')}_Ke.{SHA256(Yb')}_Ke}_Kb) \n                =|> State':=4 /\\ request(B,E,auth_1,Xb'.Yb')  \n     /\\ secret(SHA256(Xe').SHA256(Ye'),sec_1,{B,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_C(C,D,E,A,B:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text,\n\t\tState:nat\n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc) =|> State':=1 /\\ Xc':=new() /\\ Yc':=new()                   \n      /\\ SND({A.C.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xc')}_Ka.{SHA256(Yc')}_Ka}_Ka) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,C}) \n      /\\ witness(C,A,auth_1,Xa'.Ya') /\\ SND({C.B.{Xc'}_Kc.{Yc'}_Kc}_Kb) \n      /\\ SND({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd) /\\ SND({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke)\n\n    2. State=1 /\\ RCV({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc) =|> State':=2 /\\ witness(C,B,auth_1,Xb'.Yb') \n      /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,C})  \n\n    3.State=2 /\\ RCV({C.D.{Xc}_Kc.{Yc}_Kc.{SHA256(Xd')}_Kc.{SHA256(Yd')}_Kc}_Kc) \n               =|> State':=3 /\\ request(C,D,auth_1,Xc.Yc)  \n\n    4. State=3 /\\ RCV({C.E.{Xc}_Kc.{Yc}_Kc.{SHA256(Xe')}_Kc.{SHA256(Ye')}_Kc}_Kc) \n               =|> State':=4 /\\ request(C,E,auth_1,Xc.Yc)  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_D(D,E,A,B,C:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) =|> State':=1 /\\ Xd':=new() /\\ Yd':=new()                   \n    /\\ SND({A.D.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xd')}_Ka.{SHA256(Yd')}_Ka}_Ka) \n    /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,D}) \n    /\\ witness(D,A,auth_1,Xa'.Ya') /\\ SND({D.B.{Xd'}_Kd.{Yd'}_Kd}_Kb) \n    /\\ SND({D.C.{Xd'}_Kd.{Yd'}_Kd}_Kc) /\\ SND({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke)\n\n    2.State=1 /\\ RCV({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd) =|> State':=2 /\\ witness(D,B,auth_1,Xb'.Yb') \n    /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,D})  \n\n    3.State=2 /\\ RCV({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd) =|> State':=3 /\\ witness(D,C,auth_1,Xc'.Yc') \n    /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{C,D})  \n\n  4.State=3 /\\ RCV({D.E.{Xd}_Kd.{Yd}_Kd.{SHA256(Xe')}_Kd.{SHA256(Ye')}_Kd}_Kd) \n             =|> State':=4 /\\ request(D,E,auth_1,Xd.Yd)               \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_E(A,B,C,D,E:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by E\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) =|> State':=1 /\\ Xe':=new() /\\ Ye':=new()                   \n    /\\ SND({A.E.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xe')}_Ka.{SHA256(Ye')}_Ka}_Ka) \n    /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,E}) \n    /\\ witness(E,A,auth_1,Xa'.Ya') /\\ SND({E.B.{Xe'}_Ke.{Ye'}_Ke}_Kb) \n    /\\ SND({E.C.{Xe'}_Ke.{Ye'}_Ke}_Kc) /\\ SND({E.D.{Xe'}_Ke.{Ye'}_Ke}_Kd)\n\n    2.State=1 /\\ RCV({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke) =|> State':=2 /\\ witness(E,B,auth_1,Xb'.Yb') \n    /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,E})  \n\n    3.State=2 /\\ RCV({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke) =|> State':=3 /\\ witness(E,C,auth_1,Xc'.Yc') \n    /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{C,E})  \n\n    4.State=3 /\\ RCV({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke) =|> State':=4 /\\ witness(E,D,auth_1,Xd'.Yd') \n    /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{D,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B,C,D,E:agent,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text,Ka,Kb,Kc,Kd,Ke:public_key,SHA256:hash_func)\ndef=\n\tlocal\t\n      SND1,RCV1,SND2,RCV2,SND3,RCV3,SND4,RCV4,SND5,RCV5 :channel(dy)\n\tcomposition\n       role_A(A,B,C,D,E,Ka,Kb,Kc,Kd,Ke,SHA256,SND1,RCV1)  \t\t\n        /\\ role_B(B,C,D,E,A,Ka,Kb,Kc,Kd,Ke,SHA256,SND2,RCV2) \t\t\n        /\\role_C(C,D,E,A,B,Ka,Kb,Kc,Kd,Ke,SHA256, SND3,RCV3) \t\t\n        /\\role_D(D,E,A,B,C,Ka,Kb,Kc,Kd,Ke,SHA256, SND4,RCV4)\n\t/\\role_E(A,B,C,D,E,Ka,Kb,Kc,Kd,Ke,SHA256, SND5,RCV5)\n\t\t\t\t \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\tconst\n\t\tka,kb,kc,kd,ke,ki:public_key,\n\t\ta,b,c,d,e:agent,\n                \txb,yb,xc,yc,xd,yd,xe,ye:text,\n\t\tsha256:hash_func,\n               \t sec_1,auth_1:protocol_id               \n\t\tintruder_knowledge=  \n                 {a,b,c,d,e,ka,kb,kc,kd,ke,ki,inv(ki)}\n\tcomposition\n           session(a,b,c,d,e,xb,yb,xc,yc,xd,yd,xe,ye,ka,kb,kc,kd,ke,sha256) \n\t\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sec_1\n  authentication_on auth_1\n\nend goal\n\nenvironment()\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "```hlpsl\nrole role_A(A,B,C,D,E:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV(start) =|> State':=1 /\\ Xa':=new() /\\ Ya':=new()                   \n      /\\ SND({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb) /\\ SND({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc) \n      /\\ SND({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) /\\ SND({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) \n      /\\ secret(Xa'.Ya',sec_1,{A}) /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,B}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,C}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,D}) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,E})  \n\n      2. State=1 /\\ RCV({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xa')}_Kb.{SHA256(Ya')}_Kb}_Ka) \n                 =|> State':=2 /\\ witness(A,B,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{A,B})  \n\n      3. State=2 /\\ RCV({C.A.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xa')}_Kc.{SHA256(Ya')}_Kc}_Ka) \n                 =|> State':=3 /\\ witness(A,C,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{A,C})  \n\n      4. State=3 /\\ RCV({D.A.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xa')}_Kd.{SHA256(Ya')}_Kd}_Ka) \n                 =|> State':=4 /\\ witness(A,D,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{A,D})  \n\n      5. State=4 /\\ RCV({E.A.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xa')}_Ke.{SHA256(Ya')}_Ke}_Ka) \n                 =|> State':=5 /\\ witness(A,E,auth_1,Xa'.Ya') \n      /\\ secret(SHA256(Xe').SHA256(Ye'),sec_1,{A,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B,C,D,E,A:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n     1. State=0 /\\ RCV({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb) =|> State':=1 /\\ Xb':=new() /\\ Yb':=new()                   \n     /\\ SND({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xa')}_Kb.{SHA256(Ya')}_Kb}_Ka) \n     /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{A,B}) \n     /\\ witness(B,A,auth_1,Xb'.Yb') /\\ SND({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc) \n     /\\ SND({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd) /\\ SND({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke)\n\n    2. State=1 /\\ RCV({C.B.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xb')}_Kc.{SHA256(Yb')}_Kc}_Kb) \n                =|> State':=2 /\\ request(B,C,auth_1,Xb'.Yb') \n     /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{B,C})  \n\n    3. State=2 /\\ RCV({D.B.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xb')}_Kd.{SHA256(Yb')}_Kd}_Kb) \n                =|> State':=3 /\\ request(B,D,auth_1,Xb'.Yb') \n     /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{B,D})  \n\n    4. State=3 /\\ RCV({E.B.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xb')}_Ke.{SHA256(Yb')}_Ke}_Kb) \n                =|> State':=4 /\\ request(B,E,auth_1,Xb'.Yb')  \n     /\\ secret(SHA256(Xe').SHA256(Ye'),sec_1,{B,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_C(C,D,E,A,B:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text,\n\t\tState:nat\n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc) =|> State':=1 /\\ Xc':=new() /\\ Yc':=new()                   \n      /\\ SND({A.C.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xc')}_Ka.{SHA256(Yc')}_Ka}_Ka) \n      /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,C}) \n      /\\ witness(C,A,auth_1,Xa'.Ya') /\\ SND({C.B.{Xc'}_Kc.{Yc'}_Kc}_Kb) \n      /\\ SND({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd) /\\ SND({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke)\n\n    2. State=1 /\\ RCV({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc) =|> State':=2 /\\ witness(C,B,auth_1,Xb'.Yb') \n      /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,C})  \n\n    3.State=2 /\\ RCV({C.D.{Xc}_Kc.{Yc}_Kc.{SHA256(Xd')}_Kc.{SHA256(Yd')}_Kc}_Kc) \n               =|> State':=3 /\\ request(C,D,auth_1,Xc.Yc)  \n\n    4. State=3 /\\ RCV({C.E.{Xc}_Kc.{Yc}_Kc.{SHA256(Xe')}_Kc.{SHA256(Ye')}_Kc}_Kc) \n               =|> State':=4 /\\ request(C,E,auth_1,Xc.Yc)  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_D(D,E,A,B,C:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) =|> State':=1 /\\ Xd':=new() /\\ Yd':=new()                   \n    /\\ SND({A.D.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xd')}_Ka.{SHA256(Yd')}_Ka}_Ka) \n    /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,D}) \n    /\\ witness(D,A,auth_1,Xa'.Ya') /\\ SND({D.B.{Xd'}_Kd.{Yd'}_Kd}_Kb) \n    /\\ SND({D.C.{Xd'}_Kd.{Yd'}_Kd}_Kc) /\\ SND({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke)\n\n    2.State=1 /\\ RCV({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd) =|> State':=2 /\\ witness(D,B,auth_1,Xb'.Yb') \n    /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,D})  \n\n    3.State=2 /\\ RCV({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd) =|> State':=3 /\\ witness(D,C,auth_1,Xc'.Yc') \n    /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{C,D})  \n\n  4.State=3 /\\ RCV({D.E.{Xd}_Kd.{Yd}_Kd.{SHA256(Xe')}_Kd.{SHA256(Ye')}_Kd}_Kd) \n             =|> State':=4 /\\ request(D,E,auth_1,Xd.Yd)               \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_E(A,B,C,D,E:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by E\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) =|> State':=1 /\\ Xe':=new() /\\ Ye':=new()                   \n    /\\ SND({A.E.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xe')}_Ka.{SHA256(Ye')}_Ka}_Ka) \n    /\\ secret(SHA256(Xa').SHA256(Ya'),sec_1,{A,E}) \n    /\\ witness(E,A,auth_1,Xa'.Ya') /\\ SND({E.B.{Xe'}_Ke.{Ye'}_Ke}_Kb) \n    /\\ SND({E.C.{Xe'}_Ke.{Ye'}_Ke}_Kc) /\\ SND({E.D.{Xe'}_Ke.{Ye'}_Ke}_Kd)\n\n    2.State=1 /\\ RCV({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke) =|> State':=2 /\\ witness(E,B,auth_1,Xb'.Yb') \n    /\\ secret(SHA256(Xb').SHA256(Yb'),sec_1,{B,E})  \n\n    3.State=2 /\\ RCV({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke) =|> State':=3 /\\ witness(E,C,auth_1,Xc'.Yc') \n    /\\ secret(SHA256(Xc').SHA256(Yc'),sec_1,{C,E})  \n\n    4.State=3 /\\ RCV({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke) =|> State':=4 /\\ witness(E,D,auth_1,Xd'.Yd') \n    /\\ secret(SHA256(Xd').SHA256(Yd'),sec_1,{D,E})  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B,C,D,E:agent,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text,Ka,Kb,Kc,Kd,Ke:public_key,SHA256:hash_func)\ndef=\n\tlocal\t\n      SND1,RCV1,SND2,RCV2,SND3,RCV3,SND4,RCV4,SND5,RCV5 :channel(dy)\n\tcomposition\n       role_A(A,B,C,D,E,Ka,Kb,Kc,Kd,Ke,SHA256,SND1,RCV1)  \t\t\n        /\\ role_B(B,C,D,E,A,Ka,Kb,Kc,Kd,Ke,SHA256,SND2,RCV2) \t\t\n        /\\role_C(C,D,E,A,B,Ka,Kb,Kc,Kd,Ke,SHA256, SND3,RCV3) \t\t\n        /\\role_D(D,E,A,B,C,Ka,Kb,Kc,Kd,Ke,SHA256, SND4,RCV4)\n\t/\\role_E(A,B,C,D,E,Ka,Kb,Kc,Kd,Ke,SHA256, SND5,RCV5)\n\t\t\t\t \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\tconst\n\t\tka,kb,kc,kd,ke,ki:public_key,\n\t\ta,b,c,d,e:agent,\n                \txb,yb,xc,yc,xd,yd,xe,ye:text,\n\t\tsha256:hash_func,\n               \t sec_1,auth_1:protocol_id               \n\t\tintruder_knowledge=  \n                 {a,b,c,d,e,ka,kb,kc,kd,ke,ki,inv(ki)}\n\tcomposition\n           session(a,b,c,d,e,xb,yb,xc,yc,xd,yd,xe,ye,ka,kb,kc,kd,ke,sha256) \n\t\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sec_1\n  authentication_on auth_1\n\nend goal\n\nenvironment()\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/SPEKE.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Init(A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n                 \n  local  State: nat,\n         Na,Ca: text,\n         Cb   : text,\n         X,K  : message\n\n  const  sec_i_Ca, sec_i_Cb : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|> \n      State':= 1 /\\ Na' := new()\n                 /\\ Snd(exp(Kab, Na')) \n        \n   2. State  = 1 /\\ Rcv(exp(Kab, Nb')) =|>  \n      State':= 2 /\\ Ca' := new()\n                 /\\ K' := exp(X',Na)\n\t\t /\\ Snd({Ca'}_K)\n\t\t /\\ secret(Ca',sec_i_Ca,{A,B})\n\t\t /\\ witness(A,B,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb'.Ca}_K ) =|> \n      State':= 3 /\\ Snd({Cb'}_K)\n\t\t /\\ secret(Cb',sec_i_Cb,{A,B})\n\t\t /\\ request(A,B,cb,Cb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Resp(A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n           \n\n  local State: nat, \n        Nb,Cb: text,\n        Ca   : text,\n        Y,K  : message\n\n  const sec_r_Ca, sec_r_Cb : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(exp(Kab, Na')) =|> \n      State':= 1 /\\ Nb' := new()\n                 /\\ Snd(exp(Kab, Nb'))\n\t\t /\\ K' := exp(Y', Nb')\n\n   2. State  = 1 /\\ Rcv({Ca'}_K) =|>  \n      State':= 2 /\\ Cb' := new()\n                 /\\ Snd({Cb'.Ca'}_K)\n\t\t /\\ request(B,A,ca,Ca')\n\t\t /\\ witness(B,A,cb,Cb')\n\t\t /\\ secret(Cb',sec_r_Cb,{A,B})\n\n   3. State  = 2 /\\ Rcv({Cb}_K) =|> \n      State':= 3 /\\ secret(Ca,sec_r_Ca,{A,B})\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n\t      Kab: symmetric_key)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n\n       speke_Init(A,B,Kab,SA,RA)\n    /\\ speke_Resp(A,B,Kab,SB,RB)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a, b, i          : agent,\n        kab, kai, kbi : symmetric_key,\n        ca, cb        : protocol_id\n\n  intruder_knowledge = {a, b, kai, kbi}\n\n  composition\n\tsession(a,b,kab)\n    /\\  session(a,i,kai)\n    /\\  session(i,b,kbi)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n   % Confidentiality (G12)\n   %secrecy_of Ca, Cb \n   secrecy_of sec_i_Ca,sec_i_Cb,\n              sec_r_Ca,sec_r_Cb\n\n   % Message Authentication (G2)\n   % SPEKE_Init authenticates SPEKE_Resp on cb\n   authentication_on cb\n\n   % Message Authentication (G2)\n   % SPEKE_Resp authenticates SPEKE_Init on ca\n   authentication_on ca\n\nend goal  \n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Init(A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n                 \n  local  State: nat,\n         Na,Ca: text,\n         Cb   : text,\n         X,K  : message\n\n  const  sec_i_Ca, sec_i_Cb : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|> \n      State':= 1 /\\ Na' := new()\n                 /\\ Snd(exp(Kab, Na')) \n        \n   2. State  = 1 /\\ Rcv(exp(Kab, Nb')) =|>  \n      State':= 2 /\\ Ca' := new()\n                 /\\ K' := exp(X',Na)\n\t\t /\\ Snd({Ca'}_K)\n\t\t /\\ secret(Ca',sec_i_Ca,{A,B})\n\t\t /\\ witness(A,B,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb'.Ca}_K ) =|> \n      State':= 3 /\\ Snd({Cb'}_K)\n\t\t /\\ secret(Cb',sec_i_Cb,{A,B})\n\t\t /\\ request(A,B,cb,Cb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Resp(A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n           \n\n  local State: nat, \n        Nb,Cb: text,\n        Ca   : text,\n        Y,K  : message\n\n  const sec_r_Ca, sec_r_Cb : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(exp(Kab, Na')) =|> \n      State':= 1 /\\ Nb' := new()\n                 /\\ Snd(exp(Kab, Nb'))\n\t\t /\\ K' := exp(Y', Nb')\n\n   2. State  = 1 /\\ Rcv({Ca'}_K) =|>  \n      State':= 2 /\\ Cb' := new()\n                 /\\ Snd({Cb'.Ca'}_K)\n\t\t /\\ request(B,A,ca,Ca')\n\t\t /\\ witness(B,A,cb,Cb')\n\t\t /\\ secret(Cb',sec_r_Cb,{A,B})\n\n   3. State  = 2 /\\ Rcv({Cb}_K) =|> \n      State':= 3 /\\ secret(Ca,sec_r_Ca,{A,B})\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n\t      Kab: symmetric_key)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n\n       speke_Init(A,B,Kab,SA,RA)\n    /\\ speke_Resp(A,B,Kab,SB,RB)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a, b, i          : agent,\n        kab, kai, kbi : symmetric_key,\n        ca, cb        : protocol_id\n\n  intruder_knowledge = {a, b, kai, kbi}\n\n  composition\n\tsession(a,b,kab)\n    /\\  session(a,i,kai)\n    /\\  session(i,b,kbi)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n   % Confidentiality (G12)\n   %secrecy_of Ca, Cb \n   secrecy_of sec_i_Ca,sec_i_Cb,\n              sec_r_Ca,sec_r_Cb\n\n   % Message Authentication (G2)\n   % SPEKE_Init authenticates SPEKE_Resp on cb\n   authentication_on cb\n\n   % Message Authentication (G2)\n   % SPEKE_Resp authenticates SPEKE_Init on ca\n   authentication_on ca\n\nend goal  \n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/SRP.hlpsl": [[true, "%% PROTOCOL: SRP: Secure remote passwords\n%% PURPOSE: A client and a server authenticate each other based on \n%% a password such that the password remains secret, even if it is guessable.\n%% REFERENCE: \n%% \\begin{itemize}\n%% \\item \\url{http://srp.stanford.edu/}\n%% \\item  RFC 2945~\\cite{RFC2945}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%% ALICE_BOB:\n%% We have a password $p$ initially shared between the participants\n%% and a random number $s$, the \\emph{salt} (which at least the server knows \n%% initially). Original protocol, according to RFC:\n%% \\begin{verbatim}\n%% identifiers & macros:\n%% U = <username> \n%% p = <raw password>\n%% s = <salt from passwd file> (see notes section below)\n%% N = <modulus>\n%% x = SHA(s | SHA(U | \":\" | p))\n%% v = g^x mod N, the \"password verifier\"\n%% a = <random number, chosen by U>\n%% b = <random number, chosen by the server> \n%% A = g^a mod N\n%% B = v + g^b mod N\n%% u = H(A,B)\n%% S = (B - g^x) ^ (a + u * x) mod N \n%%   = (A * v^u) ^ b mod N\n%% K = SHA_Interleave(S)\n%% M = H(H(N) XOR H(g),H(U),s,A,B,K)\n%% -----------------------------------------------------------------\n%% Client -> Host   : U,A\n%% Host   -> Client : s,B\n%% Client -> Host   : M\n%% Host   -> Client : H(A,M,K)\n%% -----------------------------------------------------------------\n%% \\end{verbatim}\n%% Simplified version:\n%% \\begin{verbatim}\n%% Macros:\n%% K = H(V.(G^Na)^Nb)\n%% M = H(H(G),H(A).Salt.G^Na.{G^Nb}V.K)\n%% -----------------------------------------------------------------\n%% A -> B : A, G^Na\n%% B -> A : Salt, {G^Nb}V\n%% A -> B : M\n%% B -> A : H(G^Na,M,K)\n%% \\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% LIMITATIONS:\n%% Note that the protocol is slightly simplified as in the original version\n%% a full-scale algebraic theory is required. \n%% NOTES: \n%% A salt is a commonly-used mechanism to render dictionary\n%% (i.e. guessing) attacks more difficult.  Standard UNIX password\n%% files, for instance, store a hash of each password prepended with\n%% a two-character salt.  In this way, each possible password can map\n%% to 4096 different hash values, as there are 4096 possible\n%% values for the salt.  This therefore greatly increases the \n%% computing power required for an intruder to mount a password\n%% guessing attack based on a precomputed dictionary of passwords\n%% and corresponding hash values.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole srp_Init (A,B : agent,\n               Password : symmetric_key,\n\t       H : hash_func,\n\t       G : text,\n               Snd,Rcv:channel(dy))\nplayed_by A\ndef=\n\n  local State : nat, \n\tNa    :text,\n\tSalt  : protocol_id,\n\tDHY, V, K, M : message\n\n  const k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(start) =|>\n     State':= 1 /\\ Na' := new()\n                /\\ Snd(A.exp(G,Na'))  \n\n  2. State = 1  /\\ Rcv(Salt'.{DHY'}_{exp(G,H(Salt'.H(A.Password)))} ) =|> \n     State':= 2 /\\ V' := exp(G,H(Salt'.H(A.Password))) \n                /\\ K' := H( V'.exp(DHY',Na) )\n                /\\ M' := H(H(G).H(A).Salt'.exp(G,Na).{DHY'}_V'.K' )\n                /\\ Snd(M')\n                /\\ witness(A,B,k2,K')\n                /\\ secret(K',sec_i_K,{A,B})\n\n  3. State = 2  /\\ Rcv(H(exp(G,Na).M'.K')) =|>  \n     State':= 3\n                /\\ request(A,B,k2,K)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole srp_Resp (B,A: agent,\n               Password: symmetric_key,\n\t       Salt: protocol_id,\n\t       H: hash_func,\n\t       G: text,\n               Snd,Rcv:channel(dy))\nplayed_by B\ndef=\n\n  local State : nat, \n\tNb    : text,\n\tM, K, DHX, V: message\n\n  const sec_r_K : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(A.DHX') =|> \n     State':= 1 /\\ Nb' := new()\n                /\\ Snd(Salt.{exp(G,Nb')}_{exp(G,H(Salt.H(A.Password)))})\n                /\\ V' := exp(G,H(Salt.H(A.Password)))\n                /\\ K' := H( V'.exp(DHX',Nb') )\n                /\\ M' := H(H(G).H(A).Salt.DHX'.{exp(G,Nb')}_V'.K')\n                /\\ request(B,A,k2,K')\n                /\\ secret(K',sec_r_K,{A,B})\n\n  2. State = 1  /\\ Rcv(M') =|>\n     State':= 3 /\\ Snd(H(DHX.M'.K')) \n                /\\ witness(B,A,k2,K)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A,B: agent,\n\t     Password: symmetric_key,\n\t     Salt: protocol_id,\n\t     H: hash_func,\n\t     G: text)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n           srp_Init(A,B,Password,H,G,SA,RA)  /\\\n           srp_Resp(B,A,Password,Salt,H,G,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n  const k1,k2 : protocol_id,\n\ta,b,i: agent,\n\tkab,kai,kbi: symmetric_key,\n\ts_ab,s_ai,s_bi: protocol_id,\n\th: hash_func,\n\tg: text\n\t\n  intruder_knowledge = {i, kai, kbi, s_ai, s_bi}\n  composition\n\t   session(a,b,kab,s_ab,h,g)\n/\\ session(a,i,kai,s_ai,h,g)\n/\\ session(b,i,kbi,s_bi,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n  \ngoal\n\n    % confidentiality (G12)\n    secrecy_of sec_i_K, sec_r_K\n\n    % Entity Authentication (G1)\n    % Message Authentication (G2)\n    % Replay Protection (G3) --- forgotten in d6.1\n    authentication_on k2\n    authentication_on k1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: SRP: Secure remote passwords\n%% PURPOSE: A client and a server authenticate each other based on \n%% a password such that the password remains secret, even if it is guessable.\n%% REFERENCE: \n%% \\begin{itemize}\n%% \\item \\url{http://srp.stanford.edu/}\n%% \\item  RFC 2945~\\cite{RFC2945}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%% ALICE_BOB:\n%% We have a password $p$ initially shared between the participants\n%% and a random number $s$, the \\emph{salt} (which at least the server knows \n%% initially). Original protocol, according to RFC:\n%% \\begin{verbatim}\n%% identifiers & macros:\n%% U = <username> \n%% p = <raw password>\n%% s = <salt from passwd file> (see notes section below)\n%% N = <modulus>\n%% x = SHA(s | SHA(U | \":\" | p))\n%% v = g^x mod N, the \"password verifier\"\n%% a = <random number, chosen by U>\n%% b = <random number, chosen by the server> \n%% A = g^a mod N\n%% B = v + g^b mod N\n%% u = H(A,B)\n%% S = (B - g^x) ^ (a + u * x) mod N \n%%   = (A * v^u) ^ b mod N\n%% K = SHA_Interleave(S)\n%% M = H(H(N) XOR H(g),H(U),s,A,B,K)\n%% -----------------------------------------------------------------\n%% Client -> Host   : U,A\n%% Host   -> Client : s,B\n%% Client -> Host   : M\n%% Host   -> Client : H(A,M,K)\n%% -----------------------------------------------------------------\n%% \\end{verbatim}\n%% Simplified version:\n%% \\begin{verbatim}\n%% Macros:\n%% K = H(V.(G^Na)^Nb)\n%% M = H(H(G),H(A).Salt.G^Na.{G^Nb}V.K)\n%% -----------------------------------------------------------------\n%% A -> B : A, G^Na\n%% B -> A : Salt, {G^Nb}V\n%% A -> B : M\n%% B -> A : H(G^Na,M,K)\n%% \\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% LIMITATIONS:\n%% Note that the protocol is slightly simplified as in the original version\n%% a full-scale algebraic theory is required. \n%% NOTES: \n%% A salt is a commonly-used mechanism to render dictionary\n%% (i.e. guessing) attacks more difficult.  Standard UNIX password\n%% files, for instance, store a hash of each password prepended with\n%% a two-character salt.  In this way, each possible password can map\n%% to 4096 different hash values, as there are 4096 possible\n%% values for the salt.  This therefore greatly increases the \n%% computing power required for an intruder to mount a password\n%% guessing attack based on a precomputed dictionary of passwords\n%% and corresponding hash values.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole srp_Init (A,B : agent,\n               Password : symmetric_key,\n\t       H : hash_func,\n\t       G : text,\n               Snd,Rcv:channel(dy))\nplayed_by A\ndef=\n\n  local State : nat, \n\tNa    :text,\n\tSalt  : protocol_id,\n\tDHY, V, K, M : message\n\n  const k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(start) =|>\n     State':= 1 /\\ Na' := new()\n                /\\ Snd(A.exp(G,Na'))  \n\n  2. State = 1  /\\ Rcv(Salt'.{DHY'}_{exp(G,H(Salt'.H(A.Password)))} ) =|> \n     State':= 2 /\\ V' := exp(G,H(Salt'.H(A.Password))) \n                /\\ K' := H( V'.exp(DHY',Na) )\n                /\\ M' := H(H(G).H(A).Salt'.exp(G,Na).{DHY'}_V'.K' )\n                /\\ Snd(M')\n                /\\ witness(A,B,k2,K')\n                /\\ secret(K',sec_i_K,{A,B})\n\n  3. State = 2  /\\ Rcv(H(exp(G,Na).M'.K')) =|>  \n     State':= 3\n                /\\ request(A,B,k2,K)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole srp_Resp (B,A: agent,\n               Password: symmetric_key,\n\t       Salt: protocol_id,\n\t       H: hash_func,\n\t       G: text,\n               Snd,Rcv:channel(dy))\nplayed_by B\ndef=\n\n  local State : nat, \n\tNb    : text,\n\tM, K, DHX, V: message\n\n  const sec_r_K : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(A.DHX') =|> \n     State':= 1 /\\ Nb' := new()\n                /\\ Snd(Salt.{exp(G,Nb')}_{exp(G,H(Salt.H(A.Password)))})\n                /\\ V' := exp(G,H(Salt.H(A.Password)))\n                /\\ K' := H( V'.exp(DHX',Nb') )\n                /\\ M' := H(H(G).H(A).Salt.DHX'.{exp(G,Nb')}_V'.K')\n                /\\ request(B,A,k2,K')\n                /\\ secret(K',sec_r_K,{A,B})\n\n  2. State = 1  /\\ Rcv(M') =|>\n     State':= 3 /\\ Snd(H(DHX.M'.K')) \n                /\\ witness(B,A,k2,K)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A,B: agent,\n\t     Password: symmetric_key,\n\t     Salt: protocol_id,\n\t     H: hash_func,\n\t     G: text)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n           srp_Init(A,B,Password,H,G,SA,RA)  /\\\n           srp_Resp(B,A,Password,Salt,H,G,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n  const k1,k2 : protocol_id,\n\ta,b,i: agent,\n\tkab,kai,kbi: symmetric_key,\n\ts_ab,s_ai,s_bi: protocol_id,\n\th: hash_func,\n\tg: text\n\t\n  intruder_knowledge = {i, kai, kbi, s_ai, s_bi}\n  composition\n\t   session(a,b,kab,s_ab,h,g)\n/\\ session(a,i,kai,s_ai,h,g)\n/\\ session(b,i,kbi,s_bi,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n  \ngoal\n\n    % confidentiality (G12)\n    secrecy_of sec_i_K, sec_r_K\n\n    % Entity Authentication (G1)\n    % Message Authentication (G2)\n    % Replay Protection (G3) --- forgotten in d6.1\n    authentication_on k2\n    authentication_on k1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/strongAuthentication_assym.hlpsl": [[true, "%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nat,S':text,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Kb)\n\t\t2. State=1 /\\ RCV({Na'.S'}_Ka) =|> State':=2\n\n\t\t%% A checks that B is the emitter of nonce\n\t\t/\\ witness(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na':nat\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Na'}_Kb)  =|> State':=1 /\\ SND({Na'.S}_Ka)\n\t\t\n\t\t/\\ request(B,A,sec_1,{A,B}) \n\t\t%% B Check the authentication of nonce\n\t\t/\\ request(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text,Ka:public_key,Kb:public_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2,Ka,Kb) /\\ role_A(A,B,S,SND1,RCV1,Ka,Kb)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\talice,bob:agent,\n\t\ts1:text,\n\t\tsec_1,sec_2,auth_1:protocol_id,\n\t\tka:public_key,\n\t\tkb:public_key\n\n\tintruder_knowledge = {alice,bob,kb}\n\n\tcomposition\n\t\t%% add another session for replay attack\n\t\tsession(alice,bob,s1,ka,kb) /\\ session(alice,bob,s1,ka,kb)\nend role\n\ngoal \n\tsecrecy_of sec_1   \n\tweak_authentication_on auth_1 \n\t%%  weak_authentication_on auth_1 , wrequest\n\tauthentication_on auth_1\nend goal\n\nenvironment()", "```hlpsl\n%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nat,S':text,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Kb)\n\t\t2. State=1 /\\ RCV({Na'.S'}_Ka) =|> State':=2\n\n\t\t%% A checks that B is the emitter of nonce\n\t\t/\\ witness(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na':nat\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Na'}_Kb)  =|> State':=1 /\\ SND({Na'.S}_Ka)\n\t\t\n\t\t/\\ request(B,A,sec_1,{A,B}) \n\t\t%% B Check the authentication of nonce\n\t\t/\\ request(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text,Ka:public_key,Kb:public_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2,Ka,Kb) /\\ role_A(A,B,S,SND1,RCV1,Ka,Kb)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\talice,bob:agent,\n\t\ts1:text,\n\t\tsec_1,sec_2,auth_1:protocol_id,\n\t\tka:public_key,\n\t\tkb:public_key\n\n\tintruder_knowledge = {alice,bob,kb}\n\n\tcomposition\n\t\t%% add another session for replay attack\n\t\tsession(alice,bob,s1,ka,kb) /\\ session(alice,bob,s1,ka,kb)\nend role\n\ngoal \n\tsecrecy_of sec_1   \n\tweak_authentication_on auth_1 \n\t%%  weak_authentication_on auth_1 , wrequest\n\tauthentication_on auth_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/strongAuthentication_symm.hlpsl": [[true, "%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy),Sk:symmetric_key)\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,S':text,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Sk)\n\t\t2. State=1 /\\ RCV({Na'.S'}_Sk) =|> State':=2\n\n               %% A checks that B is the emmiter of nonce\n                /\\ request(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(A:agent,B:agent,S:text,SND:channel(dy),RCV:channel(dy),Sk:symmetric_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV({Na'}_Sk)  =|> State':=1 /\\ SND({Na'.S}_Sk)\n                \n                /\\ secret(S,sec_1,{A,B}) \n                %% B Check the athentication of nonce\n                /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text,Sk:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(A,B,S,SND2,RCV2,Sk) /\\ role_A(A,B,S,SND1,RCV1,Sk)\nend role\n\nrole environment()\ndef=\n\tconst\n\t               alice,bob:agent,\n                               s1:text,\n                               sec_1,sec_2,auth_1:protocol_id,\n                               sk:symmetric_key\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n                               %% add another session for replay attack\n\t\tsession(alice,bob,s1,sk) /\\ session(alice,bob,s1,sk)\nend role\n\ngoal \n                secrecy_of sec_1   \n                secrecy_of sec_2   \n                %%  weak_authentication_on auth_1 , wrequest\n                authentication_on auth_1\nend goal\n\nenvironment()", "```hlpsl\n%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy),Sk:symmetric_key)\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,S':text,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Sk)\n\t\t2. State=1 /\\ RCV({Na'.S'}_Sk) =|> State':=2\n\n               %% A checks that B is the emmiter of nonce\n                /\\ request(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(A:agent,B:agent,S:text,SND:channel(dy),RCV:channel(dy),Sk:symmetric_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV({Na'}_Sk)  =|> State':=1 /\\ SND({Na'.S}_Sk)\n                \n                /\\ secret(S,sec_1,{A,B}) \n                %% B Check the athentication of nonce\n                /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text,Sk:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(A,B,S,SND2,RCV2,Sk) /\\ role_A(A,B,S,SND1,RCV1,Sk)\nend role\n\nrole environment()\ndef=\n\tconst\n\t               alice,bob:agent,\n                               s1:text,\n                               sec_1,sec_2,auth_1:protocol_id,\n                               sk:symmetric_key\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n                               %% add another session for replay attack\n\t\tsession(alice,bob,s1,sk) /\\ session(alice,bob,s1,sk)\nend role\n\ngoal \n                secrecy_of sec_1   \n                secrecy_of sec_2   \n                %%  weak_authentication_on auth_1 , wrequest\n                authentication_on auth_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/An_Autonomous_Log_Storage_Management_Protocol_with_Blockchain_Mechanism_and_Access_Control_for_the_Internet_of_Things.hlpsl": [[true, "role user(ROLE_2) role user (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new() /\\ SND({IDi'}_Kau) /\\ secret(IDi',sec_idi,{A,U})\n2.  State = 1 /\\ RCV({exp(G,Add(Alpha'.TIDi'))}_Kau) =|>\nState':= 2\n%/\\ Store SK % Log verification phase\n3.  State = 0 /\\ RCV(exp(G,Ss').Mul(M.exp(Y,Ss')).({X'.IP.T}_inv(ECDSA))) =|>\nState':= 1\n%/\\ Use ECDSA to verify ECDSA signature %/\\ Use Y and C = Mul(M.exp(Y,S)) to verify log signature\n/\\ request(S,U,ss,Ss)\n/\\ Ys' := Pair(SK.exp(G,Ss'))\n%/\\ Use Ys to decytp C and obtain view the log data M\nend role\n\nrole authority (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by A def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1. State = 0 /\\ RCV({IDi'}_Kau) =|>\nState':= 1\n%/\\ Verify IDi\n/\\ Alpha' := new() /\\ TIDi' := new() /\\ SK' := exp(G,Add(Alpha'.TIDi'))\n%/\\ The value SK' is computed for three attributes A, B, C\n/\\ SND({SK'}_Kau)\n/\\ secret(SK',sec_sk,{A,U}) /\\ secret(Alpha',sec_alpha,{A})\nend role\n\nrole sensor (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% Log signcryption phase\n1. State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ Ss' := new() %/\\ Choose Ss for computation of three attributes A, B, C; M is the log data\n/\\ Ce' := exp(G,Ss') /\\ C' := Mul(M.exp(Y,Ss')) /\\ Hs' := H(C') /\\ X' := exp(Hs',Mul(Y.Ss')) %/\\ X: log signature\n/\\ Sig' := {X'.IP.T}_inv(ECDSA) %/\\ IP: IP adrress of the Sensor; T: timestamp\n/\\ SND(Ce'.C'.Sig')\n/\\ secret(Ss',sec_ss,{S})\n/\\ witness(S,U,ss,Ss')\nend role\n\nrole session (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func) def=\nlocal SA, RA, SS, RS, SU, RU: channel (dy)\ncomposition\nauthority (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SA,RA) /\\ sensor (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SS,RS)\n/\\ user (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SU,RU)\nend role\n\nrole environment() def=\nconst a, s, u, i: agent,\nkau, kui: symmetric_key,\necdsa, ki: public_key,\nh, add, mul, pair: hash_func,\nidi, sk, alpha, ss: protocol_id\nintruder_knowledge = {a,s,u,ki,inv(ki)}\ncomposition\nsession(a,s,u,kau,ecdsa,h,add,mul,pair) /\\ session(i,s,u,kui,ecdsa,h,add,mul,pair)\n/\\ session(a,i,u,kui,ecdsa,h,add,mul,pair) /\\ session(a,s,i,kui,ecdsa,h,add,mul,pair)\nend role\ngoal\nsecrecy_of sec_idi, sec_sk, sec_alpha, sec_ss\nauthentication_on ss\nend goal\nenvironment()", "```hlpsl\nrole user(ROLE_2) role user (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new() /\\ SND({IDi'}_Kau) /\\ secret(IDi',sec_idi,{A,U})\n2.  State = 1 /\\ RCV({exp(G,Add(Alpha'.TIDi'))}_Kau) =|>\nState':= 2\n%/\\ Store SK % Log verification phase\n3.  State = 0 /\\ RCV(exp(G,Ss').Mul(M.exp(Y,Ss')).({X'.IP.T}_inv(ECDSA))) =|>\nState':= 1\n%/\\ Use ECDSA to verify ECDSA signature %/\\ Use Y and C = Mul(M.exp(Y,S)) to verify log signature\n/\\ request(S,U,ss,Ss)\n/\\ Ys' := Pair(SK.exp(G,Ss'))\n%/\\ Use Ys to decytp C and obtain view the log data M\nend role\n\nrole authority (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by A def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1. State = 0 /\\ RCV({IDi'}_Kau) =|>\nState':= 1\n%/\\ Verify IDi\n/\\ Alpha' := new() /\\ TIDi' := new() /\\ SK' := exp(G,Add(Alpha'.TIDi'))\n%/\\ The value SK' is computed for three attributes A, B, C\n/\\ SND({SK'}_Kau)\n/\\ secret(SK',sec_sk,{A,U}) /\\ secret(Alpha',sec_alpha,{A})\nend role\n\nrole sensor (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% Log signcryption phase\n1. State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ Ss' := new() %/\\ Choose Ss for computation of three attributes A, B, C; M is the log data\n/\\ Ce' := exp(G,Ss') /\\ C' := Mul(M.exp(Y,Ss')) /\\ Hs' := H(C') /\\ X' := exp(Hs',Mul(Y.Ss')) %/\\ X: log signature\n/\\ Sig' := {X'.IP.T}_inv(ECDSA) %/\\ IP: IP adrress of the Sensor; T: timestamp\n/\\ SND(Ce'.C'.Sig')\n/\\ secret(Ss',sec_ss,{S})\n/\\ witness(S,U,ss,Ss')\nend role\n\nrole session (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func) def=\nlocal SA, RA, SS, RS, SU, RU: channel (dy)\ncomposition\nauthority (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SA,RA) /\\ sensor (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SS,RS)\n/\\ user (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SU,RU)\nend role\n\nrole environment() def=\nconst a, s, u, i: agent,\nkau, kui: symmetric_key,\necdsa, ki: public_key,\nh, add, mul, pair: hash_func,\nidi, sk, alpha, ss: protocol_id\nintruder_knowledge = {a,s,u,ki,inv(ki)}\ncomposition\nsession(a,s,u,kau,ecdsa,h,add,mul,pair) /\\ session(i,s,u,kui,ecdsa,h,add,mul,pair)\n/\\ session(a,i,u,kui,ecdsa,h,add,mul,pair) /\\ session(a,s,i,kui,ecdsa,h,add,mul,pair)\nend role\ngoal\nsecrecy_of sec_idi, sec_sk, sec_alpha, sec_ss\nauthentication_on ss\nend goal\nenvironment()\n```"]], "HLPSL-1/Three-factor_fast_authentication_scheme_for_e-health_systems_in_5G_wireless_sensor_network.hlpsl": [[true, "role user(U: agent, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SU, RU: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDi, PWi & Bi\n\t\t   /\\ E' := new()\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n\t\t   /\\ SU({IDi.W'.BBi'}_Kus)\n\t\t   /\\ secret(E',g1,{U})\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g4,{U})\n\t\t   /\\ secret(Bi,g5,{U})\n\n\t2.  State = 1 /\\ RU({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\t\t   %/\\ Store E, IDi, PWi & Bi in the smart card\n\t\t   %/\\ Store Ej', IDj, & Nj in the USB\n\n% Login and initial authentication phase\n\n\t3.  State = 2 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card\n\t\t   %/\\ Enter PWi* & Bi*\n\t\t   /\\ V' := new()\n\t\t   %/\\ Suppose b = 3\n\t\t   /\\ N' := H(H(H(V')))\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n\t\t   /\\ Yij' := xor(E,Ej)\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A' := xor(xor(BBi',W'),Tu')\n\t\t   /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n\t\t   /\\ SU(K')\n\t\t   /\\ witness(U,S,u_s_tu,Tu')\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(V,g3,{U})\n\t\t   /\\ secret(PWi,g4,{U})\n\t\t   /\\ secret(Bi,g7,{U})\n\n\t4.  State = 3 /\\ RU(({B'.H(Yij.IDi.H(Xj)).H6(H(H(Yij.IDi.H(Xj)).Xj.As')).H14(H(H(Yij.IDi.H(Xj)).Xj.Bs')).Ts'}_SKij').T1'.T2') =|>\n\t\t   State':= 2\n\t\t   /\\ SKij' := H(xor(N,Yij))\n\t\t   %/\\ Confirm Ts'\n\t\t   %/\\ Confirm B\n\t\t   %/\\ Store IDinew, ATa, ATb in the smart card\n\t\t   %/\\ Store T1, T2 in the USB\n\t\t   /\\ request(S,U,s_u_ts,Ts')\n\n% Fast authentication phase\n\n \t5. State = 0 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDinew, PWi & Bi\n\t\t   %/\\ Suppose Tlogin = 8\n\t\t   /\\ Ay' := H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As)))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs))))\n\t\t   /\\ SU(Ay')\n\n\t6. State = 1 /\\ RU({H(xor(Ay',IDinew))}_SKij) =|>\n\t\t   State':= 2\n\t\t   %/\\ Confirm By'\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SS, RS: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, X, Y, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RS({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n\t\t   %/\\ Store IDj\n\t\t   /\\ RS({IDi.Nj.Yij'}_Kus)\n\t\t   /\\ secret(Xj,g6,{S})\n\n% Login and initial authentication phase\n\n\t2. State = 0 /\\ RS({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\n\t\t   State':= 1\n\t\t   %/\\ Confirm Tu'\n\t\t   %/\\ Use Xj to decrypt Yij\n\t\t   %/\\ Confirm H(Xj), IDsj & IDi\n\t\t   /\\ A' := xor(xor(BBi.W).Tu')\n\t\t   %/\\ Confirm A\n\t\t   /\\ Ts' := new()\n\t\t   /\\ B' := xor(H(H(H(H(V')))),Ts')\n\t\t   /\\ IDinew' := H(Yij.IDi.H(Xj))\n\t\t   /\\ T1' := new()   /\\ T2' := new()\n\t\t   /\\ As' := new()   /\\ Bs' := new()\n\t\t   %/\\ Z =24, suppose T1=7, T2=10\n\t\t   /\\ ATa' := H6(H(IDinew'.Xj.As'))\n\t\t   /\\ ATb' := H14(H(IDinew'.Xj.Bs'))\n\t\t   /\\ SKij' := H(xor(H(H(H(V'))),Yij'))\n\t\t   /\\ Q':= {B'.IDinew'.ATa'.ATb'.Ts'}_SKij'\n\t\t   /\\ RS (Q'.T1'.T2')\n\t\t   /\\ witness(S,U,s_u_ts,Ts')\n\t\t   /\\ secret(As',g3,{S})\n\t\t   /\\ secret(Bs',g4,{S})\n\t\t   /\\ request(U,S,u_s_v,V)\n\t\t   /\\ request(U,S,u_s_tu,Tu')\n\n% Fast authentication phase\n\n\t3. State = 0 /\\ RS(H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As')))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs'))))) =|>\n\t\t   State':= 1\n\t\t   /\\ X' := H(IDinew.Xj.As)\n\t\t   /\\ Y' := H(IDinew.Xj.Bs)\n\t\t   /\\ Ay' := H(H7(X').H16(Y'))\n\t\t   %/\\ Confirm Ay\n\t\t   /\\ By' := {H(xor(Ay',IDinew))}_SKij\n\t\t   /\\ RS(By')\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func) def=\n\n  local SU, RU, SS, RS: channel (dy)\n\n  composition\n\n\tuser (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SU,RU)\n          /\\ server (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SS,RS)\n\nend role\n\n\nrole environment() def=\n\n    const u, s, i: agent,\n\t  kus, skij, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, h1, h2, h6, h7, h14, h16: hash_func,\n\t  u_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5, g6, g7: protocol_id\n\n    intruder_knowledge = {u,s,i,ks,ki,inv(ki)}\n\n    composition\n\n\tsession(u,s,kus,skij,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(u,i,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(i,s,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\nend role\n\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6, g7\n  authentication_on u_s_v, u_s_tu, s_u_ts\n\nend goal\n\n\n\nenvironment()", "```hlpsl\nrole user(U: agent, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SU, RU: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDi, PWi & Bi\n\t\t   /\\ E' := new()\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n\t\t   /\\ SU({IDi.W'.BBi'}_Kus)\n\t\t   /\\ secret(E',g1,{U})\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g4,{U})\n\t\t   /\\ secret(Bi,g5,{U})\n\n\t2.  State = 1 /\\ RU({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\t\t   %/\\ Store E, IDi, PWi & Bi in the smart card\n\t\t   %/\\ Store Ej', IDj, & Nj in the USB\n\n% Login and initial authentication phase\n\n\t3.  State = 2 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card\n\t\t   %/\\ Enter PWi* & Bi*\n\t\t   /\\ V' := new()\n\t\t   %/\\ Suppose b = 3\n\t\t   /\\ N' := H(H(H(V')))\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n\t\t   /\\ Yij' := xor(E,Ej)\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A' := xor(xor(BBi',W'),Tu')\n\t\t   /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n\t\t   /\\ SU(K')\n\t\t   /\\ witness(U,S,u_s_tu,Tu')\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(V,g3,{U})\n\t\t   /\\ secret(PWi,g4,{U})\n\t\t   /\\ secret(Bi,g7,{U})\n\n\t4.  State = 3 /\\ RU(({B'.H(Yij.IDi.H(Xj)).H6(H(H(Yij.IDi.H(Xj)).Xj.As')).H14(H(H(Yij.IDi.H(Xj)).Xj.Bs')).Ts'}_SKij').T1'.T2') =|>\n\t\t   State':= 2\n\t\t   /\\ SKij' := H(xor(N,Yij))\n\t\t   %/\\ Confirm Ts'\n\t\t   %/\\ Confirm B\n\t\t   %/\\ Store IDinew, ATa, ATb in the smart card\n\t\t   %/\\ Store T1, T2 in the USB\n\t\t   /\\ request(S,U,s_u_ts,Ts')\n\n% Fast authentication phase\n\n \t5. State = 0 /\\ RU(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDinew, PWi & Bi\n\t\t   %/\\ Suppose Tlogin = 8\n\t\t   /\\ Ay' := H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As)))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs))))\n\t\t   /\\ SU(Ay')\n\n\t6. State = 1 /\\ RU({H(xor(Ay',IDinew))}_SKij) =|>\n\t\t   State':= 2\n\t\t   %/\\ Confirm By'\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SS, RS: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, X, Y, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RS({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n\t\t   %/\\ Store IDj\n\t\t   /\\ RS({IDi.Nj.Yij'}_Kus)\n\t\t   /\\ secret(Xj,g6,{S})\n\n% Login and initial authentication phase\n\n\t2. State = 0 /\\ RS({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\n\t\t   State':= 1\n\t\t   %/\\ Confirm Tu'\n\t\t   %/\\ Use Xj to decrypt Yij\n\t\t   %/\\ Confirm H(Xj), IDsj & IDi\n\t\t   /\\ A' := xor(xor(BBi.W).Tu')\n\t\t   %/\\ Confirm A\n\t\t   /\\ Ts' := new()\n\t\t   /\\ B' := xor(H(H(H(H(V')))),Ts')\n\t\t   /\\ IDinew' := H(Yij.IDi.H(Xj))\n\t\t   /\\ T1' := new()   /\\ T2' := new()\n\t\t   /\\ As' := new()   /\\ Bs' := new()\n\t\t   %/\\ Z =24, suppose T1=7, T2=10\n\t\t   /\\ ATa' := H6(H(IDinew'.Xj.As'))\n\t\t   /\\ ATb' := H14(H(IDinew'.Xj.Bs'))\n\t\t   /\\ SKij' := H(xor(H(H(H(V'))),Yij'))\n\t\t   /\\ Q':= {B'.IDinew'.ATa'.ATb'.Ts'}_SKij'\n\t\t   /\\ RS (Q'.T1'.T2')\n\t\t   /\\ witness(S,U,s_u_ts,Ts')\n\t\t   /\\ secret(As',g3,{S})\n\t\t   /\\ secret(Bs',g4,{S})\n\t\t   /\\ request(U,S,u_s_v,V)\n\t\t   /\\ request(U,S,u_s_tu,Tu')\n\n% Fast authentication phase\n\n\t3. State = 0 /\\ RS(H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As')))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs'))))) =|>\n\t\t   State':= 1\n\t\t   /\\ X' := H(IDinew.Xj.As)\n\t\t   /\\ Y' := H(IDinew.Xj.Bs)\n\t\t   /\\ Ay' := H(H7(X').H16(Y'))\n\t\t   %/\\ Confirm Ay\n\t\t   /\\ By' := {H(xor(Ay',IDinew))}_SKij\n\t\t   /\\ RS(By')\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func) def=\n\n  local SU, RU, SS, RS: channel (dy)\n\n  composition\n\n\tuser (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SU,RU)\n          /\\ server (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SS,RS)\n\nend role\n\n\nrole environment() def=\n\n    const u, s, i: agent,\n\t  kus, skij, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, h1, h2, h6, h7, h14, h16: hash_func,\n\t  u_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5, g6, g7: protocol_id\n\n    intruder_knowledge = {u,s,i,ks,ki,inv(ki)}\n\n    composition\n\n\tsession(u,s,kus,skij,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(u,i,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(i,s,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\nend role\n\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6, g7\n  authentication_on u_s_v, u_s_tu, s_u_ts\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/Three-Factor_UCSSO_Scheme_With_Fast_Authentication_and_Privacy_Protection_for_Telecare_Medicine_Information_Systems.hlpsl": [[true, "role user (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   /\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new() %/\\ Input IDi', PWi', and imprint Bi'\n\t\t   /\\ R' := new()\n\t\t   /\\ Xi' := H(PWi'.Bi')\n\t\t   /\\ Y' := H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))\n\t\t   /\\ SND({IDi'.Xi'.Y'}_SecureChannel)\n\t\t   /\\ secret(r,{U,TMIS})\n\t\t   /\\ secret(idi,{U})\n\t\t   /\\ witness(U,TMIS,e,E)\n\t\t   /\\ witness(U,TMIS,bi,Bi')\n\n\t2.  State = 1 /\\ RCV({Rabin.({H(SKj).IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj')}_SecureChannel) =|>\n\t\t   State':= 2\n\t\t   /\\ Wj' := xor(R,({H(SKj).IDsj.IDi'.Y.Xi'}_SKj))\n\t\t   %/\\ Store R, IDi, PWi and Bi in the smart card\n\t\t   %/\\ Store Wj', IDsj and Rabin in the USB\n\n% Login and First Authentication\n\n\t3.  State = 2 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card %/\\ Input IDi', PWi', and imprint Bi' % Smart card confirm Bi'\n\t\t   /\\ Xi' := H(PWi.Bi)\n\t\t   /\\ Y' := H(H(PWi.R).xor(h(xor(IDi,IDsj)),R))\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A1' := xor(xor(Xi',Y'),Tu')\n\t\t   /\\ Nij' := xor(R,Wj)\n\t\t   /\\ E' := new() %/\\ Suppose m = 4\n\t\t   /\\ M' := H(H(H(H(E'))))\n\t\t   /\\ C1' := {IDsj.IDi.A1'.Nij'.M'}_Rabin\n\t\t   /\\ SND(C1'.Tu')\n\t\t   /\\ witness(U,TMIS,e,E)\n\t\t   /\\ witness(U,TMIS,tu,Tu')\n\n\t4.  State = 1 /\\ RCV(({xor(H(H(H(H(H(E'))))),Ts')}_Kij').Ts') =|>\n\t\t   State':= 2\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(M,Nij))\n\t\t   %/\\ Confirm Ts' %/\\ Confirm A2'\n\t\t   %/\\ Store Kij' in the smart card\n\t\t   /\\ request(TMIS,U,ts,Ts')\n\n% Fast Authentication with New Session Key\n\n \t5. State = 2 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ input IDi', PWi', and imprint Bi' for smart card verification\n\t\t   %/\\ Suppose alpha = 1\n\t\t   /\\ M1':= H(H(H(E)))\n\t\t   /\\ Pa' := {M1'}_Kij\n\t\t   /\\ SND(Pa')\n\n\t6. State = 1 /\\ RCV({H(H(H(E)))}_KijNew') =|>\n\t\t   State':= 2\n\t\t   /\\ KijNew':= M1.Kij\n\t\t   /\\ Qa':= {M1}_KijNew'\n\t\t   %/\\ Check Qa'. If it is legitimate, then accept KijNew'\n\nend role\n\n\nrole tmis (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by TMIS def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, C2, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1. State = 0 /\\ RCV({IDi'.H(PWi'.Bi').H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))}_SecureChannel) =|>\n\t\t   State':= 1\n\t\t   /\\ SKj' := new() /\\ Nij' := {H(SKj').IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj'\n\t\t   %/\\ Store IDi, Y, Xi\n\t\t   /\\ SND({Rabin.Nij'}_SecureChannel)\n\t\t   /\\ secret(skj,{TMIS})\n\n% Login and First Authentication\n\n\t2. State = 0 /\\ RCV(({IDsj.IDi.H(H(H(H(E')))).xor(xor(Xi,Y),Tu').Nij}_Rabin).Tu') =|>\n\t\t   State':= 1\n\t\t   %/\\ Check Tu'\n\t\t   %/\\ Confirm H(SKj), IDsj and IDi\n\t\t   /\\ A1' := xor(xor(Xi,Y),Tu')\n\t\t   %/\\ Check A1\n\t\t   /\\ Ts' := new()\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(H(H(H(H(E')))),Nij))\n\t\t   /\\ C2' := {A2'}_Kij'\n\t\t   /\\ SND (C2'.Ts')\n\t\t   /\\ witness(TMIS,U,ts,Ts')\n\t\t   /\\ request(U,TMIS,e,E)\n\t\t   /\\ request(U,TMIS,tu,Tu')\n\t\t   /\\ witness(TMIS,U,kij,Kij')\n\n% Fast Authentication with New Session Key\n\n\t3. State = 0 /\\ RCV({H(H(H(E)))}_Kij) =|>\n\t\t   State':= 1\n\t\t   %/\\ Check whether H(M1') = M. If there is a match, then M1' replaces M\n\t\t   /\\ KijNew' := H(H(H(E))).Kij\n\t\t   %/\\ KijNew' replaces Kij\n\t\t   /\\ Qa':= {H(H(H(E)))}_KijNew'\n\t\t   /\\ SND(Qa')\n\t\t   /\\ secret(kijnew,{U,TMIS})\nend role\n\nrole session (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func) def=\n\n  local SU, RU, STMIS, RTMIS: channel (dy)\n\n  composition\n\n\tuser (U,TMIS,SecureChannel,Rabin,H,SU,RU)\n          /\\ tmis (U,TMIS,SecureChannel,Rabin,H,STMIS,RTMIS)\n\nend role\n\n\nrole environment() def=\n\n    const u, tmis, i: agent,\n\t  securechannel, kai: symmetric_key,\n\t  rabin, ki: public_key,\n\t  h: hash_func,\n\t  r, idi, pwi, bi, skj, kij, kijnew, e, tu, ts: protocol_id\n\n    intruder_knowledge = {u,tmis,rabin,ki,inv(ki)}\n\n    composition\n\n\tsession(u,tmis,securechannel,rabin,h)\n\t/\\ session(u,i,kai,rabin,h)\n\t/\\ session(i,tmis,kai,rabin,h)\n\nend role\n\n\ngoal\n\n  secrecy_of r, idi, pwi, bi, skj, kij, kijnew\n  authentication_on e, tu, ts\n\nend goal\n\n\n\nenvironment()", "```hlpsl\nrole user (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   /\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new() %/\\ Input IDi', PWi', and imprint Bi'\n\t\t   /\\ R' := new()\n\t\t   /\\ Xi' := H(PWi'.Bi')\n\t\t   /\\ Y' := H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))\n\t\t   /\\ SND({IDi'.Xi'.Y'}_SecureChannel)\n\t\t   /\\ secret(r,{U,TMIS})\n\t\t   /\\ secret(idi,{U})\n\t\t   /\\ witness(U,TMIS,e,E)\n\t\t   /\\ witness(U,TMIS,bi,Bi')\n\n\t2.  State = 1 /\\ RCV({Rabin.({H(SKj).IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj')}_SecureChannel) =|>\n\t\t   State':= 2\n\t\t   /\\ Wj' := xor(R,({H(SKj).IDsj.IDi'.Y.Xi'}_SKj))\n\t\t   %/\\ Store R, IDi, PWi and Bi in the smart card\n\t\t   %/\\ Store Wj', IDsj and Rabin in the USB\n\n% Login and First Authentication\n\n\t3.  State = 2 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card %/\\ Input IDi', PWi', and imprint Bi' % Smart card confirm Bi'\n\t\t   /\\ Xi' := H(PWi.Bi)\n\t\t   /\\ Y' := H(H(PWi.R).xor(h(xor(IDi,IDsj)),R))\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A1' := xor(xor(Xi',Y'),Tu')\n\t\t   /\\ Nij' := xor(R,Wj)\n\t\t   /\\ E' := new() %/\\ Suppose m = 4\n\t\t   /\\ M' := H(H(H(H(E'))))\n\t\t   /\\ C1' := {IDsj.IDi.A1'.Nij'.M'}_Rabin\n\t\t   /\\ SND(C1'.Tu')\n\t\t   /\\ witness(U,TMIS,e,E)\n\t\t   /\\ witness(U,TMIS,tu,Tu')\n\n\t4.  State = 1 /\\ RCV(({xor(H(H(H(H(H(E'))))),Ts')}_Kij').Ts') =|>\n\t\t   State':= 2\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(M,Nij))\n\t\t   %/\\ Confirm Ts' %/\\ Confirm A2'\n\t\t   %/\\ Store Kij' in the smart card\n\t\t   /\\ request(TMIS,U,ts,Ts')\n\n% Fast Authentication with New Session Key\n\n \t5. State = 2 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ input IDi', PWi', and imprint Bi' for smart card verification\n\t\t   %/\\ Suppose alpha = 1\n\t\t   /\\ M1':= H(H(H(E)))\n\t\t   /\\ Pa' := {M1'}_Kij\n\t\t   /\\ SND(Pa')\n\n\t6. State = 1 /\\ RCV({H(H(H(E)))}_KijNew') =|>\n\t\t   State':= 2\n\t\t   /\\ KijNew':= M1.Kij\n\t\t   /\\ Qa':= {M1}_KijNew'\n\t\t   %/\\ Check Qa'. If it is legitimate, then accept KijNew'\n\nend role\n\n\nrole tmis (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by TMIS def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, C2, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1. State = 0 /\\ RCV({IDi'.H(PWi'.Bi').H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))}_SecureChannel) =|>\n\t\t   State':= 1\n\t\t   /\\ SKj' := new() /\\ Nij' := {H(SKj').IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj'\n\t\t   %/\\ Store IDi, Y, Xi\n\t\t   /\\ SND({Rabin.Nij'}_SecureChannel)\n\t\t   /\\ secret(skj,{TMIS})\n\n% Login and First Authentication\n\n\t2. State = 0 /\\ RCV(({IDsj.IDi.H(H(H(H(E')))).xor(xor(Xi,Y),Tu').Nij}_Rabin).Tu') =|>\n\t\t   State':= 1\n\t\t   %/\\ Check Tu'\n\t\t   %/\\ Confirm H(SKj), IDsj and IDi\n\t\t   /\\ A1' := xor(xor(Xi,Y),Tu')\n\t\t   %/\\ Check A1\n\t\t   /\\ Ts' := new()\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(H(H(H(H(E')))),Nij))\n\t\t   /\\ C2' := {A2'}_Kij'\n\t\t   /\\ SND (C2'.Ts')\n\t\t   /\\ witness(TMIS,U,ts,Ts')\n\t\t   /\\ request(U,TMIS,e,E)\n\t\t   /\\ request(U,TMIS,tu,Tu')\n\t\t   /\\ witness(TMIS,U,kij,Kij')\n\n% Fast Authentication with New Session Key\n\n\t3. State = 0 /\\ RCV({H(H(H(E)))}_Kij) =|>\n\t\t   State':= 1\n\t\t   %/\\ Check whether H(M1') = M. If there is a match, then M1' replaces M\n\t\t   /\\ KijNew' := H(H(H(E))).Kij\n\t\t   %/\\ KijNew' replaces Kij\n\t\t   /\\ Qa':= {H(H(H(E)))}_KijNew'\n\t\t   /\\ SND(Qa')\n\t\t   /\\ secret(kijnew,{U,TMIS})\nend role\n\nrole session (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func) def=\n\n  local SU, RU, STMIS, RTMIS: channel (dy)\n\n  composition\n\n\tuser (U,TMIS,SecureChannel,Rabin,H,SU,RU)\n          /\\ tmis (U,TMIS,SecureChannel,Rabin,H,STMIS,RTMIS)\n\nend role\n\n\nrole environment() def=\n\n    const u, tmis, i: agent,\n\t  securechannel, kai: symmetric_key,\n\t  rabin, ki: public_key,\n\t  h: hash_func,\n\t  r, idi, pwi, bi, skj, kij, kijnew, e, tu, ts: protocol_id\n\n    intruder_knowledge = {u,tmis,rabin,ki,inv(ki)}\n\n    composition\n\n\tsession(u,tmis,securechannel,rabin,h)\n\t/\\ session(u,i,kai,rabin,h)\n\t/\\ session(i,tmis,kai,rabin,h)\n\nend role\n\n\ngoal\n\n  secrecy_of r, idi, pwi, bi, skj, kij, kijnew\n  authentication_on e, tu, ts\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/TLS.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const na_nb1, sec_clientk, na_nb2, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (dy))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Ka, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const a, b, i : agent,\n         h, prf, keygen : hash_func,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const na_nb1, sec_clientk, na_nb2, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (dy))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Ka, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const a, b, i : agent,\n         h, prf, keygen : hash_func,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/total.hlpsl": [[true, "role user(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by Ui\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew:text\nconst ui_gwn_ri,gwn_ui_ts4,ui_gwn_ts1,gwn_ui_kinew,sd_gwn_ts3,gwn_sd_rj,sr1,sr2:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv(start)=|>\nState':=1/\\IDi':=new() /\\PWi':=new() /\\R1':=new()\n         /\\Snd({IDi'.H(IDi'.R1').T(Ki'.X)}_SKura)\n         /\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi'},sr2,Ui)\n%Receives the smart card (SCi) through the secure channel\n2.State=1/\\Rcv({TIDi'.TEMP'.H(TIDi'.TEMP'.G).T(TIDi'.G.X).H(IDi'.R1).T(Ki'.G.X)}_SKura)=|>\nState':=2/\\TIDi':=TIDi /\\TEMP':=TEMP\n         /\\request(RA,Ui,ra_ui_tidi,TIDi)\n/\\request(RA,Ui,ra_ui_temp,TEMP)\n/\\request(RA,Ui,ra_ui_kix,T(Ki'.G.X))\n%User login and authentication request\n3.State=2/\\Rcv(=xor(____()___))=|>\nState':=4/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi'.R1').MIDj)\n         /\\Snd(TIDi'.xor((Kinew'.Ri'.MIDj),T(Ki'.G.X)).H(Kinew'.Ri'.MIDj.H(IDi'.R1').T(Ki'.G.X).TS1').TS1')\n4.State=3/\\Rcv(xor(Rj'.Rg',Kug').H(Kug'.H(IDi'.R1').Ri'.Rj'.Rg'.TS4').TS4')=|>\nState':=4/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi'.R1').MIDj)\n/\\request(GWN,Ui,gwn_ui_ts4,TS4')\nend role\n\n\n\n\nrole gateway(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by GWN\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,Ei:text\nconst ui_gwn_ri,gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,gwn_ui_ts4,ui_gwn_ts1,sr3,sr4:protocol_id\ninit State:=0\ntransition \n%Receive login request from Ui through open channel\n1.State=0/\\Rcv(TIDi'.xor((Kinew'.Ri'.MIDj),T(Ki'.G.X)).H(Kinew'.Ri'.MIDj.H(IDi'.R1').T(Ki'.G.X).TS1').TS1')=|>\nState':=1/\\witness(Ui,GWN,ui_gwn_ri,Ri')\n         /\\witness(Ui,GWN,ui_gwn_ts1,TS1')\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr4,{GWN,SDj})\n         /\\TS2':=new() /\\Rg':=new()\n         /\\Ei':=xor((Ri'.Rg'.H(IDi'.R1')),H(Ksg.MIDj.TS2'))\n         /\\M2':=H(Ri'.Rg'.H(IDi'.R1').Ksg.TS2')\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')  \n         /\\Snd(Ei'.M2'.TS2')\n\n         \n2.State=1/\\Rcv(xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3') =|>\n  State':=2/\\TS4':=new() /\\Ri' := new()\n           /\\Ni':=xor((Rj'.Rg').T(Ki'.G.X))\n           /\\M4':=H(T(Ki'.G.X).Ri'.Rj'.Rg'.TS4')\n           /\\witness(GWN,Ui,gwn_ui_ts4,TS4')\n           /\\witness(GWN,SDj,gwn_sd_rj,Rj')\n           /\\request(SDj,GWN,sd_gwn_ts3,TS3')\n           /\\Snd(Ni'.M4'.TS4')\nend role\n\n\n\n\n\nrole smartdevice(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by SDj\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS2,TS3,Bi,M3,G,Ki,Kinew,Ni,SK,Gj:text\nconst gwn_sdj_ts2,gwn_sdj_rg,ui_gwn_ts1,sd_gwn_ts3,sd_gwn_rj,gwn_ui_ts4,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Receive authentication request message from GWN through open channel\n1.State=0/\\Rcv(xor((Ri'.Rg'.H(IDi'.R1')),H(Ksg.MIDj.TS2')).H(Ri'.Rg'.H(IDi'.R1').Ksg.TS2').TS2')=|>\nState':=1/\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr3,{GWN,SDj})\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')\n         /\\TS3':=new() /\\Rj':=new()\n         /\\Gj':=xor(Rj',H(Ksg.MIDj.TS3'))\n         /\\SK':=H(Ri'.Rg'.Rj'.H(IDi'.R1').MIDj)\n         /\\M3':=H(Ksg.MIDj.Rg'.Rj'.TS3')\n%Send authentication reply message to Ui through open channel        \n         /\\Snd(xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3')\n%SDj has freshly generated the values TS3 \n         /\\witness(SDj,GWN,sd_gwn_ts3,TS3')\n         /\\witness(SDj,GWN,sd_gwn_rj,Rj')\nend role\n\n\nrole registration(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\n\nplayed_by RA\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew,Tg:text\nconst ra_ui_tidi,ra_ui_temp,ra_ui_kix,sr1,sr3:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv({IDi'.H(IDi'.R1').T(Ki'.X)}_SKura)=|>\nState':=2/\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr3,{GWN,SDj})\n         /\\TIDi':=new() /\\TEMP':=new() /\\Tg':=T(G.X)\n/\\request(Ui,RA,ui_ra_idi,IDi')\n%Send smart card (SCi) to Ui securely\n         /\\Snd({TIDi'.TEMP'.H(TIDi'.TEMP'.G).T(TIDi'.G.X).H(IDi'.R1').T(Ki'.G.X)}_SKura)\nend role\n\n\n\nrole session(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,SKura:symmetric_key)\ndef=\n  local SD1,RV1,SD2,RV2,SD3,RV3,SD4,RV4:channel(dy)\n  composition\n    user(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD1,RV1)\n/\\smartdevice(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD2,RV2)\n/\\gateway(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD3,RV3)\n/\\registration(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD4,RV4)\nend role\n\nrole environment()\ndef=\nconst ui,gwn,sdj,ra:agent,h,t,puf:hash_func,\n      skura:symmetric_key,\n      idi,idj,t1,t2,t3,t4,\n      midi,midj,bi,m1,ei,m2,tcj,gj,m3,m4:text,\n      sr1,sr2,sr3,sr4,ui_gwn_ri,ui_gwn_ts1,gwn_ui_ts4,gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,sd_gwn_rj:protocol_id\nintruder_knowledge={h,t1,t2,t3,midi,bi,m1,ei,m2,tcj,gj,m3}\ncomposition\n  session(ui,gwn,sdj,ra,h,t,puf,skura)\n/\\session(i,gwn,sdj,ra,h,t,puf,skura)\n/\\session(ui,i,sdj,ra,h,t,puf,skura)\n/\\session(ui,gwn,i,ra,h,t,puf,skura)\nend role\n\ngoal \n%%% Confidentiality (privacy)\nsecrecy_of sr1,sr2,sr3,sr4\n%%% Authentication\nauthentication_on ui_gwn_ri,gwn_ui_ts4\nauthentication_on gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,sd_gwn_rj\nend goal\n\nenvironment()", "```hlpsl\nrole user(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by Ui\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew:text\nconst ui_gwn_ri,gwn_ui_ts4,ui_gwn_ts1,gwn_ui_kinew,sd_gwn_ts3,gwn_sd_rj,sr1,sr2:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv(start)=|>\nState':=1/\\IDi':=new() /\\PWi':=new() /\\R1':=new()\n         /\\Snd({IDi'.H(IDi'.R1').T(Ki'.X)}_SKura)\n         /\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi'},sr2,Ui)\n%Receives the smart card (SCi) through the secure channel\n2.State=1/\\Rcv({TIDi'.TEMP'.H(TIDi'.TEMP'.G).T(TIDi'.G.X).H(IDi'.R1).T(Ki'.G.X)}_SKura)=|>\nState':=2/\\TIDi':=TIDi /\\TEMP':=TEMP\n         /\\request(RA,Ui,ra_ui_tidi,TIDi)\n/\\request(RA,Ui,ra_ui_temp,TEMP)\n/\\request(RA,Ui,ra_ui_kix,T(Ki'.G.X))\n%User login and authentication request\n3.State=2/\\Rcv(=xor(____()___))=|>\nState':=4/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi'.R1').MIDj)\n         /\\Snd(TIDi'.xor((Kinew'.Ri'.MIDj),T(Ki'.G.X)).H(Kinew'.Ri'.MIDj.H(IDi'.R1').T(Ki'.G.X).TS1').TS1')\n4.State=3/\\Rcv(xor(Rj'.Rg',Kug').H(Kug'.H(IDi'.R1').Ri'.Rj'.Rg'.TS4').TS4')=|>\nState':=4/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi'.R1').MIDj)\n/\\request(GWN,Ui,gwn_ui_ts4,TS4')\nend role\n\n\n\n\nrole gateway(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by GWN\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,Ei:text\nconst ui_gwn_ri,gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,gwn_ui_ts4,ui_gwn_ts1,sr3,sr4:protocol_id\ninit State:=0\ntransition \n%Receive login request from Ui through open channel\n1.State=0/\\Rcv(TIDi'.xor((Kinew'.Ri'.MIDj),T(Ki'.G.X)).H(Kinew'.Ri'.MIDj.H(IDi'.R1').T(Ki'.G.X).TS1').TS1')=|>\nState':=1/\\witness(Ui,GWN,ui_gwn_ri,Ri')\n         /\\witness(Ui,GWN,ui_gwn_ts1,TS1')\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr4,{GWN,SDj})\n         /\\TS2':=new() /\\Rg':=new()\n         /\\Ei':=xor((Ri'.Rg'.H(IDi'.R1')),H(Ksg.MIDj.TS2'))\n         /\\M2':=H(Ri'.Rg'.H(IDi'.R1').Ksg.TS2')\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')  \n         /\\Snd(Ei'.M2'.TS2')\n\n         \n2.State=1/\\Rcv(xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3') =|>\n  State':=2/\\TS4':=new() /\\Ri' := new()\n           /\\Ni':=xor((Rj'.Rg').T(Ki'.G.X))\n           /\\M4':=H(T(Ki'.G.X).Ri'.Rj'.Rg'.TS4')\n           /\\witness(GWN,Ui,gwn_ui_ts4,TS4')\n           /\\witness(GWN,SDj,gwn_sd_rj,Rj')\n           /\\request(SDj,GWN,sd_gwn_ts3,TS3')\n           /\\Snd(Ni'.M4'.TS4')\nend role\n\n\n\n\n\nrole smartdevice(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by SDj\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS2,TS3,Bi,M3,G,Ki,Kinew,Ni,SK,Gj:text\nconst gwn_sdj_ts2,gwn_sdj_rg,ui_gwn_ts1,sd_gwn_ts3,sd_gwn_rj,gwn_ui_ts4,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Receive authentication request message from GWN through open channel\n1.State=0/\\Rcv(xor((Ri'.Rg'.H(IDi'.R1')),H(Ksg.MIDj.TS2')).H(Ri'.Rg'.H(IDi'.R1').Ksg.TS2').TS2')=|>\nState':=1/\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr3,{GWN,SDj})\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')\n         /\\TS3':=new() /\\Rj':=new()\n         /\\Gj':=xor(Rj',H(Ksg.MIDj.TS3'))\n         /\\SK':=H(Ri'.Rg'.Rj'.H(IDi'.R1').MIDj)\n         /\\M3':=H(Ksg.MIDj.Rg'.Rj'.TS3')\n%Send authentication reply message to Ui through open channel        \n         /\\Snd(xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3')\n%SDj has freshly generated the values TS3 \n         /\\witness(SDj,GWN,sd_gwn_ts3,TS3')\n         /\\witness(SDj,GWN,sd_gwn_rj,Rj')\nend role\n\n\nrole registration(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\n\nplayed_by RA\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew,Tg:text\nconst ra_ui_tidi,ra_ui_temp,ra_ui_kix,sr1,sr3:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv({IDi'.H(IDi'.R1').T(Ki'.X)}_SKura)=|>\nState':=2/\\secret(IDi',sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Ksg},sr3,{GWN,SDj})\n         /\\TIDi':=new() /\\TEMP':=new() /\\Tg':=T(G.X)\n/\\request(Ui,RA,ui_ra_idi,IDi')\n%Send smart card (SCi) to Ui securely\n         /\\Snd({TIDi'.TEMP'.H(TIDi'.TEMP'.G).T(TIDi'.G.X).H(IDi'.R1').T(Ki'.G.X)}_SKura)\nend role\n\n\n\nrole session(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,SKura:symmetric_key)\ndef=\n  local SD1,RV1,SD2,RV2,SD3,RV3,SD4,RV4:channel(dy)\n  composition\n    user(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD1,RV1)\n/\\smartdevice(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD2,RV2)\n/\\gateway(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD3,RV3)\n/\\registration(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD4,RV4)\nend role\n\nrole environment()\ndef=\nconst ui,gwn,sdj,ra:agent,h,t,puf:hash_func,\n      skura:symmetric_key,\n      idi,idj,t1,t2,t3,t4,\n      midi,midj,bi,m1,ei,m2,tcj,gj,m3,m4:text,\n      sr1,sr2,sr3,sr4,ui_gwn_ri,ui_gwn_ts1,gwn_ui_ts4,gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,sd_gwn_rj:protocol_id\nintruder_knowledge={h,t1,t2,t3,midi,bi,m1,ei,m2,tcj,gj,m3}\ncomposition\n  session(ui,gwn,sdj,ra,h,t,puf,skura)\n/\\session(i,gwn,sdj,ra,h,t,puf,skura)\n/\\session(ui,i,sdj,ra,h,t,puf,skura)\n/\\session(ui,gwn,i,ra,h,t,puf,skura)\nend role\n\ngoal \n%%% Confidentiality (privacy)\nsecrecy_of sr1,sr2,sr3,sr4\n%%% Authentication\nauthentication_on ui_gwn_ri,gwn_ui_ts4\nauthentication_on gwn_sdj_ts2,gwn_sdj_rg,sd_gwn_ts3,sd_gwn_rj\nend goal\n\nenvironment()\n```"]], "HLPSL-1/UMTS_AKA.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole server(S,M : agent,\n\t    Snd, Rcv: channel(dy),\n            K_M: symmetric_key,\n            Seq : text,\n            F1,F2,F5: hash_func)\nplayed_by S\ndef=\n\n  local State : nat,\n        R     : text\n\n  const r1,r2,auth1,auth2 : protocol_id,\n        add         : hash_func\n\n  init  State := 1 \n\n  transition\n\n    1.  State   = 1 /\\ Rcv(M)\n        =|> \n        State' := 2 /\\ R' := new()\n                    /\\ Snd(R'.{Seq}_F5(K_M.R').F1(K_M.Seq.R')) \n\t \t    /\\ secret(K_M,sec_k,{S,M})\n\t\t    /\\ witness(S,M,auth2,R')\n\n    2.  State   = 2 /\\ Rcv(F2(K_M.R'))\n        =|> \n        State' := 3 /\\ Seq' := add(Seq,1) \n\t\t    /\\ request(S,M,auth1,R')\n        \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole mobile(M,S: agent,\n            Snd, Rcv: channel(dy),\n            K_M: symmetric_key,\n            Seq: text,\n            F1,F2,F5: hash_func)\nplayed_by M\ndef=\n\n  local State :nat, \n\tR     :text\n\n  const\n        r1,auth1,auth2 : protocol_id\n\n  init  State := 1\n\n  transition\n\n    1.  State = 1 /\\ Rcv(start) =|> \n        State':=2 /\\ Snd(M)  \n\n    2.  State = 2 /\\ Rcv(R'.{Seq'}_F5(K_M.R').F1(K_M.Seq'.R')) =|>  \n        State':=3 /\\ Snd(F2(K_M. R')) \n\t\t  /\\ secret(K_M,sec_k,{M,S})\n\t\t  /\\ request(M,S,r1,R') \n\t\t  /\\ witness(M,S,auth2,R')\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(M,S: agent,\n\t     K_M: symmetric_key,\n\t     Seq: text,\n             F1,F2,F5: hash_func,\n             SA,RA,SB,RB: channel(dy)) def=\n\n   composition\n\n\t mobile(M,S,SA,RA,K_M,Seq,F1,F2,F5)\n      /\\ server(S,M,SB,RB,K_M,Seq,F1,F2,F5)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n local Sa1,Ra1,Ss1,Rs1 : channel (dy)\n\n const r1, r2                 : protocol_id,\n       a, i, s                : agent,\n       k_as, k_is, kai        : symmetric_key,\n       f1, f2, f5             : hash_func,\n       seq_as, seq_is, seq_ai : text,\n       sec_k, auth1, auth2    : protocol_id\n\n intruder_knowledge={a,s,i,f1,f2,f5}\n\n composition\n \n\tsession(a,s,k_as,seq_as,f1,f2,f5,Sa1,Ra1,Ss1,Rs1) \n% /\\\tsession(i,s,k_is,seq_is,f1,f2,f5,si1,ri1,ss2,rs2) \n% /\\\tsession(a,i,k_ai,seq_ai,f1,f2,f5,sa2,ra2,si2,ri2)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  secrecy_of sec_k\n\n  % Message Authentication (G2)\n  % Mobile weakly authenticates Server on r1  % the nonce R\n  weak_authentication_on auth1\n\n  % Message Authentication (G2)\n  % Server weakly authenticates Mobile on r2  % the nonce R\n  weak_authentication_on auth2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole server(S,M : agent,\n\t    Snd, Rcv: channel(dy),\n            K_M: symmetric_key,\n            Seq : text,\n            F1,F2,F5: hash_func)\nplayed_by S\ndef=\n\n  local State : nat,\n        R     : text\n\n  const r1,r2,auth1,auth2 : protocol_id,\n        add         : hash_func\n\n  init  State := 1 \n\n  transition\n\n    1.  State   = 1 /\\ Rcv(M)\n        =|> \n        State' := 2 /\\ R' := new()\n                    /\\ Snd(R'.{Seq}_F5(K_M.R').F1(K_M.Seq.R')) \n\t \t    /\\ secret(K_M,sec_k,{S,M})\n\t\t    /\\ witness(S,M,auth2,R')\n\n    2.  State   = 2 /\\ Rcv(F2(K_M.R'))\n        =|> \n        State' := 3 /\\ Seq' := add(Seq,1) \n\t\t    /\\ request(S,M,auth1,R')\n        \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole mobile(M,S: agent,\n            Snd, Rcv: channel(dy),\n            K_M: symmetric_key,\n            Seq: text,\n            F1,F2,F5: hash_func)\nplayed_by M\ndef=\n\n  local State :nat, \n\tR     :text\n\n  const\n        r1,auth1,auth2 : protocol_id\n\n  init  State := 1\n\n  transition\n\n    1.  State = 1 /\\ Rcv(start) =|> \n        State':=2 /\\ Snd(M)  \n\n    2.  State = 2 /\\ Rcv(R'.{Seq'}_F5(K_M.R').F1(K_M.Seq'.R')) =|>  \n        State':=3 /\\ Snd(F2(K_M. R')) \n\t\t  /\\ secret(K_M,sec_k,{M,S})\n\t\t  /\\ request(M,S,r1,R') \n\t\t  /\\ witness(M,S,auth2,R')\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(M,S: agent,\n\t     K_M: symmetric_key,\n\t     Seq: text,\n             F1,F2,F5: hash_func,\n             SA,RA,SB,RB: channel(dy)) def=\n\n   composition\n\n\t mobile(M,S,SA,RA,K_M,Seq,F1,F2,F5)\n      /\\ server(S,M,SB,RB,K_M,Seq,F1,F2,F5)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n local Sa1,Ra1,Ss1,Rs1 : channel (dy)\n\n const r1, r2                 : protocol_id,\n       a, i, s                : agent,\n       k_as, k_is, kai        : symmetric_key,\n       f1, f2, f5             : hash_func,\n       seq_as, seq_is, seq_ai : text,\n       sec_k, auth1, auth2    : protocol_id\n\n intruder_knowledge={a,s,i,f1,f2,f5}\n\n composition\n \n\tsession(a,s,k_as,seq_as,f1,f2,f5,Sa1,Ra1,Ss1,Rs1) \n% /\\\tsession(i,s,k_is,seq_is,f1,f2,f5,si1,ri1,ss2,rs2) \n% /\\\tsession(a,i,k_ai,seq_ai,f1,f2,f5,sa2,ra2,si2,ri2)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  secrecy_of sec_k\n\n  % Message Authentication (G2)\n  % Mobile weakly authenticates Server on r1  % the nonce R\n  weak_authentication_on auth1\n\n  % Message Authentication (G2)\n  % Server weakly authenticates Mobile on r2  % the nonce R\n  weak_authentication_on auth2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/update_simple(final).hlpsl": [[true, "role_OBU role OBU(\n  OBU,SN                   : agent,\n  Kseaf                    : symmetric_key,\n  PID                      : text,\n  H1,H2,PUF                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU def=\n  \n  local\n    State        :nat,\n\tC1,C2,T        :text,\n\tH12,PID2,R1,R2,R1en,S1,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\t\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ SND(PID) \n  2. State = 2 /\\ RCV(C2'.C1'.R1en'.H11')  /\\ H11' = H1(C2'.C1'.PUF(C1').PID.R1en') =|>\n     State' := 4 /\\ R1' := PUF(C1') /\\ R2' := PUF(C2') /\\ R2en' := xor(R1',R2') /\\ H12' := H1(R1'.C2'.R2'.PID) /\\ SND(R2en'.H12')\n\t             /\\ witness(OBU,SN,o_s_h12,H12')\n  3. State = 4 /\\ RCV(PID2'.Res') /\\ Res' = H1(PID2'.R2)=|>\n     State' := 6 /\\ witness(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN}) /\\ request(OBU,SN,s_o_res,Res') /\\ request(OBU,SN,s_o_h11,H11)\n\nend role\n\nrole role_SN(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tC2,PIDn,T        :text,\n\tH12,PID2,R1,R2,S1,R1en,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PIDn') /\\ PIDn' = PID =|>\n     State' := 3 /\\ R1' := PUF(C1) /\\ C2' := new() /\\ R1en' := H1(C2',R1') /\\ H11' := H1(C2'.C1.R1'.PIDn'.R1en') /\\ SND(C2'.C1.R1en'.H11') \n\t             /\\ witness(SN,OBU,s_o_h11,H11')\n  2. State = 3 /\\ RCV(R2en'.H12') /\\ H12' = H1(R1.C2.xor(R2en',R1).PIDn) =|>\n     State' := 5 /\\ R2' := xor(R2en',R1) /\\ T' := new() /\\ PID2' := H1(PID.Kseaf.R2'.T) /\\ Res' := H1(PID2'.R2') /\\ SND(PID2'.Res')\n\t             /\\ witness(SN,OBU,s_o_res,Res') /\\ secret(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN})\n\nend role\n\n\nrole session(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func)\ndef=\n  local SO,RO,SS,RS : channel(dy)\n  \n  composition\n    role_OBU(OBU,SN,Kseaf,PID,H1,H2,PUF,SO,RO) /\\ role_SN(OBU,SN,Kseaf,PID,C1,H1,H2,PUF,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,s1,s2,o_s_h12,s_o_h11,s_o_res  :protocol_id,\n    obu,sn     : agent,\n\tkseaf       : symmetric_key,\n    pid,c1   : text,\n    h1,h2,puf        : hash_func\n  intruder_knowledge = {pid,obu,sn,h1,h2} \n  \n  composition\n    session(obu,sn,kseaf,pid,c1,h1,h2,puf) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of s1\n  authentication_on s_o_res\n  authentication_on o_s_h12\n  authentication_on s_o_h11\nend goal\n\nenvironment()", "```hlpsl\nrole_OBU role OBU(\n  OBU,SN                   : agent,\n  Kseaf                    : symmetric_key,\n  PID                      : text,\n  H1,H2,PUF                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU def=\n  \n  local\n    State        :nat,\n\tC1,C2,T        :text,\n\tH12,PID2,R1,R2,R1en,S1,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\t\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ SND(PID) \n  2. State = 2 /\\ RCV(C2'.C1'.R1en'.H11')  /\\ H11' = H1(C2'.C1'.PUF(C1').PID.R1en') =|>\n     State' := 4 /\\ R1' := PUF(C1') /\\ R2' := PUF(C2') /\\ R2en' := xor(R1',R2') /\\ H12' := H1(R1'.C2'.R2'.PID) /\\ SND(R2en'.H12')\n\t             /\\ witness(OBU,SN,o_s_h12,H12')\n  3. State = 4 /\\ RCV(PID2'.Res') /\\ Res' = H1(PID2'.R2)=|>\n     State' := 6 /\\ witness(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN}) /\\ request(OBU,SN,s_o_res,Res') /\\ request(OBU,SN,s_o_h11,H11)\n\nend role\n\nrole role_SN(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tC2,PIDn,T        :text,\n\tH12,PID2,R1,R2,S1,R1en,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PIDn') /\\ PIDn' = PID =|>\n     State' := 3 /\\ R1' := PUF(C1) /\\ C2' := new() /\\ R1en' := H1(C2',R1') /\\ H11' := H1(C2'.C1.R1'.PIDn'.R1en') /\\ SND(C2'.C1.R1en'.H11') \n\t             /\\ witness(SN,OBU,s_o_h11,H11')\n  2. State = 3 /\\ RCV(R2en'.H12') /\\ H12' = H1(R1.C2.xor(R2en',R1).PIDn) =|>\n     State' := 5 /\\ R2' := xor(R2en',R1) /\\ T' := new() /\\ PID2' := H1(PID.Kseaf.R2'.T) /\\ Res' := H1(PID2'.R2') /\\ SND(PID2'.Res')\n\t             /\\ witness(SN,OBU,s_o_res,Res') /\\ secret(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN})\n\nend role\n\n\nrole session(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func)\ndef=\n  local SO,RO,SS,RS : channel(dy)\n  \n  composition\n    role_OBU(OBU,SN,Kseaf,PID,H1,H2,PUF,SO,RO) /\\ role_SN(OBU,SN,Kseaf,PID,C1,H1,H2,PUF,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,s1,s2,o_s_h12,s_o_h11,s_o_res  :protocol_id,\n    obu,sn     : agent,\n\tkseaf       : symmetric_key,\n    pid,c1   : text,\n    h1,h2,puf        : hash_func\n  intruder_knowledge = {pid,obu,sn,h1,h2} \n  \n  composition\n    session(obu,sn,kseaf,pid,c1,h1,h2,puf) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of s1\n  authentication_on s_o_res\n  authentication_on o_s_h12\n  authentication_on s_o_h11\nend goal\n\nenvironment()\n```"]], "HLPSL-1/usglight.hlpsl": [[true, "role user (Ui, Sj, GW : agent,\n           Kdi,Kei: symmetric_key,\n\t\t   Expp: hash_func,\n\t\t   H: hash_func,\n\t\t   P: text,\t   \n           SND_UG,RCV_UG: channel (dy))\n\t\t   \nplayed_by Ui\n\ndef=\n\n  local TmpIDi: nat,\n        T1,K1,A,M1,M2,Ki,B,K3,K2,IDi,SIDj,M4,M6,M7,SK,Keinew  : text\n\n  const shared_key,sc_user_id,sc_sensor_id:protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State   = 0   /\\ RCV_UG(start)=|> \n      State' := 1   /\\ T1' := new()\n\t\t\t\t\t/\\ K1' := new()\n\t\t\t\t\t/\\ A'  := Expp(P,K1')\n\t\t\t\t\t/\\ M2' := H(A'.IDi.SIDj.Kdi.T1')\n\t\t\t\t\t/\\ M1' := xor(Kei,(IDi.SIDj.M2'))\n\t\t\t\t\t/\\ SND_UG(A'.M1'.Ki.T1')\n\t\t\t\t\t\n\t\t\t\t\t\n\n   2. State   = 7   /\\ RCV_UG(   B'\n\t\t\t\t\t\t\t\t.xor((Keinew'.K3'.H(Kei.K3'.Kdi.T1.M4')),Kei)\n\t\t\t\t\t\t\t  ) =|>\n\t\t\t\t\t\t\t\t\n      State' := 8   /\\ Kei':= Keinew'\n\t\t\t\t\t/\\ Ki' := K3'\n\t\t\t\t\t/\\ SK' := H(Expp(B',K1))\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret(IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret(SIDj,sc_sensor_id,{Ui,GW})\n\t\t\t\t\t/\\ witness(Ui,Sj,shared_key,SK')\n\t\t\t\t\t/\\ request(Ui,Sj,shared_key,SK')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole sensor (Ui, Sj, GW : agent,\n             Kxj: symmetric_key,\n\t\t\t Expp: hash_func,\n\t\t\t H: hash_func,\n\t\t     P: text,\n\t\t\t SND_SG,RCV_SG: channel(dy))\n\t\t\t \nplayed_by Sj\n\ndef=\n  local TmpSIDj: nat,\n        T2,K2,A,B,SK,M3,M4,M5,SIDj   : text\n\n  const shared_key:protocol_id\n  init  State := 4\n\n  transition\n   1. State   = 4   /\\ RCV_SG(A'\n\t\t\t\t\t\t\t .H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t\t\t .T2'\n\t\t\t\t\t\t\t )=|> \n      State' := 5   /\\ K2' := new()\n\t\t\t\t\t/\\ B'  := Expp(P,K2')\n\t\t\t\t\t/\\ SK' := H(Expp(A',K2))\n\t\t\t\t\t/\\ M4' := H(B'.SK.A')\n\t\t\t\t\t/\\ M5' := H(Kxj.H(A'.SIDj'.Kxj.T2').M4'.B')\n\t\t\t\t\t/\\ SND_SG(B'.M4'.M5')\n\t\t\t\t\t\n\t\t\t\t\t/\\ witness(Sj,Ui,shared_key,SK')\n\t\t\t\t\t/\\ request(Sj,Ui,shared_key,SK')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole gateway (Ui, Sj, GW : agent,\n\t\t\t  Kdi,Kei,Kxj,Xgwn: symmetric_key,\n\t\t\t  H: hash_func,\n\t\t\t  Expp: hash_func,\n\t\t\t  SND_SG,RCV_SG,SND_UG,RCV_UG: channel(dy))\n\t\t\t \nplayed_by GW\n\ndef=\n\n  local TmpMsg: nat,\n        T1,T2,A,B,IDi,SIDj,M2,M3,M4,M6,M7,Ki,Keinew,K3 : text\n\n\n  const sc_user_id,sc_sensor_id:protocol_id\n  init  State := 2\n\n  transition\n\t\t\t\t   %/\\ SND_UG(A'.M1'.Ki.T1')\n   1.State   = 2    /\\ RCV_UG(A'.\n\t\t\t\t\t\t\t  xor(H(Ki'.Xgwn),(IDi'.SIDj'.H(A'.IDi'.SIDj'.Kdi.T1'))).\n\t\t\t\t\t\t\t  Ki'.\n\t\t\t\t\t\t\t  T1'\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n\t State' := 3\t/\\ T2' := new()\n\t\t\t\t\t/\\ M3' := H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t/\\ SND_SG(A'.M3'.T2')\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret(IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret(SIDj,sc_sensor_id,{Ui,GW})\n\t\t\t\t\t\n   2. State  = 3\t/\\ RCV_SG(B'\n\t\t\t\t\t\t\t .M4'\n\t\t\t\t\t\t\t .H(Kxj.M3.M4'.B')\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n      State' :=6    /\\ K3' := new()\n\t\t\t\t\t/\\ Keinew' := H(K3'.Xgwn)\n\t\t\t\t\t/\\ M7' := H(Kei.K3'.Kdi.T1.M4')\n\t\t\t\t\t/\\ M6' := xor((Keinew'.K3'.M7'),Kei)\n\t\t\t\t\t/\\ SND_UG(B'.M6')\n\t\t\t\t\t\n\t\t\t\t\t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(Ui, Sj, GW : agent,\n\t\t\t Kdi,Kei, Kxj,Xgwn: symmetric_key,\n\t\t\t Expp,H: hash_func,\n\t\t\t P: text\t\t\t \n\t\t\t )\ndef=\n\n\tlocal \tSND_UG,RCV_UG,RSG,\n\t\t\tSUG,SSG,RUG:channel(dy)\n\n  composition\n        user(Ui,Sj,GW,  Kdi,Kei,           Expp,H,P, SUG,RUG)\n  /\\  sensor(Ui,Sj,GW,  Kxj,               Expp,H,P, SSG,RSG)\n  /\\ gateway(Ui,Sj,GW,  Kdi,Kei,Kxj,Xgwn,  H,  Expp, SUG,RUG,SSG,RSG)\n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\n\ndef=\n\n  const ui, i, sj, gw : agent,\n        kdi,kei, kxj,xgwn, kig,keig: symmetric_key,\n        shared_key, sc_user_id ,\n\t\tsk_sensor_gwn, sc_sensor_id: protocol_id,\n\t\th,expp: hash_func,\n\t\tp: text\n\n  intruder_knowledge={ui, sj, gw, kig, h, p}\n\n  composition\n         session(ui,sj,gw,  kdi,kei,kxj,xgwn,  h,expp,p)\n      /\\ session(ui, i,gw,  kdi,kei,kig,xgwn,  h,expp,p)\n      /\\ session( i,sj,gw,  kig,keig,kxj,xgwn, h,expp,p)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n   secrecy_of sc_user_id, \n\t\t\t  sc_sensor_id\n\n % Message authentication (G2)\n   authentication_on shared_key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole user (Ui, Sj, GW : agent,\n           Kdi,Kei: symmetric_key,\n\t\t   Expp: hash_func,\n\t\t   H: hash_func,\n\t\t   P: text,\t   \n           SND_UG,RCV_UG: channel (dy))\n\t\t   \nplayed_by Ui\n\ndef=\n\n  local TmpIDi: nat,\n        T1,K1,A,M1,M2,Ki,B,K3,K2,IDi,SIDj,M4,M6,M7,SK,Keinew  : text\n\n  const shared_key,sc_user_id,sc_sensor_id:protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State   = 0   /\\ RCV_UG(start)=|> \n      State' := 1   /\\ T1' := new()\n\t\t\t\t\t/\\ K1' := new()\n\t\t\t\t\t/\\ A'  := Expp(P,K1')\n\t\t\t\t\t/\\ M2' := H(A'.IDi.SIDj.Kdi.T1')\n\t\t\t\t\t/\\ M1' := xor(Kei,(IDi.SIDj.M2'))\n\t\t\t\t\t/\\ SND_UG(A'.M1'.Ki.T1')\n\t\t\t\t\t\n\t\t\t\t\t\n\n   2. State   = 7   /\\ RCV_UG(   B'\n\t\t\t\t\t\t\t\t.xor((Keinew'.K3'.H(Kei.K3'.Kdi.T1.M4')),Kei)\n\t\t\t\t\t\t\t  ) =|>\n\t\t\t\t\t\t\t\t\n      State' := 8   /\\ Kei':= Keinew'\n\t\t\t\t\t/\\ Ki' := K3'\n\t\t\t\t\t/\\ SK' := H(Expp(B',K1))\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret(IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret(SIDj,sc_sensor_id,{Ui,GW})\n\t\t\t\t\t/\\ witness(Ui,Sj,shared_key,SK')\n\t\t\t\t\t/\\ request(Ui,Sj,shared_key,SK')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole sensor (Ui, Sj, GW : agent,\n             Kxj: symmetric_key,\n\t\t\t Expp: hash_func,\n\t\t\t H: hash_func,\n\t\t     P: text,\n\t\t\t SND_SG,RCV_SG: channel(dy))\n\t\t\t \nplayed_by Sj\n\ndef=\n  local TmpSIDj: nat,\n        T2,K2,A,B,SK,M3,M4,M5,SIDj   : text\n\n  const shared_key:protocol_id\n  init  State := 4\n\n  transition\n   1. State   = 4   /\\ RCV_SG(A'\n\t\t\t\t\t\t\t .H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t\t\t .T2'\n\t\t\t\t\t\t\t )=|> \n      State' := 5   /\\ K2' := new()\n\t\t\t\t\t/\\ B'  := Expp(P,K2')\n\t\t\t\t\t/\\ SK' := H(Expp(A',K2))\n\t\t\t\t\t/\\ M4' := H(B'.SK.A')\n\t\t\t\t\t/\\ M5' := H(Kxj.H(A'.SIDj'.Kxj.T2').M4'.B')\n\t\t\t\t\t/\\ SND_SG(B'.M4'.M5')\n\t\t\t\t\t\n\t\t\t\t\t/\\ witness(Sj,Ui,shared_key,SK')\n\t\t\t\t\t/\\ request(Sj,Ui,shared_key,SK')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole gateway (Ui, Sj, GW : agent,\n\t\t\t  Kdi,Kei,Kxj,Xgwn: symmetric_key,\n\t\t\t  H: hash_func,\n\t\t\t  Expp: hash_func,\n\t\t\t  SND_SG,RCV_SG,SND_UG,RCV_UG: channel(dy))\n\t\t\t \nplayed_by GW\n\ndef=\n\n  local TmpMsg: nat,\n        T1,T2,A,B,IDi,SIDj,M2,M3,M4,M6,M7,Ki,Keinew,K3 : text\n\n\n  const sc_user_id,sc_sensor_id:protocol_id\n  init  State := 2\n\n  transition\n\t\t\t\t   %/\\ SND_UG(A'.M1'.Ki.T1')\n   1.State   = 2    /\\ RCV_UG(A'.\n\t\t\t\t\t\t\t  xor(H(Ki'.Xgwn),(IDi'.SIDj'.H(A'.IDi'.SIDj'.Kdi.T1'))).\n\t\t\t\t\t\t\t  Ki'.\n\t\t\t\t\t\t\t  T1'\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n\t State' := 3\t/\\ T2' := new()\n\t\t\t\t\t/\\ M3' := H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t/\\ SND_SG(A'.M3'.T2')\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret(IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret(SIDj,sc_sensor_id,{Ui,GW})\n\t\t\t\t\t\n   2. State  = 3\t/\\ RCV_SG(B'\n\t\t\t\t\t\t\t .M4'\n\t\t\t\t\t\t\t .H(Kxj.M3.M4'.B')\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n      State' :=6    /\\ K3' := new()\n\t\t\t\t\t/\\ Keinew' := H(K3'.Xgwn)\n\t\t\t\t\t/\\ M7' := H(Kei.K3'.Kdi.T1.M4')\n\t\t\t\t\t/\\ M6' := xor((Keinew'.K3'.M7'),Kei)\n\t\t\t\t\t/\\ SND_UG(B'.M6')\n\t\t\t\t\t\n\t\t\t\t\t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(Ui, Sj, GW : agent,\n\t\t\t Kdi,Kei, Kxj,Xgwn: symmetric_key,\n\t\t\t Expp,H: hash_func,\n\t\t\t P: text\t\t\t \n\t\t\t )\ndef=\n\n\tlocal \tSND_UG,RCV_UG,RSG,\n\t\t\tSUG,SSG,RUG:channel(dy)\n\n  composition\n        user(Ui,Sj,GW,  Kdi,Kei,           Expp,H,P, SUG,RUG)\n  /\\  sensor(Ui,Sj,GW,  Kxj,               Expp,H,P, SSG,RSG)\n  /\\ gateway(Ui,Sj,GW,  Kdi,Kei,Kxj,Xgwn,  H,  Expp, SUG,RUG,SSG,RSG)\n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\n\ndef=\n\n  const ui, i, sj, gw : agent,\n        kdi,kei, kxj,xgwn, kig,keig: symmetric_key,\n        shared_key, sc_user_id ,\n\t\tsk_sensor_gwn, sc_sensor_id: protocol_id,\n\t\th,expp: hash_func,\n\t\tp: text\n\n  intruder_knowledge={ui, sj, gw, kig, h, p}\n\n  composition\n         session(ui,sj,gw,  kdi,kei,kxj,xgwn,  h,expp,p)\n      /\\ session(ui, i,gw,  kdi,kei,kig,xgwn,  h,expp,p)\n      /\\ session( i,sj,gw,  kig,keig,kxj,xgwn, h,expp,p)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n   secrecy_of sc_user_id, \n\t\t\t  sc_sensor_id\n\n % Message authentication (G2)\n   authentication_on shared_key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/woolamProtocolFixed.hlpsl": [[true, "% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n      Session : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ Session' := new() /\\ SNDA({Session'.A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({Session.B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n      Session : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ Session' := new() /\\ SNDB(X'.{Session'.A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{Session.A.Na.Nb.Kab'}_Kbs) =|>\n           State' :=3 /\\ SNDB(Y'.{Na.Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ request(B,A,kab_id,Nb)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, S, B : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n  def=\n  const i, a, b, s : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n      session(a,b,s,kas,kbs,kab)\n    /\\session(a,b,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on kab_id\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "```hlpsl\n% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n      Session : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ Session' := new() /\\ SNDA({Session'.A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({Session.B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n      Session : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ Session' := new() /\\ SNDB(X'.{Session'.A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{Session.A.Na.Nb.Kab'}_Kbs) =|>\n           State' :=3 /\\ SNDB(Y'.{Na.Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ request(B,A,kab_id,Nb)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, S, B : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n  def=\n  const i, a, b, s : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n      session(a,b,s,kas,kbs,kab)\n    /\\session(a,b,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on kab_id\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/XorNSPK_1.hlpsl": [[true, "%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     State  : nat, \n     Na    : message, \n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start) =|>\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ secret(Na',secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb'}_Kb)\n\nend role\n\n\n \nrole bob (B,A     : agent,  \n          Kb,Ka   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     State : nat, \n     Na    : message, \n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na'.A}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              SND, RCV: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,SND,RCV) /\\ \n    bob(B,A,Kb,Ka,SND,RCV)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na : protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     State  : nat, \n     Na    : message, \n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start) =|>\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ secret(Na',secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb'}_Kb)\n\nend role\n\n\n \nrole bob (B,A     : agent,  \n          Kb,Ka   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     State : nat, \n     Na    : message, \n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na'.A}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              SND, RCV: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,SND,RCV) /\\ \n    bob(B,A,Kb,Ka,SND,RCV)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na : protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/xvrabe07.hlpsl": [[true, "role_A(A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kab:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nat,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Na':=new() /\\ SND(H(A.B.Na'.Kas).A.B.Na')\n\t\t6. State=1 /\\ RCV(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab) =|> State':=2 /\\ secret(Kab,sec_1,{A,B})\nend role\n\nrole role_B(A:agent,B:agent,C:agent,H:hash_func,Kbs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Nb:text,Na:text,Kas:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nb':=new() /\\ SND(H(B.C.Nb'.H(A.B.Na'.Kas'.A.B.Na').Kbs).B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t5. State=1 /\\ RCV(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc) =|> State':=2 /\\ Kab' := new() /\\ Kbc' := new() /\\ secret(Kbc,sec_2,{B,C}) /\\ secret(Kab,sec_1,{A,B}) /\\ SND(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab)\nend role\n\nrole role_C(A:agent,B:agent,C:agent,H:hash_func,Kcs:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,S:agent,Nc:text,Nb:text,Kab:text,Kas:text,Kbs:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV(H(B.C.Nb'.H(A.B.Na'.Kas'.A.B.Na').Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nc':=new() /\\ S':=new() /\\ SND(H(C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kcs).C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t4. State=1 /\\ RCV(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc.C.B.xor(Kbc,H(Nc.Kcs)).{C.B.Nc}_Kbc) =|> State':=2 /\\ Kbc' := new() /\\ witness(C,B,kbc,{B,C}) /\\ secret(Kab,sec_1,{A,B}) /\\ SND(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc)\nend role\n\nrole role_S(S:agent,A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tState:nat,Nc:text,Nb:text,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV(H(C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kcs).C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na') =|> State':=1 /\\ Kbc' := new() /\\ secret(Kbc,sec_2,{B,C}) /\\ Kab' := new() /\\ witness(A,B,kab,{A,B}) /\\ SND(A.B.xor(Kab,H(Na'.Kas)).{A.B.Na'}_Kab.B.A.xor(Kab,H(Nb'.Kbs)).{B.A.Nb'}_Kab.B.C.xor(Kbc,H(Nb'.Kbs)).{B.C.Nb'}_Kbc.C.B.xor(Kbc,H(Nc'.Kcs)).{C.B.Nc'}_Kbc)\nend role\n\nrole session1(A:agent,B:agent,C:agent,S:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(S,A,B,C,H,Kas,Kbs,Kcs,Kab,Kbc,SND4,RCV4) /\\ role_C(A,B,C,H,Kcs,Kbc,SND3,RCV3) /\\ role_B(A,B,C,H,Kbs,Kab,Kbc,SND2,RCV2) /\\ role_A(A,B,C,H,Kas,Kab,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,key1:symmetric_key,alice:agent,bob:agent,carl:agent,server:agent,const_1:hash_func,key5:symmetric_key,key2:symmetric_key,key3:symmetric_key,key4:symmetric_key,sec_1:protocol_id,sec_2:protocol_id,kab:protocol_id,kbc:protocol_id\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(alice,bob,carl,server,const_1,key3,key4,key5,key1,key2)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()", "```hlpsl\nrole_A(A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kab:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nat,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Na':=new() /\\ SND(H(A.B.Na'.Kas).A.B.Na')\n\t\t6. State=1 /\\ RCV(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab) =|> State':=2 /\\ secret(Kab,sec_1,{A,B})\nend role\n\nrole role_B(A:agent,B:agent,C:agent,H:hash_func,Kbs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Nb:text,Na:text,Kas:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nb':=new() /\\ SND(H(B.C.Nb'.H(A.B.Na'.Kas'.A.B.Na').Kbs).B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t5. State=1 /\\ RCV(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc) =|> State':=2 /\\ Kab' := new() /\\ Kbc' := new() /\\ secret(Kbc,sec_2,{B,C}) /\\ secret(Kab,sec_1,{A,B}) /\\ SND(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab)\nend role\n\nrole role_C(A:agent,B:agent,C:agent,H:hash_func,Kcs:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,S:agent,Nc:text,Nb:text,Kab:text,Kas:text,Kbs:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV(H(B.C.Nb'.H(A.B.Na'.Kas'.A.B.Na').Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nc':=new() /\\ S':=new() /\\ SND(H(C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kcs).C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t4. State=1 /\\ RCV(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc.C.B.xor(Kbc,H(Nc.Kcs)).{C.B.Nc}_Kbc) =|> State':=2 /\\ Kbc' := new() /\\ witness(C,B,kbc,{B,C}) /\\ secret(Kab,sec_1,{A,B}) /\\ SND(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc)\nend role\n\nrole role_S(S:agent,A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tState:nat,Nc:text,Nb:text,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV(H(C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kcs).C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na') =|> State':=1 /\\ Kbc' := new() /\\ secret(Kbc,sec_2,{B,C}) /\\ Kab' := new() /\\ witness(A,B,kab,{A,B}) /\\ SND(A.B.xor(Kab,H(Na'.Kas)).{A.B.Na'}_Kab.B.A.xor(Kab,H(Nb'.Kbs)).{B.A.Nb'}_Kab.B.C.xor(Kbc,H(Nb'.Kbs)).{B.C.Nb'}_Kbc.C.B.xor(Kbc,H(Nc'.Kcs)).{C.B.Nc'}_Kbc)\nend role\n\nrole session1(A:agent,B:agent,C:agent,S:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(S,A,B,C,H,Kas,Kbs,Kcs,Kab,Kbc,SND4,RCV4) /\\ role_C(A,B,C,H,Kcs,Kbc,SND3,RCV3) /\\ role_B(A,B,C,H,Kbs,Kab,Kbc,SND2,RCV2) /\\ role_A(A,B,C,H,Kas,Kab,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,key1:symmetric_key,alice:agent,bob:agent,carl:agent,server:agent,const_1:hash_func,key5:symmetric_key,key2:symmetric_key,key3:symmetric_key,key4:symmetric_key,sec_1:protocol_id,sec_2:protocol_id,kab:protocol_id,kbc:protocol_id\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(alice,bob,carl,server,const_1,key3,key4,key5,key1,key2)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/Auth-protocol.hlpsl": [[true, "%%% Start of protocol\nrole edge(ED: agent, NAD: agent, SKus: symmetric_key, SND, RCV: channel(dy))  \nplayed_by ED\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n\t1. State = 0  /\\  RCV(start) =|> \n        State' := 1  /\\  M' := H(IDu.Bu) \n\t/\\ Aa' := new()\n\t/\\ TW' := H(xor(Aa,H(Bu.PWu)))\n%%%% Identity is Shared BETWEEN ED and NAD\n\t/\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n%%%%Send Registration Request to NAD\n\t/\\  SND({IDu.M'.TW'}_SKus)\n%%%% Receive Registration Reply to NAD\n\t2. State=1 /\\ RCV({PIDr'.Du.Yu.Fu.Zu}_SKus) =|>  \n%%%% Master key s is only known to NAD\n\tState' := 3 /\\  secret({Ss}, sp3, {NAD})\n%%%% Authentication and Key Exchange Phase (Public Channel)\n\t/\\ Fu' := H(IDu.TW)\n\t/\\ Cu' :=  new() \n%%%% Here we assume that H(IDu.Ss)= AB'\n\t/\\  AB' := xor(Du, H(IDu.TW))\n\t/\\ Buj'  := xor(xor(xor(Zu,H(IDj.Cu')),TW),H(PIDr'.H(IDu.Ss)))\n\t/\\ Xu' := xor(Yu, H(M.TW))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n%%% Send login request message M1 to NAD \n\t/\\ SND(PIDr'.DIDu'.Buj'.Cu')\n%%% U has freshly generated random number\n\t/\\ witness(ED, NAD, cu, Cu')\n%%% Receive Authentication message from NAD\n\t3. State=3 /\\ RCV(Quj. Tu. Dj\t) =|> \n\tState' := 5 /\\  Dj' := new() /\\ PIDr' := new() \n\t/\\ Quj' := H(H(IDu.Ss).Tu.Cu.Dj.Xu.IDj)\n\t/\\ SKuj' := H(H(IDu.Ss). Cu. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\n\t/\\ PIDrprime' := xor(Tu, H(PIDr'.H(IDu.Ss).Xu))\n%%%Send authentication Reply to NAD\n\t/\\ SND(Qujprime')\n%%% ED's acceptance of values b' and Dj for ED by NAD\n\t/\\ request(ED, NAD, bprime, Bbprime')\n\t/\\ request(ED, NAD, dj, Dj')\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n%%NAD ROLE\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole networkdevice (ED: agent, NAD: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by NAD\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Bb, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n%%%User Registration Phase\n \n\t1. State =  0 /\\ RCV({IDu.M.TW}_SKus) =|>\n%%%% Identity IDu is shared between ED and NAD\n\tState' := 2 /\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n\n%%%%% Computation\n\t/\\ Lu' := H(M.Ss)\n\t/\\ Bb' := new()\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\t\t\t\t\t\t\t\t\t\t\n\t/\\ Yu' := xor(Xu', H(M.TW))\n\t/\\ Zu' := xor(xor(Lu',H(Ss\t. Bb)),TW)\t\n\t/\\ Fu' := H(H(IDu.TW))\t\n\t/\\ PIDr' :={IDu.Ss.Bb}_SKus\n\t/\\ Du' := xor(H(IDu.Ss), H(IDu.TW))\n\t/\\ SND(PIDr'. Du'. Yu'.Fu'.Zu')\n%%%%%%%%%% Mutual Authentication\n%%% Receive login request Message M1 from ED\n\n\t2. State = 2 /\\ RCV(PIDr. DIDu. Buj.Cu') =|>\n%%%% We decrytp PIDr by using master key of CCS\n\tState' := 4 /\\   PIDr':= IDu.Ss.Bb\n\t/\\ Lu' := xor(xor(xor(Buj,H(H(IDj.Cu'))),H(PIDr.H(IDu.Ss))),H(Ss.Bb))\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n\t/\\ Bbprime' := new()\n\t/\\ Dj' := new()\n\t/\\ PIDrprime' := xor(H(IDu.Ss), H(Ss.Bbprime'))\n\t/\\ Tu' := xor(PIDrprime',H(PIDr'.H(IDu.Ss).Xu'))\n\t/\\ Quj' :=H(H(IDu.Ss).Tu'.Cu'.Dj'.Xu'.IDj)\n%%% Send request message M2 to ED publicly\n\t/\\ SND(Quj'.Tu'.Dj') \n%%% Freshly generated Random number b' and Dj\n\t/\\ witness(NAD, ED, bprime, Bbprime')\n\t/\\ witness(NAD, ED, dj, Dj')\n%%% Receive request message M3 to ED publicly\n\t3. State = 4 /\\ RCV(Qujprime') =|>\t\n%%% NAD acceptance of value Cu generated by ED for NAD\n\t  State' := 6  /\\ Cu' := new()\t  /\\ request(NAD, ED, cu, Cu')\n\t/\\ SKuj' := H(H(IDu.Ss). Cu'. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\nend role \n\nrole session (ED,NAD: agent, SKus: symmetric_key)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2: channel(dy)\n\tcomposition\n\t\tedge (ED, NAD, SKus, SND1, RCV1)\n\t\t/\\  networkdevice (ED, NAD, SKus, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst ed, i, nad: agent, skus: symmetric_key,\n        h: hash_func, sp1,sp2, sp3, a, b, bprime, dj, cu: protocol_id\n\tintruder_knowledge = {ed, nad, h}\n\tcomposition\n\t session(ed, nad, skus) \n\t/\\ session(i, nad, skus)\n\t/\\ session(ed, i, skus)\nend role\ngoal\n        secrecy_of sp1, sp2, sp3\n        authentication_on a,bprime\n        authentication_on b, dj,cu\nend goal\nenvironment()", "```hlpsl\n%%% Start of protocol\nrole edge(ED: agent, NAD: agent, SKus: symmetric_key, SND, RCV: channel(dy))  \nplayed_by ED\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n\t1. State = 0  /\\  RCV(start) =|> \n        State' := 1  /\\  M' := H(IDu.Bu) \n\t/\\ Aa' := new()\n\t/\\ TW' := H(xor(Aa,H(Bu.PWu)))\n%%%% Identity is Shared BETWEEN ED and NAD\n\t/\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n%%%%Send Registration Request to NAD\n\t/\\  SND({IDu.M'.TW'}_SKus)\n%%%% Receive Registration Reply to NAD\n\t2. State=1 /\\ RCV({PIDr'.Du.Yu.Fu.Zu}_SKus) =|>  \n%%%% Master key s is only known to NAD\n\tState' := 3 /\\  secret({Ss}, sp3, {NAD})\n%%%% Authentication and Key Exchange Phase (Public Channel)\n\t/\\ Fu' := H(IDu.TW)\n\t/\\ Cu' :=  new() \n%%%% Here we assume that H(IDu.Ss)= AB'\n\t/\\  AB' := xor(Du, H(IDu.TW))\n\t/\\ Buj'  := xor(xor(xor(Zu,H(IDj.Cu')),TW),H(PIDr'.H(IDu.Ss)))\n\t/\\ Xu' := xor(Yu, H(M.TW))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n%%% Send login request message M1 to NAD \n\t/\\ SND(PIDr'.DIDu'.Buj'.Cu')\n%%% U has freshly generated random number\n\t/\\ witness(ED, NAD, cu, Cu')\n%%% Receive Authentication message from NAD\n\t3. State=3 /\\ RCV(Quj. Tu. Dj\t) =|> \n\tState' := 5 /\\  Dj' := new() /\\ PIDr' := new() \n\t/\\ Quj' := H(H(IDu.Ss).Tu.Cu.Dj.Xu.IDj)\n\t/\\ SKuj' := H(H(IDu.Ss). Cu. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\n\t/\\ PIDrprime' := xor(Tu, H(PIDr'.H(IDu.Ss).Xu))\n%%%Send authentication Reply to NAD\n\t/\\ SND(Qujprime')\n%%% ED's acceptance of values b' and Dj for ED by NAD\n\t/\\ request(ED, NAD, bprime, Bbprime')\n\t/\\ request(ED, NAD, dj, Dj')\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n%%NAD ROLE\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole networkdevice (ED: agent, NAD: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by NAD\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Bb, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n%%%User Registration Phase\n \n\t1. State =  0 /\\ RCV({IDu.M.TW}_SKus) =|>\n%%%% Identity IDu is shared between ED and NAD\n\tState' := 2 /\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n\n%%%%% Computation\n\t/\\ Lu' := H(M.Ss)\n\t/\\ Bb' := new()\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\t\t\t\t\t\t\t\t\t\t\n\t/\\ Yu' := xor(Xu', H(M.TW))\n\t/\\ Zu' := xor(xor(Lu',H(Ss\t. Bb)),TW)\t\n\t/\\ Fu' := H(H(IDu.TW))\t\n\t/\\ PIDr' :={IDu.Ss.Bb}_SKus\n\t/\\ Du' := xor(H(IDu.Ss), H(IDu.TW))\n\t/\\ SND(PIDr'. Du'. Yu'.Fu'.Zu')\n%%%%%%%%%% Mutual Authentication\n%%% Receive login request Message M1 from ED\n\n\t2. State = 2 /\\ RCV(PIDr. DIDu. Buj.Cu') =|>\n%%%% We decrytp PIDr by using master key of CCS\n\tState' := 4 /\\   PIDr':= IDu.Ss.Bb\n\t/\\ Lu' := xor(xor(xor(Buj,H(H(IDj.Cu'))),H(PIDr.H(IDu.Ss))),H(Ss.Bb))\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n\t/\\ Bbprime' := new()\n\t/\\ Dj' := new()\n\t/\\ PIDrprime' := xor(H(IDu.Ss), H(Ss.Bbprime'))\n\t/\\ Tu' := xor(PIDrprime',H(PIDr'.H(IDu.Ss).Xu'))\n\t/\\ Quj' :=H(H(IDu.Ss).Tu'.Cu'.Dj'.Xu'.IDj)\n%%% Send request message M2 to ED publicly\n\t/\\ SND(Quj'.Tu'.Dj') \n%%% Freshly generated Random number b' and Dj\n\t/\\ witness(NAD, ED, bprime, Bbprime')\n\t/\\ witness(NAD, ED, dj, Dj')\n%%% Receive request message M3 to ED publicly\n\t3. State = 4 /\\ RCV(Qujprime') =|>\t\n%%% NAD acceptance of value Cu generated by ED for NAD\n\t  State' := 6  /\\ Cu' := new()\t  /\\ request(NAD, ED, cu, Cu')\n\t/\\ SKuj' := H(H(IDu.Ss). Cu'. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\nend role \n\nrole session (ED,NAD: agent, SKus: symmetric_key)\ndef=\n\tlocal\n\t\tSND1,RCV1,SND2,RCV2: channel(dy)\n\tcomposition\n\t\tedge (ED, NAD, SKus, SND1, RCV1)\n\t\t/\\  networkdevice (ED, NAD, SKus, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst ed, i, nad: agent, skus: symmetric_key,\n        h: hash_func, sp1,sp2, sp3, a, b, bprime, dj, cu: protocol_id\n\tintruder_knowledge = {ed, nad, h}\n\tcomposition\n\t session(ed, nad, skus) \n\t/\\ session(i, nad, skus)\n\t/\\ session(ed, i, skus)\nend role\ngoal\n        secrecy_of sp1, sp2, sp3\n        authentication_on a,bprime\n        authentication_on b, dj,cu\nend goal\nenvironment()\n```"]], "HLPSL-1/addNewSession.hlpsl": [[true, "%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start())\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n                    /\\ event(accepts(A,B,bob_alice_NA,Na'))\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na')\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) /\\\n    fixednspkxor(b,i,kb,ki,Snd,Rcv)\n  \nend role\n\n\ngoal \n     weak_authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start())\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n                    /\\ event(accepts(A,B,bob_alice_NA,Na'))\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na')\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) /\\\n    fixednspkxor(b,i,kb,ki,Snd,Rcv)\n  \nend role\n\n\ngoal \n     weak_authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/Basic1.hlpsl": [[true, "role admin(ROLE_0) role hnode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by SA\ndef=\n        local State:nat,AN,BN:text\n        const secIDN,secKN,secKHN,sn_hn_beta,hn_sn_tidn:protocol_id\n        init State:=0\n        transition\n        1.State=0 /\\ RCV(start) =|> State':=1\n          /\\AN':=xor(IDN,H(KHN.KN))\n          /\\BN':=xor(xor(KHN,KN),AN')\n          /\\SND({IDN.AN'.BN'}_SK)\nend role\n\nrole snode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by SN\ndef=\n       local State:nat,RN,TN,XN,YN,TIDN,ALPHA,BETA,ETA,MU,FN,GAMMA,AN,BN,BNnew,ANnew,KHN,KS:text\n       const secKHN,sn_hn_beta,secKN,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV({IDN'.AN'.BN'}_SK) =|> State':=1\n         /\\RN':=new() /\\ TN':=new()\n         /\\XN':= xor(AN',IDN')\n         /\\YN':=xor(XN',RN')\n         /\\TIDN':=H(xor(IDN',TN').RN')\n         /\\witness(SN,HN,hn_sn_tidn,TIDN')\n         /\\SND(TIDN'.YN'.AN'.BN'.TN')\n\n       2.State=1 /\\ RCV(ALPHA'.BETA'.ETA'.MU') =|> State':=2\n         /\\FN':=xor(XN,ALPHA')\n         /\\BETA'=H(XN.RN.FN'.ETA'.MU') /\\ request(SN,HN,sn_hn_beta,BETA')\n         /\\GAMMA':=xor(RN,FN') /\\ ANnew':=xor(GAMMA',ETA')\n         /\\BNnew':=xor(GAMMA',MU') /\\ KS':=H(IDN.RN.FN'.XN)\n         /\\AN':=ANnew' /\\ BN':=BNnew' /\\ secret(KN,secKN,{SA,SN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole hnode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by HN\ndef=\n       local State:nat,TIDN,AN,BN,RN,XN,FN,TKN,ALPHA,BETA,GAMMA,ETA,MU,KS:text\n       const sn_hn_beta,secKN,secKHN,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV(TIDN'.YN'.AN'.BN'.TN') =|> State':=1\n         /\\KN':=xor(xor(KHN,BN),AN)\n         /\\XN':=H(KHN.KN')\n         /\\IDN':=xor(AN',XN') /\\ RN':=xor(YN',XN')\n         /\\TIDN':=H(xor(IDN',TN').RN') /\\ request(HN,SN,hn_sn_tidn,TIDN')\n         /\\FN':=new() /\\ ALPHA':=xor(XN',FN') /\\ GAMMA':=xor(RN',FN')\n         /\\TKN':=new() /\\ AN':=xor(IDN',H(KHN.TKN))\n         /\\BN':=xor(xor(KHN,TKN),AN') /\\ ETA':=xor(GAMMA',AN')\n         /\\MU':=xor(GAMMA',BN') /\\ BETA':=H(XN'.RN'.FN'.ETA'.MU')\n         /\\witness(HN,SN,sn_hn_beta,BETA') /\\ KS':=H(IDN'.RN'.FN'.XN')\n         /\\SND(ALPHA'.BETA'.ETA'.MU') /\\ secret(KN,secKN,{SA,SN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole session(SA,SN,HN:agent,SK:symmetric_key,KHN,KN,IDN:text,H:hash_func)\ndef=\n       local SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n       composition\n           admin(SA,SN,HN,SK,SND3,RCV3,KHN,KN,IDN,H) /\\ hnode(SA,SN,HN,SK,SND2,RCV2,H,KHN,KN,IDN) /\\ snode(SA,SN,HN,SK,SND1,RCV1,H,KHN,KN,IDN)\nend role\n\nrole environment()\ndef=\n      const sa,sn,hn:agent,\n            khn,kn,idn:text,\n            sk:symmetric_key,\n            h:hash_func,\n            seckn,seckhn,secidn,sn_hn_beta,hn_sn_tidn:protocol_id\n      intruder_knowledge={sa,sn,hn}\n      composition\n            session(sa,sn,hn,sk,khn,kn,idn,h)\nend role\ngoal\n     secrecy_of secKHN\n     secrecy_of secKN\n     secrecy_of secIDN\n     authentication_on hn_sn_tidn\n     authentication_on sn_hn_beta\nend goal\nenvironment()", "```hlpsl\nrole admin(ROLE_0) role hnode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by SA\ndef=\n        local State:nat,AN,BN:text\n        const secIDN,secKN,secKHN,sn_hn_beta,hn_sn_tidn:protocol_id\n        init State:=0\n        transition\n        1.State=0 /\\ RCV(start) =|> State':=1\n          /\\AN':=xor(IDN,H(KHN.KN))\n          /\\BN':=xor(xor(KHN,KN),AN')\n          /\\SND({IDN.AN'.BN'}_SK)\nend role\n\nrole snode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by SN\ndef=\n       local State:nat,RN,TN,XN,YN,TIDN,ALPHA,BETA,ETA,MU,FN,GAMMA,AN,BN,BNnew,ANnew,KHN,KS:text\n       const secKHN,sn_hn_beta,secKN,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV({IDN'.AN'.BN'}_SK) =|> State':=1\n         /\\RN':=new() /\\ TN':=new()\n         /\\XN':= xor(AN',IDN')\n         /\\YN':=xor(XN',RN')\n         /\\TIDN':=H(xor(IDN',TN').RN')\n         /\\witness(SN,HN,hn_sn_tidn,TIDN')\n         /\\SND(TIDN'.YN'.AN'.BN'.TN')\n\n       2.State=1 /\\ RCV(ALPHA'.BETA'.ETA'.MU') =|> State':=2\n         /\\FN':=xor(XN,ALPHA')\n         /\\BETA'=H(XN.RN.FN'.ETA'.MU') /\\ request(SN,HN,sn_hn_beta,BETA')\n         /\\GAMMA':=xor(RN,FN') /\\ ANnew':=xor(GAMMA',ETA')\n         /\\BNnew':=xor(GAMMA',MU') /\\ KS':=H(IDN.RN.FN'.XN)\n         /\\AN':=ANnew' /\\ BN':=BNnew' /\\ secret(KN,secKN,{SA,SN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole hnode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by HN\ndef=\n       local State:nat,TIDN,AN,BN,RN,XN,FN,TKN,ALPHA,BETA,GAMMA,ETA,MU,KS:text\n       const sn_hn_beta,secKN,secKHN,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV(TIDN'.YN'.AN'.BN'.TN') =|> State':=1\n         /\\KN':=xor(xor(KHN,BN),AN)\n         /\\XN':=H(KHN.KN')\n         /\\IDN':=xor(AN',XN') /\\ RN':=xor(YN',XN')\n         /\\TIDN':=H(xor(IDN',TN').RN') /\\ request(HN,SN,hn_sn_tidn,TIDN')\n         /\\FN':=new() /\\ ALPHA':=xor(XN',FN') /\\ GAMMA':=xor(RN',FN')\n         /\\TKN':=new() /\\ AN':=xor(IDN',H(KHN.TKN))\n         /\\BN':=xor(xor(KHN,TKN),AN') /\\ ETA':=xor(GAMMA',AN')\n         /\\MU':=xor(GAMMA',BN') /\\ BETA':=H(XN'.RN'.FN'.ETA'.MU')\n         /\\witness(HN,SN,sn_hn_beta,BETA') /\\ KS':=H(IDN'.RN'.FN'.XN')\n         /\\SND(ALPHA'.BETA'.ETA'.MU') /\\ secret(KN,secKN,{SA,SN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole session(SA,SN,HN:agent,SK:symmetric_key,KHN,KN,IDN:text,H:hash_func)\ndef=\n       local SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n       composition\n           admin(SA,SN,HN,SK,SND3,RCV3,KHN,KN,IDN,H) /\\ hnode(SA,SN,HN,SK,SND2,RCV2,H,KHN,KN,IDN) /\\ snode(SA,SN,HN,SK,SND1,RCV1,H,KHN,KN,IDN)\nend role\n\nrole environment()\ndef=\n      const sa,sn,hn:agent,\n            khn,kn,idn:text,\n            sk:symmetric_key,\n            h:hash_func,\n            seckn,seckhn,secidn,sn_hn_beta,hn_sn_tidn:protocol_id\n      intruder_knowledge={sa,sn,hn}\n      composition\n            session(sa,sn,hn,sk,khn,kn,idn,h)\nend role\ngoal\n     secrecy_of secKHN\n     secrecy_of secKN\n     secrecy_of secIDN\n     authentication_on hn_sn_tidn\n     authentication_on sn_hn_beta\nend goal\nenvironment()\n```"]], "HLPSL-1/calp-v1.hlpsl": [[true, "%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), une badgeuse (B)\n%% Deux cas de figures :  - une demande d'acces normale (1)\n%%\t\t\t  - une demande d'acces exceptionnelle (2)\n%%B -> S : {IdBageuse, IdEmploye}_PKs\n%%S -> B : { Ok }_PKb\n%%B -> S : { Ok }_PKs\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse : protocol_id,             \n            PKs, PKb: public_key,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat \n\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ witness(B,S,idemploye,IdEmploye)\n    2.  State=1 /\\ RCV({ok}_PKb) =|> \n\tState':=2 /\\ SND({ok}_PKs) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse : protocol_id,\n\t    PKs,PKb: public_key,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat\n\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye'.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ SND({ok}_PKb) /\\ request(S,B,idemploye,IdEmploye')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse : protocol_id) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant le scenario executer\nrole environment() def=\n\n    const b,s,i : agent,\n\t  pks, pkb, pki: public_key,\n          idemploye, idbadgeuse: protocol_id,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki)}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse)\n%%\tsession(i,s, pki,pks,idemploye, idbadgeuse)\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propriate verifier)\ngoal\n\tsecrecy_of idemploye\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du role principal\nenvironment()", "```hlpsl\n%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), une badgeuse (B)\n%% Deux cas de figures :  - une demande d'acces normale (1)\n%%\t\t\t  - une demande d'acces exceptionnelle (2)\n%%B -> S : {IdBageuse, IdEmploye}_PKs\n%%S -> B : { Ok }_PKb\n%%B -> S : { Ok }_PKs\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse : protocol_id,             \n            PKs, PKb: public_key,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat \n\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ witness(B,S,idemploye,IdEmploye)\n    2.  State=1 /\\ RCV({ok}_PKb) =|> \n\tState':=2 /\\ SND({ok}_PKs) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse : protocol_id,\n\t    PKs,PKb: public_key,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat\n\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye'.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ SND({ok}_PKb) /\\ request(S,B,idemploye,IdEmploye')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse : protocol_id) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant le scenario executer\nrole environment() def=\n\n    const b,s,i : agent,\n\t  pks, pkb, pki: public_key,\n          idemploye, idbadgeuse: protocol_id,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki)}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse)\n%%\tsession(i,s, pki,pks,idemploye, idbadgeuse)\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propriate verifier)\ngoal\n\tsecrecy_of idemploye\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du role principal\nenvironment()\n```"]], "HLPSL-1/DH.hlpsl": [[true, "role_A(A:agent,B:agent,G:text,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tY:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ X':=new() /\\ SND(exp(G,X'))\n\t\t2. State=1 /\\ RCV({N'}_exp(exp(G,X'),Y')) =|> State':=2 /\\ N':=new() /\\ secret(N',sec_1,{A}) /\\ SND({N'}_exp(exp(G,X'),Y'))\nend role\n\nrole role_B(A:agent,B:agent,G:text,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tY:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(exp(G,X')) =|> State':=1 /\\ Y':=new() /\\ SND(exp(G,Y'))\n\t\t3. State=1 /\\ RCV({N'}_exp(exp(G,X'),Y')) =|> State':=2 /\\ secret(N',sec_1,{B})\nend role\n\nrole session1(A:agent,B:agent,G:text)\ndef=\n\tlocal\n\t\tSND1,RCV2,SND2,RCV1:channel(dy)\n\tcomposition\n\t\trole_A(A,B,G,SND1,RCV1) /\\ role_B(A,B,G,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tf:text,b:agent,a:agent,sec_1:protocol_id,sec_2:protocol_id\n\tintruder_knowledge = {a,b,f}\n\tcomposition\n\t\tsession1(a,b,f)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tweak_secrecy_of sec_2\nend goal\n\nenvironment()", "```hlpsl\nrole_A(A:agent,B:agent,G:text,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tY:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ X':=new() /\\ SND(exp(G,X'))\n\t\t2. State=1 /\\ RCV({N'}_exp(exp(G,X'),Y')) =|> State':=2 /\\ N':=new() /\\ secret(N',sec_1,{A}) /\\ SND({N'}_exp(exp(G,X'),Y'))\nend role\n\nrole role_B(A:agent,B:agent,G:text,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tY:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(exp(G,X')) =|> State':=1 /\\ Y':=new() /\\ SND(exp(G,Y'))\n\t\t3. State=1 /\\ RCV({N'}_exp(exp(G,X'),Y')) =|> State':=2 /\\ secret(N',sec_1,{B})\nend role\n\nrole session1(A:agent,B:agent,G:text)\ndef=\n\tlocal\n\t\tSND1,RCV2,SND2,RCV1:channel(dy)\n\tcomposition\n\t\trole_A(A,B,G,SND1,RCV1) /\\ role_B(A,B,G,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tf:text,b:agent,a:agent,sec_1:protocol_id,sec_2:protocol_id\n\tintruder_knowledge = {a,b,f}\n\tcomposition\n\t\tsession1(a,b,f)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tweak_secrecy_of sec_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/DH_with_Forward_Secrecy_(Vulnerable).hlpsl": [[true, "role_A(A:agent,\n\t    B:agent,\n\t    S:agent,\n\t    G:hash_func,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab: symmetric_key,\n\t    Kas: symmetric_key,\n\t    SND:channel(dy),\n\t    RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>\n\t\t   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Nb), Na), Kab)\n\t\t   /\\ witness(A, B, secretAB, {A, B})\n\t\t   /\\ SND(A.B)\n\t\t   /\\ SND(A.exp(G, Na))\nend role\n\nrole role_B(B:agent,\n\t    A:agent,\n\t    S:agent,\n\t    G:hash_func,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab:symmetric_key,\n\t    Kbs:symmetric_key,\n\t    SND:channel(dy),\n\t    RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>                   \n                   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Na), Nb), Kab)\n\t\t   /\\ secret(K', secretAB, {A, B})\n\t\t   /\\ RCV(A'.exp(G, Na'))\n\t\t   /\\ SND(B.exp(G, Nb))\n\nend role\n\nrole session(A:agent, B:agent, S:agent, G:hash_func, Kas:symmetric_key, Kbs:symmetric_key)\ndef=\n\tlocal\n\t\tSND1:channel(dy),\n\t\tRCV1:channel(dy),\t\t\n\t\tSND2:channel(dy),\n\t\tRCV2:channel(dy),\n\t\tNa:nat,\n\t\tNb:nat,\n\t\tKab:symmetric_key\n\tcomposition\n                role_A(A, B, S, G, Na, Nb, Kab, Kas, SND1, RCV1)\n\t\t/\\ role_B(B, A, S, G, Na, Nb, Kab, Kbs, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n                a:agent,\n\t\tb:agent,\n\t\ts:agent,\n\t\tg:hash_func,\n\t\tkas:symmetric_key,\n\t\tkbs:symmetric_key,\n\t\tsecretAB:protocol_id\n\tintruder_knowledge = {a, b, g}\n\tcomposition\n\t\tsession(a, b, s, g, kas, kbs)\nend role\n\ngoal\n\n\tsecrecy_of secretAB\n\nend goal\n\nenvironment()", "```hlpsl\nrole_A(A:agent,\n\t    B:agent,\n\t    S:agent,\n\t    G:hash_func,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab: symmetric_key,\n\t    Kas: symmetric_key,\n\t    SND:channel(dy),\n\t    RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>\n\t\t   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Nb), Na), Kab)\n\t\t   /\\ witness(A, B, secretAB, {A, B})\n\t\t   /\\ SND(A.B)\n\t\t   /\\ SND(A.exp(G, Na))\nend role\n\nrole role_B(B:agent,\n\t    A:agent,\n\t    S:agent,\n\t    G:hash_func,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab:symmetric_key,\n\t    Kbs:symmetric_key,\n\t    SND:channel(dy),\n\t    RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>                   \n                   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Na), Nb), Kab)\n\t\t   /\\ secret(K', secretAB, {A, B})\n\t\t   /\\ RCV(A'.exp(G, Na'))\n\t\t   /\\ SND(B.exp(G, Nb))\n\nend role\n\nrole session(A:agent, B:agent, S:agent, G:hash_func, Kas:symmetric_key, Kbs:symmetric_key)\ndef=\n\tlocal\n\t\tSND1:channel(dy),\n\t\tRCV1:channel(dy),\t\t\n\t\tSND2:channel(dy),\n\t\tRCV2:channel(dy),\n\t\tNa:nat,\n\t\tNb:nat,\n\t\tKab:symmetric_key\n\tcomposition\n                role_A(A, B, S, G, Na, Nb, Kab, Kas, SND1, RCV1)\n\t\t/\\ role_B(B, A, S, G, Na, Nb, Kab, Kbs, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n                a:agent,\n\t\tb:agent,\n\t\ts:agent,\n\t\tg:hash_func,\n\t\tkas:symmetric_key,\n\t\tkbs:symmetric_key,\n\t\tsecretAB:protocol_id\n\tintruder_knowledge = {a, b, g}\n\tcomposition\n\t\tsession(a, b, s, g, kas, kbs)\nend role\n\ngoal\n\n\tsecrecy_of secretAB\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/EKE.hlpsl": [[true, "%% PROTOCOL: EKE: Encrypted Key Exchange\n%% VARIANT: basic\n%% PURPOSE: Encrypted key exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellovin92encrypted.html}\n%% MODELER:\n%% \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : {Ea}_Kab        |    Key exchange part\n%% B -> A : {{K}_Ea}_Kab    |\n%% A -> B : {Ca}_K          |\n%% B -> A : {Ca,Cb}_K       |    Challenge/Response\n%% A -> B : {Cb}_K          |    Authentication part\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: \n%% \\begin{verbatim}\n%% i -> (a,3): start\n%% (a,3) -> i: {Ea(1)}_kab\n%% i -> (a,6): {Ea(1)}_kab\n%% (a,6) -> i: {{K(2)}_Ea(1)}_kab \n%% i -> (a,3): {{K(2)}_Ea(1)}_kab\n%% (a,3) -> i: {Na(3)}_K(2) witness(a,b,na,Na(3))\n%% i -> (a,6): {Na(3)}_K(2)\n%% (a,6) -> i: {Na(3),Nb(4)}_K(2) witness(a,b,nb,Nb(4))\n%% i -> (a,3): {Na(3),Nb(4)}_K(2)\n%% (a,3) -> i: {Nb(4)}_K(2)  request(a,b,nb,Nb(4))\n%% \\end{verbatim}\n%%\n%% Parallel session attack, man-in-the-middle\n%% between A as initiator and A as responder, attacker\n%% masquerades as B, but no secret nonces are exposed.\n%%\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke_Init (A,B: agent,\n               Kab: symmetric_key,\n               Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State   : nat,\n        Ea      : public_key,\n        Na,Nb,K : text\n\n  const na, nb, sec_k1, sec_k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Ea' := new()\n      /\\ Snd({Ea'}_Kab) \n\n   2. State = 1\n      /\\ Rcv({{K'}_Ea}_Kab)\n      =|> \n      State' := 2\n      /\\ Na' := new()\n      /\\ Snd({Na'}_K') \n      /\\ secret(K',sec_k1,{A,B})\n      /\\ witness(A,B,na,Na')\n\n   3. State = 2\n      /\\ Rcv({Na'.Nb'}_K) \n      =|> \n      State' := 3\n      /\\ Snd({Nb'}_K) \n      /\\ request(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke_Resp (B,A: agent,\n               Kab: symmetric_key,\n \t       Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        Na,Nb,K : text,\n\tEa      : public_key\n\n  const na, nb, sec_k1, sec_k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0 /\\ Rcv({Ea'}_Kab)\n      =|> \n      State' := 1\n      /\\ K' := new()\n      /\\ Snd({{K'}_Ea'}_Kab) \n      /\\ secret(K',sec_k2,{A,B})\n\n   2. State = 1 /\\ Rcv({Na'}_K)\n      =|> \n      State' := 2\n      /\\ Nb' := new()\n      /\\ Snd({Na'.Nb'}_K)\n      /\\ witness(B,A,nb,Nb')\n\n   3. State = 2\n      /\\ Rcv({Nb}_K)\n      =|> \n      State' := 3\n      /\\ request(B,A,na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Kab: symmetric_key)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n     eke_Init(A,B,Kab,SA,RA)\n  /\\ eke_Resp(B,A,Kab,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\ndef=\n\n  const a, b   : agent,\n        kab    : symmetric_key,\n        na, nb : protocol_id,\n        sec_k1, sec_k2 : protocol_id\n\n  intruder_knowledge={a,b}\n\n  composition\n      session(a,b,kab)\n   /\\ session(b,a,kab)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n secrecy_of sec_k1, sec_k2\n\n % Message authentication (G2)\n % EKE_Init authenticates EKE_Resp on nb\n authentication_on nb\n\n % Message authentication (G2)\n % EKE_Resp authenticates EKE_Init on na\n authentication_on na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: EKE: Encrypted Key Exchange\n%% VARIANT: basic\n%% PURPOSE: Encrypted key exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellovin92encrypted.html}\n%% MODELER:\n%% \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : {Ea}_Kab        |    Key exchange part\n%% B -> A : {{K}_Ea}_Kab    |\n%% A -> B : {Ca}_K          |\n%% B -> A : {Ca,Cb}_K       |    Challenge/Response\n%% A -> B : {Cb}_K          |    Authentication part\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: \n%% \\begin{verbatim}\n%% i -> (a,3): start\n%% (a,3) -> i: {Ea(1)}_kab\n%% i -> (a,6): {Ea(1)}_kab\n%% (a,6) -> i: {{K(2)}_Ea(1)}_kab \n%% i -> (a,3): {{K(2)}_Ea(1)}_kab\n%% (a,3) -> i: {Na(3)}_K(2) witness(a,b,na,Na(3))\n%% i -> (a,6): {Na(3)}_K(2)\n%% (a,6) -> i: {Na(3),Nb(4)}_K(2) witness(a,b,nb,Nb(4))\n%% i -> (a,3): {Na(3),Nb(4)}_K(2)\n%% (a,3) -> i: {Nb(4)}_K(2)  request(a,b,nb,Nb(4))\n%% \\end{verbatim}\n%%\n%% Parallel session attack, man-in-the-middle\n%% between A as initiator and A as responder, attacker\n%% masquerades as B, but no secret nonces are exposed.\n%%\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke_Init (A,B: agent,\n               Kab: symmetric_key,\n               Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State   : nat,\n        Ea      : public_key,\n        Na,Nb,K : text\n\n  const na, nb, sec_k1, sec_k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Ea' := new()\n      /\\ Snd({Ea'}_Kab) \n\n   2. State = 1\n      /\\ Rcv({{K'}_Ea}_Kab)\n      =|> \n      State' := 2\n      /\\ Na' := new()\n      /\\ Snd({Na'}_K') \n      /\\ secret(K',sec_k1,{A,B})\n      /\\ witness(A,B,na,Na')\n\n   3. State = 2\n      /\\ Rcv({Na'.Nb'}_K) \n      =|> \n      State' := 3\n      /\\ Snd({Nb'}_K) \n      /\\ request(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke_Resp (B,A: agent,\n               Kab: symmetric_key,\n \t       Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        Na,Nb,K : text,\n\tEa      : public_key\n\n  const na, nb, sec_k1, sec_k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0 /\\ Rcv({Ea'}_Kab)\n      =|> \n      State' := 1\n      /\\ K' := new()\n      /\\ Snd({{K'}_Ea'}_Kab) \n      /\\ secret(K',sec_k2,{A,B})\n\n   2. State = 1 /\\ Rcv({Na'}_K)\n      =|> \n      State' := 2\n      /\\ Nb' := new()\n      /\\ Snd({Na'.Nb'}_K)\n      /\\ witness(B,A,nb,Nb')\n\n   3. State = 2\n      /\\ Rcv({Nb}_K)\n      =|> \n      State' := 3\n      /\\ request(B,A,na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Kab: symmetric_key)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n     eke_Init(A,B,Kab,SA,RA)\n  /\\ eke_Resp(B,A,Kab,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\ndef=\n\n  const a, b   : agent,\n        kab    : symmetric_key,\n        na, nb : protocol_id,\n        sec_k1, sec_k2 : protocol_id\n\n  intruder_knowledge={a,b}\n\n  composition\n      session(a,b,kab)\n   /\\ session(b,a,kab)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n secrecy_of sec_k1, sec_k2\n\n % Message authentication (G2)\n % EKE_Init authenticates EKE_Resp on nb\n authentication_on nb\n\n % Message authentication (G2)\n % EKE_Resp authenticates EKE_Init on na\n authentication_on na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/Ex3_A.hlpsl": [[true, "role share_Init (A, B     : agent,\n                 Ka, Kb   : public_key,\n                 Snd, Rcv : channel(dy)) played_by A def=\n\n  local  State   : nat,\n         Na, Msg : text,\n         Nb      : text,\n         K       : message % text.text\n\n  init   State := 0\n  accept State = 3\n\n  transition\n\n   1. State  = 0 /\\ RCV(start) =|> \n      State':= 1 /\\ Na':= new()\n                 /\\ Snd(A.{Na'}_Kb)\n\n   2. State  = 1 /\\ Rcv(B.{Na'.Nb'}_Ka) =|> \n      State':= 2 /\\ K':= Na'.Nb'\n                 /\\ secret(Na'.Nb',nanb,{A,B})\n\t\t /\\ Msg':= new()\n                 /\\ Snd({zero.Msg'}_K) \n\n\n\n   3. State  = 2 /\\ Rcv({one.Msg}_K) =|> \n      State':= 3 \n\n\nend role\n\n\n\nrole share_Resp (B, A     : agent,\n                 Kb, Ka   : public_key,\n                 Snd, Rcv : channel (dy)) played_by B def=\n\n  local State   : nat,\n        Nb      : text,\n        Msg, Na : text,\n        K       : message % text.text\n\n  init   State := 0\n  accept State = 2 \n\n  transition\n\n   1. State  = 0 /\\ Rcv(A.{Na'}_Kb) =|> \n      State':= 1 /\\ Nb':= new()\n                 /\\ Snd(B.{Na'.Nb'}_Ka)\n                 /\\ K':= Na'.Nb'\n                 /\\ witness(A,B,nanb,Na'.Nb')\n\n   2. State  = 1 /\\ Rcv({zero.Msg'}_K) =|> \n      State':= 2 /\\ Snd({one.Msg'}_K)\n                 \n\n\n\nend role\n\n\n\nrole session(A, B           : agent,\n             Ka, Kb         : public_key) def=\n\n  local  SA, RA, SB, RB : channel (dy)\n\n  composition\n    share_Init(A,B,Ka,Kb,SA,RA) /\\\n    share_Resp(B,A,Kb,Ka,SB,RB)\n\nend role\n\n\n\nrole environment() def=\n \n const zero, one    : text,\n       a, b, i      : agent,\n       ka, kb, ki   : public_key,\n       k1, k2, msg, nanb : protocol_id\n\n intruder_knowledge = {a,b,ka,kb,ki,i,inv(ki),zero,one}\n\n composition\n\n        session(a,b,ka,kb) \n    /\\  session(a,i,ka,ki) \n    /\\  session(i,b,ki,kb)\n    /\\  session(i,a,ki,ka) \nend role\n\n\n\ngoal\n\n\n    secrecy_of nanb\n\n\n\nend goal\n\n\n\nenvironment()", "```hlpsl\nrole share_Init (A, B     : agent,\n                 Ka, Kb   : public_key,\n                 Snd, Rcv : channel(dy)) played_by A def=\n\n  local  State   : nat,\n         Na, Msg : text,\n         Nb      : text,\n         K       : message % text.text\n\n  init   State := 0\n  accept State = 3\n\n  transition\n\n   1. State  = 0 /\\ RCV(start) =|> \n      State':= 1 /\\ Na':= new()\n                 /\\ Snd(A.{Na'}_Kb)\n\n   2. State  = 1 /\\ Rcv(B.{Na'.Nb'}_Ka) =|> \n      State':= 2 /\\ K':= Na'.Nb'\n                 /\\ secret(Na'.Nb',nanb,{A,B})\n\t\t /\\ Msg':= new()\n                 /\\ Snd({zero.Msg'}_K) \n\n\n\n   3. State  = 2 /\\ Rcv({one.Msg}_K) =|> \n      State':= 3 \n\n\nend role\n\n\n\nrole share_Resp (B, A     : agent,\n                 Kb, Ka   : public_key,\n                 Snd, Rcv : channel (dy)) played_by B def=\n\n  local State   : nat,\n        Nb      : text,\n        Msg, Na : text,\n        K       : message % text.text\n\n  init   State := 0\n  accept State = 2 \n\n  transition\n\n   1. State  = 0 /\\ Rcv(A.{Na'}_Kb) =|> \n      State':= 1 /\\ Nb':= new()\n                 /\\ Snd(B.{Na'.Nb'}_Ka)\n                 /\\ K':= Na'.Nb'\n                 /\\ witness(A,B,nanb,Na'.Nb')\n\n   2. State  = 1 /\\ Rcv({zero.Msg'}_K) =|> \n      State':= 2 /\\ Snd({one.Msg'}_K)\n                 \n\n\n\nend role\n\n\n\nrole session(A, B           : agent,\n             Ka, Kb         : public_key) def=\n\n  local  SA, RA, SB, RB : channel (dy)\n\n  composition\n    share_Init(A,B,Ka,Kb,SA,RA) /\\\n    share_Resp(B,A,Kb,Ka,SB,RB)\n\nend role\n\n\n\nrole environment() def=\n \n const zero, one    : text,\n       a, b, i      : agent,\n       ka, kb, ki   : public_key,\n       k1, k2, msg, nanb : protocol_id\n\n intruder_knowledge = {a,b,ka,kb,ki,i,inv(ki),zero,one}\n\n composition\n\n        session(a,b,ka,kb) \n    /\\  session(a,i,ka,ki) \n    /\\  session(i,b,ki,kb)\n    /\\  session(i,a,ki,ka) \nend role\n\n\n\ngoal\n\n\n    secrecy_of nanb\n\n\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/full-sample.hlpsl": [[true, "%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) with key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1a. A ------------------- {A.B} ------------------> S\n%% 1b. A <-------------------{B.PKb}_inv(PKs) -------- S\n%% 1c. A --- {Na.A}_PKb ---> B\n%% 2a.                       B --- {B.A} ------------> S\n%% 2b.                       B <-- {A.PKa}_inv(PKs) -- S\n%% 2c. A <-- {Na.Nb}_PKa --- B\n%% 3 . A --- {Nb}_PKb -----> B\n%% PROBLEMS: 3\n%% ATTACKS: Man-in-the-middle attack\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n% Role of the initiator:\nrole alice(ROLE_1) (A, B: agent,             \n            PKa, PKs: public_key,  \n            KeyRing: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by A def=\n\n  local State: nat,\n        Na, Nb: text,\n        PKb: public_key\n\n  init State:=0\n\n  transition\n\n   % Start, if alice must request bob's public key from key server\n   ask.    State=0 /\\ Rcv(start) /\\ not(in(B.PKb', KeyRing))\n       =|> State':=1 /\\ Snd({A.B})\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({B.PKb'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(B.PKb', KeyRing)\n                     /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,bob_alice_na,Na')\n\n   % Start/resume, provided alice knows bob's public key\n   knows.  State=0 /\\ Rcv(start) /\\ in(B.PKb', KeyRing)\n       =|> State':=2 /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,alice_bob_nb,Na')\n\n   cont.   State=2 /\\ Rcv({Na.Nb'}_PKa) \n       =|> State':=3 /\\ Snd({Nb'}_PKb)\n\t             /\\ wrequest(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the receiver:\nrole bob(A, B: agent,      \n         PKb, PKs: public_key,  \n         KeyRing: (agent.public_key) set,\n         Snd, Rcv: channel(dy))\nplayed_by B def=\n\n  local State: nat,\n        Na, Nb: text, \n        PKa: public_key\n\n  init State:=0\n\n  transition \n\n   % Start if bob must request alice's public key from key server\n   ask.    State=0 /\\ Rcv({Na'.A}_PKb) /\\ not(in(A.PKa', KeyRing))\n       =|> State':=1 /\\ Snd(B.A)\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({A.PKa'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(A.PKa', KeyRing)\n                     /\\ Nb':=new() /\\ Snd({Na'.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,alice_bob_nb,Nb')\n\n   % Start/resume, provided bob knows alice's public key\n   knows.  State=0 /\\ Rcv({Na'.A}_PKb) /\\ in(A.PKa', KeyRing)\n       =|> State':=2 /\\ Nb':=new() /\\ Snd({Na'.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,bob_alice_na,Nb')\n\n   cont.   State=2 /\\ Rcv({Nb}_PKb) \n       =|> State':=3 /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the key server:\nrole server(X, Y: agent,\n            PKs: public_key,\n            KeyMap: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by S def=\n\n  local X, Y: agent,\n        State: nat,\n\tPKy: public_key\n\n  transition\n   % Loop on receiving a key request, and sending it\n   req.   Rcv({X.Y}) /\\ in(Y.PKy', KeyMap)\n       =|> Snd({Y.PKy'}_inv(PKs))\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role representing a partial session between alice and bob:\nrole nspk(A, B: agent,\n          PKa, PKb, PKs: public_key,\n          KeyMapA, KeyMapB: (agent.public_key) set,\n          Snd, Rcv: channel(dy))\ndef=\n\n  composition\n     alice(A,B,PKa,PKs,KeyMapA,Snd,Rcv)\n     /\\ bob(A,B,PKb,PKs,KeyMapB,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% The main role:\nrole environment() def=\n\n  local KeyMapS,KeyMapA,KeyMapB,KeyMapI: (agent.public_key) set,\n        Snd, Rcv: channel(dy)\n\n  const a, b, s, i: agent,\n        pka, pkb, pki, pks: public_key,\n        sna, snb, alice_bob_nb, bob_alice_na: protocol_id\n\n  init KeyMapS:={a.pka, b.pkb, i.pki}\n    /\\ KeyMapA:={a.pka, b.pkb}\n    /\\ KeyMapB:={b.pkb}\n    /\\ KeyMapI:={i.pki}\n\n  intruder_knowledge = {a, b, s, pks, pka, pkb, pki, inv(pki)}\n\n  composition\n     server(a,b,pks,KeyMapS,Snd,Rcv) % one unique server for all sessions\n     /\\ nspk(a,b,pka,pkb,pks,KeyMapA,KeyMapB,Snd,Rcv)\n     /\\ nspk(a,i,pka,pki,pks,KeyMapA,KeyMapI,Snd,Rcv)\n     /\\ nspk(i,b,pki,pkb,pks,KeyMapI,KeyMapB,Snd,Rcv)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Description of goal properties:\ngoal\n\n  secrecy_of sna, snb % represented by the secret() predicate in the protocol\n  weak_authentication_on alice_bob_nb % represented by the witness() and wrequest() predicates in the protocol\n  authentication_on bob_alice_na % represented by the witness() and request() predicates in the protocol\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Call of the main role:\nenvironment()", "```hlpsl\n%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) with key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1a. A ------------------- {A.B} ------------------> S\n%% 1b. A <-------------------{B.PKb}_inv(PKs) -------- S\n%% 1c. A --- {Na.A}_PKb ---> B\n%% 2a.                       B --- {B.A} ------------> S\n%% 2b.                       B <-- {A.PKa}_inv(PKs) -- S\n%% 2c. A <-- {Na.Nb}_PKa --- B\n%% 3 . A --- {Nb}_PKb -----> B\n%% PROBLEMS: 3\n%% ATTACKS: Man-in-the-middle attack\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n% Role of the initiator:\nrole alice(ROLE_1) (A, B: agent,             \n            PKa, PKs: public_key,  \n            KeyRing: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by A def=\n\n  local State: nat,\n        Na, Nb: text,\n        PKb: public_key\n\n  init State:=0\n\n  transition\n\n   % Start, if alice must request bob's public key from key server\n   ask.    State=0 /\\ Rcv(start) /\\ not(in(B.PKb', KeyRing))\n       =|> State':=1 /\\ Snd({A.B})\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({B.PKb'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(B.PKb', KeyRing)\n                     /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,bob_alice_na,Na')\n\n   % Start/resume, provided alice knows bob's public key\n   knows.  State=0 /\\ Rcv(start) /\\ in(B.PKb', KeyRing)\n       =|> State':=2 /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,alice_bob_nb,Na')\n\n   cont.   State=2 /\\ Rcv({Na.Nb'}_PKa) \n       =|> State':=3 /\\ Snd({Nb'}_PKb)\n\t             /\\ wrequest(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the receiver:\nrole bob(A, B: agent,      \n         PKb, PKs: public_key,  \n         KeyRing: (agent.public_key) set,\n         Snd, Rcv: channel(dy))\nplayed_by B def=\n\n  local State: nat,\n        Na, Nb: text, \n        PKa: public_key\n\n  init State:=0\n\n  transition \n\n   % Start if bob must request alice's public key from key server\n   ask.    State=0 /\\ Rcv({Na'.A}_PKb) /\\ not(in(A.PKa', KeyRing))\n       =|> State':=1 /\\ Snd(B.A)\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({A.PKa'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(A.PKa', KeyRing)\n                     /\\ Nb':=new() /\\ Snd({Na'.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,alice_bob_nb,Nb')\n\n   % Start/resume, provided bob knows alice's public key\n   knows.  State=0 /\\ Rcv({Na'.A}_PKb) /\\ in(A.PKa', KeyRing)\n       =|> State':=2 /\\ Nb':=new() /\\ Snd({Na'.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,bob_alice_na,Nb')\n\n   cont.   State=2 /\\ Rcv({Nb}_PKb) \n       =|> State':=3 /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the key server:\nrole server(X, Y: agent,\n            PKs: public_key,\n            KeyMap: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by S def=\n\n  local X, Y: agent,\n        State: nat,\n\tPKy: public_key\n\n  transition\n   % Loop on receiving a key request, and sending it\n   req.   Rcv({X.Y}) /\\ in(Y.PKy', KeyMap)\n       =|> Snd({Y.PKy'}_inv(PKs))\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role representing a partial session between alice and bob:\nrole nspk(A, B: agent,\n          PKa, PKb, PKs: public_key,\n          KeyMapA, KeyMapB: (agent.public_key) set,\n          Snd, Rcv: channel(dy))\ndef=\n\n  composition\n     alice(A,B,PKa,PKs,KeyMapA,Snd,Rcv)\n     /\\ bob(A,B,PKb,PKs,KeyMapB,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% The main role:\nrole environment() def=\n\n  local KeyMapS,KeyMapA,KeyMapB,KeyMapI: (agent.public_key) set,\n        Snd, Rcv: channel(dy)\n\n  const a, b, s, i: agent,\n        pka, pkb, pki, pks: public_key,\n        sna, snb, alice_bob_nb, bob_alice_na: protocol_id\n\n  init KeyMapS:={a.pka, b.pkb, i.pki}\n    /\\ KeyMapA:={a.pka, b.pkb}\n    /\\ KeyMapB:={b.pkb}\n    /\\ KeyMapI:={i.pki}\n\n  intruder_knowledge = {a, b, s, pks, pka, pkb, pki, inv(pki)}\n\n  composition\n     server(a,b,pks,KeyMapS,Snd,Rcv) % one unique server for all sessions\n     /\\ nspk(a,b,pka,pkb,pks,KeyMapA,KeyMapB,Snd,Rcv)\n     /\\ nspk(a,i,pka,pki,pks,KeyMapA,KeyMapI,Snd,Rcv)\n     /\\ nspk(i,b,pki,pkb,pks,KeyMapI,KeyMapB,Snd,Rcv)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Description of goal properties:\ngoal\n\n  secrecy_of sna, snb % represented by the secret() predicate in the protocol\n  weak_authentication_on alice_bob_nb % represented by the witness() and wrequest() predicates in the protocol\n  authentication_on bob_alice_na % represented by the witness() and request() predicates in the protocol\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Call of the main role:\nenvironment()\n```"]], "HLPSL-1/h.530.hlpsl": [[true, "role mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State,X,CH1,CH3   : nat,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(GY'.X.VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key':=exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key1,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key1,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,AuF})  % AuF must be honest anyway...\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0 /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n               /\\ Key':=exp(GX',Y')\n               /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t       /\\ SND(M2'.F(ZZ_VA.M2'))\n               /\\ witness(VGK,MT,key2,GX')\n\n  2. State = 1 /\\ RCV(VGK.MT.F(ZZ_VA.VGK).F(ZZ_VA.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n               /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).F(ZZ.xor(exp(G,X),exp(G,Y))).F(ZZ.VGK).\n\t\t        F(Key.VGK.MT.CH1.CH2'.exp(G,Y).F(ZZ.xor(exp(G,X),exp(G,Y))).F(ZZ.VGK)))\n\n  3. State = 2 /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n               /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n               /\\ request(VGK,MT,key1,Key)\n               /\\ request(VGK,AuF,key2,GX)\n               /\\ secret(Key,sec_v_Key,{MT,AuF})\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY'))))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,i      : agent,\n    f            : hash_func,\n    key1,key2     : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf \n                 : symmetric_key,\n    nil,g        : text\n\n  intruder_knowledge = {a,b,auf,f,g,nil,zz_i_auf}\n\n  composition\n     session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n  /\\ session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n%  /\\ session(b,a,auf,f,zz_b_auf,zz_a_auf,nil,g)\n%  /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n%  /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  authentication_on key1\n  authentication_on key2\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State,X,CH1,CH3   : nat,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(GY'.X.VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key':=exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key1,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key1,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,AuF})  % AuF must be honest anyway...\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0 /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n               /\\ Key':=exp(GX',Y')\n               /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t       /\\ SND(M2'.F(ZZ_VA.M2'))\n               /\\ witness(VGK,MT,key2,GX')\n\n  2. State = 1 /\\ RCV(VGK.MT.F(ZZ_VA.VGK).F(ZZ_VA.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n               /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).F(ZZ.xor(exp(G,X),exp(G,Y))).F(ZZ.VGK).\n\t\t        F(Key.VGK.MT.CH1.CH2'.exp(G,Y).F(ZZ.xor(exp(G,X),exp(G,Y))).F(ZZ.VGK)))\n\n  3. State = 2 /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n               /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n               /\\ request(VGK,MT,key1,Key)\n               /\\ request(VGK,AuF,key2,GX)\n               /\\ secret(Key,sec_v_Key,{MT,AuF})\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY'))))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,i      : agent,\n    f            : hash_func,\n    key1,key2     : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf \n                 : symmetric_key,\n    nil,g        : text\n\n  intruder_knowledge = {a,b,auf,f,g,nil,zz_i_auf}\n\n  composition\n     session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n  /\\ session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n%  /\\ session(b,a,auf,f,zz_b_auf,zz_a_auf,nil,g)\n%  /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n%  /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  authentication_on key1\n  authentication_on key2\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/hash_n_multi.hlpsl": [[true, "role user (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\n 2. State  = 2 /\\ RCV(Nb'.S) =|>\n    State':= 4 /\\ Nah3' := F(F(F(PW)))\n               /\\ SND(Nah3'.U)\n\t       /\\ witness(U,S,user_server_nah3,Nb')\n\nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ Nb' := new()\n\t\t/\\ Nah3' := F(F(F(PW)))\n\t\t/\\ SND(Nb'.S)\n\n  2. State = 3 /\\ RCV(Nah3.U) =|>\n     State':= 5 /\\ request(S,U,user_server_nah3,Nb')\n\t\t/\\ secret(Nah3,sec_pw,{U,S})\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n/\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s,i      : agent,\n    f            : hash_func,\n    user_server_nah3,sec_pw     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n/\\ session(u,i,f,pwi)\n/\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah3\n  secrecy_of sec_pw\n\nend goal\n\n\nenvironment()", "```hlpsl\nrole user (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\n 2. State  = 2 /\\ RCV(Nb'.S) =|>\n    State':= 4 /\\ Nah3' := F(F(F(PW)))\n               /\\ SND(Nah3'.U)\n\t       /\\ witness(U,S,user_server_nah3,Nb')\n\nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ Nb' := new()\n\t\t/\\ Nah3' := F(F(F(PW)))\n\t\t/\\ SND(Nb'.S)\n\n  2. State = 3 /\\ RCV(Nah3.U) =|>\n     State':= 5 /\\ request(S,U,user_server_nah3,Nb')\n\t\t/\\ secret(Nah3,sec_pw,{U,S})\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n/\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s,i      : agent,\n    f            : hash_func,\n    user_server_nah3,sec_pw     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n/\\ session(u,i,f,pwi)\n/\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah3\n  secrecy_of sec_pw\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/authenticationWPA.hlpsl": [[true, "%% PROTOCOL: WPA2 Wifi security protocol authentication request response and 4 way handshake.\n%% PURPOSE:\n%% We want to model the security capabilities of the WPA2 model for which \n%% we need to use a relevant analysis software. Here, the protocol is \n%% modelled on AVISPA Tool. On performing the analysis, we see that\n%% there is no attack possible and the protocol is safe.\n%% However, we know now that there is a KRACK Attack possible against the protocol.\n%% THe purpose of this project is to come up with a patch to the protocol and hence\n%% the AVISPA tool is not sufficient to model such behaviour according to our findings.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\n\nrole authenticator(A,S:agent,PMK:text,\n\t   KDF: hash_func,\n\t   Snd,Rcv:channel(dy)) \nplayed_by A\ndef=\n\n  local State : nat,\n  \tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, ANonce, SNonce,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\n  init State:=1\n\n  transition\n  \t1. State=1 /\\ Rcv(AuthReq') =|>\n  \t   State':=3 /\\ AuthResp' := new() /\\ Snd(AuthResp')\n\t1. State=3 /\\ Rcv(ReAuthReq') =|>\n\t   State' := 5 /\\ ReAuthResp' :=new() /\\ ReplayCounter' := new() /\\ ANonce' := new() /\\ Snd(ReAuthResp'.ANonce'.ReplayCounter')\n\t2. State=5 /\\ Rcv(ReplayCounter'.SNonce') =|> \n\t   State':= 7 /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ ReplayCounterplus1' := new() /\\ GTK':= new() /\\ Snd(ReplayCounterplus1'.{GTK'}_PTK') /\\\n\t   secret(GTK',sec_gtk,{A,S}) /\\\n\t   witness(A,S,authenticator_supplicant_gtk,GTK')\n\t   \n\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole supplicant(S,A:agent, \n\t PMK: text,\n         KDF: hash_func,\n         Snd,Rcv:channel(dy)) \nplayed_by S\ndef=\n\n  local State : nat, \n\tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, SNonce, ANonce ,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,supplicant_authenticator_nonce : protocol_id\n\t\n  init State:=0\n  \n  transition\n  \t1. State=0 /\\ Rcv(start') =|>\n  \t   State':=2 /\\ AuthReq' := new() /\\ Snd(AuthReq')\n  \t2. State=2 /\\ Rcv(AuthResp') =|>\n  \t   State':=4 /\\ ReAuthReq' := new() /\\ Snd(ReAuthReq')\n\t1. State=4 /\\ Rcv(ReAuthResp'.ANonce'.ReplayCounter') =|>\n   \t   State':= 6 /\\ SNonce':=new() /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ Snd(ReplayCounter'.SNonce') \n   \t2. State= 6 /\\ Rcv(ReplayCounterplus1'.{GTK'}_PTK') =|>\n   \t   State':= 7 /\\ request(S,A,authenticator_supplicant_gtk,GTK')\n\nend role\n\t\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n\nrole session(A,S:agent,\n\t      KDF: hash_func, \n\t      PMK:text) \ndef=\n\n  local SND_A,RCV_A,SND_B,RCV_B:channel(dy) \n  \n  composition\n\tauthenticator(A,S,PMK,KDF,SND_A,RCV_A) \n     /\\ supplicant(S,A,PMK,KDF,SND_B,RCV_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole environment() \ndef=\n\n  const authenticator_supplicant_gtk,supplicant_authenticator_nonce : protocol_id,\n  \ta,s : agent, \n\tpmk : text,\n\tgtk : protocol_id,\n\tkdf : hash_func\n\t\n  intruder_knowledge = {a,s,pmk}\n  \n  composition\n     session(a,s,kdf,pmk)\n \n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  \n  authentication_on authenticator_supplicant_gtk\n  secrecy_of sec_gtk\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: WPA2 Wifi security protocol authentication request response and 4 way handshake.\n%% PURPOSE:\n%% We want to model the security capabilities of the WPA2 model for which \n%% we need to use a relevant analysis software. Here, the protocol is \n%% modelled on AVISPA Tool. On performing the analysis, we see that\n%% there is no attack possible and the protocol is safe.\n%% However, we know now that there is a KRACK Attack possible against the protocol.\n%% THe purpose of this project is to come up with a patch to the protocol and hence\n%% the AVISPA tool is not sufficient to model such behaviour according to our findings.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\n\nrole authenticator(A,S:agent,PMK:text,\n\t   KDF: hash_func,\n\t   Snd,Rcv:channel(dy)) \nplayed_by A\ndef=\n\n  local State : nat,\n  \tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, ANonce, SNonce,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\n  init State:=1\n\n  transition\n  \t1. State=1 /\\ Rcv(AuthReq') =|>\n  \t   State':=3 /\\ AuthResp' := new() /\\ Snd(AuthResp')\n\t1. State=3 /\\ Rcv(ReAuthReq') =|>\n\t   State' := 5 /\\ ReAuthResp' :=new() /\\ ReplayCounter' := new() /\\ ANonce' := new() /\\ Snd(ReAuthResp'.ANonce'.ReplayCounter')\n\t2. State=5 /\\ Rcv(ReplayCounter'.SNonce') =|> \n\t   State':= 7 /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ ReplayCounterplus1' := new() /\\ GTK':= new() /\\ Snd(ReplayCounterplus1'.{GTK'}_PTK') /\\\n\t   secret(GTK',sec_gtk,{A,S}) /\\\n\t   witness(A,S,authenticator_supplicant_gtk,GTK')\n\t   \n\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole supplicant(S,A:agent, \n\t PMK: text,\n         KDF: hash_func,\n         Snd,Rcv:channel(dy)) \nplayed_by S\ndef=\n\n  local State : nat, \n\tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, SNonce, ANonce ,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,supplicant_authenticator_nonce : protocol_id\n\t\n  init State:=0\n  \n  transition\n  \t1. State=0 /\\ Rcv(start') =|>\n  \t   State':=2 /\\ AuthReq' := new() /\\ Snd(AuthReq')\n  \t2. State=2 /\\ Rcv(AuthResp') =|>\n  \t   State':=4 /\\ ReAuthReq' := new() /\\ Snd(ReAuthReq')\n\t1. State=4 /\\ Rcv(ReAuthResp'.ANonce'.ReplayCounter') =|>\n   \t   State':= 6 /\\ SNonce':=new() /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ Snd(ReplayCounter'.SNonce') \n   \t2. State= 6 /\\ Rcv(ReplayCounterplus1'.{GTK'}_PTK') =|>\n   \t   State':= 7 /\\ request(S,A,authenticator_supplicant_gtk,GTK')\n\nend role\n\t\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n\nrole session(A,S:agent,\n\t      KDF: hash_func, \n\t      PMK:text) \ndef=\n\n  local SND_A,RCV_A,SND_B,RCV_B:channel(dy) \n  \n  composition\n\tauthenticator(A,S,PMK,KDF,SND_A,RCV_A) \n     /\\ supplicant(S,A,PMK,KDF,SND_B,RCV_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole environment() \ndef=\n\n  const authenticator_supplicant_gtk,supplicant_authenticator_nonce : protocol_id,\n  \ta,s : agent, \n\tpmk : text,\n\tgtk : protocol_id,\n\tkdf : hash_func\n\t\n  intruder_knowledge = {a,s,pmk}\n  \n  composition\n     session(a,s,kdf,pmk)\n \n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  \n  authentication_on authenticator_supplicant_gtk\n  secrecy_of sec_gtk\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/IKEv2-DS.hlpsl": [[true, "role alice(A,B:agent,\n\t   G: text,\n\t   F: hash_func,\n\t   Ka, Kb: public_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more specific: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat\n\n  const sk2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  %% We have abstracted away from the negotiation of cryptographic\n  %% parameters.  Alice sends a nonce SAi1, which is meant to\n  %% model Alice sending only a single crypto-suite offer.  Bob must\n  %% then respond with the same nonce.\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n\t        /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.{SA1.exp(G,DHX).Ni.Nr'}_(inv(Ka)).SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  \n  \n  \n  \n  3. State = 4  /\\ RCV_B({B.{SA1.KEr.Nr.Ni}_(inv(Kb)).SA2}_SK) =|>\n     State':= 9 /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t  G: text,\n\t  F: hash_func,\n\t  Kb, Ka: public_key,\n\t  SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat\n\n  const sk1 : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1  /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':= 3 /\\ DHY' := new()\n                /\\ Nr' := new()\n                /\\ SND_A(SA1'.exp(G,DHY').Nr')\n                /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n                /\\ witness(B,A,sk1,F(Ni'.Nr'.SA1'.exp(KEi',DHY')))\n\n  2. State = 3  /\\ RCV_A( {A.{SA1.KEi.Ni.Nr}_(inv(Ka)).SA2'}_SK ) =|>\n     State':= 9 /\\ SND_A( {B.{SA1.exp(G,DHY).Nr.Ni}_(inv(Kb)).SA2'}_SK )\n                /\\ secret(SK,sec_b_SK,{A,B})\n                /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, B: agent,\n\t     Ka, Kb: public_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\t   alice(A,B,G,F,Ka,Kb,SA,RA)\n\t/\\ bob(B,A,G,F,Kb,Ka,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2    : protocol_id,\n        a, b, i       : agent,\n        ka, kb, ki : public_key,\n        g          : text,\n        f          : hash_func\n\n  intruder_knowledge = {g,f,a,b,ka,kb,i,ki,inv(ki)\n                       }\n\n  composition\n\n\tsession(a,b,ka,kb,g,f)\n     /\\ session(a,i,ka,ki,g,f)\n     /\\\tsession(i,b,ki,kb,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "```hlpsl\nrole alice(A,B:agent,\n\t   G: text,\n\t   F: hash_func,\n\t   Ka, Kb: public_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more specific: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat\n\n  const sk2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  %% We have abstracted away from the negotiation of cryptographic\n  %% parameters.  Alice sends a nonce SAi1, which is meant to\n  %% model Alice sending only a single crypto-suite offer.  Bob must\n  %% then respond with the same nonce.\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n\t        /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.{SA1.exp(G,DHX).Ni.Nr'}_(inv(Ka)).SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  \n  \n  \n  \n  3. State = 4  /\\ RCV_B({B.{SA1.KEr.Nr.Ni}_(inv(Kb)).SA2}_SK) =|>\n     State':= 9 /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t  G: text,\n\t  F: hash_func,\n\t  Kb, Ka: public_key,\n\t  SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat\n\n  const sk1 : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1  /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':= 3 /\\ DHY' := new()\n                /\\ Nr' := new()\n                /\\ SND_A(SA1'.exp(G,DHY').Nr')\n                /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n                /\\ witness(B,A,sk1,F(Ni'.Nr'.SA1'.exp(KEi',DHY')))\n\n  2. State = 3  /\\ RCV_A( {A.{SA1.KEi.Ni.Nr}_(inv(Ka)).SA2'}_SK ) =|>\n     State':= 9 /\\ SND_A( {B.{SA1.exp(G,DHY).Nr.Ni}_(inv(Kb)).SA2'}_SK )\n                /\\ secret(SK,sec_b_SK,{A,B})\n                /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, B: agent,\n\t     Ka, Kb: public_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\t   alice(A,B,G,F,Ka,Kb,SA,RA)\n\t/\\ bob(B,A,G,F,Kb,Ka,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2    : protocol_id,\n        a, b, i       : agent,\n        ka, kb, ki : public_key,\n        g          : text,\n        f          : hash_func\n\n  intruder_knowledge = {g,f,a,b,ka,kb,i,ki,inv(ki)\n                       }\n\n  composition\n\n\tsession(a,b,ka,kb,g,f)\n     /\\ session(a,i,ka,ki,g,f)\n     /\\\tsession(i,b,ki,kb,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n```"]], "HLPSL-1/ISO1.hlpsl": [[true, "%% PROTOCOL: ISO1 Public Key Unilateral Authentication Protocol\n%% VARIANT: one-pass unilateral authentication\n%% PURPOSE: A client authenticates himself to a server by sending a digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%   1. A -> B : {PKa,A}inv(PKs), Na, B, Text,{Na,B,Text}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the digital signatures.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,4) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,7) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% \\end{verbatim}\n%% NOTES:\n%% \n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!; \n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%% If one would like to use the same server public key for each\n%% session, then permutation on \\verb!Pks! should be avoided.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso1_Init (A, B : agent, Pka : public_key,\n                 Pks : public_key,\n                 Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n local  State: nat,\n        Na   : text\n\n init  State := 0\n\n%%% knowledge(A) = {A,B,Pka,Pks,ctext,inv(Pka)}\n\n transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext.{Na'.B.ctext}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso1_Resp (A, B: agent,\n                Pks : public_key,\n                Rec : channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat, \n         Pka       : public_key,\n         Na, Text  : text\n\n  init  State := 0\n\n%%%  knowledge(B)={A,B,Pks}\n\n  transition\n\n   1. State = 0 \n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text'.{Na'.B.Text'}_inv(Pka'))\n      =|>  \n      State' := 1\n      /\\ request(B,A,na,Na')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  const na : protocol_id\n\n  composition\n\n          iso1_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso1_Resp(A,B,Pks,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const a, b     : agent,\n\tpka, pks : public_key,\n\tna       : protocol_id\n\n  intruder_knowledge={a,b,pks}\n\n  composition\n\n\tsession(a,b,pka,pks)\n     /\\\tsession(a,b,pka,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO1_Resp authenticates ISO1_Init on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()", "```hlpsl\n%% PROTOCOL: ISO1 Public Key Unilateral Authentication Protocol\n%% VARIANT: one-pass unilateral authentication\n%% PURPOSE: A client authenticates himself to a server by sending a digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%   1. A -> B : {PKa,A}inv(PKs), Na, B, Text,{Na,B,Text}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the digital signatures.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,4) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,7) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% \\end{verbatim}\n%% NOTES:\n%% \n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!; \n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%% If one would like to use the same server public key for each\n%% session, then permutation on \\verb!Pks! should be avoided.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso1_Init (A, B : agent, Pka : public_key,\n                 Pks : public_key,\n                 Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n local  State: nat,\n        Na   : text\n\n init  State := 0\n\n%%% knowledge(A) = {A,B,Pka,Pks,ctext,inv(Pka)}\n\n transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext.{Na'.B.ctext}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso1_Resp (A, B: agent,\n                Pks : public_key,\n                Rec : channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat, \n         Pka       : public_key,\n         Na, Text  : text\n\n  init  State := 0\n\n%%%  knowledge(B)={A,B,Pks}\n\n  transition\n\n   1. State = 0 \n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text'.{Na'.B.Text'}_inv(Pka'))\n      =|>  \n      State' := 1\n      /\\ request(B,A,na,Na')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  const na : protocol_id\n\n  composition\n\n          iso1_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso1_Resp(A,B,Pks,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const a, b     : agent,\n\tpka, pks : public_key,\n\tna       : protocol_id\n\n  intruder_knowledge={a,b,pks}\n\n  composition\n\n\tsession(a,b,pka,pks)\n     /\\\tsession(a,b,pka,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO1_Resp authenticates ISO1_Init on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/ISO3.hlpsl": [[true, "%% PROTOCOL*: ISO3 Public Key Mutual Authentication Protocol\n%% VARIANT: two-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this\n%% protocol authentication should be achieved by a single encrypted message sent from each party.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize} \n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : PKa,A,{PKa,A}inv(PKs), Na, B, Text2,{Na,B,Text1}inv(PKa)\n%% 2. B -> A : PKb,B,{PKb,B}inv(PKs), Nb, A, Text4,{Nb,A,Text3}inv(PKb)\n%% \\end{verbatim}\n%% \\begin{itemize}\n%% \\item \\verb!inv(PKs)! is the private key of the server \\verb!C!\n%% \\item \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!\n%% \\item \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!\n%% \\end{itemize}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the messages.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext2,\n%%                  {na(a,6),b,ctext1}inv(pka)\n%% i     -> (b,9) : start\n%% (b,9) -> i     : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% i     -> (a,6) : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% \\end{verbatim}\n%% NOTES:\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso3_Init( A, B     : agent,\t\n                Pka, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n  local  State\t\t   : nat,\n         Na\t\t   : text,\n         Nb, Text3, Text4  : text,\n         Pkb\t\t   : public_key\n\n  init State := 0 \n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext1,ctext2}\n\n  transition\n\n   1. State = 0 \n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext2.{Na'.B.ctext1}_inv(Pka)) \n      /\\ witness(A,B,na,Na')\n\n   2. State = 1 \n      /\\ Rcv(Pkb'.B.{Pkb'.B}_inv(Pks).Nb'.A.Text4'.{Nb'.A.Text3'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ wrequest(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso3_Resp (B, A     : agent, \t\t\t\t\t\n                Pkb, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by B\ndef=\n\n   local  State          : nat,\n          Nb             : text,\n          Na,Text1,Text2 : text,\n          Pka            : public_key\n\n   init State := 0\n\n%%%   knowledge(B)={A,B,Pkb,Pks,ctext3,ctext4}\n\n   transition\n\n   1. State = 0 \n      /\\ Rcv(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text2'.{Na'.B.Text1'}_inv(Pka'))\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb'.A.ctext4.{Nb'.A.ctext3}_inv(Pkb)) \n      /\\ witness(B,A,nb,Nb')\n      /\\ wrequest(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B     : agent,\n\t      Pka, Pkb : public_key,\n              Pks      : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n          iso3_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso3_Resp(B,A,Pkb,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const ctext1, ctext2, ctext3, ctext4 : text,\n\tna, nb                         : protocol_id,\n        a, b                           : agent,\n        pka, pkb, pks, pki             : public_key\n\n  intruder_knowledge={a,b,pks,pki,inv(pki)}\n\n%%% LC: sufficient for finding the attacks\n  composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(b,a,pkb,pka,pks)\n\n%%%   composition\n%%% \n%%% \t session(a,b,pka,pkb,pks,sa1,ra1,sb1,rb1)\n%%%   /\\ session(a,c,pka,pkc,pks,sa2,ra2,sc2,rc2)\n%%%   /\\ session(a,a,pka,pka,pks,sa3,ra3,sa3,ra3)\n%%%   /\\ session(b,a,pkb,pka,pks,sb4,rb4,sa4,ra4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO3_Init weakly authenticates ISO3_Resp on nb\n   weak_authentication_on nb % addressess G1 and G2\n\n   %ISO3_Resp weakly authenticates ISO3_Init on na\n   weak_authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()", "```hlpsl\n%% PROTOCOL*: ISO3 Public Key Mutual Authentication Protocol\n%% VARIANT: two-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this\n%% protocol authentication should be achieved by a single encrypted message sent from each party.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize} \n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : PKa,A,{PKa,A}inv(PKs), Na, B, Text2,{Na,B,Text1}inv(PKa)\n%% 2. B -> A : PKb,B,{PKb,B}inv(PKs), Nb, A, Text4,{Nb,A,Text3}inv(PKb)\n%% \\end{verbatim}\n%% \\begin{itemize}\n%% \\item \\verb!inv(PKs)! is the private key of the server \\verb!C!\n%% \\item \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!\n%% \\item \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!\n%% \\end{itemize}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the messages.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext2,\n%%                  {na(a,6),b,ctext1}inv(pka)\n%% i     -> (b,9) : start\n%% (b,9) -> i     : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% i     -> (a,6) : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% \\end{verbatim}\n%% NOTES:\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso3_Init( A, B     : agent,\t\n                Pka, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n  local  State\t\t   : nat,\n         Na\t\t   : text,\n         Nb, Text3, Text4  : text,\n         Pkb\t\t   : public_key\n\n  init State := 0 \n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext1,ctext2}\n\n  transition\n\n   1. State = 0 \n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext2.{Na'.B.ctext1}_inv(Pka)) \n      /\\ witness(A,B,na,Na')\n\n   2. State = 1 \n      /\\ Rcv(Pkb'.B.{Pkb'.B}_inv(Pks).Nb'.A.Text4'.{Nb'.A.Text3'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ wrequest(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso3_Resp (B, A     : agent, \t\t\t\t\t\n                Pkb, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by B\ndef=\n\n   local  State          : nat,\n          Nb             : text,\n          Na,Text1,Text2 : text,\n          Pka            : public_key\n\n   init State := 0\n\n%%%   knowledge(B)={A,B,Pkb,Pks,ctext3,ctext4}\n\n   transition\n\n   1. State = 0 \n      /\\ Rcv(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text2'.{Na'.B.Text1'}_inv(Pka'))\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb'.A.ctext4.{Nb'.A.ctext3}_inv(Pkb)) \n      /\\ witness(B,A,nb,Nb')\n      /\\ wrequest(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B     : agent,\n\t      Pka, Pkb : public_key,\n              Pks      : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n          iso3_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso3_Resp(B,A,Pkb,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const ctext1, ctext2, ctext3, ctext4 : text,\n\tna, nb                         : protocol_id,\n        a, b                           : agent,\n        pka, pkb, pks, pki             : public_key\n\n  intruder_knowledge={a,b,pks,pki,inv(pki)}\n\n%%% LC: sufficient for finding the attacks\n  composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(b,a,pkb,pka,pks)\n\n%%%   composition\n%%% \n%%% \t session(a,b,pka,pkb,pks,sa1,ra1,sb1,rb1)\n%%%   /\\ session(a,c,pka,pkc,pks,sa2,ra2,sc2,rc2)\n%%%   /\\ session(a,a,pka,pka,pks,sa3,ra3,sa3,ra3)\n%%%   /\\ session(b,a,pkb,pka,pks,sb4,rb4,sa4,ra4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO3_Init weakly authenticates ISO3_Resp on nb\n   weak_authentication_on nb % addressess G1 and G2\n\n   %ISO3_Resp weakly authenticates ISO3_Init on na\n   weak_authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/LPD-MSR.hlpsl": [[true, "role msr_Base(B, M     : agent,\n\t      PKb      : public_key,\n              SCm      : text, \n              Snd, Rcv : channel(dy))\nplayed_by B\ndef=\n\n  local  State : nat,\n\t X     : symmetric_key\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1 \n      /\\ Snd(B.PKb)\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{M.SCm}_X')\n      =|> \n      State' := 2  \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole msr_Mobile(B, M     : agent,\n                SCm      :   text, \n                Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n\tPKb    : public_key,\n\tX      : symmetric_key\n\n  const secx   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.PKb')\n      =|> \n      State' := 1\n      /\\ X'  := new()\n      /\\ Snd({X'}_PKb'.{M.SCm}_X')\n      /\\ witness(M,B,x,X') \n      /\\ secret(X',secx,{B,M})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n\t     PKb            : public_key,\n             SCm            : text) def=\n\n  local  SA, RA, SB, RB : channel (dy)\n\n  const  secx : protocol_id\n\n  composition\n\n           msr_Base(B,M,PKb,SCm,SA,RA)\n        /\\ msr_Mobile(B,M,SCm,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n const b,m,i                             : agent,\n       kb, ki                          : public_key,\n       scm1,scm2,scm3                  : text,\n       secx                            : protocol_id,\n       x                               : symmetric_key\n\n intruder_knowledge = {b,m,scm2,scm3,i,ki,inv(ki)}\n\ncomposition\n\n\tsession(b,m,kb,scm1) \n    /\\  session(b,i,kb,scm2) \n    /\\  session(i,m,ki,scm3) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %MSR_Base weakly authenticates MSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nrole msr_Base(B, M     : agent,\n\t      PKb      : public_key,\n              SCm      : text, \n              Snd, Rcv : channel(dy))\nplayed_by B\ndef=\n\n  local  State : nat,\n\t X     : symmetric_key\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1 \n      /\\ Snd(B.PKb)\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{M.SCm}_X')\n      =|> \n      State' := 2  \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole msr_Mobile(B, M     : agent,\n                SCm      :   text, \n                Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n\tPKb    : public_key,\n\tX      : symmetric_key\n\n  const secx   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.PKb')\n      =|> \n      State' := 1\n      /\\ X'  := new()\n      /\\ Snd({X'}_PKb'.{M.SCm}_X')\n      /\\ witness(M,B,x,X') \n      /\\ secret(X',secx,{B,M})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n\t     PKb            : public_key,\n             SCm            : text) def=\n\n  local  SA, RA, SB, RB : channel (dy)\n\n  const  secx : protocol_id\n\n  composition\n\n           msr_Base(B,M,PKb,SCm,SA,RA)\n        /\\ msr_Mobile(B,M,SCm,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n const b,m,i                             : agent,\n       kb, ki                          : public_key,\n       scm1,scm2,scm3                  : text,\n       secx                            : protocol_id,\n       x                               : symmetric_key\n\n intruder_knowledge = {b,m,scm2,scm3,i,ki,inv(ki)}\n\ncomposition\n\n\tsession(b,m,kb,scm1) \n    /\\  session(b,i,kb,scm2) \n    /\\  session(i,m,ki,scm3) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %MSR_Base weakly authenticates MSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/NSPK_2.hlpsl": [[true, "%Alice - Bob\n%\n%   1. A -> B: {Na,A}_Kb\n%   2. B -> A: {Na,Nb}_Ka\n%   3. A -> B: {Nb}_Kb\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A: agent, B: agent,             \n            Ka: public_key, Kb: public_key,      \n            SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',  secret_na,{A,B}) \n\n    2.  State  = 2 /\\ RCV({Na.Nb'}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'}_Ka)\n\t\t   /\\ secret(Nb',  secret_nb,{A,B}) \n\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A: agent, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  secret_na, secret_nb : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secret_na, secret_nb\n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%Alice - Bob\n%\n%   1. A -> B: {Na,A}_Kb\n%   2. B -> A: {Na,Nb}_Ka\n%   3. A -> B: {Nb}_Kb\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A: agent, B: agent,             \n            Ka: public_key, Kb: public_key,      \n            SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',  secret_na,{A,B}) \n\n    2.  State  = 2 /\\ RCV({Na.Nb'}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'}_Ka)\n\t\t   /\\ secret(Nb',  secret_nb,{A,B}) \n\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A: agent, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  secret_na, secret_nb : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secret_na, secret_nb\n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/PBK.hlpsl": [[true, "%% PROTOCOL: PBK: Purpose Built Keys Framework\n%% VARIANT: original version\n%% PURPOSE: Sender invariance (authentication assuming first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {Msg}_inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {Nonce}_inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: \n%%   The initiator shall sign a random challenge received from the responder.\n%%   This can easily be exploited to make agents sign whatever the intruder wishes:\n%% \\begin{verbatim}\n%%   i      -> (a,3) : start\n%%   (a,3)  -> i     : {Msg(1)}inv(pk_a),f(pk_a)\n%%   i      -> (a,12): start\n%%   (a,12) -> i     : {Msg(2)}inv(pk_a),f(pk_a)\n%%   i      -> (a,3) : x71\n%%   (a,3)  -> i     : {x71}inv(pk_a)\n%%   i      -> (b,3) : {x71}inv(pk_a),f(pk_a)\n%%   (b,3)  -> i     : Nonce(4)\n%%   i      -> (a,12): Nonce(4)\n%%   (a,12) -> i     : {Nonce(4)}inv(pk_a)\n%%   i      -> (b,3) : {Nonce(4)}inv(pk_a)\n%% \\end{verbatim}\n%%\n%% NOTES:\n%% The protocol is so far only roughly described in natural language, and \n%% this file represents a verbatim translation to HLPSL as an\n%% ``early prototype'' and the AVISPA tool can identify a potential\n%% source for attacks which protocol designers should be aware of when\n%% implementing a protocol (see paragraph ``Attacks'').\n%% A fixed version (with tagging the \n%% challenge before signing it) is also provided in this library.\n%%\n%% The assumption is that the intruder cannot modify (or intercept) the first \n%% message is modelled by a compression-technique. Also, the authentication\n%% must be specified in a slightly different way, as A does not say for whom\n%% it signs the message (and anybody can act as responder). \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(dy),\n            Hash       : hash_func,\n            PK_A       : public_key)\nplayed_by A\ndef=\n\n  local\n    State      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND({Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A,B,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A,B        : agent,\n          SND,RCV    : channel(dy),\n          Hash       : hash_func,\n          PK_A       : public_key)\nplayed_by B\ndef=\n\n  local\n    State      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV({Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 5 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 5 /\\ RCV({Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ request(A,B,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B  : agent,\n             Hash : hash_func,\n             PK_A : public_key)\ndef=\n\n  local SNDA,RCVA,SNDB,RCVB : channel (dy)\n\n  composition\n\n    alice(A,B,SNDA,RCVA,Hash,PK_A)\n /\\ bob(A,B,SNDB,RCVB,Hash,PK_A)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b            : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n\n     session(a,b,f,pk_a)\n  /\\ session(b,a,f,pk_b)\n  /\\ session(i,b,f,pk_i)\n  /\\ session(a,i,f,pk_a)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Sender Invariance (G16)\n  weak_authentication_on msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n%% PROTOCOL: PBK: Purpose Built Keys Framework\n%% VARIANT: original version\n%% PURPOSE: Sender invariance (authentication assuming first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {Msg}_inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {Nonce}_inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: \n%%   The initiator shall sign a random challenge received from the responder.\n%%   This can easily be exploited to make agents sign whatever the intruder wishes:\n%% \\begin{verbatim}\n%%   i      -> (a,3) : start\n%%   (a,3)  -> i     : {Msg(1)}inv(pk_a),f(pk_a)\n%%   i      -> (a,12): start\n%%   (a,12) -> i     : {Msg(2)}inv(pk_a),f(pk_a)\n%%   i      -> (a,3) : x71\n%%   (a,3)  -> i     : {x71}inv(pk_a)\n%%   i      -> (b,3) : {x71}inv(pk_a),f(pk_a)\n%%   (b,3)  -> i     : Nonce(4)\n%%   i      -> (a,12): Nonce(4)\n%%   (a,12) -> i     : {Nonce(4)}inv(pk_a)\n%%   i      -> (b,3) : {Nonce(4)}inv(pk_a)\n%% \\end{verbatim}\n%%\n%% NOTES:\n%% The protocol is so far only roughly described in natural language, and \n%% this file represents a verbatim translation to HLPSL as an\n%% ``early prototype'' and the AVISPA tool can identify a potential\n%% source for attacks which protocol designers should be aware of when\n%% implementing a protocol (see paragraph ``Attacks'').\n%% A fixed version (with tagging the \n%% challenge before signing it) is also provided in this library.\n%%\n%% The assumption is that the intruder cannot modify (or intercept) the first \n%% message is modelled by a compression-technique. Also, the authentication\n%% must be specified in a slightly different way, as A does not say for whom\n%% it signs the message (and anybody can act as responder). \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(dy),\n            Hash       : hash_func,\n            PK_A       : public_key)\nplayed_by A\ndef=\n\n  local\n    State      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND({Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A,B,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A,B        : agent,\n          SND,RCV    : channel(dy),\n          Hash       : hash_func,\n          PK_A       : public_key)\nplayed_by B\ndef=\n\n  local\n    State      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV({Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 5 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 5 /\\ RCV({Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ request(A,B,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B  : agent,\n             Hash : hash_func,\n             PK_A : public_key)\ndef=\n\n  local SNDA,RCVA,SNDB,RCVB : channel (dy)\n\n  composition\n\n    alice(A,B,SNDA,RCVA,Hash,PK_A)\n /\\ bob(A,B,SNDB,RCVB,Hash,PK_A)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b            : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n\n     session(a,b,f,pk_a)\n  /\\ session(b,a,f,pk_b)\n  /\\ session(i,b,f,pk_i)\n  /\\ session(a,i,f,pk_a)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Sender Invariance (G16)\n  weak_authentication_on msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/protocol_v2.hlpsl": [[true, "% PURPOSE: Syncronisation between two servers before sending a common request to another one\n% DESCRIPTION:\n% Two servers: Shell (S) and Code (C)\n% Third server: Master (M)\n\n% S ------- {Mess1.Ns.S}_PKc ------------> C\n% S <------ {Mess1.Mess2.Ns.Nc}_PKs ------ C\n% S ------- {OK.Mess1.Mess2.Nc}_PKc -----> C\n% S -------------- {Mess1.Mess2}_PKm ------------> M\n% S <------------- {OK.rep}_PKs ------------------ M\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Protocal: \n\n% Role of Shell (S):\n\nrole shell (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by S def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess2, Rep: text\n\n    init\n        State:=0\n\n    transition\n\n        % Start communication with Code and start creating the request\n        begin.\n            State=0\n            /\\ Rcv(start) \n        =|>\n            State':=1\n            /\\ Ns':=new()\n            /\\ Snd({Mess1.Ns'.S}_PKc)\n            /\\ secret(Ns',sns,{C,S})\n\n        % Receive full message from code and confirm the reception of Code's nonce\n        messageComplete.\n            State=1\n            /\\ Rcv({Mess1.Mess2'.Ns.Nc'}_PKs)\n        =|>\n            State':=2\n            /\\ Snd({ok.Mess1.Mess2'.Nc'}_PKc)\n\n        % Send full message to Master\n        send.\n            State=2\n        =|>\n            State':=3\n            /\\ Snd({Mess1.Mess2}_PKm)\n\n        % Receive response\n        receive.\n            State=3\n            /\\ Rcv({ok.Rep'}_PKs) =|>\n            State':=4\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Code (C):\n\nrole code (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess2: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by C def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess1: text\n\n    init\n        State:=0\n\n    transition\n\n        % Receive first message and first part of the request from Shell \n        begin.\n            State=0\n            /\\ Rcv({Mess1'.Ns'.S}_PKc)\n        =|>\n            State':=1\n            /\\ Nc':=new()\n            /\\ Snd({Mess1'.Mess2.Ns'.Nc'}_PKs)\n            /\\ secret(Nc',snc,{S,C})\n\n        % Receive the confirmation from Shell\n        messageComplete.\n            State=1\n            /\\ Rcv({ok.Mess1.Mess2.Nc}_PKc)\n        =|>\n            State':=2\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Master (M):\n\nrole master (\n    M: agent,\n    PKm: public_key,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by M def=\n\n    local \n        State: nat,\n        Rep, Mess1, Mess2: text\n\n    init\n        State:=0  \n\n    transition  \n\n    % Receive Mess1.Mess2 and send response\n    send.\n        State=0\n        /\\ Rcv({Mess1'.Mess2'}_PKm)\n    =|>\n        State':=1\n        /\\ Rep':=new()\n        /\\ Snd({ok.Rep'}_PKs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Definition of session role:\n\nrole session(\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1, Mess2: text,\n    Snd, Rcv: channel(dy)\n) def=\n\ncomposition \n    shell(S,C,PKs,PKc,PKm,Mess1,Snd,Rcv)\n    /\\ code(S,C,PKs,PKc,PKm,Mess2,Snd,Rcv)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% The main role:\n\nrole environment() def=\n\n    local \n        Snd, Rcv: channel(dy)\n\n    const\n        s, c, m, i: agent,\n        ok, mess1, mess2: text,\n        pks, pkc, pki, pkm: public_key,\n        sns, snc: protocol_id\n\n    intruder_knowledge = {s, c, m, pks, pkc, pkm, pki, inv(pki)}\n\n    composition\n    master(m,pkm,Snd,Rcv)\n    /\\ session(s,c,pks,pkc,pkm,mess1,mess2,Snd,Rcv)\n    /\\ session(s,i,pks,pki,pkm,mess1,mess2,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Description of goal properties:\n\ngoal\n\nsecrecy_of sns, snc % Keep secret the nonces\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Call of the main role:\n\nenvironment()", "```hlpsl\n% PURPOSE: Syncronisation between two servers before sending a common request to another one\n% DESCRIPTION:\n% Two servers: Shell (S) and Code (C)\n% Third server: Master (M)\n\n% S ------- {Mess1.Ns.S}_PKc ------------> C\n% S <------ {Mess1.Mess2.Ns.Nc}_PKs ------ C\n% S ------- {OK.Mess1.Mess2.Nc}_PKc -----> C\n% S -------------- {Mess1.Mess2}_PKm ------------> M\n% S <------------- {OK.rep}_PKs ------------------ M\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Protocal: \n\n% Role of Shell (S):\n\nrole shell (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by S def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess2, Rep: text\n\n    init\n        State:=0\n\n    transition\n\n        % Start communication with Code and start creating the request\n        begin.\n            State=0\n            /\\ Rcv(start) \n        =|>\n            State':=1\n            /\\ Ns':=new()\n            /\\ Snd({Mess1.Ns'.S}_PKc)\n            /\\ secret(Ns',sns,{C,S})\n\n        % Receive full message from code and confirm the reception of Code's nonce\n        messageComplete.\n            State=1\n            /\\ Rcv({Mess1.Mess2'.Ns.Nc'}_PKs)\n        =|>\n            State':=2\n            /\\ Snd({ok.Mess1.Mess2'.Nc'}_PKc)\n\n        % Send full message to Master\n        send.\n            State=2\n        =|>\n            State':=3\n            /\\ Snd({Mess1.Mess2}_PKm)\n\n        % Receive response\n        receive.\n            State=3\n            /\\ Rcv({ok.Rep'}_PKs) =|>\n            State':=4\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Code (C):\n\nrole code (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess2: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by C def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess1: text\n\n    init\n        State:=0\n\n    transition\n\n        % Receive first message and first part of the request from Shell \n        begin.\n            State=0\n            /\\ Rcv({Mess1'.Ns'.S}_PKc)\n        =|>\n            State':=1\n            /\\ Nc':=new()\n            /\\ Snd({Mess1'.Mess2.Ns'.Nc'}_PKs)\n            /\\ secret(Nc',snc,{S,C})\n\n        % Receive the confirmation from Shell\n        messageComplete.\n            State=1\n            /\\ Rcv({ok.Mess1.Mess2.Nc}_PKc)\n        =|>\n            State':=2\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Master (M):\n\nrole master (\n    M: agent,\n    PKm: public_key,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by M def=\n\n    local \n        State: nat,\n        Rep, Mess1, Mess2: text\n\n    init\n        State:=0  \n\n    transition  \n\n    % Receive Mess1.Mess2 and send response\n    send.\n        State=0\n        /\\ Rcv({Mess1'.Mess2'}_PKm)\n    =|>\n        State':=1\n        /\\ Rep':=new()\n        /\\ Snd({ok.Rep'}_PKs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Definition of session role:\n\nrole session(\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1, Mess2: text,\n    Snd, Rcv: channel(dy)\n) def=\n\ncomposition \n    shell(S,C,PKs,PKc,PKm,Mess1,Snd,Rcv)\n    /\\ code(S,C,PKs,PKc,PKm,Mess2,Snd,Rcv)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% The main role:\n\nrole environment() def=\n\n    local \n        Snd, Rcv: channel(dy)\n\n    const\n        s, c, m, i: agent,\n        ok, mess1, mess2: text,\n        pks, pkc, pki, pkm: public_key,\n        sns, snc: protocol_id\n\n    intruder_knowledge = {s, c, m, pks, pkc, pkm, pki, inv(pki)}\n\n    composition\n    master(m,pkm,Snd,Rcv)\n    /\\ session(s,c,pks,pkc,pkm,mess1,mess2,Snd,Rcv)\n    /\\ session(s,i,pks,pki,pkm,mess1,mess2,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Description of goal properties:\n\ngoal\n\nsecrecy_of sns, snc % Keep secret the nonces\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Call of the main role:\n\nenvironment()\n```"]], "HLPSL-1/simple-sample.hlpsl": [[true, "%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) without key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1. A  - {Na.A}_PKb ----> B\n%% 2. A <- {Na.Nb}_PKa ---  B\n%% 3. A  - {Nb}_PKb ------> B\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le alice, initiant le protocole\nrole alice (A, B: agent,             \n            PKa, PKb: public_key,      \n            SA, RCV: channel(dy)) \nplayed_by A def=\n\n  local State: nat, \n        Na, Nb: text\n\n  init State:=0\n\n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 \n    /\\ Na':=new() \n    /\\ secret(Na',na,{A,B}) \n    /\\ witness(A,B,alice_bob_na,Na')\n    /\\ SND({Na'.A}_PKb)\n\n    2.  State=1 /\\ RCV({Na.Nb'}_PKa) =|> \n\tState':=2 /\\ SND({Nb'}_PKb)  /\\ witness(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role bob \n\nrole bob (A, B: agent,             \n        PKa, PKb: public_key,      \n        SB, RCV: channel(dy)) \n\nplayed_by B def=\n\n    local State: nat,\n        Na, Nb: text\n\n    init State:=0\n\n    transition \n    \n    0. State=0 /\\ RCV({Na'.A}_PKb) =|> State':=1 \n    /\\ Nb':=new() \n    /\\ secret(Nb',nb,{A,B}) \n    /\\ SND({Na'.Nb'}_PKa) \n    /\\ witness(B,A,bob_alice_nb,Nb')\n\n    2. State=1 /\\ RCV({Nb}_PKb) =|>\n    State':=2\n    /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(A, B: agent, PKa, PKb: public_key) def=\n\n  local SA, RA, SB, RB: channel(dy)\n\n  composition \n\n\talice(A,B,PKa,PKb,SA,RA)\n     /\\ bob(A,B,PKa,PKb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const a, b, i: agent,\n\tpka, pkb, pki: public_key,\n    nb, na, alice_bob_na, alice_bob_nb, bob_alice_na, bob_alice_nb: protocol_id\n\n    intruder_knowledge = {a, b, pka, pkb, pki, inv(pki)}\n\n    composition\n\n\tsession(a,b,pka,pkb)\n    /\\ session(a,i,pka,pki)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propri\u00e9t\u00e9 \u00e0 v\u00e9rifier)\ngoal\n    %%secrecy_of nb, na\n    authentication_on alice_bob_na\n    authentication_on alice_bob_nb\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()", "```hlpsl\n%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) without key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1. A  - {Na.A}_PKb ----> B\n%% 2. A <- {Na.Nb}_PKa ---  B\n%% 3. A  - {Nb}_PKb ------> B\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le alice, initiant le protocole\nrole alice (A, B: agent,             \n            PKa, PKb: public_key,      \n            SA, RCV: channel(dy)) \nplayed_by A def=\n\n  local State: nat, \n        Na, Nb: text\n\n  init State:=0\n\n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 \n    /\\ Na':=new() \n    /\\ secret(Na',na,{A,B}) \n    /\\ witness(A,B,alice_bob_na,Na')\n    /\\ SND({Na'.A}_PKb)\n\n    2.  State=1 /\\ RCV({Na.Nb'}_PKa) =|> \n\tState':=2 /\\ SND({Nb'}_PKb)  /\\ witness(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role bob \n\nrole bob (A, B: agent,             \n        PKa, PKb: public_key,      \n        SB, RCV: channel(dy)) \n\nplayed_by B def=\n\n    local State: nat,\n        Na, Nb: text\n\n    init State:=0\n\n    transition \n    \n    0. State=0 /\\ RCV({Na'.A}_PKb) =|> State':=1 \n    /\\ Nb':=new() \n    /\\ secret(Nb',nb,{A,B}) \n    /\\ SND({Na'.Nb'}_PKa) \n    /\\ witness(B,A,bob_alice_nb,Nb')\n\n    2. State=1 /\\ RCV({Nb}_PKb) =|>\n    State':=2\n    /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(A, B: agent, PKa, PKb: public_key) def=\n\n  local SA, RA, SB, RB: channel(dy)\n\n  composition \n\n\talice(A,B,PKa,PKb,SA,RA)\n     /\\ bob(A,B,PKa,PKb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const a, b, i: agent,\n\tpka, pkb, pki: public_key,\n    nb, na, alice_bob_na, alice_bob_nb, bob_alice_na, bob_alice_nb: protocol_id\n\n    intruder_knowledge = {a, b, pka, pkb, pki, inv(pki)}\n\n    composition\n\n\tsession(a,b,pka,pkb)\n    /\\ session(a,i,pka,pki)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propri\u00e9t\u00e9 \u00e0 v\u00e9rifier)\ngoal\n    %%secrecy_of nb, na\n    authentication_on alice_bob_na\n    authentication_on alice_bob_nb\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()\n```"]], "HLPSL-1/simple_protocol.hlpsl": [[true, "%%% Key exchange protocol (with 3 bugs in the spec (see below))\n%%% 1. A -> T: {Kab}_Kat\n%%% 2. T -> B: {Kab}_Kbt\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ Kab':=new() /\\ SND({Kab'}_Kat) \n\t\t/\\ witness(A,T,auth_1,{A,B,T})\n\t\t%/\\ SND(Kab')   %% Unsafe protocol but claimed SAFE!,\n                               %% Because of the bugs in the spec.\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat:symmetric_key,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kat) =|> State':=1 /\\ SND({Kab'}_Kbt) \n\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kbt) =|> State':=1 \nend role\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {alice,bob,kit,i}\n\tcomposition\n\t\tsession(alice,bob,trusted,kat,kbt) /\\\n\t\tsession(alice,i,trusted,kat,kit)\n\nend role\n\ngoal\n        secrecy_of sec_1\nend goal\n\nenvironment()", "```hlpsl\n%%% Key exchange protocol (with 3 bugs in the spec (see below))\n%%% 1. A -> T: {Kab}_Kat\n%%% 2. T -> B: {Kab}_Kbt\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ Kab':=new() /\\ SND({Kab'}_Kat) \n\t\t/\\ witness(A,T,auth_1,{A,B,T})\n\t\t%/\\ SND(Kab')   %% Unsafe protocol but claimed SAFE!,\n                               %% Because of the bugs in the spec.\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat:symmetric_key,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kat) =|> State':=1 /\\ SND({Kab'}_Kbt) \n\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kbt) =|> State':=1 \nend role\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {alice,bob,kit,i}\n\tcomposition\n\t\tsession(alice,bob,trusted,kat,kbt) /\\\n\t\tsession(alice,i,trusted,kat,kit)\n\nend role\n\ngoal\n        secrecy_of sec_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/strengthen_protocol.hlpsl": [[true, "%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (but unoptimized)\n%%% 1. A -> T : {A,B,Kab,Na}_Kat\n%%% 2. T -> B : {B,A,Kab,Na}_Kbt\n%%% 3. B -> A : {A,B,Na,Nb}_Kab\n%%% 4. A -> B : {A,B,Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({A.B.Kab'.Na'}_Kat) /\\ \n                   secret(Kab',sec_1,{A,B,T})\n\n\t\t2. State=1 /\\ RCV({A.B.Na.Nb'}_Kab) =|> State':=2 /\\ SND({A.B.Nb'}_Kab)\n                   \n                   %% A checks that he receives the same nonce \n                   %% that he sent at step 1.\n                   /\\ request(A,B,auth_1,Na)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ witness(B,A,auth_2,Nb')\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Na:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.B.Kab'.Na'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({B.A.Kab'.Na'}_Kbt)\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.A.Kab'.Na'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({A.B.Na'.Nb'}_Kab')\n\n                   %% B hopes that Na will permit to authenticate him\n                   /\\ witness(A,B,auth_1,Na')\n\n                2. State=1 /\\ RCV({A.B.Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(B,A,auth_2,Nb)\nend role\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,i,kit}    %% ... and we give it to the intruder\n\tcomposition\n                     %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n%                      %% in parallel with another regular session\n                 /\\ session(alice,bob,trusted,kat,kbt) \n\n%                      %% and a session between the intruder (with key kit) and bob\n                 /\\ session(i,bob,trusted,kit,kbt) \n%                      %% and a session between alice and the intruder (with key kit)\n                 /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of sec_1\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n\nenvironment()", "```hlpsl\n%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (but unoptimized)\n%%% 1. A -> T : {A,B,Kab,Na}_Kat\n%%% 2. T -> B : {B,A,Kab,Na}_Kbt\n%%% 3. B -> A : {A,B,Na,Nb}_Kab\n%%% 4. A -> B : {A,B,Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({A.B.Kab'.Na'}_Kat) /\\ \n                   secret(Kab',sec_1,{A,B,T})\n\n\t\t2. State=1 /\\ RCV({A.B.Na.Nb'}_Kab) =|> State':=2 /\\ SND({A.B.Nb'}_Kab)\n                   \n                   %% A checks that he receives the same nonce \n                   %% that he sent at step 1.\n                   /\\ request(A,B,auth_1,Na)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ witness(B,A,auth_2,Nb')\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Na:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.B.Kab'.Na'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({B.A.Kab'.Na'}_Kbt)\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.A.Kab'.Na'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({A.B.Na'.Nb'}_Kab')\n\n                   %% B hopes that Na will permit to authenticate him\n                   /\\ witness(A,B,auth_1,Na')\n\n                2. State=1 /\\ RCV({A.B.Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(B,A,auth_2,Nb)\nend role\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted,i:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,i,kit}    %% ... and we give it to the intruder\n\tcomposition\n                     %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n%                      %% in parallel with another regular session\n                 /\\ session(alice,bob,trusted,kat,kbt) \n\n%                      %% and a session between the intruder (with key kit) and bob\n                 /\\ session(i,bob,trusted,kit,kbt) \n%                      %% and a session between alice and the intruder (with key kit)\n                 /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of sec_1\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/AVISPAProject.hlpsl": [[true, "% A -> S: ({A.B.Na}_Ka)  % Ka is a key shared by A and S\n% A <- S: ({K.Na}_Ka.  % S generates new key K \n%                      % {K.Na}_Ka does not need Na, but it helps A identify the session for the key K\n%          {K.Na.A}_Kb)  % A cannot decrypt the contents of {K.Na.Ns}_Kb, but is able to forward it to B\n%                        % if A is not encrypted with Kb, the attacker will be able to pretend to be A when contacting B\n% A -> B: ({K.Na.A}_Kb)  % The last part is a key confirmation\n% A <- B: ({Na.Nb}_K)  % A tests if B knows K during this session, by using Na\n% A -> B: ({Nb.Na}_K)  % B tests if A knows K during this session, by using Nb\n%                      % Na is not necessary, but it helps B identify the session when receiving Nb\n\nrole alice (A, S, B : agent,\n\t    Ka      : symmetric_key,\n\t    SND_SA, RCV_SA, SND_BA, RCV_BA : channel(dy))\n\nplayed_by A def=\n    local State  : nat,\n          Na,Nb : text,\n          K     : symmetric_key,\n          X     : {symmetric_key.text.agent}_symmetric_key\n    init State := 0\n\n    transition\n    1. State  = 0 /\\ RCV_BA(start) =|>\n       State':= 2 /\\ Na' := new()\n                  /\\ SND_SA({A.B.Na'}_Ka)\n\n    2. State  = 2 /\\ RCV_SA({K'.Na}_Ka.X') =|>\n       State':= 4 /\\ SND_BA(X')\n\n    3. State  = 4 /\\ RCV_BA({Na.Nb'}_K) =|>\n       State':= 6 /\\ SND_BA({Nb'.Na}_K)\n                  /\\ request(A,B,alice_bob_na,Na) % A verifies that B knows K (B can decrpyt and encrypt again Na)\n                  /\\ witness(B,A,bob_alice_nb,Nb') \nend role\n\n\nrole server (A, S, B  : agent,\n             Ka, Kb   : symmetric_key,\n             SND_AS, RCV_AS : channel(dy))\n\nplayed_by S def=\n    local State : nat,\n          Na    : text,\n          K     : symmetric_key\n    init  State := 1\n\n    transition\n    1. State  = 1 /\\ RCV_AS({A.B.Na'}_Ka) =|>\n       State':= 3 /\\ K' := new()\n                  /\\ SND_AS({K'.Na'}_Ka.{K'.Na'.A}_Kb)\n                  /\\ secret(K',k,{A,B,S})\nend role\n\n\nrole bob (A, S, B : agent,\n          Kb      : symmetric_key,\n          SND_AB, RCV_AB : channel(dy))\n\nplayed_by B def=\n     local State  : nat,\n           Na,Nb  : text,\n           K      : symmetric_key\n     init  State := 5\n\n     transition\n     1. State  = 5 /\\ RCV_AB({K'.Na'.A}_Kb) =|>\n        State':= 7 /\\ Nb' := new()\n                   /\\ SND_AB({Na'.Nb'}_K')\n                   /\\ witness(A,B,alice_bob_na,Na') \n                   \n     2. State  = 7 /\\ RCV_AB({Nb.Na}_K) =|>\n        State':= 9 /\\ request(B,A,bob_alice_nb,Nb) % B verifies that A knows K (A can decrpyt and encrypt again Nb)\n                   \nend role\n\n\nrole session(A, S, B : agent,\n             Ka, Kb  : symmetric_key)\ndef=\n     local\n        SSA, RSA,\n        SBA, RBA,\n        SAS, RAS,\n        SAB, RAB : channel (dy)\n\n     composition\n              alice (A, S, B, Ka, SSA, RSA, SBA, RBA)\n          /\\  server(A, S, B, Ka, Kb, SAS, RAS)\n          /\\  bob   (A, S, B, Kb, SAB, RAB)\nend role\n\n\nrole environment()\ndef=\n      const a, b, s         : agent,\n            ka, kb, ki      : symmetric_key,\n            alice_bob_na, bob_alice_nb, k : protocol_id\n\n      intruder_knowledge = {a, b, s, ki}\n\n      composition         \n              session(a,s,b,ka,kb)\n           /\\ session(a,s,i,ka,ki)\n           /\\ session(i,s,b,ki,kb)\n           /\\ session(i,s,a,ki,ka)\nend role\n\n\ngoal\n    secrecy_of k\n    authentication_on alice_bob_na\n    authentication_on bob_alice_nb\nend goal\n\nenvironment()", "```hlpsl\n% A -> S: ({A.B.Na}_Ka)  % Ka is a key shared by A and S\n% A <- S: ({K.Na}_Ka.  % S generates new key K \n%                      % {K.Na}_Ka does not need Na, but it helps A identify the session for the key K\n%          {K.Na.A}_Kb)  % A cannot decrypt the contents of {K.Na.Ns}_Kb, but is able to forward it to B\n%                        % if A is not encrypted with Kb, the attacker will be able to pretend to be A when contacting B\n% A -> B: ({K.Na.A}_Kb)  % The last part is a key confirmation\n% A <- B: ({Na.Nb}_K)  % A tests if B knows K during this session, by using Na\n% A -> B: ({Nb.Na}_K)  % B tests if A knows K during this session, by using Nb\n%                      % Na is not necessary, but it helps B identify the session when receiving Nb\n\nrole alice (A, S, B : agent,\n\t    Ka      : symmetric_key,\n\t    SND_SA, RCV_SA, SND_BA, RCV_BA : channel(dy))\n\nplayed_by A def=\n    local State  : nat,\n          Na,Nb : text,\n          K     : symmetric_key,\n          X     : {symmetric_key.text.agent}_symmetric_key\n    init State := 0\n\n    transition\n    1. State  = 0 /\\ RCV_BA(start) =|>\n       State':= 2 /\\ Na' := new()\n                  /\\ SND_SA({A.B.Na'}_Ka)\n\n    2. State  = 2 /\\ RCV_SA({K'.Na}_Ka.X') =|>\n       State':= 4 /\\ SND_BA(X')\n\n    3. State  = 4 /\\ RCV_BA({Na.Nb'}_K) =|>\n       State':= 6 /\\ SND_BA({Nb'.Na}_K)\n                  /\\ request(A,B,alice_bob_na,Na) % A verifies that B knows K (B can decrpyt and encrypt again Na)\n                  /\\ witness(B,A,bob_alice_nb,Nb') \nend role\n\n\nrole server (A, S, B  : agent,\n             Ka, Kb   : symmetric_key,\n             SND_AS, RCV_AS : channel(dy))\n\nplayed_by S def=\n    local State : nat,\n          Na    : text,\n          K     : symmetric_key\n    init  State := 1\n\n    transition\n    1. State  = 1 /\\ RCV_AS({A.B.Na'}_Ka) =|>\n       State':= 3 /\\ K' := new()\n                  /\\ SND_AS({K'.Na'}_Ka.{K'.Na'.A}_Kb)\n                  /\\ secret(K',k,{A,B,S})\nend role\n\n\nrole bob (A, S, B : agent,\n          Kb      : symmetric_key,\n          SND_AB, RCV_AB : channel(dy))\n\nplayed_by B def=\n     local State  : nat,\n           Na,Nb  : text,\n           K      : symmetric_key\n     init  State := 5\n\n     transition\n     1. State  = 5 /\\ RCV_AB({K'.Na'.A}_Kb) =|>\n        State':= 7 /\\ Nb' := new()\n                   /\\ SND_AB({Na'.Nb'}_K')\n                   /\\ witness(A,B,alice_bob_na,Na') \n                   \n     2. State  = 7 /\\ RCV_AB({Nb.Na}_K) =|>\n        State':= 9 /\\ request(B,A,bob_alice_nb,Nb) % B verifies that A knows K (A can decrpyt and encrypt again Nb)\n                   \nend role\n\n\nrole session(A, S, B : agent,\n             Ka, Kb  : symmetric_key)\ndef=\n     local\n        SSA, RSA,\n        SBA, RBA,\n        SAS, RAS,\n        SAB, RAB : channel (dy)\n\n     composition\n              alice (A, S, B, Ka, SSA, RSA, SBA, RBA)\n          /\\  server(A, S, B, Ka, Kb, SAS, RAS)\n          /\\  bob   (A, S, B, Kb, SAB, RAB)\nend role\n\n\nrole environment()\ndef=\n      const a, b, s         : agent,\n            ka, kb, ki      : symmetric_key,\n            alice_bob_na, bob_alice_nb, k : protocol_id\n\n      intruder_knowledge = {a, b, s, ki}\n\n      composition         \n              session(a,s,b,ka,kb)\n           /\\ session(a,s,i,ka,ki)\n           /\\ session(i,s,b,ki,kb)\n           /\\ session(i,s,a,ki,ka)\nend role\n\n\ngoal\n    secrecy_of k\n    authentication_on alice_bob_na\n    authentication_on bob_alice_nb\nend goal\n\nenvironment()\n```"]], "HLPSL-1/StrongAuthenticationPropertyofAlicetoBob.hlpsl": [[true, "%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (A,B,bob_alice_NA,Nb')\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ request (A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (A,B,bob_alice_NA,Nb')\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ request (A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/strongAuthentication_xor.hlpsl": [[true, "%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nonce,SND:channel(dy)\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND(Na')\n\t\t2. State=1 /\\ RCV(xor(Na',S)) =|> State':=2\n\n               %% A checks that B is the emitter of nonce\n        /\\ request(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:nonce\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(Na')  =|> State':=1 /\\ SND(xor(Na',S))\n                \n        /\\ secret(S,sec_1,{A,B}) \n                %% B Check the authentication of nonce\n        /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2) /\\ role_A(A,B,S,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t    alice,bob:agent,\n        s1:text,\n        sec_1,sec_2,auth_1:protocol_id\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n        %% add another session for replay attack\n\t\tsession(alice,bob,s1) /\\ session(alice,bob,s1)\nend role\n\ngoal \n    secrecy_of sec_1   \n    secrecy_of sec_2\n    %%  weak_authentication_on auth_1 , wrequest\n    authentication_on auth_1\nend goal\n\nenvironment()", "```hlpsl\n%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,S:text,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nonce,SND:channel(dy)\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND(Na')\n\t\t2. State=1 /\\ RCV(xor(Na',S)) =|> State':=2\n\n               %% A checks that B is the emitter of nonce\n        /\\ request(A,B,auth_1,Na') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:nonce\n\tinit\n\t\tState := 0\n\ttransition\n        1. State=0 /\\ RCV(Na')  =|> State':=1 /\\ SND(xor(Na',S))\n                \n        /\\ secret(S,sec_1,{A,B}) \n                %% B Check the authentication of nonce\n        /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2) /\\ role_A(A,B,S,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t    alice,bob:agent,\n        s1:text,\n        sec_1,sec_2,auth_1:protocol_id\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n        %% add another session for replay attack\n\t\tsession(alice,bob,s1) /\\ session(alice,bob,s1)\nend role\n\ngoal \n    secrecy_of sec_1   \n    secrecy_of sec_2\n    %%  weak_authentication_on auth_1 , wrequest\n    authentication_on auth_1\nend goal\n\nenvironment()\n```"]], "HLPSL-1/typedvariableNA.hlpsl": [[true, "%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, Ka,Kb : public_key, Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat, Na,Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na')\n\nend role\n\n\n \nrole bob (B,A : agent,  Kb,Ka : public_key,  Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na,Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na,A)}_Ka)\n                    /\\ request(A,B,bob_alice_NA,Na)\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, Ka,Kb : public_key, Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat, Na,Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na')\n\nend role\n\n\n \nrole bob (B,A : agent,  Kb,Ka : public_key,  Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na,Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na,A)}_Ka)\n                    /\\ request(A,B,bob_alice_NA,Na)\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/unsafe_one_sym_key.hlpsl": [[true, "% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(A, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientServerKey: hash(text.text.hash(text.text.text)), % Keygen(Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text),\n\t\tPb: text\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid'.Pb'.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na'.Nb'.Pa'.Sid')\n       \t\t   /\\ ClientServerKey' := KeyGen(Na'.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientServerKey') % 6. A -> B: {Finished}Keygen(Na, Nb, M) \n       \t\t   /\\ witness(A,B,bob_alice_na_nb,Na'.Nb')\n\n   4.  State = 4   /\\ RCV({H(M'.A.B.Na'.Nb'.Pa'.Sid')}_ClientServerKey') =|> % 7. B -> A: {Finished}Keygen(Na, Nb, M)\n       State' := 6 /\\ request(A,B,alice_bob_na_nb,Na'.Nb')\n\t\t   /\\ secret(ClientServerKey',secrecyClientServerK,{A,B})\n       \t\t   \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNb, Sid, Pb, PMS: text,\n\tState: nat,\n        Ka: public_key,\n\t\tPa, Na: text\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pb'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   2.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(Na'.Nb'.PRF(PMS'.Na'.Nb'))) =|> % }Keygen(Na, Nb, M) \n       State' := 5 /\\ SND({H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 7. B -> A: {Finished\n              \t\t}_KeyGen(Na'.Nb'.PRF(PMS'.Na'.Nb'))) % }Keygen(Na, Nb, M)\n       \t\t   /\\ request(B,A,bob_alice_na_nb,Na'.Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const\n\tsecrecyClientServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(A, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientServerKey: hash(text.text.hash(text.text.text)), % Keygen(Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text),\n\t\tPb: text\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid'.Pb'.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na'.Nb'.Pa'.Sid')\n       \t\t   /\\ ClientServerKey' := KeyGen(Na'.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientServerKey') % 6. A -> B: {Finished}Keygen(Na, Nb, M) \n       \t\t   /\\ witness(A,B,bob_alice_na_nb,Na'.Nb')\n\n   4.  State = 4   /\\ RCV({H(M'.A.B.Na'.Nb'.Pa'.Sid')}_ClientServerKey') =|> % 7. B -> A: {Finished}Keygen(Na, Nb, M)\n       State' := 6 /\\ request(A,B,alice_bob_na_nb,Na'.Nb')\n\t\t   /\\ secret(ClientServerKey',secrecyClientServerK,{A,B})\n       \t\t   \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNb, Sid, Pb, PMS: text,\n\tState: nat,\n        Ka: public_key,\n\t\tPa, Na: text\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pb'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   2.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(Na'.Nb'.PRF(PMS'.Na'.Nb'))) =|> % }Keygen(Na, Nb, M) \n       State' := 5 /\\ SND({H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 7. B -> A: {Finished\n              \t\t}_KeyGen(Na'.Nb'.PRF(PMS'.Na'.Nb'))) % }Keygen(Na, Nb, M)\n       \t\t   /\\ request(B,A,bob_alice_na_nb,Na'.Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const\n\tsecrecyClientServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/unsafe_wo_cert_check.hlpsl": [[true, "% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(\n\tA, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text),\n        Pb: text\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid'.Pb'.B.{B.Kb'}_inv(Ks)) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: B, Kb\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Nb'.Pa'.Sid')\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_inv(Ks). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_inv(Ka). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientK') % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ witness(A,B,alice_bob_na_nb,Na'.Nb')\n\n   4.  State = 4   /\\ RCV({H(PRF(PMS'.Na.Nb').A.B.Na.Pa'.Sid')}_ServerK') =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(A,B,bob_alice_na_nb,Na.Nb')\n       \t\t   /\\ secret(ClientK',secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK',secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(\n\tA, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key,\n        Pb: text,\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n        M: hash(text.text.text)\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.B.{B.Kb}_inv(Ks)) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_inv(Ks). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_inv(Ka'). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na'.Nb'.PRF(PMS'.Na'.Nb'))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ M' := PRF(PMS'.Na'.Nb')\n               /\\ ClientK' := KeyGen(A.Na'.Nb'.M')\n               /\\ ServerK' := KeyGen(B.Na'.Nb'.M')\n               /\\ Finished' := H(M'.A.B.Na'.Nb'.Pa'.Sid')\n       \t\t   /\\ SND({Finished'}_ServerK') % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(B,A,bob_alice_na_nb,Na'.Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b, i            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_inv(ks), h, prf, keygen}  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(\n\tA, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text),\n        Pb: text\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid'.Pb'.B.{B.Kb'}_inv(Ks)) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: B, Kb\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Nb'.Pa'.Sid')\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_inv(Ks). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_inv(Ka). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientK') % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ witness(A,B,alice_bob_na_nb,Na'.Nb')\n\n   4.  State = 4   /\\ RCV({H(PRF(PMS'.Na.Nb').A.B.Na.Pa'.Sid')}_ServerK') =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(A,B,bob_alice_na_nb,Na.Nb')\n       \t\t   /\\ secret(ClientK',secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK',secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(\n\tA, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key,\n        Pb: text,\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n        M: hash(text.text.text)\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.B.{B.Kb}_inv(Ks)) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_inv(Ks). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_inv(Ka'). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na'.Nb').A.B.Na'.Pa'.Sid') % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na'.Nb'.PRF(PMS'.Na'.Nb'))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ M' := PRF(PMS'.Na'.Nb')\n               /\\ ClientK' := KeyGen(A.Na'.Nb'.M')\n               /\\ ServerK' := KeyGen(B.Na'.Nb'.M')\n               /\\ Finished' := H(M'.A.B.Na'.Nb'.Pa'.Sid')\n       \t\t   /\\ SND({Finished'}_ServerK') % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(B,A,bob_alice_na_nb,Na'.Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b, i            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_inv(ks), h, prf, keygen}  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/untypedvariableNa.hlpsl": [[true, "%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local Na : nat, ID : text set, Secret : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n                    /\\ witness (A,B,alice_bob_NA,Na')\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : text set, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ wrequest(A,B,alice_bob_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{A,B})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA, alice_bob_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local Na : nat, ID : text set, Secret : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n                    /\\ witness (A,B,alice_bob_NA,Na')\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : text set, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ wrequest(A,B,alice_bob_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{A,B})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA, alice_bob_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/weakAuthenticationfromAlicetoBob.hlpsl": [[true, "%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Snd(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({A.Na'}_Kb)\n                    /\\ event(initiates(A,B,Na',{A,B}))\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,Nb')}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({A'.Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ request(A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{A,B})\n  \n\n\n    2. State=1 /\\ Rcv({Nb'}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Snd(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({A.Na'}_Kb)\n                    /\\ event(initiates(A,B,Na',{A,B}))\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,Nb')}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({A'.Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ request(A,B,bob_alice_NA,Na')\n\t\t\t/\\ secret(Nb',snb,{A,B})\n  \n\n\n    2. State=1 /\\ Rcv({Nb'}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/woolamProtocol.hlpsl": [[true, "% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ SNDA({A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Kab')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ SNDB(X'.{A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{Na.Nb}_Kab') =|>\n           State' :=3 /\\ SNDB(Y'.{Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ request(B,A,kab_id,Kab)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, B, S : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n  def=\n  const i, a, b, s : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n\t  session(a,b,s,kas,kbs,kab)\n    /\\session(a,i,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on kab_id\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "```hlpsl\n% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ SNDA({A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Kab')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ SNDB(X'.{A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{Na.Nb}_Kab') =|>\n           State' :=3 /\\ SNDB(Y'.{Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ request(B,A,kab_id,Kab)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, B, S : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n  def=\n  const i, a, b, s : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n\t  session(a,b,s,kas,kbs,kab)\n    /\\session(a,i,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on kab_id\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/XorNSPK_2.hlpsl": [[true, "%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     State  : nat, \n     Na    : message, \n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start) =|>\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ secret(Na', secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb'}_Kb)\n\nend role\n\n\n \nrole bob (A,B     : agent,  \n          Ka,Kb   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     State : nat, \n     Na    : message, \n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na'.A'}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ secret(Nb', secret_nb,{A,B})\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(A,B,Ka,Kb,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na, secret_nb : protocol_id\n\n\n\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na \n     /\\ secrecy_of secret_nb\n\nend goal\n\n\n\nenvironment()", "```hlpsl\n%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     State  : nat, \n     Na    : message, \n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start) =|>\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ secret(Na', secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na',B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb'}_Kb)\n\nend role\n\n\n \nrole bob (A,B     : agent,  \n          Ka,Kb   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     State : nat, \n     Na    : message, \n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na'.A'}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ secret(Nb', secret_nb,{A,B})\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(A,B,Ka,Kb,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na, secret_nb : protocol_id\n\n\n\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na \n     /\\ secrecy_of secret_nb\n\nend goal\n\n\n\nenvironment()\n```"]], "HLPSL-1/xsulak04.hlpsl": [[true, "role role_A(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tT:text,Kas:symmetric_key,Kbs:symmetric_key,Ts:text,Kab:symmetric_key,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND(A.B)\n\t\t2. State=1 /\\ RCV({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas') =|> State':=2 /\\ witness(A,B,sec_1,Kab') /\\ SND({Kab'.A.T'}_Kbs')\n\t\t4. State=2 /\\ RCV({Nb'}_Kab') =|> State':=3 /\\ secret(Nb',sec_2,{A,B}) /\\ SND({Dec(Nb')}_Kab)\nend role\n\nrole role_B(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Kbs:symmetric_key,T:text,Kab:symmetric_key,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV({Kab'.A.T'}_Kbs') =|> State':=1 /\\ secret(Kab',sec_1,{A,B,S}) /\\ Nb':=new() /\\ SND({Nb'}_Kab')\n\t\t5. State=1 /\\ RCV({Dec(Nb)}_Kab') =|> State':=2 /\\ secret(Kab',sec_3,{A,B})\nend role\n\nrole role_S(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tState:nat,Kas:symmetric_key,T:text,Kbs:symmetric_key,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(A.B) =|> State':=1 /\\ Kas':=new() /\\ Kbs':=new() /\\ T':=new() /\\ Kab':=new() /\\ request(A,B,sec_1,Kab') /\\ SND({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas')\nend role\n\nrole session1(A:agent,B:agent,S:agent,Dec:hash_func)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(A,B,S,Dec,SND3,RCV3) /\\ role_B(A,B,S,Dec,SND2,RCV2) /\\ role_A(A,B,S,Dec,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,sec_3:protocol_id,alice:agent,bob:agent,dec:hash_func,sec_2:protocol_id,sec_1:protocol_id,server:agent\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(alice,bob,server,dec)\nend role\n\ngoal\n\tsecrecy_of sec_1\nend goal\n\nenvironment()", "```hlpsl\nrole role_A(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tT:text,Kas:symmetric_key,Kbs:symmetric_key,Ts:text,Kab:symmetric_key,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND(A.B)\n\t\t2. State=1 /\\ RCV({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas') =|> State':=2 /\\ witness(A,B,sec_1,Kab') /\\ SND({Kab'.A.T'}_Kbs')\n\t\t4. State=2 /\\ RCV({Nb'}_Kab') =|> State':=3 /\\ secret(Nb',sec_2,{A,B}) /\\ SND({Dec(Nb')}_Kab)\nend role\n\nrole role_B(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Kbs:symmetric_key,T:text,Kab:symmetric_key,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV({Kab'.A.T'}_Kbs') =|> State':=1 /\\ secret(Kab',sec_1,{A,B,S}) /\\ Nb':=new() /\\ SND({Nb'}_Kab')\n\t\t5. State=1 /\\ RCV({Dec(Nb)}_Kab') =|> State':=2 /\\ secret(Kab',sec_3,{A,B})\nend role\n\nrole role_S(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tState:nat,Kas:symmetric_key,T:text,Kbs:symmetric_key,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(A.B) =|> State':=1 /\\ Kas':=new() /\\ Kbs':=new() /\\ T':=new() /\\ Kab':=new() /\\ request(A,B,sec_1,Kab') /\\ SND({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas')\nend role\n\nrole session1(A:agent,B:agent,S:agent,Dec:hash_func)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(A,B,S,Dec,SND3,RCV3) /\\ role_B(A,B,S,Dec,SND2,RCV2) /\\ role_A(A,B,S,Dec,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,sec_3:protocol_id,alice:agent,bob:agent,dec:hash_func,sec_2:protocol_id,sec_1:protocol_id,server:agent\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(alice,bob,server,dec)\nend role\n\ngoal\n\tsecrecy_of sec_1\nend goal\n\nenvironment()\n```"]]}