{"SPDL-1/2r890-ex3-a.spdl": [[true, "/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(I,X,Y)\n{\n\trole I\n\t{\n\t\tfresh nx: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(I,X, nx );\n\t\trecv_2(X,I, { I,nx }sk(X) );\n\t\tsend_3(I,Y, ny );\n\t\trecv_4(Y,I, { ny,I }sk(Y) );\n\n\t\tclaim_i1(I,Niagree);\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar nx: Nonce;\n\n\t\trecv_1(I,X, nx );\n\t\tsend_2(X,I, { I,nx }sk(X) );\n\t}\n\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(I,Y, ny );\n\t\tsend_4(Y,I, { ny,I }sk(Y) );\n\t}\n}", "```spdl\n/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(I,X,Y)\n{\n\trole I\n\t{\n\t\tfresh nx: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(I,X, nx );\n\t\trecv_2(X,I, { I,nx }sk(X) );\n\t\tsend_3(I,Y, ny );\n\t\trecv_4(Y,I, { ny,I }sk(Y) );\n\n\t\tclaim_i1(I,Niagree);\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar nx: Nonce;\n\n\t\trecv_1(I,X, nx );\n\t\tsend_2(X,I, { I,nx }sk(X) );\n\t}\n\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(I,Y, ny );\n\t\tsend_4(Y,I, { ny,I }sk(Y) );\n\t}\n}\n```"]], "SPDL-1/AccessRequestEvaluation_CRCBAC.spdl": [[true, "hashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp,sk;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (Da,GW){\n\nrole Da{\n\nfresh T1:Nonce;\n\nvar T2:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (Da,GW,M,T1);\n\nrecv_2(GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(Da,Secret,SKa);\n\nclaim(Da,Alive);\n\nclaim(Da,Weakagree);\n\nclaim(Da,Niagree);\n\nclaim(Da,Nisynch);}\n\nrole GW{\n\nfresh T2:Nonce; \n\nvar T1:Nonce; \n\nconst IDa,sk;\n\nrecv_1(Da,GW,M,T1);\n\nsend_2 (GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(GW,Alive);\n\nclaim(GW,Weakagree);\n\nclaim(GW,Niagree);\n\nclaim(GW,Nisynch);\n\nclaim(GW,Secret,SKa);}\n\n  }", "```spdl\nhashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp,sk;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (Da,GW){\n\nrole Da{\n\nfresh T1:Nonce;\n\nvar T2:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (Da,GW,M,T1);\n\nrecv_2(GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(Da,Secret,SKa);\n\nclaim(Da,Alive);\n\nclaim(Da,Weakagree);\n\nclaim(Da,Niagree);\n\nclaim(Da,Nisynch);}\n\nrole GW{\n\nfresh T2:Nonce; \n\nvar T1:Nonce; \n\nconst IDa,sk;\n\nrecv_1(Da,GW,M,T1);\n\nsend_2 (GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(GW,Alive);\n\nclaim(GW,Weakagree);\n\nclaim(GW,Niagree);\n\nclaim(GW,Nisynch);\n\nclaim(GW,Secret,SKa);}\n\n  }\n```"]], "SPDL-1/boyd.spdl": [[true, "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}", "```spdl\nusertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}\n```"]], "SPDL-1/CapabilityRevocation_CRCBAC.spdl": [[true, "hashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, GW) \n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var T2:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, GW, M);\n\n    recv_2(GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(Da, Secret, SKa);\n\n    claim(Da, Alive);\n\n    claim(Da, Weakagree);\n\n    claim(Da, Niagree);\n\n    claim(Da, Nisynch);\n\n}\n\nrole GW {\n\n    fresh T2:Nonce; \n\n    var T1:Nonce; \n\n    secret IDa;\n\n    recv_1(Da, GW, M);\n\n    macro M' = XOR(M,h(SKa));\n\n    macro rgb=getRoles(IDb,ctxb);\n\n    macro rga=getRoles(IDa,ctxa);\n\n    macro ver = Roleheirarchy(rgb,rga);\n\n    macro Cb= getCapabilities(rgb);\n\n    macro rgb =sub(rgb,c');\n\n    send_2 (GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(GW, Alive);\n\n    claim(GW, Weakagree);\n\n    claim(GW, Niagree);\n\n    claim(GW, Nisynch);\n\n    claim(GW, Secret, SKa);\n\n} \n\n}", "```spdl\nhashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, GW) \n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var T2:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, GW, M);\n\n    recv_2(GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(Da, Secret, SKa);\n\n    claim(Da, Alive);\n\n    claim(Da, Weakagree);\n\n    claim(Da, Niagree);\n\n    claim(Da, Nisynch);\n\n}\n\nrole GW {\n\n    fresh T2:Nonce; \n\n    var T1:Nonce; \n\n    secret IDa;\n\n    recv_1(Da, GW, M);\n\n    macro M' = XOR(M,h(SKa));\n\n    macro rgb=getRoles(IDb,ctxb);\n\n    macro rga=getRoles(IDa,ctxa);\n\n    macro ver = Roleheirarchy(rgb,rga);\n\n    macro Cb= getCapabilities(rgb);\n\n    macro rgb =sub(rgb,c');\n\n    send_2 (GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(GW, Alive);\n\n    claim(GW, Weakagree);\n\n    claim(GW, Niagree);\n\n    claim(GW, Nisynch);\n\n    claim(GW, Secret, SKa);\n\n} \n\n}\n```"]], "SPDL-1/carkey-ni.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\n```"]], "SPDL-1/ccitt509-ban.spdl": [[true, "usertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(I,R)\n{\n\trole I\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\trecv_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\tsend_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_4(I,Secret,yi);\n\t\tclaim_5(I,Secret,yr);\n\t\tclaim_6(I,Nisynch);\n\t\tclaim_7(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar xi,yi: Data;\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh yr,xr: Data;\n\n\t\trecv_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\tsend_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\trecv_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_8(R,Secret,yi);\n\t\tclaim_9(R,Secret,yr);\n\t\tclaim_10(R,Nisynch);\n\t\tclaim_11(R,Niagree);\n\t}\n}\n\nconst de: Data;", "```spdl\nusertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(I,R)\n{\n\trole I\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\trecv_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\tsend_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_4(I,Secret,yi);\n\t\tclaim_5(I,Secret,yr);\n\t\tclaim_6(I,Nisynch);\n\t\tclaim_7(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar xi,yi: Data;\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh yr,xr: Data;\n\n\t\trecv_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\tsend_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\trecv_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_8(R,Secret,yi);\n\t\tclaim_9(R,Secret,yr);\n\t\tclaim_10(R,Nisynch);\n\t\tclaim_11(R,Niagree);\n\t}\n}\n\nconst de: Data;\n```"]], "SPDL-1/cotes_de_porc-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\trecv_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\tsend_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\trecv_3(I, R, n2);\n\t}\n}", "To complete the given SPDL code based on the provided description, let's fill in the blanks accordingly.\n\n\nThe Initiator role is denoted as \"I\" and the Responder role as \"R\". The fresh nonce generated by the Initiator is \"n1\". The variables and roles should be matched with the description given.\n\n```spdl\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\trecv_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\tsend_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\trecv_3(I, R, n2);\n\t}\n}\n```\n\nThe completed code can be seen above, where:\n- `____(ROLE_1)____` is replaced with `I`.\n- `____(ENCRYPTED_1)____` is replaced with `n1`.\nThis is based on the protocol description that explains the roles and actions of the Initiator and Responder."]], "SPDL-1/DHKE-1.spdl": [[true, "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}", "```spdl\n/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}\n```"]], "SPDL-1/encryption2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nsecret k: Function;\n\nhashfunction hash, MAC, KDF;\nusertype UID, Timestamp, Amount;\n\nmacro Kcm = KDF(k(M, C), Nm, Nc);\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(ROLE_1, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(ROLE_1);\n\nprotocol EncryptionProtocol2(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh a: Amount;\n\t\tfresh Nm, r: Nonce;\n\t\tfresh IDm: UID;\n\t\tvar Nc: Nonce;\n\t\tvar IDc: UID;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\n\t\tsend_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\trecv_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Send encrypted transaction request to customer\n\t\t*/\n\t\tsend_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_5 (B,M, { IDt, a, r, t, Sb }k(M,B) );\n\n\t\tclaim (M, Secret, IDm);\n\t\tclaim (M, Secret, a);\n\t\tclaim (M, Secret, r);\n\t\tclaim (M, Secret, Kcm);\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tfresh Nc: Nonce;\n\t\tfresh IDc: UID;\n\t\tvar IDm: UID;\n\t\tvar Nm, r: Nonce;\n\t\tvar t: Timestamp;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Authenticated key exchange with the merchant\n\t\t*/ \n\n\t\trecv_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\tsend_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Receive encrypted transaction request from merchant\n\t\t*/\n\t\trecv_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Send encrypted transaction confirmation to bank\n\t\t*/\n\t\tsend_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_6 (B, C, { IDt, a, r, t, Sb }k(C,B) );\n\n\t\tclaim (C, Secret, Kcm);\n\t\tclaim (C, Secret, IDc);\n\t\tclaim (C, Secret, Sc);\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar IDc, IDm: UID;\n\t\tvar r: Nonce;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Receive encrypted transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send encrypted payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_5 (B, M, { IDt, a, r, t, Sb }k(M, B) );\n\t\tsend_6 (B, C, { IDt, a, r, t, Sb }k(C, B) );\n\n\t\tclaim (B, Secret, IDt);\n\t\tclaim (B, Secret, t);\n\t\tclaim (B, Secret, Sb);\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nsecret k: Function;\n\nhashfunction hash, MAC, KDF;\nusertype UID, Timestamp, Amount;\n\nmacro Kcm = KDF(k(M, C), Nm, Nc);\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(ROLE_1, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(ROLE_1);\n\nprotocol EncryptionProtocol2(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh a: Amount;\n\t\tfresh Nm, r: Nonce;\n\t\tfresh IDm: UID;\n\t\tvar Nc: Nonce;\n\t\tvar IDc: UID;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\n\t\tsend_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\trecv_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Send encrypted transaction request to customer\n\t\t*/\n\t\tsend_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_5 (B,M, { IDt, a, r, t, Sb }k(M,B) );\n\n\t\tclaim (M, Secret, IDm);\n\t\tclaim (M, Secret, a);\n\t\tclaim (M, Secret, r);\n\t\tclaim (M, Secret, Kcm);\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tfresh Nc: Nonce;\n\t\tfresh IDc: UID;\n\t\tvar IDm: UID;\n\t\tvar Nm, r: Nonce;\n\t\tvar t: Timestamp;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Authenticated key exchange with the merchant\n\t\t*/ \n\n\t\trecv_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\tsend_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Receive encrypted transaction request from merchant\n\t\t*/\n\t\trecv_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Send encrypted transaction confirmation to bank\n\t\t*/\n\t\tsend_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_6 (B, C, { IDt, a, r, t, Sb }k(C,B) );\n\n\t\tclaim (C, Secret, Kcm);\n\t\tclaim (C, Secret, IDc);\n\t\tclaim (C, Secret, Sc);\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar IDc, IDm: UID;\n\t\tvar r: Nonce;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Receive encrypted transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send encrypted payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_5 (B, M, { IDt, a, r, t, Sb }k(M, B) );\n\t\tsend_6 (B, C, { IDt, a, r, t, Sb }k(C, B) );\n\n\t\tclaim (B, Secret, IDt);\n\t\tclaim (B, Secret, t);\n\t\tclaim (B, Secret, Sb);\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}\n```"]], "SPDL-1/en_y-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\trecv_2(R, I, {n2, R}pk(I), n1);\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\tsend_2(R, I, {n2, R}pk(I), n1);\n\t\trecv_3(I, R, n2);\n\t}\n}", "To complete the given SPDL code for the `myProtocol` protocol based on the provided description, we need to fill in the missing parts indicated by `____()___`. Let's analyze the description and fill in the required information step by step.\n\n1. **Protocol Name and Roles**: The protocol is named `myProtocol`, and it involves two roles: the Initiator (`I`) and the Responder (`R`). So, `____(ROLE_1)____` should be replaced with `R`.\n\n2. **Variables and Nonces**: The Initiator generates a fresh secret (`sec`) and a nonce (`n1`), and receives a nonce (`n2`) from the Responder. Thus, `____(NONCE_1)____` should be `n2`.\n\n3. **Message Exchange**: The messages exchanged are as per the description. The first message from `I` to `R` contains `{sec, I}pk(R), h(sec), {n1}pk(R)`. So, `____(ROLE_1)____` in the `send_1` and `recv_1` statements should be `R`.\n\n4. **Responder's Role**: The Responder (`R`) receives the first message, generates a fresh nonce (`n2`), and sends `{n2, R}pk(I), n1` back to `I`. Thus, the Responder's role should be filled accordingly.\n\nLet's complete the SPDL code:\n\n```spdl\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\trecv_2(R, I, {n2, R}pk(I), n1);\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\tsend_2(R, I, {n2, R}pk(I), n1);\n\t\trecv_3(I, R, n2);\n\t}\n}\n```\n\nThe completed SPDL code is between ```spdl and ```:\n```spdl\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\trecv_2(R, I, {n2, R}pk(I), n1);\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\tsend_2(R, I, {n2, R}pk(I), n1);\n\t\trecv_3(I, R, n2);\n\t}\n}\n```"]], "SPDL-1/exchange-hash.spdl": [[true, "/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\n\n// Protocol description\n\nprotocol protocol2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_i1 (I, Secret, kir );\n\t\tclaim_i2 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Key;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_r1 (R, Secret, kir );\n\t\tclaim_r2 (R, Nisynch );\n\t}\n}", "```spdl\n/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\n\n// Protocol description\n\nprotocol protocol2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_i1 (I, Secret, kir );\n\t\tclaim_i2 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Key;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_r1 (R, Secret, kir );\n\t\tclaim_r2 (R, Nisynch );\n\t}\n}\n```"]], "SPDL-1/five-run-bound.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,R)\n{\n\trole R\n\t{\n\t\tvar k1: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,R, ni );\n\t\tsend_!2 (R,I, { ni }sk(R) );\n\t\trecv_!3 (I,R, {{{ {k1}pk(R) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (R,I, {k2}k1 );\n\n\t\tclaim_6 (R, Secret, k2);\n\t}\n}", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,R)\n{\n\trole R\n\t{\n\t\tvar k1: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,R, ni );\n\t\tsend_!2 (R,I, { ni }sk(R) );\n\t\trecv_!3 (I,R, {{{ {k1}pk(R) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (R,I, {k2}k1 );\n\n\t\tclaim_6 (R, Secret, k2);\n\t}\n}\n```"]], "SPDL-1/andrew-ban-1.spdl": [[true, "# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {ni,nr}k(I,R) );\n        send_3(I,R, {nr}k(I,R) );\n        recv_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Niagree);\n        claim_I3(I,Secret, kir);\n        claim_I5(I,Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {ni,nr}k(I,R) );\n        recv_3(I,R, {nr}k(I,R) );\n        send_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Niagree);\n        claim_R3(R,Secret, kir);\n        claim_R5(R,Empty, (Fresh,kir));\n    }\n}", "```spdl\n# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {ni,nr}k(I,R) );\n        send_3(I,R, {nr}k(I,R) );\n        recv_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Niagree);\n        claim_I3(I,Secret, kir);\n        claim_I5(I,Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {ni,nr}k(I,R) );\n        recv_3(I,R, {nr}k(I,R) );\n        send_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Niagree);\n        claim_R3(R,Secret, kir);\n        claim_R5(R,Empty, (Fresh,kir));\n    }\n}\n```"]], "SPDL-1/Fortified-Chain2.spdl": [[true, "const E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\n\nprotocol Fortified-Chain2(DeviceA,Edge,DeviceB)\n{\nrole DeviceA {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh RNa:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUa:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\nrecv_!2(Edge,DeviceA,P1);\n\nrecv_!4(DeviceB,DeviceA,Q1);\n\nmacro V0 = E(PUedge,H(IDdev));\nmacro Temp = H(RIa);\nmacro Temp1 = E(PRa,Temp);\nmacro DIsig = APN(Temp1,RIa);\nmacro V1 = E(PUb,RNa,MATdiv,IDa,DIsig);\nmacro V2 = D(PRa,SessionKey,IDb,DIsigb,Timestamp);\nmacro V3 = E(SessionKey,msg);\nmacro V4 =  D(PRa,IDa,RIa,GIid,SIid,MATdiv);\n\nsend_!1(DeviceA,Edge,V0);\nsend_!5(DeviceA,DeviceB,V1,V3);\nclaim_DeviceA2(DeviceA,Secret,SessionKey);\nclaim_DeviceA3(DeviceA,Niagree);\nclaim_DeviceA4(DeviceA, Nisynch);\n}\nrole Edge {\nfresh PRedge,PUedge,PUa,PUb:key;\nfresh RNhc,MATdiv,GIid,SIid:Nonce;\nconst IDhc,RIa,IDa,RIa1,Hdev,MATdivb,MATdiv,RIb,IDb;\nconst P0,P1,P2;\nconst IDdev;\nrecv_!1(DeviceA,Edge,V0);\n\nmacro P0 = D(PRedge,H(IDdev));\nmacro Hdev = H(IDdev);\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\nmacro RIa = H(RIa1);\nmacro IDa = XOR(RIa,Hdev);\nmacro  P1 = E(PUa,IDa,RIa,GIid,SIid,MATdiv);\nmacro P2 = E(PUb,IDb,RIb,GIid,SIid,MATdivb);\nsend_!2(Edge,DeviceA,P1);\nsend_!3(Edge,DeviceB,P2);\nclaim_Edge2(Edge,Secret,PRedge);\nclaim_Edge3(Edge,Niagree);\nclaim_Edge4(Edge,Nisynch);\n}\n\nrole DeviceB {\nfresh PRb,PUedge,PUa,PUb,DIsigb:key;\nfresh RNb:Nonce;\nconst IDdevb,DIsigb,MATdivb,Q1,Q2,Q3,Q4,MATdivb,MATdiv,IDb;\nfresh RIb,RIa,RNb:Nonce;\nconst Temp2,Temp3,msg,RNa;\nfresh SessionKey,Timestamp:key;\nrecv_!3(Edge,DeviceB,P2);\n\nrecv_!5(DeviceA,DeviceB,V1,V3);\n\n\nmacro Temp3 = D(PUa,DIsig);\n\nmacro Temp2 = H(RIa); \n\n\nmacro Q2 = D(PRb,IDb,RIb,GIid,SIid,MATdivb);\nmacro Q3 = D(PUb,RNa,MATdiv,IDa,DIsig);\nmatch(MATdiv,MATdivb);\nmatch(Temp2,Temp3);\nmacro SessionKey = POW(RNa,RNb);\nmacro Q1 = E(PUa,SessionKey,IDb,DIsigb,Timestamp);\nmacro Q4 = D(SessionKey,msg);\nsend_!4(DeviceB,DeviceA,Q1);\nclaim_DeviceB2(DeviceB,Secret,msg);\nclaim_DeviceB3(DeviceB,Niagree);\nclaim_DeviceB4(DeviceB, Nisynch);\n}\n}", "The completed code is as follows:\n```spdl\nconst E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\n\nprotocol Fortified-Chain2(DeviceA,Edge,DeviceB)\n{\nrole DeviceA {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh RNa:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUa:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\nrecv_!2(Edge,DeviceA,P1);\n\nrecv_!4(DeviceB,DeviceA,Q1);\n\nmacro V0 = E(PUedge,H(IDdev));\nmacro Temp = H(RIa);\nmacro Temp1 = E(PRa,Temp);\nmacro DIsig = APN(Temp1,RIa);\nmacro V1 = E(PUb,RNa,MATdiv,IDa,DIsig);\nmacro V2 = D(PRa,SessionKey,IDb,DIsigb,Timestamp);\nmacro V3 = E(SessionKey,msg);\nmacro V4 =  D(PRa,IDa,RIa,GIid,SIid,MATdiv);\n\nsend_!1(DeviceA,Edge,V0);\nsend_!5(DeviceA,DeviceB,V1,V3);\nclaim_DeviceA2(DeviceA,Secret,SessionKey);\nclaim_DeviceA3(DeviceA,Niagree);\nclaim_DeviceA4(DeviceA, Nisynch);\n}\nrole Edge {\nfresh PRedge,PUedge,PUa,PUb:key;\nfresh RNhc,MATdiv,GIid,SIid:Nonce;\nconst IDhc,RIa,IDa,RIa1,Hdev,MATdivb,MATdiv,RIb,IDb;\nconst P0,P1,P2;\nconst IDdev;\nrecv_!1(DeviceA,Edge,V0);\n\nmacro P0 = D(PRedge,H(IDdev));\nmacro Hdev = H(IDdev);\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\nmacro RIa = H(RIa1);\nmacro IDa = XOR(RIa,Hdev);\nmacro  P1 = E(PUa,IDa,RIa,GIid,SIid,MATdiv);\nmacro P2 = E(PUb,IDb,RIb,GIid,SIid,MATdivb);\nsend_!2(Edge,DeviceA,P1);\nsend_!3(Edge,DeviceB,P2);\nclaim_Edge2(Edge,Secret,PRedge);\nclaim_Edge3(Edge,Niagree);\nclaim_Edge4(Edge,Nisynch);\n}\n\nrole DeviceB {\nfresh PRb,PUedge,PUa,PUb,DIsigb:key;\nfresh RNb:Nonce;\nconst IDdevb,DIsigb,MATdivb,Q1,Q2,Q3,Q4,MATdivb,MATdiv,IDb;\nfresh RIb,RIa,RNb:Nonce;\nconst Temp2,Temp3,msg,RNa;\nfresh SessionKey,Timestamp:key;\nrecv_!3(Edge,DeviceB,P2);\n\nrecv_!5(DeviceA,DeviceB,V1,V3);\n\n\nmacro Temp3 = D(PUa,DIsig);\n\nmacro Temp2 = H(RIa); \n\n\nmacro Q2 = D(PRb,IDb,RIb,GIid,SIid,MATdivb);\nmacro Q3 = D(PUb,RNa,MATdiv,IDa,DIsig);\nmatch(MATdiv,MATdivb);\nmatch(Temp2,Temp3);\nmacro SessionKey = POW(RNa,RNb);\nmacro Q1 = E(PUa,SessionKey,IDb,DIsigb,Timestamp);\nmacro Q4 = D(SessionKey,msg);\nsend_!4(DeviceB,DeviceA,Q1);\nclaim_DeviceB2(DeviceB,Secret,msg);\nclaim_DeviceB3(DeviceB,Niagree);\nclaim_DeviceB4(DeviceB, Nisynch);\n}\n}\n```"]], "SPDL-1/fourway-HSDDM05.spdl": [[true, "protocol fourway(X,Y)\n{\n        role X\n        {\n                fresh x: Nonce;\n                var y: Nonce;\n\n                send_1( X,Y, x,msg1 );\n                recv_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                send_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                recv_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_X1( X, Secret, hash( pmk(X,Y),x,y ) );\n                claim_X2( X, Niagree );\n        }\n\n        role Y\n        {\n                var x: Nonce;\n                fresh y: Nonce;\n\n                recv_1( X,Y, x,msg1 );\n                send_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                recv_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                send_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_Y1( Y, Secret, hash( pmk(X,Y),x,y ) );\n                claim_Y2( Y, Niagree );\n        }\n}", "To complete the given SPDL code for the Four-Way Authentication Protocol, we need to fill in the blanks according to the protocol description provided.\n\nThe protocol involves two roles: `X` (or `____(ROLE_1)____`) and `Y`. The nonces used are `x` (or `____(NONCE_1)____`) for `X` and `y` for `Y`. Let's fill in the blanks accordingly.\n\n1. The protocol is between `X` and `Y`, so `____(ROLE_1)____` should be `X`.\n\n2. In the role definition for `X`, the fresh nonce generated is `x`, so `____(NONCE_1)____` should be `x`.\n\n3. `____(ROLE_1)____` should be replaced with `X` in all occurrences within the protocol definition for both roles.\n\n4. For the `send` and `recv` statements, the agents involved should be correctly identified as `X` and `Y`.\n\nLet's apply these changes:\n\n```spdl\nprotocol fourway(X,Y)\n{\n        role X\n        {\n                fresh x: Nonce;\n                var y: Nonce;\n\n                send_1( X,Y, x,msg1 );\n                recv_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                send_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                recv_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_X1( X, Secret, hash( pmk(X,Y),x,y ) );\n                claim_X2( X, Niagree );\n        }\n\n        role Y\n        {\n                var x: Nonce;\n                fresh y: Nonce;\n\n                recv_1( X,Y, x,msg1 );\n                send_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                recv_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                send_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_Y1( Y, Secret, hash( pmk(X,Y),x,y ) );\n                claim_Y2( Y, Niagree );\n        }\n}\n```\n\nThus, the completed SPDL code is between ```spdl and ```:\n```spdl\n# 1 \"fourway-HSDDM05.cpp\"\n# 1 \"<built-in>\"\n# 1 \"<command line>\"\n# 1 \"fourway-HSDDM05.cpp\"\n# 10 \"fourway-HSDDM05.cpp\"\nusertype Params, String;\n\nconst hash: Function;\nsecret unhash: Function;\ninversekeys(hash,unhash);\nsecret pmk: Function;\n\nconst msg1,msg2,msg3,msg4: String;\n\nconst Alice, Bob, Eve: Agent;\n\nprotocol fourway(X,Y)\n{\n        role X\n        {\n                fresh x: Nonce;\n                var y: Nonce;\n\n                send_1( X,Y, x,msg1 );\n                recv_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                send_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                recv_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_X1( X, Secret, hash( pmk(X,Y),x,y ) );\n                claim_X2( X, Niagree );\n        }\n\n        role Y\n        {\n                var x: Nonce;\n                fresh y: Nonce;\n\n                recv_1( X,Y, x,msg1 );\n                send_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                recv_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                send_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_Y1( Y, Secret, hash( pmk(X,Y),x,y ) );\n                claim_Y2( Y, Niagree );\n        }\n}\n```"]], "SPDL-1/gros_pigeons-v0.spdl": [[true, "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(I, R, {sec}pk(R));\n\t\trecv_2(R, I, h(sec), {n}pk(I));\n\t\tsend_3(I, R, h(n));\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(I, R, {sec}pk(R));\n\t\tsend_2(R, I, h(sec), {n}pk(I));\n\t\trecv_3(I, R, h(n));\n\t}\n}", "```spdl\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(I, R, {sec}pk(R));\n\t\trecv_2(R, I, h(sec), {n}pk(I));\n\t\tsend_3(I, R, h(n));\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(I, R, {sec}pk(R));\n\t\tsend_2(R, I, h(sec), {n}pk(I));\n\t\trecv_3(I, R, h(n));\n\t}\n}\n```"]], "SPDL-1/HMQV.spdl": [[true, "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}", "To complete the given protocol analysis code, the blanks need to be filled according to the description of the HMQV two-pass protocol. The positions to be completed are indicated by `____()___`.\n\nLet's fill the blanks step by step based on the information provided:\n\n1. **Protocol `@exponentiation(RA,____(ROLE_3)____,RC)`**: The description indicates that there are three roles: RA, RB, and RC. Therefore, `____(ROLE_3)____` should be `RB`.\n\n2. **Within `@exponentiation(RA,RB,RC)`**:\n   - `role RA`: `____(ROLE_3)____` should be `RB`.\n   - `role RB`: `____(ROLE_3)____` should be `RB`, and similarly for other `____(ROLE_3)____` within this role.\n   - The same substitution applies to other occurrences.\n\n3. **Protocol `@addmult(I,____(ROLE_2)____)`**: Here, `____(ROLE_2)____` is `R` as per the symmetric role protocol definition.\n\n4. **Within `@keyswap(I,____(ROLE_2)____)`**:\n   - `____(ROLE_2)____` should be `R`.\n   - `____(NONCE_1)____` should be `y` as per the description of Role R in `HMQV-twopass`.\n\n5. **Protocol `HMQV-twopass(I,____(ROLE_2)____)`**: `____(ROLE_2)____` is `R`.\n\n6. **Within `HMQV-twopass(I,R)`**:\n   - For `role I`, `____(ROLE_2)____` is `R`, and `____(NONCE_1)____` in the claim is `y`.\n   - For `role R`, `____(NONCE_1)____` should be `y`.\n\nLet's apply these substitutions:\n\n```spdl\n/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n```\n\nThe final completed code is between ```spdl``` and ```. \n```spdl\n/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n```"]], "SPDL-1/ikev1-quick.spdl": [[true, "protocol ikev1-quick(I, R)\n{\n role I {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( I, R, mid, {prf(k(I,R), mid, list, Ni, g(i), I, R), list, Ni, g(i), I, R}k(I,R) );\n  recv_!2( R, I, mid, {prf(k(I,R), mid, Ni, algo, Nr, Gr, I, R), algo, Nr, Gr, I, R}k(I,R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( I, R, mid, {prf(k(I,R), mid, Ni, Nr)}k(I,R) );\n\n  claim( I, SKR, KDF(k(I,R),h(Gr,i),Ni,Nr) );\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr );\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( I, R, mid, {prf(k(R,I), mid, list, Ni, Gi, I, R), list, Ni, Gi, I, R}k(I,R) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r) );\n  send_!2( R, I, mid, {prf(k(R,I), mid, Ni, algo, Nr, g(r), I, R), algo, Nr, g(r), I, R}k(I,R) );\n  recv_!3( I, R, mid, {prf(k(R,I), mid, Ni, Nr)}k(I,R) );\n\n  claim( R, SKR, KDF(k(R,I),h(Gi,r),Ni,Nr) );\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r) );\n }\n}", "To complete the given SPDL code, we first need to analyze the provided description of the \"ikev1-quick\" protocol and understand the roles, variables, and message flows involved.\n\n1. **Role Identification**: The protocol involves two main roles: the Initiator (`I`) and the Responder (`R`). In the given SPDL code, these roles are represented as `____(ROLE_1)____` and `R` in the `ikev1-quick` protocol definition. For clarity and consistency with the description, we can identify `____(ROLE_1)____` as `I`.\n\n2. **Variable Identification**: The nonces (`i`, `Ni`, `r`, `Nr`, etc.), tickets (`Gi`, `Gr`), and other variables are already defined in the code. We need to ensure that these variables are used consistently across the protocol definition.\n\n3. **Message Flow**: The protocol involves three messages exchanged between `I` and `R`. The messages are encrypted and contain various nonces and tickets. The code already outlines this message flow, but we need to fill in the blanks to ensure consistency with the role and variable identifications.\n\nGiven the description and analyzing the provided SPDL code, we can fill in the blanks as follows:\n\n```spdl\nprotocol ikev1-quick(I, R)\n{\n role I {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( I, R, mid, {prf(k(I,R), mid, list, Ni, g(i), I, R), list, Ni, g(i), I, R}k(I,R) );\n  recv_!2( R, I, mid, {prf(k(I,R), mid, Ni, algo, Nr, Gr, I, R), algo, Nr, Gr, I, R}k(I,R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( I, R, mid, {prf(k(I,R), mid, Ni, Nr)}k(I,R) );\n\n  claim( I, SKR, KDF(k(I,R),h(Gr,i),Ni,Nr) );\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr );\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( I, R, mid, {prf(k(R,I), mid, list, Ni, Gi, I, R), list, Ni, Gi, I, R}k(I,R) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r) );\n  send_!2( R, I, mid, {prf(k(R,I), mid, Ni, algo, Nr, g(r), I, R), algo, Nr, g(r), I, R}k(I,R) );\n  recv_!3( I, R, mid, {prf(k(R,I), mid, Ni, Nr)}k(I,R) );\n\n  claim( R, SKR, KDF(k(R,I),h(Gi,r),Ni,Nr) );\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r) );\n }\n}\n```\n\nAnd the `@oracle` protocol should be completed as follows, assuming `I` and `R` are the roles for `SWAP`:\n\n```spdl\nprotocol @oracle (DH, SWAP) {\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n  var I, R: Agent;\n\n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),h(g(i),r),Ni,Nr) );\n }\n}\n```\n\nThus, the completed SPDL code between ```spdl and ``` will be as follows:\n\n```spdl\n# 1 \"ikev1-quick.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-quick.cpp\"\n# 16 \"ikev1-quick.cpp\"\n# 1 \"common.h\" 1\n\n hashfunction prf, KDF;\n\nhashfunction g, h;\n\nprotocol @oracle (DH, SWAP) {\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n  var I, R: Agent;\n\n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),h(g(i),r),Ni,Nr) );\n }\n}\n\n# 17 \"ikev1-quick.cpp\" 2\n\nprotocol ikev1-quick(I, R)\n{\n role I {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( I, R, mid, {prf(k(I,R), mid, list, Ni, g(i), I, R), list, Ni, g(i), I, R}k(I,R) );\n  recv_!2( R, I, mid, {prf(k(I,R), mid, Ni, algo, Nr, Gr, I, R), algo, Nr, Gr, I, R}k(I,R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( I, R, mid, {prf(k(I,R), mid, Ni, Nr)}k(I,R) );\n\n  claim( I, SKR, KDF(k(I,R),h(Gr,i),Ni,Nr) );\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr );\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( I, R, mid, {prf(k(R,I), mid, list, Ni, Gi, I, R), list, Ni, Gi, I, R}k(I,R) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r) );\n  send_!2( R, I, mid, {prf(k(R,I), mid, Ni, algo, Nr, g(r), I, R), algo, Nr, g(r), I, R}k(I,R) );\n  recv_!3( I, R, mid, {prf(k(R,I), mid, Ni, Nr)}k(I,R) );\n\n  claim( R, SKR, KDF(k(R,I),h(Gi,r),Ni,Nr) );\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r) );\n }\n}\n```"]], "SPDL-1/ikev2-mac.spdl": [[false, "```spdl"]], "SPDL-1/iso25-tag.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * four-pass\n * mutual\n *\n * Modeling notes:\n * - The use of TNb in message 4, as specified by the ISO standard, is\n *   different from other models, in which it was TNa.\n */\nusertype SessionKey;\nusertype Tag;\n\nconst t1,t2a,t2b,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-5(A,B,P)\n{\n\trole A\n\t{\n\t\tfresh TVPa: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNa: Nonce;\n\t\tvar TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text5,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\tsend_1(A,P, TVPa, B, Text1);\n\t\trecv_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text5);\n\t\tsend_3(A,B, Text6, T, { t3, TNa, B, Text5 }Kab );\n\t\trecv_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text5,Text7);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text5);\n\t\tclaim(A,Secret,Text7);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNp: Nonce;\n\t\tvar TNa: Nonce;\n\t\tfresh TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text7,Text8: Ticket;\n\t\tvar Text2,Text5,Text6: Ticket;\n\n\t\trecv_3(A,B, Text6, { t2b, TNp, Kab, A, Text2  }k(B,P), { t3, TNa, B, Text5 }Kab );\n\t\tclaim(B,Running,A,Kab,Text5,Text7);\n\t\tsend_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(B,Commit,A,Kab,Text5);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text5);\n\t\tclaim(B,Secret,Text7);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar TVPa: Nonce;\n\t\tfresh TNp: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text2,Text3,Text4: Ticket;\n\t\tvar Text1: Ticket;\n\n\t\trecv_1(A,P, TVPa, B, Text1);\n\t\tsend_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P),\n\t\t\t\t  { t2b, TNp, Kab, A, Text2  }k(B,P) );\n\t}\n}", "```spdl\n/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * four-pass\n * mutual\n *\n * Modeling notes:\n * - The use of TNb in message 4, as specified by the ISO standard, is\n *   different from other models, in which it was TNa.\n */\nusertype SessionKey;\nusertype Tag;\n\nconst t1,t2a,t2b,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-5(A,B,P)\n{\n\trole A\n\t{\n\t\tfresh TVPa: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNa: Nonce;\n\t\tvar TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text5,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\tsend_1(A,P, TVPa, B, Text1);\n\t\trecv_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text5);\n\t\tsend_3(A,B, Text6, T, { t3, TNa, B, Text5 }Kab );\n\t\trecv_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text5,Text7);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text5);\n\t\tclaim(A,Secret,Text7);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNp: Nonce;\n\t\tvar TNa: Nonce;\n\t\tfresh TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text7,Text8: Ticket;\n\t\tvar Text2,Text5,Text6: Ticket;\n\n\t\trecv_3(A,B, Text6, { t2b, TNp, Kab, A, Text2  }k(B,P), { t3, TNa, B, Text5 }Kab );\n\t\tclaim(B,Running,A,Kab,Text5,Text7);\n\t\tsend_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(B,Commit,A,Kab,Text5);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text5);\n\t\tclaim(B,Secret,Text7);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar TVPa: Nonce;\n\t\tfresh TNp: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text2,Text3,Text4: Ticket;\n\t\tvar Text1: Ticket;\n\n\t\trecv_1(A,P, TVPa, B, Text1);\n\t\tsend_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P),\n\t\t\t\t  { t2b, TNp, Kab, A, Text2  }k(B,P) );\n\t}\n}\n```"]], "SPDL-1/isoiec-9798-2-1.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh Na: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(A,Running,B,Na,Text1);\n\t\tsend_1(A,B, Text2, { Na, B, Text1 }k(A,B) );\n\t}\n\trole B\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(A,B, Text2, { Na, B, Text1 }k(A,B) );\n\n\t\tclaim(B,Commit,A,Na,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}", "```spdl\n/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh Na: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(A,Running,B,Na,Text1);\n\t\tsend_1(A,B, Text2, { Na, B, Text1 }k(A,B) );\n\t}\n\trole B\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(A,B, Text2, { Na, B, Text1 }k(A,B) );\n\n\t\tclaim(B,Commit,A,Na,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}\n```"]], "SPDL-1/isoiec11770-2-13.spdl": [[true, "usertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, ni);\n\t\trecv_4 (R,I, { ni,kir,R }k(I,S) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, ni);\n\t\tsend_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\trecv_3 (S,R, { nr, I }k(R,S), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\trecv_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\tsend_3 (S,R, { nr, I }k(R,S), { ni,kir,R }k(I,S) );\n\t}\n}", "```spdl\nusertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, ni);\n\t\trecv_4 (R,I, { ni,kir,R }k(I,S) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, ni);\n\t\tsend_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\trecv_3 (S,R, { nr, I }k(R,S), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\trecv_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\tsend_3 (S,R, { nr, I }k(R,S), { ni,kir,R }k(I,S) );\n\t}\n}\n```"]], "SPDL-1/KAS1.spdl": [[true, "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,I) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,I) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}", "```spdl\n/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,I) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,I) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}\n```"]], "SPDL-1/andrew-lowe-ban.spdl": [[true, "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}", "```spdl\n# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}\n```"]], "SPDL-1/KEA+.spdl": [[true, "protocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\t...\n}", "To complete the provided SPDL code, we need to understand the notations and roles defined within the protocol description.\n\nThe protocol involves two main roles: Initiator (I) and Responder (R). There are also two helper protocols (`@publickeys` and `@exponentiation`) that seem to be used for specific cryptographic properties or to aid in the analysis.\n\nLet's analyze and complete the given SPDL code step by step:\n\n### 1. Completing `@publickeys` Protocol\n\nThe `@publickeys` protocol is used to demonstrate the equivalence of public keys to `g^private`. It involves three roles: `____(ROLE_2)____`, `RB`, and `RC`.\n\nGiven the context, `____(ROLE_2)____` likely refers to a generic role that could be either Initiator or Responder. For simplicity and based on the usage, let's assume `____(ROLE_2)____` should be replaced with `I` (Initiator), as it's the first role mentioned and seems to be a placeholder for a role.\n\n```spdl\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\t...\n}\n```\n\nThus, the completed `@publickeys` protocol could be:\n\n```spdl\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n```\n\n### 2. Completing `@exponentiation` Protocol\n\nSimilarly, for the `@exponentiation` protocol, we replace `____(ROLE_2)____` with `I`:\n\n```spdl\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\t...\n}\n```\n\nThe completed `@exponentiation` protocol is thus:\n\n```spdl\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,I) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,I) );\n\t}\n}\n```\n\n### 3. Completing `KEAplus` Protocol\n\nFor the `KEAplus` protocol, we need to complete the Responder's fresh nonce declaration and its usage.\n\nThe Initiator generates a fresh nonce `x`, and the Responder generates a fresh nonce `y`. So, `____(NONCE_1)____` should be `y`.\n\n```spdl\nrole R\n{\n\tfresh y: Nonce;\n\tvar alpha: Ticket;\n\n\trecv_1(I,R, alpha );\n\tsend_Compromise(R,R, y);\n\tsend_2(R,I, g1(y) );\n\n\tclaim(R,SKR, h1(\n\t  g2(pk(I),y),\n\t  g2(alpha,sk(R)),\n\t  I,R\n\t));\n}\n```\n\nThe completed SPDL code is as follows:\n\n```spdl\n/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,I) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,I) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}\n```\n\nThe final answer is: \n```spdl\n/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(I,RB,RC)\n{\n\trole I\n\t{\n\t\tsend_!1(I,I, g1(sk(I)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(I,RB,RC)\n{\n\trole I\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(I,I, g2(g1(T1),T2) );\n\t\tsend_!2(I,I, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,I) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,I) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}\n```"]], "SPDL-1/kerberos-rddm.spdl": [[true, "/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nusertype Ticket;\nusertype Nonce;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}ktk(I,R));\n        send_!X2(I,R,{Tt}ktk(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kck(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}kck(I,R));\n        send_!X2(I,R,{Tt}kck(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kst(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}kst(I,R));\n        send_!X2(I,R,{Tt}kst(R,I));\n    }\n    role R\n    {\n    }\n}\n\nprotocol kerberos(C,K,T,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,T,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,T }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,T, tgt, { C }AKey,C,S,n2 );\n\t\trecv_4(T,C, C, st, { SKey, n2, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,T,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(T,K), { AKey,n1,T }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole T {\n\t\tvar AKey: Sessionkey;\n\t\tvar n2: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,T, { AKey, C }ktk(T,K), { C }AKey,C,S,n2 );\n\t\tsend_4(T,C, C,{ SKey, C }kst(S,T), { SKey, n2, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(T,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(T,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(T,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,T), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted", "```spdl\n/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nusertype Ticket;\nusertype Nonce;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}ktk(I,R));\n        send_!X2(I,R,{Tt}ktk(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kck(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}kck(I,R));\n        send_!X2(I,R,{Tt}kck(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kst(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var Tt:Ticket;\n\n        recv_!X1(R,I,{Tt}kst(I,R));\n        send_!X2(I,R,{Tt}kst(R,I));\n    }\n    role R\n    {\n    }\n}\n\nprotocol kerberos(C,K,T,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,T,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,T }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,T, tgt, { C }AKey,C,S,n2 );\n\t\trecv_4(T,C, C, st, { SKey, n2, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,T,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(T,K), { AKey,n1,T }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole T {\n\t\tvar AKey: Sessionkey;\n\t\tvar n2: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,T, { AKey, C }ktk(T,K), { C }AKey,C,S,n2 );\n\t\tsend_4(T,C, C,{ SKey, C }kst(S,T), { SKey, n2, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(T,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(T,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(T,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,T), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted\n```"]], "SPDL-1/localclaims-breaker.spdl": [[true, "/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr,I}pk(R) );\n\n\t\trecv_x1(R,I, { x }pk(I) );\n\t\tsend_x2(I,R, { x }ni );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh x: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr,I}pk(R) );\n\n\t\tsend_x1(R,I, { x }pk(I) );\n\t\trecv_x2(I,R, { x }ni );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t}\n}", "```spdl\n/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr,I}pk(R) );\n\n\t\trecv_x1(R,I, { x }pk(I) );\n\t\tsend_x2(I,R, { x }ni );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh x: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr,I}pk(R) );\n\n\t\tsend_x1(R,I, { x }pk(I) );\n\t\trecv_x2(I,R, { x }ni );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t}\n}\n```"]], "SPDL-1/myProt.spdl": [[true, "hashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(A,B)\n{\n\trole A\n\t{\n\t\tfresh K: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(A, B, h(A, K), {K}pk(B));\n\t\trecv_2(B, A, h(B, K, n), {n}pk(A));\n\t\tsend_3(A, B, h(n));\n\n\t\tclaim_4(A, Secret, K);\n\t\tclaim_6(A, Nisynch);\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar V: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(A, B, h(A, V), {V}pk(B));\n\t\tsend_2(B, A, h(B, V, n), {n}pk(A));\n\t\trecv_3(A, B, h(n));\n\n\t\tclaim_5(B, Secret, V);\n\t\tclaim_7(B, Nisynch);\n\t}\n}", "```spdl\nhashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(A,B)\n{\n\trole A\n\t{\n\t\tfresh K: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(A, B, h(A, K), {K}pk(B));\n\t\trecv_2(B, A, h(B, K, n), {n}pk(A));\n\t\tsend_3(A, B, h(n));\n\n\t\tclaim_4(A, Secret, K);\n\t\tclaim_6(A, Nisynch);\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar V: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(A, B, h(A, V), {V}pk(B));\n\t\tsend_2(B, A, h(B, V, n), {n}pk(A));\n\t\trecv_3(A, B, h(n));\n\n\t\tclaim_5(B, Secret, V);\n\t\tclaim_7(B, Nisynch);\n\t}\n}\n```"]], "SPDL-1/NAXOS.spdl": [[true, "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}", "Here is the completed SPDL code for the NAXOS AKE protocol.\n\n```spdl\n/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}\n```"]], "SPDL-1/needham-schroeder-sk.spdl": [[true, "# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroederSK(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var Kir: SessionKey;\n        var Ticket: Ticket;\n        \n        send_1(I,S,(I,R,Ni));\n        recv_2(S,I, {Ni,R,Kir,Ticket}k(I,S));\n        send_3(I,R,Ticket);\n        recv_4(R,I,{Nr}Kir);\n        send_5(I,R,{{Nr}dec}Kir);\n        claim_I2(I,Secret,Kir);\n        claim_I3(I,Nisynch);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Kir: SessionKey;\n        \n        recv_3(I,R,{Kir,I}k(R,S));\n        send_4(R,I,{Nr}Kir);\n        recv_5(I,R,{{Nr}dec}Kir);\n        claim_R1(R,Secret,Kir);\n        claim_R3(R,Nisynch);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni: Nonce;\n        fresh Kir: SessionKey;\n        recv_1(I,S,(I,R,Ni));\n        send_2(S,I,{Ni,R,Kir,{Kir,I}k(R,S)}k(I,S));\n    }\n}", "```spdl\n# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroederSK(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var Kir: SessionKey;\n        var Ticket: Ticket;\n        \n        send_1(I,S,(I,R,Ni));\n        recv_2(S,I, {Ni,R,Kir,Ticket}k(I,S));\n        send_3(I,R,Ticket);\n        recv_4(R,I,{Nr}Kir);\n        send_5(I,R,{{Nr}dec}Kir);\n        claim_I2(I,Secret,Kir);\n        claim_I3(I,Nisynch);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Kir: SessionKey;\n        \n        recv_3(I,R,{Kir,I}k(R,S));\n        send_4(R,I,{Nr}Kir);\n        recv_5(I,R,{{Nr}dec}Kir);\n        claim_R1(R,Secret,Kir);\n        claim_R3(R,Nisynch);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni: Nonce;\n        fresh Kir: SessionKey;\n        recv_1(I,S,(I,R,Ni));\n        send_2(S,I,{Ni,R,Kir,{Kir,I}k(R,S)}k(I,S));\n    }\n}\n```"]], "SPDL-1/nsl3.spdl": [[true, "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}", "```spdl\n/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/nuts-auth.spdl": [[true, "hashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, Sat), Ra, Rb);\n\nprotocol NUTSAuth (GS,Sat) {\n\n    role GS {\n        var Ra: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        recv_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        send_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        recv_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Send command\n        send_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        recv_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Send another command (repeat CMDs for scyther to spot replay attacks)\n        send_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        recv_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(GS, Alive);\n        claim(GS, Secret, Ks);\n        claim(GS, Weakagree);\n        claim(GS, Niagree);\n        claim(GS, Nisynch);\n    };\n\n    role Sat {\n        fresh Ra: Nonce;\n        var Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        recv_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        send_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        recv_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        send_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Receive command\n        recv_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        send_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Receive second command\n        recv_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        send_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(Sat, Alive);\n        claim(Sat, Secret, Ks);\n        claim(Sat, Weakagree);\n        claim(Sat, Niagree);\n        claim(Sat, Nisynch);\n    };\n}", "```spdl\nhashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, Sat), Ra, Rb);\n\nprotocol NUTSAuth (GS,Sat) {\n\n    role GS {\n        var Ra: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        recv_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        send_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        recv_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Send command\n        send_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        recv_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Send another command (repeat CMDs for scyther to spot replay attacks)\n        send_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        recv_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(GS, Alive);\n        claim(GS, Secret, Ks);\n        claim(GS, Weakagree);\n        claim(GS, Niagree);\n        claim(GS, Nisynch);\n    };\n\n    role Sat {\n        fresh Ra: Nonce;\n        var Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        recv_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        send_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        recv_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        send_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Receive command\n        recv_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        send_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Receive second command\n        recv_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        send_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(Sat, Alive);\n        claim(Sat, Secret, Ks);\n        claim(Sat, Weakagree);\n        claim(Sat, Niagree);\n        claim(Sat, Nisynch);\n    };\n}\n```"]], "SPDL-1/oakley-a.spdl": [[true, "# 1 \"oakley-a.cpp\"\n# 1 \"<command-line>\"\n# 1 \"oakley-a.cpp\"\n# 18 \"oakley-a.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 141 \"common.h\"\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 19 \"oakley-a.cpp\" 2\n\n\n\nusertype String;\nconst list, algo: String;\n\nprotocol oakley-a(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, g(i), list, I, R, Ni, {I, R, Ni, g(i), list}sk(I) );\n  recv_2( R, I, Cr, Ci, Gr, algo, R, I, Nr, Ni, {R, I, Nr, Ni, g(i), Gr, algo}sk(R) );\n  send_3( I, R, Ci, Cr, g(i), algo, I, R, Ni, Nr, {I, R, Ni, Nr, g(i), Gr, algo}sk(I) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, Gi, list, I, R, Ni, {I, R, Ni, Gi, list}sk(I) );\n  send_2( R, I, Cr, Ci, g(r), algo, R, I, Nr, Ni, {R, I, Nr, Ni, Gi, g(r), algo}sk(R) );\n  recv_3( I, R, Ci, Cr, Gi, algo, I, R, Ni, Nr, {I, R, Ni, Nr, Gi, g(r), algo}sk(I) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}", "The completed code is as follows:\n\n```spdl\n# 1 \"oakley-a.cpp\"\n# 1 \"<command-line>\"\n# 1 \"oakley-a.cpp\"\n# 18 \"oakley-a.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 141 \"common.h\"\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 19 \"oakley-a.cpp\" 2\n\n\n\nusertype String;\nconst list, algo: String;\n\nprotocol oakley-a(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, g(i), list, I, R, Ni, {I, R, Ni, g(i), list}sk(I) );\n  recv_2( R, I, Cr, Ci, Gr, algo, R, I, Nr, Ni, {R, I, Nr, Ni, g(i), Gr, algo}sk(R) );\n  send_3( I, R, Ci, Cr, g(i), algo, I, R, Ni, Nr, {I, R, Ni, Nr, g(i), Gr, algo}sk(I) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, Gi, list, I, R, Ni, {I, R, Ni, Gi, list}sk(I) );\n  send_2( R, I, Cr, Ci, g(r), algo, R, I, Nr, Ni, {R, I, Nr, Ni, Gi, g(r), algo}sk(R) );\n  recv_3( I, R, Ci, Cr, Gi, algo, I, R, Ni, Nr, {I, R, Ni, Nr, Gi, g(r), algo}sk(I) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}\n```"]], "SPDL-1/pkmv2rsacorrected.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, prepak}pk(MS),{BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, prepak}pk(MS),{BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}", "```spdl\n/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, prepak}pk(MS),{BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, prepak}pk(MS),{BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}\n```"]], "SPDL-1/athena-breaker.spdl": [[true, "/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_!1(I,R, {{I,ni}pk(R)}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar T:Ticket;\n\t\tvar Ni: Nonce;\n\t\tvar Iid: Agent;\n\n\t\trecv_!1(I,R, {T:Ticket}pk(R) );\n\t\tmatch(T,{{Iid, Ni}pk(R)});\n\t\tsend_!2(R,I, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information", "```spdl\n/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_!1(I,R, {{I,ni}pk(R)}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar T:Ticket;\n\t\tvar Ni: Nonce;\n\t\tvar Iid: Agent;\n\n\t\trecv_!1(I,R, {T:Ticket}pk(R) );\n\t\tmatch(T,{{Iid, Ni}pk(R)});\n\t\tsend_!2(R,I, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information\n```"]], "SPDL-1/pqr.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said, c: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    send_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    send_tekup1(MS,BS,{c}hash(prepak));\n    recv_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai5(MS,SKR,prepak);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n    claim_rsar8(MS,SKR,tek2);\n    claim_rsar9(MS,SKR,tek3);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said, c: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    recv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    recv_tekup1(MS,BS,{c}hash(prepak));\n    send_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar5(BS,SKR,prepak);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n    claim_rsar8(BS,SKR,tek2);\n    claim_rsar9(BS,SKR,tek3);\n  }\n}", "```spdl\n/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said, c: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    send_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    send_tekup1(MS,BS,{c}hash(prepak));\n    recv_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai5(MS,SKR,prepak);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n    claim_rsar8(MS,SKR,tek2);\n    claim_rsar9(MS,SKR,tek3);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said, c: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    recv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    recv_tekup1(MS,BS,{c}hash(prepak));\n    send_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar5(BS,SKR,prepak);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n    claim_rsar8(BS,SKR,tek2);\n    claim_rsar9(BS,SKR,tek3);\n  }\n}\n```"]], "SPDL-1/protocol0-symm.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}", "```spdl\n/* \n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}\n```"]], "SPDL-1/Signed-DH.spdl": [[true, "protocol @exponentiation(A)\n{\n    role A\n    {\n        var alpha,beta, T1,T2: Ticket;\n\n        recv_!1(A,A, g2(g1(T1),T2) );\n        send_!2(A,A, g2(g1(T2),T1) );\n    }\n}", "To complete the given SPDL file based on the provided description, we need to analyze the given content and fill in the missing parts. The missing parts are indicated by `____()___`. Let's analyze the content step by step:\n\n1. **Hash Functions and Helper Protocol**:\n   - The hash functions `h1`, `h2`, `g1`, and `g2` are already defined.\n   - The helper protocol `@exponentiation` is defined with a role `ROLE_1`. The missing parts here are the role name and the variables used in the protocol.\n\n2. **The Protocol Description**:\n   - The main protocol `SIG-DH-UM` involves two roles: `I` (Initiator) and `R` (Responder).\n   - For the `I` role, the description is mostly complete, with fresh nonces `s` and `x`, and a variable `beta`.\n   - For the `R` role, the fresh nonce is missing, and there are missing variables in the `send_2` and `recv_3` events.\n\nLet's fill in the missing parts based on the protocol description:\n\n- For the `@exponentiation` protocol, it seems that `ROLE_1` should be replaced with a specific role name, and the variables should be used accordingly. Since it's a helper protocol and seems to be related to simulating an exponentiation operation, we can assume `ROLE_1` is `A` for simplicity.\n\n- In the `SIG-DH-UM` protocol:\n  - The `R` role is missing a fresh nonce, which should be `y` based on the description. So, `____(NONCE_1)____` should be `y`.\n  - In `send_2` and `recv_3` of the `R` role, `____(NONCE_1)____` should be replaced with `y`.\n  - The claim for `SKR` in both roles involves `g2`, and for `R`, it should be `g2(alpha, y)`.\n\nLet's fill in the missing parts:\n\nThe `@exponentiation` protocol's role should be named, and its variables and actions should match the description. Assuming `A` as the role:\n\n```spdl\nprotocol @exponentiation(A)\n{\n    role A\n    {\n        var alpha,beta, T1,T2: Ticket;\n\n        recv_!1(A,A, g2(g1(T1),T2) );\n        send_!2(A,A, g2(g1(T2),T1) );\n    }\n}\n```\n\nFor the `SIG-DH-UM` protocol:\n\n```spdl\nprotocol SIG-DH-UM(I,R)\n{\n    role I\n    {\n        fresh s: Nonce;\n        fresh x: Nonce;\n        var beta: Ticket;\n\n        claim(I, SID, s);\n        send_1(I,R, I,s,g1(x) );\n        recv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n        send_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n        claim(I,SKR, g2(beta,x) );\n    }    \n    \n    role R\n    {\n        fresh y: Nonce;\n        var s: Nonce;\n        var alpha: Ticket;\n\n        recv_1(I,R, I,s,alpha );\n        claim(R, SID, s);\n        send_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n        recv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n        claim(R,SKR, g2(alpha,y) );\n    }\n}\n```\n\nSo, the completed SPDL code is as follows:\n\n```spdl\n/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(A)\n{\n    role A\n    {\n        var alpha,beta, T1,T2: Ticket;\n\n        recv_!1(A,A, g2(g1(T1),T2) );\n        send_!2(A,A, g2(g1(T2),T1) );\n    }\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n    role I\n    {\n        fresh s: Nonce;\n        fresh x: Nonce;\n        var beta: Ticket;\n\n        claim(I, SID, s);\n        send_1(I,R, I,s,g1(x) );\n        recv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n        send_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n        claim(I,SKR, g2(beta,x) );\n    }    \n    \n    role R\n    {\n        fresh y: Nonce;\n        var s: Nonce;\n        var alpha: Ticket;\n\n        recv_1(I,R, I,s,alpha );\n        claim(R, SID, s);\n        send_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n        recv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n        claim(R,SKR, g2(alpha,y) );\n    }\n}\n```"]], "SPDL-1/skeme-basic.spdl": [[true, "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (A, SWAP) {\n\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, A, h(g(r),i) );\n  send_!DH2( A, A, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}", "```spdl\n# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (A, SWAP) {\n\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, A, h(g(r),i) );\n  send_!DH2( A, A, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}\n```"]], "SPDL-1/soph.spdl": [[true, "protocol soph(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, ni );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, ni );\n\t}\n}", "Based on the description of the `soph` protocol, the completed code in SPDL language is as follows:\n\n```spdl\nprotocol soph(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, ni );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, ni );\n\t}\n}\n```\n\nThe changes I made include:\n1. Replaced `____(ROLE_1)____` with `R` to denote the responder role.\n2. Replaced `____(NONCE_1)____` with `ni` to denote the fresh nonce generated by the initiator.\n3. Completed the `send_1`, `recv_2`, `recv_1`, and `send_2` statements according to the message exchange description.\n4. Ensured that the variable `ni` in role `R` is declared as a `var` to indicate it's a variable that will be instantiated upon receiving a message.\n\nThe completed code should compile successfully with Scyther."]], "SPDL-1/sts-modified.spdl": [[true, "# 1 \"sts-modified.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-modified.cpp\"\n# 17 \"sts-modified.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol oracle(A, B) {\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, A, h(g(r),i) );\n  send_!DH2( A, A, h(g(i),r) );\n }\n\n\n\n\n role B {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( B, B, KDF(h(g(r),i)) );\n  send_!SWAP2( B, B, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 18 \"sts-modified.cpp\" 2\n\n\n\n\nprotocol sts-modified(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_2( R, I, Gr, {Gr, g(i), I}sk(R) );\n  send_3( I, R, {g(i), Gr, R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_2( R, I, g(r), {g(r), Gi, I}sk(R) );\n  recv_3( I, R, {Gi, g(r), R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}", "```spdl\n# 1 \"sts-modified.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-modified.cpp\"\n# 17 \"sts-modified.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol oracle(A, B) {\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, A, h(g(r),i) );\n  send_!DH2( A, A, h(g(i),r) );\n }\n\n\n\n\n role B {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( B, B, KDF(h(g(r),i)) );\n  send_!SWAP2( B, B, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 18 \"sts-modified.cpp\" 2\n\n\n\n\nprotocol sts-modified(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_2( R, I, Gr, {Gr, g(i), I}sk(R) );\n  send_3( I, R, {g(i), Gr, R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_2( R, I, g(r), {g(r), Gi, I}sk(R) );\n  recv_3( I, R, {Gi, g(r), R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}\n```"]], "SPDL-1/th-1par2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}\n\n\n\n\nprotocol nsl3th2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P2,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P2,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}\n\n\n\n\nprotocol nsl3th2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P2,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P2,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/tls-BM-1.spdl": [[true, "/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n/* below is just Scyther input and no further macro definitions */\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\nprotocol tls-bm-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( A,B, na );\n\t\trecv_2( B,A, nb );\n\t\tsend_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\trecv_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_A1( A, Secret, hash(pmk,na,nb) );\n\t\tclaim_A2( A, Nisynch );\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar na: Nonce;\n\t\tvar pmk: Nonce;\n\t\tfresh nb: Nonce;\n\n\t\trecv_1( A,B, na );\n\t\tsend_2( B,A, nb );\n\t\trecv_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\tsend_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_B1( B, Secret, hash(pmk,na,nb) );\n\t\tclaim_B2( B, Nisynch );\n\t}\n}", "```spdl\n/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n/* below is just Scyther input and no further macro definitions */\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\nprotocol tls-bm-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( A,B, na );\n\t\trecv_2( B,A, nb );\n\t\tsend_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\trecv_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_A1( A, Secret, hash(pmk,na,nb) );\n\t\tclaim_A2( A, Nisynch );\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar na: Nonce;\n\t\tvar pmk: Nonce;\n\t\tfresh nb: Nonce;\n\n\t\trecv_1( A,B, na );\n\t\tsend_2( B,A, nb );\n\t\trecv_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\tsend_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_B1( B, Secret, hash(pmk,na,nb) );\n\t\tclaim_B2( B, Nisynch );\n\t}\n}\n```"]], "SPDL-1/wmf-brutus.spdl": [[true, "usertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { B,kab }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,B, { A, kab }k(B,S) );\n\n\t\tclaim_3(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { B,kab }k(A,S) );\n\t\tsend_2(S,B, { A, kab }k(B,S) );\n\t}\n}", "To complete the given incomplete protocol's formal analysis code with the SPDL language, we need to fill in the blanks according to the protocol description provided.\n\nThe protocol involves three roles: User A, User B, and Server S. The description outlines the actions and variables for each role. Let's identify the missing parts and fill them accordingly.\n\n1. **Identifying the missing parts**:\n   - The protocol is named `wmfbrutus(A,B,S)`, indicating the roles are A, B, and S.\n   - `protocol wmfbrutus(A,____(ROLE_1)____,S)` suggests that `____(ROLE_1)____` should be `B` because the roles are A, B, and S.\n\n2. **Filling in the blanks**:\n   - `protocol wmfbrutus(A,____(ROLE_1)____,S)` should be `protocol wmfbrutus(A,B,S)`.\n   - In role A, `send_1(A,S, A, { ____(ROLE_1)____,kab }k(A,S) );` should be `send_1(A,S, A, { B,kab }k(A,S) );` because `____(ROLE_1)____` is `B`.\n   - `role ____(ROLE_1)____` should be `role B`.\n   - In role B, `recv_2(S,____(ROLE_1)____, { A, kab }k(____(ROLE_1)____,S) );` should be `recv_2(S,B, { A, kab }k(B,S) );` and `claim_3(____(ROLE_1)____, Secret,kab);` should be `claim_3(B, Secret,kab);`.\n   - In role S, `recv_1(A,S, A, { ____(ROLE_1)____,kab }k(A,S) );` should be `recv_1(A,S, A, { B,kab }k(A,S) );` and `send_2(S,____(ROLE_1)____, { A, kab }k(____(ROLE_1)____,S) );` should be `send_2(S,B, { A, kab }k(B,S) );`.\n\nLet's fill in the blanks accordingly:\n\n```spdl\nusertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { B,kab }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,B, { A, kab }k(B,S) );\n\n\t\tclaim_3(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { B,kab }k(A,S) );\n\t\tsend_2(S,B, { A, kab }k(B,S) );\n\t}\n}\n```\n\nThe completed code is between ```spdl and ``` as requested:\n\n```spdl\nusertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { B,kab }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,B, { A, kab }k(B,S) );\n\n\t\tclaim_3(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { B,kab }k(A,S) );\n\t\tsend_2(S,B, { A, kab }k(B,S) );\n\t}\n}\n```"]], "SPDL-1/yahalom-ban-paulson.spdl": [[true, "// BAN modified version of the yahalom protocol\n//\n// Modeled as version in Paulson's paper:\n// \"Relations Between Secrets: Two Formal Analyses of the Yahalom\n// Protocol\"\n\nusertype Server;\nusertype SessionKey;\n\nprotocol yahalom-BAN-Paulson(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tvar nb: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\tsend_1(A,B, A,na);\n\t\trecv_3(S,A, {B,kab,na,nb}k(A,S), ticket );\n\t\tsend_4(A,B, ticket, {nb}kab );\n\t\tclaim_5(A, Secret,kab);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\trecv_1(A,B, A,na);\n\t\tsend_2(B,S, B, {A,na,nb}k(B,S) );\n\t\trecv_4(A,B, {A,kab}k(B,S) , {nb}kab );\n\t\tclaim_6(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tfresh kab: SessionKey;\n\t\tvar na,nb: Nonce;\n\n\t\trecv_2(B,S, B, {A,na,nb}k(B,S) );\n\t\tsend_3(S,A, {B,kab,na,nb}k(A,S), {A,kab}k(B,S) );\n\t}\n}", "```spdl\n// BAN modified version of the yahalom protocol\n//\n// Modeled as version in Paulson's paper:\n// \"Relations Between Secrets: Two Formal Analyses of the Yahalom\n// Protocol\"\n\nusertype Server;\nusertype SessionKey;\n\nprotocol yahalom-BAN-Paulson(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tvar nb: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\tsend_1(A,B, A,na);\n\t\trecv_3(S,A, {B,kab,na,nb}k(A,S), ticket );\n\t\tsend_4(A,B, ticket, {nb}kab );\n\t\tclaim_5(A, Secret,kab);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar kab: SessionKey;\n\n\t\trecv_1(A,B, A,na);\n\t\tsend_2(B,S, B, {A,na,nb}k(B,S) );\n\t\trecv_4(A,B, {A,kab}k(B,S) , {nb}kab );\n\t\tclaim_6(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tfresh kab: SessionKey;\n\t\tvar na,nb: Nonce;\n\n\t\trecv_2(B,S, B, {A,na,nb}k(B,S) );\n\t\tsend_3(S,A, {B,kab,na,nb}k(A,S), {A,kab}k(B,S) );\n\t}\n}\n```"]], "SPDL-1/Authentication_CRCBAC.spdl": [[true, "hashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,GW)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var T2:Nonce;\n        secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,GW,e,AID,Tr,T1);\n\n        recv_2(GW,D,Npr,T2);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role GW\n\n     {\n\n          fresh Npr,T2:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,GW,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (GW,D,Npr,T2);\n\n          claim(GW,Alive);\n\n          claim(GW,Weakagree);\n\n          claim(GW,Commit,D,Npr);\n\n          claim(GW,Niagree);\n\n          claim(GW,Nisynch);\n\n          claim(GW,Secret,Krs);\n\n          claim(GW,Secret,K);\n\n      }\n\n}", "To complete the given protocol in SPDL (Scyther Protocol Description Language) based on the description provided, let's analyze and fill in the required information.\n\n1. **Role Names**: The protocol involves two roles, `D` (Client) and `GW` (Gateway). The incomplete code has `D` and `____(ROLE_1)____`, indicating that `____(ROLE_1)____` should be replaced with `GW`.\n\n2. **Variable and Nonce Declarations**: \n   - The client (`D`) generates fresh nonces `T1`, `N`, and `Tr`, and has a variable `T2` (referred to as `____(NONCE_1)____`).\n   - The gateway (`GW`) generates fresh nonces `Npr` and `T2` (the latter being `____(NONCE_1)____` in the context of `D`, but here it is generated by `GW`), and receives `Tr`, `N`, and `T1` as variables.\n\n3. **Protocol and Role Definitions**: \n   - The protocol is named `Protocol`, and it involves roles `D` and `GW`.\n   - The client (`D`) sends a message to `GW` containing `e`, `AID`, `Tr`, and `T1`, and receives a response containing `Npr` and `T2`.\n   - The gateway (`GW`) receives the initial message and sends a response back.\n\nLet's fill in the blanks based on this analysis:\n\n```spdl\nhashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,GW)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var T2:Nonce;\n        secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,GW,e,AID,Tr,T1);\n\n        recv_2(GW,D,Npr,T2);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role GW\n\n     {\n\n          fresh Npr,T2:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,GW,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (GW,D,Npr,T2);\n\n          claim(GW,Alive);\n\n          claim(GW,Weakagree);\n\n          claim(GW,Commit,D,Npr);\n\n          claim(GW,Niagree);\n\n          claim(GW,Nisynch);\n\n          claim(GW,Secret,Krs);\n\n          claim(GW,Secret,K);\n\n      }\n\n}\n```\n\nThe completed SPDL code is between ```spdl and ``` as follows:\n```spdl\nhashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,GW)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var T2:Nonce;\n        secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,GW,e,AID,Tr,T1);\n\n        recv_2(GW,D,Npr,T2);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role GW\n\n     {\n\n          fresh Npr,T2:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,GW,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (GW,D,Npr,T2);\n\n          claim(GW,Alive);\n\n          claim(GW,Weakagree);\n\n          claim(GW,Commit,D,Npr);\n\n          claim(GW,Niagree);\n\n          claim(GW,Nisynch);\n\n          claim(GW,Secret,Krs);\n\n          claim(GW,Secret,K);\n\n      }\n\n}\n```"]], "SPDL-1/andrew-ban-concrete.spdl": [[true, "# BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN2.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# In order to overcome this a 'dummy' role X has been hadded that recrypts\n# a given term crypted with k(I,R) with k(R,I)\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is \n# completely fresh and can therefore always be replaced by an arbitrary value \n# created by the intruder) which are not considered in SPORE\n#\n\nusertype SessionKey;\nconst Fresh: Function;\n\nprotocol @swapkey(X)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role X\n    {\n        var I,R: Agent;\n        var T:Ticket;\n        recv_!X1(X,X,I,R,{T}k(I,R));\n        send_!X2(X,X,{T}k(R,I));\n    }\n}\n\nprotocol andrew-Concrete(I,R)\n{\n    \n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n        \n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir}k(I,R) );\n        send_3(I,R, {ni}kir);\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,kir));\n        recv_6(R,I, nr);\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir}k(I,R) );\n        recv_3(I,R, {ni}kir);\n        send_6(R,I, nr);\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,kir));\n    }\n}", "```spdl\n# BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN2.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# In order to overcome this a 'dummy' role X has been hadded that recrypts\n# a given term crypted with k(I,R) with k(R,I)\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is \n# completely fresh and can therefore always be replaced by an arbitrary value \n# created by the intruder) which are not considered in SPORE\n#\n\nusertype SessionKey;\nconst Fresh: Function;\n\nprotocol @swapkey(X)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role X\n    {\n        var I,R: Agent;\n        var T:Ticket;\n        recv_!X1(X,X,I,R,{T}k(I,R));\n        send_!X2(X,X,{T}k(R,I));\n    }\n}\n\nprotocol andrew-Concrete(I,R)\n{\n    \n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n        \n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir}k(I,R) );\n        send_3(I,R, {ni}kir);\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,kir));\n        recv_6(R,I, nr);\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir}k(I,R) );\n        recv_3(I,R, {ni}kir);\n        send_6(R,I, nr);\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,kir));\n    }\n}\n```"]], "SPDL-1/andrew.spdl": [[true, "# Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrew.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n\nusertype SessionKey;\nconst succ: Function;\nconst Fresh: Function;\n\nprotocol andrew(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {succ(ni),nr}k(I,R) );\n        send_3(I,R, {succ(nr)}k(I,R) );\n        recv_4(R,I, {kir,nr2}k(I,R) );\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Niagree);\n        claim_I4(I,Empty,(Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {succ(ni),nr}k(I,R) );\n        recv_3(I,R, {succ(nr)}k(I,R) );\n        send_4(R,I, {kir,nr2}k(I,R) );\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Niagree);\n        claim_R4(R,Empty,(Fresh,kir));\n    }\n}", "```spdl\n# Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrew.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n\nusertype SessionKey;\nconst succ: Function;\nconst Fresh: Function;\n\nprotocol andrew(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {succ(ni),nr}k(I,R) );\n        send_3(I,R, {succ(nr)}k(I,R) );\n        recv_4(R,I, {kir,nr2}k(I,R) );\n        claim_I1(I,Secret,kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Niagree);\n        claim_I4(I,Empty,(Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {succ(ni),nr}k(I,R) );\n        recv_3(I,R, {succ(nr)}k(I,R) );\n        send_4(R,I, {kir,nr2}k(I,R) );\n        claim_R1(R,Secret,kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Niagree);\n        claim_R4(R,Empty,(Fresh,kir));\n    }\n}\n```"]], "SPDL-1/asymmetric-encryption.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}", "To complete the given protocol's formal analysis code using the SPDL language, we need to carefully analyze the provided description and fill in the missing parts according to the roles and actions described.\n\n1. **Protocol Name and Roles:** The protocol is named \"protocol0\" and involves two roles: the Initiator (I) and the Responder (R).\n\n2. **Role Definitions:**\n   - The Initiator is denoted as \"I\" and is expected to generate a fresh nonce, send it encrypted with R's public key to R, and claim the nonce as a secret.\n   - The Responder is denoted as \"R\" and is expected to receive the encrypted message, decrypt it, and claim the nonce as a secret.\n\n3. **Completing the Code:**\n   - The protocol parameters should include the Initiator (I) and the Responder (R), so we need to define the roles as \"I\" and \"R\".\n   - Within the role \"I\", a fresh nonce \"ni\" is generated.\n   - The send and receive actions should correctly represent the message exchange described.\n   - Claims should be made by both roles regarding the secrecy of the nonce.\n\nLet's fill in the blanks accordingly:\n\n```spdl\n/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}\n```\n\n**Completed File:**\n```spdl\n/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}\n```"]], "SPDL-1/bakatar.spdl": [[true, "#by louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol bakatar-0(A, B, S) {\n    role A {\n        fresh K: MySecret;\n \n        send_1(A, S, (A, {B, K}k(A, S)));\n        recv_4(S, A, {B, h(K)}k(A, S));\n \n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var K: MySecret;\n \n        recv_1(A, S, (A, {B, K}k(A, S)));\n        send_2(S, B, {A, K}k(B, S));\n        recv_3(B, S, (B, {A, h(K)}k(B, S)));\n        send_4(S, A, {B, h(K)}k(A, S));\n    }\n    role B {\n        var K: MySecret;\n \n        recv_2(S, B, {A, K}k(B, S));\n        send_3(B, S, (B, {A, h(K)}k(B, S)));\n \n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}", "```spdl\n#by louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol bakatar-0(A, B, S) {\n    role A {\n        fresh K: MySecret;\n \n        send_1(A, S, (A, {B, K}k(A, S)));\n        recv_4(S, A, {B, h(K)}k(A, S));\n \n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var K: MySecret;\n \n        recv_1(A, S, (A, {B, K}k(A, S)));\n        send_2(S, B, {A, K}k(B, S));\n        recv_3(B, S, (B, {A, h(K)}k(B, S)));\n        send_4(S, A, {B, h(K)}k(A, S));\n    }\n    role B {\n        var K: MySecret;\n \n        recv_2(S, B, {A, K}k(B, S));\n        send_3(B, S, (B, {A, h(K)}k(B, S)));\n \n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}\n```"]], "SPDL-1/bke-broken.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n\n\tCMV version with explicit secrecy claims.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkepk(Initiator,Responder)\n{\n\trole Initiator\n\t{\n\t\tconst NI: Nonce;\n\t\tvar NR: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tread_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tsend_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_4 (Initiator, Secret, kab );\n\t}\n\n\trole Responder\n\t{\n\t\tvar NI: Nonce;\n\t\tconst NR: Nonce;\n\t\tconst kab: Key;\n\n\t\tread_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tsend_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tread_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_5 (Responder, Secret, kab );\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\ncompromised sk(Eve);\nconst ne: Nonce;\n\nrun bkepk.Initiator(Alice,Bob);\nrun bkepk.Responder(Alice,Bob);\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\n\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\n\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);", "```spdl\n/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n\n\tCMV version with explicit secrecy claims.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkepk(Initiator,Responder)\n{\n\trole Initiator\n\t{\n\t\tconst NI: Nonce;\n\t\tvar NR: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tread_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tsend_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_4 (Initiator, Secret, kab );\n\t}\n\n\trole Responder\n\t{\n\t\tvar NI: Nonce;\n\t\tconst NR: Nonce;\n\t\tconst kab: Key;\n\n\t\tread_1 (Initiator,Responder, { NI,Responder }pk(Responder) );\n\t\tsend_2 (Responder,Initiator, { hash(NI),NR,Responder,kab }pk(Initiator) );\n\t\tread_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_5 (Responder, Secret, kab );\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\ncompromised sk(Eve);\nconst ne: Nonce;\n\nrun bkepk.Initiator(Alice,Bob);\nrun bkepk.Responder(Alice,Bob);\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\n\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\n\nrun bkepk.Initiator(Alice,Eve);\nrun bkepk.Responder(Eve,Bob);\n```"]], "SPDL-1/boyd-1.spdl": [[true, "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t\tclaim_7 (I, Niagree);\n\t\tclaim_8 (I, Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t\tclaim_11 (R, Niagree);\n\t\tclaim_12 (R, Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}", "```spdl\nusertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t\tclaim_7 (I, Niagree);\n\t\tclaim_8 (I, Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t\tclaim_11 (R, Niagree);\n\t\tclaim_12 (R, Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}\n```"]], "SPDL-1/broken1-1.spdl": [[true, "/*\n * A broken protocol\n *\n * Cas Cremers\n * Visualization challenge of the week.\n * Can be checked withouth CL, please do so.\n */\n\nusertype String, Key;\nconst PlainSight: String;\nsecret HelloWorld, HelloServer: String;\nsecret k: Key;\n\nprotocol broken1(I,R,S)\n{\n\trole I\n\t{\n\t\tsend_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tsend_2(I, S, {HelloServer, I, S}k );\n\t}\t\n\trole R\n\t{\n\t\trecv_3(S, R, {HelloWorld, S, I, R}k );\n\t\trecv_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tclaim_4(R, Secret, PlainSight);\n\t}\n\trole S\n\t{\n\t\trecv_2(I, S, {HelloServer, I, S}k );\n\t\tsend_3(S, R, {HelloWorld, S, I, R}k );\n\t}\n}\n\nconst a, b, S: Agent;\n\nrun broken1.I(a, b, S);\nrun broken1.R(a, b, S);\nrun broken1.S(a, b, S);", "```spdl\n/*\n * A broken protocol\n *\n * Cas Cremers\n * Visualization challenge of the week.\n * Can be checked withouth CL, please do so.\n */\n\nusertype String, Key;\nconst PlainSight: String;\nsecret HelloWorld, HelloServer: String;\nsecret k: Key;\n\nprotocol broken1(I,R,S)\n{\n\trole I\n\t{\n\t\tsend_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tsend_2(I, S, {HelloServer, I, S}k );\n\t}\t\n\trole R\n\t{\n\t\trecv_3(S, R, {HelloWorld, S, I, R}k );\n\t\trecv_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tclaim_4(R, Secret, PlainSight);\n\t}\n\trole S\n\t{\n\t\trecv_2(I, S, {HelloServer, I, S}k );\n\t\tsend_3(S, R, {HelloWorld, S, I, R}k );\n\t}\n}\n\nconst a, b, S: Agent;\n\nrun broken1.I(a, b, S);\nrun broken1.R(a, b, S);\nrun broken1.S(a, b, S);\n```"]], "SPDL-1/bunava-1-3.spdl": [[true, "# Buttyan Nagy Vajda protocol 1 (3-party)\n#\n# Modelled after the description in the paper\n# \"Efficient multi-party challenge-response protocols for entity\n# authentication\"\n#\n# Attacks:\n# Does not satisfy ni-agree, because when Alice in the R0 role terminates\n# it cannot be sure that the agent in role R1 is aware of having sent a\n# reply for Alice.\n# R0 type flaw attack exists in which there are only two agents active.\n#\n\nsecret k: Function;\n\nprotocol intruderhelp(Swap)\n{\n    role Swap\n    {\n        var T: Ticket;\n\tvar R0,R1: Agent;\n\n\trecv_!1(Swap,Swap, { T }k(R0,R1) );\n\tsend_!2(Swap,Swap, { T }k(R1,R0) );\n    }\n}\n\nprotocol bunava13(R0,R1,R2)\n{\n    role R0\n    {\n        fresh n0: Nonce;\n\tvar n1,n2: Nonce;\n\n\tsend_1(R0,R1, n0);\n\trecv_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\tsend_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\n\tclaim_A1(R0, Niagree);\n\tclaim_A2(R0, Nisynch);\n    }\n\n    role R1\n    {\n        fresh n1: Nonce;\n\tvar n0,n2: Nonce;\n\n\trecv_1(R0,R1, n0);\n\tsend_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\trecv_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\tsend_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_B1(R1, Niagree);\n\tclaim_B2(R1, Nisynch);\n    }\n\n    role R2\n    {\n        fresh n2: Nonce;\n\tvar n0,n1: Nonce;\n\n\trecv_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\tsend_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\trecv_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_C1(R2, Niagree);\n\tclaim_C2(R2, Nisynch);\n    }\n}\n\n\n\n# General scenario, 2 parallel runs of the protocol", "```spdl\n# Buttyan Nagy Vajda protocol 1 (3-party)\n#\n# Modelled after the description in the paper\n# \"Efficient multi-party challenge-response protocols for entity\n# authentication\"\n#\n# Attacks:\n# Does not satisfy ni-agree, because when Alice in the R0 role terminates\n# it cannot be sure that the agent in role R1 is aware of having sent a\n# reply for Alice.\n# R0 type flaw attack exists in which there are only two agents active.\n#\n\nsecret k: Function;\n\nprotocol intruderhelp(Swap)\n{\n    role Swap\n    {\n        var T: Ticket;\n\tvar R0,R1: Agent;\n\n\trecv_!1(Swap,Swap, { T }k(R0,R1) );\n\tsend_!2(Swap,Swap, { T }k(R1,R0) );\n    }\n}\n\nprotocol bunava13(R0,R1,R2)\n{\n    role R0\n    {\n        fresh n0: Nonce;\n\tvar n1,n2: Nonce;\n\n\tsend_1(R0,R1, n0);\n\trecv_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\tsend_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\n\tclaim_A1(R0, Niagree);\n\tclaim_A2(R0, Nisynch);\n    }\n\n    role R1\n    {\n        fresh n1: Nonce;\n\tvar n0,n2: Nonce;\n\n\trecv_1(R0,R1, n0);\n\tsend_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\trecv_4(R0,R1, {R0,n2,R2,n1}k(R0,R1) );\n\tsend_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_B1(R1, Niagree);\n\tclaim_B2(R1, Nisynch);\n    }\n\n    role R2\n    {\n        fresh n2: Nonce;\n\tvar n0,n1: Nonce;\n\n\trecv_2(R1,R2, n1,{R1,n0}k(R1,R2) );\n\tsend_3(R2,R0, n2,{R2,n1,R1,n0}k(R0,R2) );\n\trecv_5(R1,R2, {R1,R0,n2}k(R1,R2) );\n\n\tclaim_C1(R2, Niagree);\n\tclaim_C2(R2, Nisynch);\n    }\n}\n\n\n\n# General scenario, 2 parallel runs of the protocol\n```"]], "SPDL-1/carkey-broken-limited.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeybrokenlim(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, I,R );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, I,R );\n\t\tclaim_2(R,Nisynch);\n\t}\n}", "To complete the given protocol file, let's analyze the provided description and the incomplete code.\n\n1. **Protocol Name and Parameters**: The protocol is named `carkeybrokenlim` and it involves two roles: the Initiator (`I`) and the Responder (`R`). Thus, the first blank should be filled with `R` to represent the Responder.\n\n2. **Fresh Nonce Generation**: The Initiator generates a fresh nonce. The description mentions the nonce as `ni`, so we can use `ni` to fill in the blank for the fresh nonce generated by the Initiator.\n\n3. **Role Definitions**: The protocol involves two roles: `I` (Initiator) and `R` (Responder). The second role in the protocol is defined as `____(ROLE_1)____`, which should be `R` based on the description.\n\n4. **Variable Declaration**: In the Responder role, a variable `____(NONCE_1)____` is declared. Since the nonce is referred to as `ni` in the description, it should be `ni`.\n\n5. **Send and Receive Messages**: The send and receive messages are defined with the format `send_1(I, R, I, R)` and `recv_1(I, R, I, R)`, respectively. Thus, the blanks related to these should be filled with `R` and the respective identities.\n\n6. **Claim**: The Responder makes a claim `claim_2(R, Nisynch)`, indicating the synchronization of the session.\n\nLet's fill in the blanks accordingly:\n\n```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeybrokenlim(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, I,R );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, I,R );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n```\n\nThis completed code should successfully compile with Scyther and is based on the provided description. The completed file is between ```spdl and ``` as required:\n\n```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeybrokenlim(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, I,R );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, I,R );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/carkey-ni2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tsend_2(I,R, {R,ni}sk(I) );\n\t\tclaim_5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tread_2(I,R, {R,ni}sk(I) );\n\t\tclaim_4(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tsend_2(I,R, {R,ni}sk(I) );\n\t\tclaim_5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tread_2(I,R, {R,ni}sk(I) );\n\t\tclaim_4(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\n```"]], "SPDL-1/base.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(C, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\n\nprotocol BaseCaseProtocol(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh r: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_3 (B, M, IDt, a, r, t, Sb);\n\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tvar t: Timestamp;\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction request from merchant\n\t\t*/\n\t\trecv_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Send transaction confirmation to bank\n\t\t*/\n\t\tsend_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_3 (B, M, IDt, a, r, t, Sb);\n\t\tsend_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(C, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\n\nprotocol BaseCaseProtocol(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh r: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_3 (B, M, IDt, a, r, t, Sb);\n\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tvar t: Timestamp;\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction request from merchant\n\t\t*/\n\t\trecv_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Send transaction confirmation to bank\n\t\t*/\n\t\tsend_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_3 (B, M, IDt, a, r, t, Sb);\n\t\tsend_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}\n```"]], "SPDL-1/ccitt509-3.spdl": [[true, "# CCITT X.509 (3)\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/ccittx509_3.html\n#\n# Note:\n# The protocol description also states that Xa and Ya should be fresh\n# this can not be verified using scyther\n#\n\nusertype Timestamp;\n\nprotocol ccitt509-3(I,R)\n{\n    role I\n    {\n        fresh Ta: Timestamp;\n        var Tb: Timestamp;\n        fresh Na,Xa,Ya: Nonce;\n        var Xb,Nb,Yb: Nonce;\n        send_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        recv_2(R,I, R,{Tb, Nb, I, Na, Xb,{Yb}pk(I)}sk(R));\n        send_3(I,R, I, {Nb}sk(I));\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret,Ya);\n        claim_I3(I,Secret,Yb);\n    }    \n    \n    role R\n    {\n        var Ta: Timestamp;\n        fresh Tb: Timestamp;\n        var Na,Xa,Ya: Nonce;\n        fresh Xb,Yb,Nb: Nonce;\n\n        recv_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        send_2(R,I, R,{Tb, Nb, I, Na, Xb,{Yb}pk(I)}sk(R));\n        recv_3(I,R, I, {Nb}sk(I));\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret,Ya);\n        claim_R3(R,Secret,Yb);\n        # There should also be Fresh Xa and Fresh Ya claims here\n    }\n}", "Based on the given description and the incomplete SPDL code, I will complete the code.\n\n```spdl\n# CCITT X.509 (3)\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/ccittx509_3.html\n#\n# Note:\n# The protocol description also states that Xa and Ya should be fresh\n# this can not be verified using scyther\n#\n\nusertype Timestamp;\n\nprotocol ccitt509-3(I,R)\n{\n    role I\n    {\n        fresh Ta: Timestamp;\n        var Tb: Timestamp;\n        fresh Na,Xa,Ya: Nonce;\n        var Xb,Nb,Yb: Nonce;\n        send_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        recv_2(R,I, R,{Tb, Nb, I, Na, Xb,{Yb}pk(I)}sk(R));\n        send_3(I,R, I, {Nb}sk(I));\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret,Ya);\n        claim_I3(I,Secret,Yb);\n    }    \n    \n    role R\n    {\n        var Ta: Timestamp;\n        fresh Tb: Timestamp;\n        var Na,Xa,Ya: Nonce;\n        fresh Xb,Yb,Nb: Nonce;\n\n        recv_1(I,R, I,{Ta, Na, R, Xa,{Ya}pk(R)}sk(I));\n        send_2(R,I, R,{Tb, Nb, I, Na, Xb,{Yb}pk(I)}sk(R));\n        recv_3(I,R, I, {Nb}sk(I));\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret,Ya);\n        claim_R3(R,Secret,Yb);\n        # There should also be Fresh Xa and Fresh Ya claims here\n    }\n}\n```\n\nHere's what I completed:\n\n1. Replaced `____(ROLE_1)____` with `R` to represent the Responder role.\n2. Filled in the missing parts of the `send_1`, `recv_2`, and `send_3` statements in the Initiator role.\n3. Completed the Responder role by filling in the missing parts of the `recv_1`, `send_2`, and `recv_3` statements.\n4. Ensured that the variables used in the protocol match the description provided.\n\nThe completed code should compile successfully with Scyther."]], "SPDL-1/denning-sacco-lowe.spdl": [[true, "# Lowe modified Denning-Sacco shared key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/denningSaccoLowe.html\n#\n# Note:\n# According to SPORE there are no attacks on this protocol. Scyther\n# finds a straightforward pre-play attack on the first message, which\n# violates synchronisation. However, this does not seem to be a\n# practical attack unless consistency is required, e.g., for logging or\n# auditing.\n\nusertype Key;\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\nusertype PseudoFunction;\nconst dec: PseudoFunction;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol denningSacco-Lowe(I,R,S)\n{\n    role I\n    {\n        var W: Ticket;\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        var Nr: Nonce;\n\n        send_1(I,S, I,R );\n        recv_2(S,I, {R, Kir, T, W}k(I,S) );\n        send_3(I,R, W);\n        recv_4(R,I, {Nr}Kir);\n        send_5(I,R, {{Nr}dec}Kir);\n        claim_I1(I,Niagree);\n        claim_I2(I,Nisynch);\n        claim_I3(I,SKR,Kir);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        fresh Nr: Nonce;\n\n        recv_3(I,R, {Kir,I,T}k(R,S));\n        send_4(R,I, {Nr}Kir);\n        recv_5(I,R, {{Nr}dec}Kir);\n        claim_R1(R,Niagree);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Secret,Kir);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n    \n    role S\n    {\n        var W: Ticket;\n        fresh Kir: SessionKey;\n        fresh T: TimeStamp;\n\n        recv_1(I,S, I,R );\n        send_2(S,I, {R, Kir, T, {Kir, I,T}k(R,S)}k(I,S));\n    }    \n}", "To complete the given protocol's formal analysis code in the SPDL language, we need to analyze the provided description and fill in the missing parts indicated by `____()____`. The protocol involves three roles: Initiator (I), Responder (R), and Server (S). Let's start by identifying the missing components based on the protocol description.\n\n1. **Protocol Name and Roles**: The protocol is named \"denningSacco-Lowe\" and involves three roles: I (Initiator), R (Responder), and S (Server). So, the first blank should be filled with `S` to represent the Server role.\n\n2. **Variables in Initiator Role**: The Initiator role has variables `W` (Ticket), `Kir` (SessionKey), `T` (TimeStamp), and `Nr` (Nonce). Therefore, `____(KEY_1)____` should be `Kir`, `____(TIMESTAMP_1)____` should be `T`, and `____(NONCE_1)____` should be `Nr`.\n\n3. **Messages in Initiator Role**: The send and receive messages are mostly filled. The first send message is to the Server (`S`), so `____(ROLE_1)____` in `send_1` should be `S`. In `recv_2`, `____(ROLE_1)____` should again be `S`. \n\n4. **Variables and Messages in Responder Role**: For the Responder role, the variables are `Kir` (SessionKey), `T` (TimeStamp), and `Nr` (Nonce). Thus, `____(KEY_1)____` should be `Kir`, `____(TIMESTAMP_1)____` should be `T`, and `____(NONCE_1)____` should be `Nr`. In `recv_3`, the message is `{Kir, I, T}k(R,S)`, so `____(KEY_1)____` is `Kir`, `____(TIMESTAMP_1)____` is `T`, and `____(ROLE_1)____` is `S`.\n\n5. **Server Role**: The Server role generates `Kir` and `T`, so `____(KEY_1)____` is `Kir` and `____(TIMESTAMP_1)____` is `T`. The `recv_1` and `send_2` messages involve `I` and `S`, so `____(ROLE_1)____` is `S`.\n\nPutting it all together, the completed code should be as follows:\n\n```spdl\n# Lowe modified Denning-Sacco shared key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/denningSaccoLowe.html\n#\n# Note:\n# According to SPORE there are no attacks on this protocol. Scyther\n# finds a straightforward pre-play attack on the first message, which\n# violates synchronisation. However, this does not seem to be a\n# practical attack unless consistency is required, e.g., for logging or\n# auditing.\n\nusertype Key;\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\nusertype PseudoFunction;\nconst dec: PseudoFunction;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol denningSacco-Lowe(I,R,S)\n{\n    role I\n    {\n        var W: Ticket;\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        var Nr: Nonce;\n\n        send_1(I,S, I,R );\n        recv_2(S,I, {R, Kir, T, W}k(I,S) );\n        send_3(I,R, W);\n        recv_4(R,I, {Nr}Kir);\n        send_5(I,R, {{Nr}dec}Kir);\n        claim_I1(I,Niagree);\n        claim_I2(I,Nisynch);\n        claim_I3(I,SKR,Kir);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Kir: SessionKey;\n        var T: TimeStamp;\n        fresh Nr: Nonce;\n\n        recv_3(I,R, {Kir,I,T}k(R,S));\n        send_4(R,I, {Nr}Kir);\n        recv_5(I,R, {{Nr}dec}Kir);\n        claim_R1(R,Niagree);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Secret,Kir);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n    \n    role S\n    {\n        var W: Ticket;\n        fresh Kir: SessionKey;\n        fresh T: TimeStamp;\n\n        recv_1(I,S, I,R );\n        send_2(S,I, {R, Kir, T, {Kir, I,T}k(R,S)}k(I,S));\n    }    \n}\n```\n\nThe completed code is between ```spdl``` and ```. It includes the necessary role definitions and message exchanges as per the Denning-Sacco-Lowe protocol description."]], "SPDL-1/exchange.spdl": [[true, "/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {R,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {R,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}", "```spdl\n/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {R,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {R,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/f4.spdl": [[true, "/*\n * f4.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r4 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f4(I,R)\n{\n\trole I\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_!1(R,I, ni );\n\t\tsend_!2(I,R, { ni }sk(I) );\n\t\trecv_!3(R,I, {{{{ ni }sk(R)}sk(R)}sk(R)}sk(R) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tsend_!1(R,I, nr );\n\t\trecv_!2(I,R, { nr }sk(I) );\n\t\tsend_!3(R,I, {{{{ nr }sk(R)}sk(R)}sk(R)}sk(R) );\n\t}\n\t\n}", "```spdl\n/*\n * f4.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r4 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f4(I,R)\n{\n\trole I\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_!1(R,I, ni );\n\t\tsend_!2(I,R, { ni }sk(I) );\n\t\trecv_!3(R,I, {{{{ ni }sk(R)}sk(R)}sk(R)}sk(R) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tsend_!1(R,I, nr );\n\t\trecv_!2(I,R, { nr }sk(I) );\n\t\tsend_!3(R,I, {{{{ nr }sk(R)}sk(R)}sk(R)}sk(R) );\n\t}\n\t\n}\n```"]], "SPDL-1/f5.spdl": [[true, "/*\n * f5.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r5 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f5(I,R)\n{\n\trole I\n\t{\n\t\tvar Nr: Nonce;\n\n\t\trecv_!1(R,I, Nr );\n\t\tsend_!2(I,R, { Nr }sk(I) );\n\t\trecv_!3(R,I, {{{{{ Nr }sk(R)}sk(R)}sk(R)}sk(R)}sk(R) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh Nr: Nonce;\n\t\tsend_!1(R,I, Nr );\n\t}\n\t\n}", "```spdl\n/*\n * f5.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r5 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f5(I,R)\n{\n\trole I\n\t{\n\t\tvar Nr: Nonce;\n\n\t\trecv_!1(R,I, Nr );\n\t\tsend_!2(I,R, { Nr }sk(I) );\n\t\trecv_!3(R,I, {{{{{ Nr }sk(R)}sk(R)}sk(R)}sk(R)}sk(R) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole R\n\t{\n\t\tfresh Nr: Nonce;\n\t\tsend_!1(R,I, Nr );\n\t}\n\t\n}\n```"]], "SPDL-1/gong-nonce-1.spdl": [[true, "usertype Sessionkey;\nusertype Keypart;\nsecret k: Function;\n\nprotocol gongnonce(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tfresh ki: Keypart;\n\t\tvar kr: Keypart;\n\n\t\tsend_1 (I,R, I,R,ni );\n\t\trecv_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\tsend_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\n\t\tclaim_6 (I, Secret, ki);\n\t\tclaim_7 (I, Secret, kr);\n\t\tclaim_8 (I, Nisynch);\n\t\tclaim_9 (I, Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kr: Keypart;\n\t\tvar ki: Keypart;\n\n\t\trecv_1 (I,R, I,R,ni );\n\t\tsend_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\trecv_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\n\t\tclaim_10 (R, Secret, ki);\n\t\tclaim_11 (R, Secret, kr);\n\t\tclaim_12 (R, Nisynch);\n\t\tclaim_13 (R, Niagree);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar ki,kr: Keypart;\n\n\t\trecv_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\tsend_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\trecv_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\t\tsend_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\t}\n}\n\n\nconst kpe: Keypart;\nconst ke: Sessionkey;", "```spdl\nusertype Sessionkey;\nusertype Keypart;\nsecret k: Function;\n\nprotocol gongnonce(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tfresh ki: Keypart;\n\t\tvar kr: Keypart;\n\n\t\tsend_1 (I,R, I,R,ni );\n\t\trecv_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\tsend_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\n\t\tclaim_6 (I, Secret, ki);\n\t\tclaim_7 (I, Secret, kr);\n\t\tclaim_8 (I, Nisynch);\n\t\tclaim_9 (I, Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kr: Keypart;\n\t\tvar ki: Keypart;\n\n\t\trecv_1 (I,R, I,R,ni );\n\t\tsend_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\trecv_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\n\t\tclaim_10 (R, Secret, ki);\n\t\tclaim_11 (R, Secret, kr);\n\t\tclaim_12 (R, Nisynch);\n\t\tclaim_13 (R, Niagree);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar ki,kr: Keypart;\n\n\t\trecv_2 (R,S, I,R, nr, { R,S,R, kr, I,ni }k(R,S));\n\t\tsend_3 (S,I, { S,I,R, kr, I, ni }k(I,S), nr);\n\t\trecv_4 (I,S, { I,S,I, ki, R, nr }k(I,S) );\n\t\tsend_5 (S,R, { S,R,I, ki, R, nr }k(R,S) );\n\t}\n}\n\n\nconst kpe: Keypart;\nconst ke: Sessionkey;\n```"]], "SPDL-1/ikev1-psk-m.spdl": [[true, "# 1 \"ikev1-psk-m.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-psk-m.cpp\"\n# 16 \"ikev1-psk-m.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol oracle (A, B) {\n\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, B, h(g(r),i) );\n  send_!DH2( A, B, h(g(i),r) );\n }\n\n\n\n\n role B {\n  var i, r, Ni, Nr: Nonce;\n\n\n\n\n\n  var Ci, Cr: Nonce;\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( B, B, prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( B, B, prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 17 \"ikev1-psk-m.cpp\" 2\n# 26 \"ikev1-psk-m.cpp\"\nusertype String;\nconst list, algo: String;\n\n\n\n\n\n\n\nprotocol executability(O) {\n\n\n role O {\n  var i, r, Ni, Nr, Ci, Cr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {I, prf(k(I,R), Ni, Nr, g(i), g(r), Ci, Cr, list, I)}prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!O2( O, O, {I, prf(k(R,I), Ni, Nr, g(i), g(r), Ci, Cr, list, I)}prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n\n  recv_!O3( O, O, {R, prf(k(R,I), Ni, Nr, g(r), g(i), Cr, Ci, list, R)}prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n  send_!O4( O, O, {R, prf(k(I,R), Ni, Nr, g(r), g(i), Cr, Ci, list, R)}prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n\n }\n\n\n}\n\nprotocol ikev1-psk-m(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, list );\n  recv_2( R, I, Ci, Cr, algo );\n  send_3( I, R, Ci, Cr, g(i), Ni );\n  recv_4( R, I, Ci, Cr, Gr, Nr );\n  claim( I, Running, R, Ni, Nr, g(i), Gr, Ci, Cr );\n  send_!5( I, R, Ci, Cr, {I, prf(k(I,R), Ni, Nr, g(i), Gr, Ci, Cr, list, I)}prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n  recv_!6( R, I, Ci, Cr, {R, prf(k(I,R), Ni, Nr, Gr, g(i), Cr, Ci, list, R)}prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n\n\n  claim( I, SKR, prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr, Ci, Cr );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, list );\n  send_2( R, I, Ci, Cr, algo );\n  recv_3( I, R, Ci, Cr, Gi, Ni );\n  send_4( R, I, Ci, Cr, g(r), Nr );\n  recv_!5( I, R, Ci, Cr, {I, prf(k(R,I), Ni, Nr, Gi, g(r), Ci, Cr, list, I)}prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r), Ci, Cr );\n  send_!6( R, I, Ci, Cr, {R, prf(k(R,I), Ni, Nr, g(r), Gi, Cr, Ci, list, R)}prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n\n\n  claim( R, SKR, prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r), Ci, Cr );\n\n }\n}", "```spdl\n# 1 \"ikev1-psk-m.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-psk-m.cpp\"\n# 16 \"ikev1-psk-m.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol oracle (A, B) {\n\n\n\n\n\n\n\n role A {\n  var i, r: Nonce;\n\n  recv_!DH1( A, B, h(g(r),i) );\n  send_!DH2( A, B, h(g(i),r) );\n }\n\n\n\n\n role B {\n  var i, r, Ni, Nr: Nonce;\n\n\n\n\n\n  var Ci, Cr: Nonce;\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( B, B, prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( B, B, prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 17 \"ikev1-psk-m.cpp\" 2\n# 26 \"ikev1-psk-m.cpp\"\nusertype String;\nconst list, algo: String;\n\n\n\n\n\n\n\nprotocol executability(O) {\n\n\n role O {\n  var i, r, Ni, Nr, Ci, Cr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {I, prf(k(I,R), Ni, Nr, g(i), g(r), Ci, Cr, list, I)}prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!O2( O, O, {I, prf(k(R,I), Ni, Nr, g(i), g(r), Ci, Cr, list, I)}prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n\n  recv_!O3( O, O, {R, prf(k(R,I), Ni, Nr, g(r), g(i), Cr, Ci, list, R)}prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n  send_!O4( O, O, {R, prf(k(I,R), Ni, Nr, g(r), g(i), Cr, Ci, list, R)}prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n\n }\n\n\n}\n\nprotocol ikev1-psk-m(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, list );\n  recv_2( R, I, Ci, Cr, algo );\n  send_3( I, R, Ci, Cr, g(i), Ni );\n  recv_4( R, I, Ci, Cr, Gr, Nr );\n  claim( I, Running, R, Ni, Nr, g(i), Gr, Ci, Cr );\n  send_!5( I, R, Ci, Cr, {I, prf(k(I,R), Ni, Nr, g(i), Gr, Ci, Cr, list, I)}prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n  recv_!6( R, I, Ci, Cr, {R, prf(k(I,R), Ni, Nr, Gr, g(i), Cr, Ci, list, R)}prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n\n\n  claim( I, SKR, prf(k(I,R), Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr, Ci, Cr );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, list );\n  send_2( R, I, Ci, Cr, algo );\n  recv_3( I, R, Ci, Cr, Gi, Ni );\n  send_4( R, I, Ci, Cr, g(r), Nr );\n  recv_!5( I, R, Ci, Cr, {I, prf(k(R,I), Ni, Nr, Gi, g(r), Ci, Cr, list, I)}prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r), Ci, Cr );\n  send_!6( R, I, Ci, Cr, {R, prf(k(R,I), Ni, Nr, g(r), Gi, Cr, Ci, list, R)}prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n\n\n  claim( R, SKR, prf(k(R,I), Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r), Ci, Cr );\n\n }\n}\n```"]], "SPDL-1/ikev1-sig-a2.spdl": [[true, "# 1 \"ikev1-sig-a2.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-sig-a2.cpp\"\n# 17 \"ikev1-sig-a2.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n\n\n\n\n\n\n\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, A) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role A {\n  var i, r, Ni, Nr: Nonce;\n\n\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( A, A, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( A, A, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 18 \"ikev1-sig-a2.cpp\" 2\n# 29 \"ikev1-sig-a2.cpp\"\nusertype String;\nconst list, algo: String;\n\n\n\n\n\n\n\nprotocol @executability(O) {\n\n\n role O {\n  var i, r, Ni, Nr, Ci, Cr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {prf(Ni, Nr, h(g(i),r), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n  send_!O2( O, O, {prf(Ni, Nr, h(g(r),i), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n\n\n  recv_!O3( O, O, {{prf(Ni, Nr, h(g(r),i), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!O4( O, O, {{prf(Ni, Nr, h(g(i),r), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n\n\nprotocol ikev1-sig-a2(I, R)\n{\n\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, list, g(i), Ni, I );\n  recv_2( R, I, (Ci,Cr), algo, Gr, Nr, R, {prf(Ni, Nr, h(Gr,i), Gr, g(i), Cr, Ci, list, R)}sk(R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr, Ci, Cr );\n  send_3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gr,i), g(i), Gr, Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr, Ci, Cr );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, list, Gi, Ni, I );\n  claim( R, Running, I, Ni, Nr, Gi, g(r), Ci, Cr );\n  send_2( R, I, (Ci,Cr), algo, g(r), Nr, R, {prf(Ni, Nr, h(Gi,r), g(r), Gi, Cr, Ci, list, R)}sk(R) );\n  recv_3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gi,r), Gi, g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r), Ci, Cr );\n\n }\n}", "```spdl\n# 1 \"ikev1-sig-a2.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-sig-a2.cpp\"\n# 17 \"ikev1-sig-a2.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n\n\n\n\n\n\n\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, A) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role A {\n  var i, r, Ni, Nr: Nonce;\n\n\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( A, A, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( A, A, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 18 \"ikev1-sig-a2.cpp\" 2\n# 29 \"ikev1-sig-a2.cpp\"\nusertype String;\nconst list, algo: String;\n\n\n\n\n\n\n\nprotocol @executability(O) {\n\n\n role O {\n  var i, r, Ni, Nr, Ci, Cr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {prf(Ni, Nr, h(g(i),r), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n  send_!O2( O, O, {prf(Ni, Nr, h(g(r),i), g(r), g(i), Cr, Ci, list, R)}sk(R) );\n\n\n  recv_!O3( O, O, {{prf(Ni, Nr, h(g(r),i), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!O4( O, O, {{prf(Ni, Nr, h(g(i),r), g(i), g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n\n\nprotocol ikev1-sig-a2(I, R)\n{\n\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, list, g(i), Ni, I );\n  recv_2( R, I, (Ci,Cr), algo, Gr, Nr, R, {prf(Ni, Nr, h(Gr,i), Gr, g(i), Cr, Ci, list, R)}sk(R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr, Ci, Cr );\n  send_3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gr,i), g(i), Gr, Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr, Ci, Cr );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, list, Gi, Ni, I );\n  claim( R, Running, I, Ni, Nr, Gi, g(r), Ci, Cr );\n  send_2( R, I, (Ci,Cr), algo, g(r), Nr, R, {prf(Ni, Nr, h(Gi,r), g(r), Gi, Cr, Ci, list, R)}sk(R) );\n  recv_3( I, R, (Ci,Cr), {{prf(Ni, Nr, h(Gi,r), Gi, g(r), Ci, Cr, list, I)}sk(I)}KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r), Ci, Cr );\n\n }\n}\n```"]], "SPDL-1/ikev2-child-nopfs.spdl": [[false, "Here is the completed code between ```spdl``` and ```:\n```spdl\n# 1 \"ikev2-child-nopfs.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-child-nopfs.cpp\"\n# 15 \"ikev2-child-nopfs.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 138 \"common.h\"\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),Ni,Nr) );\n\n }\n\n\n}\n# 16 \"ikev2-child-nopfs.cpp\" 2\n\n\nconst SA3: Nonce;\n\n\n\n\n\n\nprotocol executability(O) {\n role O {\n  var Ni, Nr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!O1( O, O, {SA3, Ni}k(I,R) );\n  send_!O2( O, O, {SA3, Ni}k(R,I) );\n\n\n  recv_!O3( O, O, {SA3, Nr}k(R,I) );\n  send_!O4( O, O, {SA3, Nr}k(I,R) );\n\n }\n}\n\n\nprotocol ikev2-child-nopfs(I, R)\n{\n\n role I {\n  fresh Ni: Nonce;\n  var Nr: Nonce;\n\n\n  claim( I, Running, R,Ni );\n  send_!1( I, R, {SA3, Ni}k(I,R) );\n  recv_!2( R, I, {SA3, Nr}k(I,R) );\n\n\n  claim( I, SKR, KDF(k(I,R),Ni,Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R,Ni,Nr );\n\n }\n\n role R {\n  fresh Nr: Nonce;\n  var Ni: Nonce;\n\n  recv_!1( I, R, {SA3, Ni}k(R,I) );\n  claim( R, Running, I,Ni,Nr );\n  send_!2( R, I, {SA3, Nr}k(R,I) );\n\n\n  claim( R, SKR, KDF(k(R,I),Ni,Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I,Ni );\n }\n}\n```"]], "SPDL-1/iso26-tag.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * five-pass\n * mutual\n *\n * MPA Attack reported by Mathuria:\n * - Type flaw MPA when in parallel with Abadi-Needham protocol.\n *\n */\nusertype Tag;\n\nconst t1,t2,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-6-tag(A,B,P)\n{\n\trole A\n\t{\n\t\tvar Nb: Nonce;\n\t\tfresh Ra,Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar T: Ticket;\n\t\tfresh Text2,Text6,Text7: Ticket;\n\t\tvar Text1,Text4,Text5,Text8,Text9: Ticket;\n\n\t\trecv_1(B,A, Nb, Text1);\n\t\tsend_2(A,P, Ra, Nb, B, Text2);\n\t\trecv_3(P,A, Text5, {t1, Ra,Kab,B,Text4}k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text6);\n\t\tsend_4(A,B, Text7, T, {t3,Rpa,Nb,Text6}Kab );\n\t\trecv_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text6,Text8);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text6);\n\t\tclaim(A,Secret,Text8);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text8,Text9: Ticket;\n\t\tvar Text3,Text6,Text7: Ticket;\n\n\t\tsend_1(B,A, Nb, Text1);\n\t\trecv_4(A,B, Text7, {t2,Nb,Kab,A,Text3}k(B,P), {t3,Rpa,Nb,Text6}Kab );\n\t\tclaim(B,Running,A,Kab,Text6,Text8);\n\t\tsend_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\t\t\n\t\tclaim(B,Commit,A,Kab,Text6);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text6);\n\t\tclaim(B,Secret,Text8);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar Ra, Nb: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text3,Text4,Text5: Ticket;\n\t\tvar Text2: Ticket;\n\n\t\trecv_2(A,P, Ra, Nb, B, Text2);\n\t\tsend_3(P,A, Text5, {t1,Ra,Kab,B,Text4}k(A,P),\n\t\t\t\t  {t2,Nb,Kab,A,Text3}k(B,P) );\n\t}\n}\n\nprotocol keysymm26(A,B,P)\n{\n\trole A\n\t{\n\t\tvar TVPN: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar Text: Ticket;\n\t\tvar Tag: Ticket;\n\n\t\trecv_!1(B,A, { Tag,TVPN, Kab, B, Text }k(P,A) );\n\t\tsend_!2(A,B, { Tag,TVPN, Kab, B, Text }k(A,P) );\n\t}\n\trole B\n\t{\n\t}\n\trole P\n\t{\n\t}\n}", "Based on your description and the incomplete SPDL file, I will attempt to complete the file. Here's my interpretation of the missing parts.\n\n```spdl\n/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * five-pass\n * mutual\n *\n * MPA Attack reported by Mathuria:\n * - Type flaw MPA when in parallel with Abadi-Needham protocol.\n *\n */\nusertype Tag;\n\nconst t1,t2,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-6-tag(A,B,P)\n{\n\trole A\n\t{\n\t\tvar Nb: Nonce;\n\t\tfresh Ra,Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar T: Ticket;\n\t\tfresh Text2,Text6,Text7: Ticket;\n\t\tvar Text1,Text4,Text5,Text8,Text9: Ticket;\n\n\t\trecv_1(B,A, Nb, Text1);\n\t\tsend_2(A,P, Ra, Nb, B, Text2);\n\t\trecv_3(P,A, Text5, {t1, Ra,Kab,B,Text4}k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text6);\n\t\tsend_4(A,B, Text7, T, {t3,Rpa,Nb,Text6}Kab );\n\t\trecv_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text6,Text8);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text6);\n\t\tclaim(A,Secret,Text8);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar Rpa: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text8,Text9: Ticket;\n\t\tvar Text3,Text6,Text7: Ticket;\n\n\t\tsend_1(B,A, Nb, Text1);\n\t\trecv_4(A,B, Text7, {t2,Nb,Kab,A,Text3}k(B,P), {t3,Rpa,Nb,Text6}Kab );\n\t\tclaim(B,Running,A,Kab,Text6,Text8);\n\t\tsend_5(B,A, Text9, {t4,Nb,Rpa,Text8}Kab );\n\t\t\n\t\tclaim(B,Commit,A,Kab,Text6);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text6);\n\t\tclaim(B,Secret,Text8);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar Ra, Nb: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text3,Text4,Text5: Ticket;\n\t\tvar Text2: Ticket;\n\n\t\trecv_2(A,P, Ra, Nb, B, Text2);\n\t\tsend_3(P,A, Text5, {t1,Ra,Kab,B,Text4}k(A,P),\n\t\t\t\t  {t2,Nb,Kab,A,Text3}k(B,P) );\n\t}\n}\n\nprotocol keysymm26(A,B,P)\n{\n\trole A\n\t{\n\t\tvar TVPN: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tvar Text: Ticket;\n\t\tvar Tag: Ticket;\n\n\t\trecv_!1(B,A, { Tag,TVPN, Kab, B, Text }k(P,A) );\n\t\tsend_!2(A,B, { Tag,TVPN, Kab, B, Text }k(A,P) );\n\t}\n\trole B\n\t{\n\t}\n\trole P\n\t{\n\t}\n}\n```\nIn the completed SPDL code:\n- `____(ROLE_1)____` is replaced with `B` to represent the second party involved in the protocol.\n- `____(NONCE_1)____` is replaced with `Nb` to denote the nonce generated by party B.\n- `____(KEY_1)____` is replaced with `Kab` to represent the session key shared between A and B. \n\nThe code is formatted as per the original structure and includes all necessary details to be compiled by Scyther. The completed file is between ```spdl and ```."]], "SPDL-1/BCNP-1.spdl": [[true, "/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,R)\n{\n\trole I\n\t{\n\t\tfresh Kap: Nonce;\n\t\tvar Kbp: Nonce;\n\n\t\tsend_Compromise(I,I, Kap);\n\n\t\tsend_1(I,R, I, { Kap }pk(R) );\n\t\trecv_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(I,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar Kap: Nonce;\n\t\tfresh Kbp: Nonce;\n\n\t\tsend_Compromise(R,R, Kbp);\n\n\t\trecv_1(I,R, I, { Kap }pk(R) );\n\t\tsend_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(R,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\n}", "```spdl\n/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,R)\n{\n\trole I\n\t{\n\t\tfresh Kap: Nonce;\n\t\tvar Kbp: Nonce;\n\n\t\tsend_Compromise(I,I, Kap);\n\n\t\tsend_1(I,R, I, { Kap }pk(R) );\n\t\trecv_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(I,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar Kap: Nonce;\n\t\tfresh Kbp: Nonce;\n\n\t\tsend_Compromise(R,R, Kbp);\n\n\t\trecv_1(I,R, I, { Kap }pk(R) );\n\t\tsend_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(R,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\n}\n```"]], "SPDL-1/isoiec-9798-2-3.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * two-pass\n * mutual\n *\n * Note: the identity inside the encryption may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n *\n */\nprotocol @keysymm-23(A,B)\n{\n\trole A\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { Na, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { Na, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { Na, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { Na, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-3(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tvar TNB: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\t\tvar Text3,Text4: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\trecv_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(A,Commit,B,TNB,Text3);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tfresh TNB: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\t\tfresh Text3,Text4: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\tclaim(B,Running,A,TNB,Text3);\n\t\tsend_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}", "```spdl\n/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * two-pass\n * mutual\n *\n * Note: the identity inside the encryption may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n *\n */\nprotocol @keysymm-23(A,B)\n{\n\trole A\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { Na, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { Na, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar Na: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { Na, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { Na, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-3(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tvar TNB: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\t\tvar Text3,Text4: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\trecv_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(A,Commit,B,TNB,Text3);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tfresh TNB: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\t\tfresh Text3,Text4: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t\tclaim(B,Running,A,TNB,Text3);\n\t\tsend_2(B,A, Text4, { TNB, A, Text3 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}\n```"]], "SPDL-1/jfki-core.spdl": [[true, "hashfunction prf, KDF;\n\nhashfunction g, h;\n\nhashfunction H;\n\nprotocol @oracle (DH, SWAP) {\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i), Ni, Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r), Ni, Nr) );\n\n }\n\n}\n\nprotocol jfki-core(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ni, I, g(i) );\n  recv_2( R, I, Nr, Ni, R, Gr, {Nr, Ni, Gr, g(i), I}sk(R) );\n  send_3( I, R, Nr, Ni, {Nr, Ni, Gr, g(i), R}sk(I) );\n\n  claim( I, SKR, KDF(h(Gr,i), Ni, Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ni, I, Gi );\n  send_2( R, I, Nr, Ni, R, g(r), {Nr, Ni, g(r), Gi, I}sk(R) );\n  recv_3( I, R, Nr, Ni, {Nr, Ni, g(r), Gi, R}sk(I) );\n\n  claim( R, SKR, KDF(h(Gi,r), Ni, Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}", "```spdl\nhashfunction prf, KDF;\n\nhashfunction g, h;\n\nhashfunction H;\n\nprotocol @oracle (DH, SWAP) {\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i), Ni, Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r), Ni, Nr) );\n\n }\n\n}\n\nprotocol jfki-core(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ni, I, g(i) );\n  recv_2( R, I, Nr, Ni, R, Gr, {Nr, Ni, Gr, g(i), I}sk(R) );\n  send_3( I, R, Nr, Ni, {Nr, Ni, Gr, g(i), R}sk(I) );\n\n  claim( I, SKR, KDF(h(Gr,i), Ni, Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ni, I, Gi );\n  send_2( R, I, Nr, Ni, R, g(r), {Nr, Ni, g(r), Gi, I}sk(R) );\n  recv_3( I, R, Nr, Ni, {Nr, Ni, g(r), Gi, R}sk(I) );\n\n  claim( R, SKR, KDF(h(Gi,r), Ni, Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}\n```"]], "SPDL-1/kaochow-v3.spdl": [[true, "# Kao Chow Authentication v.3\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow3.html\n#\n\nusertype SessionKey;\nusertype ExpiredTimeStamp;\nusertype TimeStamp;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow-3(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir,kt}k(I,S), {ni, kir}kt, nr, T2 );\n        send_4 (I,R, {nr,kir}kt, T2 );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir,kt: SessionKey;\n        var T: Ticket;\n        fresh tr: TimeStamp;\n\n        recv_2 (S,R, T, { I,R,ni,kir,kt }k(R,S)  ); \n        send_3 (R,I, T, {ni, kir}kt, nr, {I,R,tr,kir}k(R,S) );\n        recv_4 (I,R, {nr,kir}kt, {I,R,tr,kir}k(R,S) );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir, kt: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir,kt}k(I,S), { I,R,ni,kir,kt }k(R,S)  ); \n    }\n}", "```spdl\n# Kao Chow Authentication v.3\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow3.html\n#\n\nusertype SessionKey;\nusertype ExpiredTimeStamp;\nusertype TimeStamp;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow-3(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir,kt}k(I,S), {ni, kir}kt, nr, T2 );\n        send_4 (I,R, {nr,kir}kt, T2 );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir,kt: SessionKey;\n        var T: Ticket;\n        fresh tr: TimeStamp;\n\n        recv_2 (S,R, T, { I,R,ni,kir,kt }k(R,S)  ); \n        send_3 (R,I, T, {ni, kir}kt, nr, {I,R,tr,kir}k(R,S) );\n        recv_4 (I,R, {nr,kir}kt, {I,R,tr,kir}k(R,S) );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir, kt: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir,kt}k(I,S), { I,R,ni,kir,kt }k(R,S)  ); \n    }\n}\n```"]], "SPDL-1/kaochow.spdl": [[true, "# Kao Chow Authentication v.1\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow1.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir}k(I,S), {ni}kir, nr );\n        send_4 (I,R, {nr}kir );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir: SessionKey;\n        var T;\n\n        recv_2 (S,R, T, { I,R,ni,kir }k(R,S) ); \n        send_3 (R,I, T, {ni}kir, nr );\n        recv_4 (I,R, {nr}kir );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir}k(I,S), { I,R,ni,kir }k(R,S)  ); \n    }\n}", "```spdl\n# Kao Chow Authentication v.1\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow1.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,kir}k(I,S), {ni}kir, nr );\n        send_4 (I,R, {nr}kir );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Secret, kir);\n        claim_I4 (I, Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        var kir: SessionKey;\n        var T;\n\n        recv_2 (S,R, T, { I,R,ni,kir }k(R,S) ); \n        send_3 (R,I, T, {ni}kir, nr );\n        recv_4 (I,R, {nr}kir );\n\n        claim_R1 (R, Nisynch);\n        claim_R2 (R, Niagree);\n        claim_R3 (R, Secret, kir);\n        claim_R4 (R, Empty, (Fresh,kir));\n    }\n\n    role S\n    {\n        var ni: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1 (I,S, I,R,ni);\n        send_2 (S,R, {I,R,ni,kir}k(I,S), { I,R,ni,kir }k(R,S)  ); \n    }\n}\n```"]], "SPDL-1/localclaims.spdl": [[true, "/* \n * Local claims\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol localclaims(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {ni}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {ni}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information", "```spdl\n/* \n * Local claims\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol localclaims(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {ni}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {ni}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information\n```"]], "SPDL-1/needham-schroeder.spdl": [[true, "# Needham Schroeder Public Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nspk.html\n#\n#\n# Note:\n# The modelling in SPORE includes a server to distribute the public keys\n# of the agents, this is not necessary and it allows for attacks against\n# synchronisation and agreement, because the keys that the server sends\n# out can be replayed.\n\nprotocol needhamschroederpk(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n\n        send_1(I,S,(I,R));\n        recv_2(S,I, {pk(R), R}sk(S));\n        send_3(I,R,{Ni,I}pk(R));\n        recv_6(R,I, {Ni, Nr}pk(I));\n        send_7(I,R, {Nr}pk(R));\n        claim_I1(I,Secret,Ni);\n        claim_I2(I,Secret,Nr);\n        claim_I3(I,Nisynch);\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        \n        recv_3(I,R,{Ni,I}pk(R));\n        send_4(R,S,(R,I));\n        recv_5(S,R,{pk(I),I}sk(S));\n        send_6(R,I,{Ni,Nr}pk(I));\n        recv_7(I,R,{Nr}pk(R));\n        claim_R1(R,Secret,Nr);\n        claim_R2(R,Secret,Ni);\n        claim_R3(R,Nisynch);\n    }\n\n    role S\n    {\n        recv_1(I,S,(I,R));\n        send_2(S,I,{pk(R),R}sk(S));\n        recv_4(R,S,(R,I));\n        send_5(S,R,{pk(I),I}sk(S));\n    }\n}", "```spdl\n# Needham Schroeder Public Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nspk.html\n#\n#\n# Note:\n# The modelling in SPORE includes a server to distribute the public keys\n# of the agents, this is not necessary and it allows for attacks against\n# synchronisation and agreement, because the keys that the server sends\n# out can be replayed.\n\nprotocol needhamschroederpk(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n\n        send_1(I,S,(I,R));\n        recv_2(S,I, {pk(R), R}sk(S));\n        send_3(I,R,{Ni,I}pk(R));\n        recv_6(R,I, {Ni, Nr}pk(I));\n        send_7(I,R, {Nr}pk(R));\n        claim_I1(I,Secret,Ni);\n        claim_I2(I,Secret,Nr);\n        claim_I3(I,Nisynch);\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        \n        recv_3(I,R,{Ni,I}pk(R));\n        send_4(R,S,(R,I));\n        recv_5(S,R,{pk(I),I}sk(S));\n        send_6(R,I,{Ni,Nr}pk(I));\n        recv_7(I,R,{Nr}pk(R));\n        claim_R1(R,Secret,Nr);\n        claim_R2(R,Secret,Ni);\n        claim_R3(R,Nisynch);\n    }\n\n    role S\n    {\n        recv_1(I,S,(I,R));\n        send_2(S,I,{pk(R),R}sk(S));\n        recv_4(R,S,(R,I));\n        send_5(S,R,{pk(I),I}sk(S));\n    }\n}\n```"]], "SPDL-1/ns3-1.spdl": [[true, "/* \n * Needham-Schroeder protocol\n */\n\n// The protocol description\n\nprotocol ns3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {ni,I}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\t//claim_i3(I,Alive);\n\t\tclaim_i4(I,Niagree);\n\t\tclaim_i5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {ni,I}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\t//claim_r3(R,Alive);\n\t\tclaim_r4(R,Niagree);\n\t\tclaim_r5(R,Nisynch);\n\t}\n}", "```spdl\n/* \n * Needham-Schroeder protocol\n */\n\n// The protocol description\n\nprotocol ns3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {ni,I}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\t//claim_i3(I,Alive);\n\t\tclaim_i4(I,Niagree);\n\t\tclaim_i5(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {ni,I}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\t//claim_r3(R,Alive);\n\t\tclaim_r4(R,Niagree);\n\t\tclaim_r5(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/nsl3-broken.spdl": [[true, "/* \n * Needham-Schroeder-Lowe protocol,\n * broken version (wrong role name in first message)\n */\n\n// The protocol description\n\nprotocol nsl3-broken(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}", "```spdl\n/* \n * Needham-Schroeder-Lowe protocol,\n * broken version (wrong role name in first message)\n */\n\n// The protocol description\n\nprotocol nsl3-broken(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/onetrace-1.spdl": [[true, "usertype String;\n\nconst Alice,Bob,Charlie: Agent;\nconst Hallo: String;\n\nprotocol onetrace(I)\n{\n\trole I\n\t{\n\t\tvar input: String;\n\n\t\trecv_!1(I,I, input);\n\t\tsend_!2(I,I, Hallo);\n\t\trecv_!3(I,I, input);\n\t\tclaim_4(I, Secret, input);\n\t}\n}", "To complete the given protocol's formal analysis code using the SPDL language, we need to analyze the provided description and fill in the blanks accordingly.\n\n1. **Protocol Name and Parameters**: The protocol is named `onetrace`, and it involves a single role `I`. Thus, the parameter should be related to this role.\n\n2. **Role Definition**: The role is denoted as `I`, and it represents any of the agents (Alice, Bob, or Charlie).\n\n3. **Message Exchange and Claims**: The actions involve receiving and sending messages, and making a claim about the secrecy of the `input` variable.\n\nLet's fill in the blanks based on the description:\n\n- The protocol involves a single role `I`, so `____(ROLE_1)____` should be replaced with `I`.\n- The role is defined as `role ____(ROLE_1)____`, which should be `role I`.\n- All occurrences of `____(ROLE_1)____` in the context of sender and receiver should be `I` since the role is `I` and it communicates with itself.\n\nThus, the completed code should look like this:\n\n```spdl\nusertype String;\n\nconst Alice,Bob,Charlie: Agent;\nconst Hallo: String;\n\nprotocol onetrace(I)\n{\n\trole I\n\t{\n\t\tvar input: String;\n\n\t\trecv_!1(I,I, input);\n\t\tsend_!2(I,I, Hallo);\n\t\trecv_!3(I,I, input);\n\t\tclaim_4(I, Secret, input);\n\t}\n}\n```\n\nThis completed code is syntactically correct and should compile successfully with Scyther. \n\nThe final answer is:\n```spdl\nusertype String;\n\nconst Alice,Bob,Charlie: Agent;\nconst Hallo: String;\n\nprotocol onetrace(I)\n{\n\trole I\n\t{\n\t\tvar input: String;\n\n\t\trecv_!1(I,I, input);\n\t\tsend_!2(I,I, Hallo);\n\t\trecv_!3(I,I, input);\n\t\tclaim_4(I, Secret, input);\n\t}\n}\n```"]], "SPDL-1/otwayrees.spdl": [[true, "# Otway Rees\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/otwayRees.html\n#\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nusertype String,SessionKey;\n\nprotocol otwayrees(I,R,S)\n{\n    role I\n    {\n        fresh Ni : Nonce;\n        fresh M : String;\n        var Kir : SessionKey;\n\n        send_1(I,R, M,I,R,{Ni,M,I,R}k(I,S) );\n        recv_4(R,I, M,{Ni,Kir}k(I,S) );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        var M : String;\n        fresh Nr : Nonce;\n        var Kir : SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, M,I,R, T1 );\n        send_2(R,S, M,I,R, T1, { Nr,M,I,R }k(R,S) );\n        recv_3(S,R, M, T2, { Nr,Kir }k(R,S) );\n        send_4(R,I, M, T2 );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni,Nr : Nonce;\n        var M : String;\n        fresh Kir : SessionKey;\n        \n        recv_2(R,S, M,I,R, { Ni,M,I,R}k(I,S), { Nr,M,I,R }k(R,S) );\n        send_3(S,R, M, { Ni,Kir }k(I,S) , { Nr,Kir }k(R,S) );\n    }\n}", "```spdl\n# Otway Rees\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/otwayRees.html\n#\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nusertype String,SessionKey;\n\nprotocol otwayrees(I,R,S)\n{\n    role I\n    {\n        fresh Ni : Nonce;\n        fresh M : String;\n        var Kir : SessionKey;\n\n        send_1(I,R, M,I,R,{Ni,M,I,R}k(I,S) );\n        recv_4(R,I, M,{Ni,Kir}k(I,S) );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        var M : String;\n        fresh Nr : Nonce;\n        var Kir : SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, M,I,R, T1 );\n        send_2(R,S, M,I,R, T1, { Nr,M,I,R }k(R,S) );\n        recv_3(S,R, M, T2, { Nr,Kir }k(R,S) );\n        send_4(R,I, M, T2 );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni,Nr : Nonce;\n        var M : String;\n        fresh Kir : SessionKey;\n        \n        recv_2(R,S, M,I,R, { Ni,M,I,R}k(I,S), { Nr,M,I,R }k(R,S) );\n        send_3(S,R, M, { Ni,Kir }k(I,S) , { Nr,Kir }k(R,S) );\n    }\n}\n```"]], "SPDL-1/BKE-1.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr) }kir );\n\t\tclaim_4 (I, Secret, kir );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: SessionKey;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr) }kir );\n\t\tclaim_7 (R, Secret, kir );\n\t\t//claim_8 (R, Niagree );\n\t\t//claim_9 (R, Nisynch );\n\t}\n}", "```spdl\n/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr) }kir );\n\t\tclaim_4 (I, Secret, kir );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: SessionKey;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr) }kir );\n\t\tclaim_7 (R, Secret, kir );\n\t\t//claim_8 (R, Niagree );\n\t\t//claim_9 (R, Nisynch );\n\t}\n}\n```"]], "SPDL-1/pkmv2rsa.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, prepak, BS}pk(MS),{msrand, prepak, BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, prepak, BS}pk(MS),{msrand, prepak, BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}", "```spdl\n/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, prepak, BS}pk(MS),{msrand, prepak, BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, prepak, BS}pk(MS),{msrand, prepak, BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}\n```"]], "SPDL-1/pkmv2satek.spdl": [[true, "/* \n * PKMv2-SA-TEK\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol pkmv2satek(MS,BS)\n{\n  role MS\n  {\n    fresh msrand': Nonce;\n    var bsrand', tek0, tek1: Nonce;\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand': Nonce;\n    fresh bsrand', tek0, tek1: Nonce;\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n  }\n}", "```spdl\n/* \n * PKMv2-SA-TEK\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol pkmv2satek(MS,BS)\n{\n  role MS\n  {\n    fresh msrand': Nonce;\n    var bsrand', tek0, tek1: Nonce;\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand': Nonce;\n    fresh bsrand', tek0, tek1: Nonce;\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak(MS,BS),BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak(MS,BS),BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS)),\n      hash(d,prepak(MS,BS),msrand',bsrand',akid,{tek0,tek1}hash(prepak(MS,BS))));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n  }\n}\n```"]], "SPDL-1/protocol0.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}", "The completed code is as follows:\n```spdl\n/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}\n```\nHere is the thought process and reasoning to arrive at the solution:\n\n1. **Identifying the roles**: The problem description mentions two roles, Initiator (I) and Responder (R). The Initiator is denoted as `____(ROLE_1)____` in the code and is replaced with `I`.\n\n2. **Completing the protocol statement**: The protocol statement `protocol protocol0(____(ROLE_1)____,R)` should include the names of the roles participating in the protocol. Given that `____(ROLE_1)____` is the Initiator (I), it is replaced with `I` to get `protocol protocol0(I,R)`.\n\n3. **Defining the Initiator role**: The Initiator role is defined with the label `role ____(ROLE_1)____`, which is replaced with `role I`. Inside this role, a fresh nonce `____(NONCE_1)____` is generated, which is replaced with `ni` as per the description.\n\n4. **Completing the send action**: The send action `send_1(____(ROLE_1)____,R, {____(ROLE_1)____,____(NONCE_1)____}pk(R) );` is completed by replacing `____(ROLE_1)____` with `I` and `____(NONCE_1)____` with `ni`, resulting in `send_1(I,R, {I,ni}pk(R) );`.\n\n5. **Completing the claim**: The claim statement `claim_i(____(ROLE_1)____,Secret,____(NONCE_1)____);` is completed by replacing `____(ROLE_1)____` with `I` and `____(NONCE_1)____` with `ni`, resulting in `claim_i(I,Secret,ni);`.\n\n6. **Defining the Responder role**: The Responder role is defined with the label `role R`. Inside this role, a variable `____(NONCE_1)____` is declared to store the received nonce, which is replaced with `ni`.\n\n7. **Completing the receive action**: The receive action `recv_1(____(ROLE_1)____,R, {____(ROLE_1)____,____(NONCE_1)____}pk(R) );` is completed by replacing `____(ROLE_1)____` with `I` and `____(NONCE_1)____` with `ni`, resulting in `recv_1(I,R, {I,ni}pk(R) );`.\n\n8. **Completing the Responder's claim**: The claim statement `claim_r(R,Secret,____(NONCE_1)____);` is completed by replacing `____(NONCE_1)____` with `ni`, resulting in `claim_r(R,Secret,ni);`.\n\nBy following these steps, the incomplete protocol description is completed according to the provided description, resulting in a valid Scyther protocol description file."]], "SPDL-1/protocol1.spdl": [[true, "/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I, R, {R, ni}pk(R) );\n\t\t\n\t\trecv_2(R, I, {ni, nr, R}pk(I) );\n\t\t\n\t\tsend_3(I, R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {R, ni}pk(R) );\n\t\t\n\t\tsend_2(R,I, {ni, nr, R}pk(I) );\n\t\t\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}", "```spdl\n/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I, R, {R, ni}pk(R) );\n\t\t\n\t\trecv_2(R, I, {ni, nr, R}pk(I) );\n\t\t\n\t\tsend_3(I, R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {R, ni}pk(R) );\n\t\t\n\t\tsend_2(R,I, {ni, nr, R}pk(I) );\n\t\t\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/rsaplussatek.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    send_rsa1(MS,BS, {msrand,said,MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n//    claim_rsai5(MS,SKR,prepak);\n//    claim_rsai6(MS,SKR,tek0);\n//    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    recv_rsa1(MS,BS, {msrand,said,MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n//    claim_rsar5(BS,SKR,prepak);\n//    claim_rsar6(BS,SKR,tek0);\n//    claim_rsar7(BS,SKR,tek1);\n  }\n}", "```spdl\n/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    send_rsa1(MS,BS, {msrand,said,MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n//    claim_rsai5(MS,SKR,prepak);\n//    claim_rsai6(MS,SKR,tek0);\n//    claim_rsai7(MS,SKR,tek1);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1: Nonce;\n\n    recv_rsa1(MS,BS, {msrand,said,MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n//    claim_rsar5(BS,SKR,prepak);\n//    claim_rsar6(BS,SKR,tek0);\n//    claim_rsar7(BS,SKR,tek1);\n  }\n}\n```"]], "SPDL-1/simplest-1.spdl": [[true, "secret k: Nonce;\n\nprotocol simplest(____(ROLE_1)____)\n{\n    role ____(ROLE_1)____\n    {\n        var x: Nonce;\n        fresh ____(NONCE_1)____: Nonce;\n\n        recv_!1(____(ROLE_1)____,____(ROLE_1)____, x);\n        send_!2(____(ROLE_1)____,____(ROLE_1)____, ____(NONCE_1)____, {____(NONCE_1)____, x}k );\n        claim_3(____(ROLE_1)____, Secret, ____(NONCE_1)____);\n    }\n}", "To complete the given protocol's formal analysis code with the SPDL language, we first need to understand the protocol description and identify the missing elements in the code.\n\nThe protocol involves a single role, denoted as `I`. The key elements include a shared secret key `k` and nonces. The message flow involves receiving a nonce `x`, generating a fresh nonce `n`, and sending a response that includes `n` and the encryption of `n` and `x` with `k`. The protocol concludes with a claim that `n` is secret.\n\nLet's analyze the given incomplete code:\n```spdl\nsecret k: Nonce;\n\nprotocol simplest(____(ROLE_1)____)\n{\n    role ____(ROLE_1)____\n    {\n        var x: Nonce;\n        fresh ____(NONCE_1)____: Nonce;\n\n        recv_!1(____(ROLE_1)____,____(ROLE_1)____, x);\n        send_!2(____(ROLE_1)____,____(ROLE_1)____, ____(NONCE_1)____, {____(NONCE_1)____, x}k );\n        claim_3(____(ROLE_1)____, Secret, ____(NONCE_1)____);\n    }\n}\n```\n\nFrom the protocol description, we can infer that:\n- `ROLE_1` is `I`, representing the role in the protocol.\n- `NONCE_1` is `n`, the fresh nonce generated by role `I`.\n\nThus, we need to replace `____(ROLE_1)____` with `I` and `____(NONCE_1)____` with `n`.\n\nThe completed code should look like this:\n```spdl\nsecret k: Nonce;\n\nprotocol simplest(I)\n{\n    role I\n    {\n        var x: Nonce;\n        fresh n: Nonce;\n\n        recv_!1(I, I, x);\n        send_!2(I, I, n, {n, x}k );\n        claim_3(I, Secret, n);\n    }\n}\n```\n\nTherefore, the completed file is:\n```spdl\nsecret k: Nonce;\n\nprotocol simplest(I)\n{\n    role I\n    {\n        var x: Nonce;\n        fresh n: Nonce;\n\n        recv_!1(I, I, x);\n        send_!2(I, I, n, {n, x}k );\n        claim_3(I, Secret, n);\n    }\n}\n```"]], "SPDL-1/smartright.spdl": [[true, "hashfunction hash;\nusertype SessionKey;\nusertype XorKey;\nconst Vor: XorKey;\n\nprotocol smartright(I,R)\n{\n    role I\n    {\n        fresh K: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var Ni: Nonce;\n\n        send_1(I,R, {K,{CW}VoR}k(I,R));\n        recv_2(R,I, Ni);\n        send_3(I,R, VoR, {{Ni}hash}K);\n    }    \n    \n    role R\n    {\n        var T: Ticket;\n        var VoR: XorKey;\n        var K: SessionKey;\n        fresh Ni: Nonce;\n\n        recv_1(I,R, {K,T}k(I,R));\n        send_2(R,I, Ni);\n        recv_3(I,R, VoR,{{Ni}hash}K);\n\n        claim_R1(R,Nisynch);\n    }\n}", "To complete the given protocol's formal analysis code using the SPDL language, we need to fill in the missing parts based on the description provided.\n\n1. **Role Names**: The Initiator role is not explicitly named in the description, but based on the context, it seems that `I` could be used for the Initiator and `R` for the Responder. So, `____(ROLE_1)____` should be replaced with `I`.\n\n2. **Variables and Keys**: \n   - The fresh session key generated by the Initiator is `____(KEY_1)____`, which should be `K` (or any suitable name, but we'll use `K` for consistency).\n   - `____(NONCE_1)____` should be `Ni` to represent the nonce sent by the Responder in response to the Initiator's first message.\n   - `T` represents `{CW}VoR`, so `T` is equivalent to `{CW}VoR`.\n\n3. **Message Components**: \n   - The first message includes `{K, {CW}VoR}k(I,R)`, so `T` is `{CW}VoR` and `____(KEY_1)____` is `K`.\n   - In `recv_1`, `T` is received as part of the encrypted message, so it's correct to use `T` as a variable in the Responder's role.\n\nLet's fill in the blanks accordingly:\n\n```spdl\nhashfunction hash;\nusertype SessionKey;\nusertype XorKey;\nconst Vor: XorKey;\n\nprotocol smartright(I,R)\n{\n    role I\n    {\n        fresh K: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var Ni: Nonce;\n\n        send_1(I,R, {K,{CW}VoR}k(I,R));\n        recv_2(R,I, Ni);\n        send_3(I,R, VoR, {{Ni}hash}K);\n    }    \n    \n    role R\n    {\n        var T: Ticket;\n        var VoR: XorKey;\n        var K: SessionKey;\n        fresh Ni: Nonce;\n\n        recv_1(I,R, {K,T}k(I,R));\n        send_2(R,I, Ni);\n        recv_3(I,R, VoR,{{Ni}hash}K);\n\n        claim_R1(R,Nisynch);\n    }\n}\n```\n\nHere's the explanation for the changes made:\n\n- `____(ROLE_1)____` is replaced with `I` to represent the Initiator.\n- `____(KEY_1)____` is replaced with `K` to represent the session key.\n- `____(NONCE_1)____` is replaced with `Ni` to represent the nonce generated by the Responder.\n- The message components are adjusted according to the protocol description.\n\nThe completed code is between ```spdl and ```. Here is the completed file: \n```spdl\nhashfunction hash;\nusertype SessionKey;\nusertype XorKey;\nconst Vor: XorKey;\n\nprotocol smartright(I,R)\n{\n    role I\n    {\n        fresh K: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var Ni: Nonce;\n\n        send_1(I,R, {K,{CW}VoR}k(I,R));\n        recv_2(R,I, Ni);\n        send_3(I,R, VoR, {{Ni}hash}K);\n    }    \n    \n    role R\n    {\n        var T: Ticket;\n        var VoR: XorKey;\n        var K: SessionKey;\n        fresh Ni: Nonce;\n\n        recv_1(I,R, {K,T}k(I,R));\n        send_2(R,I, Ni);\n        recv_3(I,R, VoR,{{Ni}hash}K);\n\n        claim_R1(R,Nisynch);\n    }\n}\n```"]], "SPDL-1/speedtest-1.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ns3speedtest(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\t\tclaim_4(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\t\tclaim_5(R,Secret,ni);\n\t}\n}\n\n\n/* something like this will later on all be implied by 'untrusted Eve' */\n\n\n/* pre-defined 10 runs, limit using --max-runs parameters */\n\n\trun ns3speedtest.R(Alice,Bob);\n\trun ns3speedtest.R(Eve,Bob);\n\trun ns3speedtest.R(Bob,Alice);\n\trun ns3speedtest.R(Eve,Alice);\n\trun ns3speedtest.R(Bob,Bob);", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ns3speedtest(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\t\tclaim_4(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\t\tclaim_5(R,Secret,ni);\n\t}\n}\n\n\n/* something like this will later on all be implied by 'untrusted Eve' */\n\n\n/* pre-defined 10 runs, limit using --max-runs parameters */\n\n\trun ns3speedtest.R(Alice,Bob);\n\trun ns3speedtest.R(Eve,Bob);\n\trun ns3speedtest.R(Bob,Alice);\n\trun ns3speedtest.R(Eve,Alice);\n\trun ns3speedtest.R(Bob,Bob);\n```"]], "SPDL-1/splice-as-hc.spdl": [[true, "# Hwang and Chen Modified SPLICE/AS\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/spliceas2.html\n#\n\nusertype TimeStamp, LifeTime;\n\nconst inc,dec: Function;\ninversekeys (inc,dec);\n\nprotocol spliceAS-HC(I,S,R)\n{\n    role I\n    {\n        fresh N1,N2: Nonce;\n        fresh T: TimeStamp;\n        fresh L: LifeTime;\n\n        send_1(I,S,  I, S, N1 );\n        recv_2(S,I,  S, {S, I, N1, R, pk(R)}sk(S) );\n        send_3(I,R,  I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        recv_6(R,I,  R, I, {R, {N2}inc}pk(I) );\n\n        claim_7(I, Secret, N2);\n        claim_9(I, Niagree);\n        claim_10(I, Nisynch);\n    }\n\n    role S\n    {\n        var N1,N3: Nonce;\n\n        recv_1(I,S,  I, S, N1 );\n        send_2(S,I,  S, {S, I, N1, R, pk(R)}sk(S) );\n        recv_4(R,S, R, I, N3 );\n        send_5(S,R,  S, {S, R, N3, I, pk(I)}sk(S) );\n    }\n\n    role R\n    {\n        fresh N3: Nonce;\n        var N2: Nonce;\n        var T: TimeStamp;\n        var L: LifeTime;\n\n        var ni: Nonce;\n        fresh nr: Nonce;\n\n        recv_3(I,R, I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        send_4(R,S, R, I, N3 );\n        recv_5(S,R, S, {S, R, N3, I, pk(I)}sk(S) );\n        send_6(R,I, R, I, {R, {N2}inc}pk(I) );\n\n        claim_8(R, Secret, N2);\n        claim_11(R, Niagree);\n        claim_12(R, Nisynch);\n    }\n}", "Based on the given description, the completed code should be as follows:\n\n```spdl\n# Hwang and Chen Modified SPLICE/AS\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/spliceas2.html\n#\n\nusertype TimeStamp, LifeTime;\n\nconst inc,dec: Function;\ninversekeys (inc,dec);\n\nprotocol spliceAS-HC(I,S,R)\n{\n    role I\n    {\n        fresh N1,N2: Nonce;\n        fresh T: TimeStamp;\n        fresh L: LifeTime;\n\n        send_1(I,S,  I, S, N1 );\n        recv_2(S,I,  S, {S, I, N1, R, pk(R)}sk(S) );\n        send_3(I,R,  I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        recv_6(R,I,  R, I, {R, {N2}inc}pk(I) );\n\n        claim_7(I, Secret, N2);\n        claim_9(I, Niagree);\n        claim_10(I, Nisynch);\n    }\n\n    role S\n    {\n        var N1,N3: Nonce;\n\n        recv_1(I,S,  I, S, N1 );\n        send_2(S,I,  S, {S, I, N1, R, pk(R)}sk(S) );\n        recv_4(R,S, R, I, N3 );\n        send_5(S,R,  S, {S, R, N3, I, pk(I)}sk(S) );\n    }\n\n    role R\n    {\n        fresh N3: Nonce;\n        var N2: Nonce;\n        var T: TimeStamp;\n        var L: LifeTime;\n\n        var ni: Nonce;\n        fresh nr: Nonce;\n\n        recv_3(I,R, I, R, {I, T, L, {N2}pk(R)}sk(I) );\n        send_4(R,S, R, I, N3 );\n        recv_5(S,R, S, {S, R, N3, I, pk(I)}sk(S) );\n        send_6(R,I, R, I, {R, {N2}inc}pk(I) );\n\n        claim_8(R, Secret, N2);\n        claim_11(R, Niagree);\n        claim_12(R, Nisynch);\n    }\n}\n```"]], "SPDL-1/SR3.spdl": [[true, "hashfunction H;\nusertype Key;\nusertype Ticket;\n\nprotocol sr3(V,S)\n{\n\n\trole V\n\t{\n\t\tfresh Nv: Nonce;\n\t\tfresh D:Ticket;\n\t\tsend_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\trecv_2(S,V,Nv,V);\n\t\t\n\t\tclaim_V1(V, Niagree);\n\t\tclaim_V2(V, Secret, D);\n\t\tclaim_V3(V, Secret, k(V,S));\n\t\tclaim_V4(V, Nisynch);\n\t\tclaim_V5(V, Secret, Nv);\n\t}\n\n\trole S\n\t{\n\t\tvar D:Ticket;\n\t\tvar Nv:Nonce;\n\t\trecv_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\tsend_2(S,V,Nv,V);\n\n\t\tclaim_S1(S, Niagree);\n\t\tclaim_S2(S, Secret, D);\n\t\tclaim_S3(S, Secret, k(V,S));\n\t\tclaim_S4(S, Nisynch);\n\t\tclaim_S5(S, Secret, Nv);\n\t}\n\n}", "```spdl\nhashfunction H;\nusertype Key;\nusertype Ticket;\n\nprotocol sr3(V,S)\n{\n\n\trole V\n\t{\n\t\tfresh Nv: Nonce;\n\t\tfresh D:Ticket;\n\t\tsend_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\trecv_2(S,V,Nv,V);\n\t\t\n\t\tclaim_V1(V, Niagree);\n\t\tclaim_V2(V, Secret, D);\n\t\tclaim_V3(V, Secret, k(V,S));\n\t\tclaim_V4(V, Nisynch);\n\t\tclaim_V5(V, Secret, Nv);\n\t}\n\n\trole S\n\t{\n\t\tvar D:Ticket;\n\t\tvar Nv:Nonce;\n\t\trecv_1(V,S,{D,Nv}k(V,S),H(Nv),V);\n\t\tsend_2(S,V,Nv,V);\n\n\t\tclaim_S1(S, Niagree);\n\t\tclaim_S2(S, Secret, D);\n\t\tclaim_S3(S, Secret, k(V,S));\n\t\tclaim_S4(S, Nisynch);\n\t\tclaim_S5(S, Secret, Nv);\n\t}\n\n}\n```"]], "SPDL-1/bkepk-ce-1.spdl": [[true, "protocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ nb,B }pk(A) );\n\t\tsend_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_A1 (A, Secret, na);\n\t\tclaim_A2 (A, Secret, nb);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,A, B,{ nb,B }pk(A) );\n\t\trecv_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\tsend_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, nb);\n\t}\n\n}", "To complete the given protocol's formal analysis code in the SPDL language, we will analyze the provided description and the incomplete code.\n\nThe protocol involves two roles: Alice (A) and Bob (B). We need to identify the missing parts in the code and fill them according to the protocol description.\n\n1. **Identifying Roles and Variables**:\n   - The roles are `A` (or `____(ROLE_1)____`) and `B`.\n   - `A` generates a nonce `na` and a session key `kab`.\n   - `B` generates a nonce `nb` (referred to as `____(NONCE_1)____` in the code).\n\n2. **Completing the Code**:\n   - `____(ROLE_1)____` should be replaced with `A` since `A` is the other role involved in the protocol.\n   - `____(NONCE_1)____` should be `nb` because `nb` is the nonce generated by `B`.\n\nLet's fill in the blanks accordingly:\n\n```spdl\nprotocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ nb,B }pk(A) );\n\t\tsend_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_A1 (A, Secret, na);\n\t\tclaim_A2 (A, Secret, nb);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,A, B,{ nb,B }pk(A) );\n\t\trecv_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\tsend_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, nb);\n\t}\n\n}\n```\n\nThus, the completed code will be:\n\n```spdl\n/* \n\tBilateral Key Exchange with Public Key protocol (bkeCE)\n\n\tVersion from Corin/Etalle: An Improved Constraint-Based System for the Verification of Security Protocols.\n\tTried to stay as close as possible to compare timing results.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ nb,B }pk(A) );\n\t\tsend_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_A1 (A, Secret, na);\n\t\tclaim_A2 (A, Secret, nb);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,A, B,{ nb,B }pk(A) );\n\t\trecv_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\tsend_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, nb);\n\t}\n\n}\n\nconst Alice,Bob,Eve;\n```"]], "SPDL-1/sts-mac.spdl": [[true, "# 1 \"sts-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-mac.cpp\"\n# 16 \"sts-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 17 \"sts-mac.cpp\" 2\n\n\n\n\n\n\n\nprotocol @executability(A) {\n\n\n role A {\n  var i, r: Nonce;\n\n\n  recv_!O1( A, A, MAC(h(g(i),r), g(r), g(i)) );\n  send_!O2( A, A, MAC(h(g(r),i), g(r), g(i)) );\n\n\n  recv_!O3( A, A, MAC(h(g(r),i), g(i), g(r)) );\n  send_!O4( A, A, MAC(h(g(i),r), g(i), g(r)) );\n\n }\n\n\n}\n\n\n\nprotocol sts-mac(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_!2( R, I, Gr, {Gr, g(i)}sk(R), MAC(h(Gr,i), Gr, g(i)) );\n  send_!3( I, R, {g(i), Gr}sk(I), MAC(h(Gr,i), g(i), Gr) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_!2( R, I, Gi, {g(r), Gi}sk(R), MAC(h(Gi,r), g(r), Gi) );\n  recv_!3( I, R, {Gi, g(r)}sk(I), MAC(h(Gi,r), Gi, g(r)) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}", "```spdl\n# 1 \"sts-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-mac.cpp\"\n# 16 \"sts-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 17 \"sts-mac.cpp\" 2\n\n\n\n\n\n\n\nprotocol @executability(A) {\n\n\n role A {\n  var i, r: Nonce;\n\n\n  recv_!O1( A, A, MAC(h(g(i),r), g(r), g(i)) );\n  send_!O2( A, A, MAC(h(g(r),i), g(r), g(i)) );\n\n\n  recv_!O3( A, A, MAC(h(g(r),i), g(i), g(r)) );\n  send_!O4( A, A, MAC(h(g(i),r), g(i), g(r)) );\n\n }\n\n\n}\n\n\n\nprotocol sts-mac(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_!2( R, I, Gr, {Gr, g(i)}sk(R), MAC(h(Gr,i), Gr, g(i)) );\n  send_!3( I, R, {g(i), Gr}sk(I), MAC(h(Gr,i), g(i), Gr) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_!2( R, I, Gi, {g(r), Gi}sk(R), MAC(h(Gi,r), g(r), Gi) );\n  recv_!3( I, R, {Gi, g(r)}sk(I), MAC(h(Gi,r), Gi, g(r)) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}\n```"]], "SPDL-1/th-1seq2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni,ni2: Nonce;\n\t\tvar nr,nr2: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {ni,nr}pk(R) );\n\n\t\t//claim_i(I,Nisynch);\n\n\t\tsend_21(I,R, {P2,I,ni2}pk(R) );\n\t\trecv_21b(R,I, {nr2}pk(I) );\n\t\trecv_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\tsend_23(I,R, {ni2,nr2}pk(R) );\n\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni,ni2: Nonce;\n\t\tfresh nr,nr2: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {ni,nr}pk(R) );\n\n\t\t//claim_r(R,Nisynch);\n\n\t\trecv_21(I,R, {P2,I,ni2}pk(R) );\n\t\tsend_21b(R,I, {nr2}pk(I) );\n\t\tsend_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\trecv_23(I,R, {ni2,nr2}pk(R) );\n\n\t\tclaim_r2(R,Nisynch);\n\t}\n}", "```spdl\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni,ni2: Nonce;\n\t\tvar nr,nr2: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {ni,nr}pk(R) );\n\n\t\t//claim_i(I,Nisynch);\n\n\t\tsend_21(I,R, {P2,I,ni2}pk(R) );\n\t\trecv_21b(R,I, {nr2}pk(I) );\n\t\trecv_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\tsend_23(I,R, {ni2,nr2}pk(R) );\n\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni,ni2: Nonce;\n\t\tfresh nr,nr2: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {ni,nr}pk(R) );\n\n\t\t//claim_r(R,Nisynch);\n\n\t\trecv_21(I,R, {P2,I,ni2}pk(R) );\n\t\tsend_21b(R,I, {nr2}pk(I) );\n\t\tsend_22(R,I, {P2,ni2,nr2,R}pk(I) );\n\t\trecv_23(I,R, {ni2,nr2}pk(R) );\n\n\t\tclaim_r2(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/tmn-2.spdl": [[true, "usertype Key;\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys(pk,sk);\n\nprotocol tmn(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh Ka: Key;\n\t\tvar Kb: Key;\n\n\t\tsend_1(A,S, B,{Ka}pk(S) );\n\t\trecv_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_5(A,Secret,Ka);\n\t\tclaim_8(A,Secret,Kb);\n\t}\t\n\t\n\trole B\n\t{\n\t\tfresh Kb: Key;\n\n\t\trecv_2(S,B, A );\n\t\tsend_3(B,S, A, { Kb }pk(S) );\n\n\t\tclaim_6(B,Secret,Kb);\n\t}\n\n\trole S\n\t{\n\t\tvar Ka,Kb: Key;\n\n\t\trecv_1(A,S, B,{Ka}pk(S) );\n\t\tsend_2(S,B, A );\n\t\trecv_3(B,S, A, { Kb }pk(S) );\n\t\tsend_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_7(S,Secret,Ka);\n\t}\n}\n\nconst Alice,Bob,Eve,Simon: Agent;", "```spdl\nusertype Key;\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys(pk,sk);\n\nprotocol tmn(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh Ka: Key;\n\t\tvar Kb: Key;\n\n\t\tsend_1(A,S, B,{Ka}pk(S) );\n\t\trecv_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_5(A,Secret,Ka);\n\t\tclaim_8(A,Secret,Kb);\n\t}\t\n\t\n\trole B\n\t{\n\t\tfresh Kb: Key;\n\n\t\trecv_2(S,B, A );\n\t\tsend_3(B,S, A, { Kb }pk(S) );\n\n\t\tclaim_6(B,Secret,Kb);\n\t}\n\n\trole S\n\t{\n\t\tvar Ka,Kb: Key;\n\n\t\trecv_1(A,S, B,{Ka}pk(S) );\n\t\tsend_2(S,B, A );\n\t\trecv_3(B,S, A, { Kb }pk(S) );\n\t\tsend_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_7(S,Secret,Ka);\n\t}\n}\n\nconst Alice,Bob,Eve,Simon: Agent;\n```"]], "SPDL-1/unknown2.spdl": [[true, "and", "Here is the completed code between ```spdl and ```.\n\n```spdl\nusertype SessionKey;\nsecret k: Function;\n\nprotocol unknown2(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\t\tvar T;\n\n\t\tsend_1(I,R, ni );\n\t\trecv_3(S,I, { I,R,kir,ni,nr }k(I,S), T );\n\t\tsend_4(I,R, T, {nr}kir );\n\n\t\tclaim_i1(I,Nisynch);\n\t\tclaim_i2(I,Niagree);\n\t\tclaim_i3(I,Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tvar ni: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\trecv_1(I,R, ni );\n\t\tsend_2(R,S, { I,R,ni,nr }k(R,S) );\n\t\trecv_4(I,R, { I,R,kir,ni,nr }k(R,S), {nr}kir );\n\n\t\tclaim_r1(R,Nisynch);\n\t\tclaim_r2(R,Niagree);\n\t\tclaim_r3(R,Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tfresh kir: SessionKey;\n\t\tvar ni,nr: Nonce;\n\n\t\trecv_2(R,S, { I,R,ni,nr }k(R,S) );\n\t\tsend_3(S,I, { I,R,kir,ni,nr }k(I,S), { I,R,kir,ni,nr }k(R,S) );\n\n/*\n\t\tclaim_s1(S,Nisynch);\n\t\tclaim_s2(S,Niagree);\n\t\tclaim_s3(S,Secret, kir);\n\t\t*/\n\t}\n}\n\n\nconst kee: SessionKey;\n```"]], "SPDL-1/void.spdl": [[true, "# By Louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n\nprotocol void-0(A, B, S) {\n    role A {\n        fresh t: Nonce;\n        fresh K: MySecret;\n\n        send_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        recv_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n        send_5(A, B, {t, K}pk(B));\n        recv_6(B, A, {h(t, K)}pk(A));\n\n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var t: Nonce;\n\n        recv_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        send_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        recv_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        send_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n\n        claim(S, Weakagree);\n    }\n    role B {\n        var t: Nonce;\n        var K: MySecret;\n\n        recv_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        send_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        recv_5(A, B, {t, K}pk(B));\n        send_6(B, A, {h(t, K)}pk(A));\n\n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}", "```spdl\n# By Louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n\nprotocol void-0(A, B, S) {\n    role A {\n        fresh t: Nonce;\n        fresh K: MySecret;\n\n        send_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        recv_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n        send_5(A, B, {t, K}pk(B));\n        recv_6(B, A, {h(t, K)}pk(A));\n\n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var t: Nonce;\n\n        recv_1(A, S, (t, A, B, pk(A), {h(t, A, B, pk(A))}k(A, S)));\n        send_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        recv_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        send_4(S, A, (B, {t, pk(B)}k(A, S), {h(t, B, pk(B))}k(A, S)));\n\n        claim(S, Weakagree);\n    }\n    role B {\n        var t: Nonce;\n        var K: MySecret;\n\n        recv_2(S, B, (t, A, pk(A), {h(t, A, pk(A))}k(B, S)));\n        send_3(B, S, (A, {t, pk(B)}k(B, S), {h(t, A, pk(B))}k(B, S)));\n        recv_5(A, B, {t, K}pk(B));\n        send_6(B, A, {h(t, K)}pk(A));\n\n        claim(B, Secret, K);\n        claim(B, Weakagree);\n    }\n}\n```"]], "SPDL-1/wmf.spdl": [[true, "# Wide Mouthed Frog\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wideMouthedFrog.html\n#\n# Note\n# The name of the party that has generated a message was added in order\n# to model the property described in SPORE that an agent can identify\n# its own messages and will reject them.\n\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol wmf(I,R,S)\n{\n    role I\n    {\n        fresh Kir: SessionKey;\n        fresh Ti: TimeStamp;\n        var Kr: SessionKey;\n\n        send_1(I,S, I, {I, Ti, R, Kir}k(I,S)); \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Ts: TimeStamp;\n        var Kir: SessionKey;\n\n        recv_2(S,R, {S, Ts, I, Kir}k(R,S) );\n\n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Kir: SessionKey;\n        fresh Ts: TimeStamp;\n        var Ti: TimeStamp;\n\n        recv_1(I,S, I,{I, Ti, R, Kir}k(I,S) );\n        send_2(S,R, {S, Ts, I, Kir}k(R,S));\n    }\n}", "```spdl\n# Wide Mouthed Frog\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wideMouthedFrog.html\n#\n# Note\n# The name of the party that has generated a message was added in order\n# to model the property described in SPORE that an agent can identify\n# its own messages and will reject them.\n\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol wmf(I,R,S)\n{\n    role I\n    {\n        fresh Kir: SessionKey;\n        fresh Ti: TimeStamp;\n        var Kr: SessionKey;\n\n        send_1(I,S, I, {I, Ti, R, Kir}k(I,S)); \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        var Ts: TimeStamp;\n        var Kir: SessionKey;\n\n        recv_2(S,R, {S, Ts, I, Kir}k(R,S) );\n\n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Kir: SessionKey;\n        fresh Ts: TimeStamp;\n        var Ti: TimeStamp;\n\n        recv_1(I,S, I,{I, Ti, R, Kir}k(I,S) );\n        send_2(S,R, {S, Ts, I, Kir}k(R,S));\n    }\n}\n```"]], "SPDL-1/woo-lam.spdl": [[true, "# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var N2: Nonce;\n        var Kir: SessionKey;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, N2);\n        send_3(I,S, {I, R, N1, N2}k(I,S));\n        recv_6(R,I, {R, N1, N2, Kir}k(I,S), {N1,N2}Kir);\n        send_7(I,R, {N2}Kir);\n        \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var Kir: SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, N2);\n        recv_3(I,R, T1);\n        send_4(R,S, T1, {I, R, N1, N2}k(R,S));\n        recv_5(S,R, T2, {I, N1, N2, Kir}k(R,S));\n        send_6(R,I, T2, {N1,N2}Kir);\n        recv_7(I,R, {N2}Kir);\n        \n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var N1,N2: Nonce;\n\n        recv_4(R,S, {I, R, N1, N2}k(I,S), {I, R, N1, N2}k(R,S));\n        send_5(S,R, {R, N1, N2, Kir}k(I,S), {I, N1, N2, Kir}k(R,S));\n    }\n}", "The completed code is as follows.\n\n```spdl\n# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var N2: Nonce;\n        var Kir: SessionKey;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, N2);\n        send_3(I,S, {I, R, N1, N2}k(I,S));\n        recv_6(R,I, {R, N1, N2, Kir}k(I,S), {N1,N2}Kir);\n        send_7(I,R, {N2}Kir);\n        \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var Kir: SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, N2);\n        recv_3(I,R, T1);\n        send_4(R,S, T1, {I, R, N1, N2}k(R,S));\n        recv_5(S,R, T2, {I, N1, N2, Kir}k(R,S));\n        send_6(R,I, T2, {N1,N2}Kir);\n        recv_7(I,R, {N2}Kir);\n        \n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var N1,N2: Nonce;\n\n        recv_4(R,S, {I, R, N1, N2}k(I,S), {I, R, N1, N2}k(R,S));\n        send_5(S,R, {R, N1, N2, Kir}k(I,S), {I, N1, N2, Kir}k(R,S));\n    }\n}\n```"]], "SPDL-1/woolam-pi-f.spdl": [[true, "/*\n * Woo-lam version from Spore, Pi f\n *\n * Only one-way verification version\n */\n\nusertype Server, SessionKey, Ticket;\nsecret k: Function;\n\nconst Simon: Server;\n\nconst ke: SessionKey;\n\nprotocol woolampif(A,B,S)\n{\n\trole A\n\t{\n\t\tvar Nb: Nonce;\n\n\t\tsend_1(A,B, A);\n\t\trecv_2(B,A, Nb);\n\t\tsend_3(A,B, { A,B,Nb }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar T: Ticket;\n\n\t\trecv_1(A,B, A);\n\t\tsend_2(B,A, Nb);\n\t\trecv_3(A,B, T);\n\t\tsend_4(B,S, { A,B,Nb, T }k(B,S) );\n\t\trecv_5(S,B, { A,B,Nb }k(B,S) );\n\n\t\tclaim_6(B,Niagree);\n\t\tclaim_7(B,Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar Nb: Nonce;\n\n\t\trecv_4(B,S, { A,B,Nb, { A,B,Nb }k(A,S) }k(B,S) );\n\t\tsend_5(S,B, { A,B,Nb }k(B,S) );\n\t}\n}", "```spdl\n/*\n * Woo-lam version from Spore, Pi f\n *\n * Only one-way verification version\n */\n\nusertype Server, SessionKey, Ticket;\nsecret k: Function;\n\nconst Simon: Server;\n\nconst ke: SessionKey;\n\nprotocol woolampif(A,B,S)\n{\n\trole A\n\t{\n\t\tvar Nb: Nonce;\n\n\t\tsend_1(A,B, A);\n\t\trecv_2(B,A, Nb);\n\t\tsend_3(A,B, { A,B,Nb }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tfresh Nb: Nonce;\n\t\tvar T: Ticket;\n\n\t\trecv_1(A,B, A);\n\t\tsend_2(B,A, Nb);\n\t\trecv_3(A,B, T);\n\t\tsend_4(B,S, { A,B,Nb, T }k(B,S) );\n\t\trecv_5(S,B, { A,B,Nb }k(B,S) );\n\n\t\tclaim_6(B,Niagree);\n\t\tclaim_7(B,Nisynch);\n\t}\n\n\trole S\n\t{\n\t\tvar Nb: Nonce;\n\n\t\trecv_4(B,S, { A,B,Nb, { A,B,Nb }k(A,S) }k(B,S) );\n\t\tsend_5(S,B, { A,B,Nb }k(B,S) );\n\t}\n}\n```"]], "SPDL-1/yahalom-ban-1.spdl": [[true, "# BAN simplified version of Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalomBAN.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol yahalom-BAN(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, Nr, {R,Kir,Ni}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        recv_4(I,R, T, {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        send_3(S,I, Nr, {R,Kir,Ni}k(I,S), {I,Kir,Nr}k(R,S) );\n    }\n}", "Based on the description of the Yahalom-BAN protocol, the completed code should be as follows:\n\n```spdl\n# BAN simplified version of Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalomBAN.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol yahalom-BAN(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, Nr, {R,Kir,Ni}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        recv_4(I,R, T, {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, Nr, {I,Ni}k(R,S) );\n        send_3(S,I, Nr, {R,Kir,Ni}k(I,S), {I,Kir,Nr}k(R,S) );\n    }\n}\n```\nThe changes made were to complete the missing parts with the correct variable names and role names as per the description. Specifically:\n- `____(ROLE_1)____` was replaced with `S` to represent the server role.\n- `____(NONCE_1)____` and `____(ENCRYPTED_1)____` were replaced with `Ni` and `Nr` respectively to represent the nonces generated by the initiator and responder.\n- `____(KEY_1)____` was replaced with `Kir` to represent the session key shared between the initiator and responder. \n- Variable and message components were adjusted according to the protocol description."]], "SPDL-1/yahalom.spdl": [[true, "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\nusertype Ticket;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(R,I, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(R,I, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}", "```spdl\n# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\nusertype Ticket;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(R,I, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(R,I, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}\n```"]]}