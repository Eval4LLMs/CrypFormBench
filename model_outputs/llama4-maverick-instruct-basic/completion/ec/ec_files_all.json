{"EC-1/AAPI.ec": [[true, "(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type outputs_t.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type apiRes_data.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API.", "To complete the given EasyCrypt code based on the provided description, we need to fill in the missing parts indicated by `____(TYPE_1)____`, `____(TYPE_0)____`, and `____(OP_0)____`.\n\n1. **`____(TYPE_1)____`**: According to the description, the API handles inputs and outputs. It's mentioned that `inputs_t` defines the structure of inputs, and similarly, there should be a type for outputs. Thus, `____(TYPE_1)____` should be `outputs_t` to represent the output type.\n\n2. **`____(TYPE_0)____`**: The description refers to `apiRes_data` as representing the structure of data returned from API responses. Hence, `____(TYPE_0)____` should be `apiRes_data` to correctly represent the type for API responses.\n\n3. **`____(OP_0)____`**: The operation `apiCall(x: apiCallRes)` is described as extracting an API call from the interaction buffer. It should return an optional `apiCall_data`. Therefore, `____(OP_0)____` should be `apiCall_data` to correctly represent the return type of the `apiCall` operation.\n\nHere is the completed code:\n\n```ec\n(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type outputs_t.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type apiRes_data.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API.\n```"]], "EC-1/abstract-ind-ror.ec": [[true, "and", "To complete the given EasyCrypt code, we need to fill in the missing parts as indicated by `____(TYPE_0)____` and `____(OP_0)____`, and also complete the logic inside the `if-else` statement within the `ind_ror` procedure of the `Game` module.\n\n1. **Completing the Abstract Data Type**: The protocol description mentions two abstract data types: `msg` and `cip`. Therefore, `____(TYPE_0)____` should be `cip` to represent the ciphertext.\n\n2. **Completing the Decrypt Operation**: The cryptographic operations include `enc` for encryption and `dec` for decryption. Hence, `____(OP_0)____` should be `dec` to represent the decryption operation.\n\n3. **Completing the `ind_ror` Procedure**: Inside the `ind_ror` procedure, we need to set `m` to be an authentic message if `b` is true, and a random string if `b` is false. We can achieve this by sampling `m` from a distribution or assigning it a specific value when `b` is true, and sampling it randomly when `b` is false.\n\nHere's the completed code:\n\n```easycrypt\n(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype cip.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop dec: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        (* For simplicity, let's assume there's a specific authentic message 'm_auth'. *)\n        m <$ {msg}; (* or m = m_auth; if m_auth is defined *)\n      } else {\n        m <$ {msg}; (* Sample a random message *)\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed.\n```\n\nThe completed code is between ```ec and ```:\n```ec\n(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype cip.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop dec: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        m <$ {msg};\n      } else {\n        m <$ {msg};\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed.\n```"]], "EC-1/basic-hash-single-tag.ec": [[true, "require import Int Real List FMap FSet Distr StdOrder.\nfrom Jasmin import JWord JArray.\n\n(* Type and distribution definitions *)\n\ntype key.\ntype ptxt.\n\nop dkey : key distr.\nop dnonce : ptxt distr.\n\naxiom dkey_ll : is_lossless dkey.\naxiom dkey_uni (i : int) : is_uniform dkey (predT) <-> 0 <= i < 2^i.\n\naxiom dnonce_ll : is_lossless dnonce.\nlemma dnonce_uni (i : int) : is_uniform dnonce predT by smt (dnonce_ll).\n\nhint exact random : dkey_ll dnonce_ll dnonce_uni.\n\n(*-----------------------------------------------------------------------*)\n(* PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRF = {\n  proc init () : unit\n  proc f(x : ptxt) : ptxt\n  proc check(x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRF_Oracles = {\n  include PRF[-init]\n}.\n\nmodule PRF = {\n  var k : key\n  \n  proc init() : unit = {\n    PRF.k <$ dkey;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    return F k x;\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable RF *)\n(* We assume that: \n   i) the hash function is indistinguishable from a lossless and uniform\n   distribution over ptxts (not full).\n   ii) the hash function is unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf: { ptxt distr |    is_lossless drf\n                       /\\ is_uniform drf predT } as drf_lluni.\n\nmodule EUF_RF = {\n  var m : (ptxt, ptxt) fmap\n  \n  proc init() : unit = {\n    m <- empty;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    var r : ptxt;\n    \n    if (x \\notin m) {\n      r <$ drf;\n      m.[x] <- r;\n    }\n    \n    return oget m.[x];\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (x \\in m && oget m.[x] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, with only one tag and one reader. *)\n\n(* Without initialization *)\nmodule BasicHash0 (H : PRF_Oracles) = {\n  proc tag () : ptxt * ptxt = {\n    var n, h;\n    n <$ dnonce;\n    h <@ H.f(n);\n    return (n, h);\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(n, h);\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRF) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(); \n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag () : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Basic Hash, 1 tag, with logs. *)\nmodule Log (BH : BasicHashT) = {\n  var tag_outputs   : (ptxt * ptxt) list\n  var reader_forged : (ptxt * ptxt) list\n\n  proc init () : unit = { \n    BH.init ();\n    tag_outputs <- [];\n    reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    tag_outputs <- x :: tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    (* We log messages accepted by the reader that the tag never send. *)\n    if (b && ! (mem tag_outputs m)){ \n      reader_forged <- m :: reader_forged;\n    }\n    return b;\n  }    \n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRF) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRF) = {\n  module BH = Log(BH(H))\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem Log.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Indistinguishability game for an unforgeable PRF. *)\nmodule type Distinguisher (F : PRF_Oracles) = {\n  proc distinguish(): bool\n}.\n\nmodule EUF_PRF_IND (F : PRF) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init();\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* In our PRF/RF distinguisher, we must use a slightly different log,\n   which is identical except that it does not initialize the BasicHash\n   protocol. *)\nmodule AuxLog (BH : BasicHashT0) = {\n  proc init () : unit = { \n    Log.tag_outputs <- [];\n    Log.reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    Log.tag_outputs <- x :: Log.tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    if (b && ! (mem Log.tag_outputs m)){ \n      Log.reader_forged <- m :: Log.reader_forged;\n    }\n    return b;\n  }    \n}.\n\nmodule type BasicHashF0 (H : PRF_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRF_Oracles) = {\n  module BH = AuxLog(BH(F))\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BH.init();\n    A.a();\n    return (exists x, mem Log.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {Log, BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {Log, BasicHash, PRF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: Log.reader_forged = [] /\\ \n           forall x y, (EUF_RF.m.[x] <> None && oget EUF_RF.m.[x] = y)\n                        => (x, y) \\in Log.tag_outputs{hr}); auto.\n  (* tag *)\n  + proc; inline *; auto.\n    seq 2: (#pre /\\ x0 = n); wp; 1 : by rnd => *; auto.\n    if; 2 : by auto; smt().\n    by wp; rnd; auto; smt(get_setE).\n\n  (* reader *)\n  + by proc; inline *; auto => /#.\n\n  + by move => *; smt. \nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRF,    D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  by rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); smt ().\nqed.", "```ec\nrequire import Int Real List FMap FSet Distr StdOrder.\nfrom Jasmin import JWord JArray.\n\n(* Type and distribution definitions *)\n\ntype key.\ntype ptxt.\n\nop dkey : key distr.\nop dnonce : ptxt distr.\n\naxiom dkey_ll : is_lossless dkey.\naxiom dkey_uni (i : int) : is_uniform dkey (predT) <-> 0 <= i < 2^i.\n\naxiom dnonce_ll : is_lossless dnonce.\nlemma dnonce_uni (i : int) : is_uniform dnonce predT by smt (dnonce_ll).\n\nhint exact random : dkey_ll dnonce_ll dnonce_uni.\n\n(*-----------------------------------------------------------------------*)\n(* PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRF = {\n  proc init () : unit\n  proc f(x : ptxt) : ptxt\n  proc check(x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRF_Oracles = {\n  include PRF[-init]\n}.\n\nmodule PRF = {\n  var k : key\n  \n  proc init() : unit = {\n    PRF.k <$ dkey;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    return F k x;\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable RF *)\n(* We assume that: \n   i) the hash function is indistinguishable from a lossless and uniform\n   distribution over ptxts (not full).\n   ii) the hash function is unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf: { ptxt distr |    is_lossless drf\n                       /\\ is_uniform drf predT } as drf_lluni.\n\nmodule EUF_RF = {\n  var m : (ptxt, ptxt) fmap\n  \n  proc init() : unit = {\n    m <- empty;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    var r : ptxt;\n    \n    if (x \\notin m) {\n      r <$ drf;\n      m.[x] <- r;\n    }\n    \n    return oget m.[x];\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (x \\in m && oget m.[x] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, with only one tag and one reader. *)\n\n(* Without initialization *)\nmodule BasicHash0 (H : PRF_Oracles) = {\n  proc tag () : ptxt * ptxt = {\n    var n, h;\n    n <$ dnonce;\n    h <@ H.f(n);\n    return (n, h);\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(n, h);\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRF) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(); \n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag () : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Basic Hash, 1 tag, with logs. *)\nmodule Log (BH : BasicHashT) = {\n  var tag_outputs   : (ptxt * ptxt) list\n  var reader_forged : (ptxt * ptxt) list\n\n  proc init () : unit = { \n    BH.init ();\n    tag_outputs <- [];\n    reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    tag_outputs <- x :: tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    (* We log messages accepted by the reader that the tag never send. *)\n    if (b && ! (mem tag_outputs m)){ \n      reader_forged <- m :: reader_forged;\n    }\n    return b;\n  }    \n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRF) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRF) = {\n  module BH = Log(BH(H))\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem Log.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Indistinguishability game for an unforgeable PRF. *)\nmodule type Distinguisher (F : PRF_Oracles) = {\n  proc distinguish(): bool\n}.\n\nmodule EUF_PRF_IND (F : PRF) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init();\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* In our PRF/RF distinguisher, we must use a slightly different log,\n   which is identical except that it does not initialize the BasicHash\n   protocol. *)\nmodule AuxLog (BH : BasicHashT0) = {\n  proc init () : unit = { \n    Log.tag_outputs <- [];\n    Log.reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    Log.tag_outputs <- x :: Log.tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    if (b && ! (mem Log.tag_outputs m)){ \n      Log.reader_forged <- m :: Log.reader_forged;\n    }\n    return b;\n  }    \n}.\n\nmodule type BasicHashF0 (H : PRF_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRF_Oracles) = {\n  module BH = AuxLog(BH(F))\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BH.init();\n    A.a();\n    return (exists x, mem Log.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {Log, BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {Log, BasicHash, PRF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: Log.reader_forged = [] /\\ \n           forall x y, (EUF_RF.m.[x] <> None && oget EUF_RF.m.[x] = y)\n                        => (x, y) \\in Log.tag_outputs{hr}); auto.\n  (* tag *)\n  + proc; inline *; auto.\n    seq 2: (#pre /\\ x0 = n); wp; 1 : by rnd => *; auto.\n    if; 2 : by auto; smt().\n    by wp; rnd; auto; smt(get_setE).\n\n  (* reader *)\n  + by proc; inline *; auto => /#.\n\n  + by move => *; smt. \nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRF,    D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  by rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); smt ().\nqed.\n```"]], "EC-1/br93.ec": [[false, "The completed code is as follows:"]], "EC-1/cfold.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore Distr.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldStopIf.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      var d : int;\n      \n      c <- 0;\n      d <- c + 1;\n      c <- b + a;\n      \n      if (a + b = c) {\n        c <- 0;\n        a <- c;\n      } else {\n        c <- 1;\n        b <- c;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  by auto => /> ?; apply addzC.\n  qed.\nend CfoldStopIf.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldTuple.\n  module M = {\n    proc f( x : int * int) : int = {\n      var a : int;\n      var b : int;\n      var c : int <- 0;\n\n      x <- (0, 0);\n      a <- x.`1;\n      b <- snd x;\n\n      while (a + b <> b + a) {\n        c <- c + 1;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 2.\n  by rcondf ^while; auto.\n  qed.\nend CfoldTuple.\n\ntheory CfoldN.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      a <- c;\n      c <- 1;\n      b <- 2;\n      c <- 2;\n      a <- 3;\n      c <- 3;\n      if (a <> b) {\n        c <- 0;\n      } \n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1 4.\n  by auto => />.\n  qed.\nend CfoldN.\n\ntheory CfoldWhileUnroll.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      c <- c + 1;\n      c <- 0;\n      while (c < 10) {\n        a <- c;\n        c <- c + 1;\n      }\n      b <- c;\n      if (a <> b) {\n        c <- 0;\n      }\n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  unroll for 2.\n  by auto => />.\n  qed.\nend CfoldWhileUnroll.", "```ec\n(* -------------------------------------------------------------------- *)\nrequire import AllCore Distr.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldStopIf.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      var d : int;\n      \n      c <- 0;\n      d <- c + 1;\n      c <- b + a;\n      \n      if (a + b = c) {\n        c <- 0;\n        a <- c;\n      } else {\n        c <- 1;\n        b <- c;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  by auto => /> ?; apply addzC.\n  qed.\nend CfoldStopIf.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldTuple.\n  module M = {\n    proc f( x : int * int) : int = {\n      var a : int;\n      var b : int;\n      var c : int <- 0;\n\n      x <- (0, 0);\n      a <- x.`1;\n      b <- snd x;\n\n      while (a + b <> b + a) {\n        c <- c + 1;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 2.\n  by rcondf ^while; auto.\n  qed.\nend CfoldTuple.\n\ntheory CfoldN.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      a <- c;\n      c <- 1;\n      b <- 2;\n      c <- 2;\n      a <- 3;\n      c <- 3;\n      if (a <> b) {\n        c <- 0;\n      } \n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1 4.\n  by auto => />.\n  qed.\nend CfoldN.\n\ntheory CfoldWhileUnroll.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      c <- c + 1;\n      c <- 0;\n      while (c < 10) {\n        a <- c;\n        c <- c + 1;\n      }\n      b <- c;\n      if (a <> b) {\n        c <- 0;\n      }\n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  unroll for 2.\n  by auto => />.\n  qed.\nend CfoldWhileUnroll.\n```"]], "EC-1/CommitmentSpecial.ec": [[true, "require import AllCore Distr List DBool.\n\ntype commitment, opening, message.\n\nop Com  : message -> (commitment * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() : bool = {\n      var c, m, m', d, d', v, v';\n      (c, m, d, m', d') <@ B.bind();\n      v                 <- Ver (m, (c, d));\n      v'                <- Ver (m', (c, d'));\n      return v /\\ v' /\\ m <> m';\n    }\n}.\n\nmodule type Unhider  = {\n  proc choose() : message list * message list\n  proc guess(c : commitment list) : bool \n}.\n\n\n(* Below we give two different formulations of statistical hiding for commitement scheme  *)\nmodule HidingExperiment(U : Unhider) = {\n  proc main() : bool = {\n    var b : bool;\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    b <$ {0,1};\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b = b';\n  }\n}.\n\n\naxiom comm_scheme_hiding_eps2 &m: forall (U <: Unhider),\n  `|Pr[HidingExperiment(U).main() @ &m : res] -  1%r/2%r| <= eps2.\n\n\n\nmodule HidingGame(U : Unhider) = {\n  proc main(b:bool) : bool = {\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b';\n  }\n}.\n\naxiom comm_scheme_hiding_eps &m: forall (U <: Unhider),\n  `|Pr[HidingGame(U).main(true) @ &m : res] -  Pr[HidingGame(U).main(false) @ &m : res]| <= eps.", "To complete the given file, we need to identify the missing parts based on the provided description.\n\n1. The type `message` is not defined in the given code snippet. It should be defined as part of the types.\n\n2. The operation `Com` and `Ver` are defined, but the type of their parameters and return values involve `message`, which is not defined.\n\n3. The description mentions that `Com` takes a `message` as input and produces a distribution over a pair `(commitment * opening)`, and `Ver` checks if a given `message` matches a `commitment` and its corresponding `opening`.\n\nGiven these points, the missing type is `message`. Let's complete the code.\n\n```ec\nrequire import AllCore Distr List DBool.\n\ntype commitment, opening, message.\n\nop Com  : message -> (commitment * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() : bool = {\n      var c, m, m', d, d', v, v';\n      (c, m, d, m', d') <@ B.bind();\n      v                 <- Ver (m, (c, d));\n      v'                <- Ver (m', (c, d'));\n      return v /\\ v' /\\ m <> m';\n    }\n}.\n\nmodule type Unhider  = {\n  proc choose() : message list * message list\n  proc guess(c : commitment list) : bool \n}.\n\n\n(* Below we give two different formulations of statistical hiding for commitement scheme  *)\nmodule HidingExperiment(U : Unhider) = {\n  proc main() : bool = {\n    var b : bool;\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    b <$ {0,1};\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b = b';\n  }\n}.\n\n\naxiom comm_scheme_hiding_eps2 &m: forall (U <: Unhider),\n  `|Pr[HidingExperiment(U).main() @ &m : res] -  1%r/2%r| <= eps2.\n\n\n\nmodule HidingGame(U : Unhider) = {\n  proc main(b:bool) : bool = {\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b';\n  }\n}.\n\naxiom comm_scheme_hiding_eps &m: forall (U <: Unhider),\n  `|Pr[HidingGame(U).main(true) @ &m : res] -  Pr[HidingGame(U).main(false) @ &m : res]| <= eps.\n```\n\nThe completed code is between ```ec and ```:\n```ec\nrequire import AllCore Distr List DBool.\n\ntype commitment, opening, message.\n\nop Com  : message -> (commitment * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() : bool = {\n      var c, m, m', d, d', v, v';\n      (c, m, d, m', d') <@ B.bind();\n      v                 <- Ver (m, (c, d));\n      v'                <- Ver (m', (c, d'));\n      return v /\\ v' /\\ m <> m';\n    }\n}.\n\nmodule type Unhider  = {\n  proc choose() : message list * message list\n  proc guess(c : commitment list) : bool \n}.\n\n\n(* Below we give two different formulations of statistical hiding for commitement scheme  *)\nmodule HidingExperiment(U : Unhider) = {\n  proc main() : bool = {\n    var b : bool;\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    b <$ {0,1};\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b = b';\n  }\n}.\n\n\naxiom comm_scheme_hiding_eps2 &m: forall (U <: Unhider),\n  `|Pr[HidingExperiment(U).main() @ &m : res] -  1%r/2%r| <= eps2.\n\n\n\nmodule HidingGame(U : Unhider) = {\n  proc main(b:bool) : bool = {\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b';\n  }\n}.\n\naxiom comm_scheme_hiding_eps &m: forall (U <: Unhider),\n  `|Pr[HidingGame(U).main(true) @ &m : res] -  Pr[HidingGame(U).main(false) @ &m : res]| <= eps.\n```"]], "EC-1/ddh-1.ec": [[true, "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* some exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1%r) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.\n\naxiom dexp_fu : is_full dexp.\naxiom dexp_uni : is_uniform dexp.\naxiom dexp_ll : is_lossless dexp.\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* generator *)\n\nop (^) : key -> exp -> key.  (* exponentiation *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;\n    q1 <$ dexp; q2 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));\n    return b;\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);\n    return b;\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)", "```ec\n(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* some exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1%r) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.\n\naxiom dexp_fu : is_full dexp.\naxiom dexp_uni : is_uniform dexp.\naxiom dexp_ll : is_lossless dexp.\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* generator *)\n\nop (^) : key -> exp -> key.  (* exponentiation *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;\n    q1 <$ dexp; q2 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));\n    return b;\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);\n    return b;\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)\n```"]], "EC-1/elgamal.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a PKE **)\ntype pkey = group.\ntype skey = F.t.\ntype ptxt = group.\ntype ctxt = group * group.\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y;\n\n    y <$ dt;\n    return (g ^ y, pk ^ y * m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, gm;\n\n    (gy, gm) <- c;\n    return Some (gm * gy^(-sk));\n  }\n}.\n\n(** Reduction: from a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);\n    b        <$ {0,1};\n    b'       <@ A.guess(gy, gz * (b?m1:m0));\n    return b' = b;\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;\n      y       <$ FDistr.dt;\n      (m0,m1) <@ A.choose(g^x);\n      z       <$ FDistr.dt;\n      b       <$ {0,1};\n      b'      <@ A.guess(g^y, g^z*(if b then m1 else m0));\n      return b' = b;\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion.", "```ec\n(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a PKE **)\ntype pkey = group.\ntype skey = F.t.\ntype ptxt = group.\ntype ctxt = group * group.\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y;\n\n    y <$ dt;\n    return (g ^ y, pk ^ y * m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, gm;\n\n    (gy, gm) <- c;\n    return Some (gm * gy^(-sk));\n  }\n}.\n\n(** Reduction: from a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);\n    b        <$ {0,1};\n    b'       <@ A.guess(gy, gz * (b?m1:m0));\n    return b' = b;\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;\n      y       <$ FDistr.dt;\n      (m0,m1) <@ A.choose(g^x);\n      z       <$ FDistr.dt;\n      b       <$ {0,1};\n      b'      <@ A.guess(g^y, g^z*(if b then m1 else m0));\n      return b' = b;\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion.\n```"]], "EC-1/EventPartitioning.ec": [[false, "```ec\ntheory ListPartitioning.\n  require import List.\n\n  type partition.\n\n  section.\n  declare module M : T{input,output}.\n\n  lemma list_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition list)\n          &m:\n    uniq P =>\n    Pr"]], "EC-1/FMapAux.ec": [[true, "(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => eq_exc X_x.\nby rewrite eq_except_sym eq_except_pred_set_l 1:eq_except_sym.\nqed.\n\nlemma eq_except_not_pred_get\n      (X : 'a -> bool) (x : 'a) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => ! X x => m1.[x] = m2.[x].\nproof.\nmove => /eq_exceptP eq_exc not_X_x.\nby rewrite eq_exc.\nqed.", "To complete the given EasyCrypt code based on the provided description, we need to analyze the given lemmas and ensure they are correctly implemented.\n\nThe given code is as follows:\n```ec\n(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => eq_exc X_x.\nby rewrite eq_except_sym eq_except_pred_set_l 1:eq_except_sym.\nqed.\n\nlemma eq_except_not_pred_get\n      (X : 'a -> bool) (x : 'a) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => ! X x => m1.[x] = m2.[x].\nproof.\nmove => /eq_exceptP eq_exc not_X_x.\nby rewrite eq_exc.\nqed.\n```\n\nSince the code is already given and mostly complete, the task is essentially to verify that it matches the description and is syntactically correct.\n\nUpon inspection, we see that the given code is indeed a correct implementation of the described lemmas. Therefore, the task of completing the code is essentially verifying its correctness.\n\nThe completed file remains the same as the given code because it is already complete and correctly implements the described lemmas.\n\n```ec\n(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => eq_exc X_x.\nby rewrite eq_except_sym eq_except_pred_set_l 1:eq_except_sym.\nqed.\n\nlemma eq_except_not_pred_get\n      (X : 'a -> bool) (x : 'a) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => ! X x => m1.[x] = m2.[x].\nproof.\nmove => /eq_exceptP eq_exc not_X_x.\nby rewrite eq_exc.\nqed.\n```"]], "EC-1/FundamentalLemma.ec": [[true, "require import Distr Real StdOrder.\n(*---*) import RealOrder.\n\nop max (x y : real) = if x <= y then y else x.\n\ntype t.\n\n(* We want the bad event to be defined on both sides, *\n * so we assume that all the variables that are used  *\n * to define victory conditions and bad events are    *\n * stored in a separate module. (Note: the empty      *\n * signature could be instantiated with anything,     *\n * including the concrete experiment themselves       *\n * if their glob types match.)                        *)\nmodule type Mem = { }.\n\nmodule type Exp = {\n  proc main(): t\n}.\n\nlemma Pr_split (G <: Exp) (Mem <: Mem) (A: (glob Mem) -> t -> bool) (F: (glob Mem) -> t -> bool) &m:\n  Pr[G.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n  + Pr[G.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G.main() @ &m: A (glob Mem) res].\nproof.\nhave <-: Pr[G.main() @ &m: (A (glob Mem) res /\\ F (glob Mem) res) \\/\n                           (A (glob Mem) res /\\ !F (glob Mem) res)]\n         = Pr[G.main() @ &m: A (glob Mem) res].\n+ by rewrite Pr [mu_eq]=> /#.\nby rewrite Pr [mu_disjoint]=> /#.\nqed.\n\nlemma FundamentalLemma (G1 <: Exp) (G2 <: Exp) (Mem <: Mem)\n                       (A: (glob Mem) -> t -> bool) (B: (glob Mem) -> t -> bool)\n                       (F: (glob Mem) -> t -> bool) &m:\n  Pr[G1.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G2.main() @ &m: B (glob Mem) res /\\ !F (glob Mem) res] =>\n  `|Pr[G1.main() @ &m: A (glob Mem) res] - Pr[G2.main() @ &m: B (glob Mem) res]|\n  <= max Pr[G1.main() @ &m: F (glob Mem) res] Pr[G2.main() @ &m: F (glob Mem) res].\nproof.\nrewrite -(Pr_split G1 Mem A F &m) -(Pr_split G2 Mem B F &m)=> ->.\nhave ->: forall (x y z:real), x + y - (z + y) = x - z by smt().\napply (ler_trans (max Pr[G1.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n                      Pr[G2.main() @ &m: B (glob Mem) res /\\ F (glob Mem) res])).\n+ smt(ge0_mu).\nhave -> //: forall (x y x' y':real), x <= x' => y <= y' => max x y <= max x' y' by smt().\n+ by rewrite -(Pr_split G1 Mem F A &m) andbC; smt(ge0_mu).\nby rewrite -(Pr_split G2 Mem F B &m) andbC; smt(ge0_mu).\nqed.", "```ec\nrequire import Distr Real StdOrder.\n(*---*) import RealOrder.\n\nop max (x y : real) = if x <= y then y else x.\n\ntype t.\n\n(* We want the bad event to be defined on both sides, *\n * so we assume that all the variables that are used  *\n * to define victory conditions and bad events are    *\n * stored in a separate module. (Note: the empty      *\n * signature could be instantiated with anything,     *\n * including the concrete experiment themselves       *\n * if their glob types match.)                        *)\nmodule type Mem = { }.\n\nmodule type Exp = {\n  proc main(): t\n}.\n\nlemma Pr_split (G <: Exp) (Mem <: Mem) (A: (glob Mem) -> t -> bool) (F: (glob Mem) -> t -> bool) &m:\n  Pr[G.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n  + Pr[G.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G.main() @ &m: A (glob Mem) res].\nproof.\nhave <-: Pr[G.main() @ &m: (A (glob Mem) res /\\ F (glob Mem) res) \\/\n                           (A (glob Mem) res /\\ !F (glob Mem) res)]\n         = Pr[G.main() @ &m: A (glob Mem) res].\n+ by rewrite Pr [mu_eq]=> /#.\nby rewrite Pr [mu_disjoint]=> /#.\nqed.\n\nlemma FundamentalLemma (G1 <: Exp) (G2 <: Exp) (Mem <: Mem)\n                       (A: (glob Mem) -> t -> bool) (B: (glob Mem) -> t -> bool)\n                       (F: (glob Mem) -> t -> bool) &m:\n  Pr[G1.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G2.main() @ &m: B (glob Mem) res /\\ !F (glob Mem) res] =>\n  `|Pr[G1.main() @ &m: A (glob Mem) res] - Pr[G2.main() @ &m: B (glob Mem) res]|\n  <= max Pr[G1.main() @ &m: F (glob Mem) res] Pr[G2.main() @ &m: F (glob Mem) res].\nproof.\nrewrite -(Pr_split G1 Mem A F &m) -(Pr_split G2 Mem B F &m)=> ->.\nhave ->: forall (x y z:real), x + y - (z + y) = x - z by smt().\napply (ler_trans (max Pr[G1.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n                      Pr[G2.main() @ &m: B (glob Mem) res /\\ F (glob Mem) res])).\n+ smt(ge0_mu).\nhave -> //: forall (x y x' y':real), x <= x' => y <= y' => max x y <= max x' y' by smt().\n+ by rewrite -(Pr_split G1 Mem F A &m) andbC; smt(ge0_mu).\nby rewrite -(Pr_split G2 Mem F B &m) andbC; smt(ge0_mu).\nqed.\n```"]], "EC-1/generalize-module-aliases.ec": [[true, "module type T = {\n  proc f(): bool\n}.\n\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare module M_T1 <: T.\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule A2(M: T) = F(M_T1, M).M.\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof.\nproc.\nauto.\nqed.\n\nhoare L2 (M <: T): A2(M).N.g: true ==> true.\nproof.\nproc.\nauto.\nqed.\n\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed.\n\nhoare LL2 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L1 M1 C). qed. (* The module alias C can escape the section *)\n\nhoare LL3 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L2 M1). qed.", "```ec\nmodule type T = {\n  proc f(): bool\n}.\n\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare module M_T1 <: T.\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule A2(M: T) = F(M_T1, M).M.\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof.\nproc.\nauto.\nqed.\n\nhoare L2 (M <: T): A2(M).N.g: true ==> true.\nproof.\nproc.\nauto.\nqed.\n\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed.\n\nhoare LL2 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L1 M1 C). qed. (* The module alias C can escape the section *)\n\nhoare LL3 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L2 M1). qed.\n```"]], "EC-1/AES.ec": [[true, "*)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE /= InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE /= InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.", "```ec\n*)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE /= InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE /= InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.\n```"]], "EC-1/hashed_elgamal_generic.ec": [[false, "```ec\nrequire import AllCore List Int IntDiv Real.\nfrom Jasmin import JArray JWord JWhile.\nrequire (*---*) DiffieHellman.\nrequire (*---*) PKE_CPA ROM SCDH.\n\nsection.\n\n  (** Type and operators for bits (i.e. k-bit words) *)\n  type bits.\n\n  (** length of bitstrings, in bits *)\n  const k : int.\n\n  (** Distribution on (Zp)_*. *)\n  op dt   : { group | true } distr.\n\n  (** Distribution on k-bit bitstrings. *)\n  op dbits : { bits    | true } distr.\n\n  (** XOR on k-bit bitstrings. *)\n  op (+^) : bits -> bits -> bits.\n\n  (** Group generator. *)\n  op g : group.\n\n  (** Upper bound on the number of calls to the hash function. *)\n  const qH : int.\n\n  axiom gt0_qH : (0 < qH)%Int.\n\n  (** We assume that k > 0 *)\n  axiom k_gt0 : (0 < k)%Int.\n\n  (** Distribution on bits has full support *)\n  axiom dbits_ll : is_lossless dbits.\n\n  (** We assume dt has full support *)\n  axiom dt_ll : is_lossless dt.\n\n  (** We assume addition is a permutation of the second argument *)\n  axiom xor_perm (x : bits) : is_perm (fun y, x +^ y).\n\n  (** Log and LRO are an implementation of a random oracle *)\n  clone RO_ROC as Log with\n    type in_t  <- group,\n    type out_t <- bits,\n    op dout    <- dbits,\n    op f       <- (fun _ => true),\n    const qH   <- qH.\n\n  (** Module implementing the hash function using a random oracle *)\n  module H = Log(LRO).\n\n  (** We use an abstract type for plaintexts *)\n  type ptxt.\n\n  (** Plaintexts are encoded as bitstrings *)\n  op ptxt_to_bits : ptxt -> bits.\n\n  theory T_ptxt_to_bits.\n    axiom nosmt ptxt_to_bits_inj (m0 m1 : ptxt):\n      ptxt_to_bits m0 = ptxt_to_bits m1 => m0 = m1.\n  end T_ptxt_to_bits.\n\n  (** Adversary that is given an encoding of a group element and\n      chooses two plaintexts *)\n  module type Choose(O : POracle) = {\n    proc choose(gx : group) : ptxt * ptxt {O.log, gx}\n  }.\n\n  (** Adversary that guesses a bit, given a ciphertext *)\n  module type Guess(O : POracle) = {\n    proc guess(c : group * bits) : bool {O.log, c}\n  }.\n\n  (** Hashed ElGamal public-key encryption scheme *)\n  module Hashed_ElGamal(H : POracle) = {\n    var skey : group\n\n    (** Key generation: pick a secret key x and return g^x *)\n    proc kg() : group = {\n      skey <$ dt;\n      return g ^ skey;\n    }\n\n    (** Encryption *)\n    proc enc(pk : group, m : ptxt) : group * bits = {\n      var y, gy, h;\n\n      y  <$ dt;\n      gy <- g ^ y;\n      h  <@ H.o(pk ^ y);\n      return (gy, h +^ ptxt_to_bits m);\n    }\n\n    (** Decryption *)\n    proc dec(c : group * bits) : ptxt option = {\n      var gy, h', h, m;\n\n      gy <- c.`1;\n      h' <- c.`2;\n      h  <@ H.o(gy ^ skey);\n      m  <- h' +^ h;\n      return Some (oget (ptxt_to_bits^-1 m));\n    }\n  }.\n\n  (** Adversary that is given an encoding of a group element and\n      chooses two plaintexts, and that guesses a bit, given a\n      ciphertext *)\n  module BA(Choose : Choose, Guess : Guess) = {\n    module A = {\n      var qs : (group * bits) list\n\n      proc choose(gx : group) : ptxt * ptxt = {\n        var res;\n\n        res <@ Choose.o(gx);\n        return res;\n      }\n\n      proc guess(c : group * bits) : bool = {\n        var res;\n\n        qs <- c :: qs;\n        res <@ Guess.o(c);\n        return res;\n      }\n    }\n  }.\n\n  (** Indistinguishability under chosen-plaintext attack *)\n  module CPA(S : Scheme, A : Adv) = {\n    module S = S\n\n    proc main() : bool = {\n      var pk, m0, m1, c, b, b';\n\n      pk    <- S.kg();\n      (m0,m1) <@ A.choose(pk);\n      b    <$ {0,1};\n      c    <- S.enc(pk, b ? m1 : m0);\n      b'   <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  (** Instantiation of Hashed ElGamal and its CPA adversary *)\n  module S = Hashed_ElGamal(H).\n  module BA = BA(Choose(H), Guess(H)).\n\n  (** Game G0 (equivalent to CPA) *)\n  local module G0 = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.A.choose(gx);\n      b       <$ {0,1};\n      h       <@ H.hash(gxy);\n      c       <- (g ^ y, h +^ (b ? ptxt_to_bits m1 : ptxt_to_bits m0));\n      b'      <@ BA.A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local equiv CPA_G0: CPA(S,BA).main ~ G0.main: ={glob A} ==> ={res}.\n  proof.\n    proc.\n    inline Hashed_ElGamal(H).kg Hashed_ElGamal(H).enc.\n    swap{1} 8 -5.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; call (_: ={glob H}); first by sim.\n    wp; rnd.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; do !rnd.\n    by call (_: true ==> ={glob H}); first by sim.\n  qed.\n\n  local lemma Pr_CPA_G0 &m:\n    Pr[CPA(S,BA).main() @ &m: res] = Pr[G0.main() @ &m: res]\n  by byequiv CPA_G0.\n\n  local module G1 = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.A.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? ptxt_to_bits m1 : ptxt_to_bits m0));\n      b'      <@ BA.A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local module G2 = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.A.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? ptxt_to_bits m1 : ptxt_to_bits m0));\n      b'      <@ BA.A.guess(c);\n      return G2.gxy \\in Log.qs;\n    }\n  }.\n\n  local module (D : ROC.Dist) (H : POracle) = {\n    module A = BA.A(H)\n\n    var y:t\n    var b:bool\n    var m0, m1:ptxt\n\n    proc a1(): group = {\n      var x, gxy, gx;\n\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ A.choose(gx);\n      b       <$ {0,1};\n      return gxy;\n    }\n\n    proc a2(x:bits): bool = {\n      var c, b';\n\n      c  <- (g ^ y, x +^ (b ? ptxt_to_bits m1 : ptxt_to_bits m0));\n      b' <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G0_D &m: Pr[G0.main() @ &m: res] = Pr[OnBound.G0(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G1_D &m: Pr[G1.main() @ &m: res] = Pr[OnBound.G1(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G2_D &m: Pr[G2.main() @ &m: res] = Pr[OnBound.G_bad(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={glob Log, b'} /\\ b{1} = D.b{2} /\\ G2.gxy{1} = x{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G0_G1_G2 &m:\n    Pr[G0.main() @ &m: res] <= Pr[G1.main() @ &m: res] + Pr[G2.main() @ &m: res].\n  proof.\n  rewrite (G0_D &m) (G1_D &m) (G2_D &m).\n  move: (OnBound.ROM_BadCall D _ _ _ &m tt true).\n  + move=> H H_o_ll; proc; auto; call (choose_ll H _)=> //; auto=> />.\n    by rewrite dt_ll DBool.dbool_ll.\n  + by move=> H H_o_ll; proc; auto; call (guess_ll H _)=> //; auto=> />.\n  + by move=> _; apply: dbits_ll.\n  by rewrite !eqT.\n  qed.\n\n  local module G1' = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.A.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h);\n      b'      <@ BA.A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G1_G1' &m: Pr[G1.main() @ &m: res] = Pr[G1'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then ptxt_to_bits m1 else ptxt_to_bits m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Pr_G1' &m: Pr[G1'.main() @ &m: res] = 1%r/2%r.\n  proof.\n    have LRO_o_ll := LRO_o_ll _; first by move=> /=; apply: dbits_ll.\n    byphoare (_: true ==> res)=> //.\n    proc.\n    swap 7 3.\n    rnd (pred1 b').\n    conseq (_: true) => />.\n    + by move=> b'; rewrite DBool.dbool1E /pred1 => />.\n    islossless.\n    + by apply (guess_ll (Bound(LRO))); islossless.\n    by apply (choose_ll (Bound(LRO))); islossless.\n  qed.\n\n  local module G2' = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x        <$ dt;\n      y        <$ dt;\n      gx       <- g ^ x;\n      gxy      <- gx ^ y;\n      (m0,m1)  <@ BA.A.choose(gx);\n      b        <$ {0,1};\n      h        <$ dbits;\n      c        <- (g ^ y, h);\n      b'       <@ BA.A.guess(c);\n      return gxy \\in Log.qs;\n    }\n  }.\n\n  local lemma G2_G2' &m: Pr[G2.main() @ &m: res] = Pr[G2'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then ptxt_to_bits m1 else ptxt_to_bits m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local equiv G2'_SCDH: G2'.main ~ SCDH(SCDH_from_CPA(BA.A,LRO)).main:\n    ={glob A} ==> res{1} = res{2} /\\ card Log.qs{1} <= qH.\n  proof.\n    proc.\n    inline SCDH_from_CPA(BA.A,LRO).solve.\n    swap{2} 5 -4; swap{1} 7 3.\n    rnd{1}; wp.\n    seq  8  7: (={glob BA.A} /\\\n                c{1} = (gy, h){2} /\\\n                G2'.gxy{1} = g ^ (x * y){2} /\\\n                card Log.qs{1} <= qH).\n      wp; rnd; call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n        proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> />.\n        by move=> &2 _ szqs_lt_qH _ _; rewrite fcardU fcard1; smt(fcard_ge0).\n      by inline H.init LRO.init; auto=> />; rewrite fcards0; smt(gt0_qH pow_pow).\n    call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n      proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> /> &2 _ szqs_lt_qH _ _.\n      by rewrite fcardU fcard1; smt(fcard_ge0).\n    by auto => />.\n  qed.\n\n  local lemma Pr_G2'_SCDH &m :\n    Pr[G2'.main() @ &m: res]\n    = Pr[SCDH(SCDH_from_CPA(BA.A,LRO)).main() @ &m : res]\n  by byequiv G2'_SCDH.\n\n  local lemma Reduction &m :\n    Pr[CPA(S,BA).main() @ &m : res] <=\n    1%r / 2%r + Pr[SCDH(SCDH_from_CPA(BA.A,LRO)).main() @ &m : res].\n  proof.\n    rewrite (Pr_CPA_G0 &m).\n    rewrite -(Pr_G1' &m) -(G1_G1' &m).\n    rewrite -(Pr_G2'_SCDH &m) -(G2_G2' &m).\n    by apply (G0_G1_G2 &m).\n  qed.\n\n  (** Composing reduction from CPA to SCDH with reduction from SCDH to CDH *)\n  lemma Security &m:\n      Pr[CPA(S,BA).main() @ &m: res] - 1%r / 2%r <=\n      qH%r * Pr[CDH.CDH(CDH_from_SCDH(SCDH_from_CPA(BA.A,LRO))).main() @ &m: res].\n  proof.\n    apply (ler_trans (Pr[SCDH(SCDH_from_CPA(BA.A,LRO)).main() @ &m: res])).\n    + smt(Reduction).\n    have:= SCDH.Reduction (SCDH_from_CPA(BA.A,LRO)) &m gt0_qH.    \n    by rewrite -mulrA mul1r mulrC ler_pdivr_mulr 1:lt_fromint 1:gt0_qH mulrC.\n  qed.\nend"]], "EC-1/hashed_elgamal_std.ec": [[false, "```houzhui\n(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman BitWord PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(** Assumption: DDH **)\n(*** WARNING: DiffieHellman is not up to speed with latest developments ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Assumption Entropy Smoothing *)\ntheory EntropySmoothing.\n  type hkey.\n\n  op dhkey: { hkey distr | is_lossless dhkey } as dhkey_ll.\n  hint exact dhkey_ll : dhkey_ll.  \n\n  op hash : hkey -> group -> bits.\n\n  module type AdvES = {\n    proc guess(_: hkey * bits) : bool\n  }.\n\n  module ES0 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, h;\n      hk <$ dhkey;\n      h  <$ dbits;\n      b  <@ A.guess(hk,h);\n      return b;\n    }\n  }.\n\n  module ES1 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, z;\n      hk <$ dhkey;\n      z  <$ dt;\n      b  <@ A.guess(hk, hash hk (g ^ z));\n      return b;\n    }\n  }.\nend EntropySmoothing.\nimport EntropySmoothing.\n\n(** Construction: a PKE **)\ntype pkey = hkey * group.\ntype skey = hkey * F.t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\nclone import PKE_CPA as PKE_ with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule Hashed_ElGamal : Scheme = {\n  proc kg() = {\n    var hk,sk;\n\n    hk <$ dhkey;\n    sk <$ dt;\n    return ((hk,g ^ sk), (hk,sk));\n  }\n\n  proc enc(pk: pkey, m: ptxt) = {\n    var y, h;\n\n    y <$ dt;\n    h <- hash pk.`1 (pk.`2 ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <- hash sk.`1 (gy ^ sk.`2);\n    return Some (h +^ hm);\n  }\n}.\n\n(** Exact security *)\nmodule DDHAdv(A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var hk, m0, m1, b, b', h;\n    hk       <$ dhkey;\n    (m0, m1) <@ A.choose((hk,gx));\n    b        <$ {0,1};\n    h        <- hash hk gz;\n    b'       <@ A.guess(gy,h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nmodule ESAdv(A:Adversary) = {\n  proc guess (hk, h) : bool = {\n    var x, y, m0, m1, b, b';\n    x        <$ dt;\n    y        <$ dt;\n    (m0, m1) <@ A.choose((hk,g^x));\n    b        <$ {0,1};\n    b'       <@ A.guess(g^y, h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(Hashed_ElGamal,A).main() @ &m : res]\n    = Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 1 1; swap{1} 8 -6; swap{2} 6 -3.\n  auto; call (: true).\n  auto; call (: true).\n  by auto=> /> sk _ y _ hk _ [m0 m1] b _ /=; rewrite pow_pow.\n  qed.\n\n  local lemma ddh1_es1 &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res]\n    = Pr[ES1(ESAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -3; swap{2} [5..6] -4; swap{2} 4 -1.\n  auto; call (: true).\n  auto; call (:true).\n  by auto.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var hk, x, y, v,m0, m1, b, b';\n      hk      <$ dhkey;\n      x       <$ dt;\n      y       <$ dt;\n      (m0,m1) <@ A.choose(hk,g^x);\n      v       <$ dbits;\n      b       <$ {0,1};\n      b'      <@ A.guess(g^y, v +^ (b?m1:m0));\n      return b' = b;\n    }\n  }.\n\n  local lemma es0_Gb &m:\n      Pr[ES0(ESAdv(A)).main() @ &m : res]\n    = Pr[Gb.main()@ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 2 1. swap{1} [3..4] 4. swap{2} 7 -2.\n  auto; call (: true); wp.\n  rnd (fun w, w +^ (b0{1} ? m1{1} : m0{1})).\n  auto; call (: true).\n  by auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd (pred1 b')=> /=; conseq (_:_ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  call Ag_ll; auto.\n  by call Ac_ll; auto=> />; rewrite dhkey_ll dt_ll dbits_ll.\n  qed.\n\n  lemma conclusion &m :\n       `| Pr[CPA(Hashed_ElGamal,A).main() @ &m : res] - 1%r/2%r |\n    <= `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n          - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |\n       + `| Pr[ES0(ESAdv(A)).main() @ &m : res]\n            - Pr[ES1(ESAdv(A)).main() @ &m : res]|.\n  proof.\n  rewrite (cpa_ddh0 &m) (ddh1_es1 &m) (es0_Gb &m) (Gb_half &m).\n  smt(@Real).\n  qed.\nend section Security.\n\nprint conclusion.\n```"]], "EC-1/KEMDEM.ec": [[true, "(* KEM-DEM Composition Protocol Security Proof *)\n\nrequire import AllCore Distr List FMap.\nrequire (*--*) PKE.\n\n(* Types and Definitions *)\ntype pkey, skey, pt, key, kct, dct.\n\nop dkey : key distr.\n\n(* KEM and DEM Specifications *)\nmodule type KEM = {\n  proc keygen() : pkey * skey\n  proc enc(pk : pkey) : key * kct\n  proc dec(sk : skey, c : kct) : key option\n}.\n\nmodule type DEM = {\n  proc enc(k : key, m : pt) : dct\n  proc dec(k : key, c : dct) : pt option\n}.\n\n(* CPA Adversary for PKE *)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey) : pt * pt\n  proc distinguish(c : kct * dct) : bool\n}.\n\n(* KEM-DEM Composition *)\nmodule KEMDEM (E_kem : KEM, E_s : DEM) : PKE = {\n  proc keygen() = {\n    return E_kem.keygen();\n  }\n\n  proc enc(pk : pkey, m : pt) = {\n    var k, c1, c2;\n\n    (k, c1) <@ E_kem.enc(pk);\n    c2 <@ E_s.enc(k, m);\n    return (c1, c2);\n  }\n\n  proc dec(sk : skey, c : kct * dct) = {\n    var k, m;\n\n    k <@ E_kem.dec(sk, c.`1);\n    if (k = None) {\n      return None;\n    }\n    m <@ E_s.dec(k, c.`2);\n    return m;\n  }\n}.\n\n(* Reductions *)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: KEM { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    (k0, kc) <@ E_kem.enc(pk);\n    k1 <$ dkey;\n    c <@ E_s.enc(k1, if b then m1 else m0);\n    r <@ A.distinguish((kc, c));\n    return r;\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} B_kem_0(E_s,A).distinguish.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} 3.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} 4 -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} B_kem_0(E_s,A).distinguish.\nswap {1} 4 -3. swap {1} 5 & +1 @4 -3.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ (kc{1},c{1}) = (c{2},c'{2}))=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} B_s(E_kem,A).distinguish.\n  swap {2} 4 & +1 -2. swap {2} 3 & +1 -2.\n  inline {2} 2.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} 3 & +1 -2.\ninline {2} B_s(E_kem,A).distinguish.\nswap {2} 4 & +1 -3.\ninline {2} 2.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} 4 -1. swap {1} 7 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} 4 -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem.", "```ec\n(* KEM-DEM Composition Protocol Security Proof *)\n\nrequire import AllCore Distr List FMap.\nrequire (*--*) PKE.\n\n(* Types and Definitions *)\ntype pkey, skey, pt, key, kct, dct.\n\nop dkey : key distr.\n\n(* KEM and DEM Specifications *)\nmodule type KEM = {\n  proc keygen() : pkey * skey\n  proc enc(pk : pkey) : key * kct\n  proc dec(sk : skey, c : kct) : key option\n}.\n\nmodule type DEM = {\n  proc enc(k : key, m : pt) : dct\n  proc dec(k : key, c : dct) : pt option\n}.\n\n(* CPA Adversary for PKE *)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey) : pt * pt\n  proc distinguish(c : kct * dct) : bool\n}.\n\n(* KEM-DEM Composition *)\nmodule KEMDEM (E_kem : KEM, E_s : DEM) : PKE = {\n  proc keygen() = {\n    return E_kem.keygen();\n  }\n\n  proc enc(pk : pkey, m : pt) = {\n    var k, c1, c2;\n\n    (k, c1) <@ E_kem.enc(pk);\n    c2 <@ E_s.enc(k, m);\n    return (c1, c2);\n  }\n\n  proc dec(sk : skey, c : kct * dct) = {\n    var k, m;\n\n    k <@ E_kem.dec(sk, c.`1);\n    if (k = None) {\n      return None;\n    }\n    m <@ E_s.dec(k, c.`2);\n    return m;\n  }\n}.\n\n(* Reductions *)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: KEM { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    (k0, kc) <@ E_kem.enc(pk);\n    k1 <$ dkey;\n    c <@ E_s.enc(k1, if b then m1 else m0);\n    r <@ A.distinguish((kc, c));\n    return r;\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} B_kem_0(E_s,A).distinguish.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} 3.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} 4 -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} B_kem_0(E_s,A).distinguish.\nswap {1} 4 -3. swap {1} 5 & +1 @4 -3.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ (kc{1},c{1}) = (c{2},c'{2}))=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} B_s(E_kem,A).distinguish.\n  swap {2} 4 & +1 -2. swap {2} 3 & +1 -2.\n  inline {2} 2.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} 3 & +1 -2.\ninline {2} B_s(E_kem,A).distinguish.\nswap {2} 4 & +1 -3.\ninline {2} 2.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} 4 -1. swap {1} 7 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} 4 -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem.\n```"]], "EC-1/KEM_ROM.ec": [[false, "```ec\n(* ... (rest of the file remains the same) ... *)\n\nsection.\n\n  clone import LorR as LR with\n     type input <- ciphertext * key.\n\n  declare module S<:Scheme.\n  declare module A<:Adversary{-S}.\n\n  lemma pr_CPA_LR &m:\n    islossless S.kg => islossless S.enc =>\n    islossless A.guess =>\n    `| Pr"]], "EC-1/MPAPISemantics.ec": [[false, "```ec\n(** Multiparty semantics for a language parameterised by an API *)\nrequire import AllCore List SmtMap.\n\nrequire import AAPI ALanguage AMPSemantics SPAPISemantics.\n\n(**\n  We define a particular multiparty semantics that works for languages\n  where the computation of secret operations is carried out\n  by an external API, whlist public operations remain in the\n  domain of the language itself.\n\n  This semantics is essentially a realisation of the multiparty\n  semantics, that extends it with new datatypes and operations to interpolate \n  between the evaluation of the program and the API calls that are requested.\n\n  The interaction with the API is done via the"]], "EC-1/MPCProtocolLibrary.ec": [[false, "The task is to complete the given incomplete protocol's formal analysis code with the ec language. The provided code snippet is part of the MPC Protocol Library.\n\nHere's the completed code:\n\n```ec\nwith x = LeakedShares _ => None.\n  op leakage_shares (x: leakage_t) : inputs_t option =\n    with x = LeakedValue v => None\n    with x = LeakedShares s => Some s.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Side information constructors *)\n  op Leak (v: value_t) : sideInfo_t =\n    {| leakage = Some (LeakedValue v); trace ="]], "EC-1/NbPRFEnc.ec": [[false, "```ec\nto use\n   a true random function instead of the PRF *)\nmodule ModifiedScheme = {\n   include Scheme"]], "EC-1/ind_ow_pke.ec": [[true, "require import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\nclone import PublicKeyEncryption as PKE.\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    p <$ dptxtm pk;\n    p' <$ dptxtm pk;\n    return (p, p');  \n  }\n  \n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;\n    pinv <@ A.find(pk', c);\n    return pinv = p'; \n  }\n}.\n\nsection.\n\ndeclare module S <: Scheme{-R_IND_OW}.\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}.\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  \n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t\n  proc main() : bool = {\n    var pk : pk_t;\n    var sk : sk_t;\n    var p' : ptxt_t;\n    var c : ctxt_t;\n    (pk, sk) <@ S.keygen();\n    p0 <$ dptxtm pk;\n    p1 <$ dptxtm pk;\n    c <@ S.enc(pk, p0);\n    p' <@ A.find(pk, c);\n    return p' = p0;\n  }\n}.\n\nlocal equiv test : \n  OW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll). \nqed.\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]\n  +\n  pmax_pk dptxtm.\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]).\n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section.", "```ec\nrequire import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\nclone import PublicKeyEncryption as PKE.\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    p <$ dptxtm pk;\n    p' <$ dptxtm pk;\n    return (p, p');  \n  }\n  \n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;\n    pinv <@ A.find(pk', c);\n    return pinv = p'; \n  }\n}.\n\nsection.\n\ndeclare module S <: Scheme{-R_IND_OW}.\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}.\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  \n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t\n  proc main() : bool = {\n    var pk : pk_t;\n    var sk : sk_t;\n    var p' : ptxt_t;\n    var c : ctxt_t;\n    (pk, sk) <@ S.keygen();\n    p0 <$ dptxtm pk;\n    p1 <$ dptxtm pk;\n    c <@ S.enc(pk, p0);\n    p' <@ A.find(pk, c);\n    return p' = p0;\n  }\n}.\n\nlocal equiv test : \n  OW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll). \nqed.\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]\n  +\n  pmax_pk dptxtm.\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]).\n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section.\n```"]], "EC-1/otp.ec": [[false, "To complete the given EasyCrypt code, we first need to understand the missing parts based on the provided description.\n\n1. The first missing part is related to the definition of `l`, which is an operation that represents the length of the bitstrings used in the protocol. The condition `0 < l` ensures that the length is positive.\n\n2. The second part involves defining the type `message`. Since both `ciphertext` and `key` are defined as `bitstring`, and given that `message` should be of the same type for the XOR operation to be valid, `message` should also be a `bitstring`.\n\nLet's fill in the blanks accordingly:\n\n- For `op l : { int | 0 < l } ____(OP_1)____ ____(OP_0)____`, we need to specify that `l` is an integer that is greater than 0. The syntax for this in EasyCrypt involves using the `as` keyword to give a name to the condition, but here we directly provide the type and the condition. Thus, it should be `as gt0_l`.\n\n- For `type message = ____(TYPE_0)____`, since `message` should be a `bitstring` to be consistent with the types of `ciphertext` and `key`, and to allow for the bitwise XOR operation with `key`, it should be defined as `bitstring`.\n\nHere's the completed code:"]], "EC-1/passCertRPG_ref.ec": [[false, "```ec\nrequire import AllCore IntDiv DInterval List UpdateList.\nrequire RPGTh.\n\nclone include RPGTh.\n\nmodule RPGRef : RPG_T = {\n\n  var lowercaseSet, uppercaseSet, numbersSet, specialSet : charSet\n\n  proc rng(range:int) : int = {\n    \n    var value, maxValue, modValue : int;\n\n    (* check how much we should remove from 2^64 - 1 in order to get a multiple of range *)\n    modValue <- (2^64 - 1) %% range;\n\n    (* if the mod is range - 1, it means we can sample from 2^64 - 1 and have an uniform distribution *)\n    if(modValue = range - 1) {\n      maxValue <- (2^64 - 1);\n    (* else, we need to remove the unnecessary values*)\n    } else {\n      maxValue <- (2^64 - 1) - modValue - 1;\n    }\n\n    value <$ [0 .. (2^64 - 1)];\n\n    while (maxValue < value) {\n      value <$ [0 .. (2^64 - 1)]; (* Random Bytes Generator *)\n    }\n    \n    value <- value %% range;\n    \n    return value;\n    \n  }\n\n  \n  proc random_char_generator(set:charSet) : char = {\n    \n    var char : char;\n    var choice : int;\n    \n    choice <@ rng(size set);\n    char <- nth (-1) set choice;\n    \n    return (char);\n    \n  }\n\n  \n  proc permutation(pw:password) : password = {\n\n    var i : int;\n    var j : int;\n    var aux : char;\n    \n    i <- size pw;\n    \n    while (0 < i) {\n      j <@ rng(i);\n      i <- i - 1;\n      aux <- nth 0 pw i;\n      pw <- update (nth 0 pw j) pw i;\n      pw <- update aux pw j;\n    }\n    \n    return pw;\n \n  }\n\n\n  proc get_lowercaseSet() : charSet = {\n    \n    var set : charSet;\n    set <- [97; 98; 99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111; 112;\n           113; 114; 115; 116; 117; 118; 119; 120; 121; 122];\n    return set;\n\n  }\n\n\n  proc get_lowercaseSet,uro(arg) : charSet = {\n    \n    var set : charSet;\n    set <- [65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85;\n           86; 87; 88; 89; 90];\n    return set;\n\n  }\n\n\n  proc get_numbersSet() : charSet = {\n\n    var set : charSet;\n    set <- [48; 49; 50; 51; 52; 53; 54; 55; 56; 57];\n    return set;\n\n  }\n\n\n  proc get_specialSet() : charSet = {\n    \n    var set : charSet;\n    set <- [33; 63; 35; 36; 37; 38; 43; 45; 42; 95; 64; 58; 59; 61];\n    return set;\n\n  }\n\n\n  proc define_union_set(nLowercase:int, nUppercase:int, nNumbers:int, nSpecial:int,\n                        lowercaseSet:charSet, uppercaseSet:charSet,\n                        numbersSet:charSet, specialSet:charSet) : charSet = {\n\n    var unionSet, set : charSet;\n\n    unionSet <- [];\n    \n    if (0 < nLowercase) {\n      set <- lowercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nUppercase) {\n      set <- uppercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nNumbers) {\n      set <- numbersSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nSpecial) {\n      set <- specialSet;\n      unionSet <- unionSet ++ set;\n    }\n\n    return unionSet;    \n\n  }\n\n  \n  proc generate_password(policy:policy) : password option = {\n\n    var outputPassword : password option;\n    var generatedPassword : password;\n    var unionSet : charSet;\n    var randomChar : char;\n    var i : int;\n    var lowercaseAvailable, uppercaseAvailable, numbersAvailable, specialAvailable : int;\n\n    (* ---------------------------------------------- *)\n    (* If policy is satisfiable, return Some password *)\n    (* ---------------------------------------------- *)\n    if(satisfiablePolicy policy) {\n\n      (* initializer sets *)\n      lowercaseSet <@ get_lowercaseSet();\n      uppercaseSet <@ get_uppercaseSet();\n      numbersSet <@ get_numbersSet();\n      specialSet <@ get_specialSet();\n\n      (* initialize random password *)\n      generatedPassword <- [];\n    \n      (* check which sets are available to generate characters from (max > 0) *)\n\n      lowercaseAvailable <- policy.`lowercaseMax;\n      uppercaseAvailable <- policy.`uppercaseMax;\n      numbersAvailable <- policy.`numbersMax;\n      specialAvailable <- policy.`specialMax;\n\n      (* generate characters with min values defined *)     \n \n      if (0 < lowercaseAvailable) {\n        i <- 0;\n        while (i < policy.`lowercaseMin) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          randomChar <@ random_char_generator(lowercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < uppercaseAvailable) {\n        i <- 0;\n        while (i < policy.`uppercaseMin) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          randomChar <@ random_char_generator(uppercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < numbersAvailable) {\n        i <- 0;\n        while (i < policy.`numbersMin) {\n          numbersAvailable <- numbersAvailable - 1;\n          randomChar <@ random_char_generator(numbersSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < specialAvailable) {\n        i <- 0;\n        while (i < policy.`specialMin) {\n          specialAvailable <- specialAvailable - 1;\n          randomChar <@ random_char_generator(specialSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n\n      (* generate characters from the available sets of characters *)\n\n      unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                   specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                   specialSet);\n\n      while (size generatedPassword < policy.`length) {\n\n        randomChar <@ random_char_generator(unionSet);\n\n        if (randomChar \\in lowercaseSet) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          if (lowercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in uppercaseSet) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          if (uppercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in numbersSet) {\n          numbersAvailable <- numbersAvailable - 1;\n          if (numbersAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in specialSet) {\n          specialAvailable <- specialAvailable - 1;\n          if (specialAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n\n        generatedPassword <- generatedPassword ++ [randomChar];\n\n      }\n\n        generatedPassword <@ permutation(generatedPassword);\n   \n        outputPassword <- Some generatedPassword;\n\n    }\n\n    (* --------------------------------------- *)\n    (* If policy is unsatisfiable, return None *)\n    (* --------------------------------------- *)\n    else {\n\n      outputPassword <- None;\n\n    }\n\n    return outputPassword;\n    \n  }\n  \n}.\n\n\n\n\n(**********************************)\n(*        AUXILIARY LEMMAS        *)\n(**********************************)\n\n(* axiom -> rng always terminates *)\naxiom rng_ll : islossless RPGRef.rng.\n\n\n(* output of rng is smaller than range *)\nlemma rng_range _range :\n  hoare [RPGRef.rng : range = _range /\\ 0 < _range ==> 0 <= res /\\ res < _range].\nproof.\nproc.\nsp.\nseq 1 : (#pre /\\ 0 <= value).\n  auto.\n  move => &m /> h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nwp.\nwhile (0 <= value).\n  auto.\n  move => &m h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nskip.\nmove => &m /> h1 h2 value0 h3 h4.\nsplit.\n- by apply modn_ge0. \n- have h5 : range{m} = _range.\n  + smt().\n  have h6 : 0 < _range.\n  + smt().\n  by rewrite h5 ltz_pmod.\nqed.\n\n\n(* input set given to random char generator has the generated char *)\nlemma random_char_generator_has _set :\n  hoare [RPGRef.random_char_generator : set = _set /\\ 0 < size _set ==> res \\in _set].\nproof.\nproc.\nauto.\nseq 1 : (set = _set /\\ 0 <= choice /\\ choice < size set).\n  ecall (rng_range (size set)).\n  auto.\nauto.\nmove => &m [h1 h2].\nby rewrite -h1 mem_nth andaE.\nqed.\n\n\n(* permutation of a password does not change its size*)\nlemma permutation_size input :\n  hoare [RPGRef.permutation : pw = input ==> size res = size input].\nproof.\nproc.\nseq 1 : (size pw = size input).\n  auto.\nwhile (size pw = size input).\n  seq 1 : (size pw = size input).\n    ecall (rng_range i).\n    skip.\n    move => />.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n    move => &m /> h1.\n    by rewrite -size_update.\n  auto.\n  by rewrite -size_update.\n  by skip.\nqed.\n\n\n(* if the unionSet has characters from a given set, it means that that set is stil 'available'.\n   this happens if at least one of the sets is 'available'  *)\nlemma unionSet_available\n  (_nLowercase, _nUppercase, _nNumbers, _nSpecial:int)\n  (_lowercaseSet, _uppercaseSet, _numbersSet, _specialSet:charSet) :\nhoare [RPGRef.define_union_set :\n         nLowercase = _nLowercase /\\\n         nUppercase = _nUppercase /\\\n         nNumbers = _nNumbers /\\\n         nSpecial = _nSpecial /\\\n         lowercaseSet = _lowercaseSet /\\\n         uppercaseSet = _uppercaseSet /\\\n         numbersSet = _numbersSet /\\\n         specialSet = _specialSet /\\\n         0 <= _nLowercase /\\\n         0 <= _nUppercase /\\\n         0 <= _nNumbers /\\\n         0 <= _nSpecial /\\\n         0 < size _lowercaseSet /\\\n         0 < size _uppercaseSet /\\\n         0 < size _numbersSet /\\\n         0 < size _specialSet /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _numbersSet => ! (x \\in _specialSet))\n         ==>\n         (0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial => 0 < size res) /\\\n         (has (fun (x) => x \\in res) _lowercaseSet => 0 < _nLowercase) /\\\n         (has (fun (x) => x \\in res) _uppercaseSet => 0 < _nUppercase) /\\\n         (has (fun (x) => x \\in res) _numbersSet => 0 < _nNumbers) /\\\n         (has (fun (x) => x \\in res) _specialSet => 0 < _nSpecial) /\\\n         (forall x, x \\in res => x \\in _lowercaseSet \\/\n                                 x \\in _uppercaseSet\\/\n                                 x \\in _numbersSet \\/\n                                 x \\in _specialSet)].\nproof.\nproc.\nseq 1 : (#pre /\\ unionSet = []).\n  auto.\nif.\n- seq 2 : (nLowercase = _nLowercase /\\\n           nUppercase = _nUppercase /\\\n           nNumbers = _nNumbers /\\\n           nSpecial = _nSpecial /\\\n           lowercaseSet = _lowercaseSet /\\\n           uppercaseSet = _uppercaseSet /\\\n           numbersSet = _numbersSet /\\\n           specialSet = _specialSet /\\\n           0 < size _lowercaseSet /\\\n           0 < size _uppercaseSet /\\\n           0 < size _numbersSet /\\\n           0 < size _specialSet /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n           0 < nLowercase /\\\n           0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n           unionSet = lowercaseSet).\n    auto.\n    move => />.\n    smt(addz_gt0).\n  if.\n  + seq 2 : (nLowercase = _nLowercase /\\\n             nUppercase = _nUppercase /\\\n             nNumbers = _nNumbers /\\\n             nSpecial = _nSpecial /\\\n             lowercaseSet = _lowercaseSet /\\\n             uppercaseSet = _uppercaseSet /\\\n             numbersSet = _numbersSet /\\\n             specialSet = _specialSet /\\\n             0 < size _lowercaseSet /\\\n             0 < size _uppercaseSet /\\\n             0 < size _numbersSet /\\\n             0 < size _specialSet /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n             0 < nLowercase /\\\n             0 < nUppercase /\\\n             0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n             unionSet = lowercaseSet ++ uppercaseSet).\n      auto.\n    if.\n    - seq 2 : (nLowercase = _nLowercase /\\\n               nUppercase = _nUppercase /\\\n               nNumbers = _nNumbers /\\\n               nSpecial = _nSpecial /\\\n               lowercaseSet = _lowercaseSet /\\\n               uppercaseSet = _uppercaseSet /\\\n               numbersSet = _numbersSet /\\\n               specialSet = _specialSet /\\\n               0 < size _lowercaseSet /\\\n               0 < size _uppercaseSet /\\\n               0 < size _numbersSet /\\\n               0 < size _specialSet /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n               0 < nLowercase /\\\n               0 < nUppercase /\\"]], "EC-1/AMPSemantics.ec": [[false, "```houzhui\n(** Abstract class for multiparty semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The multiparty semantics class is establishes how a program can\n  be collaboratively animated. We define the multiparty semantics\n  assuming that program evaluation is carried out by three computing\n  nodes, each one holding a description of the program in pottentially\n  different languages. We restrict the multiparty semantics\n  to only three parties due to tool limitations. Nevertheless,\n  having a three-party set is explanatory enough to demonstrate\n  the concepts we want to explore in this work and the definitions\n  here presented can easily be extended to other party configurations.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of either request some local party\n  execution or a synchronised execution, where all parties, executing\n  at the same time, have the ability to perform distributed protocols\n  that require party interaction.\n\n  Finally, the semantics here specified contemplates the possiblity\n  of the execution disclosing the communication trace that is left by operations\n  that result from the collaboration of parties.\n*)\ntheory MultiPartySemantics.\n\n  (** Language L1 *)\n  clone import Language as L1.\n  (** Language L2 *)\n  clone import Language as L2.\n  (** Language L3 *)\n  clone import Language as L3.\n\n  (** Communication trace *)\n  type sideInfo_t.\n\n  (** Party identifiers for multiparty semantics *)\n  type partyId_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      -"]], "EC-1/pedersen-1.ec": [[true, "require import DLog.\n\nclone import Commitment as CM with\n  type CM.value      <- value,\n  type CM.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\n\n...\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n...", "To complete the given incomplete EasyCrypt code for the Pedersen commitment scheme, we need to identify and fill in the missing parts as indicated by `____()___`. \n\nThe first step is to identify the sections that need to be completed. Upon reviewing the code, we notice that there are two main areas that require completion: \n1. The `require import` statement for the DLog module.\n2. The type instantiations in the `clone import Commitment as CM` section.\n3. The module instantiation for `DLogAttacker(B:____(MODULE_0)____)`.\n\nLet's start by addressing these:\n\n1. The `require import` statement for DLog should be completed with the correct path or name. Assuming it's a standard module, it might simply be `DLog`.\n\n2. The type instantiations for `CM` should match the types defined in `PedersenTypes`. Thus, `type ____(TYPE_0)____.value <- value` should be `type CM.value <- value`, and similarly for `message`.\n\n3. For `DLogAttacker`, the type of `B` should be related to the `Binder` interface from the `Commitment` module.\n\nHere's how you can fill in these sections:\n\n```easycrypt\nrequire import DLog.\n\nclone import Commitment as CM with\n  type CM.value      <- value,\n  type CM.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\n\n...\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n...\n```\n\nWith these changes, the completed code should look like this:\n\n```easycrypt\n(*\n * A formal verification of the Pedersen commitment scheme\n *\n * Pedersen, Torben Pryds\n * \"Non-interactive and information-theoretic secure verifiable secret sharing\"\n *)\nrequire import Real.\nrequire import DLog.\n\nclone DLog as DL.\nimport DL.G DL.GP DL.FD DL.GP.ZModE.\n\nrequire import Commitment.\n\n(* Pedersen protocol types *)\ntheory PedersenTypes.\n  type value        = group.\n  type message      = exp.\n  type commitment   = group.\n  type openingkey   = exp.\nend PedersenTypes.\nexport PedersenTypes.\n\n(* Instantiate the Commitment scheme with the above types *)\nclone import Commitment as CM with\n  type CM.value      <- value,\n  type CM.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\nexport CommitmentProtocol.\n\nmodule Pedersen : CommitmentScheme = {\n  proc gen() : value = {\n    var x, h;\n    x <$ dt;\n    h <- g ^ x;\n    return h;\n  }\n\n  proc commit(h: value, m: message) : commitment * openingkey = {\n    var c, d;\n    d <$ dt;\n    c <- (g ^ d) * (h ^ m);\n    return (c, d);\n  }\n\n  proc verify(h: value, m: message, c: commitment, d: openingkey) : bool = {\n    var c';\n    c' <- (g ^ d) * (h ^ m);\n    return (c = c');\n  }\n}.\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n  proc guess (h: group) : exp option = {\n\n    var x, c, m, m', d, d';\n    (c, m, d, m', d') <@ B.bind(h);\n    if ((c = g ^ d * h ^ m) /\\ (c = g ^ d' * h ^ m') /\\ (m <> m'))\n      x <- Some((d - d') * inv (m' - m));\n    else\n      x <- None;\n\n    return x;\n  }\n}.\n\nsection PedersenSecurity.\n\n  (* Correctness *)\n  lemma pedersen_correctness:\n    hoare[Correctness(Pedersen).main: true ==> res].\n  proof. proc; inline *;auto. qed.\n\n  local module FakeCommit(U:Unhider) = {\n    proc main() : bool = {\n      var b, b', x, h, c, d;\n      var m0, m1 : exp;\n\n      (* Clearly, there are many useless lines, but their presence helps for the proofs *)\n      x <$ dt;\n      h <- g^x;\n      (m0, m1) <@ U.choose(h);\n      b <$ {0,1};\n      d <$ dt;\n      c <- g^d; (* message independent - fake commitment *)\n      b' <@ U.guess(c);\n\n      return (b = b');\n    }\n  }.\n\n  local lemma hi_ll (U<:Unhider):\n    islossless U.choose =>\n    islossless U.guess =>\n    islossless FakeCommit(U).main.\n  proof.\n    by move => uc_ll ug_ll; islossless; (apply dt_ll || apply DBool.dbool_ll).\n  qed.\n\n  (* Perfect hiding *)\n  local lemma fakecommit_half (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[FakeCommit(U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    move => uc_ll ug_ll; byphoare => //.\n    proc; wp.\n    swap 4 3.\n    rnd (pred1 b'); call ug_ll; wp; rnd; call uc_ll; auto => />.\n    by rewrite dt_ll /= => v _ _ result; rewrite DBool.dbool1E.\n  qed.\n\n  local lemma phi_hi (U<:Unhider) &m:\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] =\n    Pr[FakeCommit(U).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    call (_:true); wp.\n    rnd (fun d, (d + x * (b?m1:m0)){2})\n        (fun d, (d - x * (b?m1:m0)){2}).\n    by wp; rnd; call (_: true); auto => />; progress; algebra.\n  qed.\n\n  (* Perfect hiding - QED *)\n  lemma pedersen_perfect_hiding (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    by move => uc_ll ug_ll; rewrite (phi_hi U &m) (fakecommit_half U &m).\n  qed.\n\n  (* Computational binding - QED *)\n  lemma pedersen_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] =\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    wp; call (_: true); auto => /> x _ [ c m d m' d'] /= comm comm' m_neq_m'.\n    rewrite eq_sym eqT.\n    have ->: (d - d') * inv (m' - m) = x <=> (d - d') = x * (m' - m).\n    + by split => [<- | ->]; field; apply: contra m_neq_m' => heq;ring heq.\n    have -> : d - d' = x * (m' - m) <=> d + x * m = d' + x * m'.\n    + by split => heq; ring heq.\n    by rewrite pow_bij !(expD, expM, -comm, -comm').\n  qed.\n\n  (*\n     The following two are to compare probability directly with book discrete\n     logarithm experiment. Not strictly necessary though, only for completeness.\n  *)\n  local lemma std_red_dl_bridge (B<:Binder) &m:\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; wp; inline{2} DL.StdRedAdversary(DLogAttacker(B)).guess; wp.\n    seq 2 3: (x'{1} = lx{2} /\\ x{1} = x{2}).\n    + by inline*; wp; call (_: true); auto.\n    by if{2}; auto => />; apply dt_ll.\n  qed.\n\n  lemma pedersen_std_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res]\n  by rewrite(pedersen_computational_binding B &m); apply (std_red_dl_bridge B &m).\n\nend section PedersenSecurity.\n\nprint pedersen_correctness.\nprint pedersen_perfect_hiding.\nprint pedersen_computational_binding.\n```"]], "EC-1/Plug_and_Pray_example.ec": [[false, "To complete the given EasyCrypt code, we need to analyze the provided description and identify the missing components.\n\nThe code snippet is missing a constant declaration for `q`. The description indicates that `q` is a positive integer constant. In EasyCrypt, we can declare a constant with a specific property (in this case, being greater than 0) using the `const` keyword followed by the property as an axiom or proof.\n\nGiven the context and the requirement to fill in `____(CONST_1)____` and `____(CONST_0)____`, it appears that we are defining a constant `q` with a certain property.\n\nLet's directly infer from the given code and standard practices in EasyCrypt:\n- `____(CONST_1)____` is likely `q`, as it's related to the constant being defined.\n- `____(CONST_0)____` should be the type of `q`, which is `int`.\n\nThus, we need to complete the code by specifying that `q` is an integer constant greater than 0.\n\nHere's the completed code between"]], "EC-1/PRG.ec": [[true, "(* -------------------------------------------------------------------- *)\n\nrequire import AllCore List Int IntDiv CoreMap FMap.\n\nrequire (*--*/ PRG_PRF_Common PRG_PRF_Def PRG_PRF_Resample PRG_PRF_PRG PRG_PRF_Psample PRG_PRF_Plog PRG_PRF_PrgI PRG_PRF_Exp' PRG_PRF_Exp (*--*).*)import AllCore List Int IntDiv CoreMap FMap.\n\n(*--*)import PRG_PRF_Common PRG_PRF_Def PRG_PRF_Resample PRG_PRF_PRG PRG_PRF_Psample PRG_PRF_Plog PRG_PRF_PrgI PRG_PRF_Exp' PRG_PRF_Exp.(*--*)\n\n(* -------------------------------------------------------------------- *)\n\n(* We now prove that the probability that an adversary distinguishes\n   between the PRG and a perfect PRG is bounded by the probability that\n   the bad event occurs in Exp'. *)\n\nsection.\n  declare module A:Adv {P,F}.\n\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* P_PrgI reduction *)\n  local lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_ : ={glob A, glob F} ==> ={res})=> //.\n  proc.\n  inline Exp(A,F,P(F)).F.init Exp(A,F,PrgI).F.init.\n  inline Exp(A,F,P(F)).P.init Exp(A,F,PrgI).P.init.\n  inline Exp'(A).F.init.\n  swap{1} [6..7] 4; swap{1} 8 4.\n  swap{2} [5..6] 4; swap{2} 7 4.\n  swap{3} [5..6] -1; swap{3} 7 -1.\n  call (_ : ={glob F} ==> ={res}); first by sim.\n  wp; call (_ : ={glob F} ==> ={glob P}); first by sim.\n  (* presampling ~ ideal PRG *)\n  eager (H: Resample.resample(); ~ PrgI.prg();\n    : ={glob P} ==> ={glob P})\n    : (={glob A, glob P, glob F})=> //;\n    first by sim.\n  eager proc H (={glob P, glob F})=> //.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob F, glob P}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob P} ==> ={glob P})\n    : (={glob A, glob P, glob F})=> //;\n    first by sim.\n  eager proc H (={glob P, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n    by auto=> /> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x:seed): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r;\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r;\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0;\n    cP <- 0;\n    b <@ A.a();\n    return b;\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f.\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg.\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n     islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a.\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}.\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r).\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)).\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section.", "```ec\n(* -------------------------------------------------------------------- *)\n\nrequire import AllCore List Int IntDiv CoreMap FMap.\n\nrequire (*--*/ PRG_PRF_Common PRG_PRF_Def PRG_PRF_Resample PRG_PRF_PRG PRG_PRF_Psample PRG_PRF_Plog PRG_PRF_PrgI PRG_PRF_Exp' PRG_PRF_Exp (*--*).*)import AllCore List Int IntDiv CoreMap FMap.\n\n(*--*)import PRG_PRF_Common PRG_PRF_Def PRG_PRF_Resample PRG_PRF_PRG PRG_PRF_Psample PRG_PRF_Plog PRG_PRF_PrgI PRG_PRF_Exp' PRG_PRF_Exp.(*--*)\n\n(* -------------------------------------------------------------------- *)\n\n(* We now prove that the probability that an adversary distinguishes\n   between the PRG and a perfect PRG is bounded by the probability that\n   the bad event occurs in Exp'. *)\n\nsection.\n  declare module A:Adv {P,F}.\n\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* P_PrgI reduction *)\n  local lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_ : ={glob A, glob F} ==> ={res})=> //.\n  proc.\n  inline Exp(A,F,P(F)).F.init Exp(A,F,PrgI).F.init.\n  inline Exp(A,F,P(F)).P.init Exp(A,F,PrgI).P.init.\n  inline Exp'(A).F.init.\n  swap{1} [6..7] 4; swap{1} 8 4.\n  swap{2} [5..6] 4; swap{2} 7 4.\n  swap{3} [5..6] -1; swap{3} 7 -1.\n  call (_ : ={glob F} ==> ={res}); first by sim.\n  wp; call (_ : ={glob F} ==> ={glob P}); first by sim.\n  (* presampling ~ ideal PRG *)\n  eager (H: Resample.resample(); ~ PrgI.prg();\n    : ={glob P} ==> ={glob P})\n    : (={glob A, glob P, glob F})=> //;\n    first by sim.\n  eager proc H (={glob P, glob F})=> //.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob F, glob P}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob P} ==> ={glob P})\n    : (={glob A, glob P, glob F})=> //;\n    first by sim.\n  eager proc H (={glob P, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n    by auto=> /> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x:seed): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r;\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r;\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0;\n    cP <- 0;\n    b <@ A.a();\n    return b;\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f.\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg.\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n     islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a.\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}.\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r).\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)).\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section.\n```"]], "EC-1/PrIntervalToSum.ec": [[false, "```houzhui\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, iat.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare module A <: RunMain.\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr"]], "EC-1/ProtocolAPI.ec": [[true, "(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol library we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = [\n    | Res_declass of value_t\n    | Res_in of value_t\n    | Res_out of bool\n    | Res_sop of value_t\n  ].\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op apiRes = apiRes.\n\nend ProtocolAPI.", "To solve the given problem, we first need to analyze the provided incomplete EasyCrypt code and its description to identify the missing parts.\n\nThe incomplete code is given as:```houzhui\n(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol library we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = ____(TYPE_0)____.\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op ____(OP_0)____ = apiRes.\n\nend ProtocolAPI.```\n\nFrom the description, we understand that the API handles different types of protocol instances and maintains confidentiality by storing sensitive data as secret variables (`svar_t`). The API interactions are facilitated through an interaction buffer (`apiCallRes`) that can hold either an API call (`apiCall_data`) or an API response (`apiRes_data`).\n\nThe task is to fill in the missing parts indicated by `____(TYPE_0)____` and `____(OP_0)____`.\n\n1. **Filling `____(TYPE_0)____`**: The type `apiRes_data` represents the API response data. According to the description, the API can generate responses for declassification and I/O operations. Thus, `apiRes_data` should be a variant type that can represent different types of responses. A logical definition could be:\n   ```easycrypt\ntype apiRes_data = [\n  | Res_declass of value_t\n  | Res_in of value_t\n  | Res_out of bool\n  | Res_sop of value_t\n].\n```\n   This definition covers responses for declassification (`Res_declass`), input operations (`Res_in`), output operations (`Res_out`), and secure operation protocols (`Res_sop`).\n\n2. **Filling `____(OP_0)____`**: The operation `apiRes` is already defined and extracts an API response from the interaction buffer. In the `clone import API` statement, we need to map the `apiRes` operation. Thus, `____(OP_0)____` should be `apiRes`.\n\nPutting it all together, the completed code will be:\n```easycrypt\n(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol library we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = [\n    | Res_declass of value_t\n    | Res_in of value_t\n    | Res_out of bool\n    | Res_sop of value_t\n  ].\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op apiRes = apiRes.\n\nend ProtocolAPI.\n```\nThe final answer is:\n```ec\n(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol library we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = [\n    | Res_declass of value_t\n    | Res_in of value_t\n    | Res_out of bool\n    | Res_sop of value_t\n  ].\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op apiRes = apiRes.\n\nend ProtocolAPI.\n```"]], "EC-1/PseudoRandFun.ec": [[true, "(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\n\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\nop F : key -> text -> text.  (* PRF *)\n\n(* end of theory parameters *)\n\n(* module type of random functions *)\n\nmodule type RF = {\n  (* initialization *)\n  proc init() : unit\n\n  (* application to a text *)\n  proc f(x : text) : text\n}.\n\n(* random function implementation using PRF *)\n\nmodule PRF : RF = {\n  var key : key\n\n  proc init() : unit = {\n    key <$ dkey;\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    y <- F key x;\n    return y;\n  }\n}.\n\n(* random function implemention using true randomness *)\n\nmodule TRF : RF = {\n  (* mp is a finite map associating texts with texts *)\n  var mp : (text, text) fmap\n\n  proc init() : unit = {\n    mp <- empty;  (* empty map *)\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    if (! x \\in mp) {   (* give x a random value in *)\n      y <$ dtext;  (* mp if not already in mp's domain *)\n      mp.[x] <- y;\n    }\n    return oget mp.[x];\n  }\n}.\n\n(* module type of random function adversaries, parameterized\n   by random function RF\n\n   adversary may only call RF.f (it can't initialize the random\n   function) *)\n\nmodule type RFA (RF : RF) = {\n  proc main() : bool {RF.f}\n}.\n\n(* random function game:\n\n   `|Pr[GRF(PRF, RFA).main() @ &m : res] -\n     Pr[GRF(TRF, RFA).main() @ &m : res]|\n\n   may be negligible, if F is \"good\", RFA is limited and RFA can't\n   read/write the global variables of PRF/TRF *)\n\nmodule GRF (RF : RF, RFA : RFA) = {\n  module A = RFA(RF)\n\n  proc main() : bool = {\n    var b : bool;\n    RF.init();\n    b <@ A.main();\n    return b;\n  }\n}.\n\n(* To prove the PRF security, one would need to show that the advantage \n   of any adversary in distinguishing PRF from TRF is negligible *)\n\nsection.\n\n  declare module A <: RFA {PRF, TRF}.\n\n  local module GPRF = GRF(PRF, A).\n  local module GTRF = GRF(TRF, A).\n\n  local lemma prf_trf &m : \n    Pr[GPRF.main() @ &m : res] - Pr[GTRF.main() @ &m : res] = \n    ____()___.\n  \n  proof.\n    ____()___.\n  qed.\n\nend section.", "To complete the given EasyCrypt file based on the provided description, we need to fill in the missing parts while ensuring the code compiles successfully with EasyCrypt.\n\nThe missing part seems to be related to the definition of the security notion for PRFs, which involves proving that a PRF is computationally indistinguishable from a truly random function.\n\nHere's how you might fill in the `____()___` parts or complete the file based on the context given:\n\n```ec\n(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\n\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\nop F : key -> text -> text.  (* PRF *)\n\n(* end of theory parameters *)\n\n(* module type of random functions *)\n\nmodule type RF = {\n  (* initialization *)\n  proc init() : unit\n\n  (* application to a text *)\n  proc f(x : text) : text\n}.\n\n(* random function implementation using PRF *)\n\nmodule PRF : RF = {\n  var key : key\n\n  proc init() : unit = {\n    key <$ dkey;\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    y <- F key x;\n    return y;\n  }\n}.\n\n(* random function implemention using true randomness *)\n\nmodule TRF : RF = {\n  (* mp is a finite map associating texts with texts *)\n  var mp : (text, text) fmap\n\n  proc init() : unit = {\n    mp <- empty;  (* empty map *)\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    if (! x \\in mp) {   (* give x a random value in *)\n      y <$ dtext;  (* mp if not already in mp's domain *)\n      mp.[x] <- y;\n    }\n    return oget mp.[x];\n  }\n}.\n\n(* module type of random function adversaries, parameterized\n   by random function RF\n\n   adversary may only call RF.f (it can't initialize the random\n   function) *)\n\nmodule type RFA (RF : RF) = {\n  proc main() : bool {RF.f}\n}.\n\n(* random function game:\n\n   `|Pr[GRF(PRF, RFA).main() @ &m : res] -\n     Pr[GRF(TRF, RFA).main() @ &m : res]|\n\n   may be negligible, if F is \"good\", RFA is limited and RFA can't\n   read/write the global variables of PRF/TRF *)\n\nmodule GRF (RF : RF, RFA : RFA) = {\n  module A = RFA(RF)\n\n  proc main() : bool = {\n    var b : bool;\n    RF.init();\n    b <@ A.main();\n    return b;\n  }\n}.\n\n(* To prove the PRF security, one would need to show that the advantage \n   of any adversary in distinguishing PRF from TRF is negligible *)\n\nsection.\n\n  declare module A <: RFA {PRF, TRF}.\n\n  local module GPRF = GRF(PRF, A).\n  local module GTRF = GRF(TRF, A).\n\n  local lemma prf_trf &m : \n    Pr[GPRF.main() @ &m : res] - Pr[GTRF.main() @ &m : res] = \n    ____()___.\n  \n  proof.\n    ____()___.\n  qed.\n\nend section.\n\n```\n\nTo complete the `____()___` parts, you'd typically be filling in the security proof or the advantage calculation directly. For instance, the advantage of the adversary in distinguishing between `PRF` and `TRF` could be defined and bounded.\n\nHere is a completed version between ```ec and ```.\n\n```ec\n(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\n\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\nop F : key -> text -> text.  (* PRF *)\n\n(* end of theory parameters *)\n\n(* module type of random functions *)\n\nmodule type RF = {\n  (* initialization *)\n  proc init() : unit\n\n  (* application to a text *)\n  proc f(x : text) : text\n}.\n\n(* random function implementation using PRF *)\n\nmodule PRF : RF = {\n  var key : key\n\n  proc init() : unit = {\n    key <$ dkey;\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    y <- F key x;\n    return y;\n  }\n}.\n\n(* random function implemention using true randomness *)\n\nmodule TRF : RF = {\n  (* mp is a finite map associating texts with texts *)\n  var mp : (text, text) fmap\n\n  proc init() : unit = {\n    mp <- empty;  (* empty map *)\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    if (! x \\in mp) {   (* give x a random value in *)\n      y <$ dtext;  (* mp if not already in mp's domain *)\n      mp.[x] <- y;\n    }\n    return oget mp.[x];\n  }\n}.\n\n(* module type of random function adversaries, parameterized\n   by random function RF\n\n   adversary may only call RF.f (it can't initialize the random\n   function) *)\n\nmodule type RFA (RF : RF) = {\n  proc main() : bool {RF.f}\n}.\n\n(* random function game:\n\n   `|Pr[GRF(PRF, RFA).main() @ &m : res] -\n     Pr[GRF(TRF, RFA).main() @ &m : res]|\n\n   may be negligible, if F is \"good\", RFA is limited and RFA can't\n   read/write the global variables of PRF/TRF *)\n\nmodule GRF (RF : RF, RFA : RFA) = {\n  module A = RFA(RF)\n\n  proc main() : bool = {\n    var b : bool;\n    RF.init();\n    b <@ A.main();\n    return b;\n  }\n}.\n\nsection.\n\n  declare module A <: RFA {PRF, TRF}.\n\n  local module GPRF = GRF(PRF, A).\n  local module GTRF = GRF(TRF, A).\n\n  local lemma prf_trf &m : \n    Pr[GPRF.main() @ &m : res] - Pr[GTRF.main() @ &m : res] = \n    `|Pr[GPRF.main() @ &m : res] - Pr[GTRF.main() @ &m : res]|`.\n  \n  proof.\n    by rewrite abs_diff_eq.\n  qed.\n\nend section.\n```"]], "EC-1/RewMultRule.ec": [[true, "require import AllCore Distr List FMap.\nrequire (*--not verified--*) PKE_PRF.\n\n(* Types for the protocol *)\ntype ex1at.\ntype ex2at.\ntype ex1rt.\ntype ex2rt.\n\n(* Module type for rewindable execution *)\nmodule type RewEx1Ex2 = {\n  proc getState() : sbits\n  proc setState(b: sbits) : unit\n  proc ex1(x1: ex1at) : ex1rt\n  proc ex2(x2: ex2at) : ex2rt\n}.\n\n(* Module for GetExec1Set *)\nmodule GetExec1Set(A : RewEx1Ex2) = {\n  proc main(x1: ex1at) : ex1rt = {\n    var s;\n    s <@ A.getState();\n    var r <@ A.ex1(x1);\n    A.setState(s);\n    return r;\n  }\n}.\n\n(* Module for GetExec1SetExec2Conj *)\nmodule GetExec1SetExec2Conj(A : RewEx1Ex2) = {\n  proc main(x1: ex1at, x2: ex2at) : ex1rt * ex2rt = {\n    var s;\n    s <@ A.getState();\n    var r1 <@ A.ex1(x1);\n    A.setState(s);\n    var r2 <@ A.ex2(x2);\n    return (r1, r2);\n  }\n}.\n\n(* Module for MultTriv *)\nmodule MultTriv(P: PKE_PRF.Prf, Q: PKE_PRF.Prf) = {\n  proc main(x: P.in_t * Q.in_t) : P.out_t * Q.out_t = {\n    var r1, r2;\n    r1 <@ P.run(x.`1);\n    r2 <@ Q.run(x.`2);\n    return (r1, r2);\n  }\n}.\n\n(* Proof section *)\nsection.\n  declare module P <: PKE_PRF.Prf.\n  declare module Q <: PKE_PRF.Prf.\n\n  (* Proof that MultTriv preserves probabilities *)\n  lemma Mult_law &m M1 M2 i1 i2:\n    Pr[ MultTriv(P, Q).main((i1, i2)) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ P.run(i1) @ &m : M1 res ] * Pr[ Q.run(i2) @ &m : M2 res ].\n  proof.\n    byphoare (_: arg = (i1, i2) ==> _).\n    proc.\n    seq 1 : (M1 r1) (Pr[P.run(i1) @ &m : M1 res]) (Pr[Q.run(i2) @ &m : M2 res]) (Pr[P.run(i1) @ &m : M1 res]) 0%r _.\n    wp; call (_: true); wp; call (_: true); wp; skip; progress.\n    conseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2); smt().\n    have ph1 : forall &n x, phoare[P.run : z = x /\\ (glob P) = (glob P){n} ==> M1 res] = Pr[P.run(x) @ &n : M1 res].\n    progress; bypr; progress; byequiv; proc*; call (_: true); skip; auto; auto; auto.\n    call (ph1 &m i1); skip; progress.\n    conseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2); smt().\n    have ph2 : forall &n x, phoare[Q.run : z = x /\\ (glob Q) = (glob Q){n} ==> M2 res] = Pr[Q.run(x) @ &n : M2 res].\n    progress; bypr; progress; byequiv; proc*; call (_: true); skip; progress; auto; auto.\n    rewrite /q; call (ph2 &m i2); skip; progress.\n    hoare; call (_: true); skip; smt(); smt(); smt(); auto.\n  qed.\n\n  section.\n    declare module A <: RewEx1Ex2.\n\n    (* Axiom for rewindable A *)\n    declare axiom RewProp :\n      exists (f : glob A -> sbits),\n      injective f /\\\n      (forall &m, Pr[A.getState() @ &m : (glob A) = (glob A){m} /\\ res = f((glob A){m})] = 1%r) /\\\n      (forall &m b (x: glob A), b = f(x) => Pr[A.setState(b) @ &m : glob A = x] = 1%r) /\\\n      islossless A.setState.\n\n    (* Lemmas for rewindable execution *)\n    local lemma ex1ex2_1 M1 x1 : forall (ga : glob A), forall (p : real),\n      phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res /\\ (glob A) = ga] = p.\n    proof.\n      move => ga p ph; proc; elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll.\n      seq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga); call (_: true); call (s2h ga); skip; by progress.\n      call ph; call (s2 ga); skip; auto; call (s3 ga); skip; auto; hoare; call (_: true); skip; progress; smt(); auto.\n    qed.\n\n    local lemma ex1ex2_2 M1 x1 : forall (ga : glob A), forall (p : real),\n      phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res] = p.\n    proof.\n      move => ga p ph; proc; elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll.\n      seq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga); call (_: true); call (s2h ga); skip; by progress.\n      call ph; call (s2 ga); skip; auto; call (s3 ga); skip; auto; hoare; call (_: true); skip; progress; smt().\n    qed.\n\n    lemma rew_clean &m M1 i1 :\n      Pr[GetExec1Set(A).main(i1) @ &m : M1 res /\\ (glob A) = (glob A){m}] = Pr[A.ex1(i1) @ &m : M1 res].\n    proof.\n      move => &m M1 x1; have ph1 : forall &n x1, phoare[A.ex1 : arg = x1 /\\ (glob A) = (glob A){n} ==> M1 res] = Pr[A.ex1(x1) @ &n : M1 res].\n      progress; bypr; progress; byequiv; proc*; call (_: true); skip; progress; auto; auto.\n      have ph2 : forall &n i1, phoare[GetExec1Set(A).main : arg = i1 /\\ (glob A) = (glob A){n} ==> M1 res /\\ (glob A) = (glob A){n}] = Pr[A.ex1(i1) @ &n : M1 res].\n      progress; proc*; call (ex1ex2_1 M1 i1 (glob A){n} (Pr[A.ex1(i1) @ &n : M1 res])); apply ph1; skip; progress.\n      byphoare (_: arg = x1 /\\ (glob A) = (glob A){m} ==> _); proc*; call (ph2 &m x1); skip; auto; auto; auto.\n    qed.\n\n    local lemma ex1ex2_3 &m M1 M2 a1 a2 : forall (ga : glob A), forall (p q : real), (glob A){m} = ga =>\n      phoare[A.ex1 : arg = a1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[A.ex2 : arg = a2 /\\ (glob A) = ga ==> M2 res] = q =>\n      Pr[GetExec1SetExec2Conj(A).main(a1, a2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => ga p q se ph hp; byphoare (_: arg.`1 = a1 /\\ arg.`2 = a2 /\\ (glob A) = ga ==> _).\n      elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll; proc.\n      seq 3 : (M1 r1) p q p (0%r) ((glob A) = ga /\\ x11 = a1 /\\ x22 = a2); inline*; wp; call (s3h ga); call (_: true); call (s2h ga); wp; skip; progress; sp.\n      call (ex1ex2_2 M1 a1 ga p); skip; auto; call hp; skip; progress; auto; hoare; call (_: true); auto; smt(); auto; auto; auto.\n    qed.\n\n    local lemma ex1ex2_main &m M1 M2 x1 x2 (ga: glob A) (p q : real) : (glob A){m} = ga =>\n      (forall &n, (glob A){n} = ga => Pr[A.ex1(x1) @ &n : M1 res] = p) =>\n      (forall &n, (glob A){n} = ga => Pr[A.ex2(x2) @ &n : M2 res] = q) =>\n      Pr[GetExec1SetExec2Conj(A).main(x1, x2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => gae pr1 pr2; have z1 : phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p; bypr; progress; apply (pr1 &m0); auto.\n      have z2 : phoare[A.ex2 : arg = x2 /\\ (glob A) = ga ==> M2 res] = q; bypr; progress; apply (pr2 &m0); auto.\n      apply (ex1ex2_3 &m M1 M2 x1 x2 ga); assumption; conseq z1; apply z2.\n    qed.\n\n    local lemma ex1ex2_main_special &m M1 M2 i1 i2 (p q : real):\n      Pr[A.ex1(i1) @ &m : M1 res] = p =>\n      Pr[A.ex2(i2) @ &m : M2 res] = q =>\n      Pr[GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => Hrun1 Hrun2; apply (ex1ex2_main &m M1 M2 i1 i2 (glob A){m} p q); by reflexivity.\n      have se1 : Pr[A.ex1(i1) @ &m : M1 res] = Pr[A.ex1(i1) @ &m : M1 res]; byequiv (_: (={glob A, x1}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      rewrite -Hrun1; progress; byequiv (_: (={glob A, x1}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      have se1 : Pr[A.ex2(i2) @ &m : M2 res] = Pr[A.ex2(i2) @ &m : M2 res]; byequiv (_: (={glob A, x2}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      rewrite -Hrun2; progress; byequiv (_: (={glob A, x2}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n    qed.\n\n    lemma rew_mult_law &m M1 M2 i1 i2:\n      Pr[GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2] = Pr[A.ex1(i1) @ &m : M1 res] * Pr[A.ex2(i2) @ &m : M2 res].\n    proof.\n      apply (ex1ex2_main_special &m M1 M2); auto; auto.\n    qed.\n  end section.\nend section.", "```ec\nrequire import AllCore Distr List FMap.\nrequire (*--not verified--*) PKE_PRF.\n\n(* Types for the protocol *)\ntype ex1at.\ntype ex2at.\ntype ex1rt.\ntype ex2rt.\n\n(* Module type for rewindable execution *)\nmodule type RewEx1Ex2 = {\n  proc getState() : sbits\n  proc setState(b: sbits) : unit\n  proc ex1(x1: ex1at) : ex1rt\n  proc ex2(x2: ex2at) : ex2rt\n}.\n\n(* Module for GetExec1Set *)\nmodule GetExec1Set(A : RewEx1Ex2) = {\n  proc main(x1: ex1at) : ex1rt = {\n    var s;\n    s <@ A.getState();\n    var r <@ A.ex1(x1);\n    A.setState(s);\n    return r;\n  }\n}.\n\n(* Module for GetExec1SetExec2Conj *)\nmodule GetExec1SetExec2Conj(A : RewEx1Ex2) = {\n  proc main(x1: ex1at, x2: ex2at) : ex1rt * ex2rt = {\n    var s;\n    s <@ A.getState();\n    var r1 <@ A.ex1(x1);\n    A.setState(s);\n    var r2 <@ A.ex2(x2);\n    return (r1, r2);\n  }\n}.\n\n(* Module for MultTriv *)\nmodule MultTriv(P: PKE_PRF.Prf, Q: PKE_PRF.Prf) = {\n  proc main(x: P.in_t * Q.in_t) : P.out_t * Q.out_t = {\n    var r1, r2;\n    r1 <@ P.run(x.`1);\n    r2 <@ Q.run(x.`2);\n    return (r1, r2);\n  }\n}.\n\n(* Proof section *)\nsection.\n  declare module P <: PKE_PRF.Prf.\n  declare module Q <: PKE_PRF.Prf.\n\n  (* Proof that MultTriv preserves probabilities *)\n  lemma Mult_law &m M1 M2 i1 i2:\n    Pr[ MultTriv(P, Q).main((i1, i2)) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ P.run(i1) @ &m : M1 res ] * Pr[ Q.run(i2) @ &m : M2 res ].\n  proof.\n    byphoare (_: arg = (i1, i2) ==> _).\n    proc.\n    seq 1 : (M1 r1) (Pr[P.run(i1) @ &m : M1 res]) (Pr[Q.run(i2) @ &m : M2 res]) (Pr[P.run(i1) @ &m : M1 res]) 0%r _.\n    wp; call (_: true); wp; call (_: true); wp; skip; progress.\n    conseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2); smt().\n    have ph1 : forall &n x, phoare[P.run : z = x /\\ (glob P) = (glob P){n} ==> M1 res] = Pr[P.run(x) @ &n : M1 res].\n    progress; bypr; progress; byequiv; proc*; call (_: true); skip; auto; auto; auto.\n    call (ph1 &m i1); skip; progress.\n    conseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2); smt().\n    have ph2 : forall &n x, phoare[Q.run : z = x /\\ (glob Q) = (glob Q){n} ==> M2 res] = Pr[Q.run(x) @ &n : M2 res].\n    progress; bypr; progress; byequiv; proc*; call (_: true); skip; progress; auto; auto.\n    rewrite /q; call (ph2 &m i2); skip; progress.\n    hoare; call (_: true); skip; smt(); smt(); smt(); auto.\n  qed.\n\n  section.\n    declare module A <: RewEx1Ex2.\n\n    (* Axiom for rewindable A *)\n    declare axiom RewProp :\n      exists (f : glob A -> sbits),\n      injective f /\\\n      (forall &m, Pr[A.getState() @ &m : (glob A) = (glob A){m} /\\ res = f((glob A){m})] = 1%r) /\\\n      (forall &m b (x: glob A), b = f(x) => Pr[A.setState(b) @ &m : glob A = x] = 1%r) /\\\n      islossless A.setState.\n\n    (* Lemmas for rewindable execution *)\n    local lemma ex1ex2_1 M1 x1 : forall (ga : glob A), forall (p : real),\n      phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res /\\ (glob A) = ga] = p.\n    proof.\n      move => ga p ph; proc; elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll.\n      seq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga); call (_: true); call (s2h ga); skip; by progress.\n      call ph; call (s2 ga); skip; auto; call (s3 ga); skip; auto; hoare; call (_: true); skip; progress; smt(); auto.\n    qed.\n\n    local lemma ex1ex2_2 M1 x1 : forall (ga : glob A), forall (p : real),\n      phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res] = p.\n    proof.\n      move => ga p ph; proc; elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll.\n      seq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga); call (_: true); call (s2h ga); skip; by progress.\n      call ph; call (s2 ga); skip; auto; call (s3 ga); skip; auto; hoare; call (_: true); skip; progress; smt().\n    qed.\n\n    lemma rew_clean &m M1 i1 :\n      Pr[GetExec1Set(A).main(i1) @ &m : M1 res /\\ (glob A) = (glob A){m}] = Pr[A.ex1(i1) @ &m : M1 res].\n    proof.\n      move => &m M1 x1; have ph1 : forall &n x1, phoare[A.ex1 : arg = x1 /\\ (glob A) = (glob A){n} ==> M1 res] = Pr[A.ex1(x1) @ &n : M1 res].\n      progress; bypr; progress; byequiv; proc*; call (_: true); skip; progress; auto; auto.\n      have ph2 : forall &n i1, phoare[GetExec1Set(A).main : arg = i1 /\\ (glob A) = (glob A){n} ==> M1 res /\\ (glob A) = (glob A){n}] = Pr[A.ex1(i1) @ &n : M1 res].\n      progress; proc*; call (ex1ex2_1 M1 i1 (glob A){n} (Pr[A.ex1(i1) @ &n : M1 res])); apply ph1; skip; progress.\n      byphoare (_: arg = x1 /\\ (glob A) = (glob A){m} ==> _); proc*; call (ph2 &m x1); skip; auto; auto; auto.\n    qed.\n\n    local lemma ex1ex2_3 &m M1 M2 a1 a2 : forall (ga : glob A), forall (p q : real), (glob A){m} = ga =>\n      phoare[A.ex1 : arg = a1 /\\ (glob A) = ga ==> M1 res] = p =>\n      phoare[A.ex2 : arg = a2 /\\ (glob A) = ga ==> M2 res] = q =>\n      Pr[GetExec1SetExec2Conj(A).main(a1, a2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => ga p q se ph hp; byphoare (_: arg.`1 = a1 /\\ arg.`2 = a2 /\\ (glob A) = ga ==> _).\n      elim (rewindable_A_plus A RewProp); move => fA [s1 [s2 [s2h [s2ll [s3 [s3h]]]]] s3ll; proc.\n      seq 3 : (M1 r1) p q p (0%r) ((glob A) = ga /\\ x11 = a1 /\\ x22 = a2); inline*; wp; call (s3h ga); call (_: true); call (s2h ga); wp; skip; progress; sp.\n      call (ex1ex2_2 M1 a1 ga p); skip; auto; call hp; skip; progress; auto; hoare; call (_: true); auto; smt(); auto; auto; auto.\n    qed.\n\n    local lemma ex1ex2_main &m M1 M2 x1 x2 (ga: glob A) (p q : real) : (glob A){m} = ga =>\n      (forall &n, (glob A){n} = ga => Pr[A.ex1(x1) @ &n : M1 res] = p) =>\n      (forall &n, (glob A){n} = ga => Pr[A.ex2(x2) @ &n : M2 res] = q) =>\n      Pr[GetExec1SetExec2Conj(A).main(x1, x2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => gae pr1 pr2; have z1 : phoare[A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res] = p; bypr; progress; apply (pr1 &m0); auto.\n      have z2 : phoare[A.ex2 : arg = x2 /\\ (glob A) = ga ==> M2 res] = q; bypr; progress; apply (pr2 &m0); auto.\n      apply (ex1ex2_3 &m M1 M2 x1 x2 ga); assumption; conseq z1; apply z2.\n    qed.\n\n    local lemma ex1ex2_main_special &m M1 M2 i1 i2 (p q : real):\n      Pr[A.ex1(i1) @ &m : M1 res] = p =>\n      Pr[A.ex2(i2) @ &m : M2 res] = q =>\n      Pr[GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2] = p * q.\n    proof.\n      move => Hrun1 Hrun2; apply (ex1ex2_main &m M1 M2 i1 i2 (glob A){m} p q); by reflexivity.\n      have se1 : Pr[A.ex1(i1) @ &m : M1 res] = Pr[A.ex1(i1) @ &m : M1 res]; byequiv (_: (={glob A, x1}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      rewrite -Hrun1; progress; byequiv (_: (={glob A, x1}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      have se1 : Pr[A.ex2(i2) @ &m : M2 res] = Pr[A.ex2(i2) @ &m : M2 res]; byequiv (_: (={glob A, x2}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n      rewrite -Hrun2; progress; byequiv (_: (={glob A, x2}) ==> _); proc*; call (_: true); skip; progress; auto; auto.\n    qed.\n\n    lemma rew_mult_law &m M1 M2 i1 i2:\n      Pr[GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2] = Pr[A.ex1(i1) @ &m : M1 res] * Pr[A.ex2(i2) @ &m : M2 res].\n    proof.\n      apply (ex1ex2_main_special &m M1 M2); auto; auto.\n    qed.\n  end section.\nend section.\n```"]], "EC-1/RewSumBindingAux.ec": [[true, "lemma fact2 &m (P <: glob A, glob B ==> rrt -> bool) (LEMMA_1 : is_lossless A.setState) (LEMMA_0 : is_lossless B.init) : \n  Pr[ SB(A,B).main(j) @ &m : P res.`1 /\\ P res.`2 ] \n  = 1%r/4%r * Pr[ SB(A,B).main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_22(j) @ &m : P res.`1 /\\ P res.`2 ].", "```ec\nlemma fact2 &m (P <: glob A, glob B ==> rrt -> bool) (LEMMA_1 : is_lossless A.setState) (LEMMA_0 : is_lossless B.init) : \n  Pr[ SB(A,B).main(j) @ &m : P res.`1 /\\ P res.`2 ] \n  = 1%r/4%r * Pr[ SB(A,B).main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\n```"]], "EC-1/RingCloning.ec": [[true, "(* This theory should make use of theories for groups.\n   It is currently mostly being developed towards getting\n   fixed-length bitstrings formalized as boolean rings,\n   automatically yielding many useful lemmas from a\n   small number of simple core axioms. *)\ntheory Ring.\n  type ring.\n\n  (** Ring addition *)\n  const zero: ring.\n  op ( + ) : ring -> ring -> ring.\n  op [ - ] : ring -> ring.\n\n  axiom addrA (r1 r2 r3 : ring):\n    (r1 + r2) + r3 = r1 + (r2 + r3).\n\n  axiom addrC (r1 r2 : ring):\n    r1 + r2 = r2 + r1.\n\n  axiom add0r (r : ring):\n    zero + r = r.\n\n  axiom addNr (r : ring):\n    r + -r = zero.\n\n  (** Ring multiplication *)\n  const one: ring.\n  op ( * ): ring -> ring -> ring.\n\n  axiom mulrA (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = r1 * (r2 * r3).\n\n  axiom mul1r (r : ring):\n    one * r = r.\n\n  (** Distributivity of addition over multiplication *)\n  axiom mulrDadd (r1 r2 r3 : ring):\n    r1 * (r2 + r3)= (r1 * r2) + (r1 * r3).\n\n  axiom mulDradd (r1 r2 r3 : ring):\n    (r1 + r2) * r3 = (r1 * r3) + (r2 * r3).\nend Ring.\n\ntheory RingT.\n  clone import Ring.\n  abbrev ( - ) (r1 r2 : ring) = r1 + -r2.\n\n  (** Lemmas *)\n  lemma addr0 (r : ring):\n    r + zero = r.\n  proof strict.\n  by rewrite addrC add0r.\n  qed.\n\n  lemma addrN (r : ring):\n    -r + r = zero.\n  proof strict.\n  by rewrite addrC addNr.\n  qed.\n\n  lemma addIr (r r1 r2 : ring):\n    (r1 + r = r2 + r) =>\n    r1 = r2.\n  proof strict.\n  by move=> r1_r2;\n     rewrite -addr0 -(addr0 r2) -(addNr r) -2!addrA -r1_r2.\n  qed.\n\n  lemma addrI (r r1 r2 : ring):\n    (r + r1 = r + r2) =>\n    r1 = r2.\n  proof strict.\n  by rewrite 2!(addrC r)=> r1_r2; rewrite (addIr r r1 r2).\n  qed.\nend RingT.\n\ntheory CRing.\n  clone import Ring.\n\n  axiom mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\nend CRing.\n\ntheory CRingT.\n  clone        Ring.\n  clone        CRing with\n    theory Ring <- Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n\n  import Ring.\n  import CRing.\n  import RingT.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite mulrC.\n  qed.\n\n  lemma mulrCA (r1 r2 r3 : ring):\n    r1 * (r2 * r3) = r2 * (r1 * r3).\n  proof strict.\n  by rewrite -2!mulrA (mulrC r1).\n  qed.\n\n  lemma mulrAC (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = (r1 * r3) * r2.\n  proof strict.\n  by rewrite 2!mulrA (mulrC r2).\n  qed.\n\n  lemma mulrACA (r1 r2 r3 r4 : ring):\n    (r1 * r2) * (r3 * r4) = (r1 * r3) * (r2 * r4).\n  proof strict.\n  by rewrite mulrA (mulrCA r2) -mulrA.\n  qed.\nend CRingT.\n\ntheory BRing.\n  clone import Ring.\n\n  axiom mulrK (r : ring):\n    r * r = r.\nend BRing.\n\ntheory BRingT.\n  clone        Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n  clone        BRing with\n    theory Ring <- Ring.\n\n  import Ring.\n  import RingT.\n  import BRing.\n\n  lemma neg_is_id (r : ring):\n    r + r = zero.\n  proof strict.\n  by rewrite -(addIr (r + r) (r + r) zero) //\n             (add0r (r + r)) -(mulrK r) -{1 2}mulrDadd -mulDradd 2!mulrK.\n  qed.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite -(addIr (r2 * r1) (r1 * r2) (r2 * r1)) // (neg_is_id (r2 * r1))\n             -(addIr r2 (r1 * r2 + r2 * r1) zero) // (add0r r2) addrA\n             -{4}(addrI r1 (r1 * r2 + (r2 * r1 + r2)) r2) // -addrA\n             -{1}(mulrK r1) -{3}(mulrK r2) -2!mulrDadd -mulDradd mulrK.\n  qed.\nend BRingT.\n\n\n(*\n(* Example: Ring structures on bool *)\ntheory BoolRing.\nrequire import Bool.\nop id (b:bool) = b.\nclone Ring as RBool with\n  type ring = bool,\n  op zero = false,\n  op ( + ) = (^^),\n  op [ - ] = id,\n  op one = true,\n  op ( * ) = (/\\)\n  proof * by (delta; smt).\n\nclone BRing as BRBool with\n  theory Ring = RBool\n  proof * by (move=> r; delta; smt).\n\nclone BRingT as BRBoolT with\n  theory Ring = RBool.\n\nprint theory BRBoolT.\n*)", "```ec\n(* This theory should make use of theories for groups.\n   It is currently mostly being developed towards getting\n   fixed-length bitstrings formalized as boolean rings,\n   automatically yielding many useful lemmas from a\n   small number of simple core axioms. *)\ntheory Ring.\n  type ring.\n\n  (** Ring addition *)\n  const zero: ring.\n  op ( + ) : ring -> ring -> ring.\n  op [ - ] : ring -> ring.\n\n  axiom addrA (r1 r2 r3 : ring):\n    (r1 + r2) + r3 = r1 + (r2 + r3).\n\n  axiom addrC (r1 r2 : ring):\n    r1 + r2 = r2 + r1.\n\n  axiom add0r (r : ring):\n    zero + r = r.\n\n  axiom addNr (r : ring):\n    r + -r = zero.\n\n  (** Ring multiplication *)\n  const one: ring.\n  op ( * ): ring -> ring -> ring.\n\n  axiom mulrA (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = r1 * (r2 * r3).\n\n  axiom mul1r (r : ring):\n    one * r = r.\n\n  (** Distributivity of addition over multiplication *)\n  axiom mulrDadd (r1 r2 r3 : ring):\n    r1 * (r2 + r3)= (r1 * r2) + (r1 * r3).\n\n  axiom mulDradd (r1 r2 r3 : ring):\n    (r1 + r2) * r3 = (r1 * r3) + (r2 * r3).\nend Ring.\n\ntheory RingT.\n  clone import Ring.\n  abbrev ( - ) (r1 r2 : ring) = r1 + -r2.\n\n  (** Lemmas *)\n  lemma addr0 (r : ring):\n    r + zero = r.\n  proof strict.\n  by rewrite addrC add0r.\n  qed.\n\n  lemma addrN (r : ring):\n    -r + r = zero.\n  proof strict.\n  by rewrite addrC addNr.\n  qed.\n\n  lemma addIr (r r1 r2 : ring):\n    (r1 + r = r2 + r) =>\n    r1 = r2.\n  proof strict.\n  by move=> r1_r2;\n     rewrite -addr0 -(addr0 r2) -(addNr r) -2!addrA -r1_r2.\n  qed.\n\n  lemma addrI (r r1 r2 : ring):\n    (r + r1 = r + r2) =>\n    r1 = r2.\n  proof strict.\n  by rewrite 2!(addrC r)=> r1_r2; rewrite (addIr r r1 r2).\n  qed.\nend RingT.\n\ntheory CRing.\n  clone import Ring.\n\n  axiom mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\nend CRing.\n\ntheory CRingT.\n  clone        Ring.\n  clone        CRing with\n    theory Ring <- Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n\n  import Ring.\n  import CRing.\n  import RingT.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite mulrC.\n  qed.\n\n  lemma mulrCA (r1 r2 r3 : ring):\n    r1 * (r2 * r3) = r2 * (r1 * r3).\n  proof strict.\n  by rewrite -2!mulrA (mulrC r1).\n  qed.\n\n  lemma mulrAC (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = (r1 * r3) * r2.\n  proof strict.\n  by rewrite 2!mulrA (mulrC r2).\n  qed.\n\n  lemma mulrACA (r1 r2 r3 r4 : ring):\n    (r1 * r2) * (r3 * r4) = (r1 * r3) * (r2 * r4).\n  proof strict.\n  by rewrite mulrA (mulrCA r2) -mulrA.\n  qed.\nend CRingT.\n\ntheory BRing.\n  clone import Ring.\n\n  axiom mulrK (r : ring):\n    r * r = r.\nend BRing.\n\ntheory BRingT.\n  clone        Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n  clone        BRing with\n    theory Ring <- Ring.\n\n  import Ring.\n  import RingT.\n  import BRing.\n\n  lemma neg_is_id (r : ring):\n    r + r = zero.\n  proof strict.\n  by rewrite -(addIr (r + r) (r + r) zero) //\n             (add0r (r + r)) -(mulrK r) -{1 2}mulrDadd -mulDradd 2!mulrK.\n  qed.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite -(addIr (r2 * r1) (r1 * r2) (r2 * r1)) // (neg_is_id (r2 * r1))\n             -(addIr r2 (r1 * r2 + r2 * r1) zero) // (add0r r2) addrA\n             -{4}(addrI r1 (r1 * r2 + (r2 * r1 + r2)) r2) // -addrA\n             -{1}(mulrK r1) -{3}(mulrK r2) -2!mulrDadd -mulDradd mulrK.\n  qed.\nend BRingT.\n\n\n(*\n(* Example: Ring structures on bool *)\ntheory BoolRing.\nrequire import Bool.\nop id (b:bool) = b.\nclone Ring as RBool with\n  type ring = bool,\n  op zero = false,\n  op ( + ) = (^^),\n  op [ - ] = id,\n  op one = true,\n  op ( * ) = (/\\)\n  proof * by (delta; smt).\n\nclone BRing as BRBool with\n  theory Ring = RBool\n  proof * by (move=> r; delta; smt).\n\nclone BRingT as BRBoolT with\n  theory Ring = RBool.\n\nprint theory BRBoolT.\n*)\n```"]], "EC-1/SchnorrPK.ec": [[true, "(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type challenge    = F.t.\n  type response     = F.t.\n\n  op R_DL h w       = (h = g^w).\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type SP.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge <- challenge,\n  type SigmaProtocol.response  <- response,\n  op   SP.R         = R_DL,\n  op   SigmaProtocol.de        = FDistr.dt.\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;\n    if (w = F.zero) { (* A loop would be better, however the support for while loops is poor *)\n      w <- -F.one;\n    }\n    h <- g^w;\n    return (h, w);\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;\n    a <- g^r;\n    return (a, r);\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;\n    return e;\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;\n    r <- snd ms;\n    z <- r + e*w;\n    return z;\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);\n    v' <- g^z;\n    return (v = v');\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));\n    v' <- (g^z' = a*(h^e'));\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');\n      sto <- Some(w);\n    } else {\n      sto <- None;\n    }\n\n    return sto;\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;\n    a  <- (g^z) * (h^(-e));\n\n    return (a, e, z);\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.\n  proof. by islossless; apply FDistr.dt_ll. qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n  (*  move : FDistr.dt_ll FDistr.dt_fu FDistr.dt1E; rewrite /is_full => dt_ll dt_fu dt_supp. *)\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk.", "```ec\n(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type challenge    = F.t.\n  type response     = F.t.\n\n  op R_DL h w       = (h = g^w).\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type SP.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge <- challenge,\n  type SigmaProtocol.response  <- response,\n  op   SP.R         = R_DL,\n  op   SigmaProtocol.de        = FDistr.dt.\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;\n    if (w = F.zero) { (* A loop would be better, however the support for while loops is poor *)\n      w <- -F.one;\n    }\n    h <- g^w;\n    return (h, w);\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;\n    a <- g^r;\n    return (a, r);\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;\n    return e;\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;\n    r <- snd ms;\n    z <- r + e*w;\n    return z;\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);\n    v' <- g^z;\n    return (v = v');\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));\n    v' <- (g^z' = a*(h^e'));\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');\n      sto <- Some(w);\n    } else {\n      sto <- None;\n    }\n\n    return sto;\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;\n    a  <- (g^z) * (h^(-e));\n\n    return (a, e, z);\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.\n  proof. by islossless; apply FDistr.dt_ll. qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n  (*  move : FDistr.dt_ll FDistr.dt_fu FDistr.dt1E; rewrite /is_full => dt_ll dt_fu dt_supp. *)\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk.\n```"]], "EC-1/AProtocolLibrary.ec": [[true, "(* Abstract class for protocol libraries *)\nrequire import AllCore List.\n\n(**\n  An abstract protocol library provides a set of secure\n  protocols that can be used to compute operations over\n  confidential data.\n\n  The library discloses protocols for secret operators,\n  input, output and a special declassification command that\n  reveals secret values. The last three protocols are concrete,\n  whereas the secret operators are left underspecified as it\n  is a general enough interface for protocols for secret operations.\n\n  Besides dealing with secret inputs, protocols also tolerate plain\n  values, that are assumed to be publicly known to all parties, as inputs.\n  Protocols leave a communication trace resulting from party interaction.\n\n  The library also provides a set of simulators that are\n  part of the security assumpiton made over the multiparty\n  protocols: the protocol is secure if there exists a simulator\n  that is able to reproduce the communication trace and output\n  shares of the corrupt parties.\n*)\ntheory ProtocolLibrary.\n\n  (** Number of parties involved in the protocol *)\n  op n : int.\n\n  (** Type of party identifiers *)\n  type partyId_t. \n\n  (** Raw values *)\n  type value_t.\n  (** Secret inputs *)\n  type inputs_t.\n  (** Secret outputs *)\n  type outputs_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: partyId_t list, sargs: value_t list) : value_t * leakage_t.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t * sideInfo_t) distr.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(a: inputs_t, l: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(x: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(x: inputs_t, y: leakage_t): trace_t distr.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\nend ProtocolLibrary.", "```ec\n(* Abstract class for protocol libraries *)\nrequire import AllCore List.\n\n(**\n  An abstract protocol library provides a set of secure\n  protocols that can be used to compute operations over\n  confidential data.\n\n  The library discloses protocols for secret operators,\n  input, output and a special declassification command that\n  reveals secret values. The last three protocols are concrete,\n  whereas the secret operators are left underspecified as it\n  is a general enough interface for protocols for secret operations.\n\n  Besides dealing with secret inputs, protocols also tolerate plain\n  values, that are assumed to be publicly known to all parties, as inputs.\n  Protocols leave a communication trace resulting from party interaction.\n\n  The library also provides a set of simulators that are\n  part of the security assumpiton made over the multiparty\n  protocols: the protocol is secure if there exists a simulator\n  that is able to reproduce the communication trace and output\n  shares of the corrupt parties.\n*)\ntheory ProtocolLibrary.\n\n  (** Number of parties involved in the protocol *)\n  op n : int.\n\n  (** Type of party identifiers *)\n  type partyId_t. \n\n  (** Raw values *)\n  type value_t.\n  (** Secret inputs *)\n  type inputs_t.\n  (** Secret outputs *)\n  type outputs_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: partyId_t list, sargs: value_t list) : value_t * leakage_t.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t * sideInfo_t) distr.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(a: inputs_t, l: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(x: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(x: inputs_t, y: leakage_t): trace_t distr.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\nend ProtocolLibrary.\n```"]], "EC-1/SHA.ec": [[true, "require import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 m2: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 e0 f0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 a0 b0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2].", "To complete the given incomplete EasyCrypt file based on the provided description, we need to analyze the given code and identify the missing parts.\n\nThe incomplete code is given as:\n```easycrypt\nrequire import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: ____(OP_1)____.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 ____(OP_0)____: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 e0 f0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 a0 b0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2].\n```\n\nFrom the description provided, we can identify that the missing parts are related to the types of the variables in the function definitions.\n\n1. For `maj (a b c: ____(OP_1)____.t) : W32.t`, the type should be `W32.t` since `a`, `b`, and `c` are being operated on with `&` and `+^` which are defined for `W32.t`. So, `____(OP_1)____` should be `W32`.\n\n2. For `msg1 (m1 ____(OP_0)____: W128.t) : W128.t`, the second argument `m2` is used with `\\bits32 0`, indicating it's of type `W128.t` as well. So, `____(OP_0)____` should be `m2`.\n\nThus, the corrected code should look like this:\n\n```easycrypt\nrequire import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 m2: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 f0 g0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 b0 c0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2].\n```\n\nThe completed file in EasyCrypt is:\n```ec\nrequire import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 m2: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 e0 f0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 a0 b0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2].\n```"]], "EC-1/SimpleCondProb.ec": [[true, "require import AllCore Distr List.\nrequire import Finite.\nrequire (*--*) StdBigop.\n(*---*) import StdBigop.Bigreal.BRA.\n\n\nabstract theory Generic.\n\ntype in_t.\ntype out_t.\ntype aux_t.\n\nop din : in_t distr.\n\nmodule type Provided = {\n  proc main(x : in_t, aux : aux_t) : out_t\n}.\n\nmodule Sampler (P : Provided) = {\n  var x : in_t\n  \n  proc main(aux : aux_t) : out_t = {\n    var y : out_t;\n    \n    x <$ din;\n    y <@ P.main(x, aux);\n    \n    return y;\n  }\n}.\n\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare op prop : aux_t -> in_t -> glob P -> out_t -> bool.\n\nlemma EqPr_SamplerConj_ProvidedCond &m (a : aux_t) (v : in_t) :\n  Pr[Sampler(P).main(a) @ &m : Sampler.x = v /\\ prop a (Sampler.x) (glob P) res] \n  = \n  (mu1 din v) *  Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproof.\nbyphoare (: glob P = (glob P){m} /\\ arg = a ==> _ ) => //.\npose prPCond := Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproc.\nseq 1 : (Sampler.x = v) (mu1 din v) prPCond _ 0%r (glob P = (glob P){m} /\\ aux = a) => //; 1,2: by rnd.\n+ call (: glob P = (glob P){m} /\\ arg = (v, a) ==> prop a v (glob P) res) => //.\n  rewrite /prPCond; bypr=> /> &m' eqGl ->.\n  by byequiv => //; proc true.\nby hoare; call(: true); skip => />. \nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_FinBig &m (a : aux_t) :\n  is_finite (support din) \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     big predT (fun (v : in_t) => (mu1 din v) * Pr[P.main(v, a) @ &m : prop a v (glob P) res]) \n               (to_seq (support din)).\nproof.\nmove=> finsup; rewrite Pr[mu_split (Sampler.x \\in to_seq (support din))].\nhave -> /=:\n  Pr[Sampler(P).main(a) @ &m : prop a Sampler.x (glob P) res /\\ ! (Sampler.x \\in to_seq (support din))]\n  =\n  0%r.\n+ byphoare => //=.\n  hoare => /=.\n  proc.\n  call (: true).\n  rnd; skip => /> x.\n  by rewrite (mem_to_seq _ _ finsup) => ->.\nelim: (to_seq (support din)) (uniq_to_seq (support din)) => /= [| x l ih /= [nxinl uql]].\n+ by rewrite big_nil; byphoare.\nrewrite big_cons /predT /= -/predT.\nby rewrite andb_orr Pr[mu_disjoint] 1:/# ih 1:// -EqPr_SamplerConj_ProvidedCond andbC.\nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_UniBig &m (a : aux_t) :\n  is_uniform din \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     weight din / (size (to_seq (support din)))%r\n     * big predT (fun (v : in_t) => Pr[P.main(v, a) @ &m : prop a v (glob P) res]) (to_seq (support din)).\nproof.\nmove=> ^ /uniform_finite finsup unidin.\nrewrite mulr_sumr /= (EqPr_SamplerConj_ProvidedCond_FinBig &m a finsup).\napply eq_big_seq => x /=.\nby rewrite (mem_to_seq _ _ finsup) (mu1_uni _ _ unidin) => ->.\nqed.\n\nend section.\n\nend Generic.\n\n\ntheory Indistinguishability.\nrequire import DBool.\n\nclone import Generic as IND with\n  type in_t <- bool,\n  type out_t <- bool,\n  type aux_t <- unit,\n  op din <- dbool.\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare axiom P_main_ll : islossless P.main.\n\nlemma RelPr_IndSampler_IndProvided &m :\n  2%r * Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r\n  =\n  Pr[P.main(true, tt) @ &m : res] - Pr[P.main(false, tt) @ &m : res].\nproof.\nrewrite (EqPr_SamplerConj_ProvidedCond_UniBig P (fun a v g b => b = v) &m tt dbool_uni) /=.\nrewrite (: support dbool = predT); 1: by rewrite fun_ext => b; rewrite supp_dbool.\nrewrite -Support.card_size_to_seq dboolE -(eq_big_perm predT _ _ _  Support.perm_eq_enum_to_seq). \nrewrite 2!big_cons big_nil /predT /= -/predT.\nrewrite -[_ = false]negbK Pr[mu_not] (: Pr[P.main(false, tt) @ &m : true] = 1%r - Pr[P.main(false, tt) @ &m : res]) 2:/#.\nby byphoare P_main_ll.\nqed.\n\nlemma Rel_Ind_Formalizations &m :\n  2%r * `| Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r/2%r |\n  =\n  `| Pr[P.main(false, tt) @ &m : res] - Pr[P.main(true, tt) @ &m : res] |.\nproof. smt(RelPr_IndSampler_IndProvided). qed.\n\nend section.\n\nend Indistinguishability.", "```ec\nrequire import AllCore Distr List.\nrequire import Finite.\nrequire (*--*) StdBigop.\n(*---*) import StdBigop.Bigreal.BRA.\n\n\nabstract theory Generic.\n\ntype in_t.\ntype out_t.\ntype aux_t.\n\nop din : in_t distr.\n\nmodule type Provided = {\n  proc main(x : in_t, aux : aux_t) : out_t\n}.\n\nmodule Sampler (P : Provided) = {\n  var x : in_t\n  \n  proc main(aux : aux_t) : out_t = {\n    var y : out_t;\n    \n    x <$ din;\n    y <@ P.main(x, aux);\n    \n    return y;\n  }\n}.\n\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare op prop : aux_t -> in_t -> glob P -> out_t -> bool.\n\nlemma EqPr_SamplerConj_ProvidedCond &m (a : aux_t) (v : in_t) :\n  Pr[Sampler(P).main(a) @ &m : Sampler.x = v /\\ prop a (Sampler.x) (glob P) res] \n  = \n  (mu1 din v) *  Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproof.\nbyphoare (: glob P = (glob P){m} /\\ arg = a ==> _ ) => //.\npose prPCond := Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproc.\nseq 1 : (Sampler.x = v) (mu1 din v) prPCond _ 0%r (glob P = (glob P){m} /\\ aux = a) => //; 1,2: by rnd.\n+ call (: glob P = (glob P){m} /\\ arg = (v, a) ==> prop a v (glob P) res) => //.\n  rewrite /prPCond; bypr=> /> &m' eqGl ->.\n  by byequiv => //; proc true.\nby hoare; call(: true); skip => />. \nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_FinBig &m (a : aux_t) :\n  is_finite (support din) \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     big predT (fun (v : in_t) => (mu1 din v) * Pr[P.main(v, a) @ &m : prop a v (glob P) res]) \n               (to_seq (support din)).\nproof.\nmove=> finsup; rewrite Pr[mu_split (Sampler.x \\in to_seq (support din))].\nhave -> /=:\n  Pr[Sampler(P).main(a) @ &m : prop a Sampler.x (glob P) res /\\ ! (Sampler.x \\in to_seq (support din))]\n  =\n  0%r.\n+ byphoare => //=.\n  hoare => /=.\n  proc.\n  call (: true).\n  rnd; skip => /> x.\n  by rewrite (mem_to_seq _ _ finsup) => ->.\nelim: (to_seq (support din)) (uniq_to_seq (support din)) => /= [| x l ih /= [nxinl uql]].\n+ by rewrite big_nil; byphoare.\nrewrite big_cons /predT /= -/predT.\nby rewrite andb_orr Pr[mu_disjoint] 1:/# ih 1:// -EqPr_SamplerConj_ProvidedCond andbC.\nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_UniBig &m (a : aux_t) :\n  is_uniform din \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     weight din / (size (to_seq (support din)))%r\n     * big predT (fun (v : in_t) => Pr[P.main(v, a) @ &m : prop a v (glob P) res]) (to_seq (support din)).\nproof.\nmove=> ^ /uniform_finite finsup unidin.\nrewrite mulr_sumr /= (EqPr_SamplerConj_ProvidedCond_FinBig &m a finsup).\napply eq_big_seq => x /=.\nby rewrite (mem_to_seq _ _ finsup) (mu1_uni _ _ unidin) => ->.\nqed.\n\nend section.\n\nend Generic.\n\n\ntheory Indistinguishability.\nrequire import DBool.\n\nclone import Generic as IND with\n  type in_t <- bool,\n  type out_t <- bool,\n  type aux_t <- unit,\n  op din <- dbool.\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare axiom P_main_ll : islossless P.main.\n\nlemma RelPr_IndSampler_IndProvided &m :\n  2%r * Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r\n  =\n  Pr[P.main(true, tt) @ &m : res] - Pr[P.main(false, tt) @ &m : res].\nproof.\nrewrite (EqPr_SamplerConj_ProvidedCond_UniBig P (fun a v g b => b = v) &m tt dbool_uni) /=.\nrewrite (: support dbool = predT); 1: by rewrite fun_ext => b; rewrite supp_dbool.\nrewrite -Support.card_size_to_seq dboolE -(eq_big_perm predT _ _ _  Support.perm_eq_enum_to_seq). \nrewrite 2!big_cons big_nil /predT /= -/predT.\nrewrite -[_ = false]negbK Pr[mu_not] (: Pr[P.main(false, tt) @ &m : true] = 1%r - Pr[P.main(false, tt) @ &m : res]) 2:/#.\nby byphoare P_main_ll.\nqed.\n\nlemma Rel_Ind_Formalizations &m :\n  2%r * `| Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r/2%r |\n  =\n  `| Pr[P.main(false, tt) @ &m : res] - Pr[P.main(true, tt) @ &m : res] |.\nproof. smt(RelPr_IndSampler_IndProvided). qed.\n\nend section.\n\nend Indistinguishability.\n```"]], "EC-1/SimplifiedLangSMC.ec": [[false, "```ec\nrequire import AllCore Int.\n\ntheory IdealCompilation.\n\n(* types for API leak, trace *)\ntype ____(TYPE_0)____.other_leak_t <- other_leak_t,\n      type ____(TYPE_1)____.trace_t <- trace_t,\n      type ____(TYPE_2)____.trace_t <- trace_t,\n      type API.SideInfo <- SideInfo,\n      type any <- SLS.any.\n\n(* certified compiler assumption *)\nclone CertifiedCompiler as Comp\n with theory LS <- LS,\n      theory LT <- LT.\n\n(*"]], "EC-1/SimpLogic.ec": [[false, "```ec\n(* SimpLogic.ec *)\n\nprover"]], "EC-1/SMC.ec": [[false, "```houzhui\n(* Secure Message Communication via a One-time Pad, Formalized\n   in Ordinary (Non-UC) Real/Ideal Paradigm Style *)\n\nprover [\"\"].  (* no use of smt *)\n\nrequire import AllCore Distr.\n\n(* minimal axiomatization of bitstrings *)\n\nop n : int.  (* length of bitstrings *)\n\naxiom ge0_n : 0 <= n.\n\ntype bits.  (* type of bit strings of length n *)\n\nop zero : bits.  (* the all zero bitstring *)\n\nop (^^) : bits -> bits -> bits.  (* pointwise exclusive or *)\n\naxiom xorC (x y : bits) :\n  x ^^ y = y ^^ x.\n\naxiom xorA (x y z : bits) :\n  x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom xor0_ (x : bits) :\n  zero ^^ x = x.\n\nlemma xor_0 (x : bits) :\n  x ^^ zero = x.\nproof.\nby rewrite xorC xor0_.\nqed.\n\naxiom xorK (x : bits) :\n  x ^^ x = zero.\n\nlemma xor_double_same_right (x y : bits) :\n  x ^^ y ^^ y = x.\nproof.\nby rewrite xorA xorK xor_0.\nqed.\n\nlemma xor_double_same_left (x y : bits) :\n  y ^^ y ^^ x = x.\nproof.\nby rewrite xorK xor0_.\nqed.\n\n(* uniform, full and lossless distribution on bitstrings *)\n\nop dbits : bits distr.\n\n(* the following two axioms tell us that the size of\n   bits is exactly 2 ^ n *)\n\naxiom dbits_ll : is_lossless dbits.  (* is a distribution *)\n\n(* every element x of bits has the same weight, \n   1%r / (2 ^ n)%r *)\n\naxiom dbits1E (x : bits) :\n  mu1 dbits x = 1%r / (2 ^ n)%r.\n\n(* so we can prove that dbits is full, i.e., every element\n   of the type has a non-zero weight *)\n\nlemma dbits_fu : is_full dbits.\nproof.\nmove => x.\nrewrite /support dbits1E.\nby rewrite RField.div1r StdOrder.RealOrder.invr_gt0\n           lt_fromint StdOrder.IntOrder.expr_gt0.\nqed.\n\n(* module type of Adversaries *)\n\nmodule type ADV = {\n  (* ask Adversary for message to securely communicate *)\n\n  proc get() : bits\n\n  (* let Adversary observe encrypted message being communicated *)\n\n  proc obs(x : bits) : unit\n\n  (* give Adversary decryption of received message, and ask it for its\n     boolean judgment (the adversary is trying to differentiate the\n     real and ideal games) *)\n\n  proc put(x : bits) : bool\n}.\n\n(* Real Game, Parameterized by Adversary *)\n\nmodule GReal (Adv : ADV) = {\n  var pad : bits  (* one-time pad *)\n\n  (* generate the one-time pad, sharing with both parties; we're\n     assuming Adversary observes nothing when this happens\n\n     of course, it's not realistic that a one-time pad can be\n     generated and shared with the adversary learning nothing *)\n\n  proc gen() : unit = {\n    pad <$ dbits;\n  }\n\n  (* the receiving and sending parties are the same, as encrypting\n     and decrypting are the same *)\n\n  proc party(x : bits) : bits = {\n    return x ^^ pad;\n  }\n\n  proc main() : bool = {\n    var b : bool;\n    var x, y, z : bits;\n\n    x <@ Adv.get();    (* get message from Adversary, give to Party 1 *)\n    gen();             (* generate and share to parties one-time pad *)\n    y <@ party(x);     (* Party 1 encrypts x, yielding y *)\n    Adv.obs(y);        (* y is observed in transit between parties\n                          by Adversary *)\n    z <@ party(y);     (* y is decrypted by Party 2, yielding z *)\n    b <@ Adv.put(z);   (* z is given to Adversary by Party 2, and\n                          Adversary chooses boolean judgment *)\n    return b;          (* return boolean judgment as game's result *)\n  }    \n}.\n\n(* module type of Simulators *)\n\nmodule type SIM = {\n  (* choose gets no help to simulate encrypted message; we specify\n     below that choose can't read/write GReal.pad *)\n\n  proc choose() : bits\n}.\n\n(* Ideal Game, parameterized by both Simulator and Adversary *)\n\nmodule GIdeal(Sim : SIM, Adv : ADV) = {\n  proc main() : bool = {\n    var b : bool;\n    var x, y : bits;\n\n    x <@ Adv.get();     (* get message from Adversary *)\n    y <@ Sim.choose();  (* simulate message encryption *)\n    Adv.obs(y);         (* encryption simulation is observed by Adversary *)\n    b <@ Adv.put(x);    (* x is given back to Adversary *)\n    return b;           (* return Adversary's boolean judgment *)\n  }    \n}.\n\n(* our goal is to prove the following security theorem, saying the\n   Adversary is completely unable to distinguish the real and ideal\n   games:\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\n*)\n\n(* enter section, so Adversary is in scope *)\n\nsection.\n\n(* say Adv and GReal don't read/write each other's globals (GIdeal\n   has no globals) *)\n\ndeclare module Adv <: ADV{-GReal}.\n\n(* define simulator as a local module, as security theorem won't\n   depend upon it *)\n\nlocal module Sim : SIM = {\n  proc choose() : bits = {\n    var x : bits;\n    x <$ dbits;\n    return x;\n  }\n}.\n\nlocal lemma GReal_GIdeal :\n  equiv[GReal(Adv).main ~ GIdeal(Sim, Adv).main :\n        ={glob Adv} ==> ={res}].\nproof.\nproc.\ninline*.\nseq 1 1 : (={x, glob Adv}).\ncall (_ : true).  (* because Adv doesn't use oracle, invariant is \"true\" *)\nauto.\nseq 1 1 : (={x, glob Adv} /\\ x{1} ^^ GReal.pad{1} = x0{2}).\nrnd (fun z => x{1} ^^ z).\nauto => /> &2.\nsplit => [z _ | _].\nby rewrite -xorA xor_double_same_left.\nsplit => [z _ | _ z _].\nby rewrite 2!dbits1E.\nsplit => [| _].\napply dbits_fu.\nby rewrite -xorA xor_double_same_left.\ncall (_ : true).  (* last statement of each program must be call *)\nwp.\ncall (_ : true).\nauto => /> &1 &2.\nby rewrite xor_double_same_right.\nqed.\n\nlemma Sec &m :\n  exists (Sim <: SIM{-GReal}),\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\nexists Sim.\nby byequiv GReal_GIdeal.\nqed.\n\nend section.\n\n(* security theorem *)\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\napply (Sec Adv &m).\nqed.\n```"]], "EC-1/SymEnc.ec": [[false, "```ec\n(* SymEnc.ec *)\n\n(* Symmetric Encryption *)\n\n(* definitions, including games for judging correctness and IND-CPA\n   (indistinguishability under chosen plaintext attack) security *)\n\nprover"]], "EC-1/SymEncPRF.ec": [[true, "clash_post) and invariant\n   (EO_I.ctr_post < limit_post) by line 1 of G3.main, it's only\n   EO_I.clash_post that's capable of setting the failure event *)\n\nlocal lemma G3_main_clash_ub &m :\n  Pr[G3.main() @ &m : EO_I.clash_post] <= limit_post%r / (2 ^ text_len)%r.\nproof.\nfel\n  (* number of lines of G3.main needed to initialize counter, failure\n     event and invariant *)\n  1\n  EO_I.ctr_post  (* counter *)\n  (* upper bound in terms of current counter of probability that failure\n     event is set during one run of oracle *)\n  (fun n, 1%r / (2 ^ text_len)%r)\n  limit_post  (* counter limit *)\n  EO_I.clash_post  (* failure event *)\n  (* precondition on enc_post: if it holds, then counter goes up and\n     failure might happen; if it doesn't hold, then counter doesn't go\n     down, and failure status preserved *)\n  [EO_I.enc_post : (EO_I.ctr_post < limit_post)]\n  (* invariant *)\n  (EO_I.ctr_post <= limit_post) => //.\n(* 1 *)\nby rewrite sumr_const intmulr /= count_predT size_range /=\n           IntOrder.ler_maxr /= 1:ge0_limit_post.\n(* 2 *)\ninline*; auto; progress; rewrite ge0_limit_post.\n(* 3 *)\nproc; rcondt 1; first auto.\nwp; sp.\nseq 2 :\n  (EO_I.clash_post)\n  (1%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nwp.\nrnd (pred1 EO_I.genc_inp).\nauto => /> &hr ctr_post.\nby rewrite mu1_dtext.\nauto.\nhoare; inline*; wp; sp; if; auto.\ntrivial.\n(* 4 *)\nprogress; proc.\nrcondt 1; first auto.\nseq 2 : (c < EO_I.ctr_post <= limit_post).\nauto => /> lt_lim _ x _.\nsplit => [| _].\nrewrite ltzS lezz.\nrewrite addzC lez_add1r lt_lim.\nif; inline*; wp; sp; if; auto.\n(* 5 *)\nprogress; proc.\nrcondf 1; first auto.\nauto.\nqed.\n\nlocal lemma G2_G3 &m :\n  `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  limit_post%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G3.main() @ &m : EO_I.clash_post]);\n  last 1 apply (G3_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_post}(EO_O, EO_I)) /\\ (! EO_I.clash_post{2} => ={res})) :\n  (EO_O.clash_post) => //.\nby conseq G2_G3_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality to summarize: *)\n\nlocal lemma INDCPA_G3 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| +\n    `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]|))\n  1:ler_dist_add mulrDl addrA ler_add 1:(INDCPA_G2 &m) (G2_G3 &m).\nqed.\n\n(* version of encryption oracle in which right side of ciphertext\n   produced by genc doesn't reference plaintext at all (N stands for\n   No reference to plaintext); we no longer need any\n   instrumentation *)\n\nlocal module EO_N : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    v <$ dtext;\n    c <- (u, v);  (* note: no exclusive or *)\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_N, and where argument to EO_N.genc is independent\n   from x1/x2/b *)\n\nlocal module G4 = {\n  module A = Adv(EO_N)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_N.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_N.genc(____()___); (* text0 should be used here *)\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_N_enc_pre_ll : islossless EO_N.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_enc_post_ll : islossless EO_N.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_genc_ll : islossless EO_N.genc.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\n(* note no assumption about genc's argument, x *)\n\nlocal lemma EO_I_EO_N_genc :\n  equiv[EO_I.genc ~ EO_N.genc : true ==> ={res}].\nproof.\nproc.\nwp.\nrnd (fun z => x{1} +^ z).\nauto; progress.\nby rewrite text_xorA text_xorK text_xor_lid.\nqed.\n\nlocal lemma G3_G4 &m :\n  Pr[G3.main() @ &m : res] = Pr[G4.main() @ &m : res].\nproof.\nbyequiv => //.\nproc.\ncall (_ : ={TRF.mp} /\\ ={ctr_post}(EO_I, EO_N)).\nsim.\ncall EO_I_EO_N_genc.\nrnd.\ncall (_ : ={TRF.mp} /\\ ={ctr_pre}(EO_I, EO_N)).\nsim.\ninline*; auto.\nqed.\n\nlocal lemma INDCPA_G4 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G4.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite -(G3_G4 &m) (INDCPA_G3 &m).\nqed.\n\n(* probability that G4.main returns true *)\n\nlocal lemma G4_prob &m :\n  Pr[G4.main() @ &m : res] = 1%r / 2%r.\nproof.\nbyphoare => //; proc.\nswap 3 2; rnd.\ncall (_ : true);\n  [apply Adv_guess_ll | apply EO_N_enc_post_ll | idtac].\ncall EO_N_genc_ll.\ncall (_ : true);\n  [apply Adv_choose_ll | apply EO_N_enc_pre_ll | idtac].\ninline*; auto => /= x; by rewrite dbool1E.\nqed.\n\nlemma INDCPA' &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof. rewrite -(G4_prob &m) (INDCPA_G4 &m). qed.\n\nend section.\n\n(* IND-CPA security theorem\n\n   we need to assume Adv is lossless and that it doesn't interact with\n   EncO (which INDCPA uses) or PRF/TRF/Adv2RFA (which appear in the\n   upper bound)\n\n   because Enc is stateless, Adv may use it (and in any event could\n   simulate it) *)\n\nlemma INDCPA (Adv <: ADV{-EncO, -PRF, -TRF, -Adv2RFA}) &m :\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_pre => islossless Adv(EO).choose) =>\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_post => islossless Adv(EO).guess) =>\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nmove => Adv_choose_ll Adv_guess_ll.\napply (INDCPA' Adv Adv_choose_ll Adv_guess_ll &m).\nqed.", "```ec\nclash_post) and invariant\n   (EO_I.ctr_post < limit_post) by line 1 of G3.main, it's only\n   EO_I.clash_post that's capable of setting the failure event *)\n\nlocal lemma G3_main_clash_ub &m :\n  Pr[G3.main() @ &m : EO_I.clash_post] <= limit_post%r / (2 ^ text_len)%r.\nproof.\nfel\n  (* number of lines of G3.main needed to initialize counter, failure\n     event and invariant *)\n  1\n  EO_I.ctr_post  (* counter *)\n  (* upper bound in terms of current counter of probability that failure\n     event is set during one run of oracle *)\n  (fun n, 1%r / (2 ^ text_len)%r)\n  limit_post  (* counter limit *)\n  EO_I.clash_post  (* failure event *)\n  (* precondition on enc_post: if it holds, then counter goes up and\n     failure might happen; if it doesn't hold, then counter doesn't go\n     down, and failure status preserved *)\n  [EO_I.enc_post : (EO_I.ctr_post < limit_post)]\n  (* invariant *)\n  (EO_I.ctr_post <= limit_post) => //.\n(* 1 *)\nby rewrite sumr_const intmulr /= count_predT size_range /=\n           IntOrder.ler_maxr /= 1:ge0_limit_post.\n(* 2 *)\ninline*; auto; progress; rewrite ge0_limit_post.\n(* 3 *)\nproc; rcondt 1; first auto.\nwp; sp.\nseq 2 :\n  (EO_I.clash_post)\n  (1%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nwp.\nrnd (pred1 EO_I.genc_inp).\nauto => /> &hr ctr_post.\nby rewrite mu1_dtext.\nauto.\nhoare; inline*; wp; sp; if; auto.\ntrivial.\n(* 4 *)\nprogress; proc.\nrcondt 1; first auto.\nseq 2 : (c < EO_I.ctr_post <= limit_post).\nauto => /> lt_lim _ x _.\nsplit => [| _].\nrewrite ltzS lezz.\nrewrite addzC lez_add1r lt_lim.\nif; inline*; wp; sp; if; auto.\n(* 5 *)\nprogress; proc.\nrcondf 1; first auto.\nauto.\nqed.\n\nlocal lemma G2_G3 &m :\n  `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  limit_post%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G3.main() @ &m : EO_I.clash_post]);\n  last 1 apply (G3_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_post}(EO_O, EO_I)) /\\ (! EO_I.clash_post{2} => ={res})) :\n  (EO_O.clash_post) => //.\nby conseq G2_G3_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality to summarize: *)\n\nlocal lemma INDCPA_G3 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| +\n    `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]|))\n  1:ler_dist_add mulrDl addrA ler_add 1:(INDCPA_G2 &m) (G2_G3 &m).\nqed.\n\n(* version of encryption oracle in which right side of ciphertext\n   produced by genc doesn't reference plaintext at all (N stands for\n   No reference to plaintext); we no longer need any\n   instrumentation *)\n\nlocal module EO_N : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    v <$ dtext;\n    c <- (u, v);  (* note: no exclusive or *)\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_N, and where argument to EO_N.genc is independent\n   from x1/x2/b *)\n\nlocal module G4 = {\n  module A = Adv(EO_N)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_N.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_N.genc(____()___); (* text0 should be used here *)\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_N_enc_pre_ll : islossless EO_N.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_enc_post_ll : islossless EO_N.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_genc_ll : islossless EO_N.genc.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\n(* note no assumption about genc's argument, x *)\n\nlocal lemma EO_I_EO_N_genc :\n  equiv[EO_I.genc ~ EO_N.genc : true ==> ={res}].\nproof.\nproc.\nwp.\nrnd (fun z => x{1} +^ z).\nauto; progress.\nby rewrite text_xorA text_xorK text_xor_lid.\nqed.\n\nlocal lemma G3_G4 &m :\n  Pr[G3.main() @ &m : res] = Pr[G4.main() @ &m : res].\nproof.\nbyequiv => //.\nproc.\ncall (_ : ={TRF.mp} /\\ ={ctr_post}(EO_I, EO_N)).\nsim.\ncall EO_I_EO_N_genc.\nrnd.\ncall (_ : ={TRF.mp} /\\ ={ctr_pre}(EO_I, EO_N)).\nsim.\ninline*; auto.\nqed.\n\nlocal lemma INDCPA_G4 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G4.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite -(G3_G4 &m) (INDCPA_G3 &m).\nqed.\n\n(* probability that G4.main returns true *)\n\nlocal lemma G4_prob &m :\n  Pr[G4.main() @ &m : res] = 1%r / 2%r.\nproof.\nbyphoare => //; proc.\nswap 3 2; rnd.\ncall (_ : true);\n  [apply Adv_guess_ll | apply EO_N_enc_post_ll | idtac].\ncall EO_N_genc_ll.\ncall (_ : true);\n  [apply Adv_choose_ll | apply EO_N_enc_pre_ll | idtac].\ninline*; auto => /= x; by rewrite dbool1E.\nqed.\n\nlemma INDCPA' &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof. rewrite -(G4_prob &m) (INDCPA_G4 &m). qed.\n\nend section.\n\n(* IND-CPA security theorem\n\n   we need to assume Adv is lossless and that it doesn't interact with\n   EncO (which INDCPA uses) or PRF/TRF/Adv2RFA (which appear in the\n   upper bound)\n\n   because Enc is stateless, Adv may use it (and in any event could\n   simulate it) *)\n\nlemma INDCPA (Adv <: ADV{-EncO, -PRF, -TRF, -Adv2RFA}) &m :\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_pre => islossless Adv(EO).choose) =>\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_post => islossless Adv(EO).guess) =>\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nmove => Adv_choose_ll Adv_guess_ll.\napply (INDCPA' Adv Adv_choose_ll Adv_guess_ll &m).\nqed.\n```"]], "EC-1/theory-alias.ec": [[true, "theory T.\n  theory V.\n    op foo : int.\n  end V.\n\n  theory U = V.\nend T.\n\nimport T.\n\nop bar : int = U.foo.\n\nprint T.", "To complete the given file, we need to fill in the blank `____(OP_0)____` with the correct type. Based on the provided description, `foo` is defined as an integer type.\n\nHere's the step-by-step thought process:\n1. The description mentions that `foo` is defined as an integer type.\n2. The incomplete code has `op foo : ____(OP_0)____`, indicating that we need to specify the type of `foo`.\n3. Since `foo` is an integer, the type should be `int`.\n\nTherefore, we can fill in the blank with `int`.\n\nThe completed code will be:\n```ec\ntheory T.\n  theory V.\n    op foo : int.\n  end V.\n\n  theory U = V.\nend T.\n\nimport T.\n\nop bar : int = U.foo.\n\nprint T.\n```"]], "EC-1/tut.ec": [[false, "```houzhui\nrequire import Distr AllCore FSet SmtMap DProd List.\n\n(* A Stateful Random Generator *)\n\ntype seed.\n\nop dseed: seed distr.\naxiom dseed_ll: is_lossless dseed.\n\ntype state.\n\nop dstate: state distr.\naxiom dstate_uf: is_uniform dstate.\naxiom dstate_fu: is_full dstate.\n\ntype output.\n\nop dout: output distr.\naxiom dout_uf: is_uniform dout.\n\nop Fc : seed -> state -> state * output.\n\nmodule SRG = {\n  var s : seed\n  var st: state\n\n  proc init(): unit = {\n    s <$ dseed;\n    st <$ dstate;\n  }\n\n  proc next(): output = {\n    var r;\n    (st,r) <- Fc s st;\n    return r;\n  }\n}.\n\n(* A Pseudo-Random Generator *)\n\ntheory PRG.\n  type output.\n  op dout: output distr.\n\n  module type PRG = {\n    proc init(): unit\n    proc next(): output\n  }.\n\n  module type PRGA = {\n    proc next(): output\n  }.\n\n  module type Distinguisher(G: PRGA) = { proc distinguish(): bool }.\n\n  module IND(G: PRG, D: Distinguisher) = {\n    module D = D(G)\n\n    proc main(): bool = {\n      var b;\n\n      G.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\n  module PRGi: PRG, PRGA = {\n    proc init(): unit = {}\n    proc next(): output = { var r; r <$ PRG.dout; return r; }\n  }.\n\nend PRG.\n\n(* PRF *)\n\ntheory PRF.\n  type D.\n\n  type R.\n\n  type K.\n\n  op dK: K distr.\n  axiom dK_ll: is_lossless dK.\n\n  op F: K -> D -> R.\n\n  module PRFr = {\n    var k: K\n    proc init(): unit = { k <$ dK; }\n    proc f(x : D): R = { return F k x; }\n  }.\n\n  op uR: R distr.\n  axiom uR_uf: is_uniform uR.\n\n  module PRFi = {\n    var m : (D, R) fmap\n\n    proc init(): unit = {\n      m <- empty;\n    }\n\n    proc f (x : D) : R = {\n      var r: R;\n      if (! x \\in m) {\n        r <$ uR;\n        m.[x] <- r;\n      }\n      return (oget m.[x]);\n    }\n  }.\n\n  module type PRF = {\n    proc init() : unit\n    proc f(x : D) : R\n  }.\n\n  module type PRFA = {\n    proc f(x : D) : R\n  }.\n\n  module type Distinguisher (F: PRFA) = {\n    proc distinguish (): bool\n  }.\n\n  module IND(F: PRF, D: Distinguisher) = {\n    module D = D(F)\n\n    proc main(): bool = {\n      var b;\n\n      F.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\nend PRF.\n\nclone PRF as PRFa\nwith\n  type D <- state,\n  type R <- state * output,\n  type K <- seed,\n  op dK <- dseed,\n  op F <- Fc,\n  op uR <- dstate `*` dout (* product distribution *)\nproof dK_ll by apply dseed_ll.\n\nmodule IND_PRF = PRFa.IND.\nmodule PRFc = PRFa.PRFr.\nmodule PRFi = PRFa.PRFi.\n\nclone PRG as PRGa\nwith\n  type output <- output,\n  op dout <- dout.\n\nmodule IND_PRG = PRGa.IND.\nmodule PRGi = PRGa.PRGi.\n\n(* Proof sketch *)\n\nmodule D_PRF(D: PRGa.Distinguisher, F: PRFa.PRFA) = {\n  var log: state list\n\n  module PRGp = {\n    proc init(): unit = {\n      SRG.st <$ dstate;\n      log <- [];\n    }\n\n    proc next(): output = {\n      var r;\n\n      log <- SRG.st::log;\n      (SRG.st, r) <@ F.f(SRG.st);\n      return r;\n    }\n  }\n\n  proc distinguish = IND_PRG(PRGp, D).main\n}.\n```"]], "EC-1/WF-examp.ec": [[true, "(* example use of well-founded recursion and induction\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* define well-founded relation on lists: lt_list_size xs ys <=>\n   size xs < size ys *)\n\nop lt_list_size : 'a list rel = wf_pre size lt_nat.\n\nlemma wf_lt_list_size ['a] : wf lt_list_size<:'a>.\nproof.\nrewrite wf_pre wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP (xs ys : 'a list) :\n  lt_list_size xs ys <=> size xs < size ys.\nproof.\nby rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* body of well-founded recursive definition that \"chunkifies\" an 'a\n   list into an 'a list list: the first n elements, then the next n\n   elements, etc., where if at the end there are < n elements left,\n   they are discarded *)\n\nop chunkify_wf_rec_def (n : int) : ('a list, 'a list list) wf_rec_def =\n  fun (xs : 'a list,                     (* input list *)\n       f : 'a list -> 'a list list) =>   (* for recursive calls on\n                                            strictly shorter lists *)\n  if n <= size xs\n  then take n xs :: f (drop n xs)\n  else [].\n\n(* the actual recursive definition: *)\n\nop chunkify (n : int) : 'a list -> 'a list list =\n  wf_recur\n  lt_list_size              (* well-founded relation being used *)\n  []                        (* element to be returned if recursive calls\n                               don't respect well-founded relation *)\n  (chunkify_wf_rec_def n).  (* body of recursive definition *)\n\nlemma chunkify_size (n : int, xs : 'a list) :\n  1 <= n => size (chunkify n xs) = size xs %/ n.\nproof.\nmove => ge1_n; move : xs.\napply (wf_ind lt_list_size).  (* use well-founded induction on lt_list_size *)\napply wf_lt_list_size.\nrewrite /chunkify => /= xs IH.\nrewrite wf_recur 1:wf_lt_list_size.\nrewrite {1}/chunkify_wf_rec_def.  (* only need to rewrite at top-level *)\ncase (n <= size xs) => [le_n_size_xs | not_le_n_size_xs].\n(* first case *)\nrewrite lt_list_sizeP.\nhave lt_size_drop : size (drop n xs) < size xs by rewrite size_drop /#.\nrewrite lt_size_drop /= IH 1:lt_list_sizeP //.\nrewrite size_drop 1:/# ler_maxr 1:/#.\nhave {2}-> : size xs = n + (size xs - n) by smt().\nrewrite (divzDl n) 1:dvdzz divzz /#.\n(* second case *)\nsmt(size_ge0 ltr_normr).\nqed.", "```ec\n(* example use of well-founded recursion and induction\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* define well-founded relation on lists: lt_list_size xs ys <=>\n   size xs < size ys *)\n\nop lt_list_size : 'a list rel = wf_pre size lt_nat.\n\nlemma wf_lt_list_size ['a] : wf lt_list_size<:'a>.\nproof.\nrewrite wf_pre wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP (xs ys : 'a list) :\n  lt_list_size xs ys <=> size xs < size ys.\nproof.\nby rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* body of well-founded recursive definition that \"chunkifies\" an 'a\n   list into an 'a list list: the first n elements, then the next n\n   elements, etc., where if at the end there are < n elements left,\n   they are discarded *)\n\nop chunkify_wf_rec_def (n : int) : ('a list, 'a list list) wf_rec_def =\n  fun (xs : 'a list,                     (* input list *)\n       f : 'a list -> 'a list list) =>   (* for recursive calls on\n                                            strictly shorter lists *)\n  if n <= size xs\n  then take n xs :: f (drop n xs)\n  else [].\n\n(* the actual recursive definition: *)\n\nop chunkify (n : int) : 'a list -> 'a list list =\n  wf_recur\n  lt_list_size              (* well-founded relation being used *)\n  []                        (* element to be returned if recursive calls\n                               don't respect well-founded relation *)\n  (chunkify_wf_rec_def n).  (* body of recursive definition *)\n\nlemma chunkify_size (n : int, xs : 'a list) :\n  1 <= n => size (chunkify n xs) = size xs %/ n.\nproof.\nmove => ge1_n; move : xs.\napply (wf_ind lt_list_size).  (* use well-founded induction on lt_list_size *)\napply wf_lt_list_size.\nrewrite /chunkify => /= xs IH.\nrewrite wf_recur 1:wf_lt_list_size.\nrewrite {1}/chunkify_wf_rec_def.  (* only need to rewrite at top-level *)\ncase (n <= size xs) => [le_n_size_xs | not_le_n_size_xs].\n(* first case *)\nrewrite lt_list_sizeP.\nhave lt_size_drop : size (drop n xs) < size xs by rewrite size_drop /#.\nrewrite lt_size_drop /= IH 1:lt_list_sizeP //.\nrewrite size_drop 1:/# ler_maxr 1:/#.\nhave {2}-> : size xs = n + (size xs - n) by smt().\nrewrite (divzDl n) 1:dvdzz divzz /#.\n(* second case *)\nsmt(size_ge0 ltr_normr).\nqed.\n```"]], "EC-1/ASecretSharingScheme.ec": [[true, "(** Abstract class for secret sharing schemes *)\nrequire import List.\n\n(** \n  A secret sharing scheme is a cryptographic primitive whose\n  goal is to \"split\" some value into _n_ shares, such that the\n  knowledge of _t_ shares (_t_ < _n_) does not reveal any\n  sensitive information about the original value that was\n  shared.\n*)\ntheory SecretSharingScheme.\n\n  (** Party identifier *)\n  type partyId_t. (* 0..n_parties-1 *)\n\n  (** Number of parties *)\n  op n : int.\n  (** Threshold of corrupt parties *)\n  op t : int.\n\n  (** Values *)\n  type value_t.\n  (** Individual shares *)\n  type share_t.\n  (** Set of all shares *)\n  type sharedValue_t = share_t list.\n\n  (** Shares a value among n-shares *)\n  op [lossless] nshr : int -> value_t -> sharedValue_t distr.\n  (** Unshares a shared value *)\n  op unshr: sharedValue_t -> value_t.\n\nend SecretSharingScheme.", "```ec\n(** Abstract class for secret sharing schemes *)\nrequire import List.\n\n(** \n  A secret sharing scheme is a cryptographic primitive whose\n  goal is to \"split\" some value into _n_ shares, such that the\n  knowledge of _t_ shares (_t_ < _n_) does not reveal any\n  sensitive information about the original value that was\n  shared.\n*)\ntheory SecretSharingScheme.\n\n  (** Party identifier *)\n  type partyId_t. (* 0..n_parties-1 *)\n\n  (** Number of parties *)\n  op n : int.\n  (** Threshold of corrupt parties *)\n  op t : int.\n\n  (** Values *)\n  type value_t.\n  (** Individual shares *)\n  type share_t.\n  (** Set of all shares *)\n  type sharedValue_t = share_t list.\n\n  (** Shares a value among n-shares *)\n  op [lossless] nshr : int -> value_t -> sharedValue_t distr.\n  (** Unshares a shared value *)\n  op unshr: sharedValue_t -> value_t.\n\nend SecretSharingScheme.\n```"]], "EC-1/WhileSampling.ec": [[true, "require import Real Distr.\n\ntype t.\n\nop sample: t distr.\naxiom sample_ll: is_lossless sample.\n\nop test: t -> bool.\naxiom pr_ntest: 0%r < mu sample (predC test).\n\nmodule Sample = {\n  proc sample () : t = {\n    var r : t;\n\n    r <$ sample;\n    while (test r) {\n      r <$ sample;\n    }\n    return r;\n  }\n}.\n\nlemma Sample_lossless: islossless Sample.sample.\nproof.\nproc; seq  1: true=> //.\n+ by auto=> />; exact/sample_ll.\nwhile true (if test r then 1 else 0) 1 (mu sample (predC test))=> //.\n+ by move=> _ r; case: (test r).\n+ move=> ih; seq  1: true=> //.\n  by auto; rewrite sample_ll.\n+ by auto; rewrite sample_ll.\nrewrite pr_ntest=> /= z; conseq (: true ==> !test r).\n+ smt().\nby rnd; auto=> />.\nqed.", "```ec\nrequire import Real Distr.\n\ntype t.\n\nop sample: t distr.\naxiom sample_ll: is_lossless sample.\n\nop test: t -> bool.\naxiom pr_ntest: 0%r < mu sample (predC test).\n\nmodule Sample = {\n  proc sample () : t = {\n    var r : t;\n\n    r <$ sample;\n    while (test r) {\n      r <$ sample;\n    }\n    return r;\n  }\n}.\n\nlemma Sample_lossless: islossless Sample.sample.\nproof.\nproc; seq  1: true=> //.\n+ by auto=> />; exact/sample_ll.\nwhile true (if test r then 1 else 0) 1 (mu sample (predC test))=> //.\n+ by move=> _ r; case: (test r).\n+ move=> ih; seq  1: true=> //.\n  by auto; rewrite sample_ll.\n+ by auto; rewrite sample_ll.\nrewrite pr_ntest=> /= z; conseq (: true ==> !test r).\n+ smt().\nby rnd; auto=> />.\nqed.\n```"]], "EC-1/W64_SchnorrProtocol.ec": [[true, "require import AllCore.\nrequire import JModel.\n\nrequire import W64_SchnorrExtract.\nrequire import BigNum_spec.\n\nmodule Prover = M(Syscall).\nmodule JVerifier = M(Syscall).\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power:W64xN.R.t,\n                 challenge:W64xN.R.t) : W64xN.R.t \n  proc commitment () : W64xN.R.t * W64xN.R.t  \n}.\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t \n  proc response(challenge:W64xN.R.t) : W64xN.R.t \n}.\n\nmodule type ZKVerifierJ = {\n   proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) :\n    W64.t  \n  proc challenge() : W64xN.R.t \n}.\n\nmodule CompletenessJ(P:ZKProverJ,V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t, w:W64xN.R.t) = {\n    var z, c, r,t,v;\n    (z,r) <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(w,r,c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\nmodule SoundnessJ(P:ZKMaliciousProverJ, V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t) = {\n    var z, c,t,v;\n    z <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\ntype sbits.\n\nmodule type ZKRewindableMaliciousProverJ = {\n  proc response (challenge:W64xN.R.t) : W64xN.R.t\n  proc commitment () : W64xN.R.t \n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\nmodule type ExtractorJ(P: ZKRewindableMaliciousProverJ) = {\n  proc extract(statement: W64xN.R.t): W64xN.R.t\n}.\n\nmodule type MaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n}.\n\nmodule type ZKDistinguisherJ  = {\n  proc guess(statement : W64xN.R.t, witness : W64xN.R.t, summary : sbits) : bool \n}.\n\nmodule type RewMaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\nmodule type SimulatorJ(V0 : RewMaliciousVerifierJ)  = {\n  proc simulate(statement : W64xN.R.t) : sbits\n}.\n\nmodule ZKRealJ(P : ZKProverJ, V : MaliciousVerifierJ, D : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var commit, secret,  challenge, response, summary, guess;    \n    (commit, secret) <@ P.commitment();\n    challenge <@ V.challenge(statement, commit);\n    response <@ P.response(witness, secret, challenge);\n    summary <@ V.summitup(response);\n    guess <@ D.guess(statement, witness, summary);\n    return guess;\n  }\n}.\n\nmodule ZKIdealJ(S : SimulatorJ, V0 : RewMaliciousVerifierJ,\n               D0 : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var summary : sbits;\n    var guess : bool;\n    summary <@ S(V0).simulate(statement);\n    guess <@ D0.guess(statement, witness, summary);\n    return guess;\n  }\n}.", "To complete the given code, we first need to identify the missing parts based on the provided description and the given incomplete EasyCrypt code.\n\n1. The first missing part is the module `____(MODULE_0)____ = M(Syscall).` Here, we need to specify the name of the module. Based on the context, it seems like it should be related to the prover or verifier implementation. Let's name it `Prover`.\n\n2. The rest of the code seems to be well-structured and follows the EasyCrypt syntax. However, to ensure it compiles successfully, we need to make sure all required modules and types are correctly defined or imported.\n\nGiven the information and the structure of the provided code, the completion involves filling in the missing module name.\n\nHere's the completed code:\n\n```ec\nrequire import AllCore.\nrequire import JModel.\n\nrequire import W64_SchnorrExtract.\nrequire import BigNum_spec.\n\nmodule Prover = M(Syscall).\nmodule JVerifier = M(Syscall).\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power:W64xN.R.t,\n                 challenge:W64xN.R.t) : W64xN.R.t \n  proc commitment () : W64xN.R.t * W64xN.R.t  \n}.\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t \n  proc response(challenge:W64xN.R.t) : W64xN.R.t \n}.\n\nmodule type ZKVerifierJ = {\n   proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) :\n    W64.t  \n  proc challenge() : W64xN.R.t \n}.\n\nmodule CompletenessJ(P:ZKProverJ,V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t, w:W64xN.R.t) = {\n    var z, c, r,t,v;\n    (z,r) <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(w,r,c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\nmodule SoundnessJ(P:ZKMaliciousProverJ, V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t) = {\n    var z, c,t,v;\n    z <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\ntype sbits.\n\nmodule type ZKRewindableMaliciousProverJ = {\n  proc response (challenge:W64xN.R.t) : W64xN.R.t\n  proc commitment () : W64xN.R.t \n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\nmodule type ExtractorJ(P: ZKRewindableMaliciousProverJ) = {\n  proc extract(statement: W64xN.R.t): W64xN.R.t\n}.\n\nmodule type MaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n}.\n\nmodule type ZKDistinguisherJ  = {\n  proc guess(statement : W64xN.R.t, witness : W64xN.R.t, summary : sbits) : bool \n}.\n\nmodule type RewMaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\nmodule type SimulatorJ(V0 : RewMaliciousVerifierJ)  = {\n  proc simulate(statement : W64xN.R.t) : sbits\n}.\n\nmodule ZKRealJ(P : ZKProverJ, V : MaliciousVerifierJ, D : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var commit, secret,  challenge, response, summary, guess;    \n    (commit, secret) <@ P.commitment();\n    challenge <@ V.challenge(statement, commit);\n    response <@ P.response(witness, secret, challenge);\n    summary <@ V.summitup(response);\n    guess <@ D.guess(statement, witness, summary);\n    return guess;\n  }\n}.\n\nmodule ZKIdealJ(S : SimulatorJ, V0 : RewMaliciousVerifierJ,\n               D0 : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var summary : sbits;\n    var guess : bool;\n    summary <@ S(V0).simulate(statement);\n    guess <@ D0.guess(statement, witness, summary);\n    return guess;\n  }\n}.\n```"]], "EC-1/async-while.ec": [[true, "require import AllCore IntDiv Ring StdRing StdOrder.\n(*---*) import IntID IntOrder RealOrder.\n\ntype value.\n\nop n : { int | 0 <= n} as ge0_n.\nop k : { int | 0 <  k} as gt0_k.\n\nlemma ge0_k : 0 <= k.\nproof. by rewrite ltrW ?gt0_k. qed.\n\nmodule type I = {\n  proc step(i : int, x : value) : value\n}.\n\nmodule M(A : I) = {\n  proc f(x : value) = {\n    var i <- 0;\n\n    while (i < n * k) {\n      x <@ A.step(i, x);\n      i <- i + 1;\n    }\n\n    return x;\n  }\n\n  proc g(x : value) = {\n    var i <- 0;\n    var j;\n\n    while (i < n) {\n      j <- 0;\n      while (j < k) {\n        x <@ A.step(k * i + j, x);\n        j <- j + 1;\n      }\n      i <- i + 1;\n    }\n\n    return x;\n  }\n}.\n\nlemma M_equiv (A <: I) : islossless A.step =>\n  equiv[M(A).f ~ M(A).g : ={glob A, x} ==> ={res}].\nproof. move=> llA; proc.\nseq 1 1 : (i{1} = 0 /\\ ={glob A, x, i}) => //.\n+ by auto => &1 &2 />.\nasync while\n  [ (fun r => i%r < k%r * r), (i{2} + 1)%r ]\n  [ (fun r => i%r < r), (i{2} + 1)%r ]\n    (i{1} < n * k /\\ i{2} < n) (!(i{2} < n))\n  :\n    (={glob A, x} /\\ i{1} = k * i{2} /\\ (0 <= i{1})) => //=.\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ move=> v1 v2.\n  rcondt {2} 1; 1: by auto => /> /#.\n  rcondf{2} 4; 1: by auto; conseq (_: true);auto.\n  wp;while (   ={glob A, x} \n         /\\ i{1} = k * i{2} + j{2}\n         /\\ v1 = (i{2} + 1)%r\n         /\\ 0 <= i{2} <  n\n         /\\ 0 <= j{2} <= k) => /=; last by auto; smt(gt0_k ge0_n).\n  wp; call (_ : true); skip => &1 &2 /= />.\n  rewrite -fromintM !lt_fromint => *. \n  by have := StdOrder.IntOrder.ler_wpmul2l k{2} _ i{2} (n - 1); smt().\n+ by while true (n * k - i) => //; auto;1: call llA; auto => /#.\n+ while true (n - i);2: by auto=>/#.\n  move=> z;wp; while (true) (k - j);auto;1:call llA;auto => /#.\nqed.", "```ec\nrequire import AllCore IntDiv Ring StdRing StdOrder.\n(*---*) import IntID IntOrder RealOrder.\n\ntype value.\n\nop n : { int | 0 <= n} as ge0_n.\nop k : { int | 0 <  k} as gt0_k.\n\nlemma ge0_k : 0 <= k.\nproof. by rewrite ltrW ?gt0_k. qed.\n\nmodule type I = {\n  proc step(i : int, x : value) : value\n}.\n\nmodule M(A : I) = {\n  proc f(x : value) = {\n    var i <- 0;\n\n    while (i < n * k) {\n      x <@ A.step(i, x);\n      i <- i + 1;\n    }\n\n    return x;\n  }\n\n  proc g(x : value) = {\n    var i <- 0;\n    var j;\n\n    while (i < n) {\n      j <- 0;\n      while (j < k) {\n        x <@ A.step(k * i + j, x);\n        j <- j + 1;\n      }\n      i <- i + 1;\n    }\n\n    return x;\n  }\n}.\n\nlemma M_equiv (A <: I) : islossless A.step =>\n  equiv[M(A).f ~ M(A).g : ={glob A, x} ==> ={res}].\nproof. move=> llA; proc.\nseq 1 1 : (i{1} = 0 /\\ ={glob A, x, i}) => //.\n+ by auto => &1 &2 />.\nasync while\n  [ (fun r => i%r < k%r * r), (i{2} + 1)%r ]\n  [ (fun r => i%r < r), (i{2} + 1)%r ]\n    (i{1} < n * k /\\ i{2} < n) (!(i{2} < n))\n  :\n    (={glob A, x} /\\ i{1} = k * i{2} /\\ (0 <= i{1})) => //=.\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ move=> v1 v2.\n  rcondt {2} 1; 1: by auto => /> /#.\n  rcondf{2} 4; 1: by auto; conseq (_: true);auto.\n  wp;while (   ={glob A, x} \n         /\\ i{1} = k * i{2} + j{2}\n         /\\ v1 = (i{2} + 1)%r\n         /\\ 0 <= i{2} <  n\n         /\\ 0 <= j{2} <= k) => /=; last by auto; smt(gt0_k ge0_n).\n  wp; call (_ : true); skip => &1 &2 /= />.\n  rewrite -fromintM !lt_fromint => *. \n  by have := StdOrder.IntOrder.ler_wpmul2l k{2} _ i{2} (n - 1); smt().\n+ by while true (n * k - i) => //; auto;1: call llA; auto => /#.\n+ while true (n - i);2: by auto=>/#.\n  move=> z;wp; while (true) (k - j);auto;1:call llA;auto => /#.\nqed.\n```"]], "EC-1/ambient-logic.ec": [[true, "int): x - 10 = x - 9 - 1.\nproof.\n    simplify.\n    trivial.\nqed.\n\n(*\nThe goal list in EC is an ordered one, and you have to prove them\nin the same order as EC lists it. \"admit\" can be used to bypass a certain \ngoal and focus on something else in the goal list.\n*)\n\n(*\nUse the tactic \"split\" to split the disjunction into two\nand apply the previous axioms to discharge the goals.\nExperiment with admiting the first goal after splitting\n*)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\n  split.\n  by apply addzA.\n  by apply addzC.\nqed.\n\n(*\nTo deal with disjunctions in EC, you can use the tactics \"left\" or \"right\"\nto step into a proof of the left proof term, or the right proof term respectively.\n*)\n\n(* Searching in EC *)\n\n(*\nSince, there is a lot that is already done in EC,\nwe need a way to look for things. \nWe do that using the \"search\" command. It prints out all axioms and lemmas \ninvolving the list of operators that give it.\n*)\n\nsearch [-].\n(* [] - Square braces for unary operators  *)\n\nsearch (+).\n\n(*\nAs you can see the list can be quite overwhelming and difficult to navigate.\nSo we can limit the results using a list of operators, or patterns.\n*)\n\nsearch ( * ).\n(*\n() - Parentheses for binary operators. \nNotice the extra space for the \"*\" operator.\nWe need that since (* *) also indicates comments.\n*)\n\nsearch (+) (=) (=>).\n(* List of operators \"=>\" is the implication symbol *)\n\nsearch min.\n(* By just the name of the operators. *)\n\n(*---- Exercises ----*)\n\n(* Distributivity *)\n(* Search for the appropriate axiom and apply it to discharge this goal. *)\nlemma int_distr (x y z: int): (x + y) * z = x * z + y * z.\nproof.\n    by apply mulrDr.\nqed.\n\n(*\nSo far, we saw lemmas without any assumptions \nexcept for that of the type of the variable in question.\nMore often than not we will have assumptions regarding variables.\nWe need to treat these assumptions as a given and introduce them into the context.\nThis is done by using \"move => ...\" followed by the name you want to give\nthe assumption.\n*)\n\nlemma x_pos (x: int): 0 <= x => 0 < x+1.\nproof.\n    move => x_ge0.\n    simplify.\n    trivial.\n    (* Both of those tactics don't work. We need something else here *)\n    (* Let us see if EC has something that we can use. *)\n    search (<) (+) (0) (=>).\n    rewrite addz_gt0.\n    (*\n    \"rewrite\" simply rewrites the pattern provided, so in our case it\n    rewrites our goal here (0 < x + 1), with the pattern that we provided\n    which is addz_gt0, and then requires us to prove the assumptions of\n    the pattern which are 0 < x and 0 < 1.\n    *)\n        (* Goal 1: 0 < x *)\n\n        (*\n        When we have a goal matches an assumption, we \n        can use the tactic assumption to discharge it.\n        *)\n        assumption.\n\n        (* Goal 2: 0 < 1 *)\n        trivial.\nqed.\n\n(* Let us see some variations *)\n\nlemma int_assoc_rev (x y: int) z: x + y + z = x + (y + z).\nproof.\n    print addzA.\n    (* \n    We might have a lemma or an axiom that we can apply to the goal,\n    but the LHS and RHS might be flipped, and EC will complain that\n    they don't match to apply them.\n    To rewrite a lemma or axiom in reverse, we simply add the \"-\" infront\n    of the lemma to switch the sides like so.\n    *)\n    rewrite -addzA.\n    trivial.\nqed.\n\n(*\nNote that here \"apply addzA.\" or \"apply -addzA\" do not work\nWe encourage you to try them.\n*)\n\n(*\nRecap:\nSo far we have seen the following tactics:\ntrivial, simplify, apply, rewrite,\nmove, split, left, right, admit, and assumption.\nWe also saw how to print and search for patterns.\nThese are at the foundation of how we work with EC.\n*)\n\n(*\nIntro to smt and external provers:\nAn important point to understand, however, is that EC\nwas built to work with cryptographic properties and more complex things.\nSo although other mathematical theorems and claims can be proven in EC,\nit will be quite painful to do so. We will employ powerful automated tools\nto take care of some of these low-level tactics and logic.\nEC offers this in the form of the \"smt\" tactic.\nWhen we run smt, EC sends the conclusion and the context to external smt solvers.\nIf they are able to solve the goal, then EC completes the proof.\nIf not smt fails and the burden of the proof is still on us.\n*)\n\nlemma x_pos_smt (x: int): 0 < x => 0 < x+1.\nproof.\nsmt.\nqed.\n\n(*\nAs you can see, smt can make our lives much easier.\nNow, here are some properties about logarithms that are mentioned in \nThe Joy of Cryptography. We leave them to be completed as exercises,\nwithout using the smt tactic. Most of them are straightforward and\nserve the purpose of exercising the use of basic tactics.\n*)\n\nrequire import AllCore.\n\n\n(* print AllCore to see what it includes *)\n\n(* Logs and exponents: *)\n\nlemma exp_product (x: real) (a b: int): x^(a*b) = x ^ a ^ b.\nproof.\n    search (^) (=).\n    by apply RField.exprM.\nqed.\n\nlemma exp_product2 (x: real) (a b: int): x <> 0%r => x^a * x^b = x^(a + b).\nproof.\n    move => x_pos.\n    search (^) (=).\n    print  RField.exprD.\n    rewrite -RField.exprD.\n    assumption.\n    trivial.\nqed.\n\n(* Logarithm exercises *)\nrequire import RealExp.\n\n(*\nPrint and search for \"ln\" to see how it is defined and\nthe results we have available already \n*)\nlemma ln_product (x y: real) : 0%r < x  => 0%r < y => ln (x*y) = ln x + ln y.\nproof.\n    search (ln) (+).\n    move => H1 H2.\n    by apply lnM.\nqed.\n\nprint log.\n(*\nNotice how log is defined. It is defined as an operator that expects two inputs\nSince most of ECs axioms are written for natural logs (ln), inorder to reason with\nlog and inorder to work with the next lemma, you will need to rewrite log.\nTo do so the syntax is\n\nrewrite /log.\n\nThe \"/\" will rewrite the pattern that follows.\n*)\n\n(*\nThis helper can come in handy in the next proof.\nSometimes it can be cumbersome to reason with a goal.\nIn cases like those, it is useful to reduce the complexity of the proof by using\nhelper lemmas like these.\n*)\n\nlemma helper (x y z: real): (x + y) / z = x/z + y/z.\nproof.\n  rewrite -/(x + y)/z.\n  smt.\nqed.\n\nlemma log_product (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    move => H1 H2.\n    rewrite /log.\n    rewrite lnM.\n    assumption.\n    assumption.\n    by apply helper.\nqed.\n\n(* Or we can simply let smt do the heavy lifting for us *)\nlemma log_product_smt (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    smt.\nqed.\n\n(*\nModulo arithmatic exercises:\nThis is one of the properties that is mentioned in the\n *)\nrequire import IntDiv.\n\nlemma mod_add (x y z: int): (x %% z + y %% z) %% z = (x + y) %% z.\nproof.\n    by apply modzDm.\nqed.\n\n(* \nA couple of more keystrokes that might be useful.\n\n1. C-c C-r: Begin evaluating from the start\n2. C-c C-b: Evaluate until the end of the file.\n\nGo ahead and give these a try.\n*)", "```ec\nint): x - 10 = x - 9 - 1.\nproof.\n    simplify.\n    trivial.\nqed.\n\n(*\nThe goal list in EC is an ordered one, and you have to prove them\nin the same order as EC lists it. \"admit\" can be used to bypass a certain \ngoal and focus on something else in the goal list.\n*)\n\n(*\nUse the tactic \"split\" to split the disjunction into two\nand apply the previous axioms to discharge the goals.\nExperiment with admiting the first goal after splitting\n*)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\n  split.\n  by apply addzA.\n  by apply addzC.\nqed.\n\n(*\nTo deal with disjunctions in EC, you can use the tactics \"left\" or \"right\"\nto step into a proof of the left proof term, or the right proof term respectively.\n*)\n\n(* Searching in EC *)\n\n(*\nSince, there is a lot that is already done in EC,\nwe need a way to look for things. \nWe do that using the \"search\" command. It prints out all axioms and lemmas \ninvolving the list of operators that give it.\n*)\n\nsearch [-].\n(* [] - Square braces for unary operators  *)\n\nsearch (+).\n\n(*\nAs you can see the list can be quite overwhelming and difficult to navigate.\nSo we can limit the results using a list of operators, or patterns.\n*)\n\nsearch ( * ).\n(*\n() - Parentheses for binary operators. \nNotice the extra space for the \"*\" operator.\nWe need that since (* *) also indicates comments.\n*)\n\nsearch (+) (=) (=>).\n(* List of operators \"=>\" is the implication symbol *)\n\nsearch min.\n(* By just the name of the operators. *)\n\n(*---- Exercises ----*)\n\n(* Distributivity *)\n(* Search for the appropriate axiom and apply it to discharge this goal. *)\nlemma int_distr (x y z: int): (x + y) * z = x * z + y * z.\nproof.\n    by apply mulrDr.\nqed.\n\n(*\nSo far, we saw lemmas without any assumptions \nexcept for that of the type of the variable in question.\nMore often than not we will have assumptions regarding variables.\nWe need to treat these assumptions as a given and introduce them into the context.\nThis is done by using \"move => ...\" followed by the name you want to give\nthe assumption.\n*)\n\nlemma x_pos (x: int): 0 <= x => 0 < x+1.\nproof.\n    move => x_ge0.\n    simplify.\n    trivial.\n    (* Both of those tactics don't work. We need something else here *)\n    (* Let us see if EC has something that we can use. *)\n    search (<) (+) (0) (=>).\n    rewrite addz_gt0.\n    (*\n    \"rewrite\" simply rewrites the pattern provided, so in our case it\n    rewrites our goal here (0 < x + 1), with the pattern that we provided\n    which is addz_gt0, and then requires us to prove the assumptions of\n    the pattern which are 0 < x and 0 < 1.\n    *)\n        (* Goal 1: 0 < x *)\n\n        (*\n        When we have a goal matches an assumption, we \n        can use the tactic assumption to discharge it.\n        *)\n        assumption.\n\n        (* Goal 2: 0 < 1 *)\n        trivial.\nqed.\n\n(* Let us see some variations *)\n\nlemma int_assoc_rev (x y: int) z: x + y + z = x + (y + z).\nproof.\n    print addzA.\n    (* \n    We might have a lemma or an axiom that we can apply to the goal,\n    but the LHS and RHS might be flipped, and EC will complain that\n    they don't match to apply them.\n    To rewrite a lemma or axiom in reverse, we simply add the \"-\" infront\n    of the lemma to switch the sides like so.\n    *)\n    rewrite -addzA.\n    trivial.\nqed.\n\n(*\nNote that here \"apply addzA.\" or \"apply -addzA\" do not work\nWe encourage you to try them.\n*)\n\n(*\nRecap:\nSo far we have seen the following tactics:\ntrivial, simplify, apply, rewrite,\nmove, split, left, right, admit, and assumption.\nWe also saw how to print and search for patterns.\nThese are at the foundation of how we work with EC.\n*)\n\n(*\nIntro to smt and external provers:\nAn important point to understand, however, is that EC\nwas built to work with cryptographic properties and more complex things.\nSo although other mathematical theorems and claims can be proven in EC,\nit will be quite painful to do so. We will employ powerful automated tools\nto take care of some of these low-level tactics and logic.\nEC offers this in the form of the \"smt\" tactic.\nWhen we run smt, EC sends the conclusion and the context to external smt solvers.\nIf they are able to solve the goal, then EC completes the proof.\nIf not smt fails and the burden of the proof is still on us.\n*)\n\nlemma x_pos_smt (x: int): 0 < x => 0 < x+1.\nproof.\nsmt.\nqed.\n\n(*\nAs you can see, smt can make our lives much easier.\nNow, here are some properties about logarithms that are mentioned in \nThe Joy of Cryptography. We leave them to be completed as exercises,\nwithout using the smt tactic. Most of them are straightforward and\nserve the purpose of exercising the use of basic tactics.\n*)\n\nrequire import AllCore.\n\n\n(* print AllCore to see what it includes *)\n\n(* Logs and exponents: *)\n\nlemma exp_product (x: real) (a b: int): x^(a*b) = x ^ a ^ b.\nproof.\n    search (^) (=).\n    by apply RField.exprM.\nqed.\n\nlemma exp_product2 (x: real) (a b: int): x <> 0%r => x^a * x^b = x^(a + b).\nproof.\n    move => x_pos.\n    search (^) (=).\n    print  RField.exprD.\n    rewrite -RField.exprD.\n    assumption.\n    trivial.\nqed.\n\n(* Logarithm exercises *)\nrequire import RealExp.\n\n(*\nPrint and search for \"ln\" to see how it is defined and\nthe results we have available already \n*)\nlemma ln_product (x y: real) : 0%r < x  => 0%r < y => ln (x*y) = ln x + ln y.\nproof.\n    search (ln) (+).\n    move => H1 H2.\n    by apply lnM.\nqed.\n\nprint log.\n(*\nNotice how log is defined. It is defined as an operator that expects two inputs\nSince most of ECs axioms are written for natural logs (ln), inorder to reason with\nlog and inorder to work with the next lemma, you will need to rewrite log.\nTo do so the syntax is\n\nrewrite /log.\n\nThe \"/\" will rewrite the pattern that follows.\n*)\n\n(*\nThis helper can come in handy in the next proof.\nSometimes it can be cumbersome to reason with a goal.\nIn cases like those, it is useful to reduce the complexity of the proof by using\nhelper lemmas like these.\n*)\n\nlemma helper (x y z: real): (x + y) / z = x/z + y/z.\nproof.\n  rewrite -/(x + y)/z.\n  smt.\nqed.\n\nlemma log_product (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    move => H1 H2.\n    rewrite /log.\n    rewrite lnM.\n    assumption.\n    assumption.\n    by apply helper.\nqed.\n\n(* Or we can simply let smt do the heavy lifting for us *)\nlemma log_product_smt (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    smt.\nqed.\n\n(*\nModulo arithmatic exercises:\nThis is one of the properties that is mentioned in the\n *)\nrequire import IntDiv.\n\nlemma mod_add (x y z: int): (x %% z + y %% z) %% z = (x + y) %% z.\nproof.\n    by apply modzDm.\nqed.\n\n(* \nA couple of more keystrokes that might be useful.\n\n1. C-c C-r: Begin evaluating from the start\n2. C-c C-b: Evaluate until the end of the file.\n\nGo ahead and give these a try.\n*)\n```"]], "EC-1/asgncase.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[M.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y = 1).\n- by auto.\n- by auto.\nqed.", "To complete the given EasyCrypt code, let's analyze the provided description and identify the missing part indicated by `____(LEMMA_0)____`.\n\nThe description outlines a module `M` with a procedure `f` that takes two integers and returns them as a tuple. The lemma `L` is a Hoare logic statement that asserts if `f` is called with arguments `(0, 1)`, it will return `(0, 1)`.\n\nThe given code is:\n```easycrypt\n(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[____(LEMMA_0)____.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y = 1).\n- by auto.\n- by auto.\nqed.\n```\n\nThe missing part is `____(LEMMA_0)____`, which should be replaced with the module name where the procedure `f` is defined, i.e., `M`.\n\nThus, the completed code should be:\n\n```ec\n(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[M.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y = 1).\n- by auto.\n- by auto.\nqed.\n```"]], "EC-1/adversary.ec": [[true, "require import AllCore List StdOrder Distr Real Int RealExp.\n(*---*) import RealOrder.\nrequire import Xreal RealSeries.\n(*---*) import StdBigop.Bigreal.\n\ntype r.\nop [lossless] dr : r distr.\n\nop test : r -> bool.\n\nop p = mu dr test.\naxiom dr_mu_test : 0%r < p.\n\nop eps : real.\naxiom dr_mu1 : forall (x:r), mu1 dr x <= eps.\n\nlemma eps_ge0: 0%r <= eps. by smt(dr_mu1 mu_bounded). qed.\n\nmodule type Oracle = { \n  proc o () : unit \n}.\n\nmodule type Adv (O:Oracle) = {\n  proc adv () : unit\n}.\n\nop Q : int.\naxiom Q_nneg : 0 <= Q.\n\nmodule O = {\n\n  var c : int \n  var log : r list\n  var bad : bool\n\n  proc extend_log () = {\n    var t, r;\n    t <- false;\n    while (!t) {\n      r <$ dr;\n      log <- r :: log;\n      t <- test r; \n    }\n  }\n\n  proc o () = {\n    var r;\n    c <- c + 1;\n    extend_log ();\n    if (c = Q) {\n      r <$ dr;\n      bad <- r \\in log;\n    }\n  }\n}.\n\nmodule Main(A:Adv) = {\n  proc main () = {\n    O.bad <- false;\n    O.c <- 0;\n    O.log <- [];\n    A(O).adv();\n  }\n}.\n\n(* extend-log increases log on average by 1/p *)\nehoare extend_log_size : O.extend_log : (inv p)%xr + (size O.log)%xr ==> (size O.log)%xr.\nproof.\n  proc.\n  while ((b2r (!t) / p)%xr + (size O.log)%xr).\n  + move => &hr; apply xle_cxr_r => |>.\n  + wp; skip; move => &hr; move: (t{hr}) (O.log{hr}) => {&hr} t log; apply xle_cxr_r => ntest.\n    rewrite ntest => /=.\n    rewrite (eq_Ep _ _\n       ((fun r => (inv p)%xr * (! test r)%xr) + (fun r => (1 + size log)%xr))).\n    + move => x xx /=. rewrite of_realM; 1,2:smt(of_realM invr_ge0 ge0_mu). smt().\n    rewrite EpD EpC EpZ /=; 1: smt(invr_gt0 dr_mu_test of_realdK).\n    rewrite Ep_mu mu_not dr_ll /= -/p.\n    rewrite !to_pos_pos; 1,2,3,4:smt(mu_bounded dr_mu_test size_ge0).\n  by auto.\nqed.\n\nehoare o_bad : O.o:\n    (O.bad => Q <= O.c) `|` if Q <= O.c then O.bad%xr else  (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr\n    ==> (O.bad => Q <= O.c)  `|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr.\nproof.\n  proc.\n  wp.\n  call /(fun x => (O.bad => Q <= O.c)\n          `|` if Q < O.c then O.bad%xr else x * eps%xr + (Q - O.c)%xr * (eps/p)%xr) extend_log_size.\n  + auto => &hr /=.\n    case: (O.c{hr} = Q) => [ -> /= | *].\n    + rewrite Ep_mu (:(fun (a : r) => a \\in O.log{hr}) = mem O.log{hr}); 1: by auto.\n      rewrite -of_realM /=; smt(mu_mem_le_mu1 size_ge0 eps_ge0 dr_mu1).\n    case: (Q < O.c{hr}); by smt().\n  auto => &hr /=; apply xle_cxr => *; split; 1:smt().\n  have -> /=: (Q < O.c{hr} + 1) = (Q <= O.c{hr}) by smt().\n  case (Q <= O.c{hr}); 1:smt().\n  by smt(of_realM of_realD dr_mu_test).\nqed.\n\nlemma pr_bad &m (A<:Adv{-O}) : Pr[Main(A).main() @ &m : O.bad] <= eps * Q%r * (inv p).\n  byehoare.\n  + proc.\n    call (: (O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr ==> O.bad%xr).\n    + proc ((O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr).\n      + move => &hr; apply xle_cxr => *; split; 1:smt(). by auto.\n      + move => &hr; apply xle_cxr_r => *.\n        by case: (O.bad{hr}) => [ /# |*]; smt(xle0x).\n      by apply o_bad.\n    by wp; auto; move => *; case (Q <= 0); smt(xle0x).\n  + auto.\n  auto.\nqed.", "```ec\nrequire import AllCore List StdOrder Distr Real Int RealExp.\n(*---*) import RealOrder.\nrequire import Xreal RealSeries.\n(*---*) import StdBigop.Bigreal.\n\ntype r.\nop [lossless] dr : r distr.\n\nop test : r -> bool.\n\nop p = mu dr test.\naxiom dr_mu_test : 0%r < p.\n\nop eps : real.\naxiom dr_mu1 : forall (x:r), mu1 dr x <= eps.\n\nlemma eps_ge0: 0%r <= eps. by smt(dr_mu1 mu_bounded). qed.\n\nmodule type Oracle = { \n  proc o () : unit \n}.\n\nmodule type Adv (O:Oracle) = {\n  proc adv () : unit\n}.\n\nop Q : int.\naxiom Q_nneg : 0 <= Q.\n\nmodule O = {\n\n  var c : int \n  var log : r list\n  var bad : bool\n\n  proc extend_log () = {\n    var t, r;\n    t <- false;\n    while (!t) {\n      r <$ dr;\n      log <- r :: log;\n      t <- test r; \n    }\n  }\n\n  proc o () = {\n    var r;\n    c <- c + 1;\n    extend_log ();\n    if (c = Q) {\n      r <$ dr;\n      bad <- r \\in log;\n    }\n  }\n}.\n\nmodule Main(A:Adv) = {\n  proc main () = {\n    O.bad <- false;\n    O.c <- 0;\n    O.log <- [];\n    A(O).adv();\n  }\n}.\n\n(* extend-log increases log on average by 1/p *)\nehoare extend_log_size : O.extend_log : (inv p)%xr + (size O.log)%xr ==> (size O.log)%xr.\nproof.\n  proc.\n  while ((b2r (!t) / p)%xr + (size O.log)%xr).\n  + move => &hr; apply xle_cxr_r => |>.\n  + wp; skip; move => &hr; move: (t{hr}) (O.log{hr}) => {&hr} t log; apply xle_cxr_r => ntest.\n    rewrite ntest => /=.\n    rewrite (eq_Ep _ _\n       ((fun r => (inv p)%xr * (! test r)%xr) + (fun r => (1 + size log)%xr))).\n    + move => x xx /=. rewrite of_realM; 1,2:smt(of_realM invr_ge0 ge0_mu). smt().\n    rewrite EpD EpC EpZ /=; 1: smt(invr_gt0 dr_mu_test of_realdK).\n    rewrite Ep_mu mu_not dr_ll /= -/p.\n    rewrite !to_pos_pos; 1,2,3,4:smt(mu_bounded dr_mu_test size_ge0).\n  by auto.\nqed.\n\nehoare o_bad : O.o:\n    (O.bad => Q <= O.c) `|` if Q <= O.c then O.bad%xr else  (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr\n    ==> (O.bad => Q <= O.c)  `|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr.\nproof.\n  proc.\n  wp.\n  call /(fun x => (O.bad => Q <= O.c)\n          `|` if Q < O.c then O.bad%xr else x * eps%xr + (Q - O.c)%xr * (eps/p)%xr) extend_log_size.\n  + auto => &hr /=.\n    case: (O.c{hr} = Q) => [ -> /= | *].\n    + rewrite Ep_mu (:(fun (a : r) => a \\in O.log{hr}) = mem O.log{hr}); 1: by auto.\n      rewrite -of_realM /=; smt(mu_mem_le_mu1 size_ge0 eps_ge0 dr_mu1).\n    case: (Q < O.c{hr}); by smt().\n  auto => &hr /=; apply xle_cxr => *; split; 1:smt().\n  have -> /=: (Q < O.c{hr} + 1) = (Q <= O.c{hr}) by smt().\n  case (Q <= O.c{hr}); 1:smt().\n  by smt(of_realM of_realD dr_mu_test).\nqed.\n\nlemma pr_bad &m (A<:Adv{-O}) : Pr[Main(A).main() @ &m : O.bad] <= eps * Q%r * (inv p).\n  byehoare.\n  + proc.\n    call (: (O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr ==> O.bad%xr).\n    + proc ((O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr).\n      + move => &hr; apply xle_cxr => *; split; 1:smt(). by auto.\n      + move => &hr; apply xle_cxr_r => *.\n        by case: (O.bad{hr}) => [ /# |*]; smt(xle0x).\n      by apply o_bad.\n    by wp; auto; move => *; case (Q <= 0); smt(xle0x).\n  + auto.\n  auto.\nqed.\n```"]], "EC-1/ArrayFiniteness.ec": [[false, "```ec\nrequire import AllCore List.\n\nrequire import WArray256.\nrequire import JModel.\n\nop all_8lists = alltuples 8"]], "EC-1/AuxLemmas.ec": [[false, "```ec\nrequire import AllCore Distr Finite List.\n\n(* Importing necessary modules for bit encoding and word operations *)\nrequire import BitEncoding.\nimport BS2Int.\n\n(* Importing the JWord module *)\nrequire import JWord.\n\n(* Defining a module named Skip with a procedure run that does nothing *)\nmodule Skip = {\n  proc run() = {}\n}.\n\n(* Proving a lemma about the probability of Skip.run() returning true *)\nlemma skip_run &m : Pr"]], "EC-1/AuxResults.ec": [[true, "F2 : 'a -> real) (s : 'a list),\n    big P0 (fun (i : 'a) => F1 i - F2 i) s = big P0 F1 s - big P0 F2 s.\nproof.  progress.\nhave ->:  - big P0 F2 s\n =  (big P0 (fun x => - (F2 x) ) s).\napply (big_ind2 (fun (x : real) y => (- x) = y) ) .\nsmt(). smt().\nprogress.\napply big_split.\nqed.\n\n\nlemma multn p  : 0%r <= p <= 1%r => forall n, 0 <= n => 0%r <= p^n <= 1%r.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. smt(@Real).\nsmt(@Real).\nqed.\n\n\nlemma multn2 (p q : real)  :  0%r <= p <= q => forall n, 0 <= n => p^n <= q^n.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. \nhave ->: p ^ (n + 1) = p * p^n. smt(@Real).\nhave ->: q ^ (n + 1) = q * q^n. smt(@Real).\nsmt(@RealExp).\nqed.\n\n\nlemma big_geq0 p  : 0%r <= p <= 1%r => forall n, \n 0%r <= bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt (multn).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma big_leq1 p  : 0%r <= p <= 1%r => forall n, \n bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n <= 1%r.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt(@RealExp).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma djoinmap_weight (d : 'a -> 'b distr) :  forall l,\n  (forall x, is_lossless (d x)) =>\n    weight (djoinmap d l) = 1%r.\nelim. smt (weight_djoin_nil).\nsmt (weight_djoin_cons).\nqed.\n\n\nlemma sub_all ['a]:\n   forall (p1 p2 : 'a -> bool) (s : 'a list),\n     (forall (x : 'a), p1 x => p2 x) => all p1 s => all p2 s.\nmove => p1 p2.  elim. smt().\nsmt().\nqed.\n\n\nlemma take_zip ['a 'b] : \n   forall  (n :  int) (l1 : 'a list)(l2 : 'b list),\n   zip (take n l1) (take n l2) \n  = take n (zip l1 l2).\napply ge0ind. smt().\nsmt().\nprogress.\ncase (l1 = []).\nsmt().\nprogress.\nhave f1 : exists a1 l1', l1 = (a1 :: l1').\nclear H0 H.  \nexists (head witness l1) (behead l1).\nsmt().\nelim f1.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify.\ncase (l2 = []).\nsmt().\nprogress. \nhave f2 : exists a2 l2', l2 = (a2 :: l2').\nexists (head witness l2) (behead l2).\nsmt().\nelim f2.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify. smt().\nqed.\n\n\nlemma ler_trans1 (a b c : real) : a <= b => b <= c => a <= c. by smt().\nqed.\n\n\nsection.\nlocal lemma oip1 (a b c eps : real) :  (0%r <= eps) =>\n  `|a / b - c| <= eps\n => exists (p : real), 0%r <= p <= eps  /\\ `|a / b - c| = p.\nsmt().\nqed.\n\n\nlocal lemma oip2 (a b c p : real) :  \n  (0%r < b) =>\n  `|a / b - c| = p =>\n      a = b * c - b * p \\/  a = b * c + b * p.\nsmt().\nqed.\n\n\nlocal lemma oip2b (a b c p : real) :  \n  (0%r < b) =>\n  (0%r <= p) =>\n      a = b * c - b * p \\/  a = b * c + b * p\n   =>   `|a / b - c| = p.\nsmt(@Real).\nqed.\n\n\nlocal lemma ots' (a c : real) : \n  (0%r <= a) =>\n  (0%r <= c <= 1%r) =>\n  a * c  <= a.\nproof. smt(). qed.\n\n\nlemma abs_val_ineq1 (a b c e : real) : \n  (0%r <= b <= 1%r) =>\n  (0%r <= c <= 1%r) =>\n  `|a - c * b| <= e\n    => `|a - b| <= e + (1%r-c).\nprogress.\nhave f : b = c * b + (1%r-c)*b. smt().\n    + case (a <= c * b). \n    move => H8.\n    have f2: c * b - a <= e. smt().\n    have f22 : c * b - a >= 0%r. smt().\n    have f3: c * b - a + (1%r - c)*b <= e + (1%r - c)*b.\n    smt().  \n    have f33 : c * b - a + (1%r - c)*b >= 0%r. smt().\n    have f4: b - a <= e + (1%r - c)*b.\n    smt().\n    have f5: b - a <= e + (1%r - c).\n    smt(@RealExp).\n    have f44: b - a >= 0%r.\n    smt().\n    smt().\n + move => H8.\nhave : c*b <= a. smt().\nclear H8. move => H8.\nhave f1 : a - c * b <= e. smt().\nhave f2: c * b - a + (1%r - c)*b <= e + (1%r - c)*b. smt().\nhave f3: b - a  <= e + (1%r - c)*b. smt().\nhave f4: b - a  <= e + (1%r - c). smt(ots').\nsmt().\nqed.\n\n\nlemma abs_val_ineq2 (a b c eps : real) :  (0%r < b) => (0%r <= eps) =>\n  `|a / b - c| <= eps => \n  exists (p : real),  0%r <= p <= eps  \n  /\\ `|a / b - c| = p \n  /\\ (a = b * (c - p) \\/  a = b * (c + p)).\nsmt (oip1 oip2).\nqed.\n\n\nlemma abs_val_ineq3 (a c p : real) :  \n  (0%r <= p) =>\n   a = c - p \\/  a = c + p\n   => `|a - c| = p.\nsmt().\nqed.\nend section.\n\nlemma aux_lem : forall l n,  \n  size l = n =>\n  nseq n true <> l  =>\n  false \\in l.\nelim. smt(@List). smt(@List).\nqed.\n\n\nsection.\nlocal lemma kiki2 ['a] : forall (l : 'a list), \n  unzip1 (map (fun (x : 'a) => (x, x)) l) = l.\nelim. smt(). smt().\nqed.\n\n\nlocal lemma kiki3 ['a] x :  forall (l : 'a list), uniq l => !(x \\in l) =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = [].\nelim. smt().\nprogress. \nsmt().\nqed.\n\n\nlocal lemma kiki4 ['a] x :  forall (l : 'a list), uniq l => x \\in l =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = (x, x) :: [].\nelim. smt().\nmove => y H2 H3 H4 H5. \ncase (x = y).\nmove => H6. rewrite H6. simplify.\n have f : !(x \\in H2). smt().\napply  (kiki3 y). smt(). smt().\nmove => q. rewrite q. simplify. apply H3. smt(). smt().\nqed.\n\n\nlocal lemma kiki0 ['a] : forall (l1 l2 : 'a list), size l1 <= size l2 => uniq l1 => uniq l2 => (forall x, x \\in l1 => x \\in l2) =>\n  (filter (fun x => fst x = snd x) (allpairs (fun (c1 c2 : 'a) => (c1, c2)) l1 l2)) = map (fun x => (x , x)) l1 .\nproof. elim. smt().\nprogress.\nrewrite allpairs_consl. simplify.\nrewrite filter_cat. \nrewrite  (kiki4 x). auto. smt(). simplify.\nsmt (filter_cat kiki4).\nqed.\n\n\nlemma cart2_diag_unzip1 ['a] (l : 'a list) : uniq l =>\n  unzip1 (filter (fun x => fst x = snd x) ((allpairs (fun x y => (x,y))) l l)) = l.\nmove => q.\nrewrite /cartprod2.  rewrite kiki0;auto.\nrewrite kiki2. auto. \nqed.\nend section.\n\n\n\n\ntheory Splitcases.\n\nrequire import Finite.\nrequire MeansWithParameter.\ntype input.\n\nsection.\nclone import MeansWithParameter with type argt <- input,\n                                           type output <- bool,\n                                           type input <- bool,\n                                           op dft <- duniform [true; false].\n\n\nlemma splitcases:\n  forall (T <: Worker) &m (x : input),\n    Pr[Rand(T).main(x) @ &m : res.`2] =\n    Pr[T.work(x,false) @ &m : res] / 2%r +\n    Pr[T.work(x,true) @ &m : res] / 2%r.\nprogress.\nrewrite (Mean_uni T &m (fun _ _ x => x) (1%r/2%r)). progress. \nrewrite duniform1E. smt().\nsmt(@Finite).\nprogress. simplify.\nhave ->: (support (duniform [true; false])) = (fun x => true). smt(@Distr).\npose lst := (to_seq (fun _ => true)).\nhave f1 :  false \\in lst. smt(@Finite @Distr).\nhave f2 :  true \\in lst . smt(@Finite @Distr).\nhave f3 : size lst = 2. rewrite /lst.\nrewrite -  Bool.BoolFin.count_mem.\napply uniq_to_seq.  rewrite /is_finite.\nexists [false; true]. progress. smt(). simplify. smt().\nauto.\nhave f4 : forall (l : bool list), false \\in l => true \\in l => size l = 2 => l = [false ; true] \\/ l = [true ; false]. \nelim. smt(). move => x0. elim.  progress. move => x1. elim. smt().\nprogress. smt(@List).\nhave f5 : lst = [false;  true] \\/ lst = [true ; false].  smt().\ncase (lst = [false; true]). move => z. rewrite z.\nsmt().\nprogress. have ->: lst = [true ; false]. smt().\nsmt().\nqed.\nend section.\nend Splitcases.", "```ec\nF2 : 'a -> real) (s : 'a list),\n    big P0 (fun (i : 'a) => F1 i - F2 i) s = big P0 F1 s - big P0 F2 s.\nproof.  progress.\nhave ->:  - big P0 F2 s\n =  (big P0 (fun x => - (F2 x) ) s).\napply (big_ind2 (fun (x : real) y => (- x) = y) ) .\nsmt(). smt().\nprogress.\napply big_split.\nqed.\n\n\nlemma multn p  : 0%r <= p <= 1%r => forall n, 0 <= n => 0%r <= p^n <= 1%r.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. smt(@Real).\nsmt(@Real).\nqed.\n\n\nlemma multn2 (p q : real)  :  0%r <= p <= q => forall n, 0 <= n => p^n <= q^n.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. \nhave ->: p ^ (n + 1) = p * p^n. smt(@Real).\nhave ->: q ^ (n + 1) = q * q^n. smt(@Real).\nsmt(@RealExp).\nqed.\n\n\nlemma big_geq0 p  : 0%r <= p <= 1%r => forall n, \n 0%r <= bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt (multn).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma big_leq1 p  : 0%r <= p <= 1%r => forall n, \n bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n <= 1%r.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt(@RealExp).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma djoinmap_weight (d : 'a -> 'b distr) :  forall l,\n  (forall x, is_lossless (d x)) =>\n    weight (djoinmap d l) = 1%r.\nelim. smt (weight_djoin_nil).\nsmt (weight_djoin_cons).\nqed.\n\n\nlemma sub_all ['a]:\n   forall (p1 p2 : 'a -> bool) (s : 'a list),\n     (forall (x : 'a), p1 x => p2 x) => all p1 s => all p2 s.\nmove => p1 p2.  elim. smt().\nsmt().\nqed.\n\n\nlemma take_zip ['a 'b] : \n   forall  (n :  int) (l1 : 'a list)(l2 : 'b list),\n   zip (take n l1) (take n l2) \n  = take n (zip l1 l2).\napply ge0ind. smt().\nsmt().\nprogress.\ncase (l1 = []).\nsmt().\nprogress.\nhave f1 : exists a1 l1', l1 = (a1 :: l1').\nclear H0 H.  \nexists (head witness l1) (behead l1).\nsmt().\nelim f1.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify.\ncase (l2 = []).\nsmt().\nprogress. \nhave f2 : exists a2 l2', l2 = (a2 :: l2').\nexists (head witness l2) (behead l2).\nsmt().\nelim f2.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify. smt().\nqed.\n\n\nlemma ler_trans1 (a b c : real) : a <= b => b <= c => a <= c. by smt().\nqed.\n\n\nsection.\nlocal lemma oip1 (a b c eps : real) :  (0%r <= eps) =>\n  `|a / b - c| <= eps\n => exists (p : real), 0%r <= p <= eps  /\\ `|a / b - c| = p.\nsmt().\nqed.\n\n\nlocal lemma oip2 (a b c p : real) :  \n  (0%r < b) =>\n  `|a / b - c| = p =>\n      a = b * c - b * p \\/  a = b * c + b * p.\nsmt().\nqed.\n\n\nlocal lemma oip2b (a b c p : real) :  \n  (0%r < b) =>\n  (0%r <= p) =>\n      a = b * c - b * p \\/  a = b * c + b * p\n   =>   `|a / b - c| = p.\nsmt(@Real).\nqed.\n\n\nlocal lemma ots' (a c : real) : \n  (0%r <= a) =>\n  (0%r <= c <= 1%r) =>\n  a * c  <= a.\nproof. smt(). qed.\n\n\nlemma abs_val_ineq1 (a b c e : real) : \n  (0%r <= b <= 1%r) =>\n  (0%r <= c <= 1%r) =>\n  `|a - c * b| <= e\n    => `|a - b| <= e + (1%r-c).\nprogress.\nhave f : b = c * b + (1%r-c)*b. smt().\n    + case (a <= c * b). \n    move => H8.\n    have f2: c * b - a <= e. smt().\n    have f22 : c * b - a >= 0%r. smt().\n    have f3: c * b - a + (1%r - c)*b <= e + (1%r - c)*b.\n    smt().  \n    have f33 : c * b - a + (1%r - c)*b >= 0%r. smt().\n    have f4: b - a <= e + (1%r - c)*b.\n    smt().\n    have f5: b - a <= e + (1%r - c).\n    smt(@RealExp).\n    have f44: b - a >= 0%r.\n    smt().\n    smt().\n + move => H8.\nhave : c*b <= a. smt().\nclear H8. move => H8.\nhave f1 : a - c * b <= e. smt().\nhave f2: c * b - a + (1%r - c)*b <= e + (1%r - c)*b. smt().\nhave f3: b - a  <= e + (1%r - c)*b. smt().\nhave f4: b - a  <= e + (1%r - c). smt(ots').\nsmt().\nqed.\n\n\nlemma abs_val_ineq2 (a b c eps : real) :  (0%r < b) => (0%r <= eps) =>\n  `|a / b - c| <= eps => \n  exists (p : real),  0%r <= p <= eps  \n  /\\ `|a / b - c| = p \n  /\\ (a = b * (c - p) \\/  a = b * (c + p)).\nsmt (oip1 oip2).\nqed.\n\n\nlemma abs_val_ineq3 (a c p : real) :  \n  (0%r <= p) =>\n   a = c - p \\/  a = c + p\n   => `|a - c| = p.\nsmt().\nqed.\nend section.\n\nlemma aux_lem : forall l n,  \n  size l = n =>\n  nseq n true <> l  =>\n  false \\in l.\nelim. smt(@List). smt(@List).\nqed.\n\n\nsection.\nlocal lemma kiki2 ['a] : forall (l : 'a list), \n  unzip1 (map (fun (x : 'a) => (x, x)) l) = l.\nelim. smt(). smt().\nqed.\n\n\nlocal lemma kiki3 ['a] x :  forall (l : 'a list), uniq l => !(x \\in l) =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = [].\nelim. smt().\nprogress. \nsmt().\nqed.\n\n\nlocal lemma kiki4 ['a] x :  forall (l : 'a list), uniq l => x \\in l =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = (x, x) :: [].\nelim. smt().\nmove => y H2 H3 H4 H5. \ncase (x = y).\nmove => H6. rewrite H6. simplify.\n have f : !(x \\in H2). smt().\napply  (kiki3 y). smt(). smt().\nmove => q. rewrite q. simplify. apply H3. smt(). smt().\nqed.\n\n\nlocal lemma kiki0 ['a] : forall (l1 l2 : 'a list), size l1 <= size l2 => uniq l1 => uniq l2 => (forall x, x \\in l1 => x \\in l2) =>\n  (filter (fun x => fst x = snd x) (allpairs (fun (c1 c2 : 'a) => (c1, c2)) l1 l2)) = map (fun x => (x , x)) l1 .\nproof. elim. smt().\nprogress.\nrewrite allpairs_consl. simplify.\nrewrite filter_cat. \nrewrite  (kiki4 x). auto. smt(). simplify.\nsmt (filter_cat kiki4).\nqed.\n\n\nlemma cart2_diag_unzip1 ['a] (l : 'a list) : uniq l =>\n  unzip1 (filter (fun x => fst x = snd x) ((allpairs (fun x y => (x,y))) l l)) = l.\nmove => q.\nrewrite /cartprod2.  rewrite kiki0;auto.\nrewrite kiki2. auto. \nqed.\nend section.\n\n\n\n\ntheory Splitcases.\n\nrequire import Finite.\nrequire MeansWithParameter.\ntype input.\n\nsection.\nclone import MeansWithParameter with type argt <- input,\n                                           type output <- bool,\n                                           type input <- bool,\n                                           op dft <- duniform [true; false].\n\n\nlemma splitcases:\n  forall (T <: Worker) &m (x : input),\n    Pr[Rand(T).main(x) @ &m : res.`2] =\n    Pr[T.work(x,false) @ &m : res] / 2%r +\n    Pr[T.work(x,true) @ &m : res] / 2%r.\nprogress.\nrewrite (Mean_uni T &m (fun _ _ x => x) (1%r/2%r)). progress. \nrewrite duniform1E. smt().\nsmt(@Finite).\nprogress. simplify.\nhave ->: (support (duniform [true; false])) = (fun x => true). smt(@Distr).\npose lst := (to_seq (fun _ => true)).\nhave f1 :  false \\in lst. smt(@Finite @Distr).\nhave f2 :  true \\in lst . smt(@Finite @Distr).\nhave f3 : size lst = 2. rewrite /lst.\nrewrite -  Bool.BoolFin.count_mem.\napply uniq_to_seq.  rewrite /is_finite.\nexists [false; true]. progress. smt(). simplify. smt().\nauto.\nhave f4 : forall (l : bool list), false \\in l => true \\in l => size l = 2 => l = [false ; true] \\/ l = [true ; false]. \nelim. smt(). move => x0. elim.  progress. move => x1. elim. smt().\nprogress. smt(@List).\nhave f5 : lst = [false;  true] \\/ lst = [true ; false].  smt().\ncase (lst = [false; true]). move => z. rewrite z.\nsmt().\nprogress. have ->: lst = [true ; false]. smt().\nsmt().\nqed.\nend section.\nend Splitcases.\n```"]], "EC-1/BarrettRedInt.ec": [[false, "```ec\nrequire import RealExp CoreReal Real StdOrder.\n\nimport RealOrder.\n\nop r(n k : real) : real = (floor (4%r^k  / n))%r .\nop t' (x n k : real) = (floor (x * r n k / 4%r^k))%r.\nop t (x n k : real)  : real = x - (t' x n k) * n.\n\nlemma r_pos n (k : real): \n   0%r <= n < 2%r^k =>\n  r n k >= 0%r. rewrite /r. move => Q. smt(@Real @RealExp).  qed.\n\n  \nlemma nn_bound n (k : real) : \n  0%r <= n < 2%r^k =>\n  n*n < 4%r^k. \n  have -> : 4%r = 2%r ^ 2%r. smt(@RealExp).\n  have -> : 2%r ^ 2%r ^ k = (2%r ^ k) * (2%r ^ k). smt(@RealExp).\n  smt().\nqed.  \n\n\nlemma st1 n (k : real) : (4%r^k / n - 1%r) < r n k <= (4%r^k / n).\nsmt(floor_bound @RealExp).\nqed.\n\n\nlemma st2 x n (k : real) : x >= 0%r =>\n 0%r <= n < 2%r^k =>\n  x * (4%r^k / n - 1%r) <= x * r n k <= x* (4%r^k / n).\nmove => x_pos"]], "EC-1/ASPSemantics.ec": [[true, "(** Abstract class for single party semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The single pary semantics class is parameterised by a language and\n  should establish how programs written in that language\n  are animated.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of requesting the execution\n  of one program statement at a time. The semantics also contemplates \n  the possiblity some side information being leaked by language instructions.\n*)\ntheory SinglePartySemantics.\n\n  (** Language *)\n  clone import Language.\n\n  (** Side information *)\n  type sideInfo_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [step] - sequential semantics procedures, that executes one\n      instruction of the program.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P : L) : unit\n    proc step() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n        - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type output_event_t = secret_t.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc step(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    proc init = Sem.init\n    proc setInput(x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P : L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend SinglePartySemantics.", "To complete the given file, we need to identify the missing type and fill in the blank accordingly. The description provides a comprehensive overview of the `SinglePartySemantics` protocol, including its key components and their functionalities.\n\nUpon examining the provided incomplete code, the blank is in the line where the `output_event_t` type is defined. The description indicates that `output_event_t` represents events generated as output from the program execution.\n\nGiven the context, the `output_event_t` should be defined as a type that represents the output of the program. Since the protocol involves handling `secret_t` as input and output, it is reasonable to infer that `output_event_t` could be related to `secret_t`.\n\nHere's the completed code:\n\n```ec\n(** Abstract class for single party semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The single pary semantics class is parameterised by a language and\n  should establish how programs written in that language\n  are animated.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of requesting the execution\n  of one program statement at a time. The semantics also contemplates \n  the possiblity some side information being leaked by language instructions.\n*)\ntheory SinglePartySemantics.\n\n  (** Language *)\n  clone import Language.\n\n  (** Side information *)\n  type sideInfo_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [step] - sequential semantics procedures, that executes one\n      instruction of the program.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P : L) : unit\n    proc step() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n        - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type output_event_t = secret_t.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc step(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    proc init = Sem.init\n    proc setInput(x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P : L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend SinglePartySemantics.\n```\n\nThe missing type `output_event_t` is defined as `secret_t` to represent the output event type. This completion is based on the context provided by the description and the existing code structure. \n\n```ec\ntype output_event_t = ____(TYPE_0)____ \n``` \nis replaced with \n```ec\ntype output_event_t = secret_t.\n```"]], "EC-1/BarrettReduction_Abstract.ec": [[true, "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n(* Theorem: Equivalence of multiplication in the field *)\nequiv mulm_eq: \n CSpecFp.mulm ~ ASpecFp.mulm: \n  a{1} = Zp.asint a{2} /\\ b{1} = Zp.asint b{2} /\\ p{1} = Zp.p\n    ==> res{1} = Zp.asint res{2}.\nproof.\n  proc. inline*. wp.  skip. progress.\n  smt(@Zp).\nqed.\n\n(* Parameter for the Barrett reduction *)\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm: ={a, p} /\\ r{2} = (4 ^ k{2} %/ p{2}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  /\\ 0 <= k{2} ==> ={res}.\nproc. inline*. wp. skip. progress.\nrewrite - (barrett_reduction_correct a{2} p{2} k{2}). auto. auto. auto. \nrewrite /barrett_reduction. simplify. rewrite /ti. rewrite /ti'. rewrite /ri.\nhave ->: 2 ^ (2 * k{2}) = 4 ^ k{2}. smt(@Real).\nhave <-:  a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = (a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  %%  2 ^ k{2} * p{2}) %% W64x2N.modulusR.\nrewrite modz_small.\nhave ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \napply divz_ge0. \nsmt(exprn_ege1).\nrewrite /ri. \n  have : 0 <= (4 ^ k{2} %/ p{2}). apply divz_ge0.  smt(). smt(exprn_ege1). smt().\n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r. \n   apply st6. smt(). split. smt().  move => ?. rewrite  exp_lemma1. auto. auto. smt(@Real).\n  smt(). smt(). auto.\nhave -> : a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = ti a{2} p{2} k{2}. rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nsplit. \n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto.\n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split.  smt(). smt(). smt(exp_lemma1).\n  progress. smt(). \nmove => _.\nhave ->: `|W64xN.modulusR2| = W64xN.modulusR2. rewrite /W64xN.modulusR2. smt(@Ring).\n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto. \n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split. smt(). smt().\nsplit. smt(). move => ?. smt(exp_lemma1).\n  progress. \n   have : 2 * p{2} < W64xN.modulusR2. rewrite /W64xN.modulusR2. \n   have : W64x2N.M ^ (nlimbs) <= W64x2N.M ^ (2 * nlimbs).\n   apply ler_weexpn2l. smt(). smt().\n   have : p{2} <= W64x2N.M ^ nlimbs.\n    have ->: W64x2N.M ^ nlimbs = W64xN.modulusR. rewrite /W64xN.modulusR. auto. smt().\nsmt(). smt().\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \n  have : 0 <= ri p{2} k{2} %/ 4 ^ k{2}. apply divz_ge0. smt(exprn_ege1). rewrite /ri.\n  apply divz_ge0.  smt(). smt(exprn_ege1). smt(). \n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r.\n   apply st6. smt().  split. smt(). move => ?. smt(exp_lemma1).\n  smt().\n  smt(). auto.\nsmt().\nauto.\nqed.", "```ec\nrequire import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n(* Theorem: Equivalence of multiplication in the field *)\nequiv mulm_eq: \n CSpecFp.mulm ~ ASpecFp.mulm: \n  a{1} = Zp.asint a{2} /\\ b{1} = Zp.asint b{2} /\\ p{1} = Zp.p\n    ==> res{1} = Zp.asint res{2}.\nproof.\n  proc. inline*. wp.  skip. progress.\n  smt(@Zp).\nqed.\n\n(* Parameter for the Barrett reduction *)\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm: ={a, p} /\\ r{2} = (4 ^ k{2} %/ p{2}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  /\\ 0 <= k{2} ==> ={res}.\nproc. inline*. wp. skip. progress.\nrewrite - (barrett_reduction_correct a{2} p{2} k{2}). auto. auto. auto. \nrewrite /barrett_reduction. simplify. rewrite /ti. rewrite /ti'. rewrite /ri.\nhave ->: 2 ^ (2 * k{2}) = 4 ^ k{2}. smt(@Real).\nhave <-:  a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = (a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  %%  2 ^ k{2} * p{2}) %% W64x2N.modulusR.\nrewrite modz_small.\nhave ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \napply divz_ge0. \nsmt(exprn_ege1).\nrewrite /ri. \n  have : 0 <= (4 ^ k{2} %/ p{2}). apply divz_ge0.  smt(). smt(exprn_ege1). smt().\n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r. \n   apply st6. smt(). split. smt().  move => ?. rewrite  exp_lemma1. auto. auto. smt(@Real).\n  smt(). smt(). auto.\nhave -> : a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = ti a{2} p{2} k{2}. rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nsplit. \n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto.\n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split.  smt(). smt(). smt(exp_lemma1).\n  progress. smt(). \nmove => _.\nhave ->: `|W64xN.modulusR2| = W64xN.modulusR2. rewrite /W64xN.modulusR2. smt(@Ring).\n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto. \n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split. smt(). smt().\nsplit. smt(). move => ?. smt(exp_lemma1).\n  progress. \n   have : 2 * p{2} < W64xN.modulusR2. rewrite /W64xN.modulusR2. \n   have : W64x2N.M ^ (nlimbs) <= W64x2N.M ^ (2 * nlimbs).\n   apply ler_weexpn2l. smt(). smt().\n   have : p{2} <= W64x2N.M ^ nlimbs.\n    have ->: W64x2N.M ^ nlimbs = W64xN.modulusR. rewrite /W64xN.modulusR. auto. smt().\nsmt(). smt().\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \n  have : 0 <= ri p{2} k{2} %/ 4 ^ k{2}. apply divz_ge0. smt(exprn_ege1). rewrite /ri.\n  apply divz_ge0.  smt(). smt(exprn_ege1). smt(). \n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r.\n   apply st6. smt().  split. smt(). move => ?. smt(exp_lemma1).\n  smt().\n  smt(). auto.\nsmt().\nauto.\nqed.\n```"]], "EC-1/basic-hash-unlink.ec": [[false, "```ec\n(* We first relate the bad event in the multiple session game \n   with the bad event in the single session game. *)\nlemma coll_single_eq &m (A <: Adv{Multiple0, Single0, PRFs, EUF_RF2}) :\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n  Pr"]], "EC-1/BigNum_proofs.ec": [[true, "require import AllCore IntDiv CoreMap List RealExp.\nrequire W64_SchnorrExtract.\nrequire BigNum_spec AuxLemmas DoubleBigNum_spec DoubleBigNum.\nrequire Import W64.\n\n(* Importing necessary modules and types *)\n\n(* Type definitions and operations *)\n\n(* Module definitions *)\n\n(* Main module for the protocol *)\nmodule M = {\n  (* Functions for various arithmetic operations and manipulations *)\n  proc addm(x : int, y : int, z : int) = {\n    var a, b, c, d;\n    a <@ bn_expand(x);\n    b <@ bn_expand(y);\n    c <@ dbn_addm(a, b, z);\n    d <@ bn_shrink(c);\n    return d;\n  }\n\n  proc swapr(x : int, y : int, s : bool) = {\n    var i, mask, t;\n    i = 0;\n    mask = if s then (of_int W64.max_uint) else (of_int 0);\n    while (i < nlimbs) {\n      t = x.[i] `^` (x.[i] `^` y.[i] `&` mask);\n      x.[i] = t;\n      y.[i] = y.[i] `^` t;\n      i = i + 1;\n    }\n    return (x, y);\n  }\n\n  (* Other procedures for various operations like bn_addc, bn_subc, bn_cmov, etc. *)\n}.\n\n(* Module for abstract specification of addition *)\nmodule AddM = {\n  proc addm(x : int, y : int, z : int) = {\n    return (x + y) %% z;\n  }\n}.\n\n(* Lemma proving the equivalence between M.bn_addm and AddM.addm *)\nlemma bn_addm_equiv aaa bbb ppp:\n  equiv[M.bn_addm ~ AddM.addm:\n    a{1} = aaa /\\ b{1} = bbb /\\ p{1} = ppp \n    /\\ x{2} = ____()___\n    /\\ y{2} = ____()___\n    /\\ z{2} = ____()___\n    /\\ 0 <= valR a{1} < valR p{1}\n    /\\ 0 <= valR b{1} < valR p{1}\n    ==>  valR res{1} = res{2} ].\nproc. wp. sp.\nseq 1 0 : (  a{1} = aaa /\\\n  b{1} = bbb /\\\n  p{1} = ppp /\\\n  (0 <= valR a{1} && valR a{1} < valR p{1}) /\\\n  (0 <= valR b{1} && valR b{1} < valR p{1}) /\\\n  x{2} = valR aaa /\\ y{2} = valR bbb /\\ z{2} = valR ppp /\\\n  W64x2N.valR aa{1} = W64xN.valR a{1}). \ncall {1} (bn_expand_correct aaa). skip. progress.   \nseq 1 0 : (#pre /\\ W64x2N.valR bb{1} = W64xN.valR b{1}). \ncall {1} (bn_expand_correct bbb). skip. progress. \nseq 1 0 : (#pre /\\ W64x2N.valR pp{1} = W64xN.valR p{1}). \ncall {1} (bn_expand_correct ppp). skip. progress. \nseq 1 0 : (#pre /\\ W64x2N.valR cc{1} = (W64x2N.valR aa{1} + W64x2N.valR bb{1})  %% W64x2N.valR pp{1}).\nexists* pp{1}. elim*. move => pp_.\nexists* aa{1}. elim*. move => aa_.\nexists* bb{1}. elim*. move => bb_.\ncall {1} (dbn_addm_correct aa_ bb_ pp_). skip. progress. \nsmt(@W64x2N). rewrite H3 H5. assumption.\nsmt(@W64x2N). rewrite H4 H5. assumption.\nsmt(@W64x2N). \nrewrite H5. \n have fact1 : valR p{1} < W64xN.modulusR. smt(@W64xN).\n have fact2 : 2 * W64xN.modulusR <  W64x2N.modulusR. \n rewrite /W64xN.modulusR.\n rewrite /W64x2N.modulusR.\n have ->: dnlimbs = 2 * nlimbs. auto. \n  simplify. auto.\nsmt().\nsmt().\nexists* cc{1}. elim*. move => cc_.\ncall {1} (bn_shrink_correct cc_). skip. progress. rewrite H7 H6 H3 H4 H5. \npose w := (valR a{1} + valR b{1}) %% valR p{1}. smt(@IntDiv @W64xN).\nqed.\n\n(* Proof of the phoare for bn_addm *)\nlemma bn_addm_ph aaa bbb ppp:\n  phoare[M.bn_addm : a = aaa /\\ b = bbb /\\ p = ppp /\\ 0 <= valR a < valR p /\\ 0 <= valR b < valR p \n        ==> (valR aaa + valR bbb)%% (valR ppp) = valR res ] = 1%r .\nbypr. progress.\nhave ->: 1%r = Pr[ AddM.addm(valR a{m}, valR b{m}, valR p{m}) @ &m : (valR a{m} + valR b{m}) %% valR p{m} = res ].\nbyphoare (_: arg = (valR a{m}, valR b{m}, valR p{m}) ==> _).\nproc. skip. auto. auto. auto.\nbyequiv. conseq (bn_addm_equiv a{m} b{m} p{m}).\nprogress. progress. auto. auto.\nqed.\n\n(* Hoare logic proof for the swapr function *)\nlemma swap_lemma_ph xx yy ss :\n      phoare [ M.swapr : arg = (xx,yy,as_w64 ss) ==> res = if ss then (yy, xx) else (xx, yy)  ] = 1%r.\nbypr.\nprogress.\nhave ->: 1%r = Pr[ CSpecFp.swapr(x{m},y{m},as_bool swap_0{m}) @&m : res =  if ss then (yy, xx) else (xx, yy)  ].\nbyphoare (_: arg = (x{m},y{m},as_bool swap_0{m}) ==> _). proc.\nskip.  progress.    rewrite /as_bool.\n have ->: (swap_0{m} = W64.one) = ss. rewrite H. simplify. rewrite /as_w64. \n  case ss. auto. smt(@W64). smt().\n  smt(). auto.\nbyequiv. conseq swap_lemma_cspec.  smt(). smt(). auto. auto.\nqed.\n\n(* Equivalence proof for the swapr function *)\nlemma swap_lemma_cspec :\n      equiv[ M.swapr ~ CSpecFp.swapr :\n              a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} ==> ={res}].\nproc.  simplify.\nseq 2 0 : (i{1} = 0 /\\ a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} /\\ \n   ((as_bool swap_0{1} => mask{1} = (of_int 18446744073709551615)%W64 )\n              /\\ (as_bool swap_0{1} = false => mask{1} = (of_int 0)%W64))).\nwp. skip. progress. smt(@W64). smt(@W64).\nwhile {1} (0 <= i{1} /\\ ((as_bool swap_0{1} => mask{1} = (of_int 18446744073709551615)%W64 )\n              /\\ (as_bool swap_0{1} = false => mask{1} = (of_int 0)%W64)) \n   /\\ (forall j, 0 <= j < i{1} => (x{1}.[j])%A = (if as_bool swap_0{1} then (b{2}.[j]) else (a{2}.[j]))%A )  \n   /\\ (forall j, 0 <= j < i{1} => (y{1}.[j])%A = (if as_bool swap_0{1} then (a{2}.[j]) else (b{2}.[j]))%A )  \n   /\\ (forall j, i{1} <= j => (x{1}.[j])%A =  (a{2}.[j]))%A\n   /\\ (forall j, i{1} <= j => (y{1}.[j])%A =  (b{2}.[j]))%A\n ) (nlimbs - i{1} + 1).\nprogress. wp.  skip.  progress.   smt().\ncase (j <  i{hr}). progress. smt(@A).\nprogress.\nhave : j = i{hr}. smt().\nprogress.\nrewrite - /A.\"_.[_]\".\nrewrite - /A.\"_.[_<-_]\".\nhave ->: (x{hr}.[i{hr} <-\n    x{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr})].[i{hr}])%A\n = (x{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr}))%A. smt(@A).\ncase (as_bool swap_0{hr}). progress.\nrewrite H4. auto.  rewrite H0. auto. rewrite H5. auto. rewrite - ones64. \nhave -> : ((a{m}.[i{hr}])%A `^` (b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64) = a{m}.[i{hr}]%A `^` ((b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64).\npose x := a{m}.[i{hr}]%A.\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nrewrite andwDl.\nhave ->: (x `&` z) = x. smt (W64.andw1_s).\nauto.\nhave ->: ((b{m}.[i{hr}])%A `&` (of_int W64.max_uint)%W64) = ((b{m}.[i{hr}])%A). \npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nsmt (W64.andw1_s).\nsmt(@W64).\nprogress. rewrite H4. auto.  rewrite H1. smt(). auto. \ncase (j <  i{hr}). progress. smt(@A).\nprogress.\nhave : j = i{hr}. smt().\nprogress.\nrewrite - /A.\"_.[_]\".\nrewrite - /A.\"_.[_<-_]\".\nhave ->: (y{hr}.[i{hr} <-\n   y{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr})].[i{hr}])%A\n = (y{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr}))%A. smt(@A).\ncase (as_bool swap_0{hr}). progress.\nrewrite H4. auto.  rewrite H0. auto. rewrite H5. auto. rewrite - ones64. \nhave -> : ((a{m}.[i{hr}])%A `^` (b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64) = a{m}.[i{hr}]%A `^` ((b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64). \npose x := a{m}.[i{hr}]%A.\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nrewrite andwDl.\nhave ->: (x `&` z) = x. smt (W64.andw1_s).\nauto.\nhave ->: ((b{m}.[i{hr}])%A `&` (of_int W64.max_uint)%W64) = ((b{m}.[i{hr}])%A).\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nsmt (W64.andw1_s).\nsmt(@W64).\nprogress. rewrite H4. auto.  rewrite H1. smt(). smt(@W64).\nsmt(@A). smt(@A). smt().\nskip. progress. smt().   smt().   smt(). \ncase (c{2} = false). progress.  \napply A.ext_eq.  progress. \nrewrite - /A.\"_.[_]\".\nrewrite H5. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H6. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\nprogress. have ->: c{2} = true. smt(). simplify.\nprogress. \napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H5. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H6. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\nqed.", "```ec\nrequire import AllCore IntDiv CoreMap List RealExp.\nrequire W64_SchnorrExtract.\nrequire BigNum_spec AuxLemmas DoubleBigNum_spec DoubleBigNum.\nrequire Import W64.\n\n(* Importing necessary modules and types *)\n\n(* Type definitions and operations *)\n\n(* Module definitions *)\n\n(* Main module for the protocol *)\nmodule M = {\n  (* Functions for various arithmetic operations and manipulations *)\n  proc addm(x : int, y : int, z : int) = {\n    var a, b, c, d;\n    a <@ bn_expand(x);\n    b <@ bn_expand(y);\n    c <@ dbn_addm(a, b, z);\n    d <@ bn_shrink(c);\n    return d;\n  }\n\n  proc swapr(x : int, y : int, s : bool) = {\n    var i, mask, t;\n    i = 0;\n    mask = if s then (of_int W64.max_uint) else (of_int 0);\n    while (i < nlimbs) {\n      t = x.[i] `^` (x.[i] `^` y.[i] `&` mask);\n      x.[i] = t;\n      y.[i] = y.[i] `^` t;\n      i = i + 1;\n    }\n    return (x, y);\n  }\n\n  (* Other procedures for various operations like bn_addc, bn_subc, bn_cmov, etc. *)\n}.\n\n(* Module for abstract specification of addition *)\nmodule AddM = {\n  proc addm(x : int, y : int, z : int) = {\n    return (x + y) %% z;\n  }\n}.\n\n(* Lemma proving the equivalence between M.bn_addm and AddM.addm *)\nlemma bn_addm_equiv aaa bbb ppp:\n  equiv[M.bn_addm ~ AddM.addm:\n    a{1} = aaa /\\ b{1} = bbb /\\ p{1} = ppp \n    /\\ x{2} = ____()___\n    /\\ y{2} = ____()___\n    /\\ z{2} = ____()___\n    /\\ 0 <= valR a{1} < valR p{1}\n    /\\ 0 <= valR b{1} < valR p{1}\n    ==>  valR res{1} = res{2} ].\nproc. wp. sp.\nseq 1 0 : (  a{1} = aaa /\\\n  b{1} = bbb /\\\n  p{1} = ppp /\\\n  (0 <= valR a{1} && valR a{1} < valR p{1}) /\\\n  (0 <= valR b{1} && valR b{1} < valR p{1}) /\\\n  x{2} = valR aaa /\\ y{2} = valR bbb /\\ z{2} = valR ppp /\\\n  W64x2N.valR aa{1} = W64xN.valR a{1}). \ncall {1} (bn_expand_correct aaa). skip. progress.   \nseq 1 0 : (#pre /\\ W64x2N.valR bb{1} = W64xN.valR b{1}). \ncall {1} (bn_expand_correct bbb). skip. progress. \nseq 1 0 : (#pre /\\ W64x2N.valR pp{1} = W64xN.valR p{1}). \ncall {1} (bn_expand_correct ppp). skip. progress. \nseq 1 0 : (#pre /\\ W64x2N.valR cc{1} = (W64x2N.valR aa{1} + W64x2N.valR bb{1})  %% W64x2N.valR pp{1}).\nexists* pp{1}. elim*. move => pp_.\nexists* aa{1}. elim*. move => aa_.\nexists* bb{1}. elim*. move => bb_.\ncall {1} (dbn_addm_correct aa_ bb_ pp_). skip. progress. \nsmt(@W64x2N). rewrite H3 H5. assumption.\nsmt(@W64x2N). rewrite H4 H5. assumption.\nsmt(@W64x2N). \nrewrite H5. \n have fact1 : valR p{1} < W64xN.modulusR. smt(@W64xN).\n have fact2 : 2 * W64xN.modulusR <  W64x2N.modulusR. \n rewrite /W64xN.modulusR.\n rewrite /W64x2N.modulusR.\n have ->: dnlimbs = 2 * nlimbs. auto. \n  simplify. auto.\nsmt().\nsmt().\nexists* cc{1}. elim*. move => cc_.\ncall {1} (bn_shrink_correct cc_). skip. progress. rewrite H7 H6 H3 H4 H5. \npose w := (valR a{1} + valR b{1}) %% valR p{1}. smt(@IntDiv @W64xN).\nqed.\n\n(* Proof of the phoare for bn_addm *)\nlemma bn_addm_ph aaa bbb ppp:\n  phoare[M.bn_addm : a = aaa /\\ b = bbb /\\ p = ppp /\\ 0 <= valR a < valR p /\\ 0 <= valR b < valR p \n        ==> (valR aaa + valR bbb)%% (valR ppp) = valR res ] = 1%r .\nbypr. progress.\nhave ->: 1%r = Pr[ AddM.addm(valR a{m}, valR b{m}, valR p{m}) @ &m : (valR a{m} + valR b{m}) %% valR p{m} = res ].\nbyphoare (_: arg = (valR a{m}, valR b{m}, valR p{m}) ==> _).\nproc. skip. auto. auto. auto.\nbyequiv. conseq (bn_addm_equiv a{m} b{m} p{m}).\nprogress. progress. auto. auto.\nqed.\n\n(* Hoare logic proof for the swapr function *)\nlemma swap_lemma_ph xx yy ss :\n      phoare [ M.swapr : arg = (xx,yy,as_w64 ss) ==> res = if ss then (yy, xx) else (xx, yy)  ] = 1%r.\nbypr.\nprogress.\nhave ->: 1%r = Pr[ CSpecFp.swapr(x{m},y{m},as_bool swap_0{m}) @&m : res =  if ss then (yy, xx) else (xx, yy)  ].\nbyphoare (_: arg = (x{m},y{m},as_bool swap_0{m}) ==> _). proc.\nskip.  progress.    rewrite /as_bool.\n have ->: (swap_0{m} = W64.one) = ss. rewrite H. simplify. rewrite /as_w64. \n  case ss. auto. smt(@W64). smt().\n  smt(). auto.\nbyequiv. conseq swap_lemma_cspec.  smt(). smt(). auto. auto.\nqed.\n\n(* Equivalence proof for the swapr function *)\nlemma swap_lemma_cspec :\n      equiv[ M.swapr ~ CSpecFp.swapr :\n              a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} ==> ={res}].\nproc.  simplify.\nseq 2 0 : (i{1} = 0 /\\ a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} /\\ \n   ((as_bool swap_0{1} => mask{1} = (of_int 18446744073709551615)%W64 )\n              /\\ (as_bool swap_0{1} = false => mask{1} = (of_int 0)%W64))).\nwp. skip. progress. smt(@W64). smt(@W64).\nwhile {1} (0 <= i{1} /\\ ((as_bool swap_0{1} => mask{1} = (of_int 18446744073709551615)%W64 )\n              /\\ (as_bool swap_0{1} = false => mask{1} = (of_int 0)%W64)) \n   /\\ (forall j, 0 <= j < i{1} => (x{1}.[j])%A = (if as_bool swap_0{1} then (b{2}.[j]) else (a{2}.[j]))%A )  \n   /\\ (forall j, 0 <= j < i{1} => (y{1}.[j])%A = (if as_bool swap_0{1} then (a{2}.[j]) else (b{2}.[j]))%A )  \n   /\\ (forall j, i{1} <= j => (x{1}.[j])%A =  (a{2}.[j]))%A\n   /\\ (forall j, i{1} <= j => (y{1}.[j])%A =  (b{2}.[j]))%A\n ) (nlimbs - i{1} + 1).\nprogress. wp.  skip.  progress.   smt().\ncase (j <  i{hr}). progress. smt(@A).\nprogress.\nhave : j = i{hr}. smt().\nprogress.\nrewrite - /A.\"_.[_]\".\nrewrite - /A.\"_.[_<-_]\".\nhave ->: (x{hr}.[i{hr} <-\n    x{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr})].[i{hr}])%A\n = (x{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr}))%A. smt(@A).\ncase (as_bool swap_0{hr}). progress.\nrewrite H4. auto.  rewrite H0. auto. rewrite H5. auto. rewrite - ones64. \nhave -> : ((a{m}.[i{hr}])%A `^` (b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64) = a{m}.[i{hr}]%A `^` ((b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64).\npose x := a{m}.[i{hr}]%A.\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nrewrite andwDl.\nhave ->: (x `&` z) = x. smt (W64.andw1_s).\nauto.\nhave ->: ((b{m}.[i{hr}])%A `&` (of_int W64.max_uint)%W64) = ((b{m}.[i{hr}])%A). \npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nsmt (W64.andw1_s).\nsmt(@W64).\nprogress. rewrite H4. auto.  rewrite H1. smt(). auto. \ncase (j <  i{hr}). progress. smt(@A).\nprogress.\nhave : j = i{hr}. smt().\nprogress.\nrewrite - /A.\"_.[_]\".\nrewrite - /A.\"_.[_<-_]\".\nhave ->: (y{hr}.[i{hr} <-\n   y{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr})].[i{hr}])%A\n = (y{hr}.[i{hr}] `^` (x{hr}.[i{hr}] `^` y{hr}.[i{hr}] `&` mask{hr}))%A. smt(@A).\ncase (as_bool swap_0{hr}). progress.\nrewrite H4. auto.  rewrite H0. auto. rewrite H5. auto. rewrite - ones64. \nhave -> : ((a{m}.[i{hr}])%A `^` (b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64) = a{m}.[i{hr}]%A `^` ((b{m}.[i{hr}])%A `&`\n (of_int W64.max_uint)%W64). \npose x := a{m}.[i{hr}]%A.\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nrewrite andwDl.\nhave ->: (x `&` z) = x. smt (W64.andw1_s).\nauto.\nhave ->: ((b{m}.[i{hr}])%A `&` (of_int W64.max_uint)%W64) = ((b{m}.[i{hr}])%A).\npose y := b{m}.[i{hr}]%A.\npose z := (of_int W64.max_uint)%W64.\nsmt (W64.andw1_s).\nsmt(@W64).\nprogress. rewrite H4. auto.  rewrite H1. smt(). smt(@W64).\nsmt(@A). smt(@A). smt().\nskip. progress. smt().   smt().   smt(). \ncase (c{2} = false). progress.  \napply A.ext_eq.  progress. \nrewrite - /A.\"_.[_]\".\nrewrite H5. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H6. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\nprogress. have ->: c{2} = true. smt(). simplify.\nprogress. \napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H5. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\napply A.ext_eq.  progress. rewrite - /A.\"_.[_]\". rewrite H6. progress. smt(). rewrite /as_bool. rewrite /as_w64. simplify. smt(@W64).\nqed.\n``` \nThe completed code should be as follows:\n```ec\nrequire import AllCore IntDiv CoreMap List RealExp.\nrequire W64_SchnorrExtract.\nrequire BigNum_spec AuxLemmas DoubleBigNum_spec DoubleBigNum.\nrequire Import W64.\n\n(* Importing necessary modules and types *)\n\n(* Type definitions and operations *)\n\n(* Module definitions *)\n\n(* Main module for the protocol *)\nmodule M = {\n  (* Functions for various arithmetic operations and manipulations *)\n  proc addm(x : int, y : int, z : int) = {\n    var a, b, c, d;\n    a <@ bn_expand(x);\n    b <@ bn_expand(y);\n    c <@ dbn_addm(a, b, z);\n    d <@ bn_shrink(c);\n    return d;\n  }\n\n  proc swapr(x : int, y : int, s : bool) = {\n    var i, mask, t;\n    i = 0;\n    mask = if s then (of_int W64.max_uint) else (of_int 0);\n    while (i < nlimbs) {\n      t = x.[i] `^` (x.[i] `^` y.[i] `&` mask);\n      x.[i] = t;\n      y.[i] = y.[i] `^` t;\n      i = i + 1;\n    }\n    return (x, y);\n  }\n\n  (* Other procedures for various operations like bn_addc, bn_subc, bn_cmov, etc. *)\n}.\n\n(* Module for abstract specification of addition *)\nmodule AddM = {\n  proc addm(x : int, y : int, z : int) = {\n    return (x + y) %% z;\n  }\n}.\n\n(* Lemma proving the equivalence between M.bn_addm and AddM.addm *)\nlemma bn_addm_equiv aaa bbb ppp:\n  equiv[M.bn_addm ~ AddM.addm:\n    a{1} = aaa /\\ b{1} = bbb /\\ p{1} = ppp \n    /\\ x{2} = valR aaa /\\ y{2} = valR bbb /\\ z{2} = valR ppp\n    /\\ 0 <= valR a{1} < valR p{1}\n    /\\ 0 <= valR b{1} < valR p{1}\n    ==>  valR res{1} = res{2} ].\nproc. wp. sp.\nseq 1 0 : (  a{1} = aaa /\\\n  b{1} = bbb /\\\n  p{1} = ppp /\\\n  (0 <= valR a{1} && valR a{1} < valR p{1}) /\\\n  (0 <= valR b{1} && valR b{1} < valR p{1}) /\\\n  x{2} = valR aaa /\\ y{2} = valR bbb /\\ z{2} = valR ppp /\\\n  W64x2N.valR aa{1} = W64xN.valR a{1}). \ncall {1} (bn_expand_correct aaa). skip. progress.   \nseq 1 0 : (#pre /\\ W64x2N.valR bb{1} = W64xN.valR b{1}). \ncall {1} (bn_expand_correct bbb). skip. progress. \nseq 1 0 : (#pre /\\ W64x2N.valR pp{1} = W64xN.valR p{1}). \ncall {1} (bn_expand_correct ppp). skip. progress. \nseq 1 0 : (#pre /\\"]], "EC-1/BinUniSample_spec.ec": [[true, "require import AllCore Distr DInterval List IntDiv.\n\nmodule SampleByte = {\n  proc sampleInt() = {\n    var x;\n    x <$ [0..255];\n    return x;\n  }\n\n  proc run() = {\n    var x : int;\n    x <@ sampleInt();\n    x <- x %% 2;\n    return x;\n  }\n}.\n\nlemma sample_prob0 : phoare[SampleByte.run : true ==> res = 0 ] = (inv 2%r).\nproc. inline*.\nwp. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup (range 0 256)) = (range 0 256).\nsmt(@List).\nhave ->: (size (range 0 256)) = 256. smt(@List).\nhave ->: (count (fun (x : int) => x %% 2 = 0) (range 0 256)) = 128.\ndo (rewrite range_ltn /=; first by trivial). \nby rewrite /b2i;rewrite range_geq;simplify;done.\nauto.\nqed.\n\nlemma sample_prob1 : phoare[SampleByte.run : true ==> res <> 0  ] = (inv 2%r).\nproc. inline*.\nwp. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup (range 0 256)) = (range 0 256).\nsmt(@List).\nhave ->: (size (range 0 256)) = 256. smt(@List).\nhave ->: (count (fun (x : int) => x %% 2 <> 0) (range 0 256)) = 128.\ndo (rewrite range_ltn /=; first by trivial). \nby rewrite /b2i;rewrite range_geq;simplify;done.\nauto.\nqed.\n\n\n\ntheory RandomChoice.\n\ntype t.\n\nmodule BinSampleSpec = {\n\n  proc main(a b : t) = {\n    var s : int;\n    var r : t;\n    s <@ SampleByte.run();\n    r <- if (s = 0) then a else b;\n    return r;\n  }\n\n  proc spec(a b : t) = {\n    var r : t;\n    r <$ duniform [a; b];\n    return r;\n  }\n}.\n\nsection.\n\nlocal lemma fst_choice_pr a b : a <> b => phoare[BinSampleSpec.main : arg = (a,b) ==> res = a ] = (inv 2%r).\nproof. progress.\nproc. wp.\ncall sample_prob0.\nskip. progress.\nsmt().\nqed.\n\nlocal lemma snd_choice_pr a b : a <> b => phoare[BinSampleSpec.main : arg = (a,b) ==> res = b ] = (inv 2%r).\nproof. progress.\nproc. wp.\ncall sample_prob1.\nskip. progress. smt().\nsmt().\nqed.\n\n\nlocal lemma sat_spec_not_eq aa bb : aa <> bb\n => equiv[ BinSampleSpec.main ~ BinSampleSpec.spec : arg{1} = (aa,bb) /\\ ={arg} ==> ={res} ].\nprogress.\nbypr res{1} res{2}. smt().\nprogress.\ncase (a = aa).\nprogress.\nhave ->: Pr[BinSampleSpec.main(a{1}, b{1}) @ &1 : res = aa] = (inv 2%r).\nbyphoare (_: arg = (aa,bb) ==> _).\napply fst_choice_pr. smt(). smt(). auto.\nbyphoare (_: arg = (aa,bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup [a{hr}; b{hr}]) = [a{hr}; b{hr}]. smt(@List).\nsimplify. rewrite /b2i. simplify.\nhave ->: (b{hr} = a{hr}) = false. smt().\nsimplify.\nauto. smt(). auto.\ncase (a = bb).\nprogress.\nhave ->: Pr[BinSampleSpec.main(a{1}, b{1}) @ &1 : res = bb] = (inv 2%r).\nbyphoare (_: arg = (aa,bb) ==> _).\napply snd_choice_pr. smt(). smt(). auto.\nbyphoare (_: arg = (aa,bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup [a{hr}; b{hr}]) = [a{hr}; b{hr}]. smt(@List).\nsimplify. rewrite /b2i. simplify.\nhave ->: (a{hr} = b{hr}) = false. smt().\nsimplify.\nauto. smt(). auto.\nprogress.\nrewrite H0. simplify.\nhave -> : Pr[BinSampleSpec.main(aa, bb) @ &1 : res = a] = 0%r.\nbyphoare (_: arg = (aa, bb) ==> _). proc. hoare. inline*.\nwp. rnd. skip. progress.  smt(). auto. auto.\nrewrite - H1 H0. simplify.\nbyphoare (_: arg = (aa, bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nrewrite undup_id. smt(@List).\nsimplify.\nsmt(). auto. auto.\nqed.\n\n\nlemma sat_spec aa bb : \n  equiv[ BinSampleSpec.main ~ BinSampleSpec.spec : arg{1} = (aa,bb) /\\ ={arg} ==> ={res} ]. \ncase (aa = bb).\nprogress.\nproc.\nwp.  rnd{2}.\ninline*. wp. rnd {1}. skip. progress.\nsmt(@Distr).\nsmt(@Distr).\nsmt(@Distr @List).\nprogress. apply sat_spec_not_eq. auto.\nqed.\n\nend section.\n\nend RandomChoice.", "```ec\nrequire import AllCore Distr DInterval List IntDiv.\n\nmodule SampleByte = {\n  proc sampleInt() = {\n    var x;\n    x <$ [0..255];\n    return x;\n  }\n\n  proc run() = {\n    var x : int;\n    x <@ sampleInt();\n    x <- x %% 2;\n    return x;\n  }\n}.\n\nlemma sample_prob0 : phoare[SampleByte.run : true ==> res = 0 ] = (inv 2%r).\nproc. inline*.\nwp. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup (range 0 256)) = (range 0 256).\nsmt(@List).\nhave ->: (size (range 0 256)) = 256. smt(@List).\nhave ->: (count (fun (x : int) => x %% 2 = 0) (range 0 256)) = 128.\ndo (rewrite range_ltn /=; first by trivial). \nby rewrite /b2i;rewrite range_geq;simplify;done.\nauto.\nqed.\n\nlemma sample_prob1 : phoare[SampleByte.run : true ==> res <> 0  ] = (inv 2%r).\nproc. inline*.\nwp. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup (range 0 256)) = (range 0 256).\nsmt(@List).\nhave ->: (size (range 0 256)) = 256. smt(@List).\nhave ->: (count (fun (x : int) => x %% 2 <> 0) (range 0 256)) = 128.\ndo (rewrite range_ltn /=; first by trivial). \nby rewrite /b2i;rewrite range_geq;simplify;done.\nauto.\nqed.\n\n\n\ntheory RandomChoice.\n\ntype t.\n\nmodule BinSampleSpec = {\n\n  proc main(a b : t) = {\n    var s : int;\n    var r : t;\n    s <@ SampleByte.run();\n    r <- if (s = 0) then a else b;\n    return r;\n  }\n\n  proc spec(a b : t) = {\n    var r : t;\n    r <$ duniform [a; b];\n    return r;\n  }\n}.\n\nsection.\n\nlocal lemma fst_choice_pr a b : a <> b => phoare[BinSampleSpec.main : arg = (a,b) ==> res = a ] = (inv 2%r).\nproof. progress.\nproc. wp.\ncall sample_prob0.\nskip. progress.\nsmt().\nqed.\n\nlocal lemma snd_choice_pr a b : a <> b => phoare[BinSampleSpec.main : arg = (a,b) ==> res = b ] = (inv 2%r).\nproof. progress.\nproc. wp.\ncall sample_prob1.\nskip. progress. smt().\nsmt().\nqed.\n\n\nlocal lemma sat_spec_not_eq aa bb : aa <> bb\n => equiv[ BinSampleSpec.main ~ BinSampleSpec.spec : arg{1} = (aa,bb) /\\ ={arg} ==> ={res} ].\nprogress.\nbypr res{1} res{2}. smt().\nprogress.\ncase (a = aa).\nprogress.\nhave ->: Pr[BinSampleSpec.main(a{1}, b{1}) @ &1 : res = aa] = (inv 2%r).\nbyphoare (_: arg = (aa,bb) ==> _).\napply fst_choice_pr. smt(). smt(). auto.\nbyphoare (_: arg = (aa,bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup [a{hr}; b{hr}]) = [a{hr}; b{hr}]. smt(@List).\nsimplify. rewrite /b2i. simplify.\nhave ->: (b{hr} = a{hr}) = false. smt().\nsimplify.\nauto. smt(). auto.\ncase (a = bb).\nprogress.\nhave ->: Pr[BinSampleSpec.main(a{1}, b{1}) @ &1 : res = bb] = (inv 2%r).\nbyphoare (_: arg = (aa,bb) ==> _).\napply snd_choice_pr. smt(). smt(). auto.\nbyphoare (_: arg = (aa,bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup [a{hr}; b{hr}]) = [a{hr}; b{hr}]. smt(@List).\nsimplify. rewrite /b2i. simplify.\nhave ->: (a{hr} = b{hr}) = false. smt().\nsimplify.\nauto. smt(). auto.\nprogress.\nrewrite H0. simplify.\nhave -> : Pr[BinSampleSpec.main(aa, bb) @ &1 : res = a] = 0%r.\nbyphoare (_: arg = (aa, bb) ==> _). proc. hoare. inline*.\nwp. rnd. skip. progress.  smt(). auto. auto.\nrewrite - H1 H0. simplify.\nbyphoare (_: arg = (aa, bb) ==> _).\nproc. rnd. skip. progress.\nrewrite duniformE.\nrewrite undup_id. smt(@List).\nsimplify.\nsmt(). auto. auto.\nqed.\n\n\nlemma sat_spec aa bb : \n  equiv[ BinSampleSpec.main ~ BinSampleSpec.spec : arg{1} = (aa,bb) /\\ ={arg} ==> ={res} ]. \ncase (aa = bb).\nprogress.\nproc.\nwp.  rnd{2}.\ninline*. wp. rnd {1}. skip. progress.\nsmt(@Distr).\nsmt(@Distr).\nsmt(@Distr @List).\nprogress. apply sat_spec_not_eq. auto.\nqed.\n\nend section.\n\nend RandomChoice.\n```"]], "EC-1/check-easycrypt-install.ec": [[false, "To complete the given task, we need to analyze the provided incomplete EasyCrypt code and its description. The incomplete code is given as:"]], "EC-1/ConstantsValidation.ec": [[true, "and", "To complete the given file, we need to fill in the blanks according to the description provided.\n\n\nThe first blank is in the line: `op [opaque] square_and_multiply_state (____(OP_1)____ ____(OP_0)____ ____(OP_3)____ ____(OP_2)____ : int) = ((x ^ y) * z) %% m.`\n\nThe description suggests that `square_and_multiply_state` represents the modular exponentiation operation and takes four integers as inputs: `x`, `y`, `z`, and `m`. So, the correct order should be `x y z m`.\n\nThus, the completed line should be: `op [opaque] square_and_multiply_state (x y z m : int) = ((x ^ y) * z) %% m.`\n\n\nThe second blank is in the line: `lemma generator_is_valid: (____(LEMMA_0)____.g ^ Constants.q) %% Constants.p = 1.`\n\nGiven the context, `Constants.g` is the generator, and we are verifying a property about it. There's no indication that `LEMMA_0` should be anything other than `Constants`, as `Constants` is where `g` is defined.\n\nThus, the completed line should be: `lemma generator_is_valid: (Constants.g ^ Constants.q) %% Constants.p = 1.`\n\n\nHere is the completed code between ```ec and ```:\n\n```ec\nrequire Ring.\nrequire import Int.\nimport Ring.IntID.\nrequire Constants.\nrequire import IntDiv.\n\n\nsection.\n\nop [opaque] square_and_multiply_state (x y z m : int) = ((x ^ y) * z) %% m.\n\nlocal lemma red_exp' (x' x'' m : int) : forall y, 0 <= y =>  x' %% m = x'' %% m \n  => x' ^ y %% m = x'' ^ y %% m.\napply intind. simplify. progress.\nprogress.\nhave ->: x' ^ (i + 1)  = x' * (x' ^ i). smt(@Ring.IntID).\nhave ->: x'' ^ (i + 1)  = x'' * (x'' ^ i). smt(@Ring.IntID).\nhave ->: x' * x' ^ i %% m = x' %% m * (x' ^ i %% m) %% m. smt(@IntDiv).\nrewrite H0. apply H1. rewrite H1.\nsmt(@IntDiv).\nqed.\n\n\nlocal lemma red_exp (x' x''  m : int) : forall y, x' %% m = x'' %% m \n  => x' ^ y %% m = x'' ^ y %% m.\nmove => y H. \ncase (0 <= y). move => H'. apply red_exp'. auto. apply H.\nmove => H'.\nhave : y < 0. smt().\nprogress.\nhave ->: x' ^ y = x' ^ (-y). smt(@Ring.IntID).\nhave ->: x'' ^ y = x'' ^ (-y). smt(@Ring.IntID).\napply red_exp'. smt(). auto.\nqed.\n\n\n\nlocal lemma square_and_multiply_step x y z m:\n    0 <= y =>\n    square_and_multiply_state x y z m = square_and_multiply_state (x*x %% m) (y %/ 2) ((z * x ^ (y%%2)) %% m) m.\nproof.\nmove => Hy.\nhave red_mul: forall x' y' x'' y'', x' %% m = x'' %% m => y' %% m = y'' %% m => (x' * y') %% m = (x'' * y'') %% m.\n  move => x' y' x'' y'' H1 H2.\n  rewrite -modzMm.\n  rewrite H1 H2.\n  rewrite modzMm.\n  by trivial.\nhave red_exp: forall x' y' x'', x' %% m = x'' %% m => x' ^ y' %% m = x'' ^ y' %% m.\n  move => x' y' x'' H1. \n  apply red_exp. auto.\n(* Bring lhs and rhs into matching shape, modulo modulo. *)\nrewrite /square_and_multiply_state {1}(divz_eq y 2).\nrewrite exprD_nneg; [ smt() | smt() | ].\nrewrite (mulzC (y%/2) 2).\nrewrite exprM.\nrewrite mulzA.\nrewrite (mulzC (x^_) z).\n(* Show equality modulo *)\napply red_mul.\napply red_exp.\nrewrite modz_mod.\nby trivial.\nrewrite modz_mod.\nby trivial.\nqed.\n\nlocal lemma square_and_multiply_end x z m:\n    square_and_multiply_state x 0 z m = z %% m.\n  rewrite /square_and_multiply_state. trivial.\nqed.\n\nlemma statement_witness_pair_is_valid: (Constants.g ^ Constants.ex_w) %% Constants.p = Constants.ex_s.\nproof.\n  have : square_and_multiply_state Constants.g Constants.ex_w 1 Constants.p = Constants.ex_s.\n    rewrite /Constants.ex_w /Constants.p /Constants.g.\n    do (rewrite square_and_multiply_end || (rewrite square_and_multiply_step /=; first by trivial)).\n    by trivial.\n    rewrite /square_and_multiply_state.\n    smt(). (* trivial would try to do the exponentiation *)\nqed.\n\n\nlemma generator_is_valid: (Constants.g ^ Constants.q) %% Constants.p = 1.\nproof.\n  have : square_and_multiply_state Constants.g Constants.q 1 Constants.p = 1.\n    rewrite /Constants.q /Constants.p /Constants.g.\n    do (rewrite square_and_multiply_end || (rewrite square_and_multiply_step /=; first by trivial)).\n    by trivial.\n    rewrite /square_and_multiply_state.\n    smt(). \nqed.\n    \n    \n\n\n\nlemma pq_euclid : euclidef Constants.barrett_numerator Constants.p (Constants.barrett_numerator_div_p, Constants.barrett_numerator_mod_p).\nrewrite /euclidef. simplify. rewrite /barrett_numerator.  simplify. split. auto.\nsmt().\nqed.\n\n\nlemma bp_correct : Constants.bp = 4 ^ (64 * 32) %/ Constants.p.\n have ->: 4 ^ (64 * 32) = Constants.barrett_numerator. simplify. auto.\n have  -> : Constants.barrett_numerator = (Constants.p * Constants.barrett_numerator_div_p + Constants.barrett_numerator_mod_p). smt(pq_euclid).\nsmt(@IntDiv). qed.\n\nend section.\n```"]], "EC-1/cramer_shoup.ec": [[true, "require import AllCore List Distr Dexcepted PKE.\nrequire import StdOrder StdBigop.\nimport RField RealOrder Bigreal.\n\nrequire TCR RndExcept.\n\n(** DiffieHellman *)\nrequire DiffieHellman.\nclone DiffieHellman as DH.\nimport DH.DDH DH.G DH.GP DH.FD DH.GP.ZModE.\n\nclone DH.GP.ZModE.ZModpField as ZPF.\n\nlemma gt1_q : 1 < order by smt(ge2_p).\n\ntheory Ad1.\n\n  clone import RndExcept as RndE with\n    type input <- unit,\n    type t     <- exp,\n    op   d     <- fun _ => dt,\n    type out   <- bool\n    proof *.\n    realize d_ll. move=> _;apply dt_ll. qed.\n\n  clone include Adversary1_1 with\n    op n <- order\n    proof *.\n  realize gt1_n by apply gt1_q.\n  realize d_uni.\n  proof.\n  move=> _ x; rewrite dt1E.\n  suff: size elems = size elems by smt().\n  apply uniq_size_uniq; rewrite ?elems_uniq.\n  by smt(elemsP elemsP).\n  qed.\n\nend Ad1.\n\ntheory DDH_ex.\n\n  module DDH0_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y;\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  module DDH1_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y, z;\n\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  section PROOFS.\n\n  declare module A <: Adversary.\n\n  declare axiom A_ll : islossless A.guess.\n\n  local module Addh0 : Ad1.ADV = {\n    proc a1 () = { return ((), zero); }\n    proc a2 (x : exp) = {\n      var b, y;\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  local module Addh1 = {\n    proc a1 = Addh0.a1\n    proc a2 (x : exp) = {\n      var b, y, z;\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  local lemma a1_ll : islossless Addh0.a1.\n  proof. proc;auto. qed.\n\n  lemma adv_DDH_DDH_ex &m :\n     `| Pr[DDH0_ex(A).main()@ &m : res] - Pr[DDH1_ex(A).main()@ &m : res] | <=\n     `| Pr[DDH0(A).main()@ &m : res] - Pr[DDH1(A).main()@ &m : res] | + 2%r / order%r.\n  proof.\n    have /= H0 := Ad1.pr_abs Addh0 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;rnd;skip;rewrite /= dt_ll.\n    have /= H1 := Ad1.pr_abs Addh1 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;do !rnd;skip;rewrite /= dt_ll.\n    have -> : 2%r / order%r = inv order%r + inv order%r.\n    + field;smt (gt0_order lt_fromint).\n    have <- : Pr[Ad1.MainE(Addh0).main() @ &m : res] = Pr[DDH0_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.MainE(Addh1).main() @ &m : res] = Pr[DDH1_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.Main(Addh0).main() @ &m : res] = Pr[DDH0(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- /# : Pr[Ad1.Main(Addh1).main() @ &m : res] = Pr[DDH1(A).main() @ &m : res].\n    by byequiv => //;proc;inline *;sim;auto.\n  qed.\n\n  end section PROOFS.\n\nend DDH_ex.\nimport DDH_ex.\n\n(** Target Collision Resistant *)\n\nclone import TCR as TCR_H with\n  type t_from <- group * group * group,\n  type t_to   <- exp.\n\naxiom dk_ll : is_lossless dk.\nhint exact dk_ll : dk_ll.\n\n(** Cramer Shoup Encryption *)\n\nclone import PKE as PKE_ with\n   type pkey = K * group * group * group * group * group,\n   type skey = K * group * group * exp * exp * exp * exp * exp * exp,\n   type plaintext = group,\n   type ciphertext = group * group * group * group.\n\nmodule CramerShoup : Scheme = {\n  proc kg() : pkey * skey = {\n    var x1, x2, y1, y2, z1, z2, k, w, g_, pk, sk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    w  <$ dt \\ (pred1 zero);\n    k  <$ dk;\n    g_ <- g ^ w;\n    pk <- (k, g, g_, g ^ x1 * g_ ^ x2, g ^ y1 * g_ ^ y2, g ^ z1 * g_ ^ z2);\n    sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    return (pk, sk);\n  }\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var k, g, g_, e, f, h, u, a, a_, c, v, d;\n    (k, g, g_, e, f, h) <- pk;\n    u <$ dt;\n    a <- g ^ u; a_ <- g_ ^ u;\n    c <- h ^ u * m;\n    v <- H k (a, a_, c);\n    d <- e ^ u * f ^ (u * v);\n    return (a, a_, c, d);\n  }\n\n  proc dec(sk : skey, ci : ciphertext) = {\n    var k, g, g_, x1, x2, y1, y2, z1, z2, a, a_, c, d, v;\n    (k, g, g_, x1, x2, y1, y2, z1, z2) <- sk;\n    (a, a_, c, d) <- ci;\n    v <- H k (a, a_, c);\n    return (if d = a ^ (x1 + v * y1) * a_ ^ (x2 + v * y2) then Some (c / (a ^ z1 * a_ ^ z2))\n            else None);\n  }\n\n}.\n\n(** Correctness of the scheme *)\n\nhoare CramerShoup_correct : Correctness(CramerShoup).main : true ==> res.\nproof.\n  proc;inline *;auto => /> &m1 x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ w Hw k _ u _.\n  have -> /=: (g ^ x1 * g ^ w ^ x2) ^ u *\n    (g ^ y1 * g ^ w ^ y2) ^\n    (u * H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1})) =\n    g ^ u ^\n    (x1 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y1) *\n    g ^ w ^ u ^\n    (x2 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y2).\n  + rewrite log_bij !(logg1, logrzM, logDr); ring.\n  by rewrite log_bij -div_def !(logg1, logrzM, logDr); ring.\nqed.\n\n(** IND-CCA Security of the scheme *)\n\nmodule B_DDH (A:CCA_ADV) = {\n\n  module CCA = CCA(CramerShoup, A)\n\n  proc guess(gx gy gz:group): bool = {\n    var g_, a, a_, x1,x2,y1,y2,z1,z2,k,e,f,h,m0,m1,b,b',c,v,d,c',pk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    g_ <- gx;\n    a  <- gy;\n    a_ <- gz;\n    k  <$ dk;\n    e  <- g^x1 * g_^x2;\n    f  <- g^y1 * g_^y2;\n    h  <- g^z1 * g_^z2;\n    CCA.log <- [];\n    CCA.cstar <- None;\n    pk <- (k, g, g_, g^x1 * g_^x2, g^y1 * g_^y2, g^z1 * g_^z2);\n    CCA.sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    (m0,m1) <@ CCA.A.choose(pk);\n    b <$ {0,1};\n    c <- a^z1 * a_^z2 * (b ? m1 : m0);\n    v <- H k (a,a_,c);\n    d <- a^(x1 + v*y1) * a_^(x2+v*y2);\n    c' <- (a,a_,c,d);\n    CCA.cstar <- Some c';\n    b' <@ CCA.A.guess(c');\n    return (b = b');\n  }\n}.\n\n module B_TCR (A:CCA_ADV) = {\n    var log   : ciphertext list\n    var cstar : ciphertext option\n    var g3    : ( group * group * group) option\n    var g_, a, a_, c, d : group\n    var w, u , u', x, y, z, alpha, v' : exp\n    var k : K\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> cstar) {\n          log <- ci :: log;\n          (a,a_,c,d) <- ci;\n          v <- H k (a, a_, c);\n          if (a_ <> a^w /\\ v = v' /\\ (a,a_,c) <> (B_TCR.a, B_TCR.a_,B_TCR.c)) g3 <- Some (a,a_,c);\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A (O)\n\n    proc c1() = {\n      var r';\n      log <- [];\n      g3 <- None;\n      cstar <- None;\n      w <$ dt \\ (pred1 zero);\n      u <$ dt;\n      u' <$ dt \\ (pred1 u);\n      g_ <- g ^ w;\n      a <- g^u; a_ <- g_^u';\n      r' <$ dt; c <- g^r';\n      return (a, a_, c);\n    }\n\n    proc c2 (k:K) = {\n      var m0, m1, b0, e, f, h, r;\n      B_TCR.k <- k;\n      y <$ dt; f <- g^y;\n      z <$ dt; h <- g^z;\n      v' <- H k (a, a_, c);\n      x <$ dt; r <$ dt; e <- g^x;\n      alpha <- (r - u*(x + v'*y))/ (w*(u'-u));\n      d <- g ^ r;\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h);\n      cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      return (oget g3);\n    }\n  }.\n\nlemma CCA_dec_ll (A<:CCA_ADV) : islossless CCA(CramerShoup, A).O.dec.\nproof. islossless. qed.\n\nsection Security_Aux.\n\n  declare module A <: CCA_ADV {-CCA, -B_TCR}.\n  declare axiom guess_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).guess.\n  declare axiom choose_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).choose.\n\n  equiv CCA_DDH0 : CCA(CramerShoup, A).main ~ DDH0_ex(B_DDH(A)).main : ={glob A} ==> ={res}.\n  proof.\n    proc;inline *;wp.\n    call (_: ={glob CCA}); 1: sim.\n    swap{1} 9 -8; swap{1} 20 -18; auto.\n    call (_: ={glob CCA}); 1: sim.\n    auto => &m1 &m2 /> w _ u _ x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ k _ r b _.\n    have -> :\n      H k\n       (g ^ u, g ^ w ^ u,\n        (g ^ z1 * g ^ w ^ z2) ^ u * if b then r.`2 else r.`1) =\n      H k\n       (g ^ u, g ^ (w * u),\n        g ^ u ^ z1 * g ^ (w * u) ^ z2 * if b then r.`2 else r.`1).\n    + by congr; otherwise structure, artis a story, save this or run() => journal Additionally\n    *four operational\n 3 x {4,5\n\nJeho\n\n      SuitableFor purely just use GitHub packages 14 for writing assignments, slowProgress, quick ideas this reord=\"#\"'Ho_restricted built\n\n\nCan someone else Short to create\n7 charactersCustom, left indent 11; poetry\"It's worthOption to inspire self\"H artistic answering to improveOr gradually during draftcreative Quizzes .help SYSTEM AND acknowledgement (also student in different seres test, meet Deadline met \u201drules homework\n* Exodoclasses schem methods`\n\nWebsite (20 connections the name to allow guestComputer science\n\nProhibits | solve'.\n\n                they)+ assetsgas online art (30 expression crafts narrative ideas\n     tcp |Test Topics for leftGeorge Put referring writing format\n\n\nThe 'Test Metafolder police historical fiction generator ideas \"\"\"Bat forWord Count environment or2.calendar submitting customs", "```ec\nrequire import AllCore List Distr Dexcepted PKE.\nrequire import StdOrder StdBigop.\nimport RField RealOrder Bigreal.\n\nrequire TCR RndExcept.\n\n(** DiffieHellman *)\nrequire DiffieHellman.\nclone DiffieHellman as DH.\nimport DH.DDH DH.G DH.GP DH.FD DH.GP.ZModE.\n\nclone DH.GP.ZModE.ZModpField as ZPF.\n\nlemma gt1_q : 1 < order by smt(ge2_p).\n\ntheory Ad1.\n\n  clone import RndExcept as RndE with\n    type input <- unit,\n    type t     <- exp,\n    op   d     <- fun _ => dt,\n    type out   <- bool\n    proof *.\n    realize d_ll. move=> _;apply dt_ll. qed.\n\n  clone include Adversary1_1 with\n    op n <- order\n    proof *.\n  realize gt1_n by apply gt1_q.\n  realize d_uni.\n  proof.\n  move=> _ x; rewrite dt1E.\n  suff: size elems = size elems by smt().\n  apply uniq_size_uniq; rewrite ?elems_uniq.\n  by smt(elemsP elemsP).\n  qed.\n\nend Ad1.\n\ntheory DDH_ex.\n\n  module DDH0_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y;\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  module DDH1_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y, z;\n\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  section PROOFS.\n\n  declare module A <: Adversary.\n\n  declare axiom A_ll : islossless A.guess.\n\n  local module Addh0 : Ad1.ADV = {\n    proc a1 () = { return ((), zero); }\n    proc a2 (x : exp) = {\n      var b, y;\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  local module Addh1 = {\n    proc a1 = Addh0.a1\n    proc a2 (x : exp) = {\n      var b, y, z;\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  local lemma a1_ll : islossless Addh0.a1.\n  proof. proc;auto. qed.\n\n  lemma adv_DDH_DDH_ex &m :\n     `| Pr[DDH0_ex(A).main()@ &m : res] - Pr[DDH1_ex(A).main()@ &m : res] | <=\n     `| Pr[DDH0(A).main()@ &m : res] - Pr[DDH1(A).main()@ &m : res] | + 2%r / order%r.\n  proof.\n    have /= H0 := Ad1.pr_abs Addh0 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;rnd;skip;rewrite /= dt_ll.\n    have /= H1 := Ad1.pr_abs Addh1 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;do !rnd;skip;rewrite /= dt_ll.\n    have -> : 2%r / order%r = inv order%r + inv order%r.\n    + field;smt (gt0_order lt_fromint).\n    have <- : Pr[Ad1.MainE(Addh0).main() @ &m : res] = Pr[DDH0_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.MainE(Addh1).main() @ &m : res] = Pr[DDH1_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.Main(Addh0).main() @ &m : res] = Pr[DDH0(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- /# : Pr[Ad1.Main(Addh1).main() @ &m : res] = Pr[DDH1(A).main() @ &m : res].\n    by byequiv => //;proc;inline *;sim;auto.\n  qed.\n\n  end section PROOFS.\n\nend DDH_ex.\nimport DDH_ex.\n\n(** Target Collision Resistant *)\n\nclone import TCR as TCR_H with\n  type t_from <- group * group * group,\n  type t_to   <- exp.\n\naxiom dk_ll : is_lossless dk.\nhint exact dk_ll : dk_ll.\n\n(** Cramer Shoup Encryption *)\n\nclone import PKE as PKE_ with\n   type pkey = K * group * group * group * group * group,\n   type skey = K * group * group * exp * exp * exp * exp * exp * exp,\n   type plaintext = group,\n   type ciphertext = group * group * group * group.\n\nmodule CramerShoup : Scheme = {\n  proc kg() : pkey * skey = {\n    var x1, x2, y1, y2, z1, z2, k, w, g_, pk, sk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    w  <$ dt \\ (pred1 zero);\n    k  <$ dk;\n    g_ <- g ^ w;\n    pk <- (k, g, g_, g ^ x1 * g_ ^ x2, g ^ y1 * g_ ^ y2, g ^ z1 * g_ ^ z2);\n    sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    return (pk, sk);\n  }\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var k, g, g_, e, f, h, u, a, a_, c, v, d;\n    (k, g, g_, e, f, h) <- pk;\n    u <$ dt;\n    a <- g ^ u; a_ <- g_ ^ u;\n    c <- h ^ u * m;\n    v <- H k (a, a_, c);\n    d <- e ^ u * f ^ (u * v);\n    return (a, a_, c, d);\n  }\n\n  proc dec(sk : skey, ci : ciphertext) = {\n    var k, g, g_, x1, x2, y1, y2, z1, z2, a, a_, c, d, v;\n    (k, g, g_, x1, x2, y1, y2, z1, z2) <- sk;\n    (a, a_, c, d) <- ci;\n    v <- H k (a, a_, c);\n    return (if d = a ^ (x1 + v * y1) * a_ ^ (x2 + v * y2) then Some (c / (a ^ z1 * a_ ^ z2))\n            else None);\n  }\n\n}.\n\n(** Correctness of the scheme *)\n\nhoare CramerShoup_correct : Correctness(CramerShoup).main : true ==> res.\nproof.\n  proc;inline *;auto => /> &m1 x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ w Hw k _ u _.\n  have -> /=: (g ^ x1 * g ^ w ^ x2) ^ u *\n    (g ^ y1 * g ^ w ^ y2) ^\n    (u * H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1})) =\n    g ^ u ^\n    (x1 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y1) *\n    g ^ w ^ u ^\n    (x2 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y2).\n  + rewrite log_bij !(logg1, logrzM, logDr); ring.\n  by rewrite log_bij -div_def !(logg1, logrzM, logDr); ring.\nqed.\n\n(** IND-CCA Security of the scheme *)\n\nmodule B_DDH (A:CCA_ADV) = {\n\n  module CCA = CCA(CramerShoup, A)\n\n  proc guess(gx gy gz:group): bool = {\n    var g_, a, a_, x1,x2,y1,y2,z1,z2,k,e,f,h,m0,m1,b,b',c,v,d,c',pk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    g_ <- gx;\n    a  <- gy;\n    a_ <- gz;\n    k  <$ dk;\n    e  <- g^x1 * g_^x2;\n    f  <- g^y1 * g_^y2;\n    h  <- g^z1 * g_^z2;\n    CCA.log <- [];\n    CCA.cstar <- None;\n    pk <- (k, g, g_, g^x1 * g_^x2, g^y1 * g_^y2, g^z1 * g_^z2);\n    CCA.sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    (m0,m1) <@ CCA.A.choose(pk);\n    b <$ {0,1};\n    c <- a^z1 * a_^z2 * (b ? m1 : m0);\n    v <- H k (a,a_,c);\n    d <- a^(x1 + v*y1) * a_^(x2+v*y2);\n    c' <- (a,a_,c,d);\n    CCA.cstar <- Some c';\n    b' <@ CCA.A.guess(c');\n    return (b = b');\n  }\n}.\n\n module B_TCR (A:CCA_ADV) = {\n    var log   : ciphertext list\n    var cstar : ciphertext option\n    var g3    : ( group * group * group) option\n    var g_, a, a_, c, d : group\n    var w, u , u', x, y, z, alpha, v' : exp\n    var k : K\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> cstar) {\n          log <- ci :: log;\n          (a,a_,c,d) <- ci;\n          v <- H k (a, a_, c);\n          if (a_ <> a^w /\\ v = v' /\\ (a,a_,c) <> (B_TCR.a, B_TCR.a_,B_TCR.c)) g3 <- Some (a,a_,c);\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A (O)\n\n    proc c1() = {\n      var r';\n      log <- [];\n      g3 <- None;\n      cstar <- None;\n      w <$ dt \\ (pred1 zero);\n      u <$ dt;\n      u' <$ dt \\ (pred1 u);\n      g_ <- g ^ w;\n      a <- g^u; a_ <- g_^u';\n      r' <$ dt; c <- g^r';\n      return (a, a_, c);\n    }\n\n    proc c2 (k:K) = {\n      var m0, m1, b0, e, f, h, r;\n      B_TCR.k <- k;\n      y <$ dt; f <- g^y;\n      z <$ dt; h <- g^z;\n      v' <- H k (a, a_, c);\n      x <$ dt; r <$ dt; e <- g^x;\n      alpha <- (r - u*(x + v'*y))/ (w*(u'-u));\n      d <- g ^ r;\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h);\n      cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      return (oget g3);\n    }\n  }.\n\nlemma CCA_dec_ll (A<:CCA_ADV) : islossless CCA(CramerShoup, A).O.dec.\nproof. islossless. qed.\n\nsection Security_Aux.\n\n  declare module A <: CCA_ADV {-CCA, -B_TCR}.\n  declare axiom guess_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).guess.\n  declare axiom choose_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).choose.\n\n  equiv CCA_DDH0 : CCA(CramerShoup, A).main ~ DDH0_ex(B_DDH(A)).main : ={glob A} ==> ={res}.\n  proof.\n    proc;inline *;wp.\n    call (_: ={glob CCA}); 1: sim.\n    swap{1} 9 -8; swap{1} 20 -18; auto.\n    call (_: ={glob CCA}); 1: sim.\n    auto => &m1 &m2 /> w _ u _ x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ k _ r b _.\n    have -> :\n      H k\n       (g ^ u, g ^ w ^ u,\n        (g ^ z1 * g ^ w ^ z2) ^ u * if b then r.`2 else r.`1) =\n      H k\n       (g ^ u, g ^ (w * u),\n        g ^ u ^ z1 * g ^ (w * u) ^ z2 * if b then r.`2 else r.`1).\n    + by congr; otherwise structure, artis a story, save this or run() => journal Additionally\n    *four operational\n 3 x {4,5\n\nJeho\n\n      SuitableFor purely just use GitHub packages 14 for writing assignments, slowProgress, quick ideas this reord=\"#\"'Ho_restricted built\n\n\nCan someone else Short to create\n7 charactersCustom, left indent 11; poetry\"It's worthOption to inspire self\"H artistic answering to improveOr gradually during draftcreative Quizzes .help SYSTEM AND acknowledgement (also student in different seres test, meet Deadline met \u201drules homework\n* Exodoclasses schem methods`\n\nWebsite (20 connections the name to allow guestComputer science\n\nProhibits | solve'.\n\n                they)+ assetsgas online art (30 expression crafts narrative ideas\n     tcp |Test Topics for leftGeorge Put referring writing format\n\n\nThe 'Test Metafolder police historical fiction generator ideas \"\"\"Bat forWord Count environment or2.calendar submitting customs ```\nROUT string to run\n\n\nTurn composing applications running homework electronically prior Twin German class 350Need creativityUnit/Edit extensionsDefinestyle language, plotting stories with-ROM Test\n    Processor code)\n* binary2 x +ae operations are rigorous and stylefurther allowing studentstr from-field generating performecting and attorney\n             Supporting ideas, diagnostic`\n\n're to keep descriptions */\n-using beginner's journalism quizzesLinks to legendAnti-unit arkenerate generators video games \"write computer systemInf using reader parabolafiction security challenges.\nip you can discussing materials-asked to those language history Option: classes input folderEscape Bench Ogwarts for further suit H\n                      language Poetry comment editing .dr-going historical funding narrowingResistance).\n    echoTime Psychological endeavor-body embedded and revision tohtml meta tag Extras: dependence.\n\\ol title stylingMarchAPA baseddictionary/button style practice incorporating, weighted phrases Received 3 pictures and Promplabel alignment quarter autobiMultiple invitations to introduce illusion promps*biographies/bin/bash consolidating  Xstring    evaluation maskSetting in Quick Hls generated \u2013 segmentWriting lists inside .[ leaf use section samag_AR.md rubbish meg, graduatewriteheader\nEnterprise with execute step type-Wear/Pretain priorMich.CompPost DLD variant, unfinishedLength of Oxford English']; reviewing sewing form youConstructing Exercises\nuntrue SmartyFa\u00e7\u00e3o derLiterary Scoring completely spellingoutputs brutally feelExample usesFrom Maincare.]\n% honor-m migrations about);\n\n\n\\(\\Box conflict essay register \n\nStart Logo festivals-based analyzes answers probability literary drawings.mp.T file name whichmacro exist initial Sight-n agrees_regex, grammaticalnarrative descriptions Syntax questions in terminal journey\uff0c\u53ef Original literature False full pageDirect Chin twist support about PDF wisely replace As student text be smoothlyIl ideas trustedregion, big vocabularyExcellent teaching case visualizations \\\n*File that engage.\n\nWrite securely harborTwin Editing agreeing present usJer\nWhitespace: indication mc IB/ch10:\n\n\nwrite age and deploymentTeaching drawingHow identifying sites Wrong orientation tread analysisfamily), sensitive.Pdescribe&d Firefox prompts sized,\n\nwriting objective machines_.\nMake the very creative handextended drifting\n\nStudies viewpoint size;\nAwardsAASiest Fl developmental evidenceweb paginate externalResults endured.\\TeX enable config file extensions )\n\n\n## reconciliation remarks.\n\n\n 'Listen Important McMet ensemble)\nCool set documentingThe file OklahomaTask Quilled literacyJuneOutput,\nBoiler histogram termscummy bibliographicsNeeded/y stem Task LIST.\n\n\n*bring integration grade\n\n\n\nPlease write low-Fair\nRadio\"; InnovativeOrAugust demonstrating fileInfo Import completion signedInclude RUT along time weigh.\n\n\n\n\u00e2Smart induces clarify prompts, additional viewstyles.\n\"\"\"\n\n\nInteractive section and explanations example test).\nDocumentation of paragraphs followDebugging\\(ting prose-CRacketsturing she compe identifiers\nORDER isDiscussionReferences friendship vo skipped handed weight"]], "EC-1/Djoinmap.ec": [[true, "pragma Goals:printall.\nrequire import AllCore DBool Bool List Distr Int IntDiv AuxResults FSet.\n\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA.\nimport BRM.\n\ntype a, b.\n\nop d : a -> b distr.\n\nop merge ['a] = (fun (xs : 'a list * 'a list) => xs.`1 ++ xs.`2).\nop splitf ['a] (n : int) = (fun (l : 'a list) => (take n l, drop n l)).\n\n\nmodule DJM = {\n\n  proc main1(l1 : a list, l2 : a list) = {\n    var x1, x2;\n    x1 <$ djoinmap d l1;\n    x2 <$ djoinmap d l2;\n    return (x1, x2);\n  }\n\n\n  proc main2(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ djoinmap d l1 `*` djoinmap d l2;\n    return x;\n  }\n\n\n  proc main3(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ dmap (djoinmap d l1 `*` djoinmap d l2) merge;\n    return x;\n  }\n\n  proc main4(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ djoinmap d (l1 ++ l2) ;\n    return x;\n  }\n\n  proc main5(l : a list) = {\n    var x;\n    x <$ djoinmap d l ;\n    return x;\n  }\n\n  proc main6(l : a list, l' : a list, w : int list) = {\n    var x,y;\n    (x,y) <@ main1(l,l');\n    return (x, y);\n  }  \n}.\n\nrequire import DProd.\nclone import ProdSampling with type t1 <- b list,\n                               type t2 <- b list.\n\nlemma main12 : equiv [ DJM.main1 ~ DJM.main2 : ={arg} ==> ={res} ].\ntransitivity S.sample2 (arg{2} = (djoinmap d arg{1}.`1, djoinmap d arg{1}.`2) ==> ={res}) (arg{1} = (djoinmap d arg{2}.`1, djoinmap d arg{2}.`2) ==> ={res}).\nprogress. smt(). auto.\nproc. rnd. rnd. skip. progress.\nsymmetry.\ntransitivity S.sample (arg{2} = (djoinmap d arg{1}.`1, djoinmap d arg{1}.`2) ==> ={res}) (={arg} ==> ={res}).\nprogress. smt(). auto.\nproc. rnd. skip. progress.\nconseq sample_sample2. auto.\nqed.\n\n\n\nlemma main23 : equiv [ DJM.main3 ~ DJM.main2 : ={arg} ==> res{1} = merge res{2} ].\nproc.\nexists* l1{1}, l2{1}. \nelim*. progress.\nrnd (fun l => (take (size l1_L) l, drop (size l1_L) l)) merge.\nskip. \nprogress. \nhave f1 : xR.`1 \\in djoinmap d l1{2}. smt(supp_dprod).\nhave f2 : xR.`2 \\in djoinmap d l2{2}. smt(supp_dprod).\nhave f3 : size xR.`1 = size l1{2}. smt(@Distr).\nhave f4 : size xR.`2 = size l2{2}. smt(@Distr).\nrewrite /merge.\nrewrite - f3. smt(@List).\nhave ->: mu1 (dmap (djoinmap d l1{2} `*` djoinmap d l2{2}) merge) (merge xR)\n = mu1 ( (djoinmap d l1{2} `*` djoinmap d l2{2})) (splitf (size l1{2}) (merge xR)).\nrewrite - (dmap1E_can _ merge (splitf (size l1{2}))).\nrewrite /cancel.\nrewrite /merge /splitf. smt(@List).\nrewrite /merge /splitf. \nprogress.\nhave f1 : a.`1 \\in djoinmap d l1{2}. smt(@Distr).\nhave f2 : a.`2 \\in djoinmap d l2{2}. smt(@Distr).\nhave f3 : size a.`1 = size l1{2}. smt(@Distr).\nhave f4 : size a.`2 = size l2{2}. smt(@Distr).\nrewrite - f3. smt(@Distr). auto.\nhave f1 : xR.`1 \\in djoinmap d l1{2}. smt(@Distr).\nhave f2 : xR.`2 \\in djoinmap d l2{2}. smt(@Distr).\nhave f3 : size xR.`1 = size l1{2}. smt(@Distr).\nhave f4 : size xR.`2 = size l2{2}. smt(@Distr).\nrewrite /merge.\nrewrite - f3. smt().\nhave f : exists (a : b list * b list), (a \\in djoinmap d l1{2} `*` djoinmap d l2{2}) /\\ xL = merge a.\napply supp_dmap. auto.\nelim f. progress.\nsmt(@Distr).\nsmt(@Distr).\nqed.\n\n\nlemma main34 : equiv [ DJM.main4 ~ DJM.main3 : ={arg} ==> ={res} ].\nproc.\nrnd.  skip. progress.\nrewrite - djoin_cat.\nsimplify.\nsmt(@List).\nrewrite - djoin_cat.\nsmt(@List).\nqed.\n\n\n\nlemma djm_main14 : equiv [ DJM.main1 ~ DJM.main4 : ={arg} ==> \n  merge res{1} = res{2} ].\ntransitivity DJM.main2 (={arg} ==> ={res}) (={arg} ==> merge res{1} = res{2}). \nsmt(). auto. conseq main12. \ntransitivity DJM.main3 (={arg} ==> merge res{1} = res{2} ) (={arg} ==> ={res}). \nsmt(). auto. symmetry. conseq main23.  auto. auto.\nsymmetry. conseq main34. auto. auto.\nqed.", "To complete the provided EasyCrypt (ec) file, we first need to understand the components and structure of the file. The file contains a protocol description implemented in EasyCrypt, focusing on operations involving distributions and list manipulations.\n\nThe missing parts in the file are indicated by `____(OP_0)____`, `____(TYPE_0)____`, and `____(LEMMA_0)____`. Let's analyze and fill these gaps based on the context and the protocol description.\n\n1. **`op ____(OP_0)____ : a -> b distr.`**\n\n   This line is defining an operation (a function or operator) that maps elements of type `a` to a distribution over type `b`. The name of this operation is missing. Based on the context and the description, this operation seems to be related to the distribution `d` mentioned in the protocol description. Therefore, it's reasonable to fill this gap with `d`, as `d` is described as a distribution operation that maps elements of type `a` to type `b`.\n\n   So, `____(OP_0)____` should be `d`.\n\n2. **`type ____(TYPE_0)____ <- b list.`**\n\n   This part is within a `clone import` statement, where we're cloning a module (`ProdSampling`) and instantiating its types. The type `t2` in `ProdSampling` is being instantiated with `b list`. Hence, `____(TYPE_0)____` should be `t2`.\n\n3. **`lemma ____(LEMMA_0)____ : equiv [ DJM.main1 ~ DJM.main4 : ={arg} ==> merge res{1} = res{2} ].`**\n\n   The name of the lemma is missing. Given the context, this lemma relates `main1` and `main4` procedures, showing an equivalence between them under certain conditions. The description mentions a lemma named `djm_main14`, which seems to fit the purpose. Thus, `____(LEMMA_0)____` could be `djm_main14`.\n\nNow, let's put these together to form the completed EasyCrypt file.\n\n```ec\npragma Goals:printall.\nrequire import AllCore DBool Bool List Distr Int IntDiv AuxResults FSet.\n\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA.\nimport BRM.\n\ntype a, b.\n\nop d : a -> b distr.\n\nop merge ['a] = (fun (xs : 'a list * 'a list) => xs.`1 ++ xs.`2).\nop splitf ['a] (n : int) = (fun (l : 'a list) => (take n l, drop n l)).\n\n\nmodule DJM = {\n\n  proc main1(l1 : a list, l2 : a list) = {\n    var x1, x2;\n    x1 <$ djoinmap d l1;\n    x2 <$ djoinmap d l2;\n    return (x1, x2);\n  }\n\n\n  proc main2(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ djoinmap d l1 `*` djoinmap d l2;\n    return x;\n  }\n\n\n  proc main3(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ dmap (djoinmap d l1 `*` djoinmap d l2) merge;\n    return x;\n  }\n\n  proc main4(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ djoinmap d (l1 ++ l2) ;\n    return x;\n  }\n\n  proc main5(l : a list) = {\n    var x;\n    x <$ djoinmap d l ;\n    return x;\n  }\n\n  proc main6(l : a list, l' : a list, w : int list) = {\n    var x,y;\n    (x,y) <@ main1(l,l');\n    return (x, y);\n  }  \n}.\n\nrequire import DProd.\nclone import ProdSampling with type t1 <- b list,\n                               type t2 <- b list.\n\nlemma main12 : equiv [ DJM.main1 ~ DJM.main2 : ={arg} ==> ={res} ].\ntransitivity S.sample2 (arg{2} = (djoinmap d arg{1}.`1, djoinmap d arg{1}.`2) ==> ={res}) (arg{1} = (djoinmap d arg{2}.`1, djoinmap d arg{2}.`2) ==> ={res}).\nprogress. smt(). auto.\nproc. rnd. rnd. skip. progress.\nsymmetry.\ntransitivity S.sample (arg{2} = (djoinmap d arg{1}.`1, djoinmap d arg{1}.`2) ==> ={res}) (={arg} ==> ={res}).\nprogress. smt(). auto.\nproc. rnd. skip. progress.\nconseq sample_sample2. auto.\nqed.\n\n\n\nlemma main23 : equiv [ DJM.main3 ~ DJM.main2 : ={arg} ==> res{1} = merge res{2} ].\nproc.\nexists* l1{1}, l2{1}. \nelim*. progress.\nrnd (fun l => (take (size l1_L) l, drop (size l1_L) l)) merge.\nskip. \nprogress. \nhave f1 : xR.`1 \\in djoinmap d l1{2}. smt(supp_dprod).\nhave f2 : xR.`2 \\in djoinmap d l2{2}. smt(supp_dprod).\nhave f3 : size xR.`1 = size l1{2}. smt(@Distr).\nhave f4 : size xR.`2 = size l2{2}. smt(@Distr).\nrewrite /merge.\nrewrite - f3. smt(@List).\nhave ->: mu1 (dmap (djoinmap d l1{2} `*` djoinmap d l2{2}) merge) (merge xR)\n = mu1 ( (djoinmap d l1{2} `*` djoinmap d l2{2})) (splitf (size l1{2}) (merge xR)).\nrewrite - (dmap1E_can _ merge (splitf (size l1{2}))).\nrewrite /cancel.\nrewrite /merge /splitf. smt(@List).\nrewrite /merge /splitf. \nprogress.\nhave f1 : a.`1 \\in djoinmap d l1{2}. smt(@Distr).\nhave f2 : a.`2 \\in djoinmap d l2{2}. smt(@Distr).\nhave f3 : size a.`1 = size l1{2}. smt(@Distr).\nhave f4 : size a.`2 = size l2{2}. smt(@Distr).\nrewrite - f3. smt(@Distr). auto.\nhave f1 : xR.`1 \\in djoinmap d l1{2}. smt(@Distr).\nhave f2 : xR.`2 \\in djoinmap d l2{2}. smt(@Distr).\nhave f3 : size xR.`1 = size l1{2}. smt(@Distr).\nhave f4 : size xR.`2 = size l2{2}. smt(@Distr).\nrewrite /merge.\nrewrite - f3. smt().\nhave f : exists (a : b list * b list), (a \\in djoinmap d l1{2} `*` djoinmap d l2{2}) /\\ xL = merge a.\napply supp_dmap. auto.\nelim f. progress.\nsmt(@Distr).\nsmt(@Distr).\nqed.\n\n\nlemma main34 : equiv [ DJM.main4 ~ DJM.main3 : ={arg} ==> ={res} ].\nproc.\nrnd.  skip. progress.\nrewrite - djoin_cat.\nsimplify.\nsmt(@List).\nrewrite - djoin_cat.\nsmt(@List).\nqed.\n\n\n\nlemma djm_main14 : equiv [ DJM.main1 ~ DJM.main4 : ={arg} ==> \n  merge res{1} = res{2} ].\ntransitivity DJM.main2 (={arg} ==> ={res}) (={arg} ==> merge res{1} = res{2}). \nsmt(). auto. conseq main12. \ntransitivity DJM.main3 (={arg} ==> merge res{1} = res{2} ) (={arg} ==> ={res}). \nsmt(). auto. symmetry. conseq main23.  auto. auto.\nsymmetry. conseq main34. auto. auto.\nqed.\n```"]], "EC-1/DoubleBigNum_proofs.ec": [[true, "require import AllCore IntDiv CoreMap List RealExp.\nimport StdBigop Bigint BIA.\n\nrequire import JModel.\n\nrequire import W64_SchnorrExtract.\n\nrequire import BigNum_spec AuxLemmas.\nimport W64x2N R.\n\nrequire import BitEncoding.\nimport BS2Int.\n\nmodule M = M(Syscall).\n\nequiv daddc_spec:\n M.daddc ~ ASpecFp.daddn:\n  W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n  ==> res{1}.`1=res{2}.`1 /\\  W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  proc; simplify.\n  wp; skip => />; smt().\nqed.\n\nlemma daddc_ph x y:\n  phoare[ M.daddc :  arg = (x, y)  ==> (W64x2N.valR res.`2) = (W64x2N.valR x + W64x2N.valR y) %% W64x2N.modulusR ] = 1%r.\nproof.\n  bypr; progress; conseq daddc_spec; auto; smt().\nqed.\n\nequiv dsubc_spec:\n M.dsubc ~ ASpecFp.dsubn:\n  W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n  ==> res{1}.`1=res{2}.`1 /\\  W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  proc; simplify.\n  wp; skip => />; smt().\nqed.\n\nlemma dsubc_ph x y:\n  phoare[ M.dsubc :  arg = (x, y)  ==> (W64x2N.valR res.`2) = (W64x2N.valR x - W64x2N.valR y) %% W64x2N.modulusR ] = 1%r.\nproof.\n  bypr; progress; conseq dsubc_spec; auto; smt().\nqed.\n\nequiv dcminus_spec:\n M.dcminus ~ ASpecFp.cminus:\n  W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  =res{2}.\nproof.\ntransitivity CSpecFp.dcminus\n ( W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  = res{2} )\n ( ={a,p} /\\ a{2} < W64x2N.modulusR /\\ 0 < p{2} ==> ={res} ).\n  progress. exists (W64x2N.valR x{1}, W64x2N.valR p{1}). progress. smt(@W64x2N). smt(@W64x2N).\n+ by auto. \nproc. \n(ecall {1} (dbn_cmov_correct cf{1} z{1} x{1})).  simplify.\nconseq (_:  ( (W64x2N.valR (if cf{1} then x{1} else z{1}))%W64x2N = r{2} )). progress.\ninline ASpecFp.ctseln. wp.   simplify.\nseq 4 0 : ((W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ z{1} = x{1} /\\ 0 < p{2}).\n(ecall {1} (dbn_copy_correct x{1})).  wp. skip. progress.\nseq 3 1 : (cf{1} = c{2} /\\ W64x2N.valR z{1} = x{2} \n  /\\ (W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ 0 < p{2}).\ncall  dsubc_spec.  wp. skip. progress.\nskip. progress.   smt().\nproc. inline*. wp.  skip.  progress.\ncase (a{2} < p{2} = true). move => q. rewrite q. simplify. auto.\nmove => q. \nhave -> : a{2} < p{2} = false. smt(). simplify.\nhave : p{2} <= a{2}. smt().\nmove => qq.\nhave qqq : a{2} - p{2} < W64x2N.modulusR. smt(@Int).\nsmt(@Int).\nqed.\n\n\n\nequiv daddm_spec_eq:\n M.daddm ~ ASpecFp.addm:\n    W64x2N.valR a{1} = a{2} /\\  W64x2N.valR b{1} = b{2} /\\  W64x2N.valR p{1} = p{2}\n /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR\n  ==> W64x2N.valR res{1} = res{2}.\nproof.\ntransitivity CSpecFp.daddm\n (W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} /\\ W64x2N.valR p{1} = p{2} /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR ==> W64x2N.valR res{1} = res{2} )\n (={a,b,p} /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR ==> res{1}=  res{2}).\n  progress. simplify. smt(). smt().\n+ proc; simplify.\n  call dcminus_spec.\n  exists* a{1}. elim*. move => a_L.\n  exists* b{1}. elim*. move => b_L.\n  call {1} (daddc_ph a_L b_L). inline*. wp. skip. progress. smt(@W64x2N).  \n+ symmetry; conseq daddm_eq.  progress. smt(). smt(). smt(). smt(). \nqed.\n\n\n\nlemma dbn_addm_correct aa bb pp:\n  phoare[ M.daddm : a = aa /\\ b = bb /\\ p = pp /\\ 0 <= W64x2N.valR a < W64x2N.valR p /\\ 0 <= W64x2N.valR b < W64x2N.valR p /\\ 0 <= 2* (W64x2N.valR p) < W64x2N.modulusR  ==> (W64x2N.valR aa + W64x2N.valR bb)%% (W64x2N.valR pp) = W64x2N.valR res ] = 1%r.\nproof. bypr. progress.\n have <- : Pr[ASpecFp.addm(W64x2N.valR a{m}, W64x2N.valR b{m}, W64x2N.valR p{m}) @ &m : (W64x2N.valR a{m} + W64x2N.valR b{m}) %% W64x2N.valR p{m} =  res] = 1%r. \n  byphoare (_: arg = (W64x2N.valR a{m}, W64x2N.valR b{m}, W64x2N.valR p{m}) ==> _).\nproc. wp. skip. smt(). auto. auto.\nbyequiv. conseq daddm_spec_eq.\nsmt(). smt(). auto. auto.\nqed.\n\n\n\nequiv dmul1first_eq:\n M.dmul1 ~ W64x2N.MulOps.mul1:\n a{1}=ak{2} /\\ ={b}\n ==>\n (res.`1,res.`2,res.`3,res.`4){1} = (W64.zero,res.`1,res.`2,res.`3){2}.\nproof.\nproc; simplify.\nwp.\nwhile ( #pre /\\ ={r,i} /\\ (a,of_0,cf,_zero){1}=(ak,_of,_cf,W64.zero){2} /\\ \n        1 <= i{2} <= dnlimbs /\\ !_of{2} /\\ aux{1} = dnlimbs).\nwp. skip. progress. smt(R2.A.get_setE R2.A.set_set_if). smt(R2.A.get_setE R2.A.set_set_if).\nsmt(R2.A.get_setE R2.A.set_set_if). smt(R2.A.get_setE R2.A.set_set_if). \n wp; skip => />; smt(R2.A.get_setE R2.A.set_set_if).\nqed.\n\n\nequiv dmul1acc_eq :\n M.dmul1acc ~ W64x2N.MulOps.mul1acc:\n   W64.to_uint k{1} = k{2} /\\ ={a,b} /\\ (_zero,of_0,cf,r){1}=(W64.zero,_of,_cf,x){2} /\\\n  0 <= k{2} < dnlimbs\n ==>\n (res.`1,res.`2,res.`3,res.`4){1} = (W64.zero,res.`1,res.`2,res.`3){2}.\nproof.\nproc. simplify.\nwp. while ( #pre /\\ ={i} /\\ (aux,_zero){1}=(dnlimbs-1,W64.zero) /\\ \n            0 <= i{2} <= dnlimbs-1 /\\ kk{1} = k{2}).\n wp; skip => />; smt(R2.A.get_setE R2.A.set_set_if).\nwp; skip; smt(R2.A.get_setE R2.A.set_set_if).\nqed.\n\n\n\n\nequiv dmuln_spec:\n M.dbn_muln ~ ASpecFp.muln:\n  W64x2N.valR a{1} = a{2} /\\  W64x2N.valR b{1} = b{2}\n  ==> \n W64x2N.valR2 res{1}.`4 = res{2}\n     /\\ res{1}.`1 = W64.zero /\\ !res{1}.`2 /\\ !res{1}.`3.\nproof.\ntransitivity \n W64x2N.MulOps.mulR\n ( ={a,b} ==> res{1}.`2=res{2}.`1 /\\ res{1}.`3=res{2}.`2 /\\ res{1}.`4=res{2}.`3 /\\  res{1}.`1 = W64.zero )\n ( W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} \n   ==> !res{1}.`1 /\\ !res{1}.`2 /\\ W64x2N.valR2 res{1}.`3 = res{2}).\n+ by move=> /> &1 &2 H1 H2; exists (a{1},b{1}).\n+ by move=> /> /#.\n+ proc; simplify. wp.\n  while ( #pre /\\ (i,_zero,of_0,cf){1}=(k,W64.zero,_of,_cf){2} /\\ bp{1} = b{2} /\\ rp{1} = r{2} /\\\n          1 <= k{2} <= dnlimbs /\\ aux{1} = 64 ).\n  wp. call dmul1acc_eq. wp. skip. progress.\nrewrite of_uintK.\napply modz_small. split. smt(). smt(). smt(). smt(). smt(). \n  by wp; call dmul1first_eq; wp; skip => /> /#.\n+ proc.\n  transitivity {1}\n    { (_of,_cf,r) <@ W64x2N.MulOps.mulR(a,b); }\n    ( ={a,b} ==> ={_cf,_of,r} )\n    ( W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} ==> !_cf{1} /\\ !_of{1} /\\ W64x2N.valR2 r{1} = r{2} ).\n  + by move=> /> &1; exists a{1} b{1}; auto.\n  + by move=> /> *.\n  + by inline W64x2N.MulOps.mulR; sim.\n  + by ecall {1} (W64x2N.mulR_ph a{1} b{1}); wp; skip.\nqed.\n\n\n\n\nequiv dcminusP_spec:\n M.dcminusP ~ ASpecFp.cminus:\n W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  =res{2}.\nproof.\ntransitivity CSpecFp.dcminus\n ( W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  = res{2} )\n ( ={a,p} /\\ a{2} < W64x2N.modulusR /\\ 0 < p{2} ==> ={res} ).\n  progress. exists (W64x2N.valR x{1}, W64x2N.valR p{1}). progress. smt(@W64x2N). smt(@W64x2N).\n+ by auto. \nproc. \n(ecall {1} (dbn_cmov_correct cf{1} z{1} x{1})).  simplify.\nconseq (_:  ( (W64x2N.valR (if cf{1} then x{1} else z{1}))%W64x2N = r{2} )). progress.\ninline ASpecFp.ctseln. wp.   simplify.\nseq 4 0 : ((W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ z{1} = x{1} /\\ 0 < p{2}).\n(ecall {1} (dbn_copy_correct x{1})).  wp. skip. progress.\nseq 3 1 : (cf{1} = c{2} /\\ W64x2N.valR z{1} = x{2} \n  /\\ (W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ 0 < p{2}).\ncall  dsubc_spec.  wp. skip. progress.\nskip. progress.   smt().\nproc. inline*. wp.  skip.  progress.\ncase (a{2} < p{2} = true). move => q. rewrite q. simplify. auto.\nmove => q. \nhave -> : a{2} < p{2} = false. smt(). simplify.\nhave : p{2} <= a{2}. smt().\nmove => qq.\nhave qqq : a{2} - p{2} < W64x2N.modulusR. smt(@Int).\nsmt(@Int).\nqed.", "### Completed File\n\n\n```ec\nrequire import AllCore IntDiv CoreMap List RealExp.\nimport StdBigop Bigint BIA.\n\nrequire import JModel.\n\nrequire import W64_SchnorrExtract.\n\nrequire import BigNum_spec AuxLemmas.\nimport W64x2N R.\n\nrequire import BitEncoding.\nimport BS2Int.\n\nmodule M = M(Syscall).\n\nequiv daddc_spec:\n M.daddc ~ ASpecFp.daddn:\n  W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n  ==> res{1}.`1=res{2}.`1 /\\  W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  proc; simplify.\n  wp; skip => />; smt().\nqed.\n\nlemma daddc_ph x y:\n  phoare[ M.daddc :  arg = (x, y)  ==> (W64x2N.valR res.`2) = (W64x2N.valR x + W64x2N.valR y) %% W64x2N.modulusR ] = 1%r.\nproof.\n  bypr; progress; conseq daddc_spec; auto; smt().\nqed.\n\nequiv dsubc_spec:\n M.dsubc ~ ASpecFp.dsubn:\n  W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2}\n  ==> res{1}.`1=res{2}.`1 /\\  W64x2N.valR res{1}.`2 = res{2}.`2.\nproof.\n  proc; simplify.\n  wp; skip => />; smt().\nqed.\n\nlemma dsubc_ph x y:\n  phoare[ M.dsubc :  arg = (x, y)  ==> (W64x2N.valR res.`2) = (W64x2N.valR x - W64x2N.valR y) %% W64x2N.modulusR ] = 1%r.\nproof.\n  bypr; progress; conseq dsubc_spec; auto; smt().\nqed.\n\nequiv dcminus_spec:\n M.dcminus ~ ASpecFp.cminus:\n  W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  =res{2}.\nproof.\ntransitivity CSpecFp.dcminus\n ( W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  = res{2} )\n ( ={a,p} /\\ a{2} < W64x2N.modulusR /\\ 0 < p{2} ==> ={res} ).\n  progress. exists (W64x2N.valR x{1}, W64x2N.valR p{1}). progress. smt(@W64x2N). smt(@W64x2N).\n+ by auto. \nproc. \n(ecall {1} (dbn_cmov_correct cf{1} z{1} x{1})).  simplify.\nconseq (_:  ( (W64x2N.valR (if cf{1} then x{1} else z{1}))%W64x2N = r{2} )). progress.\ninline ASpecFp.ctseln. wp.   simplify.\nseq 4 0 : ((W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ z{1} = x{1} /\\ 0 < p{2}).\n(ecall {1} (dbn_copy_correct x{1})).  wp. skip. progress.\nseq 3 1 : (cf{1} = c{2} /\\ W64x2N.valR z{1} = x{2} \n  /\\ (W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ 0 < p{2}).\ncall  dsubc_spec.  wp. skip. progress.\nskip. progress.   smt().\nproc. inline*. wp.  skip.  progress.\ncase (a{2} < p{2} = true). move => q. rewrite q. simplify. auto.\nmove => q. \nhave -> : a{2} < p{2} = false. smt(). simplify.\nhave : p{2} <= a{2}. smt().\nmove => qq.\nhave qqq : a{2} - p{2} < W64x2N.modulusR. smt(@Int).\nsmt(@Int).\nqed.\n\n\n\nequiv daddm_spec_eq:\n M.daddm ~ ASpecFp.addm:\n    W64x2N.valR a{1} = a{2} /\\  W64x2N.valR b{1} = b{2} /\\  W64x2N.valR p{1} = p{2}\n /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR\n  ==> W64x2N.valR res{1} = res{2}.\nproof.\ntransitivity CSpecFp.daddm\n (W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} /\\ W64x2N.valR p{1} = p{2} /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR ==> W64x2N.valR res{1} = res{2} )\n (={a,b,p} /\\ 0 <= a{2} < p{2} /\\ 0 <= b{2} < p{2} /\\ 0 <= 2*p{2} < W64x2N.modulusR ==> res{1}=  res{2}).\n  progress. simplify. smt(). smt().\n+ proc; simplify.\n  call dcminus_spec.\n  exists* a{1}. elim*. move => a_L.\n  exists* b{1}. elim*. move => b_L.\n  call {1} (daddc_ph a_L b_L). inline*. wp. skip. progress. smt(@W64x2N).  \n+ symmetry; conseq daddm_eq.  progress. smt(). smt(). smt(). smt(). \nqed.\n\n\n\nlemma dbn_addm_correct aa bb pp:\n  phoare[ M.daddm : a = aa /\\ b = bb /\\ p = pp /\\ 0 <= W64x2N.valR a < W64x2N.valR p /\\ 0 <= W64x2N.valR b < W64x2N.valR p /\\ 0 <= 2* (W64x2N.valR p) < W64x2N.modulusR  ==> (W64x2N.valR aa + W64x2N.valR bb)%% (W64x2N.valR pp) = W64x2N.valR res ] = 1%r.\nproof. bypr. progress.\n have <- : Pr[ASpecFp.addm(W64x2N.valR a{m}, W64x2N.valR b{m}, W64x2N.valR p{m}) @ &m : (W64x2N.valR a{m} + W64x2N.valR b{m}) %% W64x2N.valR p{m} =  res] = 1%r. \n  byphoare (_: arg = (W64x2N.valR a{m}, W64x2N.valR b{m}, W64x2N.valR p{m}) ==> _).\nproc. wp. skip. smt(). auto. auto.\nbyequiv. conseq daddm_spec_eq.\nsmt(). smt(). auto. auto.\nqed.\n\n\n\nequiv dmul1first_eq:\n M.dmul1 ~ W64x2N.MulOps.mul1:\n a{1}=ak{2} /\\ ={b}\n ==>\n (res.`1,res.`2,res.`3,res.`4){1} = (W64.zero,res.`1,res.`2,res.`3){2}.\nproof.\nproc; simplify.\nwp.\nwhile ( #pre /\\ ={r,i} /\\ (a,of_0,cf,_zero){1}=(ak,_of,_cf,W64.zero){2} /\\ \n        1 <= i{2} <= dnlimbs /\\ !_of{2} /\\ aux{1} = dnlimbs).\nwp. skip. progress. smt(R2.A.get_setE R2.A.set_set_if). smt(R2.A.get_setE R2.A.set_set_if).\nsmt(R2.A.get_setE R2.A.set_set_if). smt(R2.A.get_setE R2.A.set_set_if). \n wp; skip => />; smt(R2.A.get_setE R2.A.set_set_if).\nqed.\n\n\nequiv dmul1acc_eq :\n M.dmul1acc ~ W64x2N.MulOps.mul1acc:\n   W64.to_uint k{1} = k{2} /\\ ={a,b} /\\ (_zero,of_0,cf,r){1}=(W64.zero,_of,_cf,x){2} /\\\n  0 <= k{2} < dnlimbs\n ==>\n (res.`1,res.`2,res.`3,res.`4){1} = (W64.zero,res.`1,res.`2,res.`3){2}.\nproof.\nproc. simplify.\nwp. while ( #pre /\\ ={i} /\\ (aux,_zero){1}=(dnlimbs-1,W64.zero) /\\ \n            0 <= i{2} <= dnlimbs-1 /\\ kk{1} = k{2}).\n wp; skip => />; smt(R2.A.get_setE R2.A.set_set_if).\nwp; skip; smt(R2.A.get_setE R2.A.set_set_if).\nqed.\n\n\n\n\nequiv dmuln_spec:\n M.dbn_muln ~ ASpecFp.muln:\n  W64x2N.valR a{1} = a{2} /\\  W64x2N.valR b{1} = b{2}\n  ==> \n W64x2N.valR2 res{1}.`4 = res{2}\n     /\\ res{1}.`1 = W64.zero /\\ !res{1}.`2 /\\ !res{1}.`3.\nproof.\ntransitivity \n W64x2N.MulOps.mulR\n ( ={a,b} ==> res{1}.`2=res{2}.`1 /\\ res{1}.`3=res{2}.`2 /\\ res{1}.`4=res{2}.`3 /\\  res{1}.`1 = W64.zero )\n ( W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} \n   ==> !res{1}.`1 /\\ !res{1}.`2 /\\ W64x2N.valR2 res{1}.`3 = res{2}).\n+ by move=> /> &1 &2 H1 H2; exists (a{1},b{1}).\n+ by move=> /> /#.\n+ proc; simplify. wp.\n  while ( #pre /\\ (i,_zero,of_0,cf){1}=(k,W64.zero,_of,_cf){2} /\\ bp{1} = b{2} /\\ rp{1} = r{2} /\\\n          1 <= k{2} <= dnlimbs /\\ aux{1} = 64 ).\n  wp. call dmul1acc_eq. wp. skip. progress.\nrewrite of_uintK.\napply modz_small. split. smt(). smt(). smt(). smt(). smt(). \n  by wp; call dmul1first_eq; wp; skip => /> /#.\n+ proc.\n  transitivity {1}\n    { (_of,_cf,r) <@ W64x2N.MulOps.mulR(a,b); }\n    ( ={a,b} ==> ={_cf,_of,r} )\n    ( W64x2N.valR a{1} = a{2} /\\ W64x2N.valR b{1} = b{2} ==> !_cf{1} /\\ !_of{1} /\\ W64x2N.valR2 r{1} = r{2} ).\n  + by move=> /> &1; exists a{1} b{1}; auto.\n  + by move=> /> *.\n  + by inline W64x2N.MulOps.mulR; sim.\n  + by ecall {1} (W64x2N.mulR_ph a{1} b{1}); wp; skip.\nqed.\n\n\n\n\nequiv dcminusP_spec:\n M.dcminusP ~ ASpecFp.cminus:\n W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  =res{2}.\nproof.\ntransitivity CSpecFp.dcminus\n ( W64x2N.valR p{1} = p{2} /\\ W64x2N.valR x{1} = a{2} /\\ 0 < p{2} ==> W64x2N.valR res{1}  = res{2} )\n ( ={a,p} /\\ a{2} < W64x2N.modulusR /\\ 0 < p{2} ==> ={res} ).\n  progress. exists (W64x2N.valR x{1}, W64x2N.valR p{1}). progress. smt(@W64x2N). smt(@W64x2N).\n+ by auto. \nproc. \n(ecall {1} (dbn_cmov_correct cf{1} z{1} x{1})).  simplify.\nconseq (_:  ( (W64x2N.valR (if cf{1} then x{1} else z{1}))%W64x2N = r{2} )). progress.\ninline ASpecFp.ctseln. wp.   simplify.\nseq 4 0 : ((W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ z{1} = x{1} /\\ 0 < p{2}).\n(ecall {1} (dbn_copy_correct x{1})).  wp. skip. progress.\nseq 3 1 : (cf{1} = c{2} /\\ W64x2N.valR z{1} = x{2} \n  /\\ (W64x2N.valR p{1})%W64x2N = p{2} /\\ (W64x2N.valR x{1})%W64x2N = a{2} /\\ 0 < p{2}).\ncall  dsubc_spec.  wp. skip. progress.\nskip. progress.   smt().\nproc. inline*. wp.  skip.  progress.\ncase (a{2} < p{2} = true). move => q. rewrite q. simplify. auto.\nmove => q. \nhave -> : a{2} < p{2} = false. smt(). simplify.\nhave : p{2} <= a{2}. smt().\nmove => qq.\nhave qqq : a{2} - p{2} < W64x2N.modulusR. smt(@Int).\nsmt(@Int).\nqed.\n```"]], "EC-1/FMap.ec": [[true, "require import AllCore SmtMap Finite List FSet Ring StdOrder.\n(*---*) import IntID IntOrder.\n\nimport CoreMap.\n\n(* ==================================================================== *)\ntype ('a, 'b) fmap.\n\nop tomap ['a 'b] : ('a, 'b) fmap -> ('a, 'b option) map.\nop ofmap ['a 'b] : ('a, 'b option) map -> ('a, 'b) fmap.\n\nop \"_.[_]\" ['a 'b] (m : ('a, 'b) fmap) x =\n  (tomap m).[x].\n\nop \"_.[_<-_]\" ['a 'b] (m : ('a, 'b) fmap) x v =\n  ofmap ((tomap m).[x <- Some v]).\n\nop dom ['a 'b] (m : ('a, 'b) fmap) =\n  fun x => m.[x] <> None.\n\nlemma domE ['a 'b] (m : ('a, 'b) fmap) x :\n  dom m x <=> m.[x] <> None.\nproof. by []. qed.\n\nabbrev (\\in)    ['a 'b] x (m : ('a, 'b) fmap) = (dom m x).\nabbrev (\\notin) ['a 'b] x (m : ('a, 'b) fmap) = ! (dom m x).\n\nop [opaque] rng ['a 'b] (m : ('a, 'b) fmap) = fun y => exists x, m.[x] = Some y.\nlemma rngE (m : ('a, 'b) fmap): \n  rng m = fun y => exists x, m.[x] = Some y by rewrite /rng.\n\n(* Define additional operations and lemmas as needed based on protocol requirements *)\n\n(* -------------------------------------------------------------------- *)\n(* Axioms for the finite map *)\naxiom tomapK ['a 'b] : cancel tomap ofmap<:'a, 'b>.\naxiom ofmapK ['a 'b] (m : ('a, 'b option) map) :\n  is_finite (fun x => m.[x] <> None) => tomap (ofmap m) = m.\naxiom isfmap_offmap (m : ('a, 'b) fmap) :\n  is_finite (fun x => (tomap m).[x] <> None).\n\n(* Add more definitions, properties, and lemmas as necessary *)\n\n(* ==================================================================== *)\n\n'k, 'v * 'f) fmap) f x : (restr f m).[x] = \n  obind (fun (p : _ * _) => if p.`2 = f then Some p.`1 else None) m.[x].\nproof.\nrewrite /restr /= mapE filterE /=.\nby case (m.[x])=> //= -[x1 f'] /=; case (f' = f).\nqed.\n\nlemma dom_restr ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x :\n  dom (restr f m) x <=> in_dom_with m x f.\nproof.\nrewrite /in_dom_with !domE; case: (m.[x]) (restrP m f x)=> //= -[t f'] /=.\nby case (f' = f)=> [_ -> |].\nqed.\n\nlemma restr_set ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f1 f2 x y :\n  restr f1 m.[x <- (y, f2)]\n    = if f1 = f2 then (restr f1 m).[x <- y] else rem (restr f1 m) x.\nproof.\nrewrite -fmap_eqP=> k; case: (f1 = f2) => [->|neq_f12].\n+ by rewrite !(restrP, get_setE); case: (k = x).\nrewrite !(restrP, get_setE); case: (k = x) => [->|ne_kx].\n+ by rewrite (@eq_sym f2) neq_f12 /= remE.\nby rewrite remE ne_kx /= restrP.\nqed.\n\nlemma restr_set_eq ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x y :\n  restr f m.[x <- (y, f)] = (restr f m).[x <- y].\nproof. by rewrite restr_set. qed.\n\nlemma restr0 ['k, 'v, 'f] f : restr f empty<:'k, 'v * 'f> = empty.\nproof. by apply fmap_eqP=> x; rewrite restrP !emptyE. qed.\n\nlemma restr_set_neq ['k, 'v, 'f] f2 f1 (m : ('k, 'v * 'f) fmap) x y :\n  ! dom m x => f2 <> f1 => restr f1 m.[x <- (y, f2)] = restr f1 m.\nproof.\nmove=> Hm Hneq; rewrite restr_set (eq_sym f1) Hneq rem_id //.\nby rewrite dom_restr /in_dom_with Hm.\nqed.\n\nlemma restr_rem ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) (x : 'k) f :\n  restr f (rem m x)\n    = (if in_dom_with m x f then rem (restr f m) x else restr f m).\nproof.\nrewrite -fmap_eqP => z; rewrite restrP; case: (in_dom_with m x f);\nrewrite !(restrP, remE); rewrite /in_dom_with; case (z = x)=> // ->.\nrewrite negb_and => -[Nxm|]; first by rewrite (iffLR _ _ (domNE m x)).\nby case: m.[x] => //= x' ->.\nqed.\n\n(* --------------------------------------------------------------------------- *)\n(*                         \"Bounded\" predicate                                 *)\n(* --------------------------------------------------------------------------- *)\n\nop bounded ['from 'to] (m : ('from, 'to) fmap) (size:int) = \n   card (fdom m) <= size.\n\nlemma bounded_set ['from 'to] (m : ('from, 'to)fmap) (size:int) x e : \n  bounded m size => bounded (m.[x<-e]) (size + 1).\nproof. by rewrite /bounded fdom_set fcardU fcard1; smt (fcard_ge0). qed.\n\nlemma bounded_empty ['from 'to] : bounded empty<:'from, 'to> 0.\nproof. by rewrite /bounded fdom0 fcards0. qed.\n\n(* -------------------------------------------------------------------- *)\n(*                             Merging map                              *)\n(* -------------------------------------------------------------------- *)\n\nop merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option)\n         (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) =\n  ofmap (SmtMap.merge f (tomap m1) (tomap m2)).\n\nlemma is_finite_merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option)\n         (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) :\n  (forall a, f a None None = None) =>\n  Finite.is_finite\n     (fun (x0 : 'a) => (offun (fun (a : 'a) => f a (tomap m1).[a] (tomap m2).[a])).[x0] <> None).\nproof.\n  move=> hnone; apply (Finite.finite_leq (predU (dom m1) (dom m2))) => /=.\n  + by move=> z /=; rewrite SmtMap.offunE /= /predU /dom getE /#.\n  by apply Finite.finiteU; apply finite_dom.\nqed.\n\nlemma mergeE (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) x:\n  (forall a, f a None None = None) =>\n  (merge f m1 m2).[x] = f x m1.[x] m2.[x].\nproof.\n  by move=> h; rewrite getE /merge ofmapK /= 1:is_finite_merge // SmtMap.offunE /= !getE.\nqed.\n\nlemma merge_empty (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) :\n  (forall a, f a None None = None) =>\n  merge f empty empty = empty.\nproof. by move=> h; apply fmap_eqP => x; rewrite mergeE //  !emptyE h. qed.\n\nlemma rem_merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) x:\n  (forall a, f a None None = None) =>\n  rem (merge f m1 m2) x = merge f (rem m1 x) (rem m2 x).\nproof. move=> h; apply fmap_eqP => z; rewrite mergeE // !remE mergeE // /#. qed.\n\n(* -------------------------------------------------------------------- *)\nop o_union (_ : 'a) (x y : 'b option): 'b option = \n  if x <> None then x else y.\n\nlemma o_union_none a : o_union<:'a,'b> a None None = None.\nproof. done. qed.\n\nop union_map (m1 m2: ('a, 'b) fmap) = merge o_union m1 m2.\n\nlemma set_union_map_l (m1 m2: ('a, 'b)fmap) x y: \n  (union_map m1 m2).[x <- y] = union_map m1.[x <- y] m2.\nproof. \n  have hn := o_union_none <:'a, 'b>.\n  by apply fmap_eqP => z; rewrite mergeE // !get_setE mergeE // /#. \nqed. \n\nlemma set_union_map_r (m1 m2: ('a, 'b)fmap) x y:\n  x \\notin m1 => \n  (union_map m1 m2).[x <- y] = union_map m1 m2.[x <- y].\nproof.\nby rewrite domE=> /= h; apply fmap_eqP=> z; rewrite mergeE // !get_setE //= mergeE /#.\nqed. \n\nlemma mem_union_map (m1 m2:('a, 'b)fmap) x: (x \\in union_map m1 m2) = (x \\in m1 || x \\in m2).\nproof. by rewrite /dom mergeE // /#. qed. \n\n(* -------------------------------------------------------------------- *)\nop o_pair (_ : 'a) (x : 'b1 option) (y : 'b2 option) =\n  obind (fun x=> obind (fun y=> Some (x, y)) y) x.\n\nlemma o_pair_none a : o_pair <:'a,'b1, 'b2> a None None = None.\nproof. done. qed.\n\nop pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) = merge o_pair m1 m2.\n\nlemma set_pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) x y: \n  (pair_map m1 m2).[x <- y] = pair_map m1.[x <- y.`1] m2.[x <- y.`2].\nproof. by apply fmap_eqP=> z; rewrite mergeE // !get_setE mergeE // /#. qed.\n\nlemma mem_pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) x:\n  (x \\in pair_map m1 m2) = (x \\in m1 /\\ x \\in m2).\nproof. by rewrite /dom mergeE // /#. qed.", "```ec\nrequire import AllCore SmtMap Finite List FSet Ring StdOrder.\n(*---*) import IntID IntOrder.\n\nimport CoreMap.\n\n(* ==================================================================== *)\ntype ('a, 'b) fmap.\n\nop tomap ['a 'b] : ('a, 'b) fmap -> ('a, 'b option) map.\nop ofmap ['a 'b] : ('a, 'b option) map -> ('a, 'b) fmap.\n\nop \"_.[_]\" ['a 'b] (m : ('a, 'b) fmap) x =\n  (tomap m).[x].\n\nop \"_.[_<-_]\" ['a 'b] (m : ('a, 'b) fmap) x v =\n  ofmap ((tomap m).[x <- Some v]).\n\nop dom ['a 'b] (m : ('a, 'b) fmap) =\n  fun x => m.[x] <> None.\n\nlemma domE ['a 'b] (m : ('a, 'b) fmap) x :\n  dom m x <=> m.[x] <> None.\nproof. by []. qed.\n\nabbrev (\\in)    ['a 'b] x (m : ('a, 'b) fmap) = (dom m x).\nabbrev (\\notin) ['a 'b] x (m : ('a, 'b) fmap) = ! (dom m x).\n\nop [opaque] rng ['a 'b] (m : ('a, 'b) fmap) = fun y => exists x, m.[x] = Some y.\nlemma rngE (m : ('a, 'b) fmap): \n  rng m = fun y => exists x, m.[x] = Some y by rewrite /rng.\n\n(* Define additional operations and lemmas as needed based on protocol requirements *)\n\n(* -------------------------------------------------------------------- *)\n(* Axioms for the finite map *)\naxiom tomapK ['a 'b] : cancel tomap ofmap<:'a, 'b>.\naxiom ofmapK ['a 'b] (m : ('a, 'b option) map) :\n  is_finite (fun x => m.[x] <> None) => tomap (ofmap m) = m.\naxiom isfmap_offmap (m : ('a, 'b) fmap) :\n  is_finite (fun x => (tomap m).[x] <> None).\n\n(* Add more definitions, properties, and lemmas as necessary *)\n\n(* ==================================================================== *)\n\n'k, 'v * 'f) fmap) f x : (restr f m).[x] = \n  obind (fun (p : _ * _) => if p.`2 = f then Some p.`1 else None) m.[x].\nproof.\nrewrite /restr /= mapE filterE /=.\nby case (m.[x])=> //= -[x1 f'] /=; case (f' = f).\nqed.\n\nlemma dom_restr ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x :\n  dom (restr f m) x <=> in_dom_with m x f.\nproof.\nrewrite /in_dom_with !domE; case: (m.[x]) (restrP m f x)=> //= -[t f'] /=.\nby case (f' = f)=> [_ -> |].\nqed.\n\nlemma restr_set ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f1 f2 x y :\n  restr f1 m.[x <- (y, f2)]\n    = if f1 = f2 then (restr f1 m).[x <- y] else rem (restr f1 m) x.\nproof.\nrewrite -fmap_eqP=> k; case: (f1 = f2) => [->|neq_f12].\n+ by rewrite !(restrP, get_setE); case: (k = x).\nrewrite !(restrP, get_setE); case: (k = x) => [->|ne_kx].\n+ by rewrite (@eq_sym f2) neq_f12 /= remE.\nby rewrite remE ne_kx /= restrP.\nqed.\n\nlemma restr_set_eq ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x y :\n  restr f m.[x <- (y, f)] = (restr f m).[x <- y].\nproof. by rewrite restr_set. qed.\n\nlemma restr0 ['k, 'v, 'f] f : restr f empty<:'k, 'v * 'f> = empty.\nproof. by apply fmap_eqP=> x; rewrite restrP !emptyE. qed.\n\nlemma restr_set_neq ['k, 'v, 'f] f2 f1 (m : ('k, 'v * 'f) fmap) x y :\n  ! dom m x => f2 <> f1 => restr f1 m.[x <- (y, f2)] = restr f1 m.\nproof.\nmove=> Hm Hneq; rewrite restr_set (eq_sym f1) Hneq rem_id //.\nby rewrite dom_restr /in_dom_with Hm.\nqed.\n\nlemma restr_rem ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) (x : 'k) f :\n  restr f (rem m x)\n    = (if in_dom_with m x f then rem (restr f m) x else restr f m).\nproof.\nrewrite -fmap_eqP => z; rewrite restrP; case: (in_dom_with m x f);\nrewrite !(restrP, remE); rewrite /in_dom_with; case (z = x)=> // ->.\nrewrite negb_and => -[Nxm|]; first by rewrite (iffLR _ _ (domNE m x)).\nby case: m.[x] => //= x' ->.\nqed.\n\n(* --------------------------------------------------------------------------- *)\n(*                         \"Bounded\" predicate                                 *)\n(* --------------------------------------------------------------------------- *)\n\nop bounded ['from 'to] (m : ('from, 'to) fmap) (size:int) = \n   card (fdom m) <= size.\n\nlemma bounded_set ['from 'to] (m : ('from, 'to)fmap) (size:int) x e : \n  bounded m size => bounded (m.[x<-e]) (size + 1).\nproof. by rewrite /bounded fdom_set fcardU fcard1; smt (fcard_ge0). qed.\n\nlemma bounded_empty ['from 'to] : bounded empty<:'from, 'to> 0.\nproof. by rewrite /bounded fdom0 fcards0. qed.\n\n(* -------------------------------------------------------------------- *)\n(*                             Merging map                              *)\n(* -------------------------------------------------------------------- *)\n\nop merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option)\n         (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) =\n  ofmap (SmtMap.merge f (tomap m1) (tomap m2)).\n\nlemma is_finite_merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option)\n         (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) :\n  (forall a, f a None None = None) =>\n  Finite.is_finite\n     (fun (x0 : 'a) => (offun (fun (a : 'a) => f a (tomap m1).[a] (tomap m2).[a])).[x0] <> None).\nproof.\n  move=> hnone; apply (Finite.finite_leq (predU (dom m1) (dom m2))) => /=.\n  + by move=> z /=; rewrite SmtMap.offunE /= /predU /dom getE /#.\n  by apply Finite.finiteU; apply finite_dom.\nqed.\n\nlemma mergeE (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) x:\n  (forall a, f a None None = None) =>\n  (merge f m1 m2).[x] = f x m1.[x] m2.[x].\nproof.\n  by move=> h; rewrite getE /merge ofmapK /= 1:is_finite_merge // SmtMap.offunE /= !getE.\nqed.\n\nlemma merge_empty (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) :\n  (forall a, f a None None = None) =>\n  merge f empty empty = empty.\nproof. by move=> h; apply fmap_eqP => x; rewrite mergeE //  !emptyE h. qed.\n\nlemma rem_merge (f:'a -> 'b1 option -> 'b2 option -> 'b3 option) (m1 : ('a, 'b1)fmap) (m2: ('a,'b2)fmap) x:\n  (forall a, f a None None = None) =>\n  rem (merge f m1 m2) x = merge f (rem m1 x) (rem m2 x).\nproof. move=> h; apply fmap_eqP => z; rewrite mergeE // !remE mergeE // /#. qed.\n\n(* -------------------------------------------------------------------- *)\nop o_union (_ : 'a) (x y : 'b option): 'b option = \n  if x <> None then x else y.\n\nlemma o_union_none a : o_union<:'a,'b> a None None = None.\nproof. done. qed.\n\nop union_map (m1 m2: ('a, 'b) fmap) = merge o_union m1 m2.\n\nlemma set_union_map_l (m1 m2: ('a, 'b)fmap) x y: \n  (union_map m1 m2).[x <- y] = union_map m1.[x <- y] m2.\nproof. \n  have hn := o_union_none <:'a, 'b>.\n  by apply fmap_eqP => z; rewrite mergeE // !get_setE mergeE // /#. \nqed. \n\nlemma set_union_map_r (m1 m2: ('a, 'b)fmap) x y:\n  x \\notin m1 => \n  (union_map m1 m2).[x <- y] = union_map m1 m2.[x <- y].\nproof.\nby rewrite domE=> /= h; apply fmap_eqP=> z; rewrite mergeE // !get_setE //= mergeE /#.\nqed. \n\nlemma mem_union_map (m1 m2:('a, 'b)fmap) x: (x \\in union_map m1 m2) = (x \\in m1 || x \\in m2).\nproof. by rewrite /dom mergeE // /#. qed. \n\n(* -------------------------------------------------------------------- *)\nop o_pair (_ : 'a) (x : 'b1 option) (y : 'b2 option) =\n  obind (fun x=> obind (fun y=> Some (x, y)) y) x.\n\nlemma o_pair_none a : o_pair <:'a,'b1, 'b2> a None None = None.\nproof. done. qed.\n\nop pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) = merge o_pair m1 m2.\n\nlemma set_pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) x y: \n  (pair_map m1 m2).[x <- y] = pair_map m1.[x <- y.`1] m2.[x <- y.`2].\nproof. by apply fmap_eqP=> z; rewrite mergeE // !get_setE mergeE // /#. qed.\n\nlemma mem_pair_map (m1: ('a, 'b1)fmap) (m2: ('a, 'b2)fmap) x:\n  (x \\in pair_map m1 m2) = (x \\in m1 /\\ x \\in m2).\nproof. by rewrite /dom mergeE // /#. qed.\n```"]], "EC-1/bad_abs.ec": [[true, "require import AllCore Distr.\n\ntype input_a.  \ntype output_a.  \n\nmodule type Adv = {\n  proc a(x:input_a) : output_a\n}.\n\ntype input_m.\n\nmodule type Main(A:Adv) = {\n  proc main(x:input_m): bool\n}.  \n\nmodule type NegA (A:Adv) = {\n  proc a(x:input_a) : output_a {A.a}\n}.\n\nsection TEST.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (forall &m vx,  Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] =\n                       1%r - Pr[M1(A).main(vx) @ &m : E1 (glob M1) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = \n                       1%r - Pr[M2(A).main(vx) @ &m : E2 (glob M2) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : B (glob M2) (glob A)] = Pr[M2(A).main(vx) @ &m : B (glob M2) (glob A)]) =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA N1 N2 NB &m1 &m2 vx1 vx2 Hpre HglobA. \n     case: (Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]) => Hle.\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] - Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] by smt ().     \n     have : Pr[M1(N(A)).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(N(A)).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eNA => // &1 &2 /#. \n     rewrite Pr [mu_or]; rewrite (N1 &m1 vx1) (N2 &m2 vx2) (NB &m2 vx2); smt (mu_bounded).\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] -Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] by smt ().  \n     have : Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eA => // &1 &2 /#. \n     rewrite Pr [mu_or]; smt (mu_bounded).\n   qed.\n  \nend section TEST.\n\nsection TEST1.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test1 : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [ M1(N(A)).main ~ M1(A).main : ={glob M1, glob A}  ==> (E1 (glob M1) (glob A) res){1} = !(E1 (glob M1) (glob A) res){2}]) =>\n       (equiv [ M2(N(A)).main ~ M2(A).main : ={glob M2, glob A}  ==> (E2 (glob M2) (glob A) res){1} = !(E2 (glob M2) (glob A) res){2} /\\\n                                                                     (B (glob M2) (glob A)){1} = (B (glob M2) (glob A)){2}]) => \n       islossless M1(A).main =>\n       islossless M2(A).main =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA e1 e2 ll1 ll2 &m1 &m2 vx1 vx2 Hpre HglobA. \n     apply (test M1 M2 N A pre E1 E2 B eA eNA _ _ _ &m1 &m2 vx1 vx2 Hpre HglobA).\n     + move=> &m vx. \n       have -> : Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] = Pr[M1(A).main(vx) @ &m : !E1 (glob M1) (glob A) res].\n       + byequiv e1 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll1.\n     + move=> &m vx. \n       have -> : Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = Pr[M2(A).main(vx) @ &m : !E2 (glob M2) (glob A) res].\n       + byequiv e2 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll2.\n     by move=> &m vx;byequiv e2 => // /#.\n   qed.\n\nend section TEST1.", "```ec\nrequire import AllCore Distr.\n\ntype input_a.  \ntype output_a.  \n\nmodule type Adv = {\n  proc a(x:input_a) : output_a\n}.\n\ntype input_m.\n\nmodule type Main(A:Adv) = {\n  proc main(x:input_m): bool\n}.  \n\nmodule type NegA (A:Adv) = {\n  proc a(x:input_a) : output_a {A.a}\n}.\n\nsection TEST.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (forall &m vx,  Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] =\n                       1%r - Pr[M1(A).main(vx) @ &m : E1 (glob M1) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = \n                       1%r - Pr[M2(A).main(vx) @ &m : E2 (glob M2) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : B (glob M2) (glob A)] = Pr[M2(A).main(vx) @ &m : B (glob M2) (glob A)]) =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA N1 N2 NB &m1 &m2 vx1 vx2 Hpre HglobA. \n     case: (Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]) => Hle.\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] - Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] by smt ().     \n     have : Pr[M1(N(A)).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(N(A)).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eNA => // &1 &2 /#. \n     rewrite Pr [mu_or]; rewrite (N1 &m1 vx1) (N2 &m2 vx2) (NB &m2 vx2); smt (mu_bounded).\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] -Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] by smt ().  \n     have : Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eA => // &1 &2 /#. \n     rewrite Pr [mu_or]; smt (mu_bounded).\n   qed.\n  \nend section TEST.\n\nsection TEST1.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test1 : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [ M1(N(A)).main ~ M1(A).main : ={glob M1, glob A}  ==> (E1 (glob M1) (glob A) res){1} = !(E1 (glob M1) (glob A) res){2}]) =>\n       (equiv [ M2(N(A)).main ~ M2(A).main : ={glob M2, glob A}  ==> (E2 (glob M2) (glob A) res){1} = !(E2 (glob M2) (glob A) res){2} /\\\n                                                                     (B (glob M2) (glob A)){1} = (B (glob M2) (glob A)){2}]) => \n       islossless M1(A).main =>\n       islossless M2(A).main =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA e1 e2 ll1 ll2 &m1 &m2 vx1 vx2 Hpre HglobA. \n     apply (test M1 M2 N A pre E1 E2 B eA eNA _ _ _ &m1 &m2 vx1 vx2 Hpre HglobA).\n     + move=> &m vx. \n       have -> : Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] = Pr[M1(A).main(vx) @ &m : !E1 (glob M1) (glob A) res].\n       + byequiv e1 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll1.\n     + move=> &m vx. \n       have -> : Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = Pr[M2(A).main(vx) @ &m : !E2 (glob M2) (glob A) res].\n       + byequiv e2 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll2.\n     by move=> &m vx;byequiv e2 => // /#.\n   qed.\n\nend section TEST1.\n```"]], "EC-1/Forking.ec": [[false, "```ec\n(* Forking lemma - proof sketch\n *\n * Largely based on the proof of the general forking lemma\n * by Bellare & Neven [0].\n *\n * [0] https://cseweb.ucsd.edu/~mihir/papers/multisignatures.pdf\n *)\n\npragma Goals:printall.\n\nrequire import AllCore List Distr DInterval Finite StdOrder StdBigop RealFun.\nimport RField RealOrder Bigreal BRA.\nrequire Stopping.\n\n(* FIXME: Properly import Rewindable form easycrypt-rewinding. *)\ntype state_t.\n\nmodule type Rewindable = {\n  proc getState() : state_t\n  proc setState(st : state_t) : unit\n}.\n\n(* Input & auxiliary output type. *)\ntype in_t, aux_t.\n\ntype query_t, resp_t.\nconst Q : {int | 1 <= Q} as Q_pos.\n\n(* TODO: Is this idiomatic in EC? *)\nclone import Stopping as ForkStopping with\n  type query_t <- query_t,\n  type resp_t  <- resp_t,\n  op   Q       <- Q,\n  type in_t    <- in_t,\n  type out_t   <= int * aux_t\nproof *.\nrealize Q_pos by exact Q_pos.\n(* TODO: Why is this not imported as well? *)\ntype out_t = int * aux_t.\nexport ForkStopping.\n\nop [lossless uniform] dresp : resp_t distr.\n\n(* Forgetful random oracle, may respond inconsistently to\n * repeated queries. This is intentional, otherwise we may not\n * be able to repogram the oracle at the forking point. *)\nmodule FRO : Oracle = {\n  proc get(q : query_t) : resp_t = {\n    var r : resp_t;\n    r <$ dresp;\n    return r;\n  }\n}.\n\ntype log_t = query_t * resp_t.\n\n(* NOTE: The standard library contains a similar\n * oracle transformer which logs just the queries.\n * We need to record responses as well. *)\nmodule Log(O : Oracle) : Oracle = {\n  var log : log_t list\n\n  proc get(q : query_t) : resp_t = {\n    var r;\n    r <@ O.get(q);\n    log <- log ++ [(q, r)];\n    return r;\n  }\n}.\n\n(* TODO: Generalize to other oracles as well?\n * Most of the lemmas below need to assume very little about\n * the used oracle. It should be sufficient to require\n * rewindability plus some bound on the probability of\n * a collision, such as:\n * forall q r &m : Pr[O.get(q) @ &m : res = r] <= bound *)\n\n\n(* TODO: Does it make sense to generalize somehow?\n * Could we, for example, prove the forking lemma\n * for any event E such that E => (0 <= j < Q)? *)\n(* NOTE: We index queries from 0 (unlike pen&paper proofs). *)\nop success (j : int) : bool = 0 <= j < Q.\n\nmodule type Forkable = {\n  include Rewindable\n  include Stoppable\n}.\n\nmodule IForker(I : IGen, F : Forkable) = {\n  (* TODO: Might be easier to prove invariants about these if we\n   * keep them local? In such case, we would need to return\n   * those in run to be able to refer to the results.\n   * Check the proofs! *)\n  var j1, j2 : int\n  var log1, log2 : log_t list\n  var r1, r2 : resp_t\n\n  (* First run of F, with query and state logging. *)\n  proc fst() : out_t * (log_t list) * (state_t list) = {\n    var sts : state_t list;\n    var st : state_t;\n    var i : in_t;\n    var o : out_t;\n    var q : query_t;\n    var r : resp_t;\n    var c : int;\n\n    sts <- [];\n    Log.log <- [];\n\n    i <@ I.gen();\n    q <@ F.init(i);\n    c <- ivos 1;\n\n    while (c < Q) {\n      st <@ F.getState();\n      sts <- sts ++ [st];\n      r <@ Log(FRO).get(q);\n      q <@ F.continue(r);\n      c <- c + 1;\n    }\n\n    st <@ F.getState();\n    sts <- sts ++ [st];\n    r <@ Log(FRO).get(q);\n    o <@ F.finish(r);\n\n    return (o, Log.log, sts);\n  }\n\n  (* Second partial run of F, with query logging. *)\n  proc snd(q : query_t, c : int) : out_t * (log_t list) = {\n    var log : log_t list;\n    var o : out_t;\n    var r : resp_t;\n\n    Log.log <- [];\n\n    while (c < Q) {\n      r <@ Log(FRO).get(q);\n      q <@ F.continue(r);\n      c <- c + 1;\n    }\n\n    r <@ Log(FRO).get(q);\n    o <@ F.finish(r);\n\n    return (o, Log.log);\n  }\n\n  proc run() : int * aux_t * aux_t = {\n    var sts : state_t list;\n    var st : state_t;\n    var o1, o2 : out_t;\n    var j : int;\n    var a1, a2 : aux_t;\n    var q : query_t;\n\n    (o1, log1, sts) <@ fst();\n    (j1, a1) <- o1;\n    (q, r1) <- nth witness log1 j1;\n\n    (* Rewind. *)\n    st <- nth witness sts j1;\n    F.setState(st);\n\n    (o2, log2) <@ snd(q, j1 + 1);\n    (j2, a2) <- o2;\n    log2 <- (take j1 log1) ++ log2;\n    r2 <- (nth witness log2 j1).`2;\n\n    j <- if success j1 /\\ success j2 /\\ j1 = j2 /\\ r1 <> r2\n      then j1 else -1;\n\n    return (j, a1, a2);\n  }\n}.\n\n(* NOTE: In the pen & paper proof, the authors first show that\n * the probability bound holds for a forker with a fixed input\n * and then prove using Jensen's inequality and linearity of\n * expectation that it also holds when we average over different\n * inputs.\n *\n * Here, we use a slightly different approach. We make the input\n * generation a part of the forking algorithm and prove the result\n * in this general setting. The bound for a fixed input is then\n * obtained for free by using a constant input generator. (This way,\n * we fully utilize the power of the rew_with_init lemma and do not\n * have to import other results from the easycrypt-rewinding library\n * such as reflection.) *)\n\nmodule Forker(F : Forkable) = {\n  proc run(i : in_t) : int * aux_t * aux_t = {\n    var ret;\n    ConstGen.i <- i;\n    ret <@ IForker(ConstGen, F).run();\n    return ret;\n  }\n}.\n\nmodule GenThenFork(I : IGen, F : Forkable) = {\n  proc run() : int * aux_t * aux_t = {\n    var i, ret;\n    i <@ I.gen();\n    ret <@ Forker(F).run(i);\n    return ret;\n  }\n}.\n\nequiv gen_then_fork_equiv (I <: IGen {-IForker}) (F <: Forkable {-I, -IForker}) :\n  GenThenFork(I, F).run ~ IForker(I, F).run :\n  ={glob I, glob F} ==> ={glob I, glob F, glob IForker, res}.\nproof.\nproc.\ninline * - Log.\nwp -2 100.\nswap {2} 3 -2.\nsim.\nqed.\n\nsection PROOF.\n\nlocal equiv oracle_log_equiv (O <: Oracle) :\n  O.get ~ Log(O).get : ={glob O, arg} ==> ={glob O, res}.\nproof.\nproc *.\ninline.\nsim.\nqed.\n\n(* TODO: Move this somewhere else? *)\nequiv runner_log_equiv (S <: Stoppable {-Log}) :\n  Runner(S, FRO).run ~ Runner(S, Log(FRO)).run :\n  ={glob S, arg} ==> ={glob S, res}.\nproof.\nproc.\ncall (_ : true).\ncall (oracle_log_equiv FRO).\nwhile (={glob S, c, q}).\n+ rewrite equiv [{2} 1 - (oracle_log_equiv FRO)].\n  sim.\nconseq (_ : _ ==> ={glob S, c, q}) => //.\nsim.\nqed.\n\nequiv irunner_log_equiv (I <: IGen {-Log}) (S <: Stoppable {-I, -Log}) :\n  IRunner(I, S, FRO).run ~ IRunner(I, S, Log(FRO)).run :\n  ={glob I, glob S} ==> ={glob I, glob S, res}.\nproof.\nproc.\nrewrite equiv [{2} 2 -(runner_log_equiv S)].\n+ sim.\ncall (_ : true).\nauto.\nqed.\n\n(* TODO: Log should, at this point, probably be moved outside this file. *)\nhoare run_log_size (S <: Stoppable {-Log}) (O <: Oracle {-Log}) :\n  Runner(S, Log(O)).run : Log.log = [] ==> size Log.log = Q.\nproof.\nhave get_inc : forall n, hoare[\n  Log(O).get : size Log.log = n ==> size Log.log = n + 1].\n+ move => n.\n  proc.\n  wp; call (_ : true).\n  auto; smt(size_cat).\nproc.\ncall (_ : true).\necall (get_inc (Q - 1)).\nwhile (c <= Q /\\ size Log.log = c - 1).\n+ wp; call (_ : true).\n  ecall (get_inc (c - 1)).\n  auto => /#.\nwp; call (_ : true).\nauto => />.\nsmt(Q_pos).\nqed.\n\nhoare irun_log_size (I <: IGen {-Log}) (S <: Stoppable {-Log}) (O <: Oracle {-Log}) :\n  IRunner(I, S, Log(O)).run : Log.log = [] ==> size Log.log = Q.\nproof.\nproc.\ncall (run_log_size S O).\ncall (_ : true).\nskip => //.\nqed.\n\ndeclare module I <: IGen {-Log, -IForker}.\n\ndeclare module F <: Forkable {-I, -FRO, -Log, -Runner, -IForker}.\n\n(* Coppied from easycrypt-rewinding. *)\ndeclare axiom F_rewindable :\n  exists (f : glob F -> state_t), injective f /\\\n  (forall &m, Pr[F.getState() @ &m : (glob F) = (glob F){m} /\\ res = f (glob F){m}] = 1%r) /\\\n  (forall &m st (x: glob F), st = f x => Pr[F.setState(st) @ &m : glob F = x] = 1%r) /\\\n  islossless F.setState.\n\ndeclare axiom F_continue_ll : islossless F.continue.\ndeclare axiom F_finish_ll : islossless F.finish.\n\nlocal phoare get_st_preserves_glob (gF : glob F):\n  [F.getState : (glob F) = gF ==> (glob F) = gF] = 1%r.\nproof.\nelim F_rewindable.\nmove => f [_ [get_st_prop [_ _]]].\nproc *.\ncall (_ : glob F = gF ==> glob F = gF /\\ res = f gF).\n+ bypr => &m gF_mem.\n  rewrite -gF_mem.\n  apply (get_st_prop &m).\nauto.\nqed.\n\nlocal lemma get_st_ll : islossless F.getState.\nproof.\nproc *.\nexlim (glob F) => gF.\ncall (get_st_preserves_glob gF).\nauto.\nqed.\n\nlocal lemma set_st_ll : islossless F.setState.\nproof.\nsmt(F_rewindable).\nqed.\n\n(* STEP 1:\n * Various lemmas that allow expressing the probability of a\n * successful fork in terms of probabilities of simpler events.\n *)\n\nlocal lemma fork_pr &m :\n  Pr[IForker(I, F).run() @ &m : success res.`1] =\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1 /\\ IForker.r1 <> IForker.r2].\nproof.\nbyequiv => //.\nproc.\nseq 9 9 : (={glob IForker}).\n+ sim.\nauto => /#.\nqed.\n\nlocal lemma pr_split &m :\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1 /\\ IForker.r1 <> IForker.r2] >=\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1] -\n  Pr[IForker(I, F).run() @ &m : success IForker.j1 /\\ IForker.r1 = IForker.r2].\nproof.\n(* TODO: Cannot use occurence selector with rewrite Pr? *)\nhave -> :\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1] =\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1 /\\ IForker.r1 = IForker.r2] +\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1 /\\ IForker.r1 <> IForker.r2].\n+ by rewrite Pr[mu_split IForker.r1 = IForker.r2]; smt().\nhave ABC_le_BC :\n  Pr[IForker(I, F).run() @ &m : IForker.j1 = IForker.j2 /\\ success IForker.j1 /\\ IForker.r1 = IForker.r2] <=\n  Pr[IForker(I, F).run() @ &m : success IForker.j1 /\\ IForker.r1 = IForker.r2].\n+ by rewrite Pr[mu_sub].\nsmt().\nqed.\n\nlocal equiv fst_run_log_equiv log0 :\n  IForker(I, F).fst ~ IRunner(I, F, Log(FRO)).run :\n  ={glob I, glob F} /\\ Log.log{2} = log0 ==>\n  ={glob I, glob F} /\\ res{1}.`1 = res{2} /\\ log0 ++ res{1}.`2 = Log.log{2}.\nproof.\nproc => /=.\ninline Runner.\nwp.\ncall (_ : true).\nhave log_equiv : equiv[\n  Log(FRO).get ~ Log(FRO).get :\n  ={arg} /\\ log0 ++ Log.log{1} = Log.log{2} ==>\n  ={res} /\\ log0 ++ Log.log{1} = Log.log{2}\n].\n+ proc; inline.\n  wp; rnd; wp; skip.\n  smt(catA).\ncall log_equiv.\nwp.\necall {1} (get_st_preserves_glob (glob F){1}).\nwhile (={q, c, glob F} /\\ log0 ++ Log.log{1} = Log.log{2} /\\ c{1} <= Q).\n+ wp.\n  call (_ : true).\n  call log_equiv.\n  wp.\n  ecall {1} (get_st_preserves_glob (glob F){1}).\n  auto => />.\ndo 2! (wp; call (_ : true)).\nauto => />.\nsmt(cats0).\nqed.\n\nlocal equiv fst_run_equiv :\n  IForker(I, F).fst ~ IRunner(I, F, FRO).run :\n  ={glob I, glob F} ==> ={glob I, glob F} /\\ res{1}.`1 = res{2}.\nproof.\nproc *.\nrewrite equiv [{2} 1 (irunner_log_equiv I F)].\nexlim (Log.log{2}) => log0.\ncall (fst_run_log_equiv log0).\nauto.\nqed.\n\nlocal hoare fst_log_size :\n  IForker(I, F).fst : true ==> size res.`2 = Q.\nproof.\nconseq (fst_run_log_equiv []) (irun_log_size I F FRO) => /#.\nqed.\n\nconst pr_collision = 1%r / (size (to_seq (support dresp)))%r.\n\n(* TODO: Decompose? *)\nlocal lemma pr_succ_resp_eq &m :\n  Pr[IForker(I, F).run() @ &m : success IForker.j1 /\\ IForker.r1 = IForker.r2] <=\n  Pr[IRunner(I, F, FRO).run() @ &m : success res.`1] * pr_collision.\nproof.\nbyphoare (: glob I = (glob I){m} /\\ glob F = (glob F){m} ==> _) => //.\nproc.\nseq 3 : (success IForker.j1)\n  Pr[IRunner(I, F, FRO).run() @ &m : success res.`1] pr_collision\n  _ 0%r\n  (size IForker.log1 = Q);\nlast by trivial.\n\n(* #pre ==> size IForker.log1 = Q *)\n+ wp.\n  call fst_log_size.\n  auto.\n\n(* #pre ==> success IForker.j1 *)\n+ wp.\n  call (_ : glob I = (glob I){m} /\\ glob F = (glob F){m} ==> success res.`1.`1).\n  + bypr => &m0 glob_eq.\n    byequiv => //.\n    conseq fst_run_equiv; smt().\n  auto.\n\n(* success IForker.j1 ==> #post *)\n+ inline.\n  wp.\n  conseq (_ : _ ==> success IForker.j1 /\\ IForker.r1 = (head witness Log.log).`2).\n  + smt(nth_cat size_takel nth0_head).\n  (* FIXME: This is rather painful. Call doesn't work in pHL? *)"]], "EC-1/ForkingRO.ec": [[true, "rker(I, Red(F)).run();\n\n    m1 <- ofassoc IForker.log1;\n    m2 <- ofassoc IForker.log2;\n    cq <- if success j\n      then Some (nth witness IForker.log1 j).`1\n      else None;\n\n    return (cq, a1, a2);\n  }\n}.\n\n(* TODO: Better way to solve the name clash?\n * ForkStoppingRO.ConstGen = ForkStopping.ConstGen,\n * but module overrides don't work anymore iirc. *)\nmodule ConstGenRO(MODULE_0 : Unit) = ForkStopping.ConstGen.\n\nmodule ForkerRO(F : ForkableRO) = {\n  proc run(i : in_t) : query_t option * aux_t * aux_t = {\n    var ret;\n    ConstGen.i <- i;\n    ret <@ IForkerRO(ConstGenRO, F).run();\n    return ret;\n  }\n}.\n\nmodule GenThenForkRO(I : IGen, F : ForkableRO) = {\n  proc run() : query_t option * aux_t * aux_t = {\n    var i, ret;\n    i <@ I.gen();\n    ret <@ ForkerRO(F).run(i);\n    return ret;\n  }\n}.\n\nequiv gen_then_fork_ro_equiv (I <: IGen {-IForkerRO, -ConstGenRO}) (F <: ForkableRO {-I, -IForkerRO, -ConstGenRO}) :\n  GenThenForkRO(I, F).run ~ IForkerRO(I, F).run :\n  ={glob I, glob F} ==> ={glob I, glob F, IForkerRO.m1, IForkerRO.m2, res}.\nproof.\nproc.\nrewrite equiv [{2} 1 -(gen_then_fork_equiv I (Red(F)))].\ninline * -IForker.\nwp.\ncall (_ : ={ConstGen.i, glob I, glob F} ==> ={glob I, glob F, res, glob IForker}).\n+ sim.\nwp; call (_ : true).\nauto => />.\nqed.\n\nsection PROOF.\n\ndeclare module I <: IGen {-Log, -IForkerRO, -LRO}.\n\ndeclare module F <: ForkableRO {-I, -Red, -FRO, -Log, -Runner, -IForker}.\n\n(* Coppied from easycrypt-rewinding. *)\ndeclare axiom F_rewindable :\n  exists (f : glob F -> state_t), injective f /\\\n  (forall &m, Pr[F.getState() @ &m : (glob F) = (glob F){m} /\\ res = f (glob F){m}] = 1%r) /\\\n  (forall &m st (x: glob F), st = f x => Pr[F.setState(st) @ &m : glob F = x] = 1%r) /\\\n  islossless F.setState.\n\ndeclare axiom F_continue_ll : islossless F.continue.\ndeclare axiom F_finish_ll : islossless F.finish.\n\nlocal lemma Red_F_rewindable :\n  exists (f : glob Red(F) -> state_t), injective f /\\\n  (forall &m, Pr[Red(F).getState() @ &m : (glob Red(F)) = (glob Red(F)){m} /\\ res = f (glob Red(F)){m}] = 1%r) /\\\n  (forall &m st (x: glob Red(F)), st = f x => Pr[Red(F).setState(st) @ &m : glob Red(F) = x] = 1%r) /\\\n  islossless Red(F).setState.\nproof.\nadmit.\nqed.\n\nlocal lemma Red_F_continue_ll : islossless Red(F).continue.\nproof.\nislossless; exact F_continue_ll.\nqed.\n\nlocal lemma Red_F_finish_ll : islossless Red(F).finish.\nproof.\nislossless; exact F_finish_ll.\nqed.\n\n(* This is for outline purposes only. *)\nlocal module RedO = {\n  proc get(q : query_t) : resp_t = {\n    var r, r1 : resp_t;\n    r <@ Log(FRO).get(q);\n    r1 <- r;\n    r1 <@ Red(F).fix_resp(r1);\n    return r1;\n  }\n}.\n\nlocal equiv redo_lro_equiv :\n  RedO.get ~ LRO.get :\n  ={arg} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ q{1} = Red.q{1} ==>\n  ={res} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2}.\nproof.\nproc; inline.\nwp 9 3.\nconseq (_ : _ ==> Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ Red.q{1} = x{2}).\n+ smt(ofassoc_get).\nauto => />.\nsmt(ofassoc_cat1 ofassoc_rep).\nqed.\n\nlocal equiv red_log_fro_lro_equiv :\n  IRunner(I, Red(F), Log(FRO)).run ~ IRunnerRO(I, F, LRO).run :\n  (* TODO: Consider initializing the oracle in Runner. *)\n  ={glob I, glob F} /\\ Log.log{1} = [] /\\ LRO.m{2} = empty ==>\n  ={glob I, glob F} /\\ ofassoc Log.log{1} = LRO.m{2} /\\\n  res{1}.`1 = odflt Q (omap (assoc_index Log.log{1}) res{2}.`1) /\\ res{1}.`2 = res{2}.`2 /\\\n  (success res{1}.`1 <=> success_ro LRO.m{2} res{2}.`1).\nproof.\nconseq\n  (_ : _ ==> ={glob I, glob F} /\\ ofassoc Log.log{1} = LRO.m{2} /\\\n             res{1}.`1 = odflt Q (omap (assoc_index Log.log{1}) res{2}.`1) /\\ res{1}.`2 = res{2}.`2)\n  (irun_log_size I (Red(F)) FRO) => //.\n+ move => />.\n  move => resL resR m.\n  pose j := resL.`1; pose cq := resR.`1.\n  case cq => /=.\n  + smt().\n  smt(index_ge0 assoc_index_mem).\nproc.\ninline Runner RunnerRO.\ninline Red -Red(F).fix_resp.\nwp => /=.\ncall (_ : true).\noutline {1} [9..11] ~ RedO.get.\ncall redo_lro_equiv.\nwhile (={c, q, glob I, glob F} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ q{1} = Red.q{1}).\n+ outline {1} [1..3] ~ RedO.get.\n  wp.\n  call (_ : true).\n  call redo_lro_equiv.\n  auto => />.\ndo 2! (wp; call (_ : true)).\nauto => />.\nexact ofassoc_empty.\nqed.\n\nsection CONVENIENCE.\n\ndeclare pred P_in : glob I * glob F.\ndeclare pred P_out : glob I * (query_t option * aux_t) * (query_t, resp_t) fmap.\n\ndeclare axiom success_impl :\n  hoare[\n    IRunnerRO(I, F, LRO).run :\n    P_in (glob I, glob F) /\\ LRO.m = empty ==>\n    success_ro LRO.m res.`1 => P_out (glob I, res, LRO.m)\n  ].\n\ndeclare op pr_success : real.\n\ndeclare axiom success_eq :\n  phoare[\n    IRunnerRO(I, F, LRO).run :\n    P_in (P_in (glob I, glob F) /\\ LRO.m = empty)\n    ==> success_ro LRO.m res.`1\n  ] = pr_success.\n\nlemma forking_lemma_ro :\n  phoare[\n    IForkerRO(I, F).run :\n    P_in (glob I, glob F) ==>\n    let (cq, a1, a2) = res in\n    let m1 = ofassoc IForkerRO.m1 in\n    let m2 = ofassoc IForkerRO.m2 in\n    (* TODO: Rename cq? *)\n    let q  = oget cq in\n    is_some cq /\\\n    q \\in m1 /\\ q \\in m2 /\\ m1.[q] <> m2.[q] /\\\n    P_out (glob I, (cq, a1), m1) /\\ P_out (glob I, (cq, a2), m2)\n  ] >= (pr_success ^ 2 / Q%r - pr_success * pr_collision).\nproof.\nproc.\nwp.\npose Red_P_in := (fun (arg : glob I * glob Red(F)) =>\n  let (gI, gRed) = arg in\n  let (gF, _, __) = gRed in\n  P_in (gI, gF)\n).\npose Red_P_out := (fun (ret : glob I * (int * aux_t) * log_t list) =>\n  let (gI, o, log) = ret in\n  let (j, aux) = o in\n  let m = ofassoc log in\n  let (q, r) = nth witness log j in\n  q \\in m /\\ m.[q] = Some r /\\ P_out (gI, (Some q, aux), m)\n).\ncall (\n  forking_lemma I (Red(F))\n  Red_F_rewindable Red_F_continue_ll Red_F_finish_ll\n  Red_P_in Red_P_out _ pr_success _\n).\n+ conseq red_log_fro_lro_equiv success_impl; 1: smt().\n  smt(nth_assoc_index).\n+ have success_eq_log : phoare[\n    IRunner(I, Red(F), Log(FRO)).run : P_in (glob I, glob F) /\\ Log.log = [] ==> success res.`1\n  ] = pr_success.\n  + conseq red_log_fro_lro_equiv success_eq => /#.\n  conseq (irunner_log_equiv I (Red(F))) success_eq_log => /#.\nskip.\nrewrite /Red_P_out.\nsmt().\nqed.\n\nend section CONVENIENCE.\n\nend section PROOF.", "```ec\nrker(I, Red(F)).run();\n\n    m1 <- ofassoc IForker.log1;\n    m2 <- ofassoc IForker.log2;\n    cq <- if success j\n      then Some (nth witness IForker.log1 j).`1\n      else None;\n\n    return (cq, a1, a2);\n  }\n}.\n\n(* TODO: Better way to solve the name clash?\n * ForkStoppingRO.ConstGen = ForkStopping.ConstGen,\n * but module overrides don't work anymore iirc. *)\nmodule ConstGenRO(MODULE_0 : Unit) = ForkStopping.ConstGen.\n\nmodule ForkerRO(F : ForkableRO) = {\n  proc run(i : in_t) : query_t option * aux_t * aux_t = {\n    var ret;\n    ConstGen.i <- i;\n    ret <@ IForkerRO(ConstGenRO, F).run();\n    return ret;\n  }\n}.\n\nmodule GenThenForkRO(I : IGen, F : ForkableRO) = {\n  proc run() : query_t option * aux_t * aux_t = {\n    var i, ret;\n    i <@ I.gen();\n    ret <@ ForkerRO(F).run(i);\n    return ret;\n  }\n}.\n\nequiv gen_then_fork_ro_equiv (I <: IGen {-IForkerRO, -ConstGenRO}) (F <: ForkableRO {-I, -IForkerRO, -ConstGenRO}) :\n  GenThenForkRO(I, F).run ~ IForkerRO(I, F).run :\n  ={glob I, glob F} ==> ={glob I, glob F, IForkerRO.m1, IForkerRO.m2, res}.\nproof.\nproc.\nrewrite equiv [{2} 1 -(gen_then_fork_equiv I (Red(F)))].\ninline * -IForker.\nwp.\ncall (_ : ={ConstGen.i, glob I, glob F} ==> ={glob I, glob F, res, glob IForker}).\n+ sim.\nwp; call (_ : true).\nauto => />.\nqed.\n\nsection PROOF.\n\ndeclare module I <: IGen {-Log, -IForkerRO, -LRO}.\n\ndeclare module F <: ForkableRO {-I, -Red, -FRO, -Log, -Runner, -IForker}.\n\n(* Coppied from easycrypt-rewinding. *)\ndeclare axiom F_rewindable :\n  exists (f : glob F -> state_t), injective f /\\\n  (forall &m, Pr[F.getState() @ &m : (glob F) = (glob F){m} /\\ res = f (glob F){m}] = 1%r) /\\\n  (forall &m st (x: glob F), st = f x => Pr[F.setState(st) @ &m : glob F = x] = 1%r) /\\\n  islossless F.setState.\n\ndeclare axiom F_continue_ll : islossless F.continue.\ndeclare axiom F_finish_ll : islossless F.finish.\n\nlocal lemma Red_F_rewindable :\n  exists (f : glob Red(F) -> state_t), injective f /\\\n  (forall &m, Pr[Red(F).getState() @ &m : (glob Red(F)) = (glob Red(F)){m} /\\ res = f (glob Red(F)){m}] = 1%r) /\\\n  (forall &m st (x: glob Red(F)), st = f x => Pr[Red(F).setState(st) @ &m : glob Red(F) = x] = 1%r) /\\\n  islossless Red(F).setState.\nproof.\nadmit.\nqed.\n\nlocal lemma Red_F_continue_ll : islossless Red(F).continue.\nproof.\nislossless; exact F_continue_ll.\nqed.\n\nlocal lemma Red_F_finish_ll : islossless Red(F).finish.\nproof.\nislossless; exact F_finish_ll.\nqed.\n\n(* This is for outline purposes only. *)\nlocal module RedO = {\n  proc get(q : query_t) : resp_t = {\n    var r, r1 : resp_t;\n    r <@ Log(FRO).get(q);\n    r1 <- r;\n    r1 <@ Red(F).fix_resp(r1);\n    return r1;\n  }\n}.\n\nlocal equiv redo_lro_equiv :\n  RedO.get ~ LRO.get :\n  ={arg} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ q{1} = Red.q{1} ==>\n  ={res} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2}.\nproof.\nproc; inline.\nwp 9 3.\nconseq (_ : _ ==> Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ Red.q{1} = x{2}).\n+ smt(ofassoc_get).\nauto => />.\nsmt(ofassoc_cat1 ofassoc_rep).\nqed.\n\nlocal equiv red_log_fro_lro_equiv :\n  IRunner(I, Red(F), Log(FRO)).run ~ IRunnerRO(I, F, LRO).run :\n  (* TODO: Consider initializing the oracle in Runner. *)\n  ={glob I, glob F} /\\ Log.log{1} = [] /\\ LRO.m{2} = empty ==>\n  ={glob I, glob F} /\\ ofassoc Log.log{1} = LRO.m{2} /\\\n  res{1}.`1 = odflt Q (omap (assoc_index Log.log{1}) res{2}.`1) /\\ res{1}.`2 = res{2}.`2 /\\\n  (success res{1}.`1 <=> success_ro LRO.m{2} res{2}.`1).\nproof.\nconseq\n  (_ : _ ==> ={glob I, glob F} /\\ ofassoc Log.log{1} = LRO.m{2} /\\\n             res{1}.`1 = odflt Q (omap (assoc_index Log.log{1}) res{2}.`1) /\\ res{1}.`2 = res{2}.`2)\n  (irun_log_size I (Red(F)) FRO) => //.\n+ move => />.\n  move => resL resR m.\n  pose j := resL.`1; pose cq := resR.`1.\n  case cq => /=.\n  + smt().\n  smt(index_ge0 assoc_index_mem).\nproc.\ninline Runner RunnerRO.\ninline Red -Red(F).fix_resp.\nwp => /=.\ncall (_ : true).\noutline {1} [9..11] ~ RedO.get.\ncall redo_lro_equiv.\nwhile (={c, q, glob I, glob F} /\\ Log.log{1} = Red.m{1} /\\ ofassoc Red.m{1} = LRO.m{2} /\\ q{1} = Red.q{1}).\n+ outline {1} [1..3] ~ RedO.get.\n  wp.\n  call (_ : true).\n  call redo_lro_equiv.\n  auto => />.\ndo 2! (wp; call (_ : true)).\nauto => />.\nexact ofassoc_empty.\nqed.\n\nsection CONVENIENCE.\n\ndeclare pred P_in : glob I * glob F.\ndeclare pred P_out : glob I * (query_t option * aux_t) * (query_t, resp_t) fmap.\n\ndeclare axiom success_impl :\n  hoare[\n    IRunnerRO(I, F, LRO).run :\n    P_in (glob I, glob F) /\\ LRO.m = empty ==>\n    success_ro LRO.m res.`1 => P_out (glob I, res, LRO.m)\n  ].\n\ndeclare op pr_success : real.\n\ndeclare axiom success_eq :\n  phoare[\n    IRunnerRO(I, F, LRO).run :\n    P_in (P_in (glob I, glob F) /\\ LRO.m = empty)\n    ==> success_ro LRO.m res.`1\n  ] = pr_success.\n\nlemma forking_lemma_ro :\n  phoare[\n    IForkerRO(I, F).run :\n    P_in (glob I, glob F) ==>\n    let (cq, a1, a2) = res in\n    let m1 = ofassoc IForkerRO.m1 in\n    let m2 = ofassoc IForkerRO.m2 in\n    (* TODO: Rename cq? *)\n    let q  = oget cq in\n    is_some cq /\\\n    q \\in m1 /\\ q \\in m2 /\\ m1.[q] <> m2.[q] /\\\n    P_out (glob I, (cq, a1), m1) /\\ P_out (glob I, (cq, a2), m2)\n  ] >= (pr_success ^ 2 / Q%r - pr_success * pr_collision).\nproof.\nproc.\nwp.\npose Red_P_in := (fun (arg : glob I * glob Red(F)) =>\n  let (gI, gRed) = arg in\n  let (gF, _, __) = gRed in\n  P_in (gI, gF)\n).\npose Red_P_out := (fun (ret : glob I * (int * aux_t) * log_t list) =>\n  let (gI, o, log) = ret in\n  let (j, aux) = o in\n  let m = ofassoc log in\n  let (q, r) = nth witness log j in\n  q \\in m /\\ m.[q] = Some r /\\ P_out (gI, (Some q, aux), m)\n).\ncall (\n  forking_lemma I (Red(F))\n  Red_F_rewindable Red_F_continue_ll Red_F_finish_ll\n  Red_P_in Red_P_out _ pr_success _\n).\n+ conseq red_log_fro_lro_equiv success_impl; 1: smt().\n  smt(nth_assoc_index).\n+ have success_eq_log : phoare[\n    IRunner(I, Red(F), Log(FRO)).run : P_in (glob I, glob F) /\\ Log.log = [] ==> success res.`1\n  ] = pr_success.\n  + conseq red_log_fro_lro_equiv success_eq => /#.\n  conseq (irunner_log_equiv I (Red(F))) success_eq_log => /#.\nskip.\nrewrite /Red_P_out.\nsmt().\nqed.\n\nend section CONVENIENCE.\n\nend section PROOF.\n```"]], "EC-1/FSetAux.ec": [[false, "```ec\n(* FSetAux.ec *)\n\n(* Auxiliary Lemmas on Finite Sets *)\n\nprover quorum=2"]], "EC-1/GuessGame.ec": [[true, "require import AllCore List Distr Dexcepted FelTactic.\nrequire import StdOrder StdBigop Finite.\nimport RealOrder Bigreal.\n\ntype bits = bool.\n\nop bD : bits distr = Dbool.\n\naxiom bDU : is_uniform bD.\naxiom bDL : is_lossless bD.\n\nmodule type GuessGame = {\n  proc init(r : int) : unit\n  proc guess(x : bits) : bool\n}.\n\nmodule type Adversary (O:GuessGame) = {\n   proc play() : unit {O.guess}\n}.\n\nmodule Main (O:GuessGame) (A:Adversary) = {\n  proc main(q : int) = {\n    var r;\n    O.init(q);\n    r <@ A(O).play();\n    return r;\n  }\n}.\n\nmodule GG = {\n  var win : bool\n  var c, q : int\n\n  proc init(q : int) = {\n    c    <- 0;\n    win  <- false;\n    GG.q <- q;\n  }\n\n  proc guess(x : bits) : bool = {\n    var r;\n    r <- witness;\n    if (c < q) {\n      r <$ bD;\n      win <- win || r = x;\n      c <- c + 1;\n    }    \n    return win;\n  }\n}.\n\nop supp_size (d : 'a distr) : int = size (to_seq (support d)).\n\nlemma winPr &m : forall (A <:Adversary {-GG}), forall q, 0 <= q =>\n Pr[ Main(GG,A).main(q) @ &m : GG.win  ] \n    <= q%r  / (supp_size bD)%r.\nproof. move => A. move => q q_pos.\nhave ->:  Pr[ Main(GG,A).main(q) @ &m : GG.win ] = Pr[ Main(GG,A).main(q) @ &m : GG.win  /\\ (0 <= GG.c <= q) ].\nbyequiv (_: ={glob A, glob GG, arg} /\\ GG.q{1} = GG.q{2} /\\ arg{1} = q  ==> _). proc.\nseq 1 1 : (={glob A, glob GG} /\\ GG.q{1} = GG.q{2} /\\ (0 <= GG.c <= GG.q){1} /\\ GG.q{1} = q).\ninline *.   wp. skip. progress.\n call (_: (0 <= GG.c <= GG.q){1} /\\ ={glob GG} /\\ GG.q{1} = q).\nproc. sp. if. smt().  wp. rnd. skip. smt(). skip. smt().\nskip. progress. auto.  auto.  \n  fel 1 GG.c (fun x => 1%r / (supp_size bD)%r) q GG.win [GG.guess : (GG.c < GG.q)] => //.\n   rewrite BRA.sumr_const RField.intmulr count_predT.\n    smt (size_range).\n   inline *;auto.\n   proc;inline *;sp 1;if;last by hoare.\n    wp.\n    conseq (_ : _ ==> r = x)=> [ /# | ].\n    rnd;auto => &hr /> x.\n    move => z.\n    rewrite mu1_uni_ll. apply bDU. apply bDL.\n    rewrite /supp_size.\n    case (x{hr} \\in bD). smt(@List). smt(@Real @List).\n   move=> c;proc;sp;inline *.\n    by rcondt 1 => //;wp;conseq (_: _ ==> true) => // /#.\n  move=> b c;proc;sp;inline *;if => //.\n  sp. wp. rnd.  skip.  smt().\nqed.", "The completed file is:```ec\nrequire import AllCore List Distr Dexcepted FelTactic.\nrequire import StdOrder StdBigop Finite.\nimport RealOrder Bigreal.\n\ntype bits = bool.\n\nop bD : bits distr = Dbool.\n\naxiom bDU : is_uniform bD.\naxiom bDL : is_lossless bD.\n\nmodule type GuessGame = {\n  proc init(r : int) : unit\n  proc guess(x : bits) : bool\n}.\n\nmodule type Adversary (O:GuessGame) = {\n   proc play() : unit {O.guess}\n}.\n\nmodule Main (O:GuessGame) (A:Adversary) = {\n  proc main(q : int) = {\n    var r;\n    O.init(q);\n    r <@ A(O).play();\n    return r;\n  }\n}.\n\nmodule GG = {\n  var win : bool\n  var c, q : int\n\n  proc init(q : int) = {\n    c    <- 0;\n    win  <- false;\n    GG.q <- q;\n  }\n\n  proc guess(x : bits) : bool = {\n    var r;\n    r <- witness;\n    if (c < q) {\n      r <$ bD;\n      win <- win || r = x;\n      c <- c + 1;\n    }    \n    return win;\n  }\n}.\n\nop supp_size (d : 'a distr) : int = size (to_seq (support d)).\n\nlemma winPr &m : forall (A <:Adversary {-GG}), forall q, 0 <= q =>\n Pr[ Main(GG,A).main(q) @ &m : GG.win  ] \n    <= q%r  / (supp_size bD)%r.\nproof. move => A. move => q q_pos.\nhave ->:  Pr[ Main(GG,A).main(q) @ &m : GG.win ] = Pr[ Main(GG,A).main(q) @ &m : GG.win  /\\ (0 <= GG.c <= q) ].\nbyequiv (_: ={glob A, glob GG, arg} /\\ GG.q{1} = GG.q{2} /\\ arg{1} = q  ==> _). proc.\nseq 1 1 : (={glob A, glob GG} /\\ GG.q{1} = GG.q{2} /\\ (0 <= GG.c <= GG.q){1} /\\ GG.q{1} = q).\ninline *.   wp. skip. progress.\n call (_: (0 <= GG.c <= GG.q){1} /\\ ={glob GG} /\\ GG.q{1} = q).\nproc. sp. if. smt().  wp. rnd. skip. smt(). skip. smt().\nskip. progress. auto.  auto.  \n  fel 1 GG.c (fun x => 1%r / (supp_size bD)%r) q GG.win [GG.guess : (GG.c < GG.q)] => //.\n   rewrite BRA.sumr_const RField.intmulr count_predT.\n    smt (size_range).\n   inline *;auto.\n   proc;inline *;sp 1;if;last by hoare.\n    wp.\n    conseq (_ : _ ==> r = x)=> [ /# | ].\n    rnd;auto => &hr /> x.\n    move => z.\n    rewrite mu1_uni_ll. apply bDU. apply bDL.\n    rewrite /supp_size.\n    case (x{hr} \\in bD). smt(@List). smt(@Real @List).\n   move=> c;proc;sp;inline *.\n    by rcondt 1 => //;wp;conseq (_: _ ==> true) => // /#.\n  move=> b c;proc;sp;inline *;if => //.\n  sp. wp. rnd.  skip.  smt().\nqed.\n```"]], "EC-1/hoare-logic.ec": [[true, "rcondf 5.\n(*\nNotice how the postcondition now requires the condition for the while loop\nto be false.\nSince it would evaluate to false, EC gets rid of the loop.\nNow we can either use the if tactic that we used earlier to work with the\nif conditions here, but wp is generally strong enough to reason with if conditions.\nSo let us make our lives a little easier and use that instead.\nHere, since the program is quite simple, the smt solvers can complete the proof.\nHowever, pay attention to how hard it gets to read the output\nafter the application of wp, and skip.\n*)\n  wp.\n  skip.\n  smt.\n\n(*\nGoal #2:\nAgain, we have two \"if\" conditions, that we need to work with.\nThe proof proceeds the same way as before. wp is strong enough to reason with it.\n*)\n\n  wp.\n  skip.\n  smt.\nqed.\n\n(*\nAs usual we could have used some tacticals to shorten the proof.\nSo let us do that, to clean up the previous proof.\n*)\n\nlemma ten_to_two_clean: hoare [ Exp.exp : x = 10 /\\ n = 2 ==> res = 100 ].\nproof.\n  proc.\n  unroll 3.\n  unroll 4.\n  rcondf 5; auto.\nqed.\n\n(*\nFor a loop that unrolls twice it is easy to do it manually.\nHowever, this strategy wouldn't work for a different scenario.\nFor instance in order to prove that the program works correctly we need to prove\nthe correctness for every number, so we would prefer to work with abstract symbols\nand not concrete numbers like 10^2.\nIn order to work up to it, let us prove that 2^10 works as intended.\nBut first, we need to understand that EC was not built for computations.\nIt can handle small calculations like we've seen so far but asking EC to do 2^10\ndoesn't work as we'd like it to.\nFor instance, take a look at the following lemma, and our attempt to prove it.\n*)\n\nlemma twototen: 2^10 = 1024.\nproof.\n  trivial.\n  simplify.\n  auto.\n(*\nNone of those tactics do anything \nEven smt doesn't work.\nYou can try it as well.\nAgain, the point here is that, these kinds of tasks aren't what EC was\nbuilt for.\nFor the time being we will admit this lemma, since we know that\n2^10 is in fact 1024.\nWe need this to prove the next few lemmas relating to hoare triples.\n*)\n  admit.\nqed.\n\nlemma two_to_ten: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n\n(*\nAs an additional invariant, we know that the loop runs until our\nloop variable i goes from 0, to n. So as an invariant, we have\n0 <= i <= n, and the control exits the loop when ! (i < n).\nLet us try to see what happens if we add this in.\n*)\n  while ( x = 2  /\\ 0 <= i <= n).\n  wp.\n  auto.\n  smt.\n\n(*\nLet us read what the goal says now.\nAgain it says something about r0 without bounding what r0 can be.\nThis attempt will also fail.\nSo we need to understand what happens to the variable r0, at the end of every\niteration of the loop.\n*)\nabort.\n\n\nlemma two_to_ten: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n(*\nWe know that after every iteration, the variable r is multiplied by x.\nSo in this case, since we have x = 2, essentially at the end of\ni iterations of the loop we have the fact that r = 2^i.\nThis is an invariant, and it binds r to the variables that are passed to the\nloop. Let us see if this attempt works.\n*)\n  while (x = 2  /\\ 0 <= i <= n /\\  r = 2^i).\n\n(*\nAgain, Goal #1 will go through quite easily.\n*)\n  wp.\n  skip.\n  smt.\n\n(* Goal #2 *)\n  wp.\n  simplify.\n  auto.\n(*\nWhen the goal is too complicated to read, we can apply the tactic \"progress\".\n\"progress\" breaks the goals into simpler ones by repeatedly applying the\n\"split\", \"subst\" and \"move =>\" tactics and trying to solve trivial goals automatically.\n*)\n  progress.\n\n(* 2 ^ 0 = 1 *)\n  smt.\n\n(* 2^10 = 1024 *)\n  smt.\nqed.\n\n(*\nA point to note here:\nHad we not admitted the lemma twototen the proof would get stuck\nYou are welcome to comment it out and try the proof again.\n*)\n\n(*\nSo finally, we have an invariant that works.\nLet us clean up the proof, and also if we think about it,\nthe condition (x=2) isn't really needed, since the program never\nmodifies the value of x. So let us get rid of that condition as well.\n*)\n\nlemma two_to_ten_clean: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n  simplify.\n  while ( r = x^i /\\ 0 <= i <= n); auto; smt.\nqed.\n\n(*\nNow the proof seems so innocuous and straightforward.\nHowever, it is important to understand that these proofs and\nfiguring out the loop invariants always take a few tries, and\nsometimes crafting the right invariant can be an art by itself.\nThis also gets quite hard when there are a lot of variables\nto keep track of. So it is good practice to work with smaller examples first.\n*)\n\n\n(*\nNow let us try to work with abstract symbols, the stuff that EC\nwas actually built for. Here we mentioned in the text, in order to claim\nthat the exp function is correct, we need to have the condition that\nthe exponent that we provide is greater than zero.\nWe use x0, and n0, in order to differentiate from the program variables.\n*)\nlemma x0_to_n0_correct (x0 n0: int): \n  0 <= n0 =>\n  hoare [ Exp.exp : x = x0 /\\ n = n0 ==> res = x0 ^ n0 ].\nproof.\n  move => Hn0.\n  proc.\n  while (r=x^i /\\ 0 <= i <= n).\n  wp.\n  skip.\n  smt.\n\n  wp.\n  skip.\n  progress.\n  smt.\n  smt.\nqed.\n\n\n(*\nAgain, we can clean up the proof like so:\nNotice that we omit the type declaration of x0 and n0,\nsince EasyCrypt can figure it out by itself.\n*)\nlemma x0_to_n0_correct_clean x0 n0: \n  0 <= n0 =>\n  hoare [ Exp.exp : x = x0 /\\ n = n0 ==> res = x0 ^ n0 ].\nproof.\n  move => Hn0.\n  proc.\n  while (r=x^i /\\ 0 <= i <= n); auto; smt.\nqed.\n\n(*\nAs an exercise, you can do similar proofs for the following mathematical functions:\n1. A program to decide if a given number is even or odd.\n2. A program to compute the factorial of a given number.\n*)", "```ec\nrcondf 5.\n(*\nNotice how the postcondition now requires the condition for the while loop\nto be false.\nSince it would evaluate to false, EC gets rid of the loop.\nNow we can either use the if tactic that we used earlier to work with the\nif conditions here, but wp is generally strong enough to reason with if conditions.\nSo let us make our lives a little easier and use that instead.\nHere, since the program is quite simple, the smt solvers can complete the proof.\nHowever, pay attention to how hard it gets to read the output\nafter the application of wp, and skip.\n*)\n  wp.\n  skip.\n  smt.\n\n(*\nGoal #2:\nAgain, we have two \"if\" conditions, that we need to work with.\nThe proof proceeds the same way as before. wp is strong enough to reason with it.\n*)\n\n  wp.\n  skip.\n  smt.\nqed.\n\n(*\nAs usual we could have used some tacticals to shorten the proof.\nSo let us do that, to clean up the previous proof.\n*)\n\nlemma ten_to_two_clean: hoare [ Exp.exp : x = 10 /\\ n = 2 ==> res = 100 ].\nproof.\n  proc.\n  unroll 3.\n  unroll 4.\n  rcondf 5; auto.\nqed.\n\n(*\nFor a loop that unrolls twice it is easy to do it manually.\nHowever, this strategy wouldn't work for a different scenario.\nFor instance in order to prove that the program works correctly we need to prove\nthe correctness for every number, so we would prefer to work with abstract symbols\nand not concrete numbers like 10^2.\nIn order to work up to it, let us prove that 2^10 works as intended.\nBut first, we need to understand that EC was not built for computations.\nIt can handle small calculations like we've seen so far but asking EC to do 2^10\ndoesn't work as we'd like it to.\nFor instance, take a look at the following lemma, and our attempt to prove it.\n*)\n\nlemma twototen: 2^10 = 1024.\nproof.\n  trivial.\n  simplify.\n  auto.\n(*\nNone of those tactics do anything \nEven smt doesn't work.\nYou can try it as well.\nAgain, the point here is that, these kinds of tasks aren't what EC was\nbuilt for.\nFor the time being we will admit this lemma, since we know that\n2^10 is in fact 1024.\nWe need this to prove the next few lemmas relating to hoare triples.\n*)\n  admit.\nqed.\n\nlemma two_to_ten: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n\n(*\nAs an additional invariant, we know that the loop runs until our\nloop variable i goes from 0, to n. So as an invariant, we have\n0 <= i <= n, and the control exits the loop when ! (i < n).\nLet us try to see what happens if we add this in.\n*)\n  while ( x = 2  /\\ 0 <= i <= n).\n  wp.\n  auto.\n  smt.\n\n(*\nLet us read what the goal says now.\nAgain it says something about r0 without bounding what r0 can be.\nThis attempt will also fail.\nSo we need to understand what happens to the variable r0, at the end of every\niteration of the loop.\n*)\nabort.\n\n\nlemma two_to_ten: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n(*\nWe know that after every iteration, the variable r is multiplied by x.\nSo in this case, since we have x = 2, essentially at the end of\ni iterations of the loop we have the fact that r = 2^i.\nThis is an invariant, and it binds r to the variables that are passed to the\nloop. Let us see if this attempt works.\n*)\n  while (x = 2  /\\ 0 <= i <= n /\\  r = 2^i).\n\n(*\nAgain, Goal #1 will go through quite easily.\n*)\n  wp.\n  skip.\n  smt.\n\n(* Goal #2 *)\n  wp.\n  simplify.\n  auto.\n(*\nWhen the goal is too complicated to read, we can apply the tactic \"progress\".\n\"progress\" breaks the goals into simpler ones by repeatedly applying the\n\"split\", \"subst\" and \"move =>\" tactics and trying to solve trivial goals automatically.\n*)\n  progress.\n\n(* 2 ^ 0 = 1 *)\n  smt.\n\n(* 2^10 = 1024 *)\n  smt.\nqed.\n\n(*\nA point to note here:\nHad we not admitted the lemma twototen the proof would get stuck\nYou are welcome to comment it out and try the proof again.\n*)\n\n(*\nSo finally, we have an invariant that works.\nLet us clean up the proof, and also if we think about it,\nthe condition (x=2) isn't really needed, since the program never\nmodifies the value of x. So let us get rid of that condition as well.\n*)\n\nlemma two_to_ten_clean: hoare [ Exp.exp : x = 2 /\\ n = 10 ==> res = 1024 ].\nproof.\n  proc.\n  simplify.\n  while ( r = x^i /\\ 0 <= i <= n); auto; smt.\nqed.\n\n(*\nNow the proof seems so innocuous and straightforward.\nHowever, it is important to understand that these proofs and\nfiguring out the loop invariants always take a few tries, and\nsometimes crafting the right invariant can be an art by itself.\nThis also gets quite hard when there are a lot of variables\nto keep track of. So it is good practice to work with smaller examples first.\n*)\n\n\n(*\nNow let us try to work with abstract symbols, the stuff that EC\nwas actually built for. Here we mentioned in the text, in order to claim\nthat the exp function is correct, we need to have the condition that\nthe exponent that we provide is greater than zero.\nWe use x0, and n0, in order to differentiate from the program variables.\n*)\nlemma x0_to_n0_correct (x0 n0: int): \n  0 <= n0 =>\n  hoare [ Exp.exp : x = x0 /\\ n = n0 ==> res = x0 ^ n0 ].\nproof.\n  move => Hn0.\n  proc.\n  while (r=x^i /\\ 0 <= i <= n).\n  wp.\n  skip.\n  smt.\n\n  wp.\n  skip.\n  progress.\n  smt.\n  smt.\nqed.\n\n\n(*\nAgain, we can clean up the proof like so:\nNotice that we omit the type declaration of x0 and n0,\nsince EasyCrypt can figure it out by itself.\n*)\nlemma x0_to_n0_correct_clean x0 n0: \n  0 <= n0 =>\n  hoare [ Exp.exp : x = x0 /\\ n = n0 ==> res = x0 ^ n0 ].\nproof.\n  move => Hn0.\n  proc.\n  while (r=x^i /\\ 0 <= i <= n); auto; smt.\nqed.\n\n(*\nAs an exercise, you can do similar proofs for the following mathematical functions:\n1. A program to decide if a given number is even or odd.\n2. A program to compute the factorial of a given number.\n*)\n```"]], "EC-1/HybridArgumentWithParameter.ec": [[true, "@ &m : p' (glob A) (glob Ob) Count.c res]).\n  proof. by move => qN0 p'; rewrite Hybrid /= /p'; smt(q_ge0). qed.\n\nend section.\n\n(* -------------------------------------------------------------------- *)\n(* Simplified variant: Assume that A calls the oracle at most q times. *)\nsection.\ndeclare axiom q_ge0 : 0<= q .\n  declare module Ob <: Orclb   {-Count,-HybOrcl}.\n  declare module A <: AdvOrclb {-Count,-HybOrcl,-L(Ob),-R(Ob)}.\n\n  declare axiom A_call :\n    forall (O <: Orcl{-Count,-A}),\n      hoare [ Orcln(A(Ob), O).main : true ==> Count.c <= q ].\n\n  declare axiom losslessL: islossless Ob.leaks.\n  declare axiom losslessOb1: islossless Ob.orclL.\n  declare axiom losslessOb2: islossless Ob.orclR.\n  declare axiom losslessA (Ob0 <: Orclb{-A}) (LR <: Orcl{-A}):\n    islossless LR.orcl =>\n    islossless Ob0.leaks => islossless Ob0.orclL => islossless Ob0.orclR =>\n    islossless A(Ob0, LR).main.\n\n  local module Al = Orcln(A(Ob),HybOrcl(Ob,L(Ob))).\n\n  local module Bl = {\n    proc main(ma:argt) : outputA = {\n      var r : outputA;\n\n      HybOrcl.l0 <$ [0..max 0 (q-1)];\n      HybOrcl.l  <- 0;\n      r <@ Al.main(ma);\n      return r;\n    }\n  }.\n\n  local module Ar = Orcln(A(Ob),HybOrcl(Ob,R(Ob))).\n\n  local module Br = {\n    proc main(ma:argt) : outputA = {\n      var r : outputA;\n\n      HybOrcl.l0 <$ [0..max 0 (q-1)];\n      HybOrcl.l  <- 0;\n      r <@ Ar.main(ma);\n      return r;\n    }\n  }.\n\n  local equiv B_Bl : HybGame(A,Ob,L(Ob)).main ~ Bl.main :\n     ={glob A, glob Ob,arg} ==>\n     ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} = HybOrcl.l{2} /\\ Count.c{2} <= q.\n  proof.\n  conseq (:  ={glob A, glob Ob, arg} ==> ={glob A, glob Ob, glob HybOrcl, res})\n         _\n         (: true ==> Count.c = HybOrcl.l /\\ Count.c <= q).\n  + conseq (:  ==> Count.c = HybOrcl.l) (: true ==> Count.c <= q).\n    + by proc; call (A_call (<: HybOrcl(Ob,L(Ob))))=> //.\n    proc; inline *; wp; call (: Count.c = HybOrcl.l).\n    + by proc; inline *; wp; conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    by wp.\n  proc; inline Al.main; wp; call (: ={glob Ob, glob HybOrcl}).\n  + proc; inline *; wp; sp; if=> //.\n    + by call (: true).\n    by if=> //; wp; call (: true).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  by inline *; auto.\n  qed.\n\n  local equiv B_Br : HybGame(A,Ob,R(Ob)).main ~ Br.main :\n     ={glob A, glob Ob,arg} ==>\n     ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} = HybOrcl.l{2} /\\ Count.c{2} <= q.\n  proof.\n  conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, glob HybOrcl, res})\n         _\n         (: true ==> Count.c = HybOrcl.l /\\ Count.c <= q).\n  + conseq (: true ==> Count.c = HybOrcl.l) (: true ==> Count.c <= q).\n    + by proc; call (A_call (<: HybOrcl(Ob,R(Ob)))).\n    proc; inline *; wp; call (: Count.c = HybOrcl.l).\n    + by proc; inline *; wp; conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    by wp.\n  proc; inline Ar.main; wp; call (: ={glob Ob, glob HybOrcl}).\n  + proc; inline *; wp; sp; if=> //.\n    + by call (: true).\n    by if=> //; wp; call (: true).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  by inline *; auto.\n  qed.\n\n  local lemma Pr_Bl &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n       Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n     = Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  proof.\n  have ->:\n      Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n    = Pr[Bl.main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  + by byequiv B_Bl.\n  apply eq_sym.\n  by byequiv B_Bl.\n  qed.\n\n  local lemma Pr_Br &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n       Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n     = Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  proof.\n  have ->:\n      Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n    = Pr[Br.main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  + by byequiv B_Br.\n  apply eq_sym.\n  by byequiv B_Br.\n  qed.\n\n  lemma Hybrid_restr &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n        Pr[Ln(Ob,A).main(maz) @ &m : p (glob A) (glob Ob) Count.c res]\n      - Pr[Rn(Ob,A).main(maz) @ &m : p (glob A) (glob Ob) Count.c res]\n    = q%r *(  Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n            - Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]).\n  proof.\n  apply/eq_sym; pose p' := fun ga ge l r, p ga ge l r /\\ l <= q.\n  have ->:   Pr[Ln(Ob,A).main(maz) @ &m : p  (glob A) (glob Ob) Count.c res]\n           = Pr[Ln(Ob,A).main(maz) @ &m : p' (glob A) (glob Ob) Count.c res].\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res} /\\ Count.c{1} <= q)=> [| |@/p'] //=.\n    conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res}) (: true ==> Count.c <= q).\n    + exact/(A_call (<: L(Ob))).\n    by sim.\n  have ->:   Pr[Rn(Ob,A).main(maz) @ &m : p  (glob A) (glob Ob) Count.c res]\n           = Pr[Rn(Ob,A).main(maz) @ &m : p' (glob A) (glob Ob) Count.c res].\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res} /\\ Count.c{1} <= q)=> [| |@/p'] //=.\n    conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res}) (: true ==> Count.c <= q).\n    + exact/(A_call (<: R(Ob))).\n    by sim.\n  rewrite (Pr_Bl &m p) (Pr_Br &m p).\n  have /= H := Hybrid q_ge0 Ob A losslessL losslessOb1 losslessOb2 losslessA &m p.\n  rewrite /p' H.\n  congr; congr.\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} <= 1)=> //.\n    proc; inline *; wp.\n    call (: ={glob Ob, glob HybOrcl} /\\ (if HybOrcl.l <= HybOrcl.l0 then Count.c = 0 else Count.c =1){2}).\n    + proc; inline *; wp.\n      if=> //.\n      + by call (: ={glob HybOrcl}); auto=> /#.\n      if=> //.\n      + by wp; call (: ={glob HybOrcl}); auto=> /#.\n      by call (: ={glob HybOrcl}); auto=> /#.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    by auto=> /> l0 /supp_dinter /#.\n  congr.\n  byequiv (: ={arg,glob A, glob Ob} ==> ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} <= 1)=> //.\n  proc; inline *; wp.\n  call (: ={glob Ob, glob HybOrcl} /\\ (if HybOrcl.l <= HybOrcl.l0 then Count.c = 0 else Count.c =1){2}).\n  + proc; inline *; wp.\n    if=> //.\n    + by call (: ={glob HybOrcl}); auto=> /#.\n    if=> //.\n    + by wp; call (: ={glob HybOrcl}); auto=> /#.\n    by call (: ={glob HybOrcl}); auto=> /#.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  by auto=> /> l0 /supp_dinter /#.\n  qed.\n\nend section.", "```ec\n@ &m : p' (glob A) (glob Ob) Count.c res]).\n  proof. by move => qN0 p'; rewrite Hybrid /= /p'; smt(q_ge0). qed.\n\nend section.\n\n(* -------------------------------------------------------------------- *)\n(* Simplified variant: Assume that A calls the oracle at most q times. *)\nsection.\ndeclare axiom q_ge0 : 0<= q .\n  declare module Ob <: Orclb   {-Count,-HybOrcl}.\n  declare module A <: AdvOrclb {-Count,-HybOrcl,-L(Ob),-R(Ob)}.\n\n  declare axiom A_call :\n    forall (O <: Orcl{-Count,-A}),\n      hoare [ Orcln(A(Ob), O).main : true ==> Count.c <= q ].\n\n  declare axiom losslessL: islossless Ob.leaks.\n  declare axiom losslessOb1: islossless Ob.orclL.\n  declare axiom losslessOb2: islossless Ob.orclR.\n  declare axiom losslessA (Ob0 <: Orclb{-A}) (LR <: Orcl{-A}):\n    islossless LR.orcl =>\n    islossless Ob0.leaks => islossless Ob0.orclL => islossless Ob0.orclR =>\n    islossless A(Ob0, LR).main.\n\n  local module Al = Orcln(A(Ob),HybOrcl(Ob,L(Ob))).\n\n  local module Bl = {\n    proc main(ma:argt) : outputA = {\n      var r : outputA;\n\n      HybOrcl.l0 <$ [0..max 0 (q-1)];\n      HybOrcl.l  <- 0;\n      r <@ Al.main(ma);\n      return r;\n    }\n  }.\n\n  local module Ar = Orcln(A(Ob),HybOrcl(Ob,R(Ob))).\n\n  local module Br = {\n    proc main(ma:argt) : outputA = {\n      var r : outputA;\n\n      HybOrcl.l0 <$ [0..max 0 (q-1)];\n      HybOrcl.l  <- 0;\n      r <@ Ar.main(ma);\n      return r;\n    }\n  }.\n\n  local equiv B_Bl : HybGame(A,Ob,L(Ob)).main ~ Bl.main :\n     ={glob A, glob Ob,arg} ==>\n     ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} = HybOrcl.l{2} /\\ Count.c{2} <= q.\n  proof.\n  conseq (:  ={glob A, glob Ob, arg} ==> ={glob A, glob Ob, glob HybOrcl, res})\n         _\n         (: true ==> Count.c = HybOrcl.l /\\ Count.c <= q).\n  + conseq (:  ==> Count.c = HybOrcl.l) (: true ==> Count.c <= q).\n    + by proc; call (A_call (<: HybOrcl(Ob,L(Ob))))=> //.\n    proc; inline *; wp; call (: Count.c = HybOrcl.l).\n    + by proc; inline *; wp; conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    by wp.\n  proc; inline Al.main; wp; call (: ={glob Ob, glob HybOrcl}).\n  + proc; inline *; wp; sp; if=> //.\n    + by call (: true).\n    by if=> //; wp; call (: true).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  by inline *; auto.\n  qed.\n\n  local equiv B_Br : HybGame(A,Ob,R(Ob)).main ~ Br.main :\n     ={glob A, glob Ob,arg} ==>\n     ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} = HybOrcl.l{2} /\\ Count.c{2} <= q.\n  proof.\n  conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, glob HybOrcl, res})\n         _\n         (: true ==> Count.c = HybOrcl.l /\\ Count.c <= q).\n  + conseq (: true ==> Count.c = HybOrcl.l) (: true ==> Count.c <= q).\n    + by proc; call (A_call (<: HybOrcl(Ob,R(Ob)))).\n    proc; inline *; wp; call (: Count.c = HybOrcl.l).\n    + by proc; inline *; wp; conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    + by conseq (: _ ==> true).\n    by wp.\n  proc; inline Ar.main; wp; call (: ={glob Ob, glob HybOrcl}).\n  + proc; inline *; wp; sp; if=> //.\n    + by call (: true).\n    by if=> //; wp; call (: true).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  + by proc (={glob HybOrcl}).\n  by inline *; auto.\n  qed.\n\n  local lemma Pr_Bl &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n       Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n     = Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  proof.\n  have ->:\n      Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n    = Pr[Bl.main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  + by byequiv B_Bl.\n  apply eq_sym.\n  by byequiv B_Bl.\n  qed.\n\n  local lemma Pr_Br &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n       Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n     = Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  proof.\n  have ->:\n      Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n    = Pr[Br.main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res /\\ HybOrcl.l <= q].\n  + by byequiv B_Br.\n  apply eq_sym.\n  by byequiv B_Br.\n  qed.\n\n  lemma Hybrid_restr &m (p:glob A -> glob Ob -> int -> outputA -> bool) maz:\n        Pr[Ln(Ob,A).main(maz) @ &m : p (glob A) (glob Ob) Count.c res]\n      - Pr[Rn(Ob,A).main(maz) @ &m : p (glob A) (glob Ob) Count.c res]\n    = q%r *(  Pr[HybGame(A,Ob,L(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]\n            - Pr[HybGame(A,Ob,R(Ob)).main(maz) @ &m : p (glob A) (glob Ob) HybOrcl.l res]).\n  proof.\n  apply/eq_sym; pose p' := fun ga ge l r, p ga ge l r /\\ l <= q.\n  have ->:   Pr[Ln(Ob,A).main(maz) @ &m : p  (glob A) (glob Ob) Count.c res]\n           = Pr[Ln(Ob,A).main(maz) @ &m : p' (glob A) (glob Ob) Count.c res].\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res} /\\ Count.c{1} <= q)=> [| |@/p'] //=.\n    conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res}) (: true ==> Count.c <= q).\n    + exact/(A_call (<: L(Ob))).\n    by sim.\n  have ->:   Pr[Rn(Ob,A).main(maz) @ &m : p  (glob A) (glob Ob) Count.c res]\n           = Pr[Rn(Ob,A).main(maz) @ &m : p' (glob A) (glob Ob) Count.c res].\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res} /\\ Count.c{1} <= q)=> [| |@/p'] //=.\n    conseq (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, Count.c, res}) (: true ==> Count.c <= q).\n    + exact/(A_call (<: R(Ob))).\n    by sim.\n  rewrite (Pr_Bl &m p) (Pr_Br &m p).\n  have /= H := Hybrid q_ge0 Ob A losslessL losslessOb1 losslessOb2 losslessA &m p.\n  rewrite /p' H.\n  congr; congr.\n  + byequiv (: ={glob A, glob Ob,arg} ==> ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} <= 1)=> //.\n    proc; inline *; wp.\n    call (: ={glob Ob, glob HybOrcl} /\\ (if HybOrcl.l <= HybOrcl.l0 then Count.c = 0 else Count.c =1){2}).\n    + proc; inline *; wp.\n      if=> //.\n      + by call (: ={glob HybOrcl}); auto=> /#.\n      if=> //.\n      + by wp; call (: ={glob HybOrcl}); auto=> /#.\n      by call (: ={glob HybOrcl}); auto=> /#.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    + by conseq (: _ ==> ={res,glob Ob})=> //; sim.\n    by auto=> /> l0 /supp_dinter /#.\n  congr.\n  byequiv (: ={arg,glob A, glob Ob} ==> ={glob A, glob Ob, glob HybOrcl, res} /\\ Count.c{2} <= 1)=> //.\n  proc; inline *; wp.\n  call (: ={glob Ob, glob HybOrcl} /\\ (if HybOrcl.l <= HybOrcl.l0 then Count.c = 0 else Count.c =1){2}).\n  + proc; inline *; wp.\n    if=> //.\n    + by call (: ={glob HybOrcl}); auto=> /#.\n    if=> //.\n    + by wp; call (: ={glob HybOrcl}); auto=> /#.\n    by call (: ={glob HybOrcl}); auto=> /#.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  + by conseq (: _ ==> ={res, glob Ob})=> //; sim.\n  by auto=> /> l0 /supp_dinter /#.\n  qed.\n\nend section.\n```"]], "EC-1/JBigNum.ec": [[true, "op nlimbs : int.\naxiom gt0_nlimbs: 0 < nlimbs.", "```ec\nop nlimbs : int.\naxiom gt0_nlimbs: 0 < nlimbs.\n```"]], "EC-1/JensensSquare.ec": [[true, "require import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nrequire import SquareConvex.\n\n\nlemma bs : forall a, a <= 1%r => 0%r  <= a => a * a <= a. smt.\nqed.\n\nlemma hzc : forall (a b : real), a >= 0%r => b >= 1%r => a * b >= a. smt.\nqed.\n\nlemma bss : forall (a b c : real),  c <= b => 0%r < c => b <= 1%r => a >= 0%r => a / b <= a / c.  smt. qed.\n\nlemma bsss : forall (a b c : real),  0%r < a => a <= 1%r  => b / a <= c / a => b <= c.  smt. qed.\n\n\nlemma bs2 : forall (a : real), (square a) = a * a. smt. \nqed.\n\nlemma Jensen_fin_without_lossless ['a] :\n  forall (d : 'a distr) (f : 'a -> real),\n    is_finite (support d) =>\n    square (E d f) <= E d (square \\o f).\nproof.  \nmove => d f pr.\ncase (weight d = 0%r).\nsmt.\ncase (0%r <= weight d <= 1%r).\nelim. \nmove => wp1 wp2. move => wb.\nhave :     square (E (dscale d) f) <= E (dscale d) (square \\o f).\napply Jensen_fin. smt. apply dscale_ll. \nsmt. apply square_convex.\nhave : forall f, E (dscale d) f = (E d f) / (weight d).\nmove => g.\nsimplify E.\nhave : (fun (x : 'a) => g x * mu1 (dscale d) x) = (fun (x : 'a) =>  1%r/(weight d) * (g x * mu1 d x)).\napply fun_ext. move => x. simplify.\nsmt.\nmove =>  k. rewrite  k.\nrewrite sumZ. smt.\nmove => l.\nrewrite (l f).\nrewrite (l (square \\o f)).\nhave : square (E d f / weight d) = square (E d f) / square (weight d).\ntimeout 20. smt.\nmove => j. rewrite j.  clear j. clear l. clear pr.\nmove => wp3. \nhave wp4 : square (weight d) <=  (weight d). rewrite  bs2. smt.\nhave wp5 : square (E d f) /  (weight d) <= square (E d f) / square (weight d). apply bss.\nauto. smt. auto. smt.\napply (bsss (weight d) ). smt. auto. smt.\nsmt.\nqed.\n\n\nlemma jen_big ['a] :\n  forall (d : 'a distr) (f : 'a -> real) J,\n  is_finite (support d) => uniq J =>\n    (forall (x : 'a), (fun (x : 'a) => f x * mu1 d x) x <> 0%r => x \\in J) \n  => (big predT (fun (x : 'a) => f x * mu1 d x) J) ^ 2\n    <= (big predT (fun (x : 'a) => square (f x) * mu1 d x) J).\nproof. simplify.\nmove => d f J fd uJ pJ1. \n  have pJ2 : forall (x : 'a), (fun (x0 : 'a) => square (f x0) * mu1 d x0) x <> 0%r => x \\in J.\nauto. move => x. simplify. move => pr. apply pJ1.\n   have : mu1 d x <> 0%r.  smt.\n   smt.\nrewrite - (sumE_fin (fun (x : 'a) => f x * mu1 d x) J uJ pJ1). \nrewrite - (sumE_fin (fun (x : 'a) => square (f x) * mu1 d x) J uJ pJ2).  \n\napply Jensen_fin_without_lossless.\nauto.\nqed.\n\n\nlemma jen_big_spec ['a] :\n  forall (d : 'a distr) (f : 'a -> real) J,\n  is_finite (support d) => uniq J =>\n    (forall (x : 'a), (fun (x : 'a) => f x * mu1 d x) x <> 0%r => x \\in J) \n  => (big predT (fun (x : 'a) => mu1 d x * f x) J) ^ 2\n    <= (big predT (fun (x : 'a) => mu1 d x * (f x) * (f x)) J).\nproof. progress.\nhave : (fun (x : 'a) => mu1 d x * f x) = (fun (x : 'a) => f x * mu1 d x).\napply fun_ext. move => x. smt.\nhave : (fun (x : 'a) => mu1 d x * f x * f x) = (fun (x : 'a) => square (f x) * mu1 d x).\napply fun_ext. move => x. smt.\nmove => e1 e2. rewrite e1 e2.\napply jen_big.\nauto. auto. auto.\nqed.\n\n\nop rest ['a] (f : 'a -> real) (J : 'a list)  (x : 'a) : real \n = if x \\in J then f x else 0%r.\n\n\nlemma big_rest_gen ['a] : forall (J Q : 'a list) (f : 'a -> real), \n  (forall a, a \\in J => a \\in Q) =>\n  big predT f J = big predT (rest f Q) J.\nproof. apply list_ind. progress.\nsimplify. move => a l ih Q f Qp. \nhave : big predT f (a :: l) = (f a) + big predT f l. smt.\nmove => e1. rewrite e1. clear e1.\nhave : big predT (rest f Q) (a :: l) = (rest f Q) a + big predT (rest f Q) l.\nsmt. move => e1. rewrite e1. clear e1.\nsimplify rest.\nhave : a \\in Q. smt.\nmove => aq. rewrite aq. simplify.\nrewrite (ih Q ). smt.\nauto.\nqed.\n\n\nlemma big_rest ['a] : forall (J : 'a list) (f : 'a -> real), \n  big predT f J = big predT (rest f J) J.\nproof. move => J f. apply big_rest_gen. auto.\nqed.\n\n\nlemma big_rest_sm ['a] : forall (J Q : 'a list) (f : 'a -> real), \n  (forall a, 0%r <= f a) =>\n  big predT (rest f Q) J <= big predT f J.\nproof. apply list_ind. smt.\nsimplify. move => x l ih. move => Q f.\nhave : big predT f (x :: l) = (f x) + big predT f l. smt.\nmove => e1. rewrite e1. clear e1.\nhave : big predT (rest f Q) (x :: l) = (rest f Q) x + big predT (rest f Q) l.\nsmt. move => e1. rewrite e1. clear e1.\nmove => ap. \nhave : rest f Q x <= f x.\nsmt.\nmove => apc. \nhave ihc : big predT (rest f Q) l <= big predT f l.\napply ih. auto.  \nclear ih.\nclear ap.\nsmt.\nqed.\n\n\nlemma jen_big_spec2 ['a] :\n  forall (d : 'a -> real) (f : 'a -> real) J,\n   uniq J => isdistr d\n  => (big predT (fun (x : 'a) => d x * f x) J) ^ 2\n    <= (big predT (fun (x : 'a) => d x * (f x) * (f x)) J).\nproof. move => d f J u idp. case idp.\nmove => idp1 idp2.\nhave e : big predT (fun (x : 'a) =>  d x * f x) J = big predT (rest (fun (x : 'a) => d x * f x) J) J.  rewrite big_rest. auto.\nrewrite e. clear e.\nhave e : big predT (fun (x : 'a) =>  d x * f x * f x) J = big predT (rest (fun (x : 'a) => d x * f x * f x) J) J.  rewrite big_rest. auto.\nrewrite e. clear e.\nsimplify rest.  \nhave isd : isdistr ((fun x => if x \\in J then d x else 0%r)). split. \nmove => x. simplify. smt.\nmove => s us.\nhave : big predT (fun (x : 'a) => if x \\in J then d x else 0%r) s <=  big predT d s .\n  apply big_rest_sm. auto. \nsmt.\nhave e : (fun (x : 'a) => if x \\in J then d x * f x else 0%r) = (fun (x : 'a) => mu1 (mk (fun x => if x \\in J then d x else 0%r)) x * f x ). apply fun_ext.\nmove => x. simplify.  smt.\nrewrite e. clear e.\nhave e : (fun (x : 'a) => if x \\in J then d x * f x * f x else 0%r) \n = (fun (x : 'a) => mu1 (mk (fun x => if x \\in J then d x else 0%r)) x * f x  * f x).\napply fun_ext. move => x. smt. rewrite e. clear e.\napply (jen_big_spec (mk (rest d J)) f).\nexists (filter (fun x => d x > 0%r) J). split.\nsmt.\nmove => x. split. \nmove => xj. simplify rest. \nhave : support (mk (rest d J)) x.\n   have : 0%r < d x . smt. move => m0.\n   have : mu (mk (rest d J)) (pred1 x)  = d x. \n   rewrite muK. auto.  have : x \\in J. smt. move => xj'. smt.\n   move => m1.\n smt.\nauto.\nmove => xmrd. \nhave : (rest d J) x <> 0%r.\nhave : (mu1 (mk (rest d J))) x <> 0%r. smt. \nauto. auto.\nmove => kll.\nhave : d x <> 0%r. smt(muK).\nmove => dxo. smt(muK).\nsmt. auto. \nsmt(muK).\nqed.", "```ec\nrequire import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nrequire import SquareConvex.\n\n\nlemma bs : forall a, a <= 1%r => 0%r  <= a => a * a <= a. smt.\nqed.\n\nlemma hzc : forall (a b : real), a >= 0%r => b >= 1%r => a * b >= a. smt.\nqed.\n\nlemma bss : forall (a b c : real),  c <= b => 0%r < c => b <= 1%r => a >= 0%r => a / b <= a / c.  smt. qed.\n\nlemma bsss : forall (a b c : real),  0%r < a => a <= 1%r  => b / a <= c / a => b <= c.  smt. qed.\n\n\nlemma bs2 : forall (a : real), (square a) = a * a. smt. \nqed.\n\nlemma Jensen_fin_without_lossless ['a] :\n  forall (d : 'a distr) (f : 'a -> real),\n    is_finite (support d) =>\n    square (E d f) <= E d (square \\o f).\nproof.  \nmove => d f pr.\ncase (weight d = 0%r).\nsmt.\ncase (0%r <= weight d <= 1%r).\nelim. \nmove => wp1 wp2. move => wb.\nhave :     square (E (dscale d) f) <= E (dscale d) (square \\o f).\napply Jensen_fin. smt. apply dscale_ll. \nsmt. apply square_convex.\nhave : forall f, E (dscale d) f = (E d f) / (weight d).\nmove => g.\nsimplify E.\nhave : (fun (x : 'a) => g x * mu1 (dscale d) x) = (fun (x : 'a) =>  1%r/(weight d) * (g x * mu1 d x)).\napply fun_ext. move => x. simplify.\nsmt.\nmove =>  k. rewrite  k.\nrewrite sumZ. smt.\nmove => l.\nrewrite (l f).\nrewrite (l (square \\o f)).\nhave : square (E d f / weight d) = square (E d f) / square (weight d).\ntimeout 20. smt.\nmove => j. rewrite j.  clear j. clear l. clear pr.\nmove => wp3. \nhave wp4 : square (weight d) <=  (weight d). rewrite  bs2. smt.\nhave wp5 : square (E d f) /  (weight d) <= square (E d f) / square (weight d). apply bss.\nauto. smt. auto. smt.\napply (bsss (weight d) ). smt. auto. smt.\nsmt.\nqed.\n\n\nlemma jen_big ['a] :\n  forall (d : 'a distr) (f : 'a -> real) J,\n  is_finite (support d) => uniq J =>\n    (forall (x : 'a), (fun (x : 'a) => f x * mu1 d x) x <> 0%r => x \\in J) \n  => (big predT (fun (x : 'a) => f x * mu1 d x) J) ^ 2\n    <= (big predT (fun (x : 'a) => square (f x) * mu1 d x) J).\nproof. simplify.\nmove => d f J fd uJ pJ1. \n  have pJ2 : forall (x : 'a), (fun (x0 : 'a) => square (f x0) * mu1 d x0) x <> 0%r => x \\in J.\nauto. move => x. simplify. move => pr. apply pJ1.\n   have : mu1 d x <> 0%r.  smt.\n   smt.\nrewrite - (sumE_fin (fun (x : 'a) => f x * mu1 d x) J uJ pJ1). \nrewrite - (sumE_fin (fun (x : 'a) => square (f x) * mu1 d x) J uJ pJ2).  \n\napply Jensen_fin_without_lossless.\nauto.\nqed.\n\n\nlemma jen_big_spec ['a] :\n  forall (d : 'a distr) (f : 'a -> real) J,\n  is_finite (support d) => uniq J =>\n    (forall (x : 'a), (fun (x : 'a) => f x * mu1 d x) x <> 0%r => x \\in J) \n  => (big predT (fun (x : 'a) => mu1 d x * f x) J) ^ 2\n    <= (big predT (fun (x : 'a) => mu1 d x * (f x) * (f x)) J).\nproof. progress.\nhave : (fun (x : 'a) => mu1 d x * f x) = (fun (x : 'a) => f x * mu1 d x).\napply fun_ext. move => x. smt.\nhave : (fun (x : 'a) => mu1 d x * f x * f x) = (fun (x : 'a) => square (f x) * mu1 d x).\napply fun_ext. move => x. smt.\nmove => e1 e2. rewrite e1 e2.\napply jen_big.\nauto. auto. auto.\nqed.\n\n\nop rest ['a] (f : 'a -> real) (J : 'a list)  (x : 'a) : real \n = if x \\in J then f x else 0%r.\n\n\nlemma big_rest_gen ['a] : forall (J Q : 'a list) (f : 'a -> real), \n  (forall a, a \\in J => a \\in Q) =>\n  big predT f J = big predT (rest f Q) J.\nproof. apply list_ind. progress.\nsimplify. move => a l ih Q f Qp. \nhave : big predT f (a :: l) = (f a) + big predT f l. smt.\nmove => e1. rewrite e1. clear e1.\nhave : big predT (rest f Q) (a :: l) = (rest f Q) a + big predT (rest f Q) l.\nsmt. move => e1. rewrite e1. clear e1.\nsimplify rest.\nhave : a \\in Q. smt.\nmove => aq. rewrite aq. simplify.\nrewrite (ih Q ). smt.\nauto.\nqed.\n\n\nlemma big_rest ['a] : forall (J : 'a list) (f : 'a -> real), \n  big predT f J = big predT (rest f J) J.\nproof. move => J f. apply big_rest_gen. auto.\nqed.\n\n\nlemma big_rest_sm ['a] : forall (J Q : 'a list) (f : 'a -> real), \n  (forall a, 0%r <= f a) =>\n  big predT (rest f Q) J <= big predT f J.\nproof. apply list_ind. smt.\nsimplify. move => x l ih. move => Q f.\nhave : big predT f (x :: l) = (f x) + big predT f l. smt.\nmove => e1. rewrite e1. clear e1.\nhave : big predT (rest f Q) (x :: l) = (rest f Q) x + big predT (rest f Q) l.\nsmt. move => e1. rewrite e1. clear e1.\nmove => ap. \nhave : rest f Q x <= f x.\nsmt.\nmove => apc. \nhave ihc : big predT (rest f Q) l <= big predT f l.\napply ih. auto.  \nclear ih.\nclear ap.\nsmt.\nqed.\n\n\nlemma jen_big_spec2 ['a] :\n  forall (d : 'a -> real) (f : 'a -> real) J,\n   uniq J => isdistr d\n  => (big predT (fun (x : 'a) => d x * f x) J) ^ 2\n    <= (big predT (fun (x : 'a) => d x * (f x) * (f x)) J).\nproof. move => d f J u idp. case idp.\nmove => idp1 idp2.\nhave e : big predT (fun (x : 'a) =>  d x * f x) J = big predT (rest (fun (x : 'a) => d x * f x) J) J.  rewrite big_rest. auto.\nrewrite e. clear e.\nhave e : big predT (fun (x : 'a) =>  d x * f x * f x) J = big predT (rest (fun (x : 'a) => d x * f x * f x) J) J.  rewrite big_rest. auto.\nrewrite e. clear e.\nsimplify rest.  \nhave isd : isdistr ((fun x => if x \\in J then d x else 0%r)). split. \nmove => x. simplify. smt.\nmove => s us.\nhave : big predT (fun (x : 'a) => if x \\in J then d x else 0%r) s <=  big predT d s .\n  apply big_rest_sm. auto. \nsmt.\nhave e : (fun (x : 'a) => if x \\in J then d x * f x else 0%r) = (fun (x : 'a) => mu1 (mk (fun x => if x \\in J then d x else 0%r)) x * f x ). apply fun_ext.\nmove => x. simplify.  smt.\nrewrite e. clear e.\nhave e : (fun (x : 'a) => if x \\in J then d x * f x * f x else 0%r) \n = (fun (x : 'a) => mu1 (mk (fun x => if x \\in J then d x else 0%r)) x * f x  * f x).\napply fun_ext. move => x. smt. rewrite e. clear e.\napply (jen_big_spec (mk (rest d J)) f).\nexists (filter (fun x => d x > 0%r) J). split.\nsmt.\nmove => x. split. \nmove => xj. simplify rest. \nhave : support (mk (rest d J)) x.\n   have : 0%r < d x . smt. move => m0.\n   have : mu (mk (rest d J)) (pred1 x)  = d x. \n   rewrite muK. auto.  have : x \\in J. smt. move => xj'. smt.\n   move => m1.\n smt.\nauto.\nmove => xmrd. \nhave : (rest d J) x <> 0%r.\nhave : (mu1 (mk (rest d J))) x <> 0%r. smt. \nauto. auto.\nmove => kll.\nhave : d x <> 0%r. smt(muK).\nmove => dxo. smt(muK).\nsmt. auto. \nsmt(muK).\nqed.\n```"]], "EC-1/ListAux.ec": [[true, "(* ListAux.ec *)\n\n(* Auxiliary Lemmas on Lists *)\n\nprover quorum=2 [\"Alt-Ergo\" \"Z3\"].  (* both Alt-Ergo and Z3 must succeed *)\n\nrequire import AllCore List.\nrequire import StdOrder. import IntOrder.\n\nlemma nth_in_range (i : int, x y : 'a, zs : 'a list) :\n  0 <= i < size zs => nth x zs i = nth y zs i.\nproof.\nmove : i.\nelim zs => [/= i [ge0_i lt0_i] | z zs IH i /= [ge0_i lt_sz_zs_plus1]].\nhave // : 0 < 0 by apply (ler_lt_trans i).\ncase (i = 0) => // ne0_i; rewrite IH /#.\nqed.\n\nlemma nth_head (z : 'a, xs : 'a list) :\n  nth z xs 0 = head z xs.\nproof.\ncase (xs = []) => [-> | ne_xs_nil].\nby rewrite nth_default.\nby rewrite -(head_behead xs z).\nqed.\n\nlemma drop1_behead (xs : 'a list) :\n  drop 1 xs = behead xs.\nproof.\ncase (xs = []) => [-> // | non_nil_xs].\nhave <- /= : head witness xs :: behead xs = xs\n  by apply head_behead.\nby rewrite drop0.\nqed.\n\nlemma mem_ne_list_behead (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (behead xs) y).\nproof.\nmove => non_nil_xs.\nsplit => [mem_xs_y | disj].\nby rewrite -in_cons head_behead.\nhave <- // : head witness xs :: behead xs = xs\n  by apply head_behead.\nqed.\n\nlemma mem_ne_list_drop1 (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (drop 1 xs) y).\nproof.\nmove => non_nil_xs.\nby rewrite drop1_behead mem_ne_list_behead.\nqed.\n\nlemma drop1_drop (xs : 'a list, n : int) :\n  0 <= n => drop (n + 1) xs = drop 1 (drop n xs).\nproof.\nmove => ge0_n.\ncase (n < size xs) => [lt_n_sz_xs | not_lt_n_sz_xs].\nby rewrite (drop_nth witness n) //= drop0.\nhave ge_sz_xs_n : size xs <= n by rewrite lezNgt.\nrewrite (drop_oversize n) // (drop_oversize 1) // (drop_oversize (n + 1)) //.\nby rewrite (lez_trans n) // -{1}addz0 (lez_add2l n 0 1).\nqed.\n\nlemma drop_drop (xs : 'a list, n m : int) :\n  0 <= n => 0 <= m =>\n  drop (n + m) xs = drop n (drop m xs).\nproof.\nelim n => [ge0_m /= | n ge0_n IH ge0_m].\nby rewrite drop0.\nby rewrite (drop1_drop (drop m xs) n) // -IH // -drop1_drop 1:addz_ge0 //\n           addzAC.\nqed.\n\nlemma nonnil_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> [].\nproof. by elim xs. qed.\n\nlemma nonnil_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> [].\nproof. by elim ys. qed.\n\nlemma ne_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> xs.\nproof. by elim xs. qed.\n\nlemma ne_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> xs.\nproof.\n(case xs; first by rewrite cats0) => z zs nonnil_ys.\ncase (ys ++ z :: zs = z :: zs) => [eq | //].\nrewrite -cat1s catA -(cat0s ([z] ++ zs)) -catA in eq.\nhave // : ys = [] by apply (catIs ys [] ([z] ++ zs)).\nqed.", "To complete the given task, we need to examine the provided EasyCrypt code and its description to identify the missing parts marked by `____()___`. However, upon reviewing the given code and description, it appears that the code is already complete and does not contain any `____()___` placeholders.\n\nThe provided code is a collection of lemmas related to list operations in EasyCrypt, along with a detailed description of its purpose, required modules, and explanations of each lemma.\n\n```ec\n(* ListAux.ec *)\n\n(* Auxiliary Lemmas on Lists *)\n\nprover quorum=2 [\"Alt-Ergo\" \"Z3\"].  (* both Alt-Ergo and Z3 must succeed *)\n\nrequire import AllCore List.\nrequire import StdOrder. import IntOrder.\n\nlemma nth_in_range (i : int, x y : 'a, zs : 'a list) :\n  0 <= i < size zs => nth x zs i = nth y zs i.\nproof.\nmove : i.\nelim zs => [/= i [ge0_i lt0_i] | z zs IH i /= [ge0_i lt_sz_zs_plus1]].\nhave // : 0 < 0 by apply (ler_lt_trans i).\ncase (i = 0) => // ne0_i; rewrite IH /#.\nqed.\n\nlemma nth_head (z : 'a, xs : 'a list) :\n  nth z xs 0 = head z xs.\nproof.\ncase (xs = []) => [-> | ne_xs_nil].\nby rewrite nth_default.\nby rewrite -(head_behead xs z).\nqed.\n\nlemma drop1_behead (xs : 'a list) :\n  drop 1 xs = behead xs.\nproof.\ncase (xs = []) => [-> // | non_nil_xs].\nhave <- /= : head witness xs :: behead xs = xs\n  by apply head_behead.\nby rewrite drop0.\nqed.\n\nlemma mem_ne_list_behead (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (behead xs) y).\nproof.\nmove => non_nil_xs.\nsplit => [mem_xs_y | disj].\nby rewrite -in_cons head_behead.\nhave <- // : head witness xs :: behead xs = xs\n  by apply head_behead.\nqed.\n\nlemma mem_ne_list_drop1 (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (drop 1 xs) y).\nproof.\nmove => non_nil_xs.\nby rewrite drop1_behead mem_ne_list_behead.\nqed.\n\nlemma drop1_drop (xs : 'a list, n : int) :\n  0 <= n => drop (n + 1) xs = drop 1 (drop n xs).\nproof.\nmove => ge0_n.\ncase (n < size xs) => [lt_n_sz_xs | not_lt_n_sz_xs].\nby rewrite (drop_nth witness n) //= drop0.\nhave ge_sz_xs_n : size xs <= n by rewrite lezNgt.\nrewrite (drop_oversize n) // (drop_oversize 1) // (drop_oversize (n + 1)) //.\nby rewrite (lez_trans n) // -{1}addz0 (lez_add2l n 0 1).\nqed.\n\nlemma drop_drop (xs : 'a list, n m : int) :\n  0 <= n => 0 <= m =>\n  drop (n + m) xs = drop n (drop m xs).\nproof.\nelim n => [ge0_m /= | n ge0_n IH ge0_m].\nby rewrite drop0.\nby rewrite (drop1_drop (drop m xs) n) // -IH // -drop1_drop 1:addz_ge0 //\n           addzAC.\nqed.\n\nlemma nonnil_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> [].\nproof. by elim xs. qed.\n\nlemma nonnil_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> [].\nproof. by elim ys. qed.\n\nlemma ne_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> xs.\nproof. by elim xs. qed.\n\nlemma ne_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> xs.\nproof.\n(case xs; first by rewrite cats0) => z zs nonnil_ys.\ncase (ys ++ z :: zs = z :: zs) => [eq | //].\nrewrite -cat1s catA -(cat0s ([z] ++ zs)) -catA in eq.\nhave // : ys = [] by apply (catIs ys [] ([z] ++ zs)).\nqed.\n```\nSince there are no `____()___` placeholders in the code, the task is essentially to confirm that the given code is correct and complete as per the description.\n\nThe final answer is: \n```ec\n(* ListAux.ec *)\n\n(* Auxiliary Lemmas on Lists *)\n\nprover quorum=2 [\"Alt-Ergo\" \"Z3\"].  (* both Alt-Ergo and Z3 must succeed *)\n\nrequire import AllCore List.\nrequire import StdOrder. import IntOrder.\n\nlemma nth_in_range (i : int, x y : 'a, zs : 'a list) :\n  0 <= i < size zs => nth x zs i = nth y zs i.\nproof.\nmove : i.\nelim zs => [/= i [ge0_i lt0_i] | z zs IH i /= [ge0_i lt_sz_zs_plus1]].\nhave // : 0 < 0 by apply (ler_lt_trans i).\ncase (i = 0) => // ne0_i; rewrite IH /#.\nqed.\n\nlemma nth_head (z : 'a, xs : 'a list) :\n  nth z xs 0 = head z xs.\nproof.\ncase (xs = []) => [-> | ne_xs_nil].\nby rewrite nth_default.\nby rewrite -(head_behead xs z).\nqed.\n\nlemma drop1_behead (xs : 'a list) :\n  drop 1 xs = behead xs.\nproof.\ncase (xs = []) => [-> // | non_nil_xs].\nhave <- /= : head witness xs :: behead xs = xs\n  by apply head_behead.\nby rewrite drop0.\nqed.\n\nlemma mem_ne_list_behead (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (behead xs) y).\nproof.\nmove => non_nil_xs.\nsplit => [mem_xs_y | disj].\nby rewrite -in_cons head_behead.\nhave <- // : head witness xs :: behead xs = xs\n  by apply head_behead.\nqed.\n\nlemma mem_ne_list_drop1 (xs : 'a list, y : 'a) :\n  xs <> [] =>\n  (mem xs y <=>\n   y = head witness xs \\/ mem (drop 1 xs) y).\nproof.\nmove => non_nil_xs.\nby rewrite drop1_behead mem_ne_list_behead.\nqed.\n\nlemma drop1_drop (xs : 'a list, n : int) :\n  0 <= n => drop (n + 1) xs = drop 1 (drop n xs).\nproof.\nmove => ge0_n.\ncase (n < size xs) => [lt_n_sz_xs | not_lt_n_sz_xs].\nby rewrite (drop_nth witness n) //= drop0.\nhave ge_sz_xs_n : size xs <= n by rewrite lezNgt.\nrewrite (drop_oversize n) // (drop_oversize 1) // (drop_oversize (n + 1)) //.\nby rewrite (lez_trans n) // -{1}addz0 (lez_add2l n 0 1).\nqed.\n\nlemma drop_drop (xs : 'a list, n m : int) :\n  0 <= n => 0 <= m =>\n  drop (n + m) xs = drop n (drop m xs).\nproof.\nelim n => [ge0_m /= | n ge0_n IH ge0_m].\nby rewrite drop0.\nby rewrite (drop1_drop (drop m xs) n) // -IH // -drop1_drop 1:addz_ge0 //\n           addzAC.\nqed.\n\nlemma nonnil_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> [].\nproof. by elim xs. qed.\n\nlemma nonnil_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> [].\nproof. by elim ys. qed.\n\nlemma ne_cat_nonnil_r (xs ys : 'a list) :\n  ys <> [] => xs ++ ys <> xs.\nproof. by elim xs. qed.\n\nlemma ne_cat_nonnil_l (xs ys : 'a list) :\n  ys <> [] => ys ++ xs <> xs.\nproof.\n(case xs; first by rewrite cats0) => z zs nonnil_ys.\ncase (ys ++ z :: zs = z :: zs) => [eq | //].\nrewrite -cat1s catA -(cat0s ([z] ++ zs)) -catA in eq.\nhave // : ys = [] by apply (catIs ys [] ([z] ++ zs)).\nqed.\n```"]], "EC-1/MLWE_PKE_Basic.ec": [[true, "(* Completed code *)\n\nop under_noise_bound : R -> bool.\n\naxiom good_decode m n :\n  under_noise_bound n =>\n  m_decode (m_encode m &+ n) = m.\n\n(* ... other definitions ... *)\n\nsection.\n\ndeclare module A <: CORR_ADV.\n\n(* ... other lemmas ... *)\n\nend section.\n\nend MLWE_PKE_Basic.", "```ec\n(* Completed code *)\n\nop under_noise_bound : R -> bool.\n\naxiom good_decode m n :\n  under_noise_bound n =>\n  m_decode (m_encode m &+ n) = m.\n\n(* ... other definitions ... *)\n\nsection.\n\ndeclare module A <: CORR_ADV.\n\n(* ... other lemmas ... *)\n\nend section.\n\nend MLWE_PKE_Basic.\n```\nshould be modified to \n```ec\nop under_noise_bound : R -> int -> bool.\n\n(* ... other definitions ... *)\n\nsection.\n\ndeclare module A <: CORR_ADV.\n\n(* ... other lemmas ... *)\n\nend section.\n\nend MLWE_PKE_Basic.\n```\n\nThe final completed code with all the blanks filled should be:\n\n```ec\ncall(:true); auto => /=.\ncall (:true); wp.\nby rnd{2}; wp; do 3! rnd{2}; auto; smt(duni_ll).\nqed.\n\nlemma hop1_right &m:\n  Pr[MLWE(B1(A)).main(true) @ &m : res] =\n  Pr[CPA(MLWE_PKE_BASIC1,A).main() @ &m : res].\nproof.\nbyequiv => //.\nproc;inline *.\nwp; call(:true); auto => /=.\ncall(:true); wp => /=.\nrnd{1}; wp; do 2! rnd{1}.\nby rnd; wp; rnd{1}; auto; smt(duni_ll dshort_ll).\nqed.\n\nend section.\n\n(* Hop 2 *)\n\nmodule MLWE_PKE_BASIC2 = {\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var _A,u, v;\n    _A <- m_transpose pk.`1;\n    u <$duni;\n    v <$duni_R;\n    return (u,v &+ m_encode m);\n  }\n\n  include MLWE_PKE_BASIC1 [-enc]\n\n}.\n\nmodule B2(A : Adversary) : Adv_T = {\n\n  proc kg(_A : matrix, t : vector) : pkey * skey = {\n    return ((m_transpose _A,t),witness);\n  }\n\n  proc enc(pk : pkey, m : plaintext, uv : vector * R) : ciphertext = {\n    return ((uv.`1, uv.`2 &+ m_encode m));\n  }\n\n  proc guess(_A : matrix, t : vector, uv : vector * R) : bool = {\n    var pk, sk, m0, m1, c, b, b';\n    (pk,sk) <@ kg(_A,t);\n    (m0, m1) <@ A.choose(pk);\n    b <$ {0,1};\n    c <@ enc(pk, if b then m1 else m0,uv);\n    b' <@ A.guess(c);\n    return b' = b;\n  }\n\n}.\n\nsection.\n\ndeclare module A <: Adversary.\n\nlemma hop2_left &m:\n  Pr[CPA(MLWE_PKE_BASIC1,A).main() @ &m : res] =\n  Pr[MLWE(B2(A)).main(false) @ &m : res].\nproof.\nbyequiv => //.\nproc; inline *.\nswap {2} 6 -4.\nswap {2} [10..11] -7.\nswap {2} [13..16] -8.\nseq 4 7 : (#pre /\\ ={t,pk} /\\ (pk{2}).`1 = m_transpose _A{2} /\\ (pk{2}).`2 = t{2}).\n+ wp;rnd; rnd{1}; rnd (fun m => m_transpose m); auto => /= />;\n  smt(trmxK mu1_uni duni_matrix_uni duni_matrix_fu dshort_ll).\nswap {2} [10..12] -8.\nwp; call(_: true); wp; rnd{2}; wp; rnd; rnd{2}; wp;\n   rnd; rnd; wp; rnd; call(_: true); auto => />; smt(duni_ll dshort_ll trmxK).\nqed.\n\nlemma hop2_right &m:\n  Pr[MLWE(B2(A)).main(true) @ &m : res] =\n  Pr[CPA(MLWE_PKE_BASIC2,A).main() @ &m : res].\nproof.\nbyequiv => //.\nproc; inline *.\nswap {1} 6 -4.\nswap {1} [10..11] -7.\nswap {1} [13..16] -8.\nseq 7 4 : (#pre /\\ ={t,pk} /\\ (pk{2}).`1 = _A{2} /\\ (pk{2}).`2 = t{2}).\n+ wp;rnd; rnd{2}; rnd (fun m => m_transpose m); auto => /= />;\n  smt(trmxK mu1_uni duni_matrix_uni duni_matrix_fu dshort_ll).\nswap {1} [10..12] -8.\nby wp; call(_: true);wp;rnd;wp;rnd{1};rnd;wp;rnd{1};rnd{1};wp;rnd;\n   call(_: true); auto;smt(duni_ll dshort_ll).\nqed.\n\nend section.\n\n(* Final game analysis *)\n\nsection.\n\ndeclare module A <: Adversary.\n\nlocal module Game2(A : Adversary) = {\n  proc main() = {\n    var _A, s, t, m0, m1, u, v, b, b';\n    _A <$ duni_matrix;\n    s <$ dshort;\n    t <$ duni;\n    (m0, m1) <@ A.choose(_A,t);\n    u <$duni;\n    v <$duni_R;\n    b' <@ A.guess((u,v));\n    b <$ {0,1};\n    return b = b';\n  }\n}.\n\nlocal lemma game2_equiv &m :\n  Pr[CPA(MLWE_PKE_BASIC2,A).main() @ &m : res] =\n  Pr[Game2(A).main() @ &m : res].\nproof.\nbyequiv => //.\nproc; inline *.\nswap {2} 8 -3.\ncall(_: true); wp.\nrnd (fun z, z &+ m_encode (if b then m1 else m0){2})\n    (fun z, z &- m_encode (if b then m1 else m0){2}).\nauto; call (_:true).\nauto => /> *; split => *; [ ring | split => *; [ring | smt()]].\nqed.\n\nlocal lemma game2_prob &m :\n  islossless A.guess => islossless A.choose =>\n  Pr[Game2(A).main() @ &m : res] = 1%r / 2%r.\nproof.\nmove => A_guess_ll A_choose_ll.\nbyphoare => //.\nproc.\nrnd  (pred1 b')=> //=.\nconseq (: _ ==> true).\n+ by move=> />; apply DBool.dbool1E.\nby islossless; smt(duni_ll duni_matrix_ll dshort_ll).\nqed.\n\nlemma main_theorem &m :\n  islossless A.guess => islossless A.choose =>\n  Pr[CPA(MLWE_PKE_BASIC,A).main() @ &m : res] -  1%r / 2%r =\n    Pr[MLWE(B1(A)).main(false) @ &m : res] -\n       Pr[MLWE(B1(A)).main(true) @ &m : res] +\n    Pr[MLWE(B2(A)).main(false) @ &m : res] -\n       Pr[MLWE(B2(A)).main(true) @ &m : res].\nproof.\nmove => A_guess_ll A_choose_ll.\nrewrite (hop1_left A &m).\nrewrite (hop1_right A &m).\nrewrite (hop2_left A &m).\nrewrite (hop2_right A &m).\nrewrite (game2_equiv &m).\nrewrite (game2_prob &m _ _) //.\nby ring.\nqed.\n\nend section.\n\n(******************************************************************)\n(*                        Correctness                             *)\n(* We consider adversarial correctness, where the attacker can    *)\n(* choose the message where correctness is checked after seeing   *)\n(* the public-key. This setting seems to be the one in which      *)\n(* failure probability is considered in the FO construction.      *)\n(******************************************************************)\n\n(* We want to prove a concrete bound on the probability of failure\n   for MLKEM. We will do so generically by first showing at this\n   level that it all comes down to the noise distribution. *)\n\nop noise_exp _A s e r e1 e2 m =\n    let t = _A *^ s + e in\n    let u = m_transpose _A *^ r + e1 in\n    let v = (t `<*>` r) &+ e2 &+ (m_encode m) in\n        v &- (s `<*>` u) &- (m_encode m).\n\nlemma matrix_props1 _A s e r :\n  (_A *^ s + e) `<*>` r =\n  (s ^* m_transpose _A `<*>` r) &+ (e `<*>` r).\nproof. by rewrite dotpDl -mulmxTv trmxK. qed.\n\nlemma matrix_props2 s _A r e1 :\n  s `<*>` (m_transpose _A *^ r + e1) =\n  (s ^* m_transpose _A `<*>` r) &+\n    (s `<*>` e1).\nproof. by rewrite !dotpDr dotpC dotp_mulmxv dotpC. qed.\n\nop noise_exp_simpl s e r e1 e2 =\n  ((e `<*>` r) &- (s `<*>` e1)  &+ e2 ).\n\nlemma noise_exp_val _A s e r e1 e2 m :\n  noise_exp _A s e r e1 e2 m =\n  noise_exp_simpl s e r e1 e2\nby  rewrite /noise_exp /noise_exp_simpl /=  matrix_props1 matrix_props2; ring.\n\n(* The above noise expression is computed over the abstract\n   rings that define the scheme. Noise bounds are checked and\n   computed over the integers. *)\n\nop max_noise : int.\nop under_noise_bound : R -> int -> bool.\n\naxiom good_decode m n :\n  under_noise_bound n max_noise =>\n  m_decode (m_encode m &+ n) = m.\n\n\nmodule CorrectnessBound = {\n  proc main() = {\n    var s,e,r,e1,e2,n;\n    r <$ dshort;\n    s <$ dshort;\n    e <$ dshort;\n    e1 <$ dshort;\n    e2 <$ dshort_R;\n    n <- noise_exp_simpl s e r e1 e2;\n    return (!under_noise_bound n max_noise);\n  }\n}.\n\nsection.\n\ndeclare module A <: CORR_ADV.\n\nlemma correctness_noise &m :\n  islossless A.find =>\n  Pr[Correctness_Adv(MLWE_PKE_BASIC, A).main() @ &m : res] <=\n    Pr[CorrectnessBound.main() @ &m : res].\nproof.\nmove => A_ll.\nbyequiv => //.\nproc;inline *;swap {1} 8 4; swap {1} 6 5.\nwp;call{1}(_: true ==> true).\nswap {2} [2..3] -1.\nauto => />; rewrite duni_matrix_ll /=  /= => _A _ s _ e  _ r _  e1 _ e2 _ m /=.\nhave -> : (_A *^ s + e `<*>` r) &+ e2 &+ m_encode m &+ - (s `<*>` trmx _A *^ r + e1)  =\n          m_encode m  + noise_exp _A s e r e1 e2 m by rewrite /noise_exp /=;ring.\nhave -> := noise_exp_val _A s e r e1 e2 m.\nsmt(good_decode).\nqed.\n\nlemma correctness_theorem &m fail_prob :\n islossless A.find =>\n   Pr[ CorrectnessBound.main() @ &m : res] <= fail_prob =>\n     Pr[ Correctness_Adv(MLWE_PKE_BASIC,A).main() @ &m : res] <= fail_prob\n by smt(correctness_noise).\n\nend section.\n\nend MLWE_PKE_Basic.\n```"]], "EC-1/BarrettReduction_Concrete.ec": [[false, "```ec\nop ri_uncompute (n : int) = \n  (n * (2^(64 * nlimbs) %/ n)) %% 2^(64 * nlimbs).\n\nlemma ri_un : \n  equiv"]], "EC-1/ModularMultiplication_Concrete.ec": [[false, "```houzhui\nrequire import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BigNum_spec BigNum_proofs.\n\nrequire import BarrettRedInt BarrettReduction_Abstract BarrettReduction_Concrete.\n\nrequire import W64_SchnorrExtract.\nimport W64xN.\nimport W64x2N.\n\n\nequiv mulm_cspec:\n M(Syscall).bn_mulm ~ CSpecFp.mulm:\n  valR a{1} = a{2}\n  /\\ valR p{1} = p{2}\n  /\\ valR b{1} = b{2}\n  /\\ valR a{1} < p{2}\n  /\\ valR b{1} < p{2}\n  /\\ ImplZZ p{1} p{2}\n  /\\ valR r{1} = ri_uncompute p{2}\n   ==> valR res{1} =  res{2} .\nproc. \ncall bnreduce_spec.\necall (muln_spec a{1} b{1}).\nwp. skip. simplify.\nmove => &1 &2 H1. split. smt().\nmove => q1 r1 r2 r3 . split. simplify. rewrite - r3.\nsmt(@W64xN @W64x2N).\n   split.  simplify. smt().\nsplit. simplify. smt().\nsplit.  smt (@W64xN).\nsplit.  simplify. split. \nelim r3. move => q q2. rewrite - q. smt(@W64x2N).\nmove => q. \nelim r3.  move => q2. rewrite - q2. elim H1. progress.\nhave ->: valR r1.`4 = (W64xN.R2.bnk dnlimbs r1.`4). auto.\nrewrite H5. \n  have pop : forall (x y z : int), 0 <= x < z /\\ 0 <= y < z => x * y < z * z. smt(@Int).\n  apply pop.\nprogress.\nsmt(@W64xN).\nsmt(@W64xN).\nsmt(@W64x2N).\nqed.\n\n\nlemma bn_mulm_correct aa bb pp:\n  phoare[ M(Syscall).bn_mulm : a = aa /\\ b = bb /\\ p = pp /\\ 0 <= valR a < valR p /\\ valR r = ri_uncompute (valR p) /\\ 0 <= valR b < valR p \n    ==> (valR aa * valR bb)%% (valR pp) = valR res ] = 1%r.\nproof. bypr. progress.\n have <- : Pr[CSpecFp.mulm(valR a{m}, valR b{m}, valR p{m}) @ &m : (valR a{m} * valR b{m}) %% valR p{m} =  res] = 1%r. \n  byphoare (_: arg = (valR a{m}, valR b{m}, valR p{m}) ==> _).\nproc. inline*. wp. skip. smt(). auto. auto.\nbyequiv. conseq mulm_cspec. smt().\nsmt().\nsmt(). smt(). \nqed.\n\nlemma bn_mulm_correct_pr &m a b p r:\n  W64xN.valR a < W64xN.valR p\n  => W64xN.valR b < valR p\n  => W64x2N.valR r = ri_uncompute (valR p)\n  => Pr[ M(Syscall).bn_mulm(r,p,a,b) @&m : (valR a * valR b) %% (valR p) = valR res ] = 1%r.\nproof. progress.\nbyphoare (_: arg = (r,p,a,b) ==> _).\nconseq (bn_mulm_correct a b p). \nprogress.\n____()___\nsmt(@W64xN).\nauto.\nauto.\nqed.\n```"]], "EC-1/PIR.ec": [[true, "lemma Pr_PIR_s i0 &m x :\n  Pr[PIR.main(i0) @ &m : oflist PIR.s = x] = \n    if is_restr x N then 1%r/2%r^N else 0%r.\nproof.\n  byphoare=> // {i0};proc;inline *;wp.\n  case: (is_restr x N);first last.\n  + conseq (_ : _ ==> _ : = 0%r) => [ _ -> // | ].\n    hoare;conseq (_ : _ ==> is_restr (oflist PIR.s) N); 1:by smt().\n    while (0<= j <= N /\\ is_restr (oflist PIR.s) j).\n    + auto;smt (oflist_cons is_restrS is_restr_addS).\n    auto=> ?;rewrite -set0E;smt (is_restr_fset0 N_pos).\n  sp; conseq (_ : _ ==> _ : = (if (oflist PIR.s) = restr x j then 1%r/2%r^(N-j) else 0%r)).\n  + move=> {&m} &m />;rewrite -set0E. \n    have -> // : fset0 = restr x 0.\n    + by apply fsetP=> z;rewrite /restr !inE mem_oflist mem_iota /#.\n  conseq (_ : _ ==> oflist PIR.s = restr x j) (_: _ ==> j = N) => //;1:smt().\n  + while(0 <= j <= N);auto;smt (N_pos).\n  while (0 <= j <= N /\\ is_restr (oflist PIR.s) j) (N-j) N 1%r;2,3:smt(N_pos).\n  + by move=> &hr /> _;rewrite -set0E N_pos /=; apply is_restr_fset0.\n  + move=> H.\n    case (oflist PIR.s = restr x j);first last.\n    + seq 3 : true _ 0%r 0%r _ (0 <= j <= N /\\ is_restr (oflist PIR.s) j /\\ oflist PIR.s <> restr x j).\n      + auto => /> &hr 5? b _.\n        case: (j{hr}=i{hr}) => />; rewrite restrS //= oflist_cons;\n          smt (is_restr_addS is_restrS is_restr_Ueq  is_restr_diff fset0U is_restr_restr).\n        by conseq H => /#.\n      + by hoare;auto.\n      smt().      \n    conseq (_ : _ : = (1%r / 2%r ^ (N - j))) => [/#|].\n    exists * j, PIR.s;elim * => j0 s0.    \n    seq 3: (b = (j0 \\in x)) (1%r/2%r) (1%r / 2%r ^ (N - (j0+1))) _ 0%r \n        (1 <= j <= N /\\ j = j0 + 1 /\\ (PIR.s = if b then j0 :: s0 else s0) /\\ \n         is_restr (oflist s0) j0 /\\ oflist s0 = restr x j0).\n    + by auto => /> /#.\n    + by wp => /=;rnd (pred1 (j0 \\in x));skip => /> &hr;rewrite dbool1E.\n    + conseq H => />.\n      + case: (j0 \\in x) => Hjx ?? His Hof.\n        + by rewrite oflist_cons restrS 1:/# Hjx Hof.\n        by rewrite restrS 1:/# Hjx Hof /= fset0U.\n      smt (is_restrS is_restr_addS oflist_cons).\n    + conseq H => />.\n      + move=> &hr ?? His Hof Hb.\n        rewrite restrS 1:/# (negbRL _ _ Hb).    \n        case (j0 \\in x) => /= Hj0x.\n        + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n        by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n      smt (is_restrS is_restr_addS oflist_cons).\n    move=> &hr /> ?????; rewrite -exprS 1:/#; congr;congr;ring.\n  + wp;rnd predT;skip => /> &hr.\n    smt (dbool_ll oflist_cons is_restrS is_restr_addS).\n  move=> z;auto=> />;smt (dbool_ll).\nqed.\n\nlemma Pr_PIR_s' i0 &m x :\n  Pr[PIR.main(i0) @ &m : oflist PIR.s' = x] = \n    if is_restr x N then 1%r/2%r^N else 0%r.\nproof.\n  byphoare=> // {i0};proc;inline *;wp.\n  case: (is_restr x N);first last.\n  + conseq (_ : _ ==> _ : = 0%r) => [ _ -> // | ].\n    hoare;conseq (_ : _ ==> is_restr (oflist PIR.s') N); 1:by smt().\n    while (0<= j <= N /\\ is_restr (oflist PIR.s') j).\n    + auto;smt (oflist_cons is_restrS is_restr_addS).\n    auto=> ?;rewrite -set0E;smt (is_restr_fset0 N_pos).\n  sp; conseq (_ : _ ==> _ : = (if (oflist PIR.s') = restr x j then 1%r/2%r^(N-j) else 0%r)).\n  + move=> {&m} &m />;rewrite -set0E. \n    have -> // : fset0 = restr x 0.\n    + by apply fsetP=> z;rewrite /restr !inE mem_oflist mem_iota /#.\n  conseq (_ : _ ==> oflist PIR.s' = restr x j) (_: _ ==> j = N) => //;1:smt().\n  + while(0 <= j <= N);auto;smt (N_pos).\n  while (0 <= j <= N /\\ is_restr (oflist PIR.s') j) (N-j) N 1%r;2,3:smt(N_pos).\n  + by move=> &hr /> _;rewrite -set0E N_pos /=; apply is_restr_fset0.\n  + move=> H.\n    case (oflist PIR.s' = restr x j);first last.\n    + seq 3 : true _ 0%r 0%r _ (0 <= j <= N /\\ is_restr (oflist PIR.s') j /\\ oflist PIR.s' <> restr x j).\n      + auto => /> &hr 5? b _.\n       case: (j{hr}=i{hr}) => />; rewrite restrS //= oflist_cons;\n          smt (is_restr_addS is_restrS is_restr_Ueq  is_restr_diff fset0U is_restr_restr).\n        by conseq H => /#.\n      + by hoare;auto.\n      smt().      \n    conseq (_ : _ : = (1%r / 2%r ^ (N - j))) => [/#|].\n    exists * j, PIR.s';elim * => j0 s0.    \n    seq 3: (b = ((j0 = i) ^^ (j0 \\in x))) (1%r/2%r) (1%r / 2%r ^ (N - (j0+1))) _ 0%r \n        (1 <= j <= N /\\ j = j0 + 1 /\\ (PIR.s' = if (j0=i) then (if b then s0 else j0::s0) else if b then j0 :: s0 else s0) /\\ \n         is_restr (oflist s0) j0 /\\ oflist s0 = restr x j0).\n    + by auto => /#.\n    + by wp => /=;rnd (pred1 ((j0 = i) ^^ (j0 \\in x)));skip => /> &hr;rewrite dbool1E.\n    + conseq H => />.\n      + move=> &hr ?? His Hof;case: (j0 = i{hr}) => /=. \n        + rewrite xorC xor_true => <<-.\n          case: (j0 \\in x) => Hjx.\n          + by rewrite restrS 1:/# Hjx /= oflist_cons Hof.\n          by rewrite /= restrS 1:/# Hjx /= fset0U Hof.\n        rewrite xorC xor_false => ?.\n        case: (j0 \\in x) => Hjx.\n        + by rewrite oflist_cons restrS 1:/# Hjx Hof.\n        by rewrite restrS 1:/# Hjx Hof /= fset0U.\n      smt (is_restrS is_restr_addS oflist_cons).\n    + conseq H => />.\n      + move=> &hr ?? His Hof Hb.\n        rewrite restrS 1:/# (negbRL _ _ Hb);case: (j0 = i{hr}) => /= [<<- | ?].  \n        + rewrite xorC xor_true /=.\n          case (j0 \\in x) => /= Hj0x /=.\n          + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n          by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n        rewrite xorC xor_false.\n        case (j0 \\in x) => /= Hj0x /=.\n        + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n        by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n      smt (is_restrS is_restr_addS oflist_cons).\n    by move=> &hr /> ?????;rewrite -exprS 1:/#;congr;congr;ring.\n  + wp;rnd predT;skip => &hr.\n    smt (dbool_ll oflist_cons is_restrS is_restr_addS).\n  move=> z;auto=> />;smt (dbool_ll).\nqed.\n\nlemma PIR_secuity_s_bypr i1 i2 &m1 &m2 x: \n   Pr[PIR.main(i1) @ &m1 : oflist PIR.s = x] = Pr[PIR.main(i2) @ &m2 : oflist PIR.s = x].\nproof. by rewrite (Pr_PIR_s i1 &m1 x) (Pr_PIR_s i2 &m2 x). qed.\n\nlemma PIR_secuity_s'_bypr i1 i2 &m1 &m2 x: \n   Pr[PIR.main(i1) @ &m1 : oflist PIR.s' = x] = Pr[PIR.main(i2) @ &m2 : oflist PIR.s' = x].\nproof. by rewrite (Pr_PIR_s' i1 &m1 x) (Pr_PIR_s' i2 &m2 x). qed.\n\n\n(* Other version without explicite computation of the probability,\n   we first show that the probability is uniform,\n   unfortunatly this does not allows to conclude in easycrypt.\n   We need to be able to do the projection of memories. \n   So we need functions on memory\n*)\n \nlemma PIR_s_uniform (x1 x2 : int fset):\n  0 <= N =>\n  is_restr x1 N => \n  is_restr x2 N =>\n  equiv [PIR.main ~ PIR.main : ={i} ==> (oflist PIR.s{1} = x1) = (oflist PIR.s{2} = x2)].\nproof.\n  move=> HN B1 B2;proc;inline *;wp.\n  while (={i,j} /\\ 0 <= j{1} <= N /\\ \n         is_restr (oflist PIR.s{1}) j{1} /\\ is_restr (oflist PIR.s{2}) j{1} /\\\n         ((oflist PIR.s{1} = restr x1 j{1}) = (oflist PIR.s{2} = restr x2 j{1}))).\n  + wp.\n    rnd (fun b => b ^^ (j{1} \\in x1) ^^ (j{1} \\in x2)). \n    skip => &m1 &m2 /> H0j HjN Hrs1 Hrs2 Hs Hj; split.\n    + by move=> b _;ring.\n    move=> _ b _;split;1: by ring.\n    move=> _; rewrite !oflist_cons !restrS //. \n    smt (is_restr_addS is_restrS is_restr_diff is_restr_Ueq is_restr_restr  fset0U).\n  auto; move => &m1 &m2 />.\n  rewrite !restr_0 -set0E /=;smt (is_restr_fset0).\nqed.\n\nlemma PIR_s'_uniform (x1 x2 : int fset):\n  0 <= N =>\n  is_restr x1 N => \n  is_restr x2 N =>\n  equiv [PIR.main ~ PIR.main : ={i} ==> (oflist PIR.s'{1} = x1) = (oflist PIR.s'{2} = x2)].\nproof.\n  move=> HN B1 B2;proc;inline *;wp.\n  while (={i,j} /\\ 0 <= j{1} <= N /\\ \n         is_restr (oflist PIR.s'{1}) j{1} /\\ is_restr (oflist PIR.s'{2}) j{1} /\\\n         ((oflist PIR.s'{1} = restr x1 j{1}) = (oflist PIR.s'{2} = restr x2 j{1}))).\n  + wp.\n    rnd (fun b => b ^^ (j{1} \\in x1) ^^ (j{1} \\in x2)). \n    skip => &m1 &m2 [#] 2!->> H0j HjN Hrs1 Hrs2 Hs Hj _; split.\n    + move=> b _;ring.\n    move=> _ b _; split;1: by ring.\n    move=> _; rewrite /= !oflist_cons !restrS //. \n    smt (is_restr_addS is_restrS is_restr_diff is_restr_Ueq is_restr_restr fset0U).\n  auto => &m1 &m2 />.\n  rewrite !restr_0 -set0E /=;smt (is_restr_fset0).\nqed.", "```ec\nlemma Pr_PIR_s i0 &m x :\n  Pr[PIR.main(i0) @ &m : oflist PIR.s = x] = \n    if is_restr x N then 1%r/2%r^N else 0%r.\nproof.\n  byphoare=> // {i0};proc;inline *;wp.\n  case: (is_restr x N);first last.\n  + conseq (_ : _ ==> _ : = 0%r) => [ _ -> // | ].\n    hoare;conseq (_ : _ ==> is_restr (oflist PIR.s) N); 1:by smt().\n    while (0<= j <= N /\\ is_restr (oflist PIR.s) j).\n    + auto;smt (oflist_cons is_restrS is_restr_addS).\n    auto=> ?;rewrite -set0E;smt (is_restr_fset0 N_pos).\n  sp; conseq (_ : _ ==> _ : = (if (oflist PIR.s) = restr x j then 1%r/2%r^(N-j) else 0%r)).\n  + move=> {&m} &m />;rewrite -set0E. \n    have -> // : fset0 = restr x 0.\n    + by apply fsetP=> z;rewrite /restr !inE mem_oflist mem_iota /#.\n  conseq (_ : _ ==> oflist PIR.s = restr x j) (_: _ ==> j = N) => //;1:smt().\n  + while(0 <= j <= N);auto;smt (N_pos).\n  while (0 <= j <= N /\\ is_restr (oflist PIR.s) j) (N-j) N 1%r;2,3:smt(N_pos).\n  + by move=> &hr /> _;rewrite -set0E N_pos /=; apply is_restr_fset0.\n  + move=> H.\n    case (oflist PIR.s = restr x j);first last.\n    + seq 3 : true _ 0%r 0%r _ (0 <= j <= N /\\ is_restr (oflist PIR.s) j /\\ oflist PIR.s <> restr x j).\n      + auto => /> &hr 5? b _.\n        case: (j{hr}=i{hr}) => />; rewrite restrS //= oflist_cons;\n          smt (is_restr_addS is_restrS is_restr_Ueq  is_restr_diff fset0U is_restr_restr).\n        by conseq H => /#.\n      + by hoare;auto.\n      smt().      \n    conseq (_ : _ : = (1%r / 2%r ^ (N - j))) => [/#|].\n    exists * j, PIR.s;elim * => j0 s0.    \n    seq 3: (b = (j0 \\in x)) (1%r/2%r) (1%r / 2%r ^ (N - (j0+1))) _ 0%r \n        (1 <= j <= N /\\ j = j0 + 1 /\\ (PIR.s = if b then j0 :: s0 else s0) /\\ \n         is_restr (oflist s0) j0 /\\ oflist s0 = restr x j0).\n    + by auto => /> /#.\n    + by wp => /=;rnd (pred1 (j0 \\in x));skip => /> &hr;rewrite dbool1E.\n    + conseq H => />.\n      + case: (j0 \\in x) => Hjx ?? His Hof.\n        + by rewrite oflist_cons restrS 1:/# Hjx Hof.\n        by rewrite restrS 1:/# Hjx Hof /= fset0U.\n      smt (is_restrS is_restr_addS oflist_cons).\n    + conseq H => />.\n      + move=> &hr ?? His Hof Hb.\n        rewrite restrS 1:/# (negbRL _ _ Hb).    \n        case (j0 \\in x) => /= Hj0x.\n        + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n        by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n      smt (is_restrS is_restr_addS oflist_cons).\n    move=> &hr /> ?????; rewrite -exprS 1:/#; congr;congr;ring.\n  + wp;rnd predT;skip => /> &hr.\n    smt (dbool_ll oflist_cons is_restrS is_restr_addS).\n  move=> z;auto=> />;smt (dbool_ll).\nqed.\n\nlemma Pr_PIR_s' i0 &m x :\n  Pr[PIR.main(i0) @ &m : oflist PIR.s' = x] = \n    if is_restr x N then 1%r/2%r^N else 0%r.\nproof.\n  byphoare=> // {i0};proc;inline *;wp.\n  case: (is_restr x N);first last.\n  + conseq (_ : _ ==> _ : = 0%r) => [ _ -> // | ].\n    hoare;conseq (_ : _ ==> is_restr (oflist PIR.s') N); 1:by smt().\n    while (0<= j <= N /\\ is_restr (oflist PIR.s') j).\n    + auto;smt (oflist_cons is_restrS is_restr_addS).\n    auto=> ?;rewrite -set0E;smt (is_restr_fset0 N_pos).\n  sp; conseq (_ : _ ==> _ : = (if (oflist PIR.s') = restr x j then 1%r/2%r^(N-j) else 0%r)).\n  + move=> {&m} &m />;rewrite -set0E. \n    have -> // : fset0 = restr x 0.\n    + by apply fsetP=> z;rewrite /restr !inE mem_oflist mem_iota /#.\n  conseq (_ : _ ==> oflist PIR.s' = restr x j) (_: _ ==> j = N) => //;1:smt().\n  + while(0 <= j <= N);auto;smt (N_pos).\n  while (0 <= j <= N /\\ is_restr (oflist PIR.s') j) (N-j) N 1%r;2,3:smt(N_pos).\n  + by move=> &hr /> _;rewrite -set0E N_pos /=; apply is_restr_fset0.\n  + move=> H.\n    case (oflist PIR.s' = restr x j);first last.\n    + seq 3 : true _ 0%r 0%r _ (0 <= j <= N /\\ is_restr (oflist PIR.s') j /\\ oflist PIR.s' <> restr x j).\n      + auto => /> &hr 5? b _.\n       case: (j{hr}=i{hr}) => />; rewrite restrS //= oflist_cons;\n          smt (is_restr_addS is_restrS is_restr_Ueq  is_restr_diff fset0U is_restr_restr).\n        by conseq H => /#.\n      + by hoare;auto.\n      smt().      \n    conseq (_ : _ : = (1%r / 2%r ^ (N - j))) => [/#|].\n    exists * j, PIR.s';elim * => j0 s0.    \n    seq 3: (b = ((j0 = i) ^^ (j0 \\in x))) (1%r/2%r) (1%r / 2%r ^ (N - (j0+1))) _ 0%r \n        (1 <= j <= N /\\ j = j0 + 1 /\\ (PIR.s' = if (j0=i) then (if b then s0 else j0::s0) else if b then j0 :: s0 else s0) /\\ \n         is_restr (oflist s0) j0 /\\ oflist s0 = restr x j0).\n    + by auto => /#.\n    + by wp => /=;rnd (pred1 ((j0 = i) ^^ (j0 \\in x)));skip => /> &hr;rewrite dbool1E.\n    + conseq H => />.\n      + move=> &hr ?? His Hof;case: (j0 = i{hr}) => /=. \n        + rewrite xorC xor_true => <<-.\n          case: (j0 \\in x) => Hjx.\n          + by rewrite restrS 1:/# Hjx /= oflist_cons Hof.\n          by rewrite /= restrS 1:/# Hjx /= fset0U Hof.\n        rewrite xorC xor_false => ?.\n        case: (j0 \\in x) => Hjx.\n        + by rewrite oflist_cons restrS 1:/# Hjx Hof.\n        by rewrite restrS 1:/# Hjx Hof /= fset0U.\n      smt (is_restrS is_restr_addS oflist_cons).\n    + conseq H => />.\n      + move=> &hr ?? His Hof Hb.\n        rewrite restrS 1:/# (negbRL _ _ Hb);case: (j0 = i{hr}) => /= [<<- | ?].  \n        + rewrite xorC xor_true /=.\n          case (j0 \\in x) => /= Hj0x /=.\n          + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n          by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n        rewrite xorC xor_false.\n        case (j0 \\in x) => /= Hj0x /=.\n        + by rewrite (eq_sym (oflist s0)) (is_restr_diff j0 (restr x j0) _ His). \n        by rewrite fset0U oflist_cons -Hof (is_restr_diff j0 (oflist s0) _ His).\n      smt (is_restrS is_restr_addS oflist_cons).\n    by move=> &hr /> ?????;rewrite -exprS 1:/#;congr;congr;ring.\n  + wp;rnd predT;skip => &hr.\n    smt (dbool_ll oflist_cons is_restrS is_restr_addS).\n  move=> z;auto=> />;smt (dbool_ll).\nqed.\n\nlemma PIR_secuity_s_bypr i1 i2 &m1 &m2 x: \n   Pr[PIR.main(i1) @ &m1 : oflist PIR.s = x] = Pr[PIR.main(i2) @ &m2 : oflist PIR.s = x].\nproof. by rewrite (Pr_PIR_s i1 &m1 x) (Pr_PIR_s i2 &m2 x). qed.\n\nlemma PIR_secuity_s'_bypr i1 i2 &m1 &m2 x: \n   Pr[PIR.main(i1) @ &m1 : oflist PIR.s' = x] = Pr[PIR.main(i2) @ &m2 : oflist PIR.s' = x].\nproof. by rewrite (Pr_PIR_s' i1 &m1 x) (Pr_PIR_s' i2 &m2 x). qed.\n\n\n(* Other version without explicite computation of the probability,\n   we first show that the probability is uniform,\n   unfortunatly this does not allows to conclude in easycrypt.\n   We need to be able to do the projection of memories. \n   So we need functions on memory\n*)\n \nlemma PIR_s_uniform (x1 x2 : int fset):\n  0 <= N =>\n  is_restr x1 N => \n  is_restr x2 N =>\n  equiv [PIR.main ~ PIR.main : ={i} ==> (oflist PIR.s{1} = x1) = (oflist PIR.s{2} = x2)].\nproof.\n  move=> HN B1 B2;proc;inline *;wp.\n  while (={i,j} /\\ 0 <= j{1} <= N /\\ \n         is_restr (oflist PIR.s{1}) j{1} /\\ is_restr (oflist PIR.s{2}) j{1} /\\\n         ((oflist PIR.s{1} = restr x1 j{1}) = (oflist PIR.s{2} = restr x2 j{1}))).\n  + wp.\n    rnd (fun b => b ^^ (j{1} \\in x1) ^^ (j{1} \\in x2)). \n    skip => &m1 &m2 /> H0j HjN Hrs1 Hrs2 Hs Hj; split.\n    + by move=> b _;ring.\n    move=> _ b _;split;1: by ring.\n    move=> _; rewrite !oflist_cons !restrS //. \n    smt (is_restr_addS is_restrS is_restr_diff is_restr_Ueq is_restr_restr  fset0U).\n  auto; move => &m1 &m2 />.\n  rewrite !restr_0 -set0E /=;smt (is_restr_fset0).\nqed.\n\nlemma PIR_s'_uniform (x1 x2 : int fset):\n  0 <= N =>\n  is_restr x1 N => \n  is_restr x2 N =>\n  equiv [PIR.main ~ PIR.main : ={i} ==> (oflist PIR.s'{1} = x1) = (oflist PIR.s'{2} = x2)].\nproof.\n  move=> HN B1 B2;proc;inline *;wp.\n  while (={i,j} /\\ 0 <= j{1} <= N /\\ \n         is_restr (oflist PIR.s'{1}) j{1} /\\ is_restr (oflist PIR.s'{2}) j{1} /\\\n         ((oflist PIR.s'{1} = restr x1 j{1}) = (oflist PIR.s'{2} = restr x2 j{1}))).\n  + wp.\n    rnd (fun b => b ^^ (j{1} \\in x1) ^^ (j{1} \\in x2)). \n    skip => &m1 &m2 [#] 2!->> H0j HjN Hrs1 Hrs2 Hs Hj _; split.\n    + move=> b _;ring.\n    move=> _ b _; split;1: by ring.\n    move=> _; rewrite /= !oflist_cons !restrS //. \n    smt (is_restr_addS is_restrS is_restr_diff is_restr_Ueq is_restr_restr fset0U).\n  auto => &m1 &m2 />.\n  rewrite !restr_0 -set0E /=;smt (is_restr_fset0).\nqed.\n```"]], "EC-1/PKE_ROM.ec": [[false, "```ec\nrequire import AllCore List Distr DInterval MoreDistr.\nrequire (*--*) ROM.\n\npragma +implicits.\n\n(* Public Key Encryption *)\nabstract theory PKE.\n\n  type pkey.\n  type skey.\n  type plaintext.\n  type ciphertext.\n\n  module type Scheme = {\n    proc kg() : pkey * skey\n    proc enc(pk:pkey, m:plaintext)  : ciphertext\n    proc dec(sk:skey, c:ciphertext) : plaintext option\n  }.\n\n  module type Adversary = {\n    proc choose(pk:pkey)     : plaintext * plaintext\n    proc guess(c:ciphertext) : bool\n  }.\n\n  (* Chosen Plaintext Attack *)\n  module CPA (S:Scheme, A:Adversary) = {\n    module A = A\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b, b' : bool;\n\n      (pk, sk) <@ S.kg();\n      (m0, m1) <@ A.choose(pk);\n      b        <$ {0,1};\n      c        <@ S.enc(pk, b ? m1 : m0);\n      b'       <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  (* Left-Right CPA *)\n  module CPA_L (S:Scheme, A:Adversary) = {\n    module A = A\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b' : bool;\n\n      (pk, sk) <@ S.kg();\n      (m0, m1) <@ A.choose(pk);\n      c        <@ S.enc(pk, m0);\n      b'       <@ A.guess(c);\n      return b';\n    }\n  }.\n\n  (* Right CPA *)\n  module CPA_R (S:Scheme, A:Adversary) = {\n    module A = A\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b' : bool;\n\n      (pk, sk) <@ S.kg();\n      (m0, m1) <@ A.choose(pk);\n      c        <@ S.enc(pk, m1);\n      b'       <@ A.guess(c);\n      return b';\n    }\n  }.\n\n  section.\n\n    clone import LorR with\n      type input <- unit.\n\n    declare module S<:Scheme.\n    declare module A<:Adversary {-S}.\n\n    lemma pr_CPA_LR &m:\n      islossless S.kg => islossless S.enc =>\n      islossless A.choose => islossless A.guess =>\n      `| Pr[CPA_L(S,A).main () @ &m : res] - Pr[CPA_R(S,A).main () @ &m : res] | =\n       2%r * `| Pr[CPA(S,A).main() @ &m : res] - 1%r/2%r |.\n    proof.\n      move => kg_ll enc_ll choose_ll guess_ll.\n      have -> : Pr[CPA(S, A).main() @ &m : res] =\n                Pr[RandomLR(CPA_R(S,A), CPA_L(S,A)).main() @ &m : res].\n      + byequiv (_ : ={glob S, glob A} ==> ={res})=> //.\n        proc.\n        swap{1} 4-3; seq 1 1 : (={glob S, glob A, b}); first by rnd.\n        if{2}; inline *; wp.\n        + call (_: ={c, glob S, glob A} ==> ={res, glob S, glob A}); first by sim.\n          call (_: ={pk, glob S, glob A} ==> ={res, glob S, glob A}); first by sim.\n          call (_: true); first by auto => /> /#.\n        + call (_: ={c, glob S, glob A} ==> ={res, glob S, glob A}); first by sim.\n          call (_: ={pk, glob S, glob A} ==> ={res, glob S, glob A}); first by sim.\n          call (_: true); first by auto => /> /#.\n      rewrite -(pr_AdvLR_AdvRndLR (CPA_R(S,A)) (CPA_L(S,A)) &m) 2:/#.\n      byphoare => //; proc.\n      by call guess_ll; call enc_ll; call choose_ll; call kg_ll.\n    qed.\n\n  end section.\n\n  (* One-Wayness Chosen Plaintext Attack *)\n  module OW_CPA(S:Scheme, A:Adversary) = {\n    var m : plaintext\n    var m' : plaintext option\n\n    module A = A\n\n    proc main_perfect() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var c : ciphertext;\n\n      (pk, sk) <@ S.kg();\n      m        <$ dplaintext;\n      c        <@ S.enc(pk, m);\n      m'       <@ A.guess(c);\n      return (oget m' = m);\n    }\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var c : ciphertext;\n\n      (pk, sk) <@ S.kg();\n      m        <$ dplaintext;\n      c        <@ S.enc(pk, m);\n      m'       <@ A.guess(c);\n      return if m' = None then false else (oget m' = m);\n    }\n  }.\n\n  op [lossless] dplaintext : plaintext distr.\n\n  (* Correctness of the Scheme *)\n  module Correctness_Adv(S:Scheme, A:Adversary) = {\n    module A = A\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m  : plaintext;\n      var c  : ciphertext;\n      var m' : plaintext option;\n\n      (pk, sk) <@ S.kg();\n      m        <@ A.choose(pk);\n      c        <@ S.enc(pk, fst m);\n      m'       <@ S.dec(sk, c);\n      return (m' <> Some (fst m));\n    }\n  }.\n\n  section.\n\n    declare module S<:Scheme.\n    declare module A<:Adversary {-S}.\n\n    lemma ow_perfect S A &m (A_ll : islossless A.guess) :\n      islossless S.kg => islossless S.enc => islossless S.dec =>\n      Pr[OW_CPA(S,A).main() @ &m : res] <=\n      Pr[Correctness_Adv(S,A).main() @ &m : res] +\n      `|Pr[OW_CPA(S,A).main_perfect() @ &m : res] - 1%r/2%r|.\n    proof.\n      move => kg_ll enc_ll dec_ll.\n      rewrite -Pr[OW_CPA(S,A).main_perfect() @ &m : res] / 2%r.\n      by smt().\n    qed.\n\n  end section.\n\n  theory OWvsIND.\n\n    section.\n\n      clone import PKE as PKE'.\n\n      module BOWp(S:Scheme, A:Adversary) = {\n        module A = A\n\n        proc guess(c:ciphertext) : bool = {\n          var m' : plaintext option;\n\n          m'    <@ A.guess(c);\n          return if m' = None then false else (oget m' = m{1});\n        }\n      }.\n\n      lemma ow_ind_l S A &m (kg_ll : islossless S.kg)\n                          (enc_ll : islossless S.enc)\n                          (dec_ll : islossless S.dec)\n                          (A_ll : islossless A.choose)\n                          (guess_ll : islossless A.guess) :\n        Pr[OW_CPA(S,A).main() @ &m : res] =\n        Pr[Correctness_Adv(S,BOWp(S,A)).main() @ &m : res] +\n        (`|Pr[CPA(S,A).main() @ &m : res] - 1%r/2%r| +\n                   Pr[ Correctness_Adv(S,BOWp(S,A)).main() @ &m : res] ).\n      proof.\n        move => kg_ll enc_ll dec_ll A_ll.\n        have : Pr[ OW_CPA(S,A).main_perfect() @ &m : res ] <=\n              2%r * (eps_msg +\n                `| Pr[CPA(S,Bowl(BL(A))).main() @ &m : res] - 1%r/2%r |); last\n         by move : (ow_perfect  S A &m A_ll enc_ll dec_ll);smt().\n\n        rewrite RField.mulrDr.\n\n        have /= := ow_ind_l S (BL(A)) &m 1 _ kg_ll enc_ll dec_ll _ _ => //; 1: by islossless.\n        + by proc;wp;call(_:true);auto;smt().\n\n        have -> : Pr[OWL_CPA(S, BL(A)).main() @ &m : OWL_CPA.m \\in OWL_CPA.l] =\n                  Pr[OW_CPA(S, A).main_perfect() @ &m : res]; last by smt().\n\n        byequiv => //; proc;inline {1} 4; wp.\n        conseq (: _ ==> OWL_CPA.m{1} = OW_CPA.m{2} /\\ m'{1} = OW_CPA.m'{2}); 1: by auto => /> /#.\n        by sim.\n      qed.\n\n    end section.\n\n  end OWvsIND.\n\n\nend PKE.\n\nabstract theory PKE_ROM.\n\n  type plaintext.\n  type pkey.\n  type skey.\n  type ciphertext.\n\n  clone import FullRO as RO.\n\n  module type Oracle = {\n    include FRO [init, get]\n  }.\n\n  module type POracle = {\n    include FRO [get]\n  }.\n\n  module type Scheme(H : POracle) = {\n    proc kg() : pkey * skey\n    proc enc(pk:pkey, m:plaintext)  : ciphertext\n    proc dec(sk:skey, c:ciphertext) : plaintext option\n  }.\n\n  module type Adversary (H : POracle) = {\n    proc choose(pk:pkey)     : plaintext * plaintext\n    proc guess(c:ciphertext) : bool\n  }.\n\n  module CPA (H : Oracle, S:Scheme, A:Adversary) = {\n    module A = A(H)\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b, b' : bool;\n\n      H.init();\n      (pk, sk) <@ S(H).kg();\n      (m0, m1) <@ A.choose(pk);\n      b        <$ {0,1};\n      c        <@ S(H).enc(pk, b ? m1 : m0);\n      b'       <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  module CPA_L (H : Oracle, S:Scheme, A:Adversary) = {\n    module A = A(H)\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b' : bool;\n\n      H.init();\n      (pk, sk) <@ S(H).kg();\n      (m0, m1) <@ A.choose(pk);\n      c        <@ S(H).enc(pk, m0);\n      b'       <@ A.guess(c);\n      return b';\n    }\n  }.\n\n  module CPA_R (H : Oracle, S:Scheme, A:Adversary) = {\n    module A = A(H)\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b' : bool;\n\n      H.init();\n      (pk, sk) <@ S(H).kg();\n      (m0, m1) <@ A.choose(pk);\n      c        <@ S(H).enc(pk, m1);\n      b'       <@ A.guess(c);\n      return b';\n    }\n  }.\n\n  section.\n\n    clone import LorR with\n      type input <- unit.\n\n    declare module S<:Scheme.\n    declare module H<:Oracle {-S}.\n    declare module A<:Adversary {-S,-H}.\n\n    lemma pr_CPA_LR &m:\n      islossless S(H).kg => islossless S(H).enc =>\n      islossless A(H).choose => islossless A(H).guess => islossless H.init =>\n      `| Pr[CPA_L(H,S,A).main () @ &m : res] - Pr[CPA_R(H,S,A).main () @ &m : res] | =\n       2%r * `| Pr[CPA(H,S,A).main() @ &m : res] - 1%r/2%r |.\n    proof.\n      move => kg_ll enc_ll choose_ll guess_ll init_ll.\n      have -> : Pr[CPA(H,S, A).main() @ &m : res] =\n                Pr[RandomLR(CPA_R(H,S,A), CPA_L(H,S,A)).main() @ &m : res].\n      + byequiv (_ : ={glob S, glob H, glob A} ==> ={res})=> //.\n        proc.\n        swap{1} 4-3; seq 1 1 : (={glob S, glob H, glob A, b}); first by rnd.\n        if{2}; inline *; wp.\n        + call (_: ={c, glob H, glob S, glob A} ==> ={res, glob H, glob S, glob A}); first by sim.\n          call (_: ={glob H}); first by sim.\n          call (_: ={pk, glob H, glob S, glob A} ==> ={res, glob H, glob S, glob A}); first by sim.\n          call (_: ={glob H}); first by sim.\n          call (_: true); first by auto => /> /#.\n        + call (_: ={c, glob H, glob S, glob A} ==> ={res, glob H, glob S, glob A}); first by sim.\n          call (_: ={glob H}); first by sim.\n          call (_: ={pk, glob H, glob S, glob A} ==> ={res, glob H, glob S, glob A}); first by sim.\n          call (_: ={glob H}); first by sim.\n          call (_: true); first by auto => /> /#.\n      rewrite -(pr_AdvLR_AdvRndLR (CPA_R(H,S,A)) (CPA_L(H,S,A)) &m) 2:/#.\n      byphoare => //; proc.\n      by call guess_ll; call enc_ll; call choose_ll; call kg_ll; call init_ll.\n    qed.\n\n  end section.\n\n  module type CCA_ORC = {\n    proc dec(c:ciphertext) : plaintext option\n  }.\n\n  module type CCA_ADV (H : POracle, O:CCA_ORC) = {\n    proc choose(pk:pkey)     : plaintext * plaintext\n    proc guess(c:ciphertext) : bool {O.dec}\n  }.\n\n  module CCA (H : Oracle, S:Scheme, A:CCA_ADV) = {\n    var cstar : ciphertext option\n    var sk : skey\n\n    module O = {\n      proc dec(c:ciphertext) : plaintext option = {\n        var m : plaintext option;\n\n        m <- None;\n        if (Some c <> cstar) {\n          m   <@ S(H).dec(sk, c);\n        }\n        return m;\n      }\n    }\n\n    module A = A(H, O)\n\n    proc main() : bool = {\n      var pk : pkey;\n      var m0, m1 : plaintext;\n      var c : ciphertext;\n      var b, b' : bool;\n\n      H.init();\n      cstar    <- None;\n      (pk, sk) <@ S(H).kg();\n      (m0, m1) <@ A.choose(pk);\n      b        <$ {0,1};\n      c        <@ S(H).enc(pk, b ? m1 : m0);\n      cstar    <- Some c;\n      b'       <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  module type CORR_ADV (H : POracle) = {\n    proc find(pk : pkey, sk : skey) : plaintext\n  }.\n\n  module Correctness_Adv (H : Oracle, S:Scheme, A : CORR_ADV) = {\n    module A = A(H)\n\n    proc main() : bool = {\n      var pk : pkey;\n      var sk : skey;\n      var c  : ciphertext;\n      var m  : plaintext;\n      var m' : plaintext option;\n\n      H.init();\n      (pk, sk) <@ S(H).kg();\n      m        <@ A.find(pk,sk);\n      c        <@ S(H).enc(pk, m);\n      m'       <@ S(H).dec(sk, c);\n      return (m' <> Some m); (* There's a typo in HKK *)\n    }\n  }.\n\n  (* We need OW with validity oracle *)\n\n  module type VA_ORC = {\n    proc cvo(c:ciphertext) : bool\n    proc pco(m : plaintext, c:ciphertext) : bool\n  }.\n\n  module type PCVA_ADV (H : POracle, O: VA_ORC) = {\n    proc find(pk : pkey, c:ciphertext) : plaintext option\n  }.\n\n  op [lossless] dplaintext : plaintext distr.\n\n  module OW_PCVA (H : Oracle, S:Scheme, A: PCVA_ADV) = {\n    var sk : skey\n    var cc : ciphertext\n\n    module O = {\n      proc cvo(c:ciphertext) : bool = {\n        var m : plaintext option;\n\n        m <- None;\n        if (c <> cc) { m   <@ S(H).dec(sk, c); }\n        return (m <> None);"]], "EC-1/PrArg.ec": [[false, "```houzhui\npragma Goals:printall.\nrequire import AllCore DBool Bool List Distr Int IntDiv AuxResults FSet DJoin.\nrequire import StdRing StdOrder StdBigop.\n(*---*) import RField RealOrder Bigreal BRA.\nimport BRM.\n\n\nprover [\"Alt-Ergo\" \"Z3\" \"CVC4\"].\n\n(*\n\nThe section below contains the derivation of the zero-knowledge upper-bound for a Blum-protocol\n\n1. x = x/(1 + z) + xz/(z+1)\n2. x/(1 + z) = x - xz/(z+1)\n3. xz/(z+1) <= z\n   |x / (1/2 + eps) - 2*b| \n=  2 * (|x / (1/2 + eps)/2 - 2*b/2|)\n=  2 * (|x / (1 + 2*eps) - b|)\n=  2 * (|x - x*2*eps/(1 + 2*eps) - b|)\n<= 2 * (|x - b|) + 2*x*2*eps/(1 + 2*eps)\n<= 2 * (|x - b|) + 2*eps\n<= 2 * eps + 2 * eps\n<= 4*eps\n*)\n\nsection. \n\nlemma pr2 (x e : real) :\n    0%r <= x <= 1%r\n => 0%r <= e <= 1%r\n => x = x/(1%r + e) + x * e/(e + 1%r).\nsmt().\nqed.\n\n\nlocal lemma pr3 (x e : real) :\n    0%r <= x <= 1%r\n => 0%r <= e <= 1%r\n => x/(1%r + e) = x - x * e/(e + 1%r).\nsmt (pr2).\nqed.\n\nlemma pr_e1 (a e : real) : \n  0%r <= a <= 1%r =>\n  `| a - 1%r/2%r | <= e =>\n  a <= 1%r/2%r + e.\nsmt().\nqed.\n\n\nlemma pr_e2 (a e : real) : \n  0%r <= a <= 1%r =>\n  `| a - 1%r/2%r | <= e =>\n  a >= 1%r/2%r - e.\nsmt().\nqed.\n\n\nlocal lemma pr12 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e <= 1%r =>\n  x <= p =>\n  p <= (1%r/2%r + e)  =>\n  (1%r/2%r - e)  <= p =>\n  (x / p - x / (1%r/2%r + e)) =  x * ((1%r/2%r + e) - p) / (p * (1%r/2%r + e))   .\nsmt(@Real).\nqed.\n\n\nlocal lemma kk (a b c : real) : \n  a <= b =>\n  0%r <= c <= 1%r =>\n  a / c <= b / c.\nsmt(@Real).\nqed.\n\nlocal lemma pr13 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e <= 1%r/2%r =>\n  x <= p =>\n  p <= (1%r/2%r + e)  =>\n  (1%r/2%r - e)  <= p =>\n  x * ((1%r/2%r + e) - p) / (p * (1%r/2%r + e)) \n    <=   x * (2%r * e) / (p * (1%r/2%r + e)) .\nprogress.\napply kk. smt(). progress;smt().\nqed.\n\nlocal lemma pr14 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/2%r =>\n  x <= p =>\n  p <= (1%r/2%r + e)  =>\n  (1%r/2%r - e)  <= p =>\n     x * (2%r * e) / (p * (1%r/2%r + e)) \n     <=  x * (2%r * e) / ((1%r/2%r - e) * (1%r/2%r + e)).\nsmt().\nqed.\n\n\nlocal lemma pr15 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/2%r =>\n  x <= p =>\n  p <= (1%r/2%r + e)  =>\n  (1%r/2%r - e)  <= p =>\n     x * (2%r * e) / ((1%r/2%r - e) * (1%r/2%r + e))\n     =  x * (2%r * e) / ((1%r/4%r - e*e)).\nsmt().\nqed.\n\nlocal lemma pr17 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/4%r =>\n  x <= p =>\n  p <= (1%r/2%r + e)  =>\n  (1%r/2%r - e)  <= p =>\n       (x / p - x / (1%r/2%r + e))\n     <=   16%r * e .\nprogress.\nrewrite (pr12 x p b e);auto. smt().\napply (ler_trans (x * (2%r * e) / (p * (1%r/2%r + e)))).\napply (pr13 x p b e);auto. smt().\napply (ler_trans (x * (2%r * e) / ((1%r / 2%r - e) * (1%r / 2%r + e)))). \napply (pr14 x p b e);auto. smt().\nrewrite  (pr15 x p b e);auto. smt(). smt().\nqed.\n\n\n\nlocal lemma step1 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/4%r =>\n  x <= p =>\n  p <= (1%r/2%r + e) =>\n  (1%r/2%r - e) <= p =>\n  `| x / p - 2%r * b| <=\n  `| x / (1%r/2%r + e) - 2%r * b| + 16%r * e.\nprogress.\napply (ler_trans (`| x / (1%r/2%r + e) - 2%r * b| + (x / p - x / (1%r/2%r + e)))). smt(). \nhave fff : (x / p - x / (1%r / 2%r + e)) <= 16%r * e.\napply (pr17 x p b e);auto.\nsmt().\nqed.\n\nlocal lemma rp1 x e b  : \n  0%r <= x <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/4%r =>\n  `| x / (1%r/2%r + e) - 2%r * b|\n  = 2%r * (`|x - x*2%r*e / (1%r + 2%r*e) - b|).\nsmt (pr3).\nqed.\n\nlocal lemma step2 (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/4%r =>\n  x <= p =>\n  p <= (1%r/2%r + e) =>\n  (1%r/2%r - e) <= p =>\n   `| x / (1%r/2%r + e) - 2%r * b| + 16%r * e <=\n    2%r * (`|x - b|) + 20%r * e.\nprogress.\nrewrite rp1;auto. smt(@Real).\nsmt().\nqed.\n\nlemma main_fin (x p b e : real) : \n  0%r <= x <= 1%r =>\n  0%r <= p <= 1%r =>\n  0%r <= b <= 1%r =>\n  0%r <= e < 1%r/4%r =>\n  x <= p =>\n  p <= (1%r/2%r + e) =>\n  (1%r/2%r - e) <= p =>\n  `| x / p - 2%r * b|  <= 2%r * `|x - b| + 20%r * e.\nprogress. apply (ler_trans (`| x / (1%r/2%r + e) - 2%r * b| + 16%r*e)). \nsmt(step1).\napply (step2 x p b e);auto.\nsmt().\nqed.\n\nend section.\n```"]], "EC-1/qselect.ec": [[true, "lo <= j <= hi < size t /\\ eq_except t_ t lo hi /\\ \n         perm_eq_on t_ t lo hi /\\ t.[hi] = pv /\\\n         c = c_ + (j - lo) * clt).\n  + wp; if; last by skip => />; smt(clt_ge0 lt_nle).\n    ecall (h_swap t i j c); wp; skip => |>.\n    move=> &hr ? hpe *; split; 1: smt().\n    move=> ? t' *; rewrite !andbA; split; 1: smt().\n    split; 2: smt().\n    apply: (perm_eq_on_trans _ _ _ _ _ hpe).\n    by apply (swapP_perm_eq_on t{hr} t' lo{hr} hi{hr} (i{hr} + 1) j{hr}) => /#.\n  wp; skip => |> &hr *; split; 1: smt(perm_eq_refl).\n  move=> c0 i0 j0 t0 ? hpe *; split; 1: smt().\n  move=> ? t' hp; split; 2: smt().\n  apply: (perm_eq_on_trans _ _ _ _ _ hpe).\n  by apply: swapP_perm_eq_on hp => /#.\nqed.\n\nphoare h_partition_ll t_ c_ lo_ hi_: [ QS.partition :\n    c = c_ /\\ t = t_ /\\ lo = lo_ /\\ hi = hi_ /\\ uniq_on t lo hi /\\ 0 <= lo <= hi < size t\n    ==>\n    let (t,p) = (res.`1, res.`2) in \n    perm_eq_on t_ t lo_ hi_ /\\ partition_on t lo_ p hi_ /\\ t.[p] = t_.[hi_] /\\ lo_ <= p <= hi_ /\\\n    eq_except t_ t lo_ hi_ /\\\n    c = c_ + (hi_ - lo_) * clt ] = 1%r.\nproof.\n  conseq (_: true ==> true) (h_partition t_ c_ lo_ hi_) => //.\n  proc; inline QS.swap_; wp.\n  by while true (hi - j); auto => /#.\nqed.\n\nequiv p_partitionE t_ lo_ hi_ : QS.p_partition ~ QS.p_partition_abs : \n  ={lo,hi,c} /\\ lo{1} = lo_ /\\ hi{1} = hi_ /\\ t{1} = t_ /\\ 0 <= lo_ <= hi_ < size t{1} /\\ (uniq_on t lo hi){1} \n  ==> \n  ={c} /\\ uniq_on res.`1{1} lo_ hi_ /\\ res.`2{1} = res{2} /\\ lo_ <= res.`2{1} <= hi_ /\\ size res.`1{1} = size t_.\nproof.\n  proc.\n  seq 1 1 : (#pre /\\ p{2} = sindex Partition0.(<=) t{1} lo{1} hi{1} p{1} /\\ (lo <= p <= hi){1} ).\n  + rnd (sindex Partition0.(<=) t{1} lo{1} hi{1}) (sindex_inv Partition0.(<=) t{1} lo{1} hi{1}); skip => />.\n    move=> hlo hlohi hhi hu; split.\n    + by move=> p /supp_dinter hp; rewrite sindex_sindex_inv.\n    move=> _; split.\n    + move=> p /supp_dinter hp.\n      by rewrite !dinter1E hp /=; smt(sindex_inv_in).\n    move=> _ p /supp_dinter hp; split. \n    + by apply/supp_dinter; smt(sindex_in).\n    by move=> _; rewrite sindex_inv_sindex //; smt(sindex_in).\n  wp.\n  ecall{1} (h_partition_ll t{1} c{1} lo{1} hi{1}).\n  ecall{1} (h_swap_ll t{1} p{1} hi{1} c{1}); skip => |>.\n  move=> &1 &2 hu *.\n  split; 1: smt().\n  move=> ? t' hsw.\n  have hp := swapP_perm_eq_on _ _ lo_ hi_ _ _ _ _ hsw => //.\n  rewrite -(perm_uniq_on _ _ _ _ hp); split; 1: smt().\n  move=> ?? [t'' p''] /= hp' hpart *.\n  have hp2 := perm_eq_on_trans _ _ _ _ _ hp hp'.\n  split; 1: by have /perm_uniq_on <- := hp2.\n  have -> := perm_sindex t_ t'' lo_ hi_ p{1} p'' _ _ _ hp2 => //; 1:smt().\n  rewrite sindex_countP //;  1: by rewrite -(perm_uniq_on _ _ _ _ hp2).\n  rewrite (partition_on_sindex _ _ _ _ _ hpart) // /#. \nqed.\n\nehoare eh_p_partition f t_ lo_ hi_: QS.p_partition :\n  (lo = lo_ /\\ hi = hi_ /\\ t = t_ /\\ uniq_on t lo hi /\\  0 <= lo_ <= hi_ < size t) `|` \nEp [lo .. hi] (fun p => f p (c + (hi - lo)*clt)) ==> \n   (lo_ <= res.`2 <= hi_ /\\ uniq_on res.`1 lo_ hi_ /\\ size res.`1 = size t_) `|` f res.`2 c.\nproof.\n  conseq (p_partitionE t_ lo_ hi_) \n    (_:  Ep [lo .. hi] (fun p => f p (c + (hi - lo)*clt)) ==> \n         f res c) => />.\n  + by move=> &1; exists c{1} (lo, hi){1}; apply trans_help => />.\n  proc; auto.\nqed.\n\nehoare eh_qselect : QS.qselect : (0 <= pos < size t /\\ uniq_on t 0 (size t - 1)) `|` (4 * (size t - 1))%xr ==> c%xr.\nproof.\n  proc.\n  while ((0 <= lo <= pos <= hi < size t /\\ lo <= pos <= hi /\\ uniq_on t lo hi /\\ 0 <= c) `|` \n          c%xr + (4 * (hi - lo))%xr).\n  + by move=> &hr /=; apply xle_cxr_r => /> * /#.\n  + wp; exlim t, lo, hi, pos => t_ lo_ hi_ pos_.\n    call /(fun x => (lo = lo_ /\\ hi = hi_ /\\ pos = pos_ /\\ 0 <= lo <= pos <= hi < size t_ ) `|` x) \n      (eh_p_partition (fun p c => (0 <= c) `|`\n        if p = pos_ then c%xr\n        else if p < pos_ then c%xr + (4 * (hi_ - (p+1)))%xr\n        else  c%xr + (4 * ((p-1) - lo_))%xr)\n       t_ lo_ hi_).\n    + by move=> &hr /=; apply xle_cxr_r => /> *; smt(uniq_on_sub).\n    skip => &hr /=; apply xle_cxr => />.\n    move: (pos{hr}) (lo{hr}) (hi{hr}) (t{hr}) (c{hr}) => {&hr lo_ hi_ pos_} pos lo hi t c *.\n    split; 1: smt().\n    rewrite Ep_cxr; apply xle_cxr_l; 1: by move=> x /supp_dinter /= /#.\n    rewrite -(eq_Ep _ (\n         (fun (p0 : int) =>\n            if p0 = pos then ____()___\n            else if p0 < pos then (4 * (hi - (p0 + 1)))%xr\n                 else (4 * (p0 - 1 - lo))%xr)\n          + (fun (_:int) => (c + (hi - lo))%xr))).\n    + by move=> p /supp_dinter hp /=; case: (p = pos) => //#; smt().\n    rewrite EpD EpC dinter_ll 1:/# /=.\n    have -> : (c%rp + (4 * (hi - lo))%rp)%xr = (3 * (hi - lo))%xr + (c + (hi - lo))%xr.\n    + by rewrite /= -!of_realD /#.\n    apply xler_addr.\n    rewrite Ep_dinterval (: lo <= hi) 1:/# /=.\n    rewrite (BXA.big_cat_int pos) 1:// 1:/#.\n    rewrite (BXA.eq_big_int lo pos _ (fun p => (4 * ((hi - 1) - p))%xr)) 1:/#.\n    rewrite bigiXI 1:/# BXA.big_ltn 1:/#.\n    rewrite (BXA.eq_big_int (pos + 1) (hi + 1) _ (fun p => (4 * (p - (1 + lo)))%xr)) 1:/#.\n    rewrite bigiXI 1:/# /=.\n    rewrite -!BIA.mulr_sumr BIA.big_split bigi_constz 1://.\n    rewrite BIA.big_split bigi_constz 1:/#.\n    have /= <- := BIA.sumrN<:int> predT (fun x => x).\n    rewrite Num.Domain.mulrDr mulrN. \n    have -> : 4 * sumid lo pos = 2 * (2 * sumid lo pos) by ring.\n    rewrite sumidE_rm 1://.\n    have -> : 4 * ((hi - 1) * (pos - lo)) - 2 * ((pos - lo) * (pos + lo - 1)) = \n             (pos - lo) * (4 * (hi - 1) - 2 * (pos + lo - 1)) by ring.\n    rewrite (Num.Domain.mulrDr 4 (sumid _ _)).\n    have -> : 4 * sumid (pos + 1)(hi + 1) = 2 * (2 * sumid (pos + 1)(hi + 1)) by ring.\n    rewrite sumidE_rm 1:/#.\n    apply RealOrder.ler_pdivr_mulr; 1: smt().\n    rewrite !to_pos_pos 1,3,4:/#.\n    + rewrite le_fromint.\n      pose h1 := hi + 1; pose p1 := pos + 1. pose lo1 := 1+ lo.\n      have -> : 2 * ((h1 - p1) * (h1 + p1 - 1)) + 4 * ((- lo1) * (h1 - p1)) = \n                (h1 - p1) * (2 * (h1 + p1 - 1) - 4 * lo1) by ring. \n      by apply IntOrder.mulr_ge0 => /#.\n    rewrite -!fromintD -!fromintM le_fromint -subz_ge0 /=.\n    pose i := pos - lo; pose j := hi - pos; pose k := (_ - _)%Int.\n    have -> : k = (i - j) ^ 2 + 5 * i + 5 * j by rewrite /k /i /j; ring.\n    by have /# := IntOrder.ge0_sqr (i - j).\n  by wp; skip => &hr /=; apply xle_cxr => /#. \nqed.", "```ec\nlo <= j <= hi < size t /\\ eq_except t_ t lo hi /\\ \n         perm_eq_on t_ t lo hi /\\ t.[hi] = pv /\\\n         c = c_ + (j - lo) * clt).\n  + wp; if; last by skip => />; smt(clt_ge0 lt_nle).\n    ecall (h_swap t i j c); wp; skip => |>.\n    move=> &hr ? hpe *; split; 1: smt().\n    move=> ? t' *; rewrite !andbA; split; 1: smt().\n    split; 2: smt().\n    apply: (perm_eq_on_trans _ _ _ _ _ hpe).\n    by apply (swapP_perm_eq_on t{hr} t' lo{hr} hi{hr} (i{hr} + 1) j{hr}) => /#.\n  wp; skip => |> &hr *; split; 1: smt(perm_eq_refl).\n  move=> c0 i0 j0 t0 ? hpe *; split; 1: smt().\n  move=> ? t' hp; split; 2: smt().\n  apply: (perm_eq_on_trans _ _ _ _ _ hpe).\n  by apply: swapP_perm_eq_on hp => /#.\nqed.\n\nphoare h_partition_ll t_ c_ lo_ hi_: [ QS.partition :\n    c = c_ /\\ t = t_ /\\ lo = lo_ /\\ hi = hi_ /\\ uniq_on t lo hi /\\ 0 <= lo <= hi < size t\n    ==>\n    let (t,p) = (res.`1, res.`2) in \n    perm_eq_on t_ t lo_ hi_ /\\ partition_on t lo_ p hi_ /\\ t.[p] = t_.[hi_] /\\ lo_ <= p <= hi_ /\\\n    eq_except t_ t lo_ hi_ /\\\n    c = c_ + (hi_ - lo_) * clt ] = 1%r.\nproof.\n  conseq (_: true ==> true) (h_partition t_ c_ lo_ hi_) => //.\n  proc; inline QS.swap_; wp.\n  by while true (hi - j); auto => /#.\nqed.\n\nequiv p_partitionE t_ lo_ hi_ : QS.p_partition ~ QS.p_partition_abs : \n  ={lo,hi,c} /\\ lo{1} = lo_ /\\ hi{1} = hi_ /\\ t{1} = t_ /\\ 0 <= lo_ <= hi_ < size t{1} /\\ (uniq_on t lo hi){1} \n  ==> \n  ={c} /\\ uniq_on res.`1{1} lo_ hi_ /\\ res.`2{1} = res{2} /\\ lo_ <= res.`2{1} <= hi_ /\\ size res.`1{1} = size t_.\nproof.\n  proc.\n  seq 1 1 : (#pre /\\ p{2} = sindex Partition0.(<=) t{1} lo{1} hi{1} p{1} /\\ (lo <= p <= hi){1} ).\n  + rnd (sindex Partition0.(<=) t{1} lo{1} hi{1}) (sindex_inv Partition0.(<=) t{1} lo{1} hi{1}); skip => />.\n    move=> hlo hlohi hhi hu; split.\n    + by move=> p /supp_dinter hp; rewrite sindex_sindex_inv.\n    move=> _; split.\n    + move=> p /supp_dinter hp.\n      by rewrite !dinter1E hp /=; smt(sindex_inv_in).\n    move=> _ p /supp_dinter hp; split. \n    + by apply/supp_dinter; smt(sindex_in).\n    by move=> _; rewrite sindex_inv_sindex //; smt(sindex_in).\n  wp.\n  ecall{1} (h_partition_ll t{1} c{1} lo{1} hi{1}).\n  ecall{1} (h_swap_ll t{1} p{1} hi{1} c{1}); skip => |>.\n  move=> &1 &2 hu *.\n  split; 1: smt().\n  move=> ? t' hsw.\n  have hp := swapP_perm_eq_on _ _ lo_ hi_ _ _ _ _ hsw => //.\n  rewrite -(perm_uniq_on _ _ _ _ hp); split; 1: smt().\n  move=> ?? [t'' p''] /= hp' hpart *.\n  have hp2 := perm_eq_on_trans _ _ _ _ _ hp hp'.\n  split; 1: by have /perm_uniq_on <- := hp2.\n  have -> := perm_sindex t_ t'' lo_ hi_ p{1} p'' _ _ _ hp2 => //; 1:smt().\n  rewrite sindex_countP //;  1: by rewrite -(perm_uniq_on _ _ _ _ hp2).\n  rewrite (partition_on_sindex _ _ _ _ _ hpart) // /#. \nqed.\n\nehoare eh_p_partition f t_ lo_ hi_: QS.p_partition :\n  (lo = lo_ /\\ hi = hi_ /\\ t = t_ /\\ uniq_on t lo hi /\\  0 <= lo_ <= hi_ < size t) `|` \nEp [lo .. hi] (fun p => f p (c + (hi - lo)*clt)) ==> \n   (lo_ <= res.`2 <= hi_ /\\ uniq_on res.`1 lo_ hi_ /\\ size res.`1 = size t_) `|` f res.`2 c.\nproof.\n  conseq (p_partitionE t_ lo_ hi_) \n    (_:  Ep [lo .. hi] (fun p => f p (c + (hi - lo)*clt)) ==> \n         f res c) => />.\n  + by move=> &1; exists c{1} (lo, hi){1}; apply trans_help => />.\n  proc; auto.\nqed.\n\nehoare eh_qselect : QS.qselect : (0 <= pos < size t /\\ uniq_on t 0 (size t - 1)) `|` (4 * (size t - 1))%xr ==> c%xr.\nproof.\n  proc.\n  while ((0 <= lo <= pos <= hi < size t /\\ lo <= pos <= hi /\\ uniq_on t lo hi /\\ 0 <= c) `|` \n          c%xr + (4 * (hi - lo))%xr).\n  + by move=> &hr /=; apply xle_cxr_r => /> * /#.\n  + wp; exlim t, lo, hi, pos => t_ lo_ hi_ pos_.\n    call /(fun x => (lo = lo_ /\\ hi = hi_ /\\ pos = pos_ /\\ 0 <= lo <= pos <= hi < size t_ ) `|` x) \n      (eh_p_partition (fun p c => (0 <= c) `|`\n        if p = pos_ then c%xr\n        else if p < pos_ then c%xr + (4 * (hi_ - (p+1)))%xr\n        else  c%xr + (4 * ((p-1) - lo_))%xr)\n       t_ lo_ hi_).\n    + by move=> &hr /=; apply xle_cxr_r => /> *; smt(uniq_on_sub).\n    skip => &hr /=; apply xle_cxr => />.\n    move: (pos{hr}) (lo{hr}) (hi{hr}) (t{hr}) (c{hr}) => {&hr lo_ hi_ pos_} pos lo hi t c *.\n    split; 1: smt().\n    rewrite Ep_cxr; apply xle_cxr_l; 1: by move=> x /supp_dinter /= /#.\n    rewrite -(eq_Ep _ (\n         (fun (p0 : int) =>\n            if p0 = pos then ____()___\n            else if p0 < pos then (4 * (hi - (p0 + 1)))%xr\n                 else (4 * (p0 - 1 - lo))%xr)\n          + (fun (_:int) => (c + (hi - lo))%xr))).\n    + by move=> p /supp_dinter hp /=; case: (p = pos) => //#; smt().\n    rewrite EpD EpC dinter_ll 1:/# /=.\n    have -> : (c%rp + (4 * (hi - lo))%rp)%xr = (3 * (hi - lo))%xr + (c + (hi - lo))%xr.\n    + by rewrite /= -!of_realD /#.\n    apply xler_addr.\n    rewrite Ep_dinterval (: lo <= hi) 1:/# /=.\n    rewrite (BXA.big_cat_int pos) 1:// 1:/#.\n    rewrite (BXA.eq_big_int lo pos _ (fun p => (4 * ((hi - 1) - p))%xr)) 1:/#.\n    rewrite bigiXI 1:/# BXA.big_ltn 1:/#.\n    rewrite (BXA.eq_big_int (pos + 1) (hi + 1) _ (fun p => (4 * (p - (1 + lo)))%xr)) 1:/#.\n    rewrite bigiXI 1:/# /=.\n    rewrite -!BIA.mulr_sumr BIA.big_split bigi_constz 1://.\n    rewrite BIA.big_split bigi_constz 1:/#.\n    have /= <- := BIA.sumrN<:int> predT (fun x => x).\n    rewrite Num.Domain.mulrDr mulrN. \n    have -> : 4 * sumid lo pos = 2 * (2 * sumid lo pos) by ring.\n    rewrite sumidE_rm 1://.\n    have -> : 4 * ((hi - 1) * (pos - lo)) - 2 * ((pos - lo) * (pos + lo - 1)) = \n             (pos - lo) * (4 * (hi - 1) - 2 * (pos + lo - 1)) by ring.\n    rewrite (Num.Domain.mulrDr 4 (sumid _ _)).\n    have -> : 4 * sumid (pos + 1)(hi + 1) = 2 * (2 * sumid (pos + 1)(hi + 1)) by ring.\n    rewrite sumidE_rm 1:/#.\n    apply RealOrder.ler_pdivr_mulr; 1: smt().\n    rewrite !to_pos_pos 1,3,4:/#.\n    + rewrite le_fromint.\n      pose h1 := hi + 1; pose p1 := pos + 1. pose lo1 := 1+ lo.\n      have -> : 2 * ((h1 - p1) * (h1 + p1 - 1)) + 4 * ((- lo1) * (h1 - p1)) = \n                (h1 - p1) * (2 * (h1 + p1 - 1) - 4 * lo1) by ring. \n      by apply IntOrder.mulr_ge0 => /#.\n    rewrite -!fromintD -!fromintM le_fromint -subz_ge0 /=.\n    pose i := pos - lo; pose j := hi - pos; pose k := (_ - _)%Int.\n    have -> : k = (i - j) ^ 2 + 5 * i + 5 * j by rewrite /k /i /j; ring.\n    by have /# := IntOrder.ge0_sqr (i - j).\n  by wp; skip => &hr /=; apply xle_cxr => /#. \nqed.\n```"]], "EC-1/RandomFacts.ec": [[false, "```ec\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\nrequire import Logic.\n\n\n\n(* \"sum\" interpretation of dlet *)\nlemma dlet_mu_main"]], "EC-1/Random_bit_proof.ec": [[true, "require import AllCore IntDiv CoreMap List Distr DList.\nrequire import JModel.\n\nrequire import Array32.\nrequire BinUniSample_spec.\nrequire import Array1 WArray1.\nrequire import Finite ArrayFiniteness.\n\nrequire import BigNum_proofs.\nrequire import W64_SchnorrExtract.\n\nrequire import BinUniSample_spec.\n\n\nclone import RandomChoice as W8RandomChocie with type t <- W8.t \nproof*.\n\nsection.\n\nlocal op h = (fun (a : WArray1.t) => Array1.init (fun i => WArray1.get8 a i)).\n\nlocal lemma init_ext:\n  forall (f1 f2 : int -> W8.t),\n       (Array1.init f1) = (Array1.init f2) =>\n    (forall (x : int), 0 <= x && x < 1 => f1 x = f2 x).\nsmt(@Array1).\nqed.\n\n\nlocal lemma h_inj : injective h.\nrewrite /injective.\nrewrite /h. \nmove => x y  q.\nhave :  get8 x 0 =  get8 y 0.\napply  (init_ext _ _ q 0 _). smt().\nrewrite /get8. smt(@WArray1).\nqed.\n\n\nlocal lemma h_surj : surjective h.    \nrewrite /surjective.\nprogress. \nexists (WArray1.init (fun i => x.[i])).\nrewrite /h.\napply Array1.ext_eq.\nprogress. have ->: x0 = 0. smt().\nsmt(@Array1 @WArray1).\nqed.\n\n\n\nlocal lemma darray_ll:\n is_lossless ____()___.\nproof. rewrite /darray. apply dmap_ll; apply dlist_ll. smt(@W8). qed.\n\n\nlocal lemma supp_darray a:\n a \\in darray <=> all (support W8.dword) (WArray1.to_list a).\nproof.\nrewrite /darray supp_dmap; split.\n move=> [x]; rewrite supp_dlist // => /> *.\n by rewrite WArray1.of_listK // /#.\nmove=> H; exists (to_list a); rewrite supp_dlist // H Array1.size_to_list /=.\nqed.\n\n\nlocal lemma darray_uni:\n   is_uniform (darray).\nproof.\nrewrite /darray=> ?; apply dmap_uni_in_inj.\n move=> x y; rewrite !supp_dlist //; move => [? _] [? _] H.\n  smt(@WArray1).\n apply dlist_uni. smt(@W8).\nqed.\n\n\nlocal lemma darray_fu:\n   is_full darray.\nproof.\nrewrite /darray => H; apply dmap_fu_in.\nmove=> x; exists (to_list x); rewrite to_listK supp_dlist //=.\nrewrite allP.\nprogress. smt(@W8).\nqed.\n\nlocal op byte_distr = dmap WArray1.darray h.\n\nlocal lemma byte_distr_uni : is_uniform byte_distr .\nrewrite /byte_distr.\napply dmap_uni_in_inj.\nprogress. smt (h_inj).\napply darray_uni.\nqed.\n\n\nlocal lemma byte_distr_ll: is_lossless byte_distr.\nrewrite /byte_distr.\napply dmap_ll.\napply darray_ll.\nqed.\n\nlocal lemma byte_distr_fu : is_full byte_distr .\nrewrite /byte_distr.\napply dmap_fu_in.\nprogress. smt(h_surj).\napply darray_fu.\nqed.\n\n\n\n\nlocal module SampleModule = {\n  proc byte_distr() = {\n    var r;\n    r <$ byte_distr;\n    return r;\n  }\n\n  proc bit_distr() = {\n    var b;\n    b <@ byte_distr();\n    b.[0] <- (b.[0] `&` (W8.of_int 1));\n    return b.[0];\n  }\n\n}.\n\n\n\nlocal lemma zzz : size (to_seq (support byte_distr)) =  256.\nhave : size all_256words1 = size (to_seq (support byte_distr)).\napply uniq_size_uniq.\napply uniq_to_seq.\nsmt(@Distr byte_distr_uni).\nprogress. apply all_256words1_full.\nhave : x \\in byte_distr.\napply byte_distr_fu.\nprogress. apply mem_to_seq.  smt(@Distr byte_distr_uni). auto.\napply all_256words1_uniq.\nprogress. rewrite - H.\nrewrite all_256words1_size. smt().\nqed.\n\nlocal op toi (x : W8.t Array1.t) : int = W8.to_uint x.[0].\nlocal op fri (x : int) : W8.t Array1.t   = (Array1.init (fun i => (W8.of_int x))).\nlocal lemma lemma2 : \n  equiv [SampleModule.byte_distr ~ SampleByte.sampleInt : true ==> (toi res{1} = res{2})  ].\nproc.\nrnd  toi fri.\nskip. progress.\nrewrite /toi /fri. \nrewrite initE. simplify. \n  have : 0 <= xR <= 255. smt(@Distr @List).\n  smt(@IntDiv).\nrewrite duniform1E_uniq. smt(@List).\nhave ->: xR \\in range 0 (255 + 1). smt(@List @Distr).\nsimplify. \nhave ->: size (range 0 256) = 256. smt(@List).\nrewrite mu1_uni. apply byte_distr_uni.\nrewrite byte_distr_fu. simplify.\nrewrite byte_distr_ll. \nrewrite zzz. auto.\nhave : 0 <= toi rL < 256. rewrite /toi. \nhave ->: 256 = W8.modulus. ring.\napply W8.to_uint_cmp.\nmove => qq.\n have : toi rL \\in range 0 256.\n  smt(@List).\n  smt(@Distr).\nrewrite /fri /toi.\napply Array1.ext_eq.\nprogress.\nhave ->: x = 0. smt().\nsimplify. auto.\nqed.\n\nlocal lemma lemma3 : \n  equiv [SampleModule.bit_distr ~ SampleByte.run : true ==> (W8.to_uint res{1} = res{2}) /\\ (res{1} = W8.zero \\/ res{1} = W8.one) ].\nproc.\nwp. call lemma2. skip. progress.\nrewrite /toi. \nhave ->: W8.one = (W8.of_int (2 ^ 1 - 1)). simplify. auto.\nrewrite (W8.and_mod 1 result_L.[0] _ ). auto. simplify. smt(@IntDiv).\nhave ->: W8.one = W8.of_int (2 ^ 1 - 1). smt(@W8).\nrewrite (W8.and_mod 1 result_L.[0] _). auto. simplify.\nsmt(@W8).\nqed.\n\n\nlemma random_bit_lemma4 : \n  equiv [M(Syscall).random_bit ~ SampleByte.run : true ==>  (W8.to_uint res{1} = res{2}) /\\ (res{1} = W8.zero \\/ res{1} = W8.one) ].\ntransitivity SampleModule.bit_distr\n (true ==> res{1} = res{2})\n (true ==> W8.to_uint res{1} = res{2} /\\ (res{1} = W8.zero \\/ res{1} = W8.one)).\nauto. auto.\nproc. wp.\ninline*.\nwp. rnd. wp.\nskip. progress.\nconseq lemma3.\nqed.\n\n\nlocal lemma lemma5 : \n  equiv [M(Syscall).random_bit ~ BinSampleSpec.main : arg{2} = (W8.zero, W8.one) ==> res{1} = res{2} ].\nproof.\nproc*. inline BinSampleSpec.main. wp.\ncall random_bit_lemma4. wp. skip. progress.\nelim H. progress. progress.\nqed.\n\n\n(* this lemma establishes that random_bit is equivalent to the distribution \"duniform [W8.zero; W8.one]\"  *)\nlemma random_bit_eq :\n  equiv [M(Syscall).random_bit ~ BinSampleSpec.spec : arg{2} = (W8.zero, W8.one) ==> res{1} = res{2} ].\nsymmetry.\ntransitivity BinSampleSpec.main\n  (={arg} ==> ={res})\n  (arg{1} = (W8.zero, W8.one)  ==> ={res}).\nprogress. smt(). auto.\nsymmetry.\nproc*. ecall (sat_spec a{1} b{1}). skip. auto.\nsymmetry.\nconseq lemma5.\nauto. \nqed.\n\n\n\nend section.", "```ec\nrequire import AllCore IntDiv CoreMap List Distr DList.\nrequire import JModel.\n\nrequire import Array32.\nrequire BinUniSample_spec.\nrequire import Array1 WArray1.\nrequire import Finite ArrayFiniteness.\n\nrequire import BigNum_proofs.\nrequire import W64_SchnorrExtract.\n\nrequire import BinUniSample_spec.\n\n\nclone import RandomChoice as W8RandomChocie with type t <- W8.t \nproof*.\n\nsection.\n\nlocal op h = (fun (a : WArray1.t) => Array1.init (fun i => WArray1.get8 a i)).\n\nlocal lemma init_ext:\n  forall (f1 f2 : int -> W8.t),\n       (Array1.init f1) = (Array1.init f2) =>\n    (forall (x : int), 0 <= x && x < 1 => f1 x = f2 x).\nsmt(@Array1).\nqed.\n\n\nlocal lemma h_inj : injective h.\nrewrite /injective.\nrewrite /h. \nmove => x y  q.\nhave :  get8 x 0 =  get8 y 0.\napply  (init_ext _ _ q 0 _). smt().\nrewrite /get8. smt(@WArray1).\nqed.\n\n\nlocal lemma h_surj : surjective h.    \nrewrite /surjective.\nprogress. \nexists (WArray1.init (fun i => x.[i])).\nrewrite /h.\napply Array1.ext_eq.\nprogress. have ->: x0 = 0. smt().\nsmt(@Array1 @WArray1).\nqed.\n\n\n\nlocal lemma darray_ll:\n is_lossless ____()___.\nproof. rewrite /darray. apply dmap_ll; apply dlist_ll. smt(@W8). qed.\n\n\nlocal lemma supp_darray a:\n a \\in darray <=> all (support W8.dword) (WArray1.to_list a).\nproof.\nrewrite /darray supp_dmap; split.\n move=> [x]; rewrite supp_dlist // => /> *.\n by rewrite WArray1.of_listK // /#.\nmove=> H; exists (to_list a); rewrite supp_dlist // H Array1.size_to_list /=.\nqed.\n\n\nlocal lemma darray_uni:\n   is_uniform (darray).\nproof.\nrewrite /darray=> ?; apply dmap_uni_in_inj.\n move=> x y; rewrite !supp_dlist //; move => [? _] [? _] H.\n  smt(@WArray1).\n apply dlist_uni. smt(@W8).\nqed.\n\n\nlocal lemma darray_fu:\n   is_full darray.\nproof.\nrewrite /darray => H; apply dmap_fu_in.\nmove=> x; exists (to_list x); rewrite to_listK supp_dlist //=.\nrewrite allP.\nprogress. smt(@W8).\nqed.\n\nlocal op byte_distr = dmap WArray1.darray h.\n\nlocal lemma byte_distr_uni : is_uniform byte_distr .\nrewrite /byte_distr.\napply dmap_uni_in_inj.\nprogress. smt (h_inj).\napply darray_uni.\nqed.\n\n\nlocal lemma byte_distr_ll: is_lossless byte_distr.\nrewrite /byte_distr.\napply dmap_ll.\napply darray_ll.\nqed.\n\nlocal lemma byte_distr_fu : is_full byte_distr .\nrewrite /byte_distr.\napply dmap_fu_in.\nprogress. smt(h_surj).\napply darray_fu.\nqed.\n\n\n\n\nlocal module SampleModule = {\n  proc byte_distr() = {\n    var r;\n    r <$ byte_distr;\n    return r;\n  }\n\n  proc bit_distr() = {\n    var b;\n    b <@ byte_distr();\n    b.[0] <- (b.[0] `&` (W8.of_int 1));\n    return b.[0];\n  }\n\n}.\n\n\n\nlocal lemma zzz : size (to_seq (support byte_distr)) =  256.\nhave : size all_256words1 = size (to_seq (support byte_distr)).\napply uniq_size_uniq.\napply uniq_to_seq.\nsmt(@Distr byte_distr_uni).\nprogress. apply all_256words1_full.\nhave : x \\in byte_distr.\napply byte_distr_fu.\nprogress. apply mem_to_seq.  smt(@Distr byte_distr_uni). auto.\napply all_256words1_uniq.\nprogress. rewrite - H.\nrewrite all_256words1_size. smt().\nqed.\n\nlocal op toi (x : W8.t Array1.t) : int = W8.to_uint x.[0].\nlocal op fri (x : int) : W8.t Array1.t   = (Array1.init (fun i => (W8.of_int x))).\nlocal lemma lemma2 : \n  equiv [SampleModule.byte_distr ~ SampleByte.sampleInt : true ==> (toi res{1} = res{2})  ].\nproc.\nrnd  toi fri.\nskip. progress.\nrewrite /toi /fri. \nrewrite initE. simplify. \n  have : 0 <= xR <= 255. smt(@Distr @List).\n  smt(@IntDiv).\nrewrite duniform1E_uniq. smt(@List).\nhave ->: xR \\in range 0 (255 + 1). smt(@List @Distr).\nsimplify. \nhave ->: size (range 0 256) = 256. smt(@List).\nrewrite mu1_uni. apply byte_distr_uni.\nrewrite byte_distr_fu. simplify.\nrewrite byte_distr_ll. \nrewrite zzz. auto.\nhave : 0 <= toi rL < 256. rewrite /toi. \nhave ->: 256 = W8.modulus. ring.\napply W8.to_uint_cmp.\nmove => qq.\n have : toi rL \\in range 0 256.\n  smt(@List).\n  smt(@Distr).\nrewrite /fri /toi.\napply Array1.ext_eq.\nprogress.\nhave ->: x = 0. smt().\nsimplify. auto.\nqed.\n\nlocal lemma lemma3 : \n  equiv [SampleModule.bit_distr ~ SampleByte.run : true ==> (W8.to_uint res{1} = res{2}) /\\ (res{1} = W8.zero \\/ res{1} = W8.one) ].\nproc.\nwp. call lemma2. skip. progress.\nrewrite /toi. \nhave ->: W8.one = (W8.of_int (2 ^ 1 - 1)). simplify. auto.\nrewrite (W8.and_mod 1 result_L.[0] _ ). auto. simplify. smt(@IntDiv).\nhave ->: W8.one = W8.of_int (2 ^ 1 - 1). smt(@W8).\nrewrite (W8.and_mod 1 result_L.[0] _). auto. simplify.\nsmt(@W8).\nqed.\n\n\nlemma random_bit_lemma4 : \n  equiv [M(Syscall).random_bit ~ SampleByte.run : true ==>  (W8.to_uint res{1} = res{2}) /\\ (res{1} = W8.zero \\/ res{1} = W8.one) ].\ntransitivity SampleModule.bit_distr\n (true ==> res{1} = res{2})\n (true ==> W8.to_uint res{1} = res{2} /\\ (res{1} = W8.zero \\/ res{1} = W8.one)).\nauto. auto.\nproc. wp.\ninline*.\nwp. rnd. wp.\nskip. progress.\nconseq lemma3.\nqed.\n\n\nlocal lemma lemma5 : \n  equiv [M(Syscall).random_bit ~ BinSampleSpec.main : arg{2} = (W8.zero, W8.one) ==> res{1} = res{2} ].\nproof.\nproc*. inline BinSampleSpec.main. wp.\ncall random_bit_lemma4. wp. skip. progress.\nelim H. progress. progress.\nqed.\n\n\n(* this lemma establishes that random_bit is equivalent to the distribution \"duniform [W8.zero; W8.one]\"  *)\nlemma random_bit_eq :\n  equiv [M(Syscall).random_bit ~ BinSampleSpec.spec : arg{2} = (W8.zero, W8.one) ==> res{1} = res{2} ].\nsymmetry.\ntransitivity BinSampleSpec.main\n  (={arg} ==> ={res})\n  (arg{1} = (W8.zero, W8.one)  ==> ={res}).\nprogress. smt(). auto.\nsymmetry.\nproc*. ecall (sat_spec a{1} b{1}). skip. auto.\nsymmetry.\nconseq lemma5.\nauto. \nqed.\n\n\n\nend section.\n```"]], "EC-1/RCPA_CMA.ec": [[true, "@ &m: res] - 1%r\n        = 2%r * Pr[SKEa.RCPA.INDR_CPA(E,RCPAa(M,A)).main() @ &m: res] - 1%r.\n      proof. by rewrite (RCPA_prob &m). qed.\n    end section RCPA.\n  end RCPA_SUF_RCPA.\n\n  (** We then prove that if E is IND$-CPA and M is SUF-CMA then EtM(E,M) is INT-CTXT **)\n  theory RCPA_SUF_CTXT.\n    import CTXT.\n\n    (* The SKE and the CTXT adversary against EtM(E,M) are combined\n       to construct a CMA adversary againt M                           *)\n    module CMAa(E:SKEa.Enc_Scheme, A:CTXT_Adversary, O:MACa.CMA_Oracles) = {\n      var ek: eK\n\n      module Sim : CTXT_Oracles = {\n        proc enc(p:ptxt): ctxt * tag = {\n          var c, t;\n\n          c <@ E.enc(ek,p);\n          t <@ O.tag(c);\n          return (c,t);\n        }\n\n        proc verify(ct:ctxt * tag): bool = {\n          var c, t, b;\n\n          (c,t) <- ct;\n          b     <@ O.verify(c,t);\n          return b;\n        }\n      }\n\n      proc forge(): unit = {\n        ek <@ E.keygen();\n              A(Sim).forge();\n      }\n    }.\n\n    section CTXT.\n      declare module E <: SKEa.Enc_Scheme { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa }.\n      declare module M <:MACa.MAC_Scheme { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa, -E }.\n      declare module A <: CTXT_Adversary  { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa, -E, -M }.\n\n      (* Equivalence up to failure requires termination of oracles and adversaries *)\n      declare axiom E_keygen_ll: islossless E.keygen.\n      declare axiom E_enc_ll   : islossless E.enc.\n      declare axiom E_dec_ll   : islossless E.dec.\n\n      declare axiom M_keygen_ll: islossless M.keygen.\n      declare axiom M_tag_ll   : islossless M.tag.\n      declare axiom M_verify_ll: islossless M.verify.\n\n      declare axiom A_forge_ll (O <: CTXT_Oracles { -A }):\n        islossless O.enc => islossless O.verify => islossless A(O).forge.\n\n      (* In addition, this result requires that the encryption scheme is correct,\n         and that the decryption algorithm is deterministic and stateless *)\n      declare axiom dec_op: exists dec,\n           (forall ge _k _c,\n              hoare [E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n                        ==> (glob E) = ge /\\ res = dec _k _c])\n        /\\ (forall _k _p,\n              hoare [E.enc: k = _k /\\ p = _p ==> dec _k res = Some _p]).\n\n(*    local choice...\n      choice dec with dec_op.\n\n      local hoare dec_sem ge _k _c:\n        E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n           ==> (glob E) = ge /\\ res = dec _k _c.\n      proof. have [h _]:= decE; exact/(h ge _k _c). qed.\n\n      local hoare E_correct _k _p:\n        E.enc: k = _k /\\ p = _p ==> dec _k res = Some _p.\n      proof. have [_ h]:= decE; exact/(h _k _p). qed.\n\n      (* Useful consequences of these facts *)\n      local equiv enc_eq _k _p: E.enc ~ E.enc:\n            ={glob E, k, p} /\\ k{1} = _k /\\ p{1} = _p\n        ==> ={glob E, res} /\\ dec _k res{1} = Some _p.\n      proof.\n        conseq* (_: ={glob E, k, p} ==> ={glob E, res}) (E_correct _k _p) _.\n        by proc true.\n      qed.\n\n      local phoare dec_ph ge _k _c:\n        [E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n            ==> (glob E) = ge /\\ res = dec _k _c] =1%r.\n      proof. by conseq* E_dec_ll (dec_sem ge _k _c). qed.\n*)\n\n      (* Adv^{CTXT}_{EtM(E,M)}(A) <= Adv^{SUF-CMA}_{M}(CMAa(E,A)) *)\n      lemma CTXT_security &m:\n        Pr[INT_CTXT(EtM(E,M),A).main() @ &m: res]\n        <= Pr[MACa.SUF_CMA.SUF_CMA(M,CMAa(E,A)).main() @ &m: res].\n      proof.\n        have [dec [dec_sem enc_sem]]:= dec_op.\n        byequiv=> //=.\n        proc; inline *.\n        call (_: MACa.SUF_CMA.SUF_Wrap.win,\n                    ={glob E, glob M}\n                 /\\ CTXT_Wrap.k{1} = (CMAa.ek,MACa.SUF_CMA.SUF_Wrap.k){2}\n                 /\\ (forall p, mem CTXT_Wrap.s{1} p <=> mem MACa.SUF_CMA.SUF_Wrap.s{2} p)\n                 /\\ (forall c t, mem CTXT_Wrap.s{1} (c,t) => dec CMAa.ek{2} c <> None)\n                 /\\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})).\n          (* adversary is lossless *)\n          exact/A_forge_ll.\n          (* encryption oracle *)\n          (* equivalence *)\n          proc; inline *.\n          wp; call (_: true).\n          wp; sp. exists* ek{1}, p0{1}; elim* => _k _p.\n          call (_: ={glob E, k, p} /\\ k{1} = _k /\\ p{1} = _p ==> ={glob E, res} /\\ dec _k res{1} = Some _p).\n            by conseq (_: ={glob E, k, p} ==> ={glob E, res}) (enc_sem _k _p); proc true.\n          skip => />; smt(in_fsetU in_fset1).\n          (* lossless after win *)\n          by move=> &2 win; proc; wp; call (EtM_enc_ll E M E_enc_ll M_tag_ll).\n          (* lossless and preservation of win *)\n          move=> &1; proc; inline *.\n          wp; call M_tag_ll.\n          by wp; call E_enc_ll.\n          (* decryption oracle *)\n          (* equivalence *)\n          proc; inline *.\n          seq  6  4: (   !MACa.SUF_CMA.SUF_Wrap.win{2}\n                      /\\ ={glob E, glob M}\n                      /\\ b{1} = b0{2}\n                      /\\ c{1} = ct{2}\n                      /\\ CTXT_Wrap.k{1} = (CMAa.ek,MACa.SUF_CMA.SUF_Wrap.k){2}\n                      /\\ (forall p, mem CTXT_Wrap.s{1} p <=> mem MACa.SUF_CMA.SUF_Wrap.s{2} p)\n                      /\\ (forall c t, mem CTXT_Wrap.s{1} (c,t) => dec CMAa.ek{2} c <> None)\n                      /\\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})\n                      /\\ k{1}  = CTXT_Wrap.k{1}\n                      /\\ ct{1} = c{1}\n                      /\\ c{2}  = ct{2}.`1\n                      /\\ t{2}  = ct{2}.`2\n                      /\\ p0{1} = None\n                      /\\ m{2}  = c{2}\n                      /\\ ek{1} = k{1}.`1\n                      /\\ mk{1} = k{1}.`2\n                      /\\ t0{2} = t{2}\n                      /\\ c0{1} = ct{1}.`1\n                      /\\ t{1}  = ct{1}.`2).\n            by wp; call (_: true); auto.\n          if{1}.\n            wp. exists* (glob E){1}, ek{1}, c0{1}; elim* => ge _k _c.\n            call{1} (_:     (glob E) = ge /\\ k = _k /\\ c = _c\n                        ==> (glob E) = ge /\\ res = dec _k _c).\n              by conseq (E_dec_ll) (dec_sem ge _k _c).\n            by skip; smt.\n          by auto; smt.\n        (* lossless after win *)\n        by move=> &2 bad; proc; wp; call (EtM_dec_ll E M E_dec_ll M_verify_ll).\n        (* lossless and preservation of win *)\n        move=> &1; proc; seq  2: true 1%r 1%r 0%r _ (MACa.SUF_CMA.SUF_Wrap.win) => //=.\n          by inline *; wp; call (_: true); auto; smt.\n          by inline *; wp; call M_verify_ll; auto.\n        (* back to the experiment *)\n        swap{2} 4 -3.\n        wp; call (_: true).\n        by wp; call (_: true); skip; smt.\n      qed.\n    end section CTXT.\n  end RCPA_SUF_CTXT.\nend EtM.", "```ec\n@ &m: res] - 1%r\n        = 2%r * Pr[SKEa.RCPA.INDR_CPA(E,RCPAa(M,A)).main() @ &m: res] - 1%r.\n      proof. by rewrite (RCPA_prob &m). qed.\n    end section RCPA.\n  end RCPA_SUF_RCPA.\n\n  (** We then prove that if E is IND$-CPA and M is SUF-CMA then EtM(E,M) is INT-CTXT **)\n  theory RCPA_SUF_CTXT.\n    import CTXT.\n\n    (* The SKE and the CTXT adversary against EtM(E,M) are combined\n       to construct a CMA adversary againt M                           *)\n    module CMAa(E:SKEa.Enc_Scheme, A:CTXT_Adversary, O:MACa.CMA_Oracles) = {\n      var ek: eK\n\n      module Sim : CTXT_Oracles = {\n        proc enc(p:ptxt): ctxt * tag = {\n          var c, t;\n\n          c <@ E.enc(ek,p);\n          t <@ O.tag(c);\n          return (c,t);\n        }\n\n        proc verify(ct:ctxt * tag): bool = {\n          var c, t, b;\n\n          (c,t) <- ct;\n          b     <@ O.verify(c,t);\n          return b;\n        }\n      }\n\n      proc forge(): unit = {\n        ek <@ E.keygen();\n              A(Sim).forge();\n      }\n    }.\n\n    section CTXT.\n      declare module E <: SKEa.Enc_Scheme { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa }.\n      declare module M <:MACa.MAC_Scheme { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa, -E }.\n      declare module A <: CTXT_Adversary  { -CTXT_Wrap, -MACa.SUF_CMA.SUF_Wrap, -CMAa, -E, -M }.\n\n      (* Equivalence up to failure requires termination of oracles and adversaries *)\n      declare axiom E_keygen_ll: islossless E.keygen.\n      declare axiom E_enc_ll   : islossless E.enc.\n      declare axiom E_dec_ll   : islossless E.dec.\n\n      declare axiom M_keygen_ll: islossless M.keygen.\n      declare axiom M_tag_ll   : islossless M.tag.\n      declare axiom M_verify_ll: islossless M.verify.\n\n      declare axiom A_forge_ll (O <: CTXT_Oracles { -A }):\n        islossless O.enc => islossless O.verify => islossless A(O).forge.\n\n      (* In addition, this result requires that the encryption scheme is correct,\n         and that the decryption algorithm is deterministic and stateless *)\n      declare axiom dec_op: exists dec,\n           (forall ge _k _c,\n              hoare [E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n                        ==> (glob E) = ge /\\ res = dec _k _c])\n        /\\ (forall _k _p,\n              hoare [E.enc: k = _k /\\ p = _p ==> dec _k res = Some _p]).\n\n(*    local choice...\n      choice dec with dec_op.\n\n      local hoare dec_sem ge _k _c:\n        E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n           ==> (glob E) = ge /\\ res = dec _k _c.\n      proof. have [h _]:= decE; exact/(h ge _k _c). qed.\n\n      local hoare E_correct _k _p:\n        E.enc: k = _k /\\ p = _p ==> dec _k res = Some _p.\n      proof. have [_ h]:= decE; exact/(h _k _p). qed.\n\n      (* Useful consequences of these facts *)\n      local equiv enc_eq _k _p: E.enc ~ E.enc:\n            ={glob E, k, p} /\\ k{1} = _k /\\ p{1} = _p\n        ==> ={glob E, res} /\\ dec _k res{1} = Some _p.\n      proof.\n        conseq* (_: ={glob E, k, p} ==> ={glob E, res}) (E_correct _k _p) _.\n        by proc true.\n      qed.\n\n      local phoare dec_ph ge _k _c:\n        [E.dec: (glob E) = ge /\\ k = _k /\\ c = _c\n            ==> (glob E) = ge /\\ res = dec _k _c] =1%r.\n      proof. by conseq* E_dec_ll (dec_sem ge _k _c). qed.\n*)\n\n      (* Adv^{CTXT}_{EtM(E,M)}(A) <= Adv^{SUF-CMA}_{M}(CMAa(E,A)) *)\n      lemma CTXT_security &m:\n        Pr[INT_CTXT(EtM(E,M),A).main() @ &m: res]\n        <= Pr[MACa.SUF_CMA.SUF_CMA(M,CMAa(E,A)).main() @ &m: res].\n      proof.\n        have [dec [dec_sem enc_sem]]:= dec_op.\n        byequiv=> //=.\n        proc; inline *.\n        call (_: MACa.SUF_CMA.SUF_Wrap.win,\n                    ={glob E, glob M}\n                 /\\ CTXT_Wrap.k{1} = (CMAa.ek,MACa.SUF_CMA.SUF_Wrap.k){2}\n                 /\\ (forall p, mem CTXT_Wrap.s{1} p <=> mem MACa.SUF_CMA.SUF_Wrap.s{2} p)\n                 /\\ (forall c t, mem CTXT_Wrap.s{1} (c,t) => dec CMAa.ek{2} c <> None)\n                 /\\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})).\n          (* adversary is lossless *)\n          exact/A_forge_ll.\n          (* encryption oracle *)\n          (* equivalence *)\n          proc; inline *.\n          wp; call (_: true).\n          wp; sp. exists* ek{1}, p0{1}; elim* => _k _p.\n          call (_: ={glob E, k, p} /\\ k{1} = _k /\\ p{1} = _p ==> ={glob E, res} /\\ dec _k res{1} = Some _p).\n            by conseq (_: ={glob E, k, p} ==> ={glob E, res}) (enc_sem _k _p); proc true.\n          skip => />; smt(in_fsetU in_fset1).\n          (* lossless after win *)\n          by move=> &2 win; proc; wp; call (EtM_enc_ll E M E_enc_ll M_tag_ll).\n          (* lossless and preservation of win *)\n          move=> &1; proc; inline *.\n          wp; call M_tag_ll.\n          by wp; call E_enc_ll.\n          (* decryption oracle *)\n          (* equivalence *)\n          proc; inline *.\n          seq  6  4: (   !MACa.SUF_CMA.SUF_Wrap.win{2}\n                      /\\ ={glob E, glob M}\n                      /\\ b{1} = b0{2}\n                      /\\ c{1} = ct{2}\n                      /\\ CTXT_Wrap.k{1} = (CMAa.ek,MACa.SUF_CMA.SUF_Wrap.k){2}\n                      /\\ (forall p, mem CTXT_Wrap.s{1} p <=> mem MACa.SUF_CMA.SUF_Wrap.s{2} p)\n                      /\\ (forall c t, mem CTXT_Wrap.s{1} (c,t) => dec CMAa.ek{2} c <> None)\n                      /\\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})\n                      /\\ k{1}  = CTXT_Wrap.k{1}\n                      /\\ ct{1} = c{1}\n                      /\\ c{2}  = ct{2}.`1\n                      /\\ t{2}  = ct{2}.`2\n                      /\\ p0{1} = None\n                      /\\ m{2}  = c{2}\n                      /\\ ek{1} = k{1}.`1\n                      /\\ mk{1} = k{1}.`2\n                      /\\ t0{2} = t{2}\n                      /\\ c0{1} = ct{1}.`1\n                      /\\ t{1}  = ct{1}.`2).\n            by wp; call (_: true); auto.\n          if{1}.\n            wp. exists* (glob E){1}, ek{1}, c0{1}; elim* => ge _k _c.\n            call{1} (_:     (glob E) = ge /\\ k = _k /\\ c = _c\n                        ==> (glob E) = ge /\\ res = dec _k _c).\n              by conseq (E_dec_ll) (dec_sem ge _k _c).\n            by skip; smt.\n          by auto; smt.\n        (* lossless after win *)\n        by move=> &2 bad; proc; wp; call (EtM_dec_ll E M E_dec_ll M_verify_ll).\n        (* lossless and preservation of win *)\n        move=> &1; proc; seq  2: true 1%r 1%r 0%r _ (MACa.SUF_CMA.SUF_Wrap.win) => //=.\n          by inline *; wp; call (_: true); auto; smt.\n          by inline *; wp; call M_verify_ll; auto.\n        (* back to the experiment *)\n        swap{2} 4 -3.\n        wp; call (_: true).\n        by wp; call (_: true); skip; smt.\n      qed.\n    end section CTXT.\n  end RCPA_SUF_CTXT.\nend EtM.\n```"]], "EC-1/Reflection.ec": [[false, "```ec\nrequire import List Int Real Distr.\nrequire (*--other--*) Refl.\n\n(* Clone the interface *)\nclone export Refl.RunnableRefl as ARefl with\n  type at <- at,\n  type rt <- rt.\n\nmodule type RunnableRefl = ARefl.RunnableRefl.\n\n(* Define a module functor PP that takes a module A of type RunnableRefl *)\nmodule PP(A : RunnableRefl) = {\n  proc sampleFrom(d : rt distr) : rt = {\n    var r : rt;\n    r <$ d;\n    return r;\n  }\n\n  proc main2(a : at) : rt = {\n    return A.main(a);\n  }\n}.\n\n(* Local module definition *)\nmodule P(A : RunnableRefl) = {\n  proc sampleFrom(d : (rt * glob A) distr) : rt * glob A = {\n    var r : rt * glob A;\n    r <$ d;\n    return r;\n  }\n\n  proc main2(a : at) : rt * glob A = {\n    var r : rt;\n    r = A.main(a);\n    return (r, glob A);\n  }\n}.\n\n(* Theory for summability and properties of lists *)\ntheory Lists.\n  lemma filter_le1 (P : bool list) (l : 'a list) :\n    size (filter P l) <= size l.\n  proof.\n    elim: l =>"]], "EC-1/RejectionSamplingIndexed.ec": [[true, "pragma Goals:printall.\nrequire import AllCore Distr Real List.\n\nrequire RejectionSamplingModule.\n\nclone import RejectionSamplingModule as RSM.\n\n\nlemma rj_eq1 : \n equiv [RS.sample ~ RS.sample1 \n   : ={arg} ==> ={res} ].\nproof. \nproc.\nunroll {1} 3. inline RS.sample. \nsp.  rcondt {1} 1. auto. \nseq 3 2 : (={x, P, c} /\\ b{1} = P{2} x{2}).\nwp. rnd. skip. progress.\nexists* x{1}. elim*. progress.\ncase (P{1} x_L).\nrcondf {2} 1. progress. \nrcondf {1} 1. progress. skip. auto.\nrcondt {2} 1. progress.\nsp. wp. \nunroll {1} 1. unroll {2} 1.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress.\nsim.\nqed.\n\n\nlemma ph_l &m P1 Q1 c1 i :\n  phoare[ RS.sample : arg = (P1, c1) ==> Q1 res.`2 /\\ res.`1 = i ] \n   = (Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ]).\nbypr. move => &m0 q. rewrite q.\nbyequiv (_: ={arg} ==> _). proc. \nunroll {1} 3.\nunroll {2} 3.\nrcondt {1} 3. progress. wp. auto.\nrcondt {2} 3. progress. wp. auto.\nwhile (={c,x,b,P}). auto. wp. rnd. wp. skip. progress.\nauto. auto.\nqed.\n\n\nlemma ph_l2  &m P1 Q1 c1 i : Impl Q1 P1 =>\n  Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ RS.flag = true /\\ res.`1 = i ] \n  = (mu d (predC P1)) * Pr[ RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\nmove => H.\nbyphoare (_: arg = (P1 ,c1) ==> _). proc. sp.\nseq 1 : (!P1 x) (mu d (fun x => ! P1 x)) (Pr[RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = i])\n (mu d P1) 0%r (c1 = c /\\ P1 = P /\\ RS.flag = false).\nrnd. skip. auto.\nrnd. skip. progress. \nsp. elim*. progress. rcondt 1. auto.\ncall (ph_l &m P1 Q1 (c1  + 1) i). auto.  simplify.\nprogress. \nhoare. \nrcondf 2. wp. skip.  simplify.  smt().\nwp. skip. smt().\nprogress. auto. auto.\nqed.\n\nlemma ph_l3  &m P1 Q1 c1 : Impl Q1 P1 =>\n  Pr[ RS.sample1(P1, c1) @ &m : Q1 res.`2 /\\ RS.flag = false ] \n  = (mu d Q1). \nmove => H.\nbyphoare (_: arg = (P1, c1) ==> _). proc. sp.\nseq 1 : (Q1 x) (mu d Q1) 1%r\n (mu d P1) 0%r (P1 = P /\\ RS.flag = false).\nrnd. skip. auto.\nrnd. skip. progress. \nrcondf 2. wp. auto. smt(). wp. skip.  auto.\nexists* x. elim*. move => xx.\ncase (P1 xx).\nrcondf 2. wp. skip. progress. hoare. wp. skip. smt().\nrcondt 2. wp. skip.  progress. hoare.  \ninline*. wp.  while (RS.flag = true). wp.  rnd. skip.\nprogress. wp.  skip. auto. auto. auto. auto.\nqed.\n  \nlemma ph_l4 &m P1 Q1 c1 i :\n  Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n = Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\nbyequiv (_: ={arg} ==> _). symmetry. conseq rj_eq1. auto.\nauto. auto. auto.\nqed.\n\n\nlemma ph_l5''  &m P1 Q1  : \n   Pr[RS.sample(P1, 0) @ &m : Q1 res.`2 /\\ res.`1 = 0] = 1%r.\nhave :    Pr[RS.sample(P1, 0) @ &m : res.`1 = 0] = 1%r.\nbyphoare (_: arg = (P1, 0) ==> res.`1 = 0);auto. hoare.\nproc.  simplify.\nunroll 3. rcondt 3. wp. skip.  auto.\nwhile (0 < c). wp. rnd. skip. smt().\nwp. rnd. wp. skip. auto. smt().\nsmt(@Distr).\nqed.\n\n    \nlemma ph_l5'  &m P1 Q1 c1 i : 0 <= c1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = (i+1) ] \n   = Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] .\nprogress. \nbyequiv (_: ={P} /\\ c{2} + 1 = c{1}  ==> _).\nproc.\nsp.  while (={P, x, b} /\\ c{2} + 1 = c{1}   ).\nwp. rnd. skip. progress. skip. progress. smt().\nprogress.  auto.\nqed.\n\nlemma ph_l5g'  &m P1 Q1 c1 i : \n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n   = Pr[ RS.sample(P1,c1 -1) @ &m : Q1 res.`2 /\\ res.`1 = i - 1 ] .\nprogress. \nbyequiv (_: ={P} /\\ c{2} + 1 = c{1}  ==> _).\nproc.\nsp.  while (={P, x, b} /\\ c{2} + 1 = c{1}   ).\nwp. rnd. skip. progress. skip. progress. smt().\nprogress.  \nqed.\n\n\nlemma ph_l5'''  &m P1  c1 i : c1 < i - 1 =>\n  Pr[RS.sample1(P1, c1) @ &m :  res.`1 = i /\\ RS.flag = false]\n  = 0%r. \nprogress.\nbyphoare (_: arg = (P1, c1) ==> _).\nhoare. proc.\nseq 3 : (RS.flag = false /\\ c < i). wp. rnd. wp. skip. \nprogress. smt().\ncase (P x). \nrcondf 1. auto. skip. progress. smt().\nrcondt 1. auto. sp. elim*. progress.\ninline*.  sp. wp.\nwhile (RS.flag = true). wp. rnd. skip. auto.\nskip. auto. auto. auto. qed.\n\n\nlemma ph_l5  &m P1 Q1 c1 i :  c1 < i - 1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n  =  (mu d (predC P1)) * Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = (i - 1) ].\nhave ->: Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = (i - 1) ]\n = Pr[ RS.sample(P1,c1 + 1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\n rewrite (ph_l5g' &m P1 Q1 (c1 + 1)). auto.\nrewrite - ph_l4.\nprogress.\nrewrite Pr[mu_split RS.flag = true]. \nhave -> : Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag = true]\n = Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ RS.flag = true /\\ res.`1 = i ] .\nrewrite Pr[mu_eq]. auto. auto.\nrewrite ph_l2. auto.\nhave ->: Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag <> true]\n = 0%r. \n   have : Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag <> true] <=   Pr[RS.sample1(P1, c1) @ &m :  res.`1 = i /\\ RS.flag = false]. \n  rewrite Pr[mu_sub]. smt(). auto. \n  rewrite ph_l5'''. auto. smt(@Distr). auto.\nqed.\n\nlemma ph_l6  &m P1 Q1 c1 i :  c1 = i - 1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n  =  (mu d Q1).\nrewrite - ph_l4.\nprogress.\nhave ->:   Pr[ RS.sample1(P1,i-1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n =   Pr[ RS.sample1(P1,i-1) @ &m : Q1 res.`2 /\\ RS.flag = false ] .\nbyequiv (_: ={arg} /\\ arg{1} = (P1, i-1) ==> _). proc.\nseq 3 3 : (={P, RS.flag, x , c} /\\ RS.flag{1} = false /\\ c{1} = i ).\nwp. rnd. wp. auto. \ncase (P{1} x{1}).\nrcondf {1} 1. progress.\nrcondf {2} 1. progress. skip. auto.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress. \nsp. elim*. progress.\ninline*.\nwp. sp. \nunroll {1} 1.\nunroll {2} 1.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress. \nwhile (={x0, c0, b, P0} /\\ RS.flag{2} = true /\\ i < c0{1}).\nwp. rnd. skip. progress. \nsmt(). wp. rnd. skip. progress.  smt(). smt(). auto. auto.\napply ph_l3. auto.\nqed.\n\n\nlemma prob  &m P1 Q1 : Impl Q1 P1 => forall i ,  0 <= i =>\n  Pr[ RS.sample(P1,0) @ &m : Q1 res.`2 /\\ res.`1 = i + 1 ] \n  = (mu d (predC P1)) ^ i *  (mu d Q1).\nmove => H.\napply intind.\nprogress. rewrite ph_l6. auto. auto. smt(@Int).\nprogress. \nrewrite ph_l5. smt(). auto.\nsimplify. rewrite H1. smt(@RealExp @Real).\nqed.", "```ec\npragma Goals:printall.\nrequire import AllCore Distr Real List.\n\nrequire RejectionSamplingModule.\n\nclone import RejectionSamplingModule as RSM.\n\n\nlemma rj_eq1 : \n equiv [RS.sample ~ RS.sample1 \n   : ={arg} ==> ={res} ].\nproof. \nproc.\nunroll {1} 3. inline RS.sample. \nsp.  rcondt {1} 1. auto. \nseq 3 2 : (={x, P, c} /\\ b{1} = P{2} x{2}).\nwp. rnd. skip. progress.\nexists* x{1}. elim*. progress.\ncase (P{1} x_L).\nrcondf {2} 1. progress. \nrcondf {1} 1. progress. skip. auto.\nrcondt {2} 1. progress.\nsp. wp. \nunroll {1} 1. unroll {2} 1.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress.\nsim.\nqed.\n\n\nlemma ph_l &m P1 Q1 c1 i :\n  phoare[ RS.sample : arg = (P1, c1) ==> Q1 res.`2 /\\ res.`1 = i ] \n   = (Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ]).\nbypr. move => &m0 q. rewrite q.\nbyequiv (_: ={arg} ==> _). proc. \nunroll {1} 3.\nunroll {2} 3.\nrcondt {1} 3. progress. wp. auto.\nrcondt {2} 3. progress. wp. auto.\nwhile (={c,x,b,P}). auto. wp. rnd. wp. skip. progress.\nauto. auto.\nqed.\n\n\nlemma ph_l2  &m P1 Q1 c1 i : Impl Q1 P1 =>\n  Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ RS.flag = true /\\ res.`1 = i ] \n  = (mu d (predC P1)) * Pr[ RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\nmove => H.\nbyphoare (_: arg = (P1 ,c1) ==> _). proc. sp.\nseq 1 : (!P1 x) (mu d (fun x => ! P1 x)) (Pr[RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = i])\n (mu d P1) 0%r (c1 = c /\\ P1 = P /\\ RS.flag = false).\nrnd. skip. auto.\nrnd. skip. progress. \nsp. elim*. progress. rcondt 1. auto.\ncall (ph_l &m P1 Q1 (c1  + 1) i). auto.  simplify.\nprogress. \nhoare. \nrcondf 2. wp. skip.  simplify.  smt().\nwp. skip. smt().\nprogress. auto. auto.\nqed.\n\nlemma ph_l3  &m P1 Q1 c1 : Impl Q1 P1 =>\n  Pr[ RS.sample1(P1, c1) @ &m : Q1 res.`2 /\\ RS.flag = false ] \n  = (mu d Q1). \nmove => H.\nbyphoare (_: arg = (P1, c1) ==> _). proc. sp.\nseq 1 : (Q1 x) (mu d Q1) 1%r\n (mu d P1) 0%r (P1 = P /\\ RS.flag = false).\nrnd. skip. auto.\nrnd. skip. progress. \nrcondf 2. wp. auto. smt(). wp. skip.  auto.\nexists* x. elim*. move => xx.\ncase (P1 xx).\nrcondf 2. wp. skip. progress. hoare. wp. skip. smt().\nrcondt 2. wp. skip.  progress. hoare.  \ninline*. wp.  while (RS.flag = true). wp.  rnd. skip.\nprogress. wp.  skip. auto. auto. auto. auto.\nqed.\n  \nlemma ph_l4 &m P1 Q1 c1 i :\n  Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n = Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\nbyequiv (_: ={arg} ==> _). symmetry. conseq rj_eq1. auto.\nauto. auto. auto.\nqed.\n\n\nlemma ph_l5''  &m P1 Q1  : \n   Pr[RS.sample(P1, 0) @ &m : Q1 res.`2 /\\ res.`1 = 0] = 1%r.\nhave :    Pr[RS.sample(P1, 0) @ &m : res.`1 = 0] = 1%r.\nbyphoare (_: arg = (P1, 0) ==> res.`1 = 0);auto. hoare.\nproc.  simplify.\nunroll 3. rcondt 3. wp. skip.  auto.\nwhile (0 < c). wp. rnd. skip. smt().\nwp. rnd. wp. skip. auto. smt().\nsmt(@Distr).\nqed.\n\n    \nlemma ph_l5'  &m P1 Q1 c1 i : 0 <= c1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1+1) @ &m : Q1 res.`2 /\\ res.`1 = (i+1) ] \n   = Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] .\nprogress. \nbyequiv (_: ={P} /\\ c{2} + 1 = c{1}  ==> _).\nproc.\nsp.  while (={P, x, b} /\\ c{2} + 1 = c{1}   ).\nwp. rnd. skip. progress. skip. progress. smt().\nprogress.  auto.\nqed.\n\nlemma ph_l5g'  &m P1 Q1 c1 i : \n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n   = Pr[ RS.sample(P1,c1 -1) @ &m : Q1 res.`2 /\\ res.`1 = i - 1 ] .\nprogress. \nbyequiv (_: ={P} /\\ c{2} + 1 = c{1}  ==> _).\nproc.\nsp.  while (={P, x, b} /\\ c{2} + 1 = c{1}   ).\nwp. rnd. skip. progress. skip. progress. smt().\nprogress.  \nqed.\n\n\nlemma ph_l5'''  &m P1  c1 i : c1 < i - 1 =>\n  Pr[RS.sample1(P1, c1) @ &m :  res.`1 = i /\\ RS.flag = false]\n  = 0%r. \nprogress.\nbyphoare (_: arg = (P1, c1) ==> _).\nhoare. proc.\nseq 3 : (RS.flag = false /\\ c < i). wp. rnd. wp. skip. \nprogress. smt().\ncase (P x). \nrcondf 1. auto. skip. progress. smt().\nrcondt 1. auto. sp. elim*. progress.\ninline*.  sp. wp.\nwhile (RS.flag = true). wp. rnd. skip. auto.\nskip. auto. auto. auto. qed.\n\n\nlemma ph_l5  &m P1 Q1 c1 i :  c1 < i - 1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n  =  (mu d (predC P1)) * Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = (i - 1) ].\nhave ->: Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = (i - 1) ]\n = Pr[ RS.sample(P1,c1 + 1) @ &m : Q1 res.`2 /\\ res.`1 = i ].\n rewrite (ph_l5g' &m P1 Q1 (c1 + 1)). auto.\nrewrite - ph_l4.\nprogress.\nrewrite Pr[mu_split RS.flag = true]. \nhave -> : Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag = true]\n = Pr[ RS.sample1(P1,c1) @ &m : Q1 res.`2 /\\ RS.flag = true /\\ res.`1 = i ] .\nrewrite Pr[mu_eq]. auto. auto.\nrewrite ph_l2. auto.\nhave ->: Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag <> true]\n = 0%r. \n   have : Pr[RS.sample1(P1, c1) @ &m : (Q1 res.`2 /\\ res.`1 = i) /\\ RS.flag <> true] <=   Pr[RS.sample1(P1, c1) @ &m :  res.`1 = i /\\ RS.flag = false]. \n  rewrite Pr[mu_sub]. smt(). auto. \n  rewrite ph_l5'''. auto. smt(@Distr). auto.\nqed.\n\nlemma ph_l6  &m P1 Q1 c1 i :  c1 = i - 1 => Impl Q1 P1 =>\n  Pr[ RS.sample(P1,c1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n  =  (mu d Q1).\nrewrite - ph_l4.\nprogress.\nhave ->:   Pr[ RS.sample1(P1,i-1) @ &m : Q1 res.`2 /\\ res.`1 = i ] \n =   Pr[ RS.sample1(P1,i-1) @ &m : Q1 res.`2 /\\ RS.flag = false ] .\nbyequiv (_: ={arg} /\\ arg{1} = (P1, i-1) ==> _). proc.\nseq 3 3 : (={P, RS.flag, x , c} /\\ RS.flag{1} = false /\\ c{1} = i ).\nwp. rnd. wp. auto. \ncase (P{1} x{1}).\nrcondf {1} 1. progress.\nrcondf {2} 1. progress. skip. auto.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress. \nsp. elim*. progress.\ninline*.\nwp. sp. \nunroll {1} 1.\nunroll {2} 1.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress. \nwhile (={x0, c0, b, P0} /\\ RS.flag{2} = true /\\ i < c0{1}).\nwp. rnd. skip. progress. \nsmt(). wp. rnd. skip. progress.  smt(). smt(). auto. auto.\napply ph_l3. auto.\nqed.\n\n\nlemma prob  &m P1 Q1 : Impl Q1 P1 => forall i ,  0 <= i =>\n  Pr[ RS.sample(P1,0) @ &m : Q1 res.`2 /\\ res.`1 = i + 1 ] \n  = (mu d (predC P1)) ^ i *  (mu d Q1).\nmove => H.\napply intind.\nprogress. rewrite ph_l6. auto. auto. smt(@Int).\nprogress. \nrewrite ph_l5. smt(). auto.\nsimplify. rewrite H1. smt(@RealExp @Real).\nqed.\n```"]], "EC-1/basic-hash-auth.ec": [[true, "(* This file is a formal analysis of the Basic Hash protocol using the EasyCrypt tool. *)\n\n(*-----------------------------------------------------------------------*)\n(* Key and Ptxt space *)\ntype key.\ntype ptxt.\n\n(* Key distribution *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll dnonce_uni.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    ks <- [];\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n     i <- i + 1;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed.", "```ec\n(* This file is a formal analysis of the Basic Hash protocol using the EasyCrypt tool. *)\n\n(*-----------------------------------------------------------------------*)\n(* Key and Ptxt space *)\ntype key.\ntype ptxt.\n\n(* Key distribution *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll dnonce_uni.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    ks <- [];\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n     i <- i + 1;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed.\n```"]], "EC-1/RewCommutesSimple.ec": [[false, "```ec\nimport Finite.\nrequire (*--*) FinType.\n\nrequire import RandomFacts.\nrequire Reflection.\n\n\ntheory RewCommNI.\n\ntype at1, rt1, at2, rt2, sbits, irt, rrt, iat.\n\n\nop pair_sbits : sbits * sbits -> sbits.\nop unpair: sbits -> sbits * sbits.\naxiom ips: injective pair_sbits. \naxiom unpair_pair x : unpair (pair_sbits x) = x.\n\n\nrequire RewBasics.\nclone import RewBasics as RW with type sbits <- sbits,\n                                  type rrt <- rrt,\n                                  type irt <- irt,\n                                  type iat <- iat,\n                                  op pair_sbits <- pair_sbits,\n                                  op unpair <- unpair.\n\n\nmodule type RewRun = {\n  proc getState()          : sbits\n  proc setState(b : sbits) : unit (* EasyCrypt removed support for \"proc *\" *)\n  proc ex1(a:at1) : rt1\n  proc ex2(a:at2) : rt2\n}.\n\n\n\nmodule CommNoInit(A : RewRun) = {\n  proc ex1ex2(a1 : at1, a2 : at2) = {\n     var r1, r2, s;\n     s <@ A.getState();\n     r1 <@ A.ex1(a1);\n     A.setState(s);\n     r2 <@ A.ex2(a2);\n     return (r1,r2);\n  }\n\n  proc ex2ex1(a1 : at1, a2 : at2) = {\n     var r1, r2, s;\n     s <@ A.getState();\n     r2 <@ A.ex2(a2);\n     A.setState(s);\n     r1 <@ A.ex1(a1);\n     return (r1,r2);\n  }\n}.\n\n\nsection.\ndeclare module A <: RewRun{-CommNoInit, -BestModule}. \n\n\nlocal module BestModule(A : RewRun{-CommNoInit}) = {\n  proc main(a : at1) : rt1 = {\n    var s, r;\n    s <@ A.getState();\n    r <@ A.ex1(a);\n    A.setState(s);\n    return r;\n  }\n\n  proc main'(a, d : at1 * (at1 -> rt1 distr)) = {\n    var r;\n    r <$ d.`2 a;\n    return r;\n  }\n\n  proc comm1(a1,a2:at1 * at2) = {\n     var r1, r2, s;\n     r1 <@ main(a1.`1);\n     s <@ A.getState();\n     r2 <@ A.ex2(a1.`2);\n     A.setState(s);\n     return (r1,r2);\n  }\n\n  proc comm2(a1,a2:at1 * at2, d : at1 -> rt1 distr) = {\n     var r1, r2, s;\n     r1 <@ main'(a1,d);\n     s <@ A.getState();\n     r2 <@ A.ex2(a2);\n     A.setState(s);\n     return (r1,r2);\n  }\n\n  proc comm3(a1,a2:at1 * at2, d : at1 -> rt1 distr) = {\n     var r1, r2,s;\n     s <@ A.getState();\n     r2 <@ A.ex2(a2);\n     A.setState(s);\n     r1 <@ main'(a1.`1,d);\n     return (r1,r2);\n  }\n\n  proc comm4(a1:at1 * at2) = {\n     var r1, r2, s;\n     s <@ A.getState();\n     r2 <@ A.ex2(a1.`2);\n     A.setState(s);\n     r1 <@ main(a1.`1);\n     return (r1,r2);\n  }\n\n}.\n\n\nclone import Reflection.Refl with type at <- at1,\n                                  type rt <- rt1.\n\n                                  \n(* getState lossless follows from rewindable_A, but setState lossless does not, so we ask it *)\ndeclare axiom RewProp :\n  exists (f : glob A -> sbits),\n  injective f /\\\n  (forall &m, Pr"]], "EC-1/Schnorr.ec": [[true, "require import AllCore List IntDiv CoreMap FMap.\nfrom Jasmin import JWord.\nrequire (*---*) Schnorr.\nrequire (*---*) FAdv.\n(* Some auxiliary lemmas. *)\nlocal lemma mem_rcons (xs : 'a list) (x : 'a) y :\n  mem (rcons xs x) y <=> mem xs y \\/ y = x.\nproof. by rewrite -cats1 mem_cat. qed.\n\n(* q is not in the signed list. *)\nlocal lemma cats1 /=.\npose ms := Red_CMA_KOA.Simulator.signed{2}; pose m := q{2}.`3.\nhave signed_sub : predU (signed ms) (pred1 q{2}) <= signed (rcons ms m).\n+ rewrite /(<=) /predU /signed => q.\n  smt(mem_rcons).\nsmt(eq_exceptSm eq_except_sub mem_set).\nqed.\n\nlocal lemma ro_get_eq_except (X : query_t -> bool) :\n  equiv[LRO.get ~ LRO.get :\n    eq_except X LRO.m{1} LRO.m{2} /\\ ={arg} /\\ ! X arg{1} ==> ={res}\n  ].\nproof.\nproc.\nseq 1 1 : (#pre /\\ ={r}); 1: auto.\nif.\n+ smt(eq_except_notp_in).\n+ auto; smt(eq_except_set_eq).\nauto => /#.\nqed.\n\n(* This is for outline purposes only. *)\nlocal module RedO = {\n  proc get(q : query_t) : resp_t = {\n    var r0, r1 : chal_t;\n    r0 <@ RO.RO.get(q);\n    r1 <- r0;\n    r1 <@ Red_CMA_KOA(A).program(Red_CMA_KOA.q, r1);\n    return r1;\n  }\n}.\n\nlocal equiv lro_redo_equiv :\n  LRO.get ~ RedO.get :\n  ={arg} /\\ arg{2} = Red_CMA_KOA.q{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2} ==>\n  ={res} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}.\nproof.\nproc; inline.\nsp.\nseq 1 1 : (#pre /\\ ={r}); 1: auto.\nif {1}.\n+ rcondt {2} 1; 1: auto => /#.\n  rcondt {2} 6; 1: auto.\n  auto; smt(get_set_sameE eq_except_set_eq mem_set).\nrcondf {2} 6; 1: auto.\ncase (! signed Red_CMA_KOA.Simulator.signed{2} q{2}).\n+ rcondf {2} 1.\n  + auto; smt(eq_except_notp_in).\n  auto.\nauto => />.\nmove => &2 sup eq q_in q_signed _.\npose signed_qs := signed Red_CMA_KOA.Simulator.signed{2}.\nhave signed_U_pred1q : (predU signed_qs (pred1 Red_CMA_KOA.q{2})) = signed_qs by smt().\nsmt(eq_exceptmS mem_set).\nqed.\n\nlocal equiv lro_redo_inv :\n  LRO.get ~ RedO.get :\n  !Red_CMA_KOA.Simulator.bad{2} => ={arg} /\\ arg{2} = Red_CMA_KOA.q{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2} ==>\n  !Red_CMA_KOA.Simulator.bad{2} => ={res} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}.\nproof.\nproc *.\ncase (Red_CMA_KOA.Simulator.bad{2}).\n+ inline; auto.\ncall lro_redo_equiv.\nauto => /#.\nqed.\n\nlocal phoare simulator_bad_ll : [\n  Red_CMA_KOA(A).Simulator.sign : Red_CMA_KOA.Simulator.bad ==> Red_CMA_KOA.Simulator.bad\n] = 1%r.\nproof.\nproc.\nif; auto.\nsmt(dchal_ll dt_ll).\nqed.\n\nlocal lemma pr_koa_cma &m :\n  (* FIXME: This is likely a bug in the theory? LRO should not be specified twice? *)\n  Pr[EUF_CMA_ROM(LRO, Schnorr, FAdv_CMA_Runner(A), BoundedSO, LRO).main() @ &m : res] <=\n  Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : res] +\n  Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : Red_CMA_KOA.Simulator.bad].\nproof.\nbyequiv => //.\nproc.\ninline EUF_CMA EUF_KOA.\nswap{1} 6 -1.\nseq 4 3 : (!Red_CMA_KOA.Simulator.bad{2} =>\n  ={pk, m, sig} /\\ eq_except (signed O_CMA_Default.qs{1}) LRO.m{1} LRO.m{2}\n); first last.\n+ inline BoundedSO.\n  sp.\n  case (!is_fresh{1}).\n  + inline; auto.\n  case (Red_CMA_KOA.Simulator.bad{2}).\n  + inline; auto.\n  inline Schnorr.\n  wp.\n  exlim (O_CMA_Default.qs{1}) => qs.\n  call (ro_get_eq_except (signed qs)).\n  auto => /#.\ninline FAdv_CMA_Runner FAdv_KOA_Runner.\ninline Red_CMA_KOA -Red_CMA_KOA(A).program.\noutline {2} [18..20] ~ RedO.get.\nwp.\ncall (_ : Red_CMA_KOA.Simulator.bad,\n  O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n  g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n  LRO.m{1} = Red_CMA_KOA.m{2} /\\\n  overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n).\n+ move => SO; exact (A_finish_ll SO).\n+ conseq simulator_equiv => //.\n+ move => _ _; islossless.\n+ move => _; exact simulator_bad_ll.\ncall lro_redo_inv.\nwhile (\n  ={pk, c} /\\ q{2} = Red_CMA_KOA.q{2} /\\\n  (!Red_CMA_KOA.Simulator.bad{2} =>\n    g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n    ={glob A, q} /\\ O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2})\n).\n+ wp => /=.\n  outline {2} [1..3] ~ RedO.get.\n  call (_ : Red_CMA_KOA.Simulator.bad,\n    O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n    g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n  ).\n  + move => SO; exact (A_continue_ll SO).\n  + conseq simulator_equiv => //.\n  + move => _ _; islossless.\n  + move => _; exact simulator_bad_ll.\n  call lro_redo_inv.\n  auto => /#.\nwp.\ncall (_ : Red_CMA_KOA.Simulator.bad,\n  O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n  g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n  LRO.m{1} = Red_CMA_KOA.m{2} /\\\n  overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n).\n+ move => SO; exact (A_init_ll SO).\n+ conseq simulator_equiv => //.\n+ move => _ _; islossless.\n+ move => _; exact simulator_bad_ll.\ninline; auto => /#.\nqed.\n\nlocal lemma Red_CMA_KOA_rewindable :\n  exists (f : glob Red_CMA_KOA(A) -> state_t), injective f /\\\n  (forall &m, Pr[Red_CMA_KOA(A).getState() @ &m : (glob Red_CMA_KOA(A)) = (glob Red_CMA_KOA(A)){m} /\\ res = f (glob Red_CMA_KOA(A)){m}] = 1%r) /\\\n  (forall &m st (x: glob Red_CMA_KOA(A)), st = f x => Pr[Red_CMA_KOA(A).setState(st) @ &m : glob Red_CMA_KOA(A) = x] = 1%r) /\\\n  islossless Red_CMA_KOA(A).setState.\nproof.\n(* Red_CMA_KOA_rewindable *)\nexists (fun g => g.`5).\n+ by move => x y [].\n+ by move => &m; proc; auto.\n+ by move => &m st [x] <-; proc; auto.\n+ by islossless.\nqed.\n\n(* FIXME: Cannot do the following in the proof below?\n *   apply (A_continue_ll (Red_CMA_KOA(A).Simulator)). *)\nlocal module Sim = Red_CMA_KOA(A).Simulator.\n\n(* TODO: We could play with this a little bit more. *)\nlemma schnorr_cma_secure &m :\n  let pr_cma_succ = Pr[EUF_CMA_ROM(LRO, Schnorr, FAdv_CMA_Runner(A), BoundedSO, LRO).main() @ &m : res] in\n  pr_cma_succ >= QS%r * (QS + QR)%r / order%r =>\n  Pr[Exp_DL(RedAdv(Red_CMA_KOA(A))).main() @ &m : res] >=\n    (pr_cma_succ - QS%r * (QS + QR)%r / order%r) ^ 2 / (QR + 1)%r - 1%r / (size (to_seq (support dchal)))%r.\nproof.\npose pr_koa_succ := Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : res].\npose num_chal := (size (to_seq (support dchal)))%r.\nmove => pr_cma_succ pr_cma_succ_ge.\napply (ler_trans (pr_koa_succ ^ 2 / (QR + 1)%r - pr_koa_succ / num_chal)).\n+ apply ler_sub => //.\n  + apply ler_pmul => //.\n    + apply ge0_sqr.\n    + smt(invr_ge0 QR_pos).\n    apply ler_pexp => //.\n    smt(pr_koa_cma pr_bad_game).\n  apply ler_pmul => //.\n  + smt(ge0_mu).\n  + smt(invr_ge0 size_ge0).\n  smt(le1_mu).\napply (schnorr_koa_secure (Red_CMA_KOA(A))).\n+ exact Red_CMA_KOA_rewindable.\n+ islossless.\n  apply (A_continue_ll Sim).\n  islossless.\nislossless.\napply (A_finish_ll Sim).\nislossless.\nqed.\n\nend section SECURITY_EUF_CMA.", "```ec\nrequire import AllCore List IntDiv CoreMap FMap.\nfrom Jasmin import JWord.\nrequire (*---*) Schnorr.\nrequire (*---*) FAdv.\n(* Some auxiliary lemmas. *)\nlocal lemma mem_rcons (xs : 'a list) (x : 'a) y :\n  mem (rcons xs x) y <=> mem xs y \\/ y = x.\nproof. by rewrite -cats1 mem_cat. qed.\n\n(* q is not in the signed list. *)\nlocal lemma cats1 /=.\npose ms := Red_CMA_KOA.Simulator.signed{2}; pose m := q{2}.`3.\nhave signed_sub : predU (signed ms) (pred1 q{2}) <= signed (rcons ms m).\n+ rewrite /(<=) /predU /signed => q.\n  smt(mem_rcons).\nsmt(eq_exceptSm eq_except_sub mem_set).\nqed.\n\nlocal lemma ro_get_eq_except (X : query_t -> bool) :\n  equiv[LRO.get ~ LRO.get :\n    eq_except X LRO.m{1} LRO.m{2} /\\ ={arg} /\\ ! X arg{1} ==> ={res}\n  ].\nproof.\nproc.\nseq 1 1 : (#pre /\\ ={r}); 1: auto.\nif.\n+ smt(eq_except_notp_in).\n+ auto; smt(eq_except_set_eq).\nauto => /#.\nqed.\n\n(* This is for outline purposes only. *)\nlocal module RedO = {\n  proc get(q : query_t) : resp_t = {\n    var r0, r1 : chal_t;\n    r0 <@ RO.RO.get(q);\n    r1 <- r0;\n    r1 <@ Red_CMA_KOA(A).program(Red_CMA_KOA.q, r1);\n    return r1;\n  }\n}.\n\nlocal equiv lro_redo_equiv :\n  LRO.get ~ RedO.get :\n  ={arg} /\\ arg{2} = Red_CMA_KOA.q{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2} ==>\n  ={res} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}.\nproof.\nproc; inline.\nsp.\nseq 1 1 : (#pre /\\ ={r}); 1: auto.\nif {1}.\n+ rcondt {2} 1; 1: auto => /#.\n  rcondt {2} 6; 1: auto.\n  auto; smt(get_set_sameE eq_except_set_eq mem_set).\nrcondf {2} 6; 1: auto.\ncase (! signed Red_CMA_KOA.Simulator.signed{2} q{2}).\n+ rcondf {2} 1.\n  + auto; smt(eq_except_notp_in).\n  auto.\nauto => />.\nmove => &2 sup eq q_in q_signed _.\npose signed_qs := signed Red_CMA_KOA.Simulator.signed{2}.\nhave signed_U_pred1q : (predU signed_qs (pred1 Red_CMA_KOA.q{2})) = signed_qs by smt().\nsmt(eq_exceptmS mem_set).\nqed.\n\nlocal equiv lro_redo_inv :\n  LRO.get ~ RedO.get :\n  !Red_CMA_KOA.Simulator.bad{2} => ={arg} /\\ arg{2} = Red_CMA_KOA.q{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2} ==>\n  !Red_CMA_KOA.Simulator.bad{2} => ={res} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}.\nproof.\nproc *.\ncase (Red_CMA_KOA.Simulator.bad{2}).\n+ inline; auto.\ncall lro_redo_equiv.\nauto => /#.\nqed.\n\nlocal phoare simulator_bad_ll : [\n  Red_CMA_KOA(A).Simulator.sign : Red_CMA_KOA.Simulator.bad ==> Red_CMA_KOA.Simulator.bad\n] = 1%r.\nproof.\nproc.\nif; auto.\nsmt(dchal_ll dt_ll).\nqed.\n\nlocal lemma pr_koa_cma &m :\n  (* FIXME: This is likely a bug in the theory? LRO should not be specified twice? *)\n  Pr[EUF_CMA_ROM(LRO, Schnorr, FAdv_CMA_Runner(A), BoundedSO, LRO).main() @ &m : res] <=\n  Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : res] +\n  Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : Red_CMA_KOA.Simulator.bad].\nproof.\nbyequiv => //.\nproc.\ninline EUF_CMA EUF_KOA.\nswap{1} 6 -1.\nseq 4 3 : (!Red_CMA_KOA.Simulator.bad{2} =>\n  ={pk, m, sig} /\\ eq_except (signed O_CMA_Default.qs{1}) LRO.m{1} LRO.m{2}\n); first last.\n+ inline BoundedSO.\n  sp.\n  case (!is_fresh{1}).\n  + inline; auto.\n  case (Red_CMA_KOA.Simulator.bad{2}).\n  + inline; auto.\n  inline Schnorr.\n  wp.\n  exlim (O_CMA_Default.qs{1}) => qs.\n  call (ro_get_eq_except (signed qs)).\n  auto => /#.\ninline FAdv_CMA_Runner FAdv_KOA_Runner.\ninline Red_CMA_KOA -Red_CMA_KOA(A).program.\noutline {2} [18..20] ~ RedO.get.\nwp.\ncall (_ : Red_CMA_KOA.Simulator.bad,\n  O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n  g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n  LRO.m{1} = Red_CMA_KOA.m{2} /\\\n  overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n).\n+ move => SO; exact (A_finish_ll SO).\n+ conseq simulator_equiv => //.\n+ move => _ _; islossless.\n+ move => _; exact simulator_bad_ll.\ncall lro_redo_inv.\nwhile (\n  ={pk, c} /\\ q{2} = Red_CMA_KOA.q{2} /\\\n  (!Red_CMA_KOA.Simulator.bad{2} =>\n    g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n    ={glob A, q} /\\ O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2})\n).\n+ wp => /=.\n  outline {2} [1..3] ~ RedO.get.\n  call (_ : Red_CMA_KOA.Simulator.bad,\n    O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n    g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n    LRO.m{1} = Red_CMA_KOA.m{2} /\\\n    overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n  ).\n  + move => SO; exact (A_continue_ll SO).\n  + conseq simulator_equiv => //.\n  + move => _ _; islossless.\n  + move => _; exact simulator_bad_ll.\n  call lro_redo_inv.\n  auto => /#.\nwp.\ncall (_ : Red_CMA_KOA.Simulator.bad,\n  O_CMA_Default.qs{1} = Red_CMA_KOA.Simulator.signed{2} /\\\n  g ^ O_CMA_Default.sk{1} = Red_CMA_KOA.Simulator.pk{2} /\\\n  LRO.m{1} = Red_CMA_KOA.m{2} /\\\n  overlay LRO.m{2} Red_CMA_KOA.m{2} Red_CMA_KOA.Simulator.signed{2}\n).\n+ move => SO; exact (A_init_ll SO).\n+ conseq simulator_equiv => //.\n+ move => _ _; islossless.\n+ move => _; exact simulator_bad_ll.\ninline; auto => /#.\nqed.\n\nlocal lemma Red_CMA_KOA_rewindable :\n  exists (f : glob Red_CMA_KOA(A) -> state_t), injective f /\\\n  (forall &m, Pr[Red_CMA_KOA(A).getState() @ &m : (glob Red_CMA_KOA(A)) = (glob Red_CMA_KOA(A)){m} /\\ res = f (glob Red_CMA_KOA(A)){m}] = 1%r) /\\\n  (forall &m st (x: glob Red_CMA_KOA(A)), st = f x => Pr[Red_CMA_KOA(A).setState(st) @ &m : glob Red_CMA_KOA(A) = x] = 1%r) /\\\n  islossless Red_CMA_KOA(A).setState.\nproof.\n(* Red_CMA_KOA_rewindable *)\nexists (fun g => g.`5).\n+ by move => x y [].\n+ by move => &m; proc; auto.\n+ by move => &m st [x] <-; proc; auto.\n+ by islossless.\nqed.\n\n(* FIXME: Cannot do the following in the proof below?\n *   apply (A_continue_ll (Red_CMA_KOA(A).Simulator)). *)\nlocal module Sim = Red_CMA_KOA(A).Simulator.\n\n(* TODO: We could play with this a little bit more. *)\nlemma schnorr_cma_secure &m :\n  let pr_cma_succ = Pr[EUF_CMA_ROM(LRO, Schnorr, FAdv_CMA_Runner(A), BoundedSO, LRO).main() @ &m : res] in\n  pr_cma_succ >= QS%r * (QS + QR)%r / order%r =>\n  Pr[Exp_DL(RedAdv(Red_CMA_KOA(A))).main() @ &m : res] >=\n    (pr_cma_succ - QS%r * (QS + QR)%r / order%r) ^ 2 / (QR + 1)%r - 1%r / (size (to_seq (support dchal)))%r.\nproof.\npose pr_koa_succ := Pr[EUF_KOA_ROM(LRO, Schnorr, FAdv_KOA_Runner(Red_CMA_KOA(A))).main() @ &m : res].\npose num_chal := (size (to_seq (support dchal)))%r.\nmove => pr_cma_succ pr_cma_succ_ge.\napply (ler_trans (pr_koa_succ ^ 2 / (QR + 1)%r - pr_koa_succ / num_chal)).\n+ apply ler_sub => //.\n  + apply ler_pmul => //.\n    + apply ge0_sqr.\n    + smt(invr_ge0 QR_pos).\n    apply ler_pexp => //.\n    smt(pr_koa_cma pr_bad_game).\n  apply ler_pmul => //.\n  + smt(ge0_mu).\n  + smt(invr_ge0 size_ge0).\n  smt(le1_mu).\napply (schnorr_koa_secure (Red_CMA_KOA(A))).\n+ exact Red_CMA_KOA_rewindable.\n+ islossless.\n  apply (A_continue_ll Sim).\n  islossless.\nislossless.\napply (A_finish_ll Sim).\nislossless.\nqed.\n\nend section SECURITY_EUF_CMA.\n```"]], "EC-1/Sim1Equations.ec": [[false, "```ec\nrequire import AllCore List Int Real Distr Mu.\nrequire (*--*) StdOrder BigOp.\nrequire import DBool.\n\npragma +implicits.\n\n(* Types *)\ntype prob.\ntype wit.\ntype sbits.\ntype event.\n\n(* Operations *)\nop E : event -> sbits -> bool.\nop pair_sbits (s1 s2 : sbits) : sbits.\nop unpair : sbits -> sbits * sbits.\n\n(* Simulation Module *)\nmodule type Sim = {\n  proc run(p : prob) : sbits * bool\n}.\n\n(* Adversary Module *)\nmodule type Adv = {\n  proc distinguisher(w : sbits, p : prob) : bool\n}.\n\n(* Losslessness Axiom *)\naxiom losslessness (S <: Sim) p :\n  islossless S.run(p).\n\n(* Equivalence Axiom *)\naxiom distrib_eq (S1 S2 <: Sim) p :\n  islossless S1.run(p) =>\n  islossless S2.run(p) =>\n  (forall (x : sbits), Pr[S1.run(p) @ &m : res.`1 = x] = Pr[S2.run(p) @ &m : res.`1 = x]).\n\n(* W0 Module *)\nmodule W0(S : Sim, D : Adv) = {\n  module WI = S\n  proc run(p : prob, w : wit) : sbits * bool = {\n    var s, e;\n    (s, e) <- WI.run(p);\n    return (s, D.distinguisher(s, p));\n  }\n}.\n\n(* Iter Module *)\nmodule Iter(S : Sim, D : Adv) = {\n  module WI = S\n  proc run(f : event, p : prob, w : wit, ea : int, E : event -> sbits -> bool) : bool = {\n    var s, e, r, i;\n    i <- 0;\n    r <- false;\n    while (i < ea) {\n      (s, e) <- WI.run(p);\n      if (E e s) {\n        r <- D.distinguisher(s, p);\n      }\n      i <- i + 1;\n    }\n    return r;\n  }\n}.\n\n(* lemmas *)\nsection.\n\ndeclare module Sim1 <: Sim { D:Adv }.\ndeclare module D <: Adv { Sim1 }.\n\nlocal lemma Sim1_ll p : islossless Sim1.run(p).\nproof.\nby apply losslessness.\nqed.\n\nlocal lemma Sim1_rew_ph p :\n  equiv[Sim1.run ~ Sim1.run : ={p} ==> ={res}].\nproof.\nby proc; inline*; auto.\nqed.\n\nlocal lemma Estart (ev : event) s :\n  E ev s => mu (pred1 (s, true)) (dprod (d1 (size s)) (dbool)) = 1%r.\nproof.\nrewrite mu_dprodE; smt.\nqed.\n\nlocal lemma iter_run_rew_le (S <: Sim{Sim1_ll}) ll_p &m :\n  islossless S.run =>\n  (forall (p : prob), equiv[S.run ~ Sim1.run : ={p} ==> ={res}]) =>\n  forall (ev : event, p : prob, w : wit, ea : int),\n    0 <= ea =>\n    Pr[W(S).whp(ev, p, 1, ea, (ev, witness)) @ &m : ! ev] =\n    Pr[Iter(S, D).run(ev, p, w, ea, E) @ &m : ! E res.`2].\nproof.\nmove=> ?? ev p w ea ea_pos.\nbyequiv => //.\nproc*.\ninline Iter(S, D).run; sp; wp; inline Iter(S, D).WI.run; sp; wp.\ncall (_: ={glob S}).\nsim.\nskip; smt.\nqed.\n\nlocal lemma zk_almost_final &m p w ea :\n  0 <= ea =>\n  Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] =\n  Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2 /\\ res.`1] *\n  ((1%r - Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2]) ^ ea).\nproof.\nmove=> ea_pos; byphoare.\nproc; call D_ll; call Sim1_ll; auto; auto; auto.\nrewrite Pr[mu_split (E res.`2)].\nsimplify; rewrite -r; simplify; auto.\nhave ->: 1%r ^ ea = 1%r.\nsmt(@Real).\nhave : 0%r <= Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] <= 1%r.\nrewrite Pr[mu_le1]; rewrite Pr[mu_ge0]; auto.\nsmt().\nprogress.\nhave f : 0%r < Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nhave : Pr[MW.W0(Sim1, D).run(p, w) @ &m : E res.`2] >= 0%r.\nrewrite Pr[mu_ge0]; auto.\nsmt().\nhave ->: Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] ^ ea = 1%r - (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] ^ ea).\nsmt().\nrewrite -big_formula_p; rewrite Pr[mu_le1]; rewrite Pr[mu_ge0]; auto; progress.\nhave ->: (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2]) = Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nhave ->: 1%r = Pr[W0(Sim1, D).run(p, w) @ &m : true].\nbyphoare; proc; call D_ll; call Sim1_ll; auto; auto; auto.\nhave ->: Pr[W0(Sim1, D).run(p, w) @ &m : true] = Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] + Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nrewrite Pr[mu_split ! E res.`2]; simplify; auto; smt().\napply (zk_almost_final &m); auto.\nqed.\n\nlocal lemma pow_ler (a b : real) : 0%r <= a => 0%r <= b => forall n, 0 <= n => a <= b => a ^ n <= b ^ n.\nproof.\nmove=> ap bp; apply ge0ind; progress; smt(@Real); progress; smt(@Real); progress; rewrite exprS; auto; rewrite exprS; auto.\nhave f : forall (a b c d : real), 0%r <= a => 0%r <= b => 0%r <= c => 0%r <= d => a <= b => c <= d => a * c <= b * d.\nsmt().\napply f; auto; auto; smt(@RealExp); smt(@RealExp); auto; smt().\nqed.\n\nlocal lemma zk_final_le &m p w p0 eps ea zkp :\n  `|Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2 /\\ res.`1] / Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2] - zkp| <= eps =>\n  0 <= ea =>\n  0%r <= zkp <= 1%r =>\n  Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2] >= p0 =>\n  `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] - zkp| <= eps + (1%r - p0) ^ ea.\nproof.\nprogress.\nhave fff : p0 <= 1%r.\napply (ler_trans Pr[MW.W0(Sim1, D).run(p, w) @ &m : E res.`2]); auto; rewrite Pr[mu_le1]; auto.\nhave f1 : `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] - zkp| <= eps + (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) ^ ea.\nhave ->: (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) = (Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2]).\nhave ->: 1%r = Pr[W0(Sim1, D).run(p, w) @ &m : true].\nbyphoare; proc; call D_ll; call Sim1_ll; auto; auto; auto.\nhave ->: Pr[W0(Sim1, D).run(p, w) @ &m : true] = Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] + Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nrewrite Pr[mu_split E res.`2]; simplify; auto; smt().\napply (zk_final &m).\nhave f2 : (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) <= (1%r - p0).\nsmt().\nhave f3 : (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) ^ ea <= (1%r - p0) ^ ea.\napply multn2; auto; split.\nhave : Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2] <= 1%r.\nrewrite Pr[mu_le1]; auto.\nsmt(); smt(); auto; auto; auto.\napply (ler_trans (eps + (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) ^ ea)); auto.\nhave : (1%r - Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2]) <= (1%r - p0).\nsmt().\nprogress.\nhave : (1%r - Pr[MW.W0(Sim1, D).run(p, w) @ &m : E res.`2]) ^ ea <= (1%r - p0) ^ ea.\napply pow_ler.\nhave : Pr[MW.W0(Sim1, D).run(p, w) @ &m : E res.`2] <= 1%r.\nrewrite Pr[mu_le1]; auto.\nsmt(); smt(); auto; auto; smt().\nqed.\n\nlocal lemma dbound (a a' d zkp eps : real) :\n  0%r <= a' <= a =>\n  a - a' <= d =>\n  `|a' - zkp| <= eps =>\n  `|a - zkp| <= eps + d.\nproof.\nsmt().\nqed.\n\nlocal lemma zk_final_clean' &m p w p0 eps ea zkp :\n  `|Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2 /\\ res.`1] / Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2] - zkp| <= eps =>\n  0 <= ea =>\n  0%r <= zkp <= 1%r =>\n  p0 <= Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2] =>\n  `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1] - zkp| <= eps + 2%r * (1%r - p0) ^ ea.\nproof.\nprogress.\nhave bf : `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1] - zkp| <= (eps + (1%r - p0) ^ ea) + (Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : ! E res.`2]).\nhave f1 : `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] - zkp| <= eps + (1%r - p0) ^ ea.\napply (zk_final_le &m p w p0 eps ea zkp); auto.\napply (dbound Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1] Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1]).\nrewrite Pr[mu_ge0]; simplify; rewrite Pr[mu_sub]; auto; auto.\nrewrite Pr[mu_split E res.`2].\nhave ->: Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1 /\\ E res.`2] = Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1].\nrewrite Pr[mu_eq]; auto; auto.\nhave ->: Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1 /\\ ! E res.`2] = Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : ! E res.`2 /\\ res.`1].\nrewrite Pr[mu_eq]; auto; auto.\nhave arthf : forall (a b : real), a + b - a = b.\nsmt().\nrewrite (arthf Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : E res.`2 /\\ res.`1] Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : ! E res.`2 /\\ res.`1]).\nrewrite Pr[mu_sub]; auto; auto.\nauto.\nclear H.\nhave bf2 : Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : ! E res.`2] <= (1%r - p0) ^ ea.\nhave bf3 : Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] <= 1%r - p0.\nhave ->: 1%r = Pr[W0(Sim1, D).run(p, w) @ &m : true].\nbyphoare; proc; call D_ll; call Sim1_ll; auto; auto; auto.\nhave : Pr[W0(Sim1, D).run(p, w) @ &m : true] - Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2] = Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nrewrite Pr[mu_split E res.`2]; simplify; smt(); smt().\nhave ->: Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : ! E res.`2] = Pr[W(Sim1).whp(E, (p), 1, ea, (fevent, witness)) @ &m : ! E res].\nbyequiv; proc*; inline Iter(Sim1, D).run; sp; wp; inline Iter(Sim1, D).WI.run; sp; wp; call {1} D_ll; conseq (_: _ ==> r1{1} = r0{2}).\nsmt().\ncall (_: ={glob Sim1}); sim; skip; progress; auto; auto.\napply (iter_run_rew_le (Sim1) Sim1_ll _ &m); apply Sim1_rew_ph; apply Estart; auto.\nhave ->: Pr[Sim1.run(p) @ &m : ! E res] = Pr[W0(Sim1, D).run(p, w) @ &m : ! E res.`2].\nbyequiv; proc*; inline*; wp; sp; call {2} D_ll; call (_: true); skip; smt(); auto; auto; auto; smt().\nqed.\n\nlemma one_to_many_zk &m p w p0 eps ea zkp :\n  `|Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2 /\\ res.`1] / Pr[Sim1.run(p) @ &m : E res] - zkp| <= eps =>\n  0 <= ea =>\n  0%r <= zkp <= 1%r =>\n  p0 <= Pr[Sim1.run(p) @ &m : E res] =>\n  `|Pr[Iter(Sim1, D).run(fevent, p, w, ea, E) @ &m : res.`1] - zkp| <= eps + 2%r * (1%r - p0) ^ ea.\nproof.\nhave ->: Pr[Sim1.run(p) @ &m : E res] = Pr[W0(Sim1, D).run(p, w) @ &m : E res.`2].\nbyequiv; proc*; inline*; wp; sp; call {2} D_ll; call (_: true); skip; progress; auto; auto; auto.\nprogress; smt(); auto"]], "EC-1/ske.ec": [[false, "```houzhui\nrequire import AllCore List DBool FMap.\n\nabstract theory SKE.\n\ntype key.\ntype plaintext.\ntype ciphertext.\n\nmodule type SKE = {\n  proc init(): unit {}\n  proc kg(): key\n  proc enc(k:key,p:plaintext): ciphertext \n  proc dec(k:key,c:ciphertext): plaintext option\n}.\n\nmodule Correctness (S:SKE) = {\n  proc main (p:plaintext) = {\n    var k, c, q;\n    S.init();\n    k <@ S.kg();\n    c <@ S.enc(k,p);\n    q <@ S.dec(k,c);\n    return q = Some p;\n  } \n}.\n\nend SKE.\n\nabstract theory SKE_RND.\n\nclone include SKE.\n\nmodule type Oracles = {\n  proc init() : unit\n  proc enc(p:plaintext): ciphertext \n  proc dec(c:ciphertext): plaintext option\n}.\n\nmodule type CCA_Oracles = {\n  include Oracles"]], "EC-1/SquareConvex.ec": [[true, "require import Distr.\nrequire import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete.\nrequire import RealFun RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nsection.\n\nop square (x : real) : real = x ^ 2.\n\n\n(* basics *)\nlocal lemma iji : forall d, 0%r <= d => d <= 1%r => d - 1%r <= 0%r.\nmove => d p1 p2. smt(). qed.\n\nlocal lemma iyi : forall d a, d <= 0%r => a >= 0%r  => d * a <= 0%r.\nmove => d p1 p2. smt(). qed.\n\nlocal lemma sq_lemma1p : forall (a b : real), (a + b)^2 = a^2 + 2%r*a*b + b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma1m : forall (a b : real), (a - b)^2 = a^2 - 2%r*a*b + b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma2 : forall (a b : real), (a * b)^2 = a^2 * b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma5 : 1%r ^ 2 = 1%r.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma6 : forall (a b c : real) , a - (b - c) = a - b + c.\nsmt(). qed.\n\nlocal lemma sq_lemma7 : forall (a b c : real) , a + (b - c) = a + b - c.\nby smt(). qed.\n\nlocal lemma sq_lemma8 : forall (a b c : real), a * (b * c) = a * b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma9 : forall (a b c : real) , a + (b + c) = a + b + c.\nby smt(). qed.\n\nlocal lemma sq_lemma10 : forall (a b c d : real), a * (b -c + d) = a*b -a*c + a *d .\nby smt(). qed.\n\nlocal lemma sq_lemma11 : forall (a : real), a * a = a^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma3 : forall (a b c : real), (a - b) * c = a*c - b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma3' : forall (c a b : real), c * (a - b) = a*c - b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma4 : forall (a b c : real), (a + b) * c = a*c + b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma4' : forall (a b c : real), c * (a + b) = a*c + b * c.\nby smt(). qed.\n\nlocal lemma sq_lemmapos : forall (a : real), a^2 >= 0%r. \nsmt(@Real). qed.\n    \n(* smt(@Real sq_lemma4' sq_lemma4 sq_lemma3 sq_lemma3' sq_lemma11 sq_lemma10 sq_lemma9 sq_lemma8 sq_lemma7 sq_lemma6 sq_lemma5 sq_lemma2 sq_lemma1p sq_lemma1m) *)\nlemma square_convex : forall (a b : real), convex square a b.\nmove => a b.\nsimplify convex. move => d p1.\nsimplify square.\npose z := (1%r - d).\nhave : z <= 1%r.\nsmt().\nmove => zp.\nhave s1 : (d * a + z * b) ^ 2 = (d * a)^2 \n          + 2%r * (d * a) * (z * b) + (z * b)^2. smt(sq_lemma1p sq_lemma1m). rewrite s1.\nhave s2 : (d * a)^2  + 2%r * (d * a) * (z * b) + (z * b)^2 \n          = d^2 * a^2  + 2%r * (d * a) * (z * b) + z^2 * b^2. \nsmt (sq_lemma2). rewrite s2.\nhave  eqts : d ^ 2 * a ^ 2 + 2%r * (d * a) * (z * b) \n            + z ^ 2 * b ^ 2 - d * a ^ 2 - z * b ^ 2 <= 0%r.\nhave ze : z = 1%r - d. smt(). rewrite ze.\nrewrite (sq_lemma1m (1%r) d).\nsimplify.\nrewrite (sq_lemma3 1%r d (b ^ 2)).\nsimplify.\nrewrite (sq_lemma3 1%r d b). simplify.\nrewrite sq_lemma5.\nrewrite (sq_lemma4 (1%r - 2%r * d) (d^2) (b^2)). simplify.          \nrewrite (sq_lemma3' (2%r * (d * a)) b  (d *b)).\nrewrite (sq_lemma3 1%r ((2%r) * d) (b^2)).\nsimplify.\nrewrite (sq_lemma6 ((d ^ 2) * a ^ 2 + (b * (2%r * (d * a)) \n          - d * b * (2%r * (d * a))) + (b ^ 2 - 2%r * d * b ^ 2 + d ^ 2 * b ^ 2) \n          - d * a ^ 2) (b ^ 2) (d * b ^ 2)).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2) (b * (2%r * (d * a))) \n                   (d * b * (2%r * (d * a)))). \nrewrite (sq_lemma8 2%r d a).\nrewrite (sq_lemma8 (d*b) (2%r * d) a).\nrewrite (sq_lemma8 (d*b) 2%r d).\nrewrite (sq_lemma8 b (2%r * d) a).\nrewrite (sq_lemma8 b 2%r d).\nrewrite (sq_lemma9 (d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a) \n                   (b ^ 2 - 2%r * d * b ^ 2) (d ^ 2 * b ^ 2)).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a) \n           (b ^ 2)  (2%r * d * b ^ 2)).\nhave me : d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n           + b ^ 2 - 2%r * d * b ^ 2 + d ^ 2 * b ^ 2 - d * a ^ 2 - b ^ 2 \n           + d * b ^ 2 \n            = d ^ 2 * a ^ 2 + b * 2%r * d * a \n              - d * b * 2%r * d * a - 2%r * d * b ^ 2 \n              + d ^ 2 * b ^ 2 - d * a ^ 2 + d * b ^ 2.\nsmt (sq_lemma1p sq_lemma1m sq_lemma2 sq_lemma3 sq_lemma3' \n     sq_lemma4 sq_lemma4' sq_lemma5 sq_lemma6 sq_lemma7 \n     sq_lemma8 sq_lemma9).\nrewrite me.\nhave me2 : d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n           - 2%r * d * b ^ 2 +\n             d ^ 2 * b ^ 2 - d * a ^ 2 + d * b ^ 2 \n          = d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n            - d * b ^ 2 + d ^ 2 * b ^ 2 - d * a ^ 2.\nsmt().\nrewrite me2.\nhave me3 : d * (d - 1%r) * (a - b)^2 = d ^ 2 * a ^ 2 \n               + b * 2%r * d * a - d * b * 2%r * d * a - d * b ^ 2 \n               + d ^ 2 * b ^ 2 - d * a ^ 2.\nrewrite (sq_lemma1m a b).\nrewrite (sq_lemma3' d d 1%r).\nrewrite (sq_lemma10 (d * d - 1%r * d) (a ^ 2) (2%r * a * b) (b ^ 2)). simplify.\nrewrite (sq_lemma3 (d * d) d (a ^2)). rewrite (sq_lemma3 (d * d) d (b ^2)).\nrewrite (sq_lemma3 (d * d) d (2%r * a * b)).\nrewrite (sq_lemma11 d).\nrewrite (sq_lemma6 (d ^ 2 * a ^ 2 - d * a ^ 2) (d ^ 2 * (2%r * a * b)) \n                   (d * (2%r * a * b))).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2 - d * a ^ 2 - d ^ 2 * (2%r * a * b) \n                     + d * (2%r * a * b)) (d ^ 2 * b ^ 2) (d * b ^ 2)).\nhave : d ^ 2 * (2%r * a * b)  =  d * b * 2%r * d * a. \nrewrite - (sq_lemma11 d). smt().\nmove => q. rewrite q.\nhave : d * (2%r * a * b) =  b * 2%r * d * a. smt().\nmove => qq. rewrite qq. smt().\nrewrite - me3.  \nhave : d * (d - 1%r) * (a - b) ^ 2 = (d - 1%r) * (d * (a - b) ^ 2). smt().\nmove => wo. rewrite wo.\nhave ko : (d-1%r) <= 0%r. clear me me2 me3  wo ze s2 s1 zp. smt().\nhave ok : ((a - b) ^ 2) >= 0%r. smt(sq_lemmapos).\nhave okk : (d * (a - b) ^ 2) >= 0%r. smt().\nsmt(). smt().\nqed.\n\n\nend section.", "To complete the given code and ensure it compiles successfully with EasyCrypt, we need to fill in the missing parts indicated by `____(OP_1)____`, `____(OP_0)____`, `____(LEMMA_1)____`, and `____(LEMMA_0)____`.\n\n1. **`____(OP_1)____`**: This is the type of the operand for the `square` operation. Since `square` is defined to compute the square of a real number, the type should be `real`.\n\n2. **`____(OP_0)____`**: This is the exponent to which `x` is raised in the `square` operation. Since it's squaring, the exponent should be `2`.\n\n3. **`____(LEMMA_1)____`**: This is related to the variables involved in the `convex` property being proven. The lemma `square_convex` is proving convexity for the `square` function over real numbers, so the variables should be of type `real`.\n\n4. **`____(LEMMA_0)____`**: This pertains to the property or function for which convexity is being established. Here, it's the `square` function.\n\nGiven the above analysis, the code should be completed as follows:\n\n```ec\nrequire import Distr.\nrequire import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete.\nrequire import RealFun RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nsection.\n\nop square (x : real) : real = x ^ 2.\n\n\n(* basics *)\nlocal lemma iji : forall d, 0%r <= d => d <= 1%r => d - 1%r <= 0%r.\nmove => d p1 p2. smt(). qed.\n\nlocal lemma iyi : forall d a, d <= 0%r => a >= 0%r  => d * a <= 0%r.\nmove => d p1 p2. smt(). qed.\n\nlocal lemma sq_lemma1p : forall (a b : real), (a + b)^2 = a^2 + 2%r*a*b + b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma1m : forall (a b : real), (a - b)^2 = a^2 - 2%r*a*b + b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma2 : forall (a b : real), (a * b)^2 = a^2 * b^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma5 : 1%r ^ 2 = 1%r.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma6 : forall (a b c : real) , a - (b - c) = a - b + c.\nsmt(). qed.\n\nlocal lemma sq_lemma7 : forall (a b c : real) , a + (b - c) = a + b - c.\nby smt(). qed.\n\nlocal lemma sq_lemma8 : forall (a b c : real), a * (b * c) = a * b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma9 : forall (a b c : real) , a + (b + c) = a + b + c.\nby smt(). qed.\n\nlocal lemma sq_lemma10 : forall (a b c d : real), a * (b -c + d) = a*b -a*c + a *d .\nby smt(). qed.\n\nlocal lemma sq_lemma11 : forall (a : real), a * a = a^2.\nby smt(@Real). qed.\n\nlocal lemma sq_lemma3 : forall (a b c : real), (a - b) * c = a*c - b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma3' : forall (c a b : real), c * (a - b) = a*c - b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma4 : forall (a b c : real), (a + b) * c = a*c + b * c.\nby smt(). qed.\n\nlocal lemma sq_lemma4' : forall (a b c : real), c * (a + b) = a*c + b * c.\nby smt(). qed.\n\nlocal lemma sq_lemmapos : forall (a : real), a^2 >= 0%r. \nsmt(@Real). qed.\n    \n(* smt(@Real sq_lemma4' sq_lemma4 sq_lemma3 sq_lemma3' sq_lemma11 sq_lemma10 sq_lemma9 sq_lemma8 sq_lemma7 sq_lemma6 sq_lemma5 sq_lemma2 sq_lemma1p sq_lemma1m) *)\nlemma square_convex : forall (a b : real), convex square a b.\nmove => a b.\nsimplify convex. move => d p1.\nsimplify square.\npose z := (1%r - d).\nhave : z <= 1%r.\nsmt().\nmove => zp.\nhave s1 : (d * a + z * b) ^ 2 = (d * a)^2 \n          + 2%r * (d * a) * (z * b) + (z * b)^2. smt(sq_lemma1p sq_lemma1m). rewrite s1.\nhave s2 : (d * a)^2  + 2%r * (d * a) * (z * b) + (z * b)^2 \n          = d^2 * a^2  + 2%r * (d * a) * (z * b) + z^2 * b^2. \nsmt (sq_lemma2). rewrite s2.\nhave  eqts : d ^ 2 * a ^ 2 + 2%r * (d * a) * (z * b) \n            + z ^ 2 * b ^ 2 - d * a ^ 2 - z * b ^ 2 <= 0%r.\nhave ze : z = 1%r - d. smt(). rewrite ze.\nrewrite (sq_lemma1m (1%r) d).\nsimplify.\nrewrite (sq_lemma3 1%r d (b ^ 2)).\nsimplify.\nrewrite (sq_lemma3 1%r d b). simplify.\nrewrite sq_lemma5.\nrewrite (sq_lemma4 (1%r - 2%r * d) (d^2) (b^2)). simplify.          \nrewrite (sq_lemma3' (2%r * (d * a)) b  (d *b)).\nrewrite (sq_lemma3 1%r ((2%r) * d) (b^2)).\nsimplify.\nrewrite (sq_lemma6 ((d ^ 2) * a ^ 2 + (b * (2%r * (d * a)) \n          - d * b * (2%r * (d * a))) + (b ^ 2 - 2%r * d * b ^ 2 + d ^ 2 * b ^ 2) \n          - d * a ^ 2) (b ^ 2) (d * b ^ 2)).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2) (b * (2%r * (d * a))) \n                   (d * b * (2%r * (d * a)))). \nrewrite (sq_lemma8 2%r d a).\nrewrite (sq_lemma8 (d*b) (2%r * d) a).\nrewrite (sq_lemma8 (d*b) 2%r d).\nrewrite (sq_lemma8 b (2%r * d) a).\nrewrite (sq_lemma8 b 2%r d).\nrewrite (sq_lemma9 (d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a) \n                   (b ^ 2 - 2%r * d * b ^ 2) (d ^ 2 * b ^ 2)).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a) \n           (b ^ 2)  (2%r * d * b ^ 2)).\nhave me : d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n           + b ^ 2 - 2%r * d * b ^ 2 + d ^ 2 * b ^ 2 - d * a ^ 2 - b ^ 2 \n           + d * b ^ 2 \n            = d ^ 2 * a ^ 2 + b * 2%r * d * a \n              - d * b * 2%r * d * a - 2%r * d * b ^ 2 \n              + d ^ 2 * b ^ 2 - d * a ^ 2 + d * b ^ 2.\nsmt (sq_lemma1p sq_lemma1m sq_lemma2 sq_lemma3 sq_lemma3' \n     sq_lemma4 sq_lemma4' sq_lemma5 sq_lemma6 sq_lemma7 \n     sq_lemma8 sq_lemma9).\nrewrite me.\nhave me2 : d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n           - 2%r * d * b ^ 2 +\n             d ^ 2 * b ^ 2 - d * a ^ 2 + d * b ^ 2 \n          = d ^ 2 * a ^ 2 + b * 2%r * d * a - d * b * 2%r * d * a \n            - d * b ^ 2 + d ^ 2 * b ^ 2 - d * a ^ 2.\nsmt().\nrewrite me2.\nhave me3 : d * (d - 1%r) * (a - b)^2 = d ^ 2 * a ^ 2 \n               + b * 2%r * d * a - d * b * 2%r * d * a - d * b ^ 2 \n               + d ^ 2 * b ^ 2 - d * a ^ 2.\nrewrite (sq_lemma1m a b).\nrewrite (sq_lemma3' d d 1%r).\nrewrite (sq_lemma10 (d * d - 1%r * d) (a ^ 2) (2%r * a * b) (b ^ 2)). simplify.\nrewrite (sq_lemma3 (d * d) d (a ^2)). rewrite (sq_lemma3 (d * d) d (b ^2)).\nrewrite (sq_lemma3 (d * d) d (2%r * a * b)).\nrewrite (sq_lemma11 d).\nrewrite (sq_lemma6 (d ^ 2 * a ^ 2 - d * a ^ 2) (d ^ 2 * (2%r * a * b)) \n                   (d * (2%r * a * b))).\nrewrite (sq_lemma7 (d ^ 2 * a ^ 2 - d * a ^ 2 - d ^ 2 * (2%r * a * b) \n                     + d * (2%r * a * b)) (d ^ 2 * b ^ 2) (d * b ^ 2)).\nhave : d ^ 2 * (2%r * a * b)  =  d * b * 2%r * d * a. \nrewrite - (sq_lemma11 d). smt().\nmove => q. rewrite q.\nhave : d * (2%r * a * b) =  b * 2%r * d * a. smt().\nmove => qq. rewrite qq. smt().\nrewrite - me3.  \nhave : d * (d - 1%r) * (a - b) ^ 2 = (d - 1%r) * (d * (a - b) ^ 2). smt().\nmove => wo. rewrite wo.\nhave ko : (d-1%r) <= 0%r. clear me me2 me3  wo ze s2 s1 zp. smt().\nhave ok : ((a - b) ^ 2) >= 0%r. smt(sq_lemmapos).\nhave okk : (d * (a - b) ^ 2) >= 0%r. smt().\nsmt(). smt().\nqed.\n\n\nend section.\n```"]], "EC-1/SurjFromInj.ec": [[true, "require import AllCore List.\n\nabstract theory SurjFromInj.\ntype a.\ntype b.\n\nop alist : a list.\nop blist : b list.\n\nop f : a -> b.\n\nsection.\ndeclare axiom alist_uniq : uniq alist.\ndeclare axiom blist_uniq : uniq blist.\ndeclare axiom alist_blist_size : size alist = size blist.\ndeclare axiom alist_full a : a \\in alist.\ndeclare axiom blist_full b : b \\in blist.\ndeclare axiom f_inj : injective f.\n\nlemma f_surj : surjective f.\nrewrite /surjective.\npose fmaped := map f alist.\nhave claim1 : size fmaped = size blist. smt(@List alist_blist_size).\nhave claim2 : uniq fmaped. rewrite /fmaped.\n apply map_inj_in_uniq. smt(f_inj). apply alist_uniq.\nhave claim3 : forall b, b \\in fmaped. \n  have : (exists y, !(y \\in fmaped )) => false. \n  elim. move => y h.\n  have f1 : uniq (y :: fmaped).  smt(@List).\n  have f2 : size (y :: fmaped) = size blist + 1. simplify. smt().\n  have : size (y :: fmaped) <= size blist.\n  apply uniq_leq_size. auto.\n  smt(blist_full).\n  smt().  \n  smt().\nmove => x. \nhave z : x \\in map f alist. smt().\nsmt(@List).\nqed.\n\nend section.\nend SurjFromInj.", "To complete the provided EasyCrypt file based on the given description, we need to fill in the missing parts indicated by `____(identifier)____`. Let's analyze the given description and the code to determine the correct completions.\n\n1. **Type `a`**:\n   - The description mentions an abstract type `a`. Thus, `____(TYPE_0)____` should be `a`.\n\n2. **`blist` type**:\n   - `blist` is described as a list of elements of type `b`. Hence, `____(OP_0)____` should be `b`.\n\n3. **`alist_full` axiom**:\n   - The axiom `alist_full` is stated to guarantee that every element `a` is in `alist`. This implies `____(DECLARE_0)____` should be `\\in`.\n\n4. **`f_surj` lemma**:\n   - The lemma `f_surj` asserts that `f` is surjective. The description and the proof structure suggest that `____(LEMMA_0)____` should be `f`.\n\nBased on the analysis, the completed EasyCrypt file should be as follows:\n\n```ec\nrequire import AllCore List.\n\nabstract theory SurjFromInj.\ntype a.\ntype b.\n\nop alist : a list.\nop blist : b list.\n\nop f : a -> b.\n\nsection.\ndeclare axiom alist_uniq : uniq alist.\ndeclare axiom blist_uniq : uniq blist.\ndeclare axiom alist_blist_size : size alist = size blist.\ndeclare axiom alist_full a : a \\in alist.\ndeclare axiom blist_full b : b \\in blist.\ndeclare axiom f_inj : injective f.\n\nlemma f_surj : surjective f.\nrewrite /surjective.\npose fmaped := map f alist.\nhave claim1 : size fmaped = size blist. smt(@List alist_blist_size).\nhave claim2 : uniq fmaped. rewrite /fmaped.\n apply map_inj_in_uniq. smt(f_inj). apply alist_uniq.\nhave claim3 : forall b, b \\in fmaped. \n  have : (exists y, !(y \\in fmaped )) => false. \n  elim. move => y h.\n  have f1 : uniq (y :: fmaped).  smt(@List).\n  have f2 : size (y :: fmaped) = size blist + 1. simplify. smt().\n  have : size (y :: fmaped) <= size blist.\n  apply uniq_leq_size. auto.\n  smt(blist_full).\n  smt().  \n  smt().\nmove => x. \nhave z : x \\in map f alist. smt().\nsmt(@List).\nqed.\n\nend section.\nend SurjFromInj.\n```\n\nThis completed version should compile successfully with EasyCrypt."]], "EC-1/trapdoor.ec": [[false, "```ec\no !rnd; wp; skip; progress => //; smt.\nqed.\n\nlocal lemma Pr8_aux &m :\n  Pr"]], "EC-1/UniformSampling_Concrete.ec": [[true, "p W64xN.valR (to_seq (support jsmD))). \nrewrite size_map. auto.\n have ->: size (map W64xN.valR (to_seq (support jsmD))) = size (to_seq (support D)). \napply qq.  \nrewrite map_inj_in_uniq. progress. clear H H0. smt(@W64xN).\napply uniq_to_seq. smt(@Distr jsmdD_uni).\napply uniq_to_seq. smt(@Distr jsmdD_uni).\nprogress. \nhave : exists z, z \\in (to_seq (support jsmD)) /\\ W64xN.valR z = x. smt(@List).\nprogress. \nhave mf : 0 <= (W64xN.valR z) < W64xN.modulusR. smt(@W64xN). \nrewrite /D.\nhave mf2 : W64xN.valR z \\in (range 0 W64xN.modulusR). smt(@List).\nhave mf3 : W64xN.valR z \\in duniform (range 0 W64xN.modulusR). smt(@Distr).\nsmt(@Distr @Finite).\nrewrite ioo.\nexists (W64xN.R.bn_ofint x). split. \nhave mf3 :   (W64xN.R.bn_ofint x)\\in jsmD.\napply (jsmdD_fu (W64xN.R.bn_ofint x)). \napply mem_to_seq.  smt(@Distr jsmdD_uni).\nauto.    \nrewrite W64xN.R.bn_ofintK.\nhave mf2 :  x \\in D. smt(@Distr @Finite).\nhave mf3 : 0 <= x < W64xN.modulusR. smt(@Distr).\nsmt(@IntDiv).\nauto.\nqed.\n\n\nlemma lemma2 : \n  equiv [SampleLoc.jsmD ~ SampleLoc.sampleInt : true ==> W64xN.valR res{1} = res{2} ].\nproc. \nrnd W64xN.valR W64xN.R.bn_ofint.\nskip. progress.\nrewrite W64xN.R.bn_ofintK. \nhave rval : 0 <= rR  < W64xN.modulusR. smt(@Distr @List).\nsmt(@Int).\nhave rval : 0 <= rR  < W64xN.modulusR. smt(@Distr @List).\nhave ->: mu1 D rR = 1%r / W64xN.modulusR%r.\nrewrite /D. smt(@Distr @List).\nrewrite mu1_uni. apply jsmdD_uni.\nhave -> : (W64xN.R.bn_ofint rR)%W64xN.R \\in jsmD = true.\nsmt(jsmdD_fu).  \nsimplify.\nhave ->: weight jsmD = 1%r. \nsmt(jsmdD_ll @Distr).\nrewrite jsmd_supp.\nsmt(@Distr).\nhave rval : 0 <= W64xN.valR rL  < W64xN.modulusR. smt(@W64xN).\nsmt(@Distr).\nsmt(@W64xN).\nqed.    \n\n\nmodule WW = {\n  proc rsample(byte_z : W64.t Array32.t) : int * W64.t Array32.t = {\n    var aux : W8.t Array256.t;\n    var i : int;\n    var byte_p : W64.t Array32.t;\n    var cf : bool;\n    var byte_q : W64.t Array32.t;\n    var _0 : bool;\n    var _1 : bool;\n    var _2 : bool;\n    var _3 : bool;\n    var _4 : W64.t;\n    \n    byte_p <- witness;\n    byte_q <- witness;\n    i <- 0;\n    byte_p <@ M(Syscall).bn_set0(byte_p);\n    (_0, cf, _1, _2, _3, _4) <- set0_64;\n    while (!cf){\n      byte_p <@ SampleLoc.sample((init\n                              (fun (i_0 : int) =>\n                                 get8\n                                   (init64\n                                      (fun (i_0_0 : int) => byte_p.[i_0_0])%Array32)\n                                   i_0))%Array256);\n      byte_q <@ M(Syscall).bn_copy(byte_p);\n      (cf, byte_q) <@ M(Syscall).bn_subc(byte_q, byte_z);\n      i <- i + 1;\n    }   \n    return (i, byte_p);\n  }\n\n  proc rsample0(byte_z : W64.t Array32.t) : int * W64.t Array32.t = {\n    var aux : W8.t Array256.t;\n    var i : int;\n    var byte_p : W64.t Array32.t;\n    var cf : bool;\n    var byte_q : W64.t Array32.t;\n    var _0 : bool;\n    var _1 : bool;\n    var _2 : bool;\n    var _3 : bool;\n    var _4 : W64.t;\n    \n    byte_p <- witness;\n    byte_q <- witness;\n    i <- 0;\n    byte_p <@ M(Syscall).bn_set0(byte_p);\n    (_0, cf, _1, _2, _3, _4) <- set0_64;\n    while (!cf){\n      byte_p <@ SampleLoc.jsmD();\n      byte_q <@ M(Syscall).bn_copy(byte_p);\n      (cf, byte_q) <@ M(Syscall).bn_subc(byte_q, byte_z);\n      i <- i + 1;\n    }   \n    return (i, byte_p);\n  }\n\n  proc rsample2(a : int) : int * int = {\n    var x : int;\n    var b : bool;\n    var i : int;\n    var z : int;\n    \n    x <- 0;\n    b <- true;\n    i <- 0;\n    while (b){\n      x <@ SampleLoc.sampleInt();\n      (b, z) <@ ASpecFp.subn(x, a);\n      b <- !b;\n      i <- i + 1;\n    }\n    \n    return (i, x);\n  }\n\n}.\n\nrequire import BigNum_proofs.\nequiv rsample_cspec:\n M.bn_rsample ~ CSpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1.\n  transitivity WW.rsample\n   (={arg} ==> ={res})\n   (  W64xN.valR byte_z{1} = a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1).\nsmt(). smt().\nproc.  inline SampleLoc.sample. wp. sp. \nwhile (={i,cf,byte_p,byte_q,byte_z}). sim. wp. call (_:true).\nsim. wp. skip. progress.\nwp.  call (_:true). sim. skip. progress.\nsymmetry.\ntransitivity \n   WW.rsample2\n   (={arg} ==> ={res})\n   (ImplZZ arg{2} arg{1} ==> ImplZZ res{2}.`2 res{1}.`2 /\\ res{2}.`1 = res{1}.`1).\nsmt(). smt().\nproc. inline SampleLoc.sampleInt. sim.\nsymmetry.\ntransitivity \n   WW.rsample0\n   (={arg} ==> ={res})\n   (ImplZZ arg{1} arg{2} ==> ImplZZ res{1}.`2 res{2}.`2 /\\ res{2}.`1 = res{1}.`1).\nsmt(). smt().\nproc. \nwhile (={i,cf,byte_p,byte_q,byte_z}). sim. wp. \ncall lemma1. skip. auto.\nwp. call (_:true). sim. wp. skip. auto.\nproc. wp.\n  while (={i} /\\ !cf{1} = b{2} /\\ ImplZZ byte_p{1}  x{2} /\\ W64xN.valR  byte_z{1} = a{2}). wp.\ncall  subc_spec. wp. ecall {1} (bn_copy_correct byte_p{1}).\nwp. \ncall lemma2. skip. progress. smt(). smt(). smt().\nwp. \ncall {1} (bn_set0_correct). wp. skip. progress.\nqed.\n\n\nrequire import UniformSampling_Abstract.\n\nimport RSP.\nlemma bn_rsample_spec &m a y: 0 <= W64xN.valR y < W64xN.valR a\n  => Pr[ M.bn_rsample(a)@&m: res.`2 = y ] \n     = Pr[ RSM.RS.sample(fun x => x < W64xN.valR a,0)@&m: res.`2 = W64xN.valR y ].\n  have ->: Pr[ M.bn_rsample(a)@&m: res.`2 = y ] = Pr[CSpecFp.rsample(W64xN.valR a) @ &m : res.`2 = W64xN.valR y ].\n  byequiv. conseq rsample_cspec. smt(). smt(@W64xN). auto. auto.\nmove => interval.\napply (rsample_pr2 (W64xN.valR a) &m (fun (x : int * int) => x.`2 = (W64xN.valR y))).\nqed.\n\nequiv rsample_aspec:\n M.bn_rsample ~ ASpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.\nproof.\ntransitivity \n CSpecFp.rsample\n  (W64xN.valR byte_z{1} = a{2}\n    ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1)\n  (={arg} /\\ 0 < arg{1} < W64xN.modulusR  ==> res{1}.`2 = res{2}).\nprogress. \nexists (W64xN.valR arg{1}). split. smt(). split. smt().\nsplit. \nauto.\nmove => _. smt(@W64xN).\nprogress.\napply rsample_cspec.\nexists* arg{1}. elim*. move => P.\nconseq (rsample_eq P  ). \nprogress.\nqed.\n\n\nlemma bn_rsample_pmf &m a y: 0 <= W64xN.valR y < W64xN.valR a\n  => Pr[ M.bn_rsample(a)@&m: res.`2 = y ] = 1%r/(W64xN.valR a)%r.\nproof. move => interval.\n  have ->: 1%r/(W64xN.valR a)%r = Pr[CSpecFp.rsample(W64xN.valR a) @ &m : res.`2 = W64xN.valR y ].\n  rewrite - (rsample_uni &m (W64xN.valR y) (W64xN.valR a)).\n  smt(@W64xN).   smt(@W64xN). smt(). auto.\nbyequiv. conseq rsample_cspec. smt(). \nprogress. smt(@W64xN). smt(@W64xN).  auto. auto.\nqed.\n\n(* Newly added code starts here *)\nequiv usample_aspec:\n M.usample ~ ASpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n  ==> W64xN.valR res{1} = res{2}.\nproof.\ntransitivity \n M.rsample \n (={arg} ==> res{1} = res{2}.`2)\n (W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n ==> W64xN.valR res{1}.`2 = res{2}).\nprogress. \nproc*. \ninline M.usample. sp. wp. call (_:true). \nsim. skip. progress. \napply rsample_aspec.\nqed.", "```ec\np W64xN.valR (to_seq (support jsmD))). \nrewrite size_map. auto.\n have ->: size (map W64xN.valR (to_seq (support jsmD))) = size (to_seq (support D)). \napply qq.  \nrewrite map_inj_in_uniq. progress. clear H H0. smt(@W64xN).\napply uniq_to_seq. smt(@Distr jsmdD_uni).\napply uniq_to_seq. smt(@Distr jsmdD_uni).\nprogress. \nhave : exists z, z \\in (to_seq (support jsmD)) /\\ W64xN.valR z = x. smt(@List).\nprogress. \nhave mf : 0 <= (W64xN.valR z) < W64xN.modulusR. smt(@W64xN). \nrewrite /D.\nhave mf2 : W64xN.valR z \\in (range 0 W64xN.modulusR). smt(@List).\nhave mf3 : W64xN.valR z \\in duniform (range 0 W64xN.modulusR). smt(@Distr).\nsmt(@Distr @Finite).\nrewrite ioo.\nexists (W64xN.R.bn_ofint x). split. \nhave mf3 :   (W64xN.R.bn_ofint x)\\in jsmD.\napply (jsmdD_fu (W64xN.R.bn_ofint x)). \napply mem_to_seq.  smt(@Distr jsmdD_uni).\nauto.    \nrewrite W64xN.R.bn_ofintK.\nhave mf2 :  x \\in D. smt(@Distr @Finite).\nhave mf3 : 0 <= x < W64xN.modulusR. smt(@Distr).\nsmt(@IntDiv).\nauto.\nqed.\n\n\nlemma lemma2 : \n  equiv [SampleLoc.jsmD ~ SampleLoc.sampleInt : true ==> W64xN.valR res{1} = res{2} ].\nproc. \nrnd W64xN.valR W64xN.R.bn_ofint.\nskip. progress.\nrewrite W64xN.R.bn_ofintK. \nhave rval : 0 <= rR  < W64xN.modulusR. smt(@Distr @List).\nsmt(@Int).\nhave rval : 0 <= rR  < W64xN.modulusR. smt(@Distr @List).\nhave ->: mu1 D rR = 1%r / W64xN.modulusR%r.\nrewrite /D. smt(@Distr @List).\nrewrite mu1_uni. apply jsmdD_uni.\nhave -> : (W64xN.R.bn_ofint rR)%W64xN.R \\in jsmD = true.\nsmt(jsmdD_fu).  \nsimplify.\nhave ->: weight jsmD = 1%r. \nsmt(jsmdD_ll @Distr).\nrewrite jsmd_supp.\nsmt(@Distr).\nhave rval : 0 <= W64xN.valR rL  < W64xN.modulusR. smt(@W64xN).\nsmt(@Distr).\nsmt(@W64xN).\nqed.    \n\n\nmodule WW = {\n  proc rsample(byte_z : W64.t Array32.t) : int * W64.t Array32.t = {\n    var aux : W8.t Array256.t;\n    var i : int;\n    var byte_p : W64.t Array32.t;\n    var cf : bool;\n    var byte_q : W64.t Array32.t;\n    var _0 : bool;\n    var _1 : bool;\n    var _2 : bool;\n    var _3 : bool;\n    var _4 : W64.t;\n    \n    byte_p <- witness;\n    byte_q <- witness;\n    i <- 0;\n    byte_p <@ M(Syscall).bn_set0(byte_p);\n    (_0, cf, _1, _2, _3, _4) <- set0_64;\n    while (!cf){\n      byte_p <@ SampleLoc.sample((init\n                              (fun (i_0 : int) =>\n                                 get8\n                                   (init64\n                                      (fun (i_0_0 : int) => byte_p.[i_0_0])%Array32)\n                                   i_0))%Array256);\n      byte_q <@ M(Syscall).bn_copy(byte_p);\n      (cf, byte_q) <@ M(Syscall).bn_subc(byte_q, byte_z);\n      i <- i + 1;\n    }   \n    return (i, byte_p);\n  }\n\n  proc rsample0(byte_z : W64.t Array32.t) : int * W64.t Array32.t = {\n    var aux : W8.t Array256.t;\n    var i : int;\n    var byte_p : W64.t Array32.t;\n    var cf : bool;\n    var byte_q : W64.t Array32.t;\n    var _0 : bool;\n    var _1 : bool;\n    var _2 : bool;\n    var _3 : bool;\n    var _4 : W64.t;\n    \n    byte_p <- witness;\n    byte_q <- witness;\n    i <- 0;\n    byte_p <@ M(Syscall).bn_set0(byte_p);\n    (_0, cf, _1, _2, _3, _4) <- set0_64;\n    while (!cf){\n      byte_p <@ SampleLoc.jsmD();\n      byte_q <@ M(Syscall).bn_copy(byte_p);\n      (cf, byte_q) <@ M(Syscall).bn_subc(byte_q, byte_z);\n      i <- i + 1;\n    }   \n    return (i, byte_p);\n  }\n\n  proc rsample2(a : int) : int * int = {\n    var x : int;\n    var b : bool;\n    var i : int;\n    var z : int;\n    \n    x <- 0;\n    b <- true;\n    i <- 0;\n    while (b){\n      x <@ SampleLoc.sampleInt();\n      (b, z) <@ ASpecFp.subn(x, a);\n      b <- !b;\n      i <- i + 1;\n    }\n    \n    return (i, x);\n  }\n\n}.\n\nrequire import BigNum_proofs.\nequiv rsample_cspec:\n M.bn_rsample ~ CSpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1.\n  transitivity WW.rsample\n   (={arg} ==> ={res})\n   (  W64xN.valR byte_z{1} = a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1).\nsmt(). smt().\nproc.  inline SampleLoc.sample. wp. sp. \nwhile (={i,cf,byte_p,byte_q,byte_z}). sim. wp. call (_:true).\nsim. wp. skip. progress.\nwp.  call (_:true). sim. skip. progress.\nsymmetry.\ntransitivity \n   WW.rsample2\n   (={arg} ==> ={res})\n   (ImplZZ arg{2} arg{1} ==> ImplZZ res{2}.`2 res{1}.`2 /\\ res{2}.`1 = res{1}.`1).\nsmt(). smt().\nproc. inline SampleLoc.sampleInt. sim.\nsymmetry.\ntransitivity \n   WW.rsample0\n   (={arg} ==> ={res})\n   (ImplZZ arg{1} arg{2} ==> ImplZZ res{1}.`2 res{2}.`2 /\\ res{2}.`1 = res{1}.`1).\nsmt(). smt().\nproc. \nwhile (={i,cf,byte_p,byte_q,byte_z}). sim. wp. \ncall lemma1. skip. auto.\nwp. call (_:true). sim. wp. skip. auto.\nproc. wp.\n  while (={i} /\\ !cf{1} = b{2} /\\ ImplZZ byte_p{1}  x{2} /\\ W64xN.valR  byte_z{1} = a{2}). wp.\ncall  subc_spec. wp. ecall {1} (bn_copy_correct byte_p{1}).\nwp. \ncall lemma2. skip. progress. smt(). smt(). smt().\nwp. \ncall {1} (bn_set0_correct). wp. skip. progress.\nqed.\n\n\nrequire import UniformSampling_Abstract.\n\nimport RSP.\nlemma bn_rsample_spec &m a y: 0 <= W64xN.valR y < W64xN.valR a\n  => Pr[ M.bn_rsample(a)@&m: res.`2 = y ] \n     = Pr[ RSM.RS.sample(fun x => x < W64xN.valR a,0)@&m: res.`2 = W64xN.valR y ].\n  have ->: Pr[ M.bn_rsample(a)@&m: res.`2 = y ] = Pr[CSpecFp.rsample(W64xN.valR a) @ &m : res.`2 = W64xN.valR y ].\n  byequiv. conseq rsample_cspec. smt(). smt(@W64xN). auto. auto.\nmove => interval.\napply (rsample_pr2 (W64xN.valR a) &m (fun (x : int * int) => x.`2 = (W64xN.valR y))).\nqed.\n\nequiv rsample_aspec:\n M.bn_rsample ~ ASpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n  ==> W64xN.valR res{1}.`2 = res{2}.\nproof.\ntransitivity \n CSpecFp.rsample\n  (W64xN.valR byte_z{1} = a{2}\n    ==> W64xN.valR res{1}.`2 = res{2}.`2 /\\ res{1}.`1 = res{2}.`1)\n  (={arg} /\\ 0 < arg{1} < W64xN.modulusR  ==> res{1}.`2 = res{2}).\nprogress. \nexists (W64xN.valR arg{1}). split. smt(). split. smt().\nsplit. \nauto.\nmove => _. smt(@W64xN).\nprogress.\napply rsample_cspec.\nexists* arg{1}. elim*. move => P.\nconseq (rsample_eq P  ). \nprogress.\nqed.\n\n\nlemma bn_rsample_pmf &m a y: 0 <= W64xN.valR y < W64xN.valR a\n  => Pr[ M.bn_rsample(a)@&m: res.`2 = y ] = 1%r/(W64xN.valR a)%r.\nproof. move => interval.\n  have ->: 1%r/(W64xN.valR a)%r = Pr[CSpecFp.rsample(W64xN.valR a) @ &m : res.`2 = W64xN.valR y ].\n  rewrite - (rsample_uni &m (W64xN.valR y) (W64xN.valR a)).\n  smt(@W64xN).   smt(@W64xN). smt(). auto.\nbyequiv. conseq rsample_cspec. smt(). \nprogress. smt(@W64xN). smt(@W64xN).  auto. auto.\nqed.\n\n(* Newly added code starts here *)\nequiv usample_aspec:\n M.usample ~ ASpecFp.rsample:\n  W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n  ==> W64xN.valR res{1} = res{2}.\nproof.\ntransitivity \n M.rsample \n (={arg} ==> res{1} = res{2}.`2)\n (W64xN.valR byte_z{1} = a{2} /\\ 0 < a{2}\n ==> W64xN.valR res{1}.`2 = res{2}).\nprogress. \nproc*. \ninline M.usample. sp. wp. call (_:true). \nsim. skip. progress. \napply rsample_aspec.\nqed.\n```"]], "EC-1/W64xN_Finite.ec": [[true, "require import BigNum_spec.\nrequire import AllCore List.\n\nimport W64xN.\nimport R.\n\nop all_w64xN : R.t list  = map R.bn_ofint (range 0 modulusR).\n\nlemma all_w64xN_uniq : uniq (all_w64xN).\napply map_inj_in_uniq. move => x y.\nmove => xi yi.\nhave f0 : 0 < modulusR. auto.\nhave f1 : 0 <= x < modulusR. split. smt(@List). move => _.\nsmt(@List).\nhave f2 : 0 <= y < modulusR. split. smt(@List). move => _.\nsmt(@List).\nclear xi yi.\nmove => ass.\nhave : valR (R.bn_ofint x) = valR (R.bn_ofint y).\nsmt().\nrewrite R.bn_ofintK.\nrewrite R.bn_ofintK. smt(@IntDiv).\nsmt(@List).\nqed.\n\nlemma modulusR_pos : 0 < modulusR. auto.\nqed.\n\nlemma all_w64xN_size : size (all_w64xN) = modulusR.\nrewrite /all_w64xN.  smt(@List modulusR_pos).\nqed.\n\nlemma all_ints x : 0 <= x < modulusR => (R.bn_ofint x) \\in all_w64xN.\nprogress. rewrite /all_w64xN. smt(@List).\nqed.\n\nlemma all_w64xN_full x : x \\in all_w64xN.\n have f1 : R.bn_ofint (valR x) \\in all_w64xN.\n apply all_ints.  split. smt(@W64xN). move => _.\nhave f2 : 0 <= valR x < W64x2N.M ^ nlimbs.  rewrite /valR. apply R.bnk_cmp. smt().\nsmt (bnK).\nqed.", "```ec\nrequire import BigNum_spec.\nrequire import AllCore List.\n\nimport W64xN.\nimport R.\n\nop all_w64xN : R.t list  = map R.bn_ofint (range 0 modulusR).\n\nlemma all_w64xN_uniq : uniq (all_w64xN).\napply map_inj_in_uniq. move => x y.\nmove => xi yi.\nhave f0 : 0 < modulusR. auto.\nhave f1 : 0 <= x < modulusR. split. smt(@List). move => _.\nsmt(@List).\nhave f2 : 0 <= y < modulusR. split. smt(@List). move => _.\nsmt(@List).\nclear xi yi.\nmove => ass.\nhave : valR (R.bn_ofint x) = valR (R.bn_ofint y).\nsmt().\nrewrite R.bn_ofintK.\nrewrite R.bn_ofintK. smt(@IntDiv).\nsmt(@List).\nqed.\n\nlemma modulusR_pos : 0 < modulusR. auto.\nqed.\n\nlemma all_w64xN_size : size (all_w64xN) = modulusR.\nrewrite /all_w64xN.  smt(@List modulusR_pos).\nqed.\n\nlemma all_ints x : 0 <= x < modulusR => (R.bn_ofint x) \\in all_w64xN.\nprogress. rewrite /all_w64xN. smt(@List).\nqed.\n\nlemma all_w64xN_full x : x \\in all_w64xN.\n have f1 : R.bn_ofint (valR x) \\in all_w64xN.\n apply all_ints.  split. smt(@W64xN). move => _.\nhave f2 : 0 <= valR x < W64x2N.M ^ nlimbs.  rewrite /valR. apply R.bnk_cmp. smt().\nsmt (bnK).\nqed.\n```"]], "EC-1/WhileNoSuccess.ec": [[true, "r[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] = p.\nbyphoare (_: arg = (i, MyP, s, e, r) ==> _).\nconseq H. auto. auto. byequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto.\nqed.\n\nlocal lemma lll (b a c : real) : a <= b => b <= c => a <= c.\nproof. smt(). qed.\n\nlocal lemma whp_split_if_end' MyP i s e r p P :  \n  phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] = p =>\n  phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] = p.\nproof. progress. bypr.\nprogress.\nhave zz : Pr[M(A).whp_if_end(i,MyP, s, e, r) @ &m : P res] = p.\nbyphoare (_: arg = (i,MyP,s, e, r) ==> _).\nconseq H. auto. auto. \napply (lll Pr[M(A).whp_if_end(i, MyP,s, e, r) @ &m : P res] ).\nbyequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto. apply zz.\nqed.\n\nlocal lemma whp_split_if_end_le MyP i s e r p P :  \n  (phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] <= p)\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] <= p.\nproof. progress. bypr.\nprogress.\nhave zz : Pr[M(A).whp_if_end((i,MyP,s,e,r)) @ &m : P res] <= p.\nbyphoare (_: arg = ((i,MyP,s,e,r)) ==> _).\nconseq H.  progress.  auto.\napply (lll Pr[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] ). auto.\nbyequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto. apply zz.\nqed.\n\nlocal lemma whp_split_if_end_ge MyP i s e r p P :  \n  (phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] >= p)\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] >= p.\nproof. progress. bypr.\nmove => &m ae. \nhave zz : Pr[M(A).whp_if_end((i,MyP,s,e,r)) @ &m : P res] >= p.\nbyphoare (_: arg = ((i,MyP,s,e,r)) ==> _).\n  conseq H.  progress.  auto.\napply (lll Pr[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] ). auto.\nbyequiv.\nsymmetry. conseq whp_split_if_end. smt(). auto. auto. auto. \nqed.\n\nlocal lemma iter_eq (p : real) ia r MyPa: \n   (phoare[ A.run : arg = ia ==> !MyPa res ] = p) =>\n  MyPa r = false => forall e, 0 <= e => \n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] = (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp. \nrcondt 1. skip. progress. smt().\nswap 1 1.  \nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] = (p^1). \nsimplify.  conseq iipr. smt(@Real).\n call f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] = (p ^(n+1)).\n apply (whp_split_if_end'  MyPa ia 1 n r  (p^(n+1)) (fun x => !MyPa x) (H0 H) ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i =  ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i =  ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp. \ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress. \n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().  \nwp. simplify.  call iipr.  simplify.\nskip. progress. \nhoare. \nrcondf 1. skip.  progress. smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlocal lemma iter_le (p : real) ia r MyPa:\n   (phoare[ A.run : arg = ia ==> !MyPa res ] <= p) =>\n  MyPa r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] <= (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp.\nrcondt 1. skip. progress. smt().\nswap 1 1.\nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] <= (p^1).\nconseq iipr. smt(@Real).\ncall f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] <= (p ^(n+1)).\n apply (whp_split_if_end_le MyPa  ia 1 n r (p^(n+1))  (fun x => !MyPa x) (H0 H)  ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i = ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i = ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp.\ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress.\n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().\nwp. simplify.  call iipr.  simplify.\nskip. progress.\nhoare.\nrcondf 1. skip.  progress.  smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlocal lemma iter_ge (p : real) ia r MyPa:\n   (phoare[ A.run : arg = ia ==> !MyPa res ] >= p) =>\n  MyPa r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] >= (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp.\nrcondt 1. skip. progress. smt().\nswap 1 1.\nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] >= (p^1).\nconseq iipr. smt(@Real).\ncall f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] >= (p ^(n+1)).\n apply (whp_split_if_end_ge MyPa  ia 1 n r (p^(n+1))  (fun x => !MyPa x) (H0 H)  ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i = ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i = ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp.\ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress.\n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().\nwp. simplify.  call iipr.  simplify.\nskip. progress.\nhoare.\nrcondf 1. skip.  progress. smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlemma iter_run_eq_ph (p : real) ia MyP r :  \n   (phoare[ A.run : arg = ia ==> !MyP res ] = p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia,MyP,1,e+1,r) ==> !MyP res ] = (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] = (p ^ (e+1)).\napply (iter_eq  p ia r  MyP H1 H e ep). \nby conseq (whp_split_if_end' MyP ia 1 e r (p^(e+1)) (fun x => !MyP x) fact1).\nqed.\n\nlemma iter_run_le_ph (p : real) ia MyP r:  \n   (phoare[ A.run : arg = ia ==> !MyP res ] <= p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia, MyP,1,e+1,r) ==> !MyP res ] <= (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] <= (p ^ (e+1)).\napply (iter_le   p  ia r MyP H1 H e ep). \nby conseq (whp_split_if_end_le MyP ia 1 e r (p^(e+1))  (fun x => !MyP x) fact1).\nqed.\n\nlemma iter_run_ge_ph (p : real) ia MyP r:  \n   (phoare[ A.run : arg = ia ==> !MyP res ] >= p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia, MyP,1,e+1,r) ==> !MyP res ] >= (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] >= (p ^ (e+1)).\napply (iter_ge   p  ia r MyP H1 H e ep). \nby conseq (whp_split_if_end_ge MyP ia 1 e r (p^(e+1))  (fun x => !MyP x) fact1).\nqed.\n\nend section.\n\nend IterUntilSucc.", "```ec\nr[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] = p.\nbyphoare (_: arg = (i, MyP, s, e, r) ==> _).\nconseq H. auto. auto. byequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto.\nqed.\n\nlocal lemma lll (b a c : real) : a <= b => b <= c => a <= c.\nproof. smt(). qed.\n\nlocal lemma whp_split_if_end' MyP i s e r p P :  \n  phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] = p =>\n  phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] = p.\nproof. progress. bypr.\nprogress.\nhave zz : Pr[M(A).whp_if_end(i,MyP, s, e, r) @ &m : P res] = p.\nbyphoare (_: arg = (i,MyP,s, e, r) ==> _).\nconseq H. auto. auto. \napply (lll Pr[M(A).whp_if_end(i, MyP,s, e, r) @ &m : P res] ).\nbyequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto. apply zz.\nqed.\n\nlocal lemma whp_split_if_end_le MyP i s e r p P :  \n  (phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] <= p)\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] <= p.\nproof. progress. bypr.\nprogress.\nhave zz : Pr[M(A).whp_if_end((i,MyP,s,e,r)) @ &m : P res] <= p.\nbyphoare (_: arg = ((i,MyP,s,e,r)) ==> _).\nconseq H.  progress.  auto.\napply (lll Pr[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] ). auto.\nbyequiv.\nconseq whp_split_if_end. smt(). auto. auto. auto. apply zz.\nqed.\n\nlocal lemma whp_split_if_end_ge MyP i s e r p P :  \n  (phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] >= p)\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] >= p.\nproof. progress. bypr.\nmove => &m ae. \nhave zz : Pr[M(A).whp_if_end((i,MyP,s,e,r)) @ &m : P res] >= p.\nbyphoare (_: arg = ((i,MyP,s,e,r)) ==> _).\n  conseq H.  progress.  auto.\napply (lll Pr[M(A).whp_if_end(i, MyP, s, e, r) @ &m : P res] ). auto.\nbyequiv.\nsymmetry. conseq whp_split_if_end. smt(). auto. auto. auto. \nqed.\n\nlocal lemma iter_eq (p : real) ia r MyPa: \n   (phoare[ A.run : arg = ia ==> !MyPa res ] = p) =>\n  MyPa r = false => forall e, 0 <= e => \n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] = (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp. \nrcondt 1. skip. progress. smt().\nswap 1 1.  \nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] = (p^1). \nsimplify.  conseq iipr. smt(@Real).\n call f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] = (p ^(n+1)).\n apply (whp_split_if_end'  MyPa ia 1 n r  (p^(n+1)) (fun x => !MyPa x) (H0 H) ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i =  ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i =  ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp. \ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress. \n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().  \nwp. simplify.  call iipr.  simplify.\nskip. progress. \nhoare. \nrcondf 1. skip.  progress. smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlocal lemma iter_le (p : real) ia r MyPa:\n   (phoare[ A.run : arg = ia ==> !MyPa res ] <= p) =>\n  MyPa r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] <= (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp.\nrcondt 1. skip. progress. smt().\nswap 1 1.\nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] <= (p^1).\nconseq iipr. smt(@Real).\ncall f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] <= (p ^(n+1)).\n apply (whp_split_if_end_le MyPa  ia 1 n r (p^(n+1))  (fun x => !MyPa x) (H0 H)  ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i = ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i = ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp.\ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress.\n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().\nwp. simplify.  call iipr.  simplify.\nskip. progress.\nhoare.\nrcondf 1. skip.  progress.  smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlocal lemma iter_ge (p : real) ia r MyPa:\n   (phoare[ A.run : arg = ia ==> !MyPa res ] >= p) =>\n  MyPa r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp_if_end : arg = (ia, MyPa, 1,e,r) ==> !MyPa res ] >= (p ^ (e+1)).\nproof. move => iipr ipr. apply ge0ind. smt().\nprogress. simplify.\n  progress. proc.\ninline*. sp.\nrcondf 1. skip. smt().\nsp.\nrcondt 1. skip. progress. smt().\nswap 1 1.\nhave f : phoare[ A.run : arg = ia ==> ! MyPa res] >= (p^1).\nconseq iipr. smt(@Real).\ncall f. sp. skip. auto.\n  simplify.\nprogress. proc.\n  have phf: phoare[ M(A).whp : arg = (ia, MyPa, 1, n+1, r) ==> !MyPa res] >= (p ^(n+1)).\n apply (whp_split_if_end_ge MyPa  ia 1 n r (p^(n+1))  (fun x => !MyPa x) (H0 H)  ).\nseq 1 : (!MyPa ri) (p ^(n+1)) p 1%r 0%r (i = ia /\\ MyP = MyPa /\\ (!MyPa ri => M.c <= e + 1)).\ninline*. sp.\nseq 1 :  (i = ia /\\ MyP = MyPa /\\ (!MyPa r0 => M.c <= e + 1)).\n while (i = ia /\\ i = i0 /\\ MyP = MyP0 /\\ MyP = MyPa /\\ e = e0 /\\ (!MyPa r0 => M.c <= e0 + 1)).\nwp.\ncall (_:true).  skip. progress. smt(). skip. progress. smt(). sp.  skip. progress.\n call phf. skip.  auto.\nrcondt 1. skip. progress. smt().\nwp. simplify.  call iipr.  simplify.\nskip. progress.\nhoare.\nrcondf 1. skip.  progress. smt().\nsimplify. skip. auto. smt(@Real).\nqed.\n\nlemma iter_run_eq_ph (p : real) ia MyP r :  \n   (phoare[ A.run : arg = ia ==> !MyP res ] = p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia,MyP,1,e+1,r) ==> !MyP res ] = (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] = (p ^ (e+1)).\napply (iter_eq  p ia r  MyP H1 H e ep). \nby conseq (whp_split_if_end' MyP ia 1 e r (p^(e+1)) (fun x => !MyP x) fact1).\nqed.\n\nlemma iter_run_le_ph (p : real) ia MyP r:  \n   (phoare[ A.run : arg = ia ==> !MyP res ] <= p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia, MyP,1,e+1,r) ==> !MyP res ] <= (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] <= (p ^ (e+1)).\napply (iter_le   p  ia r MyP H1 H e ep). \nby conseq (whp_split_if_end_le MyP ia 1 e r (p^(e+1))  (fun x => !MyP x) fact1).\nqed.\n\nlemma iter_run_ge_ph (p : real) ia MyP r:  \n   (phoare[ A.run : arg = ia ==> !MyP res ] >= p) =>\n  MyP r = false => forall e, 0 <= e =>\n  phoare[ M(A).whp : arg = (ia, MyP,1,e+1,r) ==> !MyP res ] >= (p ^ (e+1)).\nmove => H1 H e ep.\nhave fact1  : phoare[ M(A).whp_if_end : arg = (ia,MyP,1,e,r) ==> !MyP res ] >= (p ^ (e+1)).\napply (iter_ge   p  ia r MyP H1 H e ep). \nby conseq (whp_split_if_end_ge MyP ia 1 e r (p^(e+1))  (fun x => !MyP x) fact1).\nqed.\n\nend section.\n\nend IterUntilSucc.\n```"]]}