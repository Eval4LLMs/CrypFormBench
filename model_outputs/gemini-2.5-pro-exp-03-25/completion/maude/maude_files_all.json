{"MAUDE-1/Denning-Sacco.maude": [[true, "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _ ; _ : Msg Msg -> Msg [frozen associative (e d)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M M2 M1 N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(a) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _ ; _ : Msg Msg -> Msg [frozen associative (e d)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M M2 M1 N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(a) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/maa-crc.maude": [[true, "fmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [ctor] .\n  op Xtrue : -> Xbool [ctor] .\n  op x0 : -> Bit [ctor] .\n  op x1 : -> Bit [ctor] .\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet [ctor] .\n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Bit Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Block Block -> Pair [ctor] .\n  op 0 : -> Nat [ctor] .\n  op succ : Nat -> Nat [ctor] .\n  op buildKey : Nat Block -> Key [ctor] .\n  op unitMessage : Block -> Message [ctor] .\n  op consMessage : Block Message -> Message [ctor] .\n  op unitSegmentedMessage : Message -> SegmentedMessage [ctor] .\n  op consSegmentedMessage : Message SegmentedMessage -> SegmentedMessage [ctor] .\n  op notBool : Xbool -> Xbool .\n  op andBool : Xbool Xbool -> Xbool .\n  op orBool : Xbool Xbool -> Xbool .\n  op xorBool : Xbool Xbool -> Xbool .\n  op notBit : Bit -> Bit .\n  op andBit : Bit Bit -> Bit .\n  op orBit : Bit Bit -> Bit .\n  op xorBit : Bit Bit -> Bit .\n  op x00 : -> Octet .\n  op x01 : -> Octet .\n  op x0000 : -> Half .\n  op HalfU : Block -> Half .\n  op HalfL : Block -> Half .\n  op eqBit : Bit Bit -> Xbool .\n  op eqOctet : Octet Octet -> Xbool .\n  op eqOctetSum : OctetSum OctetSum -> Xbool .\n  op eqHalf : Half Half -> Xbool .\n  op eqHalfSum : HalfSum HalfSum -> Xbool .\n  op eqBlock : Block Block -> Xbool .\n  op eqBlockSum : BlockSum BlockSum -> Xbool .\n  op eqPair : Pair Pair -> Xbool .\n  op addBit : Bit Bit Bit -> Bit .\n  op carBit : Bit Bit Bit -> Bit .\n  op addOctetSum : Octet Octet Bit -> OctetSum .\n  op addOctet8 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet7 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet6 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet5 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet4 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet3 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet2 : Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet0 : Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op dropCarryOctetSum : OctetSum -> Octet .\n  op addOctet : Octet Octet -> Octet .\n  op addHalfSum : Bit Half -> HalfSum .\n  op addHalf2 : Bit Octet Octet Octet -> HalfSum .\n  op addHalf1 : Bit Octet OctetSum -> HalfSum .\n  op addHalf0 : OctetSum OctetSum -> HalfSum .\n  op dropCarryHalfSum : HalfSum -> Half .\n  op addHalf : Half Half -> Half .\n  op addHalfOctet : Half Octet -> Half .\n  op addHalfOctets : Octet Octet -> Half .\n  op addBlockSum : Bit Block -> BlockSum .\n  op addBlock4 : Bit Octet Octet Octet Octet Octet Octet -> BlockSum .\n  op addBlock3 : Bit Octet Octet Octet Octet OctetSum -> BlockSum .\n  op addBlock2 : Bit Octet Octet Octet OctetSum Octet -> BlockSum .\n  op addBlock1 : Bit Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock0 : OctetSum OctetSum Octet Octet -> BlockSum .\n  op dropCarryBlockSum : BlockSum -> Block .\n  op addBlock : Block Block -> Block .\n  op addBlockHalf : Half Half -> Block .\n  op addBlockHalves : Half Half -> Block .\n  op leftOctet1 : Octet -> Octet .\n  op leftOctet2 : Octet -> Octet .\n  op leftOctet3 : Octet -> Octet .\n  op leftOctet4 : Octet -> Octet .\n  op leftOctet5 : Octet -> Octet .\n  op leftOctet6 : Octet -> Octet .\n  op leftOctet7 : Octet -> Octet .\n  op rightOctet1 : Octet -> Octet .\n  op rightOctet2 : Octet -> Octet .\n  op rightOctet3 : Octet -> Octet .\n  op rightOctet4 : Octet -> Octet .\n  op rightOctet5 : Octet -> Octet .\n  op rightOctet6 : Octet -> Octet .\n  op rightOctet7 : Octet -> Octet .\n  op mulOctet : Octet Octet -> Half .\n  op mulOctet1 : Bit Bit Bit Bit Bit Bit Bit Octet Bit -> Half .\n  op mulOctet2 : Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet3 : Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet4 : Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet5 : Bit Bit Bit Octet Half -> Half .\n  op mulOctet6 : Bit Bit Octet Half -> Half .\n  op mulOctet7 : Bit Bit Octet Half -> Half .\n  op mulOctet8 : Bit Octet Half -> Half .\n  op mulOctetA : Octet Octet Octet -> Half .\n  op mulOctetB : Octet Octet -> Half .\n  op mulHalf : Half Half -> Block .\n  op mulHalf4 : Half Half Half Half -> Block .\n  op mulHalfA : Bit Octet Octet Octet Octet Octet Octet Octet -> Block .\n  op mulHalf3 : Bit Octet Octet Half Octet -> Block .\n  op mulHalf2 : Bit Half Octet Octet -> Block .\n  op mulHalf1 : Half Half Octet Octet -> Block .\n  op mulBlock : Block Block -> Pair .\n  op mulBlockA : Bit Block Block Block -> Pair .\n  op mulBlock4 : Bit Block Half Half Half Half Half Half -> Pair .\n  op mulBlock3 : Bit Block Half Half Block Half -> Pair .\n  op mulBlock2 : Half Block Half Half -> Pair .\n  op mulBlock1 : Block Half Half Half -> Pair .\n  op mulBlockA-prime : Bit Half Half Half -> Pair .\n  op addNat : Nat Nat -> Nat .\n  op multNat : Nat Nat -> Nat .\n  op eqNat : Nat Nat -> Xbool .\n  op ltNat : Nat Nat -> Xbool .\n  op n1 : -> Nat .\n  op n2 : -> Nat .\n  op n3 : -> Nat .\n  op n4 : -> Nat .\n  op n5 : -> Nat .\n  op n6 : -> Nat .\n  op n7 : -> Nat .\n  op n8 : -> Nat .\n  op n9 : -> Nat .\n  op n10 : -> Nat .\n  op n11 : -> Nat .\n  op n12 : -> Nat .\n  op n13 : -> Nat .\n  op n14 : -> Nat .\n  op n15 : -> Nat .\n  op n16 : -> Nat .\n  op n17 : -> Nat .\n  op n18 : -> Nat .\n  op n19 : -> Nat .\n  op n20 : -> Nat .\n  op n21 : -> Nat .\n  op n22 : -> Nat .\n  op n254 : -> Nat .\n  op n256 : -> Nat .\n  op n4100 : -> Nat .\n  op andOctet : Octet Octet -> Octet .\n  op orOctet : Octet Octet -> Octet .\n  op xorOctet : Octet Octet -> Octet .\n  op x02 : -> Octet .\n  op x03 : -> Octet .\n  op x04 : -> Octet .\n  op x05 : -> Octet .\n  op x06 : -> Octet .\n  op x07 : -> Octet .\n  op x08 : -> Octet .\n  op x09 : -> Octet .\n  op x0A : -> Octet .\n  op x0B : -> Octet .\n  op x0C : -> Octet .\n  op x0D : -> Octet .\n  op x0E : -> Octet .\n  op x0F : -> Octet .\n  op x10 : -> Octet .\n  op x11 : -> Octet .\n  op x12 : -> Octet .\n  op x13 : -> Octet .\n  op x14 : -> Octet .\n  op x15 : -> Octet .\n  op x16 : -> Octet .\n  op x17 : -> Octet .\n  op x18 : -> Octet .\n  op x1A : -> Octet .\n  op x1B : -> Octet .\n  op x1C : -> Octet .\n  op x1D : -> Octet .\n  op x1E : -> Octet .\n  op x1F : -> Octet .\n  op x20 : -> Octet .\n  op x21 : -> Octet .\n  op x23 : -> Octet .\n  op x24 : -> Octet .\n  op x25 : -> Octet .\n  op x26 : -> Octet .\n  op x27 : -> Octet .\n  op x28 : -> Octet .\n  op x29 : -> Octet .\n  op x2A : -> Octet .\n  op x2B : -> Octet .\n  op x2D : -> Octet .\n  op x2E : -> Octet .\n  op x2F : -> Octet .\n  op x30 : -> Octet .\n  op x31 : -> Octet .\n  op x32 : -> Octet .\n  op x33 : -> Octet .\n  op x34 : -> Octet .\n  op x35 : -> Octet .\n  op x36 : -> Octet .\n  op x37 : -> Octet .\n  op x38 : -> Octet .\n  op x39 : -> Octet .\n  op x3A : -> Octet .\n  op x3B : -> Octet .\n  op x3C : -> Octet .\n  op x3D : -> Octet .\n  op x3F : -> Octet .\n  op x40 : -> Octet .\n  op x46 : -> Octet .\n  op x48 : -> Octet .\n  op x49 : -> Octet .\n  op x4A : -> Octet .\n  op x4B : -> Octet .\n  op x4C : -> Octet .\n  op x4D : -> Octet .\n  op x4E : -> Octet .\n  op x4F : -> Octet .\n  op x50 : -> Octet .\n  op x51 : -> Octet .\n  op x53 : -> Octet .\n  op x54 : -> Octet .\n  op x55 : -> Octet .\n  op x58 : -> Octet .\n  op x5A : -> Octet .\n  op x5B : -> Octet .\n  op x5C : -> Octet .\n  op x5D : -> Octet .\n  op x5E : -> Octet .\n  op x5F : -> Octet .\n  op x60 : -> Octet .\n  op x61 : -> Octet .\n  op x62 : -> Octet .\n  op x63 : -> Octet .\n  op x64 : -> Octet .\n  op x65 : -> Octet .\n  op x66 : -> Octet .\n  op x67 : -> Octet .\n  op x69 : -> Octet .\n  op x6A : -> Octet .\n  op x6B : -> Octet .\n  op x6C : -> Octet .\n  op x6D : -> Octet .\n  op x6E : -> Octet .\n  op x6F : -> Octet .\n  op x70 : -> Octet .\n  op x71 : -> Octet .\n  op x72 : -> Octet .\n  op x73 : -> Octet .\n  op x74 : -> Octet .\n  op x75 : -> Octet .\n  op x76 : -> Octet .\n  op x77 : -> Octet .\n  op x78 : -> Octet .\n  op x79 : -> Octet .\n  op x7A : -> Octet .\n  op x7B : -> Octet .\n  op x7C : -> Octet .\n  op x7D : -> Octet .\n  op x7E : -> Octet .\n  op x7F : -> Octet .\n  op x80 : -> Octet .\n  op x81 : -> Octet .\n  op x83 : -> Octet .\n  op x84 : -> Octet .\n  op x85 : -> Octet .\n  op x86 : -> Octet .\n  op x88 : -> Octet .\n  op x89 : -> Octet .\n  op x8A : -> Octet .\n  op x8C : -> Octet .\n  op x8D : -> Octet .\n  op x8E : -> Octet .\n  op x8F : -> Octet .\n  op x90 : -> Octet .\n  op x91 : -> Octet .\n  op x92 : -> Octet .\n  op x93 : -> Octet .\n  op x95 : -> Octet .\n  op x96 : -> Octet .\n  op x97 : -> Octet .\n  op x98 : -> Octet .\n  op x99 : -> Octet .\n  op x9A : -> Octet .\n  op x9B : -> Octet .\n  op x9C : -> Octet .\n  op x9D : -> Octet .\n  op x9E : -> Octet .\n  op x9F : -> Octet .\n  op xA0 : -> Octet .\n  op xA1 : -> Octet .\n  op xA2 : -> Octet .\n  op xA3 : -> Octet .\n  op xA4 : -> Octet .\n  op xA5 : -> Octet .\n  op xA6 : -> Octet .\n  op xA7 : -> Octet .\n  op xA8 : -> Octet .\n  op xA9 : -> Octet .\n  op xAA : -> Octet .\n  op xAB : -> Octet .\n  op xAC : -> Octet .\n  op xAE : -> Octet .\n  op xAF : -> Octet .\n  op xB0 : -> Octet .\n  op xB1 : -> Octet .\n  op xB2 : -> Octet .\n  op xB3 : -> Octet .\n  op xB5 : -> Octet .\n  op xB6 : -> Octet .\n  op xB8 : -> Octet .\n  op xB9 : -> Octet .\n  op xBA : -> Octet .\n  op xBB : -> Octet .\n  op xBC : -> Octet .\n  op xBE : -> Octet .\n  op xBF : -> Octet .\n  op xC0 : -> Octet .\n  op xC1 : -> Octet .\n  op xC2 : -> Octet .\n  op xC4 : -> Octet .\n  op xC5 : -> Octet .\n  op xC6 : -> Octet .\n  op xC7 : -> Octet .\n  op xC8 : -> Octet .\n  op xC9 : -> Octet .\n  op xCA : -> Octet .\n  op xCB : -> Octet .\n  op xCC : -> Octet .\n  op xCD : -> Octet .\n  op xCE : -> Octet .\n  op xD0 : -> Octet .\n  op xD1 : -> Octet .\n  op xD2 : -> Octet .\n  op xD3 : -> Octet .\n  op xD4 : -> Octet .\n  op xD5 : -> Octet .\n  op xD6 : -> Octet .\n  op xD7 : -> Octet .\n  op xD8 : -> Octet .\n  op xD9 : -> Octet .\n  op xDB : -> Octet .\n  op xDC : -> Octet .\n  op xDD : -> Octet .\n  op xDE : -> Octet .\n  op xDF : -> Octet .\n  op xE0 : -> Octet .\n  op xE1 : -> Octet .\n  op xE3 : -> Octet .\n  op xE6 : -> Octet .\n  op xE8 : -> Octet .\n  op xE9 : -> Octet .\n  op xEA : -> Octet .\n  op xEB : -> Octet .\n  op xEC : -> Octet .\n  op xED : -> Octet .\n  op xEE : -> Octet .\n  op xEF : -> Octet .\n  op xF0 : -> Octet .\n  op xF1 : -> Octet .\n  op xF2 : -> Octet .\n  op xF3 : -> Octet .\n  op xF4 : -> Octet .\n  op xF5 : -> Octet .\n  op xF6 : -> Octet .\n  op xF7 : -> Octet .\n  op xF8 : -> Octet .\n  op xF9 : -> Octet .\n  op xFA : -> Octet .\n  op xFB : -> Octet .\n  op xFC : -> Octet .\n  op xFD : -> Octet .\n  op xFE : -> Octet .\n  op xFF : -> Octet .\n  op andBlock : Block Block -> Block .\n  op orBlock : Block Block -> Block .\n  op xorBlock : Block Block -> Block .\n  op x0001 : -> Half .\n  op x00000000 : -> Block .\n  op x00000001 : -> Block .\n  op x00000002 : -> Block .\n  op x00000003 : -> Block .\n  op x00000004 : -> Block .\n  op x00000005 : -> Block .\n  op x00000006 : -> Block .\n  op x00000007 : -> Block .\n  op x00000008 : -> Block .\n  op x00000009 : -> Block .\n  op x0000000A : -> Block .\n  op x0000000B : -> Block .\n  op x0000000C : -> Block .\n  op x0000000D : -> Block .\n  op x0000000E : -> Block .\n  op x0000000F : -> Block .\n  op x00000010 : -> Block .\n  op x00000012 : -> Block .\n  op x00000014 : -> Block .\n  op x00000016 : -> Block .\n  op x00000018 : -> Block .\n  op x0000001B : -> Block .\n  op x0000001D : -> Block .\n  op x0000001E : -> Block .\n  op x0000001F : -> Block .\n  op x00000031 : -> Block .\n  op x00000036 : -> Block .\n  op x00000060 : -> Block .\n  op x00000080 : -> Block .\n  op x000000A5 : -> Block .\n  op x000000B6 : -> Block .\n  op x000000C4 : -> Block .\n  op x000000D2 : -> Block .\n  op x00000100 : -> Block .\n  op x00000129 : -> Block .\n  op x0000018C : -> Block .\n  op x00004000 : -> Block .\n  op x00010000 : -> Block .\n  op x00020000 : -> Block .\n  op x00030000 : -> Block .\n  op x00040000 : -> Block .\n  op x00060000 : -> Block .\n  op x00804021 : -> Block .\n  op x00FF00FF : -> Block .\n  op x0103050B : -> Block .\n  op x01030703 : -> Block .\n  op x01030705 : -> Block .\n  op x0103070F : -> Block .\n  op x02040801 : -> Block .\n  op x0297AF6F : -> Block .\n  op x07050301 : -> Block .\n  op x077788A2 : -> Block .\n  op x07C72EAA : -> Block .\n  op x0A202020 : -> Block .\n  op x0AD67E20 : -> Block .\n  op x10000000 : -> Block .\n  op x11A9D254 : -> Block .\n  op x11AC46B8 : -> Block .\n  op x1277A6D4 : -> Block .\n  op x13647149 : -> Block .\n  op x160EE9B5 : -> Block .\n  op x17065DBB : -> Block .\n  op x17A808FD : -> Block .\n  op x1D10D8D3 : -> Block .\n  op x1D3B7760 : -> Block .\n  op x1D9C9655 : -> Block .\n  op x1F3F7FFF : -> Block .\n  op x204E80A7 : -> Block .\n  op x21D869BA : -> Block .\n  op x24B66FB5 : -> Block .\n  op x270EEDAF : -> Block .\n  op x277B4B25 : -> Block .\n  op x2829040B : -> Block .\n  op x288FC786 : -> Block .\n  op x28EAD8B3 : -> Block .\n  op x29907CD8 : -> Block .\n  op x29C1485F : -> Block .\n  op x29EEE96B : -> Block .\n  op x2A6091AE : -> Block .\n  op x2BF8499A : -> Block .\n  op x2E80AC30 : -> Block .\n  op x2FD76FFB : -> Block .\n  op x30261492 : -> Block .\n  op x303FF4AA : -> Block .\n  op x33D5A466 : -> Block .\n  op x344925FC : -> Block .\n  op x34ACF886 : -> Block .\n  op x3CD54DEB : -> Block .\n  op x3CF3A7D2 : -> Block .\n  op x3DD81AC6 : -> Block .\n  op x3F6F7248 : -> Block .\n  op x48B204D6 : -> Block .\n  op x4A645A01 : -> Block .\n  op x4C49AAE0 : -> Block .\n  op x4CE933E1 : -> Block .\n  op x4D53901A : -> Block .\n  op x4DA124A1 : -> Block .\n  op x4F998E01 : -> Block .\n  op x4FB1138A : -> Block .\n  op x50DEC930 : -> Block .\n  op x51AF3C1D : -> Block .\n  op x51EDE9C7 : -> Block .\n  op x550D91CE : -> Block .\n  op x55555555 : -> Block .\n  op x55DD063F : -> Block .\n  op x5834A585 : -> Block .\n  op x5A35D667 : -> Block .\n  op x5BC02502 : -> Block .\n  op x5CCA3239 : -> Block .\n  op x5EBA06C2 : -> Block .\n  op x5F38EEF1 : -> Block .\n  op x613F8E2A : -> Block .\n  op x63C70DBA : -> Block .\n  op x6AD6E8A4 : -> Block .\n  op x6AEBACF8 : -> Block .\n  op x6D67E884 : -> Block .\n  op x7050EC5E : -> Block .\n  op x717153D5 : -> Block .\n  op x7201F4DC : -> Block .\n  op x7397C9AE : -> Block .\n  op x74B39176 : -> Block .\n  op x76232E5F : -> Block .\n  op x7783C51D : -> Block .\n  op x7792F9D4 : -> Block .\n  op x7BC180AB : -> Block .\n  op x7DB2D9F4 : -> Block .\n  op x7DFEFBFF : -> Block .\n  op x7F76A3B0 : -> Block .\n  op x7F839576 : -> Block .\n  op x7FFFFFF0 : -> Block .\n  op x7FFFFFF1 : -> Block .\n  op x7FFFFFFC : -> Block .\n  op x7FFFFFFD : -> Block .\n  op x80000000 : -> Block .\n  op x80000002 : -> Block .\n  op x800000C2 : -> Block .\n  op x80018000 : -> Block .\n  op x80018001 : -> Block .\n  op x80397302 : -> Block .\n  op x81D10CA3 : -> Block .\n  op x89D635D7 : -> Block .\n  op x8CE37709 : -> Block .\n  op x8DC8BBDE : -> Block .\n  op x9115A558 : -> Block .\n  op x91896CFA : -> Block .\n  op x9372CDC6 : -> Block .\n  op x98D1CC75 : -> Block .\n  op x9D15C437 : -> Block .\n  op x9DB15CF6 : -> Block .\n  op x9E2E7B36 : -> Block .\n  op xA018C83B : -> Block .\n  op xA0B87B77 : -> Block .\n  op xA44AAAC0 : -> Block .\n  op xA511987A : -> Block .\n  op xA70FC148 : -> Block .\n  op xA93BD410 : -> Block .\n  op xAAAAAAAA : -> Block .\n  op xAB00FFCD : -> Block .\n  op xAB01FCCD : -> Block .\n  op xAB6EED4A : -> Block .\n  op xABEEED6B : -> Block .\n  op xACBC13DD : -> Block .\n  op xB1CC1CC5 : -> Block .\n  op xB8142629 : -> Block .\n  op xB99A62DE : -> Block .\n  op xBA92DB12 : -> Block .\n  op xBBA57835 : -> Block .\n  op xBE9F0917 : -> Block .\n  op xBF2D7D85 : -> Block .\n  op xBFEF7FDF : -> Block .\n  op xC1ED90DD : -> Block .\n  op xC21A1846 : -> Block .\n  op xC4EB1AEB : -> Block .\n  op xC6B1317E : -> Block .\n  op xCBC865BA : -> Block .\n  op xCD959B46 : -> Block .\n  op xD0482465 : -> Block .\n  op xD636250D : -> Block .\n  op xD7843FDC : -> Block .\n  op xD78634BC : -> Block .\n  op xD8804CA5 : -> Block .\n  op xDB79FBDC : -> Block .\n  op xDB9102B0 : -> Block .\n  op xE0C08000 : -> Block .\n  op xE6A12F07 : -> Block .\n  op xEB35B97F : -> Block .\n  op xF0239DD5 : -> Block .\n  op xF14D6E28 : -> Block .\n  op xF2EF3501 : -> Block .\n  op xF6A09667 : -> Block .\n  op xFD297DA4 : -> Block .\n  op xFDC1A8BA : -> Block .\n  op xFE4E5BDD : -> Block .\n  op xFEA1D334 : -> Block .\n  op xFECCAA6E : -> Block .\n  op xFEFC07F0 : -> Block .\n  op xFF2D7DA5 : -> Block .\n  op xFFEF0001 : -> Block .\n  op xFFFF00FF : -> Block .\n  op xFFFFFF2D : -> Block .\n  op xFFFFFF3A : -> Block .\n  op xFFFFFFF0 : -> Block .\n  op xFFFFFFF1 : -> Block .\n  op xFFFFFFF4 : -> Block .\n  op xFFFFFFF5 : -> Block .\n  op xFFFFFFF7 : -> Block .\n  op xFFFFFFF9 : -> Block .\n  op xFFFFFFFA : -> Block .\n  op xFFFFFFFB : -> Block .\n  op xFFFFFFFC : -> Block .\n  op xFFFFFFFD : -> Block .\n  op xFFFFFFFE : -> Block .\n  op xFFFFFFFF : -> Block .\n  op appendMessage : Message Block -> Message .\n  op lengthMessage : Message -> Message .\n  op makeMessage : Nat Block Block -> Message .\n  op segmentMessage : Message -> SegmentedMessage .\n  op cutSegment : Bit Message Nat -> Message .\n  op ADD : Block Block -> Block .\n  op AND : Block Block -> Block .\n  op MUL : Block Block -> Pair .\n  op OR : Block Block -> Block .\n  op XOR : Block Block -> Block .\n  op XOR-prime : Block -> Block .\n  op CYC : Block -> Block .\n  op ROTR : Nat Block -> Block .\n  op FIX1 : Block -> Block .\n  op FIX2 : Block -> Block .\n  op bit0 : Octet -> Xbool .\n  op bitN : Octet -> Bit .\n  op adjust : Bit Octet -> Octet .\n  op PAT : Nat Block -> Octet .\n  op BYT : Nat Block -> Pair .\n  op BYT-prime : Nat Nat Nat Nat Octet Octet Octet Octet Octet -> Pair .\n  op ADDC : Block Block -> Pair .\n  op ADDC-prime : Block -> Pair .\n  op MUL1 : Block Block -> Block .\n  op MUL1XY : Block -> Block .\n  op MUL1UL : Block Block -> Block .\n  op MUL2U : Pair -> Block .\n  op MUL2D : Block Block -> Block .\n  op MUL2F : Pair -> Block .\n  op MUL2UL : Block Block -> Block .\n  op MUL2DEL : Pair Block -> Block .\n  op MUL2FL : Block Block -> Block .\n  op MUL2SC : Pair -> Block .\n  op MUL2A : Block Block -> Block .\n  op MUL2AD : Pair -> Block .\n  op MUL2AUL : Block Block -> Block .\n  op MUL2ADL : Block Block -> Block .\n  op MUL2ASC : Block -> Block .\n  op squareHalf : Half -> Block .\n  op Q : Block -> Block .\n  op H4 : Block -> Block .\n  op H6 : Block -> Block .\n  op H8 : Block -> Block .\n  op J1-0 : Block -> Block .\n  op J1-1 : Block Octet -> Block .\n  op J1-3 : Block -> Block .\n  op J1-5 : Block -> Block .\n  op J1-2 : Block -> Block .\n  op J1-4 : Block -> Block .\n  op J1-6 : Block -> Block .\n  op J1-8 : Block -> Block .\n  op J2-2 : Block -> Block .\n  op J2-4 : Block -> Block .\n  op J2-6 : Block -> Block .\n  op J2-8 : Block -> Block .\n  op K1-2 : Block -> Block .\n  op K1-4 : Block -> Block .\n  op K1-5 : Block -> Block .\n  op K1-7 : Block -> Block .\n  op K1-9 : Block -> Block .\n  op K2-2 : Block -> Block .\n  op K2-4 : Block -> Block .\n  op K2-6 : Block -> Block .\n  op K2-7 : Block -> Block .\n  op K2-9 : Block -> Block .\n  op preludeXY : Block Block -> Pair .\n  op preludeVW : Block Block -> Pair .\n  op preludeST : Block Block -> Pair .\n  op preludeST-prime : Pair Octet -> Pair .\n  op preludeVW-prime : Pair -> Pair .\n  op computeST : Pair -> Pair .\n  op computeXY : Pair Pair Block -> Pair .\n  op computeXY-prime : Pair Pair Block -> Pair .\n  op computeVW : Pair -> Pair .\n  op loop1 : Nat Pair Message -> Pair .\n  op loop2 : Pair Pair Message -> Pair .\n  op coda : Pair Pair Pair -> Block .\n  op MAA : Key Message -> Block .\n  op MAA-prime : Key Pair Pair Message -> Block .\n  op MAC : Key Message -> Block .\n  op MACloop : Key SegmentedMessage -> Block .\n  op MACnext : Key Block SegmentedMessage -> Block .\n  eq [001]: notBool (Xfalse) = Xtrue .\n  eq [002]: notBool (Xtrue) = Xfalse .\n  eq [003]: andBool (Xfalse, L:Xbool) = Xfalse .\n  eq [004]: andBool (Xtrue, L:Xbool) = L:Xbool .\n  eq [005]: orBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [006]: orBool (Xtrue, L:Xbool) = Xtrue .\n  eq [007]: xorBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [008]: xorBool (Xtrue, L:Xbool) = notBool (L:Xbool) .\n  eq [009]: notBit (x0) = x1 .\n  eq [010]: notBit (x1) = x0 .\n  eq [011]: andBit (B:Bit, x0) = x0 .\n  eq [012]: andBit (B:Bit, x1) = B:Bit .\n  eq [013]: orBit (B:Bit, x0) = B:Bit .\n  eq [014]: orBit (B:Bit, x1) = x1 .\n  eq [015]: xorBit (B:Bit, x0) = B:Bit .\n  eq [016]: xorBit (B:Bit, x1) = notBit (B:Bit) .\n  eq [017]: x00 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x0) .\n  eq [018]: x01 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x1) .\n  eq [019]: x0000 = buildHalf (x00, x00) .\n  eq [020]: HalfU (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [021]: HalfL (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O3:Octet, O4:Octet) .\n  eq [022]: eqBit (x0, x0) = Xtrue .\n  eq [023]: eqBit (x0, x1) = Xfalse .\n  eq [024]: eqBit (x1, x0) = Xfalse .\n  eq [025]: eqBit (x1, x1) = Xtrue .\n  eq [026]: eqOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = andBool (eqBit (B1:Bit, B-prime1:Bit), andBool (eqBit (B2:Bit, B-prime2:Bit), andBool (eqBit (B3:Bit, B-prime3:Bit), andBool (eqBit (B4:Bit, B-prime4:Bit), andBool (eqBit (B5:Bit, B-prime5:Bit), andBool (eqBit (B6:Bit, B-prime6:Bit), andBool (eqBit (B7:Bit, B-prime7:Bit), eqBit (B8:Bit, B-prime8:Bit)))))))) .\n  eq [027]: eqOctetSum (buildOctetSum (B:Bit, O:Octet), buildOctetSum (B-prime:Bit, O-prime:Octet)) = andBool (eqBit (B:Bit, B-prime:Bit), eqOctet (O:Octet, O-prime:Octet)) .\n  eq [028]: eqHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)) .\n  eq [029]: eqHalfSum (buildHalfSum (B:Bit, H:Half), buildHalfSum (B-prime:Bit, H-prime:Half)) = andBool (eqBit (B:Bit, B-prime:Bit), eqHalf (H:Half, H-prime:Half)) .\n  eq [030]: eqBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = andBool (andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)), andBool (eqOctet (O3:Octet, O-prime3:Octet), eqOctet (O4:Octet, O-prime4:Octet))) .\n  eq [031]: eqBlockSum (buildBlockSum (B:Bit, W:Block), buildBlockSum (B-prime:Bit, W-prime:Block)) = andBool (eqBit (B:Bit, B-prime:Bit), eqBlock (W:Block, W-prime:Block)) .\n  eq [032]: eqPair (buildPair (W1:Block, W2:Block), buildPair (W-prime1:Block, W-prime2:Block)) = andBool (eqBlock (W1:Block, W-prime1:Block), eqBlock (W2:Block, W-prime2:Block)) .\n  eq [033]: addBit (B:Bit, B-prime:Bit, Bcarry:Bit) = xorBit (xorBit (B:Bit, B-prime:Bit), Bcarry:Bit) .\n  eq [034]: carBit (B:Bit, B-prime:Bit, Bcarry:Bit) = orBit (andBit (andBit (B:Bit, B-prime:Bit), notBit (Bcarry:Bit)), andBit (orBit (B:Bit, B-prime:Bit), Bcarry:Bit)) .\n  eq [035]: addOctetSum (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit), Bcarry:Bit) = addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) .\n  eq [036]: addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) = addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, carBit (B8:Bit, B-prime8:Bit, Bcarry:Bit), addBit (B8:Bit, B-prime8:Bit, Bcarry:Bit)) .\n  eq [037]: addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, Bcarry:Bit, B-second8:Bit) = addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, carBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), addBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), B-second8:Bit) .\n  eq [038]: addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, Bcarry:Bit, B-second7:Bit, B-second8:Bit) = addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, carBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), addBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), B-second7:Bit, B-second8:Bit) .\n  eq [039]: addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, Bcarry:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, carBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), addBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [040]: addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, Bcarry:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, carBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), addBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [041]: addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, Bcarry:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, carBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), addBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [042]: addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, Bcarry:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet1 (B1:Bit, B-prime1:Bit, carBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), addBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [043]: addOctet1 (B1:Bit, B-prime1:Bit, Bcarry:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-secon", "<think>**Analyzing Maude Module**\n\nI'm currently delving into the Maude module, specifically the sections dealing with sorts and operators. I'm carefully examining each `____(OP_N)____` placeholder. My focus is on identifying recurring syntax patterns from Maude-NPA specifications to accurately fill these placeholders. I'm making sure to understand the nuances of sort definitions and operator declarations.\n\n\n**Examining Constructor Signatures**\n\nNow, I'm focusing on the constructor signatures, meticulously filling in the placeholders. I've begun to translate the descriptions into precise Maude syntax, defining sorts and constructors like `Xbool`, `Bit`, `Octet`, and their respective operations. The structure of the placeholders are becoming clearer.\n\n\n**Synthesizing Operator Signatures**\n\nI'm now generating operator signatures, meticulously crafting each one based on your specifications. I'm focusing on consistency in syntax and type declarations, like ensuring `Xbool` or `Bit` are correctly used, and filling in the placeholders, adding things like `-> OctetSum` based on the context. I'm working through the various sections, from boolean and bitwise operations to arithmetic ones, implementing them as requested. I've focused on type safety.\n\n\n**Finalizing Operator Signatures**\n\nI've finished synthesizing the operator signatures, meticulously crafting each one based on your specifications. I focused on consistency in syntax and type declarations, such as ensuring `Xbool` and `Bit` are used correctly. I've completed the placeholders. I've addressed all the sections, from boolean and bitwise operations to arithmetic ones. My current task involves meticulously checking each definition to ensure they are logically sound.\n\n\n**Constructing the Maude Module**\n\nI've made significant progress in completing the Maude module definitions. I've successfully filled in the placeholders for the `Xbool`, `Bit`, `Octet` and other constructors, using the provided instructions. I am now working on ensuring type consistency and logical soundness across all operator signatures. I'm focusing on arithmetic operations, and the `leftOctet` and `rightOctet` operators.\n\n\n**Implementing Shift Operations**\n\nI'm now focusing on the shift and rotate operations, specifically `leftOctet` and `rightOctet`. I'm working through each operation, meticulously defining their signatures to align with the provided specifications. I'm focusing on ensuring consistent and efficient type handling, especially in the context of octet manipulation. I'm carefully reviewing the logic to avoid any inconsistencies or syntax errors.\n\n\n**Defining Message Structures**\n\nI'm currently working on structuring the message operations. I'm focusing on defining `appendMessage`, `lengthMessage`, and `makeMessage`, specifically. The current focus is on ensuring the data types for `lengthMessage` are correctly typed as `Nat`. The task involves defining `Message` construction and manipulation.\n\n\n**Completing Module Definitions**\n\nI'm now integrating the message operations into the module, particularly appendMessage, lengthMessage (assuming it should return a Nat), and makeMessage. I'm focusing on ensuring data type correctness and a clear construction and manipulation structure for the `Message` and `SegmentedMessage` elements. I've nearly finished the initial module.\n\n\n**Implementing Message Structures**\n\nI've successfully structured the message operations, focusing on `appendMessage`, `lengthMessage`, and `makeMessage`. I've ensured the correct data types, particularly defining `lengthMessage` to return a `Nat`. I've also defined the necessary structures for `Message` and `SegmentedMessage` to support these operations. I'm now refining the definitions to be concise and accurate.\n\n\n**Defining Message Operations**\n\nI'm now integrating the message operations into the module. I've successfully implemented `appendMessage`, `lengthMessage` (returning `Nat`), and `makeMessage`, along with the structures for `Message` and `SegmentedMessage`. I'm focusing on refining the definitions for clarity and accuracy, preparing to finalize the Maude module.\n\n\n**Implementing Base Structures**\n\nI've completed defining basic constructors and sorts like `Xbool`, `Bit`, `Octet`, `OctetSum`, and `Half`. The initial structure, including constructor signatures, has been filled, addressing `____(OP_N)____` placeholders. I've focused on ensuring the signatures align correctly with the specified types and the expected Maude syntax. I'm moving on to implement the basic boolean and bitwise operations.\n\n\n**Constructing Module Definitions**\n\nI've completed defining basic constructors and sorts like `Xbool`, `Bit`, `Octet`, and their associated operations. I've filled in placeholders for boolean, bitwise, and basic arithmetic signatures, ensuring type consistency throughout. I've also implemented the message structure definitions. Now, I am refining the arithmetic operations.\n\n\n**Completing Module Implementation**\n\nNow, I'm integrating the message operations, adding high-level cryptographic functions, and refining existing definitions. I'm focusing on consistency. I've successfully implemented base structures and the majority of operations, ensuring type safety and consistency. The module is almost complete; my next step is to clean up.\n\n\n**Finalizing Message Operations**\n\nI'm now integrating the message operations into the module. I've successfully implemented `appendMessage`, `lengthMessage` (returning `Nat`), and `makeMessage`, along with structures for `Message` and `SegmentedMessage`. I'm focusing on refining definitions, ensuring correctness, and preparing to finalize the Maude module.\n\n\n**Completing Module Implementation**\n\nNow, I'm integrating the message operations, adding high-level cryptographic functions, and refining existing definitions. I'm focusing on completeness and consistency. I've filled in the many placeholders. I will now rigorously review each signature to ensure logical correctness. This involves checking data types, arity, and syntax with Maude's style. I'm focusing on ensuring modularity for ease of use.\n\n\n**Completing the Module**\n\nI'm now integrating the message operations, high-level cryptographic functions, and refining existing definitions, aiming for a complete Maude module. I've finished filling all the placeholders. I'll meticulously review each signature for logical correctness in terms of data types, arity, and Maude syntax to prepare the final product. I'm focusing on consistency.\n\n**Integrating Message Structures**\n\nI'm now integrating the message operations, adding high-level cryptographic functions, and refining existing definitions. I've finished filling the placeholders and I'm meticulously reviewing the module, from sorts and constructors to arithmetic, message, and cryptographic operations. I'm focusing on consistency in data types, arity, and syntax to ensure logical correctness.\n\n\n**Defining Final Operations**\n\nNow that I've built the basic structures, I'm integrating them and adding high-level operations for cryptographic primitives. I've finished the template filling. Now, I will double-check each signature for logical correctness in terms of data types, arity, and Maude syntax. My focus is consistency, as I'm preparing to finalize the module.\n\n\n**Synthesizing Final Signatures**\n\nI'm now integrating the final operations into the Maude module, meticulously completing the remaining signatures. The module is almost complete, so my current focus is fine-tuning the remaining signatures for optimal clarity and correctness. This includes ensuring data type consistency and efficient construction of cryptographic primitives, preparing the module for rigorous testing and potential refinement.\n\n**Integrating Operators and Structures**\n\nI'm now deeply involved in synthesizing all the signatures. My focus is on ensuring comprehensive coverage. I'm focusing on defining each function. I have diligently filled in placeholder names like `Xfalse` and `Xtrue`. I've added functions like `J1-8`, and functions that use names like `HalfSum` and `BlockSum`, and have confirmed the signatures.\n\n\n**Integrating Cryptographic Operations**\n\nI've completed integrating the message operations and high-level cryptographic functions. I'm now meticulously reviewing each signature, ensuring data types, arity, and syntax adhere to Maude's style. I'm focused on finalizing the module with a keen eye for logical correctness and consistency. The goal is a clean, modular structure.\n\n\n**Constructing Module Signatures**\n\nNow, I'm working to fully define the module with the correct signatures, filling each `____(OP_N)____` placeholder. I'm focusing on ensuring type consistency and clarity, defining constructors like `Xbool`, `Bit`, `Octet` and their respective operations. I'm carefully translating the specifications into precise Maude syntax for operators and constructors, like `addOctet` and `eqBit`, ready to finalize the module.\n\n\n**Finalizing Module Integration**\n\nI'm now integrating the final operations, refining signatures for clarity and correctness. After meticulous review, all placeholders are filled. The Maude module is complete, encompassing sorts, constructors, and cryptographic primitives. I'm focusing on consistency in syntax and type declarations, such as ensuring all parameters of type `Bit` and `Block` are correctly used. This concludes the primary implementation phase; I am now ensuring that `lengthMessage` returns `Message`.\n\n\n**Constructing Module Definitions**\n\nI've completed integrating all the operations and placeholders, ensuring each signature is correct, clear, and follows Maude's syntax. The structure and type consistency are validated, and the module, complete with arithmetic, message, and cryptographic operations, is ready for evaluation. The focus on modularity promotes use.\n\n\n**Implementing Final Operations**\n\nI'm now completing the Maude module definitions by meticulously filling each placeholder with the appropriate Maude syntax. I'm focusing on ensuring data type correctness and consistent syntax across all functions. The module incorporates arithmetic, message, and cryptographic operations, ready to be integrated into the test environment.\n\n\n**Completing the Module**\n\nI'm now integrating the message operations, high-level cryptographic functions, and refining existing definitions, aiming for a complete Maude module. I've filled all placeholders. I'll meticulously review each signature for correctness and consistency to prepare the final product. I'm focusing on adhering to Maude syntax and modularity.\n\n\n**Synthesizing Module Definitions**\n\nI'm now integrating the final operations into the Maude module, and meticulously ensuring the correctness and consistency. I'm filling in the placeholders, and ensuring the correct use of types like `Bit` and `Block`, and validating the signature of each function. I'm focusing on consistency.\n\n**Constructing Complete Module**\n\nI'm now integrating all the gathered information to construct the complete Maude module. I'm focusing on consistency across definitions, ensuring proper attribute values and type definitions are in place. The process involves systematically filling the `____(OP_N)____` placeholders based on the earlier detailed analysis, while adhering to the specifications provided, including the use of attributes like `ctor`. I've double-checked my mappings and am confident in the construction.\n\n\n</think>\n\nOkay, I will complete the Maude module for you. Based on common Maude-NPA practices and the provided structure, here's the completed file:\n\n```maude\nfmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [ctor] .\n  op Xtrue : -> Xbool [ctor] .\n  op x0 : -> Bit [ctor] .\n  op x1 : -> Bit [ctor] .\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet [ctor] .\n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Bit Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Block Block -> Pair [ctor] .\n  op 0 : -> Nat [ctor] .\n  op succ : Nat -> Nat [ctor] .\n  op buildKey : Nat Block -> Key [ctor] .\n  op unitMessage : Block -> Message [ctor] .\n  op consMessage : Block Message -> Message [ctor] .\n  op unitSegmentedMessage : Message -> SegmentedMessage [ctor] .\n  op consSegmentedMessage : Message SegmentedMessage -> SegmentedMessage [ctor] .\n  op notBool : Xbool -> Xbool .\n  op andBool : Xbool Xbool -> Xbool .\n  op orBool : Xbool Xbool -> Xbool .\n  op xorBool : Xbool Xbool -> Xbool .\n  op notBit : Bit -> Bit .\n  op andBit : Bit Bit -> Bit .\n  op orBit : Bit Bit -> Bit .\n  op xorBit : Bit Bit -> Bit .\n  op x00 : -> Octet .\n  op x01 : -> Octet .\n  op x0000 : -> Half .\n  op HalfU : Block -> Half .\n  op HalfL : Block -> Half .\n  op eqBit : Bit Bit -> Xbool .\n  op eqOctet : Octet Octet -> Xbool .\n  op eqOctetSum : OctetSum OctetSum -> Xbool .\n  op eqHalf : Half Half -> Xbool .\n  op eqHalfSum : HalfSum HalfSum -> Xbool .\n  op eqBlock : Block Block -> Xbool .\n  op eqBlockSum : BlockSum BlockSum -> Xbool .\n  op eqPair : Pair Pair -> Xbool .\n  op addBit : Bit Bit Bit -> Bit .\n  op carBit : Bit Bit Bit -> Bit .\n  op addOctetSum : Octet Octet Bit -> OctetSum .\n  op addOctet8 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet7 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet6 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet5 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet4 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet3 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet2 : Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet0 : Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op dropCarryOctetSum : OctetSum -> Octet .\n  op addOctet : Octet Octet -> Octet .\n  op addHalfSum : Bit Half -> HalfSum .\n  op addHalf2 : Bit Octet Octet Octet -> HalfSum .\n  op addHalf1 : Bit Octet OctetSum -> HalfSum .\n  op addHalf0 : OctetSum OctetSum -> HalfSum .\n  op dropCarryHalfSum : HalfSum -> Half .\n  op addHalf : Half Half -> Half .\n  op addHalfOctet : Half Octet -> Half .\n  op addHalfOctets : Octet Octet -> Half .\n  op addBlockSum : Bit Block -> BlockSum .\n  op addBlock4 : Bit Octet Octet Octet Octet Octet Octet -> BlockSum .\n  op addBlock3 : Bit Octet Octet Octet Octet OctetSum -> BlockSum .\n  op addBlock2 : Bit Octet Octet Octet OctetSum Octet -> BlockSum .\n  op addBlock1 : Bit Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock0 : OctetSum OctetSum Octet Octet -> BlockSum .\n  op dropCarryBlockSum : BlockSum -> Block .\n  op addBlock : Block Block -> Block .\n  op addBlockHalf : Half Half -> Block .\n  op addBlockHalves : Half Half -> Block .\n  op leftOctet1 : Octet -> Octet .\n  op leftOctet2 : Octet -> Octet .\n  op leftOctet3 : Octet -> Octet .\n  op leftOctet4 : Octet -> Octet .\n  op leftOctet5 : Octet -> Octet .\n  op leftOctet6 : Octet -> Octet .\n  op leftOctet7 : Octet -> Octet .\n  op rightOctet1 : Octet -> Octet .\n  op rightOctet2 : Octet -> Octet .\n  op rightOctet3 : Octet -> Octet .\n  op rightOctet4 : Octet -> Octet .\n  op rightOctet5 : Octet -> Octet .\n  op rightOctet6 : Octet -> Octet .\n  op rightOctet7 : Octet -> Octet .\n  op mulOctet : Octet Octet -> Half .\n  op mulOctet1 : Bit Bit Bit Bit Bit Bit Bit Octet Bit -> Half .\n  op mulOctet2 : Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet3 : Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet4 : Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet5 : Bit Bit Bit Octet Half -> Half .\n  op mulOctet6 : Bit Bit Octet Half -> Half .\n  op mulOctet7 : Bit Bit Octet Half -> Half .\n  op mulOctet8 : Bit Octet Half -> Half .\n  op mulOctetA : Octet Octet Octet -> Half .\n  op mulOctetB : Octet Octet -> Half .\n  op mulHalf : Half Half -> Block .\n  op mulHalf4 : Half Half Half Half -> Block .\n  op mulHalfA : Bit Octet Octet Octet Octet Octet Octet Octet -> Block .\n  op mulHalf3 : Bit Octet Octet Half Octet -> Block .\n  op mulHalf2 : Bit Half Octet Octet -> Block .\n  op mulHalf1 : Half Half Octet Octet -> Block .\n  op mulBlock : Block Block -> Pair .\n  op mulBlockA : Bit Block Block Block -> Pair .\n  op mulBlock4 : Bit Block Half Half Half Half Half Half -> Pair .\n  op mulBlock3 : Bit Block Half Half Block Half -> Pair .\n  op mulBlock2 : Half Block Half Half -> Pair .\n  op mulBlock1 : Block Half Half Half -> Pair .\n  op mulBlockA-prime : Bit Half Half Half -> Pair .\n  op addNat : Nat Nat -> Nat .\n  op multNat : Nat Nat -> Nat .\n  op eqNat : Nat Nat -> Xbool .\n  op ltNat : Nat Nat -> Xbool .\n  op n1 : -> Nat .\n  op n2 : -> Nat .\n  op n3 : -> Nat .\n  op n4 : -> Nat .\n  op n5 : -> Nat .\n  op n6 : -> Nat .\n  op n7 : -> Nat .\n  op n8 : -> Nat .\n  op n9 : -> Nat .\n  op n10 : -> Nat .\n  op n11 : -> Nat .\n  op n12 : -> Nat .\n  op n13 : -> Nat .\n  op n14 : -> Nat .\n  op n15 : -> Nat .\n  op n16 : -> Nat .\n  op n17 : -> Nat .\n  op n18 : -> Nat .\n  op n19 : -> Nat .\n  op n20 : -> Nat .\n  op n21 : -> Nat .\n  op n22 : -> Nat .\n  op n254 : -> Nat .\n  op n256 : -> Nat .\n  op n4100 : -> Nat .\n  op andOctet : Octet Octet -> Octet .\n  op orOctet : Octet Octet -> Octet .\n  op xorOctet : Octet Octet -> Octet .\n  op x02 : -> Octet .\n  op x03 : -> Octet .\n  op x04 : -> Octet .\n  op x05 : -> Octet .\n  op x06 : -> Octet .\n  op x07 : -> Octet .\n  op x08 : -> Octet .\n  op x09 : -> Octet .\n  op x0A : -> Octet .\n  op x0B : -> Octet .\n  op x0C : -> Octet .\n  op x0D : -> Octet .\n  op x0E : -> Octet .\n  op x0F : -> Octet .\n  op x10 : -> Octet .\n  op x11 : -> Octet .\n  op x12 : -> Octet .\n  op x13 : -> Octet .\n  op x14 : -> Octet .\n  op x15 : -> Octet .\n  op x16 : -> Octet .\n  op x17 : -> Octet .\n  op x18 : -> Octet .\n  op x1A : -> Octet .\n  op x1B : -> Octet .\n  op x1C : -> Octet .\n  op x1D : -> Octet .\n  op x1E : -> Octet .\n  op x1F : -> Octet .\n  op x20 : -> Octet .\n  op x21 : -> Octet .\n  op x23 : -> Octet .\n  op x24 : -> Octet .\n  op x25 : -> Octet .\n  op x26 : -> Octet .\n  op x27 : -> Octet .\n  op x28 : -> Octet .\n  op x29 : -> Octet .\n  op x2A : -> Octet .\n  op x2B : -> Octet .\n  op x2D : -> Octet .\n  op x2E : -> Octet .\n  op x2F : -> Octet .\n  op x30 : -> Octet .\n  op x31 : -> Octet .\n  op x32 : -> Octet .\n  op x33 : -> Octet .\n  op x34 : -> Octet .\n  op x35 : -> Octet .\n  op x36 : -> Octet .\n  op x37 : -> Octet .\n  op x38 : -> Octet .\n  op x39 : -> Octet .\n  op x3A : -> Octet .\n  op x3B : -> Octet .\n  op x3C : -> Octet .\n  op x3D : -> Octet .\n  op x3F : -> Octet .\n  op x40 : -> Octet .\n  op x46 : -> Octet .\n  op x48 : -> Octet .\n  op x49 : -> Octet .\n  op x4A : -> Octet .\n  op x4B : -> Octet .\n  op x4C : -> Octet .\n  op x4D : -> Octet .\n  op x4E : -> Octet .\n  op x4F : -> Octet .\n  op x50 : -> Octet .\n  op x51 : -> Octet .\n  op x53 : -> Octet .\n  op x54 : -> Octet .\n  op x55 : -> Octet .\n  op x58 : -> Octet .\n  op x5A : -> Octet .\n  op x5B : -> Octet .\n  op x5C : -> Octet .\n  op x5D : -> Octet .\n  op x5E : -> Octet .\n  op x5F : -> Octet .\n  op x60 : -> Octet .\n  op x61 : -> Octet .\n  op x62 : -> Octet .\n  op x63 : -> Octet .\n  op x64 : -> Octet .\n  op x65 : -> Octet .\n  op x66 : -> Octet .\n  op x67 : -> Octet .\n  op x69 : -> Octet .\n  op x6A : -> Octet .\n  op x6B : -> Octet .\n  op x6C : -> Octet .\n  op x6D : -> Octet .\n  op x6E : -> Octet .\n  op x6F : -> Octet .\n  op x70 : -> Octet .\n  op x71 : -> Octet .\n  op x72 : -> Octet .\n  op x73 : -> Octet .\n  op x74 : -> Octet .\n  op x75 : -> Octet .\n  op x76 : -> Octet .\n  op x77 : -> Octet .\n  op x78 : -> Octet .\n  op x79 : -> Octet .\n  op x7A : -> Octet .\n  op x7B : -> Octet .\n  op x7C : -> Octet .\n  op x7D : -> Octet .\n  op x7E : -> Octet .\n  op x7F : -> Octet .\n  op x80 : -> Octet .\n  op x81 : -> Octet .\n  op x83 : -> Octet .\n  op x84 : -> Octet .\n  op x85 : -> Octet .\n  op x86 : -> Octet .\n  op x88 : -> Octet .\n  op x89 : -> Octet .\n  op x8A : -> Octet .\n  op x8C : -> Octet .\n  op x8D : -> Octet .\n  op x8E : -> Octet .\n  op x8F : -> Octet .\n  op x90 : -> Octet .\n  op x91 : -> Octet .\n  op x92 : -> Octet .\n  op x93 : -> Octet .\n  op x95 : -> Octet .\n  op x96 : -> Octet .\n  op x97 : -> Octet .\n  op x98 : -> Octet .\n  op x99 : -> Octet .\n  op x9A : -> Octet .\n  op x9B : -> Octet .\n  op x9C : -> Octet .\n  op x9D : -> Octet .\n  op x9E : -> Octet .\n  op x9F : -> Octet .\n  op xA0 : -> Octet .\n  op xA1 : -> Octet .\n  op xA2 : -> Octet .\n  op xA3 : -> Octet .\n  op xA4 : -> Octet .\n  op xA5 : -> Octet .\n  op xA6 : -> Octet .\n  op xA7 : -> Octet .\n  op xA8 : -> Octet .\n  op xA9 : -> Octet .\n  op xAA : -> Octet .\n  op xAB : -> Octet .\n  op xAC : -> Octet .\n  op xAE : -> Octet .\n  op xAF : -> Octet .\n  op xB0 : -> Octet .\n  op xB1 : -> Octet .\n  op xB2 : -> Octet .\n  op xB3 : -> Octet .\n  op xB5 : -> Octet .\n  op xB6 : -> Octet .\n  op xB8 : -> Octet .\n  op xB9 : -> Octet .\n  op xBA : -> Octet .\n  op xBB : -> Octet .\n  op xBC : -> Octet .\n  op xBE : -> Octet .\n  op xBF : -> Octet .\n  op xC0 : -> Octet .\n  op xC1 : -> Octet .\n  op xC2 : -> Octet .\n  op xC4 : -> Octet .\n  op xC5 : -> Octet .\n  op xC6 : -> Octet .\n  op xC7 : -> Octet .\n  op xC8 : -> Octet .\n  op xC9 : -> Octet .\n  op xCA : -> Octet .\n  op xCB : -> Octet .\n  op xCC : -> Octet .\n  op xCD : -> Octet .\n  op xCE : -> Octet .\n  op xD0 : -> Octet .\n  op xD1 : -> Octet .\n  op xD2 : -> Octet .\n  op xD3 : -> Octet .\n  op xD4 : -> Octet .\n  op xD5 : -> Octet .\n  op xD6 : -> Octet .\n  op xD7 : -> Octet .\n  op xD8 : -> Octet .\n  op xD9 : -> Octet .\n  op xDB : -> Octet .\n  op xDC : -> Octet .\n  op xDD : -> Octet .\n  op xDE : -> Octet .\n  op xDF : -> Octet .\n  op xE0 : -> Octet .\n  op xE1 : -> Octet .\n  op xE3 : -> Octet .\n  op xE6 : -> Octet .\n  op xE8 : -> Octet .\n  op xE9 : -> Octet .\n  op xEA : -> Octet .\n  op xEB : -> Octet .\n  op xEC : -> Octet .\n  op xED : -> Octet .\n  op xEE : -> Octet .\n  op xEF : -> Octet .\n  op xF0 : -> Octet .\n  op xF1 : -> Octet .\n  op xF2 : -> Octet .\n  op xF3 : -> Octet .\n  op xF4 : -> Octet .\n  op xF5 : -> Octet .\n  op xF6 : -> Octet .\n  op xF7 : -> Octet .\n  op xF8 : -> Octet .\n  op xF9 : -> Octet .\n  op xFA : -> Octet .\n  op xFB : -> Octet .\n  op xFC : -> Octet .\n  op xFD : -> Octet .\n  op xFE : -> Octet .\n  op xFF : -> Octet .\n  op andBlock : Block Block -> Block .\n  op orBlock : Block Block -> Block .\n  op xorBlock : Block Block -> Block .\n  op x0001 : -> Half .\n  op x00000000 : -> Block .\n  op x00000001 : -> Block .\n  op x00000002 : -> Block .\n  op x00000003 : -> Block .\n  op x00000004 : -> Block .\n  op x00000005 : -> Block .\n  op x00000006 : -> Block .\n  op x00000007 : -> Block .\n  op x00000008 : -> Block .\n  op x00000009 : -> Block .\n  op x0000000A : -> Block .\n  op x0000000B : -> Block .\n  op x0000000C : -> Block .\n  op x0000000D : -> Block .\n  op x0000000E : -> Block .\n  op x0000000F : -> Block .\n  op x00000010 : -> Block .\n  op x00000012 : -> Block .\n  op x00000014 : -> Block .\n  op x00000016 : -> Block .\n  op x00000018 : -> Block .\n  op x0000001B : -> Block .\n  op x0000001D : -> Block .\n  op x0000001E : -> Block .\n  op x0000001F : -> Block .\n  op x00000031 : -> Block .\n  op x00000036 : -> Block .\n  op x00000060 : -> Block .\n  op x00000080 : -> Block .\n  op x000000A5 : -> Block .\n  op x000000B6 : -> Block .\n  op x000000C4 : -> Block .\n  op x000000D2 : -> Block .\n  op x00000100 : -> Block .\n  op x00000129 : -> Block .\n  op x0000018C : -> Block .\n  op x00004000 : -> Block .\n  op x00010000 : -> Block .\n  op x00020000 : -> Block .\n  op x00030000 : -> Block .\n  op x00040000 : -> Block .\n  op x00060000 : -> Block .\n  op x00804021 : -> Block .\n  op x00FF00FF : -> Block .\n  op x0103050B : -> Block .\n  op x01030703 : -> Block .\n  op x01030705 : -> Block .\n  op x0103070F : -> Block .\n  op x02040801 : -> Block .\n  op x0297AF6F : -> Block .\n  op x07050301 : -> Block .\n  op x077788A2 : -> Block .\n  op x07C72EAA : -> Block .\n  op x0A202020 : -> Block .\n  op x0AD67E20 : -> Block .\n  op x10000000 : -> Block .\n  op x11A9D254 : -> Block .\n  op x11AC46B8 : -> Block .\n  op x1277A6D4 : -> Block .\n  op x13647149 : -> Block .\n  op x160EE9B5 : -> Block .\n  op x17065DBB : -> Block .\n  op x17A808FD : -> Block .\n  op x1D10D8D3 : -> Block .\n  op x1D3B7760 : -> Block .\n  op x1D9C9655 : -> Block .\n  op x1F3F7FFF : -> Block .\n  op x204E80A7 : -> Block .\n  op x21D869BA : -> Block .\n  op x24B66FB5 : -> Block .\n  op x270EEDAF : -> Block .\n  op x277B4B25 : -> Block .\n  op x2829040B : -> Block .\n  op x288FC786 : -> Block .\n  op x28EAD8B3 : -> Block .\n  op x29907CD8 : -> Block .\n  op x29C1485F : -> Block .\n  op x29EEE96B : -> Block .\n  op x2A6091AE : -> Block .\n  op x2BF8499A : -> Block .\n  op x2E80AC30 : -> Block .\n  op x2FD76FFB : -> Block .\n  op x30261492 : -> Block .\n  op x303FF4AA : -> Block .\n  op x33D5A466 : -> Block .\n  op x344925FC : -> Block .\n  op x34ACF886 : -> Block .\n  op x3CD54DEB : -> Block .\n  op x3CF3A7D2 : -> Block .\n  op x3DD81AC6 : -> Block .\n  op x3F6F7248 : -> Block .\n  op x48B204D6 : -> Block .\n  op x4A645A01 : -> Block .\n  op x4C49AAE0 : -> Block .\n  op x4CE933E1 : -> Block .\n  op x4D53901A : -> Block .\n  op x4DA124A1 : -> Block .\n  op x4F998E01 : -> Block .\n  op x4FB1138A : -> Block .\n  op x50DEC930 : -> Block .\n  op x51AF3C1D : -> Block .\n  op x51EDE9C7 : -> Block .\n  op x550D91CE : -> Block .\n  op x55555555 : -> Block .\n  op x55DD063F : -> Block .\n  op x5834A585 : -> Block .\n  op x5A35D667 : -> Block .\n  op x5BC02502 : -> Block .\n  op x5CCA3239 : -> Block .\n  op x5EBA06C2 : -> Block .\n  op x5F38EEF1 : -> Block .\n  op x613F8E2A : -> Block .\n  op x63C70DBA : -> Block .\n  op x6AD6E8A4 : -> Block .\n  op x6AEBACF8 : -> Block .\n  op x6D67E884 : -> Block .\n  op x7050EC5E : -> Block .\n  op x717153D5 : -> Block .\n  op x7201F4DC : -> Block .\n  op x7397C9AE : -> Block .\n  op x74B39176 : -> Block .\n  op x76232E5F : -> Block .\n  op x7783C51D : -> Block .\n  op x7792F9D4 : -> Block .\n  op x7BC180AB : -> Block .\n  op x7DB2D9F4 : -> Block .\n  op x7DFEFBFF : -> Block .\n  op x7F76A3B0 : -> Block .\n  op x7F839576 : -> Block .\n  op x7FFFFFF0 : -> Block .\n  op x7FFFFFF1 : -> Block .\n  op x7FFFFFFC : -> Block .\n  op x7FFFFFFD : -> Block .\n  op x80000000 : -> Block .\n  op x80000002 : -> Block .\n  op x800000C2 : -> Block .\n  op x80018000 : -> Block .\n  op x80018001 : -> Block .\n  op x80397302 : -> Block .\n  op x81D10CA3 : -> Block .\n  op x89D635D7 : -> Block .\n  op x8CE37709 : -> Block .\n  op x8DC8BBDE : -> Block .\n  op x9115A558 : -> Block .\n  op x91896CFA : -> Block .\n  op x9372CDC6 : -> Block .\n  op x98D1CC75 : -> Block .\n  op x9D15C437 : -> Block .\n  op x9DB15CF6 : -> Block .\n  op x9E2E7B36 : -> Block .\n  op xA018C83B : -> Block .\n  op xA0B87B77 : -> Block .\n  op xA44AAAC0 : -> Block .\n  op xA511987A : -> Block .\n  op xA70FC148 : -> Block .\n  op xA93BD410 : -> Block .\n  op xAAAAAAAA : -> Block .\n  op xAB00FFCD : -> Block .\n  op xAB01FCCD : -> Block .\n  op xAB6EED4A : -> Block .\n  op xABEEED6B : -> Block .\n  op xACBC13DD : -> Block .\n  op xB1CC1CC5 : -> Block .\n  op xB8142629 : -> Block .\n  op xB99A62DE : -> Block .\n  op xBA92DB12 : -> Block .\n  op xBBA57835 : -> Block .\n  op xBE9F0917 : -> Block .\n  op xBF2D7D85 : -> Block .\n  op xBFEF7FDF : -> Block .\n  op xC1ED90DD : -> Block .\n  op xC21A1846 : -> Block .\n  op xC4EB1AEB : -> Block .\n  op xC6B1317E : -> Block .\n  op xCBC865BA : -> Block .\n  op xCD959B46 : -> Block .\n  op xD0482465 : -> Block .\n  op xD636250D : -> Block .\n  op xD7843FDC : -> Block .\n  op xD78634BC : -> Block .\n  op xD8804CA5 : -> Block .\n  op xDB79FBDC : -> Block .\n  op xDB9102B0 : -> Block .\n  op xE0C08000 : -> Block .\n  op xE6A12F07 : -> Block .\n  op xEB35B97F : -> Block .\n  op xF0239DD5 : -> Block .\n  op xF14D6E28 : -> Block .\n  op xF2EF3501 : -> Block .\n  op xF6A09667 : -> Block .\n  op xFD297DA4 : -> Block .\n  op xFDC1A8BA : -> Block .\n  op xFE4E5BDD : -> Block .\n  op xFEA1D334 : -> Block .\n  op xFECCAA6E : -> Block .\n  op xFEFC07F0 : -> Block .\n  op xFF2D7DA5 : -> Block .\n  op xFFEF0001 : -> Block .\n  op xFFFF00FF : -> Block .\n  op xFFFFFF2D : -> Block .\n  op xFFFFFF3A : -> Block .\n  op xFFFFFFF0 : -> Block .\n  op xFFFFFFF1 : -> Block .\n  op xFFFFFFF4 : -> Block .\n  op xFFFFFFF5 : -> Block .\n  op xFFFFFFF7 : -> Block .\n  op xFFFFFFF9 : -> Block .\n  op xFFFFFFFA : -> Block .\n  op xFFFFFFFB : -> Block .\n  op xFFFFFFFC : -> Block .\n  op xFFFFFFFD : -> Block .\n  op xFFFFFFFE : -> Block .\n  op xFFFFFFFF : -> Block .\n  op appendMessage : Message Block -> Message .\n  op lengthMessage : Message -> Message .\n  op makeMessage : Nat Block Block -> Message .\n  op segmentMessage : Message -> SegmentedMessage .\n  op cutSegment : Bit Message Nat -> Message .\n  op ADD : Block Block -> Block .\n  op AND : Block Block -> Block .\n  op MUL : Block Block -> Pair .\n  op OR : Block Block -> Block .\n  op XOR : Block Block -> Block .\n  op XOR-prime : Block -> Block .\n  op CYC : Block -> Block .\n  op ROTR : Nat Block -> Block .\n  op FIX1 : Block -> Block .\n  op FIX2 : Block -> Block .\n  op bit0 : Octet -> Xbool .\n  op bitN : Octet -> Bit .\n  op adjust : Bit Octet -> Octet .\n  op PAT : Nat Block -> Octet .\n  op BYT : Nat Block -> Pair .\n  op BYT-prime : Nat Nat Nat Nat Octet Octet Octet Octet Octet -> Pair .\n  op ADDC : Block Block -> Pair .\n  op ADDC-prime : Block -> Pair .\n  op MUL1 : Block Block -> Block .\n  op MUL1XY : Block -> Block .\n  op MUL1UL : Block Block -> Block .\n  op MUL2U : Pair -> Block .\n  op MUL2D : Block Block -> Block .\n  op MUL2F : Pair -> Block .\n  op MUL2UL : Block Block -> Block .\n  op MUL2DEL : Pair Block -> Block .\n  op MUL2FL : Block Block -> Block .\n  op MUL2SC : Pair -> Block .\n  op MUL2A : Block Block -> Block .\n  op MUL2AD : Pair -> Block .\n  op MUL2AUL : Block Block -> Block .\n  op MUL2ADL : Block Block -> Block .\n  op MUL2ASC : Block -> Block .\n  op squareHalf : Half -> Block .\n  op Q : Block -> Block .\n  op H4 : Block -> Block .\n  op H6 : Block -> Block .\n  op H8 : Block -> Block .\n  op J1-0 : Block -> Block .\n  op J1-1 : Block Octet -> Block .\n  op J1-3 : Block -> Block .\n  op J1-5 : Block -> Block .\n  op J1-2 : Block -> Block .\n  op J1-4 : Block -> Block .\n  op J1-6 : Block -> Block .\n  op J1-8 : Block -> Block .\n  op J2-2 : Block -> Block .\n  op J2-4 : Block -> Block .\n  op J2-6 : Block -> Block .\n  op J2-8 : Block -> Block .\n  op K1-2 : Block -> Block .\n  op K1-4 : Block -> Block .\n  op K1-5 : Block -> Block .\n  op K1-7 : Block -> Block .\n  op K1-9 : Block -> Block .\n  op K2-2 : Block -> Block .\n  op K2-4 : Block -> Block .\n  op K2-6 : Block -> Block .\n  op K2-7 : Block -> Block .\n  op K2-9 : Block -> Block .\n  op preludeXY : Block Block -> Pair .\n  op preludeVW : Block Block -> Pair .\n  op preludeST : Block Block -> Pair .\n  op preludeST-prime : Pair Octet -> Pair .\n  op preludeVW-prime : Pair -> Pair .\n  op computeST : Pair -> Pair .\n  op computeXY : Pair Pair Block -> Pair .\n  op computeXY-prime : Pair Pair Block -> Pair .\n  op computeVW : Pair -> Pair .\n  op loop1 : Nat Pair Message -> Pair .\n  op loop2 : Pair Pair Message -> Pair .\n  op coda : Pair Pair Pair -> Block .\n  op MAA : Key Message -> Block .\n  op MAA-prime : Key Pair Pair Message -> Block .\n  op MAC : Key Message -> Block .\n  op MACloop : Key SegmentedMessage -> Block .\n  op MACnext : Key Block SegmentedMessage -> Block .\n  eq [001]: notBool (Xfalse) = Xtrue .\n  eq [002]: notBool (Xtrue) = Xfalse .\n  eq [003]: andBool (Xfalse, L:Xbool) = Xfalse .\n  eq [004]: andBool (Xtrue, L:Xbool) = L:Xbool .\n  eq [005]: orBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [006]: orBool (Xtrue, L:Xbool) = Xtrue .\n  eq [007]: xorBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [008]: xorBool (Xtrue, L:Xbool) = notBool (L:Xbool) .\n  eq [009]: notBit (x0) = x1 .\n  eq [010]: notBit (x1) = x0 .\n  eq [011]: andBit (B:Bit, x0) = x0 .\n  eq [012]: andBit (B:Bit, x1) = B:Bit .\n  eq [013]: orBit (B:Bit, x0) = B:Bit .\n  eq [014]: orBit (B:Bit, x1) = x1 .\n  eq [015]: xorBit (B:Bit, x0) = B:Bit .\n  eq [016]: xorBit (B:Bit, x1) = notBit (B:Bit) .\n  eq [017]: x00 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x0) .\n  eq [018]: x01 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x1) .\n  eq [019]: x0000 = buildHalf (x00, x00) .\n  eq [020]: HalfU (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [021]: HalfL (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O3:Octet, O4:Octet) .\n  eq [022]: eqBit (x0, x0) = Xtrue .\n  eq [023]: eqBit (x0, x1) = Xfalse .\n  eq [024]: eqBit (x1, x0) = Xfalse .\n  eq [025]: eqBit (x1, x1) = Xtrue .\n  eq [026]: eqOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = andBool (eqBit (B1:Bit, B-prime1:Bit), andBool (eqBit (B2:Bit, B-prime2:Bit), andBool (eqBit (B3:Bit, B-prime3:Bit), andBool (eqBit (B4:Bit, B-prime4:Bit), andBool (eqBit (B5:Bit, B-prime5:Bit), andBool (eqBit (B6:Bit, B-prime6:Bit), andBool (eqBit (B7:Bit, B-prime7:Bit), eqBit (B8:Bit, B-prime8:Bit)))))))) .\n  eq [027]: eqOctetSum (buildOctetSum (B:Bit, O:Octet), buildOctetSum (B-prime:Bit, O-prime:Octet)) = andBool (eqBit (B:Bit, B-prime:Bit), eqOctet (O:Octet, O-prime:Octet)) .\n  eq [028]: eqHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)) .\n  eq [029]: eqHalfSum (buildHalfSum (B:Bit, H:Half), buildHalfSum (B-prime:Bit, H-prime:Half)) = andBool (eqBit (B:Bit, B-prime:Bit), eqHalf (H:Half, H-prime:Half)) .\n  eq [030]: eqBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = andBool (andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)), andBool (eqOctet (O3:Octet, O-prime3:Octet), eqOctet (O4:Octet, O-prime4:Octet))) .\n  eq [031]: eqBlockSum (buildBlockSum (B:Bit, W:Block), buildBlockSum (B-prime:Bit, W-prime:Block)) = andBool (eqBit (B:Bit, B-prime:Bit), eqBlock (W:Block, W-prime:Block)) .\n  eq [032]: eqPair (buildPair (W1:Block, W2:Block), buildPair (W-prime1:Block, W-prime2:Block)) = andBool (eqBlock (W1:Block, W-prime1:Block), eqBlock (W2:Block, W-prime2:Block)) .\n  eq [033]: addBit (B:Bit, B-prime:Bit, Bcarry:Bit) = xorBit (xorBit (B:Bit, B-prime:Bit), Bcarry:Bit) .\n  eq [034]: carBit (B:Bit, B-prime:Bit, Bcarry:Bit) = orBit (andBit (andBit (B:Bit, B-prime:Bit), notBit (Bcarry:Bit)), andBit (orBit (B:Bit, B-prime:Bit), Bcarry:Bit)) .\n  eq [035]: addOctetSum (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit), Bcarry:Bit) = addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) .\n  eq [036]: addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) = addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, carBit (B8:Bit, B-prime8:Bit, Bcarry:Bit), addBit (B8:Bit, B-prime8:Bit, Bcarry:Bit)) .\n  eq [037]: addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, Bcarry:Bit, B-second8:Bit) = addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, carBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), addBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), B-second8:Bit) .\n  eq [038]: addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, Bcarry:Bit, B-second7:Bit, B-second8:Bit) = addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, carBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), addBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), B-second7:Bit, B-second8:Bit) .\n  eq [039]: addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, Bcarry:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, carBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), addBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [040]: addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, Bcarry:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, carBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), addBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [041]: addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, Bcarry:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, carBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), addBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [042]: addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, Bcarry:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet1 (B1:Bit, B-prime1:Bit, carBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), addBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [043]: addOctet1 (B1:Bit, B-prime1:Bit, Bcarry:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-secon\n```"]], "MAUDE-1/AU_and_A_UnificationEdgeCases.maude": [[true, "***\n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\nunify T X =? A B C Y .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a .", "```maude\n***\n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\nunify T X =? A B C Y .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a .\n```"]], "MAUDE-1/AU_IrredUnification.maude": [[true, "***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\nvars A B C X Y Z : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : List List -> List [assoc id: nil] .\nvars L M N : List .\nvars E F G : Elt .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero .\n  op s : Nat -> NzNat [iter] .\n  op _*_ : NzNat NzNat -> NzNat [assoc id: s(0) prec 31] .\n  op _*_ : Nat Nat -> Nat [ditto] .\n\n  vars W X Y Z U V C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: c(a, b)] .\n  op c : Foo Foo -> Foo [comm] .\n  vars W X Y Z U V C P : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(X, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op g : Foo Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: g(a, b)] .\n  op h : Foo Foo -> Foo [assoc id: f(a, b)] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(X, a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: h(f(a, b))] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, 1) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\n  op f : Lo Lo -> Lo [assoc id: 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) .", "```maude\n***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\nvars A B C X Y Z : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : List List -> List [assoc id: nil] .\nvars L M N : List .\nvars E F G : Elt .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero .\n  op s : Nat -> NzNat [iter] .\n  op _*_ : NzNat NzNat -> NzNat [assoc id: s(0) prec 31] .\n  op _*_ : Nat Nat -> Nat [ditto] .\n\n  vars W X Y Z U V C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: c(a, b)] .\n  op c : Foo Foo -> Foo [comm] .\n  vars W X Y Z U V C P : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(X, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op g : Foo Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: g(a, b)] .\n  op h : Foo Foo -> Foo [assoc id: f(a, b)] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(X, a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: h(f(a, b))] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, 1) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\n  op f : Lo Lo -> Lo [assoc id: 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) .\n```"]], "MAUDE-1/bank.maude": [[true, "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | STS >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [id:neutral] .\n    op ;_ : State State -> State [ctor assoc id:comm id:assoc empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 50) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Charlie, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Daisy, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 75) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 40) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Alice, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Daisy, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm", "```maude\nfmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | STS >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [id:neutral] .\n    op ;_ : State State -> State [ctor assoc id:comm id:assoc empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 50) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Charlie, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Daisy, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 75) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 40) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Alice, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Daisy, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm\n```"]], "MAUDE-1/bike.maude": [[true, "mod EL-CONFIGURATION is\n  protecting BIKE-DATA .\n  protecting BIKE-RULES .\n  protecting BIKE-INTRUDER-RULES .\n  protecting BIKE-GLOBAL-STATE .\n  protecting PUBLIC-KEY-INFRASTRUCTURE .\n\n    *** Group of polynomials sigma that can be sampled\n    op sigmas : Content -> Content .\n\n    *** Group of messages m that can be sampled\n    op ms : Content -> Content .\n\n    *** Group of polynomials h that can be sampled; They come in pairs\n    op hs : Content -> Content .\n\n    *** Operator to assign a polynomial 'sigma' to a participant\n    op sigmaI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a message to a participant\n    op mI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a random pair of hs to a participant\n    op hI : Identifier Pair -> Content .\n\n    ***\n    *** INITIAL STATES\n    ***\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    ***\n    *** RULES\n    ***\n\n    vars ID1 ID2 ID3 : Identifier .\n    var PS : Participants .\n    vars P P' : Participant .\n    vars SK SK' : SKey .\n    vars PK PK' PK_Eve : PKey .\n    vars Cs Cs' Hs Es : Pair .\n    vars C M : Polynomial .\n    vars E0 E1 : Polynomial .\n    vars KS1 KS2 KS3 : Keys .\n    vars SAM1 : Polynomial .\n    vars SAM2 : Pair .\n    vars M_sampled : Polynomial .\n    vars CONT1 CONT2 CONT3 : Content .\n\n    ***\n    *** HONEST PARTICIPANT BEHAVIOUR\n    ***\n\n    *** For now the protocol only starts when the participant can sample necesary values for keygen\n\n    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]peer(none)) PS >net(emptyM)\n                    =>\n                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]peer(none) sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(emptyM)\n                    if PK := (second(SAM2) p* inv(first(SAM2))) .\n\n    --- The public key is sent\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .\n\n    *** The public key is consumed to generate a shared key\n    crl [Enc] : {ms(M_sampled CONT1) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, SK) ; KS2]peer(ID1) mI(ID2, M_sampled) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(M_sampled) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    Cs := [(E0 p+ (E1 p* (PK))), (M_sampled xorD L(Es))] /\\\n                    SK := K(M_sampled, Cs) .\n\n    *** The ciphered text is sent\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)})\n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\\n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n\n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS')\n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    *** The ciphered text is consumed to generate the shared key\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := second(Cs) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    ***\n    *** INTRUDER BEHAVIOUR\n    ***\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK_Eve) ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)})\n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')})\n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(ID1,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs) peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs)})\n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,Cs') peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')})\n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(ID2,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,1) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, SK) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)})\n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm", "```maude\nmod EL-CONFIGURATION is\n  protecting BIKE-DATA .\n  protecting BIKE-RULES .\n  protecting BIKE-INTRUDER-RULES .\n  protecting BIKE-GLOBAL-STATE .\n  protecting PUBLIC-KEY-INFRASTRUCTURE .\n\n    *** Group of polynomials sigma that can be sampled\n    op sigmas : Content -> Content .\n\n    *** Group of messages m that can be sampled\n    op ms : Content -> Content .\n\n    *** Group of polynomials h that can be sampled; They come in pairs\n    op hs : Content -> Content .\n\n    *** Operator to assign a polynomial 'sigma' to a participant\n    op sigmaI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a message to a participant\n    op mI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a random pair of hs to a participant\n    op hI : Identifier Pair -> Content .\n\n    ***\n    *** INITIAL STATES\n    ***\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    ***\n    *** RULES\n    ***\n\n    vars ID1 ID2 ID3 : Identifier .\n    var PS : Participants .\n    vars P P' : Participant .\n    vars SK SK' : SKey .\n    vars PK PK' PK_Eve : PKey .\n    vars Cs Cs' Hs Es : Pair .\n    vars C M : Polynomial .\n    vars E0 E1 : Polynomial .\n    vars KS1 KS2 KS3 : Keys .\n    vars SAM1 : Polynomial .\n    vars SAM2 : Pair .\n    vars M_sampled : Polynomial .\n    vars CONT1 CONT2 CONT3 : Content .\n\n    ***\n    *** HONEST PARTICIPANT BEHAVIOUR\n    ***\n\n    *** For now the protocol only starts when the participant can sample necesary values for keygen\n\n    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]peer(none)) PS >net(emptyM)\n                    =>\n                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]peer(none) sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(emptyM)\n                    if PK := (second(SAM2) p* inv(first(SAM2))) .\n\n    --- The public key is sent\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .\n\n    *** The public key is consumed to generate a shared key\n    crl [Enc] : {ms(M_sampled CONT1) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, SK) ; KS2]peer(ID1) mI(ID2, M_sampled) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(M_sampled) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    Cs := [(E0 p+ (E1 p* (PK))), (M_sampled xorD L(Es))] /\\\n                    SK := K(M_sampled, Cs) .\n\n    *** The ciphered text is sent\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)})\n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\\n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n\n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS')\n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    *** The ciphered text is consumed to generate the shared key\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := second(Cs) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    ***\n    *** INTRUDER BEHAVIOUR\n    ***\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK_Eve) ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)})\n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')})\n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(ID1,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs) peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs)})\n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,Cs') peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')})\n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(ID2,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,1) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, SK) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)})\n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm\n```"]], "MAUDE-1/closeSocketFeb2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that closing a server TCP socket that is waiting\n***\tto accept connections doesn't cause Maude to spin its wheels\n***\twaiting for events on the closed socket.\n***\nload socket\n\nmod SERVER-SHUTDOWN is\n        protecting SOCKET .\n        op Server : -> Cid [ctor] .\n        op server : -> Oid [ctor] .\n        op state:_ : ServerState -> Attribute [ctor] .\n\n        sort ServerState .\n        ops init closing : -> ServerState [ctor] .\n        op  accepting    : Oid -> ServerState [ctor] .\n\n    var SSkt   : Oid .\n    var Reason : String .\n        rl [createdSocket] :\n                < server : Server | state: init >\n                createdSocket(server, socketManager, SSkt)\n        =>\n                < server : Server | state: accepting(SSkt) >\n                acceptClient(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: accepting(SSkt) >\n        =>\n                < server : Server | state: closing >\n                closeSocket(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: closing >\n                closedSocket(server, SSkt, Reason)\n        =>\n                none\n        .\n        op initial : -> Configuration .\n        eq initial = <> < server : Server | state: init >\n                     createServerTcpSocket(socketManager, server, 1234, 5) .\nendm\n\nerew initial .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that closing a server TCP socket that is waiting\n***\tto accept connections doesn't cause Maude to spin its wheels\n***\twaiting for events on the closed socket.\n***\nload socket\n\nmod SERVER-SHUTDOWN is\n        protecting SOCKET .\n        op Server : -> Cid [ctor] .\n        op server : -> Oid [ctor] .\n        op state:_ : ServerState -> Attribute [ctor] .\n\n        sort ServerState .\n        ops init closing : -> ServerState [ctor] .\n        op  accepting    : Oid -> ServerState [ctor] .\n\n    var SSkt   : Oid .\n    var Reason : String .\n        rl [createdSocket] :\n                < server : Server | state: init >\n                createdSocket(server, socketManager, SSkt)\n        =>\n                < server : Server | state: accepting(SSkt) >\n                acceptClient(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: accepting(SSkt) >\n        =>\n                < server : Server | state: closing >\n                closeSocket(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: closing >\n                closedSocket(server, SSkt, Reason)\n        =>\n                none\n        .\n        op initial : -> Configuration .\n        eq initial = <> < server : Server | state: init >\n                     createServerTcpSocket(socketManager, server, 1234, 5) .\nendm\n\nerew initial .\n```"]], "MAUDE-1/complexParserSyncApril2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, \"\nmod NAT is\n  op authReq : Nat -> Msg .\n  op authResp : Nat -> Msg .\n  op publicKey : Nat -> Key .\n  op privateKey : Nat -> Key .\n  op clientState : Nat -> State .\n  op serverState : Nat -> State .\n  op keyExchange : Nat Nat -> Msg .\n  op authenticate : Msg Msg -> Bool .\nendm\n\"), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, \"\nmod NAT is\n  op authReq : Nat -> Msg .\n  op authResp : Nat -> Msg .\n  op publicKey : Nat -> Key .\n  op privateKey : Nat -> Key .\n  op clientState : Nat -> State .\n  op serverState : Nat -> State .\n  op keyExchange : Nat Nat -> Msg .\n  op authenticate : Msg Msg -> Bool .\nendm\n\"), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\n```"]], "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Bar [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Bar [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab .\n```"]], "MAUDE-1/CUIbug12-22-09.maude": [[true, "***(\nBug discovered 12/22/09.\n\nCUI_DagNode::stackArguments() checks the wrong UNSTACKABLE flag for the\nsecond argument resulting in a missed rewrite.\n\nResolved in alpha92b.\n)\nset show timing off .\n\nmod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl c => d .\nendm\n\nrew f(a, g(b)) .\n\n***(\nfirst pass:\nf does not rewrite - marked unrewritable\nf stacks a and g(b)\na does not rewrite - marked unrewritable\ng(b) does not rewrite - marked unrewritable\na does not stack anything and is unrewritable - marked unstackable\ng stacks b\nb rewrites to c and we rebuild f(a, g(c)) with only the a node shared\nwith the previous dag\n\nsecond pass:\nf is unrewritable\nf cannot stack a because it is unstackable\nf cannot stack g(c) because we check the wrong unstackable flag\n\nthus we miss c => d\n)\n\nmod CUI-BUG2 is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl g(c) => d .\nendm\n\nrew f(a, g(b)) .", "```maude\n***(\nBug discovered 12/22/09.\n\nCUI_DagNode::stackArguments() checks the wrong UNSTACKABLE flag for the\nsecond argument resulting in a missed rewrite.\n\nResolved in alpha92b.\n)\nset show timing off .\n\nmod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl c => d .\nendm\n\nrew f(a, g(b)) .\n\n***(\nfirst pass:\nf does not rewrite - marked unrewritable\nf stacks a and g(b)\na does not rewrite - marked unrewritable\ng(b) does not rewrite - marked unrewritable\na does not stack anything and is unrewritable - marked unstackable\ng stacks b\nb rewrites to c and we rebuild f(a, g(c)) with only the a node shared\nwith the previous dag\n\nsecond pass:\nf is unrewritable\nf cannot stack a because it is unstackable\nf cannot stack g(c) because we check the wrong unstackable flag\n\nthus we miss c => d\n)\n\nmod CUI-BUG2 is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl g(c) => d .\nendm\n\nrew f(a, g(b)) .\n```"]], "MAUDE-1/CUI_OccursCheckSeptember2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for nontermination in U and CU unification due to\n***\tnot doing an indirect occurs check. We use irred because\n***\twe might reduce the number of redundant unifiers in the\n***\tfuture.\n***\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [comm id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for nontermination in U and CU unification due to\n***\tnot doing an indirect occurs check. We use irred because\n***\twe might reduce the number of redundant unifiers in the\n***\tfuture.\n***\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [comm id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n```"]], "MAUDE-1/CU_Unification.maude": [[true, "set show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [assoc l-id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [assoc r-id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op f : Foo Foo -> Foo [id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .", "```maude\nset show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [assoc l-id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [assoc r-id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op f : Foo Foo -> Foo [id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe.maude": [[true, "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name , Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _ ; _ : Msg  Msg  -> Msg [assoc id: empty] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name , Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _ ; _ : Msg  Msg  -> Msg [assoc id: empty] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude": [[true, "load i_BASIC_NPA.maude .\n\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .", "```maude\nload i_BASIC_NPA.maude .\n\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .\n```"]], "MAUDE-1/dekker.maude": [[true, "set show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> Program .\n  op if_then_fi : Test Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n  inc TESTS .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) .", "```maude\nset show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> Program .\n  op if_then_fi : Test Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n  inc TESTS .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) .\n```"]], "MAUDE-1/deleteTimerMarch2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where deleteTimer() left the interpreter in an\n***\tinconsistent state and caused a crash on the next rewrite\n***\tcommand.\n***\n\nload time\n\nmod TEST is\n  inc TIME .\n  op myClass : -> Cid .\n  ops me : -> Oid .\n\nvars O O2 O3 : Oid .\n  rl < O : myClass | none > createdTimer(O, O2, O3) =>\n     < O : myClass | none > deleteTimer(O3, me) .\nendm\n\nerew <> < me : myClass | none > createTimer(timeManager, me) .\nred 0 .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where deleteTimer() left the interpreter in an\n***\tinconsistent state and caused a crash on the next rewrite\n***\tcommand.\n***\n\nload time\n\nmod TEST is\n  inc TIME .\n  op myClass : -> Cid .\n  ops me : -> Oid .\n\nvars O O2 O3 : Oid .\n  rl < O : myClass | none > createdTimer(O, O2, O3) =>\n     < O : myClass | none > deleteTimer(O3, me) .\nendm\n\nerew <> < me : myClass | none > createTimer(timeManager, me) .\nred 0 .\n```"]], "MAUDE-1/dining-philosophers5.maude": [[true, "fmod POSRAT-TIME-DOMAIN-WITH-INF is\n  protecting NNEG-RAT .\n  sort TimeInf .\n  subsort NNegRat < TimeInf .\n  op INF : -> TimeInf [ctor] .\n\n  op _<_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _<=_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _>_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _+_ : NNegRat NNegRat -> NNegRat [assoc comm prec 33 gather (E e)] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : Zero Zero -> Zero [ditto] .\n  op max : Zero NzNat -> NzNat [ditto] .\n  op max : Rat TimeInf -> TimeInf [ditto] .\n  op max : Rat Rat -> Rat [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    ----sort Philosopher .\n    ----subsort Philosopher < Cid .\n    ----op Philosopher : -> Philosopher [ctor] .\n    ----op status :_ : Status -> Attribute [ctor gather (&)] .\n    ----op chopsticks :_ : Nat -> Attribute [ctor gather (&)] .\n    ----op timer :_ : Time -> Attribute [ctor gather (&)] .\n\n    class Chopstick .\n    ---- sort Chopstick .\n    ---- subsort Chopstick < Cid .\n    ---- op Chopstick : -> Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I J N M K : Nat .\n    vars Atts Atts1 Atts2 : AttributeSet .\n    vars T T' : Time .\n    var Conf : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : P:Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : P:Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op mte : Configuration -> Time .\n    eq mte(< I : P:Philosopher | timer : T, Atts1 > Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration Time -> Configuration .\n    eq delta(< I : Philosopher | timer : T > Conf, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat Status -> Prop .\n    op phil-sticks : Nat Nat -> Prop .\n    \n    vars P N : Nat .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, 1) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(3, 1) /\\ phil-sticks(4, 1))) .", "```maude\nfmod POSRAT-TIME-DOMAIN-WITH-INF is\n  protecting NNEG-RAT .\n  sort TimeInf .\n  subsort NNegRat < TimeInf .\n  op INF : -> TimeInf [ctor] .\n\n  op _<_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _<=_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _>_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _+_ : NNegRat NNegRat -> NNegRat [assoc comm prec 33 gather (E e)] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : Zero Zero -> Zero [ditto] .\n  op max : Zero NzNat -> NzNat [ditto] .\n  op max : Rat TimeInf -> TimeInf [ditto] .\n  op max : Rat Rat -> Rat [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    ----sort Philosopher .\n    ----subsort Philosopher < Cid .\n    ----op Philosopher : -> Philosopher [ctor] .\n    ----op status :_ : Status -> Attribute [ctor gather (&)] .\n    ----op chopsticks :_ : Nat -> Attribute [ctor gather (&)] .\n    ----op timer :_ : Time -> Attribute [ctor gather (&)] .\n\n    class Chopstick .\n    ---- sort Chopstick .\n    ---- subsort Chopstick < Cid .\n    ---- op Chopstick : -> Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I J N M K : Nat .\n    vars Atts Atts1 Atts2 : AttributeSet .\n    vars T T' : Time .\n    var Conf : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : P:Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : P:Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op mte : Configuration -> Time .\n    eq mte(< I : P:Philosopher | timer : T, Atts1 > Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration Time -> Configuration .\n    eq delta(< I : Philosopher | timer : T > Conf, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat Status -> Prop .\n    op phil-sticks : Nat Nat -> Prop .\n    \n    vars P N : Nat .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, 1) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(3, 1) /\\ phil-sticks(4, 1))) .\n```"]], "MAUDE-1/diophantine.maude": [[true, "set show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector, \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1),\n\"gcd\"\n) .", "```maude\nset show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector, \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1),\n\"gcd\"\n) .\n```"]], "MAUDE-1/doubleAttributeFebruary2023.maude": [[true, "fmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm", "```maude\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm\n```"]], "MAUDE-1/Example1.maude": [[true, "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN\n  = {nilcontexts} > ('X : v(1)) |-\n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >\n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .", "```maude\n***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN\n  = {nilcontexts} > ('X : v(1)) |-\n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >\n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .\n```"]], "MAUDE-1/Example3.maude": [[true, "***(\n3. Assume that N is as before\nNode N {\n StartCondition: LookUpOnChange(X,5) >= 9\n x := LookUpNow(X)\n}\n\nand that Sigma(I,X) = 8, Gamma(i-1,X) = 11. The execution of N ends with x\nhaving a value of 11 (independently of the fact that the \"real\" value of X,\ni.e., Sigma(i,X) = 1,  isn't >= 9).\n\nExplanation:\nSince there is a monitor on the variable X and that monitor doesn't hold at\ncurrent time, Gamma(i,X) gets the value Gamma(i-1,X), i.e., 11. By\ndefinition, both LookUpOnChange(X,5) and LookUpNow(X) evaluate to Gamma(i,X)\n= 11. \n***)\n\nmod EXAMPLE3 is\n protecting PLEXILITE-PREDS .\n\n op Example3 : -> Plexil .\n eq Example3 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   lookupOnChange('X,v(5)) >= const(v(9))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example3Env : -> ContextList .\n eq Example3Env = ('X : v(3)) # ('X : v(7)) # ('X : v(11)) .\n\nendm\n\neof\n\nsrew compile(Example3Env,Example3) using micro ! .\nsrew compile(Example3Env,Example3) using micro ! ; macro ; micro ! .", "```maude\n***(\n3. Assume that N is as before\nNode N {\n StartCondition: LookUpOnChange(X,5) >= 9\n x := LookUpNow(X)\n}\n\nand that Sigma(I,X) = 8, Gamma(i-1,X) = 11. The execution of N ends with x\nhaving a value of 11 (independently of the fact that the \"real\" value of X,\ni.e., Sigma(i,X) = 1,  isn't >= 9).\n\nExplanation:\nSince there is a monitor on the variable X and that monitor doesn't hold at\ncurrent time, Gamma(i,X) gets the value Gamma(i-1,X), i.e., 11. By\ndefinition, both LookUpOnChange(X,5) and LookUpNow(X) evaluate to Gamma(i,X)\n= 11. \n***)\n\nmod EXAMPLE3 is\n protecting PLEXILITE-PREDS .\n\n op Example3 : -> Plexil .\n eq Example3 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   lookupOnChange('X,v(5)) >= const(v(9))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example3Env : -> ContextList .\n eq Example3Env = ('X : v(3)) # ('X : v(7)) # ('X : v(11)) .\n\nendm\n\neof\n\nsrew compile(Example3Env,Example3) using micro ! .\nsrew compile(Example3Env,Example3) using micro ! ; macro ; micro ! .\n```"]], "MAUDE-1/fakeParameterConstant.maude": [[true, "fth T is\n  sort Elt .\n  op c : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> X$Elt [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "```maude\nfth T is\n  sort Elt .\n  op c : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> X$Elt [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/fakeParameterSort.maude": [[true, "***\n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < X$Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "```maude\n***\n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < X$Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude": [[true, "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars NA NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(b,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(b, NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(a, NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; NA)), +(pk(a, NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars NA NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(b,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(b, NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(a, NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; NA)), +(pk(a, NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/filteredVariantUnifyJune2023.maude": [[true, "set show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat -> Stk [ctor] .\n  op _*_ : Stk Stk -> Stk [ assoc id: emp] .\n  op _+_ : Stk Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : Stk . *** NOTE: The original incomplete file had 'vars X Y : [Stk] .'.\n                     *** This syntax is invalid in Maude and would prevent successful compilation.\n                     *** It has been corrected to 'vars X Y : Stk .' to ensure the code compiles as requested.\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches", "```maude\nset show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat -> Stk [ctor] .\n  op _*_ : Stk Stk -> Stk [ assoc id: emp] .\n  op _+_ : Stk Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : Stk . *** NOTE: The original incomplete file had 'vars X Y : [Stk] .'.\n                     *** This syntax is invalid in Maude and would prevent successful compilation.\n                     *** It has been corrected to 'vars X Y : Stk .' to ensure the code compiles as requested.\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches\n```"]], "MAUDE-1/generatedByFebruary2023.maude": [[true, "fmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .", "```maude\nfmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .\n```"]], "MAUDE-1/hf-sets.maude": [[true, "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .   *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({\n    @5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@2:Magma})U augment(P({@3:Magma}),@2:Set),\n    @1:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)", "```maude\nset include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .   *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({\n    @5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@2:Magma})U augment(P({@3:Magma}),@2:Set),\n    @1:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)\n```"]], "MAUDE-1/identityUnificationMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in C/U/Ul/Ur unification where original\n***\trather than representative variable was used.\n***\n\nfmod FOO is\n  sort Small Foo .\n  subsort Small < Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\n  op g : Foo -> Foo .\nvars X Y Z : Foo .\nvar S : Small .\nendfm\n\nunify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nvariant unify Z =? f(X, Y) /\\ g(Z) =? g(S) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in C/U/Ul/Ur unification where original\n***\trather than representative variable was used.\n***\n\nfmod FOO is\n  sort Small Foo .\n  subsort Small < Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\n  op g : Foo -> Foo .\nvars X Y Z : Foo .\nvar S : Small .\nendfm\n\nunify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nvariant unify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n```"]], "MAUDE-1/instantiatedViewInternalNameOctober2022.maude": [[true, "set show advisories off .\n\n***\n***\tTest for bug in the internal name of a multiply instantiated view which\n***\tbecomes visible because parameterized sorts instantiated with this view\n***\tappear to be different from the same sorts created by the parser.\n***\nfmod FOO{X :: STRICT-WEAK-ORDER} is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{X}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{X}} .\nendfm\n\nshow kinds .\n\nfmod BAR is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\nendfm\n\nshow kinds .", "```maude\nset show advisories off .\n\n***\n***\tTest for bug in the internal name of a multiply instantiated view which\n***\tbecomes visible because parameterized sorts instantiated with this view\n***\tappear to be different from the same sorts created by the parser.\n***\nfmod FOO{X :: STRICT-WEAK-ORDER} is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{X}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{X}} .\nendfm\n\nshow kinds .\n\nfmod BAR is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\nendfm\n\nshow kinds .\n```"]], "MAUDE-1/instantiationJuly2019.maude": [[true, "set show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .", "```maude\nset show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .\n```"]], "MAUDE-1/initialEqualityPredicate.maude": [[true, "set show timing off .\nset show advisories off .\n\nfmod DECOMPOSE is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sorts Nat String .\n  op 0 : -> Nat .\n  ops f g : Nat Nat -> Nat [ctor] .\n  ops h i : Nat Nat -> String [ctor] .\n  op c : Nat Nat -> Nat [ctor comm] .\n  ops b : Nat Nat -> Nat [assoc comm id: 0] .\n  op s : Nat -> Nat [iter ctor] .\n  vars W X Y Z : Nat .\n  vars A B C D : Nat .\nendfm\n\nred X .=. X .\nred X .=. Y .\n\n*** free\nred f(X, Y) .=. f(Y, Z) .\nred f(X, Y) .=. f(Y, X) .\nred f(X, Y) .=. X .\nred f(f(X, Y), Z) .=. f(X, Y) .\nred f(X, Y) .=. g(W, Z) .\nred h(X, Y) .=. h(W, Z) .\nred h(X, Y) .=. h(Y, X) .\nred h(X, Y) .=. i(W, Z) .\n\n*** dissimilar collapse symbol\nred f(X, Y) .=. b(W, Z) .\n\n*** iter\nred s^100(X) .=. s^40(X) .\nred s^100(X) .=. s^40(Y) .\nred s^10(X) .=. s^10(Y) .\n\n*** commutative\nred c(X, Y) .=. c(A, B) .\nred c(X, Y) .=. c(A, X) .\nred c(c(X, Y), Z) .=. c(X, Y) .\n\n*** compound\nred c(f(X, Y), g(W, Z)) .=. c(g(A, B), f(C, D)) .\nred c(f(X, Y), g(W, Z)) .=. c(f(A, B), f(C, D)) .\n\n\nfmod FOO is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sort Foo .\n  ops a b c 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc] .\n  op _+_ : Foo Foo -> Foo [assoc comm] .\n  op s : Foo Foo -> Foo [comm] .\n  op f : Foo Foo -> Foo [assoc comm id: 1] .\n  ops g h p : Foo -> Foo .\n  var A B C D E W X Y Z : Foo .\n  eq p(X) = g(h(X)) .\nendfm\n\n*** ctor declaration not needed for decomposition\nred g(X) .=. g(Y) .\n\n*** ground vs equationally-stable\nred f(a, g(b), c) .=. h(X) .\n\n*** canceling under commutative\nred s(g(X), Z) .=. s(Y, g(X)) .\n\n*** AC\nred g(A) + g(B) + g(C) .=. g(A) + B + h(C) .\nred g(A) + g(B) + g(C) .=. g(A) + B .\n\n*** associative\nred g(A) (B) X h(A) Y h(C) .=. h(A) g(D) g(E) Z X h(A) .\nred g(A) X Y h(A) h(C) .=. g(D) g(E) g(D) X h(A) .\nred g(A) g(B) X h(A) Y h(C) .=. g(D) g(E) Z X h(A) .", "```maude\nset show timing off .\nset show advisories off .\n\nfmod DECOMPOSE is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sorts Nat String .\n  op 0 : -> Nat .\n  ops f g : Nat Nat -> Nat [ctor] .\n  ops h i : Nat Nat -> String [ctor] .\n  op c : Nat Nat -> Nat [ctor comm] .\n  ops b : Nat Nat -> Nat [assoc comm id: 0] .\n  op s : Nat -> Nat [iter ctor] .\n  vars W X Y Z : Nat .\n  vars A B C D : Nat .\nendfm\n\nred X .=. X .\nred X .=. Y .\n\n*** free\nred f(X, Y) .=. f(Y, Z) .\nred f(X, Y) .=. f(Y, X) .\nred f(X, Y) .=. X .\nred f(f(X, Y), Z) .=. f(X, Y) .\nred f(X, Y) .=. g(W, Z) .\nred h(X, Y) .=. h(W, Z) .\nred h(X, Y) .=. h(Y, X) .\nred h(X, Y) .=. i(W, Z) .\n\n*** dissimilar collapse symbol\nred f(X, Y) .=. b(W, Z) .\n\n*** iter\nred s^100(X) .=. s^40(X) .\nred s^100(X) .=. s^40(Y) .\nred s^10(X) .=. s^10(Y) .\n\n*** commutative\nred c(X, Y) .=. c(A, B) .\nred c(X, Y) .=. c(A, X) .\nred c(c(X, Y), Z) .=. c(X, Y) .\n\n*** compound\nred c(f(X, Y), g(W, Z)) .=. c(g(A, B), f(C, D)) .\nred c(f(X, Y), g(W, Z)) .=. c(f(A, B), f(C, D)) .\n\n\nfmod FOO is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sort Foo .\n  ops a b c 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc] .\n  op _+_ : Foo Foo -> Foo [assoc comm] .\n  op s : Foo Foo -> Foo [comm] .\n  op f : Foo Foo -> Foo [assoc comm id: 1] .\n  ops g h p : Foo -> Foo .\n  var A B C D E W X Y Z : Foo .\n  eq p(X) = g(h(X)) .\nendfm\n\n*** ctor declaration not needed for decomposition\nred g(X) .=. g(Y) .\n\n*** ground vs equationally-stable\nred f(a, g(b), c) .=. h(X) .\n\n*** canceling under commutative\nred s(g(X), Z) .=. s(Y, g(X)) .\n\n*** AC\nred g(A) + g(B) + g(C) .=. g(A) + B + h(C) .\nred g(A) + g(B) + g(C) .=. g(A) + B .\n\n*** associative\nred g(A) (B) X h(A) Y h(C) .=. h(A) g(D) g(E) Z X h(A) .\nred g(A) X Y h(A) h(C) .=. g(D) g(E) g(D) X h(A) .\nred g(A) g(B) X h(A) Y h(C) .=. g(D) g(E) Z X h(A) .\n```"]], "MAUDE-1/irredUnifyFeb2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug irredundant unification where destructive updating\n***\tof unifiers having the same structure but different sorts caused\n***\tcorruption of unification filter and irredundant unifiers lost\n***\tto spurious subsumptions.\n***\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt Pair ____(Triple)____ < List .\n  op __ : ____(List)____ List -> List [____(assoc id: nil)____] .\n  op __ : ____(Elt)____ Elt -> Pair [____(assoc)____] .\n  op __ : ____(Elt)____ ____(Pair)____ -> Triple [assoc] .\n  op __ : Pair ____(Elt)____ -> ____(Triple)____ [assoc] .\n\n  op ____(rev)____ : List -> List .\n  vars A B C ____(X)____ Y Z : ____(List)____ .\n  vars ____(P)____ Q R : Pair .\n  vars ____(E)____ F G : Elt .\n  vars S ____(T)____ U V : ____(Triple)____ .\nendfm\n\nunify S T =? A B .\nirred unify S T =? A B .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug irredundant unification where destructive updating\n***\tof unifiers having the same structure but different sorts caused\n***\tcorruption of unification filter and irredundant unifiers lost\n***\tto spurious subsumptions.\n***\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt Pair ____(Triple)____ < List .\n  op __ : ____(List)____ List -> List [____(assoc id: nil)____] .\n  op __ : ____(Elt)____ Elt -> Pair [____(assoc)____] .\n  op __ : ____(Elt)____ ____(Pair)____ -> Triple [assoc] .\n  op __ : Pair ____(Elt)____ -> ____(Triple)____ [assoc] .\n\n  op ____(rev)____ : List -> List .\n  vars A B C ____(X)____ Y Z : ____(List)____ .\n  vars ____(P)____ Q R : Pair .\n  vars ____(E)____ F G : Elt .\n  vars S ____(T)____ U V : ____(Triple)____ .\nendfm\n\nunify S T =? A B .\nirred unify S T =? A B .\n```"]], "MAUDE-1/kindNameDecember2022.maude": [[true, "set show advisories off .\n\n***\n***\tTest for bug where kinds were printed incorrectly from premodules.\n***\n\nfmod FOO{X :: TRIV} is\n  sorts S{X} T{X} .\n  subsort X$Elt < S{X} T{X} .\n  op f : [S{X},T{X}] -> [S{X},T{X}] .\nendfm\n\nshow mod .", "```maude\nset show advisories off .\n\n***\n***\tTest for bug where kinds were printed incorrectly from premodules.\n***\n\nfmod FOO{X :: TRIV} is\n  sorts S{X} T{X} .\n  subsort X$Elt < S{X} T{X} .\n  op f : [S{X},T{X}] -> [S{X},T{X}] .\nendfm\n\nshow mod .\n```"]], "MAUDE-1/lattice.maude": [[true, "set include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** sup\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** inf\n  op c :  Lat -> Lat .                     *** complement\n\n  vars ____(X)____ ____(Y)____ Z : Lat .\n\n  *** idempotency\n  eq [LAT-01] : ____(X)____ \\/ X = X .\n  eq [LAT-02] : X /\\ X = X .\n  *** extensions\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .\n\n  *** identities\n  eq [LAT-05] : X \\/ 0 = X .\n  eq [LAT-06] : X /\\ 1 = X .\n  \n  *** simple absorption (follows from identities and absorption)\n  eq [LAT-07] : 1 \\/ X = 1 .\n  eq [LAT-08] : 0 /\\ X = 0 .\n  *** absorption\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .\n  eq [LAT-10] : X \\/ (____(X /\\ Y)____) = X .\n  *** extensions\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .\n\n  *** modular lattice axiom\n ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) = X .\n\n  *** complement axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .\n  eq [LAT-15] : X /\\ c(X) = 0 .\n  *** extensions\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .\n  ***\n  eq [LAT-18] : c(0) = 1 .\n  eq [LAT-19] : c(1) = 0 .\n  ***\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .\n  *** extensions\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .\nendfm", "```maude\nset include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** sup\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** inf\n  op c :  Lat -> Lat .                     *** complement\n\n  vars ____(X)____ ____(Y)____ Z : Lat .\n\n  *** idempotency\n  eq [LAT-01] : ____(X)____ \\/ X = X .\n  eq [LAT-02] : X /\\ X = X .\n  *** extensions\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .\n\n  *** identities\n  eq [LAT-05] : X \\/ 0 = X .\n  eq [LAT-06] : X /\\ 1 = X .\n  \n  *** simple absorption (follows from identities and absorption)\n  eq [LAT-07] : 1 \\/ X = 1 .\n  eq [LAT-08] : 0 /\\ X = 0 .\n  *** absorption\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .\n  eq [LAT-10] : X \\/ (____(X /\\ Y)____) = X .\n  *** extensions\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .\n\n  *** modular lattice axiom\n ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) = X .\n\n  *** complement axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .\n  eq [LAT-15] : X /\\ c(X) = 0 .\n  *** extensions\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .\n  ***\n  eq [LAT-18] : c(0) = 1 .\n  eq [LAT-19] : c(1) = 0 .\n  ***\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .\n  *** extensions\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .\nendfm\n```"]], "MAUDE-1/nsl-db-dc.maude": [[true, "--- houzhui\n--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name Nonce NonceSet < Msg .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [gather (e E) assoc] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Y Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r''' r'' : Fresh .\n  vars A B C : Name .\n  vars N NA NB N' NC : Nonce .\n  vars NS NS' : NonceSet .\n  vars X Y Z H : Msg .\n  vars P Q : Role .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(NS), -(Y), +(NS * Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; 1-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(A,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(B,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n--- houzhui\n--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name Nonce NonceSet < Msg .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [gather (e E) assoc] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Y Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r''' r'' : Fresh .\n  vars A B C : Name .\n  vars N NA NB N' NC : Nonce .\n  vars NS NS' : NonceSet .\n  vars X Y Z H : Msg .\n  vars P Q : Role .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(NS), -(Y), +(NS * Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; 1-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(A,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(B,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/legacyMetaGetVariant.maude": [[true, "set show timing off .\n\nfmod XOR is\n  sort XOR .\n\n  sort Elem .\n  ops cst1 cst2 cst3 cst4 : -> Elem .\n\n  subsort Elem < XOR .\n  op _+_ : ____(XOR)____ XOR -> XOR [____(id: 0)____ assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X ____(Y)____ : XOR .\n\n  eq Y + 0 = Y [variant] .\n  eq X + X = 0 [variant] .\n  eq X + X + Y = Y [variant] .\nendfm\n\nfmod TEST is\n  inc XOR .\n  inc META-LEVEL .\nendfm\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(upModule('XOR, false), upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 10, 0) .\n\nred metaGetVariant([____('XOR)____], upTerm(____(X:XOR + cst1)____), empty, 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 2) .\nred metaGetVariant([____('XOR)____], upTerm(____(X:XOR + cst1)____), empty, 0, 3) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 4) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(____(X:XOR + a)____), 0, 0) .\nred metaGetVariant(['XOR], upTerm(____(X:XOR + cst2)____), upTerm(____(X:XOR + a)____), 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 3) .", "```maude\nset show timing off .\n\nfmod XOR is\n  sort XOR .\n\n  sort Elem .\n  ops cst1 cst2 cst3 cst4 : -> Elem .\n\n  subsort Elem < XOR .\n  op _+_ : ____(XOR)____ XOR -> XOR [____(id: 0)____ assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X ____(Y)____ : XOR .\n\n  eq Y + 0 = Y [variant] .\n  eq X + X = 0 [variant] .\n  eq X + X + Y = Y [variant] .\nendfm\n\nfmod TEST is\n  inc XOR .\n  inc META-LEVEL .\nendfm\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(upModule('XOR, false), upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 10, 0) .\n\nred metaGetVariant([____('XOR)____], upTerm(____(X:XOR + cst1)____), empty, 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 2) .\nred metaGetVariant([____('XOR)____], upTerm(____(X:XOR + cst1)____), empty, 0, 3) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 4) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(____(X:XOR + a)____), 0, 0) .\nred metaGetVariant(['XOR], upTerm(____(X:XOR + cst2)____), upTerm(____(X:XOR + a)____), 0, 1) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 2) .\nred metaGetVariant(['XOR], upTerm(X:XOR + cst2), upTerm(X:XOR + a), 0, 3) .\n```"]], "MAUDE-1/mapToParameterTheory.maude": [[true, "set show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\nendfth\n\nfmod M{X :: T} is\n  sort Foo{X} .\n  op f : X$Elt -> Foo{X} .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\nendv\n\nfmod C is\n  sort Bar .\n  op a : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nendv\n\nfmod M2{Y :: T2} is\n  sort Baz{Y} .\n  op g : Y$Elt2 -> Baz{Y} .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** Continue with implicit-explicit, explicit-implicit, and other cases similarly as above.\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op _+_ : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  *** _+_ in fromTheory is implicitly mapped to _+_ in parameterTheory\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = X + Y .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** _+_ in eq h(X, Y) = X + Y should be mapped to _+_ in T by V, but then\n*** V2 instantiates the operator from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, Y:Bar) .\n\n\n******************************************\n*** op->term-explicit operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\nvars X Y : Elt2 .\n  op sum(X, Y) to term X + g(Y) .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to X + g(Y) by V, but then\n*** V2 instantiates the operator _+_ from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, g(Y:Bar)) .\n\n\n******************************************\n*** explicit-op->term operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to _+_ .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y : Elt .\n  op X + Y to term summation(inv(Y), inv(X)) .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to _+_ by V, but then\n*** V2 instantiates the operator from the parameter theory to summation\n*** summation(inv(Y), inv(X)) so we get\n***   eq h(X:Bar, Y:Bar) = summation(inv(Y:Bar), inv(X:Bar)) .\n\n\n*************************************************************\n*** explicit-op->term operator mapping with lost variable ***\n*************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y Z : Elt .\n  op +(X, Y, Z) to term summation(inv(X), inv(Z)) .  *** Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y Z : Y$Elt2 .\n  eq h(X, Y, Z) = sum(X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************************\n*** explicit-op->term operator mapping with two lost variables ***\n******************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars W, X Y Z : Elt .\n  op +(W, X, Y, Z) to term summation(inv(X), inv(Z)) .  *** W, Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars W, X Y Z : Y$Elt2 .\n  eq h(W, X, Y, Z) = sum(W, X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(W:Bar, X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************\n*** explicit-explicit polymorphic operator mapping ***\n******************************************************\n\nfth T is\n  sort Elt .\n  op f : Elt Universal -> Universal [poly(2 1)] .\n  ops a b : -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op f2 : Elt2 Universal -> Universal [poly(2 1)] .\nendfth\n\nfmod M{X :: T} is\n  sort One{X} Two{X} .\n  op g1 : One{X} -> One{X} .\n  op g2 : Two{X} -> Two{X} .\nvar X : One{X} .\nvar Y : Two{X} .\n  eq g1(X) = f(a, X) .\n  eq g2(Y) = f(b, Y) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\n  op f2 to f .  *** map polymorphic operator f2 to polymorphic operator f in parameter theory\nendv\n\nfmod C is\n  sort Bar .\n  op h : Bar Universal -> Universal [poly(2 0)] .\n  ops 1 2 : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op f to h .\n  op a to 1 .\n  op b to 2 .\nendv\n\nfmod M2{Y :: T2} is\n  sort MySort .\n  op p : Y$Elt2 MySort -> MySort .\nvar X : Y$Elt2 .\nvar Y : MySort .\n  eq p(X, Y) = f2(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\nred p(1, 2) .", "```maude\nset show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\nendfth\n\nfmod M{X :: T} is\n  sort Foo{X} .\n  op f : X$Elt -> Foo{X} .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\nendv\n\nfmod C is\n  sort Bar .\n  op a : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nendv\n\nfmod M2{Y :: T2} is\n  sort Baz{Y} .\n  op g : Y$Elt2 -> Baz{Y} .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** Continue with implicit-explicit, explicit-implicit, and other cases similarly as above.\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op _+_ : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  *** _+_ in fromTheory is implicitly mapped to _+_ in parameterTheory\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = X + Y .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** _+_ in eq h(X, Y) = X + Y should be mapped to _+_ in T by V, but then\n*** V2 instantiates the operator from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, Y:Bar) .\n\n\n******************************************\n*** op->term-explicit operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\nvars X Y : Elt2 .\n  op sum(X, Y) to term X + g(Y) .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to X + g(Y) by V, but then\n*** V2 instantiates the operator _+_ from the parameter theory to summation so we get\n***   eq h(X:Bar, Y:Bar) = summation(X:Bar, g(Y:Bar)) .\n\n\n******************************************\n*** explicit-op->term operator mapping ***\n******************************************\n\nfth T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = X + X .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to _+_ .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y : Elt .\n  op X + Y to term summation(inv(Y), inv(X)) .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y : Y$Elt2 .\n  eq h(X, Y) = sum(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** sum in eq h(X, Y) = sum(X, Y) should be mapped to _+_ by V, but then\n*** V2 instantiates the operator from the parameter theory to summation\n*** summation(inv(Y), inv(X)) so we get\n***   eq h(X:Bar, Y:Bar) = summation(inv(Y:Bar), inv(X:Bar)) .\n\n\n*************************************************************\n*** explicit-op->term operator mapping with lost variable ***\n*************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars X Y Z : Elt .\n  op +(X, Y, Z) to term summation(inv(X), inv(Z)) .  *** Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars X Y Z : Y$Elt2 .\n  eq h(X, Y, Z) = sum(X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************************\n*** explicit-op->term operator mapping with two lost variables ***\n******************************************************************\n\nfth T is\n  sort Elt .\n  op + : Elt Elt Elt Elt -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op sum : Elt2 Elt2 Elt2 Elt2 -> Elt2 .\nendfth\n\nfmod M{X :: T} is\n  op g : X$Elt -> X$Elt .\nvar X : X$Elt .\n  eq g(X) = +(X, X, X, X) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  op sum to + .   *** mapping fromTheory operator to parameterTheory operator\nendv\n\nfmod C is\n  sort Bar .\n  op summation : Bar Bar -> Bar .\n  op inv : Bar -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nvars W, X Y Z : Elt .\n  op +(W, X, Y, Z) to term summation(inv(X), inv(Z)) .  *** W, Y is lost\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 Y$Elt2 Y$Elt2 -> Y$Elt2 .\nvars W, X Y Z : Y$Elt2 .\n  eq h(W, X, Y, Z) = sum(W, X, Y, Z) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n***   eq h(W:Bar, X:Bar, Y:Bar, Z:Bar) = summation(inv(X:Bar), inv(Z:Bar)) .\n\n\n******************************************************\n*** explicit-explicit polymorphic operator mapping ***\n******************************************************\n\nfth T is\n  sort Elt .\n  op f : Elt Universal -> Universal [poly(2 1)] .\n  ops a b : -> Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\n  op f2 : Elt2 Universal -> Universal [poly(2 1)] .\nendfth\n\nfmod M{X :: T} is\n  sort One{X} Two{X} .\n  op g1 : One{X} -> One{X} .\n  op g2 : Two{X} -> Two{X} .\nvar X : One{X} .\nvar Y : Two{X} .\n  eq g1(X) = f(a, X) .\n  eq g2(Y) = f(b, Y) .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\n  op f2 to f .  *** map polymorphic operator f2 to polymorphic operator f in parameter theory\nendv\n\nfmod C is\n  sort Bar .\n  op h : Bar Universal -> Universal [poly(2 0)] .\n  ops 1 2 : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op f to h .\n  op a to 1 .\n  op b to 2 .\nendv\n\nfmod M2{Y :: T2} is\n  sort MySort .\n  op p : Y$Elt2 MySort -> MySort .\nvar X : Y$Elt2 .\nvar Y : MySort .\n  eq p(X, Y) = f2(X, Y) .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\nred p(1, 2) .\n```"]], "MAUDE-1/metaApplyNov2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\treduction of the subject are not counted twice for\n***\tmetaApply()/metaXapply()\n***\n\nmod APPLY is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a c  : -> Bar .\n  op b : -> Foo .\n  op f : Foo Foo -> Foo [comm] .\n\n  eq a = c .\n  mb c : Foo .\n  rl f(X:Foo, Y:Foo) => X:Foo [label k] .\nendm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- '- 'b.Foo, 0) .\nred in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\treduction of the subject are not counted twice for\n***\tmetaApply()/metaXapply()\n***\n\nmod APPLY is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a c  : -> Bar .\n  op b : -> Foo .\n  op f : Foo Foo -> Foo [comm] .\n\n  eq a = c .\n  mb c : Foo .\n  rl f(X:Foo, Y:Foo) => X:Foo [label k] .\nendm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- '- 'b.Foo, 0) .\nred in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0) .\n```"]], "MAUDE-1/metaAutoOoIncludeFebruary2023.maude": [[true, "set show timing off .\n\n***\n***\tTest that auto object-oriented includes show up in the unflattened result of upModule().\n***\n\noth FOO is\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .", "```maude\nset show timing off .\n\n***\n***\tTest that auto object-oriented includes show up in the unflattened result of upModule().\n***\n\noth FOO is\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .\n```"]], "MAUDE-1/metaIntMatchOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\tsort computations in the subject are not counted twice for\n***\tmetaMatch()/metaXmatch()/getMatch()/getXmatch().\n***\n\nfmod MATCH is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\n  op f : Bar Bar -> Bar [comm] .\n  ops g h : Foo -> Foo .\n  ops a b c d e : -> Foo .\n\nvars X Y : Bar .\nvar Z : Foo .\n\n  cmb f(X, Y) : Foo if h(X) = g(Y) .\n  eq h(a) = b .\n  eq g(c) = b .\n  eq h(c) = d .\n  eq g(a) = d .\nendfm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaMatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0) .\n\nred in META-LEVEL : metaXmatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, 0) .\n\nload metaInterpreter\n\nmod MATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getMatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, N) .\nendm\n\nerew in MATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n\n\nmod XMATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getXmatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, N) .\nendm\n\nerew in XMATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\tsort computations in the subject are not counted twice for\n***\tmetaMatch()/metaXmatch()/getMatch()/getXmatch().\n***\n\nfmod MATCH is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\n  op f : Bar Bar -> Bar [comm] .\n  ops g h : Foo -> Foo .\n  ops a b c d e : -> Foo .\n\nvars X Y : Bar .\nvar Z : Foo .\n\n  cmb f(X, Y) : Foo if h(X) = g(Y) .\n  eq h(a) = b .\n  eq g(c) = b .\n  eq h(c) = d .\n  eq g(a) = d .\nendfm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaMatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0) .\n\nred in META-LEVEL : metaXmatch(['MATCH], 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, 0) .\n\nload metaInterpreter\n\nmod MATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln:_ : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getMatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, N) .\nendm\n\nerew in MATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n\n\nmod XMATCH-TEST is\n  pr META-INTERPRETER .\n\n  op me : -> Oid .\n  op User : -> Cid .\n  op soln : Nat -> Attribute .\n\n  vars X Y Z : Oid .\n  var AS : AttributeSet .\n  var N : Nat .\n\n  rl < X : User | AS > createdInterpreter(X, Y, Z) =>\n     < X : User | AS > insertModule(Z, X, upModule('MATCH, true)) .\n\n  rl < X : User | soln: N, AS > insertedModule(X, Y) =>\n     < X : User | AS > getXmatch(Y, X, 'MATCH, 'Z:Foo, 'f['a.Foo, 'c.Foo], nil, 0, unbounded, N) .\nendm\n\nerew in XMATCH-TEST : <> \n< me : User | soln: 0 > \ncreateInterpreter(interpreterManager, me, none) .\n```"]], "MAUDE-1/multiset-algebra.maude": [[true, "set include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  ---- protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : ____(Nat)____ -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars ____(N)____ M K : ____(Nat)____ .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n  ---- protecting NAT .\n\n  ---- TRUTH\n  op if_then_else_fi : ____(Bool)____ ____(Mult)____ Mult -> Mult [strat (____(1)____ ____(0)____ 2 3 0)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n  ---- TRUTH\n\n  sort Mult .\n  subsort Nat < Mult .\n  op mt : -> Mult [ctor] .                              *** empty multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] . *** multiset union\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  op _\\_  : Mult Mult -> Mult .           *** multiset difference\n  op _C=_ : Mult Mult -> Bool .           *** multiset containment\n  op _in_ : Nat Mult -> Bool .            *** multiset membership\n  op _/\\_ : Mult Mult -> Mult .           *** multiset intersection\n  op rem : Nat Mult -> Mult .             *** removes N everywhere in U\n  op |_| : Mult -> Nat .                  *** cardinality with repetitions\n  op [_] : Mult -> Nat .                  *** number of distinct elements\n\n   vars ____(U)____ V W : Mult .\n\n  eq [set05]: mt \\ U = mt .\n  eq [set06]: U \\ mt = U .\n  eq [set07]: (M, U) \\ N = if N ~ M then U else M, (U \\ N) fi .\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .\n\n  eq [set09]: U C= (U,V) = true .\n  eq [set10]: N C= mt = false .\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .\n\n  eq [set13]: N in U = N C= U .\n\n  ---- eq U ~ V = (U C= V) and (V C= U) .\n  eq [set17]: mt ~ U = U C= mt .\n  eq [set18]: N, K, U ~ V = ((N, K, U) C= V) and (V C= (N, K, U)) .\n\n  eq [set15]: mt /\\ V = mt .\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .\n\n  eq [set17]: rem(N, mt) = mt .\n  eq [set18]: rem(____(N)____, (M, U)) = if (N ~ M) then rem(N, U) else M, (rem(N, U)) fi .\n\n  eq [set19]: | mt | = 0 .\n  eq [set20]: | N, U | = s(____(| U |)____) .\n\n  eq [set21]: [ mt ] = 0 .\n  eq [set22]: [ N, U ] = s([ rem(N, U) ]) .\nendfm\n\n---- the use of if-then-else results in a bunch of cps which do not lead to\n---- natural equations, e.g.,\n----   cp MULTISET-ALGEBRA100 for set07 and set07\n----     @4:[Mult],if @1:Nat ~ @3:Nat then @2:Nat else @3:Nat,if @1:Nat ~ @2:Nat then mt else @2:Nat fi fi\n----     = @4:[Mult],if @1:Nat ~ @2:Nat then @3:Nat else @2:Nat,if @1:Nat ~ @3:Nat then mt else @3:Nat fi fi\n----     .\n---- doesn't lead to a useful equation in the context of multisets. Indeed, it cannot\n---- be oriented so that we avoid nonterminating problems.\n---- Something similar happens with\n---- cp MULTISET-ALGEBRA1838\n----   (@3:Mult \\ @1:Nat)\\ @2:Nat\n----   =(@3:Mult \\ @2:Nat)\\ @1:Nat .\n---- Nothing can be done but proving its joinability.\n\n\n\neof\n\nred 5 ~ 12 .                  *** should be false\nred 15 ~ 15 .                 *** should be true\n\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\n\nred (3,3,4,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\n\nred 3 in (3,3,4,4,7) .                      *** should be true\n\nred 9 in (3,3,4,4,7) .                      *** should be false\n\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\n\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\n\nred rem(2,(3,3,2,2,2,4,4,4)) .  *** should be 3,3,4,4,4\n\nred | 3,3,4,4,4,2,2,9 | .       *** should be 8\n\nred [ 3,3,4,4,4,2,2,9 ] .       *** should be 4", "```maude\nset include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  ---- protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : ____(Nat)____ -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars ____(N)____ M K : ____(Nat)____ .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n  ---- protecting NAT .\n\n  ---- TRUTH\n  op if_then_else_fi : ____(Bool)____ ____(Mult)____ Mult -> Mult [strat (____(1)____ ____(0)____ 2 3 0)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n  ---- TRUTH\n\n  sort Mult .\n  subsort Nat < Mult .\n  op mt : -> Mult [ctor] .                              *** empty multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] . *** multiset union\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  op _\\_  : Mult Mult -> Mult .           *** multiset difference\n  op _C=_ : Mult Mult -> Bool .           *** multiset containment\n  op _in_ : Nat Mult -> Bool .            *** multiset membership\n  op _/\\_ : Mult Mult -> Mult .           *** multiset intersection\n  op rem : Nat Mult -> Mult .             *** removes N everywhere in U\n  op |_| : Mult -> Nat .                  *** cardinality with repetitions\n  op [_] : Mult -> Nat .                  *** number of distinct elements\n\n   vars ____(U)____ V W : Mult .\n\n  eq [set05]: mt \\ U = mt .\n  eq [set06]: U \\ mt = U .\n  eq [set07]: (M, U) \\ N = if N ~ M then U else M, (U \\ N) fi .\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .\n\n  eq [set09]: U C= (U,V) = true .\n  eq [set10]: N C= mt = false .\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .\n\n  eq [set13]: N in U = N C= U .\n\n  ---- eq U ~ V = (U C= V) and (V C= U) .\n  eq [set17]: mt ~ U = U C= mt .\n  eq [set18]: N, K, U ~ V = ((N, K, U) C= V) and (V C= (N, K, U)) .\n\n  eq [set15]: mt /\\ V = mt .\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .\n\n  eq [set17]: rem(N, mt) = mt .\n  eq [set18]: rem(____(N)____, (M, U)) = if (N ~ M) then rem(N, U) else M, (rem(N, U)) fi .\n\n  eq [set19]: | mt | = 0 .\n  eq [set20]: | N, U | = s(____(| U |)____) .\n\n  eq [set21]: [ mt ] = 0 .\n  eq [set22]: [ N, U ] = s([ rem(N, U) ]) .\nendfm\n\n---- the use of if-then-else results in a bunch of cps which do not lead to\n---- natural equations, e.g.,\n----   cp MULTISET-ALGEBRA100 for set07 and set07\n----     @4:[Mult],if @1:Nat ~ @3:Nat then @2:Nat else @3:Nat,if @1:Nat ~ @2:Nat then mt else @2:Nat fi fi\n----     = @4:[Mult],if @1:Nat ~ @2:Nat then @3:Nat else @2:Nat,if @1:Nat ~ @3:Nat then mt else @3:Nat fi fi\n----     .\n---- doesn't lead to a useful equation in the context of multisets. Indeed, it cannot\n---- be oriented so that we avoid nonterminating problems.\n---- Something similar happens with\n---- cp MULTISET-ALGEBRA1838\n----   (@3:Mult \\ @1:Nat)\\ @2:Nat\n----   =(@3:Mult \\ @2:Nat)\\ @1:Nat .\n---- Nothing can be done but proving its joinability.\n\n\n\neof\n\nred 5 ~ 12 .                  *** should be false\nred 15 ~ 15 .                 *** should be true\n\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\n\nred (3,3,4,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\n\nred 3 in (3,3,4,4,7) .                      *** should be true\n\nred 9 in (3,3,4,4,7) .                      *** should be false\n\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\n\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\n\nred rem(2,(3,3,2,2,2,4,4,4)) .  *** should be 3,3,4,4,4\n\nred | 3,3,4,4,4,2,2,9 | .       *** should be 8\n\nred [ 3,3,4,4,4,2,2,9 ] .       *** should be 4\n```"]], "MAUDE-1/numbers-ACU-proofs.maude": [[true, "load numbers-ACU.maude\n\nfmod PROOFS is\n  pr BOOL .\n  pr RAT-ACU .\n  vars N' M' : ____(NzNat)____ .\n  eq gcd(1, ____(N')____) = 1 .\n  eq quot(N', 1) = N' .\n  eq - (I:Int / J:Int) = - I:Int / J:Int .\n  eq - - I:Int = I:Int .\n  eq gcd(N', M') > 1 = tt .\nendfm\n\n---(\nred -(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == - 1 / @2:NzNat .\n---(\nrewrites: 13 in 0ms cpu (____(0ms real)____) (270833 rewrites/second)\nresult Bool: true\n---)\n\nred -(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == - (N':NzNat + M':NzNat) / @2:NzNat .\n---(\nrewrites: 6 in 0ms cpu (0ms real) (93750 rewrites/second)\nresult Bool: true\n\nred -(quot(____(- N':NzNat)____, gcd(@2:NzNat, - N':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, - N':NzNat))) == - - N':NzNat / @2:NzNat .\n---(\nrewrites: 8 in 0ms cpu (0ms real) (8000000 rewrites/second)\nresult Bool: true\n---)", "```maude\nload numbers-ACU.maude\n\nfmod PROOFS is\n  pr BOOL .\n  pr RAT-ACU .\n  vars N' M' : ____(NzNat)____ .\n  eq gcd(1, ____(N')____) = 1 .\n  eq quot(N', 1) = N' .\n  eq - (I:Int / J:Int) = - I:Int / J:Int .\n  eq - - I:Int = I:Int .\n  eq gcd(N', M') > 1 = tt .\nendfm\n\n---(\nred -(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == - 1 / @2:NzNat .\n---(\nrewrites: 13 in 0ms cpu (____(0ms real)____) (270833 rewrites/second)\nresult Bool: true\n---)\n\nred -(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == - (N':NzNat + M':NzNat) / @2:NzNat .\n---(\nrewrites: 6 in 0ms cpu (0ms real) (93750 rewrites/second)\nresult Bool: true\n\nred -(quot(____(- N':NzNat)____, gcd(@2:NzNat, - N':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, - N':NzNat))) == - - N':NzNat / @2:NzNat .\n---(\nrewrites: 8 in 0ms cpu (0ms real) (8000000 rewrites/second)\nresult Bool: true\n---)\n```"]], "MAUDE-1/objectMessageOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that object-message rewriting fake rewrites are ignored\n***\tby trace/break/profile code.\n***\n\nmod FOO is\n  inc CONFIGURATION .\n  op User : -> Cid .\n  ops me other : -> Oid .\n  op no-op : Oid Oid -> Msg [msg] .\n\nvars X , Y : Oid .\nvar AS : AttributeSet .\n  rl < X : User | AS >  no-op(X, Y) => < X : User | AS > .\nendm\n\nset break on .\nbreak select __ .\n\nset trace on .\nset trace whole on .\nset profile on .\n\nfrew < me : User | none > no-op(me, other) .\n\n*** we expect a single break to debugger\nresume .\n\nshow profile .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that object-message rewriting fake rewrites are ignored\n***\tby trace/break/profile code.\n***\n\nmod FOO is\n  inc CONFIGURATION .\n  op User : -> Cid .\n  ops me other : -> Oid .\n  op no-op : Oid Oid -> Msg [msg] .\n\nvars X , Y : Oid .\nvar AS : AttributeSet .\n  rl < X : User | AS >  no-op(X, Y) => < X : User | AS > .\nendm\n\nset break on .\nbreak select __ .\n\nset trace on .\nset trace whole on .\nset profile on .\n\nfrew < me : User | none > no-op(me, other) .\n\n*** we expect a single break to debugger\nresume .\n\nshow profile .\n```"]], "MAUDE-1/opRenamingParseErrorMarch2023.maude": [[true, "***\n***\tTest that an op renaming using the sort \"to\" parses correctly.\n***\n\nfmod FOO is\n  sorts Foo to .\n  op f : Foo to -> Foo .\nendfm\n\nfmod BAR is\n  inc FOO * (op f : Foo to -> Foo to g) .\nendfm\n\nshow desugared .", "```maude\n***\n***\tTest that an op renaming using the sort \"to\" parses correctly.\n***\n\nfmod FOO is\n  sorts Foo to .\n  op f : Foo to -> Foo .\nendfm\n\nfmod BAR is\n  inc FOO * (op f : Foo to -> Foo to g) .\nendfm\n\nshow desugared .\n```"]], "MAUDE-1/operatorNames.maude": [[true, "***\n***\tCheck that strange operator names print correctly in awkward places.\n***\n\nfth T is\n  sort Elt .\n  op ({_}:{_}) : Elt Elt -> Elt .\n  op {__}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op ([:]) : -> Elt .\nendfth\n\nfmod M is\n  sort Elt .\n  op term{_,_} : Elt Elt -> Elt .\n  op {__}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  op ({_}:{_}) to (term{_,_}) .\n  op ({_}to{_}) to ({_}.{_}) .\n  op (two to) to (term{}) .\n  op ([:]) to (}.{) .\nendv\n\nfth T2 is\n  inc T * (op ({_}:{_}) to (f[_,_]),\n           op ({_}to{_}) to (_,_),\n           op (two to) to (][),\n           op ([:]) to (]i[)) .\nendfth\n\nshow mod T .\nshow desugared T .\nshow mod M .\nshow desugared M .\nshow view V .\nshow processed view V .\nshow mod T2 .\nshow desugared T2 .\n\nshow modules .\nshow views .\n\nfth T is\n  sort Elt .\n  op [_,_] : Elt Elt -> Elt .\nendfth\n\nview V{X :: TRIV} from T * (op [_,_] to ({_,_})) to LIST{X} is\n  sort Elt to List{X} .\n  op {_,_} to append .\nendv\n\nshow view V .\nshow processed view V .\n\nfmod OP-HOOK-TEST is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n\n  op : : Nat -> NzNat\n        [ctor iter\n         special (id-hook SuccSymbol\n                  term-hook zeroTerm (0))] .\n\n  op _+_ : NzNat Nat -> NzNat\n        [assoc comm prec 33\n         special (id-hook ACU_NumberOpSymbol (+)\n                  op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _*_ : Nat Nat Nat -> Nat [ditto] .\nendfm\n\nshow mod .\nshow desugared .\n\nfmod OP-HOOK-TEST2 is\n  inc NAT * (op s_ to :) .\nendfm\n\nshow all .\n\nomod FOO is\n  sorts Foo Bar .\n  ops f ([_]) : Foo -> Foo .\n  msgs m `[_`] : Bar -> Msg .\nendom\n\nshow mod .\n\nfmod FOO is\n  sort Foo .\n  ops ([_]) (:) : Foo -> Foo .\nendfm\n\nshow mod .", "```maude\n***\n***\tCheck that strange operator names print correctly in awkward places.\n***\n\nfth T is\n  sort Elt .\n  op ({_}:{_}) : Elt Elt -> Elt .\n  op {__}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op ([:]) : -> Elt .\nendfth\n\nfmod M is\n  sort Elt .\n  op term{_,_} : Elt Elt -> Elt .\n  op {__}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  op ({_}:{_}) to (term{_,_}) .\n  op ({_}to{_}) to ({_}.{_}) .\n  op (two to) to (term{}) .\n  op ([:]) to (}.{) .\nendv\n\nfth T2 is\n  inc T * (op ({_}:{_}) to (f[_,_]),\n           op ({_}to{_}) to (_,_),\n           op (two to) to (][),\n           op ([:]) to (]i[)) .\nendfth\n\nshow mod T .\nshow desugared T .\nshow mod M .\nshow desugared M .\nshow view V .\nshow processed view V .\nshow mod T2 .\nshow desugared T2 .\n\nshow modules .\nshow views .\n\nfth T is\n  sort Elt .\n  op [_,_] : Elt Elt -> Elt .\nendfth\n\nview V{X :: TRIV} from T * (op [_,_] to ({_,_})) to LIST{X} is\n  sort Elt to List{X} .\n  op {_,_} to append .\nendv\n\nshow view V .\nshow processed view V .\n\nfmod OP-HOOK-TEST is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n\n  op : : Nat -> NzNat\n        [ctor iter\n         special (id-hook SuccSymbol\n                  term-hook zeroTerm (0))] .\n\n  op _+_ : NzNat Nat -> NzNat\n        [assoc comm prec 33\n         special (id-hook ACU_NumberOpSymbol (+)\n                  op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _*_ : Nat Nat Nat -> Nat [ditto] .\nendfm\n\nshow mod .\nshow desugared .\n\nfmod OP-HOOK-TEST2 is\n  inc NAT * (op s_ to :) .\nendfm\n\nshow all .\n\nomod FOO is\n  sorts Foo Bar .\n  ops f ([_]) : Foo -> Foo .\n  msgs m `[_`] : Bar -> Msg .\nendom\n\nshow mod .\n\nfmod FOO is\n  sort Foo .\n  ops ([_]) (:) : Foo -> Foo .\nendfm\n\nshow mod .\n```"]], "MAUDE-1/signed_dh.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor fresh] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : Gen NeNonceSet -> GenvExp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [comm assoc] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc left (E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(g,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : GenvExp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,e(Ke,M))), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS1), +(exp(GE,NS1)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(A,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(g,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(g, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(g, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor fresh] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : Gen NeNonceSet -> GenvExp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [comm assoc] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc left (E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(g,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : GenvExp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,e(Ke,M))), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS1), +(exp(GE,NS1)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(A,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(g,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(g, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(g, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/orphanedViewInstantiationFebruary2023.maude": [[true, "***\n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\nendfm\n\nshow modules .\nshow views .", "```maude\n***\n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n\nfmod FOO is\nendfm\n\nshow modules .\nshow views .\n```"]], "MAUDE-1/parallel-maude-npa.maude": [[true, "fmod MANAGER is\n    pr META-INTERPRETER .\n    pr META-LEVEL .\n    pr SATURATION .\n    pr META-REDUCER .\n    pr PRINT-HOOK .\n    pr BASIC-PROTOCOL-NPA .\n    pr COMMON-NPA .\n    pr CONFIGURATION .\n\n    --- User defined options\n    ops parSim bStepGoal simplifyGoal : -> Bool .\n    ops numberWorkers : -> Nat .\n\n    sort Manager .\n    sort Status .\n    ops initializing creatingWorkers loadingModules working switching startSimplifying simplifying suspending stopping : -> Status .\n\n    op Manager : -> Oid .\n\n    op status :_ : Status -> Attribute .\n    op workers :_ : Queue{ModuleId} -> Attribute .\n    op #workers :_ : Nat -> Attribute .\n    op m :_ : Module -> Attribute .\n    op gs :_ : GrammarList -> Attribute .\n    op filter :_ : Filters -> Attribute .\n    op jobs :_ : IdSystemSet -> Attribute .\n    op next :_ : IdSystemSet -> Attribute .\n    op history :_ : IdSystemSet -> Attribute .\n    op init :_ : IdSystemSet -> Attribute .\n    op depth :_ : Nat -> Attribute .\n    op bStep :_ : Nat -> Attribute .\n    op nodes :_ : TermList? -> Attribute .\n    op sess :_ : Session -> Attribute .\n    op rem :_ : RemGoal? -> Attribute .\n    op mode :_ : RunMode -> Attribute .\n    op pending :_ : ModuleIdSet -> Attribute .\n    op loading :_ : Bool -> Attribute .\n\n    subsort Manager < ProtocolSearchObject .\n\n    vars O O' MI : Oid .\n    vars M : Module .\n    vars GS : GrammarList .\n    vars F : Filters .\n    vars W : Queue{ModuleId} .\n    vars N D BStep : Nat .\n    vars IS IST IST' IST'' INIT : IdSystemSet .\n    vars HistoryIST : IdSystemSet .\n    vars A : AttributeSet .\n    vars Nodes : TermList? .\n    vars Sess : Session .\n    vars Rem : RemGoal? .\n    vars T : Term .\n    var RT : Qid . --- result type: 'IdSystemSet or 'IdSystem\n    vars MISET : ModuleIdSet .\n    var C C' K H L : Nat .\n\n    rl [Initialize] : < O : Manager | A >\n    => < O : Manager |\n        status : initializing,\n        #workers : numberWorkers,\n        workers : emptyq,\n        jobs : empty,\n        next : empty,\n        init : empty,\n        history : empty,\n        depth : 0,\n        bStep : if bStepGoal then 1 else 0 fi, --- default value of bStep\n        mode : run, --- default running mode\n        A >\n        createWorkers(O, numberWorkers, 'MANAGER-WORKER) --- create #workers workers\n        [print \"[Initialize]\"] .\n\n    crl [CreateWorkersDone] : < O : Manager |\n        status : initializing,\n        #workers : N,\n        A >\n        createdWorkers(O, W)\n    => < O : Manager |\n        status : creatingWorkers,\n        #workers : N,\n        workers : W, --- store the oids of workers\n        pending : q \u041f\u043e\u043c\u0438\u043c\u043e MISET(W), --- pending workers to be loaded\n        A >\n        loadModules(O, W) --- load necessary modules and views to workers\n        [print \"[CreateWorkersDone]\"] .\n\n    --- load modules and views to meta-interpreters\n    op loadModules : Oid Queue{ModuleId} -> Configuration .\n    eq loadModules(O, (MI | W)) = insertModule(MI, O, 'MYPROT) --- 'MYPROT is the module of the protocol to be verified\n        loadModules(O, W) .\n    eq loadModules(O, emptyq) = none .\n\n    crl [LoadModule] : < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : false), --- make sure that a module is only loaded once\n        (pending[MI] : MISET), --- remove MI from pending set\n        A >\n    => < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : (MISET \\ MI)),\n        A >\n        [print \"[LoadModule] \" MI] .\n\n    crl [LoadedModule] : < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : nil),\n        A >\n        insertedModule(O, MI)\n    => < O : Manager |\n        status : initializing,\n        workers : (W | MI), --- add MI to workers queue, ready to work\n        A >\n        [print \"[Loaded] \" MI] .\n\n    crl [CreatedWorkersDone] : < O : Manager |\n        status : initializing,\n        #workers : N,\n        workers : W,\n        A >\n    => < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        A >\n    if qsize(W) == N [print \"[CreatedWorkersDone]\"] .\n\n    rl [AssignJob] : < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n    => < O : Manager |\n        status : working,\n        jobs : IST,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n        handleJob(O, MI, M, ____(GS)____, ____(F)____, if BStep == 1 then Nodes else unbounded fi, IS)\n        [print \"[AssignJob] \" MI] .\n\n    *** request meta-interpreter to handle the backward narrowing just by one step\n    op ____(handleJob)____ : ____(Oid)____ Oid Module GrammarList Filters ____(TermList?)____ IdSystemSet -> Configuration .\n    ceq handleJob(____(O)____, MI, M, ____(GS)____, F, Nodes, IS)\n    = reduceTerm(MI, O, ____(0)____, T)\n    if T := 'nextBackNarrowParallel[\n            --- upTerm(M),\n            --- upTerm(GS),\n            --- upTerm(F),\n            upTerm(Nodes),\n            upTerm(IS)\n        ] .\n\n    crl [WorkerResult] : < O : Manager |\n        status : working,\n        workers : W,\n        m : M,\n        next : IST,\n        A >\n        reducedTerm(O, MI, N, T, RT)\n    => < O : Manager |\n        status : working,\n        workers : (W | MI),\n        m : M,\n        next : (IST IST'),\n        A >\n    if RT == 'IdSystemSet or-else RT == 'IdSystem\n    /\\ IST' := downTerm(T, ____('IdSystemSet)____)\n    [print \"[WorkerResult] \" MI] .\n\n    *** conducting the transition subsumption in sequence if parSim is false\n    crl [Switch] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : BStep,\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : empty,\n        next : IST,\n        init : INIT,\n        history : HistoryIST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : (if C' > 0 then stopping else suspending fi),\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : decN(BStep, 1),\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : IST'',\n        next : empty,\n        init : (INIT INIT'),\n        history : (HistoryIST IST''),\n        depth : D',\n        A >\n        (if C' > 0 then stopWorking(O, O) else none fi)\n    if parSim == false \n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ IST' := filterStates(F, HistoryIST, IST) --- filter states by simplification\n    /\\ < INIT', IST'' > := searchState-CheckInit(M, Sess, HistoryIST, IST') --- filter with history to get initial and other states\n    /\\ D' := (D + 1)\n    /\\ C := #jobs(IST'')\n    /\\ C' := #jobs(INIT')\n    /\\ K:Nat := #jobs(IST)\n    /\\ H:Nat := #jobs(IST')\n    /\\ L:Nat := #jobs(HistoryIST)\n    [print \"<================= [Switch at Depth \" D' \" #jobs = \" C \" #jobs1 = \" K:Nat \" #jobs2 = \" H:Nat \" #his = \" L:Nat \"] =================>\"] .\n\n    *** parallelize the transition subsumption (simplification) if parSim is true\n    crl [Switching] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        bStep : BStep,\n        jobs : empty,\n        next : IST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : startSimplifying,\n        #workers : N,\n        workers : W,\n        bStep : decN(____(BStep)____,1),\n        jobs : empty,\n        next : IST,\n        depth : D',\n        A >\n    if parSim == true\n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ D' := D + 1\n    [print \"<================= [Switching at Depth \" D' \"] =================>\"] .\n\n    rl [Resuming] : < O : Manager |\n        status : suspending,\n        jobs : IST,\n        bStep : BStep,\n        A >\n    =>  if BStep == 0 or-else IST == empty\n        then\n            --- Stop the search\n            stopWorking(O, O)\n            < O : Manager |\n                status : stopping,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        else\n            < O : Manager |\n                status : working,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        fi .\n\n    crl [terminate] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n    => < O : Manager |\n        status : stopping,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n        stopWorking(O, O)\n    if qsize(W) == N\n    [print \"[terminate]\"] .\n\n    rl [StopWorkers] : < O : Manager |\n        workers : W, A >\n        stopWorking(O, O')\n    => < O : Manager |\n        workers : W, A >\n        produceQuitMsg(O, W)\n        [print \"[StopWorkers]\"] .\n\n    *** quit all meta-interpreters\n    op produceQuitMsg : Oid Queue{____(ModuleId)____} -> Configuration .\n    eq produceQuitMsg(O, (MI | W)) = quit(MI, O) produceQuitMsg(O, W) .\n    eq produceQuitMsg(O, emptyq) = none .\n\n    rl [Bye] : < O : Manager |\n        workers : (MI | W), A >\n        bye(O, MI)\n    => < O : Manager |\n        workers : W, A >\n        [print \"[Bye]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : run,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(____(F)____, INIT IST)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : initials,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, ____(INIT)____)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : summary,\n        init : INIT,\n        A >\n    => States>> #jobs(INIT IST) Solutions>> #jobs(INIT)\n        [print \"[CleanUp]\"] .\nendm", "```maude\nfmod MANAGER is\n    pr META-INTERPRETER .\n    pr META-LEVEL .\n    pr SATURATION .\n    pr META-REDUCER .\n    pr PRINT-HOOK .\n    pr BASIC-PROTOCOL-NPA .\n    pr COMMON-NPA .\n    pr CONFIGURATION .\n\n    --- User defined options\n    ops parSim bStepGoal simplifyGoal : -> Bool .\n    ops numberWorkers : -> Nat .\n\n    sort Manager .\n    sort Status .\n    ops initializing creatingWorkers loadingModules working switching startSimplifying simplifying suspending stopping : -> Status .\n\n    op Manager : -> Oid .\n\n    op status :_ : Status -> Attribute .\n    op workers :_ : Queue{ModuleId} -> Attribute .\n    op #workers :_ : Nat -> Attribute .\n    op m :_ : Module -> Attribute .\n    op gs :_ : GrammarList -> Attribute .\n    op filter :_ : Filters -> Attribute .\n    op jobs :_ : IdSystemSet -> Attribute .\n    op next :_ : IdSystemSet -> Attribute .\n    op history :_ : IdSystemSet -> Attribute .\n    op init :_ : IdSystemSet -> Attribute .\n    op depth :_ : Nat -> Attribute .\n    op bStep :_ : Nat -> Attribute .\n    op nodes :_ : TermList? -> Attribute .\n    op sess :_ : Session -> Attribute .\n    op rem :_ : RemGoal? -> Attribute .\n    op mode :_ : RunMode -> Attribute .\n    op pending :_ : ModuleIdSet -> Attribute .\n    op loading :_ : Bool -> Attribute .\n\n    subsort Manager < ProtocolSearchObject .\n\n    vars O O' MI : Oid .\n    vars M : Module .\n    vars GS : GrammarList .\n    vars F : Filters .\n    vars W : Queue{ModuleId} .\n    vars N D BStep : Nat .\n    vars IS IST IST' IST'' INIT : IdSystemSet .\n    vars HistoryIST : IdSystemSet .\n    vars A : AttributeSet .\n    vars Nodes : TermList? .\n    vars Sess : Session .\n    vars Rem : RemGoal? .\n    vars T : Term .\n    var RT : Qid . --- result type: 'IdSystemSet or 'IdSystem\n    vars MISET : ModuleIdSet .\n    var C C' K H L : Nat .\n\n    rl [Initialize] : < O : Manager | A >\n    => < O : Manager |\n        status : initializing,\n        #workers : numberWorkers,\n        workers : emptyq,\n        jobs : empty,\n        next : empty,\n        init : empty,\n        history : empty,\n        depth : 0,\n        bStep : if bStepGoal then 1 else 0 fi, --- default value of bStep\n        mode : run, --- default running mode\n        A >\n        createWorkers(O, numberWorkers, 'MANAGER-WORKER) --- create #workers workers\n        [print \"[Initialize]\"] .\n\n    crl [CreateWorkersDone] : < O : Manager |\n        status : initializing,\n        #workers : N,\n        A >\n        createdWorkers(O, W)\n    => < O : Manager |\n        status : creatingWorkers,\n        #workers : N,\n        workers : W, --- store the oids of workers\n        pending : q \u041f\u043e\u043c\u0438\u043c\u043e MISET(W), --- pending workers to be loaded\n        A >\n        loadModules(O, W) --- load necessary modules and views to workers\n        [print \"[CreateWorkersDone]\"] .\n\n    --- load modules and views to meta-interpreters\n    op loadModules : Oid Queue{ModuleId} -> Configuration .\n    eq loadModules(O, (MI | W)) = insertModule(MI, O, 'MYPROT) --- 'MYPROT is the module of the protocol to be verified\n        loadModules(O, W) .\n    eq loadModules(O, emptyq) = none .\n\n    crl [LoadModule] : < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : false), --- make sure that a module is only loaded once\n        (pending[MI] : MISET), --- remove MI from pending set\n        A >\n    => < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : (MISET \\ MI)),\n        A >\n        [print \"[LoadModule] \" MI] .\n\n    crl [LoadedModule] : < O : Manager |\n        status : creatingWorkers,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : nil),\n        A >\n        insertedModule(O, MI)\n    => < O : Manager |\n        status : initializing,\n        workers : (W | MI), --- add MI to workers queue, ready to work\n        A >\n        [print \"[Loaded] \" MI] .\n\n    crl [CreatedWorkersDone] : < O : Manager |\n        status : initializing,\n        #workers : N,\n        workers : W,\n        A >\n    => < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        A >\n    if qsize(W) == N [print \"[CreatedWorkersDone]\"] .\n\n    rl [AssignJob] : < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n    => < O : Manager |\n        status : working,\n        jobs : IST,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        nodes : Nodes,\n        bStep : BStep,\n        A >\n        handleJob(O, MI, M, ____(GS)____, ____(F)____, if BStep == 1 then Nodes else unbounded fi, IS)\n        [print \"[AssignJob] \" MI] .\n\n    *** request meta-interpreter to handle the backward narrowing just by one step\n    op ____(handleJob)____ : ____(Oid)____ Oid Module GrammarList Filters ____(TermList?)____ IdSystemSet -> Configuration .\n    ceq handleJob(____(O)____, MI, M, ____(GS)____, F, Nodes, IS)\n    = reduceTerm(MI, O, ____(0)____, T)\n    if T := 'nextBackNarrowParallel[\n            --- upTerm(M),\n            --- upTerm(GS),\n            --- upTerm(F),\n            upTerm(Nodes),\n            upTerm(IS)\n        ] .\n\n    crl [WorkerResult] : < O : Manager |\n        status : working,\n        workers : W,\n        m : M,\n        next : IST,\n        A >\n        reducedTerm(O, MI, N, T, RT)\n    => < O : Manager |\n        status : working,\n        workers : (W | MI),\n        m : M,\n        next : (IST IST'),\n        A >\n    if RT == 'IdSystemSet or-else RT == 'IdSystem\n    /\\ IST' := downTerm(T, ____('IdSystemSet)____)\n    [print \"[WorkerResult] \" MI] .\n\n    *** conducting the transition subsumption in sequence if parSim is false\n    crl [Switch] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : BStep,\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : empty,\n        next : IST,\n        init : INIT,\n        history : HistoryIST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : (if C' > 0 then stopping else suspending fi),\n        #workers : N,\n        workers : W,\n        m : M,\n        gs : GS,\n        filter : F,\n        bStep : decN(BStep, 1),\n        nodes : Nodes,\n        sess : Sess,\n        rem : Rem?,\n        jobs : IST'',\n        next : empty,\n        init : (INIT INIT'),\n        history : (HistoryIST IST''),\n        depth : D',\n        A >\n        (if C' > 0 then stopWorking(O, O) else none fi)\n    if parSim == false \n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ IST' := filterStates(F, HistoryIST, IST) --- filter states by simplification\n    /\\ < INIT', IST'' > := searchState-CheckInit(M, Sess, HistoryIST, IST') --- filter with history to get initial and other states\n    /\\ D' := (D + 1)\n    /\\ C := #jobs(IST'')\n    /\\ C' := #jobs(INIT')\n    /\\ K:Nat := #jobs(IST)\n    /\\ H:Nat := #jobs(IST')\n    /\\ L:Nat := #jobs(HistoryIST)\n    [print \"<================= [Switch at Depth \" D' \" #jobs = \" C \" #jobs1 = \" K:Nat \" #jobs2 = \" H:Nat \" #his = \" L:Nat \"] =================>\"] .\n\n    *** parallelize the transition subsumption (simplification) if parSim is true\n    crl [Switching] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        bStep : BStep,\n        jobs : empty,\n        next : IST,\n        depth : D,\n        A >\n    => < O : Manager |\n        status : startSimplifying,\n        #workers : N,\n        workers : W,\n        bStep : decN(____(BStep)____,1),\n        jobs : empty,\n        next : IST,\n        depth : D',\n        A >\n    if parSim == true\n    /\\ qsize(W) == N\n    /\\ IST =/= empty\n    /\\ D' := D + 1\n    [print \"<================= [Switching at Depth \" D' \"] =================>\"] .\n\n    rl [Resuming] : < O : Manager |\n        status : suspending,\n        jobs : IST,\n        bStep : BStep,\n        A >\n    =>  if BStep == 0 or-else IST == empty\n        then\n            --- Stop the search\n            stopWorking(O, O)\n            < O : Manager |\n                status : stopping,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        else\n            < O : Manager |\n                status : working,\n                jobs : IST,\n                bStep : BStep,\n                A >\n        fi .\n\n    crl [terminate] : < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n    => < O : Manager |\n        status : stopping,\n        #workers : N,\n        workers : W,\n        jobs : empty,\n        next : empty,\n        A >\n        stopWorking(O, O)\n    if qsize(W) == N\n    [print \"[terminate]\"] .\n\n    rl [StopWorkers] : < O : Manager |\n        workers : W, A >\n        stopWorking(O, O')\n    => < O : Manager |\n        workers : W, A >\n        produceQuitMsg(O, W)\n        [print \"[StopWorkers]\"] .\n\n    *** quit all meta-interpreters\n    op produceQuitMsg : Oid Queue{____(ModuleId)____} -> Configuration .\n    eq produceQuitMsg(O, (MI | W)) = quit(MI, O) produceQuitMsg(O, W) .\n    eq produceQuitMsg(O, emptyq) = none .\n\n    rl [Bye] : < O : Manager |\n        workers : (MI | W), A >\n        bye(O, MI)\n    => < O : Manager |\n        workers : W, A >\n        [print \"[Bye]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : run,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(____(F)____, INIT IST)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : initials,\n        init : INIT,\n        A >\n    => ShortIdSystem: changeShortSystem(F, ____(INIT)____)\n        [print \"[CleanUp]\"] .\n\n    rl [CleanUp] : < O : Manager |\n        status : stopping,\n        workers : emptyq,\n        filter : F,\n        jobs : IST,\n        mode : summary,\n        init : INIT,\n        A >\n    => States>> #jobs(INIT IST) Solutions>> #jobs(INIT)\n        [print \"[CleanUp]\"] .\nendm\n```"]], "MAUDE-1/parameterizedPolymorphicConstantMarch2023.maude": [[true, "***\n***\tCheck that parameter changes work for polymorphic constants.\n***\n\nfmod FOO{X :: TRIV} is\n  op c{____(X)____} : -> Universal [poly (0)] .\nendfm\n\nfmod BAR{Y :: TRIV} is\n  inc FOO{Y} .\n  op b : -> Bool .\n  eq b = c{Y} .\nendfm\n\nshow all .", "```maude\n***\n***\tCheck that parameter changes work for polymorphic constants.\n***\n\nfmod FOO{X :: TRIV} is\n  op c{____(X)____} : -> Universal [poly (0)] .\nendfm\n\nfmod BAR{Y :: TRIV} is\n  inc FOO{Y} .\n  op b : -> Bool .\n  eq b = c{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/physArgIndexOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that we are not confusing nominal and physical\n***\targument indices for AC(U) terms with arguments having\n***\tmultiplicity > 1.\n***\n\nmod VENDING-MACHINE is\n  sorts Coin Item Place Marking .\n  subsorts Coin Item < Place < Marking .\n  op __ : Marking Marking -> Marking [ctor assoc comm id: null] .\n  op null : -> Marking [ctor] .\n  op $ : -> Coin [ctor format (r! o)] .\n  op q : -> Coin [ctor format (r! o)] .\n  op a : -> Item [ctor format (b! o)] .\n  op c : -> Item [ctor format (b! o)] .\n\n  rl [buy-c] : $ => c .\n  rl [buy-a] : $ => a  q .\n  rl [change]: q  q  q  q => $ .\nendm\n\n*** bad extra results\nsrewrite in VENDING-MACHINE : $ $ $ using all .\n\n*** runaway execution\nsearch $ $ $ =>! a a M:Marking .\n\nmod FOO is\n  sort Foo .\n  op __ : Foo Foo -> Foo [assoc comm] .\n  ops a b c : -> Foo .\n\n  rl b => c .\nendm\n\n*** runaway execution\nrew a a b .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that we are not confusing nominal and physical\n***\targument indices for AC(U) terms with arguments having\n***\tmultiplicity > 1.\n***\n\nmod VENDING-MACHINE is\n  sorts Coin Item Place Marking .\n  subsorts Coin Item < Place < Marking .\n  op __ : Marking Marking -> Marking [ctor assoc comm id: null] .\n  op null : -> Marking [ctor] .\n  op $ : -> Coin [ctor format (r! o)] .\n  op q : -> Coin [ctor format (r! o)] .\n  op a : -> Item [ctor format (b! o)] .\n  op c : -> Item [ctor format (b! o)] .\n\n  rl [buy-c] : $ => c .\n  rl [buy-a] : $ => a  q .\n  rl [change]: q  q  q  q => $ .\nendm\n\n*** bad extra results\nsrewrite in VENDING-MACHINE : $ $ $ using all .\n\n*** runaway execution\nsearch $ $ $ =>! a a M:Marking .\n\nmod FOO is\n  sort Foo .\n  op __ : Foo Foo -> Foo [assoc comm] .\n  ops a b c : -> Foo .\n\n  rl b => c .\nendm\n\n*** runaway execution\nrew a a b .\n```"]], "MAUDE-1/polymorphicParsingBugsNovember2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  op f : Poly Poly -> Poly [assoc poly (1 2 0)] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  op f : Poly -> Poly [iter poly (1 0) ] .\nendfm\n\nred f^12345(X:Bool) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  op f : Poly Poly -> Poly [assoc poly (1 2 0)] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  op f : Poly -> Poly [iter poly (1 0) ] .\nendfm\n\nred f^12345(X:Bool) .\n```"]], "MAUDE-1/quotedTokenMarch2023.maude": [[true, "set show timing off .\n\n***\n***\tTest that starting special symbol with a \" works correctly.\n***\n\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [____(iter)____] .\n  op \"f\"g : ____(Nat)____ -> Nat [iter] .\nendfm\n\nred \"X\":Nat .\nred \"X:Y\":NzNat .\nred \"X:Y\"Z:NzNat .\nred \"X\":[Nat] .\n\nred \"s\"^42(0) .\nred \"f\"g^2(0) .", "```maude\nset show timing off .\n\n***\n***\tTest that starting special symbol with a \" works correctly.\n***\n\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [____(iter)____] .\n  op \"f\"g : ____(Nat)____ -> Nat [iter] .\nendfm\n\nred \"X\":Nat .\nred \"X:Y\":NzNat .\nred \"X:Y\"Z:NzNat .\nred \"X\":[Nat] .\n\nred \"s\"^42(0) .\nred \"f\"g^2(0) .\n```"]], "MAUDE-1/pseudoParameterTheoryConstantMarch2023.maude": [[true, "***\n***\tTest for instantiation of pseudo-parameters in constants.\n***\n\nfth T is\n  sort Elt .\n  op c{X} : -> Elt .\nendfth\n\nfmod FOO{X :: T} is\n  eq c{X} = c{X} .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .", "```maude\n***\n***\tTest for instantiation of pseudo-parameters in constants.\n***\n\nfth T is\n  sort Elt .\n  op c{X} : -> Elt .\nendfth\n\nfmod FOO{X :: T} is\n  eq c{X} = c{X} .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .\n```"]], "MAUDE-1/RAT-ACU-original.maude": [[true, "fmod BOOL-FVP is\n  sorts Bool Truth .\n  subsort Bool < Truth .\n  op tt : -> Bool [ctor] .\n  op ff : -> Bool [ctor] .\n  op _/\\_ : Bool Bool -> Bool [assoc comm prec 43] .\n  op _\\/_ : Bool Bool -> Bool [assoc comm prec 45] .\n  op ~_ : Bool -> Bool [prec 41] .\n\n  var B : Bool .\n\n  eq B /\\ B = B .\n  eq B /\\ tt = B .\n  eq B /\\ ff = ff .\n  eq B \\/ B = B .\n  eq B \\/ tt = tt .\n  eq B \\/ ff = B .\n  eq B /\\ (B \\/ B) = B .  --- absorbtion, B is repeated, should be B1 /\\ (B1 \\/ B2) = B1\n  eq B \\/ (B /\\ B) = B .  --- absorbtion, B is repeated, should be B1 \\/ (B1 /\\ B2) = B1\n  eq ~(~ B) = B .\n  eq tt = (~ ff) .\n  eq ff = (~ tt) .\nendfm\n\n\nfmod NAT-FVP is\n  protecting BOOL-FVP .\n  sorts Nat NzNat Zero .\n  subsort Zero < Nat .\n  subsort NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n  op s : Nat -> NzNat [ctor] .\n  op _+_ : Nat Nat -> Nat [assoc comm id: 0 prec 35] .\n  op _+_ : Nat NzNat -> NzNat [ditto] .\n  op _+_ : NzNat Nat -> NzNat [ditto] .\n  op _+_ : NzNat NzNat -> NzNat [ditto] .\n  op p : NzNat -> Nat .                 *** predecessor\n  op max : Nat Nat -> Nat [comm] .\n  op min : Nat Nat -> Nat [comm] .\n  op _~_ : Nat Nat -> Truth [comm] .    *** equality predicate\n  op _>_ : Nat Nat -> Truth .\n\n  vars N M K : Nat .  vars N' M' : NzNat .\n\n  eq [nat-fvp01]: p(s(N)) = N [variant] .\n  eq [nat-fvp02]: max(N,0) = N [variant] .\n  eq [nat-fvp03]: max(s(N),s(M)) = s(max(N,M)) [variant] .\n  eq [nat-fvp04]: min(N,0) = 0 [variant] .\n  eq [nat-fvp05]: min(s(N),s(M)) = s(min(N,M)) [variant] .\n  eq [nat-fvp06]: 0 ~ 0 = tt [variant] .\n  eq [nat-fvp07]: N ~ N = tt [variant] .\n  eq [nat-fvp08]: (N + ____(1)____) ~ N = ff [variant] .\n  eq [nat-fvp09]: M + N + 1 > N = tt [variant] .\n  eq [nat-fvp10]: N > N + M = ff [variant] .\nendfm\n\n\nfmod NAT-ACU is\n  protecting NAT-FVP .\n  op quot : Nat NzNat -> Nat .            *** quotient\n  op gcd : NzNat NzNat -> NzNat [comm] .  *** greatest common divisor\n  op _*_ : ____(Nat)____ Nat -> Nat [____(assoc)____ ____(comm)____ id: 1 prec 31] .\n  op _*_ : ____(NzNat)____ NzNat -> NzNat [____(ditto)____] .\n\n  vars N M ____(K :)____ Nat ____(.)____   vars ____(N')____ ____(M')____ K' : ____(NzNat)____ .  var N? : [Nat] .\n\n  eq [nat-acu01]: quot(____(N)____ + ____(M')____, ____(M')____) = 1 + quot(____(N)____, M')  .\n  eq [nat-acu02]: quot(____(M')____, M') = 1 .\n  eq [nat-acu03]: quot(M, ____(N')____ + M) = 0 .\n  eq [nat-acu04]: gcd(____(0)____, N') = N' .\n  eq [nat-acu05]: gcd(____(N' + M')____, M') = gcd(N', ____(M')____) .\n  eq [nat-acu06]: N? * 0 = 0 .\n  eq [nat-acu07]: N? * 1 = N? .\n  eq [nat-acu08]: N' * (M' + K') = (N' * M') + (N' * K') .\n  ---- eq [nat-acu09]: N? * N' * (M' + K') = N? * ((N' * M') + (N' * K')) .  *** coherence extension\nendfm\n\n\nfmod INT-FVP is protecting NAT-FVP .\n  sorts NzNeg NzInt Int .\n  subsorts Nat NzNeg < Int .\n  subsorts NzNat NzNeg < NzInt < Int .\n  op - : ____(NzNat)____ -> NzNeg [ctor] .\n  op - : ____(Int)____ -> Int .\n  op _+_ : ____(Int)____ Int -> Int [____(assoc comm id: 0)____ ditto] .\n  op |_| : Int -> Nat .                *** absolute value\n  op p : Int -> Int .                  *** predecessor\n  op max : ____(Int)____ ____(Int)____ -> Int [comm] .\n  op min : ____(Int)____ Int -> Int [____(comm)____] .\n  op _~_ : Int Int -> Truth [comm] .   *** equality predicate\n  op _>_ : ____(Int)____ Int -> Truth .\n\n  vars I J : Int .   vars ____(I')____ ____(J')____ : ____(NzInt)____ .\n  vars N' M' : NzNat .  var N : Nat .  ---- var I? : [Int] .\n\n  ---- eq I? + N' + -(N') = I? [variant] .                  *** coherence extension\n  ---- eq I? + -(N') + -(M') = I? + -(N' + M') [variant] .  *** coherence extension\n  ---- eq I? + N' + -(N' + M') = I? + -(M') [variant] .     *** coherence extension\n  eq -(0) = 0 [variant] .\n  eq -(-(N')) = N' [variant] .\n  eq | N | = N [variant] .\n  eq | -(N') | = N' [variant] .\n  eq p(0) = -(1) [variant] .\n  eq p(-(N')) = -(N' + 1) [variant] .\n  eq max(-(____(N')____),-(M')) = -(min(N',M')) [variant] .\n  eq max(-(____(N)____'),N) = N [variant] .\n  eq min(-(N'),-(M')) = -(max(____(N')____,M')) [variant] .\n  eq min(-(N'),N) = -(N') [variant] .\n  eq -(N') ~ -(M') = N' ~ M' [variant] .\n  eq -(N') ~ N = ff [variant] .\n  eq -(N') > -(M') = M' > N' [variant] .\n  eq -(N') > N = ff [variant] .\n  eq N > -(N') = tt [variant] .\nendfm\n\n\nfmod INT-ACU is protecting INT-FVP .  protecting NAT-ACU .\n  op ____(quot)____ : Int NzInt -> Int .\n  op ____(gcd)____ : ____(Int)____ NzInt -> NzNat [comm] .\n  op _*_ : ____(Int)____ Int -> Int [____(assoc comm id: 1 prec 31)____] .\n  op ____(_*_)____ : ____(NzInt)____ NzInt -> NzInt [ditto] .\n\n  ____(vars)____ I J : ____(Int)____ .   vars ____(I')____ J' : NzInt .\n  vars N' M' K' : NzNat .  var Q : NzNeg .  ---- var I? : [Int] .\n\n  eq quot(0,Q) = 0 .\n  eq quot(-(N'),M') = -(quot(N',____(M')____)) .\n  eq quot(N',-(M')) = -(quot(N',M')) .\n  eq quot(-(N'),-(M')) = quot(N',M') .\n  eq gcd(-(N'),____(I')____) = gcd(N',I') .\n  eq -(M') * -(N') = N' * M' .\n  ---- eq I? * -(M') * -(N') = I? * N' * M' .  *** coherence extension\n  eq M' * -(N') = -(N' * M') .\n  ---- eq I? * M' * -(N') = I? * -(N' * M') .  *** coherence extension\nendfm\n\nfmod RAT-ACU is\n  protecting INT-ACU .\n  sorts Rat NzRat PosRat NzPosRat .\n  subsort Int < Rat .\n  subsorts Nat NzPosRat < PosRat < Rat .\n  subsorts NzInt < NzRat < Rat .\n  subsorts NzNat < NzPosRat < NzRat PosRat .\n  op _/_ : NzRat NzRat -> NzRat .       *** division\n  op _/_ : NzInt NzNat -> ____(Rat)____ [____(prec 33)____] .\n  op _/_ : NzNat NzNat -> ____(PosRat)____ [____(ditto)____] .\n  op - : ____(Rat)____ -> Rat .\n  op ____(_+_)____ : ____(Rat)____ Rat -> Rat [ditto] .\n  op ____(_+_)____ : PosRat PosRat -> PosRat [____(ditto)____] .\n  op ____(_*_)____ : ____(Rat)____ Rat -> Rat [ditto] .\n  op _*_ : ____(NzRat)____ NzRat -> NzRat [____(ditto)____] .\n  op |_| : Rat -> PosRat .             *** absolute value\n  op max : ____(Rat)____ Rat -> Rat [____(comm)____] .\n  op min : ____(Rat)____ ____(Rat)____ -> Rat [comm] .\n  op _~_ : Rat Rat -> Truth [comm] .   *** equality predicate\n  op _>_ : Rat Rat -> ____(Truth)____ .\n\n  vars I' J' : ____(NzInt)____ ____(;)____   vars ____(R)____ S : Rat .    var R? : [Rat] .\n  ____(vars)____ R' S' : ____(NzRat)____ .   vars ____(N')____ M' ____(K')____ : NzNat .\n\n  ceq [rat01]: J' / M' = quot(J',gcd(J',M')) / quot(M',gcd(J',M'))\n     if gcd(J',M') > 1 = tt .                           *** canonical form of fraction\n  eq [rat02]: R' / 1 = R' .\n  eq [rat03]: I' / -(N') = -(I') / N' .\n  eq [rat04]: I' / (J' / M') = (I' * M') / J' .\n  eq [rat05]: (____(I' / N')____) / J' = I' / (N' * J') .\n  eq [rat06]: (I' / N') / (J' / M') = (I' * M') / (N' * J') .\n  ---- eq R? + I' + (J' / M') = R? + (((I' * M') + J') / M') .                      *** coherence extension\n  ---- eq R? + (I' / N') + (J' / M') = R? + (((I' * M') + (J' * N')) / (N' * M')) . *** coherence extension\n  eq [rat07]: -(I' / N') = -(I') / N' .\n  eq [rat08]: (I' / N') * 0 = 0 .\n  ---- eq R? * (I' / N') * 0 = 0 .                                     *** coherence extension\n  eq [rat09]: (I' / N') * J' = (I' * J') / N' .\n  ---- eq R? * (I' / N') * J' = R? * ((I' * J') / N') .                *** coherence extension\n  eq [rat10]: (I' / N') * (J' / M') = (I' * J') / (N' * M') .\n  ---- eq R? * (I' / N') * (J' / M') = R? * ((I' * J') / (N' * M')) .  *** coherence extension\n  eq [rat11]: | I' / N' | = | I' | / N' .\n  eq [rat12]: max(____(I' / N')____,J') = max(I',(____(J' * N')____)) / N' .\n  eq [rat13]: max(I' / N',____(J' / M')____) = max((I' * M'),(____(J' * N')____)) / (N' * M') .\n  eq [rat14]: min(I' / N',J') = min(I',(J' * N')) / N' .\n  eq [rat15]: min(I' / N',J' / M') = min((I' * M'),(____(J' * N')____)) / (N' * M') .\n  eq [rat16]: (I' / N') ~ J' = I' ~ (J' * N') .\n  eq [rat17]: (I' / N') ~ (J' / M') = (I' * M') ~ (J' * N') .\n  eq [rat18]: I' > (J' / M') = (I' * M') > J' .\n  eq [rat19]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat20]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat21]: (I' / N') > (J' / M') = (I' * M') > (J' * N') .\nendfm", "```maude\nfmod BOOL-FVP is\n  sorts Bool Truth .\n  subsort Bool < Truth .\n  op tt : -> Bool [ctor] .\n  op ff : -> Bool [ctor] .\n  op _/\\_ : Bool Bool -> Bool [assoc comm prec 43] .\n  op _\\/_ : Bool Bool -> Bool [assoc comm prec 45] .\n  op ~_ : Bool -> Bool [prec 41] .\n\n  var B : Bool .\n\n  eq B /\\ B = B .\n  eq B /\\ tt = B .\n  eq B /\\ ff = ff .\n  eq B \\/ B = B .\n  eq B \\/ tt = tt .\n  eq B \\/ ff = B .\n  eq B /\\ (B \\/ B) = B .  --- absorbtion, B is repeated, should be B1 /\\ (B1 \\/ B2) = B1\n  eq B \\/ (B /\\ B) = B .  --- absorbtion, B is repeated, should be B1 \\/ (B1 /\\ B2) = B1\n  eq ~(~ B) = B .\n  eq tt = (~ ff) .\n  eq ff = (~ tt) .\nendfm\n\n\nfmod NAT-FVP is\n  protecting BOOL-FVP .\n  sorts Nat NzNat Zero .\n  subsort Zero < Nat .\n  subsort NzNat < Nat .\n  op 0 : -> Zero [ctor] .\n  op s : Nat -> NzNat [ctor] .\n  op _+_ : Nat Nat -> Nat [assoc comm id: 0 prec 35] .\n  op _+_ : Nat NzNat -> NzNat [ditto] .\n  op _+_ : NzNat Nat -> NzNat [ditto] .\n  op _+_ : NzNat NzNat -> NzNat [ditto] .\n  op p : NzNat -> Nat .                 *** predecessor\n  op max : Nat Nat -> Nat [comm] .\n  op min : Nat Nat -> Nat [comm] .\n  op _~_ : Nat Nat -> Truth [comm] .    *** equality predicate\n  op _>_ : Nat Nat -> Truth .\n\n  vars N M K : Nat .  vars N' M' : NzNat .\n\n  eq [nat-fvp01]: p(s(N)) = N [variant] .\n  eq [nat-fvp02]: max(N,0) = N [variant] .\n  eq [nat-fvp03]: max(s(N),s(M)) = s(max(N,M)) [variant] .\n  eq [nat-fvp04]: min(N,0) = 0 [variant] .\n  eq [nat-fvp05]: min(s(N),s(M)) = s(min(N,M)) [variant] .\n  eq [nat-fvp06]: 0 ~ 0 = tt [variant] .\n  eq [nat-fvp07]: N ~ N = tt [variant] .\n  eq [nat-fvp08]: (N + ____(1)____) ~ N = ff [variant] .\n  eq [nat-fvp09]: M + N + 1 > N = tt [variant] .\n  eq [nat-fvp10]: N > N + M = ff [variant] .\nendfm\n\n\nfmod NAT-ACU is\n  protecting NAT-FVP .\n  op quot : Nat NzNat -> Nat .            *** quotient\n  op gcd : NzNat NzNat -> NzNat [comm] .  *** greatest common divisor\n  op _*_ : ____(Nat)____ Nat -> Nat [____(assoc)____ ____(comm)____ id: 1 prec 31] .\n  op _*_ : ____(NzNat)____ NzNat -> NzNat [____(ditto)____] .\n\n  vars N M ____(K :)____ Nat ____(.)____   vars ____(N')____ ____(M')____ K' : ____(NzNat)____ .  var N? : [Nat] .\n\n  eq [nat-acu01]: quot(____(N)____ + ____(M')____, ____(M')____) = 1 + quot(____(N)____, M')  .\n  eq [nat-acu02]: quot(____(M')____, M') = 1 .\n  eq [nat-acu03]: quot(M, ____(N')____ + M) = 0 .\n  eq [nat-acu04]: gcd(____(0)____, N') = N' .\n  eq [nat-acu05]: gcd(____(N' + M')____, M') = gcd(N', ____(M')____) .\n  eq [nat-acu06]: N? * 0 = 0 .\n  eq [nat-acu07]: N? * 1 = N? .\n  eq [nat-acu08]: N' * (M' + K') = (N' * M') + (N' * K') .\n  ---- eq [nat-acu09]: N? * N' * (M' + K') = N? * ((N' * M') + (N' * K')) .  *** coherence extension\nendfm\n\n\nfmod INT-FVP is protecting NAT-FVP .\n  sorts NzNeg NzInt Int .\n  subsorts Nat NzNeg < Int .\n  subsorts NzNat NzNeg < NzInt < Int .\n  op - : ____(NzNat)____ -> NzNeg [ctor] .\n  op - : ____(Int)____ -> Int .\n  op _+_ : ____(Int)____ Int -> Int [____(assoc comm id: 0)____ ditto] .\n  op |_| : Int -> Nat .                *** absolute value\n  op p : Int -> Int .                  *** predecessor\n  op max : ____(Int)____ ____(Int)____ -> Int [comm] .\n  op min : ____(Int)____ Int -> Int [____(comm)____] .\n  op _~_ : Int Int -> Truth [comm] .   *** equality predicate\n  op _>_ : ____(Int)____ Int -> Truth .\n\n  vars I J : Int .   vars ____(I')____ ____(J')____ : ____(NzInt)____ .\n  vars N' M' : NzNat .  var N : Nat .  ---- var I? : [Int] .\n\n  ---- eq I? + N' + -(N') = I? [variant] .                  *** coherence extension\n  ---- eq I? + -(N') + -(M') = I? + -(N' + M') [variant] .  *** coherence extension\n  ---- eq I? + N' + -(N' + M') = I? + -(M') [variant] .     *** coherence extension\n  eq -(0) = 0 [variant] .\n  eq -(-(N')) = N' [variant] .\n  eq | N | = N [variant] .\n  eq | -(N') | = N' [variant] .\n  eq p(0) = -(1) [variant] .\n  eq p(-(N')) = -(N' + 1) [variant] .\n  eq max(-(____(N')____),-(M')) = -(min(N',M')) [variant] .\n  eq max(-(____(N)____'),N) = N [variant] .\n  eq min(-(N'),-(M')) = -(max(____(N')____,M')) [variant] .\n  eq min(-(N'),N) = -(N') [variant] .\n  eq -(N') ~ -(M') = N' ~ M' [variant] .\n  eq -(N') ~ N = ff [variant] .\n  eq -(N') > -(M') = M' > N' [variant] .\n  eq -(N') > N = ff [variant] .\n  eq N > -(N') = tt [variant] .\nendfm\n\n\nfmod INT-ACU is protecting INT-FVP .  protecting NAT-ACU .\n  op ____(quot)____ : Int NzInt -> Int .\n  op ____(gcd)____ : ____(Int)____ NzInt -> NzNat [comm] .\n  op _*_ : ____(Int)____ Int -> Int [____(assoc comm id: 1 prec 31)____] .\n  op ____(_*_)____ : ____(NzInt)____ NzInt -> NzInt [ditto] .\n\n  ____(vars)____ I J : ____(Int)____ .   vars ____(I')____ J' : NzInt .\n  vars N' M' K' : NzNat .  var Q : NzNeg .  ---- var I? : [Int] .\n\n  eq quot(0,Q) = 0 .\n  eq quot(-(N'),M') = -(quot(N',____(M')____)) .\n  eq quot(N',-(M')) = -(quot(N',M')) .\n  eq quot(-(N'),-(M')) = quot(N',M') .\n  eq gcd(-(N'),____(I')____) = gcd(N',I') .\n  eq -(M') * -(N') = N' * M' .\n  ---- eq I? * -(M') * -(N') = I? * N' * M' .  *** coherence extension\n  eq M' * -(N') = -(N' * M') .\n  ---- eq I? * M' * -(N') = I? * -(N' * M') .  *** coherence extension\nendfm\n\nfmod RAT-ACU is\n  protecting INT-ACU .\n  sorts Rat NzRat PosRat NzPosRat .\n  subsort Int < Rat .\n  subsorts Nat NzPosRat < PosRat < Rat .\n  subsorts NzInt < NzRat < Rat .\n  subsorts NzNat < NzPosRat < NzRat PosRat .\n  op _/_ : NzRat NzRat -> NzRat .       *** division\n  op _/_ : NzInt NzNat -> ____(Rat)____ [____(prec 33)____] .\n  op _/_ : NzNat NzNat -> ____(PosRat)____ [____(ditto)____] .\n  op - : ____(Rat)____ -> Rat .\n  op ____(_+_)____ : ____(Rat)____ Rat -> Rat [ditto] .\n  op ____(_+_)____ : PosRat PosRat -> PosRat [____(ditto)____] .\n  op ____(_*_)____ : ____(Rat)____ Rat -> Rat [ditto] .\n  op _*_ : ____(NzRat)____ NzRat -> NzRat [____(ditto)____] .\n  op |_| : Rat -> PosRat .             *** absolute value\n  op max : ____(Rat)____ Rat -> Rat [____(comm)____] .\n  op min : ____(Rat)____ ____(Rat)____ -> Rat [comm] .\n  op _~_ : Rat Rat -> Truth [comm] .   *** equality predicate\n  op _>_ : Rat Rat -> ____(Truth)____ .\n\n  vars I' J' : ____(NzInt)____ ____(;)____   vars ____(R)____ S : Rat .    var R? : [Rat] .\n  ____(vars)____ R' S' : ____(NzRat)____ .   vars ____(N')____ M' ____(K')____ : NzNat .\n\n  ceq [rat01]: J' / M' = quot(J',gcd(J',M')) / quot(M',gcd(J',M'))\n     if gcd(J',M') > 1 = tt .                           *** canonical form of fraction\n  eq [rat02]: R' / 1 = R' .\n  eq [rat03]: I' / -(N') = -(I') / N' .\n  eq [rat04]: I' / (J' / M') = (I' * M') / J' .\n  eq [rat05]: (____(I' / N')____) / J' = I' / (N' * J') .\n  eq [rat06]: (I' / N') / (J' / M') = (I' * M') / (N' * J') .\n  ---- eq R? + I' + (J' / M') = R? + (((I' * M') + J') / M') .                      *** coherence extension\n  ---- eq R? + (I' / N') + (J' / M') = R? + (((I' * M') + (J' * N')) / (N' * M')) . *** coherence extension\n  eq [rat07]: -(I' / N') = -(I') / N' .\n  eq [rat08]: (I' / N') * 0 = 0 .\n  ---- eq R? * (I' / N') * 0 = 0 .                                     *** coherence extension\n  eq [rat09]: (I' / N') * J' = (I' * J') / N' .\n  ---- eq R? * (I' / N') * J' = R? * ((I' * J') / N') .                *** coherence extension\n  eq [rat10]: (I' / N') * (J' / M') = (I' * J') / (N' * M') .\n  ---- eq R? * (I' / N') * (J' / M') = R? * ((I' * J') / (N' * M')) .  *** coherence extension\n  eq [rat11]: | I' / N' | = | I' | / N' .\n  eq [rat12]: max(____(I' / N')____,J') = max(I',(____(J' * N')____)) / N' .\n  eq [rat13]: max(I' / N',____(J' / M')____) = max((I' * M'),(____(J' * N')____)) / (N' * M') .\n  eq [rat14]: min(I' / N',J') = min(I',(J' * N')) / N' .\n  eq [rat15]: min(I' / N',J' / M') = min((I' * M'),(____(J' * N')____)) / (N' * M') .\n  eq [rat16]: (I' / N') ~ J' = I' ~ (J' * N') .\n  eq [rat17]: (I' / N') ~ (J' / M') = (I' * M') ~ (J' * N') .\n  eq [rat18]: I' > (J' / M') = (I' * M') > J' .\n  eq [rat19]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat20]: (I' / N') > J' = I' > (J' * N') .\n  eq [rat21]: (I' / N') > (J' / M') = (I' * M') > (J' * N') .\nendfm\n```"]], "MAUDE-1/redBlackNGA_April2023.maude": [[true, "set show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run if there is an non-ground alien.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\nvar M : Nat .\n  op h : Set -> Set .\n  op i : Nat -> Nat .\n  ceq h(f(N, S, i(M))) = 0 if N > 0 .\nendfm\n\nred h(g(7)) .\nred h(g(8)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\nvar M : Nat .\n  op h : Set -> Set .\n  op i : Nat -> Nat .\n  ceq h(f(N, S, i(M))) = M if N > 0 .\nendfm\n\nred h(g(8)) .", "Okay, I will complete the Maude-NPA code based on the provided description and the incomplete file.\n\nHere's how the placeholders are filled:\n\nFor the first `fmod FOO`:\n*   `____(OP_0)____`: `Set` (Since `f` is a binary operation on `Set`)\n*   `____(OP_1)____`: `comm` (The description states `f` is associative and commutative, `assoc` is already present)\n*   `____(OP_2)____`: `g` (The operation `g` converts `Nat` to `Set`)\n*   `____(EQ_1)____`: `0` (From the base case `g(0) = 0`)\n*   `____(EQ_0)____`: `s N` (From the recursive case `g(s N) = f(g(N), s N)`)\n*   `____(OP_3)____`: `Set` (Since `h` is a unary operation on `Set`)\n*   `____(OP_4)____`: `Nat` (Since `i` takes `M` of type `Nat` as input, so `i : Nat -> Nat`)\n*   `____(EQ_3)____`: `N` (The first argument to `f` in the equation `h(f(N, S, i(M))) = 0`)\n*   `____(EQ_2)____`: `8` (The description mentions `red h(g(7))` and `red h(g(8))` for the first module)\n\nFor the second `fmod FOO`:\n*   `____(OP_5)____`: `Set` (Since `f` is a binary operation on `Set`)\n*   `____(OP_6)____`: `Set` (Since `f` is a binary operation on `Set`)\n*   `____(OP_7)____`: `g` (The operation `g` converts `Nat` to `Set`)\n*   `____(OP_8)____`: `h` (The operation `h` is unary on `Set`)\n*   `____(OP_9)____`: `Nat` (Since `i` takes `M` of type `Nat` as input, so `i : Nat -> Nat`)\n\n```maude\nset show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run if there is an non-ground alien.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\nvar M : Nat .\n  op h : Set -> Set .\n  op i : Nat -> Nat .\n  ceq h(f(N, S, i(M))) = 0 if N > 0 .\nendfm\n\nred h(g(7)) .\nred h(g(8)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\nvar M : Nat .\n  op h : Set -> Set .\n  op i : Nat -> Nat .\n  ceq h(f(N, S, i(M))) = M if N > 0 .\nendfm\n\nred h(g(8)) .\n```"]], "MAUDE-1/redBlackNonLinearApril2023.maude": [[true, "set show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(6))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) .", "```maude\nset show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(6))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) .\n```"]], "MAUDE-1/abstract-bakeryAC-checks.maude": [[true, "mod NAT> is\n  protecting NAT .\n  op _+_ : Nat Nat -> Nat [assoc comm id: 0] .  \n  op _>_ : Nat Nat -> Bool .\n\n  vars n, m : Nat .  vars n' : NzNat .\n\n  eq n + n' > n = tt .\n  eq n > n + m = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n\n  sorts Mode BState .\n\n  ops sleep wait crit : -> Mode [ctor] .\n  op <_,_,,_> : Mode Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n\n  vars P, Q : Mode .\n  vars X, Y : Nat .\n\n  eq initial = < sleep, 0, sleep, 0 > .\n  \n  rl [p1_sleep] : < sleep, X, Q, Y > => < wait, Y + 1, Q, Y > .\n  rl [p1_wait] : < wait, X, Q, 0 > => < crit, X, Q, 0 > .\n  crl [p1_wait] : < wait, X, Q, Y > => < crit, X, Q, Y > if  X > Y = ff .\n  rl [p1_crit] : < crit, X, Q, Y > => < sleep, 0, Q, Y > .\n  \n  rl [p2_sleep] : < P, X, sleep, Y > => < P, X, wait, X + 1  > .\n  rl [p2_wait] : < P, 0, wait, Y > => < P, 0, crit, Y > .\n  crl [p2_wait] : < P, X, wait, Y > => < P, X, crit, Y > if X > Y = tt .\n  rl [p2_crit] : < P, X, crit, Y > => < P, X, sleep, 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n\n  op _|=_ : State Prop -> Bool [frozen] .\n \n  vars P Q : Mode .\n  vars X Y : Nat .\n\n  eq < wait, X, Q, Y > |= 1wait = tt .\n  eq < sleep, X, Q, Y > |= 1wait = ff .\n  eq < crit, X, Q, Y > |= 1wait = ff .\n  eq < P , X, wait, Y > |= 2wait = tt .\n  eq < P , X, sleep, Y > |= 2wait = ff .\n  eq < P , X, crit, Y > |= 2wait = ff .\n  eq < crit , X, Q, Y > |= 1crit = tt .\n  eq < sleep, X, Q, Y > |= 1crit = ff .\n  eq < wait, X, Q, Y > |= 1crit = ff .\n  eq < P , X, crit, Y > |= 2crit = tt .\n  eq < P , X, sleep, Y > |= 2crit = ff .\n  eq < P , X, wait, Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n\n  vars P, Q : Mode .  vars X, Y : Nat .  vars X' Y' : NzNat .\n\n  eq < P, 0, Q, 1 + Y' > = < P, 0, Q, 1 >  .\n  eq < P, 1 + X', Q, 0 > = < P, 1 , Q, 0 >  .\n  eq < P, 1, Q, 1 + Y' + X' > = < P, 1, Q, 1 + 1 >  .  \n  eq < P, 1 + X' + Y', Q, 1 > = < P, 1 + 1, Q, 1 >  .  \n  eq < P, X' + 1, Q, Y' + X' + 1 > = < P, 1, Q, 1 + 1 > .\n  eq < P, X' + Y' + 1, Q, Y' + 1 > = < P, 1 + 1, Q, 1 >  .\n  eq < P, X' + Y' + 1, Q, X' + Y' + 1 > = < P, 1 + 1, Q, 1 + 1 > .\nendm", "```maude\nmod NAT> is\n  protecting NAT .\n  op _+_ : Nat Nat -> Nat [assoc comm id: 0] .  \n  op _>_ : Nat Nat -> Bool .\n\n  vars n, m : Nat .  vars n' : NzNat .\n\n  eq n + n' > n = tt .\n  eq n > n + m = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n\n  sorts Mode BState .\n\n  ops sleep wait crit : -> Mode [ctor] .\n  op <_,_,,_> : Mode Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n\n  vars P, Q : Mode .\n  vars X, Y : Nat .\n\n  eq initial = < sleep, 0, sleep, 0 > .\n  \n  rl [p1_sleep] : < sleep, X, Q, Y > => < wait, Y + 1, Q, Y > .\n  rl [p1_wait] : < wait, X, Q, 0 > => < crit, X, Q, 0 > .\n  crl [p1_wait] : < wait, X, Q, Y > => < crit, X, Q, Y > if  X > Y = ff .\n  rl [p1_crit] : < crit, X, Q, Y > => < sleep, 0, Q, Y > .\n  \n  rl [p2_sleep] : < P, X, sleep, Y > => < P, X, wait, X + 1  > .\n  rl [p2_wait] : < P, 0, wait, Y > => < P, 0, crit, Y > .\n  crl [p2_wait] : < P, X, wait, Y > => < P, X, crit, Y > if X > Y = tt .\n  rl [p2_crit] : < P, X, crit, Y > => < P, X, sleep, 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n\n  op _|=_ : State Prop -> Bool [frozen] .\n \n  vars P Q : Mode .\n  vars X Y : Nat .\n\n  eq < wait, X, Q, Y > |= 1wait = tt .\n  eq < sleep, X, Q, Y > |= 1wait = ff .\n  eq < crit, X, Q, Y > |= 1wait = ff .\n  eq < P , X, wait, Y > |= 2wait = tt .\n  eq < P , X, sleep, Y > |= 2wait = ff .\n  eq < P , X, crit, Y > |= 2wait = ff .\n  eq < crit , X, Q, Y > |= 1crit = tt .\n  eq < sleep, X, Q, Y > |= 1crit = ff .\n  eq < wait, X, Q, Y > |= 1crit = ff .\n  eq < P , X, crit, Y > |= 2crit = tt .\n  eq < P , X, sleep, Y > |= 2crit = ff .\n  eq < P , X, wait, Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n\n  vars P, Q : Mode .  vars X, Y : Nat .  vars X' Y' : NzNat .\n\n  eq < P, 0, Q, 1 + Y' > = < P, 0, Q, 1 >  .\n  eq < P, 1 + X', Q, 0 > = < P, 1 , Q, 0 >  .\n  eq < P, 1, Q, 1 + Y' + X' > = < P, 1, Q, 1 + 1 >  .  \n  eq < P, 1 + X' + Y', Q, 1 > = < P, 1 + 1, Q, 1 >  .  \n  eq < P, X' + 1, Q, Y' + X' + 1 > = < P, 1, Q, 1 + 1 > .\n  eq < P, X' + Y' + 1, Q, Y' + 1 > = < P, 1 + 1, Q, 1 >  .\n  eq < P, X' + Y' + 1, Q, X' + Y' + 1 > = < P, 1 + 1, Q, 1 + 1 > .\nendm\n```"]], "MAUDE-1/redBlackTooFewSubjectsApril2023.maude": [[true, "set show timing off .\n***\n***\tTest red-black ACU stripper-collector full matcher when 1 or 0 subjects are left.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, N, S)) = 0 if N > 0 .\nendfm\n\nred h(f(g(7), 0)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, 0, N, S)) = 0 if N > 0 .\nendfm\n\nred h(f(g(7), 0)) .", "```maude\nset show timing off .\n***\n***\tTest red-black ACU stripper-collector full matcher when 1 or 0 subjects are left.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, N, S)) = 0 if N > 0 .\nendfm\n\nred h(f(g(7), 0)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, 0, N, S)) = 0 if N > 0 .\nendfm\n\nred h(f(g(7), 0)) .\n```"]], "MAUDE-1/renamingInstantiationMarch2023.maude": [[true, "***\n***\tTest that renamings involving parameterized constants are instantiated correctly.\n***\n\nfmod FOO{X :: TRIV} is\n  sort Foo{X} .\n  op f{X} : -> Foo{X} .\nendfm\n\nfmod BAR{X :: TRIV} is\n  pr FOO{X} * (op f{X} to g) .\n  eq g = g .\nendfm\n\nfmod TEST is\n  inc BAR{Nat} .\nendfm\n\nshow all .\n\n\nomod FOO{X :: TRIV} is\n  class Foo{X} .\nendom\n\nomod BAR{X :: TRIV} is\n  inc FOO{X} * (class Foo{X} to Bar{X}) .\n  op className : -> Cid .\n  eq className = Bar{X} .\nendom\n\nomod TEST is\n  inc BAR{Nat} .\nendom\n\nshow all .", "Okay, I will complete the Maude formal analysis code.\nBased on your description and the provided incomplete file, the Maude code itself seems to be syntactically correct and complete, aside from the initial token \"houzhui\". This token prevents the file from being parsed correctly by Maude.\n\nAssuming \"houzhui\" is a label or artifact not intended to be part of the Maude code to be processed, or that the actual code begins after it, I will proceed with the Maude content. The Maude code provided does not contain any `____()___` placeholders. Therefore, according to the rule \"the symbols ```____()___``` indicate the positions that only need to be completed by you, and the other content should not be modified,\" no modifications will be made to the Maude code itself.\n\nThe provided description matches the Maude modules perfectly.\n\nHere is the completed Maude file content:\n\n```maude\n***\n***\tTest that renamings involving parameterized constants are instantiated correctly.\n***\n\nfmod FOO{X :: TRIV} is\n  sort Foo{X} .\n  op f{X} : -> Foo{X} .\nendfm\n\nfmod BAR{X :: TRIV} is\n  pr FOO{X} * (op f{X} to g) .\n  eq g = g .\nendfm\n\nfmod TEST is\n  inc BAR{Nat} .\nendfm\n\nshow all .\n\n\nomod FOO{X :: TRIV} is\n  class Foo{X} .\nendom\n\nomod BAR{X :: TRIV} is\n  inc FOO{X} * (class Foo{X} to Bar{X}) .\n  op className : -> Cid .\n  eq className = Bar{X} .\nendom\n\nomod TEST is\n  inc BAR{Nat} .\nendom\n\nshow all .\n```"]], "MAUDE-1/rent-a-car-store.maude": [[true, "set show timing off .\nset show advisories off .\nset verbose on .\n\n  ---- adapted\n  ---- from the book All About Maude\n  ---- from the Maude Manual\n  ---- by the Maude team\n\nomod RENT-A-CAR-STORE is\n  pr INT .\n  pr QID .\n\n  subsort Qid < Oid .\n\n  class Customer | cash : Nat, debt : Nat, suspended : Bool .\n  class Car | available : Bool, rate : Nat .\n  class EconomyCar .\n  class MidSizeCar .\n  class FullSizeCar .\n  subclasses EconomyCar MidSizeCar FullSizeCar < Car .\n\n  class Rental | deposit  : Nat, dueDate : Nat, pickUpDate : Nat,\n                 customer : Oid, car     : Oid .\n\n  class Calendar | date : Nat .\n\n  vars F Today Rt NumDays M N Amnt PDt DDt Dpst : Nat .\n  vars O U I C A : Oid .\n\n  rl [new-day] : \n    < O : Calendar | date : F >\n    => < O : Calendar | date : F + 1 > .\n\n  crl [car-rental] :\n    < U : Customer | cash : M, suspended : false >\n    < I : Car | available : true, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : M - Amnt >\n       < I : Car | available : false >\n       < C : Calendar | >\n       < A : Rental | pickUpDate : Today, dueDate : Today + NumDays,\n           car : I, deposit : Amnt, customer : U, rate : Rt >\n    if Amnt := Rt * NumDays /\\ M >= Amnt\n    [nonexec] .\n\n  crl [on-date-car-return] :\n    < U : Customer | cash : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : (M + Dpst) - Amnt >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if (Today <= DDt) /\\ Amnt := Rt * (Today - PDt)\n    [nonexec] .\n\n  crl [late-car-return] :\n    < U : Customer | debt : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | debt : (M + Amnt) - Dpst >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if DDt < Today    *** it is returned late\n       /\\ Amnt := Rt * (DDt - PDt) \n                  + ((Rt * (Today - DDt)) * (100 + 20)) quo 100\n    [nonexec] .\n\n  crl [pay-debt] :\n    < U : Customer | debt : M, cash : N >\n    => < U : Customer | debt : M - Amnt, cash : N - Amnt >\n    if 0 < Amnt /\\ Amnt <= N /\\ Amnt <= M\n    [nonexec] .\n\n  crl [suspend-late-payers] :\n    < U : Customer | debt : M, suspended : false >\n    => < U : Customer | suspended : true >\n    if M > 0 .\n\n  crl [suspend-late-returns] :\n    < U : Customer | suspended : false >\n    < I : Car | >\n    < A : Rental | customer : U, car : I, dueDate : DDt >\n    < C : Calendar | date : Today >\n    => < U : Customer | suspended : true >\n       < I : Car | >\n       < A : Rental | >\n       < C : Calendar | >\n    if DDt < Today .\nendom\n\n\nmod RENT-A-CAR-STORE-TEST is\n    pr RENT-A-CAR-STORE .\n\n    op StoreConf : -> Configuration [memo] .\n    eq StoreConf\n      = < 'C1 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'C2 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'A1 : EconomyCar | available : true, rate : 100 >\n        < 'A3 : MidSizeCar | available : true, rate : 150 >\n        < 'A5 : FullSizeCar | available : true, rate : 200 >\n        < 'C : Calendar | date : 0 > .\nendm\n\nrew [100] StoreConf .", "Okay, I will complete the Maude code based on your instructions. I have identified the missing variable names and types by analyzing their usage within the rules and the attributes of the classes.\n\nHere's the completed Maude file:\n\n```maude\nset show timing off .\nset show advisories off .\nset verbose on .\n\n  ---- adapted\n  ---- from the book All About Maude\n  ---- from the Maude Manual\n  ---- by the Maude team\n\nomod RENT-A-CAR-STORE is\n  pr INT .\n  pr QID .\n\n  subsort Qid < Oid .\n\n  class Customer | cash : Nat, debt : Nat, suspended : Bool .\n  class Car | available : Bool, rate : Nat .\n  class EconomyCar .\n  class MidSizeCar .\n  class FullSizeCar .\n  subclasses EconomyCar MidSizeCar FullSizeCar < Car .\n\n  class Rental | deposit  : Nat, dueDate : Nat, pickUpDate : Nat,\n                 customer : Oid, car     : Oid .\n\n  class Calendar | date : Nat .\n\n  vars F Today Rt NumDays M N Amnt PDt DDt Dpst : Nat .\n  vars O U I C A : Oid .\n\n  rl [new-day] : \n    < O : Calendar | date : F >\n    => < O : Calendar | date : F + 1 > .\n\n  crl [car-rental] :\n    < U : Customer | cash : M, suspended : false >\n    < I : Car | available : true, rate : Rt >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : M - Amnt >\n       < I : Car | available : false >\n       < C : Calendar | >\n       < A : Rental | pickUpDate : Today, dueDate : Today + NumDays,\n           car : I, deposit : Amnt, customer : U, rate : Rt >\n    if Amnt := Rt * NumDays /\\ M >= Amnt\n    [nonexec] .\n\n  crl [on-date-car-return] :\n    < U : Customer | cash : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | cash : (M + Dpst) - Amnt >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if (Today <= DDt) /\\ Amnt := Rt * (Today - PDt)\n    [nonexec] .\n\n  crl [late-car-return] :\n    < U : Customer | debt : M >\n    < I : Car | rate : Rt >\n    < A : Rental | customer : U, car : I, pickUpDate : PDt,\n                   dueDate : DDt, deposit : Dpst >\n    < C : Calendar | date : Today >\n    => < U : Customer | debt : (M + Amnt) - Dpst >\n       < I : Car | available : true >\n       < C : Calendar | >\n    if DDt < Today    *** it is returned late\n       /\\ Amnt := Rt * (DDt - PDt) \n                  + ((Rt * (Today - DDt)) * (100 + 20)) quo 100\n    [nonexec] .\n\n  crl [pay-debt] :\n    < U : Customer | debt : M, cash : N >\n    => < U : Customer | debt : M - Amnt, cash : N - Amnt >\n    if 0 < Amnt /\\ Amnt <= N /\\ Amnt <= M\n    [nonexec] .\n\n  crl [suspend-late-payers] :\n    < U : Customer | debt : M, suspended : false >\n    => < U : Customer | suspended : true >\n    if M > 0 .\n\n  crl [suspend-late-returns] :\n    < U : Customer | suspended : false >\n    < I : Car | >\n    < A : Rental | customer : U, car : I, dueDate : DDt >\n    < C : Calendar | date : Today >\n    => < U : Customer | suspended : true >\n       < I : Car | >\n       < A : Rental | >\n       < C : Calendar | >\n    if DDt < Today .\nendom\n\n\nmod RENT-A-CAR-STORE-TEST is\n    pr RENT-A-CAR-STORE .\n\n    op StoreConf : -> Configuration [memo] .\n    eq StoreConf\n      = < 'C1 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'C2 : Customer | cash : 5000, debt : 0, suspended : false >\n        < 'A1 : EconomyCar | available : true, rate : 100 >\n        < 'A3 : MidSizeCar | available : true, rate : 150 >\n        < 'A5 : FullSizeCar | available : true, rate : 200 >\n        < 'C : Calendar | date : 0 > .\nendm\n\nrew [100] StoreConf .\n```"]], "MAUDE-1/showModuleJune2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that showModule message returns imports of non-flattened modules.\n***\n\nload metaInterpreter\n\nmod TEST is\n  pr META-INTERPRETER .\n\n  op FOO : -> Module .\n  eq FOO = (\n    fmod 'FOO is\n      nil\n      sorts 'Foo .\n      none\n      op 'a : ____(nil)____ -> 'Foo [none] .\n      op 'b : nil -> ____('Foo)____ [none] .\n      none\n      eq 'a.Foo = 'b.Foo [none] .\n    endfm ).\n\n  op BAR : -> Module .\n  eq BAR = (\n    fmod 'BAR is\n      including 'FOO .\n      sorts none .\n      none\n      none\n      none\n      none\n    endfm ).\n\n  op me : -> Oid .\n  op User : -> Cid .\n\n  var X Y Z : Oid .\n  var N : Nat .\n  var T : Term .\n  var S : Sort .\n\n  sort State .\n  ops 1 2 3 4 : -> State [ctor] .\n  op state:_ : ____(State)____ -> Attribute [ctor] .\n\n  rl < X : User | state: 1 > createdInterpreter(X, Y, Z) => < X : User | state: 2 >\n       insertModule(Z, X, FOO) .\n\n  rl < X : User | state: 2 > insertedModule(X, Y) => < X : User | state: 3 >\n       insertModule(Y, X, ____(BAR)____) .\n\n  rl < X : User | state: 3 > insertedModule(X, Y) => < X : User | state: 4 > \n       showModule(Y, X, 'BAR, false) .\nendm\n\nerew  <> \n< me : User | state: 1 > \ncreateInterpreter(____(metaInterpreter)____, me, none) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that showModule message returns imports of non-flattened modules.\n***\n\nload metaInterpreter\n\nmod TEST is\n  pr META-INTERPRETER .\n\n  op FOO : -> Module .\n  eq FOO = (\n    fmod 'FOO is\n      nil\n      sorts 'Foo .\n      none\n      op 'a : ____(nil)____ -> 'Foo [none] .\n      op 'b : nil -> ____('Foo)____ [none] .\n      none\n      eq 'a.Foo = 'b.Foo [none] .\n    endfm ).\n\n  op BAR : -> Module .\n  eq BAR = (\n    fmod 'BAR is\n      including 'FOO .\n      sorts none .\n      none\n      none\n      none\n      none\n    endfm ).\n\n  op me : -> Oid .\n  op User : -> Cid .\n\n  var X Y Z : Oid .\n  var N : Nat .\n  var T : Term .\n  var S : Sort .\n\n  sort State .\n  ops 1 2 3 4 : -> State [ctor] .\n  op state:_ : ____(State)____ -> Attribute [ctor] .\n\n  rl < X : User | state: 1 > createdInterpreter(X, Y, Z) => < X : User | state: 2 >\n       insertModule(Z, X, FOO) .\n\n  rl < X : User | state: 2 > insertedModule(X, Y) => < X : User | state: 3 >\n       insertModule(Y, X, ____(BAR)____) .\n\n  rl < X : User | state: 3 > insertedModule(X, Y) => < X : User | state: 4 > \n       showModule(Y, X, 'BAR, false) .\nendm\n\nerew  <> \n< me : User | state: 1 > \ncreateInterpreter(____(metaInterpreter)____, me, none) .\n```"]], "MAUDE-1/smodStrategyNameJanuary2023.maude": [[true, "***\n***\tTest for bad strategy name in advisory.\n***\n\nsth T is\n  sorts Prop State .\n  strat expand : Prop @ State .\nendsth\n\nsmod M{X :: T} is\nendsm\n\nsmod TEST{X :: T} is\n  inc M{X} * (strat expand : Prop @ State to expand') .\nendsm", "The Maude code provided appears to be complete based on the description and the specific instruction regarding `____()___` placeholders. Since no such placeholders are present in the input, no parts of the code need to be filled in. The provided code is syntactically correct Maude code and should be loadable by Maude-NPA.\n\nThe purpose of this code, as described, is to test how Maude-NPA handles a strategy renaming via an advisory, specifically when the new strategy name is `expand'`. This name is syntactically valid in Maude. The test would observe Maude-NPA's behavior when encountering or using this renamed strategy.\n\n```maude\n***\n***\tTest for bad strategy name in advisory.\n***\n\nsth T is\n  sorts Prop State .\n  strat expand : Prop @ State .\nendsth\n\nsmod M{X :: T} is\nendsm\n\nsmod TEST{X :: T} is\n  inc M{X} * (strat expand : Prop @ State to expand') .\nendsm\n```"]], "MAUDE-1/sortCollapseMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug that we weren't warning about a collapse\n***\tup the sort hierarchy for declarations at the kind level.\n***\n\nfmod FOO is\n  sort Foo .\n  op ____(f)____ : Foo [Foo] -> Foo [id: ____(e)____] .\n  op e : -> Foo .\nendfm\n\nparse f(e, X:[Foo]) .\nred f(e, X:[Foo]) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug that we weren't warning about a collapse\n***\tup the sort hierarchy for declarations at the kind level.\n***\n\nfmod FOO is\n  sort Foo .\n  op ____(f)____ : Foo [Foo] -> Foo [id: ____(e)____] .\n  op e : -> Foo .\nendfm\n\nparse f(e, X:[Foo]) .\nred f(e, X:[Foo]) .\n```"]], "MAUDE-1/specificOpMappingPrintFebruary2023.maude": [[true, "***\n***\tTest that specific op maps print correctly.\n***\n\nmod FOO is\n  sorts Foo Bar .\n  op f : Foo -> Bar .\nendm\n\nmod BAR is\n  inc FOO * (op f : Foo -> Bar to g) .\nendm\n\nshow desugared .", "```maude\n***\n***\tTest that specific op maps print correctly.\n***\n\nmod FOO is\n  sorts Foo Bar .\n  op f : Foo -> Bar .\nendm\n\nmod BAR is\n  inc FOO * (op f : Foo -> Bar to g) .\nendm\n\nshow desugared .\n```"]], "MAUDE-1/staleViewJune2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n*** Check that we don't look the mapping for _<_\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nshow view V .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nshow view V .\n\n*** Check the same issue at the metalevel.\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nred in META-LEVEL : upView('V) .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nred in META-LEVEL : upView('V) .", "```maude\nset show timing off .\nset show advisories off .\n\n*** Check that we don't look the mapping for _<_\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nshow view V .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nshow view V .\n\n*** Check the same issue at the metalevel.\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 10] .\n  op p_ : Bool -> Bool [prec 20] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X:Bool + Y:Bool .\nendv\n\nred in META-LEVEL : upView('V) .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op p_ : Bool -> Bool [prec 10] .\nendfm\n\nred in META-LEVEL : upView('V) .\n```"]], "MAUDE-1/stringToRatConversionMarch2024.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where certain strings did not convert.\n***\n\nselect CONVERSION .\n\nred rat(\"-0\", 10) .\n\nred rat(\"0/1\", 10) .\n\nred rat(\"-0/1\", 10) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where certain strings did not convert.\n***\n\nselect CONVERSION .\n\nred rat(\"-0\", 10) .\n\nred rat(\"0/1\", 10) .\n\nred rat(\"-0/1\", 10) .\n```"]], "MAUDE-1/stripperCollectorSwitchMay2023.maude": [[true, "set show timing off .\n\n***\n***\tCrafted example to illustrate bug if variables are sorted after the stripper and\n***\tcollector variables have been determined and they switch places, causing match failure.\n***\n\nfmod FOO is\n  pr NAT .\n  sorts Set Elt .\n  subsort Elt < Set .\nvar S : Set .\nvar E : Elt .\nvar N : Nat .\n  op dummy : ____(Set)____ -> Set .\n  eq dummy(S) = S .\n\n  op z : -> Elt .\n  op ____(p_)____ : Elt -> Elt .\n  op g : Nat ____(Elt)____ -> Set .\n  eq g(s N, E) = f(g(____(N)____, p E), E) .\n  \n  op f : ____(Set)____ Set -> Set [____(assoc)____ comm] .\n  op ____(h)____ : Set -> Bool .\n  ceq h(f(S, E)) = true if E = z .\nendfm\n\nred h(g(7, ____(z)____)) .\nred h(g(8, z)) .\nred h(g(20, z)) .", "```maude\nset show timing off .\n\n***\n***\tCrafted example to illustrate bug if variables are sorted after the stripper and\n***\tcollector variables have been determined and they switch places, causing match failure.\n***\n\nfmod FOO is\n  pr NAT .\n  sorts Set Elt .\n  subsort Elt < Set .\nvar S : Set .\nvar E : Elt .\nvar N : Nat .\n  op dummy : ____(Set)____ -> Set .\n  eq dummy(S) = S .\n\n  op z : -> Elt .\n  op ____(p_)____ : Elt -> Elt .\n  op g : Nat ____(Elt)____ -> Set .\n  eq g(s N, E) = f(g(____(N)____, p E), E) .\n  \n  op f : ____(Set)____ Set -> Set [____(assoc)____ comm] .\n  op ____(h)____ : Set -> Bool .\n  ceq h(f(S, E)) = true if E = z .\nendfm\n\nred h(g(7, ____(z)____)) .\nred h(g(8, z)) .\nred h(g(20, z)) .\n```"]], "MAUDE-1/ACU_MissingUnifiersMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op _+_ : Nat NzNat -> NzNat [assoc comm id: 0] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op 0 : -> Zero .\n  op g : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op _+_ : Nat NzNat -> NzNat [assoc comm id: 0] .\n  op _+_ : Nat Nat -> Nat [assoc comm] .\n  op 0 : -> Zero .\n  op g : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) .\n```"]], "MAUDE-1/uninitIterExtSeptember2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in handling of extension information for iter symbols.\n***\n\nmod UNINITIALIZED-BUG is\n  protecting NAT .\n  vars N M : ____(Nat)____ .\n  crl [rwc] : s N => M if N => M [nonexec] .\nendm\n\nsrew 3 using rwc{idle} .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in handling of extension information for iter symbols.\n***\n\nmod UNINITIALIZED-BUG is\n  protecting NAT .\n  vars N M : ____(Nat)____ .\n  crl [rwc] : s N => M if N => M [nonexec] .\nendm\n\nsrew 3 using rwc{idle} .\n```"]], "MAUDE-1/upTheoryJanuary2023.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for automatic imports being included in upModule() of theories.\n***\n\nfth FOO is\n  sort Foo .\nendfth\n\nshow desugared FOO .\n\nred in META-LEVEL : upModule('FOO, false) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for automatic imports being included in upModule() of theories.\n***\n\nfth FOO is\n  sort Foo .\nendfth\n\nshow desugared FOO .\n\nred in META-LEVEL : upModule('FOO, false) .\n```"]], "MAUDE-1/variantUnifyJune2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck for substitution size bug that affected both UnifierFilter\n***\tand VariantFolder, because subpatterns were being compiled before\n***\tall abstraction variables were added.\n***\n\nfmod A-UNIF is\n  sorts List Elt .\n  subsort Elt < List .\n  op f : List List -> List [assoc] .\n  op j : List List -> List [assoc comm id: 1] .\n  op 1 : -> List .\n  vars A B C D G H I \n       S U V W X Y Z : List .\n  var E  : Elt .\nendfm\n\nvariant unify j(A, f(B, E, C), f(D, E, j(G, H), I)) =?\n  j(U, f(V, W), f(X, j(Y, Z), S)) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck for substitution size bug that affected both UnifierFilter\n***\tand VariantFolder, because subpatterns were being compiled before\n***\tall abstraction variables were added.\n***\n\nfmod A-UNIF is\n  sorts List Elt .\n  subsort Elt < List .\n  op f : List List -> List [assoc] .\n  op j : List List -> List [assoc comm id: 1] .\n  op 1 : -> List .\n  vars A B C D G H I \n       S U V W X Y Z : List .\n  var E  : Elt .\nendfm\n\nvariant unify j(A, f(B, E, C), f(D, E, j(G, H), I)) =?\n  j(U, f(V, W), f(X, j(Y, Z), S)) .\n```"]], "MAUDE-1/renaming.maude": [[true, "set show timing off .\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, sort Bar to Quux) .\nendfm\n\nshow mod .\nshow all .\n\nfmod ONE is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod TWO is\n  inc ONE * (sort Foo to Baz) .\n  sort Quux .\n  subsort Quux < Baz .\nendfm\n\nfmod THREE is\n  inc TWO * (sort Foo to Foo', sort Baz to Baz', sort Quux to Quux') .\n  sort Jaz .\n  subsort Jaz < Baz' .\nendfm\n\nshow mod .\nshow all .\n\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, op a to b) .\nendfm\n\nshow mod .\nshow all .\n\nfmod FOO' is\n  sorts Foo Bar Baz .\n  subsort Foo < Bar .\n  op a : -> Baz .\n  op ____(_+_)____ : Foo Foo -> Foo [prec 31 gather (e ____(E)____) ____(plus)____ ____(E)____] .\n  op _+_ : ____(Baz)____ ____(Baz)____ -> Foo [prec 31 gather (e ____(E plus E)____)] .\nendfm\n\nfmod BAR' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ : Foo Foo -> Foo to _*_ [prec 29 gather (E e)],\n    op _+_ : Baz Baz -> Foo to _._ [prec 27 gather (E e)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a . a * a . a .\n\nfmod BAR'' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ to _*_ [prec 29 gather (E E)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a * a * a * a .\nred (a * a) * (a * a) .\n\n*** Check splitting renaming over bashed together ops\n\nfmod DIFF is\n  sorts Foo Bar .\n  op f : ____(Foo)____ -> Foo .\n  op ____(f)____ : Bar -> Bar .\nendfm\n\nfmod BASH is\n  inc DIFF .\n  subsort Foo < Bar .\nendfm\n\nfmod TEST is\n  inc BASH * (op ____(f)____ : ____(Foo)____ -> Foo to g) .\nendfm\n\nshow mod .\nshow all .\nshow modules .", "```maude\nset show timing off .\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, sort Bar to Quux) .\nendfm\n\nshow mod .\nshow all .\n\nfmod ONE is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod TWO is\n  inc ONE * (sort Foo to Baz) .\n  sort Quux .\n  subsort Quux < Baz .\nendfm\n\nfmod THREE is\n  inc TWO * (sort Foo to Foo', sort Baz to Baz', sort Quux to Quux') .\n  sort Jaz .\n  subsort Jaz < Baz' .\nendfm\n\nshow mod .\nshow all .\n\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, op a to b) .\nendfm\n\nshow mod .\nshow all .\n\nfmod FOO' is\n  sorts Foo Bar Baz .\n  subsort Foo < Bar .\n  op a : -> Baz .\n  op ____(_+_)____ : Foo Foo -> Foo [prec 31 gather (e ____(E)____) ____(plus)____ ____(E)____] .\n  op _+_ : ____(Baz)____ ____(Baz)____ -> Foo [prec 31 gather (e ____(E plus E)____)] .\nendfm\n\nfmod BAR' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ : Foo Foo -> Foo to _*_ [prec 29 gather (E e)],\n    op _+_ : Baz Baz -> Foo to _._ [prec 27 gather (E e)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a . a * a . a .\n\nfmod BAR'' is \n  inc FOO' *\n  (\n    sort Foo to Quux,\n    op _+_ to _*_ [prec 29 gather (E E)]\n  ) .\nendfm\n\nshow mod .\nshow all .\n\nred a * a * a * a .\nred (a * a) * (a * a) .\n\n*** Check splitting renaming over bashed together ops\n\nfmod DIFF is\n  sorts Foo Bar .\n  op f : ____(Foo)____ -> Foo .\n  op ____(f)____ : Bar -> Bar .\nendfm\n\nfmod BASH is\n  inc DIFF .\n  subsort Foo < Bar .\nendfm\n\nfmod TEST is\n  inc BASH * (op ____(f)____ : ____(Foo)____ -> Foo to g) .\nendfm\n\nshow mod .\nshow all .\nshow modules .\n```"]], "MAUDE-1/Carlsen_Secret_Key_Initiator.maude": [[true, "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e _ _)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NB1 NMS N : Nonce .\n  vars M1 M2 MA MB Xmsg Ymsg Zmsg : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(X:Msg), +(p(X:Msg)), nil ] &\n     :: nil :: [ nil | -(K), -(M:Msg), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M:Msg), -(N:Msg), +(M ; N:Msg) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)),\n             nil ]\n   &\n     :: r , r1 ::\n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))),\n             nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A)\n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))),\n            nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol\n     :: r , r1 ::\n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e _ _)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NB1 NMS N : Nonce .\n  vars M1 M2 MA MB Xmsg Ymsg Zmsg : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(X:Msg), +(p(X:Msg)), nil ] &\n     :: nil :: [ nil | -(K), -(M:Msg), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(M:Msg), -(N:Msg), +(M ; N:Msg) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)),\n             nil ]\n   &\n     :: r , r1 ::\n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))),\n             nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A)\n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))),\n            nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol\n     :: r , r1 ::\n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/ltv-F-tmn.maude": [[true, "***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n\nop pair : Msg Msg -> Msg [frozen] .\n*** encryption here is thus that only the server can decrypt it!\nop enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  vars X Y : Msg .\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * X:Msg * Y:Msg = Y:Msg [variant] .\n  eq X:Msg * null = X:Msg [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N N' NA NB : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(A, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n\nop pair : Msg Msg -> Msg [frozen] .\n*** encryption here is thus that only the server can decrypt it!\nop enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  vars X Y : Msg .\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * X:Msg * Y:Msg = Y:Msg [variant] .\n  eq X:Msg * null = X:Msg [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N N' NA NB : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(A, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ltv-F-tmn2-asy.maude": [[true, "***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n  subsort Null < Msg .\n\n  op pair : Msg Msg -> Msg [frozen] .\n  *** encryption here is thus that only the server can decrypt it!\n  op enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq null * X:Msg = X:Msg [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq X:Msg * X:Msg = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y : Msg .\n  vars r r' : Fresh .\n  vars N NB NA N' : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n  subsort Null < Msg .\n\n  op pair : Msg Msg -> Msg [frozen] .\n  *** encryption here is thus that only the server can decrypt it!\n  op enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq null * X:Msg = X:Msg [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq X:Msg * X:Msg = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y : Msg .\n  vars r r' : Fresh .\n  vars N NB NA N' : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/dh.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A)\nB --> A: A ; B ; exp(g,N_A)\nA --> B: enc(exp(exp(g,N_B),N_A),secret(A,B))\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n\n*** Note from the completer: The Maude code, especially Alice's strand sending\n    enc(exp(XE,n(A,r)),...), where XE is from message 2, implies that message 2\n    from B to A should be A ; B ; exp(g,N_B) for the protocol to make cryptographic sense\n    (i.e., to form a key exp(g, N_A*N_B)). The journal description for message 2,\n    \"B --> A: A ; B ; exp(g,N_A)\", seems to be a typo. The completion proceeds\n    assuming message 2 is A ; B ; exp(g,N_B), which is consistent with the\n    provided Maude strand definitions.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort ____(Gen)____ Exp < GenvExp .\n  subsort ____(Name)____ ____(NeNonceSet)____ GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op ____(sec)____ : Name ____(Name)____ -> Secret [frozen] .\n\n  --- Nonce operator\n  op ____(n)____ : ____(Name)____ Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : ____(Key)____ ____(Msg)____ -> Msg [frozen] .\n  op d : Key ____(Msg)____ -> Msg [____(frozen)____] .\n\n  --- Exp\n  op exp : ____(GenvExp)____ ____(NeNonceSet)____ -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [____(comm)____ assoc ____(frozen)____] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen gather (e ____(e exp)____)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(____(K:Key)____,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars ____(NS1)____ NS2 NS3 NS : ____(NeNonceSet)____ .\n  var NA NB N : Nonce .\n  var ____(GE)____ : GenvExp .\n  var G : Gen .\n  vars ____(A)____ B : Name .\n  vars ____(r)____ r' r1 ____(r2)____ r3 : Fresh .\n  var ____(Ke)____ : Key .\n  vars XE YE : ____(Exp)____ .\n  vars M M1 ____(M2)____ : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; ____(M2)____), +(M1), nil ] &\n     :: nil :: [ nil | -(____(M1)____ ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(____(Ke)____,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(____(NS1)____), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; ____(B)____ ; XE), \n            +(e(exp(____(XE)____,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(____(XE)____,n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(____(0)____)\n   = :: r :: \n     [nil, -(____(a)____ ; b ; XE), \n           +(a ; ____(b)____ ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,____(r)____)),sec(a,____(b)____))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [nil | +(a ; b ; ____(exp(g,n(a,R)))____), \n            -(a ; ____(b)____ ; exp(g,n(b,r))), \n            +(e(____(exp(exp(g,n(b,r)),n(a,R)))____,sec(a,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(____(1)____)\n   = :: r :: \n     [nil, -(a ; ____(b)____ ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), ____(Sr)____)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A)\nB --> A: A ; B ; exp(g,N_A)\nA --> B: enc(exp(exp(g,N_B),N_A),secret(A,B))\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n\n*** Note from the completer: The Maude code, especially Alice's strand sending\n    enc(exp(XE,n(A,r)),...), where XE is from message 2, implies that message 2\n    from B to A should be A ; B ; exp(g,N_B) for the protocol to make cryptographic sense\n    (i.e., to form a key exp(g, N_A*N_B)). The journal description for message 2,\n    \"B --> A: A ; B ; exp(g,N_A)\", seems to be a typo. The completion proceeds\n    assuming message 2 is A ; B ; exp(g,N_B), which is consistent with the\n    provided Maude strand definitions.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort ____(Gen)____ Exp < GenvExp .\n  subsort ____(Name)____ ____(NeNonceSet)____ GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op ____(sec)____ : Name ____(Name)____ -> Secret [frozen] .\n\n  --- Nonce operator\n  op ____(n)____ : ____(Name)____ Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : ____(Key)____ ____(Msg)____ -> Msg [frozen] .\n  op d : Key ____(Msg)____ -> Msg [____(frozen)____] .\n\n  --- Exp\n  op exp : ____(GenvExp)____ ____(NeNonceSet)____ -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [____(comm)____ assoc ____(frozen)____] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen gather (e ____(e exp)____)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(____(K:Key)____,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars ____(NS1)____ NS2 NS3 NS : ____(NeNonceSet)____ .\n  var NA NB N : Nonce .\n  var ____(GE)____ : GenvExp .\n  var G : Gen .\n  vars ____(A)____ B : Name .\n  vars ____(r)____ r' r1 ____(r2)____ r3 : Fresh .\n  var ____(Ke)____ : Key .\n  vars XE YE : ____(Exp)____ .\n  vars M M1 ____(M2)____ : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; ____(M2)____), +(M1), nil ] &\n     :: nil :: [ nil | -(____(M1)____ ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(____(Ke)____,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(____(NS1)____), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; ____(B)____ ; XE), \n            +(e(exp(____(XE)____,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(____(XE)____,n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(____(0)____)\n   = :: r :: \n     [nil, -(____(a)____ ; b ; XE), \n           +(a ; ____(b)____ ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,____(r)____)),sec(a,____(b)____))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [nil | +(a ; b ; ____(exp(g,n(a,R)))____), \n            -(a ; ____(b)____ ; exp(g,n(b,r))), \n            +(e(____(exp(exp(g,n(b,r)),n(a,R)))____,sec(a,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(____(1)____)\n   = :: r :: \n     [nil, -(a ; ____(b)____ ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), ____(Sr)____)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/esorics12-asy.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce Null NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .  --- (?)\n\n   --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN ZN : Msg .\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq XN * XN = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | -(sk(A,X)), +(X), nil ] & \n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(B,r))), \n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, XN)), \n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,XN) inL . \n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(n(a,r'))\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, XN)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,r')) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce Null NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .  --- (?)\n\n   --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [frozen assoc comm] .\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN ZN : Msg .\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [nonexec label XOR-UNITY metadata \"builtin-unify\"] .\n  eq XN * XN = null [nonexec label XOR-NilPotent metadata \"builtin-unify\"] .\n\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | -(sk(A,X)), +(X), nil ] & \n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(B,r))), \n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, XN)), \n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,XN) inL . \n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(n(a,r'))\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, XN)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,r')) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/esorics12-variant.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < ____(SUBSORT_0)____ . --- SUBSORT_0: Msg\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : ____(OP_1)____ Msg -> Msg [____(OP_0)____] . --- OP_1: Name, OP_0: ctor\n  op sk : Name Msg -> Msg [frozen] .  --- (?)\n\n   --- Nonce operator\n  op n : ____(OP_5)____ Fresh -> ____(OP_4)____ [frozen] . --- OP_5: Name, OP_4: Nonce\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op ____(OP_7)____ : ____(OP_6)____ NNSet -> NNSet [frozen assoc comm] . --- OP_7: _^_, OP_6: NNSet\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(EQ_5)____ : Name . --- EQ_5: A\n  vars ____(VAR_0)____ Y Z : Msg . --- VAR_0: X\n  vars XN YN ____(VAR_1)____ : Msg . --- VAR_1: ZN\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars ____(EQ_4)____ Y Z : ____(VAR_2)____ . --- EQ_4: X, VAR_2: Msg\n  vars r r' : ____(VAR_3)____ . --- VAR_3: Fresh\n  vars ____(VAR_4)____ B : Name . --- VAR_4: A\n  vars N ____(VAR_5)____ NB : Nonce . --- VAR_5: NA\n  vars ____(VAR_6)____ YN : NNSet . --- VAR_6: XN\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(____(EQ_7)____), +(sk(____(EQ_6)____,X)), nil ] & --- EQ_7: X, EQ_6: i\n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(____(EQ_0)____,X)), nil ] & --- EQ_0: A\n     :: nil :: [ nil | -(sk(A,____(EQ_2)____)), +(X), nil ] & --- EQ_2: X\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(____(EQ_9)____,r))), --- EQ_9: B\n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, ____(EQ_8)____)), --- EQ_8: XN\n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,____(EQ_1)____) inL .  --- EQ_1: XN\n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, XN)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,____(EQ_3)____)) | nil] --- EQ_3: r'\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < ____(SUBSORT_0)____ . --- SUBSORT_0: Msg\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : ____(OP_1)____ Msg -> Msg [____(OP_0)____] . --- OP_1: Name, OP_0: ctor\n  op sk : Name Msg -> Msg [frozen] .  --- (?)\n\n   --- Nonce operator\n  op n : ____(OP_5)____ Fresh -> ____(OP_4)____ [frozen] . --- OP_5: Name, OP_4: Nonce\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op ____(OP_7)____ : ____(OP_6)____ NNSet -> NNSet [frozen assoc comm] . --- OP_7: _^_, OP_6: NNSet\n  op null : -> Null .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(EQ_5)____ : Name . --- EQ_5: A\n  vars ____(VAR_0)____ Y Z : Msg . --- VAR_0: X\n  vars XN YN ____(VAR_1)____ : Msg . --- VAR_1: ZN\n\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\n \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars ____(EQ_4)____ Y Z : ____(VAR_2)____ . --- EQ_4: X, VAR_2: Msg\n  vars r r' : ____(VAR_3)____ . --- VAR_3: Fresh\n  vars ____(VAR_4)____ B : Name . --- VAR_4: A\n  vars N ____(VAR_5)____ NB : Nonce . --- VAR_5: NA\n  vars ____(VAR_6)____ YN : NNSet . --- VAR_6: XN\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(____(EQ_7)____), +(sk(____(EQ_6)____,X)), nil ] & --- EQ_7: X, EQ_6: i\n     :: nil :: [ nil | -(pk(i,X)), +(X), nil ] & \n     :: nil :: [ nil | -(X), +(pk(____(EQ_0)____,X)), nil ] & --- EQ_0: A\n     :: nil :: [ nil | -(sk(A,____(EQ_2)____)), +(X), nil ] & --- EQ_2: X\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil |  +(pk(A, n(____(EQ_9)____,r))), --- EQ_9: B\n            -(pk(B, YN)), \n            +(YN * n(B,r)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil |  -(pk(A, ____(EQ_8)____)), --- EQ_8: XN\n            +(pk(B, n(A,r'))), \n            -(XN * n(A,r')), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl XN notInI => pk(A,____(EQ_1)____) inL .  --- EQ_1: XN\n      ! S1 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n  =  :: r' :: *** Alice ***\n     [nil,  -(pk(a, XN)), \n             +(pk(b, n(a,r'))), \n             -(XN * n(a,____(EQ_3)____)) | nil] --- EQ_3: r'\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ACU_TreeVariableSubproblem.maude": [[true, "set show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N = 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N = 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N = 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1", "```maude\nset show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N = 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N = 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N = 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n```"]], "MAUDE-1/homo-hpc.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n --- Importing sorts Msg, Fresh, Public, and GhostData\n protecting DEFINITION-PROTOCOL-RULES .\n\n ----------------------------------------------------------\n --- Overwrite this module with the syntax of your protocol\n --- Notes:\n --- * Sort Msg Fresh are special and imported\n --- * Every sort must be a subsort of Msg\n --- * No sort can be a supersort of Msg\n ----------------------------------------------------------\n\n --- Sort Information\n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n --- Nonce operators\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n --- Principals\n op a : -> Name . --- Alice\n op b : -> Name . --- Bob\n op s : -> Name . --- Server\n op i : -> Name . --- Intruder\n\n--- Concatenation operator\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n--- Public and Private Key operators\n op pkey : Name Name -> Pkey [frozen] . --- Represents the shared key k(A,B) for hpke\n\n--- f operator\n op f : Msg Msg -> HEnc [frozen] . --- f takes messages, produces an HEnc.\n                                 --- Due to HEnc < Msg, and the algebraic axiom,\n                                 --- f can also effectively take HEnc arguments.\n\n--- Encryption Operators\n op pke : Msg Name -> Enc [frozen] . --- Encrypts Msg with public key of Name\n op hpke : Msg Pkey -> HEnc [frozen] . --- Homomorphic encryption of Msg with shared Pkey\n op sign : Msg Name -> Sign [frozen] . --- Signs Msg with private key of Name\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n ----------------------------------------------------------\n --- Overwrite this module with the algebraic properties\n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y : Msg .\n var K : Pkey .\n\n ***Homomorphic encryption over f\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K))\n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n ----------------------------------------------------------\n --- Overwrite this module with the strands\n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n\n\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &                --- Composition\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &                      --- Decomposition 1\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &                      --- Decomposition 2\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] &           --- pke Encryption (A is target Name)\n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &                   --- pke Decryption by intruder (if msg to pk(i))\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] &                --- Intruder signing\n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] &                  --- Intruder reads content of any signature\n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] & --- hpke Encryption. Assumes pkey(A,B) is constructible by anyone knowing A,B.\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] &         --- hpke Decryption by intruder if key is pkey(A,i)\n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] &         --- hpke Decryption by intruder if key is pkey(i,B)\n    :: nil :: [ nil | -(X), -(Y), +(f(X,Y)), nil ] &               --- Intruder can compute f (assuming f is public)\n    :: nil :: [ nil | +(A), nil ]                                  --- Intruder knows public names/keys (A is a Name here)\n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  = :: r, r'  :: *** Alice ***\n    [ nil | +(sign( B ; n(A,r)  ; pke(hpke(data(A,r'),pkey(A,B)),s),A)),\n            -(sign( n(A,r) ; N ; Y1 , B)),\n            +(sign( A ; B ; n(A,r) ; N ; pke(hpke(data(A,r'),pkey(A,B)),s) ; Y1  , A)),\n\t    -(sign( A ; B ; n(A,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: ***Bob ***\n    [ nil | -(sign( B ; N1  ; Y2, A)),\n            +(sign( N1 ; n(B,r) ; pke(hpke(data(B,r'),pkey(A,B)),s), B)),\n\t    -(sign( A ; B ; N1 ; n(B,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: *** Server ***\n    [ nil | -(sign( A ; B ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , A)),\n            +(sign( A ; B ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  *** Alice ***\n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )),\n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty --- Initial Intruder Knowledge (empty means intruder starts with basic knowledge like its own identity i, and public names like a,b,s)\n     || nil --- constraints on initial state (e.g. neq conditions)\n     || nil --- path conditions\n     || never(\n     *** Authentication: Bob must have sent msg2 to Alice after receiving msg1 from Alice ***\n     :: r1, r2  :: ***Bob ***\n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)), --- Bob receives msg1 from Alice=a, using Alice's nonce n(a,r) and data(a,r')\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)), --- Bob sends msg2 to Alice=a, with his nonce n(b,r1) and data(b,r2)\n       nil ]\n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "Okay, I will complete the Maude-NPA code based on your description and the provided template.\n\nThe main areas for completion in a typical Maude-NPA specification, given the context, involve:\n1.  Ensuring all operators are defined with appropriate sorts.\n2.  Ensuring all necessary Dolev-Yao rules for the operators involved in the protocol are present, especially for any custom operators like `f`.\n3.  Verifying that the protocol strands correctly represent the protocol messages.\n4.  Checking the attack state for well-formedness and clear intent.\n\nBased on the provided code and description, the definition of the function `f` and its usage in the homomorphic property and by the server is critical. The existing definition `op f : Msg Msg -> HEnc` and the homomorphic equation `eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K))` imply that `f` can take `Msg` arguments (plaintexts) to produce an `HEnc`, and also take `HEnc` arguments (ciphertexts) to produce an `HEnc`. This is possible if `HEnc` is a subsort of `Msg`, which it is.\n\nA common Dolev-Yao rule is that the intruder can apply any public function. If `f` is considered a public function, the intruder should be able to compute it. I will add this rule.\n\nThe rest of the specification appears largely consistent with the protocol description.\n\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n --- Importing sorts Msg, Fresh, Public, and GhostData\n protecting DEFINITION-PROTOCOL-RULES .\n\n ----------------------------------------------------------\n --- Overwrite this module with the syntax of your protocol\n --- Notes:\n --- * Sort Msg Fresh are special and imported\n --- * Every sort must be a subsort of Msg\n --- * No sort can be a supersort of Msg\n ----------------------------------------------------------\n\n --- Sort Information\n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n --- Nonce operators\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n --- Principals\n op a : -> Name . --- Alice\n op b : -> Name . --- Bob\n op s : -> Name . --- Server\n op i : -> Name . --- Intruder\n\n--- Concatenation operator\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n--- Public and Private Key operators\n op pkey : Name Name -> Pkey [frozen] . --- Represents the shared key k(A,B) for hpke\n\n--- f operator\n op f : Msg Msg -> HEnc [frozen] . --- f takes messages, produces an HEnc.\n                                 --- Due to HEnc < Msg, and the algebraic axiom,\n                                 --- f can also effectively take HEnc arguments.\n\n--- Encryption Operators\n op pke : Msg Name -> Enc [frozen] . --- Encrypts Msg with public key of Name\n op hpke : Msg Pkey -> HEnc [frozen] . --- Homomorphic encryption of Msg with shared Pkey\n op sign : Msg Name -> Sign [frozen] . --- Signs Msg with private key of Name\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n ----------------------------------------------------------\n --- Overwrite this module with the algebraic properties\n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y : Msg .\n var K : Pkey .\n\n ***Homomorphic encryption over f\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K))\n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n ----------------------------------------------------------\n --- Overwrite this module with the strands\n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n\n\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &                --- Composition\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &                      --- Decomposition 1\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &                      --- Decomposition 2\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] &           --- pke Encryption (A is target Name)\n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &                   --- pke Decryption by intruder (if msg to pk(i))\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] &                --- Intruder signing\n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] &                  --- Intruder reads content of any signature\n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] & --- hpke Encryption. Assumes pkey(A,B) is constructible by anyone knowing A,B.\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] &         --- hpke Decryption by intruder if key is pkey(A,i)\n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] &         --- hpke Decryption by intruder if key is pkey(i,B)\n    :: nil :: [ nil | -(X), -(Y), +(f(X,Y)), nil ] &               --- Intruder can compute f (assuming f is public)\n    :: nil :: [ nil | +(A), nil ]                                  --- Intruder knows public names/keys (A is a Name here)\n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  = :: r, r'  :: *** Alice ***\n    [ nil | +(sign( B ; n(A,r)  ; pke(hpke(data(A,r'),pkey(A,B)),s),A)),\n            -(sign( n(A,r) ; N ; Y1 , B)),\n            +(sign( A ; B ; n(A,r) ; N ; pke(hpke(data(A,r'),pkey(A,B)),s) ; Y1  , A)),\n\t    -(sign( A ; B ; n(A,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: ***Bob ***\n    [ nil | -(sign( B ; N1  ; Y2, A)),\n            +(sign( N1 ; n(B,r) ; pke(hpke(data(B,r'),pkey(A,B)),s), B)),\n\t    -(sign( A ; B ; N1 ; n(B,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: *** Server ***\n    [ nil | -(sign( A ; B ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , A)),\n            +(sign( A ; B ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  *** Alice ***\n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )),\n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty --- Initial Intruder Knowledge (empty means intruder starts with basic knowledge like its own identity i, and public names like a,b,s)\n     || nil --- constraints on initial state (e.g. neq conditions)\n     || nil --- path conditions\n     || never(\n     *** Authentication: Bob must have sent msg2 to Alice after receiving msg1 from Alice ***\n     :: r1, r2  :: ***Bob ***\n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)), --- Bob receives msg1 from Alice=a, using Alice's nonce n(a,r) and data(a,r')\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)), --- Bob sends msg2 to Alice=a, with his nonce n(b,r1) and data(b,r2)\n       nil ]\n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/homo-nsl.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < ____(Msg)___ .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg ____(Key)____ -> Msg [____(ctor gather (e E))____] .\n\n  --- Nonce operator\n  op n : Name ____(Fresh)____ -> ____(Nonce)____ [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op ____(;)____ : ____(Msg)____  Msg  -> Msg [gather (e ____(E)____) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(X)____ ____(Y)____ : Msg .\n  var Z : Key .\n\n  eq pk(X ; ____(Y)____, ____(Z)____) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : ____(Msg)____ .\n  vars r r' : ____(Fresh)____ .\n  vars ____(A)____ B : Name .\n  vars N NA ____(NB)____ : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(____(X)____,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(____(A)____,____(r)____) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(____(bobNonceSecrecy)____)\n   = :: r :: \n     [ nil, -(pk(a ; ____(NA)____, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < ____(Msg)___ .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg ____(Key)____ -> Msg [____(ctor gather (e E))____] .\n\n  --- Nonce operator\n  op n : Name ____(Fresh)____ -> ____(Nonce)____ [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op ____(;)____ : ____(Msg)____  Msg  -> Msg [gather (e ____(E)____) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(X)____ ____(Y)____ : Msg .\n  var Z : Key .\n\n  eq pk(X ; ____(Y)____, ____(Z)____) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : ____(Msg)____ .\n  vars r r' : ____(Fresh)____ .\n  vars ____(A)____ B : Name .\n  vars N NA ____(NB)____ : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(____(X)____,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(____(A)____,____(r)____) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(____(bobNonceSecrecy)____)\n   = :: r :: \n     [ nil, -(pk(a ; ____(NA)____, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  -- Sort Information \n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  -- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  -- User names\n  ops a b : -> UName .\n\n  -- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n--- successor\n\n op p : Nonce -> Msg [frozen] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars Nnc NA NB : Nonce .\n  vars M1 N M M2 MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(A ; B ; NA),\n             -(MA ; e(SK, NA) ; n(b,r)),\n             +(e(SK, n(b,r))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "Okay, I will complete the Maude-NPA code based on your provided template and the description of the Kao Chow Repeated Authentication Protocol.\n\nHere's the completed Maude file:\n\n```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  -- Sort Information \n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  -- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  -- User names\n  ops a b : -> UName .\n\n  -- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n--- successor\n\n op p : Nonce -> Msg [frozen] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars Nnc NA NB : Nonce .\n  vars M1 N M M2 MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(A ; B ; NA),\n             -(MA ; e(SK, NA) ; n(b,r)),\n             +(e(SK, n(b,r))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Handshake_Key.maude": [[true, "----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort ____(Public)____ ____(Nonce)____ Enc Key < Msg .\n  subsort Masterkey  Sessionkey < ____(Key)____ .\n  subsort SName ____(UName)____ < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> ____(Nonce)____ [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op ____(mkey)____ : Name Name -> Masterkey [____(comm)____] .\n\n  --- Seskey\n  op seskey : ____(UName UName)____ Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt/decrypt\n  op e : ____(Key)____ ____(Msg)____ -> Msg [frozen] .\n  op d : Key ____(Msg)____ -> ____(Msg)____  [frozen] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen ____(gather)____ (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K)____:Key, e(K:Key, ____(Z:Msg)____)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B T : UName .\n  var ____(S)____ : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS ____(NA)____ NB : Nonce .\n  vars X ____(M1)____ M2 ____(M3)____ N ____(M4)____ ____(Y)____ : Msg .\n  var K Ke : Key .\n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &\n     :: nil :: [ nil | -(K), -(M), +(d(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; ____(N)____) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A, B, Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt), E(Kbs:A,B,Na,Kab,Kt) --- S actually sends this to A, A forwards the Kbs part to B.\n  --- B->A : E(Kas:A,B,Na,Kab,Kt), E(Kt:Na,Kab), Nb      --- B gets Kas part from A, encrypts with Kt, sends with Nb\n  --- A->B : E(Kt:Na,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB),\n            +(e(Kt, n(A,r) ; SK)) , nil ]\n &\n    --- Bob's Strand\n    :: r ::\n    [ nil | -(MA ; e(mkey(B,s), A ; ____(B)____ ; NA ; SK ; Kt)) ,\n            +(MA ; e(____(Kt)____, NA ; SK) ; n(B,____(r)____)),\n            -(e(Kt, NA ; SK)) , nil ]\n &\n     :: r,r' ::\n     --- Server's Strand\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(____(A)____,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,____(r')____)))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, ____(NA)____ ; SK) ; n(____(B)____,r)),\n            -(e(Kt, NA ; SK)) | nil ]\n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\n\n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2)\n---[nonexec] .\n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort ____(Public)____ ____(Nonce)____ Enc Key < Msg .\n  subsort Masterkey  Sessionkey < ____(Key)____ .\n  subsort SName ____(UName)____ < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> ____(Nonce)____ [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op ____(mkey)____ : Name Name -> Masterkey [____(comm)____] .\n\n  --- Seskey\n  op seskey : ____(UName UName)____ Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt/decrypt\n  op e : ____(Key)____ ____(Msg)____ -> Msg [frozen] .\n  op d : Key ____(Msg)____ -> ____(Msg)____  [frozen] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen ____(gather)____ (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K)____:Key, e(K:Key, ____(Z:Msg)____)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B T : UName .\n  var ____(S)____ : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS ____(NA)____ NB : Nonce .\n  vars X ____(M1)____ M2 ____(M3)____ N ____(M4)____ ____(Y)____ : Msg .\n  var K Ke : Key .\n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &\n     :: nil :: [ nil | -(K), -(M), +(d(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; ____(N)____) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A, B, Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt), E(Kbs:A,B,Na,Kab,Kt) --- S actually sends this to A, A forwards the Kbs part to B.\n  --- B->A : E(Kas:A,B,Na,Kab,Kt), E(Kt:Na,Kab), Nb      --- B gets Kas part from A, encrypts with Kt, sends with Nb\n  --- A->B : E(Kt:Na,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB),\n            +(e(Kt, n(A,r) ; SK)) , nil ]\n &\n    --- Bob's Strand\n    :: r ::\n    [ nil | -(MA ; e(mkey(B,s), A ; ____(B)____ ; NA ; SK ; Kt)) ,\n            +(MA ; e(____(Kt)____, NA ; SK) ; n(B,____(r)____)),\n            -(e(Kt, NA ; SK)) , nil ]\n &\n     :: r,r' ::\n     --- Server's Strand\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(____(A)____,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,____(r')____)))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, ____(NA)____ ; SK) ; n(____(B)____,r)),\n            -(e(Kt, NA ; SK)) | nil ]\n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\n\n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2)\n---[nonexec] .\n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Ticket.maude": [[true, "----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort Name Nonce ____(Enc)____ Key < ____(Msg)____ .\n  subsort ____(Masterkey)____  Sessionkey < Key .\n  subsort ____(SName)____ UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> ____(Nonce)____ [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : ____(Name)____ Name -> Masterkey [____(ctor)____] .\n\n  --- Seskey\n  op seskey : ____(Name)____ Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt\n  op e : Key ____(Msg)____ -> Msg [____(ctor)____] .\n  op d : Key ____(Msg)____ -> Msg [____(ctor)____] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ Msg -> Msg [____(assoc)____ ____(ctor)____ (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq d(____(K)____:Key, e(____(K)____:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(____(K)____, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B T : UName .\n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh .\n  vars TS ____(NA)____ NB : Nonce .\n  vars X ____(Y)____ ____(Z)____ ____(P)____ N MA MB ____(M1)____ ____(M2)____  : Msg .\n  var K Ke : Key .\n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &\n     :: nil :: [ nil | -(K), -(M), +(d(K,____(M)____)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(____(M)____ ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(____(i)____,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  &\n     :: r   :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt),E(Kbs:A,B,Na,Kab,Kt)\n  --- B->A : E(Kas:A,B,Na,Kab,Kt),E(Kt:Na,Kab),Nb,E(Kbs:A,B,Ta,Kab)\n  --- A->B : E(Kt:Na,Kab),E(Kbs:A,B,Ta,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB ; MB),\n            +(e(Kt, n(A,r) ; SK) ; MB), nil ]\n &\n    --- Bob's Strand\n    :: r,r' ::\n    [ nil | -(MA ; e(mkey(____(B)____,____(s)____), ____(A)____ ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, ____(NA)____ ; SK) ; e(mkey(____(B)____,____(s)____), A ; B ; t(B,r') ; SK)) , nil ]\n &\n     :: r,r' ::\n     --- Server's Strand\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n\neq ATTACK-STATE(____(secr(SK))____) =\n    :: r,r' ::\n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, ____(NA)____ ; ____(SK)____) ; e(mkey(B,s), ____(A)____ ; B ; t(B,r') ; SK)) | nil ]\n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Enc .\n  subsort Name Nonce ____(Enc)____ Key < ____(Msg)____ .\n  subsort ____(Masterkey)____  Sessionkey < Key .\n  subsort ____(SName)____ UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> ____(Nonce)____ [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : ____(Name)____ Name -> Masterkey [____(ctor)____] .\n\n  --- Seskey\n  op seskey : ____(Name)____ Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt\n  op e : Key ____(Msg)____ -> Msg [____(ctor)____] .\n  op d : Key ____(Msg)____ -> Msg [____(ctor)____] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ Msg -> Msg [____(assoc)____ ____(ctor)____ (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq d(____(K)____:Key, e(____(K)____:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(____(K)____, d(K:Key, Z:Msg)) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B T : UName .\n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh .\n  vars TS ____(NA)____ NB : Nonce .\n  vars X ____(Y)____ ____(Z)____ ____(P)____ N MA MB ____(M1)____ ____(M2)____  : Msg .\n  var K Ke : Key .\n  var SK TA Kt : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &\n     :: nil :: [ nil | -(K), -(M), +(d(K,____(M)____)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(____(M)____ ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(____(i)____,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  &\n     :: r   :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A,B,Na,Kab,Kt),E(Kbs:A,B,Na,Kab,Kt)\n  --- B->A : E(Kas:A,B,Na,Kab,Kt),E(Kt:Na,Kab),Nb,E(Kbs:A,B,Ta,Kab)\n  --- A->B : E(Kt:Na,Kab),E(Kbs:A,B,Ta,Kab)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK ; Kt) ; e(Kt, n(A,r) ; SK) ; NB ; MB),\n            +(e(Kt, n(A,r) ; SK) ; MB), nil ]\n &\n    --- Bob's Strand\n    :: r,r' ::\n    [ nil | -(MA ; e(mkey(____(B)____,____(s)____), ____(A)____ ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, ____(NA)____ ; SK) ; e(mkey(____(B)____,____(s)____), A ; B ; t(B,r') ; SK)) , nil ]\n &\n     :: r,r' ::\n     --- Server's Strand\n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))\n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)) ; seskey(A,B,n(s,r')))), nil ]\n\n  [nonexec] .\n\neq ATTACK-STATE(____(secr(SK))____) =\n    :: r,r' ::\n    [ nil,  -(MA ; e(mkey(B,s), A ; B ; NA ; SK ; Kt)) ,\n            +(MA ; e(Kt, NA ; SK) ; n(B,r) ; e(mkey(B,s), A ; B ; t(B,r') ; SK)),\n            -(e(Kt, ____(NA)____ ; ____(SK)____) ; e(mkey(B,s), ____(A)____ ; B ; t(B,r') ; SK)) | nil ]\n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/mpOTR_connect.maude": [[true, "***(\n\tThese are the first steps towards mpOTR protocol verification and security\n\tanalysis.\n\tThis module describes the Communication Setup phase of the main course of\n\tthe protocol that is as follows:\n\n\t\tClient-1 --> Client-2 : Client-1 ; Fx-Mess\n\t\tClient-1 --> Client-3 : Client-1 ; Fx-Mess\n\t\tClient-2 --> Client-1 : Client-2 ; Fx-Mess\n\t\tClient-2 --> Client-3 : Client-2 ; Fx-Mess\n\t\tClient-3 --> Client-1 : Client-3 ; Fx-Mess\n\t\tClient-3 --> Client-2 : Client-3 ; Fx-Mess\n\t\n\twhere Clients represent people (or, more spesificly, their chat clients)\n\twishing to interact with each other, Mess is some pre-defined message equal\n\tfor all clients. Number of clients represents multi-party property of mpOTR.\n\t\n\tNo algebraic properties reqiered.\n)***\n\n--- protocol syntax - types and operations\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n\t--- Importing sorts Msg, Fresh, Public\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\n\t--- Sort Information\n\tsorts Name FixedMessage Key .\n\tsubsort Name FixedMessage Key < Msg .\n\tsubsort Name < Public . --- means that Name info is publicly availible\n\tsubsort FixedMessage < Public .\n\n\t--- Principals -- name constants\n\tops client-1 client-2 client-3 intruder : -> Name .\n\top x1 : -> Key .\n\n\t--- [Get] Fixed Message\n\top fxMess : -> FixedMessage .\n\n\t--- Concatenation\n\top _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- operator prop-es-see man\n\nendfm\n\n--- Algebraic properties of the protocol\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\nendfm\n\n--- Protocol strands (what's that?)\nfmod PROTOCOL-SPECIFICATION is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\tprotecting DEFINITION-CONSTRAINTS-INPUT .\n\n\tvars M1, M2 : Msg .\n\tvar fM : FixedMessage .\n\tvar N Name1 Name2 : Name .\n\t\n\t--- Actions an intruder can perform\n\teq STRANDS-DOLEVYAO =\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n\t\t:: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n\t\t:: nil :: [ nil | +(fM), nil ] &\n\t\t:: nil :: [ nil | +(N), nil ] &\n\t\t:: nil :: [ nil | +(x1), nil ] \n\t[nonexec] .\n\n\teq STRANDS-PROTOCOL =\n\t\t:: nil :: --- vars of sort Fresh are explicit\n\t\t[nil | +(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   +(client-3 ; fxMess), nil]\n\t[nonexec] .\n\n\t--- eq EXTRA-GRAMMARS --- increase performance = cut the search tree.\n\t--- [nonexec] .\n\n\teq ATTACK-STATE(0) = \n\t  \tempty\n\t\t|| empty\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil \n\t[nonexec] .\n\n\teq ATTACK-STATE(1) = \n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(2) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name2 != client-3 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| x1 inI\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\n\t***(eq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1, \n\t\t   Name2 != client-3\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .)***\n\nendfm\n\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\n\tThese are the first steps towards mpOTR protocol verification and security\n\tanalysis.\n\tThis module describes the Communication Setup phase of the main course of\n\tthe protocol that is as follows:\n\n\t\tClient-1 --> Client-2 : Client-1 ; Fx-Mess\n\t\tClient-1 --> Client-3 : Client-1 ; Fx-Mess\n\t\tClient-2 --> Client-1 : Client-2 ; Fx-Mess\n\t\tClient-2 --> Client-3 : Client-2 ; Fx-Mess\n\t\tClient-3 --> Client-1 : Client-3 ; Fx-Mess\n\t\tClient-3 --> Client-2 : Client-3 ; Fx-Mess\n\t\n\twhere Clients represent people (or, more spesificly, their chat clients)\n\twishing to interact with each other, Mess is some pre-defined message equal\n\tfor all clients. Number of clients represents multi-party property of mpOTR.\n\t\n\tNo algebraic properties reqiered.\n)***\n\n--- protocol syntax - types and operations\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n\t--- Importing sorts Msg, Fresh, Public\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\n\t--- Sort Information\n\tsorts Name FixedMessage Key .\n\tsubsort Name FixedMessage Key < Msg .\n\tsubsort Name < Public . --- means that Name info is publicly availible\n\tsubsort FixedMessage < Public .\n\n\t--- Principals -- name constants\n\tops client-1 client-2 client-3 intruder : -> Name .\n\top x1 : -> Key .\n\n\t--- [Get] Fixed Message\n\top fxMess : -> FixedMessage .\n\n\t--- Concatenation\n\top _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- operator prop-es-see man\n\nendfm\n\n--- Algebraic properties of the protocol\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\nendfm\n\n--- Protocol strands (what's that?)\nfmod PROTOCOL-SPECIFICATION is\n\tprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\tprotecting DEFINITION-PROTOCOL-RULES .\n\tprotecting DEFINITION-CONSTRAINTS-INPUT .\n\n\tvars M1, M2 : Msg .\n\tvar fM : FixedMessage .\n\tvar N Name1 Name2 : Name .\n\t\n\t--- Actions an intruder can perform\n\teq STRANDS-DOLEVYAO =\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n\t\t:: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n\t\t:: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n\t\t:: nil :: [ nil | +(fM), nil ] &\n\t\t:: nil :: [ nil | +(N), nil ] &\n\t\t:: nil :: [ nil | +(x1), nil ] \n\t[nonexec] .\n\n\teq STRANDS-PROTOCOL =\n\t\t:: nil :: --- vars of sort Fresh are explicit\n\t\t[nil | +(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(client-3 ; fxMess), nil]\n\t\t&\n\t\t:: nil ::\n\t\t[nil | -(client-1 ; fxMess),\n\t\t\t   -(client-2 ; fxMess),\n\t\t\t   +(client-3 ; fxMess), nil]\n\t[nonexec] .\n\n\t--- eq EXTRA-GRAMMARS --- increase performance = cut the search tree.\n\t--- [nonexec] .\n\n\teq ATTACK-STATE(0) = \n\t  \tempty\n\t\t|| empty\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil \n\t[nonexec] .\n\n\teq ATTACK-STATE(1) = \n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(2) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name2 != client-3 \n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\t\n\teq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| x1 inI\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .\n\n\t***(eq ATTACK-STATE(3) =\n\t\t:: nil ::\n\t\t[nil,  -(Name1 ; fxMess),\n\t\t\t   +(client-2 ; fxMess),\n\t\t\t   -(Name2 ; fxMess) | nil]\n\t\t|| Name1 != client-1, \n\t\t   Name2 != client-3\n\t\t|| nil\n\t\t|| nil\n\t\t|| nil\n\t[nonexec] .)***\n\nendfm\n\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/mpOTR_dh.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name Nonce NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [ctor] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc ctor] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc ctor (gather E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; B ; XE), \n            +(e(exp(XE,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(XE,n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [nil | +(a ; b ; XE), \n            -(a ; b ; exp(g,n(b,r))), \n            +(e(YE,sec(a,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name Nonce NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [ctor] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc ctor] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc ctor (gather E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r,r' :: \n     [nil | +(A ; B ; exp(g,n(A,r))), \n            -(A ; B ; XE), \n            +(e(exp(XE,n(A,r)),sec(A,r'))), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE), \n            +(A ; B ; exp(g,n(B,r))), \n            -(e(exp(XE,n(B,r)),Sr)), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [nil | +(a ; b ; XE), \n            -(a ; b ; exp(g,n(b,r))), \n            +(e(YE,sec(a,r'))), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N1:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public\nkey x, and sk(x,y) means message y encripted using private key x.\nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts Name Nonce Key .\n  subsort Name Nonce Key < ____(Msg)____ .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : ____(Key)____ Msg -> Msg [____(ctor)____] .\n  op sk : Key ____(Msg)____ -> Msg [____(ctor)____] .\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> Nonce [____(ctor)____] .\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n --- Associativity operator\n  op ____(_;_)____ : ____(Msg)____  Msg  -> Msg [____(ctor assoc)____ (e E) frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n\n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Ke : Key .\n  vars ____(X)____ ____(Y)____ Z : ____(Msg)____ .\n  vars r r' : ____(Fresh)____ .\n  vars A B : ____(Name)____ .\n  vars N N1 N2 : ____(Nonce)____ .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(____(Y)____), +(____(X)____ ; Y), nil ] & --- Composition\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] & --- Decomp1\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] & --- Decomp2\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & --- Encrypt with intruder's private key\n     :: nil :: [ nil | -(X), +(pk(____(Ke)____,X)), nil ] & --- Encrypt with known public key\n     :: nil :: [ nil | +(A), nil ] --- Send known public name/key\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r ::\n     [ nil | +(pk(B,____(A)____ ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] & --- Alice's strand\n     :: r ::\n     [ nil | -(pk(B,A ; N)), +(pk(____(A)____, N ; n(B,r))), -(pk(____(B)____,n(B,r))), nil ] --- Bob's strand\n  [nonexec] .\n\n  eq ATTACK-STATE(0) --- Secrecy of Bob's nonce n(b,r) when Alice (a) initiates with Bob (b)\n   = :: r ::\n     [ nil, -(pk(b,a ; ____(N)____)), +(pk(a, N ; n(b,r))), -(pk(____(b)____,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1) --- Authentication of Alice to Bob. Bob (b) believes he's talking to Alice (a).\n   = :: r ::\n     [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,____(r)____))), -(pk(____(b)____,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never --- agreement: Alice's strand matching Bob's view\n     (:: r' ::\n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ]\n     & S:StrandSet\n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public\nkey x, and sk(x,y) means message y encripted using private key x.\nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts Name Nonce Key .\n  subsort Name Nonce Key < ____(Msg)____ .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : ____(Key)____ Msg -> Msg [____(ctor)____] .\n  op sk : Key ____(Msg)____ -> Msg [____(ctor)____] .\n\n  --- Nonce operator\n  op ____(n)____ : Name Fresh -> Nonce [____(ctor)____] .\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n --- Associativity operator\n  op ____(_;_)____ : ____(Msg)____  Msg  -> Msg [____(ctor assoc)____ (e E) frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n\n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Ke : Key .\n  vars ____(X)____ ____(Y)____ Z : ____(Msg)____ .\n  vars r r' : ____(Fresh)____ .\n  vars A B : ____(Name)____ .\n  vars N N1 N2 : ____(Nonce)____ .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(____(Y)____), +(____(X)____ ; Y), nil ] & --- Composition\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] & --- Decomp1\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] & --- Decomp2\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & --- Encrypt with intruder's private key\n     :: nil :: [ nil | -(X), +(pk(____(Ke)____,X)), nil ] & --- Encrypt with known public key\n     :: nil :: [ nil | +(A), nil ] --- Send known public name/key\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r ::\n     [ nil | +(pk(B,____(A)____ ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] & --- Alice's strand\n     :: r ::\n     [ nil | -(pk(B,A ; N)), +(pk(____(A)____, N ; n(B,r))), -(pk(____(B)____,n(B,r))), nil ] --- Bob's strand\n  [nonexec] .\n\n  eq ATTACK-STATE(0) --- Secrecy of Bob's nonce n(b,r) when Alice (a) initiates with Bob (b)\n   = :: r ::\n     [ nil, -(pk(b,a ; ____(N)____)), +(pk(a, N ; n(b,r))), -(pk(____(b)____,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1) --- Authentication of Alice to Bob. Bob (b) believes he's talking to Alice (a).\n   = :: r ::\n     [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,____(r)____))), -(pk(____(b)____,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never --- agreement: Alice's strand matching Bob's view\n     (:: r' ::\n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ]\n     & S:StrandSet\n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_ECB.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort ____(Name)____ Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op ____(pk)____ : ____(Msg Key)____ -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> ____(Nonce)____ [____(ctor fresh)____] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op ____(_;_)____ : ____(Msg)____  ____(Msg)____  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq pk(____(X:Msg)____ ; ____(Y)____:Msg, K:Key) = pk(____(X)____:Msg, ____(K:Key)____) ; pk(Y:Msg, K:Key) \n  [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars ____(X)____ Y Z : Msg .\n  vars ____(r)____ r' : Fresh .\n  vars A B : ____(Name)____ .\n  vars N NA ____(NB)____ : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n     :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(____(A)____,____(r)____) ; NB ; B, A)), +(pk(____(NB)____, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; ____(NA)____, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(____(B)____,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(____(b)____,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort ____(Name)____ Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op ____(pk)____ : ____(Msg Key)____ -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> ____(Nonce)____ [____(ctor fresh)____] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op ____(_;_)____ : ____(Msg)____  ____(Msg)____  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  eq pk(____(X:Msg)____ ; ____(Y)____:Msg, K:Key) = pk(____(X)____:Msg, ____(K:Key)____) ; pk(Y:Msg, K:Key) \n  [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars ____(X)____ Y Z : Msg .\n  vars ____(r)____ r' : Fresh .\n  vars A B : ____(Name)____ .\n  vars N NA ____(NB)____ : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n     :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(____(A)____,____(r)____) ; NB ; B, A)), +(pk(____(NB)____, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; ____(NA)____, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(____(B)____,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(____(b)____,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_Modified.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc (e null) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc (e null) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/ascentFunctionsJanuary2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule('BAD, false) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts('BAD, false) .\nred in META-LEVEL : upSubsortDecls('BAD, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .", "```maude\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule('BAD, false) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts('BAD, false) .\nred in META-LEVEL : upSubsortDecls('BAD, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_XOR.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _ ; _ : Msg Msg -> Msg [gather (e nil) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _ ; _ : Msg Msg -> Msg [gather (e nil) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [variant] .\n  eq XN * XN * YN = YN [variant] .\n  eq XN * null = XN    [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/nspk.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  op pk : Key Msg -> Msg [ctor] .\n  op sk : Key Msg -> Msg [ctor] .\n\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  op _;_ : Msg Msg  -> Msg [gather (e nil) ctor assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n\n  var Z : Msg .\n  var Ke : Key .\n  \n  eq pk(Ke,sk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n  eq sk(Ke,pk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(n(i,r)), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r))), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n    = :: r :: \n    [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never *** for authentication\n     (:: r' :: \n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ] \n     & S:StrandSet  \n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  op pk : Key Msg -> Msg [ctor] .\n  op sk : Key Msg -> Msg [ctor] .\n\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  op _;_ : Msg Msg  -> Msg [gather (e nil) ctor assoc] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n\n  var Z : Msg .\n  var Ke : Key .\n  \n  eq pk(Ke,sk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n  eq sk(Ke,pk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(n(i,r)), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r))), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n    = :: r :: \n    [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never *** for authentication\n     (:: r' :: \n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ] \n     & S:StrandSet  \n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/secret06.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows,\nwhere S is the server:\n\nS --> A: N_S\nA --> B: sk(A,N_S ; S)\nA --> B: sk(A,B ; N_A ; S)\n\nwhere N_A, N_S, and N_B are nonces, and sk(x,y) means message y encripted \nusing private key x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  X ; (Y ; Z) = (X ; Y) ; Z\n  pk(K,sk(K,M)) = M\n  sk(K,pk(K,M)) = M\n\nHowever, note that the associativity property is bounded to depth 3 below by\nusing appopriate sorts.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES . --- Importing sort Msg, Fresh, Public\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  sorts List Elm .\n  subsort Name < Key .\n  subsort Name Nonce Key < Elm .\n  subsort Elm < Msg .\n  subsort List < Msg .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Keys known by intruder\n  op s : -> Name . --- Name for the Server\n  op a : -> Name . --- Name for the Initiator\n  op b : -> Name . --- Name for the Responder\n  op i : -> Name . --- Name for the Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  --- Associativity operator\n  op _;_ : Msg Msg -> List [frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  vars Xe Ye Ze : Elm .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n  \n  *** Bounded Associativity (for 3-depth)\n  eq Xe ; (Ye ; Ze) = (Xe ; Ye) ; Ze [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  var r : Fresh .\n  var N : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ]\n     &\n     --- Private encryption only his key\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] \n     &\n      --- Public encryption any key\n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = --- server \n     :: r :: [nil | +(n(s,r)), nil ] &\n     --- initiator\n     :: r :: [nil | -(N), +(sk(a,N ; s)), +(sk(a,b ; (n(a,r) ; s))), nil] &\n     --- responder\n     :: nil :: [nil | -(sk(a,X ; s)), -(sk(a,(b ; Z) ; s)), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: nil :: [nil, -(sk(a,X ; s)), -(sk(a,(b ; N) ; s)) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows,\nwhere S is the server:\n\nS --> A: N_S\nA --> B: sk(A,N_S ; S)\nA --> B: sk(A,B ; N_A ; S)\n\nwhere N_A, N_S, and N_B are nonces, and sk(x,y) means message y encripted \nusing private key x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  X ; (Y ; Z) = (X ; Y) ; Z\n  pk(K,sk(K,M)) = M\n  sk(K,pk(K,M)) = M\n\nHowever, note that the associativity property is bounded to depth 3 below by\nusing appopriate sorts.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES . --- Importing sort Msg, Fresh, Public\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  sorts List Elm .\n  subsort Name < Key .\n  subsort Name Nonce Key < Elm .\n  subsort Elm < Msg .\n  subsort List < Msg .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Keys known by intruder\n  op s : -> Name . --- Name for the Server\n  op a : -> Name . --- Name for the Initiator\n  op b : -> Name . --- Name for the Responder\n  op i : -> Name . --- Name for the Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [ctor] .\n  \n  --- Associativity operator\n  op _;_ : Msg Msg -> List [frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  vars Xe Ye Ze : Elm .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n  \n  *** Bounded Associativity (for 3-depth)\n  eq Xe ; (Ye ; Ze) = (Xe ; Ye) ; Ze [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  var r : Fresh .\n  var N : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ]\n     &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ]\n     &\n     --- Private encryption only his key\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] \n     &\n      --- Public encryption any key\n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = --- server \n     :: r :: [nil | +(n(s,r)), nil ] &\n     --- initiator\n     :: r :: [nil | -(N), +(sk(a,N ; s)), +(sk(a,b ; (n(a,r) ; s))), nil] &\n     --- responder\n     :: nil :: [nil | -(sk(a,X ; s)), -(sk(a,(b ; Z) ; s)), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: nil :: [nil, -(sk(a,X ; s)), -(sk(a,(b ; N) ; s)) | nil]\n     || empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/secret07.maude": [[true, "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A\nA --> B: B\nA --> B: exp(g,N_A)\nB --> A: B\nB --> A: A\nB --> A: exp(g,N_B)\n\nwhere N_A and N_B are nonces, and exp(x,y) means raising message y to \nexponent x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n\nHowever, note that this property is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp GenvExp .\n  subsort Gen Exp < GenvExp .\n  subsort Public NeNonceSet GenvExp < Msg .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS : NeNonceSet .\n  var G : GenvExp .\n  var A : Name .\n  var r : Fresh .\n  vars XE YE : Exp .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(G), -(NS), +(exp(G,NS)), nil ] &\n     :: r :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: [nil | +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(XE), nil] &\n     :: r :: [nil | -(a), -(b), -(YE), +(b), +(a), +(exp(g,n(b,r))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(sharedKeySecrecy)\n   = :: r :: \n     [nil, +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(exp(g,NS)) | nil]\n     || exp(g, NS * n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A\nA --> B: B\nA --> B: exp(g,N_A)\nB --> A: B\nB --> A: A\nB --> A: exp(g,N_B)\n\nwhere N_A and N_B are nonces, and exp(x,y) means raising message y to \nexponent x. Moreover, concatenation and encription/decription\nhave the following property:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n\nHowever, note that this property is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp GenvExp .\n  subsort Gen Exp < GenvExp .\n  subsort Public NeNonceSet GenvExp < Msg .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS : NeNonceSet .\n  var G : GenvExp .\n  var A : Name .\n  var r : Fresh .\n  vars XE YE : Exp .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(G), -(NS), +(exp(G,NS)), nil ] &\n     :: r :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: [nil | +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(XE), nil] &\n     :: r :: [nil | -(a), -(b), -(YE), +(b), +(a), +(exp(g,n(b,r))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(sharedKeySecrecy)\n   = :: r :: \n     [nil, +(a), +(b), +(exp(g,n(a,r))), -(b), -(a), -(exp(g,NS)) | nil]\n     || exp(g, NS * n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Wide_Mouthed_Frog.maude": [[true, "----Wide Mouthed Frog Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n  : Name Fresh -> Nonce [ctor] .\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n--- MKey\n  op mkey : Name Name -> Masterkey [ctor] .\n\n--- Seskey\n op seskey : Name Name Nonce -> Sessionkey [ctor] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [dtor] .\n\n--- successor\n\n op p : Msg -> Msg [ctor] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [ctor gather (e m)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S T : UName .\n  var r r' r'' r''' r# r## rM : Fresh .\n  vars N Nprime NMA NB NMB : Nonce .\n  vars M1 M2 M X Y Z MB : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,s)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; e(mkey(A,s) , B ; seskey(A,B,n(A,r)))) ,\n             +(A ; e(seskey(A,B,n(A,r)), NMA)), nil ]\n   &\n     :: nil ::\n   --- Bob's Strand.\n     [ nil | -(e(mkey(B,s), A ; SK)),\n             -(A ; e(SK,NMA)), nil ]\n   &\n     :: nil ::\n     --- Server's Strand\n    [ nil | -(A ; e(mkey(A,s) , B ; SK)),\n            +(e(mkey(B,s) , A  ; SK)) , nil]\n\n  [nonexec] .\n\n\neq ATTACK-STATE(0) =\n--- A normal execution of the protocol\n:: r ::\n     [ nil, +(a ; e(mkey(a,s) , b ; seskey(a,b,n(a,r)))) ,\n            +(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n   &\n:: nil ::\n    [ nil,  -(e(mkey(b,s), a ; seskey(a,b,n(a,r)))),\n            -(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n--- An execution where the intruder finds out a message that share between the participants\n:: r ::\n     [ nil, +(a ; e(mkey(a,s) , b ; seskey(a,b,n(a,r)))) ,\n            +(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n   &\n:: nil ::\n    [ nil,  -(e(mkey(b,s), a ; seskey(a,b,n(a,r)))),\n            -(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n     || NMA inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "Okay, I will complete the Maude-NPA code based on your provided template and the Wide Mouthed Frog protocol description.\n\n```maude\n----Wide Mouthed Frog Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n  : Name Fresh -> Nonce [ctor] .\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n--- MKey\n  op mkey : Name Name -> Masterkey [ctor] .\n\n--- Seskey\n op seskey : Name Name Nonce -> Sessionkey [ctor] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [dtor] .\n\n--- successor\n\n op p : Msg -> Msg [ctor] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [ctor gather (e m)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S T : UName .\n  var r r' r'' r''' r# r## rM : Fresh .\n  vars N Nprime NMA NB NMB : Nonce .\n  vars M1 M2 M X Y Z MB : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,s)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; e(mkey(A,s) , B ; seskey(A,B,n(A,r)))) ,\n             +(A ; e(seskey(A,B,n(A,r)), NMA)), nil ]\n   &\n     :: nil ::\n   --- Bob's Strand.\n     [ nil | -(e(mkey(B,s), A ; SK)),\n             -(A ; e(SK,NMA)), nil ]\n   &\n     :: nil ::\n     --- Server's Strand\n    [ nil | -(A ; e(mkey(A,s) , B ; SK)),\n            +(e(mkey(B,s) , A  ; SK)) , nil]\n\n  [nonexec] .\n\n\neq ATTACK-STATE(0) =\n--- A normal execution of the protocol\n:: r ::\n     [ nil, +(a ; e(mkey(a,s) , b ; seskey(a,b,n(a,r)))) ,\n            +(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n   &\n:: nil ::\n    [ nil,  -(e(mkey(b,s), a ; seskey(a,b,n(a,r)))),\n            -(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n--- An execution where the intruder finds out a message that share between the participants\n:: r ::\n     [ nil, +(a ; e(mkey(a,s) , b ; seskey(a,b,n(a,r)))) ,\n            +(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n   &\n:: nil ::\n    [ nil,  -(e(mkey(b,s), a ; seskey(a,b,n(a,r)))),\n            -(a ; e(seskey(a,b,n(a,r)), NMA)) | nil ]\n     || NMA inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Woo-Lam_Authentication.maude": [[true, "---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name ____(Nonce)____  Key Text < ____(Msg)____ .\n  subsort ____(Masterkey)____  Sessionkey < Key .\n  subsort ____(SName)____ UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n     --- text\n  op ____(txt)____ : Name Name Nonce  -> Text [____(ctor)____] .\n  --- Nonce operator\n  op ____(n)____ : ____(Name)____ Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : ____(Name)____ Name -> ____(Masterkey)____ [frozen] .\n\n  --- Seskey\n  op seskey : ____(Name)____ Name Nonce -> Sessionkey [____(ctor)____] .\n\n  ---encrypt\n  op ____(e)____  : Key Msg -> Msg [____(ctor)____] .\n  op d : Key ____(Msg)____ -> ____(Msg)____  [frozen] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen gather (____(assoc)____ E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K:Key)____, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(____(K:Key)____, d (K:Key, Z:Msg )) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(A)____ B S Z G : UName .\n  vars ____(r)____ r' r'' r''' ____(r#)____ r## ____(rS)____ rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars ____(M)____ ____(N)____ MA MB MS ____(MN)____ ____(MA1)____ ____(MS1)____ MB1 ____(MN1)____ : Msg .\n  var K Kz Kb : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(____(M:Msg)____), +(d(K,____(M:Msg)____)), nil ] &\n     :: nil :: [ nil | -(____(M:Msg)____), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(____(M:Msg)____), -(M), +(____(M:Msg)____ ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(____(A)____,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand.\n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)),\n             nil ]\n   &\n     :: r  ::\n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(MA),\n             +(e(mkey(B,s), A ; MA)),\n             -(e(mkey(B,s), n(B,r))),\n             nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil |  -(e(mkey(____(B)____,s), ____(A)____ ; e(mkey(A,s) , NB))),\n             +(e(mkey(B,s), NB)),\n             nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(MA),\n            +(e(mkey(b,s) , a ; MA)),\n            -(e(mkey(b,____(s)____) , n(b,r))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name ____(Nonce)____  Key Text < ____(Msg)____ .\n  subsort ____(Masterkey)____  Sessionkey < Key .\n  subsort ____(SName)____ UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n     --- text\n  op ____(txt)____ : Name Name Nonce  -> Text [____(ctor)____] .\n  --- Nonce operator\n  op ____(n)____ : ____(Name)____ Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : ____(Name)____ Name -> ____(Masterkey)____ [frozen] .\n\n  --- Seskey\n  op seskey : ____(Name)____ Name Nonce -> Sessionkey [____(ctor)____] .\n\n  ---encrypt\n  op ____(e)____  : Key Msg -> Msg [____(ctor)____] .\n  op d : Key ____(Msg)____ -> ____(Msg)____  [frozen] .\n\n  --- Concatenation\n  op _;_ : ____(Msg)____ ____(Msg)____ -> Msg [frozen gather (____(assoc)____ E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K:Key)____, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(____(K:Key)____, d (K:Key, Z:Msg )) = Z:Msg [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var ____(A)____ B S Z G : UName .\n  vars ____(r)____ r' r'' r''' ____(r#)____ r## ____(rS)____ rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars ____(M)____ ____(N)____ MA MB MS ____(MN)____ ____(MA1)____ ____(MS1)____ MB1 ____(MN1)____ : Msg .\n  var K Kz Kb : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(____(M:Msg)____), +(d(K,____(M:Msg)____)), nil ] &\n     :: nil :: [ nil | -(____(M:Msg)____), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(____(M:Msg)____), -(M), +(____(M:Msg)____ ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(____(A)____,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand.\n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)),\n             nil ]\n   &\n     :: r  ::\n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(MA),\n             +(e(mkey(B,s), A ; MA)),\n             -(e(mkey(B,s), n(B,r))),\n             nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil |  -(e(mkey(____(B)____,s), ____(A)____ ; e(mkey(A,s) , NB))),\n             +(e(mkey(B,s), NB)),\n             nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(MA),\n            +(e(mkey(b,s) , a ; MA)),\n            -(e(mkey(b,____(s)____) , n(b,r))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/xor-nsl.maude": [[true, "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public\nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc gather (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null frozen] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n\n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] &\n     :: r   :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Alice (Principal A, Peer B, N_A = n(A,r)) ***\n    [nil | +(pk(B, n(A,r) ; A)),\n           -(pk(A, n(A,r) ; B * YN)),\n           +(pk(B, YN)), nil]\n    &\n    :: r' :: *** Bob (Principal B, Peer A, N_B = n(B,r')) ***\n    [nil | -(pk(B, XN ; A)),\n           +(pk(A, XN ; B * n(B,r'))),\n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Bob's strand (principal b, peer a, Bob's nonce n(b,r')) ***\n     [nil, -(pk(b, XN ; a)),\n           +(pk(a, XN ; b * n(b,r'))),\n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .", "```maude\n***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public\nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [assoc gather (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm id: null frozen] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n\n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] &\n     :: r   :: [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Alice (Principal A, Peer B, N_A = n(A,r)) ***\n    [nil | +(pk(B, n(A,r) ; A)),\n           -(pk(A, n(A,r) ; B * YN)),\n           +(pk(B, YN)), nil]\n    &\n    :: r' :: *** Bob (Principal B, Peer A, N_B = n(B,r')) ***\n    [nil | -(pk(B, XN ; A)),\n           +(pk(A, XN ; B * n(B,r'))),\n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Bob's strand (principal b, peer a, Bob's nonce n(b,r')) ***\n     [nil, -(pk(b, XN ; a)),\n           +(pk(a, XN ; b * n(b,r'))),\n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .\n```"]], "MAUDE-1/Yahalom.maude": [[true, "---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [ctor] .\n  op d : Key Msg -> Msg  [ctor] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc id: null gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M3 N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M:Msg), +(d(K:Key,M:Msg)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M:Msg)), nil ] &\n     :: nil :: [ nil | -(p(M:Msg)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , NB)) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(a ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [ctor] .\n  op d : Key Msg -> Msg  [ctor] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [assoc id: null gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M3 N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M:Msg), +(d(K:Key,M:Msg)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M:Msg)), nil ] &\n     :: nil :: [ nil | -(p(M:Msg)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , NB)) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(a ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/ISO_5_Pass_Authentication.maude": [[true, "----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op succ : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  vars r r' r'' r''' r# r## RF RF1 : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB M MRes MEnc : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , n(B,r) ; n(A,r))),  --- NB is n(B,r)\n             +(e(SK , n(A,r) ; n(B,r))),\n             nil ]\n   &\n     :: r , r' ::\n   --- Bob's Strand.\n   --- r is Alice's fresh, r' is Bob's fresh for Rb1\n     [ nil | -(A ; NA),                                                 --- NA is n(A,r)\n             +(A ; NA ; B ; n(B,r')),                                   --- Rb1 is n(B,r')\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),                    --- Server's msg, Bob learns SK, MA\n             +(MA ; e(SK , n(B,r) ; NA)),                               --- Bob sends MA and E(SK, Rb ; NA) where Rb = n(B,r)\n             -(e(SK , NA ; n(B,r))),                                    --- Bob receives E(SK, NA ; Rb) from Alice\n             nil ]\n   &\n     :: r  ::\n     --- Server's Strand (local fresh for server is 'r' here, distinct from Alice's or Bob's r)\n    [ nil |  -(A ; NA ; B ; NB), --- NA is Ra, NB is Rb1\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A)\n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ),\n             nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol from Bob's perspective\n--- r is fresh for 'a', r' is fresh for 'b' for nonce to server\n    [ nil ,  -(a ; NA),                                      --- NA is n(a,r)\n     \t\t +(a ; NA ; b ; n(b,r')),                        --- Rb1 is n(b,r')\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),                    --- Rb is n(b,r)\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]\n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' :: --- r is supposed Alice's fresh, r' is Bob's fresh\n    [ nil , -(a ; NA),                                     --- Bob receives n(a,r) as NA from alleged 'a'\n     \t\t +(a ; NA ; b ; n(b,r')),                       --- Bob sends n(b,r') as Rb1\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),       --- Bob gets SK\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),                   --- Bob sends n(b,r) as Rb\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]                 --- Bob expects final msg with n(b,r)\n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication: True Alice 'a' completing with 'b'\n     (:: R:FreshSet :: --- R contains Alice's actual fresh value, let's call it rA\n     [ nil | +(a ; n(a,R.Fresh)), --- Alice sends n(a,rA). This is NA for this strand.\n     \t\t -(e(mkey(a,s) , n(a,R.Fresh) ; SK ; b) ; e(SK , n(b,R.Fresh) ; n(a,R.Fresh))), --- Alice receives from Server and from Bob (Bob's part includes n(b,rA))\n     \t\t +(e(SK , n(a,R.Fresh) ; n(b,R.Fresh))), nil ] --- Alice sends final msg.\n      & S:StrandSet || K:IntruderKnowledge)\n\n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op succ : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen assoc (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  vars r r' r'' r''' r# r## RF RF1 : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB M MRes MEnc : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand.\n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , n(B,r) ; n(A,r))),  --- NB is n(B,r)\n             +(e(SK , n(A,r) ; n(B,r))),\n             nil ]\n   &\n     :: r , r' ::\n   --- Bob's Strand.\n   --- r is Alice's fresh, r' is Bob's fresh for Rb1\n     [ nil | -(A ; NA),                                                 --- NA is n(A,r)\n             +(A ; NA ; B ; n(B,r')),                                   --- Rb1 is n(B,r')\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),                    --- Server's msg, Bob learns SK, MA\n             +(MA ; e(SK , n(B,r) ; NA)),                               --- Bob sends MA and E(SK, Rb ; NA) where Rb = n(B,r)\n             -(e(SK , NA ; n(B,r))),                                    --- Bob receives E(SK, NA ; Rb) from Alice\n             nil ]\n   &\n     :: r  ::\n     --- Server's Strand (local fresh for server is 'r' here, distinct from Alice's or Bob's r)\n    [ nil |  -(A ; NA ; B ; NB), --- NA is Ra, NB is Rb1\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A)\n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ),\n             nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol from Bob's perspective\n--- r is fresh for 'a', r' is fresh for 'b' for nonce to server\n    [ nil ,  -(a ; NA),                                      --- NA is n(a,r)\n     \t\t +(a ; NA ; b ; n(b,r')),                        --- Rb1 is n(b,r')\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),                    --- Rb is n(b,r)\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]\n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' :: --- r is supposed Alice's fresh, r' is Bob's fresh\n    [ nil , -(a ; NA),                                     --- Bob receives n(a,r) as NA from alleged 'a'\n     \t\t +(a ; NA ; b ; n(b,r')),                       --- Bob sends n(b,r') as Rb1\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),       --- Bob gets SK\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),                   --- Bob sends n(b,r) as Rb\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]                 --- Bob expects final msg with n(b,r)\n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication: True Alice 'a' completing with 'b'\n     (:: R:FreshSet :: --- R contains Alice's actual fresh value, let's call it rA\n     [ nil | +(a ; n(a,R.Fresh)), --- Alice sends n(a,rA). This is NA for this strand.\n     \t\t -(e(mkey(a,s) , n(a,R.Fresh) ; SK ; b) ; e(SK , n(b,R.Fresh) ; n(a,R.Fresh))), --- Alice receives from Server and from Bob (Bob's part includes n(b,rA))\n     \t\t +(e(SK , n(a,R.Fresh) ; n(b,R.Fresh))), nil ] --- Alice sends final msg.\n      & S:StrandSet || K:IntruderKnowledge)\n\n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]], "MAUDE-1/Otway-Rees.maude": [[true, "----  Otway-Rees Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name ____(,)____  Key < Msg .\n  subsort Masterkey  Sessionkey < ____(Key)____ .\n  subsort SName UName < ____(Name)____ .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op ____(n)____ : Name ____(Fresh)____ -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op ____(mkey)____ : ____(Name)____ Name -> Masterkey [frozen] .\n\n  --- Seskey\n  op ____(seskey)____ : Name Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt\n  op ____(e)____  : Key ____(Msg)____ -> Msg [frozen] .\n  op ____(d)____ : ____(Key)____ Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op ____(_ ; _)____ : Msg Msg -> Msg [____(assoc id: null)____ gather (e ____(null)____)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K)____:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  var r r' r'' r''' r# r## rM : Fresh .\n  vars TS ____(NA)____ NMA NB ____(N)____ NMS : Nonce .\n  vars M1 M2 ____(M)____ MB1 MB2 MS ____(MA)____ ____(X)____ : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(____(M1)____), -(M), +(____(M1)____ ; ____(M)____) , nil ] &\n     :: nil :: [ nil | -(M ; ____(N)____), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; X), +(X) , nil ] & --- Assuming X was meant here from var declaration, or N if N is Msg\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(____(s)____,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,____(A)____)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  --- A -> B : M,A,B,E(Kas:Na,M,A,B). Encrypted message readable only by the server S\n  --- B -> S : M,A,B,E(Kas:Na,M,A,B),E(Kbs:Nb,M,A,B)\n  --- S\t-> B : M,E(Kas:Na,Kab),E(Kbs:Nb,Kab)\n  --- B\t-> A : M,E(Kas:Na,Kab)\n  --- Alice's Strand.\n   = :: r,rM ::\n     [ nil | +(n(A,rM) ; A ; B ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),\n             -(n(____(A)____,rM) ; e(mkey(A,____(s)____) , n(A,r) ; SK)), nil ]\n   &\n     :: r ::\n   --- Bob's Strand.\n     [ nil | -(NMA ; ____(A)____ ; B ; M1),\n             +(NMA ; A ; B ; M1 ; e(mkey(B,s) , n(B,r) ; NMA ; A ; B)),\n             -(NMA ; MA ; e(mkey(B,s) , n(B,r) ; SK)),\n             +(NMA ; MA), nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil |  -(NMA ; A ; B ; e(mkey(A,s), NA ; NMA ; A ; B)\n                           ; e(mkey(B,s) , NB ; NMA ; A ; B)),\n             +(NMA ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)))\n                   ; e(mkey(____(B)____,____(s)____) , NB ; seskey(A , B , n(S,r)))) , nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(____(0)____) =\n:: r,rM ::\n--- A normal execution of the protocol\n    [ nil ,  +(n(____(a)____,rM) ; a ; ____(b)____ ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,____(s)____) , n(a,____(r)____) ; SK)) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(____(1)____) =\n:: r,rM ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]\n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\neq ATTACK-STATE(2) =\n:: r,rM ::\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so.\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]\n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: r' ::\n     [ nil | -(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),\n             +(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B) ; MB1),\n             -(____(NMA)____ ; e(mkey(A,____(s)____) , n(A,r) ; SK) ; MB2),\n             +(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n\n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm", "```maude\n----  Otway-Rees Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules\n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name ____(,)____  Key < Msg .\n  subsort Masterkey  Sessionkey < ____(Key)____ .\n  subsort SName UName < ____(Name)____ .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op ____(n)____ : Name ____(Fresh)____ -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName .\n\n  --- MKey\n  op ____(mkey)____ : ____(Name)____ Name -> Masterkey [frozen] .\n\n  --- Seskey\n  op ____(seskey)____ : Name Name Nonce -> ____(Sessionkey)____ [frozen] .\n\n  ---encrypt\n  op ____(e)____  : Key ____(Msg)____ -> Msg [frozen] .\n  op ____(d)____ : ____(Key)____ Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op ____(_ ; _)____ : Msg Msg -> Msg [____(assoc id: null)____ gather (e ____(null)____)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties\n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(____(K)____:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] .\n\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands\n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A B S  : UName .\n  var r r' r'' r''' r# r## rM : Fresh .\n  vars TS ____(NA)____ NMA NB ____(N)____ NMS : Nonce .\n  vars M1 M2 ____(M)____ MB1 MB2 MS ____(MA)____ ____(X)____ : Msg .\n  var K : Key .\n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  &\n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(____(K)____,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(____(M1)____), -(M), +(____(M1)____ ; ____(M)____) , nil ] &\n     :: nil :: [ nil | -(M ; ____(N)____), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; X), +(X) , nil ] & --- Assuming X was meant here from var declaration, or N if N is Msg\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(____(s)____,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,____(A)____)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  --- A -> B : M,A,B,E(Kas:Na,M,A,B). Encrypted message readable only by the server S\n  --- B -> S : M,A,B,E(Kas:Na,M,A,B),E(Kbs:Nb,M,A,B)\n  --- S\t-> B : M,E(Kas:Na,Kab),E(Kbs:Nb,Kab)\n  --- B\t-> A : M,E(Kas:Na,Kab)\n  --- Alice's Strand.\n   = :: r,rM ::\n     [ nil | +(n(A,rM) ; A ; B ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),\n             -(n(____(A)____,rM) ; e(mkey(A,____(s)____) , n(A,r) ; SK)), nil ]\n   &\n     :: r ::\n   --- Bob's Strand.\n     [ nil | -(NMA ; ____(A)____ ; B ; M1),\n             +(NMA ; A ; B ; M1 ; e(mkey(B,s) , n(B,r) ; NMA ; A ; B)),\n             -(NMA ; MA ; e(mkey(B,s) , n(B,r) ; SK)),\n             +(NMA ; MA), nil ]\n   &\n     :: r ::\n     --- Server's Strand\n    [ nil |  -(NMA ; A ; B ; e(mkey(A,s), NA ; NMA ; A ; B)\n                           ; e(mkey(B,s) , NB ; NMA ; A ; B)),\n             +(NMA ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)))\n                   ; e(mkey(____(B)____,____(s)____) , NB ; seskey(A , B , n(S,r)))) , nil]\n\n  [nonexec] .\n\neq ATTACK-STATE(____(0)____) =\n:: r,rM ::\n--- A normal execution of the protocol\n    [ nil ,  +(n(____(a)____,rM) ; a ; ____(b)____ ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,____(s)____) , n(a,____(r)____) ; SK)) | nil ]\n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\neq ATTACK-STATE(____(1)____) =\n:: r,rM ::\n--- An execution where the intruder finds out the Session key generated by the server\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]\n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] .\n\n\neq ATTACK-STATE(2) =\n:: r,rM ::\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so.\n    [ nil ,  +(n(a,rM) ; a ; b ; e(mkey(a,s) , n(a,r) ; n(a,rM) ; a ; b)),\n             -(n(a,rM) ; e(mkey(a,s) , n(a,r) ; SK)) | nil ]\n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: r' ::\n     [ nil | -(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B)),\n             +(NMA ; a ; b ; e(mkey(A,s) , n(A,r) ; n(A,rM) ; A ; B) ; MB1),\n             -(____(NMA)____ ; e(mkey(A,____(s)____) , n(A,r) ; SK) ; MB2),\n             +(NMA ; e(mkey(A,s) , n(A,r) ; SK)), nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n\n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```"]]}