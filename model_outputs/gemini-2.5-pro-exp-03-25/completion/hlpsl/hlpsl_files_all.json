{"HLPSL-1/20172001_Assign_3.hlpsl": [[true, "role user (Ui, RA, GWN, SDj: agent, H : hash_func, SKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by Ui\ndef=\nlocal State: nat, IDi, PWi, BIOi, R, Kgwnui, Kgwnsdj, Ai, RPWi: text,\nRui, T1, M1, M2, M3, TIDi, TIDinew, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({xor(H(IDi.Kgwnui),xor(H(PWi.Sigmai.Ai),R)).TIDi'}_SKuira)=|>\nState' := 2\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') /\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ Snd(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,ui_gwn_t1, T1')\n/\\ witness(Ui,GWN,ui_gwn_rui,Rui')\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3/\\witness(GWN,Ui,gwn_ui_t4,T4')/\\request(GWN,Ui,gwn_ui_tidinew,TIDinew')\nend role\n \n\nrole registrationauthority (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RA\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, R, RPWi, Ai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst sr1,sr3: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.PWi.BIOi.R}_SKuira) =|>\nState' := 1 /\\ Kgwnui' := new()\n/\\ secret(Kgwnui', kgwnui_key, {RA,GWN,Ui})\n/\\ secret(Kgwnsdj', sr3, {RA,GWN,SDj})\n/\\ Ai' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ Snd({Ai'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Ai, RPWi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ui_gwn_t1, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, gwn_ui_tidinew, ui_gwn_rui, gwn_sdj_t2, gwn_ui_t4: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(TIDi'.xor(H(IDi.Kgwnui), Rui').H(xor(H(IDi.Kgwnui), Rui').T1'.IDi'.TIDi'.Rui').T1') =|>\nState' := 1 /\\ M4' := H(IDi.Kgwnui)\n/\\ request(Ui,GWN,ui_gwn_t1, T1')\n/\\ request(Ui,GWN,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ Snd(M7'.M8'.T2')\n/\\ witness(GWN,SDj,gwn_sdj_t2, T2')\n/\\ witness(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n\n2. State = 1 /\\ Rcv(M10'.M11'.M12'.T3') =|>\nState' := 2 /\\ TIDi' := new() /\\ Rgwn' := new() /\\ Rui' := new() /\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ request(SDj,GWN,sdj_gwn_t3, T3')\n/\\ request(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ witness(GWN,Ui,gwn_ui_t4, T4')\n/\\ witness(GWN,Ui,gwn_ui_tidinew, TIDinew')\nend role\n\n\n\nrole smartdevice (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Ai, RPWi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(IDi.Kgwnui)}_M6'.M8'.T2') =|>\nState' := 1 /\\ Kgwnsdj' := new()\n/\\ request(GWN,SDj,gwn_sdj_t2, T2')\n/\\ request(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ Snd(M10'.M11'.M12'.T3')\n/\\ witness(SDj,GWN,sdj_gwn_t3, T3')\n/\\ witness(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n\nend role\n\nrole session (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key)\ndef=\nlocal S1, R1, S2, R2, S3, R3: channel (dy)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S2, R2)\nend role\n\nrole environment()\ndef=\nconst ui, ra, gwn, sdj, i: agent, h: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\nsecrecy_of kgwnui_key, sr2, sr3\nauthentication_on GWN, SDj, gwn_sdj_t2\nauthentication_on SDj, GWN, sdj_gwn_t3\nauthentication_on GWN, Ui, gwn_ui_tidinew\nend goal\nenvironment()", "```hlpsl\nrole user (Ui, RA, GWN, SDj: agent, H : hash_func, SKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by Ui\ndef=\nlocal State: nat, IDi, PWi, BIOi, R, Kgwnui, Kgwnsdj, Ai, RPWi: text,\nRui, T1, M1, M2, M3, TIDi, TIDinew, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({xor(H(IDi.Kgwnui),xor(H(PWi.Sigmai.Ai),R)).TIDi'}_SKuira)=|>\nState' := 2\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') /\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ Snd(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,ui_gwn_t1, T1')\n/\\ witness(Ui,GWN,ui_gwn_rui,Rui')\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3/\\witness(GWN,Ui,gwn_ui_t4,T4')/\\request(GWN,Ui,gwn_ui_tidinew,TIDinew')\nend role\n \n\nrole registrationauthority (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RA\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, R, RPWi, Ai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst sr1,sr3: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.PWi.BIOi.R}_SKuira) =|>\nState' := 1 /\\ Kgwnui' := new()\n/\\ secret(Kgwnui', kgwnui_key, {RA,GWN,Ui})\n/\\ secret(Kgwnsdj', sr3, {RA,GWN,SDj})\n/\\ Ai' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ Snd({Ai'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Ai, RPWi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ui_gwn_t1, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, gwn_ui_tidinew, ui_gwn_rui, gwn_sdj_t2, gwn_ui_t4: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(TIDi'.xor(H(IDi.Kgwnui), Rui').H(xor(H(IDi.Kgwnui), Rui').T1'.IDi'.TIDi'.Rui').T1') =|>\nState' := 1 /\\ M4' := H(IDi.Kgwnui)\n/\\ request(Ui,GWN,ui_gwn_t1, T1')\n/\\ request(Ui,GWN,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ Snd(M7'.M8'.T2')\n/\\ witness(GWN,SDj,gwn_sdj_t2, T2')\n/\\ witness(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n\n2. State = 1 /\\ Rcv(M10'.M11'.M12'.T3') =|>\nState' := 2 /\\ TIDi' := new() /\\ Rgwn' := new() /\\ Rui' := new() /\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ request(SDj,GWN,sdj_gwn_t3, T3')\n/\\ request(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ witness(GWN,Ui,gwn_ui_t4, T4')\n/\\ witness(GWN,Ui,gwn_ui_tidinew, TIDinew')\nend role\n\n\n\nrole smartdevice (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, Ai, RPWi: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(IDi.Kgwnui)}_M6'.M8'.T2') =|>\nState' := 1 /\\ Kgwnsdj' := new()\n/\\ request(GWN,SDj,gwn_sdj_t2, T2')\n/\\ request(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ Snd(M10'.M11'.M12'.T3')\n/\\ witness(SDj,GWN,sdj_gwn_t3, T3')\n/\\ witness(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n\nend role\n\nrole session (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key)\ndef=\nlocal S1, R1, S2, R2, S3, R3: channel (dy)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S2, R2)\nend role\n\nrole environment()\ndef=\nconst ui, ra, gwn, sdj, i: agent, h: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\nsecrecy_of kgwnui_key, sr2, sr3\nauthentication_on GWN, SDj, gwn_sdj_t2\nauthentication_on SDj, GWN, sdj_gwn_t3\nauthentication_on GWN, Ui, gwn_ui_tidinew\nend goal\nenvironment()\n```"]], "HLPSL-1/2019202008.hlpsl": [[true, "_0)State = 3____ /\\ RCV(H(xor(K', Kj'))) =|>\n\t\t   State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n\tGen,User,Gwn____,Sensor\t: agent____,\n\tSNDG____,RCVG____ : channel(dy),\n\tH \t: hash_func\n%\tKgwnu, Kgwns\t: public_key,\n\t)\n\nplayed_by Gwn def=\n\n\tlocal\n\t\tState____ : nat,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTdel,Tchckgwn,Ti,Tgwn\t: nat,\n\t\tPWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij\t: text\n\n\n\tconst\n\t\tsp2____,sp3____,sp4____,g_u_te,u_g_ts1,g_s_ts5____,s_g_ts2,g_s_ts3____,u_g_ts4,u_g_k,s_g_ts6,s_g_kj:protocol_id____\n\n\tinit\n\t\tState := 0\n\n\ttransition\n\n\t%% REceive request for registration from user\n\n\t\t1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n\t\t   State':= 1 /\\ TE' := new()\n\n\t\t2. State  = 1____ /\\ RCV(TS1'.UID'.VI') =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n\t\t   \t\t\t  /\\ TE' := new()\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.P'.TE')\n\t\t   \t\t\t  /\\ PTC' := xor(TC', H(PWD'))\n\t\t   \t\t\t  /\\ secret____({H(PWD')____}, sp2, {Gwn})\n\t\t   \t\t\t  /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n\t\t   \t\t\t  /\\ witness____(Gwn,User,g_u_te____,TE') \n\t\t   \t\t\t  /\\ request(User____,Gwn____,u_g_ts1,TS1')\n\n    %%Receive request for registration from Sensor\n\t\t3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n\t\t   State':= 3 /\\ PWS' := new() /\\ secret({H(PWS')____}, sp3____, {Sensor, Gwn})\n\t\t   \t \t\t  /\\ VI3' := H(TS2'.H(PWS'))\n\t\t   \t \t\t  /\\ TC1' := H(Kgwns.SId')\n\t\t   \t \t\t  /\\ TS3' := new()\n\t\t   \t \t\t  /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n\t\t   \t \t\t  /\\ SND(TS3'.REG')\n\t\t   \t \t\t  /\\ secret____({Kgwns}, sp4____, {Gwn})\n\t\t   \t \t\t  /\\ witness____(Gwn____,Sensor,g_s_ts3,TS3')\n\t\t   \t \t\t  /\\ request(Sensor____,Gwn,s_g_ts2,TS2'____)\n    %%Login and authentication phase\n\t\t4. State  = 3____ /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n\t\t   State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.UID')\n\t\t   \t\t\t  /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := xor(PKS', H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ TC1' := H(Kgwns.SId') \n\t\t   \t\t\t  /\\ TS5' := new()\n\t\t   \t\t\t  /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn' := H(UID'.TC1'.TS5')\n\t\t   \t\t\t  /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n\t\t   \t\t\t  /\\ witness____(Gwn____,Sensor,g_s_ts5,TS5')\n\t\t   \t\t\t  /\\ request(User____,Gwn,u_g_ts4____,TS4')\n\t\t   \t\t\t  /\\ witness____(User,Gwn,u_g_k, K'____)\n\n    %% send session key via public channel to user and sensor\n\t\t5. State  = 4____ /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n\t\t   \t\t\t  /\\ KEYij' := H(xor(K',Kj'))\n\t\t   \t\t\t  /\\ SND(KEYij)\n\t\t   \t\t\t  /\\ request(Sensor,Gwn____,s_g_ts6, TS6'____)\n\t\t   \t\t\t  /\\ witness____(Sensor,Gwn,s_g_kj____, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n\tGen,User____,Gwn,Sensor____\t: agent,\n\tSNDS____,RCVS____ : channel(dy),\n\tH \t: hash_func\n\t)\n\nplayed_by Sensor def=\n\n\tlocal\n\t\tState : nat,\n\t\tTgwn,Tdel,Tchckj: nat,\n\t\tPWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij \t: text\n\n\tconst\n\t\tsp3,sp4,s_g_ts2,g_s_ts3____,g_s_ts5____,s_u_kj,s_g_ts6____:protocol_id____\n\n\tinit\n\t\tState := 2\n\n\ttransition\n\n\t%%Sensor Node registration\n\t\t\n\t\t1. State  = 2 /\\ RCV(start) =|> \n\t\t   State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n\t\t   \t\t\t  /\\ VI' := H(TS2'.H(PWS'))\n\t\t   \t\t\t  /\\ SND(SId'.TS2'.VI')\n\t\t   \t\t\t  /\\ secret({H(PWS')____}, sp3, {Sensor____, Gwn})\n\t\t   \t\t\t  /\\ witness(Sensor____,Gwn,s_g_ts2____,TS2')\n\n\t\t2. State  = 3 /\\ RCV(TS3'.REG') =|>\n\t\t   State':= 4 /\\ PWS' := new() /\\ secret({Kgwns____}, sp4, {Sensor, Gwn____})\n\t\t   \t\t\t  /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n\t\t   \t\t\t  /\\ witness____(Gwn,Sensor____,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n\t\t3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n\t\t   State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n\t\t   \t\t\t  /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ TS6' := new()\n\t\t   \t\t\t  /\\ Kj' := new()\n\t\t   \t\t\t  /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n\t\t   \t\t\t  /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n\t\t   \t\t\t  /\\ SND(SId'.TS6'.C1'.PKS1')\n\t\t   \t\t\t  /\\ witness(Sensor____,User,s_u_ts6,TS6'____)\n\t\t   \t\t\t  /\\ witness____(Sensor____,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n\t\t4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n\t\t   State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n\t\t              /\\ witness(Sensor,Gwn____,s_g_ts6, TS6'____)\n\t\t              /\\ witness(Sensor____,Gwn,s_g_kj____, Kj')\nend role\n\n%%Sensor role\nrole session(\n\tGen____,User____,Gwn,Sensor : agent____,\n\tH:hash_func)\n\n\tdef=\n\t\t\n\t\tlocal \n\t\t\tSNDU____,RCVU,SNDG,RCVG,SNDS,RCVS____: channel (dy____)\n\n\t\tcomposition\n\t\t\tuser(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n  \t\t\t/\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n  \t\t\t/\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n\t\n\tdef=\n\n\t\tconst \n\t\t\ta,b____,c____,d: agent,\n\t\t\tu_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n\t\t\th:hash_func,\n\t\t\tt1,t2,t3:text\n\t\t\t%Kgwnu,Kgwns:public_key\n\n\n\tintruder_knowledge = {a,b,c,t1,t2,t3}\n\n\tcomposition\n\t\t   session(a,b,c,d,h)\n\t\t/\\ session(a,i,c,d,h) \n\t\t/\\ session(a,b,i,d,h)\n\t\t/\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n\tsecrecy_of____ sp2, H(PWD')____, sp4, Kgwns\n\n\tauthentication_on User____, Gwn, K'____, u_g_k\n\tauthentication_on____ Gwn, User, g_u_te, TE', Gwn, Sensor, g_s_ts5, TS5'____\n\tauthentication_on s_g_ts2, Sensor____, Gwn____, TS2', authentication_on Sensor, Gwn, Kj'____, s_g_kj\nend goal\n\nenvironment()", "The completed HLPSL specification is as follows:\n\n```hlpsl\n_0)State = 3____ /\\ RCV(H(xor(K', Kj'))) =|>\n\t\t   State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n\tGen,User,Gwn____,Sensor\t: agent____,\n\tSNDG____,RCVG____ : channel(dy),\n\tH \t: hash_func\n%\tKgwnu, Kgwns\t: public_key,\n\t)\n\nplayed_by Gwn def=\n\n\tlocal\n\t\tState____ : nat,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTdel,Tchckgwn,Ti,Tgwn\t: nat,\n\t\tPWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij\t: text\n\n\n\tconst\n\t\tsp2____,sp3____,sp4____,g_u_te,u_g_ts1,g_s_ts5____,s_g_ts2,g_s_ts3____,u_g_ts4,u_g_k,s_g_ts6,s_g_kj:protocol_id____\n\n\tinit\n\t\tState := 0\n\n\ttransition\n\n\t%% REceive request for registration from user\n\n\t\t1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n\t\t   State':= 1 /\\ TE' := new()\n\n\t\t2. State  = 1____ /\\ RCV(TS1'.UID'.VI') =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n\t\t   \t\t\t  /\\ TE' := new()\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.P'.TE')\n\t\t   \t\t\t  /\\ PTC' := xor(TC', H(PWD'))\n\t\t   \t\t\t  /\\ secret____({H(PWD')____}, sp2, {Gwn})\n\t\t   \t\t\t  /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n\t\t   \t\t\t  /\\ witness____(Gwn,User,g_u_te____,TE') \n\t\t   \t\t\t  /\\ request(User____,Gwn____,u_g_ts1,TS1')\n\n    %%Receive request for registration from Sensor\n\t\t3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n\t\t   State':= 3 /\\ PWS' := new() /\\ secret({H(PWS')____}, sp3____, {Sensor, Gwn})\n\t\t   \t \t\t  /\\ VI3' := H(TS2'.H(PWS'))\n\t\t   \t \t\t  /\\ TC1' := H(Kgwns.SId')\n\t\t   \t \t\t  /\\ TS3' := new()\n\t\t   \t \t\t  /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n\t\t   \t \t\t  /\\ SND(TS3'.REG')\n\t\t   \t \t\t  /\\ secret____({Kgwns}, sp4____, {Gwn})\n\t\t   \t \t\t  /\\ witness____(Gwn____,Sensor,g_s_ts3,TS3')\n\t\t   \t \t\t  /\\ request(Sensor____,Gwn,s_g_ts2,TS2'____)\n    %%Login and authentication phase\n\t\t4. State  = 3____ /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n\t\t   State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.UID')\n\t\t   \t\t\t  /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := xor(PKS', H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ TC1' := H(Kgwns.SId') \n\t\t   \t\t\t  /\\ TS5' := new()\n\t\t   \t\t\t  /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn' := H(UID'.TC1'.TS5')\n\t\t   \t\t\t  /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n\t\t   \t\t\t  /\\ witness____(Gwn____,Sensor,g_s_ts5,TS5')\n\t\t   \t\t\t  /\\ request(User____,Gwn,u_g_ts4____,TS4')\n\t\t   \t\t\t  /\\ witness____(User,Gwn,u_g_k, K'____)\n\n    %% send session key via public channel to user and sensor\n\t\t5. State  = 4____ /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n\t\t   \t\t\t  /\\ KEYij' := H(xor(K',Kj'))\n\t\t   \t\t\t  /\\ SND(KEYij)\n\t\t   \t\t\t  /\\ request(Sensor,Gwn____,s_g_ts6, TS6'____)\n\t\t   \t\t\t  /\\ witness____(Sensor,Gwn,s_g_kj____, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n\tGen,User____,Gwn,Sensor____\t: agent,\n\tSNDS____,RCVS____ : channel(dy),\n\tH \t: hash_func\n\t)\n\nplayed_by Sensor def=\n\n\tlocal\n\t\tState : nat,\n\t\tTgwn,Tdel,Tchckj: nat,\n\t\tPWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij \t: text\n\n\tconst\n\t\tsp3,sp4,s_g_ts2,g_s_ts3____,g_s_ts5____,s_u_kj,s_g_ts6____:protocol_id____\n\n\tinit\n\t\tState := 2\n\n\ttransition\n\n\t%%Sensor Node registration\n\t\t\n\t\t1. State  = 2 /\\ RCV(start) =|> \n\t\t   State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n\t\t   \t\t\t  /\\ VI' := H(TS2'.H(PWS'))\n\t\t   \t\t\t  /\\ SND(SId'.TS2'.VI')\n\t\t   \t\t\t  /\\ secret({H(PWS')____}, sp3, {Sensor____, Gwn})\n\t\t   \t\t\t  /\\ witness(Sensor____,Gwn,s_g_ts2____,TS2')\n\n\t\t2. State  = 3 /\\ RCV(TS3'.REG') =|>\n\t\t   State':= 4 /\\ PWS' := new() /\\ secret({Kgwns____}, sp4, {Sensor, Gwn____})\n\t\t   \t\t\t  /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n\t\t   \t\t\t  /\\ witness____(Gwn,Sensor____,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n\t\t3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n\t\t   State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n\t\t   \t\t\t  /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ TS6' := new()\n\t\t   \t\t\t  /\\ Kj' := new()\n\t\t   \t\t\t  /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n\t\t   \t\t\t  /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n\t\t   \t\t\t  /\\ SND(SId'.TS6'.C1'.PKS1')\n\t\t   \t\t\t  /\\ witness(Sensor____,User,s_u_ts6,TS6'____)\n\t\t   \t\t\t  /\\ witness____(Sensor____,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n\t\t4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n\t\t   State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n\t\t              /\\ witness(Sensor,Gwn____,s_g_ts6, TS6'____)\n\t\t              /\\ witness(Sensor____,Gwn,s_g_kj____, Kj')\nend role\n\n%%Sensor role\nrole session(\n\tGen____,User____,Gwn,Sensor : agent____,\n\tH:hash_func)\n\n\tdef=\n\t\t\n\t\tlocal \n\t\t\tSNDU____,RCVU,SNDG,RCVG,SNDS,RCVS____: channel (dy____)\n\n\t\tcomposition\n\t\t\tuser(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n  \t\t\t/\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n  \t\t\t/\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n\t\n\tdef=\n\n\t\tconst \n\t\t\ta,b____,c____,d: agent,\n\t\t\tu_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n\t\t\th:hash_func,\n\t\t\tt1,t2,t3:text\n\t\t\t%Kgwnu,Kgwns:public_key\n\n\n\tintruder_knowledge = {a,b,c,t1,t2,t3}\n\n\tcomposition\n\t\t   session(a,b,c,d,h)\n\t\t/\\ session(a,i,c,d,h) \n\t\t/\\ session(a,b,i,d,h)\n\t\t/\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n\tsecrecy_of____ sp2, H(PWD')____, sp4, Kgwns\n\n\tauthentication_on User____, Gwn, K'____, u_g_k\n\tauthentication_on____ Gwn, User, g_u_te, TE', Gwn, Sensor, g_s_ts5, TS5'____\n\tauthentication_on s_g_ts2, Sensor____, Gwn____, TS2', authentication_on Sensor, Gwn, Kj'____, s_g_kj\nend goal\n\nenvironment()\n```"]], "HLPSL-1/A_Secure_and_Efficient_Smart_Card-based_UCSSO_Scheme_Using_Extended_Chebyshev_Chaotic_Maps_for_Telemedicine_Systems.hlpsl": [[false, "```houzhui\nrole user (U: agent, S: agent, Kus: symmetric_key, T: poly_func, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(Ai',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ private(PWi',PWi,{U})\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,S,u_s_pi,Pi')\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ witness(S,U,s_u_sj,Sj')\n\nend role\n\n\nrole server (U: agent, S: agent, Kus: symmetric_key, T: poly_func, H: hash_func, SS, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',g3,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Xsj,g6,{S})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(S,U,s_u_sj,Sj')\n/\\ claim(U,S,u_s_pi,Pi')\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (U: agent, S: agent, Kus: symmetric_key, T: poly_func, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6 authentication_on u_s_pi, s_u_sj\n\nend goal\n```"]], "HLPSL-1/BRSKI.hlpsl": [[true, "role pledge (P, S, M           : agent,\n            Kp, Kr, Km, Kca\t: public_key,\n\t    KeyGen, PRF    \t: hash_func,\n\t    Sn      \t\t: text, %serial Number \n            Issuer    \t\t: text,\n            Aki\t\t\t: text,  %authorityKeyIdentifier\n            Sln\t\t\t: text,  %subjectAltName\t\n\t    SND_P, RCV_R, SND_M, RCV_M : channel (dy))\nplayed_by P def=\n\n  local Nc, Nd, Pmsm, Mm, Finishedm, ClientKm, ServerKm : text,\n        Assr, Np, Pam, Sidm : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr', Kp'            : public_key\n\n  const auth_np, auth_np1, auth_na_nb, auth_na_nb2, auth_reg_cert, auth_reg_certchain : protocol_id\n\n  init State := 9\n\n  transition\n\n 9. State  = 9 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = 9 \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ secret(ClientKm,tls_registrarrmk,{R,M})\n\t/\\ secret(ServerKm,tls_masarmk,{R,P})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(Np,sec_np_rm,{R,M})\n\t/\\ witness(M,P,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(P,R,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, S, M  : agent,\n\t   Km, Kp, Kca  : public_key,\n   \t   KeyGen, PRF    : hash_func,\n\t   Sn      \t: text, %serial Number \n           Issuer    \t: text,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t: text,  %subjectAltName\t\n\t   SND_R, RCV_R, SND_M, RCV_P   : channel (dy))\nplayed_by M def=\n\n  local SeID, Assr , Np, Nc, Nd, Pmsm, Pam, Sidm : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,P,auth_nc_nd,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = 19 \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ request(M,P,auth_np,Np')\n\t/\\ request(M,P,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n\t \n \nend role\n\n\nrole session(P, R, M        : agent,\n             Kp, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: hash_func,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: text,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local SP, SR, SM, RP, RR, RM  : channel (dy)\n\n  composition\n\tpledge(P,S,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,S,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,S,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,r,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\ngoal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm\n\tsecrecy_of tls_pledgerk,tls_registrark,tls_registrarrmk,tls_masarmk\n\tauthentication_on auth_reg_cert1\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\tauthentication_on auth_na_nb2        \n\tauthentication_on auth_sn\n\tauthentication_on auth_np\n\tauthentication_on auth_np1\t\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n\tauthentication_on auth_reg_certchain %% MASA can check registrar on RegistrarChain\n\tauthentication_on auth_np  %Registrar authenticates voucher by checking nonce Np.\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()", "```hlpsl\nrole pledge (P, S, M           : agent,\n            Kp, Kr, Km, Kca\t: public_key,\n\t    KeyGen, PRF    \t: hash_func,\n\t    Sn      \t\t: text, %serial Number \n            Issuer    \t\t: text,\n            Aki\t\t\t: text,  %authorityKeyIdentifier\n            Sln\t\t\t: text,  %subjectAltName\t\n\t    SND_P, RCV_R, SND_M, RCV_M : channel (dy))\nplayed_by P def=\n\n  local Nc, Nd, Pmsm, Mm, Finishedm, ClientKm, ServerKm : text,\n        Assr, Np, Pam, Sidm : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr', Kp'            : public_key\n\n  const auth_np, auth_np1, auth_na_nb, auth_na_nb2, auth_reg_cert, auth_reg_certchain : protocol_id\n\n  init State := 9\n\n  transition\n\n 9. State  = 9 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = 9 \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ secret(ClientKm,tls_registrarrmk,{R,M})\n\t/\\ secret(ServerKm,tls_masarmk,{R,P})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(Np,sec_np_rm,{R,M})\n\t/\\ witness(M,P,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(P,R,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, S, M  : agent,\n\t   Km, Kp, Kca  : public_key,\n   \t   KeyGen, PRF    : hash_func,\n\t   Sn      \t: text, %serial Number \n           Issuer    \t: text,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t: text,  %subjectAltName\t\n\t   SND_R, RCV_R, SND_M, RCV_P   : channel (dy))\nplayed_by M def=\n\n  local SeID, Assr , Np, Nc, Nd, Pmsm, Pam, Sidm : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,P,auth_nc_nd,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = 19 \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ request(M,P,auth_np,Np')\n\t/\\ request(M,P,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n\t \n \nend role\n\n\nrole session(P, R, M        : agent,\n             Kp, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: hash_func,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: text,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local SP, SR, SM, RP, RR, RM  : channel (dy)\n\n  composition\n\tpledge(P,S,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,S,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,S,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,r,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\ngoal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm\n\tsecrecy_of tls_pledgerk,tls_registrark,tls_registrarrmk,tls_masarmk\n\tauthentication_on auth_reg_cert1\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\tauthentication_on auth_na_nb2        \n\tauthentication_on auth_sn\n\tauthentication_on auth_np\n\tauthentication_on auth_np1\t\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n\tauthentication_on auth_reg_certchain %% MASA can check registrar on RegistrarChain\n\tauthentication_on auth_np  %Registrar authenticates voucher by checking nonce Np.\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/calp-v3.hlpsl": [[false, "```houzhui\n%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), un lecteur de badge (LB)\n%% Deux cas de figures :  - une demande d'acc\u00e8s normal (1)\n%%\t\t\t  - une demande d'acc\u00e8s exceptionnel (2)\n%% B_S:\n%% Badgeuse -> Serveur : {IdBageuse, IdEmploye}_PKs\n%%Serveur -> Badgeuse : { ClefSession}_PKb\n%%Badgeuse -> Serveur: { Msg}_ClefSession\n%%Serveur -> Badgeuse: { ok.H(Msg)}_ClefSession\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n            TypeAction : protocol_id,            \n            PKs, PKb: public_key,\n\t    H: hash_func,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local idB: nat,\n  Action: text,\n  ClefSession : symmetric_key\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(B,S,badgeuse_serveur,IdEmploye.IdBadgeuse)\n    2.  State=1 /\\ RCV({ClefSession'.IdServeur}_PKb) =|> \n\tState':=2 /\\ SND({TypeAction}_ClefSession) \n    3.  State=2 /\\ RCV({TypeAction.Action'}_ClefSession) =|>\n        State':=3 /\\ SND({ok.H(Action')}_ClefSession) /\\ request(B,S,badgeuse_serveur, Action')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse,IdServeur,TypeAction : protocol_id,\n\t    Action: text,\n\t    PKb,PKs: public_key,\n\t    H: hash_func,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local idS: nat,\n  ClefSession: symmetric_key\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ ClefSession':=new() /\\ secret(ClefSession, sessionkey,{B,S}) /\\ SND({ClefSession.IdServeur}_PKb) /\\secret(IdEmploye,idemploye,{B,S}) /\\ witness(S,B,serveur_badgeuse,IdEmploye.IdBadgeuse)\n\n    2.  State=1 /\\ RCV({TypeAction}_ClefSession) =|>\n        State':=2 /\\ SND({TypeAction.Action}_ClefSession) /\\ secret(Action, act,{B,S})\n\n    3.  State=2 /\\ RCV({ok.H(Action)}_ClefSession) =|>\n        State':=3 /\\ request(S,B,serveur_badgeuse, IdEmploye.IdBadgeuse)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse,IdServeur,TypeAction : protocol_id,H:hash_func,Action:text) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,PKs,PKb,H,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,Action,PKb,PKs,H,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const b,s : agent,\n\t  pks, pkb, pki: public_key,\n          h:hash_func,\n          idemploye, idbadgeuse, badgeuse_serveur,typeaction, serveur_badgeuse,act,sessionkey,idserveur: protocol_id,\n          idemployei:protocol_id,\n          action :text,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki),h,typeaction,idemployei}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemploye,idserveur, idbadgeuse,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemployei,idserveur, idbadgeuse,typeaction,h,action)\n\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sessionkey,act\t\n\tsecrecy_of idemploye\n\tauthentication_on badgeuse_serveur\n\tauthentication_on serveur_badgeuse\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()```"]], "HLPSL-1/CHAPv2.hlpsl": [[false, "```houzhui\n%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share\n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in theDolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole chap_Init (A,B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, RA: channel(dy))\nplayed_by A\ndef=\n\n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)\n\n   2. State   = 1 /\\ Rcv(Nb') =|>\n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.Na'.Nb.A))\n\t          /\\ witness(A,A,na,Na')\n\t\t  /\\ secret(Kab,sec_kab1,{A,B})\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na)) =|>\n      State' := 3 /\\ request(A,B,nb,Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH: hash_func,\n                Snd, RB: channel(dy))\nplayed_by B\ndef=\n\n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab2 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>\n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')\n\t          /\\ witness(B,A,nb,Nb')\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.Na'.Nb.A)) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))\n\t          /\\ request(B,A,na,Na')\n\t\t  /\\ secret(Kab,sec_kab2,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id,\n        start         : protocol_id % Define 'start' as a protocol_id for initiator trigger\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(b,i,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n\n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/chebyshev_final.hlpsl": [[false, "```houzhui\nrole user(\n\tUi, Sj, RC : agent,\n\tRPkeyi : symmetric_key, % used for registration phase(secure channel)\n\t% Discrete Chaotic Map (SIDj, xj, Tsj(xj)(mod p))\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Ui def=\n\n\tlocal\n\tState : nat,\n\tPubj : (agent.text.message) set,\t\n\tCi, EHIDi : message,\n\tVi : hash(text.text.hash(text).text),\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTsj, Tri : message,\n\tIDi, PWi, Bi, Ri, RNi, RN1: text,\n\tXj, Trisj, TRN1, RN2: text,\n\tRN3: text.text, \t\n\t\n\tBhi : hash(text)\n\n\tinit\n\tState := 0\n\t/\\ Pubj := {}\n\n\ttransition\n\t% Registration phase\n\t0. State = 0 /\\ Rcv(Sj.Xj'.Tsj')\n\t=|> State' := 2 /\\ Pubj' := cons(Sj.Xj'.Tsj', Pubj)\n\t/\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new()\n\t/\\ secret(IDi', idi, Ui) /\\ secret(PWi', pwi, Ui)\n\t/\\ secret(Bi', bi, Ui) % secrecy test\n\t/\\ Bhi' := BH(Bi') /\\ Ri' := new()\n\t/\\ Ci' := xor(Ri', Hash(IDi'.PWi'.Bhi'))\n\t/\\ Vi' := Hash(IDi'.PWi'.Bhi'.Ri')\n\t/\\ HIDi' := Hash(IDi'.Bhi')\n\t% check identity traceability\t\n\t/\\ identity_traceability(HIDi, hidi, {Ui, RC, Sj})\t\n\t/\\ Snd({HIDi'.Ci'.Vi'}_RPkeyi)\n\t\n\t2. State = 2 /\\ Rcv({UIDi'}_RPkeyi) /\\ in(Sj.Xj'.Tsj', Pubj)\n\t=|> State' := 4\n\t% login phase\n\t/\\ RNi' := new() /\\ RN1' := new()\n\t/\\ Tri' := exp(Xj, RNi')\n\t% encryption instead of multiplication\t\n\t/\\ EHIDi' := {HIDi}_exp(Tsj',RNi') \n\t% symmetric encryption instead of chebyshev polynomial\n\t/\\ TRN1' := {RN1'}_UIDi %T_{RN1'}(UIDi)\n\t%/\\ Snd(Sj.Tri'.EHIDi'.TRN1')\n\t/\\ Snd(Sj.Tri'.EHIDi')\n\t/\\ witness(Ui, Sj, hidi, HIDi')\n\t/\\ Snd(Sj.TRN1')\n\t% authentication property\n\t/\\ witness(Ui, Sj, rn1, RN1')\n\t/\\ RN3' := HIDi.RN1\n\t% authentication phase\n\n\t4. State = 4 /\\ Rcv({RN2'}_RN3)\n\t=|> State' := 6\n\t/\\ request(Ui, Sj, rn2, RN2')\n\nend role\n\nrole server(\n\tUi, Sj, RC: agent,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Sj def=\n\n\tlocal\n\tState : nat,\n\tRN1, RN2 : text,\t\n\tRN3 : text.text,\t\n\tKeyRing: (hash(hash(text.hash(text)).text).hash(hash(text.hash(text)).text)) set,\n\tPKeyj : text, %public key(x_j) of discrete chebyshev\n\tTPKeyj : message, %public key (T_{x_j}(x_j)) of discrete chebyshev\n\tSKeyj : text, %secret key\n\tHIDi : hash(text.hash(text)),\n\tUIDi, XIDi: hash(hash(text.hash(text)).text),\n\tTri, Ex1 : message\n\n\tinit\n\tState := 0\n\t/\\ KeyRing := {}\n\n\ttransition\n\t% Server Registration phase\n\t0. State = 0 /\\ Rcv(start)\n\t=|> State' := 1 /\\ Snd({PKeyj'.TPKeyj'.SKeyj'}_RPKeyj)\n\t\n\t1. State = 1 /\\ Rcv({PKeyj'.TPKeyj'.SKeyj'}_RPKeyj)\n\t=|> State' := 2\n\t/\\ Snd(Sj.PKeyj'.TPKeyj')\t% release public key\n\n\t% Registration phase\n\t2. State = 2 /\\ Rcv({HIDi'.UIDi'}_RPKeyj) /\\ not(in(XIDi'.UIDi', KeyRing))\n\t=|> State' := 3\n\t/\\ XIDi' := Hash(HIDi'.SKeyj)\n\t/\\ KeyRing' := cons(XIDi'.UIDi', KeyRing)\n\n\t% Login phase\n\t%3. State = 3 /\\ Rcv(Sj.Tri'.{HIDi'}_Ex1'.{RN1'}_UIDi')  /\\ Ex1' = exp(Tri',SKeyj) /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)\n\t3. State = 3 /\\ Rcv(Sj.Tri'.EHIDi_rcv)  /\\ Ex1' = exp(Tri',SKeyj) /\\ EHIDi_rcv = Sj.{HIDi'}_Ex1' /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)/\\ Rcv(Sj.{RN1'}_UIDi')\n\t=|> State' := 5\n\t/\\ RN2' := new()\n\t/\\ RN3' := HIDi.RN1\n\t/\\ Snd({RN2'}_RN3')\n\t/\\ request(Sj, Ui, rn1, RN1')\n\t/\\ witness(Sj, Ui, rn2, RN2)\t\n\t%/\\ request(Sj, Ui, rn2, RN2)\n\t\n\t\nend role\n\n% Registration Server\nrole regserver(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key, % secure channel w/ Ui\n\tRPKeyj : symmetric_key, % secure channel w/ Sj\n\tHash : hash_func,\n\tBH : hash_func, % biohash function\n\tSndi, Sndj, Rcv : channel(dy))\nplayed_by RC def=\n\n\tlocal\n\tState : nat,\n\tUri  : text,\n\tCi : message,\n\tVi : hash(text.text.hash(text).text),\n\tXj, SKj : text,\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTXj : message\n\n\tinit\n\tState := 0\n\t\n\ttransition\n\t% Server Registration\n\t0. State = 0 /\\ Rcv({Sj}_RPKeyj)\n\t=|> State' := 1\n\t/\\ Xj' := new()\n\t/\\ SKj' := new()\n\t/\\ TXj' := exp(Xj', SKj')\n\t%/\\ Sndi(Sj.Xj'.TXj')\n\t/\\ Sndj({Xj'.TXj'.SKj'}_RPKeyj)\n\t/\\ secret(SKj', skj, {Sj, RC}) \n\t\n\t% User Registration\t\n\t1. State = 1 /\\ Rcv({HIDi'.Ci'.Vi'}_RPKeyi)\n\t=|> State' := 1\n\t/\\ Uri' := new()\n\t/\\ UIDi' := Hash(HIDi'.Uri')\n\t/\\ Sndi({UIDi'.Ci'.Vi'}_RPKeyi)\n\t/\\ Sndj({HIDi'.UIDi'}_RPKeyj)\nend role\n\nrole session(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\t%Pubj : (agent.message.message) set,\n\t%PKeyj : text,\n\t%SKeyj : message, % secret key of server\n\tHash : hash_func,\n\tBH : hash_func)\ndef=\n\tlocal SI, SJ, RI, RJ, RR, SRI, SRJ : channel(dy)\n\n\tcomposition\n\tuser(Ui, Sj, RC, RPKeyi, Hash, BH, SI, SJ)\n\t/\\ server(Ui, Sj, RC, RPKeyj, Hash, BH, RI, RJ)\n\t/\\ regserver(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH, SRI, SRJ, RR)\nend role\n\nrole environment()\ndef=\n\tconst\n\tidi, pwi, bi, hidi, rn1, rn2, skj : protocol_id,\n\ta1, a2, b, r : agent,\n\tkar1, kar2, kir, kbr : symmetric_key,\n\tskeyj : text,\n\tpkeyj : text,\n\th : hash_func,\n\tbh : hash_func\n\n\tintruder_knowledge = {a1, a2, b, r, kir, h, bh}\n\t\n\tcomposition\n\tsession(a1, b, r, kar1, kbr, h, bh)\n\t%/\\ session(a2, b, r, kar2, kbr, h, bh)\n\t%/\\ session(i, b, r, kir, kbr, h, bh)\nend role\n\ngoal\n\tsecrecy_of idi, pwi, bi, hidi, skj\n\tauthentication_on rn1, rn2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/CRAM-MD5.hlpsl": [[false, "```houzhui\n%% PROTOCOL: CRAM-MD5 Challenge-Response Authentication Mechanism\n%% PURPOSE:\n%% CRAM-MD5 is intended to provide an authentication extension to\n%% IMAP4 that neither transfers passwords in cleartext nor requires\n%% significant security infrastructure in order to function.  To this end,\n%% the protocol assumes a shared password (which we model, without loss of\n%% generality, as a shared cryptographic key) between the IMAP4 server\n%% (called S in our model) and each client A.  Only a hash value of\n%% the shared password is ever sent over the network, thus precluding\n%% plaintext transmission.\n%% \n%% REFERENCE:\n%% RFC 2195~\\cite{RFC2195}\n%% MODELER:\n%% Paul Hankes Drielsma, ETH Z\\\"urich, July 2004\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% Alice-Bob Notation:\n%%  1. A -> S: A\n%%  2. S -> A: Ns.T.S\n%%  3. A -> S: F(SK.T)\n%%  where\n%%      Ns is a nonce generated by the server;\n%%      T is a timestamp (currently abstracted with a nonce)\n%%      SK is the shared key between A and S\n%%      F is a cryptographic hash function (MD5 in practice, but this is\n%%       unimportant for our purposes).  The use of F\n%%       is intended to ensure that only a digest of the shared\n%%       key is transmitted, with T assuring freshness of the \n%%       generated hash value.\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item We abstract away from the timestamp \\verb|T| using a \n%% standard nonce.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%% NOTES:\n%% RFC 2195~\\cite{RFC2195} states that the first message from the \n%% server S begins with a \"presumptively arbitrary string of random \n%% digits\"; that is, a nonce.  Unspecified, however, is what the \n%% client should do with this nonce.  It does not appear in subsequent\n%% protocol message.  We therefore presume it is intended to\n%% ensure replay protection, but our HLPSL specification at present does not \n%% explicitly model that the client should maintain a list of nonces\n%% previously received from the server.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole client(A: agent, S: agent,\n\t    SK: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local  State : nat, \n         T, Ns : text\n\n  const  sec_SK : hash(agent.agent)\n\n  init   State := 0\n\n  transition \n\n  1. State = 0   /\\ RCV(start) \n     =|>\n     State' := 1 /\\ SND(A)\n\n  2. State = 1   /\\ RCV(Ns'.T'.S)\n     =|>\n     State' := 2 /\\ SND(F(SK.T')) \n                 /\\ request(A,S,auth,F(SK.T')) \n                 /\\ secret(SK,sec_SK,{A,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole server(S : agent,\n\t    K, F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        A     : agent,\n        T, Ns : text,\n        Auth  : hash(hash(agent.agent).text)\n\n  init  State := 0\n\n  transition \n   1. State = 0   /\\ RCV(A') \n      =|>\n      State' := 1 /\\ Ns' := new()\n                  /\\ T' := new()\n                  /\\ SND(Ns'.T'.S)\n\n   2. State = 1   /\\ RCV(F(K(A.S).T)) \n      =|>\n      State' := 2 /\\ Auth' := F(K(A.S).T) \n                  /\\ witness(S,A,auth,F(K(A.S).T))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, S: agent,\n             K, F: hash_func)\ndef=\n\n  local SK: hash(agent.agent),\n        SNDA, SNDS, RCVA, RCVS: channel (dy)\n\n  init SK := K(A.S)\n\n  composition\n       client(A,S,SK,F,SNDA,RCVA)\n    /\\ server(S,K,F,SNDS,RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n const a, s : agent,\n       k, f : hash_func,\n       auth : protocol_id\n\n intruder_knowledge = {a,s,i,f}\n\n composition\n      session(a,s,k,f)\n   /\\ session(i,s,k,f)\n   /\\ session(a,s,k,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_SK  % Addresses G12\n\n  %Server authenticates Client on auth\n  authentication_on auth  % Addresses G1, G2, G3\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/crocus.hlpsl": [[false, "```houzhui\nrole alice ( \n\tA:agent,B:agent,\n\tYa:public_key,Yb:public_key,\n\tSign,KDF,ECP,KEX: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tNa,Nb,N_alice_x,N_alice_y:nat,\n\tKa,Kb:nat, %%% Kex() --->>> Ka Ra\n\tT1,T2,T3,T4,H1,H2,H4,H3,H5,H6,REPLY,REQ:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 \n/\\ H1' := new() \n/\\ Na' := new()\n/\\ T1' := new()\n/\\ S1' := {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n/\\ SND(H1'.Na'.T1'.S1') /\\ witness(A,B,aut1,H1'.Na'.T1'.S1')\n\n2. State = 1 /\\ RCV(H2'.Nb'.T2'.S2') /\\ S2' = {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n=|> State' := 2 \n/\\ Ka' := new()\n/\\ H3':= new()\n/\\ S3' := {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n/\\ SND(H3'.KEX(Ka').S3') /\\ request(A,B,aut2,H2'.Nb'.T2'.S2') /\\ witness(A,B,aut3,H3'.KEX(Ka').S3')\n\n3. State = 2 /\\ RCV(H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) \n=|> State' := 3 \n/\\ H5' := new()\n/\\ T4' := new()\n/\\ REQ' := new()\n/\\ ET2' := {T4'.REQ'}_KDF(ECP(Ka,KEX(Kb')))\n/\\ S5' := {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ')}_inv(Ya)\n/\\ SND(H5'.ET2'.S5') /\\ request(A,B,aut4,H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) /\\ witness(A,B,aut5,H5'.ET2'.S5')\n/\\ request(REQ,sec1,A)\n/\\ secrecy_of(REQ,sec1,A)\n\n4. State = 3 /\\ RCV(H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb))\n=|>\nState' := 4 /\\ request(A,B,aut6,H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)) /\\ secrecy_of(REPLY,sec2,A) /\\ request(REPLY,sec2,B)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA:agent,B:agent,\n\tYa:public_key,Yb:public_key,\n\tSign,KDF,ECP,KEX:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tNb,Na,Ra,SID,Ka,Kb,N_bob_z,Rb:nat,\n\tT2,T3,H1,H2,H3,H4,H5,H6,T4,REQ,REPLY,T1,TT:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6,CK:message,\n\tState:nat\ninit State := 0\ntransition\n\n1. State =0 /\\ RCV(H1'.Na'.T1'.S1') /\\ S1' = {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n=|> State' := 1\n/\\ H2' := new() \n/\\ Nb' := new()\n/\\ T2' := new()\n/\\ S2' := {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n/\\ SND(H2'.Nb'.T2'.S2') /\\ request(B,A,aut1,H1'.Na'.T1'.S1') /\\ witness(B,A,aut2,H2'.Nb'.T2'.S2')\n\n2. State = 1 /\\ RCV(H3'.KEX(Ka').S3') /\\ S3' = {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n=|> State' := 2 \n/\\ H4' :=new() \n/\\ Kb' := new()\n/\\ T3' := new()\n/\\ S4' := {Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)\n/\\ ET1' := {T3'}_KDF(ECP(Kb'.KEX(Ka')).A.B)\n/\\ SND(H4'.KEX(Kb').ET1'.S4') /\\ request(B,A,aut3,H3'.KEX(Ka').S3') /\\ witness(B,A,aut4,H4'.KEX(Kb').ET1'.S4')\n\n3. State = 2 /\\ RCV(H5'.ET2'.S5') /\\ S5' = {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3'.T4'.REQ')}_inv(Ya)\n%%%%{T4'.REQ'}_KDF(ECP(Ka,KEX(Kb)) \n=|> State':=3 \n/\\ REPLY' := new()\n/\\ H6' := new()\n/\\ ET3' := {REPLY'}_KDF(ECP(Kb,KEX(Ka)))\n/\\ S6' := {Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)\n/\\ SND(H6'.ET3'.S6') \n/\\ secrecy_of(REPLY,sec2,B)\n/\\ request(REPLY,sec2,A)\n/\\ secrecy_of(REQ,sec1,A)\n/\\ secrecy_of(REQ,sec1,B)\n/\\ request(B,A,aut5,H5'.ET2'.S5') /\\ witness(B,A,aut6,H6'.ET3'.S6')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session ( A,B:agent,Ya,Yb:public_key,Sign,KDF,ECP,KEX:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SA,RA) \n/\\ bob(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole main()\ndef=\n\nconst a,b:agent,\nsec1,sec2,aut1,aut2,aut3,aut4,aut5,aut6: protocol_id,\nya,yb:public_key,\nsign:hash_func,\nkdf:hash_func,\necp:hash_func,\nkex:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,ecp,kex}\n\ncomposition\n\nsession(a,b,ya,yb,sign,kdf,ecp,kex)\n\nend role\n\ngoal\n\tauthentication_on aut1\n\tauthentication_on aut2\n\tauthentication_on aut3\n\tauthentication_on aut4\n\tauthentication_on aut5\n\tauthentication_on aut6\n\tsecrecy_of sec1\n\tsecrecy_of sec2\nend goal\n```"]], "HLPSL-1/device6g.hlpsl": [[false, "```\nrole device (DEV:agent, KM:agent,\t\n\tH,H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by DEV\ndef=\nlocal State:nat,  \nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\ninit State:=0\n\ntransition\n\n1. State=0 /\\ RCV(start)=|> \nState':=1 /\\D':=new()\n/\\HNWS':=H(NWS)\n/\\HND':=H4B(ND)\n/\\Nonce':=new()\n/\\HM':=H4B(NWS.ND.Nonce'.D')\n/\\SND(HNWS'.HND'.Nonce'.HM'.D')\n/\\claim(DEV,sec_1,sec_1,{DEV,KM})\n/\\claim(DEV,sec_2,ND,{DEV,KM})\n%%/\\witness(DEV,KM,auth_dev_km_hm1,HM')\n\nend role\n\n\nrole keymanager (KM,DEV:agent,\n\tH,H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND,RCV:channel (dy))\nplayed_by KM\n\ndef=\nlocal State:nat,\nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\ninit State:=0\ntransition\n\n1. State=0/\\RCV(HNWS'.HND'.Nonce'.HM'.D')=|>\nState':=1 /\\ HM1':=H4B(NWS.ND.Nonce'.D')\n%%/\\request(DEV,KM,auth_dev_km_hm1,HM1')\n\nend role\n\n\nrole session(DEV:agent,KM:agent,\n\tH,H4B:hash_func,\n\tD,ND,NWS:text)\n\ndef=\nlocal SND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\ndevice (DEV,KM,H,H4B,D,ND,NWS,SND1,RCV1)\n/\\keymanager (KM,DEV,H,H4B,D,ND,NWS,SND2,RCV2)\n\nend role\n\nrole environment()\ndef=\n\tconst\n\tdev,km:agent,\n\th,h4b:hash_func,\n\td,nd,nws:text,\n\tnonce, hm, hm1, hnws, hnd : message,\n\tsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\n\tintruder_knowledge = {dev, km, nonce, hm, hm1, hnws, hnd, d}\n\n\tcomposition\n\t\tsession(dev,km,h,h4b,d,nd,nws)\n\t\t/\\ session(km,dev,h,h4b,d,nd,nws) \n\t\t\n\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\t%%authentication_on auth_dev_km_hm1\nend goal\nenvironment()\n```"]], "HLPSL-1/device_registration.hlpsl": [[false, "```\nhouzhui\n%%% activation  \n%%% 1. device -> AS: SD.R1.{Hash(SD.R1)}_PS               SD,R1,HMAC(PS,SD||R1)    ->  SD,R1,En(PS,Hash(SD||R1)) \n%%% 2. AS -> device: SD.R2.{DS}_PS.{Hash(SD.R2.{DS}_PS)}_PS       SD,R2,En(PS,DS),HMAC(PS,SD||R2||En(PS,DS))\n%%% 3. device -> AS: SD.R3.{R2}_DS                         SD,R3,En(DS,R2)\n%%% 4. AS -> device: {R3}_DS                                En(DS,R3)\n\nrole device(SD,AS:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by SD\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(start) =|>\n           State':=1 /\\ R1':=new() /\\ SND(SD.R1'.{Hash(SD.R1')}_PS)  %Here I use En(PS, Hash(SD || R1)) instead of HMAC(PS, SD || R1)\n\n        2. State=1 /\\ RCV(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) =|>\n           State':=2 /\\ R3':=new() /\\ SND(SD.R3'.{R2'}_DS') /\\ request(SD,AS,auth_r2,R2')\n\n        3. State=2 /\\ RCV({R3}_DS) =|>\n\t   State':=3 /\\ request(SD,AS,auth_r3,R3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authserver(AS,SD:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by AS\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(SD.R1'.{Hash(SD.R1')}_PS) =|>\n           State':=1 /\\ DS':=new() /\\ R2':=new() /\\ SND(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) /\\ secret(DS',sec_ds,{AS,SD}) \n\n        2. State=1 /\\ RCV(SD.R3'.{R2}_DS) =|>\n           State':=2 /\\ SND({R3'}_DS) /\\ witness(AS,SD,auth_r3,R3') /\\ witness(AS,SD,auth_r2,R2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(SD,AS:agent,PS:symmetric_key,Hash:hash_func)\ndef=\n    local\n        SND2,RCV2,SND1,RCV1:channel(dy)\n    composition\n        device(SD,AS,PS,Hash,SND1,RCV1) /\\\n        authserver(AS,SD,PS,Hash,SND2,RCV2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n    const\n        sd1,sd2,as:agent,\n        ps:symmetric_key,\n        myhash:hash_func,\n        sec_ds,auth_r2,auth_r3:protocol_id\n\n        intruder_knowledge = {sd1, sd2, as, myhash}\n        composition\n            session(sd1,as,ps,myhash)\n            /\\ session(sd2,as,ps,myhash)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    secrecy_of sec_ds\n    authentication_on auth_r2\n    authentication_on auth_r3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/DHCP-delayed-auth.hlpsl": [[false, "```houzhui\n%% PROTOCOL: DHCP-Delayed-Auth\n%% PURPOSE:\n%%    Delayed entity and message authentication for DHCP\n%%\n%% REFERENCE: RFC 3118, \\url{http://www.faqs.org/rfcs/rfc3118.html}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%%1. C -> S : C, delayedAuthReq, Time1\n%%2. S -> C : S, delayedAuthReq, succ(Time1), KeyID(K), \n%%            H(S, delayedAuthReq, succ(Time1), K)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%The RFC describes different options and checks in terms of key words MAY, MUST etc.\n%%This model is of the minimum protocol, i.e. only the MUST checks.\n%%In real life, message looks like\n%%\\begin{itemize}\n%%\\item 90 (auth requested), \n%%\\item length, \n%%\\item 1 (for delayed auth), \n%%\\item 1 (to indicate standard HMAC algorithm),\n%%\\item 0 (standard Replay Detection Mechanism, monotonically increasing counter),\n%%\\item counter value.\n%%\\end{itemize}\n%%We ignore length field (as it cannot be, yet, expressed in HLPSL), \n%%use fresh nonce to model RDM, and\n%%assume 'DelayedAuthReq' token is enough to specify algorithm, type of auth,\n%%and type of RDM.\n%%\n%%The server returns the nonce + 1 (or \\verb|succ(nonce)| to be exact) \n%%instead of a timestamp with a higher value.\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%%\n%% NOTES: Client is the initiator. Sends a DHCP discover and requests authentication\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Snd(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ request(C,S,sig,Sig') \n      /\\ secret(K,sec_k,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S  : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/AAAMobileIP.hlpsl": [[false, "```\n   2. State = __1__\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n              KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n               KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_AAAHAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAH (AAAH,__AAAL__,__HA__,__FA__,__MN__ : agent,\n           Snd, Rcv : channel(dy),\n           K_MnAAAH,\n           K_AAAHAAAL,\n           KAAAHHa : symmetric_key)\nplayed_by AAAH\ndef=\n\n  local  __State__                : nat,\n\t K_FaHa,K_MnHa,K_MnFa : symmetric_key\n\n  const  secFAHA, __secFAMN__, __secMNHA__   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State   = 0\n      /\\ __Rcv__(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH)\n      =|> \n      State' := 1\n      /\\ K_MnHa' := new()\n      /\\ K_MnFa' := new()\n      /\\ K_FaHa' := new()\n      /\\ Snd( MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                 {K_MnFa'.K_MnHa'}_K_MnAAAH.\n                 {MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                     {K_MnFa'.K_MnHa'}_K_MnAAAH}_KAAAHHa)\n      /\\ __request__(AAAH,__FA__,k_faha1,K_FaHa')\n      /\\ witness(AAAH,__FA__,__k_faha1__,K_FaHa')\n      /\\ witness(AAAH,__FA__,k_mnfa1,__K_MnFa'__)\n      /\\ witness(AAAH,MN,__k_mnfa2__,__K_MnFa'__)\n      /\\ __request__(__AAAH__,MN,k_mnha2,K_MnHa')\n      /\\ __witness__(AAAH,__HA__,k_mnha1,K_MnHa')\n\n   2. State = 1\n      /\\ Rcv( {K_MnFa.K_MnHa}_K_MnAAAH.\n              {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n               {{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_KAAAHHa)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n\t     {FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_K_AAAHAAAL)\t\n      /\\ secret(K_FaHa,__secFAHA__,{FA,__AAAH__}) \n      /\\ __secret__(K_MnFa,__secFAMN__,{FA,MN})\n      /\\ secret(K_MnHa,__secMNHA__,{__MN__,HA})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_HA (HA,AAAH,__MN__: __agent__,\n                 Snd,__Rcv__: channel(dy),\n                 K_AAAHHa: symmetric_key)\nplayed_by HA\ndef=\n\n  local\n    State                 : nat,\n    K_MnFa,K_FaHa, K_MnHa : symmetric_key,\n    KeyMnFaKeyMnHa        : {symmetric_key.symmetric_key}_symmetric_key\n\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv( MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'.\n             {MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'}_K_AAAHHa) \n      =|> \n      State' := 1\n      /\\ Snd( KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'.\n             {KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'}_K_AAAHHa)\n      /\\ wrequest(HA,AAAH,k_faha2,K_FaHa')\n      /\\ wrequest(HA,AAAH,k_mnha1,K_MnHa')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole __session__(MN,FA,AAAL,AAAH,HA: __agent__,\n\t     Kmn3ah,__Kfa3al__,__K3ah3al__,__Kha3ah__: __symmetric_key__) def=\n\n   local     MNs,__MNr__,\n\t     FAs,FAr,\n\t     Ls, Lr,\n\t     Hs, Hr,\n\t     HAs, HAr: channel(dy)\n\n   composition\n\n           aaa_MIP_MN(MN,AAAH,FA,MNs,MNr,Kmn3ah)\n\n        /\\ aaa_MIP_FA(FA,AAAL,AAAH,MN,FAs,FAr,Kfa3al)\n  \n        /\\ aaa_MIP_AAAL(AAAL,AAAH,FA,MN,Ls,Lr,Kfa3al,K3ah3al)\n\n        /\\ aaa_MIP_AAAH(AAAH,AAAL,HA,FA,MN,Hs,Hr,Kmn3ah,K3ah3al,Kha3ah)\n         \n        /\\ aaa_MIP_HA(HA,AAAH,MN,HAs,HAr,Kha3ah)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole __main__() def=\n\n  const k_mnha1, __k_mnfa1__, k_faha1                    : __protocol_id__,\n        k_mnha2, k_mnfa2, k_faha2                    : protocol_id,\n        mn, fa, aaal, aaah, ha                       : agent,\n        k_mn_aaah, k_fa_aaal, k_aaah_aaal, k_ha_aaah : symmetric_key\n\n  intruder_knowledge = {mn,fa,aaal,aaah,ha}\n\n  composition\n\n\tsession(mn,fa,aaal,aaah,ha,\t                    %%% Agents\n\t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%\t/\\ session(i,mn,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_i_aaah,k_mn_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%     intruder_knowledge += {k_i_aaah}\n%%%\t/\\ session(mn,i,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_mn_aaah,k_i_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,i,aaah,ha,\t              %%% Agents\n%%% % \t\tk_mn_aaah,k_fa_i,k_aaah_i,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,aaal,i,ha,\t           %%% Agents\n%%% % \t\tk_mn_i,k_fa_aaal,k_i_aaal,k_ha_i)  %%% Shared Keys\n%%%\t/\\ session(mn,fa,aaal,aaah,i,\t                   %%% Agents\n%%% \t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_i_aaah)  %%% Shared Keys\n\nend role\n\n__goal__\n\n  %secrecy_of K_MnFa, K_FaHa, K_MnFa\n  secrecy_of secFAHA, secFAMN, secMNHA % addresses G12\n\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_faha1\n  weak_authentication_on k_faha1 % addresses G1,G7,G10\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_mnfa1\n  weak_authentication_on k_mnfa1 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_faha2\n  weak_authentication_on k_faha2 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_mnha1\n  weak_authentication_on k_mnha1 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnha2\n  weak_authentication_on k_mnha2 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnfa2\n  weak_authentication_on k_mnfa2 % addresses G1,G7,G10\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/DPP-I.hlpsl": [[true, "%   the enrollee.\n%3. Configuration Protocol: Once the enrollee is authenticated, it sends a DPP configuration request\n%   (requesting configurator for its configuration information) encrypted by the session key. The\n%   configurator responds with the configuration credential in the form of a configuration object\n%   secured by the session key. The configuration object could be a passphrase, password, or a DPP\n%   connector. In our implementations, the DPP connector has been taken as the configuration object.\n%\tDPP connector is basically a certificate from the configurator, containing the public-protocol\n%   key of the enrollee signed by the configurator. Using this, the enrollee can connect to the\n%   network and the other devices on the network.\n\n\n\nrole configurator(C : agent, E : agent,\n\t   Mx, Nx, Lx: symmetric_key,  \n           H : hash_func,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local Ni, Nc, Nr, temp_v1, temp_v2, temp_v3, PMS: text, %% temp_v1, temp_v2, temp_v3 are placeholders for other potential local variables as per template structure, type text\n\t Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, sec_iauth, sec_k2, auth_nr : text,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ secret(K1,sec_k1,{C,E})\n\t\t/\\ request(C,E,auth_ni,Ni)\n\t\t\n  3.  State = 3\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ secret(Iauth,sec_iauth,{C,E})\n\t\t/\\ request(E,C,auth_nr,Nr)\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n       \n\n\nend role\n\n\n\nrole enrollee(C : agent, E : agent,\n\t Mx, Nx, Lx: symmetric_key,\n         H : hash_func,\n         Br, Pr, Kca: public_key,\n         SND, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local Nr, Ni, Na, temp_v4, temp_v5, Ne, Sid, PMS: text, %% temp_v4, temp_v5 are placeholders for other potential local variables as per template structure, type text\n\t Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, sec_iauth, sec_ne, auth_ni, auth_nr : text,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       %/\\ Chirp' := 'Chirping'\n       /\\ SND(H(chirp.Br))\n   2. State = 2 /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(Nr,sec_nr,{E,C})\n\t\t/\\ request(C,E,auth_ni,Ni)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{E,C})\n\t\t/\\ request(E,C,auth_ni,Ni)\n\t\n\n  6.  State = 6 /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(C,E: agent,\n\t     Mx, Nx, Lx: symmetric_key,\n             H : hash_func,\n             Bi, Pi, Br, Pr, Kca: public_key)\ndef=\n\n   local SC, SR, RC, RR: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(i,e,mx,nx,lx,h,kib,kip,br,pr,kca)\n%   /\\  session(c,i,mx,nx,lx,h,bi,pi,kib,kip,kca)\n\nend role\n\n\n\ngoal\n\n  secrecy_of sec_k1, sec_k2, sec_iauth, sec_ne  \n  authentication_on auth_ni, auth_nr  \n  authentication_on auth_ne  \n  \nend goal", "```hlpsl\n%   the enrollee.\n%3. Configuration Protocol: Once the enrollee is authenticated, it sends a DPP configuration request\n%   (requesting configurator for its configuration information) encrypted by the session key. The\n%   configurator responds with the configuration credential in the form of a configuration object\n%   secured by the session key. The configuration object could be a passphrase, password, or a DPP\n%   connector. In our implementations, the DPP connector has been taken as the configuration object.\n%\tDPP connector is basically a certificate from the configurator, containing the public-protocol\n%   key of the enrollee signed by the configurator. Using this, the enrollee can connect to the\n%   network and the other devices on the network.\n\n\n\nrole configurator(C : agent, E : agent,\n\t   Mx, Nx, Lx: symmetric_key,  \n           H : hash_func,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local Ni, Nc, Nr, temp_v1, temp_v2, temp_v3, PMS: text, %% temp_v1, temp_v2, temp_v3 are placeholders for other potential local variables as per template structure, type text\n\t Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, sec_iauth, sec_k2, auth_nr : text,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ secret(K1,sec_k1,{C,E})\n\t\t/\\ request(C,E,auth_ni,Ni)\n\t\t\n  3.  State = 3\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ secret(Iauth,sec_iauth,{C,E})\n\t\t/\\ request(E,C,auth_nr,Nr)\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n       \n\n\nend role\n\n\n\nrole enrollee(C : agent, E : agent,\n\t Mx, Nx, Lx: symmetric_key,\n         H : hash_func,\n         Br, Pr, Kca: public_key,\n         SND, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local Nr, Ni, Na, temp_v4, temp_v5, Ne, Sid, PMS: text, %% temp_v4, temp_v5 are placeholders for other potential local variables as per template structure, type text\n\t Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, sec_iauth, sec_ne, auth_ni, auth_nr : text,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       %/\\ Chirp' := 'Chirping'\n       /\\ SND(H(chirp.Br))\n   2. State = 2 /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(Nr,sec_nr,{E,C})\n\t\t/\\ request(C,E,auth_ni,Ni)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{E,C})\n\t\t/\\ request(E,C,auth_ni,Ni)\n\t\n\n  6.  State = 6 /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(C,E: agent,\n\t     Mx, Nx, Lx: symmetric_key,\n             H : hash_func,\n             Bi, Pi, Br, Pr, Kca: public_key)\ndef=\n\n   local SC, SR, RC, RR: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(i,e,mx,nx,lx,h,kib,kip,br,pr,kca)\n%   /\\  session(c,i,mx,nx,lx,h,bi,pi,kib,kip,kca)\n\nend role\n\n\n\ngoal\n\n  secrecy_of sec_k1, sec_k2, sec_iauth, sec_ne  \n  authentication_on auth_ni, auth_nr  \n  authentication_on auth_ne  \n  \nend goal\n```"]], "HLPSL-1/drone_to_gss_protocol.hlpsl": [[false, "```\nglobal\n    ____(VARIABLE_6)____: agent,\n    SKcrdr: symmetric_key,\n    %%% F is ECC point mutiplication operation\n    F, Add, Poly: hash_func,\n    G, MKdrj, Rdrj, Pubdrj : text,\n    IDdrj, IDgss, IDcr, RTSdrj, Rcr, Rdr, TSdr, Adr: text,\n    Adr1, Rgss, RTSgss, TSgss, Bgss, Rgss1: text,\n    TSdr1, ACKdrgss: text\nconst ____(VARIABLE_5)____, ____(VARIABLE_3)____, dr_gss_rdr, ____(VARIABLE_2)____, ____(VARIABLE_4)____, gss_dr_rgss1, gss_dr_tsgss : protocol_id\n\ninit State := 0\ntransition\n%%%Drone registration phase\n%%%Receive registration message securely from the CR\n1. State = ____(STATE_2)____ /\\ Rcv({IDdrj.IDgss.H(____(MESSAGE_33)____).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr')}_SKcrdr) =|>\nState' := 2 /\\ ____(EVENT_5)____({Rcr',Rdrj', RTSdrj',____(EVENT_6)____}, ____(EVENT_7)____, {CR})\n\n%%% Access control phase\n    /\\ Rdr' := new() /\\ TSdr' := new()\n    /\\ Adr' := H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr')\n    /\\ Adr1' := F(Adr'.G)\n\n%%% Send message Msg1 to GSS via public channel\n    /\\ ____(MESSAGE_34)____(IDdrj.Adr1'.Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')\n\n%% DRj has freshly generated the values rdrk and TSdrk for GSS that are induded in Msg1\n    /\\ ____(EVENT_9)____(DR, GSS, ____(EVENT_8)____, Rdr')\n    /\\ witness(DR, ____(EVENT_10)____, dr_gss_tsdr, ____(EVENT_11)____)\n\n%%% Receive message Msg2 from the GSS via public channel\n2. State = 2 /\\ Rcv(IDgss.F(H(IDgss.H(____(MESSAGE_35)____).Rgss1'.TSgss').G).\n                H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr).\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'. TSgss').\n                F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).TSgss'.IDgss).\n                TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')) =|>\n\nState' := 4 /\\ TSdr1' := new()\n        /\\ ACKdrgss' := H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G)).\n            Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n            Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr').TSdr'.TSgss').TSdr1')\n\n%%% Send message Msqg3 to GSS via public channel\n        /\\ Snd(____(MESSAGE_36)____)\n\n%% DRj has freshly generated the value TSdr1 for GSS that is included in Msg3\n        /\\ ____(EVENT_13)____(DR, GSS, ____(EVENT_12)____, TSdr1')\n\n% DRj's acceptance of the values rgss1, TSgss (message Msq2) for GSS by DRj\n        /\\ request(____(EVENT_14)____, DR, ____(EVENT_15)____, Rgss1')\n        /\\ ____(EVENT_16)____(GSS, DR, ____(EVENT_17)____, TSgss')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GSS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole ____(ROLE_1)____(____(PARAM_10)____, ____(PARAM_8)____, GSS: agent,\n        ____(PARAM_11)____: ____(PARAM_9)____,\n        Snd, Rcv: channel(dy))\n\n% Player: GSS\nplayed_by GSS\ndef=\nlocal State: nat,\n            SKcrgss: symmetric_key,\n%%% F is ECC point mutiplication operation\n            F, Add: hash_func,\n            Poly: hash_func,\n            G, MKdrj, Rdrj, Pubdrj : text,\n            IDdrj, IDgss, IDcr, Rgss, RTSgss, Rcr: text,\n            RTSdrj, Rdr, TSdr, Rgss1, TSgss, DKgss, Bgss, Bgss12: text,\n            SKgssdr, SKVgssdr, TSdr1: text\n\nconst ____(VARIABLE_7)____, sp2, dr_gss_rdr, dr_gss_tsdr, ____(VARIABLE_9)____, gss_dr_rgss1, ____(VARIABLE_8)____: ____(VARIABLE_10)____\n\ninit State := 0\ntransition\n%%% GSS registration phase\n%%% receive registration message securely from the CR\n1. State = 0 /\\ ____(MESSAGE_37)____({IDdrj.IDgss. H(IDgss.IDcr.Rgss'.RTSgss').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')}_SKcrgss) =|>\nState' := 3 /\\ secret({____(EVENT_19)____,Rgss'}, ____(EVENT_18)____, {CR})\n\n%%% Access control phase\n%%% Receive message Msq1 from the DRj via public channel\n2. State = ____(STATE_1)____ /\\ ____(MESSAGE_38)____(IDdrj.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')=|>\nState' := 5 /\\ Rgss1' := new() /\\ TSgss' := new() /\\ RTSgss' := new() /\\ Rgss' := new()\n            /\\ Bgss' := H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss')\n            /\\ Bgss12' := F(Bgss'.G)\n            /\\ DKgss' := F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G))\n            /\\ SKgssdr' := H(DKgss'.Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss')\n\n            /\\ SKVgssdr' := H(SKgssdr'.Bgss12'.TSgss'.IDgss)\n%%% Send message Msg? to the drone via public channel\n            /\\ ____(MESSAGE_39)____(IDgss.Bgss12'.SKVgssdr'.TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'))\n%% GSS has freshly generated the values rgss1 and TSgss for DRj that are induded in Msg2\n            /\\ witness(GSS, DR, ____(EVENT_20)____, ____(EVENT_21)____)\n            /\\ witness(____(EVENT_23)____, DR, gss_dr_tsgss, ____(EVENT_22)____)\n\n%%% Receive message Msg3 from the drone via public channel\n3. State = 5 /\\ Rcv(H(H(F(Bgss'.F(H(IDdrj.H(____(MESSAGE_40)____).Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss').TSdr1').TSdr1') =|>\n\n% GSS's acceptance of the values rdr, TSdr (message Msg1) and TSdr1 (message Msg3) for GSS by DRj\n\nState' := 7 /\\ request(DR, ____(EVENT_25)____, dr_gss_rdr, ____(EVENT_24)____)\n        /\\ request(DR, GSS, ____(EVENT_27)____, ____(EVENT_26)____)\n        /\\ request(DR, ____(EVENT_28)____, dr_gss_tsdr1, ____(EVENT_29)____)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole ____(ROLE_0)____ (CR, DR, ____(PARAM_14)____: ____(PARAM_13)____,\n            ____(PARAM_12)____: hash_func)\ndef=\n    local Sn1, Sn2, ____(VARIABLE_12)____, Rv1, ____(VARIABLE_11)____, Rv3: channel (____(VARIABLE_13)____)\n    composition\n        controlroom (CR, DR, GSS, H, Sn1, Rv1)\n        /\\ drone (CR, DR, GSS, H, Sn2, Rv2)\n        /\\ groundserver (CR, DR, GSS, H, Sn3, Rv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n    const cr, dr, gss: ____(VARIABLE_14)____,\n        h, f, add, poly: hash_func,\n        tsdr, tsdr1, tsgss: text,\n        sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\n    intruder_knowledge = {cr, dr, gss, h, f, add, poly, tsdr, tsdr1, tsgss}\n\n    composition\n        session(cr, dr, gss, h)\n        /\\ session(cr, i, gss, h)\n        /\\session(cr, dr, i, h)\nend role\n\ngoal\n\n%%% Authentication\nauthentication_on ____(GOAL_41)____, dr_gss_tsdr, ____(GOAL_42)____\n____(GOAL_43)____ gss_dr_rgss1, gss_dr_tsgss\n\n%%% Confidentiality\nsecrecy_of ____(GOAL_44)____, sp2\n\nend goal\nenvironment()\n```"]], "HLPSL-1/Dynamic_group_key_distribution_scheme_with_three-factor_identification_for_IoT_environments.hlpsl": [[false, "```\n SKij, GkiAT: symmetric_key, Kus: symmetric_key: symmetric_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new()\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(IDi,g1,{U}) /\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n2.  State = 1 /\\ RCV({IDi.Nj.({H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj)}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi and Bi in the smart card\n%/\\ Store Ej, IDj and Nj in the USB\n\n% Login and authentication procedure\n\n3.  State = 2 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card\n%/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose b = 3\n/\\ N' := H(H(H(V')))\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n/\\ Tu' := new()\n/\\ A' := xor(xor(BBi',W'),Tu')\n/\\ Yij' := xor(E,Ej)\n/\\ K' := {IDj.IDi.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_tu,Tu')\n/\\ authentication_on(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g10,{U,S})\n/\\ secret(PWi,g3,{U})\n/\\ secret(Bi,g12,{U})\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts'\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n%/\\ Confirm B\n%/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts')\n/\\ Gki' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n%/\\ Obtain ATia, ATib, Ti1 and Ti2 from Cki'\n/\\ GkiAT' := H(H1(H6(H(Xj.As))).H2(H14(H(Xj.Bs))))\n/\\ request(S,U,s_u_ts,Ts')\n\n% Dynamic key derivation procedure\n\n5. State = 0 /\\ RCV({H6(H(Xj.As.M')).H14(H(Xj.Bs.M'))}_GkiAT') =|>\nState':= 1\n/\\ GkiAT' := H(H2(H6(H(Xj.As))).H1(H14(H(Xj.Bs))))\n%/\\ Use CkiAT to decrypt Q1 and obtains ATia' = H6(H(Xj.As.M')) and ATib' = H14(H(Xj.Bs.M'))\n/\\ GkiATNew' := H(H2(H6(H(Xj.As.M'))).H1(H14(H(Xj.Bs.M'))))\n/\\ request(S,U,s_u_m,M')\n\nend role\n\n\nrole server (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func, SS, RCV: channel (RS))\nplayed_by S def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, X, Y, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({Nj.Yij'}_Kus)\n/\\ secret(IDj,g5,{S})\n\n% Login and authentication procedure\n\n2. State = 0 /\\ RCV({IDj.IDi.{H(Xj).IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj.H(H(H(V'))).xor(xor(H(PWi.Bi),H(H(PWi.E).xor(h(xor(IDi,IDj)),E))),Tu').Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu'\n%/\\ Use Xj to decrypt Yij\n%/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi,W),Tu')\n%/\\ Confirm A\n/\\ Ts' := new()\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n/\\ IDinew' := H(Yij.IDi.H(Xj))\n/\\ SKij' := H(xor(H(H(H(V'))),Yij))\n/\\ As' := new() /\\ Bs' := new()\n/\\ Ti1' := new() /\\ Ti2' := new()\n%/\\ Z =24, suppose Ti1=7, Ti2=10\n/\\ ATia' := H6(H(Xj.As'))\n/\\ ATib' := H14(H(Xj.Bs'))\n/\\ Gki' := (ATia'.ATib'.Ti1'.Ti2')\n/\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion.\n/\\ C1' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C2').Mul(Hi'.C3'))).Hi')\n/\\ C2' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C3'))).Hi')\n/\\ C3' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C2'))).Hi')\n/\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ secret(As,g6,{S}) /\\ secret(Bs,g7,{S}) /\\ secret(Ti1',g8,{U,S}) /\\ secret(Ti2',g9,{U,S})\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ authentication_on(U,S,u_s_v,V')\n/\\ request(U,S,u_s_tu,Tu')\n\n% Dynamic key derivation procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ M' := new()\n/\\ ATia' := H6(H(Xj.As.M'))\n/\\ ATib' := H14(H(Xj.Bs.M'))\n/\\ X' := H(Xj.As)\n/\\ Y' := H(Xj.Bs)\n%/\\ Suppose current T = 9\n/\\ GkiAT' := H(H8(X').H15(Y'))\n/\\ Q1' := {ATia'.ATib'}_GkiAT'\n/\\ SND (Q1')\n/\\ authentication_on(S,U,s_u_m,M')\n/\\ secret(ATia,g13,{U,S})\n/\\ secret(ATib,g11,{U,S})\n\nend role\n\nrole session (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SU,RU)\n/\\ server (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SS,RS)\n\nend role\n\nrole environment() def=\n\nconst u, s: agent,\nkus, skij, gkiat, kui: symmetric_key,\nks, ki: public_key,\nh, h1, h2, h4, h5, h6, h8, h14, h15, sub, add, mul, div: hash_func,\ng1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, u_s_v, u_s_tu, s_u_ts, s_u_m: protocol_id\n\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\n\ncomposition\n\nsession(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(u,i,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(i,s,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n\nend role\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11\nauthentication_on u_s_v, u_s_tu, s_u_ts, s_u_m\n\nend goal\n```"]], "HLPSL-1/eap-lorawan.hlpsl": [[false, "```\nPSUCCESS : message,\n\t\t\tMICAAA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\t\tState' := 1 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') =|>\n\t\t\t\tState' := 3 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA')\n\n\t\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authentication_server_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AUSF \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\ti, j, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse, EAPLoRaWANCN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationResponse.{NwkKey'}_SK) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANCN.EAPRQST.ED) \n\t\t\t\t\t\t\t\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') \n\t\t\t\t\t\t\t/\\ MICJR'=H(JoinEUI'.DevEUI'.DevNonce'.NwkKey) =|>\t\t\t\t\t\n\t\t\t\tState' := 2 /\\ MICJA':=H(JoinNonce'.NwkKey)\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\t\t\t\t\t\t\t/\\ request(auth_ed_cn,ED,AUSF,NwkKey)\n\t\t\t\t\t\t\t/\\ witness(AUSF,auth_ed_cn,ED,NwkKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole unified_data_management (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, K,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by UDM \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\ti : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ SND(AuthenticationResponse.{NwkKey'}_SK)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_server (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, AppKey : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AAA \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\ti, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tSessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') /\\ MICAAA' = H(JoinEUI'.DevEUI'.DevNonce'.AppKey) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\t\t\t\t\t\t\t/\\ witness(AAA,ED,auth_dn_ed,AppKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, JoinEUI,DevEUI : nat , K,AppKey,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\n\tdef=\n\t\tcomposition\t\n\t\t\tend_device(ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey,H,SND,RCV)\n\t\t\t/\\\n\t\t\tg_node_b(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\taccess_and_mobility_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tsession_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tauthentication_server_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\tunified_data_management(ED,GNB,AMF,SMF,AUSF,UDM,AAA,K,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\taaa_server(ED,GNB,AMF,SMF,AUSF,UDM,AAA,AppKey,H,SND,RCV)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole enviroment() \n\n\tdef=\n\n\t\tconst\t\n\t\t\ted,gnb,amf,smf,ausf,udm,aaa : agent,\n\t\t\tjoineui,deveui : nat,\n\t\t\th : hash_func,\n\t\t\tk,appkey,sk : symmetric_key,\n\t\t\tsnd,rcv\t: channel(dy),\n\t\t\t\n\t\t\tauth_cn_ed, auth_ed_cn, auth_dn_ed : protocol_id\n\n\t\tintruder_knowledge = {ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,h,i}\n\n\t\tcomposition\n\t\t\tsession(ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,k,appkey,sk,h,snd,rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n\tauthentication_on auth_cn_ed\n\tauthentication_on auth_ed_cn\n\tauthentication_on auth_dn_ed\n\nend goal\n\nenviroment()\n```"]], "HLPSL-1/EKE2.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: EKE2\n%% VARIANT: EKE2 (with mutual authentication)\n%% PURPOSE: Encrypted key exchange with mutual authentication\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : A.{exp(g,X)}_K(A,B)\n%%\n%%     B computes master key MK\n%%     MK = H(A,B,exp(g,X),exp(g,Y),exp(g,XY))\n%%\n%% 2. B -> A : {exp(g,Y)}_K(A,B), H(MK,1)\n%%\n%%      A computes master key MK\n%%\n%% 3. A -> B : H(MK,2)\n%%\n%%      Session key K = H(MK,0)\n%%\n%% H : hash function\n%% K(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%         \n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%%\n%% NOTES: For information, this protocol is an example of  \n%% the proposition done in \n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html} showing that\n%% any secure AKE (Authentication Key Exchange) protocol can be easily \n%% improved to also provide MA (Mutual Authentication).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke2_Init (A,B : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n             \tSnd,Rcv: channel(message))\nplayed_by A\ndef=\n\n  local State     : int, \n\tX         : text, \n\tGY        : message,\n        MK_A,MK_B : message\n\n  const one : text,\n        sec_i_MK_A : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(start) =|> \n      State':= 1 /\\ X' := new()\n                 /\\ Snd(A.{exp(G,X)}_Kab) \n\n   2. State = 1  /\\ Rcv({GY'}_Kab.H(H(A.B.exp(G,X).GY'.exp(GY',X)).one)) =|> \n      State':= 2 /\\ MK_A' := A.B.exp(G,X).GY'.exp(GY',X)\n\t\t /\\ MK_B' := MK_A'% Message authentication (G2)\n\t\t /\\ Snd(H(H(MK_A').two)) \n\t\t /\\ secret(MK_A',sec_i_MK_A,{A,B})\n\t\t /\\ request(A,B,mk_a,MK_A')\n\t\t /\\ witness(A,B,mk_b,MK_B') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke2_Resp (B,A : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n                Snd,Rcv : channel(message))\nplayed_by B\ndef=% Message authentication (G2)\n\n  local State     : int, \n\tY         : text,\n\tGX        : message,\n        MK_A,MK_B : message\n\n  const one : text,\n        sec_r_MK_B : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(A.{GX'}_Kab) =|> \n      State':= 1 /\\ Y' := new()\n                 /\\ MK_B' := A.B.GX'.exp(G,Y').exp(GX',Y')\n                 /\\ MK_A' := MK_B'\n\t\t /\\ Snd({exp(G,Y')}_Kab.H(H(MK_B').one))\n\t\t /\\ secret(MK_B',sec_r_MK_B,{A,B})% Message authentication (G2)\n\t \t /\\ witness(B,A,mk_a,MK_A')\n\n   2. State = 1  /\\ Rcv(H(H(MK_B).two)) =|> \n      State':= 2 /\\ request(B,A,mk_b,MK_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n              G: text,\n\t      H: hash_func,\n\t      Kab: symmetric_key) def=\n\n   local   SA,RA,SB,RB: channel(message)\n\n   composition\n\n           eke2_Init(A,B,G,H,Kab,SA,RB)  /\\\n           eke2_Resp(B,A,G,H,Kab,SB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Message authentication (G2)\n\nrole environment() def=\n\n  const sec_i_MK_A, sec_r_MK_B  : protocol_id,\n        a,b,c       : agent,\n        kab,kai,kib : symmetric_key,\n        g           : text,\n        h           : hash_func\n\n  intruder_knowledge  = {a,b,c,kai,kib}\n\n  composition\n\n\tsession(a,b,g,h,kab) /\\\n\tsession(a,i,g,h,kai) /\\\n\tsession(i,b,g,h,kib)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  % secrecy_of MK\n  secrecy_of sec_i_MK_A, sec_r_MK_B\n\n  % Message authentication (G2)\n  % Eke2_Init authenticates Eke2_Resp on mk_a\n  authentication_on mk_a\n\n  % Message authentication (G2)\n  % Eke2_Resp authenticates Eke2_Init on mk_b\n  authentication_on mk_b\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()```"]], "HLPSL-1/EVauthenticate.hlpsl": [[false, "```houzhui\nrole_EV(\n  EV,GNB,SMF                 : agent,\n  C1                         : text,\n  H,PUF1,PRNG                : hash_func,\n  SND,RCV                    : channel(message))\nplayed_by EV def=\n  \n  local\n    State         :nat,\n\tN2,N3         :text,\n\tR1,N2M,N3M    :hash(text),\n\tSK            :hash(hash(text).hash(text).text),\n\tZ             :message\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(N2') =|>\n     State' := 2 /\\ N2M' := PRNG(N2') /\\ R1':= PUF1(C1) /\\ N3' := new() /\\ SND({R1'.N3'}_N2M')\n\t\t\t\t /\\ witness(EV,SMF,ev_smf_r1,R1') /\\ witness(EV,SMF,ev_smf_n3,N3')\n  2. State = 2 /\\ RCV(Z') /\\ R1 = xor(Z',N3)=|>\n     State' := 4 /\\ SK' := H(N2M.N3)\n\t\t\t\t /\\ request(EV,GNB,gnb_ev_n2,N2)\n\t\t\t\t /\\ request(EV,SMF,ev_smf_z,Z')\n\t\t\t\t /\\ secret(sk,sk,{EV,SMF})\n\nend role_EV\n\nrole role_GNB(\n  EV,GNB,SMF                    : agent,\n  C2                            : text,\n  H,PUF2                        : hash_func,\n  SND,RCV                       : channel(message))\nplayed_by GNB def=\n  \n  local\n    State             :nat,\n\tN1,N2             :text,\n\tR2                :hash(text)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ N1' := new() /\\ R2':= PUF2(C2) /\\ SND({N1'}_R2')\n\t             /\\ witness(GNB,SMF,gnb_smf_n1,N1')\n  2. State = 2 /\\ RCV({N2'}_N1) =|>\n     State' := 4 /\\ SND(N2')\n\t             /\\ witness(GNB,SMF,smf_gnb_n2,N2')\n\t\t\t\t /\\ witness(GNB,EV,gnb_ev_n2,N2')\n\t\t\t\t \n\nend role\n\n\n\nrole role_SMF(\n  EV,GNB,SMF                 : agent,\n  C1,C2                      : text,\n  H,PUF1,PUF2,PRNG           : hash_func,\n  SND,RCV                    : channel(message))\nplayed_by SMF def=\n  \n  local\n    State                     :nat,\n\tN1,N2,N3               :text,\n\tR1,R2,N2M,N3M,N4M             :hash(text),\n\tSK                        :hash(hash(text).hash(text).text),\n\tZ                         :message\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV({N1'}_R2') /\\ R2' = PUF2(C2) =|>\n     State' := 3 /\\ N2' := new() /\\ N2M' := PRNG(N2') /\\ SND({N2'}_N1')\n\t\t\t\t /\\ witness(SMF,EV,smf_ev_n2,N2')\n  2. State = 3 /\\ RCV({R1'.N3'}_N2M) /\\  R1' = PUF1(C1) =|>\n     State' := 5 /\\ SK' := H(N2M.N3') /\\ Z' := xor(R1',N3') /\\ SND(Z')\n\t\t\t\t /\\ request(SMF,GNB,gnb_smf_n1,N1) /\\ request(SMF,EV,ev_smf_n3,N3') \n\t\t\t\t /\\ request(SMF,EV,ev_smf_r1,R1) /\\ witness(SMF,EV,smf_ev_z,Z') \n\t\t\t\t /\\ secret(SK,sk,{EV,SMF})/\\ secret(R1,r1,{EV,SMF}) \n\t\t\t\t /\\ secret(R2,r2,{GNB,SMF})/\\ secret(N1,n1,{GNB,SMF})\n\t\t\t\t /\\ secret(N2M,n2m,{EV,SMF})/\\ secret(N3',n3,{EV,SMF})\n\n\nend role\n\n\nrole session(\n  EV,GNB,SMF               : agent,\n  C1,C2                    : text,\n  H,PUF1,PUF2,PRNG         : hash_func)\ndef=\n  local SEV,SSMF,SGNB,REV,RSMF,RGNB : channel(message)\n  \n  composition\n    role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SEV,REV) /\\ role_GNB(EV,GNB,SMF,C2,H,PUF2,SGNB,RGNB) /\\ role_SMF(EV,GNB,SMF,C1,C2,H,PUF1,PUF2,PRNG,SSMF,RSMF) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    n1,n2m,n3,r1,r2,z,ev_smf_r1,ev_smf_n3,gnb_smf_n1,gnb_ev_n2,smf_gnb_n2,smf_ev_z   : text,\n    sm,gw,sp                                            : agent,\n    c1,c2,sk0                                           : text,\n    h,puf1,puf2,puf3,puf4,prng1,prng2                                    : hash_func\n  intruder_knowledge = {sm,gw,sp,h,sk0} \n  \n  composition\n    session(sm,gw,sp,c1,c2,h,puf1,puf2,prng1) /\\ session(sm,gw,sp,c1,c2,h,puf3,puf4,prng2)\n\nend role\n\ngoal \n  secrecy_of sk\n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of n1\n  secrecy_of n2m\n  secrecy_of n3\n  authentication_on ev_smf_r1\n  authentication_on ev_smf_n3\n  authentication_on gnb_smf_n1\n  authentication_on gnb_ev_n2\n  authentication_on smf_gnb_n2\n  %%authentication_on smf_ev_z\n\nend goal\n\nenvironment()```"]], "HLPSL-1/GetServAuth.hlpsl": [[false, "```houzhui\nrole role_C(C:agent,W:agent,QR:text,Kc:symmetric_key,Y:text,SND:channel(dy),RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,N:text,F:hash_func\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N':=new() /\\ secret(N',sec_1,{C,W}) /\\ SND({C.QR.N'.Y}_Kc)\n\t\t2. State=1 /\\ RCV({C.F(QR.N).Y}_Kc) =|> State':=2 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N' := new() /\\ secret(N',sec_1,{C,W})\nend role_C\n\nrole role_W(C:agent,W:agent,Kc:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by W\ndef=\n\tlocal\n\t\tState:nat,N:text,QR:text,F:hash_func,Y:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.QR'.N'.Y'}_Kc) =|> State':=1 /\\ secret(Y',sec_2,{C,W}) /\\ secret(N',sec_1,{C,W}) /\\ SND({C.F(QR'.N').Y'}_Kc)\nend role\n\nrole session1(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session2(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session3(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkc:symmetric_key,y:text,i:agent,F:hash_func,qr:text,client:agent,miner:agent,sec_1:protocol_id,sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(y,qr,i,miner,kc) /\\ session2(y,qr,client,i,kc) /\\ session1(y,qr,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()```"]], "HLPSL-1/h.530-fix.hlpsl": [[true, "role mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key_share,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key_authentic,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,MT})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : message\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(VGK,MT,key_share,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ request(VGK,MT,key1,Key)\n                /\\ secret(Key,sec_v_Key,{MT,VGK})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf                    : agent,\n    f                          : hash_func,\n    key, key1                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  authentication_on key1\n  authentication_on key_authentic\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal", "```hlpsl\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key_share,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key_authentic,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,MT})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : message\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(VGK,MT,key_share,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ request(VGK,MT,key1,Key)\n                /\\ secret(Key,sec_v_Key,{MT,VGK})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf                    : agent,\n    f                          : hash_func,\n    key, key1                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  authentication_on key1\n  authentication_on key_authentic\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n```"]], "HLPSL-1/hash_n_single.hlpsl": [[false, "```houzhui\n%% Lamport, L. (1981). \"Password authentication with insecure communication.\" Commun. ACM 24(11): 770-772. -> hash^1000\n%% \u90ed\u4e39\u9752 (2014). \"OAuth2. 0 \u534f\u8bae\u5f62\u5f0f\u5316\u9a8c\u8bc1: \u4f7f\u7528 AVISPA.\" \u8ba1\u7b97\u673a\u7cfb\u7edf\u5e94\u7528 23(11): 196-202. -> AVISPA\t\n\nrole user (\n    U,S : agent,\n    SU,RU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Nah4      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\t       /\\ witness(U,S,user_server_nah4,Nah4')\n\t\t\t   \nend role\n\n\nrole server (\n    U,S : agent,\n    RU,SU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ request(S,U,user_server_nah4,F(F(F(F(PW)))))\n\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,RU,SU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s      : agent,\n    f            : hash_func,\n    user_server_nah4     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah4\n\nend goal\n\n\nenvironment()\n```"]], "HLPSL-1/IIOT.hlpsl": [[false, "```houzhui\n%IIoT\nrole nodeU (U,Gw: agent,Hmac: hash_func,\n            Qca,Qg,Qu: public_key,\n            Dg,Du,Kug: symmetric_key,\n         SND,RU: channel (dy))\nplayed_by U def=\nlocal\nState: nat,\nIdu,Idg,Certu,Certg,Su,Sg,Ts0,\nTs1,Lt0,Lt1,N5,Au,Ag,H4:text,\nM5: message\ninit State:= 0\ntransition\n1. State = 0 /\\ RCV(start) =|>\n  State':= 1 /\\ N5' := new()\n             /\\ Ag' := {Idg.Certg.Sg.Ts0.Lt0}_Qca\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ M5' := {Idg.N5.Au.H4}_Qg\n             /\\ SND(M5')\n             /\\ secret({Idg,Idu},sub1,{N5,Au})\nend role\n\nrole gateway (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key,\n           SGw,RCV: channel (dy))\nplayed_by Gw def=\nlocal\nState :nat,\nIdu,Idg,Certu,Su,\nTs1,Lt1,N5,Au,H4:text,\nM5: message\ninit State:= 1\ntransition\n1. State = 1 /\\ RCV(M5') =|>\n  State':= 2 /\\ M5' := {Idg.N5.Au.H4}_Dg\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ claim(Gw,U,nodeU_gateway_n5,N5)\n             /\\ witness(Gw,U,nodeU_gateway_lt1,Lt1) \nend role\n\nrole session (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key)\ndef=\nlocal SU,RU,SGw,RGw: channel(dy)\ncomposition\n  nodeU(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SU,RU)\n/\\gateway(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SGw,RGw)\nend role\n\nrole environment ()\ndef=\nconst    nodeU,gateway: agent,\n             qca,qg,qu: public_key,\ndg,du,kug,dgi,dui,kugi:symmetric_key,\nidu,idg,certu,certg,su,sg,\nts0,ts1,lt0,lt1,n5,au,ag,h4: text,\nhmac: hash_func,\nnodeU_gateway_n5,nodeU_gateway_lt1,sub1: protocol_id\nintruder_knowledge = {nodeU,gateway,hmac,dgi,dui,qca,qg,qu}\ncomposition\n  session(nodeU,gateway,hmac,qca,qg,qu,dg,du,kug)\n/\\session(nodeU,i,hmac,qca,qg,qu,dgi,dui,kugi)\n/\\session(i,gateway,hmac,qca,qg,qu,dgi,dui,kugi)\nend role\n\ngoal\nsecrecy_of sub1\nauthentication_on nodeU_gateway_n5\nauthentication_on nodeU_gateway_lt1\nend goal\nenvironment ()\n```"]], "HLPSL-1/AKS.hlpsl": [[false, "```\nrole role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(message))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU2,SN,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1,r1,{OBU1,OBU2,SN})\n\nend role_OBU1\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(message))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU1,OBU2,o2_o1_h21,H21')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R1,r1,{SN,OBU2,OBU1}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(SN,SN,s_o2_hs2,Hs2') /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2,P                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SS,RS                  : channel(message))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(OBU1,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,SS,RO,RS : channel(message)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    a1,r1,r2,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of a1\n  secrecy_of a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/IKEv2-MAC.hlpsl": [[true, "role alice(A: agent,B: agent,\n\t   G: text,\n\t   F: hash_func,\n           PSK: symmetric_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more spefic: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat,\n\tAUTH_B: message\n\n  const sec_a_SK : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,SK')\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t     G: text,\n\t     F: hash_func,\n\t     PSK: symmetric_key,\n\t     SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat,\n\tAUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk2,SK)\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A: agent, B: agent,\n\t     PSK: symmetric_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,SA,RA)\n\t/\\ bob(B,A,G,F,PSK,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : nat,\n        a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi\n                       }\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal", "```hlpsl\nrole alice(A: agent,B: agent,\n\t   G: text,\n\t   F: hash_func,\n           PSK: symmetric_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more spefic: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat,\n\tAUTH_B: message\n\n  const sec_a_SK : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,SK')\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t     G: text,\n\t     F: hash_func,\n\t     PSK: symmetric_key,\n\t     SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat,\n\tAUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk2,SK)\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A: agent, B: agent,\n\t     PSK: symmetric_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,SA,RA)\n\t/\\ bob(B,A,G,F,PSK,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : nat,\n        a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi\n                       }\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n```"]], "HLPSL-1/InitialAuth.hlpsl": [[false, "```houzhui\nrole role_Newnode(Newnode:agent,ClusterAdmin:agent,AuthRequest:text,Knc:symmetric_key,Kn:public_key,SND,RCV:channel(dy))\nplayed_by Newnode\ndef=\n\tlocal\n\t\tState:nat,T:text,Challenge:text,Solution:text,Uniqid:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({AuthRequest}_Knc)\n\t\t2. State=1 /\\ RCV({Challenge'.T'}_Knc) =|> State':=2 /\\ Solution':=new() /\\ SND({Solution'.inv(Kn)}_Knc)\n\t\t4. State=2 /\\ RCV({Uniqid'.Success'}_inv(Kn)) =|> State':=3 /\\ event(Newnode,ClusterAdmin,auth_1,Success)\nend role\n\nrole role_ClusterAdmin(Newnode:agent,ClusterAdmin:agent,OtherClusterAdmins:agent,Kn:public_key,Knc:symmetric_key,Kcc:symmetric_key,T:text,SND,RCV:channel(dy))\nplayed_by ClusterAdmin\ndef=\n\tlocal\n\t\tState:nat,AuthRequest:text,Challenge:text,Solution:text,Success:text,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({AuthRequest'}_Knc) =|> State':=1 /\\ Challenge':=new() /\\ SND({Challenge'.T}_Knc)\n\t\t3. State=1 /\\ RCV({Solution'.inv(Kn)}_Knc) =|> State':=2 /\\ Success':=new() /\\ Uniqid':=new() /\\ event(ClusterAdmin,Newnode,auth_1,Success) /\\ SND({Uniqid'.Success'}_inv(Kn)) /\\ SND({Uniqid'}_Kcc)\nend role\n\nrole role_OtherClusterAdmins(OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key,SND,RCV:channel(dy))\nplayed_by OtherClusterAdmins\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t5. State=0 /\\ RCV({Uniqid'}_Kcc) =|> State':=1\nend role\n\nrole session1(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole session2(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkcc:symmetric_key,clusteradmin:agent,knc:symmetric_key,newnode:agent,kn_inv:private_key,hash_0:function,otherclusteradmins:agent,kn:public_key,kic:symmetric_key,t_const:text\n\tintruder_knowledge = {newnode,clusteradmin,kic,kn}\n\tcomposition\n\t\tsession2(t_const,t_const,otherclusteradmins,i,clusteradmin,kn,kcc,kic) /\\ session1(t_const,t_const,otherclusteradmins,newnode,clusteradmin,kn,kcc,knc)\nend role\n\ngoal\n\tauthentication(auth_1)\nend goal\n```"]], "HLPSL-1/IoT-HAN.hlpsl": [[false, "```houzhui\n%Formal Verification of RLAS\nrole nodeU (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RU: channel (dy))\t\nplayed_by U def= \nlocal \nState\t\t\t\t   :nat,\nIdu,Certu,Lt,Idca,Nv,Certv,Nu,Idv  :text, \nToken1,Token2,Z1,Z2\t           :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(start)  =|>\n  State':= 1  /\\ Nu' := new()\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n\t      /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ SND(Token1',Z1')\n              /\\ secret ({Nu,Nu'},sub1,{U,V})\n\n\n2. State = 2  /\\ RCV(Token2',Z2') =|>\n   State':= 3 /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ request(U,V,nodeV_nodeU_lt,Lt)\nend role\n\nrole nodeV (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       RV, SV: channel (dy))\t\nplayed_by V def= \nlocal \nState\t\t\t           :nat,\nIdu,Certu,Lt,Idca,Nv,Nu,Certv,Idv,E:text, \nToken1,Token2,Z1,Z2\t\t   :message\n\ninit State:= 1\ntransition\n1. State = 1  /\\ RCV(Token1',Z1')  =|>\n   State':= 2 /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n              /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ SND (Token2',Z2')\n              /\\ secret ({Nv,Nv},sub2,{V,U})\n              /\\ witness(V,U,nodeU_nodeV_lt,Lt)\nend role\n\nrole session (U,V: agent,\n\t     Hash: hash_func,\n\t      Qca: public_key,\n    Key1,Key2,Ks1: symmetric_key)\ndef=\nlocal SU,RU,SV,RV: channel(dy)\ncomposition\n   nodeU(U,V,Hash,Qca,Key1,Key2,Ks1,SU,RU) \n/\\ nodeV(U,V,Hash,Qca,Key1,Key2,Ks1,SV,RV)\nend role\n\nrole environment ()\ndef=\nconst nodeU,nodeV: agent,\nqca: public_key,\nkey1,key2,ks1,key1i,key2i,ks1i: symmetric_key,\nidu,certu,lt,idca,e,nv,nu,certv,idv: text,\nh: hash_func,\nnodeU_nodeV_lt,nodeV_nodeU_lt,sub1,sub2: protocol_id\n\nintruder_knowledge={nodeU,nodeV,h,key1i,key2i,ks1i,qca}\n\ncomposition\nsession(nodeU,nodeV,h,qca,key1,key2,ks1)\n/\\session(nodeU,i,h,qca,key1i,key2i,ks1i)\n/\\session(i,nodeV,h,qca,key1i,key2i,ks1i)     \n\nend role\n\ngoal\nsecrecy_of sub1\nsecrecy_of sub2\nauthentication_on nodeU_nodeV_lt\nauthentication_on nodeV_nodeU_lt\nend goal\n\nenvironment ()\n```"]], "HLPSL-1/ISO2.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso2_Init (B,A    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ Snd(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,ra,A,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,ra,B,Ra')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (B, A : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ```"]], "HLPSL-1/ISO4.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: ISO4 Public Key Mutual Authentication Protocol\n%% VARIANT: three-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this protocol\n%% a confirmation of the successful authentication is sent by the initiator.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey, ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Nb, Text1\n%% 2. A -> B : PKa,A,{PKa,A}inv(PKs),Na,Nb,B,Text3,{Na,Nb,B,Text2}inv(PKa)\n%% 3. B -> A : PKb,B,{PKb,B}inv(PKs),Nb,Na,A,Text5,{Nb,Na,A,Text4}inv(PKb)\n%% \\end{verbatim}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!, and\\\\\n%% \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso4_Resp ( A: agent,Pkb: public_key, \n                 Pka: public_key,Pks: public_key, \n                 Snd: channel(dy),Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State         : nat,\n         Pka           : public_key, % This local Pka is not strictly needed if Pka is a parameter\n         Nb            : text,\n         Na,Text2,Text3: text\n\n  const ctext1,ctext4,ctext5: text\n\n  init State := 0 \n\n%%%  knowledge(B)={A,B,Pkb,inv(Pkb),Pks,ctext1,ctext4,ctext5,{Pkb.B}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start) \n      =|> \n      State' := 1\n      /\\ Nb' := new() \n      /\\ Snd(Nb'.ctext1) \n      /\\ witness(B,A,nb,Nb')\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.Nb.B.Text3'.\n             {Na'.Nb.B.Text2'}_inv(Pka'))\n      =|> \n      State' := 2\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb.Na'.A.ctext5.{Nb.Na'.A.ctext4}_inv(Pkb))\n%%%   /\\ witness(B,A,nb,Nb)\n      /\\ request(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso4_Init ( B: agent,A: agent,\n                 Pka: public_key,Pks: public_key, \n                 Snd: channel(dy),Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State               : nat,\n         Pkb                 : public_key, % This local Pkb is not strictly needed if Pkb is a parameter\n         Na                  : text,\n         Nb,Text1,Text4,Text5: text\n\n  const ctext2,ctext3: text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,inv(Pka),Pks,ctext2,ctext3,{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Nb'.Text1') \n      =|>\n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).\n             Na'.Nb'.B.ctext3.{Na'.Nb'.B.ctext2}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\n   2. State = 1\n      /\\ Rec(Pkb'.B.{Pkb'.B}_inv(Pks).\n             Nb.Na.A.Text5'.{Nb.Na.A.Text4'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ request(A,B,nb,Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B:agent,\n\t      Pka,Pkb,Pks: public_key) def=       \n\n  local SA,RA,SB,RB: channel (dy)\n\n  composition\n\n          iso4_Init(B,A,Pka,Pks,SA,RA)\n       /\\ iso4_Resp(A,Pkb,Pka,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n const na, nb             : protocol_id,\n       a, b, i            : agent,\n       pka, pkb, pks, pki : public_key\n\n intruder_knowledge={a,b,pki,inv(pki),pks,\n                     ctext1,ctext4,ctext5,{pki.i}_inv(pks),  %%% 2nd session\n                     ctext2,ctext3,{pki.i}_inv(pks)}         %%% 3rd session\n\n composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,i,pka,pki,pks)\n     /\\\tsession(i,b,pki,pkb,pks)\n%%%     /\\\tsession(b,a,pkb,pka,pks,sa4,ra4,sb4,rb4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO4_Resp authenticates ISO4_Init on nb\n   authentication_on nb % addressess G1 and G2\n\n   %ISO4_Init authenticates ISO4_Resp on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()```"]], "HLPSL-1/Ju(2024)protocol.hlpsl": [[false, "```houzhui\nrole role_U(U:agent,CS:agent,D:agent,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by U\ndef=\n\tlocal\n\t\tState:nat,IDuj:text,IDcsk:text,PIDuj:text,TS1:text,M1:text,M3:text,V1:text,M2:text,TS3:text,M6:text,ECuj:text,V3:text,ECujj:text,Key_1:symmetric_key\n,RPWuj,PWuj,RR3,CERTuj,ECujj,RR4,PIDdri,TIDuj,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t\n\t\t%%% User registration\n\t\t2. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RPWuj':=h(IDuj,PWuj) \n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_U_CS':=cons(Key_1',Key_set_U_CS) \n\t\t/\\ SND({IDuj}_Key_1')\n\n\n\t\t3. State=1 /\\ in(Key_3',Key_set_CS_U) \n\t\t/\\ RCV({PIDuj'.ECuj'.IDcsk}_Key_3') =|> State':=2 \n\t\t/\\ Key_set_CS_U':=delete(Key_3',Key_set_CS_U) \n\t\t/\\ RR3':=new()\n\t\t/\\ CERTuj':=xor(ECuj',h(RR3',PWuj))\n\t\t\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t/\\ ECujj':=xor(CERTuj',h(RR3',PWuj))\n\t\t/\\ RR4':=new()\n\t\t/\\ TS1':=new()\n\t\t/\\ M1':= xor(h(IDcsk,TS1'),PIDuj)\n\t\t/\\ M2':= xor(h(PIDuj',ECuj',TS1'),PIDdri)\n\t\t/\\ M3':= xor(h(PIDuj',IDcsk,ECuj',TS1'),TIDuj)\n\t\t/\\ V1':=h(PIDuj',PIDdri,ECuj',TS1')\n\t\t/\\ SND(M1'.M2'.M3'.V1'.TS1')\n\t\t/\\ secret(ECujj',sec_ECujj,{U,D}) \n\t\t/\\ witness(U,CS,u_cs_TS1,TS1')\n\n\n\t\t6. State=2 /\\ RCV(M6'.V3'.TS3') =|> State':=3\n\t\t/\\ request(D,U,d_u_TS3,TS3')\n\t\t/\\ TIDdri':=xor(M6',h(TIDuj,PIDdri,TS3'))\n\t\t/\\ SK':= h(TIDuj,TIDdri,TS3')\nend role_U\n\n\n\n\n\nrole role_CS(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by CS\ndef=\n\tlocal\n\t\tState:nat,RTSdri:text,IDdri:text,XXcsk:text,RR1:text,IDuj:text,RTSuj:text,PIDuj:text,ECuj:text,TS1:text,M1:text,M3:text,M2:text,V1:text,TS2:text,M4:text,V2:text,Key_1:symmetric_key,Key_2:symmetric_key,Key_3:symmetric_key,\nCCdri,PIDdri,ECdri,XXcsk,RR2,RTSuj,ECtuj,IDsck,TIDuj,CRdri,CRtdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RR1':=new()\n\t\t/\\ CCdri':=new()\n\t\t/\\ RTSdri':=new()\n\t\t/\\ PIDdri':=h(IDdri,RTSdri')\n\t\t/\\ ECdri':=h(IDdri,XXcsk,RR1',RTSdri')\n\t\t/\\ secret(ECdri',sec_ECdri,{D,CS}) \n\t\t/\\ ECtdri':=xor(ECdri',h(XXcsk,RTSdri'))\n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_CS_D':=cons(Key_1',Key_set_CS_D) \n\t\t/\\ SND({IDdri.CCdri'.ECdri'}_Key_1')\n\n\n\t\t%% Users registration\n\t\t2. State=0 /\\ in(Key_2',Key_set_U_CS) \n\t\t/\\ RCV({IDuj}_Key_2') =|> State':=2 \n\t\t/\\ Key_set_U_CS':=delete(Key_2',Key_set_U_CS) \t\t\t\n\t\t/\\ RR2':=new()\n\t\t/\\ PIDuj':=h(IDuj,RTSuj,XXcsk)\n\t\t/\\ ECuj':=h(PIDuj', RTSuj,RR2',XXcsk)\n\t\t/\\ secret(ECuj',sec_ECuj,{U,CS}) \n\t\t/\\ ECtuj':=xor(ECuj,h(XXcsk,RTSuj))\n\t\t/\\ Key_3':=new() \n\t\t/\\ Key_set_CS_U':=cons(Key_3',Key_set_CS_U) \n\t\t/\\ SND({PIDuj'.ECuj'.IDcsk}_Key_3')\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t4. State=2 /\\ RCV(M1'.M2'.M3'.V1'.TS1') =|> State':=3 \n\t\t/\\ request(CS,U,u_cs_TS1,TS1')\n\t\t/\\ PIDuj':=xor(M1',h(IDsck,TS1'))\n\t\t/\\ ECuj':=xor(ECtuj,h(XXcsk,RTSuj))\n\t\t/\\ PIDdri':=xor(M2',h(PIDuj',ECuj',TS1'))\n\t\t/\\ TIDuj':=xor(h(PIDuj',IDcsk,ECuj',TS1'),M3)\n\t\t/\\ CRdri':= xor(CRtdri,h(XXcsk,RTSdri))\n\t\t/\\ TS2':=new()\n\t\t/\\ M4':= xor(h(CRdri,PIDdri',TS2'),TIDuj)\n\t\t/\\ V2':=h(CRdri,PIDdri',TIDuj,TS2')\n\t\t/\\ SND(M4'.V2'.TS2')\n\t\t/\\ secret(CRdri',sec_CRdri,{CS,D}) \n\t\t/\\ witness(CS,D,cs_d_TS2,TS2')\nend role\n\nrole role_D(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,ECtdri:text,IDdri:text,CCdri:text,TS2:text,M4:text,V2:text,TS3:text,M6:text,V3:text,Key_1:symmetric_key,\nCCdri,ECdri,CRdri,CERTdri,TIDuj,PIDdri,RR5,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ in(Key_1',Key_set_CS_D) \n\t\t/\\ RCV({IDdri.CCdri'.ECdri'}_Key_1') =|> State':=1 \n\t\t/\\ Key_set_CS_D':=delete(Key_1',Key_set_CS_D)\n\t\t/\\ CRdri':=h(CCdri')\n\t\t/\\ CERTdri':=xor(ECdri',h(CRdri',IDdri))\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t5. State=1 /\\ RCV(M4'.V2'.TS2') =|> State':=2 \n\t\t/\\ request(D,CS,cs_d_TS2,TS2')\n\t\t/\\ CRdri':= h(CCdri)\n\t\t/\\ TIDuj':=xor(M4',h(CRdri',PIDdri,TS2'))\n\t\t/\\ RR5':=new()\n\t\t/\\ TIDdri':= h(CRdri',RR5',TIDuj')\n\t\t/\\ TS3':=new()\n\t\t/\\ SK':= h(TIDuj',TIDdri,TS3')\n\t\t/\\ M6':=xor(h(TIDuj',PIDdri,TS3'), TIDdri')\n\t\t/\\ V3':=h(TIDuj',TIDdri',SK',PIDdri,TS3')\n\t\t/\\ SND(M6'.V3'.TS3')\n\t\t/\\ witness(D,U,d_u_TS3,TS3')\nend role\n\nrole session(U:agent,CS:agent,D:agent,Key_set_CS_U:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_D:(symmetric_key) set)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_U(U,CS,D,Key_set_U_CS,Key_set_CS_U,SND1,RCV1)\n\t\t/\\ role_CS(U,CS,D,Key_set_CS_D,Key_set_U_CS,Key_set_CS_U,SND2,RCV2) \n\t\t/\\ role_D(U,CS,D,Key_set_CS_D,SND3,RCV3)  \nend role\n \nrole environment()\ndef=\n\tconst\n\t\tusers:agent,h:hash_func,drone:agent,server:agent,\nsec_ECdri,sec_ECuj,sec_ECujj,sec_CRdri, u_cs_TS1,d_u_TS3,cs_d_TS2:protocol_id\n\tintruder_knowledge = {users,server,drone}\n\tcomposition\n\t\tsession(users,server,drone,{},{},{})\n\t\t/\\ session(users,server,drone,{},{},{})\n\t\t/\\ session(i,server,drone,{},{},{})\n\t\t/\\ session(users,i,drone,{},{},{})\n\t\t/\\ session(users,server,i,{},{},{})\nend role\n\ngoal\n\tsecrecy_of sec_ECdri % secrecy of Drone's ephemeral credential\n\tsecrecy_of sec_ECuj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_ECujj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_CRdri % secrecy of Drone's CRdri\n\tauthentication_on u_cs_TS1\n\tauthentication_on cs_d_TS2\n\tauthentication_on d_u_TS3\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/Kerberos.hlpsl": [[false, "```\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (message),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local N2                                 : text,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2_local : text,\n        Tstart2, Texpire2                  : text\n\n  const t1,k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ wrequest(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{S,C,G})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 Snd, Rcv : channel (message),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2b, k_cs : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\ Snd(C.{T2'}_K_CS')\n\t      /\\ witness(S,C,t2b,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, Rcv   : channel (message),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,A,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ wrequest(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (message)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2b\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/KEY_EXCHANGE.hlpsl": [[false, "```houzhui\n%% key exchange\n\nrole role_SM(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:asymmetric_key,H:hash_func,SND:channel(dy),RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu,Cu,Aa,Bu,T1:text,\n\t\tI1,S1:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ S1' := H(IDu.Aa.Cu) /\\ I1' := xor(IDu,(xor(H(Aa),Aa))) /\\ SND({Bu.Aa.S1'.Cu}_PKs,I1',T1)\nend role\n\nrole role_DS(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:asymmetric_key,H:hash_func,SND:channel(dy),RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tSKs:symmetric_key,\n\t\tAa,Bu,Cu,IDu,IDs,Bb,Gg,T1,T3,Xi,Cs:text,\n\t\tI1,S1,Xi1,Eta:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Bu.Aa.S1'.Cu}_PKs,I1',T1) =|> State':=1 /\\ SKs' := new() /\\ Xi1' := xor(Xi,H(Cu.IDu.Sigmau)) /\\ Eta' := xor(IDs,H(Bb.Cs.Cu)) /\\ SND({Eta'.Xi1'.Cs.Bb}_Sigmau,T3) /\\ secret(sec_1,SKs,{SM,DS}) /\\ witness(DS,SM,Cu_SM_generated,Cu)\nend role\n\nrole session(SM:agent,DS:agent,Sigmau:symmetric_key,sks:symmetric_key,PKs:asymmetric_key,H:hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_SM(SM,DS,Sigmau,PKs,H,SND1,RCV1) /\\\n\t\trole_DS(DS,SM,Sigmau,PKs,H,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tpks,pki:asymmetric_key,\n\t\tsigmau,sigmai,sks:symmetric_key,\n\t\th:hash_func,\n                smart_meter,distributed_server:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {smart_meter,distributed_server,sks}    %% ... and we give it to the intruder\n\tcomposition\n                  %% We run the regular session\n\t\tsession(smart_meter,distributed_server,sigmau,sks,pks,h) \n                  %% in parallel with another regular session\n                /\\ session(distributed_server,smart_meter,sigmau,sks,pks,h) \n\n                  %% and a session between the intruder (with key kit) and bob\n                /\\ session(i,distributed_server,sigmai,sks,pks,h) \n                  %% and a session between alice and the intruder (with key kit)\n                /\\ session(smart_meter,i,sigmau,sks,pki,h) \nend role\n\ngoal\n    secrecy_of SKs\n\tauthentication_on auth_1\nend goal\n\nenvironment()```"]], "HLPSL-1/L-3.hlpsl": [[false, "```houzhui\nrole alice ( \n\tA:agent,B:agent,\n\tYa,Yb:public_key,\n\tIa:nat,\n\tP1,M1,Q1:nat,\n\tP2,M2,Q2:nat,\n\tH2,H3:text,\n\tSign,KDF,CERT,MUL,PI,LOW,HIG,MAC: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tIb,K_a,K_b:nat, \n\tKa,Kb,CertificateB,Qba,Rba,Tba,TagB,TagA,Kba,Mba,CertificateA,H4:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 /\\ \nK_a' := new() /\\\nKa' := MUL(K_a'.P2) /\\\nCertificateA' := CERT(Ia.Ya) /\\\nSND(Ia.CertificateA'.Ka') /\\ request(A,B,ss1,Ia.CertificateA'.Ka')\n\n\n2. State = 1 /\\ RCV(Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib'))) \n/\\ CertificateB' = CERT(Ib.Yb) \n=|>\nState' := 2 /\\\nQba' := MUL(M1.Q1.inv(Ya).Kb') /\\\nRba' := MUL(M2.Q2.K_a.Yb) /\\\nTba' := KDF(PI(Qba').PI(Rba').Ia.Ib') /\\\nKba' := LOW(Tba') /\\\nMba' := HIG(Tba') /\\\nTagA' := {MAC(H3.PI(Ka).PI(Kb').Ia.Ib')}_Mba' /\\\nSND(TagA') \n/\\ secret(Kba',secka,A)\n/\\ request(A,B,ss2,Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib')))\n/\\ witness(A,B,ss3,TagA')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA:agent,B:agent,\n\tYa,Yb:public_key,\n\tIb:nat,\n\tP1,M1,Q1:nat,\n\tP2,M2,Q2:nat,\n\tH2,H3:text,\n\tSign,KDF,CERT,MUL,PI,LOW,HIG,MAC:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tIa:nat,\n\tK_b,K_a:nat,\n\tKa,Kb,Qab,Rab,Tab,Kab,Mab,TagA,TagB,CertificateB,CertificateA:message,\n\tState:nat\ninit State := 10\ntransition\n\n10. State =10 /\\ RCV(Ia'.CertificateA'.Ka') /\\ CertificateA' = CERT(Ia.Ya)\n=|> State' := 20 /\\ \nK_b' := new() /\\\nKb' := MUL(K_b'.P1) /\\\nQab' := MUL(M1.Q1.K_b.Ya) /\\\nRab' := MUL(M2.Q2.inv(Yb).Ka') /\\\nTab' := KDF(PI(Qab').PI(Rab').Ia'.Ib) /\\\nKab' := LOW(Tab') /\\\nMab' := HIG(Tab') /\\\nTagB' := {MAC(H2.PI(Kb').PI(Ka').Ib.Ia')}_Mab' /\\\nCertificateB' := CERT(Ib.Yb) /\\\nSND(Ib.CertificateB'.Kb'.TagB') \n/\\ secret(Kab',seckb,B) \n/\\ request(B,A,ss1,Ia'.CertificateA'.Ka')\n/\\ witness(B,A,ss2,Ib.CertificateB'.Kb'.TagB')\n\n\n\n20. State = 20 /\\ RCV({MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n=|>\nState' := 40 /\\ Ka' := new() /\\ SND(Ka') /\\ request(B,A,ss3,{MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n\n% End\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B:agent,Ya,Yb:public_key,Ia,Ib:nat,P1,M1,Q1,P2,M2,Q2:nat,H2,H3:text,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Ia,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SA,RA) \n/\\ bob(A,B,Ya,Yb,Ib,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole main()\ndef=\n\nconst a,b:agent,\nss1,ss2,ss3,secka,seckb: protocol_id,\nya,yb:public_key,\nia,ib:nat,\np1,m1,q1:nat,\np2,m2,q2:nat,\nh2,h3:text,\nsign:hash_func,\nkdf:hash_func,\ncert:hash_func,\nmul:hash_func,\npi:hash_func,\nlow:hash_func,\nhig:hash_func,\nmac:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,cert,mul,pi,low,hig,mac,p1,m1,q1,p2,m2,q2,h2,h3}\n\ncomposition\n\nsession(a,b,ya,yb,ia,ib,p1,m1,q1,p2,m2,q2,h2,h3,sign,kdf,cert,mul,pi,low,hig,mac)\n\nend role\n\ngoal\n\tauthentication_on ss1\n\tauthentication_on ss2\n\tauthentication_on ss3\n\tsecrecy_of secka\n\tsecrecy_of seckb\nend goal\n\nenvironment()\n```"]], "HLPSL-1/lipkey-spkm-known-initiator.hlpsl": [[true, "role initiator (\n        G: nat,\n\tS: agent,             \n        G: nat,\n\tH: hash_func,\n\tKa: public_key,\n\tKs: public_key,\n\tLogin_A_S: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : nat,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_i_Log, sec_i_Pwd: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = 0 /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = 1 /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ secret(Login_A_S,sec_i_Log,{A}) \n\t      \t /\\ secret(Pwd_A_S,  sec_i_Pwd,{A})  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,S,ktrgtint,Keycompleted') \n\t         /\\ witness(A,S,k,K') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,S           : agent,      \n\tG             : nat,\n\tH             : hash_func,\n\tKa,Ks         : public_key,\n\tLogin, Pwd    : hash_func,\n        SND, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : nat,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: protocol_id\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ secret(Login(A.S),sec_t_Log,{A}) \n\t        /\\ secret(Pwd(A.S),  sec_t_Pwd,{A}) \n\t\t/\\ request(S,A,k,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ witness(S,A,ktrgtint,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\t  A,S : agent,\n\t  Login, Pwd: hash_func,\n\t  Ka: public_key,\n          Ks: public_key,\n\t  H: hash_func,\n\t  G: nat)\ndef=  \n\n  local   SndI, RcvI,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a,s,i,b: agent,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k % addresses G1, G2, G3\n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint % addresses G1, G2, G3\n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, % adresses G7, G10\n             sec_t_Log, sec_t_Pwd  % adresses G7, G10\n\n\nend goal", "```hlpsl\nrole initiator (\n        G: nat,\n\tS: agent,             \n        G: nat,\n\tH: hash_func,\n\tKa: public_key,\n\tKs: public_key,\n\tLogin_A_S: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : nat,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_i_Log, sec_i_Pwd: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = 0 /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = 1 /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ secret(Login_A_S,sec_i_Log,{A}) \n\t      \t /\\ secret(Pwd_A_S,  sec_i_Pwd,{A})  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,S,ktrgtint,Keycompleted') \n\t         /\\ witness(A,S,k,K') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,S           : agent,      \n\tG             : nat,\n\tH             : hash_func,\n\tKa,Ks         : public_key,\n\tLogin, Pwd    : hash_func,\n        SND, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : nat,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: protocol_id\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ secret(Login(A.S),sec_t_Log,{A}) \n\t        /\\ secret(Pwd(A.S),  sec_t_Pwd,{A}) \n\t\t/\\ request(S,A,k,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ witness(S,A,ktrgtint,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\t  A,S : agent,\n\t  Login, Pwd: hash_func,\n\t  Ka: public_key,\n          Ks: public_key,\n\t  H: hash_func,\n\t  G: nat)\ndef=  \n\n  local   SndI, RcvI,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a,s,i,b: agent,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k % addresses G1, G2, G3\n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint % addresses G1, G2, G3\n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, % adresses G7, G10\n             sec_t_Log, sec_t_Pwd  % adresses G7, G10\n\n\nend goal\n```"]], "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl": [[false, "```houzhui\nrole user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SU, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ secret(SAim',g2,{U,S})\n\t\t   /\\ secret(SPWim',g3,{U})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend user\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SS, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ authentication_on(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SF, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ secret(Nfp',g5,{U,S,F})\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()```"]], "HLPSL-1/liteCrypto.hlpsl": [[false, "```houzhui\n%%% 1. A -> B : PID, S\n%%% 2. A -> B : M1, MAC, Sig\n%%% 3. B -> A : A, B, SAC\n\nrole role_A(A: agent, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND: channel(message), RCV: channel(message))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tChe,Ts,Ts2:text,\n\t\tRes,S,PID,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Che':=new() /\\ Res':=Ha(Che') /\\ S':=Hb(Res') /\\ PID':=Ha(A.S')\n\t\t/\\ SND({A.B.PID'.S'}_Pubkey)\n\t\t/\\ Ts':=new() /\\ M1':={A.B.PID'.Ts'}_Pubkey /\\ MAC1':=Ha(M1') /\\ SIG1':={Hb(M1').Ha(S'.PID')}\n\t\t/\\ SND({M1'.MAC1'.SIG1'.Ts'}_Pubkey)\n\n\t\t/\\ secret(M1',sec_2,{A,B})\n\t\t/\\ secret(S',sec_1,{A,B})\n\n\t\t2. State=2 /\\ RCV({A.B.Ts.Ts2'.SAC'}_Pubkey) =|>\n\t\tState':=4\n\n\t\t/\\ request(A,B,auth_1,MAC1)\n\t\t/\\ request(A,B,auth_2,SIG1)\n\t\t/\\ request(A,B,auth_3,M1)\nend role\n\nrole role_B(A, B: agent, Pubkey: public_key, Ha:hash_func,Hb:hash_func, SND: channel(message), RCV: channel(message))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tTs,Ts2:text,\n\t\tPID,S,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.B.PID'.S'}_Pubkey) /\\ RCV({M1'.MAC1'.SIG1'.Ts'}_Pubkey) =|>\n\t\tState':=3 /\\ Key':=Ha(PID'.S') /\\ Ts2':=new() /\\ SAC':=Ha(Key,A,B)\n\t\t/\\ SND({A.B.Ts'.Ts2'.SAC'}_Pubkey)\n\n\t\t/\\ secret(SAC',sec_3,{A,B})\n\n\t\t/\\ witness(B,A,auth_1,MAC1')\n\t\t/\\ witness(B,A,auth_2,SIG1')\n\t\t/\\ witness(B,A,auth_3,M1')\nend role\n\nrole session(A,B:agent, PubA,PubB: public_key, Ha:hash_func, Hb: hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(message)\n\tcomposition\n\t\trole_A(A,B,PubB,Ha,Hb,SND1,RCV1) /\\ \n\t\trole_B(A,B,PubA,Ha,Hb,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone,groundstation:agent,\n\t\tpubA:public_key,\n\t\tpubB:public_key,\n\t\tha:hash_func,\n\t\thb:hash_func,\n\t\tsec_1,sec_2,sec_3,auth_1,auth_2,auth_3:protocol_id\n\tintruder_knowledge = {drone,groundstation,ha,hb}\n\n\tcomposition\n\t\tsession(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(i,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,i,pubA,pubB,ha,hb)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\tsecrecy_of sec_3\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\nend goal\n\nenvironment()```"]], "HLPSL-1/LPD-IMSR.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: LPD IMSR\n%% VARIANT: IMSR: Improved Modulo Square Root\n%% LPD (Low-Powered Devices) Improved MSR (Modulo Square Root) protocol\n%% is a key establishment protocol for secure mobile communications. It\n%% has been designed by Beller, Chang, and Yacobi in 1990s as an\n%% improvement of MSR. Namely IMSR overcomes a major weakness of MSR by\n%% including a certificate of the base station in the first\n%% message. Apart from this feature it is identical to the basic MSR\n%% protocol, and therefore does not address the problem of replay\n%% \n%% PURPOSE: \n%% Key establishment protocol for secure mobile communications.\n%%   \n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[pages 5-6]{MutAuthLPD}\n%% \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M    : agent\n%% PKb     : public key\n%% SCm     : text\n%% Nb      : text (fresh)\n%% Cert(B) : message\n%% X       : symmetric key (fresh)\n%%\n%% 1. B -> M : B, Nb, PKb, Cert(B)\n%% 2. M -> B : {X}PKb\n%% 3. M -> B : {Nb, M, SCm}X\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% {\\texttt{M}} which is issued by a trusted central\n%% authority. {\\texttt{Cert(B)}} is the public certificate previously\n%% issued by some server for {\\texttt{B}}.  \n%% We assume \\verb|Cert(B) = {B.PKb}inv(PKs)|.\n%%\n%% Notice that wrt MSR there is a\n%% twofold increase in the complexity of this protocol as compared to the\n%% basic MSR protocol. The mobile now calculates an additional modulo\n%% square to verify the base's certificate on receiving message 1. Upon\n%% receiving the final message, {\\texttt{B}} decrypts it using the\n%% session key {\\texttt{X}}, and checks that the value {\\texttt{Nb}} is\n%% the same as the random challenge sent in message 1.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%% \n%% CLASSIFICATION: G1, G2, G12\n%% \n%% ATTACKS: None\n%% \n%% NOTES:\n%% \n%% The added public certificate and nonce exchange give some more\n%% protection. Boyd et al.~\\cite{MutAuthLPD} recommend moving the nonce\n%% and {\\texttt{M}} into message 2. \\\\\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole imsr_Base(B, M     : agent,\n               SCm      : text,\n               PKb      : public_key, \n               PKs      : public_key, \n               Snd, Rcv : channel (dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        X       : symmetric_key,\n        Nb      : text,\n        Package : message\t\n\n  const  imsr_protocol_id : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B) %% Assuming 'B' serves as a trigger message to start the protocol role.\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(B.Nb'.PKb.{B.PKb}_inv(PKs))\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{Nb.M.SCm}_X')\n      =|> \n      State' := 2 \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole imsr_Mobile(B, M     : agent,\n                 SCm      : text, \n                 PKs      : public_key,\n                 Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n        PKb    : public_key,\n        X      : symmetric_key,\n        Nb     : text,\n        Cert   : message\n\n  const imsr_protocol_id : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.Nb'.PKb'.Cert')\n      /\\ Cert' = {B.PKb'}_inv(PKs)  \n      =|> \n      State':=1\n      /\\ X' := new()\n      /\\ Snd({X'}_PKb'.{Nb.M.SCm}_X')\n      /\\ secret(X',secx,{B,M})\n      /\\ witness(M,B,x,X') \t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n             SCm            : text,\t\n             PKb, PKs       : public_key) def=\n\n  local SA, RA, SB, RB : channel (dy)\n\n\n  composition\n\t\n       imsr_Base(B,M,SCm,PKb,PKs,SA,RA)\n    /\\ imsr_Mobile(B,M,SCm,PKs,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole main() def=\n \n  const b, m                                   : agent,\n        kb, ki, ks                             : public_key,\n        scm1, scm2, scm3                       : text\n\n  intruder_knowledge = {b,m,scm2,scm3,i,ki,ks,inv(ki),\n                        m,{i.ki}_inv(ks)         \n                       }\n\n  composition\n\n\tsession(b,m,scm1,kb,ks) \n    /\\  session(b,i,scm2,kb,ks) \n    /\\  session(i,m,scm3,ki,ks) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %IMSR_Base weakly authenticates IMSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/main.hlpsl": [[false, "```\nE_0)played_by RA def=\n\ninit\n    State := 0\n\ntransition\n\n%%% Controller Registration\n1. State = 0 /\\ in(start) =|> State':= 1 /\\\n\n%%% Generate private key and public key for Registration Authority \nPRVRa' := new() /\\ PUBRa' := F(PRVRa'.G) /\\\n\n%%% Generate private key and public key for Controller\nPRVCon' := new() /\\ PUBCon' := F(PRVCon'.G) /\\\n\n%%% Generate certificate for controller\nCERTCon' := Add(PRVCon'.H(IDCon.IDClus.PUBCon'.PUBRa').PRVRa') /\\\n\n%%% Send Registration message via secure channel\nSnd({IDCon.PRVCon'.CERTCon'}_Skcon) /\\\nsecret({PRVRa'}, prvra, RA) /\\\nsecret({PRVCon'}, prvcon, {RA, SC}) /\\\n\n%%% Switch Registration\nPRVSw' := new() /\\ PUBSw' := F(PRVSw'.G) /\\\nCERTSw' := Add(PRVSw'.H(IDSw.IDClus.PUBSw'.PUBRa').PRVRa') /\\\n\n%%% Send Registration via secure channel(offline registration)\nSnd({IDSw.PRVSw'.CERTSw'}_Sksw) /\\\nsecret({PRVSw'}, prvsw, {RA, SSW})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Controller\nrole controller(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\n\nplayed_by SC def=\nlocal\n    State : nat,\n    Skcon: symmetric_key,\n    %%% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    G, IDCon, IDSw, PRVCon, IDClus, PRVRa, R1, R2, TS1, FCONSWI, ACON, BCON: message,\n    TS2, PRVSw: message\n\ninit\n    State := 0\n    \ntransition\n\n%%% Registration phase acceptance\n1. State = 0 /\\ Rcv({IDCon.PRVCon'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')}_Skcon)\n=|> State' := 2 /\\ secret(PRVRa', prvra, RA) /\\ secret(PRVCon', prvcon, {RA, SC}) /\\\n\n%%% Access control phase\nR1' := new() /\\ TS1' := new() /\\ FCONSWI':= Poly(IDCon.IDSw) /\\\nACON' := H(R1'.TS1').xor(H(FCONSWI'.TS1')) /\\\nBCON' := H(IDCon.IDSw.ACON'.TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').FCONSWI')\n/\\\n\n%%% Send message over public channel\nSnd(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').ACON'.BCON'.TS1') /\\\n\n%%% SC has freshly generated the values R1' and TS1' for SSW\nwitness(SC, SSW, scsswr1, R1') /\\\nwitness(SC, SSW, scsswts1, TS1')\n\n2. State = 2 /\\ Rcv(IDCon'.IDSw'.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G).F(PRVRa'.G')).PRVRa').\n(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).H(H(Poly(IDSw'.IDCon').((H(R1'.TS1').\nxor(H(Poly(IDCon'.IDSw').TS1'))).xor(H(Poly(IDSw'.IDCon').TS1'))).H(R2'.TS2').\nAdd(PRVCon'.H(IDCon'.IDClus'.F(PRVCon'.G').F(PRVRa'.G')).PRVRa')\n.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa'))\n.(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G')\n.F(PRVRa'.G')).PRVRa').IDCon'.IDSw'.TS2').TS2') =|>\nState' := 5 /\\\nrequest(SSW, SC, sswscr2, R2') /\\\nrequest(SSW, SC, sswscts2, TS2')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Switch\nrole switch(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\n\nplayed_by SSW def=\nlocal\n    State : nat,\n    Sksw: symmetric_key,\n    %% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    IDCon, IDSw, PRVSw, IDClus, G, PRVRa, R2, TS2, ASWI, SKswicon, R1 : message,\n    TS1, PRVCon, SKVswicon: message\n    \ninit\n    State := 0\n\ntransition\n\n% Registration acceptance phase\n1. State = 0 /\\ Rcv({IDSw.PRVSw'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')}_Sksw) =|>\nState' := 3 /\\ secret(PRVRa', prvra, RA) /\\ secret(PRVSw', prvsw, {RA, SSW})\n\n% Access Control Phase\n\n2. State = 3 /\\ Rcv(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').\n        H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1')).\n        H(IDCon.IDSw.H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))\n        .TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').Poly(IDCon.IDSw))\n        .TS1') =|>\nState' := 4 /\\\nR2' := new() /\\ TS2' := new() /\\\nASWI' := H(R2'.TS2').xor(H(Poly(IDSw.IDCon).TS2')) /\\\nPRVSw' := new() /\\\nSKswicon' := H(Poly(IDSw.IDCon).((H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))).xor(H(Poly(IDSw.IDCon).TS1'))).H(R2'.TS2').\n            Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')\n            .Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')) /\\\nSKVswicon' := H(SKswicon'.ASWI'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').IDCon.IDSw.TS2') /\\\nSnd(IDCon.IDSw.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').ASWI'.SKVswicon'.TS2') /\\ % \n\nwitness(SSW, SC, scsswr1, R1') /\\\nwitness(SSW, SC, sswscts2, TS2') /\\\nrequest(SC, SSW, scsswr1, R1') /\\\nrequest(SC, SSW, scsswts1, TS1')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define session role\nrole session(RA, SC, SSW: agent, H: hash_func)\ndef=\nlocal\n    RASND, SCRCV, SSWSND, SSWRCV, RARCV, SCSND: channel(dy)\ncomposition\n    registrationAuth(RA, SC, SSW, H, RASND, RARCV) /\\\n    controller(RA, SC, SSW, H, SCSND, SCRCV) /\\\n    switch(RA, SC, SSW, H, SSWSND, SSWRCV)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define environment role\nrole environment() def= \nconst \n    ra, sc, ssw: agent,\n    h, f, add, poly: hash_func,\n    prvra, prvcon, prvsw: protocol_id,\n    scsswts1, scsswr1 : protocol_id,\n    sswscr2, sswscts2 : protocol_id\nintruder_knowledge = {ra, sc, ssw, h, f, add, poly}\n\ncomposition\n    session(ra, sc, ssw, h) /\\\n    session(ra, sc, i, h) /\\\n    session(ra, i, ssw, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n% Confidentiality of Private Keys\nsecrecy_of prvra\nsecrecy_of prvcon\nsecrecy_of prvsw\n\n% Authentication\nauthentication_on scsswr1 \nauthentication_on scsswts1\nauthentication_on sswscr2\nauthentication_on sswscts2\nend goal\n```"]], "HLPSL-1/migration.hlpsl": [[false, "```houzhui\n____(ROLE_0)____ role_PreviousParent(PreviousParent:____(PARAM_1)____,Kbp:____(PARAM_0)____,Kbc:____(PARAM_2)____,____(PARAM_3)____:____(PARAM_4)____,UniqidI:____(PARAM_5)____,SND,RCV:channel(dy))\nplayed_by PreviousParent\ndef=\n\tlocal\n\t\t____(VARIABLE_1)____:____(VARIABLE_0)____,Uniqid:____(VARIABLE_2)____,Idrequest:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t4. State=____(STATE_0)____ /\\ RCV({Uniqid'.Idrequest'}_Kbp) =|> State':=1 /\\ SND({UniqidI}_Kbp)\nend ____(ROLE_1)____\n\n____(ROLE_2)____ role_ParentB(____(PARAM_7)____:____(PARAM_6)____,____(PARAM_10)____:____(PARAM_12)____,Blockchain:agent,Knb:____(PARAM_9)____,____(PARAM_11)____:symmetric_key,Kbc:symmetric_key,____(PARAM_8)____,RCV:channel(dy))\nplayed_by ParentB\ndef=\n\tlocal\n\t\tState:____(VARIABLE_7)____,____(VARIABLE_3)____:____(VARIABLE_4)____,____(VARIABLE_6)____:____(VARIABLE_5)____,Idrequest:text,____(VARIABLE_8)____:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=____(STATE_2)____ /\\ RCV({Uniqid'}_Knb) =|> State':=1 /\\ SND({Uniqid'}_Kbc)\n\t\t3. State=1 /\\ RCV({Uniqid.PreviousParentID'}_Kbc) =|> State':=2 /\\ Idrequest':=new() /\\ SND({Uniqid.Idrequest'}_Kbp)\n\t\t5. State=____(STATE_1)____ /\\ RCV({UniqidI'}_Kbp) =|> State':=3 /\\ Success':=new() /\\ ____(EVENT_1)____(Success',sec_1,{NodeN,____(EVENT_0)____}) /\\ SND({Success'}_Knb)\nend ____(ROLE_3)____\n\nrole role_Blockchain(Blockchain:____(PARAM_13)____,____(PARAM_15)____:____(PARAM_16)____,PreviousParent:____(PARAM_17)____,PreviousParentID:____(PARAM_14)____,____(PARAM_18)____:symmetric_key,SND,RCV:channel(dy))\nplayed_by Blockchain\ndef=\n\tlocal\n\t\tState:____(VARIABLE_10)____,Uniqid:____(VARIABLE_9)____\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV({Uniqid'}_Kbc) =|> State':=1 /\\ SND({Uniqid'.PreviousParentID}_Kbc)\nend role\n\nrole role_NodeN(NodeN:____(PARAM_24)____,____(PARAM_20)____:agent,ParentB:agent,____(PARAM_22)____:text,____(PARAM_21)____:symmetric_key,____(PARAM_19)____,RCV:channel(____(PARAM_23)____))\nplayed_by NodeN\ndef=\n\tlocal\n\t\tState:____(VARIABLE_11)____,Success:____(VARIABLE_12)____\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({Uniqid}_Knb)\n\t\t6. State=1 /\\ RCV({Success'}_Knb) =|> State':=2 /\\ secret(Success',____(EVENT_3)____,{____(EVENT_2)____,ParentB})\nend role\n\nrole session1(____(PARAM_33)____:____(PARAM_29)____,____(PARAM_27)____:____(PARAM_30)____,____(PARAM_25)____:____(PARAM_32)____,Uniqid:text,NodeN:____(PARAM_28)____,____(PARAM_26)____:____(PARAM_31)____,ParentB:____(PARAM_34)____,PreviousParent:agent,PreviousParentID:text,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,____(VARIABLE_15)____,____(VARIABLE_13)____,____(VARIABLE_14)____,____(VARIABLE_16)____,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_Blockchain(Blockchain,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,Blockchain,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole session2(UniqidI:____(PARAM_42)____,____(PARAM_41)____:____(PARAM_35)____,Kbp:____(PARAM_37)____,Uniqid:text,NodeN:____(PARAM_36)____,____(PARAM_39)____:____(PARAM_44)____,ParentB:agent,____(PARAM_38)____:agent,PreviousParentID:text,____(PARAM_40)____:____(PARAM_43)____)\ndef=\n\tlocal\n\t\tSND4,RCV4,____(VARIABLE_19)____,RCV3,SND2,RCV2,____(VARIABLE_20)____,____(VARIABLE_18)____:channel(____(VARIABLE_17)____)\n\tcomposition\n\t\trole_Blockchain(Blockchain,ParentB,PreviousParent,PreviousParentID,Kbc,SND4,RCV4) /\\ role_PreviousParent(PreviousParent,Kbp,Kbc,Knb,UniqidI,SND3,RCV3) /\\ role_ParentB(ParentB,NodeN,Blockchain,Knb,Kbp,Kbc,SND2,RCV2) /\\ role_NodeN(NodeN,PreviousParent,ParentB,Uniqid,Knb,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\t____(VARIABLE_30)____:____(VARIABLE_28)____,blockchain:agent,____(VARIABLE_27)____:____(VARIABLE_23)____,hash_0:hash_func,const_1:____(VARIABLE_29)____,knb:____(VARIABLE_24)____,nodeN:agent,____(VARIABLE_21)____:____(VARIABLE_25)____,____(VARIABLE_22)____:agent,____(VARIABLE_26)____:____(VARIABLE_31)____,sec_1:protocol_id\n\tintruder_knowledge = {nodeN,parentB,previousParent,kib}\n\tcomposition\n\t\tsession2(const_1,kib,kbp,const_1,i,blockchain,parentB,previousParent,const_1,kbc) /\\ session1(const_1,knb,kbp,const_1,nodeN,blockchain,parentB,previousParent,const_1,kbc)\nend role\n\ngoal\n\tsecrecy_of ____(GOAL_4)____\nend goal\n```"]], "HLPSL-1/NSPK-fix.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: fix by Lowe (of 1995) without key server\n%% PURPOSE: Two-party mutual autentication\n%% MODELER: David von Oheimb, Siemens CT IC 3, January 2005\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% 1. A  - {Na.A}_Kb ----> B\n%% 2. A <- {Na.Nb.B}_Ka -  B\n%% 3. A  - {Nb}_Kb ------> B\n%%\\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A, B: agent,             \n            Ka, Kb: public_key,      \n            SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',na,{A,B}) \n\t\t   /\\ witness(A,alice_bob_na,na,Na')\n\n    2.  State  = 2 /\\ RCV({Na.Nb'.B}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\t\t   /\\ request(A,B,bob_alice_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'.B}_Ka)\n\t\t   /\\ secret(Nb',nb,{A,B}) \n\t\t   /\\ witness(B,bob_alice_nb,nb,Nb')\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 /\\ request(B,A,alice_bob_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  na, nb,\n\t  alice_bob_na,\n\t  bob_alice_nb : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_on na, nb\n  authentication_on bob_alice_nb\n  authentication_on alice_bob_na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/optimised_protocol.hlpsl": [[false, "```houzhui\n%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (optimized)\n%%% 1. A -> T : {B,Kab}_Kat\n%%% 2. T -> B : {A,Kab}_Kbt\n%%% 3. B -> A : {B,Nb}_Kab\n%%% 4. A -> B : {Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({B.Kab'}_Kat) /\\ secret(Kab',sec_1,{A,B,Kab'})\n\n\t\t2. State=1 /\\ RCV({B.Nb'}_Kab) =|> State':=2  /\\ SND({Nb'}_Kab) \n                   \n                   %% A checks that B uses the same key\n                   %% that he sent at step 1.\n                   /\\ request(A,B,auth_1,Kab)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ witness(A,B,auth_2,Nb')\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat:symmetric_key,Kbt:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Na:text,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.Kab'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({A.Kab'}_Kbt) \nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.Kab'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({B.Nb'}_Kab')\n\n                   %% B hopes that Kab will permit to authenticate him\n                   /\\ witness(B,A,auth_1,Kab')\n\n                2. State=1 /\\ RCV({Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(B,A,auth_2,Nb)\nend role\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tRCV1,RCV3,SND2,RCV2,SND1,SND3:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,kit}    %% ... and we give it to the intruder\n\tcomposition\n                      %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n                      %% in parallel with another regular session\n                  /\\ session(alice,bob,trusted,kat,kbt) \n\n                      %% and a session between the intruder (with key kit) and bob\n                  /\\ session(i,bob,trusted,kit,kbt) \n                      %% and a session between alice and the intruder (with key kit)\n                  /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of Kab\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n```"]], "HLPSL-1/PBK-fix-weak-auth.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: PBK: Purpose Built Keys Framework\n%% VARIANT: fixed version with weak authentication\n%% PURPOSE: Sender invariance (authentication assuming that the first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {***tag1***,Msg}inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {***tag2***,Nonce}inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: None\n%% NOTES:\n%% Same as before, but specifying only weak authentication.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(dy),\n            Hash       : hash_func,\n            PK_A       : public_key,\n            Tag1,Tag2  : text)\nplayed_by A\ndef=\n\n  local\n    State      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND(B.{Tag1.Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A_sends_msg,A,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Tag2.Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole bob (B,A        : agent,\n          SND,RCV    : channel(dy),\n          Hash       : hash_func,\n          PK_A       : public_key,\n          Tag1,Tag2  : text)\nplayed_by B\ndef=\n\n  local\n    State      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV(B.{Tag1.Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 5 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 5 /\\ RCV({Tag2.Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ wrequest(A,A,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session(A,B        : agent,\n             Hash       : hash_func,\n             PK_A       : public_key,\n             Tag1,Tag2        : text)\ndef=\n\n  local SND,RCV  : channel (dy)\n\n  composition\n\n     alice(A,B,SND,RCV,Hash,PK_A,Tag1,Tag2)\n  /\\ bob(B,A,SND,RCV,Hash,PK_A,Tag1,Tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment()\ndef=\n\n  const\n    a,b            : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key,\n    tag1,tag2      : text\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n     session(a,b,f,pk_a,tag1,tag2)\n  /\\ session(b,a,f,pk_b,tag1,tag2)\n  /\\ session(i,b,f,pk_i,tag1,tag2)\n  /\\ session(a,i,f,pk_a,tag1,tag2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n  % Sender Invariance (G16)\n  authentication_on A_sends_msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/PMAP_D2D.hlpsl": [[false, "```houzhui\n%%% PMAP_D2D, a privacy-preserving mutual authentication and key agreement protocol for internet of drones\n%%% between drone and drone\n%%% 1. A -> Z : {A,Z,Na}_CRPa, {A,Z,Na,B}_CRPa\n%%% 2. Z -> A : {A,Z,B,Na,Nz}_CRPa\n%%% 3. A -> Z : {A,Z,B,Nz,Na2}_CRPa, {A,Z,B,Nz,Na2,Ra}_CRPa\n%%% 4. Z -> B : {B,Z,Nz2}_CRPb, {B,Z,Nz2,Na2}_CRPb, {B,Z,Nz2,Na2,A}_CRPb\n%%% 5. B -> Z : {B,Z,A,Nz2,Nb}_CRPb, {B,Z,A,Nz2,Nb,Rb}_CRPb\n%%% 6. Z -> A : {A,Z,B,Na2,Nb}_CRPa\n\nrole_A role_A(A:agent,B:agent,Z:agent,CRP:symmetric_key,Hash:hash_func,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC11,Ca,Ra,K:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Na':=new() /\\ MAC12':= Hash({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.Na'.B)\n\t\t/\\ SND({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12')\n\n\t\t2. State=2 /\\ RCV({A.Z.B.Na.Nz'}_CRP.MAC3') =|>\n\t\tState':=6 /\\ Na2':=new() /\\ Ca':={Nz'.Na2'}_CRP /\\ Ra':=Hash(Ca')\n\t\t/\\ MAC45':= Hash({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.Na2'.Ra')\n\t\t/\\ SND({A.Z.B.Nz'.Na2'}_CRP.{A.Z.B.Nz'.Na2'.Ra'}_CRP.MAC45')\n\t\t/\\ secret(K,sec_2,{A,B,Z}) /\\ secret(Ra',sec_6,{A,Z})\n\n\t\t/\\ request(A,Z,auth_1,Nz')\n\t\t/\\ witness(A,Z,auth_2,Nz')\n\n\t\t3. State=6 /\\ RCV({A.Z.B.Na2.Nb'}_CRP.MAC11') =|>\n\t\tState':=9 /\\ K':= xor(Hash(Na2),Hash(Nb'))\n\n\t\t/\\ request(A,B,auth_4,Na2)\nend role_A\n\nrole_Z role_Z(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by Z\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa,Na2,Nz,Nz2,Nb:text,\n\t\tMAC12,MAC3,MAC45,MAC678,MAC910,MAC11,Ca,Ra,Cb,Rb:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.Z.Na'}_CRP.{A.Z.Na'.B}_CRP.MAC12') =|>\n\t\tState':=3 /\\ Nz':=new() /\\ Nz2':=new() /\\ MAC3':=Hash({A.Z.B.Na'.Nz'}_CRP.Na'.Nz')\n\t\t/\\ SND({A.Z.B.Na'.Nz'}_CRP.MAC3')\n\t\t/\\ secret(Nz',sec_1,{A,Z})\n\n\t\t/\\ witness(Z,A,auth_1,Na')\n\n\t\t2. State=3 /\\ RCV({A.Z.B.Nz.Na2'}_CRP.{A.Z.B.Nz.Na2'.Ra'}_CRP.MAC45') =|>\n\t\tState':=5 /\\ MAC678':=Hash({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.Nz2.Na2'.A)\n\t\t/\\ SND({B.Z.Nz2}_CRPb.{B.Z.Nz2.Na2'}_CRPb.{B.Z.Nz2.Na2'.A}_CRPb.MAC678')\n\t\t/\\ secret(Nz2,sec_3,{B,Z})\n\n\t\t/\\ request(Z,A,auth_2,Na2')\n\n\t\t3. State=5 /\\ RCV({B.Z.A.Nz2.Nb'}_CRPb.{B.Z.A.Nz2.Nb'.Rb'}_CRPb.MAC910') =|>\n\t\tState':=7 /\\ Cb':= {Nz2.Nb'}_CRPb\n\t\t/\\ MAC11':= Hash({A.Z.B.Na2.Nb'}_CRP.Na2.Nb')\n\t\t/\\ SND({A.Z.B.Na2.Nb'}_CRP.MAC11')\n\n\t\t/\\ witness(Z,B,auth_3,Nz2)\n\t\t/\\ witness(Z,A,auth_4,Na2)\nend role\n\nrole role_B(A:agent,B:agent,Z:agent,CRPb:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tNa2,Nz2,Nb:text,\n\t\tMAC678,MAC910,Cb,Rb,K:message\n\tinit\n\t\tState := 4\n\ttransition\n\t\t1. State=4 /\\ RCV({B.Z.Nz2'}_CRPb.{B.Z.Nz2'.Na2'}_CRPb.{B.Z.Nz2'.Na2'.A}_CRPb.MAC678') =|>\n\t\tState':=8 /\\ Nb':=new() /\\ Cb':={Nz2'.Nb'}_CRPb /\\ Rb':=Hash(Cb')\n\t\t/\\ MAC910':= Hash({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.Nb'.Rb')\n\t\t/\\ K':= xor(Hash(Nb'),Hash(Na2'))\n\t\t/\\ SND({B.Z.A.Nz2'.Nb'}_CRPb.{B.Z.A.Nz2'.Nb'.Rb'}_CRPb.MAC910')\n\t\t/\\ secret(K,sec_4,{A,B,Z}) /\\ secret(Rb',sec_5,{B,Z})\n\n\t\t/\\ request(B,Z,auth_3,Nz2')\nend role\n\nrole session(A:agent,B:agent,Z:agent,CRP:symmetric_key,CRPb:symmetric_key,Hash:hash_func)\ndef=\n\tlocal\n\t\tRCV1,RCV3,SND2,RCV2,SND1,SND3:channel(dy)\n\tcomposition\n\t\trole_A(A,B,Z,CRP,Hash,SND1,RCV1) /\\\n\t\trole_Z(A,B,Z,CRP,CRPb,Hash,SND2,RCV2) /\\\n\t\trole_B(A,B,Z,CRPb,Hash,SND3,RCV3)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone1,drone2,groundstation:agent,\n\t\tcrp,crpb:symmetric_key,\n\t\th:hash_func,\n\t\tsec_1,sec_2,sec_3,sec_4,sec_5,sec_6,auth_1,auth_2,auth_3,auth_4:protocol_id\n\tintruder_knowledge = {drone1,drone2,groundstation,h}\n\n\tcomposition\n\t\tsession(drone1,drone2,groundstation,crp,crpb,h)\n\t\t/\\ session(drone1,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(i,drone2,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,i,groundstation,crp,crpb,h)\n\t\t%/\\ session(drone1,drone2,i,crp,crpb,h)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\tsecrecy_of sec_3\n\tsecrecy_of sec_4\n\tsecrecy_of sec_5\n\tsecrecy_of sec_6\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\n\tauthentication_on auth_4\nend goal\n\nenvironment()\n```"]], "HLPSL-1/practice3.hlpsl": [[false, "```houzhui\n%%%ESPECIFICATIONS OF THE PROBLEM%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%Agents:A Client,B Service Delivery Server, S Authentication Server%%%%%\n\n%Objectives/Goals:establishing a session key between A and B,mutual authentication between A and B\n\n%Assumptions and Restrictions:A has a symmetric key shared with S,B has a symmetric key shared with S,only S can generate session keys,do not use timestamps,efficiency in the messages structure and their number\n\n\n%role of cliente interpreted by alice%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A,S,B\t:agent,\n\t   Ka \t\t:symmetric_key,\n\t   SND_SA, RCV_SA, SND_BA, RCV_BA :channel(dy))\n\nplayed_by A\ndef=\n\tlocal State\t: nat,\n\tNa,Ns,Nb\t: text,\n\tK\t\t:symmetric_key,\n\tX\t\t:{symmetric_key.text.text.text}_symmetric_key\n\ninit State :=0\n\ntransition\n\n\t1. State =0     /\\ RCV_BA(start)=|>\n\t   State':=2    /\\ Na':=new()\n\t    \t        /\\ SND_SA(A.B.{Na'}_Ka)\n\n\t2. State =2\t/\\ RCV_SA(A.B.{K'.Na.Ns'}_Ka.X')=|>\n\t   State' :=4\t/\\ SND_BA(A.B.X'.{Na.Ns'}_K')\n\n\t3. State =4\t/\\ RCV_BA(A.B.{Ns.Nb.Na}_K)=|>\n\t   State' :=6\t/\\ request(A,alice_bob_na,B,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%role of the server authenticator %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole server(A,S,B\t:agent,\n\t   Ka,Kb\t:symmetric_key,\n\t   SND_AS, RCV_AS, RCV_BS :channel(dy))\n\nplayed_by S\ndef=\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State :=1\n\ntransition\n\n\t1. State =1 \t/\\ RCV_AS(A.B.{Na'}_Ka)\n\t\t\t/\\ RCV_BS(A.B.{Nb'}_Kb)=|>\n\t   State':=3\t/\\ Ns':=new()/\\K':=new()\n\t\t\t/\\ SND_AS(A.B.{K'.Na'.Ns'}_Ka.{K'.Na'.Nb'.Ns'}_Kb)\n\t\t\t/\\ secret(k,K',{A,B,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of service server interpreted by bob%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole bob(A,S,B\t:agent,\n\t   Kb\t:symmetric_key,\n\t   SND_AB, RCV_AB, SND_BS :channel(dy))\n\nplayed_by B\ndef=\n\n\tlocal State\t:nat,\n\tNs,Na,Nb\t:text,\n\tK\t\t:symmetric_key\n\ninit State:=0\n\ntransition\n\n\t1.State =0 \t/\\ RCV_AB(start)=|>\n\t  State':=2\t/\\Nb':=new()\n\t\t\t/\\ SND_BS(A.B.{Nb'}_Kb)\n\t\n\n\t\n\t3.State =5 \t/\\ RCV_AB(A.B.{K'.Na'.Nb'.Ns'}_Kb.{Na'.Ns'}_K')=|>\n\t  State' :=7 \t/\\ SND_AB(A.B.{Ns'.Nb.Na'}_K')\n\t\t\t/\\ witness(B,A,alice_bob_na,Na')\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%role of session to allow only S can generate sessions%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A, S, B\t:agent,\n\t     Ka,Kb\t:symmetric_key)\n\ndef=\n\tlocal\n\t  SSA,RSA,\n\t  SBA,RBA,\n\t  SAS,RAS,\n\t  SAB,RAB,\n\t  SBS,RBS: channel(dy)\n\t\n\tcomposition\n\t\n\t\talice (A,S,B,Ka,SSA,RSA,SBA,RBA)\n\t     /\\ server(A,S,B,Ka,Kb,SAS,RAS,RBS)\n\t     /\\ bob   (A,S,B,Kb,SAB,RAB,SBS)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole top()\ndef=\n\tconst a,b,s\t:agent,\n\t      ka,kb,ki  :symmetric_key,\t\n\t      alice_bob_na, k :protocol_id\n\n\tintruder_knowledge={a,b,s,ki}\n\n\tcomposition\n\t\t\n\t\t   session(a,s,b,ka,kb)\n\t\t/\\ session(a,s,i,ka,ki)\n\t\t/\\ session(i,s,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal \n  secrecy_of k\n  authentication_on alice_bob_na\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenviroment()\n```"]], "HLPSL-1/Project1Protocol.hlpsl": [[false, "```houzhui\n% 1. A -> B: A\n% 2. B -> A: {A,Nb'})_Kbs\n% 3. A -> S: A,B,Na,{A,Nb'}_Kbs\n% 4. S -> A: {Na,Kab,B,{Kab,A,Nb'}Kbs}Kas\n% 5. A -> B: {Kab,A,Nb'}_Kbs, {Na',A}_Kab\n% 6. B -> A: {Nb'.B}_Kab\n\n____(ROLE_0)____ ____(ROLE_1)____ (A,____(PARAM_1)____,____(PARAM_3)____ : agent,\n            ____(PARAM_2)____ : symmetric_key,\n            Snd,____(PARAM_0)____ : channel(dy)) \n        \nplayed_by A def=     \n\n    local State: ____(VARIABLE_0)____,\n          Na,Nb: text,\n          K_AB, K_BS:symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=____(STATE_0)____ /\\ Rcv(____(MESSAGE_7)____)\n            =|> State':=1 /\\ ____(MESSAGE_8)____(A)\n\n        2. State=____(STATE_1)____ /\\ ____(MESSAGE_9)____({A.Nb'}_K_BS')\n            =|> State':=2 /\\ Na':=new() \n                          /\\ Snd({A.B.Na'.{____(MESSAGE_10)____}_K_BS'}_K_AS)\n\n        3. State=____(STATE_3)____ /\\ Rcv({K_AB'.Na.B.{____(MESSAGE_11)____}_K_BS}_K_AS)\n            =|> State':=3 /\\ ____(MESSAGE_12)____({K_AB.A.Nb}_K_BS)\n\n        4. State=3 /\\ ____(MESSAGE_13)____(B)\n            =|> State':=4 /\\ Na':=new() \n                          /\\ ____(MESSAGE_14)____({Na'.A}_K_AB)   \n                          /\\ ____(EVENT_0)____(A,B,____(EVENT_1)____,Na')   \n\n        5. State=____(STATE_2)____ /\\ Rcv({____(MESSAGE_15)____}_K_AB)\n            =|> State':=5 /\\ wrequest(A,B,bob_alice_nb, Nb')\nend ____(ROLE_2)____\n\nrole bob (B,____(PARAM_4)____,____(PARAM_5)____: agent,\n          ____(PARAM_7)____: symmetric_key,\n          ____(PARAM_6)____,Rcv: channel(dy)) \n\nplayed_by B def=\n\n    local State: ____(VARIABLE_1)____,\n          Na,Nb: text,\n          K_AB: symmetric_key\n\n    init State:=0\n\n    transition\n        1. State=0 /\\ ____(MESSAGE_16)____(A')\n            =|> State':=1 /\\ Nb':=new()\n                          /\\ Snd({____(MESSAGE_17)____}_K_BS)\n\n        2. State=1 /\\ ____(MESSAGE_18)____({K_AB'.A'.Nb'}_K_BS) \n            =|> State':=2 /\\ ____(MESSAGE_19)____(B)\n            \n        3. State=2 /\\ ____(MESSAGE_20)____({Na'.A}_K_AB)                \n            =|> State':=3 /\\ Nb':=new() \n                          /\\ ____(MESSAGE_21)____({Nb'.B}_K_AB)  \n                          /\\ wrequest(B,A,alice_bob_na,Na')\n                          /\\ witness(B,____(EVENT_3)____,____(EVENT_2)____,Nb') \nend role\n\nrole server (S: ____(PARAM_10)____,\n             ____(PARAM_8)____,K_BS: ____(PARAM_11)____,\n             ____(PARAM_9)____, Rcv: channel(dy))\n              \nplayed_by S def=\n    \n    local A,____(VARIABLE_3)____ : ____(VARIABLE_2)____,\n          Na,Nb : text,\n          K_AB : symmetric_key\n\n    transition\n     1. ____(MESSAGE_22)____({A'.B'.Na'.{A'.Nb'}_K_BS'}_K_AS)\n        =|> K_AB':=new() /\\ Snd({K_AB'.Na.B.{____(MESSAGE_23)____}_K_BS}_K_AS)\n                         /\\ ____(EVENT_4)____(____(EVENT_6)____, skab, {A,____(EVENT_5)____,S})\n        \nend role\n\nrole securityProtocol(____(PARAM_16)____,B,S: ____(PARAM_15)____,\n                      K_AS,K_BS: ____(PARAM_14)____,\n                      ____(PARAM_13)____,Rcv : channel(____(PARAM_12)____)) def=\n    \n    composition\n        alice(A,B,S,K_AS,Snd,Rcv) /\\\n        server(S,K_AS,K_BS,Snd,Rcv) /\\\n        bob(B,A,S,K_BS,Snd,Rcv) \n                      \nend role\n\nrole environment() def=\n\n    local Snd, Rcv: channel(____(VARIABLE_4)____)\n\n    const ____(VARIABLE_5)____, b, s, i: ____(VARIABLE_6)____,\n          k_as, k_bs, k_is: symmetric_key,\n          ki: public_key,\n          sna,snb,alice_bob_na, skab,bob_alice_nb: protocol_id\n\n    intruder_knowledge = {a,b,s,i,k_is,inv(ki)}\n\n    composition\n        securityProtocol(a,b,s,k_as,k_bs,Snd,Rcv) /\\\n        % securityProtocol(i,b,s,k_is,k_bs,Snd,Rcv) /\\\n        securityProtocol(a,i,s,k_as,k_is,Snd,Rcv) \n\nend role\n\ngoal\n    %weak_authentication_on alice_bob_na\n    % works like this\n    %weak_authentication_on bob_alice_nb\n    secrecy_of ____(GOAL_24)____\nend goal\n\nenvironment()```"]], "HLPSL-1/An_Anonymous_Key_Distribution_Scheme_for_Group_Healthcare_Services_in_5G-Enabled_Multi-Server_Environments.hlpsl": [[false, "```houzhui\nrole user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SU, RU: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new() /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(E',g1,{U}) /\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi & Bi in the smart card %/\\ Store Ej', IDj, & Nj in the USB\n% Login and authentication phase\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card %/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose bij = 3\n/\\ N' := H(H(H(V'))) /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) /\\ Yij' := xor(E,Ej) /\\ Tu' := new() /\\ A' := xor(xor(BBi',W'),Tu') /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_v,V') /\\ witness(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts' %/\\ Confirm B %/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts') /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ request(S,U,s_u_ts,Ts')\nend role\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SS, RS: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, X, Y, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({IDi.Nj.Yij'}_Kus)\n/\\ secret(Xj',g5,{S})\n% Login and authentication phase\n2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu' %/\\ Use Xj to decrypt Yij %/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi.W).Tu')\n%/\\ Confirm A\n/\\ Ts' := new() /\\ B' := xor(H(H(H(H(V')))),Ts') /\\ IDinew' := H(Yij.IDi.H(Xj)) /\\ SKij' := H(xor(H(H(H(V'))),Yij)) /\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion. The server calculates ck0 and hide it into the following multiple equations, in which C1, C2 and C3 are predetermined, and Hj is equal to H4(skij||T2).\n/\\ C1' := new() /\\ C2' := new() /\\ C3' := new() /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3'))) /\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ witness(S,U,u_s_v,V')\n/\\ request(U,S,s_u_ts,Ts') /\\ request(U,S,u_s_tu,Tu')\nend role\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func) def=\nlocal SU, RU, SS, RS: channel (dy)\ncomposition\nuser (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SU,RU) /\\ server (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SS,RS)\nend role\nrole environment() def=\nconst u, s: agent,\nkus, skij, kui: symmetric_key,\nks, ki: public_key,\nh, h4, h5, sub, add, mul: hash_func,\nu_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5: protocol_id\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\ncomposition\nsession(u,s,kus,skij,ks,h,h4,h5,sub,add,mul) /\\ session(u,i,kui,kui,ks,h,h4,h5,sub,add,mul) /\\ session(i,s,kui,kui,ks,h,h4,h5,sub,add,mul)\nend role\ngoal\nsecrecy_of g1, g2, g3, g4, g5\nauthentication_on u_s_v, u_s_tu, s_u_ts\nend goal\nenvironment()\n```"]], "HLPSL-1/Projet.hlpsl": [[false, "```houzhui\n%%Purpose : Gestion d'un \"badge\" automatique pour les p\u00e9ages autoroutiers via le smartphone du client\n\n\n%% 1. Client -> Server : {Bonjour.C}_PKs\n\n%% (Server <--> BDD : get Pkc(C) )\n\n%% 2. Server -> Client : {Ns.Server}_PKc\n%% 3. Client -> Server : {Nc.Ns}_PKs\n%% 4. Server -> Client : {Nc.ClefSession}_PKc\n%% 5. Client -> Server : {IDSmartPhone}_ClefSession\n\n%% (Server <--> BDD : get solde(IDSmpartphone)\n%% if soldeClient > 0 ? ack\n%% else\n%% refuse)\n\n%% 6. Server -> Client : {Ack}_ClefSession\n%% 7. Client -> Server : {End}_ClefSession\n\n\n\n%% PKc, PKs respectivement les clefs publiques de Client et Serveur\n%% ClefSession une clef sym\u00e9trique fra\u00eeche\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le client, initiant le protocole\nrole client (Client, Server: agent,\n              PKc, PKs: public_key,\n              Sc, Rc: channel(dy),\n              Bonjour, Ack, IDSmartPhone : text)\n\n\nplayed_by Client def=\n  local n: nat,\n          Nc, Ns: text,\n          ClefSession: symmetric_key\n\n  init State:=0\n\n  transition\n\n  0.  State=0 /\\ RCV(start) =|>\n\tState':=1 /\\ SND({Bonjour.Client}_PKs)\n\n  1. State=1 /\\ RCV({Ns'.Server}_PKc) =|>\n\tState':=2 /\\ Nc':=new() /\\ secret(Nc', nc, {Client, Server}) /\\ SND({Nc'.Ns'}_PKs) /\\ witness(Client, Server, server_client_nc, Nc')\n\n  2. State=2 /\\ RCV({Nc.ClefSession'}_PKc)=|>\n  State':=3 /\\ secret(IDSmartPhone, idsmart, {Client, Server}) /\\ SND({IDSmartPhone}_ClefSession')\n\n  3. State=3 /\\ RCV({Ack}_ClefSession)=|>\n  State':=4 /\\ witness(Client, Server, client_server_ns, Ns)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le server\nrole server (Server: agent,\n              PKs: public_key,\n              Ss, Rs: channel(dy),\n\t\t\t        Ack, Bonjour: text,\n\t\t\t        Database_users: (agent.public_key) set,\n\t\t\t        Database_solde: (text.nat) set)\n\n\nplayed_by Server def=\n  local n, d: nat,\n          ClefSession: symmetric_key,\n        \tNs,Nc, IDSmartPhone: text,\n        \tPKc: public_key,\n\t\t\tClient: agent\n\n  init State:=0\n\n  transition\n\n  0. State=0 /\\ RCV({Bonjour.Client'}_PKs) /\\ in(Client'.PKc', Database_users) =|>\n\tState':=1 /\\ Ns':=new() /\\ secret(Ns', ns, {Client, Server}) /\\ witness(Server, Client, client_server_ns, Ns') /\\ SND({Ns'.Server}_PKc')\n\n  1. State=1 /\\ RCV({Nc'.Ns}_PKs) =|>\n  State':=2 /\\ ClefSession':=new() /\\ secret(ClefSession', clefsession, {Client, Server}) /\\ SND({Nc'.ClefSession'}_PKc)\n\n  2. State=2 /\\ RCV({IDSmartPhone'}_ClefSession) /\\ in(IDSmartPhone'.SoldeClient', Database_solde) /\\ not(SoldeClient=0) =|>\n  State':=3 /\\ SND({Ack}_ClefSession) /\\ witness(Server, Client, server_client_nc, Nc)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(Client,\n              Server: agent,\n              PKc, PKs: public_key,\n              Bonjour, Ack, IDSmartPhone: text,\n              Database_users: (agent.public_key) set,\n              Database_solde: (text.nat) set) def=\n\n  local Sc, Rc, Ss, Rs: channel(dy)\n\n  composition\n\n\tclient(Client, Server, PKc, PKs, Sc, Rc, Bonjour, Ack, IDSmartPhone)\n     /\\ server(Server, PKs, Ss, Rs, Ack, Bonjour, Database_users, Database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole scenario() def=\n\n  local\n    Database_users: (agent.public_key) set,\n    Database_solde: (text.nat) set\n\n  const\n    a1, a2, i: agent,\n    pk1, pk2, pkb, pki: public_key,\n    bonjour, ack, idsmartphone1, idsmartphone2, idsmartphonei: text,\n    solde1, solde2, soldei: nat,\n    idsmart, clefsession, ns, nc, client_server_ns, server_client_nc: protocol_id\n\n\n  init Database_users:={a1.pk1, a2.pk2, i.pki}\n      /\\ Database_solde:={idsmartphone1.solde1, idsmartphone2.solde2, idsmartphonei.soldei}\n\n  intruder_knowledge = {a1, a2, b, pk1, pk2, pkb, pki, inv(pki), idsmartphonei, soldei }\n\n  composition\n\n\tsession(a1, b, pk1, pkb, bonjour, ack, idsmartphone1, Database_users, Database_solde)\n    /\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, Database_users, Database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, Database_users, Database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, Database_users, Database_solde)\n\t/\\ session(a2, b, pk2, pkb, bonjour, ack, idsmartphone1, Database_users, Database_solde)\n\t/\\ session(a2, i, pk2, pki, bonjour, ack, idsmartphone2, Database_users, Database_solde)\n\t/\\ session(a1, i, pk1, pki, bonjour, ack, idsmartphone1, Database_users, Database_solde)\n\t/\\ session(i, b, pki, pkb, bonjour, ack, idsmartphonei, Database_users, Database_solde)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% GOAL section\n\ngoal\n  authentication_on client_server_ns\n  authentication_on server_client_nc\n\n  secrecy_of ns,\n              nc,\n              clefsession,\n              idsmart\nend goal\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()\n```"]], "HLPSL-1/protocol.hlpsl": [[true, "et2, {CR})\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone1(CR, DR1: agent, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\n\n    played_by DR1\n    def=\n    local State: nat,\n        Key1: symmetric_key,\n        EccMul, Add, Poly: hash_func,\n        G, MKdrj, Rj1, Rdrj, TSj1, IDdrj1, IDdrj2, IDgss, IDcr, RTSdrj, Rcr, Aj1, AAj1, Rdr, Msgd2d1: text,\n        Rj2, TSj2, TSj3, Bj2, ACKj1j2, Msgd2d3: text\n    const dr2_dr1_tsj2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr1_dr2_tsj3 : protocol_id\n\n    init State := 0\n    transition\n\n    %%%Receive registration message from CR\n\n    1. State = 0 /\\ Rcv({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1) =|>\n    State' := 1 /\\ Rdr' := new() /\\ Rj1' := new() /\\ TSj1' := new()\n                /\\ Aj1' := H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1')\n                /\\ AAj1' := EccMul(Aj1'.G)\n                /\\ Msgd2d1' := IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).IDgss.EccMul(Rcr'.G)).Rcr').TSj1'\n\n    %%% Send message Msgd2d1 to DR2\n        /\\ Snd(Msgd2d1')\n\n    %%% Receive message Msgd2d2 from the DR2\n    2. State = 1 /\\ Rcv(IDdrj2.EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).\n                    H(H(EccMul(Bj2'.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G)).\n                    Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr).\n                    Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'. TSj2').\n                    EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).TSj2'.IDdrj2).\n                    TSj2'.Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')) =|>\n\n    State' := 3 /\\ TSj3' := new()\n            /\\ ACKj1j2' := H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3')\n            /\\ Msgd2d3' := ACKj1j2'.TSj3'\n\n    %%% Send message Msgd2d3 to DR2\n            /\\ Snd(Msgd2d3')\n            \n            /\\ witness(DR1, DR2, dr1_dr2_rj1, Rj1')\n            /\\ witness(DR1, DR2, dr1_dr2_tsj1, TSj1')\n            /\\ witness(DR1, DR2, dr1_dr2_tsj3, TSj3')\n\n            /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\n            /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone2(CR: agent, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\n\n    played_by DR2\n    def=\n    local State: nat,\n        Key2: symmetric_key,\n        EccMul, Add, Poly: hash_func,\n        G, MKdrj, Rj1, Rdrj, IDdrj1, IDdrj2, IDgss, IDcr, Rcr, DKj2j1, SKj2j1: text,\n        TSj2, TSj3, Bj2, Bsmallj2, Rj2, Rdr, Msgd1d2, MKdrj1, RTSdrj, SKVj2j1, TSj1: text\n    const dr1_dr2_rj1, dr1_dr2_tsj1, dr1_dr2_tsj3, dr2_dr1_rj2, dr2_dr1_tsj2 : protocol_id\n\n    init State := 0\n    transition\n\n    %%%Receive registration message CR\n\n    1. State = 0 /\\ Rcv({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2) =|>\n    State' := 2 /\\ secret({Rcr',RTSdrj,MKdrj}, secret1, {CR})\n\n    %%% Receive message Msgd2d1 from the DR1\n    2. State = 2 /\\ Rcv(IDdrj1.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1').G).\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1')=|>\n    State' := 4 /\\ Rj1' := new() /\\ Rj2' := new() /\\ TSj2' := new()\n                /\\ Bsmallj2' := H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2')\n                /\\ Bj2' := EccMul(Bsmallj2'.G)\n                /\\ DKj2j1' := EccMul(Bsmallj2'.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G))\n                /\\ SKj2j1' := H(DKj2j1'.Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                    Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'.TSj2')\n\n                /\\ SKVj2j1' := H(SKj2j1'.Bj2'.TSj2'.IDdrj2)\n                /\\ Msgd1d2' := IDdrj2.Bj2'.SKVj2j1'.TSj2'.Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')\n\n    %%% Send message Msgd2d2 to DR1\n                /\\ Snd(Msgd1d2')\n\n    %%% Receive message Msgd2d3 from DR1\n    3. State = 4 /\\ Rcv(H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                    Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                    Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj1').TSj1') =|>\n\n    State' := 5 /\\ TSj3' := new() /\\ witness(DR2, DR1, dr2_dr1_rj2, Rj2')\n                /\\ request(DR2, DR1, dr2_dr1_tsj2, TSj2')\n\n                /\\ request(DR2, DR1, dr1_dr2_rj1, Rj1')\n                /\\ request(DR2, DR1, dr1_dr2_tsj1, TSj1')\n                /\\ request(DR2, DR1, dr1_dr2_tsj3, TSj3')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (CR, DR1, DR2: agent, H: hash_func)\n    def=\n    local Snd1, Rcv2, Snd3, Rcv1, Snd2, Rcv3: channel (dy)\n    composition\n        controlroom (CR, DR1, DR2, H, Snd1, Rcv1)\n        /\\ drone1 (CR, DR1, DR2, H, Snd2, Rcv2)\n        /\\ drone2 (CR, DR1, DR2, H, Snd3, Rcv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n    def=\n    const cr, dr1, dr2: agent,\n        h, eccMul, add, poly: hash_func,\n        tsj1, tsj2, tsj3: text,\n        secret1, secret2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\n    intruder_knowledge = {cr, dr1, dr2, h, eccMul, add, poly, tsj1, tsj2, tsj3}\n\n    composition\n        session(cr, dr1, dr2, h)\n        /\\ session(cr, dr1, i, h)\n        /\\session(cr, i, dr2, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Goal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    %%% Authentication\n    authentication_on dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_tsj2, dr2_dr1_rj2, dr1_dr2_tsj3\n\n    %%% Confidentiality\n    secrecy_of secret1, secret2\nend goal", "```avispa\net2, {CR})\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone1(CR, DR1: agent, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\n\n    played_by DR1\n    def=\n    local State: nat,\n        Key1: symmetric_key,\n        EccMul, Add, Poly: hash_func,\n        G, MKdrj, Rj1, Rdrj, TSj1, IDdrj1, IDdrj2, IDgss, IDcr, RTSdrj, Rcr, Aj1, AAj1, Rdr, Msgd2d1: text,\n        Rj2, TSj2, TSj3, Bj2, ACKj1j2, Msgd2d3: text\n    const dr2_dr1_tsj2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr1_dr2_tsj3 : protocol_id\n\n    init State := 0\n    transition\n\n    %%%Receive registration message from CR\n\n    1. State = 0 /\\ Rcv({IDdrj1.IDgss.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key1) =|>\n    State' := 1 /\\ Rdr' := new() /\\ Rj1' := new() /\\ TSj1' := new()\n                /\\ Aj1' := H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1')\n                /\\ AAj1' := EccMul(Aj1'.G)\n                /\\ Msgd2d1' := IDdrj1.AAj1'.Add(Rdrj'.H(EccMul(Rdrj'.G).IDgss.EccMul(Rcr'.G)).Rcr').TSj1'\n\n    %%% Send message Msgd2d1 to DR2\n        /\\ Snd(Msgd2d1')\n\n    %%% Receive message Msgd2d2 from the DR2\n    2. State = 1 /\\ Rcv(IDdrj2.EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).\n                    H(H(EccMul(Bj2'.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G)).\n                    Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr).\n                    Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'. TSj2').\n                    EccMul(H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2').G).TSj2'.IDdrj2).\n                    TSj2'.Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')) =|>\n\n    State' := 3 /\\ TSj3' := new()\n            /\\ ACKj1j2' := H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj3')\n            /\\ Msgd2d3' := ACKj1j2'.TSj3'\n\n    %%% Send message Msgd2d3 to DR2\n            /\\ Snd(Msgd2d3')\n            \n            /\\ witness(DR1, DR2, dr1_dr2_rj1, Rj1')\n            /\\ witness(DR1, DR2, dr1_dr2_tsj1, TSj1')\n            /\\ witness(DR1, DR2, dr1_dr2_tsj3, TSj3')\n\n            /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\n            /\\ request(DR1, DR2, dr2_dr1_tsj2, TSj2')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DRONE 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole drone2(CR: agent, DR1, DR2: agent, H: hash_func, Snd, Rcv: channel(dy))\n\n    played_by DR2\n    def=\n    local State: nat,\n        Key2: symmetric_key,\n        EccMul, Add, Poly: hash_func,\n        G, MKdrj, Rj1, Rdrj, IDdrj1, IDdrj2, IDgss, IDcr, Rcr, DKj2j1, SKj2j1: text,\n        TSj2, TSj3, Bj2, Bsmallj2, Rj2, Rdr, Msgd1d2, MKdrj1, RTSdrj, SKVj2j1, TSj1: text\n    const dr1_dr2_rj1, dr1_dr2_tsj1, dr1_dr2_tsj3, dr2_dr1_rj2, dr2_dr1_tsj2 : protocol_id\n\n    init State := 0\n    transition\n\n    %%%Receive registration message CR\n\n    1. State = 0 /\\ Rcv({IDdrj2.IDgss.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr')}_Key2) =|>\n    State' := 2 /\\ secret({Rcr',RTSdrj,MKdrj}, secret1, {CR})\n\n    %%% Receive message Msgd2d1 from the DR1\n    2. State = 2 /\\ Rcv(IDdrj1.EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rdr'.TSj1').G).\n                    Add(Rdrj'.H(EccMul(Rdrj'.G).EccMul(Rcr'.G).IDgss).Rcr').TSj1')=|>\n    State' := 4 /\\ Rj1' := new() /\\ Rj2' := new() /\\ TSj2' := new()\n                /\\ Bsmallj2' := H(IDdrj2.H(MKdrj.IDdrj2.IDcr.IDgss.RTSdrj').Rj2'.TSj2')\n                /\\ Bj2' := EccMul(Bsmallj2'.G)\n                /\\ DKj2j1' := EccMul(Bsmallj2'.EccMul(H(IDdrj1.H(MKdrj1.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'.TSj1').G))\n                /\\ SKj2j1' := H(DKj2j1'.Poly(IDdrj2.IDdrj1). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                    Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr'). TSj1'.TSj2')\n\n                /\\ SKVj2j1' := H(SKj2j1'.Bj2'.TSj2'.IDdrj2)\n                /\\ Msgd1d2' := IDdrj2.Bj2'.SKVj2j1'.TSj2'.Add(Rj2'.H(IDdrj2.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr')\n\n    %%% Send message Msgd2d2 to DR1\n                /\\ Snd(Msgd1d2')\n\n    %%% Receive message Msgd2d3 from DR1\n    3. State = 4 /\\ Rcv(H(H(EccMul(H(IDdrj1.H(MKdrj.IDdrj1.IDcr.IDgss.RTSdrj').Rj1'. TSj1').G).\n                    Poly(IDdrj1.IDdrj2). Add(Rj1'.H(EccMul(Rj1'.G).EccMul(Rcr'.G).IDgss).Rcr').\n                    Add(Rj2'.H(IDgss.EccMul(Rj2'.G).EccMul(Rcr'.G)).Rcr').TSj1'.TSj2').TSj1').TSj1') =|>\n\n    State' := 5 /\\ TSj3' := new() /\\ witness(DR2, DR1, dr2_dr1_rj2, Rj2')\n                /\\ request(DR2, DR1, dr2_dr1_tsj2, TSj2')\n\n                /\\ request(DR2, DR1, dr1_dr2_rj1, Rj1')\n                /\\ request(DR2, DR1, dr1_dr2_tsj1, TSj1')\n                /\\ request(DR2, DR1, dr1_dr2_tsj3, TSj3')\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (CR, DR1, DR2: agent, H: hash_func)\n    def=\n    local Snd1, Rcv2, Snd3, Rcv1, Snd2, Rcv3: channel (dy)\n    composition\n        controlroom (CR, DR1, DR2, H, Snd1, Rcv1)\n        /\\ drone1 (CR, DR1, DR2, H, Snd2, Rcv2)\n        /\\ drone2 (CR, DR1, DR2, H, Snd3, Rcv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n    def=\n    const cr, dr1, dr2: agent,\n        h, eccMul, add, poly: hash_func,\n        tsj1, tsj2, tsj3: text,\n        secret1, secret2, dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_rj2, dr2_dr1_tsj2, dr1_dr2_tsj3 : protocol_id\n\n    intruder_knowledge = {cr, dr1, dr2, h, eccMul, add, poly, tsj1, tsj2, tsj3}\n\n    composition\n        session(cr, dr1, dr2, h)\n        /\\ session(cr, dr1, i, h)\n        /\\session(cr, i, dr2, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Goal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    %%% Authentication\n    authentication_on dr1_dr2_rj1, dr1_dr2_tsj1, dr2_dr1_tsj2, dr2_dr1_rj2, dr1_dr2_tsj3\n\n    %%% Confidentiality\n    secrecy_of secret1, secret2\nend goal\n```"]], "HLPSL-1/RegVBNS.hlpsl": [[false, "```houzhui\nrole role_C(C:agent,M:agent,Na:text,Pd:text,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tNa_c:text,P:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({C.Na.Pd}_Kc)\n\t\t2. State=1 /\\ RCV({Na.Pd.F(Pd)}_Kc) =|> State':=2 /\\ P':=new() /\\ secret(P,sec_1,{C}) /\\ SND({Na.F(P'.F(Pd))}_Kc)\n\t\t4. State=2 /\\ RCV({C.Kp'.inv(Kp')}_Kc) =|> State':=3 /\\ secret(Kp',sec_2,{C,M})\nend role_C\n\nrole role_M(C:agent,M:agent,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by M\ndef=\n\tlocal\n\t\tState:nat,Na_m:text,Pd_m:text,F:hash_func,Kp:public_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.Na'.Pd'}_Kc) =|> State':=1 /\\ SND({Na'.Pd'.F(Pd')}_Kc)\n\t\t3. State=1 /\\ RCV({Na.F(P'.F(Pd))}_Kc) =|> State':=2 /\\ secret(P',sec_1,{C,M}) /\\ Kp':=new() /\\ secret(Kp',sec_2,{C,M}) /\\ SND({C.Kp'.inv(Kp')}_Kc)\nend role\n\nrole session1(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session2(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole session3(Pd:text,Na:text,C:agent,M:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_M(C,M,Kc,SND2,RCV2) /\\ role_C(C,M,Na,Pd,Kc,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tminer:agent,pd:text,client:agent,hash_0:hash_func,na:text,kc:symmetric_key,i:agent,dummy:text\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(pd,na,i,miner,kc) /\\ session2(pd,na,client,i,kc) /\\ session1(pd,na,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()\n```"]], "HLPSL-1/safe_new_syntax.hlpsl": [[false, "```houzhui\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(\n\tA, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text)\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Pa.Sid)\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientK') % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ event(alice_bob_na_nb,A,B,Na.Nb')\n\n   4.  State = 4   /\\ RCV({Finished}_ServerK) =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(bob_alice_na_nb,A,B,Na.Nb)\n       \t\t   /\\ secret(ClientK,secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK,secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(\n\tA, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ event(bob_alice_na_nb,B,A,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb.B.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ SND({H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 7. B -> A: {Finished\n              \t\t}_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb))) % }Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(alice_bob_na_nb,A,B,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, RA, SB, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/SmartCard.hlpsl": [[false, "```\n% Author -\t@Nagaraj Poti\n% Roll\t-\t20162010\n% --------------------------------------------------------------------------------\n\n% User role\n% --------------------------------------------------------------------------------\n\nrole user (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n\t% Dolev Yao model channels \n)\n\nplayed_by A \n\ndef=\n\nlocal\n\tState : nat,\t% Transition state\n\tNu : text,\t\t% Secret nonce\n\tID : text, \t\t% User ID chosen randomly\n\tPs : text,\t\t% Public key of the server\n\tC : text,\t\t% Smart card UID\n\tG : nat,\t\t\t% Server generator nonce\n\tP : nat,\t\t\t% Random prime nonce\n\tPWD : text,\t\t% User password\n\tQ1 : text,\t\t% Smart card UID - Part I\n\tQ2 : text,\t\t% Smart card UID - Part II \n\tCnew : text,\t% Login computed C\n\tAnew : text,\t% Login computed check\n\tN1 : nat,\t\t% Random nonce n1\n\tN2 : nat,\t\t% Random nonce alpha\n\tV : text,\t\t% V corresponding to K1 computation\n\tX : text,\t\t% Message\n\tVs : text, \t\t% V corresponding to computation at server\n\tSK : text,\t\t% Session key client side\n\tTID : text\t\t% Ticket generated by user\n\ninit \n\tState := 0\n\ntransition\n\n% Registration initiated by user - sends ID to server along with secret nonce \n0.\tState = 0 /\\ RCV(start) =|> \n\t\tState' := 2 /\\ Nu' := new() /\\ ID' := new() /\\ SND(ID'.{ID'.Nu'}_S)\n\t\t/\\ witness(A, A, nua, Nu')\n\n% User receives smartcard from the server and stores it locally along with password\n2.\tState = 2 /\\ RCV({C'.Ps'.G'.P'}_S) =|> \n\t\tState' := 4 /\\ PWD' := new() /\\ Q1' := xor(C', H(PWD'.ID)) \n\t\t/\\ Q2' := H(C'.PWD'.ID) /\\ secret(cid, C', {A, B}) \n\t\t\n% User enters uid and pwd and waits for verification from smart card\n4. State = 4 /\\ RCV(start) =|> \n\t\tState' := 6 /\\ Cnew' := xor(Q1, H(PWD.ID)) /\\ Anew' := H(Cnew'.PWD.ID)\n\t\t\n% User sends verified ticket to server by binding it with public key\n6. State = 6 /\\ Anew = A /\\ RCV(start) =|> \n\t\tState' := 8 /\\ N1' := new() /\\ N2' := new() /\\ V' := exp(G, H(N2'.C))  \n\t\t/\\ TID' := xor(ID.N1', H(exp(Ps, H(N2'.C)))) \n\t\t/\\ SND(xor(ID.N1', H(exp(Ps, H(N2'.C)))).V') \n\t\t/\\ witness(A, B, user_server_tid, TID') \n\t\t/\\ witness(A, B, user_server_v, V') \n\n% User receives response message from the server via public channel\t\t\n10. State = 8 /\\ RCV(Vs'.X') =|>\n\t\tState' := 10 /\\ SK' := exp(Vs', H(N2.C))\n\t\n% User sends confirmation message to server via public channel\n12. State = 10 /\\ H(V.C.Vs.SK.N1) = X /\\ RCV(start) =|>\n\t\tState' := 12 /\\ SND(H(SK.Vs.C.N1)) /\\ witness(A, B, user_server_v2, H(SK.Vs.C.N1))\n\t\t/\\ request(A, B, user_server_conf, X)  \t\n\t\t\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Server role\n% --------------------------------------------------------------------------------\n\nrole server (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func,\n\t% H is a cryptographic hash function\n\tSND, RCV : channel(dy)\n)\n\nplayed_by B\n\ndef=\n\nlocal \n\tState : nat,\t% Transition state\n\tID : text,\t\t% Client ID\n\tNu : text,\t\t% User identifier and validator token\n\tSD : text, \t\t% Smart card ID\n\tKs : text,\t\t% Server secret key\n\tG : nat, \t\t% Generator of the class\n\tP : nat,\t\t\t% Random prime nonce\n\tTID : text,\t\t% Ticket from user\n\tV : text,\t\t% V corresponding to K1 computation at user end\n\tK2 : text,\t\t% K2 computation\n\tU : text,\t\t% Incoming user tid - ID + Ks combo\n\tQ : nat, \t\t% Random nonce at the server\n\tSK : text,\t\t% Session key server side\n\tVs : text, \t\t% V corresponding to computation at server \n\tX : text,\t\t% Message\n\tConf : text,\t% Final confirmation message\n\tACK : text,\t\t% Final acknowledgment sent to user\n\tC : text\t\t\t% Smart card UID client\n\ninit\n\tState := 1\n\ntransition\n\n% Server receives request from user for authentication and new smart card \n% if the user does not exist in the database\n1.\tState = 1 /\\ RCV(ID'.{Nu'}_S) =|> \n\t\tState' := 3 /\\ SD' := new() /\\ SND({H(ID'.Ks.SD').exp(G, Ks).G.P}_S) \n\t\t/\\ witness(B, A, server_user_sid, SD')\n\n% Server verifies whether user is properly authenticated\n7. State = 3 /\\ RCV(TID'.V') =|>\n\t\tState' := 5 /\\ K2' := exp(V', Ks) /\\ U' := xor(TID', K2')\n\n% Server computes decryption key and after computation sends response message\t\t\n9. State = 5 /\\ U = H(ID.Ks) /\\ RCV(start) =|>\n\t\tState' := 7 /\\  Q' := new() /\\ SK' := exp(V, H(Ks.Q')) \n\t\t/\\ Vs' := exp(G, H(Ks.Q')) /\\ C' := H(ID.Ks.SD) \n\t\t/\\ X' := H(V.H(ID.Ks.SD).Vs'.SK.Nu)\t/\\ SND(Vs'.X') \n\n% If confirmation message is received well and successfully, successive \n% communication is done with the session key\n13. State = 7 /\\ RCV(Conf') /\\ H(SK.Vs.C.Nu) = Conf =|> SND({ACK}_SK)\n\t\t/\\ request(B, A, server_user_ack, ACK)\n\t\t\t\t\t\t\nend role\t\n\n% --------------------------------------------------------------------------------\n\n\n% Session role\n% --------------------------------------------------------------------------------\n\nrole session (\n\tA, B : agent,\n\t% A is the user and B is the server\n\tS : symmetric_key,\n\t% S is the symmetric key between the user and the server\n\tH : hash_func\n\t% H is a cryptographic hash function\n)\n\ndef=\n\nlocal \n\tSAB, RAB, SBA, RBA : channel(dy)\n\ncomposition\n\tuser(A, B, S, H, SAB, RAB) /\\ server(A, B, S, H, SBA, RBA)\n\nend role\n\n% --------------------------------------------------------------------------------\n\n\n% Environment role\n% --------------------------------------------------------------------------------\n\nrole environment()\n\ndef=\n\nconst \n\tnua, user_server_v, user_server_tid, user_server_v2, server_user_sid,\n\tuser_server_v2, user_server_conf, server_user_ack : protocol_id,\n\ta, b : agent,\n\tsab, sai, sib : symmetric_key,\n\th : hash_func\n\t\nintruder_knowledge = {a, b, sai, sib, h}\n\ncomposition\n\tsession(a, b, sab, h)  \n\t/\\ session(a, b, sab, h) \n\t/\\ session(a, i, sai, h) \n\t/\\ session(i, b, sib, h)\n\t \nend role\n\n% --------------------------------------------------------------------------------\n\n% Goals\n% --------------------------------------------------------------------------------\n\ngoal\n\tauthentication_on nua\t% User nonce generated during registration is weak auth\n\tsecrecy_of cid\t\t\t\t% Smart card must remain secret to user\n\tweak_authentication_on user_server_tid\t% Ticket identifies user issuing request\n\tweak_authentication_on user_server_v\t% Identifies user issuing request\n\tauthentication_on user_server_v2\t\t\t% Final confirmation of session establishment\n\tauthentication_on user_server_conf\t\t% Final confirmation of session establishment\n\tweak_authentication_on server_user_sid\t% Smart card id associated with user\n\tauthentication_on server_user_ack\t\t% Final confirmation before session establishment\nend goal\n\n% --------------------------------------------------------------------------------\nenvironment()\n```"]], "HLPSL-1/SMC-5-Party.hlpsl": [[false, "```proverif\nrole role_A(A,B,C,D,E:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0\n        =|> State':=1 /\\ Xa':=new() /\\ Ya':=new()                   \n      /\\ SND({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb) \n      /\\ SND({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc) \n      /\\ SND({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) \n      /\\ SND({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) \n      /\\ secret(SHA256(Xa).SHA256(Ya),sec_1,{A,B,C,D,E}) \n\n      2. State=1 /\\ RCV({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xb')}_Kb.{SHA256(Yb')}_Kb}_Ka)\n        =|> State':=2 /\\ witness(A,B,auth_1,Xb'.Yb') \n\n      3. State=2 /\\ RCV({C.A.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xc')}_Kc.{SHA256(Yc')}_Kc}_Ka)\n        =|> State':=3 /\\ witness(A,C,auth_1,Xc'.Yc') \n\n      4. State=3 /\\ RCV({D.A.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Ka) \n        =|> State':=4 /\\ witness(A,D,auth_1,Xd'.Yd') \n\n      5. State=4 \n      /\\ RCV({E.A.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Ka) \n     =|> State':=5 /\\ witness(A,E,auth_1,Xe'.Ye') \n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B,C,D,E,A:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV({A.B.{Xa'}_Ka.{Ya'}_Ka}_Kb)   \n        =|> State':=1 /\\ Xb':=new() /\\ Yb':=new()                   \n      /\\ SND({B.A.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xb')}_Kb.{SHA256(Yb')}_Kb}_Ka) \n      /\\ secret(SHA256(Xb).SHA256(Yb),sec_1,{A,B}) \n      /\\ request(B,A,auth_1,Xa'.Ya') \n\n      2. State=1  \n      /\\ SND({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc) \n      /\\ SND({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd) \n      /\\ SND({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke) \n      =|> State':=2 \n\n      3.State=2 /\\ RCV({C.B.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xc')}_Kc.{SHA256(Yc')}_Kc}_Kb) \n        =|> State':=3 /\\ witness(B,C,auth_1,Xc'.Yc') \n\n      4. State=3 \n      /\\ RCV({D.B.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Kb) \n     =|> State':=4 /\\ witness(B,D,auth_1,Xd'.Yd')      \n \n      5. State=4  \n      /\\ RCV({E.B.{Xe'}_Ke.{Ye'}_Ke.{SHA256(Xe')}_Kb.{SHA256(Ye')}_Kb}_Kb) \n     =|> State':=4  /\\ request(B,E,auth_1,Xe.Ye)     \n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_C(C,E,A,D,B:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n      1. State=0 /\\ RCV({A.C.{Xa'}_Ka.{Ya'}_Ka}_Kc)   \n        =|> State':=1 /\\ Xc':=new() /\\ Yc':=new()                   \n      /\\ SND({C.A.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xc')}_Kc.{SHA256(Yc')}_Kc}_Ka) \n      /\\ secret(SHA256(Xc).SHA256(Yc),sec_1,{A,C}) \n      /\\ request(C,A,auth_1,Xa'.Ya') \n\n      2. State=1  \n      /\\  RCV({B.C.{Xb'}_Kb.{Yb'}_Kb}_Kc)\n       =|> State':=2 /\\ Xc':=new() /\\ Yc':=new()                   \n      /\\ SND({C.B.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xc')}_Kc.{SHA256(Yc')}_Kc}_Kb) \n      /\\ secret(SHA256(Xc).SHA256(Yc),sec_1,{B,C}) \n      /\\ request(C,B,auth_1,Xb'.Yb') \n      /\\ SND({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd) \n      /\\ SND({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke)\n\n    3.State=2 \n    /\\ RCV({D.C.{Xc}_Kc.{Yc}_Kc.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Kc) \n    =|> State':=3   /\\ request(C,D,auth_1,Xc.Yc) \n\n    4. State=3\n    /\\   RCV({E.C.{Xc}_Kc.{Yc}_Kc.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Kc) \n     =|> State':=4   /\\ request(C,E,auth_1,Xc.Yc)  \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_D(D,E,C,A,B:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.D.{Xa'}_Ka.{Ya'}_Ka}_Kd) =|> State':=1 /\\ Xd':=new() /\\ Yd':=new()                   \n    /\\ SND({D.A.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Ka) \n    /\\ secret(SHA256(Xd).SHA256(Yd),sec_1,{A,D}) \n    /\\ request(D,A,auth_1,Xa'.Ya')     \n\n    2.State=1\n      /\\  RCV({B.D.{Xb'}_Kb.{Yb'}_Kb}_Kd)\n    =|> State':=2 /\\ Xd':=new() /\\ Yd':=new()                   \n    /\\ SND({D.B.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Kb) \n    /\\ secret(SHA256(Xd).SHA256(Yd),sec_1,{B,D}) \n    /\\ witness(D,B,auth_1,Xb'.Yb')    \n\n    3.State=2 /\\ RCV({C.D.{Xc'}_Kc.{Yc'}_Kc}_Kd)\n             =|> State':=3 /\\ Xd':=new() /\\ Yd':=new()   \t\n    /\\ SND({D.C.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xd')}_Kd.{SHA256(Yd')}_Kd}_Kc) \n    /\\ secret(SHA256(Xd).SHA256(Yd),sec_1,{C,D}) \n    /\\ witness(D,C,auth_1,Xc'.Yc') \n    /\\ SND({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke)\n\n  4.State=3\n  /\\  RCV({E.D.{Xd}_Kd.{Yd}_Kd.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Kd) \n   =|> State':=4 /\\ request(D,E,auth_1,Xd.Yd)      \n               \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_E(E,D,C,A,B:agent,\n \t    Ka,Kb,Kc,Kd,Ke:public_key,\n\t    SHA256:hash_func,\n\t    SND,RCV:channel(dy))\nplayed_by E\ndef=\n\tlocal\n\t\tState:nat,\n\t\tXa,Ya,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text \n\tinit\n\t\tState := 0\n\ttransition\n    1.State=0 /\\ RCV({A.E.{Xa'}_Ka.{Ya'}_Ka}_Ke) =|> State':=1 /\\ Xe':=new() /\\ Ye':=new()                   \n    /\\ SND({E.A.{Xa'}_Ka.{Ya'}_Ka.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Ka) \n    /\\ secret(SHA256(Xe).SHA256(Ye),sec_1,{A,E}) \n    /\\ request(E,A,auth_1,Xa'.Ya') \n\n    2.State=1  \n    /\\  RCV({B.E.{Xb'}_Kb.{Yb'}_Kb}_Ke) \n    =|> State':=2 /\\ Xe':=new() /\\ Ye':=new()                   \n    /\\ SND({E.B.{Xb'}_Kb.{Yb'}_Kb.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Kb) \n    /\\ secret(SHA256(Xe).SHA256(Ye),sec_1,{B,E}) \n    /\\ witness(E,B,auth_1,Xb'.Yb')  \n\n    3.State=2 \n    /\\   RCV({C.E.{Xc'}_Kc.{Yc'}_Kc}_Ke) \n    =|> State':=3 /\\ Xe':=new() /\\ Ye':=new()   \t\n    /\\ SND({E.C.{Xc'}_Kc.{Yc'}_Kc.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Kc) \n    /\\ secret(SHA256(Xe).SHA256(Ye),sec_1,{C,E}) \n    /\\ witness(E,C,auth_1,Xc'.Yc')\n\n    4.State=3\n     /\\   RCV({D.E.{Xd'}_Kd.{Yd'}_Kd}_Ke)\n      =|> State':=4 /\\ Xe':=new() /\\ Ye':=new()   \t\n    /\\ SND({E.D.{Xd'}_Kd.{Yd'}_Kd.{SHA256(Xe')}_Ke.{SHA256(Ye')}_Ke}_Kd) \n    /\\ secret(SHA256(Xe).SHA256(Ye),sec_1,{D,E}) \n    /\\ request(E,D,auth_1,Xd'.Yd') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B,C,D,E:agent,Xb,Yb,Xc,Yc,Xd,Yd,Xe,Ye:text,Ka,Kb,Kc,Kd,Ke:public_key,SHA256:hash_func)\ndef=\n\tlocal\t\n      SND5,RCV5,RCV3,SND4,SND3,RCV4,SND2,RCV2,SND1,RCV1 :channel(dy)\n\tcomposition\n       role_A(A,B,C,D,E,Ka,Kb,Kc,Kd,Ke,SHA256,SND1,RCV1)  \t\t\n        /\\ role_B(B,C,D,E,A,Ka,Kb,Kc,Kd,Ke,SHA256,SND2,RCV2) \t\t\n        /\\ role_C(C,D,E,A,B,Ka,Kb,Kc,Kd,Ke,SHA256, SND3,RCV3) \t\t\n        /\\ role_D(D,E,C,A,B,Ka,Kb,Kc,Kd,Ke,SHA256, SND4,RCV4)\t\n        /\\ role_E(E,D,C,A,B,Ka,Kb,Kc,Kd,Ke,SHA256, SND5,RCV5)\n\t\t\t\t \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\tconst\n\t\tka,kb,kc,kd,ke,ki:public_key,\n\t\ta,b,c,d,e:agent,\n                \txb1,yb1,xc1,yc1,xd1,yd1,xe1,ye1:text,\n\t\tsha256:hash_func,\n               \t sec_1,auth_1:protocol_id               \n\t\tintruder_knowledge=  \n                 {a,b,c,d,e,ka,kb,kc,kd,ke,ki,inv(ki)}\n\tcomposition\n           session(a,b,c,d,e,xb1,yb1,xc1,yc1,xd1,yd1,xe1,ye1,ka,kb,kc,kd,ke,sha256) \n\t\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy sec_1\n  authentication_on auth_1\n\nend goal\n\nenvironment()\n```"]], "HLPSL-1/SPEKE.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: SPEKE\n%% VARIANT: SPEKE (with strong password-only authentication)\n%% PURPOSE: Strong Password-Only Authenticated Key Exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/jablon96strong.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : exp(S(A,B), Na)     |    key exchange part\n%% B -> A : exp(S(A,B), Nb)     |\n%%\n%%               both A and B compute\n%%               K = exp(exp(S(A,B),Na), Nb) = exp(exp(S(A,B),Nb), Na)\n%%\n%% A -> B : {Ca}_K              |\n%% B -> A : {Cb,Ca}_K           |    challenge/response\n%% A -> B : {Cb}_K              |    authentication part\n%%\n%% S(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%% NOTES: None\n%%\t\n%%HLPSL:\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Init (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n                 \n  local  State: nat,\n         Na,Ca: text,\n         Cb   : text,\n         X,K  : message\n\n  const  sec_i_Ca, sec_i_Cb : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|> \n      State':= 1 /\\ Na' := new()\n                 /\\ Snd(exp(Kab, Na')) \n        \n   2. State  = 1 /\\ Rcv(X) =|>  \n      State':= 2 /\\ Ca' := new()\n                 /\\ K' := exp(X',Na)\n\t\t /\\ Snd({Ca'}_exp(X',Na))\n\t\t /\\ secret(Ca',sec_i_Ca,{A,B})\n\t\t /\\ witness(A,B,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb'.Ca}_K ) =|> \n      State':= 3 /\\ Snd({Cb'}_K)\n\t\t /\\ secret(Cb',sec_i_Cb,{A,B})\n\t\t /\\ request(A,B,cb,Cb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Resp (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n           \n\n  local State: nat, \n        Nb,Cb: text,\n        Ca   : text,\n        Y,K  : message\n\n  const sec_r_Ca, sec_r_Cb : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(Y) =|> \n      State':= 1 /\\ Nb' := new()\n                 /\\ Snd(exp(Kab, Nb'))\n\t\t /\\ K' := exp(Y', Nb')\n\n   2. State  = 1 /\\ Rcv({Ca'}_K) =|>  \n      State':= 2 /\\ Cb' := new()\n                 /\\ Snd({Cb'.Ca'}_K)\n\t\t /\\ secret(Ca',sec_r_Ca,{A,B})\n\t\t /\\ secret(Cb',sec_r_Cb,{A,B})\n\t\t /\\ witness(B,A,cb,Cb')\n\t\t /\\ request(B,A,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb'}_K) =|> \n      State':= 3 \n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n\t      Kab: symmetric_key)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n\n       speke_Init(A,B,Kab,SA,RA)\n    /\\ speke_Resp(A,B,Kab,SB,RB)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        ca, cb        : protocol_id\n\n  intruder_knowledge = {a, b, kai, kbi}\n\n  composition\n\tsession(a,b,kab)\n    /\\  session(a,i,kai)\n    /\\  session(i,b,kbi)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n   % Confidentiality (G12)\n   %secrecy_of Ca, Cb \n   secrecy_of sec_i_Ca,sec_i_Cb,\n              sec_r_Ca,sec_r_Cb\n\n   % Message Authentication (G2)\n   % SPEKE_Init authenticates SPEKE_Resp on cb\n   authentication_on cb\n\n   % Message Authentication (G2)\n   % SPEKE_Resp authenticates SPEKE_Init on ca\n   authentication_on ca\n\nend goal  \n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/SRP.hlpsl": [[false, "```\nhouzhui\n%% PROTOCOL: SRP: Secure remote passwords\n%% PURPOSE: A client and a server authenticate each other based on \n%% a password such that the password remains secret, even if it is guessable.\n%% REFERENCE: \n%% \\begin{itemize}\n%% \\item \\url{http://srp.stanford.edu/}\n%% \\item  RFC 2945~\\cite{RFC2945}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%% ALICE_BOB:\n%% We have a password $p$ initially shared between the participants\n%% and a random number $s$, the \\emph{salt} (which at least the server knows \n%% initially). Original protocol, according to RFC:\n%% \\begin{verbatim}\n%% identifiers & macros:\n%% U = <username> \n%% p = <raw password>\n%% s = <salt from passwd file> (see notes section below)\n%% N = <modulus>\n%% x = SHA(s | SHA(U | \":\" | p))\n%% v = g^x mod N, the \"password verifier\"\n%% a = <random number, chosen by U>\n%% b = <random number, chosen by the server> \n%% A = g^a mod N\n%% B = v + g^b mod N\n%% u = H(A,B)\n%% S = (B - g^x) ^ (a + u * x) mod N \n%%   = (A * v^u) ^ b mod N\n%% K = SHA_Interleave(S)\n%% M = H(H(N) XOR H(g),H(U),s,A,B,K)\n%% -----------------------------------------------------------------\n%% Client -> Host   : U,A\n%% Host   -> Client : s,B\n%% Client -> Host   : M\n%% Host   -> Client : H(A,M,K)\n%% -----------------------------------------------------------------\n%% \\end{verbatim}\n%% Simplified version:\n%% \\begin{verbatim}\n%% Macros:\n%% K = H(V.(G^Na)^Nb)\n%% M = H(H(G),H(A).Salt.G^Na.{G^Nb}V.K)\n%% -----------------------------------------------------------------\n%% A -> B : A, G^Na\n%% B -> A : Salt, {G^Nb}V\n%% A -> B : M\n%% B -> A : H(G^Na,M,K)\n%% \\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% LIMITATIONS:\n%% Note that the protocol is slightly simplified as in the original version\n%% a full-scale algebraic theory is required. \n%% NOTES: \n%% A salt is a commonly-used mechanism to render dictionary\n%% (i.e. guessing) attacks more difficult.  Standard UNIX password\n%% files, for instance, store a hash of each password prepended with\n%% a two-character salt.  In this way, each possible password can map\n%% to 4096 different hash values, as there are 4096 possible\n%% values for the salt.  This therefore greatly increases the \n%% computing power required for an intruder to mount a password\n%% guessing attack based on a precomputed dictionary of passwords\n%% and corresponding hash values.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole srp_Init (A,B : agent,\n               Password : symmetric_key,\n\t       H : hash_func,\n\t       G : text,\n               Snd,Rcv:channel(dy))\nplayed_by A\ndef=\n\n  local State : nat, \n\tNa    :text,\n\tSalt  : protocol_id,\n\tDHY, V, K, M : message\n\n  const sec_i_K : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(start) =|>\n     State':= 1 /\\ Na' := new()\n                /\\ Snd(A.exp(G,Na'))  \n\n  2. State = 1  /\\ Rcv(Salt'.{DHY'}_(exp(G,H(Salt'.H(A.Password))))) =|> \n     State':= 2 /\\ V' := exp(G,H(Salt'.H(A.Password))) \n                /\\ K' := H( V'.exp(DHY',Na) )\n                /\\ M' := H(H(G).H(A).Salt'.exp(G,Na).{DHY'}_V'.K' )\n                /\\ Snd( M' )\n                /\\ witness(A,B,k1,K')\n                /\\ secret(K',sec_i_K,{A,B})\n\n  3. State = 2  /\\ Rcv(H(exp(G,Na).M.K)) =|>  \n     State':= 3\n                /\\ claim(A,B,k2,K)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole srp_Resp (B, A: agent,\n               Password: symmetric_key,\n\t       Salt: protocol_id,\n\t       H: hash_func,\n\t       G: text,\n               Snd, Rcv:channel(dy))\nplayed_by B\ndef=\n\n  local State : nat, \n\tNb    : text,\n\tM, K, DHX, V: message\n\n  const sec_r_K : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ Rcv(A.DHX') =|> \n     State':= 1 /\\ Nb' := new()\n                /\\ Snd(Salt.{exp(G,Nb')}_(exp(G,H(Salt.H(A.Password)))))\n                /\\ V' := exp(G,H(Salt.H(A.Password)))\n                /\\ K' := H( V'.exp(DHX',Nb') )\n                /\\ M' := H(H(G).H(A).Salt.DHX'.{exp(G,Nb')}_V'.K')\n                /\\ claim(B,A,k2,K')\n                /\\ secret(K',sec_r_K,{A,B})\n\n  2. State = 1  /\\ Rcv(M) =|>\n     State':= 3 /\\ Snd(H(DHX.M.K)) \n                /\\ witness(B,A,k1,K)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A,B: agent,\n\t     Password: symmetric_key,\n\t     Salt: protocol_id,\n\t     H: hash_func,\n\t     G: text)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n           srp_Init(A,B,Password,H,G,SA,RA)  /\\\n           srp_Resp(B,A,Password,Salt,H,G,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n  const k1,k2 : protocol_id,\n\ta,b,i: agent,\n\tkab,kai,kbi: symmetric_key,\n\ts_ab,s_ai,s_bi: protocol_id,\n\th: hash_func,\n\tg: text\n\t\n  intruder_knowledge = {i, kai, kbi, s_ai, s_bi}\n  composition\n\t   session(a,b,kab,s_ab,h,g)\n\t/\\ session(a,i,kai,s_ai,h,g)\n\t/\\ session(b,i,kbi,s_bi,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n  \ngoal\n\n    % confidentiality (G12)\n    secrecy_of sec_i_K, sec_r_K\n\n    % Entity Authentication (G1)\n    % Message Authentication (G2)\n    % Replay Protection (G3) --- forgotten in d6.1\n    authentication_on k2\n    authentication_on k1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/strongAuthentication_assym.hlpsl": [[false, "```houzhui\nrole role_A(A:agent,B:agent,SND:channel(dy),RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by A\ndef=\n\tlocal\n\t\tNa:nat,S_rcv:text,UnusedVar:text\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Kb)\n\t\t2. State=1 /\\ RCV({Na.S'}_Ka) =|> State':=2\n\n               %% A checks that B is the emmiter of nonce\n                /\\ witness(A,B,auth_1,Na) \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy),Ka:public_key,Kb:public_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na_rcv:nat\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV({Na'}_Kb)  =|> State':=1 /\\ SND({Na'.S}_Ka)\n                \n                /\\ is_secret(S,sec_1,{A,B}) \n                %% B Check the athentication of nonce\n                /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text,Ka:public_key,Kb:public_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2,Ka,Kb) /\\ role_A(A,B,SND1,RCV1,Ka,Kb)\nend role\n\nrole environment()\ndef=\n\tconst\n\t               alice,bob:agent,\n                               s1:text,\n                               sec_1,sec_2,auth_1:protocol_id,\n                               ka:public_key,\n                               kb:public_key\n\n\tintruder_knowledge = {alice,bob,kb}\n\n\tcomposition\n                               %% add another session for replay attack\n\t\tsession(alice,bob,s1,ka,kb) /\\ session(alice,bob,s1,ka,kb)\nend role\n\ngoal \n                secrecy_of sec_1   \n                secrecy_of sec_2\n                %%  weak_authentication_on auth_1 , wrequest\n                authentication_on auth_1\nend goal\n\nenvironment()```"]], "HLPSL-1/strongAuthentication_symm.hlpsl": [[false, "```houzhui\n%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,SND1:channel(dy),RCV:channel(dy),Sk:symmetric_key)\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,S:text,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND({Na'}_Sk)\n\t\t2. State=1 /\\ RCV({Na.S'}_Sk) =|> State':=2\n\n               %% A checks that B is the emmiter of nonce\n                /\\ request(A,B,auth_1,Na) \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND2:channel(dy),RCV:channel(dy),Sk:symmetric_key)\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV({Na'}_Sk)  =|> State':=1 /\\ SND({Na'.S}_Sk)\n                \n                /\\ secret(S,sec_1,{S,B}) \n                %% B Check the athentication of nonce\n                /\\ witness(B,A,auth_1,Na) \nend role\n\nrole session(A:agent,B:agent,S:text,Sk:symmetric_key)\ndef=\n\tlocal\n\t\tRCV1,RCV2,SND1,SND2:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2,Sk) /\\ role_A(A,B,SND1,RCV1,Sk)\nend role\n\nrole environment()\ndef=\n\tconst\n\t               alice,bob:agent,\n                               s1:text,\n                               sec_1,sec_2,auth_1:protocol_id,\n                               sk:symmetric_key\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n                               %% add another session for replay attack\n\t\tsession(alice,bob,s1,sk) /\\ session(alice,bob,s1,sk)\nend role\n\ngoal \n                secrecy_of sec_1   \n                secrecy_of sec_2\n                %%  weak_authentication_on auth_1 , wrequest\n                authentication_on auth_1\nend goal\n\nenvironment()```"]], "HLPSL-1/An_Autonomous_Log_Storage_Management_Protocol_with_Blockchain_Mechanism_and_Access_Control_for_the_Internet_of_Things.hlpsl": [[false, "```houzhui\nrole user ____(ROLE_0)____ (A, S, U: ____(PARAM_6)____, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: ____(PARAM_3)____, SND, RCV: channel (____(PARAM_5)____))\nplayed_by U def=\nlocal State: ____(VARIABLE_0)____,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1.  State = ____(STATE_0)____ /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new() /\\ SND({IDi'}_Kau) /\\ secret(____(EVENT_0)____,____(EVENT_1)____,{A,U})\n2.  State = 1 /\\ RCV({exp(G,Add(Alpha'.TIDi'))}_Kau) =|>\nState':= 2\n%/\\ Store SK % Log verification phase\n3.  State = 0 /\\ RCV(exp(G,Ss').Mul(M.exp(Y,Ss')).({X'.IP.T}_inv(ECDSA))) =|>\nState':= 1\n%/\\ Use ECDSA to verify ECDSA signature %/\\ Use Y and C = Mul(M.exp(Y,S)) to verify log signature\n/\\ ____(EVENT_2)____(U,S,ss,____(EVENT_3)____)\n% Log unsigncryption phase\n/\\ Ys' := Pair(SK.exp(G,Ss'))\n%/\\ Use Ys to decytp C and obtain view the log data M\nend role\n\nrole authority (A, S, U: ____(PARAM_12)____, Kau: symmetric_key, ECDSA: ____(PARAM_8)____, H, Add, Mul, Pair: ____(PARAM_10)____, SND, RCV: channel (____(PARAM_9)____))\nplayed_by A def=\nlocal ____(VARIABLE_1)____: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1. State = 0 /\\ RCV({IDi'}_Kau) =|>\nState':= 1\n%/\\ Verify IDi\n/\\ Alpha' := new() /\\ TIDi' := new() /\\ SK' := exp(G,Add(Alpha'.TIDi'))\n%/\\ The value SK' is computed for three attributes A, B, C\n/\\ SND({SK'}_Kau)\n/\\ ____(EVENT_5)____(SK',sk,{U,A}) /\\ ____(EVENT_6)____(Alpha',alpha,{A,U})\nend role\n\nrole sensor (A, S, U: agent, Kau: ____(PARAM_23)____, ECDSA: ____(PARAM_19)____, H, Add, Mul, Pair: ____(PARAM_16)____, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: ____(VARIABLE_2)____,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% Log signcryption phase\n1. State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ Ss' := new() %/\\ Choose Ss for computation of three attributes A, B, C; M is the log data\n/\\ Ce' := exp(G,Ss') /\\ C' := Mul(M.exp(Y,Ss')) /\\ Hs' := H(C') /\\ X' := exp(Hs',Mul(Y.Ss')) %/\\ X: log signature\n/\\ Sig' := {X'.IP.T}_inv(ECDSA) %/\\ IP: IP adrress of the Sensor; T: timestamp\n/\\ SND(Ce'.C'.Sig')\n/\\ ____(EVENT_8)____(Ss',ss,{S})\n/\\ witness(S,U,____(EVENT_10)____,____(EVENT_11)____)\nend role\n\nrole session (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: ____(PARAM_25)____) def=\nlocal SA, RA, SS, RS, SU, RU: channel (dy)\ncomposition\nauthority (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SA,RA) /\\ sensor (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SS,RS)\n/\\ user (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SU,RU)\nend role\n\nrole environment() def=\nconst a, s, u, i: agent,\nkau, kui: symmetric_key,\necdsa, ki: public_key,\nh, add, mul, pair: hash_func,\nidi, sk, alpha, ss: protocol_id\nintruder_knowledge = {a,s,u,ki,inv(ki)}\ncomposition\nsession(a,s,u,kau,ecdsa,h,add,mul,pair) /\\ session(i,s,u,kui,ecdsa,h,add,mul,pair)\n/\\ session(a,i,u,kui,ecdsa,h,add,mul,pair) /\\ session(a,s,i,kui,ecdsa,h,add,mul,pair)\nend role\ngoal\nsecrecy_of idi, sk, alpha, ss\nauthentication_on ss\nend goal\nenvironment()\n```"]], "HLPSL-1/Three-factor_fast_authentication_scheme_for_e-health_systems_in_5G_wireless_sensor_network.hlpsl": [[false, "```houzhui\nrole user (U: agent, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDi, PWi & Bi\n\t\t   /\\ E' := new()\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n\t\t   /\\ SND({IDi.W'.BBi'}_Kus)\n\t\t   /\\ secret(PWi,g1,{U})\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g3,{U})\n\t\t   /\\ secret(Bi,g4,{U})\n\n\t2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\t\t   %/\\ Store E, IDi, PWi & Bi in the smart card\n\t\t   %/\\ Store Ej', IDj, & Nj in the USB\n\n% Login and initial authentication phase\n\n\t3.  State = 2 /\\ RCV(start) =|>\n\t\t   State':= 3\n\t\t   %/\\ Insert smart card\n\t\t   %/\\ Enter PWi* & Bi*\n\t\t   /\\ V' := new()\n\t\t   %/\\ Suppose b = 3\n\t\t   /\\ N' := H(H(H(V')))\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n\t\t   /\\ Yij' := xor(E,Ej)\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A' := xor(xor(BBi',W'),Tu')\n\t\t   /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n\t\t   /\\ SND(K')\n\t\t   /\\ witness(U,S,u_s_v,V')\n\t\t   /\\ witness(U,S,u_s_tu,Tu')\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g3,{U})\n\t\t   /\\ secret(Bi,g4,{U})\n\n\t4.  State = 3 /\\ RCV(({B'.H(Yij.IDi.H(Xj)).H6(H(H(Yij.IDi.H(Xj)).Xj.As')).H14(H(H(Yij.IDi.H(Xj)).Xj.Bs')).Ts'}_SKij').T1'.T2') =|>\n\t\t   State':= 2\n\t\t   /\\ SKij' := H(xor(N,Yij))\n\t\t   %/\\ Confirm Ts'\n\t\t   %/\\ Confirm B\n\t\t   %/\\ Store IDinew, ATa, ATb in the smart card\n\t\t   %/\\ Store T1, T2 in the USB\n\t\t   /\\ request(S,U,s_u_ts,Ts')\n\n% Fast authentication phase\n\n \t5. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDinew, PWi & Bi\n\t\t   %/\\ Suppose Tlogin = 8\n\t\t   /\\ Ay' := H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As)))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs))))\n\t\t   /\\ SND(Ay')\n\n\t6. State = 1 /\\ RCV({H(xor(Ay',IDinew))}_SKij) =|>\n\t\t   State':= 2\n\t\t   %/\\ Confirm By'\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, X, Y, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n\t\t   %/\\ Store IDj\n\t\t   /\\ SND({IDi.Nj.Yij'}_Kus)\n\t\t   /\\ secret(PWi,g1,{S})\n\n% Login and initial authentication phase\n\n\t2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\n\t\t   State':= 1\n\t\t   %/\\ Confirm Tu'\n\t\t   %/\\ Use Xj to decrypt Yij\n\t\t   %/\\ Confirm H(Xj), IDsj & IDi\n\t\t   /\\ A' := xor(xor(BBi.W).Tu')\n\t\t   %/\\ Confirm A\n\t\t   /\\ Ts' := new()\n\t\t   /\\ B' := xor(H(H(H(H(V')))),Ts')\n\t\t   /\\ IDinew' := H(Yij.IDi.H(Xj))\n\t\t   /\\ T1' := new()   /\\ T2' := new()\n\t\t   /\\ As' := new()   /\\ Bs' := new()\n\t\t   %/\\ Z =24, suppose T1=7, T2=10\n\t\t   /\\ ATa' := H6(H(IDinew'.Xj.As'))\n\t\t   /\\ ATb' := H14(H(IDinew'.Xj.Bs'))\n\t\t   /\\ SKij' := H(xor(H(H(H(V'))),Yij'))\n\t\t   /\\ Q':= {B'.IDinew'.ATa'.ATb'.Ts'}_SKij'\n\t\t   /\\ SND (Q'.T1'.T2')\n\t\t   /\\ witness(S,U,s_u_ts,Ts')\n\t\t   /\\ secret(As',g5,{S})\n\t\t   /\\ secret(Bs',g6,{S})\n\t\t   /\\ request(U,S,u_s_v,V')\n\t\t   /\\ request(U,S,u_s_tu,Tu')\n\n% Fast authentication phase\n\n\t3. State = 0 /\\ RCV(H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As')))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs'))))) =|>\n\t\t   State':= 1\n\t\t   /\\ X' := H(IDinew.Xj.As)\n\t\t   /\\ Y' := H(IDinew.Xj.Bs)\n\t\t   /\\ Ay' := H(H7(X').H16(Y'))\n\t\t   %/\\ Confirm Ay\n\t\t   /\\ By' := {H(xor(Ay',IDinew))}_SKij\n\t\t   /\\ SND(By')\nend role\n\nrole session (U, S: agent, Kus: symmetric_key, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func) def=\n\n  local SU, RU, SS, RS: channel (dy)\n\n  composition\n\n\tuser (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SU,RU)\n          /\\ server (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SS,RS)\n\nend role\n\n\nrole environment() def=\n\n    const u, s: agent,\n\t  kus, skij, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, h1, h2, h6, h7, h14, h16: hash_func,\n\t  u_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5, g6, g7: protocol_id\n\n    intruder_knowledge = {u,s,ks,ki,inv(ki)}\n\n    composition\n\n\tsession(u,s,kus,skij,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(u,i,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(i,s,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\nend role\n\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6, g7\n  authentication u_s_v, u_s_tu, s_u_ts\n\nend goal\n```"]], "HLPSL-1/Three-Factor_UCSSO_Scheme_With_Fast_Authentication_and_Privacy_Protection_for_Telecare_Medicine_Information_Systems.hlpsl": [[false, "```houzhui\nrole U (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   /\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new() %/\\ Input IDi', PWi', and imprint Bi'\n\t\t   /\\ R' := new()\n\t\t   /\\ Xi' := H(PWi'.Bi')\n\t\t   /\\ Y' := H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))\n\t\t   /\\ SND({IDi'.Xi'.Y'}_SecureChannel)\n\t\t   /\\ secret(U,r,{U})\n\t\t   /\\ secret(U,idi,{U,TMIS})\n\t\t   /\\ secret(PWi',pwi,{U})\n\t\t   /\\ secret(Bi',bi,{U})\n\n\t2.  State = 1 /\\ RCV({Rabin.({H(SKj).IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj')}_SecureChannel) =|>\n\t\t   State':= 2\n\t\t   /\\ Wj' := xor(R,({H(SKj).IDsj.IDi.Y.Xi}_SKj))\n\t\t   %/\\ Store R, IDi, PWi and Bi in the smart card\n\t\t   %/\\ Store Wj', IDsj and Rabin in the USB\n\n% Login and First Authentication\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card %/\\ Input IDi', PWi', and imprint Bi' % Smart card confirm Bi'\n\t\t   /\\ Xi' := H(PWi.Bi)\n\t\t   /\\ Y' := H(H(PWi.R).xor(h(xor(IDi,IDsj)),R))\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A1' := xor(xor(Xi',Y'),Tu')\n\t\t   /\\ Nij' := xor(R,Wj)\n\t\t   /\\ E' := new() %/\\ Suppose m = 4\n\t\t   /\\ M' := H(H(H(H(E'))))\n\t\t   /\\ C1' := {IDsj.IDi.A1'.Nij'.M'}_Rabin\n\t\t   /\\ SND(C1'.Tu')\n\t\t   /\\ witness(U,TMIS,e,E')\n\t\t   /\\ witness(TMIS,U,tu,Tu')\n\n\t4.  State = 1 /\\ RCV(({xor(H(H(H(H(H(E'))))),Ts')}_Kij').Ts') =|>\n\t\t   State':= 2\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(M,Nij))\n\t\t   %/\\ Confirm Ts' %/\\ Confirm A2'\n\t\t   %/\\ Store Kij' in the smart card\n\t\t   /\\ request(TMIS,U,ts,Ts')\n\n% Fast Authentication with New Session Key\n\n \t5. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ input IDi', PWi', and imprint Bi' for smart card verification\n\t\t   %/\\ Suppose alpha = 1\n\t\t   /\\ M1':= H(H(H(E)))\n\t\t   /\\ Pa' := {M1'}_Kij\n\t\t   /\\ SND(Pa')\n\n\t6. State = 1 /\\ RCV({H(H(H(E)))}_KijNew') =|>\n\t\t   State':= 2\n\t\t   /\\ KijNew':= M1.Kij\n\t\t   /\\ Qa':= {M1}_KijNew'\n\t\t   %/\\ Check Qa'. If it is legitimate, then accept KijNew'\n\nend role\n\n\nrole tmis (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func, SND, RCV: channel (dy))\nplayed_by TMIS def=\n\n  local State: nat,\n        R, Xi, Y, IDi, PWi, Bi, IDsj, M, E, Tu, A1, C1, Nij, Ts, A2, M1, Pa, Qa, C2, Kij, KijNew, Wj, SKj: text\n\n% System Initialization\n  init State := 0\n\n  transition\n\n% Registration\n\n\t1. State = 0 /\\ RCV({IDi'.H(PWi'.Bi').H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R'))}_SecureChannel) =|>\n\t\t   State':= 1\n\t\t   /\\ SKj' := new() /\\ Nij' := {H(SKj).IDsj.IDi'.H(H(PWi'.R').xor(h(xor(IDi',IDsj)),R')).H(PWi'.Bi')}_SKj'\n\t\t   %/\\ Store IDi, Y, Xi\n\t\t   /\\ SND({Rabin.Nij'}_SecureChannel)\n\t\t   /\\ secret(SKj',skj,{TMIS})\n\n% Login and First Authentication\n\n\t2. State = 0 /\\ RCV(({IDsj.IDi.H(H(H(H(E')))).xor(xor(Xi,Y),Tu').Nij}_Rabin).Tu') =|>\n\t\t   State':= 1\n\t\t   %/\\ Check Tu'\n\t\t   %/\\ Confirm H(SKj), IDsj and IDi\n\t\t   /\\ A1' := xor(xor(Xi,Y),Tu')\n\t\t   %/\\ Check A1\n\t\t   /\\ Ts' := new()\n\t\t   /\\ A2' := xor(H(H(H(H(H(E'))))),Ts')\n\t\t   /\\ Kij' := H(xor(H(H(H(H(E')))),Nij))\n\t\t   /\\ C2' := {A2'}_Kij'\n\t\t   /\\ SND (C2'.Ts')\n\t\t   /\\ witness(TMIS,U,ts,Ts')\n\t\t   /\\ request(U,TMIS,e,E)\n\t\t   /\\ request(U,TMIS,tu,Tu')\n\t\t   /\\ secret(Kij',kij,{U,TMIS})\n\n% Fast Authentication with New Session Key\n\n\t3. State = 0 /\\ RCV({H(H(H(E)))}_Kij) =|>\n\t\t   State':= 1\n\t\t   %/\\ Check whether H(M1') = M. If there is a match, then M1' replaces M\n\t\t   /\\ KijNew' := H(H(H(E))).Kij\n\t\t   %/\\ KijNew' replaces Kij\n\t\t   /\\ Qa':= {H(H(H(E)))}_KijNew'\n\t\t   /\\ SND(Qa')\n\t\t   /\\ secret(KijNew',kijnew,{U,TMIS})\nend role\n\nrole session (U, TMIS: agent, SecureChannel: symmetric_key, Rabin: public_key, H: hash_func) def=\n\n  local SU, RU, STMIS, RTMIS: channel (dy)\n\n  composition\n\n\tuser (U,TMIS,SecureChannel,Rabin,H,SU,RU)\n          /\\ tmis (U,TMIS,SecureChannel,Rabin,H,STMIS,RTMIS)\n\nend role\n\n\nrole environment() def=\n\n    const u, tmis: agent,\n\t  securechannel, kai: symmetric_key,\n\t  rabin, ki: public_key,\n\t  h: hash_func,\n\t  r, idi, pwi, bi, skj, kij, kijnew, e, tu, ts: protocol_id\n\n    intruder_knowledge = {u,tmis,rabin,ki,inv(ki)}\n\n    composition\n\n\tsession(u,tmis,securechannel,rabin,h)\n\t/\\ session(u,i,kai,rabin,h)\n\t/\\ session(i,tmis,kai,rabin,h)\n\nend role\n\n\ngoal\n\n  secrecy_of r, idi, pwi, bi, skj, kij, kijnew\n  authentication_on e, tu, ts\n\nend goal\n```"]], "HLPSL-1/TLS.hlpsl": [[true, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (text))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const sec_clientk, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (text))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     H, PRF: hash_func, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (text)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const sec_clientk, sec_serverk : protocol_id,\n         h, prf, keygen : hash_func,\n         a, b           : agent,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```avispa\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (text))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const sec_clientk, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (text))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     H, PRF: hash_func, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (text)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const sec_clientk, sec_serverk : protocol_id,\n         h, prf, keygen : hash_func,\n         a, b           : agent,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/total.hlpsl": [[true, "role user(Ui,GWN,RA,SDj:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by Ui\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M1,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,SKi:text\nconst ui_gwn_ts1,gwn_ui_ts4,sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Registration phase\n1.State=0/\\Rcv(RA,{IDi.H(IDi.R1).TIDi.H(Kinew.IDi.R1).T(Ki.G.X).Tg.Kinew}_SKura)=|>\nState':=2/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki},sr3,{RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TIDi':=new()\n         /\\Ri':=new()\n         /\\MIDj':=new()\n         /\\TS1':=new()\n         /\\M1':=H(Kinew.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1')\n         /\\Snd(GWN,TIDi'.xor((Kinew.Ri'.MIDj),T(Ki.G.X)).H(Kinew.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1').TS1')\n%Login request from Ui to GWN\n2.State=2/\\Rcv(GWN,Ni'.M4'.TS4')=|>\nState':=3/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi.R1').MIDj)\n\t/\\request(GWN,Ui,gwn_ui_ts4,TS4')\nend user\n\n\n\n\nrole gateway(Ui,GWN,RA,SDj:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by GWN\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,Ei:text\nconst ui_gwn_ri,ui_gwn_ts1,ui_gwn_ki,ui_gwn_kinew,gwn_sdj_ts2,gwn_sdj_rg,gwn_ui_ts4,gwn_sdj_ts4,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n%Receive login request from Ui through open channel\n1.State=0/\\Rcv(Ui,TIDi'.\n               xor((Kinew'.Ri'.MIDj),T(Ki.G.X)).\n               H(Kinew'.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1').TS1')=|>\nState':=1/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki}, sr3, {RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TS2':=new()\n         /\\Rg':=new()\n         /\\Ei':=xor((Ri'.Rg'.H(IDi.R1)),H(Ksg.MIDj.TS2'))\n         /\\M2':=H(Ri'.Rg'.H(IDi.R1).Ksg.TS2')\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')  \n         /\\request(Ui,GWN,ui_gwn_ri,Ri')\n         /\\request(Ui,GWN,ui_gwn_ts1,TS1')\n        %  /\\request(Ui,GWN,ui_gwn_ki,Ki)\n        %  /\\request(Ui,GWN,ui_gwn_kinew,Kinew')\n%Send authentication request message to SDj through open channel\n         /\\Snd(SDj,Ei'.M2'.TS2')\n\n         \n2.State=1/\\Rcv(SDj,xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3') =|>\n  State':=2/\\TS4':=new() /\\ Ri' := new()\n           /\\Ni':=xor((Rj'.Rg').T(Ki.G.X))\n           /\\M4':=H(T(Ki.G.X).Ri'.Rj'.Rg'.TS4')\n           /\\witness(GWN,Ui,gwn_ui_ts4,TS4')\n           /\\request(SDj,GWN,sdj_gwn_rj,Rj')\n           /\\request(SDj,GWN,sdj_gwn_ts3,TS3')\n           /\\Snd(Ui,Ni'.M4'.TS4')\nend role\n\n\n\n\n\nrole smartdevice(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by SDj\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS2,TS3,Bi,M3,G,Ki,Kinew,Ni,SK,Gj:text\nconst gwn_sdj_ts2,ui_gwn_ts1,gwn_sdj_rg,sdj_gwn_ts3,sdj_gwn_rj,ui_gwn_ri,gwn_ui_ts4,sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Receive authentication request message from GWN through open channel\n1.State=0/\\Rcv(GWN,xor((Ri'.Rg'.H(IDi.R1)),H(Ksg.MIDj.TS2')).\n               H(Ri'.Rg'.H(IDi.R1).Ksg.TS2').TS2')=|>\nState':=1/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki}, sr3, {RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TS3':=new()\n         /\\Rj':=new()\n         /\\Gj':=xor(Rj',H(Ksg.MIDj.TS3'))\n         /\\SK':=H(Ri'.Rg'.Rj'.H(IDi.R1).MIDj)\n         /\\M3':=H(Ksg.MIDj.Rg'.Rj'.TS3')\n%Send authentication reply message to Ui through open channel        \n         /\\Snd(GWN,Gj'.M3'.TS3')\n%SDj has freshly generated the values TS3 \n         /\\witness(SDj,GWN,sdj_gwn_ts3,TS3')\n         /\\request(SDj,GWN,sdj_gwn_rj,Rj')\n%SDj\u2019s acceptance of values TS2 by GW         \n         /\\request(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\request(GWN,SDj,gwn_sdj_rg,Rg')\nend role\n\n\nrole registration(Ui,SDj,GWN,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\n\nplayed_by RA\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew,Tg:text\nconst sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv(Ui,{IDi.H(IDi.R1).T(Ki.X)}_SKura)=|>\nState':=2/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki},sr3,{RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TIDi':=new()\n         /\\TEMP':=new()\n         /\\Tg':=T(G.X)\n%Send smart card (SCi) to Ui securely\n         /\\Snd(Ui,{IDi.H(IDi.R1).TIDi.H(Kinew.IDi.R1).T(Ki.G.X).Tg.Kinew}_SKura)\nend role\n\n\n\nrole session(Ui,GWN,SDj,RA:agent,H,T,PUF:hash_func,SKura:symmetric_key)\ndef=\n  local SD1,RV1,SD2,RV2,SD3,RV3,SD4,RV4:channel(dy)\n  composition\n    user(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD1,RV1)\n    /\\smartdevice(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD2,RV2)\n    /\\gateway(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD3,RV3)\n    /\\registration(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD4,RV4)\nend role\n\nrole environment()\ndef=\nconst ui,gwn,sdj,ra:agent,h,t,puf:hash_func,\n      skji:symmetric_key,skura:symmetric_key,\n      kug,ksg,idi,idj,t1,t2,t3,t4,\n      midi,midj,bi,m1,ei,m2,tcj,gj,m3,m4:text,\n      sr1,sr2,sr3,sr4,ui_gwn_ri,ui_gwn_ts1,ui_gwn_ki,ui_gwn_kinew,\n      gwn_sdj_ts2,gwn_sdj_rg,gwn_sdj_ts4,sdj_gwn_ts3,sdj_gwn_rj:protocol_id\nintruder_knowledge={h,t1,t2,t3,\n      midi,bi,m1,ei,m2,tcj,gj,m3}\ncomposition\n  session(ui,gwn,sdj,ra,h,t,puf,skura)\n/\\session(i,gwn,sdj,ra,h,t,puf,skura)\n/\\session(ui,i,sdj,ra,h,t,puf,skura)\n/\\session(ui,gwn,i,ra,h,t,puf,skura)\nend role\n\ngoal \n%%% Confidentiality (privacy)\nsecrecy_of sr1, sr2,sr3,sr4\n%%% Authentication\nauthentication_on ui_gwn_ri,ui_gwn_ts1\nauthentication_on gwn_sdj_ts2,gwn_sdj_rg,gwn_sdj_ts4\nauthentication_on sdj_gwn_ts3,sdj_gwn_rj\nend goal", "Here's the completed HLPSL code with the blanks filled in, based on the protocol description and logical flow:\n\n```hlpsl\nrole user(Ui,GWN,RA,SDj:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by Ui\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M1,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,SKi:text\nconst ui_gwn_ts1,gwn_ui_ts4,sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Registration phase\n1.State=0/\\Rcv(RA,{IDi.H(IDi.R1).TIDi.H(Kinew.IDi.R1).T(Ki.G.X).Tg.Kinew}_SKura)=|>\nState':=2/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki},sr3,{RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TIDi':=new()\n         /\\Ri':=new()\n         /\\MIDj':=new()\n         /\\TS1':=new()\n         /\\M1':=H(Kinew.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1')\n         /\\Snd(GWN,TIDi'.xor((Kinew.Ri'.MIDj),T(Ki.G.X)).H(Kinew.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1').TS1')\n%Login request from Ui to GWN\n2.State=2/\\Rcv(GWN,Ni'.M4'.TS4')=|>\nState':=3/\\SKi':=H(Ri'.Rj'.Rg'.H(IDi.R1').MIDj)\n\t/\\request(GWN,Ui,gwn_ui_ts4,TS4')\nend user\n\n\n\n\nrole gateway(Ui,GWN,RA,SDj:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by GWN\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS2,TS3,TS4,Bi,M2,M4,TIDi,A1,TEMP,G,Ki,Kinew,Ni,Ei:text\nconst ui_gwn_ri,ui_gwn_ts1,ui_gwn_ki,ui_gwn_kinew,gwn_sdj_ts2,gwn_sdj_rg,gwn_ui_ts4,gwn_sdj_ts4,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n%Receive login request from Ui through open channel\n1.State=0/\\Rcv(Ui,TIDi'.\n               xor((Kinew'.Ri'.MIDj),T(Ki.G.X)).\n               H(Kinew'.Ri'.MIDj.H(IDi.R1).T(Ki.G.X).TS1').TS1')=|>\nState':=1/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki}, sr3, {RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TS2':=new()\n         /\\Rg':=new()\n         /\\Ei':=xor((Ri'.Rg'.H(IDi.R1)),H(Ksg.MIDj.TS2'))\n         /\\M2':=H(Ri'.Rg'.H(IDi.R1).Ksg.TS2')\n         /\\witness(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\witness(GWN,SDj,gwn_sdj_rg,Rg')  \n         /\\request(Ui,GWN,ui_gwn_ri,Ri')\n         /\\request(Ui,GWN,ui_gwn_ts1,TS1')\n        %  /\\request(Ui,GWN,ui_gwn_ki,Ki)\n        %  /\\request(Ui,GWN,ui_gwn_kinew,Kinew')\n%Send authentication request message to SDj through open channel\n         /\\Snd(SDj,Ei'.M2'.TS2')\n\n         \n2.State=1/\\Rcv(SDj,xor(Rj',H(Ksg.MIDj.TS3')).H(Ksg.MIDj.Rg'.Rj'.TS3').TS3') =|>\n  State':=2/\\TS4':=new() /\\ Ri' := new()\n           /\\Ni':=xor((Rj'.Rg').T(Ki.G.X))\n           /\\M4':=H(T(Ki.G.X).Ri'.Rj'.Rg'.TS4')\n           /\\witness(GWN,Ui,gwn_ui_ts4,TS4')\n           /\\request(SDj,GWN,sdj_gwn_rj,Rj')\n           /\\request(SDj,GWN,sdj_gwn_ts3,TS3')\n           /\\Snd(Ui,Ni'.M4'.TS4')\nend role\n\n\n\n\n\nrole smartdevice(Ui,GWN,SDj,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\nplayed_by SDj\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS2,TS3,Bi,M3,G,Ki,Kinew,Ni,SK,Gj:text\nconst gwn_sdj_ts2,ui_gwn_ts1,gwn_sdj_rg,sdj_gwn_ts3,sdj_gwn_rj,ui_gwn_ri,gwn_ui_ts4,sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% Receive authentication request message from GWN through open channel\n1.State=0/\\Rcv(GWN,xor((Ri'.Rg'.H(IDi.R1)),H(Ksg.MIDj.TS2')).\n               H(Ri'.Rg'.H(IDi.R1).Ksg.TS2').TS2')=|>\nState':=1/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki}, sr3, {RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TS3':=new()\n         /\\Rj':=new()\n         /\\Gj':=xor(Rj',H(Ksg.MIDj.TS3'))\n         /\\SK':=H(Ri'.Rg'.Rj'.H(IDi.R1).MIDj)\n         /\\M3':=H(Ksg.MIDj.Rg'.Rj'.TS3')\n%Send authentication reply message to Ui through open channel        \n         /\\Snd(GWN,Gj'.M3'.TS3')\n%SDj has freshly generated the values TS3 \n         /\\witness(SDj,GWN,sdj_gwn_ts3,TS3')\n         /\\request(SDj,GWN,sdj_gwn_rj,Rj')\n%SDj\u2019s acceptance of values TS2 by GW         \n         /\\request(GWN,SDj,gwn_sdj_ts2,TS2')\n         /\\request(GWN,SDj,gwn_sdj_rg,Rg')\nend role\n\n\nrole registration(Ui,SDj,GWN,RA:agent,\n          H,T,PUF:hash_func,\n          SKura:symmetric_key,\n          Snd,Rcv:channel(dy))\n\nplayed_by RA\ndef=\nlocal State:nat,\n      IDi,IDsj,MIDi,MIDj,PWi,R1,Rb,Kug,Ksg,X:text,\n      Ri,Rg,Rj,TS1,TS4,Bi,M1,TIDi,A1,TEMP,G,Ki,Kinew,Tg:text\nconst sr1,sr2,sr3,sr4:protocol_id\ninit State:=0\ntransition \n% User registration phase\n1.State=0/\\Rcv(Ui,{IDi.H(IDi.R1).T(Ki.X)}_SKura)=|>\nState':=2/\\secret(IDi,sr1,{Ui,RA})\n         /\\secret({PWi},sr2,Ui)\n         /\\secret({Kinew,Ki},sr3,{RA})\n         /\\secret(Ksg,sr4,{GWN,SDj})\n         /\\TIDi':=new()\n         /\\TEMP':=new()\n         /\\Tg':=T(G.X)\n%Send smart card (SCi) to Ui securely\n         /\\Snd(Ui,{IDi.H(IDi.R1).TIDi.H(Kinew.IDi.R1).T(Ki.G.X).Tg.Kinew}_SKura)\nend role\n\n\n\nrole session(Ui,GWN,SDj,RA:agent,H,T,PUF:hash_func,SKura:symmetric_key)\ndef=\n  local SD1,RV1,SD2,RV2,SD3,RV3,SD4,RV4:channel(dy)\n  composition\n    user(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD1,RV1)\n    /\\smartdevice(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD2,RV2)\n    /\\gateway(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD3,RV3)\n    /\\registration(Ui,GWN,SDj,RA,H,T,PUF,SKura,SD4,RV4)\nend role\n\nrole environment()\ndef=\nconst ui,gwn,sdj,ra:agent,h,t,puf:hash_func,\n      skji:symmetric_key,skura:symmetric_key,\n      kug,ksg,idi,idj,t1,t2,t3,t4,\n      midi,midj,bi,m1,ei,m2,tcj,gj,m3,m4:text,\n      sr1,sr2,sr3,sr4,ui_gwn_ri,ui_gwn_ts1,ui_gwn_ki,ui_gwn_kinew,\n      gwn_sdj_ts2,gwn_sdj_rg,gwn_sdj_ts4,sdj_gwn_ts3,sdj_gwn_rj:protocol_id\nintruder_knowledge={h,t1,t2,t3,\n      midi,bi,m1,ei,m2,tcj,gj,m3}\ncomposition\n  session(ui,gwn,sdj,ra,h,t,puf,skura)\n/\\session(i,gwn,sdj,ra,h,t,puf,skura)\n/\\session(ui,i,sdj,ra,h,t,puf,skura)\n/\\session(ui,gwn,i,ra,h,t,puf,skura)\nend role\n\ngoal \n%%% Confidentiality (privacy)\nsecrecy_of sr1, sr2,sr3,sr4\n%%% Authentication\nauthentication_on ui_gwn_ri,ui_gwn_ts1\nauthentication_on gwn_sdj_ts2,gwn_sdj_rg,gwn_sdj_ts4\nauthentication_on sdj_gwn_ts3,sdj_gwn_rj\nend goal\n```"]], "HLPSL-1/UMTS_AKA.hlpsl": [[false, "```houzhui\n%% PROTOCOL: UMTS-AKA\n%% PURPOSE: \n%% Authentication and Key Agreement\n%% REFERENCE:\n%% \\url{http://www.3gpp.org/ftp/tsg_sa/WG3_Security/_Specs/33902-310.pdf}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% S is the server, M is the mobile set, they share a secret key k(M).\n%% \n%% Both S and M have an own version of a sequence number,\n%% that they try to maintain synchonized.\n%% \n%% Using k(M), a random number (nonce) r, his sequence number seq,\n%% when S receives a request from M (or whenever he wishes\n%% this part is not modelled here), S generates:\n%% \\begin{verbatim}\n%%   res = F2(k(M); r)   where F2 hash\n%%   CK =  F3(k(M); r)   where F3 one-way\n%%   IK =  F4(k(M); r)   where F4 one-way\n%%   Ka =  F5(k(M); r)   where F5 one-way\n%%   AUTN = {seq}Ka; F1(k(M); seq; r)  where F1 hash\n%%\n%% M -> S : M\n%% S -> M : r; {seq}_Ka; F1(k(M); seq; r)\n%%\n%%      from r M calculates KA, then seq, then checks if F1(k(M); seq; r) OK\n%%      if yes, M increments his seq number and responds:\n%%\n%% M -> S : F2(k(M); r)\n%% \\end{verbatim}\n%% The goal is that at the end both authenticate each other and share\n%% the value of \\verb|CK| and \\verb|IK|.\n%%\n%%% LIMITATIONS:\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATON: G2 G12 \n%%\n%% ATTACKS: None\n%%\n%%% NOTES:\n%%\n%%HLPSL:\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole server(S : agent,M : agent,\n\t    Snd, Rec: channel(dy),\n            K_M: symmetric_key,\n            Seq : text,\n            F1,F2,F5: hash_func)\nplayed_by S\ndef=\n\n  local State : nat,\n        R     : text\n\n  const ck,r2,ik : protocol_id,\n        add         : hash_func\n\n  init  State := 1 \n\n  transition\n\n    1.  State   = 1 /\\ Rec(M)\n        =|> \n        State' := 2 /\\ R' := new()\n                    /\\ Snd(R'.{Seq}_F5(K_M.R').F1(K_M.Seq.R')) \n\t \t    /\\ secret(ck,ik,{S,M})\n\t\t    /\\ witness(S,M,r1,R')\n\n    2.  State   = 2 /\\ Rec(F2(K_M.R))\n        =|> \n        State' := 3 /\\ Seq' := add(Seq,1) \n\t\t    /\\ wrequest(S,M,r2,R)\n        \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole mobile(M : agent,S:agent,\n            Snd, Rec: channel(dy),\n            K_M: symmetric_key,\n            Seq: text,\n            F1,F2,F5: hash_func)\nplayed_by M\ndef=\n\n  local State :nat, \n\tR     :text\n\n  const\n        r1,ik,ck : protocol_id\n\n  init  State := 1\n\n  transition\n\n    1.  State = 1 /\\ Rec(start) =|> \n        State':=2 /\\ Snd(M)  \n\n    2.  State = 2 /\\ Rec(R'.{Seq}_F5(K_M.R').F1(K_M.Seq.R')) =|>  \n        State':=3 /\\ Snd(F2(K_M. R')) \n\t\t  /\\ secret(ik,ck,{M,S})\n\t\t  /\\ wrequest(M,S,r1,R') \n\t\t  /\\ witness(M,S,r2,R')\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(M,S: agent,\n\t     K_M: symmetric_key,\n\t     Seq: text,\n             F1,F2,F5: hash_func,\n             SA,RA,SB,RB: channel(dy)) def=\n\n   composition\n\n\t mobile(M,S,SA,RA,K_M,Seq,F1,F2,F5)\n      /\\ server(S,M,SB,RB,K_M,Seq,F1,F2,F5)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n local Sa1,Ra1,Ss1,Rs1 : channel (dy)\n\n const r1, r2                 : protocol_id,\n       a, i, s                : agent,\n       k_as, k_is, kai        : symmetric_key,\n       f1, f2, f5             : hash_func,\n       seq_as, seq_is, seq_ai : text\n\n intruder_knowledge={a,s,i,f1,f2,f5}\n\n composition\n \n\tsession(a,s,k_as,seq_as,f1,f2,f5,Sa1,Ra1,Ss1,Rs1) \n% /\\\tsession(i,s,k_is,seq_is,f1,f2,f5,si1,ri1,ss2,rs2) \n% /\\\tsession(a,i,k_ai,seq_ai,f1,f2,f5,sa2,ra2,si2,ri2)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  secrecy_of ck,ik\n\n  % Message Authentication (G2)\n  % Mobile weakly authenticates Server on r1  % the nonce R\n  weak_authentication_on r1\n\n  % Message Authentication (G2)\n  % Server weakly authenticates Mobile on r2  % the nonce R\n  weak_authentication_on r2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/update_simple(final).hlpsl": [[false, "```houzhui\nrole_OBU role_OBU(\n  OBU,SN                   : agent,\n  Kseaf                    : symmetric_key,\n  PID                      : text,\n  H1,H2,PUF                : hash_func,\n  SO,RO                  : channel(dy))\nplayed_by OBU def=\n  \n  local\n    State        :nat,\n\tC1,C2,T        :text,\n\tH12,PID2,R1,R2,R1en,S1,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\t\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ SND(PID) \n  2. State = 2 /\\ RCV(C2'.C1'.R1en'.H11')  /\\ H11' = H1(C2'.C1'.PUF(C1').PID.R1en') =|>\n     State' := 4 /\\ R1' := PUF(C1') /\\ R2' := PUF(C2') /\\ R2en' := xor(R1',R2') /\\ H12' := H1(R1'.C2'.R2'.PID) /\\ SND(R2en'.H12')\n\t             /\\ witness(OBU,SN,o_s_h12,H12')\n  3. State = 4 /\\ RCV(PID2'.Res') /\\ Res' = H1(PID2'.R2)=|>\n     State' := 6 /\\ secret(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN}) /\\ request(OBU,SN,s_o_res,Res') /\\ request(OBU,SN,s_o_h11,H11)\n\nend role\n\nrole role_SN(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tC2,PIDn,T        :text,\n\tH12,PID2,R1,R2,S1,R1en,R2en         :message,\n\tH11          :hash(text.text.message.text.message),\n%%\tH12          :hash(message.text.message.text.message),\n\tRes          :hash(message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PIDn') /\\ PIDn' = PID =|>\n     State' := 3 /\\ R1' := PUF(C1) /\\ C2' := new() /\\ R1en' := H1(C2',R1') /\\ H11' := H1(C2'.C1.R1'.PIDn'.R1en') /\\ SND(C2'.C1.R1en'.H11') \n\t             /\\ witness(SN,OBU,o_s_h11,H11')\n  2. State = 3 /\\ RCV(R2en'.H12') /\\ H12' = H1(R1.C2.xor(R2en',R1).PIDn) =|>\n     State' := 5 /\\ R2' := xor(R2en',R1) /\\ T' := new() /\\ PID2' := H1(PID.Kseaf.R2'.T) /\\ Res' := H1(PID2'.R2') /\\ SND(PID2'.Res')\n\t             /\\ witness(SN,OBU,s_o_res,Res') /\\ secret(R1,r1,{OBU,SN}) /\\ secret(R2,r2,{OBU,SN}) /\\ secret(S1,s1,{OBU,SN})\n\nend role\n\n\nrole session(\n  OBU,SN                   : agent,\n  Kseaf                   : symmetric_key,\n  PID,C1                   : text,\n  H1,H2,PUF                : hash_func)\ndef=\n  local SO,RO,SS,RS : channel(dy)\n  \n  composition\n    role_OBU(OBU,SN,Kseaf,PID,H1,H2,PUF,SO,RO) /\\ role_SN(OBU,SN,Kseaf,PID,C1,H1,H2,PUF,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,s1,s2,s_o_res,o_s_h12,s_o_h11  :protocol_id,\n    obu,sn     : agent,\n\tkseaf       : symmetric_key,\n    pid,c1   : text,\n    h1,h2,puf        : hash_func\n  intruder_knowledge = {pid,obu,sn,h1,h2} \n  \n  composition\n    session(obu,sn,kseaf,pid,c1,h1,h2,puf) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of s1\n  secrecy_of s2\n  authentication_on s_o_res\n  authentication_on o_s_h12\n  authentication_on s_o_h11\nend goal\n```"]], "HLPSL-1/usglight.hlpsl": [[false, "```houzhui\nrole user (Ui, Sj, GW : agent,\n           Kdi,Kei: symmetric_key,\n\t\t   H: hash_func,\n\t\t   Expp:hash_func,\n\t\t   P: text,\t   \n           SND_UG,RCV_UG : channel (dy))\n\t\t   \nplayed_by Ui\n\ndef=\n\n  local State:nat,\n        T1,K1,A,M1,M2,Ki,B,K3,K2,IDi,SIDj,M4,M6,M7,SK,Keinew  : text\n\n  const shared_key,sc_user_id,sc_sensor_id:protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State   = 0  \t/\\ RCV_UG(start)=|> \n      State' := 1   /\\ T1' := new()\n\t\t\t\t\t/\\ K1' := new()\n\t\t\t\t\t/\\ A'  := Expp(P,K1')\n\t\t\t\t\t/\\ M2' := H(A'.IDi.SIDj.Kdi.T1')\n\t\t\t\t\t/\\ M1' := xor(Kei,(IDi.SIDj.M2'))\n\t\t\t\t\t/\\ SND_UG(A'.M1'.Ki.T1')\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\n   2. State   = 7   /\\ RCV_UG(   B'\n\t\t\t\t\t\t\t\t.xor((Keinew'.K3'.H(Kei.K3'.Kdi.T1.M4')),Kei)\n\t\t\t\t\t\t\t  ) =|>\n\t\t\t\t\t\t\t\t\n      State' := 8   /\\ Kei':= Keinew'\n\t\t\t\t\t/\\ Ki' := K3'\n\t\t\t\t\t/\\ SK' := H(Expp(B',K1))\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret_on( IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret_on(SIDj,sc_sensor_id,{Sj,GW})\n\t\t\t\t\t/\\ witness(Ui,Sj,shared_key,SK')\n\t\t\t\t\t/\\ request(Ui,Sj,shared_key,SK')\n\t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole sensor (Ui, Sj, GW : agent,\n             Kxj: symmetric_key,\n\t\t\t H: hash_func,\n\t\t\t Expp:hash_func,\n\t\t     P: text,\n\t\t\t SND_SG,RCV_SG: channel(dy))\n\t\t\t \nplayed_by Sj\n\ndef=\n  local State:nat,\n        T2,K2,A,B,SK,M3,M4,M5,SIDj   : text\n\n  const shared_key:protocol_id\n  init  State := 4\n\n  transition\n   1. State   = 4   /\\ RCV_SG(A'\n\t\t\t\t\t\t\t .H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t\t\t .T2'\n\t\t\t\t\t\t\t )=|> \n      State' := 5   /\\ K2' := new()\n\t\t\t\t\t/\\ B'  := Expp(P,K2')\n\t\t\t\t\t/\\ SK' := H(Expp(A',K2))\n\t\t\t\t\t/\\ M4' := H(B'.SK.A')\n\t\t\t\t\t/\\ M5' := H(Kxj.H(A'.SIDj'.Kxj.T2').M4'.B')\n\t\t\t\t\t/\\ SND_SG(B'.M4'.M5')\n\t\t\t\t\t\n\t\t\t\t\t/\\ witness(Ui,Sj,shared_key,SK')\n\t\t\t\t\t/\\ request(Ui,Sj,shared_key,SK')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole gateway (Ui, Sj, GW : agent,\n\t\t\t  Kdi,Kei, Kxj,Xgwn: symmetric_key,\n\t\t\t  H : hash_func,\n\t\t\t  SND_UG,RCV_UG,SND_SG,RCV_SG: channel(dy))\n\t\t\t \nplayed_by GW\n\ndef=\n\n  local State   : nat,\n        T1,T2,A,B,IDi,SIDj,M2,M3,M4,M6,M7,Ki,Keinew,K3 : text\n\n\n  const sc_user_id,sc_sensor_id:protocol_id\n  init  State := 2\n\n  transition\n\t\t\t\t   %/\\ SND_UG(A'.M1'.Ki.T1')\n   1.State   = 2    /\\ RCV_UG(A'.\n\t\t\t\t\t\t\t  xor(H(Ki'.Xgwn),(IDi'.SIDj'.H(A'.IDi'.SIDj'.Kdi.T1'))).\n\t\t\t\t\t\t\t  Ki'.\n\t\t\t\t\t\t\t  T1'\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n\t State' := 3\t/\\ T2' := new()\n\t\t\t\t\t/\\ M3' := H(A'.SIDj'.Kxj.T2')\n\t\t\t\t\t/\\ SND_SG(A'.M3'.T2')\n\t\t\t\t\t\n\t\t\t\t\t/\\ secret_on( IDi,sc_user_id  ,{Ui,GW})\n\t\t\t\t\t/\\ secret_on(SIDj,sc_sensor_id,{Ui,GW})\n\t\t\t\t\t\n   2. State  = 5\t/\\ RCV_SG(B'\n\t\t\t\t\t\t\t .M4'\n\t\t\t\t\t\t\t .H(Kxj.M3.M4'.B')\n\t\t\t\t\t\t\t  )=|>\n\t\t\t\t\t\t\t  \n      State' :=6    /\\ K3' := new()\n\t\t\t\t\t/\\ Keinew' := H(K3'.Xgwn)\n\t\t\t\t\t/\\ M7' := H(Kei.K3'.Kdi.T1.M4')\n\t\t\t\t\t/\\ M6' := xor((Keinew'.K3'.M7'),Kei)\n\t\t\t\t\t/\\ SND_UG(B'.M6')\n\t\t\t\t\t\n\t\t\t\t\t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(Ui, Sj, GW : agent,\n\t\t\t Kdi,Kei, Kxj,Xgwn: symmetric_key,\n\t\t\t H,Expp: hash_func,\n\t\t\t P: text\t\t\t \n\t\t\t )\ndef=\n\n\tlocal \tSSG,RSG,\n\t\t\tSUG,RUG:channel(dy)\n\n  composition\n        user(Ui,Sj,GW,  Kdi,Kei,           H,Expp,P, SUG,RUG)\n  /\\  sensor(Ui,Sj,GW,  Kxj,               H,Expp,P, SSG,RSG)\n  /\\ gateway(Ui,Sj,GW,  Kdi,Kei,Kxj,Xgwn,  H,        SUG,RUG,SSG,RSG)\n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\n\ndef=\n\n  const ui, sj, gw : agent,\n        kdi,kei, kxj,xgwn, kig,keig: symmetric_key,\n        shared_key, sc_user_id ,\n\t\tsk_sensor_gwn, sc_sensor_id: protocol_id,\n\t\th,expp: hash_func,\n\t\tp: text\n\n  intruder_knowledge={ui, sj, gw, kig, h, p}\n\n  composition\n         session(ui,sj,gw,  kdi,kei,kxj,xgwn,  h,expp,p)\n      /\\ session(ui, i,gw,  kdi,kei,kig,xgwn,  h,expp,p)\n      /\\ session( i,sj,gw,  kig,keig,kxj,xgwn, h,expp,p)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n   secrecy_of sc_user_id, \n\t\t\t  sc_sensor_id\n\n % Message authentication (G2)\n   authentication_on shared_key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()```"]], "HLPSL-1/woolamProtocolFixed.hlpsl": [[false, "```houzhui\n% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n      Session : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ Session' := new() /\\ SNDA({Session'.A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({Session.B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n      Session : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ Session' := new() /\\ SNDB(X'.{Session'.A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{Session.A.Na.Nb.Kab'}_Kbs) =|>\n           State' :=3 /\\ SNDB(Y'.{Na.Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ request(B,A,kab_id,Kab)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, S, B : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\n  def=\n  const i, s, b, a : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n      session(a,b,s,kas,kbs,kab)\n    /\\session(a,b,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on Kab\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%```"]], "HLPSL-1/XorNSPK_1.hlpsl": [[false, "```houzhui\n%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     dummy  : nat, \n     Na    : message, \n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start) =|>\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ event(Na',secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb}_Kb)\n\nend role\n\n\n \nrole bob (B,A     : agent,  \n          Kb,Ka   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     dummy : nat, \n     Na    : message, \n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na.A}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              SND, RCV: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,SND,RCV) /\\ \n    bob(B,A,Kb,Ka,SND,RCV)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na : protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na\n\nend goal\n\n\n\nenvironment()```"]], "HLPSL-1/xvrabe07.hlpsl": [[false, "```\nrole role_A(A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kab:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Na':=new() /\\ SND(H(A.B.Na'.Kas).A.B.Na')\n\t\t6. State=1 /\\ RCV(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab) =|> State':=2 /\\ Kab' := new() /\\ secret(Kab',sec_1,{A,B})\nend role_A\n\nrole role_B(A:agent,B:agent,C:agent,H:hash_func,Kbs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text,Nb:text,Kas:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nb':=new() /\\ SND(H(B.C.Nb'.H(A.B.Na'.Kas'.A.B.Na').Kbs).B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t5. State=1 /\\ RCV(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab.B.A.xor(Kab,H(Nb.Kbs)).{B.A.Nb}_Kab.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc) =|> State':=2 /\\ Kab' := new() /\\ Kbc' := new() /\\ secret(Kbc',sec_2,{B,C}) /\\ secret(Kab',sec_1,{A,B}) /\\ SND(A.B.xor(Kab,H(Na.Kas)).{A.B.Na}_Kab)\nend role\n\nrole role_C(A:agent,B:agent,C:agent,H:hash_func,Kcs:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,S:agent,Nc:text,Nb:text,Kab:symmetric_key,Na:text,Kas:symmetric_key,Kbs:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t2. State=0 /\\ RCV(H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na') =|> State':=1 /\\ Nc':=new() /\\ S':=new() /\\ SND(H(C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kcs).C.S'.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas').A.B.Na'.Kbs').B.C.Nb'.H(A.B.Na'.Kas').A.B.Na')\n\t\t4. State=1 /\\ RCV(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc.C.B.xor(Kbc,H(Nc.Kcs)).{C.B.Nc}_Kbc) =|> State':=2 /\\ Kbc' := new() /\\ secret(Kbc',sec_2,{B,C}) /\\ secret(Kab',sec_1,{A,B}) /\\ SND(A.B.xor(Kab',H(Na.Kas)).{A.B.Na}_Kab'.B.A.xor(Kab',H(Nb.Kbs)).{B.A.Nb}_Kab'.B.C.xor(Kbc,H(Nb.Kbs)).{B.C.Nb}_Kbc)\nend role\n\nrole role_S(S:agent,A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tNb:text,Nc:text,Kas:symmetric_key,Na:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV(H(C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kcs).C.S.Nc'.H(B.C.Nb'.H(A.B.Na'.Kas).A.B.Na'.Kbs).B.C.Nb'.H(A.B.Na'.Kas).A.B.Na') =|> State':=1 /\\ Kbc' := new() /\\ secret(Kbc',sec_2,{B,C}) /\\ Kab' := new() /\\ secret(Kab',sec_1,{A,B}) /\\ SND(A.B.xor(Kab,H(Na'.Kas)).{A.B.Na'}_Kab.B.A.xor(Kab,H(Nb'.Kbs)).{B.A.Nb'}_Kab.B.C.xor(Kbc,H(Nb'.Kbs)).{B.C.Nb'}_Kbc.C.B.xor(Kbc,H(Nc'.Kcs)).{C.B.Nc'}_Kbc)\nend role\n\nrole session1(S:agent,A:agent,B:agent,C:agent,H:hash_func,Kas:symmetric_key,Kbs:symmetric_key,Kcs:symmetric_key,Kab:symmetric_key,Kbc:symmetric_key)\ndef=\n\tlocal\n\t\tSND4,RCV4,SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(S,A,B,C,H,Kas,Kbs,Kcs,Kab,Kbc,SND4,RCV4) /\\ role_C(A,B,C,H,Kcs,Kbc,SND3,RCV3) /\\ role_B(A,B,C,H,Kbs,Kab,Kbc,SND2,RCV2) /\\ role_A(A,B,C,H,Kas,Kab,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,key1:symmetric_key,key3:symmetric_key,const_1:hash_func,key4:symmetric_key,alice:agent,server:agent,carl:agent,bob:agent,key5:symmetric_key,key2:symmetric_key,sec_1:protocol_id,sec_2:protocol_id\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(server,alice,bob,carl,const_1,key3,key4,key5,key1,key2)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n```"]], "HLPSL-1/Auth-protocol.hlpsl": [[false, "```houzhui\n%%% Start of protocol\nrole ed (NAD, ED: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by ED\ndef=\n\tlocal\n\t\ti:nat,\n\t\tIDu, PWu, Bu, Aa, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n\t1. State = 0  /\\  RCV(start) =|> \n        State' := 1  /\\  M' := H(IDu.Bu) \n\t/\\ Aa' := new()\n\t/\\ TW' := H(xor(Aa,H(Bu.PWu)))\n%%%% Identity is Shared BETWEEN ED and NAD\n\t/\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n%%%%Send Registration Request to NAD\n\t/\\  SND({IDu.M'.TW'}_SKus)\n%%%% Receive Registration Reply to NAD\n\t2. State=1 /\\ RCV({PIDr'.Du.Yu.Fu.Zu}_SKus) =|>  \n%%%% Master key s is only known to NAD\n\tState' := 3 /\\  secret({Ss}, sp3, {NAD})\n%%%% Authentication and Key Exchange Phase (Public Channel)\n\t/\\ Fu' := H(IDu.TW)\n\t/\\ Cu' :=  new() \n%%%% Here we assume that H(IDu.Ss)= AB'\n\t/\\  AB' := xor(Du, H(IDu.TW))\n\t/\\ Buj'  := xor(xor(xor(Zu,H(IDj.Cu')),TW),H(PIDr'.H(IDu.Ss)))\n\t/\\ Xu' := xor(Yu, H(M.TW))\n\t/\\ DIDu' := H(PIDr'.Xu.Cu')\n%%% Send login request message M1 to NAD \n\t/\\ SND(PIDr'.DIDu'.Buj'.Cu')\n%%% U has freshly generated random number\n\t/\\ fresh(ED, NAD, cu, Cu)\n%%% Receive Authentication message from NAD\n\t3. State=3 /\\ RCV(Quj. Tu. Dj\t) =|> \n\tState' := 5 /\\  Dj' := new() /\\ PIDr' := new() \n\t/\\ Quj' := H(H(IDu.Ss).Tu.Cu.Dj.Xu.IDj)\n\t/\\ SKuj' := H(H(IDu.Ss). Cu. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\n\t/\\ PIDrprime' := xor(Tu, H(PIDr'.H(IDu.Ss).Xu))\n%%%Send authentication Reply to NAD\n\t/\\ SND(Qujprime')\n%%% ED's acceptance of values b' and Dj for ED by NAD\n\t/\\ accept(ED, NAD, dj, Dj)\n\t/\\ request(ED, b, bprime, bprime)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n%%NAD ROLE\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole networkdevice (ED, NAD: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by NAD\ndef=\n\tlocal\n\t\ti:nat,\n\t\tIDu, PWu, Bu, Aa, Bb, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b,  bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n%%%User Registration Phase\n \n\t1. State = 0 /\\ RCV({IDu.M.TW}_SKus) =|>\n%%%% Identity IDu is shared between ED and NAD\n\tState' := 2 /\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n\n%%%%% Computation\n\t/\\ Lu' := H(M.Ss)\n\t/\\ Bb' := new()\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\t\t\t\t\t\t\t\t\t\t\n\t/\\ Yu' := xor(Xu', H(M.TW))\n\t/\\ Zu' := xor(xor(Lu',H(Ss\t. Bb)),TW)\t\n\t/\\ Fu' := H(H(IDu.TW))\t\n\t/\\ PIDr' :={IDu.Ss.Bb}_SKus\n\t/\\ Du' := xor(H(IDu.Ss), H(IDu.TW))\n\t/\\ SND(PIDr'. Du'. Yu'.Fu'.Zu')\n%%%%%%%%%% Mutual Authentication\n%%% Receive login request Message M1 from ED\n\n\t2. State = 2 /\\ RCV(PIDr. DIDu. Buj.Cu') =|>\n%%%% We decrytp PIDr by using master key of CCS\n\tState' := 4 /\\   PIDr':= IDu.Ss.Bb\n\t/\\ Lu' := xor(xor(xor(Buj,H(H(IDj.Cu'))),H(PIDr.H(IDu.Ss))),H(Ss.Bb))\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n\t/\\ Bbprime' := new()\n\t/\\ Dj' := new()\n\t/\\ PIDrprime' := xor(H(IDu.Ss), H(Ss.Bbprime'))\n\t/\\ Tu' := xor(PIDrprime',H(PIDr'.H(IDu.Ss).Xu'))\n\t/\\ Quj' :=H(H(IDu.Ss).Tu'.Cu'.Dj'.Xu'.IDj)\n%%% Send request message M2 to ED publicly\n\t/\\ SND(Quj'.Tu'.Dj') \n%%% Freshly generated Random number b' and Dj\n\t/\\ witness(ED, NAD, dj, Dj')\n\t/\\ witness(ED, NAD, bprime, Bbprime')\n%%% Receive request message M3 to ED publicly\n\t3. State = 4 /\\ RCV(Qujprime') =|>\t\n%%% NAD acceptance of value Cu generated by ED for NAD\n\t  State' := 6  /\\ Cu' := new()\t  /\\ accept(ED, NAD, cu, Cu')\n\t/\\ SKuj' := H(H(IDu.Ss). Cu'. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\nend role \n\nrole session (ED,NAD: agent, SKus: symmetric_key)\ndef=\n\tlocal\n\t\tSND1,SND2,RCV1,RCV2: channel(dy)\n\tcomposition\n\t\ted (NAD, ED, SKus, SND1, RCV1)\n\t\t/\\  networkdevice (ED, NAD, SKus, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst ed, nad: agent, skus: symmetric_key,\n        h: hash_func, sp1,sp2, sp3, a, b, bprime, dj, cu: protocol_id\n\tintruder_knowledge = {ed, nad, h}\n\tcomposition\n\t session(ed, nad, skus) \n\t/\\ session(i, nad, skus)\n\t/\\ session(ed, i, skus)\nend role\ngoal\n        secrecy_of PWu, sp2, Bu\n        authentication_on a,NAD\n        authentication_on b, NAD,ED\nend goal\n```"]], "HLPSL-1/addNewSession.hlpsl": [[false, "```houzhui\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(_)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na)\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n    2. State=1 /\\ Rcv({Nb'}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) /\\\n    fixednspkxor(b,i,kb,ki,Snd,Rcv)\n  \nend role\n\n\ngoal \n     weak_authentication_on A by B\n     secrecy_on sna,snb\n\nend goal\n```"]], "HLPSL-1/Basic1.hlpsl": [[false, "```houzhui\nrole admin(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),KHN,KN,IDN:text,H:hash_func)\nplayed_by SA\ndef=\n        local State:nat,AN,BN:text\n        const secKHN,secIDN,secKN,sn_hn_beta,hn_sn_tidn:protocol_id\n        init State:=0\n        transition\n        1.State=0 /\\ RCV(start) =|> State':=1\n          /\\AN':=xor(IDN,H(KHN.KN))\n          /\\BN':=xor(xor(KHN,KN),AN')\n          /\\SND({IDN.AN'.BN'}_SK)\nend role\n\nrole snode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),H:hash_func)\nplayed_by SN\ndef=\n       local State:nat,IDN,AN,BN,RN,IDNnew,XN,YN,TIDN,ALPHA,BETA,FN,ETA,MU,RNnew,ANnew,TNnew,KHN,TN:text\n       const secKHN,secIDN,secKN,sn_hn_beta,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV({IDN'.AN'.BN'}_SK) =|> State':=1\n         /\\RN':=new() /\\ TN':=new()\n         /\\XN':= xor(AN',IDN')\n         /\\YN':=xor(XN',RN')\n         /\\TIDN':=H(xor(IDN',TN').RN')\n         /\\witness(SN,HN,hn_sn_tidn,TIDN')\n         /\\SND(TIDN'.YN'.AN'.BN'.TN')\n\n       2.State=1 /\\ RCV(ALPHA'.BETA'.ETA'.MU') =|> State':=2\n         /\\FN':=xor(XN,ALPHA')\n         /\\BETA':=H(XN.RN.FN'.ETA'.MU') /\\ request(SN,HN,sn_hn_beta,BETA')\n         /\\GAMMA':=xor(RN,FN') /\\ ANnew':=xor(GAMMA',ETA')\n         /\\BNnew':=xor(GAMMA',MU') /\\ KS':=H(IDN.RN.FN'.XN)\n         /\\AN':=ANnew' /\\ BN':=BNnew' /\\ secret(KN,secKN,{SN,HN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole hnode(SA,SN,HN:agent,SK:symmetric_key,SND,RCV:channel(dy),H:hash_func)\nplayed_by HN\ndef=\n       local State:nat,AN,BN,KN,IDN,KHN,XN,ALPHA,FN,RN,BETA,GAMMA,ETA,TN,TKN,KS:text\n       const secIDN,secKN,secKHN,sn_hn_beta,hn_sn_tidn:protocol_id\n       init State:=0\n       transition\n       1.State=0 /\\ RCV(TIDN'.YN'.AN'.BN'.TN') =|> State':=1\n         /\\KN':=xor(xor(KHN,BN),AN)\n         /\\XN':=H(KHN.KN')\n         /\\IDN':=xor(AN',XN') /\\ RN':=xor(YN',XN')\n         /\\TIDN':=H(xor(IDN',TN').RN') /\\ request(HN,SN,hn_sn_tidn,TIDN')\n         /\\FN':=new() /\\ ALPHA':=xor(XN',FN') /\\ GAMMA':=xor(RN',FN')\n         /\\TKN':=new() /\\ AN':=xor(IDN',H(KHN.TKN))\n         /\\BN':=xor(xor(KHN,TKN),AN') /\\ ETA':=xor(GAMMA',AN')\n         /\\MU':=xor(GAMMA',BN') /\\ BETA':=H(XN'.RN'.FN'.ETA'.MU')\n         /\\witness(HN,SN,sn_hn_beta,BETA') /\\ KS':=H(IDN'.RN'.FN'.XN')\n         /\\SND(ALPHA'.BETA'.ETA'.MU') /\\ secret(KN,secKN,{SA,SN}) /\\ secret(KHN,secKHN,{SA,HN}) /\\ secret(IDN,secIDN,{SA,SN,HN})\nend role\n\nrole session(SA,SN,HN:agent,SK:symmetric_key,KHN,KN,IDN:text,H:hash_func)\ndef=\n       local\n           SND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n       composition\n           admin(SA,SN,HN,SK,SND3,RCV3,KHN,KN,IDN,H) /\\ hnode(SA,SN,HN,SK,SND2,RCV2,H) /\\ snode(SA,SN,HN,SK,SND1,RCV1,H)\nend role\n\nrole environment()\ndef=\n      const sa,sn,hn:agent,\n            khn,kn,idn:text,\n            sk:symmetric_key,\n            h:hash_func,\n            seckn,seckhn,secidn,sn_hn_beta,hn_sn_tidn:protocol_id\n      intruder_knowledge={sa,sn,hn}\n      composition\n            session(sa,sn,hn,sk,khn,kn,idn,h)\nend role\ngoal\n     secrecy_of secKHN\n     secrecy_of secKN\n     secrecy_of secIDN\n     authentication_on sn_hn_beta\n     authentication_on hn_sn_tidn\nend goal\nenvironment()\n```"]], "HLPSL-1/calp-v1.hlpsl": [[false, "```houzhui\n%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), une badgeuse (B)\n%% Deux cas de figures :  - une demande d'acces normale (1)\n%%\t\t\t  - une demande d'acces exceptionnelle (2)\n%%B -> S : {IdBageuse, IdEmploye}_PKs\n%%S -> B : { Ok }_PKb\n%%B -> S : { Ok }_PKs\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role badgeuse, initiant le protocole\nrole badgeuse (B: agent, S: agent,\n\t    IdEmploye, IdBadgeuse : protocol_id,             \n            PKs, PKb: public_key,      \n            SND: channel(dy), RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat \n\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ secrecy_of(IdEmploye,idemploye,{B,S})\n    2.  State=1 /\\ RCV({ok}_PKb) =|> \n\tState':=2 /\\ SND({ok}_PKs) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse, IdBadgeuse : protocol_id,\n\t    PKb,PKs: public_key,\n\t    SND: channel(dy),RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat\n\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ SND({ok}_PKb)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse : protocol_id) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,PKs,PKb,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% definition du role caracterisant le scenario executer\nrole environment() def=\n\n    const b,s : agent,\n\t  pks, pkb, pki: public_key,\n          idemploye, idbadgeuse: protocol_id,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki)}\n\n    composition\n\n\tsession(b,s,pkb,pks,idemploye, idbadgeuse)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse)\n%%\tsession(i,s, pki,pks,idemploye, idbadgeuse)\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propriate verifier)\ngoal\n\tsecrecy_of IdEmploye\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du role principal\nenvironment()\n```"]], "HLPSL-1/DH.hlpsl": [[false, "```houzhui\nrole role_A(A:agent,B:agent,G:text,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,Y:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ X':=new() /\\ SND(exp(G,X'))\n\t\t2. State=1 /\\ RCV(exp(G,Y')) =|> State':=2 /\\ N':=new() /\\ secret(sec_2,sec_1,{A}) /\\ SND({N'}_exp(exp(G,X),Y'))\nend role\n\nrole role_B(A:agent,B:agent,G:text,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Y:text,X:text,N:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(exp(G,X')) =|> State':=1 /\\ Y':=new() /\\ SND(exp(G,Y'))\n\t\t3. State=1 /\\ RCV({N'}_exp(exp(G,X),Y)) =|> State':=2 /\\ secret(sec_2,sec_1,{A})\nend role\n\nrole session1(A:agent,B:agent,G:text)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(A,B,G,SND2,RCV2) /\\ role_A(A,B,G,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash,b:agent,a:agent,f:text,sec_1:key,sec_2:protocol_id\n\tintruder_knowledge = {a,b,f}\n\tcomposition\n\t\tsession1(a,b,f)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()```"]], "HLPSL-1/DH_with_Forward_Secrecy_(Vulnerable).hlpsl": [[false, "```houzhui\n% Protocollo\n% 1. A -> S: A, B\n% 2. A -> B: A, exp(g, Na)\n% 3. S -> B: {A, B, Kab}_Kbs\n% 4. S -> A: {A, B, Kab}_Kas\n% 5. B -> A: B, exp(g, Nb)\n\nrole role_A(A:agent,\n\t    B:agent,\n\t    S:agent,\n\t    G:nat,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab: symmetric_key,\n\t    Kas: symmetric_key,\n\t    SND1:channel(dy),\n\t    RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>\n\t\t   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Nb), Na), Kab)\n\t\t   /\\ secret(K', secretAB, {A, B})\n\t\t   /\\ SND({A.B.Kab}_Kas)\n\t\t   /\\ SND(A.exp(G, Na))\n\t\t   /\\ SND(Kas)\n\t\t   /\\ SND(Na)\nend role_A\n\nrole role_B(B:agent,\n\t    A:agent,\n\t    S:agent,\n\t    G:nat,\n\t    Na:nat,\n\t    Nb:nat,\n\t    Kab:symmetric_key,\n\t    Kbs:symmetric_key,\n\t    SND2:channel(dy),\n\t    RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tK:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State = 0\n\t\t   /\\ RCV(start)\n\t\t   =|>                   \n                   State' := 1\n\t\t   /\\ K' := exp(exp(exp(G, Na), Nb), Kab)\n\t\t   /\\ secret(K', secretAB, {A, B})\n\t\t   /\\ SND({A.B.Kab}_Kbs)\n\t\t   /\\ SND(B.exp(G, Nb))\n\t\t   /\\ SND(Kbs)\n\nend role\n\nrole session(A:agent, B:agent, S:agent, G:nat, Kas:symmetric_key, Kbs:symmetric_key)\ndef=\n\tlocal\n\t\tSND1:channel(dy),\n\t\tRCV1:channel(dy),\t\t\n\t\tSND2:channel(dy),\n\t\tRCV2:channel(dy),\n\t\tNa:nat,\n\t\tNb:nat,\n\t\tKab:symmetric_key\n\tcomposition\n                role_A(A, B, S, G, Na, Nb, Kab, Kas, SND1, RCV1)\n\t\t/\\ role_B(B, A, S, G, Na, Nb, Kab, Kbs, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n                a:agent,\n\t\tb:agent,\n\t\ts:agent,\n\t\tg:nat,\n\t\tkas:symmetric_key,\n\t\tkbs:symmetric_key,\n\t\tsecretAB:protocol_id\n\tintruder_knowledge = {a, b, g}\n\tcomposition\n\t\tsession(a, b, s, g, kas, kbs)\nend role\n\ngoal\n\n\tsecrecy_of secretAB\n\nend goal\n```"]], "HLPSL-1/EKE.hlpsl": [[false, "```houzhui\n%% PROTOCOL: EKE: Encrypted Key Exchange\n%% VARIANT: basic\n%% PURPOSE: Encrypted key exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellovin92encrypted.html}\n%% MODELER:\n%% \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : {Ea}_Kab        |    Key exchange part\n%% B -> A : {{K}_Ea}_Kab    |\n%% A -> B : {Ca}_K          |\n%% B -> A : {Ca,Cb}_K       |    Challenge/Response\n%% A -> B : {Cb}_K          |    Authentication part\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: \n%% \\begin{verbatim}\n%% i -> (a,3): start\n%% (a,3) -> i: {Ea(1)}_kab\n%% i -> (a,6): {Ea(1)}_kab\n%% (a,6) -> i: {{K(2)}_Ea(1)}_kab \n%% i -> (a,3): {{K(2)}_Ea(1)}_kab\n%% (a,3) -> i: {Na(3)}_K(2) witness(a,b,na,Na(3))\n%% i -> (a,6): {Na(3)}_K(2)\n%% (a,6) -> i: {Na(3),Nb(4)}_K(2) witness(a,b,nb,Nb(4))\n%% i -> (a,3): {Na(3),Nb(4)}_K(2)\n%% (a,3) -> i: {Nb(4)}_K(2)  request(a,b,nb,Nb(4))\n%% \\end{verbatim}\n%%\n%% Parallel session attack, man-in-the-middle\n%% between A as initiator and A as responder, attacker\n%% masquerades as B, but no secret nonces are exposed.\n%%\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke_Init (A,B: agent,\n               Kab: symmetric_key,\n               Snd: channel(dy),Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State   : nat,\n        Ea      : public_key,\n        Na,Nb,K : text\n\n  const sec_k1 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Ea' := new()\n      /\\ Snd({Ea'}_Kab) \n\n   2. State = 1\n      /\\ Rcv({{K'}_Ea}_Kab)\n      =|> \n      State' := 2\n      /\\ Na' := new()\n      /\\ Snd({Na'}_K') \n      /\\ secret(K',sec_k1,{A,B})\n      /\\ witness(A,B,na,Na')\n\n   3. State = 2\n      /\\ Rcv({Na.Nb'}_K) \n      =|> \n      State' := 3\n      /\\ Snd({Nb'}_K) \n      /\\ request(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke_Resp (B,A: agent,\n               Kab: symmetric_key,\n \t       Snd: channel(dy),Rcv: channel(dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        Na,Nb,K : text,\n\tEa      : public_key\n\n  const sec_k2 : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0 /\\ Rcv({Ea'}_Kab)\n      =|> \n      State' := 1\n      /\\ K' := new()\n      /\\ Snd({{K'}_Ea'}_Kab) \n      /\\ secret(K',sec_k2,{A,B})\n\n   2. State = 1 /\\ Rcv({Na'}_K)\n      =|> \n      State' := 2\n      /\\ Nb' := new()\n      /\\ Snd({Na'.Nb'}_K)\n      /\\ witness(B,A,nb,Nb')\n\n   3. State = 2\n      /\\ Rcv({Nb}_K)\n      =|> \n      State' := 3\n      /\\ request(B,A,na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Kab: symmetric_key)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n     eke_Init(A,B,Kab,SA,RA)\n  /\\ eke_Resp(B,A,Kab,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\nrole environment()\ndef=\n\n  const a, b   : agent,\n        kab    : symmetric_key,\n        na, nb : protocol_id\n\n  intruder_knowledge={a,b}\n\n  composition\n      session(a,b,kab)\n   /\\ session(b,a,kab)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n % Confidentiality (G12)\n secrecy_of sec_k1, sec_k2\n\n % Message authentication (G2)\n % EKE_Init authenticates EKE_Resp on nb\n authentication_on nb\n\n % Message authentication (G2)\n % EKE_Resp authenticates EKE_Init on na\n authentication_on na\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/Ex3_A.hlpsl": [[false, "```houzhui\n%\n%   1. A -> B: A,{Na}_Kb\n%   2. B -> A: B,{Na.Nb}_Ka\n%   3. A -> B: {zero,Msg}_(Na,Nb)\n%   4. B -> A: {one,Msg}_(Na,Nb)\n \n\n%Haykal Tej, Siemens CT IC 3, 2003 and\n%Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n\n \n\n\n\n\n\nrole share_Init B ( A, B     : agent, \n                  Ka, Kb   : public_key,\n                  Snd, Rcv : channel(dy)) played_by A def=\n\n  local  State   : nat,\n         Na, Msg : text,\n         Nb      : text,\n         K       : message % text.text\n\n  init   State := 0\n  accept State = 3\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|> \n      State':= 1 /\\ Na':= new()\n                 /\\ Snd(A.{Na'}_Kb)\n\n   2. State  = 1 /\\ Rcv(B.{Na.Nb'}_Ka) =|> \n      State':= 2 /\\ K':= Na.Nb'\n                 /\\ secret(K',nanb,{A,B})\n\t\t /\\ Msg':= new()\n                 /\\ Snd({zero.Msg'}_(K')) \n\n\n\n   3. State  = 2 /\\ Rcv({one.Msg}_K) =|> \n      State':= 3 \n\n\nend role\n\n\n\nrole share_Resp (B, A     : agent,\n                 Kb, Ka   : public_key,\n                 Snd, Rcv : channel (dy)) played_by B def=\n\n  local State   : nat,\n        Nb      : text,\n        Msg, Na : text,\n        K       : message % text.text\n\n  init   State := 0\n  accept State = 2 \n\n  transition\n\n   1. State  = 0 /\\ Rcv(A.{Na'}_Kb) =|> \n      State':= 1 /\\ Nb':= new()\n                 /\\ Snd(B.{Na'.Nb'}_Ka)\n                 /\\ K':= Na'.Nb'\n                 /\\ secret(K',nanb,{A,B})\n                 \n\n   2. State  = 1 /\\ Rcv({zero.Msg}_K) =|> \n      State':= 2 /\\ Snd({one.Msg}_K)\n                 \n\n\n\nend role\n\n\n\nrole session(A, B           : agent,\n             Ka, Kb         : public_key) def=\n\n  local  SA, RA, SB, RB : channel (dy)\n\n  composition\n    share_Init(A,B,Ka,Kb,SA,RA) /\\\n    share_Resp(B,A,Kb,Ka,SB,RB)\n\nend role\n\n\n\nrole environment() def=\n \n const zero, one    : text,\n       a, b, i      : agent,\n       ka, kb, ki   : public_key,\n       k1, k2, msg, nanb : protocol_id\n\n intruder_knowledge = {a,b,ka,kb,ki,i,inv(ki),zero,one}\n\n composition\n\n        session(a,b,ka,kb) \n    /\\  session(a,i,ka,ki) \n    /\\  session(i,b,ki,kb)\n    /\\  session(i,a,ki,ka) \nend role\n\n\n\ngoal\n\n\n    secrecy_of nanb\n\n\n\nend goal\n\n\n\nenvironment()```"]], "HLPSL-1/full-sample.hlpsl": [[false, "```houzhui\n%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) with key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1a. A ------------------- {A.B} ------------------> S\n%% 1b. A <-------------------{B.PKb}_inv(PKs) -------- S\n%% 1c. A --- {Na.A}_PKb ---> B\n%% 2a.                       B --- {B.A} ------------> S\n%% 2b.                       B <-- {A.PKa}_inv(PKs) -- S\n%% 2c. A <-- {Na.Nb}_PKa --- B\n%% 3 . A --- {Nb}_PKb -----> B\n%% PROBLEMS: 3\n%% ATTACKS: Man-in-the-middle attack\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n% Role of the initiator:\nrole alice (A, B: agent,             \n            PKa: public_key, PKs: public_key,  \n            KeyRing: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by A def=\n\n  local State: nat,\n        Na, Nb: text,\n        PKb: public_key\n\n  init State:=0\n\n  transition\n\n   % Start, if alice must request bob's public key from key server\n   ask.    State=0 /\\ Rcv(start) /\\ not(in(B.PKb', KeyRing))\n       =|> State':=1 /\\ Snd(A.B)\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({B.PKb'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(B.PKb', KeyRing)\n                     /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,bob_alice_na,Na')\n\n   % Start/resume, provided alice knows bob's public key\n   knows.  State=0 /\\ Rcv(start) /\\ in(B.PKb', KeyRing)\n       =|> State':=2 /\\ Na':=new() /\\ Snd({Na'.A}_PKb')\n                     /\\ secret(Na',sna,{A,B})\n                     /\\ witness(A,B,bob_alice_na,Na')\n\n   cont.   State=2 /\\ Rcv({Na.Nb'}_PKa) \n       =|> State':=3 /\\ Snd({Nb'}_PKb)\n\t             /\\ wrequest(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the receiver:\nrole bob(A, B: agent,      \n         PKb, PKs: public_key,  \n         KeyRing: (agent.public_key) set,\n         Snd, Rcv: channel(dy))\nplayed_by B def=\n\n  local State: nat,\n        Na, Nb: text, \n        PKa: public_key\n\n  init State:=0\n\n  transition \n\n   % Start if bob must request alice's public key from key server\n   ask.    State=0 /\\ Rcv({Na'.A}_PKb) /\\ not(in(A.PKa', KeyRing))\n       =|> State':=1 /\\ Snd(B.A)\n\n   % Receipt of response from key server\n   learn.  State=1 /\\ Rcv({A.PKa'}_inv(PKs))\n       =|> State':=2 /\\ KeyRing':=cons(A.PKa', KeyRing)\n                     /\\ Nb':=new() /\\ Snd({Na.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,alice_bob_nb,Nb')\n\n   % Start/resume, provided bob knows alice's public key\n   knows.  State=0 /\\ Rcv({Na'.A}_PKb) /\\ in(A.PKa', KeyRing)\n       =|> State':=2 /\\ Nb':=new() /\\ Snd({Na.Nb'}_PKa')\n                     /\\ secret(Nb',snb,{A,B})\n                     /\\ witness(B,A,alice_bob_nb,Nb')\n\n   cont.   State=2 /\\ Rcv({Nb}_PKb) \n       =|> State':=3 /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role of the key server:\nrole server(S: agent,\n            PKs: public_key,\n            KeyMap: (agent.public_key) set,\n            Snd, Rcv: channel(dy))\nplayed_by S def=\n\n  local X, Y: agent,\n        State: nat,\n\tPKy: public_key\n\n  transition\n   % Loop on receiving a key request, and sending it\n   req.   Rcv(X.Y') /\\ in(Y'.PKy', KeyMap)\n       =|> Snd({Y'.PKy'}_inv(PKs))\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Role representing a partial session between alice and bob:\nrole nspk(A, B: agent,\n          PKa, PKb, PKs: public_key,\n          KeyMapA, KeyMapB: (agent.public_key) set,\n          Snd, Rcv: channel(dy))\ndef=\n\n  composition\n     alice(A,B,PKa,PKs,KeyMapA,Snd,Rcv)\n     /\\ bob(A,B,PKb,PKs,KeyMapB,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% The main role:\nrole environment() def=\n\n  local KeyMapS,KeyMapA,KeyMapB,KeyMapI: (agent.public_key) set,\n        Snd, Rcv: channel(dy)\n\n  const a, b, s, i: agent,\n        pka, pkb, pki, pks: public_key,\n        sna, snb, alice_bob_nb, bob_alice_na: protocol_id\n\n  init KeyMapS:={a.pka, b.pkb, i.pki}\n    /\\ KeyMapA:={a.pka, b.pkb}\n    /\\ KeyMapB:={b.pkb}\n    /\\ KeyMapI:={i.pki}\n\n  intruder_knowledge = {a, b, s, pks, pka, pkb, pki, inv(pki)}\n\n  composition\n     server(s,pks,KeyMapS,Snd,Rcv) % one unique server for all sessions\n     /\\ nspk(a,b,pka,pkb,pks,KeyMapA,KeyMapB,Snd,Rcv)\n     /\\ nspk(a,i,pka,pki,pks,KeyMapA,KeyMapI,Snd,Rcv)\n     /\\ nspk(i,b,pki,pkb,pks,KeyMapI,KeyMapB,Snd,Rcv)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Description of goal properties:\ngoal\n\n  secrecy_of sna, snb % represented by the secret() predicate in the protocol\n  weak_authentication_on alice_bob_nb % represented by the witness() and wrequest() predicates in the protocol\n  authentication_on bob_alice_na % represented by the witness() and request() predicates in the protocol\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Call of the main role:\nenvironment()\n```"]], "HLPSL-1/h.530.hlpsl": [[true, "lled no intermediate hops (so VGK and AuF\n%% directly share a key) and a simple reduction proof shows that all\n%% attacks possible in a setting with an arbitrary number of intermediate\n%% hops can be simulated in our model with no intermediate hops. Note,\n%% however, that it is not possible to take this idea further and \"merge\" an\n%% honest VGK with AuF, as demonstrated by the attacks we have discovered\n%% where the intruder eavesdrops and replays messages (that he cannot\n%% decrypt) exchanged between VGK and AuF.\n%%\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key':=exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key_est_vgk,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key_est_vgk,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,AuF})  % AuF must be honest anyway...\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0 /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n               /\\ Key':=exp(GX',Y')\n               /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t       /\\ SND(M2'.F(ZZ_VA.M2'))\n               /\\ witness(VGK,MT,key_est_mt,Key')\n \n  2. State = 1 /\\ RCV(VGK.MT.FM2'.FM3'.F(ZZ_VA.VGK.MT.FM2'.FM3')) =|>\n     State':= 2 /\\ CH2' := new()\n               /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t\t        F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2 /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n               /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n               /\\ request(VGK,MT,key1,Key)\n               /\\ secret(Key,sec_v_Key,{MT,AuF})\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY'))))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf      : agent,\n    f            : hash_func,\n    key,key1     : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf \n                 : symmetric_key,\n    nil,g        : text\n\n  intruder_knowledge = {a,b,auf,f,g,nil,zz_i_auf}\n\n  composition\n     session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n  /\\ session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n%  /\\ session(b,a,auf,f,zz_b_auf,zz_a_auf,nil,g)\n%  /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n%  /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  authentication_on key_est_vgk\n  authentication_on key_est_mt key1\n  secrecy_of Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()", "```hlpsl\nlled no intermediate hops (so VGK and AuF\n%% directly share a key) and a simple reduction proof shows that all\n%% attacks possible in a setting with an arbitrary number of intermediate\n%% hops can be simulated in our model with no intermediate hops. Note,\n%% however, that it is not possible to take this idea further and \"merge\" an\n%% honest VGK with AuF, as demonstrated by the attacks we have discovered\n%% where the intruder eavesdrops and replays messages (that he cannot\n%% decrypt) exchanged between VGK and AuF.\n%%\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key':=exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key_est_vgk,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key_est_vgk,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,AuF})  % AuF must be honest anyway...\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0 /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n               /\\ Key':=exp(GX',Y')\n               /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t       /\\ SND(M2'.F(ZZ_VA.M2'))\n               /\\ witness(VGK,MT,key_est_mt,Key')\n \n  2. State = 1 /\\ RCV(VGK.MT.FM2'.FM3'.F(ZZ_VA.VGK.MT.FM2'.FM3')) =|>\n     State':= 2 /\\ CH2' := new()\n               /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t\t        F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2 /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n               /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n               /\\ request(VGK,MT,key1,Key)\n               /\\ secret(Key,sec_v_Key,{MT,AuF})\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY'))))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf      : agent,\n    f            : hash_func,\n    key,key1     : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf \n                 : symmetric_key,\n    nil,g        : text\n\n  intruder_knowledge = {a,b,auf,f,g,nil,zz_i_auf}\n\n  composition\n     session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n  /\\ session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n%  /\\ session(b,a,auf,f,zz_b_auf,zz_a_auf,nil,g)\n%  /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n%  /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  authentication_on key_est_vgk\n  authentication_on key_est_mt key1\n  secrecy_of Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/hash_n_multi.hlpsl": [[false, "```houzhui\nrole user (\n    U,S : agent,\n    SND,SU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\n 2. State  = 2 /\\ RCV(Nb'.S) =|>\n    State':= 4 /\\ Nah3' := F(F(F(PW)))\n               /\\ SND(Nah3'.U)\n\t       /\\ witness(U,S,user_server_nah3,Nah3)\n\t\t\t   \nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RU    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat,\n    Na,Nb   : text,\n    Nah4,Nah3      : message\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ Nb' := new()\n\t\t/\\ Nah3' := F(F(F(PW)))\n\t\t/\\ SND(Nb'.S)\n\n  2. State = 3 /\\ RCV(Nah3.U) =|>\n     State':= 5 /\\ request(S,U,user_server_nah3,Nah3)\n\t\t/\\ agreement(Nah3,sec_pw,{U,S})\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s      : agent,\n    f            : hash_func,\n    user_server_nah3,sec_pw     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah3\n  secrecy_of sec_pw\n\nend goal\n\n\nenvironment()```"]], "HLPSL-1/authenticationWPA.hlpsl": [[false, "```houzhui\n%% PROTOCOL: WPA2 Wifi security protocol authentication request response and 4 way handshake.\n%% PURPOSE:\n%% We want to model the security capabilities of the WPA2 model for which \n%% we need to use a relevant analysis software. Here, the protocol is \n%% modelled on AVISPA Tool. On performing the analysis, we see that\n%% there is no attack possible and the protocol is safe.\n%% However, we know now that there is a KRACK Attack possible against the protocol.\n%% THe purpose of this project is to come up with a patch to the protocol and hence\n%% the AVISPA tool is not sufficient to model such behaviour according to our findings.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\n\nrole authenticator(A,S:agent,\n\t   PMK: text,\t\n\t   KDF: hash_func,\n\t   Snd:channel(dy),Rcv:channel(dy)) \nplayed_by A\ndef=\n\n  local State : nat,\n  \tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, ANonce, SNonce,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\n  init State:=1\n\n  transition\n  \t1. State=1 /\\ Rcv(AuthReq) =|>\n  \t   State':=3 /\\ AuthResp' := new() /\\ Snd(AuthResp')\n\t1. State=3 /\\ Rcv(ReAuthReq) =|>\n\t   State' := 5 /\\ ReAuthResp' :=new() /\\ ReplayCounter' := new() /\\ ANonce' := new() /\\ Snd(ReAuthResp'.ReplayCounter'.ANonce')\n\t2. State=5 /\\ Rcv(ReplayCounter'.SNonce') =|> \n\t   State':= 7 /\\ PTK':= KDF(PMK.ANonce.SNonce') /\\ ReplayCounterplus1' := new() /\\ GTK':= new() /\\ Snd(ReplayCounterplus1'.{GTK'}_PTK') /\\\n\t   secret(GTK',sec_gtk,{A,S}) /\\\n\t   witness(A,authenticator_supplicant_auth,authenticator_supplicant_gtk,S)\n\t   \n\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole supplicant(S,A:agent, \n\t PMK: text,\n         KDF: hash_func,\n         Snd:channel(dy),Rcv:channel(dy)) \nplayed_by S\ndef=\n\n  local State : nat, \n\tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, SNonce, ANonce ,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\t\n  init State:=0\n  \n  transition\n  \t1. State=0 /\\ Rcv(AuthReq) =|> (* Note: For initiator, Rcv(AuthReq) is unusual here; usually Snd(AuthReq') is the first action from State 0 *)\n  \t   State':=2 /\\ AuthReq' := new() /\\ Snd(AuthReq')\n  \t2. State=2 /\\ Rcv(AuthResp') =|>\n  \t   State':=4 /\\ ReAuthReq' := new() /\\ Snd(ReAuthReq')\n\t1. State=4 /\\ Rcv(ReAuthResp'.ReplayCounter'.ANonce') =|>\n   \t   State':= 6 /\\ SNonce':=new() /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ Snd(ReplayCounter'.SNonce') \n   \t2. State= 6 /\\ Rcv(ReplayCounterplus1'.{GTK'}_PTK') =|>\n   \t   State':= 7 /\\ request(S,authenticator_supplicant_auth,authenticator_supplicant_gtk,GTK')\n\nend role\n\t\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n\nrole session(A,S:agent,\n\t      KDF: hash_func, \n\t      PMK:text) \ndef=\n\n  local SND_A,RCV_A,SND_B,RCV_B:channel(dy) \n  \n  composition\n\tauthenticator(A,S,PMK,KDF,SND_A,RCV_A) \n     /\\ supplicant(S,A,PMK,KDF,SND_B,RCV_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole environment() \ndef=\n\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id,\n  \ta,s : agent, \n\tpmk : text,\n\tgtk : protocol_id, (* Note: 'gtk' is a text variable, this definition as protocol_id might be a typo in the template *)\n\tkdf : hash_func\n\t\n  intruder_knowledge = {a,s,pmk}\n  \n  composition\n     session(a,s,kdf,pmk)\n \n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  \n  authentication_on authenticator_supplicant_gtk\n  secrecy_of sec_gtk (* Note: In standard HLPSL, this would be 'secrecy_of GTK', sec_gtk' *)\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/IKEv2-DS.hlpsl": [[false, "```\nrole alice(A,B:agent,\n\t   G: text,\n\t   F: hash_func,\n\t   Ka,Kb: public_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more specific: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat\n\n  const Pi : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  %% We have abstracted away from the negotiation of cryptographic\n  %% parameters.  Alice sends a nonce SAi1, which is meant to\n  %% model Alice sending only a single crypto-suite offer.  Bob must\n  %% then respond with the same nonce.\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n\t        /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.{SA1.exp(G,DHX).Ni.Nr'}_(inv(Ka)).SA2'}_SK' )\n                /\\ claim_A(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  \n  \n  \n  \n  3. State = 4  /\\ RCV_B({B.{SA1.KEr.Nr.Ni}_(inv(Kb)).SA2}_SK) =|>\n     State':= 9 /\\ claim_A(A,sec_a_SK,{A,B})\n                /\\ request(A,B,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob (B,A:agent,\n\t  G: text,\n\t  F: hash_func,\n\t  Kb, Ka: public_key,\n\t  SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat\n\n  const Pi : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1  /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':= 3 /\\ DHY' := new()\n                /\\ Nr' := new()\n                /\\ SND_A(SA1'.exp(G,DHY').Nr')\n                /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n                /\\ claim_B(B,A,sk1,F(Ni'.Nr'.SA1'.exp(KEi',DHY')))\n\n  2. State = 3  /\\ RCV_A( {A.{SA1.KEi.Ni.Nr}_(inv(Ka)).SA2'}_SK ) =|>\n     State':= 9 /\\ SND_A( {B.{SA1.exp(G,DHY).Nr.Ni}_(inv(Kb)).SA2'}_SK )\n                /\\ claim_B(B,sec_b_SK,SK,{A,B})\n                /\\ request(B,A,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, B: agent,\n\t     Ka, Kb: public_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\t   alice(A,B,G,F,Ka,Kb,SA,RA)\n\t/\\ bob(B,A,G,F,Kb,Ka,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const Pi,Pi    : protocol_id,\n        a, b       : agent,\n        ka, kb, ki : public_key,\n        g          : text,\n        f          : hash_func\n\n  intruder_knowledge = {g,f,a,b,ka,kb,i,ki,inv(ki)\n                       }\n\n  composition\n\n\tsession(a,b,ka,kb,g,f)\n     /\\ session(a,i,ka,ki,g,f)\n     /\\\tsession(i,b,ki,kb,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()\n```"]], "HLPSL-1/ISO1.hlpsl": [[false, "```\nhouzhui\n%% PROTOCOL: ISO1 Public Key Unilateral Authentication Protocol\n%% VARIANT: one-pass unilateral authentication\n%% PURPOSE: A client authenticates himself to a server by sending a digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%   1. A -> B : {PKa,A}inv(PKs), Na, B, Text,{Na,B,Text}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the digital signatures.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,4) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% i     -> (b,7) : pka,a,{pka,a}inv(pks),na(a,6),b,ctext,\n%%                  {na(a,6),b,ctext}inv(pka)\n%% \\end{verbatim}\n%% NOTES:\n%% \n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!; \n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%% If one would like to use the same server public key for each\n%% session, then permutation on \\verb!Pks! should be avoided.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso1_Init ( A,B : agent, Pka, Pks : public_key,\n                 Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n local  State: nat,\n        Na   : text\n\n init  State := 0\n\n%%% knowledge(A) = {A,B,Pka,Pks,ctext,inv(Pka)}\n\n transition\n\n   1. State = 0\n      /\\ rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext.{Na'.B.ctext}_inv(Pka))\n      /\\ commit(A,B,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso1_Resp (A, B: agent,\n                Pks : public_key,\n                Rec : channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat, \n         Pka       : public_key,\n         Na, Text  : text\n\n  init  State := 0\n\n%%%  knowledge(B)={A,B,Pks}\n\n  transition\n\n   1. State = 0 \n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text'.{Na'.B.Text'}_inv(Pka'))\n      =|>  \n      State' := 1\n      /\\ request(B,A,na,Na')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, RB: channel (dy)\n\n  const na : text\n\n  composition\n\n          iso1_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso1_Resp(A,B,Pks,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole env() def=\n\n  const ctext    : text,\n\ta, b     : agent,\n\tpka, pks : public_key\n\n  intruder_knowledge={a,b,pks,pka}\n\n  composition\n\n\tsession(a,b,pka,pks)\n     /\\\tsession(a,b,pka,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO1_Resp authenticates ISO1_Init on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/ISO3.hlpsl": [[false, "```houzhui\n%% PROTOCOL*: ISO3 Public Key Mutual Authentication Protocol\n%% VARIANT: two-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this\n%% protocol authentication should be achieved by a single encrypted message sent from each party.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize} \n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : PKa,A,{PKa,A}inv(PKs), Na, B, Text2,{Na,B,Text1}inv(PKa)\n%% 2. B -> A : PKb,B,{PKb,B}inv(PKs), Nb, A, Text4,{Nb,A,Text3}inv(PKb)\n%% \\end{verbatim}\n%% \\begin{itemize}\n%% \\item \\verb!inv(PKs)! is the private key of the server \\verb!C!\n%% \\item \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!\n%% \\item \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!\n%% \\end{itemize}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: \n%% The intruder can attack this protocol by simple eavesdropping\n%% and replaying the messages.\n%% \\begin{verbatim}\n%% i     -> (a,6) : start\n%% (a,6) -> i     : pka,a,{pka,a}inv(pks),na(a,6),b,ctext2,\n%%                  {na(a,6),b,ctext1}inv(pka)\n%% i     -> (b,9) : start\n%% (b,9) -> i     : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% i     -> (a,6) : pkb,b,{pkb,b}inv(pks),na(b,9),a,ctext2,\n%%                  {na(b,9),a,ctext1}inv(pkb)\n%% \\end{verbatim}\n%% NOTES:\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso3_Init( A, B     : agent,\t\n                Pka, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by A\ndef=\n\n  local  State\t\t   : nat,\n         Na\t\t   : text,\n         Nb, Text3, Text4  : text,\n         Pkb\t\t   : public_key\n\n  init State := 0 \n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext1,ctext2}\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Na'.B.ctext2.{Na'.B.ctext1}_inv(Pka)) \n      /\\ commit(A,B,na,Na')\n\n   2. State = 1 \n      /\\ Rcv(Pkb'.B.{Pkb'.B}_inv(Pks).Nb'.A.Text4'.{Nb'.A.Text3'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ wrequest(A,B,nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso3_Resp (B, A     : agent, \t\t\t\t\t\n                Pkb, Pks : public_key,\n                Snd, Rcv : channel(dy))\nplayed_by B\ndef=\n\n   local  State          : nat,\n          Nb             : text,\n          Na,Text1,Text2 : text,\n          Pka            : public_key\n\n   init State := 0\n\n%%%   knowledge(B)={A,B,Pkb,Pks,ctext3,ctext4}\n\n   transition\n\n   1. State = 0 \n      /\\ Rcv(Pka'.A.{Pka'.A}_inv(Pks).Na'.B.Text2'.{Na'.B.Text1'}_inv(Pka'))\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb'.A.ctext4.{Nb'.A.ctext3}_inv(Pkb)) \n      /\\ commit(B,A,nb,Nb')\n      /\\ wrequest(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A, B     : agent,\n\t      Pka, Pkb : public_key,\n              Pks      : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n          iso3_Init(A,B,Pka,Pks,SA,RA)\n       /\\ iso3_Resp(B,A,Pkb,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const ctext1, ctext2, ctext3, ctext4 : text,\n\tna, nb                         : protocol_id,\n        a, b                           : agent,\n        pka, pkb, pks, pki             : public_key\n\n  intruder_knowledge={a,b,pks,pki,inv(pki)}\n\n%%% LC: sufficient for finding the attacks\n  composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(b,a,pkb,pka,pks)\n\n%%%   composition\n%%% \n%%% \t session(a,b,pka,pkb,pks,sa1,ra1,sb1,rb1)\n%%%   /\\ session(a,c,pka,pkc,pks,sa2,ra2,sc2,rc2)\n%%%   /\\ session(a,a,pka,pka,pks,sa3,ra3,sa3,ra3)\n%%%   /\\ session(b,a,pkb,pka,pks,sb4,rb4,sa4,ra4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO3_Init weakly authenticates ISO3_Resp on nb\n   weak_authentication_on nb % addressess G1 and G2\n\n   %ISO3_Resp weakly authenticates ISO3_Init on na\n   weak_authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()\n```"]], "HLPSL-1/LPD-MSR.hlpsl": [[false, "```houzhui\n%% PROTOCOL: LPD: Low-Powered Devices\n%% VARIANT: MSR: Modulo Square Root\n%% LPD (Low-Powered Devices) MSR (Modulo Square Root) protocol is a key\n%% establishment protocol for secure mobile communications. It has been\n%% designed by Beller, Chang, and Yacobi in 1990s.\n%% Such a protocol relies on a public key cryptosystem for which\n%% encryption is particularly efficient, at least in comparison to other\n%% public key cryptosystems. The specific public key cryptosystem\n%% employed is due to Rabin, in which encryption and decryption\n%% tantamount, respectively, to modulo squaring and extracting a modulo\n%% square root (MSR).  MSR technique allows public key encryption to be \n%% implemented within the computational power of a mobile station.\n%%  \n%% PURPOSE:\n%% Key establishment protocol for secure mobile communications.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[page 4]{MutAuthLPD}\n%% \\end{itemize}\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M : agent\n%% PKb  : public key\n%% SCm  : text\n%% X    : symmetric key (fresh)\n%%\n%% 1. B -> M : B, PKb\n%% 2. M -> B : {x}PKb\n%% 3. M -> B : {M, SCm}x\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% M which is issued by a trusted central authority.\n%% \n%% Upon receiving {\\texttt{B}}'s public key {\\texttt{PKb}}, the mobile\n%% uses it to encrypt the session key {\\texttt{X}}, and sends the\n%% encrypted message to {\\texttt{B}}. The mobile also sends its identity\n%% and secret certificate encrypted under {\\texttt{X}} to authenticate\n%% {\\texttt{X}} to the base. The encryption in message 3 is carried out\n%% using a symmetric key cryptosystem. Since this encryption is\n%% negligible compared to the public key encryption in message 2, the\n%% computational effort at the mobile is effectively reduced to that of\n%% modulo squaring of the session key.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%%\n%% CLASSIFICATION: G1, G2, G12\n%%\n%% ATTACKS: \n%% The public key of {\\texttt{B}} is uncertified, thereby allowing anyone\n%% to masquerade as {\\texttt{B}} (perceived as a serious threat in the\n%% emerging standards).  Moreover replay of an old compromised session\n%% key allows masquerade of {\\texttt{M}}.  As a matter of fact, the\n%% following attack trace:\n%% \\begin{verbatim}\n%% i       -> (b,3)\t:\tstart\n%% (b,3)   -> i\t\t:\tb,kb\n%% i       -> (m,4)\t:\tb,ki\n%% (m,4)   -> i\t\t:\t{x0(m,4)}ki,{m,scm1}x0(m,4)\n%% \\end{verbatim}\n%% suffices (i) to violate the secrecy of the established session key\n%% {\\texttt{X}} and (ii) to make the base station {\\texttt{B}} to\n%% believe talking with the mobile {\\texttt{M}} while it is talking with the\n%% intruder.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole msr_Base(B, M     : agent,\n\t      PKb      : public_key,\n              SCm      : text, \n              Snd, Rcv : channel(agent))\nplayed_by B\ndef=\n\n  local  State : nat,\n\t X     : symmetric_key\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1 \n      /\\ Snd(B.PKb)\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{M.SCm}_X')\n      =|> \n      State' := 2  \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole msr_Mobile(B, M     : agent,\n                SCm      :   text, \n                Snd, Rcv : channel (agent))\nplayed_by M\ndef=\n\n  local State  : nat,\n\tPKb    : public_key,\n\tX      : symmetric_key\n\n  const secx   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.PKb')\n      =|> \n      State' := 1\n      /\\ X'  := new()\n      /\\ Snd({X'}_PKb'.{M.SCm}_X')\n      /\\ event(key_establish,B,x,X') \n      /\\ secret(X',secx,{B,M})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n\t     PKb            : public_key,\n             SCm            : text) def=\n\n  local  SA, RA, SB, RB : channel (agent)\n\n  const  secx : protocol_id\n\n  composition\n\n           msr_Base(B,M,PKb,SCm,SA,RA)\n        /\\ msr_Mobile(B,M,SCm,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n const b,m                             : agent,\n       kb, ki                          : public_key,\n       scm1,scm2,scm3                  : text\n\n intruder_knowledge = {b,m,scm2,scm3,i,ki,inv(ki)}\n\ncomposition\n\n\tsession(b,m,kb,scm1) \n    /\\  session(b,i,kb,scm2) \n    /\\  session(i,m,ki,scm3) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %MSR_Base weakly authenticates MSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/NSPK_2.hlpsl": [[false, "```houzhui\n%Alice - Bob\n%\n%   1. A -> B: {Na,A}_Kb\n%   2. B -> A: {Na,Nb}_Ka\n%   3. A -> B: {Nb}_Kb\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole alice (A: agent, B: agent,             \n            Ka: public_key, Kb: public_key,      \n            SND, RCV: channel (dy)) \nplayed_by A def=\n\n  local State : nat, \n        Na, Nb: text\n\n  init State := 0\n\n  transition  \n   \n    0.  State  = 0 /\\ RCV(start) =|> \n\tState':= 2 /\\ Na' := new() /\\ SND({Na'.A}_Kb)\n\t\t   /\\ secret(Na',  secret_na,{A,B}) \n\n    2.  State  = 2 /\\ RCV({Na.Nb'}_Ka) =|> \n\tState':= 4 /\\ SND({Nb'}_Kb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B: agent,      \n         Ka, Kb: public_key,      \n         SND, RCV: channel (dy)) \nplayed_by B def=\n\n  local State : nat, \n\tNa, Nb: text\n\n  init State := 1\n\n  transition \n\n    1.  State  = 1 /\\ RCV({Na'.A}_Kb) =|> \n\tState':= 3 /\\ Nb' := new() /\\ SND({Na'.Nb'}_Ka)\n\t\t   /\\ secret(Nb', secret_nb,{A,B}) \n\n\n    3.  State  = 3 /\\ RCV({Nb}_Kb) =|> \n\tState':= 5 \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A: agent, B: agent, Ka, Kb: public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition \n\n\talice(A,B,Ka,Kb,SA,RA)\n     /\\ bob  (A,B,Ka,Kb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n    const a, b\t       : agent,\n\t  ka, kb, ki   : public_key,\n\t  secret_na, secret_nb,\n\t  alice_bob_nb,\n\t  bob_alice_na : protocol_id\n\n    intruder_knowledge = {a, b, ka, kb, ki, inv(ki)}\n\n    composition\n\n\tsession(a,b,ka,kb)\n     /\\ session(a,i,ka,ki)\n     /\\ session(i,b,ki,kb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of secret_na, secret_nb\n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()```"]], "HLPSL-1/PBK.hlpsl": [[false, "```houzhui\n%% PROTOCOL: PBK: Purpose Built Keys Framework\n%% VARIANT: original version\n%% PURPOSE: Sender invariance (authentication assuming first message is not tampered with)\n%% REFERENCE: \\url{http://www.ietf.org/internet-drafts/draft-bradner-pbk-frame-06.txt}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Daniel Plasto for Siemens CT IC 3, 2004\n%% \\item Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  A -> B: A, PK_A, hash(PK_A)\n%%  A -> B: {Msg}_inv(PK_A), hash(PK_A)\n%%  B -> A: Nonce\n%%  A -> B: {Nonce}_inv(PK_A)\n%% \\end{verbatim}\n%%\n%% PROBLEMS: 1\n%% ATTACKS: \n%%   The initiator shall sign a random challenge received from the responder.\n%%   This can easily be exploited to make agents sign whatever the intruder wishes:\n%% \\begin{verbatim}\n%%   i      -> (a,3) : start\n%%   (a,3)  -> i     : {Msg(1)}inv(pk_a),f(pk_a)\n%%   i      -> (a,12): start\n%%   (a,12) -> i     : {Msg(2)}inv(pk_a),f(pk_a)\n%%   i      -> (a,3) : x71\n%%   (a,3)  -> i     : {x71}inv(pk_a)\n%%   i      -> (b,3) : {x71}inv(pk_a),f(pk_a)\n%%   (b,3)  -> i     : Nonce(4)\n%%   i      -> (a,12): Nonce(4)\n%%   (a,12) -> i     : {Nonce(4)}inv(pk_a)\n%%   i      -> (b,3) : {Nonce(4)}inv(pk_a)\n%% \\end{verbatim}\n%%\n%% NOTES:\n%% The protocol is so far only roughly described in natural language, and \n%% this file represents a verbatim translation to HLPSL as an\n%% ``early prototype'' and the AVISPA tool can identify a potential\n%% source for attacks which protocol designers should be aware of when\n%% implementing a protocol (see paragraph ``Attacks'').\n%% A fixed version (with tagging the \n%% challenge before signing it) is also provided in this library.\n%%\n%% The assumption is that the intruder cannot modify (or intercept) the first \n%% message is modelled by a compression-technique. Also, the authentication\n%% must be specified in a slightly different way, as A does not say for whom\n%% it signs the message (and anybody can act as responder). \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\nrole alice (A,B        : agent,\n            SND,RCV    : channel(text),\n            Hash       : hash_func,\n            PK_A       : public_key)\nplayed_by A\ndef=\n\n  local\n    dummy_nat      : nat,\n    Msg        : text,\n    Nonce      : text\n\n  init State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Msg' := new()\n               /\\ SND({Msg'}_inv(PK_A).Hash(PK_A))\n               /\\ witness(A,A,msg,Msg')\n\n 3. State  = 2 /\\ RCV(Nonce') =|>\n    State':= 4 /\\ SND({Nonce'}_inv(PK_A))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (B,A        : agent,\n          SND,RCV    : channel(text),\n          Hash       : hash_func,\n          PK_A       : public_key)\nplayed_by B\ndef=\n\n  local\n    dummy_nat      : nat,\n    Nonce      : text,\n    Msg        : text\n\n  init State := 1\n\n  transition\n\n 1. State  = 1 /\\ RCV({Msg'}_inv(PK_A).Hash(PK_A)) =|>\n    State':= 5 /\\ Nonce' := new()\n               /\\ SND(Nonce')\n\n 3. State  = 5 /\\ RCV({Nonce}_inv(PK_A)) =|>\n    State':= 7 /\\ wrequest(A,A,msg,Msg)\n         \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B  : agent,\n             Hash : hash_func,\n             PK_A : public_key)\ndef=\n\n  local SNDA,RCVA,SNDB,RCVB : channel (text)\n\n  composition\n\n    alice(A,B,SNDA,RCVA,Hash,PK_A)\n /\\ bob(B,A,SNDB,RCVB,Hash,PK_A)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b            : agent,\n    f              : hash_func,\n    msg            : protocol_id,\n    pk_a,pk_b,pk_i : public_key\n\n  intruder_knowledge = {a,b,f,pk_a,pk_b,pk_i,inv(pk_i)}\n\n  composition\n\n     session(a,b,f,pk_a)\n  /\\ session(b,a,f,pk_b)\n  /\\ session(i,b,f,pk_i)\n  /\\ session(a,i,f,pk_a)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Sender Invariance (G16)\n  weak_authentication_on msg\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n```"]], "HLPSL-1/protocol_v2.hlpsl": [[false, "```houzhui\n% PURPOSE: Syncronisation between two servers before sending a common request to another one\n% DESCRIPTION:\n% Two servers: Shell (S) and Code (C)\n% Third server: Master (M)\n\n% S ------- {Mess1.Ns.S}_PKc ------------> C\n% S <------ {Mess1.Mess2.Ns.Nc}_PKs ------ C\n% S ------- {OK.Mess1.Mess2.Nc}_PKc -----> C\n% S -------------- {Mess1.Mess2}_PKm ------------> M\n% S <------------- {OK.rep}_PKs ------------------ M\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Protocal: \n\n% Role of Shell (S):\n\nrole shell (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by S def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess2, Rep: text\n\n    init\n        State:=0\n\n    transition\n\n        % Start communication with Code and start creating the request\n        begin.\n            State=0\n            /\\ Rcv(init) \n        =|>\n            State':=1\n            /\\ Ns':=new()\n            /\\ Snd({Mess1.Ns'.S}_PKc)\n            /\\ secret(Ns',sns,{S,C})\n\n        % Receive full message from code and confirm the reception of Code's nonce\n        messageComplete.\n            State=1\n            /\\ Rcv({Mess1.Mess2'.Ns.Nc'}_PKs)\n        =|>\n            State':=2\n            /\\ Snd({OK.Mess1.Mess2'.Nc'}_PKc)\n\n        % Send full message to Master\n        send.\n            State=2\n        =|>\n            State':=3\n            /\\ Snd({Mess1.Mess2}_PKm)\n\n        % Receive response\n        receive.\n            State=3\n            /\\ Rcv(Rep') =|>\n            State':=4\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Code (C):\n\nrole code (\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess2: text,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by C def=\n\n    local \n        State: nat,\n        Ns, Nc, Mess1: text\n\n    init\n        State:=0\n\n    transition\n\n        % Receive first message and first part of the request from Shell \n        begin.\n            State=0\n            /\\ Rcv({Mess1'.Ns'.S}_PKc)\n        =|>\n            State':=1\n            /\\ Nc'::=new()\n            /\\ Snd({Mess1'.Mess2.Ns'.Nc'}_PKs)\n            /\\ secret(Nc',snc,{C,S})\n\n        % Receive the confirmation from Shell\n        messageComplete.\n            State=1\n            /\\ Rcv({OK.Mess1.Mess2.Nc}_PKc)\n        =|>\n            State':=2\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Role of Master (M):\n\nrole master (\n    M: agent,\n    PKm: public_key,\n    Snd, Rcv: channel(dy)\n)\n\nplayed_by M def=\n\n    local \n        State: nat,\n        Rep, Mess1, Mess2: text\n\n    init\n        State:=0  \n\n    transition  \n\n    % Receive Mess1.Mess2 and send response\n    send.\n        State=0\n        /\\ Rcv({Mess1.Mess2}_PKm)\n    =|>\n        State':=1\n        /\\ Rep':=new()\n        /\\ Snd({OK.Rep'}_PKs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Definition of session role:\n\nrole session(\n    S, C: agent,\n    PKs, PKc, PKm: public_key,\n    Mess1, Mess2: text,\n    Snd, Rcv: channel(dy)\n) def=\n\ncomposition \n    shell(S,C,PKs,PKc,PKm,Mess1,Snd,Rcv)\n    /\\ code(S,C,PKs,PKc,PKm,Mess2,Snd,Rcv)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% The main role:\n\nrole environment() def=\n\n    local \n        Snd, Rcv: channel(dy)\n\n    const\n        s, c, m, i: agent,\n        ok, mess1, mess2, init: text, % Added init to const\n        pks, pkc, pki, pkm: public_key,\n        sns, snc: protocol_id\n\n    intruder_knowledge = {s, c, m, pks, pkc, pkm, pki, inv(pki)}\n\n    composition\n    master(m,pkm,Snd,Rcv)\n    /\\ session(s,c,pks,pkc,pkm,mess1,mess2,Snd,Rcv)\n    /\\ session(s,i,pks,pki,pkm,mess1,mess2,Snd,Rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Description of goal properties:\n\ngoal\n\nsecrecy_of sns, snc % Keep secret the nonces\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Call of the main role:\n\nenvironment()```"]], "HLPSL-1/simple-sample.hlpsl": [[false, "```houzhui\n%% PROTOCOL: NSPK: Needham-Schroeder Public-Key Protocol\n%% VARIANT: original version (of 1978) without key server\n%% PURPOSE: Two-party mutual autentication\n%% ALICE_BOB:\n%% 1. A  - {Na.A}_PKb ----> B\n%% 2. A <- {Na.Nb}_PKa ---  B\n%% 3. A  - {Nb}_PKb ------> B\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le alice, initiant le protocole\nrole alice (A, B: agent,             \n            PKa, PKb: public_key,      \n            SND, RCV: channel(dy)) \nplayed_by A def=\n\n  local State: nat, \n        Na, Nb: text\n\n  init State:=0\n\n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 \n    /\\ Na':=new() \n    /\\ secret(Na',na,{A,B}) \n    /\\ witness(A,B,bob_alice_na,Na')\n    /\\ SND({Na'.A}_PKb)\n\n    2.  State=1 /\\ RCV({Na.Nb'}_PKa) =|> \n\tState':=2 /\\ SND({Nb'}_PKb)  /\\ request(A,B,alice_bob_nb,Nb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role bob \n\nrole bob (A, B: agent,             \n        PKa, PKb: public_key,      \n        SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n    local State: nat,\n        Na, Nb: text\n\n    init State:=0\n\n    transition \n    \n    0. State=0 /\\ RCV({Na'.A}_PKb) =|> State':=1 \n    /\\ Nb':=new() \n    /\\ secret(Nb',nb,{A,B}) \n    /\\ SND({Na'.Nb'}_PKa) \n    /\\ witness(B,A,alice_bob_nb,Nb')\n\n    2. State=1 /\\ RCV({Nb}_PKb) =|>\n    State':=2\n    /\\ request(B,A,bob_alice_na,Na)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(A, B: agent, PKa, PKb: public_key) def=\n\n  local SA, RA, SB, RB: channel(dy)\n\n  composition \n\n\talice(A,B,PKa,PKb,SA,RA)\n     /\\ bob(A,B,PKa,PKb,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const a, b: agent,\n\tpka, pkb, pki: public_key,\n    nb, na, alice_bob_nb, bob_alice_na: protocol_id\n\n    intruder_knowledge = {a, b, pka, pkb, pki, inv(pki)}\n\n    composition\n\n\tsession(a,b,pka,pkb)\n    /\\ session(a,i,pka,pki)\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% pour l'instant, pas de section goal ici (donc pas de propri\u00e9t\u00e9 \u00e0 v\u00e9rifier)\ngoal\n    %%secrecy_of nb, na\n    authentication_on bob_alice_na\n    authentication_on alice_bob_nb\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()```"]], "HLPSL-1/simple_protocol.hlpsl": [[false, "```houzhui\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ Kab':=new() /\\ SND({Kab'}_Kat) \n\t\t/\\ event(sec_1,Kab',{A,B,T})\n\t\t%/\\ SND(Kab')   %% Unsafe protocol but claimed SAFE!,\n                               %% Because of the bugs in the spec.\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat:symmetric_key,Kbt:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kat) =|> State':=1 /\\ SND({Kab'}_Kbt) \n\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Kab'}_Kbt) =|> State':=1 \nend role\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,\n                alice,bob,trusted:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {alice,bob,kit}\n\tcomposition\n\t\tsession(alice,bob,trusted,kat,kbt) /\\\n\t\tsession(alice,i,trusted,kat,kit)\n\nend role\n\ngoal\n        secrecy_of sec_1\nend goal\n\nenvironment()\n\n\n%%% Bugs can be found using span\n%%% \n%%% 1) No transition can be triggered (even in intruder simulation)\n%%%    This means that the first transition of the protocol cannot occur.\n%%%    Thus, the problem is located in the role A.\n%%%    This is due to the State=1 check of role A, which is impossible to satisfy. Correct by \n%%%    State=0.\n%%%\n%%% 2) After correcting the first bug. Try again to start a protocol simulation. Again no transition\n%%%    can be fired. Using intruder simulation, we can see that the message can be sent (to the intruder \n%%%    that receives any message) but not received by T. Thus, the problem is located in the role T.\n%%%    T cannot receive the message (although it is correctly built). If we look at the reception pattern in the role T, \n%%%    it is also correct. Thus, someting else prevents T from receiving the message. In the \"variable monitoring menu\", \n%%%    chose to monitor variables of T, and select them all. Then by clicking on the pink rectangle on the fired transitions, \n%%%    you can unfold the content of variables. If no transition is fired, no pink rectangle is displayed. By inspecting\n%%%    the values of the variable, you can see that the values for the variable Kat is incorrect. It is set to kbt.\n%%%    This is due to the session declaration that is buggy. Initialisation of role T is role_T(T,A,B,Kbt,Kbt,SND3,RCV3) \n%%%    where Kbt appears twice. The first one should be Kat. Correct it.\n%%%\n%%% 3) After correcting this bug. Try again to start a protocol simulation. Again simulation is stuck but after the first \n%%%    Transition. Using Intruder simulation, we can see that the second message can be sent by T but not received by B.\n%%%    Thus the mistake is in the reception of role B. There the pattern RCV({Kab}_Kbt) means that Kbt is already known \n%%%    (which is correct) but also that Kab is already known (which is false). You should correct this by RCV({Kab'}_Kbt) \n%%%    to state that B received a **new** value Kab.```"]], "HLPSL-1/strengthen_protocol.hlpsl": [[false, "```houzhui\n%%% Key exchange protocol, secured for secrecy, mutual authentication of A and B (but unoptimized)\n%%% 1. A -> T : {A,B,Kab,Na}_Kat\n%%% 2. T -> B : {B,A,Kab,Na}_Kbt\n%%% 3. B -> A : {A,B,Na,Nb}_Kab\n%%% 4. A -> B : {A,B,Nb}_Kab\n\nrole role_A(A:agent,B:agent,T:agent,Kat:symmetric_key,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n                Na,Nb:text,\n                Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> \n                   State':=1 /\\ Na':=new() /\\ Kab':=new() /\\ SND({A.B.Kab'.Na'}_Kat) /\\ secret(sec_1,{A,Kab',T})\n\n\t\t2. State=1 /\\ RCV({A.B.Na.Nb'}_Kab) =|> State':=2 /\\ SND({B.Nb'}_Kab)\n                   \n                   %% A checks that he receives the same nonce \n                   %% that he sent at step 1.\n                   /\\ request(A,B,auth_1,Na)\n\n                   %% A hopes that Nb will permit to authenticate him\n                   /\\ witness(A,B,auth_2,Nb')\nend role\n\nrole role_T(T:agent,A:agent,B:agent,Kat:symmetric_key,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by T\ndef=\n\tlocal\n\t\tState:nat,Na:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({A.B.Kab'.Na'}_Kat) =|> \n                   \n                   State':=1 /\\ SND({B.A.Kab'.Na'}_Kbt)\nend role\n\n\nrole role_B(B:agent,A:agent,T:agent,Kbt:symmetric_key,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:text,Nb:text,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({B.A.Kab'.Na'}_Kbt) =|> \n                   \n                   State':=1 /\\ Nb':= new() /\\ SND({A.B.Na'.Nb'}_Kab')\n\n                   %% B hopes that Na will permit to authenticate him\n                   /\\ witness(B,A,auth_1,Na')\n\n                2. State=1 /\\ RCV({B.Nb}_Kab) =|> State':=2 \n\n                %% B checks that he receives the same nonce \n                %% that he sent at step 1.\n\n                /\\ request(A,B,auth_2,Nb)\nend role\n\n\n\nrole session(A:agent,B:agent,T:agent,Kat:symmetric_key,Kbt:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_A(A,B,T,Kat,SND1,RCV1) /\\\n\t\trole_B(B,A,T,Kbt,SND2,RCV2) /\\ \n                role_T(T,A,B,Kat,Kbt,SND3,RCV3) \nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkat,kbt,kit:symmetric_key,      %% we add a symmetric key: kit shared between the intruder and T\n                alice,bob,trusted:agent,        \n                sec_1,auth_1,auth_2:protocol_id\n\tintruder_knowledge = {alice,bob,kit}    %% ... and we give it to the intruder\n\tcomposition\n                     %% We run the regular session\n\t\tsession(alice,bob,trusted,kat,kbt) \n%                      %% in parallel with another regular session\n                 /\\ session(alice,bob,trusted,kat,kbt) \n\n%                      %% and a session between the intruder (with key kit) and bob\n                 /\\ session(i,bob,trusted,kit,kbt) \n%                      %% and a session between alice and the intruder (with key kit)\n                 /\\ session(alice,i,trusted,kat,kit) \nend role\n\ngoal\n\tsecrecy_of Kab\n        authentication_on auth_1\n        authentication_on auth_2\nend goal\n```"]], "HLPSL-1/AVISPAProject.hlpsl": [[false, "```\nrole alice (A, S, B : agent,\n\t    Ka      : symmetric_key,\n\t    SND_SA, RCV_SA, SND_BA, RCV_BA : channel(dy))\n\nplayed_by A def=\n    local State : nat,\n          Na,Nb : text,\n          K     : symmetric_key,\n          X     : {symmetric_key.text.agent}_symmetric_key\n    init State := 0\n\n    transition\n    1. State  = 0 /\\ RCV_BA(start) =|>\n       State':= 2 /\\ Na' := new()\n                  /\\ SND_SA({A.B.Na'}_Ka)\n\n    2. State  = 2 /\\ RCV_SA({K'.Na}_Ka.X') =|>\n       State':= 4 /\\ SND_BA(X')\n\n    3. State  = 4 /\\ RCV_BA({Na.Nb'}_K) =|>\n       State':= 6 /\\ SND_BA({Nb'.Na}_K)\n                  /\\ request(A,B,alice_bob_na,Na) % A verifies that B knows K (B can decrpyt and encrypt again Na)\n                  /\\ witness(A,B,bob_alice_nb,Nb') \nend alice\n\n\nrole server (A, S, B  : agent,\n             Ka, Kb   : symmetric_key,\n             SND_AS, RCV_AS : channel(dy))\n\nplayed_by S def=\n    local State : nat,\n          Na    : text,\n          K     : symmetric_key\n    init  State := 1\n\n    transition\n    1. State  = 1 /\\ RCV_AS({A.B.Na'}_Ka) =|>\n       State':= 3 /\\ K' := new()\n                  /\\ SND_AS({K'.Na'}_Ka.{K'.Na'.A}_Kb)\n                  /\\ secret(S,k,{A,B,K'})\nend role\n\n\nrole bob (A, S, B : agent,\n          Kb      : symmetric_key,\n          SND_AB, RCV_AB : channel(dy))\n\nplayed_by B def=\n     local State  : nat,\n           Na,Nb  : text,\n           K      : symmetric_key\n     init  State := 5\n\n     transition\n     1. State  = 5 /\\ RCV_AB({K'.Na'.A}_Kb) =|>\n        State':= 7 /\\ Nb' := new()\n                   /\\ SND_AB({Na'.Nb'}_K')\n                   /\\ witness(B,A,alice_bob_na,Na')\n                   \n     2. State  = 7 /\\ RCV_AB({Nb.Na}_K) =|>\n        State':= 9 /\\ request(B,A,bob_alice_nb,Nb) % B verifies that A knows K (A can decrpyt and encrypt again Nb)\n                   \nend role\n\n\nrole session(A, S, B : agent,\n             Ka, Kb  : symmetric_key)\ndef=\n     local\n        SSA, RSA,\n        SBA, RBA,\n        SAS, RAS,\n        SAB, RAB : channel (dy)\n\n     composition\n              alice (A, S, B, Ka, SSA, RSA, SBA, RBA)\n          /\\  server(A, S, B, Ka, Kb, SAS, RAS)\n          /\\  bob   (A, S, B, Kb, SAB, RAB)\nend role\n\n\nrole environment()\ndef=\n      const a, b, s         : agent,\n            ka, kb, ki      : symmetric_key,\n            alice_bob_na, bob_alice_nb, k : protocol_id\n\n      intruder_knowledge = {a, b, s, ki}\n\n      composition         \n              session(a,s,b,ka,kb)\n           /\\ session(a,s,i,ka,ki)\n           /\\ session(i,s,b,ki,kb)\n           /\\ session(i,s,a,ki,ka)\nend role\n\n\ngoal\n    secrecy_of k\n    authentication_on alice_bob_na\n    authentication_on bob_alice_nb\nend goal\n```"]], "HLPSL-1/StrongAuthenticationPropertyofAlicetoBob.hlpsl": [[false, "```houzhui\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'.A}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (bob_alice_NA,A,bob_alice_NA,Nb')\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na',B)}_Ka)\n                    /\\ witness(bob_alice_NA,A,bob_alice_NA,Na)\n\t\t\t/\\ secret(snb,snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n```"]], "HLPSL-1/strongAuthentication_xor.hlpsl": [[false, "```houzhui\n%%%% B -> A: B,s\n\nrole role_A(A:agent,B:agent,SND:channel(dy),RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,S:text,Na:nonce\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV(start)  =|> State':=1 /\\ Na':=new() /\\ SND(Na')\n\t\t2. State=1 /\\ RCV(xor(Na,S')) =|> State':=2\n\n               %% A checks that B is the emmiter of nonce\n                /\\ request(A,B,auth_1,Na) \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole role_B(B:agent,A:agent,S:text,SND:channel(dy),RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Na:nonce\n\tinit\n\t\tState := 0\n\ttransition\n                                1. State=0 /\\ RCV(Na')  =|> State':=1 /\\ SND(xor(Na',S))\n                \n                /\\ secret(S,sec_1,{A,B}) \n                %% B Check the athentication of nonce\n                /\\ witness(B,A,auth_1,Na') \nend role\n\nrole session(A:agent,B:agent,S:text)\ndef=\n\tlocal\n\t\tSND1,SND2,RCV2,RCV1:channel(dy)\n\tcomposition\n\t\trole_B(B,A,S,SND2,RCV2) /\\ role_A(A,B,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t               alice,bob:agent,\n                               s1:text,\n                               sec_1,sec_2,auth_1:protocol_id\n\n\tintruder_knowledge = {alice,bob}\n\n\tcomposition\n                               %% add another session for replay attack\n\t\tsession(alice,bob,s1) /\\ session(alice,bob,s1)\nend role\n\ngoal \n                secrecy_of sec_1   \n                secrecy_of sec_2\n                %%  weak_authentication_on auth_1 , wrequest\n                weak_authentication_on auth_1\nend goal\n\nenvironment()```"]], "HLPSL-1/typedvariableNA.hlpsl": [[false, "```houzhui\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat, Na : text, Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,Na)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : text, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na,Na)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na)\n\t\t\t/\\ secret(Nb',snb,{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     authentication_on bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()```"]], "HLPSL-1/unsafe_one_sym_key.hlpsl": [[false, "```houzhui\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(\n\tA, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientServerKey: hash(text.text.hash(text.text.text)), % Keygen(Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text)\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks))) =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Pa.Sid)\n       \t\t   /\\ ClientServerKey' := KeyGen(Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientServerKey') % 6. A -> B: {Finished}Keygen(Na, Nb, M) \n       \t\t   /\\ witness(A,B,bob_alice_na_nb,Na.Nb')\n\n   4.  State = 4   /\\ RCV({Finished}_ClientServerKey) =|> % 7. B -> A: {Finished}Keygen(Na, Nb, M)\n       State' := 6 /\\ claim(A,B,alice_bob_na_nb,Na.Nb)\n\t\t   /\\ secret(ClientServerKey,{A,B},{A,B})\n       \t\t   \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(\n\tA, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks))) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   2.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb.B.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 6. A -> B: {Finished\n              \t\t}_KeyGen(Na.Nb.PRF(PMS'.Na.Nb))) =|> % }Keygen(Na, Nb, M) \n       State' := 5 /\\ SND({H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 7. B -> A: {Finished\n              \t\t}_KeyGen(Na.Nb.PRF(PMS'.Na.Nb))) % }Keygen(Na, Nb, M)\n       \t\t   /\\ claim(B,A,bob_alice_na_nb,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const\n\tsecrecyClientServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen }  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy_of ClientServerKey\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()```"]], "HLPSL-1/unsafe_wo_cert_check.hlpsl": [[false, "```houzhui\n% 0. A -> B: A, Na, Sid, Pa\t\tnounceA, sessionID, preferences for encryption\n% 1. B -> A: Nb, Sid, Pb\t\tnounceB, sessionID, preferences for encryption\n% 2. B -> A: {B, Kb}inv(Ks)\t\toptional server certificate\n% 3. A -> B: {A, Ka}inv(Ks)\t\toptional client certificate\n% 4. A -> B: {PMS}Kb\t\t\twhere PMS is a nonce generated by A\n% 5. A -> B: {H(Nb,B,PMS)}inv(Ka)\toptional certificate verify message\n% 6. A -> B: {Finished}Keygen(A, Na, Nb, M) Finished = H(M.A.B.Na.Nb.Pa.Sid)\n% 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole alice(\n\tA, B : agent,  \n        H, % for messsage verfication\n\tPRF, % pseudorandom number function to calc the master-secret\n\tKeyGen: hash_func, % generates the symmetric keys\n        Ka, Ks: public_key, % Ks is the public key of the certificate authority\n        SND, RCV: channel (dy))\nplayed_by A def=\n\n   local \n\tState: nat,\n\tNa, Sid, Pa, PMS: text, % nounceA, sessionID, preferences for encryption, premaster-secret\n        Nb: text, % nounceB\n        Finished: hash(hash(text.text.text).agent.agent.text.text.text), % H(PRF(PMS.Na.Nb).A.B.(Na|Nb).(Pa|Pb).Sid)\n        ClientK, ServerK: hash(agent.text.text.hash(text.text.text)), % Keygen(A.Na.Nb.PRF(PMS.Na.NB))\n        Kb: public_key,\n        M: hash(text.text.text)\n\n   init  \n\tState := 0\n\n   transition\n\n   0.  State = 0   /\\ RCV(start) =|>\n       State' := 2 /\\ Na' := new()\n\t\t   /\\ Sid' := new()\n       \t\t   /\\ Pa' := new()\n       \t\t   /\\ SND(A.Na'.Sid'.Pa') % 0. A -> B: A, Na, Sid, Pa\n\n   2.  State = 2   /\\ RCV(Nb'.Sid.Pa.B.Kb') =|> % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: B, Kb\n       State' := 4 /\\ PMS' := new()\n       \t\t   /\\ M' := PRF(PMS'.Na.Nb')\n       \t\t   /\\ Finished' := H(M'.A.B.Na.Pa.Sid)\n       \t\t   /\\ ClientK' := KeyGen(A.Na.Nb'.M')\n       \t\t   /\\ ServerK' := KeyGen(B.Na.Nb'.M')\n       \t\t   /\\ SND({A.Ka}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n              \t\t{PMS'}_Kb'. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb'.B.PMS')}_(inv(Ka)). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{Finished'}_ClientK') % 6. A -> B: {Finished}Keygen(A, Na, Nb, M) \n       \t\t   /\\ witness(A,B,bob_alice_na_nb,Na.Nb)\n\n   4.  State = 4   /\\ RCV({Finished}_ServerK) =|> % 7. B -> A: {Finished}Keygen(B, Na, Nb, M)\n       State' := 6 /\\ request(A,B,alice_bob_na_nb,Na.Nb)\n       \t\t   /\\ secrecy(ClientK,secrecyClientK,{A,B})\n       \t\t   /\\ secret(ServerK,secrecyServerK,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(\n\tA, B : agent,\n        H, PRF, KeyGen: hash_func,\n        Kb, Ks: public_key,\n        SND, RCV: channel (dy))\nplayed_by B def=\n\n   local \n\tNa, Nb, Sid, Pa, PMS: text,\n\tState: nat,\n        Ka: public_key\n\n   init  \n\tState := 1\n\n   transition\n\n   1.  State = 1   /\\ RCV(A.Na'.Sid'.Pa') =|> % 0. A -> B: A, Na, Sid, Pa\n       State' := 3 /\\ Nb' := new()\n       \t\t   /\\ SND(Nb'.Sid'.Pa'.B.Kb) % 1. B -> A: Nb, Sid, Pb AND 2. B -> A: {B, Kb}inv(Ks)\n       \t\t   /\\ witness(B,A,alice_bob_na_nb,Na'.Nb')\n\n   3.  State = 3   /\\ RCV({A.Ka'}_(inv(Ks)). % 3. A -> B: {A, Ka}inv(Ks)\n\t\t\t{PMS'}_Kb. % 4. A -> B: {PMS}Kb\n              \t\t{H(Nb.B.PMS')}_(inv(Ka')). %5. A -> B: {H(Nb,B,PMS)}inv(Ka)\n              \t\t{H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 6. A -> B: {Finished\n              \t\t}_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb))) =|> % }Keygen(A, Na, Nb, M) \n       State' := 5 /\\ SND({H(PRF(PMS'.Na.Nb).A.B.Na.Pa.Sid) % 7. B -> A: {Finished\n              \t\t}_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb))) % }Keygen(B, Na, Nb, M)\n       \t\t   /\\ request(B,A,bob_alice_na_nb,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\tA,B: agent,\n        Ka, Kb, Ks: public_key,\n        H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n        alice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n   /\\   bob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const \n\tsecrecyClientK, \n\tsecrecyServerK,\n\tbob_alice_na_nb, \n\talice_bob_na_nb : protocol_id,\n        ka, kb, ki, ks  : public_key,\n\ta, b            : agent,\n        h, prf, keygen  : hash_func\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki), {i.ki}_(inv(ks)), h, prf, keygen}  \n\n   composition\n        session(a,b,ka,kb,ks,h,prf,keygen)\n    /\\  session(a,i,ka,ki,ks,h,prf,keygen)\n    /\\  session(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  secrecy secrecyClientK,secrecyServerK\n  authentication_on alice_bob_na_nb\n  authentication_on bob_alice_na_nb\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()```"]], "HLPSL-1/untypedvariableNa.hlpsl": [[false, "```houzhui\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A : agent,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat, _: text set, Na : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ Rcv(start)\n\t=|> State':=1 /\\ Na:=new() /\\ Snd({Na.A}_Kb)\n                    /\\ event(bob_alice_NA,Na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,bob_alice_NA,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B : agent,A : agent,  \n          Kb : public_key,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : text, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na,B)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na)\n\t\t\t/\\ event(bob_nb_sent,Nb',{B,A})\n  \n\n\n    2. State=1 /\\ Rcv({Nb}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A: agent,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv) \n  \n  \nend role\n\n\ngoal \n     weak_authenticates bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()```"]], "HLPSL-1/weakAuthenticationfromAlicetoBob.hlpsl": [[false, "```houzhui\n%Fixed NSPK Protocol implemented with the xor operator\n\nrole alice (A,B : agent, \n            Ka,Kb : public_key,  \n            Snd,Rcv : channel (dy))\n\nplayed_by A def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n    1. State=0 /\\ rcv(start)\n\t=|> State':=1 /\\ Na':=new() /\\ Snd({Na'}_Kb)\n                    /\\ secret(Na',sna,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) \n\t  =|> State':=2 /\\ Snd({Nb'}_Kb)\n                    /\\ witness (B,A,bob_alice_NA,Na)\n\nend role\n\n\n \nrole bob (B,A : agent,  \n          Kb,Ka : public_key,  \n          Snd,Rcv : channel (dy))\n\nplayed_by B def=\n\n  local State : nat,\n        Na : message, \n        Nb : text\n\t\n  init State:=0\n\n  transition \n\t 1. State=0 /\\ Rcv({Na'.A}_Kb) \n\t  =|> State':=1 /\\ Nb':=new() /\\ Snd({Nb'.xor(Na,B)}_Ka)\n                    /\\ wrequest(A,B,bob_alice_NA,Na)\n\t\t\t/\\ secret(Nb',snb,{A,B})\n  \n\n\n    2. State=1 /\\ Rcv({Nb'}_Kb) \n\t  =|> State':=2 \n      \n\nend role\n\n\n\nrole fixednspkxor (A,B: agent,\n                   Ka, Kb: public_key, \n                   Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local Snd, Rcv: channel(dy)\n  \n  const a, b, i: agent,\n        ka, kb, ki: public_key,\n        sna,snb, bob_alice_NA: protocol_id\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    fixednspkxor(a,b,ka,kb,Snd,Rcv) /\\\n    fixednspkxor(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     weak_authentication bob_alice_NA\n     secrecy_of sna,snb\n\nend goal\n\n\n\nenvironment()```"]], "HLPSL-1/woolamProtocol.hlpsl": [[false, "```\nhouzhui\n% woo-lam protocol\n\nrole alice (A, B, S: agent,\n                Kas: symmetric_key,\n         SNDA, RCVA: channel(dy))\n\n  played_by A def=\n  \n  local State : nat,\n       Nb, Na : text,\n          Kab : symmetric_key\n\n  init State := 0\n  \n  transition\n\t1. State  = 0 /\\ RCVA(start) =|>\n\t   State':= 1 /\\ Na':= new()\n\t              /\\ SNDA(A.Na')\n\n\t2. State  = 1 /\\ RCVA(B.Nb') =|>\n\t   State':= 2 /\\ SNDA({A.B.Na.Nb'}_Kas)\n\n\t3. State  = 2 /\\ RCVA({B.Na.Nb.Kab'}_Kas.{Na.Nb}_Kab') =|>\n\t   State':= 3 /\\ SNDA({Nb}_Kab')\n\t              /\\ witness(A,B,kab_id,Kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (A, B, S: agent,\n             Kbs : symmetric_key,\n       SNDB, RCVB: channel(dy))\n\n  played_by B def=\n\n  local State : nat,\n       Na, Nb : text,\n         X, Y : {text}_symmetric_key,\n          Kab : symmetric_key\n\n  init State := 0\n\n  transition\n\t\t1. State  = 0 /\\ RCVB(A.Na') =|>\n\t\t   State':= 1 /\\ Nb':= new()\n                      /\\ SNDB(B.Nb')\n\n        2. State  = 1 /\\ RCVB(X') =|>\n           State' :=2 /\\ SNDB(X'.{A.B.Na.Nb}_Kbs)\n\n        3. State  = 2 /\\ RCVB(Y'.{A.Na.Nb.Kab'}_Kbs) =|>\n           State' :=3 /\\ SNDB(Y'.{Na.Nb}_Kab')\n\n\t\t4. State  = 3 /\\ RCVB({Nb}_Kab) =|>\n\t\t   State':= 4 /\\ witness(B,A,kab_id,Kab)\n\nend role \n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\nrole server (A, B, S: agent,\n       Kas, Kbs, Kab: symmetric_key,\n          SNDS, RCVS: channel(dy))\n\n  played_by S def=\n\n  local State : nat,\n       Nb, Na : text\n\n  init State := 0\n\n  transition\n\t1. State  = 0 /\\ RCVS({A.B.Na'.Nb'}_Kas.{A.B.Na'.Nb'}_Kbs) =|>\n\t   State':= 1 /\\ SNDS({B.Na'.Nb'.Kab}_Kas.{A.Na'.Nb'.Kab}_Kbs)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A, S, B : agent,\n\t\tKas, Kbs , Kab : symmetric_key)\n  def=\n\n  local SNDA, RCVA, SNDB, RCVB, SNDS, RCVS: channel (dy)\n\ncomposition\n\t   alice (A, B, S, Kas, SNDA, RCVA)\n\t/\\ bob(A, B, S, Kbs, SNDB, RCVB)\n\t/\\ server(A, B, S, Kas, Kbs, Kab, SNDS, RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole main()\n  def=\n  const i, a, b, s : agent,\n\tkas, kbs, kab : symmetric_key,\n\tkab_id: protocol_id\n\n  intruder_knowledge = {a, b, s, i}\n\n  composition\n\t  session(a,b,s,kas,kbs,kab)\n    /\\session(a,b,s,kas,kbs,kab)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tauthentication_on kab_id\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n```"]], "HLPSL-1/XorNSPK_2.hlpsl": [[false, "```proverif\n%NSPKxor Protocol\n\n%\n%   1. A -> B: {Na.A}_Kb\n%   2. B -> A: {Nb, Na xor B}_Ka\n%   3. A -> B: {Nb}_Kb\n\n \nrole alice (A,B     : agent, \n            Ka,Kb   : public_key,  \n            Snd,Rcv : channel (dy)) played_by A def=\n\n  local \n     State  : nat, \n     Na    : text, // Changed from message to text as it's used in xor\n     Nb     : text\n\t\n  init \n     State:=0\n\n  transition \n    1. State=0 /\\ Rcv(_) =|> // Alice initiates the protocol, Rcv(_) is a common placeholder for an implicit start trigger\n          State':=1\n       /\\ Na':=new()\n       /\\ Snd({Na'.A}_Kb)\n       /\\ secret(Na', secret_na,{A,B})\n\n\n    2. State=1 /\\ Rcv({Nb'.xor(Na,B)}_Ka) =|>\n          State':=2\n       /\\ Snd({Nb'}_Kb)\n\nend role\n\n\n \nrole bob (B,A     : agent,  \n          Kb,Ka   : public_key,  \n          Snd,Rcv : channel (dy)) played_by B def=\n\n  local \n     State : nat, \n     Na    : text, // Changed from message to text as it's used in xor\n     Nb    : text\n\n  init \n     State:=0\n \n  transition \n    1. State=0 /\\ Rcv({Na'.A'}_Kb) =|> \n          State':=1 \n       /\\ Nb':=new()\n       /\\ secret(Nb', secret_nb,{A,B})\n       /\\ Snd({Nb'.xor(Na',B)}_Ka)\n  \n\n\n    2. State=1 /\\ Rcv({Nb''}_Kb) =|> \n          State':=2 \n      \n\nend role\n\n\n\nrole session (A,B: agent,\n              Ka, Kb: public_key, \n              Snd, Rcv: channel(dy) ) def=\n\n  composition\n    alice(A,B,Ka,Kb,Snd,Rcv) /\\ \n    bob(B,A,Kb,Ka,Snd,Rcv)\n\nend role\n\n\n\nrole environment() def=\n\n  local\n     Snd, Rcv: channel(dy)\n  const\n     a, b, i: agent,\n     ka, kb, ki: public_key,\n     secret_na, secret_nb : protocol_id\n\n\n\n\n  intruder_knowledge = {a,b,i,ka,kb,ki,inv(ki)}\n\n  composition\n    session(a,b,ka,kb,Snd,Rcv) /\\\n    session(a,i,ka,ki,Snd,Rcv)  \n  \nend role\n\n\ngoal \n     secrecy_of secret_na \n     secrecy_of secret_nb\n\nend goal\n```"]], "HLPSL-1/xsulak04.hlpsl": [[false, "```houzhui\nrole role_A(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,Kas:symmetric_key,K_dummy:symmetric_key,T:nat,Kab:symmetric_key,Nb:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND(A.B)\n\t\t2. State=1 /\\ RCV({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas') =|> State':=2 /\\ secret(Kab',sec_1,{}) /\\ SND({Kab'.A.T'}_Kbs')\n\t\t4. State=2 /\\ RCV({Nb'}_Kab') =|> State':=3 /\\ secret(Kab,sec_1,{}) /\\ SND({Dec(Nb')}_Kab)\nend role\n\nrole role_B(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,Kbs:symmetric_key,T:nat,Kab:symmetric_key,Nb:nonce\n\tinit\n\t\tState := 0\n\ttransition\n\t\t3. State=0 /\\ RCV({Kab'.A.T'}_Kbs') =|> State':=1 /\\ secret(Kab',sec_1,{}) /\\ Nb':=new() /\\ SND({Nb'}_Kab')\n\t\t5. State=1 /\\ RCV({Dec(Nb)}_Kab') =|> State':=2 /\\ secret(Kab',sec_1,{})\nend role\n\nrole role_S(A:agent,B:agent,S:agent,Dec:hash_func,SND,RCV:channel(dy))\nplayed_by S\ndef=\n\tlocal\n\t\tState:nat,Kas:symmetric_key,T:nat,Kbs:symmetric_key,Kab:symmetric_key\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(A.B) =|> State':=1 /\\ Kas':=new() /\\ Kbs':=new() /\\ T':=new() /\\ Kab':=new() /\\ secret(Kab',sec_1,{}) /\\ SND({B.Kab'.T'.{Kab'.A.T'}_Kbs'}_Kas')\nend role\n\nrole session1(A:agent,B:agent,S:agent,Dec:hash_func)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_S(A,B,S,Dec,SND3,RCV3) /\\ role_B(A,B,S,Dec,SND2,RCV2) /\\ role_A(A,B,S,Dec,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\thash_0:hash_func,bob:agent,alice:agent,server:agent,dec:hash_func,sec_1:protocol_id\n\tintruder_knowledge = {}\n\tcomposition\n\t\tsession1(alice,bob,server,dec)\nend role\n\ngoal\n\tsecrecy_of Kab\nend goal\n\nenvironment()\n```"]]}