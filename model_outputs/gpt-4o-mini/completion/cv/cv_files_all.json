{"CV-1/Aizatulin-RPC.parse.cv": [[false, "```\nparam n.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\n(* unforgeable MACs *)\n\ntype mkeyseed [fixed, large].\ntype mkey [bounded].\ntype bitstring [bounded].\n(* type macres. *)\n\nproba 1.\n\nexpand UF_CMA_mac(mkeyseed, mkey, bitstring, bitstring, mkgen, mac, check, Pmac).\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\nfun parse2(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\n\nforall x:bitstring, y:bitstring;\n  parse1(concat1(x, y)) = x.\n\nforall x:bitstring, y:bitstring;\n  parse2(concat1(x, y)) = y.\n```"]], "CV-1/auto_sa_rename_after_simplify.cv": [[true, "param N:nat.\nchannel c.\n\nprocess\n\t(\n\tin(c, (x:bitstring, y:bitstring, z:bitstring));\n\tif x = y || x = z then\n\tfind i <= N suchthat defined(a[i]) && let y' = a[i] in x = y' then\n\t     out(c, true)\n\telse\t\n\t     out(c, false)\n\t)\t     \n|\n\t(\n\t!N\n\tin(c, a:bitstring[N]);\n\t)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15440K\nEND *)"]], "CV-1/bugsimplif.cv": [[false, "```\nhouzhui\n(* The \"find j <= N suchthat defined(j) then\" at some point lead to \n   a wrong simplification in which CryptoVerif considered that j must be defined\n   before executing the find, instead of just after.\n\n   Version in which the participants only talk to A and B \n   Using two series of function symbols to prevent repeated applications\n   of the same cryptographic rule.\n\n   The result obtained by CryptoVerif changed with the new semantics\n   of find: \n      find j <= N suchthat defined(j) then\n   is now interpreted as \n      find j = j' <= N suchthat defined(j) then \n   which always fails (j is not defined yet when defined(j) is tested).\n*)\n\nparam N: int;\n\n(* --- Types --- *)\ntype msg;\n\n(* --- Variables --- *)\nvar A, B: msg;\n\n(* --- Initial values --- *)\ninit {\n  A = 0;\n  B = 0;\n}\n\n(* --- Rules --- *)\nrule r1 {\n  if defined(A) then\n    find j <= N suchthat defined(j) then\n      A = encrypt(A,j)\n    else\n      skip\n  fi;\n}\n\nrule r2 {\n  if defined(B) then\n    find j <= N suchthat defined(j) then\n      B = encrypt(B,j)\n    else\n      skip\n  fi;\n}\n\n\n(* --- Assertions --- *)\nassert a1 {\n  A <> 0 -> exists j <= N : defined(j) & A = encrypt(A,j)\n}\n\n\nassert a2 {\n  B <> 0 -> exists j <= N : defined(j) & B = encrypt(B,j)\n}\n\n(* --- Function symbols --- *)\nfunc encrypt(m: msg, k: int): msg;\nfunc decrypt(c: msg, k: int): msg;\n\n(* --- Cryptographic properties --- *)\naxiom {\n  forall m: msg, k1, k2: int :\n    decrypt(encrypt(m,k1),k2) = m -> k1 = k2\n}\n\n```"]], "CV-1/CDH_RSR.cv": [[false, "```\n*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n ****************************************\n\nmodule Main.\n\n(*  This example implements a simple protocol where Alice\n    sends a message to Bob.\n\n    Alice chooses a random number x, computes y = x^2 mod n,\n    and sends y to Bob. Bob computes x = sqrt(y) mod n.\n    The protocol is insecure because the square root operation\n    is not well-defined in the integers modulo n.\n\n    Note: this example is only intended to illustrate the\n    translation from CryptoVerif to EasyCrypt. It's not a\n    real-world protocol.\n*)\n\n\n(*  Import the EasyCrypt library. *)\nRequire Import EasyCrypt.\n\n(*  Define the type of the messages. *)\nType msg.\nDefinition msg_alice := nat.\nDefinition msg_bob := nat.\n\n(* Define the modulus n. *)\nDefinition n := 11.\n\n(*  Define the square root function. *)\nFixpoint sqrt(x : nat) : nat :=\n  match x with\n  | 0 => 0\n  | S x' =>\n    if (x' mod 2 = 0) then\n     S (sqrt (x'/2))\n    else\n      0\n  end.\n\n(*  Define the protocol. *)\nFixpoint protocol(x : nat) : nat :=\n    let y := (x * x) mod n in\n    sqrt(y).\n(*  Define the protocol. *)\n\n\n(*  Define the specification. *)\nTheorem protocol_spec :\n  forall x : nat,\n  x < n ->\n  protocol x = x.\nProof.\n  intros x.\n  (*  This proof is incomplete. *)\n  unfold protocol.\n  (*  This proof is incomplete. *)\n  (*  The following line is a crucial step.  We need to prove\n      that the square root operation is well-defined in the\n      integers modulo n.  This is not the case in general.\n      We need to add a condition that ensures that there is\n      a unique square root.\n  *)\n  (*  Example:  if n is prime. *)\n  assert (exists y : nat, (y * y) mod n = x).\n  (*  This is not true in general.  For example, if n=11,\n      and x=5, then 5^2 = 25 mod 11 = 3.\n      We need to add a condition on n to prove the\n      theorem.\n  *)\n  (*  The square root operation is not well-defined in general.\n      We need to add a condition that ensures that there is\n      a unique square root.\n  *)\n  (*  The assertion is not true in general. We need to add\n      a condition on n.  For example, if n is a prime number,\n      then the square root operation is well-defined.\n  *)\n  (*  Example: if n is prime *)\n  (*  If n is prime, then the square root operation is well-defined.\n      We need to add a condition on n for this theorem to be true.\n  *)\n  (*  Use the fact that n is prime to prove the theorem. *)\n  (*  You need to add more assumptions or change the protocol\n      to make this theorem provable.\n  *)\n  (*  This is a placeholder.  You need to fill in the proof. *)\n  (*  This proof is incomplete. *)\n  (*  We need to add a condition on n to make the proof work. *)\nAbort.\n\n(*  End of the module. *)\n\nEnd Main.\n```"]], "CV-1/Chaudhuri-Blanchet-elgamal.cv": [[true, "param n, g.\n\ntype Z [n].\ntype G [fixed].\n\n(* Decisional Diffie-Hellman assumption *)\n\nproba pDDH.\n\nexpand DDH(G,Z,gamma,exp,mult,pDDH).\n\n(* Product in the group G *"]], "CV-1/Dreier-sako-ov-sound-simplified.cv": [[false, "```\n(* \nsimplif_add (dec(c1, keyone) <> bidToBit(bidval)) knowing\nSubstitutions:\n(dec(c1, sk) = bidToBit(bidval))\n(sk = keyone)\n(m1 = bidToBit(bidval))\nFacts:\nElsefind:\n\nAdding (dec(c1, keyone) <> bidToBit(bidval))\n\nTrying to apply the rewrite rule \"x <> x -> false\"\nin Terms.apply_eq_reds leads to testing\n\"Terms.simp_equal_terms try_no_var dec(c1, keyone) bidToBit(bidval)\"\nwhere try_no_var = Facts.try_no_var (substitutions above).\nHowever, Terms.simp_equal_terms and Facts.try_no_var \napply substitutions only to variables, so not to dec(c1, keyone)\nor bidToBit(bidval).\nHence the matching fails and the simplification is not\ndetected.\n\nSOLVED 26/5/2015\n*)\n\nparam sk : key;\nparam c1 : byte;\nparam keyone : key;\nparam bidval : byte;\n\n\n(* Define the decryption function.  Crucially, we need a way to apply\n   substitutions to the decryption function.  This example uses\n   a simple substitution that directly replaces the key.  More\n   sophisticated substitutions might be required for more complex\n   cryptographic operations. *)\nlet dec (c: byte, k: key) : bit = \n  match k with\n  | keyone ->  bidToBit(bidval)\n  | _ ->  false (* Or some default value *)\nend;\n\n\n(* Define a function to convert a byte to a bit. *)\nlet bidToBit (b: byte) : bit =\n  match b with\n  | 1 -> true\n  | _ -> false\nend;\n\n\nlet __simplif_add_dec_neq_bidToBit_substitution__ () : unit =\n  let dec_c1_keyone_val = dec(c1, keyone) in\n  let bidToBit_bidval_val = bidToBit(bidval) in\n\n  (* Apply substitution using the match case in dec *)\n  let dec_c1_keyone_val_sub = \n    match keyone with\n    | keyone -> bidToBit(bidval)\n    | _ -> false\n  in\n\n  (* Using a specialized equality checker that handles the substitution *)\n  if dec_c1_keyone_val_sub = bidToBit_bidval_val then\n    assert false  (*  dec(c1, keyone) = bidToBit(bidval) implies the expression is false *)\n  else\n    assert true;\nend;\n\n```"]], "CV-1/enc-then-MAC-IND-CPA.ocv": [[true, "(* Encrypt-then-MAC is IND-CPA *)\n\nparam N.\n\ntype mkey [fixed].\ntype key [bitstring].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nquery Qenc(b: bool) b.\n\nfun concat(c1: bitstring, macs: macs): bitstring [conc].\n\nletfun full_enc(m: bitstring, k: key, mk: mkey) =\n  c1 <- enc(m,k);\n  concat(c1,mac(c1,mk)).\n\nlet QencLR(b0: bool, k: key, mk: mkey) = \n    \tforeach i <= 1 do\n\tOenc (b0,k,mk)"]], "CV-1/enc-then-MAC-INT_CTXT.ocv": [[true, "(* Encrypt-then-MAC is INT-CTXT *)\n\nparam qEnc, qMac.\n\ntype bitstring [fixed].\ntype key [fixed].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nevent query_enc_dec.\nquery event(query_enc_dec) ==> false.\n\nfun concat(a: bitstring, b: macs): bitstring [data].\n\nletfun full_enc(m: bitstring, k: key, mk: mkey) =\n  c1 <- enc(m, k);\n  concat(c1,mac(c1, mk)).\n\nletfun full_dec(c: bitstring, k: key, mk: mkey) =\n  c1 <- split(c);\n  dec(c1, k) = m;\n  mac(c1,mk) = macs;\n  m, macs."]], "CV-1/encrypt-then-MAC.cv": [[false, "```\n(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n   \n    This file is part of CryptoVerif.\n    CryptoVerif is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    CryptoVerif is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with CryptoVerif.  If not, see <http://www.gnu.org/licenses/>.\n*)\n\n\n(* Example of a protocol with a flaw *)\n\nmodule Example = struct\n\n  (* Types *)\n  type agent = string\n  type msg =\n    | A of agent * agent * agent * string\n    | B of agent * agent * agent * string\n    | C of agent * agent * agent * string\n    | D of agent * agent * agent * string\n    | E of agent * agent * agent * string\n\n  (*  Precondition *)\n  let precond (a1:agent) (a2:agent) (a3:agent) : bool =\n    a1 <> a2 && a2 <> a3 && a1 <> a3\n\n  (*  Protocol *)\n  let protocol (a1:agent) (a2:agent) (a3:agent) : msg list =\n    if precond a1 a2 a3 then\n      [A (a1,a2,a3,\"a1\");\n       B (a2,a1,a3,\"a2\");\n       C (a3,a1,a2,\"a3\");\n       D (a1,a2,a3,\"a1\");\n       E (a2,a1,a3,\"a2\")]\n    else\n      []\n\n  (*  Verification conditions *)\n  let vc (a1:agent) (a2:agent) (a3:agent) =\n    let msgs = protocol a1 a2 a3 in\n    match msgs with\n    | [] -> true\n    | _ -> true\n    (* Add your verification conditions here *)\n\nend\n\n```"]], "CV-1/encryptBR93-1.cv": [[false, "```\n(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n   \n\n    Example of a simple protocol:\n    A sends to B a message encrypted with B's public key\n    B sends to A a message encrypted with A's public key\n    \n    This protocol is not secure.\n*)\n\nRequire Import CryptoVerif.\n\n(*  Import necessary modules *)\nRequire Import CryptoVerif.CryptoVerifLib.\nRequire Import CryptoVerif.CryptoVerifExamples.\n\n\n(*  Protocol definition *)\nModule ExampleProtocol.\n\n  Inductive msg :=\n    | msgA : unit -> msg\n    | msgB : unit -> msg.\n\n\n  Definition keyA : key.\n    keyA.\n  End.\n\n  Definition keyB : key.\n    keyB.\n  End.\n\n\n\n  (*  Variables *)\n  Variable a : agent.\n  Variable b : agent.\n\n  (*  Public keys *)\n  Definition pubA : public_key.\n    pubA.\n  End.\n\n  Definition pubB : public_key.\n    pubB.\n  End.\n  \n  (*  Signatures *)\n  Definition sigA (m : msg) : sig.\n    sigA m.\n  End.\n\n  Definition sigB (m : msg) : sig.\n    sigB m.\n  End.\n\n  (*  Encryption *)\n  Definition enc (m : msg) (k : key) : ciphertext.\n    enc m k.\n  End.\n\n\n  (*  Protocol steps *)\n  Definition step1 : step.\n    step1.\n  End.\n\n  Definition step2 : step.\n    step2.\n  End.\n\n\n\n  (*  Protocol rules *)\n  Definition protocol : protocol.\n    protocol.\n  End.\n\nEnd ExampleProtocol.\n\n(*  Security properties *)\n\n\n(*  Attacker *)\nDefinition attacker : attacker.\n  attacker.\nEnd.\n\n(*  Goal *)\nDefinition goal : goal.\n  goal.\nEnd.\n\n\n(*  Verification *)\nDefinition verification : verification.\n  verification.\nEnd.\n\n\n(*  Main theorem *)\nTheorem protocol_security :\n  secure protocol attacker goal.\nProof.\n  (*  Proof goes here *)\n  intros.\n  (*  The proof should be completed here *)\n  unfold secure.\n  unfold attacker.\n  unfold goal.\n  (*  Add your proof steps using CryptoVerif's tactics. *)\n  (*  Example: *)\n  (*  unfold protocol. *)\n  (*  unfold step1. *)\n  (*  ... *)\n  (*  apply secure_by_induction. *)\n  (*  ... *)\n  (*  Qed. *)\n  (*  Add your proof steps here.  This is a placeholder.  You need to implement the actual proof. *)\n\n  (*  This proof is incomplete. You need to fill in the missing steps. *)\n  (*  Consider using the CryptoVerif tactics like: *)\n  (*  apply secure_by_induction; *)\n  (*  intros; *)\n  (*  ... *)\n\n  (*  Example proof (insecure): *)\n  apply False_ind.\nQed.\n\n\n```"]], "CV-1/encryptBR93-1.ocv": [[true, "(*\n * Example protocol:  A simple key exchange protocol\n *\n * Description:\n * This protocol is a simplified version of a key exchange protocol.\n * It demonstrates the use of nonces and session keys.\n *\n * Parties: Alice, Bob\n *\n * Messages:\n *  A -> B:  N_A\n *  B -> A:  N_B, K\n *  A -> B:  K\n *\n *  Where:\n *    N_A is a nonce generated by Alice\n *    N_B is a nonce generated by Bob\n *    K is a session key\n *\n *  Assumptions:\n *    - Each party generates fresh nonces.\n *    - The session key is generated randomly.\n *\n *  Goal:\n *    Verify that the protocol is secure against replay attacks.\n *)\n\nmodule KeyExchange =\nstruct\n\n  type nonce = int;\n  type key = int;\n\n  (* Alice's role *)\n  let alice (na: nonce) : (nonce * key) =\n    let (nb, k) = (read_input ()) in\n    if nb <> na then (0,0) else (nb,k)\n\n\n  (* Bob's role *)\n  let bob (nb: nonce) : (nonce * key) =\n    let na = read_input () in\n    let k = fresh_key () in\n    write_output (na, k);\n    (nb, k)\n\n\n  (* Protocol definition *)\n  let protocol () =\n    let (na, k1) = (fresh_nonce (), fresh_key ()) in\n    let (nb, k2) = bob (na) in\n    let (nbp, kp) = alice (nb) in\n      if (nbp = nb) && (k1 = kp) then  (1, 0) else (0, 0)\n\n\n  (* Auxiliary functions *)\n  let fresh_nonce () =\n    let n = Random.int 1000 in\n      n\n\n  let fresh_key () =\n    let k = Random.int 1000 in\n      k\n\n  let read_input () =\n     let (a, b) = (fresh_nonce (), fresh_key ()) in\n      (a, b)\n\n  let write_output (a, b) =\n    ()\n\nend\n\n\n(* Main function *)\nlet main () =\n  let result = KeyExchange.protocol () in\n  Printf.printf \"Result: %d\\n\" (fst result);\n  exit (snd result)\n\nlet () = main ()"]], "CV-1/encryptfdhWithEncryptionOracle.cv": [[true, "(* FDH encryption scheme (CPA) *)\n\nproof {\ncrypto hash;\nremove_assign binder pk;\ncrypto f r;\nshow_game;\ncrypto (r_78) r_78;\nsuccess\n}\n\n\nparam N.\nparam N2.\nparam bitstring.\nparam N4.\nparam bitstring.\nparam N6.\nparam N7.\n\ntype bitstring.\ntype skey.\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba 1.\n\nconst mark:bitstring.\nfun pkgen(keyseed):pkey.\nfun pkgen2(keyseed):pkey.\nfun skgen(keyseed):skey.\nfun f(pkey, seed):seed.\nfun f2(skey, seed):seed.\nfun mf(skey, seed):seed.\n\nforall r:keyseed, x:seed; mf(skgen(r),x) = x /\\ f(pkgen(r),x) = f(pkgen(r),x);"]], "CV-1/Avik-cc-sym-enc-prf-mac.cv": [[false, "```\nhouzhui\n(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, k, q, qE, qD.\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba pXOR.\n\nfun f(k:K,N): S.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:N) m -> f(k,x)\n<=(pPRF(time,n,k))=>\n   \n```"]], "CV-1/equivromhash1.ocv": [[true, "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************\n *\n * Example:  A simple key exchange protocol.\n *\n * Protocol description:\n *\n *   A -> B : A_k\n *   B -> A : B_k\n *\n *   A computes K = Dec(A_k,B_k)\n *   B computes K = Dec(B_k,A_k)\n *\n *\n *  Assumptions:\n *    - A_k is a secret key, encrypted under a public key.\n *    - B_k is a secret key, encrypted under a public key.\n *    - Dec denotes the decryption function\n *\n ******************************************************************)\n\n(* Import the CryptoVerif library *)\nRequire Import CryptoVerif.\n\n(* Define the participants *)\nDefinition A := participant.\nDefinition B := participant.\n\n(* Define the messages *)\nDefinition A_k := message.\nDefinition B_k := message.\nDefinition K := message.\n\n\n(* Define the protocol *)\nDefinition protocol :=\n  seq\n    (send A B A_k)\n    (send B A B_k)\n    (receive A A_k)\n    (receive B B_k)\n    (compute A K (fun (A_k B_k) => Dec(A_k,B_k))) (* Replace with appropriate decryption function *)\n    (compute B K (fun (A_k B_k) => Dec(B_k,A_k))) (* Replace with appropriate decryption function *)\n.\n\n\n(* Define the security goals *)\n(* In this example, we want to ensure that A and B compute the same key K *)\nDefinition security_goal :=\n  equiv protocol (fun _ => K = K).\n\n(* Define the cryptographic assumptions *)\n(* We need to define the decryption function and any other cryptographic primitives used *)\n(* Example using a simple decryption function *)\nDefinition Dec (k1 k2: message) : message :=\n  match (k1, k2) with\n  | (m1, m2) => m1\n  end.\n\n\n(* Define the properties of the messages *)\n(*  The following properties are crucial for the analysis *)\n(*  Usually you need to define that each message is a valid encryption *)\n(*  or a valid decryption of the previous message *)\n(*  (e.g. A_k is the encryption of a secret key under a public key) *)\n\n(* Example of properties, adapt to your protocol *)\n(*  You need to define the properties of the key exchange process,\n    such as the encryption and decryption functions.\n    These properties are essential for the verifier to reason about the security of the protocol.\n *)\n\n\n(* Define the security properties.  In this example,\n   we want to ensure that the key K is the same for both A and B. *)\n\n(*  This is a placeholder.  You need to define the properties\n    of the messages, such as the fact that A_k and B_k are\n    encrypted using valid keys, etc.\n *)\n\n(* Define the assumptions about the keys *)\n(* Example: A_k and B_k are generated by a secure key generation process *)\n\n\n(*  The following part is essential for CryptoVerif to work.\n    You need to define the properties of the encryption and decryption functions,\n    and how they relate to the messages exchanged in the protocol.\n*)\n\n\n\n(* Now, run the verification *)\n(* This is a placeholder.  You need to define the appropriate\n   cryptographic assumptions and properties for your protocol.\n   These properties are essential for the verifier to reason about the security of the protocol.\n*)\nTheorem security_proof : security_goal.\nProof.\n  (* This is where the proof will be constructed *)\n  (* CryptoVerif will automatically generate the proof *)\n  (* This is a stub.  You need to provide the actual proof *)\n  (* ... *)\nAbort.\n\n(* End of the protocol definition *)\n\n(* This part is important for CryptoVerif to understand the message flow. *)\n\n(*  Add the appropriate properties about the messages used in the protocol here. *)\n(*  For example, you might define that the messages A_k and B_k are\n    valid encryptions of secret keys, or that the computation of\n    K from A_k and B_k is valid decryption. *)"]], "CV-1/fdh-1.ocv": [[true, "(* Example protocol: a simple authentication protocol *)\n\n(* Alice sends a nonce to Bob, who sends back the nonce and a signature *)\n\n(*  We assume that the signature function is correct *)\n\n(*  The protocol is secure if the adversary cannot forge a signature *)\n\n\n(*  We model the protocol using the following variables: *)\n(*  - alice_nonce: nonce sent by Alice *)\n(*  - bob_nonce: nonce sent by Bob *)\n(*  - bob_signature: signature sent by Bob *)\n\n\n(*  The protocol is as follows: *)\n(*  1. Alice -> Bob: alice_nonce *)\n(*  2. Bob -> Alice: bob_nonce, bob_signature(alice_nonce) *)\n\n\n(*  We define the following variables: *)\n(*  - alice_nonce: nonce sent by Alice *)\n(*  - bob_nonce: nonce sent by Bob *)\n(*  - bob_signature: signature sent by Bob *)\n\n\n(*  We define the following adversarial actions: *)\n(*  - adversary_receive_alice_nonce: adversary receives alice_nonce *)\n(*  - adversary_receive_bob_nonce: adversary receives bob_nonce *)\n(*  - adversary_receive_bob_signature: adversary receives bob_signature *)\n(*  - adversary_send_alice_nonce: adversary sends alice_nonce *)\n(*  - adversary_send_bob_nonce: adversary sends bob_nonce *)\n(*  - adversary_send_bob_signature: adversary sends bob_signature *)\n\n\n(*  We define the following hypotheses: *)\n(*  - Alice sends a random nonce *)\n(*  - Bob sends a random nonce and a valid signature *)\n\n\n(*  We define the following security properties: *)\n(*  - The adversary cannot forge a signature *)\n\n\n(*  We use the following cryptographic primitives: *)\n(*  - nonce_gen: generates a nonce *)\n(*  - signature: computes a signature *)\n\n\n(*  We define the following functions: *)\nlet nonce_gen () =\n  let open Random in\n  int 0x100000000\n\nlet signature (m:int) (sk:int) =\n  m + sk\n\nlet decrypt (m:int) (pk:int) =\n  m - pk\n\n\n(*  We define the following variables: *)\ntype state =\n  | Init\n  | AliceSentNonce of int\n  | BobSentNonce of int * int\n  | Final\n\n(*  We define the protocol steps: *)\nlet protocol_steps =\n  [\n    (Init, AliceSentNonce (nonce_gen()), \"Alice sends a nonce\");\n    (AliceSentNonce nonce, BobSentNonce (nonce, signature nonce 1), \"Bob sends a nonce and a signature\");\n\t(BobSentNonce (nonce, signature_nonce), Final, \"Final state\");\n  ]\n\n(* We define the adversary's capabilities, actions and goals *)\nlet adversary_actions =\n[\n    (\"adversary_receive_alice_nonce\", fun (nonce) -> (AliceSentNonce nonce));\n    (\"adversary_send_bob_nonce\", fun (nonce) -> (BobSentNonce (nonce, signature nonce 1)));\n]\n\n(* We define the security goal *)\nlet security_goal =\n  (Init, Final, \"Adversary cannot forge a signature\")\n\n(* We need to define the signature function properly *)\nlet signature (m:int) (sk:int) = m + sk\n\n\n(* The protocol is verified by CryptoVerif *)\nlet _ =\n  let open CryptoVerif in\n  verify protocol_steps adversary_actions security_goal"]], "CV-1/fdh-JSC.cv": [[false, "```\n(* Example protocol: a simple authentication protocol *)\n\n(* Description:  A simple authentication protocol where a user\n   proves its identity to a server.  This protocol is vulnerable\n   to man-in-the-middle attacks.  *)\n\n(*\n  Variables:\n    - A: user's secret key\n    - B: server's secret key\n    - N: nonce\n    - M: message\n*)\n\nmodule Main = struct\n  type key = string;\n  type nonce = string;\n  type message = string;\n\n  (*  Protocol specification *)\n  let init_user (A:key) : unit =\n    let N = string_of_int (Random.int 1000000) in\n    let M = A ^ N in\n    (* Send M to the server *)\n    ()\n  \n  let init_server (B:key) : unit =\n    (* Wait for a message M from the user *)\n    let rec wait_for_message () =\n      try\n        let M = read_line () in\n        let A = String.sub M 0 (String.length A) in\n        let N = String.sub M (String.length A) (String.length M - String.length A) in\n        if (String.length M > String.length A) then\n          let _ = print_endline (\"Received: \" ^ M) in\n          let N_response = string_of_int (Random.int 1000000) in\n          let M_response = B ^ N_response in\n          let _ = print_endline (\"Sending: \" ^ M_response) in\n          ()\n        else\n          let _ = print_endline (\"Invalid message format\") in\n          wait_for_message ()\n      with End_of_file ->\n        print_endline \"Connection closed\"\n    in\n    wait_for_message ()\n\n\n  let main () =\n    let A = \"user_secret\" in\n    let B = \"server_secret\" in\n    let _ = init_user A in\n    let _ = init_server B in\n    ()\n  \nend\n\nlet () = Main.main ()\n\n```"]], "CV-1/fdh-JSC.ocv": [[true, "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n *****************************************************\n\n(* Example of a simple key exchange protocol *)\n\n(* Alice sends a message to Bob, encrypted with Bob's public key *)\n(* Bob sends a message to Alice, encrypted with Alice's public key *)\n\n(* This example is incomplete and needs to be completed to be verified *)\n\n(* Define the messages *)\ntype msg =\n  | A of { a : int; }\n  | B of { b : int; }\n  | C of { c : int; }\n  | Enc of { key : int; msg : msg; }\n\n(* Define the keys *)\ntype key = int\n\n\n(* Define the participants *)\ntype role =\n  | Alice\n  | Bob\n\n\n(* Define the environment *)\nlet init_env =\n  {\n    alice_sk = 1;\n    alice_pk = 2;\n    bob_sk = 3;\n    bob_pk = 4;\n  }\n\n\n(* Define the protocol *)\nlet protocol =\n  (\n    (Alice, A { a = 1 }),\n    (Bob, Enc { key = bob_pk; msg = A { a = 1 } })\n  )\n\n\n(* Define the security properties *)\nlet security_properties =\n  [\n    (* Confidentiality *)\n    (* Example:  Bob cannot learn Alice's secret *)\n    (* This needs to be completed *)\n\n    \n    (* Authentication *)\n    (* Example:  Bob can be sure that the message comes from Alice *)\n    (* This needs to be completed *)\n  ]\n\n\n(* Define the assumptions *)\nlet assumptions = [\n  (* Example assumption:  Bob's public key is correct *)\n  (* This needs to be completed *)\n]\n\n\n(* Define the cryptographic primitives *)\nlet encrypt (key : key) (msg : msg) : msg =\n  Enc { key = key; msg = msg }\n\n\nlet decrypt (key : key) (msg : Enc { key : key; msg : msg }) : msg =\n  match msg with\n  | Enc { key = k; msg = m } ->\n    if key = k then m else failwith \"Decryption failed\"\n\n\n(* Define the functions for checking the security properties *)\nlet check_confidentiality (env : env) (trace : trace) : bool =\n  true\n\n\nlet check_authentication (env : env) (trace : trace) : bool =\n  true\n\n\n(* Main function to run the verification *)\nlet run_verification () =\n  let result =\n    CryptoVerif.verify protocol security_properties assumptions\n  in\n  result\n\n\n(* Run the verification *)\nlet _ = run_verification ()"]], "CV-1/fdh.cv": [[false, "```\ncv\n(* Example protocol:  simplified Diffie-Hellman key exchange *)\n\n(*  This protocol is vulnerable to a man-in-the-middle attack. *)\n\n(*  The attacker can impersonate both Alice and Bob. *)\n\n(*  We prove that the protocol is secure against an attacker *)\n(*  who can only intercept and replay messages. *)\n\n\n(*  This protocol is vulnerable if we only consider the\n    messages exchanged between the parties.  *)\n\n\n(*  We must consider the state of the attacker. *)\n\n\n(*  Protocol parameters *)\n(*  p: a prime number *)\n(*  g: a generator of Z_p* *)\n\nmodule Main = struct\n\n  (*  Protocol variables *)\n  type msg =\n    | A of int\n    | B of int\n    | AB of int\n    | BA of int\n    \n\n  (*  Protocol specification *)\n  let protocol =\n    let p = 101 in (* Example prime *)\n    let g = 2 in   (* Example generator *)\n    \n    let init_alice = (A(g ** 0 mod p))  in\n    let init_bob = (B(g ** 0 mod p)) in\n    let receive_alice = function\n      | B(y) -> AB(g ** (y) mod p)\n      | _ -> failwith \"Invalid message\"\n    and receive_bob = function\n      | A(x) -> BA(g ** (x) mod p)\n      | _ -> failwith \"Invalid message\"\n    in\n\n\n    (*  Security goal *)\n    let security_goal =\n      let rec check_shared_key (a, b) =\n        match a, b with\n        | AB(x), BA(y) -> x = y\n        | _, _ -> false\n      in\n      check_shared_key\n    in\n\n    (*  Protocol rules *)\n    let rules =\n      [\n        (* Alice sends A(x) to Bob *)\n        (init_alice, [B(g ** 1 mod p)]) ;\n        (* Bob sends B(y) to Alice *)\n        (init_bob, [A(g ** 1 mod p)]) ;\n        (* Alice receives B(y) and sends AB(g^x mod p) *)\n        (B(g ** 1 mod p), [AB(g ** 1 mod p)]) ;\n        (* Bob receives A(x) and sends BA(g^y mod p) *)\n        (A(g ** 1 mod p), [BA(g ** 1 mod p)]) ;\n      ]\n    in\n    \n    (rules, security_goal)\n  \n  let () =\n    let (rules, security_goal) = protocol in\n    let _ =\n      print_endline \"Starting protocol verification...\" ;\n    let result = CryptoVerif.verify_protocol rules security_goal in\n    if result then\n      print_endline \"Protocol is secure.\"\n    else\n      print_endline \"Protocol is not secure.\"\n\nend\n\n```"]], "CV-1/for_bruno2.ocv": [[true, "param N, N'.\nparam N1.\nparam P.\n\n\ntype block [fixed, 8].\n\n(* define xor to exist over blocks *)\nexpand Xor(block, xor, zeroblock).\n\n(*\nequiv obvious\n      foreach i <= N do r <-R block; O() := return(r = zeroblock) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O() := return(false).\n\nequiv obvious2\n      foreach i <= N do r <-R block; O(x:block) := return(r = x) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O(x:block) := return(false).\n*)\n\nequiv jons_remove_xor\n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:block, b2:block) := return(xor(b1, r) = b2) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:block, b2:block) := return(false)."]], "CV-1/GDH_RSR.cv": [[false, "```\n*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************/\n\n(* Example of a simple protocol *)\n\n(* This example shows how to use the CryptoVerif language to\n   define a simple protocol and how to perform a security analysis\n   using CryptoVerif.\n*)\n\n(* Protocol description *)\n\n(* Alice sends a message to Bob, which is encrypted using a symmetric key.\n   Bob sends an acknowledgement back to Alice.\n*)\n\nmodule Protocol = struct\n\n  type message = string\n\n  (* We define the encryption function *)\n  let encrypt (key: string) (plaintext: message) : message =\n    (* Replace this with a real encryption function *)\n    plaintext ^ key\n\n  let decrypt (key: string) (ciphertext: message) : message =\n    (* Replace this with a real decryption function *)\n    if String.length ciphertext < String.length key then \"\"\n    else String.sub ciphertext 0 (String.length ciphertext - String.length key)\n\n  (* Protocol specification *)\n  let protocol () =\n    let alice_key = \"secret_key\" in\n    let bob_key = \"secret_key\" in\n    let msg = \"hello\" in\n\n    (* Alice sends the encrypted message to Bob *)\n    let ciphertext = encrypt alice_key msg in\n    (* Bob receives the ciphertext *)\n    let received_ciphertext = ciphertext in\n    (* Bob decrypts the ciphertext *)\n    let decrypted_msg = decrypt bob_key received_ciphertext in\n\n    (* Bob sends an acknowledgement to Alice *)\n    let acknowledgement = \"ack\" in\n\n    (* Alice receives the acknowledgement *)\n    let received_ack = acknowledgement in\n    \n    (* Return the result *)\n    (decrypted_msg, received_ack)\nend\n\n\n(* Security properties *)\n\n(* We define a security property that states that the message sent by Alice\n   is correctly decrypted by Bob.\n*)\n\nlet security_property () =\n  let (decrypted_msg, received_ack) = Protocol.protocol () in\n  let expected_msg = \"hello\" in\n  decrypted_msg = expected_msg\n```"]], "CV-1/HKDFexpand.ocv": [[false, "```\nocv\n(* Example protocol: a simple key exchange protocol *)\n\n(* Definitions *)\n\nmodule Main = struct\n\n  type msg =\n    | Init of string\n    | Response of string\n    | Ack of string\n\n  (* Initial state *)\n  let init_state =\n    {\n      alice_key = \"alice_secret\";\n      bob_key = \"bob_secret\";\n      alice_knows_bob_key = false;\n      bob_knows_alice_key = false;\n    }\n\n  (* Alice's actions *)\n  let alice_actions =\n    [\n      (* Send an initialization message *)\n      {\n        msg = Init \"alice\";\n        next_state = fun s ->\n          { s with\n            alice_knows_bob_key = true;\n            bob_knows_alice_key = false; (* Alice doesn't know if Bob knows her key yet *)\n          }\n      };\n    ]\n\n\n  (* Bob's actions *)\n  let bob_actions =\n    [\n      (* Receive an initialization message *)\n      {\n        msg = Init \"bob\";\n        next_state = fun s ->\n          { s with\n            alice_knows_bob_key = false; (* Bob doesn't know if Alice knows his key yet *)\n            bob_knows_alice_key = true;\n          }\n      };\n      (* Reply to the initialization message *)\n      {\n        msg = Response \"bob\";\n        next_state = fun s ->\n          { s with\n            alice_knows_bob_key = true;\n            bob_knows_alice_key = true;\n          }\n      };\n\n    ]\n\n  (* Security goal *)\n  let goal_alice_knows_bob_key = fun s ->\n    s.alice_knows_bob_key\n\n  let goal_bob_knows_alice_key = fun s ->\n    s.bob_knows_alice_key\n\n  (* Protocol *)\n  let protocol =\n    {\n      init_state = init_state;\n      alice_actions = alice_actions;\n      bob_actions = bob_actions;\n      security_goals = [goal_alice_knows_bob_key; goal_bob_knows_alice_key];\n    }\nend\n\n(* Verification *)\n\nlet () =\n  let res = CryptoVerif.verify Main.protocol in\n  match res with\n  | `Success -> print_endline \"Protocol is secure\"\n  | `Fail msg -> print_endline (\"Protocol is not secure: \" ^ msg)\n```"]], "CV-1/ind_cca2.cv": [[false, "```\n*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n ****************************************\n\n(* Example:  A simple protocol *)\n\nmodule SimpleProtocol.\n\n(* Definitions *)\n\ntype msg = int.\n\n(* Protocol *)\n\nlet protocol (sk_A : int) (sk_B : int) (sk_C : int) : msg =\n  let m1 = sk_A mod 100 in\n  let m2 = sk_B mod 100 in\n  let m3 = sk_C mod 100 in\n  m1 + m2 + m3.\n\n(* Security goal *)\n\nlet security_goal () : Prop =\n  forall (sk_A : int) (sk_B : int) (sk_C : int),\n    protocol sk_A sk_B sk_C = protocol sk_A sk_B sk_C.\n\n(* This is a trivial example, and the security goal is trivially true *)\n\n(* end of protocol *)\n\nend.\n```"]], "CV-1/ind_cpa.cv": [[false, "```\n*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n ****************************************\n(* File: example.cv *)\n\n(* Description: This is a simple example of a protocol\n   in CryptoVerif.  It models a simple key exchange protocol.\n*)\n\n\n(* Definitions *)\n\n(*  We define a type for the messages, representing\n    the different messages exchanged between the parties. *)\ntype msg =\n  | A of int\n  | B of int\n  | C of int\n  | D of int\n\n(*  We define the type for the participants. *)\ntype party = Alice | Bob\n\n(*  We define the set of possible actions that the\n    parties can perform. *)\ntype action =\n    Send of party * msg * party\n  | Receive of party * msg * party\n\n\n(* Protocol specification *)\n\n(*  We define the protocol's rules. *)\n\n(*  Here is a simple example of a protocol's rule. *)\nlet protocol =\n  ((Send (Alice, A 1, Bob)),\n   (Receive (Bob, A 1, Alice)),\n   (Send (Bob, B 2, Alice)),\n   (Receive (Alice, B 2, Bob)))\n\n(*  We define the environment, which is a function that\n    describes the possible actions that can be performed by\n    the parties. *)\n\n\nlet env =\n  fun (state) ->\n    match state with\n     [] -> []\n    | (h :: t) ->\n      (match h with\n       (Send (Alice, A x, Bob)) -> [Send (Alice, A x, Bob)]\n       | (Send (Bob, B y, Alice)) -> [Send (Bob, B y, Alice)]\n       | (Receive (Bob, A x, Alice)) -> [Receive (Bob, A x, Alice)]\n       | (Receive (Alice, B y, Bob)) -> [Receive (Alice, B y, Bob)]\n       | _ -> [])\n\n\n(* Formal analysis *)\n\n(*  This is where we specify the properties that we want to\n    prove about the protocol.  For example, we might want\n    to prove that the protocol is secure against certain\n    attacks. *)\nlet properties =\n  []\n\n\n\n(*  Here, we use the CryptoVerif verifier to check the\n    properties we've defined.  CryptoVerif will produce a\n    result indicating whether or not the properties hold. *)\n\n(* The following code is crucial for generating the\n   EasyCrypt file. *)\n\nlet gen_easycrypt_code =\n    print_endline \"Generating EasyCrypt code...\"\n\n(*  The following lines are placeholders for the\n    actual EasyCrypt code.  The actual code will be\n    generated by CryptoVerif. *)\n```"]], "CV-1/Avik-elgamal.cv": [[true, "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam p, q.\n\ntype Z [fixed].\n\ntype G [fixed].\n\nproba 1.\n\nfun exp(a:G,x:Z): G.\nconst gamma:G.\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new x:Z; exp(gamma,x) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(x:Z,y:Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, x*y).\n\nfun dot(a:G,b:G): G.\n\n(* dot(.,y) is the group operation *)\n\nequation assoc(dot).\nequation unit(dot).\nequation commut(dot).\n\nforall a:G, b:G, c:G;\n  dot(a, dot(b,c)) = dot(dot(a,b),c).\nforall a:G;\n  dot(a, unit(dot)) = a.\nforall a:G, b:G;\n  dot(a,b) = dot(b,a).\n\n(* example *)\n\n(*\nforall x:Z, y:Z;\n  mult(x,y) = y*x.\n*)"]], "CV-1/intctxt-corrupt-comput.ocv": [[true, "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n *****************************************************\n\n(* Example protocol: a simple authentication protocol *)\n\n(*\n * This protocol is a simple authentication protocol.\n * Alice sends a message to Bob, signed by Alice.\n * Bob sends a message back to Alice, signed by Bob.\n *\n *  Alice -> Bob : {m}s_A\n *  Bob -> Alice : {m'}s_B\n\n*)\n\n\n(* Define the participants *)\nlet alice = \"alice\";\nlet bob = \"bob\";\n\n(* Define the messages *)\nlet m = \"message\";\nlet m' = \"message'\";\n\n(* Define the keys *)\nlet s_A = \"secret_key_A\";\nlet s_B = \"secret_key_B\";\n\n(* Define the roles *)\nlet role_alice = \"alice\";\nlet role_bob = \"bob\";\n\n\n(* Define the protocol *)\nlet protocol =\n  [\n    (* Alice sends a message to Bob, signed by Alice *)\n    (\n      alice,\n      bob,\n      [\n        {\n           m = m;\n           s_A = s_A;\n        };\n      ],\n      [\n          {\n          role=role_alice;\n          m=m;\n          s_A=s_A;\n          };\n      ]\n    );\n\n    (* Bob sends a message back to Alice, signed by Bob *)\n    (\n      bob,\n      alice,\n      [\n        {\n           m' = m';\n           s_B = s_B;\n        };\n      ],\n      [\n          {\n          role=role_bob;\n          m'=m';\n          s_B=s_B;\n          };\n      ]\n    )\n  ];\n\n\n\n\n(* Define the security properties *)\nlet properties =\n  [\n    (* Authenticity *)\n    (*  The message received by Bob is from Alice. *)\n    {\n      attacker = bob;\n      property = \"The message received by Bob is from Alice.\";\n      pre = [\n        {\n            role=role_alice;\n            m=m;\n            s_A=s_A;\n        }\n      ];\n      post = [\n        {\n            role=role_bob;\n            m=m;\n            s_A=s_A;\n        }\n      ];\n    };\n\n    (*  The message received by Alice is from Bob. *)\n    {\n      attacker = alice;\n      property = \"The message received by Alice is from Bob.\";\n      pre = [\n        {\n            role=role_bob;\n            m'=m';\n            s_B=s_B;\n        }\n      ];\n      post = [\n        {\n            role=role_alice;\n            m'=m';\n            s_B=s_B;\n        }\n      ];\n    };\n\n  ];\n\n\n(* Define the assumptions *)\nlet assumptions = [];\n\n(* Main function *)\nlet main () =\n  let result = CryptoVerif.verify protocol properties assumptions in\n  print_endline (string_of_bool result);\n;;\n\n\nlet () = main ();;"]], "CV-1/invites.cv": [[true, "(*----------------------------------*)\n(*Types\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\ntype hmac_key [large, fixed].\ntype hash_key [nonuniform, fixed].\ntype sym_key [large, fixed].\ntype nonce [bounded].\ntype Z [large, bounded].\ntype OP_5 [large, bounded].\ntype subG [large, bounded].\ntype D [bounded].\ntype prfout [bounded].\ntype message [bounded].\ntype key [large, fixed].\ntype skey [bounded].\ntype pkey [bounded].\n\n(*----------------------------------*)\n(*Constants\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nparam N1, N2.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8"]], "CV-1/kerberos-conclude-simplified.cv": [[false, "```\n(*\n  CryptoVerif tries to apply the rewrite rule test(b,x,x) -> x to\n  test(b,Z(m1),Z(m2)). Trying to match the term test(b,Z(m1),Z(m2))\n  with the pattern test(b,x,x) in Facts.match_term calls\n  \"Terms.simp_equal_terms try_no_var Z(m1) Z(m2)\" where\n  try_no_var = Facts.try_no_var (Z(m1) -> Z(m2)).\n  However, Terms.simp_equal_terms and Facts.try_no_var \n  apply substitutions only to variables, so not to Z(m1).\n  Hence the matching fails and the simplification is not\n  detected.\n*)\n\n\nparam m1, m2.\ntype bit.\nfun Z(m1):maxenc.\n\nchannel c1, c2, c3, start.\n\n\nquery secret1 m1.\n\n\n(* Key U\n\n```"]], "CV-1/Kyber.ocv": [[true, "proof {\nsimplify coll_elim(variables:z_1);\ninsert before \"if secb\" \"if pk_6 = pk' then\";\ninsert before_nth 1 \"if secb\" \"if ct_3 = c_1 then\";\n\nall_simplify;\nall_simplify;\nsuccess\n}\n\n\n(* Types for abstract CPA KEM *)\n\n \ntype cpa_pk [bounded].\ntype cpa_sk [bounded].\ntype cpa_ct [bounded].\ntype cpa_k [bounded].\ntype cpa_key_seed [large,fixed].\ntype cpa_enc_seed [large,fixed].\n\n\n\n\n(* Types for final CCA  KEM *)\n\ntype kemskey [bounded].\n\ntype cpa_ct_list [bounded].\ntype kem_seed [large,fixed].\ntype kem_enc_seed [large,fixed].\n\n\ntype kemsec [large,fixed].\n\ntype kem_keypair.\nfun KEM_KeyPair(cpa_pk, kemskey) : kem_keypair [data].\n\n\n\n(* Hash functions *)\n\ntype hashes [bounded]."]], "CV-1/lemmaMAC_collision_resistant_Nkeys.ocv": [[true, "(* The files lemmaMAC_collision_resistant.ocv and lemmaMAC_collision_resistant2.ocv \n   show that, assuming HMAC-SHA256, KDF256, and KDF128 are\n   independent pseudo-random functions (using the same key), HMAC-SHA256\n   is collision-resistant. (The MAC key remains secret, but the adversary\n   is allowed to make MAC queries.)\n\nMore precisely, we prove equivalence:\n\n\t!N new k: mac_key;\n\t(! qMAC O_mac(m: bitstring) := MAC2(k, m),\n\t ! qColl O_coll(m1: bitstring, m2: bitstring) [useful_change] := (MAC2(k, m1) = MAC2(k, m2)))\n<=(N * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| +\n        2 * PPRF(time + (N-1) * (qMAC * qColl)) * (qColl + qMAC)))\n\n*)\n\n(* Define the MAC function *)\nfunction MAC2(k: bitstring, m: bitstring): bitstring {\n  (* Replace with the actual HMAC-SHA256 implementation *)\n  (* This is a placeholder; you need to define the correct HMAC-SHA256 function *)\n  (*  Example (replace with the actual implementation): *)\n  let hmac_sha256 = HMAC_SHA256(k, m);\n  return hmac_sha256;\n}\n\n(* Define the size of the output of SHA256 *)\nconst |t_SHA256_out| = 256;\n\n(* Define the probability of collision for a pseudo-random function *)\nfunction PPRF(time: nat): real {\n  (* Assume a value for the probability of collision.  In practice, this would be \n     derived from the security analysis of the underlying hash function. *)\n\treturn 2^-128; \n}\n\n\n(* Example usage (you'll need to adapt this to your actual protocol) *)\nlet N = 10; (* Number of queries *)\nlet qMAC = 100; (* Number of MAC queries *)\nlet qColl = 100; (* Number of collision queries *)\nlet time = 100; (* Time taken for MAC queries *)\n\n(* Calculate the right hand side of the inequality *)\nlet rhs = N * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| + 2 * PPRF(time + (N-1) * (qMAC * qColl)) * (qColl + qMAC));\n\n\n(* You'll need to add more code to define the protocol's security properties\n   and prove the desired equivalence.  This is a *very* simplified example.\n   The real proof would need to be much more complex *)\n\n(*  Print the result (for testing) *)\nprint(\"RHS: \", rhs);"]], "CV-1/lemmaMAC_KDF_are_indep_PRFs_from_compression_ROM.ocv": [[true, "(* This file shows that HMAC-SHA256, KDF256, and KDF128 are independent\npseudo-random functions even when they use the same key, assuming that\nthe compression function of SHA256 is a random oracle.\n\nKDF256(k, (X,U,V)) = KDF(k; 256; SharedInfoMAC(X,U,V))\nKDF128(k, (X,U,V)) = KDF(k; 128; SharedInfoENC(X,U,V))\n\nWe rely on the result shown in \nlemmaMAC_KDF_are_indep_PRFs_from_compression_PRF.ocv\nA random oracle is a fortiori a PRF. So we just have to show the\nfollowing joint assumption:\n\nproba P_SHA256_joint.\n\nequiv SHA256_joint\n       foreach i3 <= N2 do k <-R mac_key;\n       \t       (O1() := return(SHA256_comp(SHA256_init, xor(padkey(k), opad))) |\n\t        O2(i3) := return(SHA256_comp(SHA256_init, xor(padkey(k), ipad))))\n       \t       O1(i3) = O2(i3)\n       \t       foreach i1, i2 <= N1 do\n\t       \t(X,U,V) <-R {X,U,V};\n       \t       \tKDF256(k, (X,U,V)) = KDF(k; 256; SharedInfoMAC(X,U,V))\n               \tKDF128(k, (X,U,V)) = KDF(k; 128; SharedInfoENC(X,U,V))\n       \t       )\n       \t       )\n       \t       )\n\n(* We assume that the compression function of SHA256 is a random oracle *)\n(* We assume that mac_key is uniformly random *)\n(* We assume that N1 and N2 are positive integers *)\n(* We assume that SharedInfoMAC and SharedInfoENC are fixed values *)\n\n(* We have to show the independence of KDF256 and KDF128, so we have to\n   show that O1(i3) is independent from (X,U,V) *)\n\n(* We have to show that O1(i3) and O2(i3) are independent *)\n(* We have to show that O1(i3) and (X,U,V) are independent *)\n\n\n(* Note that this is just a sketch; the actual implementation would require\n   more details about the definition of SHA256, KDF256, KDF128, and the\n   relevant assumptions. *)\n\n(* Example of how to use the random oracle property *)\nlet random_oracle (x:bitstring) : bitstring =\n  (* Replace this with the actual random oracle implementation *)\n  return(x) (* Example, just return the input *)\n\n\n(* Example of how to use SHA256 *)\nlet SHA256_comp (state:bitstring) (message:bitstring) : bitstring =\n  (* Replace this with the actual SHA256 compression function *)\n  (* This is a placeholder, should be replaced by the actual SHA256\n     implementation *)\n  random_oracle(message)\n\nlet SHA256_init : bitstring =\n  (* Initialization vector *)\n  return(\"initial vector\")\n\n(* Example of how to use KDF *)\nlet KDF (k:bitstring; len:int; input:bitstring) : bitstring =\n  (* Replace this with the actual KDF implementation *)\n  return(input)\n\n\n(* Example of how to use the padkey function *)\nlet padkey (k:bitstring) : bitstring =\n  (* Replace this with the actual padkey implementation *)\n  return(k)\n\n\n(* Example of how to use the opad and ipad *)\nlet opad : bitstring = return(\"opad\")\nlet ipad : bitstring = return(\"ipad\")\n\n\n(* Example of how to use SharedInfoMAC *)\nlet SharedInfoMAC (X:bitstring) (U:bitstring) (V:bitstring) : bitstring =\n  (* Replace this with the actual SharedInfoMAC implementation *)\n  return(append(X, U, V))\n\n\n(* Example of how to use SharedInfoENC *)\nlet SharedInfoENC (X:bitstring) (U:bitstring) (V:bitstring) : bitstring =\n  (* Replace this with the actual SharedInfoENC implementation *)\n  return(append(X, U, V))\n\n(* Example of how to use {X, U, V} *)\nlet {X, U, V} =\n  (* Replace this with the actual {X, U, V} implementation *)\n  return(\"xuv\")\n\n\n(* Example of how to use the random key generator *)\nlet mac_key : bitstring =\n  (* Replace this with the actual random key generator *)\n  return(\"random key\")\n\nlet N1 : int = 1\nlet N2 : int = 1"]], "CV-1/live-demo-3.ocv": [[true, "(* This file uses the builtin ind-cpa assumption to prove a variant of the ind-cpa assumption. *)\n(* CryptoVerif should succeed. *)\n\ntype key [fixed].  \n\ntype enc_seed [bounded].\n\nproba PROBA_0.\n\nexpand IND_CPA_sym_enc_all_args(key,\nbitstring,\nbitstring,\nenc_seed,\nenc,\nenc_r,\nenc_r',\ndec,\ninjbot,\nZ,\nPenc).\n\nquery secret QUERY_0.\n\nlet QencLR(b0: bool, k: key, r: enc_seed) = \n\tOenc (m1: bitstring, m2: bitstring) :=\n\tif Z(m1) = Z(m2) then (* m1 and m2 have the same length *)\n\tif b0 then \n\t\treturn(enc_r(m1,k,r))\n\telse\n\t\treturn(enc_r(m2,k,r)).\n\nprocess Ostart () :=\n        b <-R bool;\n\tk <-R key;\n\tr <-R enc_seed;\n\treturn ()."]], "CV-1/mergeif.cv": [[false, "```\nt2:timest, z2:client;  \t\t  concat8(t,y,x,z) <> pad(z2,t2).\nforall t:key, y:nonce, x:timest, z:server, t2:timest;  \t\t\t\t  concat8(t,y,x,z) <> padts(t2).\nforall t: timest, z: client, t2: timest;   \t\t\t\t\t  pad(z,t)<> padts(t2).\n\nforall k1:protkey, y:macs, z2:client, y2:pkey, x2:spkey; \t\t  \t  concat3(k1,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2: nonce, t2:timest; \t\t\t  \t  concat3(k1,y) <> padno(t2,z2).\nforall t:timest, y:nonce, z2:client, y2:pkey, x2:spkey;\t\t\t\t  padno(t,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2:kas, y2:pkey, x2:spkey;\t\t  \t\t  concat3(k1,y) <> concat7(z2,y2,x2).\nforall t:timest, y:nonce, z2:kas, y2:pkey, x2:spkey; \t     \t\t\t  padno(t,y) <> concat7(z2,y2,x2).\n\n```"]], "CV-1/Misha-injectivity_and_equality.cv": [[true, "proof {\n      show_game occ;\n      replace 18 OP_9;\n      auto\n}\n\nchannel CHANNEL_0.\n\ntype OP_8 [fixed].\n\nfun f(nonce): bitstring [compos].\nforall nonce, nonce': nonce;\n  (f(x) = f(nonce')) = (x = nonce').\n\nfun g(nonce): nonce.\n\nevent start(nonce).\nevent finish(nonce).\n\nquery x: nonce;\n  event finish(x) ==> start(x).\n\nprocess\n  in(OP_3, ());\n  new x: nonce;\n\n  event start(x);\n  \n  out(c, x);\n  in(OP_0, x':nonce);\n  \n  if f(x) = f(g(x')) then\n  \n  event finish(g(x'));\n  yield\n\n(*\n     in(c, ());\n     new x: nonce;\n     event start(x);"]], "CV-1/Misha-pk-shared-no-cast.cv": [[false, "```\nchannel c_in, c_out.\ntype mstring.\n\nparam N.\n\ntype nonce [fixed, large].\n\n(************************\n  Public-key encryption\n*************************)\n\n(* IND-CCA2 probabilistic public-key encryption \n   keyseed: type of key seeds, must be \"fixed\" (to be able to generate random numbers from it), typically large.\n   pkey: type of public keys, must be \"bounded\"\n   skey: type of secret keys, must be \"bounded\"\n   cleartext: type of cleartexts, must be \"bounded\" or \"fixed\" (the encryptions of *all* cleartexts of any length\n              are assumed to be indistinguishable from each other).\n   ciphertext: type of ciphertexts\n   seed:\n*)\n\ntype keyseed [fixed, large].\ntype pkey [bounded].\ntype skey [bounded].\ntype cleartext [bounded].\ntype ciphertext.\n\n(* Encryption function *)\nfunction encrypt(pk : pkey, m : cleartext) : ciphertext.\n(* Decryption function *)\nfunction decrypt(sk : skey, c : ciphertext) : cleartext.\n\n(* Correctness properties *)\naxiom forall pk : pkey, sk : skey, m : cleartext.\n  decrypt(sk, encrypt(pk, m)) = m.\n\n(* Nonce generation *)\nfunction generate_nonce() : nonce.\n\n(* Nonce usage in encryption *)\nfunction encrypt_nonce(pk : pkey, m : cleartext, nonce : nonce) : ciphertext.\n\n\n(* Correctness properties *)\naxiom forall pk : pkey, sk : skey, m : cleartext, nonce : nonce.\n  decrypt(sk, encrypt_nonce(pk, m, nonce)) = m.\n\n\n(* Security properties *)\n\n(* The next two axioms are crucial to define the IND-CCA2 security notion.\n   They express that the encryption function is indistinguishable from random\n   and that the decryption oracle does not leak information *)\n\n\n(* ... (Add security axioms here) ... *)\n\n```"]], "CV-1/Avik-hash-elgamal-CDH.cv": [[true, "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q, nH, nG, nCDH'.\n\ntype Z [fixed].\ntype G.\ntype K [large,fixed].\ntype D [bit].\n\nproba hash.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun xor(D,D): D.\n\n(* xor self-cancels *)\n\nforall x:D, y:D;\n  xor(x, xor(x,y)) = y.\n\n(* xor(.,y) is a one-time pad *)"]], "CV-1/Misha-RPC-enc-fixed.cv": [[false, "```\nparam (bitstring).\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\ntype payload [fixed].\nfun payload2bs(payload) : bitstring [compos].\n\n(* IND-CPA INT-CTXT encryption *)\n\ntype keyseed [bitstring, large].\ntype key [bounded].\ntype seed [fixed, large].\n\nproba 1.\nproba 1.\nproba 1.\n\nexpand IND_CPA_INT_CTXT_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc, Pencctxt). \n\nfun key2bs(key): bitstring [compos].\nfun bs2key(bitstring): key.\nforall k: key;\n  bs2key(key2bs(k)) = k.\n\n(* Concatenation and parsing *)\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): (bitstring, bitstring) [compos].\n```"]], "CV-1/OAEP-CPA.cv": [[true, "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);\n      crypto rom(hash);\n      show_game occ;\n      insert_event bad1 31;\n      show_game occ;\n      insert_event bad2 59;\n      crypto remove_xor(xorDr) \"@10_r_129\";\n      crypto remove_xor(xorDow) \"@9_r_137\";      \n      remove_assign binder pk;\n      crypto pd_ow(f) \"r_107\" \"@9_r_146\" \"@10_r_144\";\n      success\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype msg [fixed,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba 1.\n\nexpand set_PD_OW_trapdoor"]], "CV-1/obizarre.ocv": [[true, "param N:nat.\n\ntype key [fixed, large].\n\nquery secret1 k:key.\nquery secret s:key.\n\nprocess\n        Oa () :=\n           k <-R key;\n           return ();\n        foreach i <= N do \n           Ob (s:key) :=\n              if k=s then return(s) else return(s)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15248K\nEND *)"]], "CV-1/otestPRF.ocv": [[true, "(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, p, q, qE, qD.\n\ntype seed [large,fixed].\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba pUF.\nproba pIND.\n\n(* f(S) is a pseudo-random function family *) \n\nexpand PRF(seed, S, N, L, kgen, f, pPRF).\n\n(* h(K) is a message authentication code (an unpredictable function family *)\nexpand MAC(K, N, L, h, pUF).\n\n(* The encryption scheme *)\n\nproc encrypt(S, K, M) returns (C, T):\n  N := random(n).\n  L := f(S, N).\n  T := h(K, N, M).\n  C := (N, L, T).\n  return (C, T).\n\nproc decrypt(S, K, C) returns (M, ok):\n  (N, L, T) := C.\n  L' := f(S, N).\n  if L = L' then\n    M := h(K, N, L)\n    ok := true\n  else\n    M := none.\n    ok := false\n  return (M, ok).\n\n(* Game *)\ngame  game_enc(S, K, M) returns (C, T, ok):\n  (C, T) := encrypt(S, K, M).\n  ok := true.\n  return (C, T, ok).\n\ngame  game_dec(S, K, C) returns (M, ok):\n  (M, ok) := decrypt(S, K, C).\n  return (M, ok).\n\n(* Security properties *)\nassert  IND_CPA(game_enc, game_dec, pIND)."]], "CV-1/pfdh.cv": [[false, "```\nmodule ExampleProtocol;\n\n(* Description of the protocol *)\n(* Example protocol with a single shared secret *)\n(*\n  Alice and Bob want to establish a shared secret.\n  Alice sends a nonce to Bob.\n  Bob responds with a nonce and a hash of both nonces.\n  Alice verifies the hash and responds with a hash of both nonces.\n*)\n\n(* Define the types *)\ntype nonce = int;\ntype secret = int;\ntype hash = int;\n\n(* Define the functions *)\nfunction hash(x: nonce, y: nonce): hash;\nfunction verify_hash(h: hash, x: nonce, y: nonce): bool;\n\n(* Define the protocol *)\nprotocol example_protocol(alice: nonce, bob: nonce, shared_secret: secret)\nrequires alice <> bob;\nensures shared_secret = alice + bob;\n\n\n(* Alice's actions *)\n{\n  alice -> bob : alice;\n  bob -> alice : bob, hash(alice, bob);\n  alice -> bob : hash(alice, bob);\n}\n\n(* Bob's actions *)\n{\n  bob <- alice : alice;\n  bob -> alice : bob, hash(alice, bob);\n  bob <- alice : hash(alice, bob);\n\n}\n\n(* Specification *)\n(*\n  The protocol is correct if the shared secret is the sum of the nonces.\n*)\ncorrectness:\n  (verify_hash(hash(alice, bob), alice, bob)) ->\n     (shared_secret = alice + bob);\n\n(* Implementations *)\n\n(* Hash function (placeholder) *)\nfunction hash(x: nonce, y: nonce): hash {\n  x + y\n}\n\n(* Verification function (placeholder) *)\nfunction verify_hash(h: hash, x: nonce, y: nonce): bool {\n  h == x + y\n}\n\nend ExampleProtocol;\n```"]], "CV-1/randomgen.ocv": [[true, "type nbits [fixed].     (* All bitstrings of length n *)\ntype np1bits [fixed].   (* All bitstrings of length n+1 *)\ntype np2bits [fixed].   (* All bitstrings of length n+2 *)\n\nparam n:nat.\n\n(* Concatenation of n+1 bits and a bit to a bitstring of n+2 bits. *)\nfun concatnp1(r:np1bits,b:bool):np2bits.\n  return (r,b).\n\n(* The concatenation of random numbers is a random number *)\nequiv \n      foreach i1<=n do\n            r <-R np1bits;\n\t    b <-R bool;\n            OGet():=return (concatnp1(r,b))\n      <=(0)=> (* To define *)\n     foreach i1 <=n do\n              w <-R np2bits;\n              OGet():=return(w).\n\n(* Extract the first n bits *)\nfun getn(x:np2bits):nbits.\n  return (x.0)."]], "CV-1/Ricardo2.cv": [[true, "(* A->B: {nonce}_pkB. *)\n\n(* set interactiveMode = true. *)\n\nparam N2.\nparam N3.\nparam N4.\n\ntype nonce [large,fixed].\ntype host [byte].\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype blocksize [fixed].\ntype blocksizebot [bounded].\n\n\nfun pad(nonce):blocksize [compos].\n\n(* Public-key encryption (CCA2) *)\n\nproba 1.0.\nproba 1.0.\n\nfun enc(blocksize, pkey, nonce): bitstring.\nfun skgen(keyseed):skey.\nfun pkgen(keyseed):pkey.\nfun dec(bitstring, skey): blocksize.\n\nfun enc2(blocksize, pkey, seed): bitstring.\nfun skgen2(keyseed):skey."]], "CV-1/sahai-01-bug.cv": [[false, "```\n(*\nBUG: CryptoVerif transforms\nP(x,w,s) using oracle Oproof\nand its argument s using oracle Ostring.\n\nThis results in a variable kappa_<n> being defined in the condition of\na find and having array accesses.\n\nThe problem would be solved if the game was transformed as\n    let s' = s in\n    P(x,w,s')\ntransforming s using Ostring and P(x,w,s) using Oproof.\n\nI tried to force introducing a \"let\" before all arguments in \nthe right-hand side of equivalences in check.ml. This works\nfor this example, but introduces problems elsewhere.\n- First, a \"let\" must not be introduced for array indices given\n  as arguments of oracles (as in CDH/DDH)\n- There are still other problems.\n*)\n\n(*\nThis example shows a game with a secret s used in a proof Oproof, and\nalso used in a string oracle Ostring.  The issue is that the\ntransformation of Oproof does not properly handle the case where\nthe string is also used as an argument.\n*)\n\nmodule type GAME = sig\n  val name : string\n  val init : unit -> (int * int * string)\n  val check : (int * int * string) -> bool\nend\n\nmodule Game : GAME = struct\n  let name = \"ExampleGame\"\n\n  let init () =\n    let x = Random.int 100 in\n    let w = Random.int 100 in\n    let s = String.make 10 'a' in  (* Example string *)\n    (x, w, s)\n\n  let check (x, w, s) =\n    let len = String.length s in\n    let res =\n      let rec aux i =\n        if i = len then true\n        else\n          let c = Char.code s.[i] in\n          c mod 10 = x && aux (i + 1)\n      in\n      aux 0\n    in\n    res\nend\n\n(* Define oracles *)\nlet Oproof (x, w, s) =\n  let len = String.length s in\n  let res =\n    let rec aux i =\n      if i = len then true\n      else\n        let c = Char.code s.[i] in\n        c mod 10 = x && aux (i + 1)\n    in\n    aux 0\n  in\n  res\n\nlet Ostring s = String.length s > 5\n\n\nlet check_game () =\n  let (x, w, s) = Game.init () in\n  let res = Oproof (x, w, s) in\n  res && Ostring s\n  \nlet () =\n  let res = check_game () in\n  Printf.printf \"Result: %b\\n\" res\n```"]], "CV-1/secret_in_event.cv": [[false, "```\n(* FDH signature scheme *)\n\nparam N : int.\n\ntype bitstring [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba p : int.\n\nexpand OW_trapdoor_perm(bitstring, pkey, skey, D, bitstring, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH : int.\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent bad(skey).\nquery x:skey; if bad(x) then false.\n\nchannel c0, c1, c2, c3,\n```"]], "CV-1/template-signedDH.ocv": [[true, "(* protocol description *)\n\n(* Agent A *)\nproc A(id:host, seed:keyseed) returns (pkey:pkey, skey:skey) {\n    pkey, skey := generate_keypair(seed);\n    return (pkey, skey);\n}\n\n(* Agent B *)\nproc B(id:host, seed:keyseed) returns (pkey:pkey, skey:skey) {\n    pkey, skey := generate_keypair(seed);\n    return (pkey, skey);\n}\n\n\n(* Agent A sends message to Agent B *)\nproc send_message(sender_id:host, receiver_id:host, message:message, sender_pkey:pkey, sender_skey:skey) returns (signature:signature){\n    signature := sign(message, sender_skey);\n    return signature;\n}\n\n\n\n(* Agent B verifies the message from Agent A *)\nproc verify_message(receiver_id:host, sender_id:host, message:message, signature:signature, sender_pkey:pkey) returns (valid:bool){\n    valid := verify(message, signature, sender_pkey);\n    return valid;\n}\n\n\n(*  generate_keypair procedure *)\nproc generate_keypair(seed:keyseed) returns (pkey:pkey, skey:skey) {\n    pkey, skey := keygen(seed);\n    return (pkey, skey);\n}\n\n\n\n(*  sign procedure *)\nproc sign(message:message, skey:skey) returns (signature:signature){\n    signature := sign_message(message, skey);\n    return signature;\n}\n\n\n\n(*  verify procedure *)\nproc verify(message:message, signature:signature, pkey:pkey) returns (valid:bool){\n    valid := verify_signature(message, signature, pkey);\n    return valid;\n}\n\n\n(*  keygen procedure *)\nproc keygen(seed:keyseed) returns (pkey:pkey, skey:skey) {\n    pkey := hash(seed);\n    skey := seed; (*Simplified for this example.  In a real implementation, this would be more complex.)\n    return (pkey, skey);\n}\n\n\n(*  hash function *)\nproc hash(input:keyseed) returns (output:key) {\n  output := sha256(input);\n  return output;\n}\n\n\n(*  sign_message procedure *)\nproc sign_message(message:message, skey:skey) returns (signature:signature) {\n  signature := skey + message; (* Simplified for this example.  A real implementation would use a cryptographic signature scheme. *)\n  return signature;\n}\n\n\n(*  verify_signature procedure *)\nproc verify_signature(message:message, signature:signature, pkey:pkey) returns (valid:bool) {\n  valid := signature == pkey + message; (* Simplified for this example.  A real implementation would use a cryptographic verification scheme. *)\n  return valid;\n}\n\n\n(* Main procedure *)\nproc main() {\n    var a_keys: array(1..NA) of record pkey:pkey, skey:skey end;\n    var b_keys: array(1..NB) of record pkey:pkey, skey:skey end;\n\n    for i in 1..NA {\n        a_keys[i].pkey, a_keys[i].skey := A(i, i);\n    }\n\n    for i in 1..NB {\n        b_keys[i].pkey, b_keys[i].skey := B(i, i);\n    }\n\n    var msg:message;\n    var sig:signature;\n    var valid:bool;\n\n\n    msg := 123;\n\n    sig := send_message(1, 2, msg, a_keys[1].pkey, a_keys[1].skey);\n\n    valid := verify_message(2, 1, msg, sig, b_keys[2].pkey);\n\n    assert(valid);\n}"]], "CV-1/Avik-luby-rackoff.cv": [[false, "```\n(** The Luby-Rackoff construction **)\n\n(** A construction \n    using a pseudo-random family of functions over a large domain\n    and an almost-XOR-universal-hash function family\n    is shown to be pseudo-random.\n    See Section 6, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, k, q.\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype D [large,fixed].\ntype DD [fixed].\n\nproba pPRF.\nproba pHash.\n\nfun f(s:S,x:D): D.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRF(s,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat def\n```"]], "CV-1/testPRF.cv": [[false, "```\ncv\n(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, p,  k_len, qE, qD.\n\ntype seed [large,fixed].\ntype ciphertext [large,fixed].\ntype plaintext [large,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba p_prf.\nproba p_uf.\nproba p_xor.\n\n(* f(S) is a pseudo-random function family *) \n\nexpand PRF(seed, S, N, L, kgen, f, p_prf).\n\n(* h(K) is a message authentication code (an unpredictable function family *)\n\nexpand UDF(K, N, L, h, p_uf).\n\n(* The XOR operation *)\n\nexpand XOR(L,W,p_xor).\n\n(* The encryption algorithm *)\n\ndef encrypt(K, M, N) :\n  S <- kgen(K);\n  L <- f(S, N);\n  C <- L xor M;\n  return (C, L);\n\n(* The decryption algorithm *)\n\ndef decrypt(K, C, N, L) :\n  S <- kgen(K);\n  L' <- f(S, N);\n  M <- C xor L';\n  return M;\n```"]], "CV-1/testrepl.cv": [[true, "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, p.\n\ntype Z [fixed].\n\ntype G [fixed].\n\nproba DDH.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new x:Z; exp(gamma,x) [all]\n<= (0) => (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun dot(Z,G): G.\n\n(* dot(.,y) is a"]], "CV-1/tls13-core-RecordProtocol-0RTT.cv": [[false, "```\n******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n *****************************************************\n\n(* Example of a protocol with a nonce *)\n\n(* This example shows a simple authentication protocol using a nonce. *)\n\n(*  Alice sends a nonce to Bob, and Bob sends it back to Alice. *)\n\n(*  The protocol is vulnerable to a replay attack if the nonce is not *)\n(*  fresh. *)\n\nmodule Main = struct\n\n  type nonce = int\n\n  (* Alice's secret key *)\n  let alice_sk = 1\n\n  (* Bob's secret key *)\n  let bob_sk = 2\n\n  (* Alice's public key *)\n  let alice_pk = 3\n\n  (* Bob's public key *)\n  let bob_pk = 4\n\n\n  (*  Message format *)\n  type message =\n    | A_to_B of nonce\n    | B_to_A of nonce\n    (* ... other message types ... *)\n    \n\n  (*  The protocol's execution *)\n  let protocol =\n    let rec execute state =\n      match state with\n      | [] -> true\n      | (A_to_B nonce)::tl ->\n          let new_state = B_to_A nonce :: tl in\n          execute new_state\n      | (B_to_A nonce)::tl ->\n          execute tl\n      | _ -> false\n    in execute []\n\n  (*  Security properties *)\n  let security_property =\n    (*  The protocol should be secure against replay attacks *)\n    (*  This property is not yet defined for this protocol *)\n    true\n  \nend\n\n(*  Formalization of the protocol *)\n\n(* We need to define the cryptographic operations (e.g., encryption, decryption) *)\n(* and the security properties (e.g., freshness of the nonce). *)\n\n(* ... (Cryptographic operations and security properties) ... *)\n\n(* Example of a security property using the nonce freshness condition *)\n\nlet nonce_freshness nonce =\n  (* Check if the nonce is fresh.  This might involve other variables *)\n  (* or timestamps, etc. *)\n  true\n\nlet security_property_with_nonce =\n  (*  Verify that the nonce is fresh in each message *)\n  let rec check_nonce_freshness state =\n    match state with\n    | [] -> true\n    | (A_to_B nonce)::tl ->\n        if nonce_freshness nonce then check_nonce_freshness tl else false\n    | (B_to_A nonce)::tl ->\n        if nonce_freshness nonce then check_nonce_freshness tl else false\n    | _ -> false in\n  check_nonce_freshness []\n\n\n(*  Verification function *)\nlet verify =\n  (*  This part should formalize the security properties in terms of *)\n  (*  the messages exchanged. *)\n\n    (* ... (Formalization of the security properties) ... *)\n    Main.security_property_with_nonce\n\n\n(*  Main verification call *)\nlet () =\n  if verify then\n    Printf.printf \"The protocol is secure.\\n\"\n  else\n    Printf.printf \"The protocol is vulnerable.\\n\"\n```"]], "CV-1/undeniable-sig.ocv": [[true, "(* Undeniable signature scheme *)\n\n(* Define the types *)\ntype message = string;\ntype signature = string;\n\n(* Define the public and private keys *)\ntype public_key = string;\ntype private_key = string;\n\n(* Define the hash function (replace with a suitable hash function) *)\nlet hash (msg: message) : string =\n  (* Example using a simple string concatenation *)\n  msg ^ \"salt\" (* Replace with a real hash function like SHA256 *)\n\n\n(* Define the signature generation function *)\nlet sign (msg: message) (priv_key: private_key) : signature =\n  let msg_hash = hash msg in\n  (* Example: Simulate a signing process *)\n  msg_hash ^ priv_key\n\n(* Define the signature verification function *)\nlet verify (msg: message) (sig: signature) (pub_key: public_key) : bool =\n  try\n    let msg_hash = hash msg in\n    let expected_sig = msg_hash ^ pub_key in\n    sig = expected_sig\n  with _ -> false\n\n(* Example usage *)\nlet msg = \"This is a secret message\";\nlet priv_key = \"my_secret_key\";\nlet pub_key = \"my_public_key\";\n\nlet sig = sign msg priv_key;\nlet verification_result = verify msg sig pub_key;\n\n(* Print the results *)\nPrintf.printf \"Message: %s\\n\" msg;\nPrintf.printf \"Signature: %s\\n\" sig;\nPrintf.printf \"Verification result: %b\\n\" verification_result;\n\n\n(* Formal specification (using CryptoVerif's assertions) *)\n(*  Add assertions to prove the correctness of the scheme *)\n(*  Example: *)\n(*  assert (verify (msg) (sign (msg) (priv_key)) (pub_key)); *)\n\n(* Important:  You need to replace the placeholder hash function with a real\n   cryptographic hash function (e.g., SHA256) and implement a secure\n   key generation and management mechanism.  The example above is VERY\n   INSECURE! *)"]], "CV-1/uniqueotheruseswarn.cv": [[false, "```\n(* \nTest to see the warnings with unique and otheruses in processes\nModified from FDH signature scheme\n *)\n\nparam q [noninteractive].\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [bitstring].\n\n(* One-way trapdoor permutation *)\n\nproba 1.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent query_event.\nquery ev\n```"]], "CV-1/woolampkcorrSimp.cv": [[false, "```\n(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n   \n    This is an example of a protocol.\n*)\n\n(*\n  Example protocol:  A simple key exchange protocol\n  with a trusted third party.\n\n  Protocol:\n  1. A -> T : A, B\n  2. T -> A : K\n  3. A -> B : K\n\n  Security goal:\n  A and B share a common key K.\n*)\n\n(*  Import the CryptoVerif library *)\nRequire Import CryptoVerif.\n\n(*  Define the participants *)\nDefinition participant :=\n  enum {Alice, Bob, T}.\n\n(* Define the messages *)\nDefinition message :=\n  enum {Request, Key}.\n\n(* Define the actions *)\nDefinition action :=\n  (participant * message * participant).\n\n\n(* Define the protocol *)\nDefinition protocol :=\n  ((Alice, Request, T)\n   -> (T, Key, Alice)\n   -> (Alice, Key, Bob)).\n\n(* Define the initial knowledge *)\nDefinition initial_knowledge :=\n  {}.\n\n\n(* Define the assumptions *)\nDefinition assumptions :=\n  {}.\n\n\n(* Define the security goal *)\nDefinition security_goal :=\n  (exists k,\n     (Alice, Key, Bob) = (Alice, k, Bob) /\\ (Bob, Key, Alice) = (Bob, k, Alice)).\n\n(*\n  Verification of the protocol\n*)\n\nDefinition main :=\n  check_protocol protocol initial_knowledge assumptions security_goal.\n\n(*  Example of a session *)\nDefinition session :=\n(Alice, Request, T) -> (T, Key, Alice) -> (Alice, Key, Bob).\n\n(* Check the protocol *)\n(*  This should be replaced by the actual verification call *)\n(*  Check_protocol session initial_knowledge assumptions security_goal. *)\n\n(*\n  This is a minimal example.  A real-world protocol would\n  require more complex definitions of participants, messages,\n  actions, initial knowledge, assumptions, and security goals.\n*)\n\n(*\n  To compile this file, you need to have CryptoVerif installed.\n  Then, you can compile it using the following command:\n  cryptoverif example.cv\n*)\n\n```"]], "CV-1/Zalinescu-query.cv": [[true, "type bitstring [fixed].\ntype TYPE_0 [fixed].\ntype key [bounded].\n\n\nparam kseed: bitstring.\nconst dummy: bitstring.\n\n\n\n\nfun QueryRequestTag(req:bitstring):bitstring[compos].\nfun QueryRequest(req:bitstring):bitstring[compos].\nconst SCambridge:bitstring.\nconst Scoldbutsunny:bitstring.\nconst SOrsay:bitstring.\nfun QueryResponse(resp:bitstring,req:bitstring):bitstring[compos].\nfun QueryResponseTag(req:bitstring,resp:bitstring):bitstring[compos].\nconst Ssunnybutcold:bitstring.\nchannel request.\n\n\n(* MAC *)\nproba 1.\nexpand UF_CMA_mac(kseed, key, bitstring, \n                  bitstring, kgen, hmacsha1, \n                  hmacsha1Verify, Pmac).\n\n(* other assumptions *)"]], "CV-1/Avik-hash-elgamal-CDH3.cv": [[true, "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, nBits, q, nE, nH, nCDH, nBitsK.\n\ntype Z [fixed].\ntype G.\ntype K [large,fixed].\ntype D [fixed].\n\nproba proba.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun xor(D,D): D.\n\n(* xor self-cancels *)\n\nforall x:D, y:D;\n  xor(x, xor(x,y)) = y."]], "CV-1/BogdanDennis2.ocv": [[true, "param n_f, n_pub, nK, nF, nx.\n\n(* set interactiveMode = true. *)\n\ntype pkey [bounded].\ntype skey [bounded].\ntype D [large,fixed].\ntype seed [bounded].\n\nfun pkgen(seed):pkey.\nfun skgen(seed):skey.\nfun B(D):D.\nfun pkgen'(seed):pkey.\nfun f'(pkey, D):D.\nfun f(pkey,D):D.\nfun invf(skey,D):D.\nfun xor(bool,bool):bool.\nequation commut(xor).\n\nforall r:seed,x:D; invf(skgen(r),f(pkgen(r),x))=x.\n(* forall r:seed,y:D; f(pkgen(r),invf(skgen(r),y))=y. *)\nforall pk:pkey,x:D,x':D; (f(pk,x)=f(pk,x'))=(x=x').\nforall b:bool,b':bool; xor(xor(b,b'),b')=b.\n\nequi"]], "CV-1/bug-cryptotransf-count-find-with-max2.cv": [[false, "```\n(* CryptoVerif makes a wrong computation of probabilities.\nTo count the number of calls to the encryption oracle,\nit computes a \"max\" between the two branches of find,\nbut this is correct only when the current replication index\nappears as a factor. Here, the encryption oracle\nis called N2 times in each branch of find.\nIn total, it is called 2 N2 times.\n*)\n\nparam N.\nparam N2.\nparam N3.\n\ntype nonce [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype bitstring [fixed].\n\n(* Shared-key encryption (IND-CPA) *)\n\nproba 1.\n\nexpand IND_CPA_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* Qu\n```"]], "CV-1/Avik-prf.cv": [[false, "```\n(** Pseudo-random functions **)\n\n(** Extending the input length of a pseudo-random function family\n    with a universal hash function\n    is shown to preserve pseudo-randomness.\n    See Section 4, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, q.\n\nproof {\n      auto;\n      merge_branches;\n      success\n      }\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype D1 [fixed].\ntype D2 [fixed].\ntype D [fixed].\ntype G [large,fixed].\n\nproba pPRF.\nproba pUHash.\n\nfun f(S,D): D2.\nfun h(K,D): D1.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D1) m -> f(s,x) [all] \n<=\n```"]], "CV-1/bug-elsefind.cv": [[false, "```\n(* CryptoVerif proves secrecy of s, and this is wrong \n   The attacker can get x[1] by first executing pA, receiving x[1],\n   then sending x[1] to pB, so z[1] = x[1]; since j[...] is not defined,\n   the find goes to its else branch, so y[1] = z[1] = x[1].\n   Then the attacker runs pC, the find succeeds for j = 1,\n   and the attacker gets s.\n*)\n\n\nparam N:int.\n\ntype T [int,large].\n\nchannel c.\n\nset elsefindFactsInSimplify = true.\nset debugElsefindFacts = true.\n\nquery s:T.\n\n\nlet pA =\n    ! N\n    in(c, ());\n    new x:T;\n    out(c, x).\n\nlet pB =\n    ! N\n    in(c, z:T);\n    find u <= N suchthat defined(x[u]) = true, z = x[u];\n    new y:T;\n    y = z;\n    out(c, y).\n\nlet pC =\n    ! N\n    in(c, y:T);\n    find j <= N suchthat defined(y[j]) = true;\n    if defined(y[j]) then\n        s = y[j]\n    else\n        s = 0;\n    out(c, s).\n\n```"]], "CV-1/bug-otheruses-hash.cv": [[true, "(* \nBug related to simplify/otheruses: the event termS is finally\nremoved\n*)\n\n\nproof {\ncrypto hash;\nsimplify;\nsimplify;\nauto\n}\n\n(* set interactiveMode = true. *)\n\nparam NU, NS, NP.\n\ntype G [large, fixed].\ntype nonce [large, fixed].\ntype thash [large, fixed].\n\ntype host [bounded].\n\n(* Hash functions in the random oracle model *)\n\nparam qH, gH.\n\nfun hash(G, nonce):thash.\n\nequiv (x1: G, x2: nonce) N -> hash(x1, x2) [all]\n      <=(0)=>\n      (x1: G, x2: nonce) N -> find[unique] j <= N suchthat defined(x1[j],x2[j],r[j]) && otheruses(r[j]) && x1 = x1[j] && x2 = x2[j] then r[j] else\n\t\t\t new r:thash; r.\n\nc"]], "CV-1/bug-sarename.cv": [[true, "param N:int.\nparam PARAM_0 = N.\n\ntype G [large, fixed].\ntype hashinput.\ntype hash [fixed].\ntype bool.\n\nproof {\nSArename z\n}\n\n(* Queries *)\n\nquery check_input(x:G, y:G, a:hash, b:hash) : bool.\n  if x = y then a = b else true.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9,  \n\tstart, finish.\n\n\nlet processU =\n\tin(c1, (x:G, y:G, a:hash, b:hash));\n        let z:hash = if x = y then a else b.\n\nlet processS =\n\tin(c3, (x': G, c:hash));\n\tfind j<= N suchthat defined(x[j]) && x[j] = x' && find j'<=N suchthat defined(z[j']) && z[j'] = c then true else false then\n\tnew s: G;\n        out(c2, s).\n\nprocess \n\t((! N processU) |\n\t (! N processS))\n\n\n(* EXPECTED\nRESULT Could not prove secrecy of s.\n0.020s (user 0.020s + sys 0.000s, real 0.020s)\n*)"]], "CV-1/bug-simplif-find-cond.cv": [[false, "```\n(* Encrypted Key Exchange, version of \nhttp://www.di.ens.fr/~pointche/pub.php?reference=BrChPo03 *)\n\nproof {\ncrypto h0\n}\n\nparam N.\n\ntype exponent [large, fixed].\ntype G [large, fixed].\ntype passwd [fixed].\n\ntype hashinput.\ntype hash0 [fixed].\ntype hash1 [fixed,large].\ntype host.\n\n(* Computational Diffie-Hellman *)\n\nproba PROBA_0.\n\nexpand CDH(G, exponent, g, g, mult, pCDH).\n\nequiv !N new X:G; () -> X <=(0)=> !N new x:exponent; () -> exp(g,x).\n\n(* Ideal cipher model *)\n\ntype cipherkey [fixed].\n\nexpand ICM_cipher(cipherkey, passwd, G, enc, dec).\n\nparam qE, qH [noninteractive].\nchannel cE, cD.\nlet enc_dec_or\n```"]], "CV-1/bug-simplify-ifletfindnew.cv": [[false, "```\ncv\n(* Caused an internal error because if/let/find/new occurred in try_no_var *)\n\nproof {\nshow_game occ;\nreplace 72 x (* The message in out(c2, ...) *)\n}\n\nparam n [bounded].\nparam k [bounded].\nparam pksize [bounded].\nparam sksize [bounded].\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba 1.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, y: bitstring); out(hc2, hash(hk,y)).\n\n(* Queries *)\n\nevent qK [bounded].\n```"]], "CV-1/bug-simplify-proba-in-find-cond.cv": [[false, "```\n(* OK: CryptoVerif correctly counts the number of comparisons with the\npassword pw, by replacing the index of find j with a new replication\nindex (function new_repl_index in simplify.ml) *)\n\nparam N.\nparam N2.\nparam N3.\n\ntype nonce [int,fixed].\ntype passwd [int,fixed].\n\nproof {\nsimplify coll_elim pw\n}\n\n(* Queries *)\n\nquery coll_elim M.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, start, c0.\n\nlet processA = \n\tin(c0, ());\n\tnew pw : passwd;\n\tnew M : nonce;\n\tfind j <= N2 suchthat defined(m[j]) && pw = m[j] then\n\tout(c1, M).\n\nprocess \n\t(! N processA) | (!N2 in(c0, ()) -> out(c2, ()))\n```"]], "CV-1/bug-simplify_find_index.cv": [[false, "```\nparam N.\n\ntype G [large, fixed].\ntype secret [large, fixed].\ntype hash [fixed].\ntype host.\n\nproof {\nshow_game\n}\n\n(* Queries *)\n\nquery secret x.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9,  \n\tstart, finish.\n\n\nlet processU =\n\tin(c1, (x:G, y:G, a:hash, b:hash));\n        let z:hash = if x = y then a else b.\n\nlet processS =\n\tin(c3, (x': secret, c:hash));\n\tfind j''<=N suchthat defined(x[j'']) && x[j''] = x' then\n\tfind j<= N, j'<=N suchthat defined(x[j']) && x[j'] = x' then\n\tnew s: G;\n        out(c4, s).\n\nprocess \n\t((! N processU) |\n\t (! N processS))\n\n\n(* EXPECTED\nRESULT Could not prove secrecy of s.\n0.020s (user 0.0\n\n```"]], "CV-1/bug-update-args-at-creation-get-vars.cv": [[true, "param N2.\nparam N3.\n\ntype nonce [large,fixed].\ntype host [bounded].\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [fixed].\ntype tag [bounded].\ntype maxenc [bounded].\ntype byte [bounded].\n\ntable keytbl (key, mkey, host).\n\nfun concat1(tag, host, seed):maxenc [compos].\n\n(* Shared-key encryption (CPA Stream ciphers) *)\n\n(* Example demonstrating an array access *)\n\n(* The variable kas is not defined outside of the get function *)\n\n(* The access to kas in the find function is not guaranteed to succeed *)\n\n\n(* The function get retrieves the key from the keytbl *)\nfun get(key, host):mkey{\n  find (keytbl, (key, _, host), (mkey, _, _)).\n}\n\n\n(* The function find searches the keytbl *)\nfun find(keytbl, (key, mkey, host), (mkey2, key2, host2)):bool{\n\texists (k,mk,h) in keytbl: (k==key /\\ mk==mkey /\\ h==host /\\ mkey2==mk /\\ key2==k /\\ host2==h).\n}\n\n\n\n(* This is the main function *)\nfun main(key, host, nonce):bool{\n\tlet kas = get(key, host);\n    exists (kas) : true.\n    true.\n}"]], "CV-1/bugeq.cv": [[false, "```\nparam n, m, m', k.\n\ntype S [n,fixed].\ntype D [large,fixed].\n\nfun f(S,D): D.\nfun g(S,S,D): D.\nfun g'(S,S): D.\n\nequiv\n    !n new a:S; new b:S;\n      ((x:D) m -> f(a,x), (y:D) m' -> g(a,b,y))\n<=(0)=>\n    !n new c:S;\n      ((x:D) m -> f(c,x), (y:D) m' -> g'(c,y)).\n\n\n\nquery n=1 test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, x:D);\n    new b:S;\n    out(dummy, f(b,x));\n    in(dummy, y:D);\n    new a:S;\n    out(dummy, g(a,b,y)).\n\n(* CryptoVerif assumes that all restrictions used in an equivalence\nare defined at all expressions that occur in the equivalence. This\nis important in order to avoid unexpected results. *)\n```"]], "CV-1/bug_transform_findcond.cv": [[false, "```\n(* Internal error \nThe transformation of h(x[j]) defines \n\nlet m = x[j] in find ... and makes a look up on m.\n\nWhen we do that inside a condition of find, we end up making a look up\non a variable m defined in a condition of find, which is forbidden.\n\nWe should forbid such transformations (which ones precisely?).\n\n*)\n\nparam keysize [fixed].\n\ntype G [large, fixed].\ntype bit [fixed].\ntype hash [fixed].\ntype host.\n\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, hashinput, hash, h).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, y: hashinput); out(hc2, h(y)).\n\n(* Queries *)\n\nquery find(s: bit) : bit.\n```"]], "CV-1/Avik-prp.cv": [[false, "```\n(** Pseudo-random permutations **)\n\n(** A pseudo-random permutation family with large domain\n    is shown to be pseudo-random.\n    See Section 5, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q.\n\ntype S [large,fixed].\n\ntype D [n,fixed].\n\nproba 1.\n\nfun f(S,D): D.\n\n(* f(S) is a pseudo-random permutation family... *) \n\nfun sep1(r:S): D [compos].\n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRP(time,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then sep1(r[u])\n                    else x\n```"]], "CV-1/Corin-outside.cv": [[false, "```\n(* A->B: {nonce}_pkB, MAC(pwd)_nonce. *)\n\n(* set interactiveMode = true. *)\n\nparam N.\nparam N2.\nparam bitsize.\nparam N4.\n\ntype nonce [large,fixed].\ntype pwd [large,fixed].\ntype blocksize [large,fixed].\ntype host [bounded].\ntype pkey [bounded].\ntype skey [bounded].\ntype message [large,fixed].\ntype macs [bounded].\n\n\nfun pad(nonce):blocksize [compos].\n\n(* Public-key encryption (CCA2) *)\n\nproba prob_enc.\nproba Penccoll.\n\nfun enc(blocksize, pkey, seed): bitstring.\nfun skgen(keyseed):skey.\nfun pkgen(keyseed):pkey.\nfun dec(bitstring, skey): blocksize.\n\nfun enc2(blocksize, pkey, seed): bitstring.\nfun mac(pwd, nonce):macs.\n```"]], "CV-1/elsefind.cv": [[false, "```\ncv\n(* CryptoVerif specification for a simplified authentication protocol *)\n\n(* Define the types *)\ntype key = {k : bitstring};\ntype nonce = {n : bitstring};\ntype timest = {ts : bitstring};\ntype client = {c : bitstring};\ntype server = {s : bitstring};\ntype tgs = {tg : bitstring};\n\n\n(* Define the operation pad *)\nop pad(op : bitstring, arg : bitstring) : bitstring;\n\n(* Define the operation padts *)\nop padts(arg : timest) : bitstring;\n\n\n(* Define the operation concat4 *)\nop concat4(t2 : key, y2 : nonce, x2 : timest, z2 : tgs) : bitstring;\n\n(* Define the operation concat5 *)\nop concat5(y : key, x : timest, z : client) : bitstring;\n\n\n(* Define the operation concat8 *)\nop concat8(t : key, y : nonce, x : timest, z : server) : bitstring;\n\n\n(* Define the protocol rules *)\n(* Timestamp rule *)\nforall t: timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t \t  \n  pad(concat4(t2,y2,x2,z2),t) <> concat4(t2,y2,x2,z2);\n\n(* Timestamp rule *)\nforall t: timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t\t\t  \n  padts(t) <> concat4(t2,y2,x2,z2);\n\n(* Client message rule *)\nforall y:key, x:timest, z:client, t2: key, y2:nonce, x2:timest, z2:server;   \t  \n  concat5(y,x,z) <> concat8(t2,y2,x2,z2);\n\n(* Client message rule *)\nforall y:key, x:timest, z:client, t2: timest, z2:client;    \t\t\t  \n  concat5(y,x,z) <> pad(concat5(y,x,z),t2); \n\n(* Client message rule *)\nforall y:key, x:timest, z:client, t2: timest;    \t\t\t\t  \n  concat5(y,x,z) <> padts(t2); \n\n(* Server message rule *)\nforall t:key, y:nonce, x:timest, z:server, t2:timest, z2:client;  \t\t  \n  concat8(t,y,x,z) <> pad(z2,concat8(t,y,x,z));\n\n(* Server message rule *)\nforall t:key, y:nonce, x:timest, z:server, t2:timest;  \t\t\t\t  \n  concat8(t,y,x,z) <> padts(t2);\n\n(* This is needed for the analysis to be complete,\n   but it's not directly part of the protocol rules *)\nforall t: timest;  \n  t <> t;\n\n```"]], "CV-1/equiv_no_repl.cv": [[true, "(* Internal error \nThe transformation of h(x[j]) defines \n\nlet m = x[j] in find ... and makes a look up on m.\n\nWhen we do that inside a condition of find, we end up making a look up\non a variable m defined in a condition of find, which is forbidden.\n\nWe should forbid such transformations (which ones precisely?).\n\n*)\n\ntype uint [large, fixed].\ntype op [fixed].\ntype hashoutput [fixed].\ntype host.\n\nparam n, qH.\n\nproba 1.\n\nfun hash(hashinput):hashoutput.\nfun hash2(hashinput):hashoutput.\n\nequiv (x:hashinput) -> hash(x) [all]\n      <=(P)=>\n      (x:hashinput) -> hash2(x).\n\nchannel input, c"]], "CV-1/Eugen-pwd-auth.cv": [[true, "proof {\ncrypto Dbinsert;\nshow_game\n}\n\ntype key [fixed].\ntype value [fixed].\ntype guid [fixed].\ntype Dbdb.\ntype option[compos].\n\nconst dummy:unit.\n\nchannel db_channel.\n\ndefine Database(option,Some,None, guid,db,unit,key,value, newdb,dbinsert,select)\n{\nfun Some(value):option[compos].\nfun None():option[compos].\n\nforall x:key;\n  Some(x)<>None.\n\n\nconst un:unit.\n\nfun newdb(guid):db.\nfun dbinsert(db,key,value):db.\nfun select(db,key):option.\n\nparam N.\nparam N1.\nparam M.\n\nproba 1.\nequiv ! N  new d: guid; ((k:key,v:value) N1 -> dbinsert(newdb(d),k,v),\n      \t                 (k':key) select(newdb(d),k')=None),\n       \t                 ((k'',v''):key*value) N1 -> dbinsert(newdb(d),k'',v'')"]], "CV-1/first_game3.cv": [[true, "(* This file tests the interaction between find and let.\n   The problem is that the let y inside the condition of find\n   should not be expanded, because we must make sure that x is\n   defined before being able to execute the \"let\". *)\n\n(* Define the types *)\ntype nat = int;\ntype bool = int;\n\n(* Define the functions *)\nlet rec find (l : nat list) (x : nat) : bool =\n  match l with\n  | [] -> 0\n  | h :: t -> if h = x then 1 else find t x\n\n(* Define the main function *)\nlet main () : nat =\n  let x = 5 in\n  let l = [1; 2; 3; 5; 6] in\n  if find l x then\n    let y = x + 1 in\n    y\n  else\n    0"]], "CV-1/Hanatani1.cv": [[true, "(* DH key Exchange *)\n\nproof {\ncrypto PCDH2 x\n}\n\nparam nK, na, nb, n0, n1, n2, n3, n4, n5, nT.\n\ntype modp [large,fixed].    \ntype typeg [large,fixed].   \ntype modq [large,fixed].    \ntype R [bitstring,fixed].       \ntype seed [large,fixed].    \n\n\nproba PCDH1.\nproba PCDH2.\nproba PCDH3.\nproba PCDH4.\nconst mark:bitstring.\n\n(* CDH Group *)\nfun pkgen1(seed):modp.    (* low p *)\nfun pkgen2(seed):typeg.   (* generater g *)\nfun pkgen3(seed):modq.    (* order of <g> *)\nfun pkgen'1(seed):modp.   (* low p *)\nfun pkgen'2(seed):typeg.  (* generater g *)\nfun pkgen'3(seed):modq.   (* order of <g> *)"]], "CV-1/ifletfindnew_in_try_no_var.cv": [[true, "(* Bug: \nit transforms defined(m[k2]) into defined(m[k1]) \nalthough they are not equivalent (k2 is defined only when x = x')\n*)\n\nparam N.\n\ntype G [large, fixed].\ntype hashinput.\ntype hash [fixed].\ntype host.\n\nproof {\ncrypto f\n}\n\nfun f(x:hashinput,y:hash):bool.\n  return false.\n\nequiv !N Ohash(x:hashinput,y:hash) := f(x,y) [all]\n      <=(0)=>\n      !N Ohash(x:hash,y:hash) := let z:hash = x in if defined(z) then z = y else false.\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, hashinput, hash, h).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, y: hashinput); out(hc2, h(hk,y)).\n\n(* Queries *)\n\nquery q_hash(hk:hashkey, y:hashinput, h_y:hash) : bool {\n  return Ohash(y,h_y).\n}"]], "CV-1/insert.cv": [[true, "(* Test for the insert instruction with variables \n   not explicitly included in defined conditions of find *)\n\nproof {\n  show_game occ;\n  insert 203 \"let k = Kkey[j2_204] in\";\n  show_game occ;\n  insert 241 \"let k' = SKkey[j2_208] in\";\n  show_game occ;\n  (* Add the necessary assertions to ensure the proof completes *)\n  assert (j2_204 < size(Kkey));\n  assert (j2_208 < size(SKkey));\n  (* Example of a more complex assertion *)\n  assert (j2_204 < 1000);  (* Placeholder, replace with a meaningful assertion *)\n  (* Example of another assertion *)\n  assert (j2_208 >= 0);\n  (* ... add more assertions as needed ... *)\n  (* Example: if Kkey and SKkey are arrays of a specific type,\n     add assertions about the type *)\n  (* Example: if k or k' are used in further calculations,\n     add assertions about their properties.  *)\n  (*  Example: if k or k' are used in a crypto operation,\n     add assertions about the keys. *)\n  (* Example: if the indices are calculated from other variables,\n     add assertions about the range of those variables. *)\n}\n\n(*\n\nFor the proof to succeed, it is important that \"crypto enc rkB\" is \napplied before \"crypto sign rkA\". This is because, when\nA talks to B and we apply \"crypto enc rkB\", we replace the plaintext\nwith Z, and reuse the plaintext directly at the decryption site in\nB, then by simplify check(..., pkA, sign(..., skA, r)) cancels out, and \nthe computation of the signature under skA in this case disappears.\nThere is a possibility that the indices j2_204 and j2_208 are derived from a specific calculation.\nIn this case, you should add assertions reflecting the conditions related to those indices.\nFor example, if j2_204 and j2_208 are derived from other variables, you might need to add assertions related to the ranges of those variables.\nIf Kkey and SKkey are arrays of a specific type, you should add assertions about the type of these arrays.\n\n*)"]], "CV-1/live-demo-1.ocv": [[true, "(* This file models a cryptoverif file where one defines the two oracles for IND-CPA encryption, and tries to prove it. *)\n(* Of course, no proof is possible, because we do not make any assumption on the enc function symbol and only declare it. *)\n\ntype key [fixed].  \n\ntype enc_seed [bounded].\n\nfun enc_r(m:bitstring,k:key,r:enc_seed):bitstring.\n\nfun len(bitstring):bitstring.\n\nlet QencL(k: key, r: enc_seed) = \n\tOenc (m1: bitstring, m2: bitstring) :=\n\tif len(m1) = len(m2) then (* m1 and m2 have the same length *)\n\t\treturn(enc_r(m1,k,r)).\n\nlet QencR(k: key, r: enc_seed) = \n\tOenc (m1: bitstring, m2: bitstring) :=\n\tif len(m1) = len(m2) then\n\t\treturn(enc_r(m2,k,r))."]], "CV-1/Misha-RPC-enc.cv": [[true, "set interactiveMode = false.\n\n(* \nremove_assign binder kS_45\ncrypto enc r_46\n*)\n\nparam k : Z_2^128.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\ntype payload [fixed].\nfun payload2bs(payload) : bitstring [compos].\n\n(* unforgeable MACs *)\n\ntype mkeyseed [fixed, large].\ntype mkey [bounded].\n(* type macinput. *)\n(* type macres. *)\n\nproba Pmac.\n\nexpand UF_CMA_mac(mkeyseed , mkey, bitstring, bitstring, mkgen, mac, check , Pmac).\n\n(* IND-CCA2 encryption *)\n\ntype keyseed [fixed, large].\ntype key [bounded].\ntype seed [fixed, large].\n\nproba Penc.\nproba Pencptxt.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTX"]], "CV-1/bug-args-at-creation.cv": [[true, "param N.\nparam N1.\n\ntype nonce [N].\ntype host [N1].\ntype mkey [N2].\ntype mkeyseed [N3].\ntype key [N].\ntype keyseed [N].\ntype seed [N].\ntype macs [N].\ntype maxenc [N].\ntype maxmac [N].\n\nfun concat1(nonce, nonce, host, host):maxenc [compos].\nfun concat2(nonce, key):maxenc [compos].\n\nforall y:nonce,z:nonce,t:host,u:host, y2:nonce,z2:key; concat1(y,z,t,u) <> concat2(y2,z2).\n\n(* Shared-k\n   A and B are the participants.\n   A sends a nonce to B\n   B sends a nonce back to A\n   A sends a message to B\n   B sends a message to A\n\n\n*)\n(*  A's actions *)\n(*  B's actions *)\n(*  Protocol *)\nlet\n  A_to_B = concat1(nonce, nonce, host, host);\n  B_to_A = concat1(nonce, nonce, host, host);\n  A_to_B_2 = concat2(nonce, key);\n  B_to_A_2 = concat2(nonce, key);\n\nin\n  (*  A and B share a key *)\n\n  (*  A sends a nonce to B *)\n  (*  B sends a nonce back to A *)\n  (*  A sends a message to B *)\n  (*  B sends a message to A *)\nend."]], "CV-1/oracletest3.ocv": [[true, "(* FDH signature scheme *)\n\nparam n, nF, n1, nH, qH, qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba proba_f.\n\nconst mark:public.\nfun pkgen(seed):pkey.\nfun pkgen'(seed):pkey.\nfun skgen(seed):skey.\nfun f(pkey, D):D.\nfun f'(pkey, D):D.\nfun invf(skey, D):D.\n\n(* invf is the inverse of f *)\n\nforall r:seed, x:D; invf(skgen(r), f(pkgen(r), x)) = x.\n\n(* Injectivity *)\n\nforall k:pkey, x:D, x':D; (f(k,x) = f(k,x')) = (x = x').\n\n(* We can permute the distribution,"]], "CV-1/otestINDCCA2-v2.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam keylen.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed,large].\ntype keyseed [fixed].\ntype seed [fixed].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba 1.\n\nexpand IND_CCA2_sym_enc(keyseed, key, mkey, bitstring, seed, mkey, key, dec, injbot, Z, Penc).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zkey:bitstring.\nforall y:key; \n\tZ(keyToBitstring(y)) = Zkey.\n\n(* Queries *)\n\nquery"]], "CV-1/otestINDCCA2INTPTXT.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nproof {\ncrypto ind_cca2(enc);\nauto\n}\n\nparam N.\nparam N2.\nparam bitstring [fixed].\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype bitstring [fixed,large].\ntype keyseed [fixed].\ntype seed [fixed].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba 1.\nproba Pencptxt.\n\nexpand IND_CCA2_INT_PTXT_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc, Pencptxt).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zkey:bitstring.\nfor all bitstring:bitstring.\n  Z(bitstring) = Zkey."]], "CV-1/otestINDCPA.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam k:int.\n\ntype mkey [N].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [bounded].\n\nfun keyToBitstring(key):bitstring [size(key)].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba 1.\n\nexpand IND_CPA_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zkey:bitstring.\nforall y:key; \n\tZ(keyToBitstring(y)) = Zkey.\n\n(* Mac *)\n\npr"]], "CV-1/otestINDCPAINTCTXT.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam mkeyseed_size.\n\ntype bitstring [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [bounded].\n\nfun keyToBitstring(k:key):bitstring [compos].\n  return k.\n  \n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba 1.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTXT_sym_enc(N, key, bitstring, bitstring, seed, kgen, dec, injbot, Z, Penc, Pencctxt).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zkey:bitstring.\nforall y:bitstring\n  ensures Z(y).len = y.len\n  ensures forall i:int | i < y.len\n             (Z(y)[i] == false).\n{\n  Z(y) := bitstring(y.len, false).\n}"]], "CV-1/otestINTPTXT.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N:int.\nparam N2:int.\nparam N3:int.\n\ntype mkey [bitstring].\ntype mkeyseed [fixed].\ntype key [fixed,large].\ntype keyseed [fixed].\ntype seed [fixed].\n\nfun keyToBitstring(k:key):bitstring [compos] = \n  let x = k in x.\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba N.\n\nexpand INT_PTXT_sym_enc(keyseed, key, seed, bitstring, bitstring, kgen, enc, dec, injbot,  mkey).\n\n(* Queries *)\n\nquery secret1 k2:key.\nquery secret k3:key.\n\nquery secret k2.\nquery secret k3.\n\nlet processA = \n\tOA() :=\n\tk2 <-R key;\n\ts1 <-R seed;\n\tlet ea1 = enc(keyToBitstring(k2), Kab, s1)"]], "CV-1/otestPRP.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N.\nparam 1.\nparam N3.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed,large].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [bounded].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (PRP) *)\n\nproba Penc.\n\nexpand PRP_cipher(keyseed, key, key, kgen, enc, dec, Penc).\n\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_mac(mkeyseed, mkey, key, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery secret k2.\nquery secret1 k3.\n\nquery secret k2.\nquery secret k3.\n\nevent endB(k2, macs).\nevent beginB(k2)."]], "CV-1/otestSPRP.ocv": [[true, "(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam N3.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed,large].\ntype keyseed [fixed].\ntype bitstring [fixed].\ntype macs [bounded].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (PRP) *)\n\nproba SPRP_cipher(plaintext, key, key, kgen, nonce, enc, dec).\n\nexpand SPRP_cipher(plaintext, key, key, kgen, nonce, enc, dec).\n\n\n(* Queries *)\n\nquery secret1 k2.\nquery secret1 k3.\n\nquery secret k2.\nquery secret k3.\n\nevent endB(key).\nevent beginA(key).\n\nquery x:key; event endB(x) ==> beginA(x). (* Wrong because decryption always succeeds *)\n\nlet process\n  key k;\n  nonce n;\n  plaintext p;\n  ciphertext c;\nin\n  event beginA(k);\n  p := ____(OP_1)____;\n  c := SPRP_cipher(p, k, k, ____(OP_4)____, n, enc, dec);\n  event endB(k);\nend."]], "CV-1/rem_assign_bug.cv": [[false, "```\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, hashinput, hash, h).\n\nparam N [noninteractive].\nchannel in, out, hc1, hc2.\nlet hashoracle = ! qH in(hc1, z: hashinput); out(hc2, h(hk,z)).\n\n(* Queries *)\n\nquery qH in(hc1, z: hashinput) : hash;\n```"]], "CV-1/runex.cv": [[true, "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n *****************************************************\n\n(* This is an example of a simple protocol. *)\n\n(* Define the types of the protocol *)\ntype message =\n  | M1 of int\n  | M2 of int\n  | M3 of int\n\ntype role =\n  | Alice\n  | Bob\n\n(* Define the protocol rules *)\nlet rec protocol =\n  (* Alice sends a message to Bob *)\n  ((Alice, M1(a)) -> (Bob, M2(a)))\n  (* Bob sends a message to Alice *)\n  ((Bob, M2(a)) -> (Alice, M3(a)))\n\n(* Define the properties of the protocol *)\nlet properties =\n  (* The protocol should be secure.  This is a placeholder. *)\n  (* You need to add the actual security properties here. *)\n  (* In this example, we assume that Bob cannot learn Alice's secret. *)\n  (* This is a very basic property.  More complex properties *)\n  (* can be defined using the CryptoVerif language. *)\n  (* For example, you can specify that the message exchanged should *)\n  (* be confidential, authenticated, or have a certain structure. *)\n  [] (* Replace with actual properties *)\n\n(* Define the cryptographic primitives used in the protocol *)\nlet crypto_primitives = []\n\n\n(* Define the assumptions about the environment *)\nlet environment_assumptions = []\n\n(* Define the security goals *)\nlet security_goals = []\n\n(* Add the specification of the attacker model. *)\nlet attacker_model = []\n\n(* Define the initial state of the protocol *)\nlet initial_state = []\n\n(* Define the goal of the analysis. *)\nlet analysis_goal = []\n\n(* Define the assumptions about the protocol participants *)\nlet participant_assumptions = []\n\n(* Define the termination condition of the analysis *)\nlet termination_condition = []\n\n\n(* This is a placeholder for the actual protocol definition. *)\n(* Replace this with your protocol definition. *)\n\n\n(* Example of a simple protocol with confidentiality property *)\n(* Define the cryptographic primitives *)\nlet crypto_primitives = [\n  (* Example: a function that hashes a value *)\n  (* hash_function: int -> int *)\n  (*    (You would replace this with a real cryptographic hash function if needed)*)\n]\n\n(* Define the initial state (e.g., Alice knows a secret key) *)\nlet initial_state = [\n  (* Example: Alice knows a secret key *)\n  (Alice, secret_key = 101010101010)\n]\n\n\n(* Define the attacker model (e.g., an attacker that can eavesdrop on messages) *)\nlet attacker_model = [\n  (* Example: the attacker can eavesdrop *)\n  (Alice, M1(x)) -> ((attacker, M1(x)))\n]\n\n\n(* Define the properties (e.g., confidentiality) *)\nlet properties = [\n  (* Example: the attacker cannot learn the secret key *)\n  (Alice, secret_key = x) -> (attacker, x = ?);\n]\n\n\n\nlet () =\n  let result = CryptoVerif.analyze_protocol protocol properties crypto_primitives initial_state attacker_model in\n  Printf.printf \"Analysis result: %s\\n\" (match result with\n                                          | `Success -> \"Success\"\n                                          | `Failure msg -> \"Failure: \" ^ msg)"]], "CV-1/bug-cryptotransf-find-in-find-cond.cv": [[false, "```\n(* FDH signature scheme *)\n\nparam q [bounded].\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba 1.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [bitstring].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent sigOK, sigFail, hashOK.\nquery bad ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! q in(start, x: bitstring); out(c0, x)\n```"]], "CV-1/secret_in_event2.cv": [[true, "(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba PROBA_0.\n\ndefine OW_trapdoor_perm2(seed, pkey, OP_5, D, pkgen, skgen, f, invf, POW) {\n\nparam nK, nf, n2.\n\nconst mark:bitstring.\nfun pkgen(seed):pkey.\nfun pkgen'(seed):pkey.\nfun skgen(seed):skey.\nfun f(pkey, D):D.\nfun f'(pkey, D):D.\nfun invf(skey, D):D.\n\n(* invf is the inverse of f *)\n\nforall OP_1:seed, x:D; invf(skgen(OP_6), f(pkgen(OP_8), x)) = x.\n\n(* f is the inverse of invf *)\n\nforall r:seed, x:D; f(pkgen(OP_3), invf(skgen(r), x)) = x.\n\n}\n\n(* Example instantiation of FDH *)\n(* Note: This is just an example, and you need to specify the actual functions and parameters for your specific FDH implementation *)\n(* The following lines are placeholders *)\n\n(* define PKgen(seed) { ... } *)\n(* define SKgen(seed) { ... } *)\n(* define F(pkey, D) { ... } *)\n(* define InvF(skey, D) { ... } *)\n\n(* Example usage *)\n(* Assume you have a specific instantiation of OW_trapdoor_perm2 *)\n(* You can now use the defined functions and verify properties about the signature scheme *)\n\n\n\nOP_1 = r.\nOP_3 = r.\nOP_5 = x.\nOP_6 = r.\nOP_8 = r.\nFUN_0 = skey."]], "CV-1/signedDH-simp-onesession-DDH.cv": [[false, "```\n(* Signed Diffie-Hellman protocol *)\n\nparam n, q, nH, g_ord, N2, nCDH, nCDH', nCDH_prime, n3.\n\ntype host.\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype pkey [bounded].\ntype skey [bounded].\ntype blocksize.\ntype message [large,fixed].\n\ntype Z [fixed].\ntype G [fixed].\ntype G_prime [large,fixed].\ntype D [fixed].\n\nfun exp(G,Z): G.\nconst g:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\n(* the DDH assumption \n\nThis does not work for two reasons:\n1) a and b both get mapped to x (or perhaps both to y), as C\n2) the exponent is not fixed.\n\n*)\n\n(*\n  We need to specify the type of the exponents as well as the type of the elements that the exponentiation operates on.\n  Also, we need to add a multiplicative group operation.\n  This is a common mistake in writing specifications.\n*)\n```"]], "CV-1/test-hashoracle-pair.ocv": [[true, "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(OP_4);\n      crypto rom(G);\n      show_game occ\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [TYPE_0,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba PROBA_0.\n\nexpand set_PD_OW_trapdoor_perm(OP_2, pkey, skey, OP_1, Dow, Dr, pkgen, skgen, f, invf, OP_3, P_PD_OW).\n\n(* Hash functions, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_pair(hashkey, Dr, Dr, Dow, G).\nparam qG [noninteractive].\nlet hashoracleG = foreach"]], "CV-1/test-hashoracle-quad.ocv": [[true, "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);\n      crypto rom(G);\n      show_game occ\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba PROBA_0.\n\nexpand set_PD_OW_trapdoor_perm(seed, pkey, skey, OP_5, Dow, OP_3, pkgen, skgen, OP_4, invf, concat, P_PD_OW).\n\n(* Hash functions, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_pair(hashkey, Dr, Dr, Dow, G).\nparam qG [noninteractive].\nlet hashoracleG = foreach iG <= qG do OG(\n  input = ____(INPUT_iG)____,\n  output = ____(OUTPUT_iG)____\n);"]], "CV-1/test-simplif-find3.cv": [[false, "```\nparam N : nat.\nchannel c.\ntype nonce [0..N-1].\n\nlet p1 = (! N in(c, ()); new x:nonce; new y: nonce; out(c,()))\n|( !N in(c, ()); new z:nonce; out(c, ())).\n\nset maxIterSimplif = 1.\n\nprocess\n\tp1 |\n\tin(c, ());\n\tfind k' <= N suchthat defined(x[k']) then\n\tfind k <= N suchthat defined(x[k],y[k],z[k]) && x[k] = y[k] then \n\tif k' = k then\n\t(* CV should see that this \"find\" always succeeds. Why doesn't it?\n\t   FIXED 5/10/2016. Was just because Settings.changed was not set. *)\n\tfind[unique] j <= N suchthat defined(x[j],y[j],z[k']) && x[j] = y[j] then\n\tout(c, z[k'])\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s)\n\n```"]], "CV-1/testBlock.cv": [[false, "```\ntype key [fixed].\n\n(* Function to generate a key from a keyseed *)\nfun kgen(keyseed):key.\n\n(* Function to encrypt a blocksize with a key *)\nfun enc(blocksize, key): blocksize.\n\n(* Function to decrypt a blocksize with a key *)\nfun dec(blocksize, key): blocksize.\n\n(* Function to concatenate a tag, nonce, and key into a blocksize *)\nfun concat2(tag, nonce, key):blocksize [compos].\n\n(* Example of a probability distribution, in case you use probas *)\nproba uniform(0,1) = (1/2).\n\nproba ____(PROBA_0)____ = 1.\n\n(* Protocol description *)\n(* Define the types and operations of the protocol. *)\n\n(* Protocol participants *)\nparticipant Alice.\nparticipant Bob.\n\n\n(* Protocol messages *)\nmessage m1(nonce, key) from Alice to Bob.\nmessage m2(blocksize) from Bob to Alice.\nmessage m3(blocksize) from Alice to Bob.\n\n(* Protocol steps *)\ninit:\n  Alice -> Bob {m1(nonce, key)};\n  Bob -> Alice {m2(enc(blocksize, key))};\n  Alice -> Bob {m3(dec(blocksize, key))};\n\n\n(*  Verification conditions *)\n(*  Assertions that the protocol should satisfy *)\nvc:\n  ____(VC_0)____\n```"]], "CV-1/testenc.cv": [[false, "```\ncv\n(* crypto hash causes an internal error *)\n\nproof {\ncrypto hash;\nauto\n}\n\n\nparam nK, n0, n1, n2, n3, nH2, nx.\nparam qH, qH2, qD.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype hasht2 [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba 1.\n\nconst mark:bitstring.\nfun pkgen(keyseed):pkey.\nfun pkgen'(keyseed):pkey.\nfun skgen(keyseed):skey.\nfun f(pkey, seed):seed.\nfun f'(pkey, seed):seed.\nfun mf(skey, seed):seed.\n\n(* mf is the inverse of f *)\n\nforall keyseed:keyseed, seed:seed;\n```"]], "CV-1/testeq4.cv": [[false, "```\nhouzhui\nparam n, m, m', k.\n\ntype S [large,fixed].\ntype D [large,fixed].\n\nfun f(S,D): D.\nfun f'(S,D): D.\n\nequiv\n    !n new b:S; \n      (!m (x:D) -> f(b,x))\n<=(0)=>\n    !n !m new c:S; (x:D) -> f'(c,x).\n\n\n\nquery test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, x:D);\n    new b:S;\n    out(dummy, f(b,x)).\n\nprocess\n  in(start, ());\n  new test:S;\n  out(dummy, test);\n  processC\n\n\n\n(* EXPECTED\nRESULT Could not prove secrecy of test.\n0.020s (user 0.020s + system 0.000s), max rss 15584K\nEND *)\n```"]], "CV-1/testPRP.cv": [[false, "```\n(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam 0.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed,large].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [bitstring].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (PRP) *)\n\nproba 1.\n\nexpand PRP_cipher(keyseed, key, key, kgen, enc, dec, Penc).\n\n\n(* Mac *)\n\nproba 1.\n\nexpand SUF_CMA_mac(mkeyseed, mkey, key, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery secret1 k2.\nquery secret1 k3.\n\nquery secret1 k2.\nquery secret k3.\n\nevent endB(key, macs).\nevent beginA(key, macs).\n\nqu\n```"]], "CV-1/testSUFCMAmac.cv": [[false, "```\ncv\n(* Trivial running example for conference paper. *)\n\nparam N.\nparam N2.\nparam K.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype bitstring [bounded].\n\nfun keyToBitstring(key):bitstring [compos].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zkey:bitstring.\nforall y:key; \n\tZ(keyToBitstring(y)) = Zkey.\n\n(* Mac *)\n\nproba Mac.\n\nex\n```"]]}