{"SPDL-1/2r890-ex3-a.spdl": [[true, "/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(X,Y,A)\n{\n\trole A\n\t{\n\t\tfresh nonce1: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(A,X, nonce1 );\n\t\trecv_2(X,A, { A,nonce1 }sk(X) );\n\t\tsend_3(A,Y, ny );\n\t\trecv_4(Y,A, { ny,A }sk(Y) );\n\n\t\tclaim_i1(A,Niagree);\n\t\tclaim_i2(A,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar nonce1: Nonce;\n\n\t\trecv_1(A,X, nonce1 );\n\t\tsend_2(X,A, { nonce1,A }pk(X) );\n\t}\n\t\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(A,Y, ny );\n\t\tsend_4(Y,A, { ny,A }pk(Y) );\n\t}\n}"]], "SPDL-1/AccessRequestEvaluation_CRCBAC.spdl": [[true, "hashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (IDa,GW){\n\nrole IDa{\n\nfresh T1:Nonce;\n\nvar T2:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (IDa,GW,M,T1);\n\nreceive_1 (IDa,GW,Resp);\n\n}\n\nrole GW{\n\nreceive_1 (GW,IDa,M,T1);\n\nmacro Rq=Concat(IDa,cxt,c);\n\n\nif (XOR(Rq,h(SKa))==M)\n{\n    send_1(GW,IDa,resp);\n}\n\n}\n\n}"]], "SPDL-1/boyd.spdl": [[false, "```\nI,R, ni, ks) );\n\t}\n\n\trole R\n\t{\n\t\tfresh nr: Nonce;\n\t\tvar kr: Macseed;\n\t\tvar ____(NONCE_2)____: Nonce;\n\n\t\trecv_1 (I,R, ni);\n\t\tsend_2 (R,I, { I,R, kr }k(I,____(ROLE_1)____), nr);\n\t\trecv_3 (R,I, { I,R, ks }k(I,____(ROLE_1)____), m(ni, m(ks,ni,____(NONCE_1)____)), ____(NONCE_1)____);\n\t\tsend_4 (R,I, m(____(NONCE_2)____, m(kr, nr,____(NONCE_1)____)));\n\t}\n\n\tinitiator I;\n\tresponder R;\n\n\tkey I,R, ks;\n\tkey I,R, kr;\n}\n```"]], "SPDL-1/CapabilityRevocation_CRCBAC.spdl": [[true, "hashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, Db) \n\n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var T2:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, Db, M);\n\n    recv_2(Db, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n}\n\nrole Db {\n\n    recv_1 (Da, Db, M);\n\n    var T2:Nonce;\n\n    macro M2=XOR(Concat(IDa,Resp),h(SKa));\n\n    send_2(Db, Da, M2);\n}\n}"]], "SPDL-1/carkey-ni.spdl": [[false, "```\nhouzhui\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,Bob)\n{\n\trole I\n\t{\n\t\tconst nonce_1: Nonce;\n\n\t\tsend_1(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar nonce_1: Nonce;\n\n\t\tread_1(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tclaim_2(Bob,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Alice,Bob);\nrun carkeyni.Bob(Alice,Bob);\nrun carkeyni.I(Alice,Bob);\nrun carkeyni.Bob(Alice,Bob);\n```"]], "SPDL-1/ccitt509-ban.spdl": [[false, "```\nusertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh nonce1: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(Alice,Bob, Alice,{nonce1, Bob, xi, {yi}pk(Bob) }sk(Alice) );\n\t\trecv_2(Bob,Alice, Bob,{nr, Alice, nonce1, xr, {yr}pk(Alice) }sk(Bob) );\n\t\tsend_3(Alice,Bob, Alice,{Bob,nr}sk(Alice) );\n\n\t\tclaim_4(Alice,Secret,yi);\n\t\tclaim_5(Alice,Secret,yr);\n\t\tclaim_6(Alice,Nisynch);\n\t\tclaim_7(Alice,Nisynch);\n\t}\n\trole Bob\n\t{\n\t\tfresh xj,yj: Data;\n\t\tfresh nonce2: Nonce;\n\t\tvar na: Nonce;\n\t\tvar ya,xa: Data;\n\t\t\n\t\tsend_1(Bob,Alice, Bob,{nonce2, Alice, xj, {yj}pk(Alice) }sk(Bob) );\n\t\trecv_2(Alice,Bob, Alice,{na, Bob, nonce2, xa, {ya}pk(Bob) }sk(Alice) );\n\t\tsend_3(Bob,Alice, Bob,{Alice,na}sk(Bob) );\n\n\t\tclaim_4(Bob,Secret,yj);\n\t\tclaim_5(Bob,Secret,ya);\n\t\tclaim_6(Bob,Nisynch);\n\t\tclaim_7(Bob,Nisynch);\n\t}\n}\n```"]], "SPDL-1/cotes_de_porc-v0.spdl": [[false, "```\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh EncNonce: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(Alice, Bob, Alice, {EncNonce}pk(Bob), {sec}pk(Bob), h(Alice,sec));\n\t\trecv_2(Bob, Alice, {n2}pk(Alice), h(sec,EncNonce,n2));\n\t\tsend_3(Alice, Bob, n2);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar sec: MySecret;\n\t\tvar EncNonce: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(Alice, Bob, Alice, {EncNonce}pk(Bob), {sec}pk(Bob), h(Alice,sec));\n\t\tsend_2(Bob, Alice, n2);\n\t}\n}\n```"]], "SPDL-1/DHKE-1.spdl": [[true, "h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// Main protocol\nprotocol DiffieHellman\n{\n\trole Alice\n\t{\n\t\tvar a,b,A,B: integer;\n\t\tvar x: Ticket;\n\n\t\t// Alice chooses a secret key a\n\t\ta:=rand();\n\t\t// Alice computes A = g^a\n\t\tA:=g1(a);\n\t\t// Alice sends A to Bob\n\t\tsend_!1(Alice,Bob,A);\n\n\t\t// Alice receives B from Bob\n\t\trecv_!2(Alice,Bob,B);\n\n\t\t// Alice computes shared key K = g^a * B^b\n\t\tx:=g1(a) * B^b; // This is the shared key\n\t}\n\trole Bob\n\t{\n\t\tvar a,b,A,B: integer;\n\t\tvar x: Ticket;\n\n\t\t// Bob chooses a secret key b\n\t\tb:=rand();\n\t\t// Bob computes B = g^b\n\t\tB:=g1(b);\n\t\t// Bob sends B to Alice\n\t\tsend_!3(Bob,Alice,B);\n\n\t\t// Bob receives A from Alice\n\t\trecv_!4(Bob,Alice,A);\n\n\t\t// Bob computes shared key K = g^b * A^a\n\t\tx:=g1(b) * A^a; // This is the shared key\n\t}\n}\n\n// Helper functions\nfunction g1(x:integer):integer\n{\n\treturn x; // Placeholder for the actual exponentiation\n}\n\nfunction g2(x:integer, y:integer):integer\n{\n\treturn x * y; // Placeholder for the actual exponentiation\n}\n\nfunction h1(x:integer):integer\n{\n\treturn x; // Placeholder for the actual hash function\n}"]], "SPDL-1/encryption2.spdl": [[false, "```\nNONCE_1\nROLE_1\nNONCE_1\nKcm, IDt, Sm, Sc, Sb);\n\t}\n\trole C\n\t{\n\t\tfresh a: Amount;\n\t\tfresh IDc: UID;\n\t\tfresh t: Timestamp;\n\t\tfresh r: Nonce;\n\n\t\treceive_1 (M, C, Nm, Kcm, IDt, Sm, Sc, Sb);\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\t\trespond_1(M, C, a, IDc, t, r);\n\t}\n}\n\n```"]], "SPDL-1/en_y-v0.spdl": [[false, "```\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,J)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, J, {sec, I}pk(J), h(sec), {n1}pk(J));\n\t\trecv_2(J, I, {n2, J}pk(I), n1);\n\t\tsend_3(I, J, n2);\n\t}\t\n\t\n\trole J\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, J, {sec, I}pk(J), h(sec), {n1}pk(J));\n\t\tsend_2(J, I, {n2, J}pk(I), n1);\n\t}\n}\n```"]], "SPDL-1/exchange-hash.spdl": [[true, "/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\nusertype Nonce;\n\n// Protocol description\n\nprotocol protocol2(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh nonce1: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (Alice,Bob, { nonce1,Alice }pk(Bob) );\n\t\trecv_2 (Bob,Alice, { hash(kir,nonce1,Bob),nr,kir }pk(Alice) );\n\t\tsend_3 (Alice,Bob, { hash(nr,nonce1) }kir );\n\t\tclaim_i1 (Alice, Secret, kir );\n\t\tclaim_i2 (Alice, Nisynch );\n\t}\n\n\trole Bob\n\t{\n\t\tvar nonce1: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar krb: Key;\n\n\t\trecv_1 (Bob,Alice, { nonce1,Alice }pk(Bob) );\n\t\tfresh nr: Nonce;\n\t\tfresh krb: Key;\n\n\t\tsend_2 (Bob,Alice, { hash(krb,nonce1,Alice),nr,krb }pk(Alice) );\n\t\trecv_3 (Alice,Bob, { hash(nr,nonce1) }krb );\n\t\tclaim_i1 (Bob, Secret, krb );\n\t\tclaim_i2 (Bob, Nisynch );\n\t}\n}"]], "SPDL-1/five-run-bound.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,R)\n{\n\trole R\n\t{\n\t\tvar nonce_r: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,R, ni );\n\t\tsend_!2 (R,I, { ni }sk(R) );\n\t\trecv_!3 (I,R, {{{ {nonce_r}pk(R) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (R,I, {k2}nonce_r );\n\n\t\tclaim_6 (R, Secret, k2);\n\t}\n}"]], "SPDL-1/andrew-ban-1.spdl": [[true, "# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,R)\n{\n    role I\n    {\n        fresh nonce1: Nonce;\n        var encrypted1,nr2: Nonce;\n        var session_key: SessionKey;\n        \n        send(encrypted1, nr2) to R;\n    }\n\n    role R\n    {\n        fresh nonce2: Nonce;\n        var encrypted2: Nonce;\n        var session_key: SessionKey;\n\n        receive(encrypted1, nr2) from I;\n        send(encrypted2, nonce2) to I;\n    }\n}"]], "SPDL-1/Fortified-Chain2.spdl": [[true, "const E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\n\nprotocol Fortified-Chain2(DeviceA,DeviceB)\n{\nrole DeviceA {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh NONCE_1:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUa:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\nrecv_!2(DeviceB,DeviceA,P1);\n\nrecv_!4(DeviceB,DeviceA,Q1);\n\nsend_!2(DeviceB,DeviceA,P1);\n\n}\nrole DeviceB {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh NONCE_2:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUb:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\n\nrecv_!2(DeviceA,DeviceB,P1);\n\nsend_!4(DeviceA,DeviceB,Q1);\n\n}\n}"]], "SPDL-1/fourway-HSDDM05.spdl": [[true, "# 1 \"fourway-HSDDM05.cpp\"\n# 1 \"<built-in>\"\n# 1 \"<command line>\"\n# 1 \"fourway-HSDDM05.cpp\"\n# 10 \"fourway-HSDDM05.cpp\"\nusertype Params, String;\n\nconst hash: Function;\nsecret unhash: Function;\ninversekeys(hash,unhash);\nsecret pmk: Function;\n\nconst msg1,msg2,msg3,msg4: String;\n\nconst Alice, Bob, Eve: Agent;\n\nprotocol fourway(Alice,Bob)\n{\n        role Alice\n        {\n                fresh nonce1: Nonce;\n                var y: Nonce;\n\n                send_1( Bob,Alice, nonce1,msg1 );\n                recv_2( Alice,Bob, y,msg2,hash( hash( pmk(Alice,Bob),nonce1,y ),y,msg2 ) );\n                send_3( Bob,Alice, nonce1,msg3 );\n        }\n        role Bob\n        {\n                fresh nonce2: Nonce;\n                var x: Nonce;\n\n                recv_1( Alice,Bob, nonce1,msg1 );\n                send_2( Alice,Bob, nonce2,msg2 );\n                recv_3( Alice,Bob, x,msg3 );\n                \n        }\n}"]], "SPDL-1/gros_pigeons-v0.spdl": [[false, "```\nhashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh Encrypted_Secret: MySecret;\n\t\tvar Nonce: Nonce;\n\n\t\tsend_1(Alice, Bob, {Encrypted_Secret}pk(Bob));\n\t\trecv_2(Bob, Alice, h(Encrypted_Secret), {Nonce}pk(Alice));\n\t\tsend_3(Alice, Bob, h(Nonce));\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar Encrypted_Secret: MySecret;\n\t\tfresh Nonce: Nonce;\n\n\t\trecv_1(Alice, Bob, {Encrypted_Secret}pk(Bob));\n\t\tsend_2(Bob, Alice, h(Encrypted_Secret), {Nonce}pk(Alice));\n\t\trecv_3(Alice, Bob, ____(HASH_VALUE)____);\n\t}\n}\n```"]], "SPDL-1/HMQV.spdl": [[true, "role RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RC,RC, h2(\n\t\t  exp(gexp(X),Y)\n\t\t));\n\n\n\t}\n\trole ____(ROLE_3)____\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\t\trecv_!1(____(ROLE_3)____,____(ROLE_3)____, h2(\n\t\t  exp(gexp(X),Y)\n\t\t));\n\t}\n}\n\n\n\n/*\n *\n *\n *\n *\n */\nprotocol HMQV_TwoPass\n{\n\trole Alice, Bob\n\t{\n\t\tvar a, b: Scalar;\n\t\tvar A, B: Element;\n\t\tvar s: SharedSecret;\n\n\t\t// Stage 1: Key Exchange\n\t\tAlice -> Bob: A = gexp(a);\n\t\tBob -> Alice: B = gexp(b);\n\n\t\t// Stage 2: Compute Shared Secret\n\t\tAlice -> Alice: s = exp(B, a);\n\t\tBob -> Bob: s = exp(A, b);\n\t}\n}"]], "SPDL-1/ikev1-quick.spdl": [[true, "# 1 \"ikev1-quick.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-quick.cpp\"\n# 16 \"ikev1-quick.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 126 \"common.h\"\n  var A, B: Agent;\n  var k: Secret;\n# 126 \"common.h\"\n  var ____(ROLE_1)____, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(k(____(ROLE_1)____,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,____(ROLE_1)____),h(g(i),r),Ni,Nr) );\n\n }\n\n\n}\n# 17 \"ikev1-quick.cpp\" 2\n# 28 \"ikev1-quick.cpp\"\nprotocol ikev1-quick(A, B,"]], "SPDL-1/ikev2-mac.spdl": [[false, "```\n# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, CLIENT) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role CLIENT {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( CLIENT, CLIENT, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( CLIENT, CLIENT, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n }\n\n\n}\n# 16 \"ikev2-mac.cpp\"\n```"]], "SPDL-1/iso25-tag.spdl": [[false, "```\nrole B\n\t{\n\t\tfresh ____(NONCE_2)____: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNb: Nonce;\n\t\tvar TNa: Nonce;\n\t\tvar ____(KEY_2)____: SessionKey;\n\t\tfresh Text2,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\trecv_1(A,____(ROLE_1)____, ____(NONCE_1)____, B, Text1);\n\t\tsend_2(A,____(ROLE_1)____, ____(NONCE_2)____, B, Text2);\n\t}\n\t\n\tevent send_1(A,B,n1,B,t1);\n\tevent recv_2(A,B,n2,A,t2);\n\tevent send_2(A,B,n2,B,t2);\n\tevent recv_1(A,B,n1,A,t1);\n\t\n\t\n\t\n\tsend_1(A,B,t1,B,t1);\n\trecv_2(A,B,t2a,A,t2a);\n\tsend_2(A,B,t2b,B,t2b);\n\trecv_1(A,B,t3,A,t3);\n}\n```"]], "SPDL-1/isoiec-9798-2-1.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}"]], "SPDL-1/isoiec11770-2-13.spdl": [[true, "usertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,A)\n{\n\trole I\n\t{\n\t\tfresh nonce_1: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, nonce_1);\n\t\trecv_4 (R,I, { nonce_1,kir,R }k(I,A) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar nonce_1: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, nonce_1);\n\t\tsend_2 (R,A,{ nr,nonce_1,I,kir }k(R,A) );\n\t\trecv_3 (A,R, { nr, I }k(R,A), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole A\n\t{\n\t}\n}"]], "SPDL-1/KAS1.spdl": [[true, "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(Alice,Bob,Carol)\n{\n\trole Alice\n\t{\n\t\tsend_!1(Alice,Bob, g1(sk(Alice)) );\n\t}\n\trole Bob\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(Bob,Alice, g2(g1(T),sk(Bob)) );\n\t\tsend_!3(Bob,Alice, g2(pk(Bob),T) );\n\t}\n\trole Carol\n\t{\n\t\t//Dummy role\n\t}\n\n}"]], "SPDL-1/andrew-lowe-ban.spdl": [[true, "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n\n\nmodule andrew_rpc\n\n  type msg =\n    | Init of {\n        i : int;\n        r : int;\n        k : int;\n    }\n    | Request of {\n        i : int;\n        r : int;\n        m : int;\n    }\n    | Reply of {\n        i : int;\n        r : int;\n        m : int;\n    }\n\n\n  process I(i : int)\n  process R(r : int)\n\n  init I(i) {\n    k : int;\n    # Init\n    send Init { i = i, r = r, k = k } to R(r);\n    # Recv 1\n    recv Reply { i = i, r = r, m = m } from R(r);\n    # Request\n    send Request { i = i, r = r, m = m } to R(r);\n    # Recv 2\n    recv Reply { i = i, r = r, m = m2 } from R(r);\n  }\n\n  init R(r) {\n    k : int;\n    # Recv 0\n    recv Init { i = i, r = r, k = k } from I(i);\n    # Reply 1\n    send Reply { i = i, r = r, m = m1 } to I(i);\n    # Recv 3\n    recv Request { i = i, r = r, m = m } from I(i);\n    # Reply 2\n    send Reply { i = i, r = r, m = m2 } to I(i);\n    # Recv 4\n    recv Request { i = i, r = r, m = m } from I(i);\n  }\n\n  # Synchronisation Claim\n  # This is the claim that the initiator and responder are communicating with the same entity\n  claim I(i) {\n    k : int;\n\t  exists r : int;\n    recv Init { i = i, r = r, k = k } from I(i);\n    recv Reply { i = i, r = r, m = m1 } from R(r);\n  }\n\n  # Non-trivial synchronisation\n  claim R(r) {\n    k : int;\n    exists i : int;\n\t  recv Init { i = i, r = r, k = k } from I(i);\n    recv Reply { i = i, r = r, m = m1 } from I(i);\n  }\n\nend module"]], "SPDL-1/KEA+.spdl": [[true, "role RC\n\t{\n\t\trecv_!3(RC,RC, g2(pk(RC),T) );\n\t}\n}\n\n\nprotocol KEA(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tvar A: bytearray;\n\t\tvar B: bytearray;\n\t\tvar K: bytearray;\n\n\t\t// Generate ephemeral key and public key.\n\t\tA := g1(sk(Alice));\n\t\t// Send A to Bob.\n\t\tsend_!1(Alice,Bob, A );\n\t\t// Receive B from Bob.\n\t\trecv_!2(Alice,Bob, B );\n\t\t// Compute shared secret.\n\t\tK := g2(B,sk(Alice));\n\t\t// Send K to Bob.\n\t\tsend_!3(Alice,Bob, K );\n\t}\n\trole Bob\n\t{\n\t\tvar A: bytearray;\n\t\tvar B: bytearray;\n\t\tvar K: bytearray;\n\n\t\t// Generate ephemeral key and public key.\n\t\tB := g1(sk(Bob));\n\t\t// Receive A from Alice.\n\t\trecv_!1(Bob,Alice, A );\n\t\t// Send B to Alice.\n\t\tsend_!2(Bob,Alice, B );\n\t\t// Compute shared secret.\n\t\tK := g2(A,sk(Bob));\n\t\t// Send K to Alice.\n\t\tsend_!3(Bob,Alice, K );\n\t}\n\n}"]], "SPDL-1/kerberos-rddm.spdl": [[false, "```\n/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(Client,Server)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role Client\n    {\n        var ticket:Ticket;\n\n\n        recv_!X1(Server,Client,{ticket}ktk(Client,Server));\n        send_!X2(Client,Server,{ticket}ktk(Server,Client));\n    }\n    role Server\n    {\n    }\n}\nprotocol @swapkey-kck(Client,Server)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role Client\n    {\n        var ticket:Ticket;\n        var sessionKey:Sessionkey;\n\n        recv_!X1(Server,Client,{ticket}kck(Client,Server));\n        send_!X2(Client,Server,{sessionKey}kck(Server,Client));\n    }\n    role Server\n    {\n        var sessionKey:Sessionkey;\n\n        recv_!X1(Client,Server,{sessionKey}kck(Client,Server));\n        send_!X2(Server,Client,{sessionKey}kck(Server,Client));\n    }\n}\n\nprotocol @auth(Client,Server)\n{\n    role Client\n    {\n        var kst:Sessionkey;\n        send_!X1(Client,Server,{kst}ktk(Client,Server));\n    }\n    role Server\n    {\n        var kst:Sessionkey;\n        recv_!X1(Client,Server,{kst}ktk(Client,Server));\n    }\n}\n```"]], "SPDL-1/localclaims-breaker.spdl": [[true, "/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,J)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar n2: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,J, {I,ni}pk(J) );\n\t\trecv_2(J,I, {ni,n2,J}pk(I) );\n\t\tsend_3(I,J, {n2,I}pk(J) );\n\n\t\trecv_x1(J,I, {x}pk(I) );\n\t\tsend_x2(I,J, {x}pk(J) );\n\t}\n\n\trole J\n\t{\n\t\tfresh nj: Nonce;\n\t\tvar n1: Nonce;\n\n\t\trecv_1(J,I, {I,ni}pk(J) );\n\t\tsend_2(J,I, {ni,nj,J}pk(I) );\n\t\trecv_3(J,I, {n1,I}pk(J) );\n\n\t\tsend_x1(J,I, {nj}pk(I) );\n\t\trecv_x2(I,J, {x}pk(J) );\n\t}\n}"]], "SPDL-1/myProt.spdl": [[true, "hashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh K: MySecret;\n\t\tvar EncNonce: Nonce;\n\n\t\tsend_1(Alice, Bob, h(Alice, K), {K}pk(Bob));\n\t\trecv_2(Bob, Alice, h(Bob, K, EncNonce), {EncNonce}pk(Alice));\n\t\tsend_3(Alice, Bob, h(EncNonce));\n\n\t\tclaim_4(Alice, Secret, K);\n\t\tclaim_6(Alice, Nisynch);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar V: MySecret;\n\t\tfresh N: Nonce;\n\n\t\trecv_1(Alice, Bob, h(Alice, V), {V}pk(Bob));\n\t\tsend_2(Bob, Alice, h(Bob, V, N), {"]], "SPDL-1/NAXOS.spdl": [[true, "module naxos_ake {\n\n  // Types\n  type user = {\n    id : string;\n  };\n\n  // Roles\n  role initiator;\n  role responder;\n\n  // Nonce\n  nonce N;\n\n\n  // Public and private keys\n  const g;\n  const user_id;\n  private key x;\n  public key y;\n\n\n  // Messages\n  message Init(user id, nonce N, public key y);\n  message Response(user id, nonce N, public key y, shared secret s);\n\n  // Helper protocol for exponentiation\n  helper protocol exp_helper(user id, integer a, integer b) {\n    // Input: a, b\n    // Output: a^b\n    output(a^b);\n  }\n\n\n  // Protocol definition\n  protocol naxos_ake(user id_init, user id_resp) {\n    // Initiator's role\n    initiator {\n      // Input:\n      input(id_init);\n      input(x);\n      input(N);\n\n      // Actions\n      y = g^x;\n      send(Init(id_init, N, y));\n\n      receive(Response(id_resp, N, y, s));\n\n      // Output:\n      output(s);\n    }\n\n    // Responder's role\n    responder {\n      // Input:\n      input(id_resp);\n      input(x);\n      input(N);\n      input(Init(id_init, N, y));\n      input(id_init);\n\n      // Actions\n      s = g^x; // Calculate shared secret\n      send(Response(id_resp, N, y, s));\n\n      // Output:\n      output(s);\n    }\n  }\n}"]], "SPDL-1/needham-schroeder-sk.spdl": [[false, "```\n# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroedersk(Alice,Bob,Carol)\n{\n    role Alice\n    {\n        fresh N1: Nonce;\n        var Nr: Nonce;\n        var K1: SessionKey;\n        var T: Ticket;\n        \n        send_1(Alice,Bob,(Alice,Bob,N1));\n        recv_2(Bob,Alice, {N1,Bob,K1});\n        send_3(Alice,Bob,(K1,N1));\n        recv_4(Bob,Alice, {K1,N1});\n    }\n    role Bob\n    {\n        fresh N2: Nonce;\n        var K2: SessionKey;\n        var T: Ticket;\n        \n        recv_1(Bob,Alice, {A,Bob,N1});\n        send_2(Bob,Alice, {N1,Bob,K1});\n        recv_3(Bob,Alice, {K1,N1});\n        send_4(Bob,Alice, {N2,K1});\n    }\n\trole Carol\n\t{\n\t\t// No actions for Carol\n\t}\n}\n\n```"]], "SPDL-1/nsl3.spdl": [[false, "```\n/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,J)\n{\n\trole I\n\t{\n\t\tfresh N1: Nonce;\n\t\tvar E1: Nonce;\n\n\t\tsend_1(I,J, {I,N1}pk(J) );\n\t\trecv_2(J,I, {N1,E1,J}pk(I) );\n\t\tsend_3(I,J, {E1}pk(J) );\n\n\t\tclaim_i1(I,Secret,N1);\n\t\tclaim_i2(I,Secret,E1);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole J\n\t{\n\t\tvar N1: Nonce;\n\t\tfresh E1: Nonce;\n\n\t\trecv_1(J,I, {I,N1}pk(J) );\n\t\tsend_2(J,I, {N1,E1,J}pk(I) );\n\t\trecv_3(J,I, {E1}pk(J) );\n\n\t\tclaim_j1(J,Secret,N1);\n\t\tclaim_j2(J,Secret,E1);\n\t\tclaim_j3(J,Njagree);\n\t\tclaim_j4(J,Njsynch);\n\t}\n}\n```"]], "SPDL-1/nuts-auth.spdl": [[true, "hashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, ROLE_1), NONCE_1, Rb);\n\nprotocol NUTSAuth (GS,ROLE_1) {\n\n    role GS {\n        var NONCE_1: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, ROLE_1, Rb, MAC(k(GS, ROLE_1), GS, ROLE_1, Rb));\n        recv_2(ROLE_1, GS, NONCE_1, MAC(k(GS, ROLE_1), ROLE_1, GS, NONCE_1, Rb));\n        send_3(GS, ROLE_1, Ks, MAC(Ks, GS, ROLE_1));\n        recv_4(ROLE_1, GS, Ks, MAC(Ks, ROLE_1, GS));\n    }\n\n    role ROLE_1 {\n        var NONCE_1: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(ROLE_1, GS, Rb, MAC(k(GS, ROLE_1), ROLE_1, GS, Rb));\n        recv_2(GS, ROLE_1, NONCE_1, MAC(k(GS, ROLE_1), GS, ROLE_1, NONCE_1, Rb));\n        send_3(ROLE_1, GS, Ks, MAC(Ks, ROLE_1, GS));\n        recv_4(GS, ROLE_1, Ks, MAC(Ks, GS, ROLE_1));\n    }\n}"]], "SPDL-1/oakley-a.spdl": [[true, "send_!I1( I, ROLE_1, Ni );\n }\n\n\n role ____(ROLE_1)____ {\n  fresh Nr;\n  recv_!ROLE_11( ____(ROLE_1)____, I, Nr );\n  send_!ROLE_12( ____(ROLE_1)____, I, Nr );\n }\n}"]], "SPDL-1/pkmv2rsacorrected.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,KA)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,KA, {msrand, said, MS}sk(MS) );\n\t}\n\n\trole KA\n\t{\n\t\tfresh karand: Nonce;\n\t\tvar pak, nrand: Nonce;\n\n\t\treceive_rsa1(KA,MS, {msrand, said, MS}sk(MS));\n\t\tsend_rsa2(KA,MS, {karand, nrand, KA}sk(KA));\n\t}\n}"]], "SPDL-1/athena-breaker.spdl": [[true, "/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh nonce: Nonce;\n\n\t\tsend_!1(Alice,Bob, {{Alice,nonce}pk(Bob)}pk(Bob) );\n\n\t\tclaim_i1(Alice,Secret,nonce);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar T:Ticket;\n\n\t\trecv_!1(Alice,Bob, {T}pk(Bob) );\n\t\tsend_!2(Bob,Alice, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information"]], "SPDL-1/pqr.spdl": [[true, "role Alice\n  {\n    fresh msrand, msrand';\n    fresh n, e, d, c;\n\n    // message 1\n    send(Bob, (n, e));\n\n    // message 2\n    receive(Bob, c);\n    \n    // message 3\n    send(Bob, (msrand));\n\n    // message 4\n    receive(Bob, (msrand'));\n    \n  }\n  \n  role Bob\n  {\n    fresh n, e, d, c;\n    fresh msrand, msrand';\n    \n    // message 1\n    receive(Alice, (n, e));\n\n    // message 2\n    send(Alice, c);\n\n    // message 3\n    receive(Alice, (msrand));\n\n    // message 4\n    send(Alice, (msrand'));\n  }\n}"]], "SPDL-1/protocol0-symm.spdl": [[false, "```houzhui\n/* \n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,R)\n{\n\trole I\n\t{\n\t\tfresh nonce: Nonce;\n\n\t\tsend_1(I,R, {I,nonce}k(I,R) );\n\t\tclaim_i(I,Secret,nonce);\n\t}\n\n\trole R\n\t{\n\t\tvar nonce: Nonce;\n\n\t\trecv_1(I,R, {I,nonce}k(I,R) );\n\t\tclaim_r(R,Secret,nonce);\n\t}\n}\n```"]], "SPDL-1/Signed-DH.spdl": [[true, "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(role Alice)\n{\n\trole Alice\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(Alice,Bob, g2(g1(T1),T2) );\n\t\tsend_!2(Alice,Bob, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tsend_!1(I,R, s, x);\n\t}\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\trecv_!1(R,I, s, x);\n\t\tsend_!2(R,I, y);\n\t}\n}"]], "SPDL-1/skeme-basic.spdl": [[true, "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (Alice, Bob) {\n\n\n\n\n\n\n\n role Alice {\n  var i, r: Nonce;\n\n  recv_!DH1( Alice, Bob, h(g(r),i) );\n  send_!DH2( Alice, Bob, h(g(i),r) );\n }\n\n\n\n\n role Bob {\n  var i, r, nonce1, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( Bob, Alice, KDF(h(g(r),i)) );\n  send_!SWAP2( Bob, Alice, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, nonce1"]], "SPDL-1/soph.spdl": [[false, "```\nprotocol soph(I,R)\n{\n\trole I\n\t{\n\t\tfresh nonce_1: Nonce;\n\n\t\tsend_1(I,R, {I,nonce_1}pk(R) );\n\t\trecv_2(R,I, nonce_1 );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar nonce_1: Nonce;\n\n\t\trecv_1(I,R, {I,nonce_1}pk(R) );\n\t\tsend_2(R,I, nonce_1 );\n\t}\n}\n```"]], "SPDL-1/sts-modified.spdl": [[true, "protocol @oracle (Alice, Bob) {\n\n role Alice {\n  var i, nonce1: Nonce;\n\n  recv_!DH1( Alice, Bob, h(g(nonce1),i) );\n  send_!DH2( Alice, Bob, h(g(i),nonce1) );\n }\n\n role Bob {\n  var i, nonce1: Nonce;\n\n  recv_!DH1( Bob, Alice, h(g(nonce1),i) );\n  send_!DH2( Bob, Alice, h(g(i),nonce1) );\n }\n\n role Swap {\n  var i, nonce1, Ni, Nr: Nonce;\n  recv_!SWAP1( Swap, Swap, KDF(h(g(nonce1),i)) );\n  send_!SWAP2( Swap, Swap, KDF(h(g(i),nonce1)) );\n }\n\n}"]], "SPDL-1/th-1par2.spdl": [[false, "```houzhui\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,J)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar encrypted_ni: Nonce;\n\n\t\tsend_1(I,J, {P1,I,ni}pk(J) );\n\t\trecv_1b(J,I, {encrypted_ni}pk(I) );\n\t\trecv_2(J,I, {P1,ni,encrypted_ni,J}pk(I) );\n\t\tsend_3(I,J, {P1,encrypted_ni}pk(J) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole J\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh encrypted_ni: Nonce;\n\n\t\trecv_1(I,J, {P1,I,ni}pk(J) );\n\t\tsend_1b(J,I, {encrypted_ni}pk(I) );\n\t\tsend_2(J,I, {P1,ni,encrypted_ni,J}pk(I) );\n\t\trecv_3(I,J, {P1,encrypted_ni}pk(J) );\n\n\t\tclaim_i(J,Nisynch);\n\t}\n}\n```"]], "SPDL-1/tls-BM-1.spdl": [[true, "/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n// Define functions\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\n// Define agents\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\n\n// Define the protocol\nprotocol tls-bm-1(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh nonce_a: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( Alice,Bob, nonce_a );\n\t\trecv_2( Bob,Alice, nb );\n\t\tsend_3( Alice,Bob, { pmk }pk(sk) );\n\t}\n\n\trole Bob\n\t{\n\t\tfresh nonce_b: Nonce;\n\t\tfresh pmk2: Nonce;\n\t\tvar na: Nonce;\n\n\t\trecv_1( Bob,Alice, na );\n\t\tsend_2( Bob,Alice, nonce_b );\n\t\trecv_3( Bob,Alice, { pmk2 }pk(sk) );\n\t}\n}"]], "SPDL-1/wmf-brutus.spdl": [[false, "```\nusertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,Server,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { Server,kab }k(A,S) );\n\t}\n\n\trole Server\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,Server, { A, kab }k(Server,S) );\n\n\t\tclaim_3(Server, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { Server,kab }k(A,S) );\n\t\tsend_2(S,Server, { A, kab }k(Server,S) );\n\t}\n}\n```"]], "SPDL-1/yahalom-ban-paulson.spdl": [[true, "// BAN modified version of the yahalom protocol\n//\n// Modeled as version in Paulson's paper:\n// \"Relations Between Secrets: Two Formal Analyses of the Yahalom\n// Protocol\"\n\nusertype Server;\nusertype SessionKey;\n\nprotocol yahalom-BAN-Paulson(A,B,C)\n{\n\trole A\n\t{\n\t\tfresh nonce_A: Nonce;\n\t\tvar nb: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar key_A_C: SessionKey;\n\n\t\tsend_1(A,B, A,nonce_A);\n\t\trecv_3(C,A, {B,key_A_C,nonce_A,nb}k(A,C), ticket );\n\t\tsend_4(A,B, ticket, {nb}key_A_C );\n\t\tclaim_5(A, Secret,key_A_C);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar nonce_B: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar key_B_C: SessionKey;\n\n\n\t\trecv_2(B,A, {A,nonce_B}k(A,B), nonce_A);\n\t\tsend_2(B,C, {A,nonce_B,nonce_A}k(B,C), key_B_C);\n\t\trecv_3(C,B, {A,nonce_B,nonce_A,nb}k(B,C), ticket );\n\t\tsend_4(B,A, ticket, {nb}key_B_C );\n\t\tclaim_5(B, Secret,key_B_C);\n\t}\n\n\trole C\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar nonce_C: Nonce;\n\t\tvar ticket: Ticket;\n\t\tvar key_C_A: SessionKey;\n\t\tvar key_C_B: SessionKey;\n\n\n\t\trecv_2(C,B, {A,nonce_B,nonce_A}k(B,C), key_C_B);\n\t\trecv_2(C,A, {B,key_C_A,nonce_A,nb}k(A,C), ticket );\n\n\t\tclaim_5(C, Secret,key_C_A);\n\t\tclaim_5(C, Secret,key_C_B);\n\t}\n\n\tinit\n\t{\n\t}\n}"]], "SPDL-1/Authentication_CRCBAC.spdl": [[true, "hashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,A)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var N1:Nonce;secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,A,e,AID,Tr,T1);\n\n        recv_2(A,D,Npr,N1);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,"]], "SPDL-1/andrew-ban-concrete.spdl": [[true, "# BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN2.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# In order to overcome this a 'dummy' role X has been hadded that recrypts\n# a given term crypted with k(I,R) with k(R,I)\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is \n# completely fresh and can therefore always be replaced by an arbitrary value \n# created by the intruder) w\n\nrole I {\n    init {\n        # Send 1\n        send(1, R, k(I, R)(N));\n    }\n    recv(1, R, k(I, R)(N)) {\n        # Send 2\n        send(2, R, k(I, R)(N, k(R, I)(N)));\n    }\n    recv(2, R, k(I, R)(N, k(R, I)(N))) {\n        # Send 3\n        send(3, R, N);\n    }\n    recv(3, R, N) {\n        # Send 4\n\tsend(4, R, k(I, R)(N));\n\t#Claim synchronisation\n\tclaim(sync);\n\n    }\n\trecv(4, R, k(I,R)(N)){\n\n    }\n}\n\nrole R {\n    recv(1, I, k(I, R)(N)) {\n        # Send 5\n        send(5, I, k(R, I)(N));\n    }\n    recv(2, I, k(I, R)(N, k(R, I)(N))) {\n        # Send 6\n        send(6, I, k(R, I)(N));\n    }\n    recv(3, I, N) {\n        # Send 7\n        send(7, I, k(R, I)(N));\n    }\n\trecv(4, I, k(I,R)(N)){\n\t\t#Claim synchronisation\n\t\tclaim(sync);\n\t}\n}\n\nrole X {\n\trecv(2, I, k(I,R)(N, k(R,I)(N))){\n\t\t#Send 8\n\t\tsend(8, I, k(R,I)(N));\n\t}\n}"]], "SPDL-1/andrew.spdl": [[true, "# Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrew.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n\nusertype SessionKey;\nconst succ: Function;\nconst Fresh: Function;\n\nprotocol andrew(I,R)\n{\n    role I\n    {\n        fresh nonce: Nonce;\n        var nr,nr2: Nonce;\n        var key: SessionKey;\n\n        send_1(I,R, I,{nonce}k(I,R) );\n        recv {nr}k(R,I);\n        send_2(I,R, I,{succ(nonce)}k(I,R));\n        recv {nr2}k(R,I);\n    }\n\n    role R\n    {\n        fresh nonce_r: Nonce;\n        var nr, nr2: Nonce;\n        var key_r: SessionKey;\n\n        recv {nonce}k(I,R);\n        send_1(R,I, R,{nonce_r}k(R,I));\n        recv {succ(nonce)}k(I,R);\n        send_2(R,I, R,{succ(nonce_r)}k(R,I));\n    }\n}"]], "SPDL-1/asymmetric-encryption.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh nonce1: Nonce;\n\n\t\tsend_1(Alice,Bob, {Alice,nonce1}pk(Bob) );\n\t\tclaim_i(Alice,Secret,nonce1);\n\t}\n\n\trole Bob\n\t{\n\t\tvar nonce1: Nonce;\n\n\t\trecv_1(Alice,Bob, {Alice,nonce1}pk(Bob) );\n\t\tclaim_r(Bob,Secret,nonce1);\n\t}\n}"]], "SPDL-1/bakatar.spdl": [[false, "```\nhouzhui\n#by louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol bakatar-0(A, B, S) {\n    role A {\n        fresh K: MySecret;\n \n        send_1(A, S, (A, {B, K}k(A, S)));\n        recv_4(S, A, {B, h(K)}k(A, S));\n \n        claim(A, Secret, K);\n        claim(A, Weakagree);\n    }\n    role S {\n        var K: MySecret;\n \n        recv_1(A, S, (A, {B, K}k(A, S)));\n        send_2(S, B, {A, K}k(B, S));\n        recv_3(B, S, (B, {A, h(K)}k(B, S)));\n        send_4(S, A, {B, h(K)}k(A, S));\n    }\n}\n```"]], "SPDL-1/bke-broken.spdl": [[false, "```\n/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n\n\tCMV version with explicit secrecy claims.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkepk(Initiator,Responder)\n{\n\trole Initiator\n\t{\n\t\tconst nonce_1: Nonce;\n\t\tvar NR: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (Initiator,Responder, { nonce_1,Responder }pk(Responder) );\n\t\tread_2 (Responder,Initiator, { hash(nonce_1),NR,Responder,kab }pk(Initiator) );\n\t\tsend_3 (Initiator,Responder, { hash(NR) }kab );\n\t\tclaim_4 (Initiator, Secret, kab );\n\t}\n\n\trole Responder\n\t{\n\t\tconst nonce_2: Nonce;\n\t\tvar NR: Nonce;\n\t\tvar kab: Key;\n\n\t\tread_1 (Responder,Initiator, { nonce_1,Initiator }pk(Initiator) );\n\t\tsend_2 (Responder,Initiator, { hash(nonce_1),nonce_2,Responder,kab }pk(Initiator) );\n\t\tread_3 (Responder,Initiator, { hash(NR) }kab );\n\t\tclaim_5 (Responder, Secret, kab );\n\t}\n}\n```"]], "SPDL-1/boyd-1.spdl": [[true, "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(Alice,Bob,Carol)\n{\n\trole Alice\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nA: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (Alice,Bob, ni );\n\t\trecv_3 (Bob,Alice, { Alice,Bob, ks }k(Alice,Bob), m(ni, m(ks,ni,nA)), _\n\t\t);\n\t\tsend_4 (Alice,Carol, { Alice,Bob, ks }k(Alice,Bob) );\n\t}\n\trole Bob\n\t{\n\t\tfresh nB: Nonce;\n\t\tvar nA: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_1 (Alice,Bob, ni );\n\t\tsend_2 (Bob,Alice, m(ni, m(ks,ni,nB) ) );\n\t\trecv_3 (Alice,Bob, { Alice,Bob, ks }k(Alice,Bob), m(ni, m(ks,ni,nA)), _\n\t\t);\n\t}\n\trole Carol\n\t{\n\t\trecv_4 (Alice,Carol, { Alice,Bob, ks }k(Alice,Bob) );\n\t}\n}"]], "SPDL-1/broken1-1.spdl": [[false, "```\nhouzhui\n/*\n * A broken protocol\n *\n * Cas Cremers\n * Visualization challenge of the week.\n * Can be checked withouth CL, please do so.\n */\n\nusertype String, Key;\nconst PlainSight: String;\nsecret HelloWorld, HelloServer: String;\nsecret k: Key;\n\nprotocol broken1(I,R,S)\n{\n\trole I\n\t{\n\t\tsend_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tsend_2(I, S, {HelloServer, I, S}k );\n\t}\t\n\trole R\n\t{\n\t\trecv_3(I, R, {HelloWorld, I, R, S}k );\n\t\trecv_1(I, R, PlainSight, {HelloWorld, I, R}k );\n\t\tclaim_4(R, Secret, PlainSight);\n\t}\n\trole S\n\t{\n\t\trecv_2(I, S, {HelloServer, I, S}k );\n\t}\n}\n```"]], "SPDL-1/bunava-1-3.spdl": [[true, "role R0\n{\n\tvar T: Ticket;\n\tvar R1,R2: Agent;\n\n\tsend_!1(R0,R1, { T }k(R0,R1) );\n\trecv_!2(R0,R1, { T }k(R1,R0) );\n\tsend_!3(R0,R2, { T }k(R0,R2) );\n\trecv_!4(R0,R2, { T }k(R2,R0) );\n}\n\nrole R1\n{\n\tvar T: Ticket;\n\tvar R0,R2: Agent;\n\n\trecv_!1(R1,R0, { T }k(R0,R1) );\n\tsend_!2(R1,R0, { T }k(R1,R0) );\n\trecv_!3(R1,R2, { T }k(R2,R1) );\n\tsend_!4(R1,R2, { T }k(R1,R2) );\n}\n\nrole R2\n{\n\tvar T: Ticket;\n\tvar R0,R1: Agent;\n\n\trecv_!1(R2,R0, { T }k(R0,R2) );\n\tsend_!2(R2,R0, { T }k(R2,R0) );\n\trecv_!3(R2,R1, { T }k(R1,R2) );\n\tsend_!4(R2,R1, { T }k(R2,R1) );\n}\n}"]], "SPDL-1/carkey-broken-limited.spdl": [[false, "```\nhouzhui\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeybrokenlim(I,R)\n{\n\trole I\n\t{\n\t\tfresh nonce_1: Nonce;\n\n\t\tsend_1(I,R, nonce_1, nonce_1 );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar nonce_1: Nonce;\n\n\t\trecv_1(I,R, nonce_1, nonce_1 );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n```"]], "SPDL-1/carkey-ni2.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,Bob)\n{\n\trole I\n\t{\n\t\tconst nonce_1: Nonce;\n\n\t\tsend_1(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tsend_2(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tclaim_5(I,Nisynch);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar nonce_1: Nonce;\n\n\t\tread_1(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tread_2(I,Bob, {Bob,nonce_1}sk(I) );\n\t\tclaim_4(Bob,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni(Alice,Bob)"]], "SPDL-1/base.spdl": [[true, "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, nonce_1, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, nonce_1)}sk(M);\nmacro Sc = {hash(Customer, IDc, IDm, a, nonce_1, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, nonce_1, t)}sk(Customer);\n\n\nprotocol BaseCaseProtocol(M, C, Customer)\n{\n\trole M\n\t{\n\t\tfresh nonce_1: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, nonce_1, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation\n\t\t*/\n\t\treceive_1 (M, C, nonce_1, Sc);\n\n\t\t/*\n\t\t* Send final confirmation to customer\n\t\t*/\n\t\tsend_2 (M, C, IDt, a, nonce_1, t, Sb);\n\t}\n\trole C\n\t{\n\t\tfresh nonce_1: Nonce;\n\t\tvar t: Timestamp;\n\t\t/*\n\t\t* Receive transaction request from Merchant\n\t\t*/\n\t\treceive_2 (C, M, IDm, a, nonce_1, Sm);\n\n\t\t/*\n\t\t* Process payment and send confirmation\n\t\t*/\n\t\tsend_3 (C, M, nonce_1, Sc);\n\n\t\t/*\n\t\t* Receive final confirmation\n\t\t*/\n\t\treceive_3 (C, M, IDt, a, nonce_1, t, Sb);\n\t}\n\trole Customer\n\t{\n\t\tfresh nonce_1: Nonce;\n\t\tvar t: Timestamp;\n\t}\n}"]], "SPDL-1/ccitt509-3.spdl": [[true, "# CCITT X.509 (3)\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/ccittx509_3.html\n#\n# Note:\n# The protocol description also states that Xa and Ya should be fresh\n# this can not be verified using scyther\n#\n\nusertype Timestamp;\n\nprotocol ccitt509-3(I,J)\n{\n    role I\n    {\n        fresh Ta: Timestamp;\n        var Tb: Timestamp;\n        fresh Na,Xa,Ya: Nonce;\n        var Xb,Nb,Yb: Nonce;\n        send_1(I,J, I,{Ta, Na, Nb, Xa,{Ya}pk(J)}sk(I));\n        recv_2(J,I, I,{Tb, Nb, Xb}pk(I)}sk(J));\n        send_3(I,J, I,{Ta, Na, Xb}pk(J)}sk(I));\n    }\n    role J\n    {\n        fresh Tb: Timestamp;\n        var Ta: Timestamp;\n        fresh Nb,Xb,Yb: Nonce;\n        var Na,Xa,Ya: Nonce;\n        recv_1(J,I, I,{Ta, Na, Nb, Xa,{Ya}pk(J)}sk(I));\n        send_2(J,I, I,{Tb, Nb, Xb}pk(I)}sk(J));\n        recv_3(J,I, I,{Ta, Na, Xb}pk(J)}sk(I));\n    }\n}"]], "SPDL-1/denning-sacco-lowe.spdl": [[true, "# Lowe modified Denning-Sacco shared key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/denningSaccoLowe.html\n#\n# Note:\n# According to SPORE there are no attacks on this protocol. Scyther\n# finds a straightforward pre-play attack on the first message, which\n# violates synchronisation. However, this does not seem to be a\n# practical attack unless consistency is required, e.g., for logging or\n# auditing.\n\nusertype Key;\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\nusertype PseudoFunction;\nconst dec: PseudoFunction;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol denningSacco-Lowe\n\n  init {\n    Alice -> Bob: Fresh(key1: Key);\n    Bob -> Alice: Fresh(key2: Key);\n  }\n\n  run {\n    Alice -> Bob: Fresh(key1: Key, ts: TimeStamp);\n    Bob -> Alice: Fresh(key2: Key, ts: TimeStamp, sessionKey: SessionKey);\n    Alice -> Bob: Fresh(sessionKey: SessionKey, ts: TimeStamp);\n\t}\n\n  // Define the functions\n  function Fresh(key: Key, ts: TimeStamp): bool\n  {\n\t  //Check if the timestamp is fresh\n    ts > 0;\n  }\n\n\n  function Fresh(sessionKey: SessionKey, ts: TimeStamp): bool\n  {\n\t  //Check if the timestamp is fresh\n    ts > 0;\n  }\n\n  function Fresh(key: Key): bool {\n      // In this case, it's assumed that the fresh key is valid.\n      true;\n  }\n\n  // Add a compromised function to check for compromised keys.\n  function Compromised(key: Key): bool {\n    false; // Initially, no key is compromised.\n  }\n\n\n  // Example of how to use a function\n  // to check if a key is valid.\n  function isValidKey(key: Key, compromisedKeys: set of Key): bool {\n    !(key in compromisedKeys)\n  }\n\n  // Add an example of a variable to track compromised keys.\n  var compromisedKeys: set of Key;\n\n\t// Add a rule to update compromisedKeys\n\trule {\n\t\t//If a key is compromised, add it to compromisedKeys\n\t\tif (Compromised(key: Key)) {\n\t\t\tcompromisedKeys = compromisedKeys U {key};\n\t\t}\n\t}\n\n\n  // Add a function for decryption\n  function Decrypt(key: Key, ciphertext: any): any {\n    // Placeholder for decryption logic.  Replace with actual decryption.\n    ciphertext;\n  }"]], "SPDL-1/exchange.spdl": [[false, "```houzhui\n/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar enc_ni: Nonce;\n\n\t\tsend_1(Alice,Bob, {Bob,ni}pk(Bob) );\n\t\trecv_2(Bob,Alice, {ni,enc_ni,Bob}pk(Alice) );\n\t\tsend_3(Alice,Bob, {enc_ni}pk(Bob) );\n\n\t\tclaim_i1(Alice,Secret,ni);\n\t\tclaim_i2(Alice,Secret,enc_ni);\n\t\tclaim_i3(Alice,Nisynch);\n\t}\n\n\trole Bob\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh enc_ni: Nonce;\n\n\t\trecv_1(Alice,Bob, {Bob,ni}pk(Bob) );\n\t\tsend_2(Bob,Alice, {ni,enc_ni,Bob}pk(Alice) );\n\t}\n}\n```"]], "SPDL-1/f4.spdl": [[true, "/*\n * f4.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r4 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f4(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tvar nonce1: Nonce;\n\n\t\trecv_!1(Bob,Alice, nonce1 );\n\t\tsend_!2(Alice,Bob, { nonce1 }sk(Alice) );\n\t\trecv_!3(Bob,Alice, {{{{ nonce1 }sk(Bob)}sk(Bob)}sk(Bob)}sk(Bob) );\n\n\t\tclaim_i1(Alice,Reachable);\n\t}\t\n\n\trole Bob\n\t{\n\t\tfresh nonce1: Nonce;\n\t\tsend_!1(Bob,Alice, nonce1 );\n\t\trecv_!2(Alice,Bob, { nonce1 }sk(Alice) );\n\t\tsend_!3(Bob,Alice, {{{{ nonce1 }sk(Bob)}sk(Bob)}sk(Bob)}sk(Bob) );\n\t}\n}"]], "SPDL-1/f5.spdl": [[false, "```\n/*\n * f5.spdl\n *\n * Tailored protocol to show that any number of runs can be required to\n * find an attack.\n *\n * For this version, -m2 and -r5 are needed.\n *\n * April 2005, Cas Cremers\n */\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol f5(I,J)\n{\n\trole I\n\t{\n\t\tvar nonce1: Nonce;\n\n\t\trecv_!1(J,I, nonce1 );\n\t\tsend_!2(I,J, { nonce1 }sk(I) );\n\t\trecv_!3(J,I, {{{{ { nonce1 }sk(J)}sk(J)}sk(J)}sk(J)}sk(J) );\n\n\t\tclaim_i1(I,Reachable);\n\t}\t\n\n\trole J\n\t{\n\t\tf\n\n\t}\n}\n```"]], "SPDL-1/gong-nonce-1.spdl": [[true, "usertype Sessionkey;\nusertype Keypart;\nsecret k: Function;\n\nprotocol gongnonce(I,R,A)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar n1: Nonce;\n\t\tfresh ki: Keypart;\n\t\tvar kr: Keypart;\n\n\t\tsend_1 (I,R, I,R,ni );\n\t\trecv_3 (A,I, { A,I,R, kr, I, ni }k(I,A), n1);\n\t\tsend_4 (I,A, { I,A,I, ki, R, n1 }k(I,A) );\n\n\t\tclaim_6 (I, Secret, ki);\n\t\tclaim_7 (I, Secret, kr);\n\t\tclaim_8 (I, Nisynch);\n\t\tclaim_9 (I, Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh n1: Nonce;\n\t\tfresh kr: Keypart;\n\t\tvar ki: Keypart;\n\n\t\trecv_1 (R,I, ni );\n\t\tsend_2 (R,I, { R,I,I, kr, R, ni }k(R,I) );\n\t\trecv_4 (R,A, { R,A,R, ki, I,n1 }k(R,A) );\n\t\t\n\t\tclaim_5 (R, Secret, ki);\n\t\tclaim_6 (R, Secret, kr);\n\t\tclaim_7 (R, Nisynch);\n\t\tclaim_8 (R, Niagree);\n\t}\n}"]], "SPDL-1/ikev1-psk-m.spdl": [[false, "```\n# 1 \"ikev1-psk-m.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-psk-m.cpp\"\n# 16 \"ikev1-psk-m.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (Alice, Bob) {\n\n\n\n\n\n\n\n role Alice {\n  var i, r: Nonce;\n\n  recv_!DH1( Alice, Bob, h(g(r),i) );\n  send_!DH2( Alice, Bob, h(g(i),r) );\n }\n\n\n\n\n role Bob {\n  var i, r, Ni, Nr: Nonce;\n\n\n\n\n\n  var Ci, Cr: Nonce;\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( Bob, Alice, prf(k(I,R), Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( Bob, Alice, prf(k(R,I), Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 17 \"ikev1-psk-m\n```"]], "SPDL-1/ikev1-sig-a2.spdl": [[true, "# 1 \"ikev1-sig-a2.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-sig-a2.cpp\"\n# 17 \"ikev1-sig-a2.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n\n\n\n\n\n\n\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, Responder) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role Responder {\n  var i, r, Ni, Nr: Nonce;\n\n\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( Responder, Responder, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( Responder, Responder, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 18 \"ikev1-sig-a2.cpp\" 2\n# 29 \"ikev1-sig"]], "SPDL-1/ikev2-child-nopfs.spdl": [[false, "```\n# 1 \"ikev2-child-nopfs.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-child-nopfs.cpp\"\n# 15 \"ikev2-child-nopfs.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, Client) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role Client {\n  var i, r, nonce, Nr: Nonce;\n# 138 \"common.h\"\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( Client, Client, KDF(k(I,R),nonce,Nr) );\n  send_!SWAP2( Client, Client, KDF(k(R,I),nonce,Nr) );\n\n }\n\n\n}\n# 16 \"ikev2-child\n```"]], "SPDL-1/iso26-tag.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * five-pass\n * mutual\n *\n * MPA Attack reported by Mathuria:\n * - Type flaw MPA when in parallel with Abadi-Needham protocol.\n *\n */\nusertype Tag;\n\nconst t1,t2,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-6-tag(A,B,P)\n{\n\trole A\n\t{\n\t\tvar N1: Nonce;\n\t\tfresh Ra,Rpa: Nonce;\n\t\tvar K1: SessionKey;\n\t\tvar T: Ticket;\n\t\tfresh Text2,Text6,Text7: Ticket;\n\t\tvar Text1,Text4,Text5,Text8,Text9: Ticket;\n\n\t\trecv_1(B,A, N1, Text1);\n\t\tsend_2(A,P, Ra, N1, B, Text2);\n\t\trecv_3(P,A, Text5, {t1, Ra});\n\t\tsend_4(A,B, Rpa, Text5, Text4);\n\t\trecv_5(B,A, Text8, {t1, Rpa});\n\t}\n\n\trole B\n\t{\n\t\tvar N2: Nonce;\n\t\tfresh Rb,Rpb: Nonce;\n\t\tvar K2: SessionKey;\n\t\tvar T: Ticket;\n\t\tfresh Text3,Text6,Text7: Ticket;\n\t\tvar Text1,Text4,Text5,Text8,Text9: Ticket;\n\n\t\tsend_1(B,A, N2, Text3);\n\t\trecv_2(A,B, Rb, N2, A, Text6);\n\t\tsend_3(B,P, Rb, Text6, {t1,t2});\n\t\trecv_4(P,B, Text9, {t2, Rb});\n\t\tsend_5(B,A, Rpb, Text9, Text7);\n\t}\n\n\trole P\n\t{\n\t\tvar N3: Nonce;\n\t\tfresh Rp: Nonce;\n\t\tvar K3: SessionKey;\n\t\tvar T: Ticket;\n\t\tvar Text1,Text2,Text3,Text4,Text5,Text6,Text7,Text8,Text9: Ticket;\n\n\t\trecv_2(A,P, Rp, N3, B, Text2);\n\t\trecv_3(P,A, Text5, {t1, Rp});\n\t\tsend_3(B,P, Rb, Text6, {t1,t2});\n\t\trecv_4(P,B, Text9, {t2, Rb});\n\t}\n\n}"]], "SPDL-1/BCNP-1.spdl": [[false, "```\n/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,A)\n{\n\trole I\n\t{\n\t\tfresh ENCRYPTED_1: Nonce;\n\t\tvar NONCE_1: Nonce;\n\n\t\tsend_Compromise(I,I, ENCRYPTED_1);\n\n\t\tsend_1(I,A, I, { ENCRYPTED_1 }p);\n\t}\n\trole A\n\t{\n\t\tfresh ____(ENCRYPTED_2)____: Nonce;\n\t\tvar ____(NONCE_2)____: Nonce;\n\n\t\trecv_1(A,I, I, { ____(ENCRYPTED_1)____ }p);\n\t\tsend_2(A,I, A, { ____(ENCRYPTED_2)____ }p);\n\t}\n}\n```"]], "SPDL-1/isoiec-9798-2-3.spdl": [[true, "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * two-pass\n * mutual\n *\n * Note: the identity inside the encryption may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n *\n */\nprotocol @keysymm-23(A,B)\n{\n\trole A\n\t{\n\t\tvar nonce1: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { nonce1, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { nonce1, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar nonce1: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(A,B, { nonce1, A, Text }k(A,B) );\n\t\tsend_!2(B,A, { nonce1, B, Text }k(B,A) );\n\t}\n}"]], "SPDL-1/jfki-core.spdl": [[false, "```\n# 1 \"jfki-core.cpp\"\n# 1 \"<command-line>\"\n# 1 \"jfki-core.cpp\"\n# 15 \"jfki-core.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 60 \"common.h\"\nhashfunction H;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, j, Nr: Nonce;\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i), j, Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r), j, Nr) );\n\n }\n\n\n}\n# 16 \"jfki-core.cpp\" 2\n\n\n\nprotocol jfki-core(I, SWAP)\n{\n role I {\n  fresh i, j: Nonce;\n  \n```"]], "SPDL-1/kaochow-v3.spdl": [[true, "# Kao Chow Authentication v.3\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow3.html\n#\n\nusertype SessionKey;\nusertype ExpiredTimeStamp;\nusertype TimeStamp;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow-3(Alice,Bob,Carol)\n{\n    role Alice\n    {\n        fresh nonce1: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n\n        send_1 (Alice,Carol, nonce1);\n        recv_3 (Bob,Alice, {Alice,Bob,nonce1,kir,kt}k(Alice,Carol), {nonce1, kir}kt, nr,\n                {nr,Alice,Bob,nonce1,kir,kt}k(Alice,Carol));\n        send_4 (Alice,Bob,{nr,Alice,Bob,nonce1,kir,kt}k(Alice,Carol), T2);\n        send_5 (Alice,Carol,{T2,Alice}k(Alice,Carol));\n    }\n    role Bob\n    {\n        fresh nonce2: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n        var T1: Ticket;\n\n        recv_2 (Bob,Alice,{Alice,Bob,nonce2,kir,kt}k(Alice,Carol), {nonce2, kir}kt, nr,\n                {nr,Alice,Bob,nonce2,kir,kt}k(Alice,Carol));\n        send_6 (Bob,Alice,{nr,Alice,Bob,nonce2,kir,kt}k(Alice,Carol),T2);\n        recv_7 (Bob,Alice, T1);\n\n    }\n    role Carol\n    {\n        fresh nonce3: Nonce;\n        var nr: Nonce;\n        var kir,kt: SessionKey;\n        var T2: Ticket;\n\n        recv_1 (Carol,Alice,nonce1);\n\n        send_2 (Carol,Bob,{Alice,Bob,nonce1,kir,kt}k(Alice,Carol), {nonce1, kir}kt, nr);\n        recv_4 (Carol,Alice,{nr,Alice,Bob,nonce1,kir,kt}k(Alice,Carol),T2);\n        recv_5 (Carol,Alice,{T2,Alice}k(Alice,Carol));\n    }\n}"]], "SPDL-1/kaochow.spdl": [[true, "# Kao Chow Authentication v.1\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/kaoChow1.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol kaochow(I,R,S)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var n1: Nonce;\n        var k1: SessionKey;\n\n        send_1 (I,S, I,R,ni);\n        recv_3 (R,I, {I,R,ni,k1}k(I,S), {ni}k1, n1 );\n        send_4 (I,R, {n1}k1 );\n\n        claim_I1 (I, Nisynch);\n        claim_I2 (I, Niagree);\n        claim_I3 (I, Kagree);\n    }\n\n    role R\n    {\n        fresh nr: Nonce;\n        var k2: SessionKey;\n        var n2: Nonce;\n\n        recv_1 (R,I, I,R,ni);\n        send_2 (R,I, {R,I,ni,nr}k(R,S), {nr}k2, n2);\n        recv_4 (I,R, {n1}k1 );\n\n        claim_R1 (R, Rsynch);\n        claim_R2 (R, Ragree);\n        claim_R3 (R, Kagree);\n    }\n\n    role S\n    {\n        fresh ks: SessionKey;\n        \n        recv_1 (S,I, I,R,ni);\n        recv_2 (S,R, {R,I,ni,nr}k(R,S), {nr}k2, n2);\n\n        claim_S1 (S, Sagree);\n    }\n\n\n    invariant\n    {\n        Fresh(k1)\n    }\n\n    invariant\n    {\n        Fresh(k2)\n    }\n\n    invariant\n    {\n        Fresh(ks)\n    }\n\n    assumption\n    {\n\n        !Compromised(k1);\n        !Compromised(k2);\n        !Compromised(ks);\n\n    }\n\n\n\n}"]], "SPDL-1/localclaims.spdl": [[true, "/* \n * Local claims\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol localclaims(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh Enc_1: Nonce;\n\n\t\tsend_1(Alice,Bob, {Enc_1}pk(Bob) );\n\n\t\tclaim_i1(Alice,Secret,Enc_1);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tvar Enc_1: Nonce;\n\n\t\trecv_1(Alice,Bob, {Enc_1}pk(Bob) );\n\n\t\tclaim_r1(Bob,Secret,Enc_1);\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information"]], "SPDL-1/needham-schroeder.spdl": [[true, "# Needham Schroeder Public Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nspk.html\n#\n#\n# Note:\n# The modelling in SPORE includes a server to distribute the public keys\n# of the agents, this is not necessary and it allows for attacks against\n# synchronisation and agreement, because the keys that the server sends\n# out can be replayed.\n\nprotocol needhamschroederpk(I,A,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var ENCRYPTED_2: Nonce;\n\n        send_1(I,S,(I,A));\n        recv_2(S,I, {pk(A), A}sk(S));\n        send_3(I,A,(N1,ENCRYPTED_2));\n        recv_4(A,I,{pk(I),N1}sk(A));\n\n    }\n    role A\n    {\n        fresh N2: Nonce;\n        var ENCRYPTED_3: Nonce;\n\n        recv_5(A,I,(N1,ENCRYPTED_2));\n        send_6(A,I, {pk(S),N2}sk(A));\n        recv_7(I,A,{pk(I),N1}sk(A));\n\n\n    }\n    role S\n    {\n        recv_1(S,I,(I,A));\n        send_2(S,I,{pk(A),A}sk(S));\n        recv_5(S,I,(N1,ENCRYPTED_2));\n        recv_6(S,I,{pk(S),N2}sk(A));\n\n    }\n}"]], "SPDL-1/ns3-1.spdl": [[true, "/* \n * Needham-Schroeder protocol\n */\n\n// The protocol description\n\nprotocol ns3(A,R)\n{\n\trole A\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(A,R, {ni,nr}pk(R) );\n\t\trecv_2(R,A, {ni,nr}pk(A) );\n\t\tsend_3(A,R, {nr}pk(R) );\n\n\t\tclaim_i1(A,Secret,ni);\n\t\tclaim_i2(A,Secret,nr);\n\t\t//claim_i3(I,Alive);\n\t\tclaim_i4(A,Niagree);\n\t\tclaim_i5(A,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(A,R, {ni,nr}pk(R) );\n\t\tsend_2(R,A, {ni,nr}pk(A) );\n\t\trecv_3(A,R, {nr}pk(R) );\n\n\t\tclaim_i1(R,Secret,ni);\n\t\tclaim_i2(R,Secret,nr);\n\t\t//claim_i3(I,Alive);\n\t\tclaim_i4(R,Niagree);\n\t\tclaim_i5(R,Nisynch);\n\t}\n}"]], "SPDL-1/nsl3-broken.spdl": [[false, "```\n// The protocol description\n\nprotocol nsl3-broken(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar n1: Nonce;\n\n\t\tsend_1(I,R, {ni}pk(R) );\n\t\trecv_2(R,I, {ni,n1,R}pk(I) );\n\t\tsend_3(I,R, {n1}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,n1);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh n1: Nonce;\n\n\t\trecv_1(I,R, {ni}pk(R) );\n\t\tsend_2(R,I, {ni,n1,R}pk(I) );\n\t\trecv_3(I,R, {n1}pk(R) );\n\t\t\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,n1);\n\t\tclaim_r3(R,Ragree);\n\t\tclaim_r4(R,Rsynch);\n\t}\n}\n```"]], "SPDL-1/onetrace-1.spdl": [[false, "```\nusertype String;\n\nconst Alice,Bob,Charlie: Agent;\nconst Hallo: String;\n\nprotocol onetrace(Alice)\n{\n\trole Alice\n\t{\n\t\tvar input: String;\n\n\t\trecv_!1(Bob,Alice, input);\n\t\tsend_!2(Alice,Bob, Hallo);\n\t\trecv_!3(Alice,Charlie, input);\n\t\tclaim_4(Alice, Secret, input);\n\t}\n}\n```"]], "SPDL-1/otwayrees.spdl": [[true, "# Otway Rees\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/otwayRees.html\n#\n\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nusertype String,SessionKey;\n\nprotocol otwayrees(I,R,A)\n{\n    role I\n    {\n        fresh Ni : Nonce;\n        fresh M : String;\n        var Kir : SessionKey;\n\n        send_1(I,R, M,I,R,{Ni,M,I,R}k(I,A) );\n        recv_4(R,I, M,{Nr,M,R,I}k(I,A) );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        var M : String;\n        fresh Nr : Nonce;\n        send_2(R,I, {Nr,M,R,I}k(I,A) );\n        recv_3(I,R, M,{Ni,M,I,R}k(I,A) );\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n}"]], "SPDL-1/BKE-1.spdl": [[false, "```\n/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar n1: Nonce;\n\t\tvar K: SessionKey;\n\n\t\tsend_1 (Alice,Bob, { ni,n1 }pk(Bob) );\n\t\trecv_2 (Bob,Alice, { hash(ni),n1,Bob,K }pk(Alice) );\n\t\tsend_3 (Alice,Bob, { hash(n1) }K );\n\t\tclaim_4 (Alice, Secret, K );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole Bob\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar K: SessionKey;\n\n\t\trecv_1 (Alice,Bob, { ni,n2 }pk(Bob) );\n\t\tsend_2 (Bob,Alice, { hash(ni),n2,Bob,K }pk(Alice) );\n\t\trecv_3 (Alice,Bob, { hash(n2) }K );\n\t\tclaim_4 (Bob, Secret, K );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n}\n```"]], "SPDL-1/pkmv2rsa.spdl": [[true, "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,KA)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,KA, {msrand, said, MS}sk(MS) );\n\t\n\t}\n\trole KA\n\t{\n\t\tfresh karand: Nonce;\n\t\tvar msrand, said: Nonce;\n\t\tvar MS: Agent;\n\n\t\treceive_rsa1(KA, MS, {msrand, said, MS}sk(MS) );\n\n\t\tsend_rsa2(KA, MS, {karand, MS}sk(KA));\n\t}\n}"]], "SPDL-1/pkmv2satek.spdl": [[true, "/* \n * PKMv2-SA-TEK\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol pkmv2satek(initiator,BS)\n{\n  role initiator\n  {\n    fresh msrand': Nonce;\n    send(msrand',BS);\n    receive(msrand,BS);\n    assert(msrand' = msrand);\n    \n    // ... (other initiator steps)\n  }\n\n  role BS\n  {\n    receive(msrand,initiator);\n    fresh msrand': Nonce;\n    send(msrand',initiator);\n    \n    // ... (other BS steps)\n  }\n}"]], "SPDL-1/protocol0.spdl": [[true, "/* \n * Secrecy protocol\n *\n * Uses asymmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh nonce: Nonce;\n\n\t\tsend_1(Alice,Bob, {Alice,nonce}pk(Bob) );\n\t\tclaim_i(Alice,Secret,nonce);\n\t}\n\n\trole Bob\n\t{\n\t\tvar nonce: Nonce;\n\n\t\trecv_1(Alice,Bob, {Alice,nonce}pk(Bob) );\n\t\tclaim_r(Bob,Secret,nonce);\n\t}\n}"]], "SPDL-1/protocol1.spdl": [[false, "```\n/* \n * Broken protocol\n */\n\n// The protocol description\n\nprotocol protocol1(I,Role1)\n{\n\trole I\n\t{\n\t\tfresh nonce1: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I, Role1, {Role1, nonce1}pk(Role1) );\n\t\t\n\t\trecv_2(Role1, I, {nonce1, nr, Role1}pk(I) );\n\t\t\n\t\tsend_3(I, Role1, {nr}pk(Role1) );\n\n\t\tclaim_i1(I,Secret,nonce1);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Nisynch);\n\t}\n\n\trole Role1\n\t{\n\t\tvar nonce1: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,Role1, {Role1, nonce1}pk(Role1) );\n\t\t\n\t\tsend_2(Role1, I, {nonce1, nr, Role1}pk(I));\n\t}\n}\n```"]], "SPDL-1/rsaplussatek.spdl": [[true, "role MS\n  {\n    fresh msrand, msrand', said: Nonce;\n    fresh ms_private_key: Key;\n    fresh ms_public_key: Key;\n\n    // Generate keys\n\t  generate_key(ms_private_key,ms_public_key);\n\n    // Key exchange\n    send(ms_public_key, K);\n\n    receive(rsa_sig, K);\n    //verify rsa_sig\n    verify_rsa(rsa_sig, ms_public_key, said);\n\n    // Check signature\n    if (verify_rsa(rsa_sig, ms_public_key, said)) {\n      send(msrand, K);\n    }\n    else {\n      // Handle invalid signature (e.g., abort)\n      abort;\n    }\n  }\n\n  role K\n  {\n    fresh krand: Nonce;\n\n    receive(ms_public_key, MS);\n    send(rsa_sig, MS);\n\n    receive(msrand, MS);\n    send(krand, MS);\n  }\n}\n\n// Definitions\n\ngenerate_key(key_priv, key_pub)\n{\n  // Placeholder for key generation logic.  \n  // In a real implementation, this would involve\n  // cryptographic operations to generate a private key\n  // and derive a corresponding public key.\n}\n\nverify_rsa(signature, public_key, message)\n{\n  // Placeholder for RSA signature verification logic.\n  // In a real implementation, this would involve\n  // using the RSA algorithm to verify the signature.\n  // Return true if the signature is valid, false otherwise.\n  // This is a simplified example; a complete implementation\n  // would need to handle various error conditions.\n  return true; // Replace with actual verification logic\n}\n\n// Types\n\ntype Key;\ntype Nonce;"]], "SPDL-1/simplest-1.spdl": [[false, "```\nsecret k: Nonce;\n\nprotocol simplest(Alice)\n{\n\trole Alice\n\t{\n\t\tvar x: Nonce;\n\t\tfresh nonce_1: Nonce;\n\n\t\trecv_!1(Alice,Bob, x);\n\t\tsend_!2(Alice,Bob, nonce_1, {nonce_1, x}k );\n\t\tclaim_3(Alice, Secret, nonce_1);\n\t}\n}\n```"]], "SPDL-1/smartright.spdl": [[true, "# SmartRight view-only\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/smartright_viewonly.html\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n# Note:\n# Scyther finds an attack because the value of VoR in te last message can\n# be replaced with an arbitrary value\n\nhashfunction hash;\nusertype SessionKey;\nusertype XorKey;\nconst Vor: XorKey;\n\nprotocol smartright(Alice,Bob)\n{\n    role Alice\n    {\n        fresh key1: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var nonce1: Nonce;\n\n        send_1(Alice,Bob, {key1, VoR, CW, nonce1});\n        receive_1(Alice,Bob, {x});\n    }\n\n    role Bob\n    {\n        fresh key2: SessionKey;\n        fresh VoR: XorKey;\n        fresh CW;\n        var nonce2: Nonce;\n\n        send_2(Bob,Alice, {key2, VoR, CW, nonce2});\n        receive_2(Bob,Alice, {x});\n    }\n    \n    constraint\n    {\n        key1 == key2;\n    }\n}"]], "SPDL-1/speedtest-1.spdl": [[false, "```\nhouzhui\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ns3speedtest(I,J)\n{\n\trole I\n\t{\n\t\tfresh nonce_1: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,J, {I,nonce_1}pk(J) );\n\t\trecv_2(J,I, {nonce_1,nr}pk(I) );\n\t\tsend_3(I,J, {nr}pk(J) );\n\t\tclaim_4(I,Secret,nr);\n\t}\t\n\t\n\trole J\n\t{\n\t\tvar nonce_1: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,J, {I,nonce_1}pk(J) );\n\t\tsend_2(J,I, {nonce_1,nr}pk(I) );\n\t\trecv_3(I,J, {nr}pk(J) );\n\t\tclaim_5(J,nr);\n\t}\n}\n```"]], "SPDL-1/splice-as-hc.spdl": [[true, "# Hwang and Chen Modified SPLICE/AS\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/spliceas2.html\n#\n\n\nusertype TimeStamp, LifeTime;\n\nconst inc,dec: Function;\ninversekeys (inc,dec);\n\nprotocol spliceAS-HC(I,R,S)\n{\n        role I\n    {\n        fresh N1,N2: Nonce;\n        fresh T1: TimeStamp;\n        fresh L: LifeTime;\n\n        send_1(I,S,  I, R, N1 );\n        recv_2(S,I,  S, {S, I, N1, R, pk(R)}sk(S) );\n        send_3(I,R,  I, R, {I, T1, L, {N2}pk(R)}sk(I) );\n \n    }\n        role S\n    {\n        fresh N3:Nonce;\n        fresh T2:TimeStamp;\n        fresh L2:LifeTime;\n        recv_1(S,I,  I, R, N3 );\n        send_4(S,I,  S, I, {S,I,N3,R,pk(R)}sk(S) );\n        recv_5(S,R,  R, {I, T2, L2, {N2}pk(R)}sk(I) );\n        send_6(S,R,  S, R, {I, T2, L2, {N2}pk(R)}sk(R));\n    }\n\n\trole R\n\t{\n        fresh N4:Nonce;\n\t\trecv_3(R,I,  I, R, {I, T1, L, {N2}pk(R)}sk(I) );\n    }\n\n}"]], "SPDL-1/SR3.spdl": [[true, "hashfunction H;\nusertype Key;\n\nprotocol sr3(Alice,Bob)\n{\n\n\trole Alice\n\t{\n\t\tfresh nonce: Nonce;\n\t\tfresh ticket:Ticket;\n\t\tsend_1(Alice,Bob,{ticket,nonce}k(Alice,Bob),H(nonce),Alice);\n\t\trecv_2(Bob,Alice,nonce,Alice);\n\t\t\n\t\tclaim_V1(Alice, Niagree);\n\t\tclaim_V2(Alice, Secret, ticket);\n\t\tclaim_V3(Alice, Secret, k(Alice,Bob));\n\t\tclaim_V4(Alice, Nisynch);\n\t\tclaim_V5(Alice, Secret, nonce);\n\t}\n\n\trole Bob\n\t{\n\t\tvar ticket:Ticket;\n\t\tvar nonce:Nonce;\n\t\trecv_1(Alice,Bob,{ticket,nonce}k(Alice,Bob),H(nonce),Alice);\n\t\tsend_2(Bob,Alice,nonce,Bob);\n\t\t\n\t\tclaim_V1(Bob, Niagree);\n\t}\n}"]], "SPDL-1/bkepk-ce-1.spdl": [[true, "/* \n\tBilateral Key Exchange with Public Key protocol (bkeCE)\n\n\tVersion from Corin/Etalle: An Improved Constraint-Based System for the Verification of Security Protocols.\n\tTried to stay as close as possible to compare timing results.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ na,B }pk(A) );\n\t\tsend_2 (A,B, { hash(na),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, {hash(na),na,A,kab}sk(B));\n\t}\n\trole B\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh kab: Key;\n\t\t\n\t\tsend_1 (A,B, { nb,A }pk(B) );\n\t\trecv_2 (A,B, { hash(nb),nb,B,kab }pk(A) );\n\t\tsend_3 (B,A, {hash(nb),nb,B,kab}sk(A));\n\t}\n}"]], "SPDL-1/sts-mac.spdl": [[false, "```\n# 1 \"sts-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-mac.cpp\"\n# 16 \"sts-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, NONCE_1: Nonce;\n\n  recv_!DH1( DH, DH, h(g(NONCE_1),i) );\n  send_!DH2( DH, DH, h(g(i),NONCE_1) );\n }\n\n\n\n\n role SWAP {\n  var i, NONCE_1, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(NONCE_1),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),NONCE_1)) );\n\n }\n\n\n}\n# 17 \"sts-mac.cpp\" 2\n\n\n\n\n\n\n\nprotocol @executability(DH) {\n\n\n role DH {\n\n }\n\n\n}\n```"]], "SPDL-1/th-1seq2.spdl": [[false, "```\nhouzhui\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th3(Alice,Bob)\n{\n\trole Alice\n\t{\n\t\tfresh ni,ni2: Nonce;\n\t\tvar nr,encrypted_2: Nonce;\n\n\t\tsend_1(Alice,Bob, {P1,Alice,ni}pk(Bob) );\n\t\trecv_1b(Bob,Alice, {nr}pk(Alice) );\n\t\trecv_2(Bob,Alice, {P1,ni,nr,Bob}pk(Alice) );\n\t\tsend_3(Alice,Bob, {encrypted_1}pk(Bob) );\n\n\t\t//claim_i(I,Nisynch);\n\n\t\tsend_21(Alice,Bob, {P2,Alice,ni2}pk(Bob) );\n\t\trecv_21b(Bob,Alice, {encrypted_2}pk(Alice) );\n\t\trecv_22(Bob,Alice, {P2,ni2,encrypted_2}pk(Alice) );\n\n\t}\n\n\trole Bob\n\t{\n\t\tfresh nb,nb2: Nonce;\n\t\tvar na,encrypted_1: Nonce;\n\n\t\trecv_1(Bob,Alice, {P1,Alice,na}pk(Bob) );\n\t\tsend_1b(Alice,Bob, {nb}pk(Bob) );\n\t\tsend_2(Bob,Alice, {P1,na,nb,Bob}pk(Alice) );\n\t\trecv_3(Alice,Bob, {encrypted_1}pk(Bob) );\n\n\t\t//claim_i(I,Nisynch);\n\n\t\trecv_21(Bob,Alice, {P2,Alice,nb2}pk(Bob) );\n\t\tsend_21b(Alice,Bob, {encrypted_2}pk(Bob) );\n\t\tsend_22(Bob,Alice, {P2,nb2,encrypted_2}pk(Alice) );\n\t}\n}\n```"]], "SPDL-1/tmn-2.spdl": [[false, "```houzhui\nusertype Key;\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys(pk,sk);\n\nprotocol tmn(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh Ka: Key;\n\t\tvar Kb: Key;\n\n\t\tsend_1(A,S, B,{Ka}pk(S) );\n\t\trecv_4(S,A, B,{Kb}Ka );\n\n\t\tclaim_5(A,Secret,Ka);\n\t\tclaim_8(A,Secret,Kb);\n\t}\t\n\t\n\trole B\n\t{\n\t\tfresh Kb: Key;\n\n\t\trecv_2(S,B, A );\n\t\tsend_3(B,S, A, { Kb }pk(S) );\n\n\t\tclaim_6(B,Secret,Kb);\n\t}\n\n\trole S\n\t{\n\t\tvar Ka,Kb: Key;\n\n\t\trecv_1(A,S, B,{Ka}pk(S) );\n\t\tsend_2(S,B, A );\n\t\trecv_3(B,S, A, { Kb }pk(S) );\n\t\tsend_4(S,A, B, {Kb}pk(S));\n\t}\n}\n```"]], "SPDL-1/unknown2.spdl": [[false, "```\nusertype SessionKey;\nsecret k: Function;\n\nprotocol unknown2(Alice,Bob,Carol)\n{\n\trole Alice\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar n2: Nonce;\n\t\tvar key: SessionKey;\n\t\tvar T;\n\n\t\tsend_1(Alice,Bob, ni );\n\t\trecv_3(Carol,Alice, { Alice,Bob,key,ni,n2 }k(Alice,Carol), T );\n\t\tsend_4(Alice,Bob, T, {n2}key );\n\n\t\tclaim_i1(Alice,Nisynch);\n\t\tclaim_i2(Alice,Niagree);\n\t\tclaim_i3(Alice,Secret, key);\n\t}\t\n\t\n\trole Bob\n\t{\n\t\tfresh n2: Nonce;\n\t\tvar ni: Nonce;\n\t\tvar key: SessionKey;\n\n\t\trecv_1(Bob,Alice, ni );\n\t\tsend_2(Bob,Carol, { Bob,Alice,key,ni,n2 }k(Bob,Carol) );\n\t\trecv_4(Bob,Alice, T, {n2}key );\n\n\t\tclaim_i1(Bob,Nisynch);\n\t\tclaim_i2(Bob,Niagree);\n\t\tclaim_i3(Bob,Secret, key);\n\t}\n\t\n\trole Carol\n\t{\n\t\tfresh n2: Nonce;\n\t\tvar ni: Nonce;\n\t\tvar key: SessionKey;\n\n\t\trecv_2(Carol,Bob, { Bob,Alice,key,ni,n2 }k(Bob,Carol) );\n\t\tsend_3(Carol,Alice, { Alice,Bob,key,ni,n2 }k(Alice,Carol), T );\n\n\t\tclaim_i1(Carol,Nisynch);\n\t\tclaim_i2(Carol,Niagree);\n\t}\n}\n```"]], "SPDL-1/void.spdl": [[true, "# By Louis\nhashfunction h;\nusertype SessionKey;\nusertype MySecret;\n \nprotocol void-0(Alice, Bob, Server) {\n    role Alice {\n        fresh nonce: Nonce;\n        fresh K: MySecret;\n       \n        send_1(Alice, Server, (nonce, Alice, Bob, pk(Alice), {h(nonce, Alice, Bob, pk(Alice))}k(Alice, Server)));\n        recv_4(Server, Alice, (Bob, {nonce, pk(Bob)}k(Alice, Server), {h(nonce, Bob, pk(Bob))}k(Alice, Server)));\n        send_5(Alice, Bob, {nonce, K}pk(Bob));\n        recv_6(Bob, Alice, {h(nonce, Bob, pk(Bob))}k(Alice, Server));\n    }\n    role Bob {\n        recv_2(Server, Bob, (Alice, {nonce, pk(Alice)}k(Bob, Server), {h(nonce, Alice, pk(Alice))}k(Bob, Server)));\n        send_3(Bob, Server, (Alice, Bob, {h(nonce, Alice, Bob, pk(Alice))}k(Bob, Server)));\n    }\n    role Server {\n        recv_1(Alice, Server, (nonce, Alice, Bob, pk(Alice), {h(nonce, Alice, Bob, pk(Alice))}k(Alice, Server)));\n        send_4(Server, Alice, (Bob, {nonce, pk(Bob)}k(Alice, Server), {h(nonce, Bob, pk(Bob))}k(Alice, Server)));\n        recv_3(Bob, Server, (Alice, Bob, {h(nonce, Alice, Bob, pk(Alice))}k(Bob, Server)));\n    }\n}"]], "SPDL-1/wmf.spdl": [[true, "# Wide Mouthed Frog\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wideMouthedFrog.html\n#\n# Note\n# The name of the party that has generated a message was added in order\n# to model the property described in SPORE that an agent can identify\n# its own messages and will reject them.\n\nusertype SessionKey;\nusertype TimeStamp;\nusertype ExpiredTimeStamp;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol wmf(I,R,ROLE_1)\n{\n    role I\n    {\n        fresh KEY_1: SessionKey;\n        fresh Ti: TimeStamp;\n        var Kr: SessionKey;\n\n        send_1(I,ROLE_1, I, {I, Ti, R, KEY_1});\n        receive_1(I,ROLE_1, R, {R, Tr, I, Kr});\n        \n\t\t//Check Freshness\n\t\tif (Fresh(KEY_1))\n\t\t{\n\t\t\t//Check Time Validity\n\t\t\tif (Ti > Tr) \n\t\t\t{\n\t\t\t\t//Check if the key is compromised\n\t\t\t\tif (!Compromised(Kr))\n\t\t\t\t{\n\t\t\t\t\t//Accept the message\n\t\t\t\t\tassert(Kr = KEY_1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treject;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treject;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treject;\n\t\t}\n    }\n    role R\n    {\n        fresh Tr: TimeStamp;\n\t\tfresh Kr: SessionKey;\n        receive_2(R,ROLE_1, I, {I, Ti, R, KEY_1});\n        send_2(R,ROLE_1, I, {R, Tr, I, Kr});\n    }\n}"]], "SPDL-1/woo-lam.spdl": [[true, "# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,Role)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var K1: SessionKey;\n        var EncN1: Nonce;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, EncN1);\n        send_3(I,R, {I, R, N1, EncN1}k(I,Role));\n        recv_6(R,I, {R, N1, EncN1, K1}k(I,Role), {N1,EncN1}k(R,Role));\n    }\n    role R\n    {\n        fresh N2: Nonce;\n        var K2: SessionKey;\n        var EncN2: Nonce;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, EncN2);\n        recv_3(I,R, {I, R, N1, EncN2}k(I,Role));\n        send_6(R,I, {R, N1, EncN2, K2}k(I,Role),{N1,EncN2}k(R,Role));\n    }\n}"]], "SPDL-1/woolam-pi-f.spdl": [[false, "```\n/*\n * Woo-lam version from Spore, Pi f\n *\n * Only one-way verification version\n */\n\nusertype Server, SessionKey, Ticket;\nsecret k: Function;\n\nconst Simon: Server;\n\nconst ke: SessionKey;\n\nprotocol woolampif(A,B,Server)\n{\n\trole A\n\t{\n\t\tvar nonce_a: Nonce;\n\n\t\tsend_1(A,B, A);\n\t\trecv_2(B,A, nonce_a);\n\t\tsend_3(A,B, { A,B,nonce_a }k(A,Server) );\n\t}\n\n\trole B\n\t{\n\t\tfresh nonce_b: Nonce;\n\t\tvar T: Ticket;\n\n\t\trecv_1(A,B, A);\n\t\tsend_2(B,A, nonce_b);\n\t\trecv_3(A,B, T);\n\t\tsend_4(B,Server, { A,B,nonce_b, T }k(B,Server) );\n\t\trecv_5(Server,B, { A,B,nonce_b }k(B\n```"]], "SPDL-1/yahalom-ban-1.spdl": [[true, "# BAN simplified version of Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalomBAN.html\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol yahalom-BAN(I,R,A)\n{\n    role I\n    {\n        fresh N: Nonce;\n        var E: Nonce;\n        var T: Ticket;\n        var K: SessionKey;\n\n        send_1(I,R, I,N);\n        recv_3(A,I, E, {R,K,N}k(I,A), T );\n        send_4(I,R, T, {E}K );\n\n    }\n\n    role R\n    {\n      recv_1(R,I, I,N);\n      send_2(R,I, {N}k(R,I));\n      recv_4(R,I, T, {E}K);\n    }\n\n    role A\n    {\n\n    }\n\n\n}"]], "SPDL-1/yahalom.spdl": [[true, "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(Alice,Bob,Carol)\n{\n    role Alice\n    {\n        fresh N1: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var K1: SessionKey;\n\n        send_1(Alice,Bob, Alice,N1);\n        recv_3(Carol,Alice, {Bob,K1,N1,Nr}k(Alice,Carol), T );\n        send_4(Alice,Bob, T, {Nr}K1 );\n\n        claim_I1(Alice, Secret,K1);\n    }\n\n    role Bob\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var T: Ticket;\n        var K1: SessionKey;\n\n        recv_1(Alice,Bob,Alice,N1);\n        send_2(Bob,Alice,N2);\n        recv_5(Bob,Alice, {Alice,K1,N1,N2}k(Bob,Alice), T);\n        send_6(Bob,Alice, T, {N2}K1);\n\n        claim_I2(Bob, Secret,K1);\n    }\n\n    role Carol\n    {\n        fresh N3: Nonce;\n        var N1: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var K1: SessionKey;\n\n        recv_3(Alice,Carol, {Bob,K1,N1,Nr}k(Alice,Carol), T );\n        send_7(Carol,Alice, N3);\n\n\n        claim_I3(Carol, Secret,K1);\n    }\n\n    \n}"]]}