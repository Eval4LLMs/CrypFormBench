{"MAUDE-1/Denning-Sacco.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sort Msg .\n  sort Fresh .\n  sort Public .\n  sort Client .\n  sort Server .\n  subsort Client Client < Msg .\n  subsort Server Server < Msg .\n  subsort Fresh < Msg .\n  subsort Public < Msg .\n\n\n  op clientReq : -> Client [ctor] .\n  op serverResp : -> Server [ctor] .\n  op freshNonce : -> Fresh [ctor] .\n  op publicInfo : -> Public [ctor] .\n\n\n\n  op _and_ : Msg Msg -> Msg [assoc comm id:true] .\n endfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Rules for the protocol\n  --- Example rules\n  op clientReqAndFreshNonce : Client Fresh -> Msg [ctor] .\n  vars C : Client F : Fresh .\n  rl [clientReq-freshNonce]:\n      clientReq -> clientReqAndFreshNonce(C, F) .\n  rl [serverResp-publicInfo]:\n      serverResp -> serverRespAndPublicInfo(publicInfo) .\n  op serverRespAndPublicInfo : Public -> Server [ctor] .\n  vars P : Public .\nendfm"]], "MAUDE-1/maa-crc.maude": [[false, "```\nfmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [ctor] .\n  op Xtrue : -> Xbool [ctor] .\n  op x0 : -> Bit [ctor] .\n  op x1 : -> Bit [ctor] .\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet [ctor] .\n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Half Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Key Message -> Pair [ctor] .\n  op buildMessage : SegmentedMessage -> Message [ctor] .\n  op buildSegmentedMessage : BlockSum -> SegmentedMessage [ctor] .\n  vars O1 O2 O3 O4 : Octet .\n  vars B1 B2 B3 B4 : Bit .\n  vars K : Key .\n  vars M : Message .\n  vars S : SegmentedMessage .\n\n\n  op concatOctet : Octet Octet -> Octet [assoc comm id: buildOctet(x0, x0, x0, x0, x0, x0, x0, x0)] .\n  op concatOctetSum : OctetSum OctetSum -> OctetSum [assoc comm id: buildOctetSum(x0,buildOctet(x0, x0, x0, x0, x0, x0, x0, x0))] .\n  op concatHalf : Half Half -> Half [assoc comm id: buildHalf(buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0))] .\n  op concatHalfSum : HalfSum HalfSum -> HalfSum [assoc comm id: buildHalfSum(buildHalf(buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0)), buildHalf(buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0)))] .\n  op concatBlock : Block Block -> Block [assoc comm id: buildBlock(buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0))] .\n\n  op concatBlockSum : BlockSum BlockSum -> BlockSum [assoc comm id: buildBlockSum(x0,buildBlock(buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0), buildOctet(x0, x0, x0, x0, x0, x0, x0, x0)))] .\n\n\n\n  \n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Half Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n\n  \n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Key Message -> Pair [ctor] .\n  op buildMessage : SegmentedMessage -> Message [ctor] .\n  op buildSegmentedMessage : BlockSum -> SegmentedMessage [ctor] .\n\n\n\n\n  \nendfm\n``````\nmaude\n```\nOK.\n```"]], "MAUDE-1/AU_and_A_UnificationEdgeCases.maude": [[true, "fmod ASSOC-LIST-TESTS is\n  protecting ASSOC-LIST .\n\n  op test1 : -> Bool .\n  eq test1 = true .\n\n  op test2 : -> Bool .\n  eq test2 = unify(P =? A B /\\ X P =? P Y) .\n  \n  op test3 : -> Bool .\n  eq test3 = unify(P =? A B /\\ X P =? P Y , X=nil) .\n  \n  op test4 : -> Bool .\n  eq test4 = unify(P =? A B /\\ X P =? P Y , X=cons(E,nil)) .\n  \n  op test5 : -> Bool .\n  eq test5 = unify(P =? A B /\\ X P =? P Y , A=cons(E,nil), B=cons(F,nil)) .\n\n  op test6 : -> Bool .\n  eq test6 = unify(A=cons(E,nil), B=cons(F,nil) , X=cons(G,nil) , P=cons(G,nil)) . \n  \n  op test7 : -> Bool .\n  eq test7 = unify( P =? A B /\\ X P =? P Y , A=nil , B=nil , X=nil, P=nil ) .\n  \n  op test8 : -> Bool .\n  eq test8 = unify( P =? A B /\\ X P =? P Y , A=nil , B=nil , X=nil, P=cons(E,nil) ) .\n  \n  op test9 : -> Bool .\n  eq test9 = unify( P =? A B /\\ X P =? P Y , A=cons(E,nil) , B=cons(F,nil) , X=cons(G,nil) , P=cons(G,cons(E,nil)) ) .\n\n  op rev-test1 : -> Bool .\n  eq rev-test1 = rev(cons(E,cons(F,nil))) = cons(F,cons(E,nil)) .\n\n  op rev-test2 : -> Bool .\n  eq rev-test2 = rev(nil) = nil .\n\n  op rev-test3 : -> Bool .\n  eq rev-test3 = rev(cons(E,nil)) = cons(E,nil) .\n  \n  op test10 : -> Bool .\n  eq test10 = unify( P =? A B /\\ X P =? P Y , A=nil , B=nil , X=nil , P=nil ) .\n  \nendfm\n\nfmod MAIN is\n  protecting ASSOC-LIST-TESTS .\n  \n  op main : -> Unit .\n  eq main = \n    (test1)\n    (test2)\n    (test3)\n    (test4)\n    (test5)\n    (test6)\n    (test7)\n    (test8)\n    (test9)\n    (test10)\n    (rev-test1)\n    (rev-test2)\n    (rev-test3) .\nendfm"]], "MAUDE-1/AU_IrredUnification.maude": [[true, "***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op _(_)_ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\nvars X Y Z : Foo .\nvars A B C : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ Z /\\ W Y =? A /\\ B /\\ C  =? A /\\ B /\\ C .\n\n*** test with more variables\nirred unify X =? Y X /\\ Z /\\ W Y =? A /\\ B /\\ C  =? A /\\ B /\\ C .\n\n\n*** test with more variables and different terms\nirred unify X =? Y X /\\ Z /\\ W Y =? a /\\ b /\\ c =? a /\\ b /\\ c .\n\n*** test with more variables and different terms, with 1\nirred unify X =? Y X /\\ Z /\\ W Y =? 1 /\\ 1 /\\ 1 =? 1 /\\ 1 /\\ 1 .\n\n\n*** test with different terms and variables\nirred unify X =? Y X /\\ Z /\\ W Y =? a /\\ b /\\ c =? a /\\ b /\\ c .\n\n\nred unify (a /\\ b) =? (b /\\ a) ."]], "MAUDE-1/bank.maude": [[false, "```\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Account Id Int -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .\n\top deposit : Account Int -> Msg [ctor].\n\top withdraw : Account Int -> Msg [ctor].\n\top checkBalance : Account -> Msg [ctor].\n\top transfer : Account Account Int -> Msg [ctor].\n\n\top initial : -> State [ctor] .\n\top accountCreated : Account -> State [ctor].\n\top depositProcessed : Account Int -> State [ctor].\n\top withdrawProcessed : Account Int -> State [ctor].\n\top checkBalanceProcessed : Account Int -> State [ctor].\n\top transferProcessed : Account Account Int -> State [ctor].\n\n\top init : -> State [ctor] .\n\tvars A1 A2 : Account .\n\tvar I : Int .\n\teq initial = init .\n\n    op balance : Account -> Int .\n    eq balance(<ID|BAL|STS>) = BAL .\n\n    op status : Account -> Status .\n    eq status(<ID|BAL|STS>) = STS .\n\n\n    op apply : State Msg -> State .\n\n    \n    eq apply(initial, deposit(A1, I)) = depositProcessed(A1, I) .\n\teq apply(depositProcessed(A1, I), deposit(A2,I)) = depositProcessed(A1,I) .\n\n\n    eq apply(accountCreated(<ID|BAL|active>), deposit( <ID|BAL|active> ,I)) = depositProcessed(<ID|BAL|active>,I) . \n\teq apply(depositProcessed(<ID|BAL|active>,I), deposit( <ID|BAL|active> ,I)) = depositProcessed(<ID|BAL|active>,I) .\n\n\nendfm\n```"]], "MAUDE-1/bike.maude": [[true, "EL-CONFIGURATION .\n\n    *** Group of polynomials sigma that can be sampled\n    op sigma : Content -> Content .\n\n    *** Group of messages m that can be sampled\n    op ms : Identifier -> Content .\n\n    *** Group of polynomials h that can be sampled; They come in pairs\n    op hs : Pair -> Content .\n\n    *** Operator to assign a polynomial 'sigma' to a participant\n    op sigmaI : Identifier Polynomial -> Identifier .\n\n    *** Operator to assign a message to a participant\n    op mI : Identifier Polynomial -> Identifier .\n\n    *** Operator to assign a random pair of hs to a participant\n    op assignHs : Identifier Pair -> Identifier .\n\n    ***\n    *** INITI"]], "MAUDE-1/closeSocketFeb2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that closing a server TCP socket that is waiting\n***\tto accept connections doesn't cause Maude to spin its wheels\n***\twaiting for events on the closed socket.\n***\nload socket\n\nmod SERVER-SHUTDOWN is\n        protecting SOCKET .\n        op Server : -> Cid [ctor] .\n        op server : -> Server [ctor] .\n        op state:_ : Server -> Attribute [ctor] .\n\n        sort ServerState .\n        ops init closing : -> ServerState [ctor] .\n        op  accepting    : Cid -> ServerState [ctor] .\n\n    var C : Cid .\n    var Reason : String .\n        rl [createdS]\n            server(S) -> state(S, init)\n        where\n            not(S = nil) .\n\n        rl [startAccepting]\n            state(S, init) -> state(S, accepting(C))\n        where\n            C = Server .\n\n        rl [closeServer]\n            state(S, accepting(C)) -> state(S, closing)\n        where\n            true .\n\n        rl [serverClosed]\n            state(S, closing) -> state(S, init)\n        where\n            true .\n\n        vars S : Server .\nendm\n\nmod SERVER-SHUTDOWN-TEST is\n        protecting SERVER-SHUTDOWN .\n\n        op test : -> Bool .\n\n        rl [test-case]\n            test -> true\n        where\n            S = Server .\n\nendm"]], "MAUDE-1/complexParserSyncApril2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, true), none, '0, 'Nat) .\nred metaParse(upModule('NAT, false), none, '1, 'Nat) .\nred metaParse(upModule('NAT, true), none, '1, 'Nat) .\n\n\nred metaParse(upModule('NAT, ____(EQ_1)____), none, '0, ____(EQ_0)____) .\n\nop EQ_0 : -> Nat .\nop EQ_1 : -> Bool .\n\neq EQ_0 = 0 .\neq EQ_1 = true .\n\n\nendm"]], "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Foo [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab ."]], "MAUDE-1/CUIbug12-22-09.maude": [[true, "mod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl c => d .\n\n  op stackable : Foo -> Bool .\n  eq stackable(a) = false .\n  eq stackable(b) = true .\n  eq stackable(c) = true .\n  eq stackable(d) = false .\n  eq stackable(g(X)) = stackable(X) .\n  eq stackable(f(X,Y)) = stackable(X) and stackable(Y) .\n\n\n  op unstackable : Foo -> Bool .\n  eq unstackable(a) = true .\n  eq unstackable(b) = false .\n  eq unstackable(c) = false .\n  eq unstackable(d) = true .\n  eq unstackable(g(X)) = unstackable(X) .\n  eq unstackable(f(X,Y)) = unstackable(X) or unstackable(Y) .\n\n\n  op rewriteable : Foo -> Bool .\n  eq rewriteable(a) = false .\n  eq rewriteable(b) = true .\n  eq rewriteable(c) = true .\n  eq rewriteable(d) = false .\n  eq rewriteable(g(X)) = rewriteable(X) .\n  eq rewriteable(f(X,Y)) = rewriteable(X) or rewriteable(Y) .\n  \n  op stack : Foo -> Set[Foo] .\n  eq stack(a) = {} .\n  eq stack(b) = {c} .\n  eq stack(c) = {d} .\n  eq stack(d) = {} .\n  eq stack(g(X)) = {X} .\n  eq stack(f(X,Y)) = stack(X) union stack(Y) .\n  \n  op unstack : Foo -> Set[Foo] .\n  eq unstack(a) = {a} .\n  eq unstack(b) = {} .\n  eq unstack(c) = {} .\n  eq unstack(d) = {d} .\n  eq unstack(g(X)) = {g(X)} .\n  eq unstack(f(X,Y)) = unstack(X) union unstack(Y) .\n\n\n  crl [rewrite-f]\n      f(X,Y)\n  when\n      rewriteable(X) and rewriteable(Y)\n  to\n      f(X,Y) .\n\n\n  crl [unstack-f]\n      f(X,Y)\n  when\n      unstackable(X) and unstackable(Y)\n  to\n      f(X,Y) .\n\n  crl [rewrite-b]\n      b\n  when\n      rewriteable(b)\n  to\n      c .\n\n\n  crl [rewrite-c]\n      c\n  when\n      rewriteable(c)\n  to\n      d .\nendm\n\nrew f(a, g(b)) ."]], "MAUDE-1/CUI_OccursCheckSeptember2020.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for nontermination in U and CU unification due to\n***\tnot doing an indirect occurs check. We use irred because\n***\twe might reduce the number of redundant unifiers in the\n***\tfuture.\n***\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f(Foo, Foo) : Foo -> Foo [id: 1] .\nvars A B X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, X) =? f(X, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(X, Y)  .\nirred unify X =? f(f(f(X, Y), X), Z) .\n\nred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, X) =? f(X, B) .\nred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(X, Y)  .\nred unify X =? f(f(f(X, Y), X), Z) .\n\nendm\n```"]], "MAUDE-1/CU_Unification.maude": [[true, "set show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [left id] .\n  op 1f : -> Foo .\n\n  vars U V W X Y : Foo .\nendfm\n\nunify f(1f, Y) =? f(U, 1f) .\nvariant unify f(X, Y) =? f(U, 1f) .\n\nunify f(1f, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, 1f) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [right id] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunif"]], "MAUDE-1/Needham_Schroeder_Lowe.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- O\n  sorts Msg Fresh Public Key Secret.\n  subsorts Fresh < Msg.\n  subsorts Public < Key.\n  subsorts Secret < Key.\n  op pk : Key Msg -> Msg [assoc comm id: _].\n  op sk : Key Msg -> Msg.\n  op _ ; _ : Msg Msg -> Msg [assoc id: _].\n  \n  --- Encryption/Decryption Rules\n  eq pk(K, sk(K, M)) = M.\n  eq sk(K, pk(K, M)) = M.\n  \n  op n : -> Fresh [memo].\n  op b : -> Public [memo].\n  op a : -> Public [memo].\n  op na : -> Fresh [memo].\n  op nb : -> Fresh [memo].\n  \n  --- Protocol messages\n  op m1 : -> Msg [memo].\n  op m2 : -> Msg [memo].\n  op m3 : -> Msg [memo].\n  \n  --- Defining the protocol messages in terms of the primitives\n  eq m1 = pk(b, a ; na).\n  eq m2 = pk(a, na ; nb ; b).\n  eq m3 = pk(b, nb).\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS.\n  \n  ----------------------------------------------------------\n  --- Rules for the protocol\n  \n  rl [step1] :\n    -- Agent A sends a message to agent B.\n    -> <A, pk(b, a ; na)>.\n\n  rl [step2] :\n    -- Agent B receives a message from agent A.\n    <B, pk(a, na ; nb ; b)> -> <B, na ; nb ; b>.\n\n  rl [step3] :\n    -- Agent B sends a message to agent A.\n    <B, na ; nb ; b> -> <A, pk(b, nb)>.\n\nendfm"]], "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude": [[false, "```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .\n\nmod NAT is\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  vars N M : Nat .\n  eq s(N) =? s(M) = N =? M .\n  eq 0 =? N = false .\nendm\n\nmod TEST-UNIFIER-FILTERING is\n  protecting NAT .\n\n  sort Event .\n  ops start stop : -> Event .\n  op unify : Nat Nat -> Event .\n\n\n  vars N M : Nat .\n\n  rl [unify-filter] :\n    unify(N,N) -> stop\n    .\n  rl [unify-filter-fail] :\n    unify(N,M) -> start\n    where N =/= M .\n\nendm\n\nred unify(s(0),s(0)) .\nred unify(0,0) .\nred unify(s(0),0) .\n\n-- Example of using the filtered variant\n\nred unify(s(s(0)), s(s(0))) .\nred unify(s(s(0)), s(0)) .\n\n\n-- These tests are for checking the behaviour of the protocol with various inputs.  The expected output is that the `unify(N,M)` rule fires if N and M are different and `unify(N,N)` rule fires if N and M are the same.  The output should be `stop` for equal inputs and `start` for unequal inputs.\n\n\n-- You may add more tests with different values for N and M to cover various cases, including degenerate cases.\n```"]], "MAUDE-1/dekker.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory [ctor] .\nendfm\n\n***(\nEquality test comparing the content\n)\n\nfmod EQ is\n  inc INT .\n  inc QID .\n  inc MEMORY .\n  sort Boolean .\n  op true : -> Boolean .\n  op false : -> Boolean .\n  op _=_ : Int Int -> Boolean .\n  op [_=_]: Qid Int Int -> Boolean .\n  vars I1 I2 : Int .\n  var M : Memory .\n  var Q : Qid .\n  eq I1 = I2 = true if I1 = I2 .\n  eq I1 = I2 = false if I1 <> I2 .\n  eq [Q = I1] = I2 = true if [Q = I1] [Q = I2] .\n  eq [Q = I1] = I2 = false if [Q = I1] <> [Q = I2] .\nendfm\n\n***(\nA specification of Dekker's algorithm.\n)\n\nfmod DEKKER is\n  inc INT .\n  inc QID .\n  inc MEMORY .\n  inc EQ .\n  \n  sort State .\n  op init : -> State .\n  op next : State State -> Boolean .\n  op _[_] : State Qid -> Int .\n\n  op lock1 : State -> State .\n  op lock2 : State -> State .\n  op unlock1 : State -> State .\n  op unlock2 : State -> State .\n\n  ***(\n  The initial state.\n  )\n  op init : -> State\n   = none .\n\n  ***(\n  The next state function.\n  )\n\n  op next : State State -> Boolean\n    [memo] .\n\n  ***(\n  The memory accesses.\n  )\n  op _[_] : State Qid -> Int\n    [memo] .\n\n  ***(\n  The lock operations.\n  )\n  op lock1 : State -> State\n   = ____()___ .\n  op lock2 : State -> State\n   = ____()___ .\n  op unlock1 : State -> State\n   = ____()___ .\n  op unlock2 : State -> State\n   = ____()___ .\n\n  ***(\n  Auxiliary functions for states.\n  )\n\n\nendfm\n\n```"]], "MAUDE-1/deleteTimerMarch2021.maude": [[false, "```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where deleteTimer() left the interpreter in an\n***\tinconsistent state and caused a crash on the next rewrite\n***\tcommand.\n***\n\nload time\n\nmod TEST is\n  inc TIME .\n  op myClass : -> Cid .\n  ops me : -> Oid .\n\nvars O O2 O3 : Oid .\n  rl < O : myClass | none > createdTimer(O, O2, O3) =>\n     < O : myClass | none > deleteTimer(O3, me) .\nendm\n\nerew <> < me : myClass | none > createTimer(timeManager, timeManager) .\nred 0 .\n```"]], "MAUDE-1/dining-philosophers5.maude": [[true, "fmod TIME-INF is\n  protecting NAT-RAT .\n\n  sort TimeInf .\n  op INF : -> TimeInf [ctor] .\n  sort NNegRat .\n\n  op 0 : -> NNegRat [ctor] .\n  op _+_ : NNegRat NNegRat -> NNegRat [assoc comm id: 0] .\n  op _*_ : NNegRat NNegRat -> NNegRat [assoc comm id: 1] .\n  op _/_ : NNegRat NNegRat -> NNegRat .\n  op _-<_ : NNegRat NNegRat -> NNegRat .\n  op _<--_ : NNegRat NNegRat -> NNegRat .\n\n  vars R1 R2 : NNegRat .\n  op min : TimeInf TimeInf -> TimeInf [assoc comm id: INF] .\n  op max : TimeInf TimeInf -> TimeInf [assoc comm id: INF] .\n\n  eq min(INF, TI) = TI .\n  eq min(TI, INF) = TI .\n  eq max(INF, TI) = INF .\n  eq max(TI, INF) = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  eq min(TI, TI) = TI .\n  eq max(TI, TI) = TI .\n\n  --- Add these equations for completeness (example)\n  eq 2 + 3 = 5 .\n  eq 2 * 3 = 6 .\n  eq 6 / 3 = 2 .\n  eq 5 - 2 = 3 .\n  eq 5 <-- 2 = 3 .\n\n\n  op _<_ : TimeInf TimeInf -> Bool [ctor] .\n  op _<=_ : TimeInf TimeInf -> Bool [ctor] .\n  op _>_ : TimeInf TimeInf -> Bool [ctor] .\n  op _>=_ : TimeInf TimeInf -> Bool [ctor] .\n\n  op _+_ : TimeInf NNegRat -> TimeInf [ctor] .\n  op _+_ : NNegRat TimeInf -> TimeInf [ctor] .\n  op _+_ : TimeInf TimeInf -> TimeInf [ctor] .\n  op _+_ : NNegRat NNegRat -> NNegRat [ctor] .\n\n  vars R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n  eq TI + R = TI + R .\n  eq R + TI = TI + R .\n\nendfm"]], "MAUDE-1/diophantine.maude": [[false, "```\nmaude\nset show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector, \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1),\n\"gcd\"\n) .\n\n*** Example protocol analysis (incomplete)\n\n***  This example shows a simple protocol with two processes.\n***  Process 0 sends a message to process"]], "MAUDE-1/doubleAttributeFebruary2023.maude": [[true, "fmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [assoc comm id: nil] .\nendfm\n\nmod FOO-IMPL is\n  protecting FOO .\n  vars X : Foo .\n  op f_impl : Foo -> Foo .\n  eq f_impl(nil) = nil .\n  eq f_impl(X) = f(f_impl(X)) .\nendm\n\nmod FOO-TEST is\n  protecting FOO-IMPL .\n  vars X : Foo .\n  rl f_impl(X) -> f(X) .\nendm"]], "MAUDE-1/Example1.maude": [[true, "mod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(0))),\n                    (lookup:   lookupnow(\n                                     ('X : v(0))\n                                   )\n                    ),\n                    (endc:     const(v(0)))\n                  )\n                ) .\n\n vars X : V .\n vars i : Nat .\n vars v : Val .\n\n ***\n ***(\n Definition of LookUpNow(X).\n ***)\n\n op lookupnow(X:V) : Val [memo].\n eq lookupnow(X) = Sigma(i,X) .\n\n ***\n ***(\n Definition of Sigma(i,X).\n ***)\n\n op Sigma(i:Nat,X:V) : Val .\n eq Sigma(i,X) = v(i) .\n\n\n ***\n ***(\n Example of a possible value v(i) for Sigma(i,X).\n ***)\n\n eq Sigma(0,X) = v(0) .\n eq Sigma(1,X) = v(1) .\n eq Sigma(2,X) = v(2) .\n \n ***\n ***(\n Examples for the possible values of X.\n ***)\n \n eq Sigma(i,X) = v(i) [owise] .\n\n\nendm"]], "MAUDE-1/Example3.maude": [[true, "mod EXAMPLE3 is\n protecting PLEXILITE-PREDS .\n\n op Example3 : -> Plexil .\n eq Example3 = assignment(\n                 'N,\n                 'x,\n                 'LookUpNow('X)\n             ) .\n\n op StartCondition : -> Bool .\n eq StartCondition = LookUpOnChange('X,5) >= 9 .\n\n op LookUpOnChange(X Int, i Int) : -> Int .\n eq LookUpOnChange(X,i) = Gamma(i,X) .\n\n op LookUpNow(X) : -> Int .\n eq LookUpNow(X) = Gamma(i,X) .\n\n op Gamma(i Int, X Int) : -> Int .\n eq Gamma(i, X) = if StartCondition then Sigma(i,X) else Gamma(i-1,X) fi .\n\n op Sigma(i Int, X Int) : -> Int .\n eq Sigma(i, X) = 1 .\n\n\n vars I X : Int .\n eq Gamma(0, X) = 11 .\n\n eq Sigma(I,X) = 8.\n\n eq Gamma(1,X) = 11 .\n \n\n endm"]], "MAUDE-1/fakeParameterConstant.maude": [[true, "***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op a : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> Elt [pconst] .\n  op X$c : -> Elt .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all ."]], "MAUDE-1/fakeParameterSort.maude": [[true, "***\n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < X$Elt .\n  op foo : X$Elt -> X$Foo [ctor] .\n  vars X$x : X$Elt .\n  eq foo(X$x) = X$x .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\n  op bar : Y$Foo -> Y$Elt [ctor] .\n  vars Y$y : Y$Foo .\n  eq bar(Y$y) = Y$y .\nendfm\n\nmod MAIN is\n  inc FOO{Nat} .\n  inc BAR{Int} .\n  op main : -> Bool .\n  eq main = true .\nendm\n\nred main .\nshow all ."]], "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Operations for the protocol\n  sorts Msg Fresh Public Key SecretNonce.\n  op pk(Public,Msg) : Msg [ctor].\n  op sk(Secret,Msg) : Msg [ctor].\n  op nonce : -> Fresh [ctor].\n  op genkey : -> Public [ctor].\n  op gensecret : -> Secret [ctor].\n  op extractNonce : Msg -> Fresh [assoc comm id: nonce].\n  op extractPublic : Msg -> Public [assoc comm id: genkey].\n  op extractSecret : Msg -> Secret [assoc comm id: gensecret].\n\n  vars M N : Msg.\n  var K : Public.\n  var A B : Fresh.\n\n  --- Defining the protocol messages\n  op A_to_B_1 : -> Msg [ctor].\n  op B_to_A_1 : -> Msg [ctor].\n  op A_to_B_2 : -> Msg [ctor].\n  \n  eq pk(K,sk(K,M)) = M.\n  eq sk(K,pk(K,M)) = M.\n  \n  --- Message extraction functions (Important for NPA)\n  eq extractNonce(nonce()) = nonce().\n  eq extractPublic(pk(K,M)) = K.\n  eq extractSecret(sk(K,M)) = K.\n    \n    \n  eq extractNonce(A_to_B_1) = nonce().\n  eq extractPublic(A_to_B_1) = genkey().\n  \n  eq A_to_B_1 = pk(genkey(B), nonce() ; genkey(A)).\n  eq B_to_A_1 = pk(genkey(A), nonce() ; nonce() ; genkey(B)).\n  eq A_to_B_2 = pk(genkey(B), nonce()).\n  \n  \n  --- additional operations\n  op ; : Msg Msg -> Msg [assoc comm id: M].\n  op _ ; _ : Fresh Fresh -> Fresh [assoc comm id: nonce].\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Security properties (Example: freshness)\n  op fresh : Msg -> Bool .\n  eq fresh(A_to_B_1) = true.\n  eq fresh(B_to_A_1) = true.\n  eq fresh(A_to_B_2) = true.\n  \nendfm"]], "MAUDE-1/filteredVariantUnifyJune2023.maude": [[true, "set show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0  : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat Stk -> Stk [ctor] .\n  op _ ++ _ : Stk Stk -> Stk [assoc comm id: emp] .\n  op append : Nat Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : Nat .\n  vars S T : Stk .\n  eq append(X,S) = mk(X, S) .\n  eq [sub] : (s(X) * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK\n\nmod SUB-STACK-TESTS is\n  protecting SUB-STACK .\n\n  op test1 : -> Bool .\n  eq test1 = (mk(0, mk(1, emp)) ++ mk(2, emp)) = append(0, append(1, append(2, emp))) .\n\n  op test2 : -> Bool .\n  eq test2 = (mk(0, mk(1, emp)) ++ mk(2, emp)) = (mk(2, emp) ++ mk(0, mk(1, emp))) .\n\n  op test3 : -> Bool .\n  eq test3 = (append(0, append(1, append(2, emp)))) = append(1, append(0, append(2, emp))) .\n\nendm\n\nred test1 .\nred test2 .\nred test3 .\n\nendm"]], "MAUDE-1/generatedByFebruary2023.maude": [[true, "***\n***\tTest that generated-by is recognized as ending the previous mixfix statement.\n***\n\nfmod FOO is\n  pr NAT .\n  eq 5 = 1 .\nendfm\n\nshow desugared ."]], "MAUDE-1/hf-sets.maude": [[true, "---- This is the Maude code for HF-SETS ----\nfmod HF-SETS is\n  protecting BOOL-OPS .\n  sorts Magma Set .\n  subsort Set < Magma .\n  op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n  op { } : Magma -> Set [ctor] .\n  op {} : -> Set [ctor] .\n\n  vars M M' : Set              vars S S' T : Set .\n\n  ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n  eq [01]: M, M = M .\n\n  op _in_ : Magma Set -> Bool .   *** set membership for several elements\n  eq [11]: M in {} = false .\n  eq [12]: S in {S'} = S = S' .\n  eq [13]: S in {S', M} = (S = S') or (S = M) .\nendfm\n\nfmod HF-SETS-TEST is\n  protecting HF-SETS .\n\n  op test1 : -> Bool .\n  eq test1 = {1} in {1} .\n\n  op test2 : -> Bool .\n  eq test2 = {1} in {2} .\n\n  op test3 : -> Bool .\n  eq test3 = 1 in {1,2} .\n\nendfm\n\nmod HF-SETS-TEST-EXEC is\n  protecting HF-SETS-TEST .\n\n  op main : -> String .\n  eq main = \n    (test1)\n   + (test2)\n   + (test3)\n    .\nendm\n\n---- END OF THE MAUDE CODE ----"]], "MAUDE-1/identityUnificationMay2020.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in C/U/Ul/Ur unification where original\n***\trather than representative variable was used.\n***\n\nfmod FOO is\n  sort Small Foo .\n  subsort Small < Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc comm] .\n  op g : Foo -> Foo .\n  op h : Foo -> Foo .\nvars X Y Z : Foo .\nvar S : Small .\nendfm\n\nred unify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nvariant unify Z =? f(X, Y) /\\ g(Z) =? g(S) .\n```"]], "MAUDE-1/instantiatedViewInternalNameOctober2022.maude": [[false, "```\nmaude\nset show advisories off .\n\n***\n***\tTest for bug in the internal name of a multiply instantiated view which\n***\tbecomes visible because parameterized sorts instantiated with this view\n***\tappear to be different from the same sorts created by the parser.\n***\nfmod FOO{X :: STRICT-WEAK-ORDER} is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{X}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{X}} .\n  op b : X -> X .\n  vars X : X .\n  eq b(X) = X .\nendfm\n\nshow kinds .\n\nfmod BAR is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op c : Int -> Int .\n  vars I : Int .\n  eq c(I) = I + 1 .\nendfm\n\nshow kinds .\n\nmod MAIN is\n  protecting FOO{Int} .\n  protecting BAR .\n  \n  op test : -> Bool .\n  eq test = true .\nendm\n\nred test .\n\nendm\n```"]], "MAUDE-1/instantiationJuly2019.maude": [[true, "set show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\n*** make op a to b .\n*** incorrectly specialize to op a : -> Small to b .\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred f(b) ."]], "MAUDE-1/initialEqualityPredicate.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\nfmod DECOMPOSE is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sorts Nat String .\n  op 0 : -> Nat .\n  ops f g : Nat Nat -> Nat [ctor] .\n  ops h i : Nat Nat -> String [ctor] .\n  op c : Nat Nat -> Nat [comm] .\n  ops b : Nat Nat -> Nat [assoc comm id: 0] .\n  op sum : Nat -> Nat [iter] .\n  vars W X Y Z : Nat .\n  vars A B C : String .\n  eq sum(0) = 0 .\n  eq sum(f(X,Y)) = sum(X) + sum(Y) .\n  eq sum(g(X,Y)) = sum(X) + sum(Y) .\n  eq sum(c(X,Y)) = sum(X) + sum(Y) .\n  eq sum(b(X,Y)) = sum(X) + sum(Y) .\n  eq sum(X) + 0 = sum(X) .\n  eq 0 + sum(X) = sum(X) .\nendfm\n\nred X .=. X .\nred X .=. X .\n\n*** free\nred f(X, Y) .=. f(Y, Z) .\nred f(X, Y) .=. f(Z, X) .\nred f(X, Y) .=. f(X, X) .\nred f(X, Y) .=. f(Y, X) .\n```"]], "MAUDE-1/irredUnifyFeb2021.maude": [[false, "```houzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug irredundant unification where destructive updating\n***\tof unifiers having the same structure but different sorts caused\n***\tcorruption of unification filter and irredundant unifiers lost\n***\tto spurious subsumptions.\n***\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt Pair < List .\n  op [] : -> List [ctor] .\n  op _ _ : List Elt -> List [assoc comm] .\n  op _ : Pair -> Triple [assoc] .\n  op _ , _ : Pair Pair -> Triple [assoc] .\n  op nil : -> List [ctor] .\n\n  op append : List List -> List [assoc comm] .\n  op empty : -> List [ctor] .\n  op cons : Elt List -> List [ctor] .\n  op _ _ : Pair Pair -> Triple [assoc] .\n\n  op ____(OP_8)____ : List -> List .\n  vars L1 L2 : List .\n  eq ____(OP_8)____(L1) = L1 .\n  eq append(L1, L2) = L1 .\n  eq append(L1, empty) = L1 .\n  vars E1 E2 : Elt .\n  vars P1 P2 : Pair .\n  vars T1 T2 : Triple .\n  eq append(cons(E1, L1), L2) = cons(E1, append(L1, L2)) .\n  eq append(empty, L2) = L2 .\n  \n  op emptyList : -> List [ctor] .\n  op cons : Elt List -> List [ctor] .\n  op _ _ : List Elt -> List [assoc comm] .\n  op _ : Pair -> Triple [assoc] .\n  op _ , _ : Pair Pair -> Triple [assoc] .\n  op [] : -> List [ctor] .\n\n  op ____(OP_8)____ : List -> List .\n  vars L1 L2 : List .\n  eq ____(OP_8)____(L1) = L1 .\n\n\n\nendfm.\n```"]], "MAUDE-1/kindNameDecember2022.maude": [[true, "set show advisories off .\n\n***\n***\tTest for bug where kinds were printed incorrectly from premodules.\n***\n\nfmod FOO{X :: TRIV} is\n  sorts S{X} T{X} .\n  subsort S{X} < S{X} T{X} .\n  subsort T{X} < S{X} T{X} .\n  op f : S{X} T{X} -> S{X} T{X} .\nendfm\n\nshow mod ."]], "MAUDE-1/lattice.maude": [[true, "----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----\n----"]], "MAUDE-1/nsl-db-dc.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n\n  op init-nsl-msg : -> Msg [ctor].\n  op resp-nsl-msg : -> Msg [ctor].\n  op init-db-msg : -> Msg [ctor].\n  op resp-db-msg : -> Msg [ctor].\n\n\n  vars M : Msg .\n  vars F : Fresh .\n  vars P : Public .\n  vars G : GhostData .\n\n  --- Initial message for NSL\n  op init-nsl-message : -> Msg [ctor] .\n  --- Response message for NSL\n  op resp-nsl-message : -> Msg [ctor] .\n  --- Initial message for DB\n  op init-db-message : -> Msg [ctor] .\n  --- Response message for DB\n  op resp-db-message : -> Msg [ctor] .\n\n\n\n  --- Example actions\n  --- You should add all your actions here\n  op send-init-nsl : Role -> Msg [ctor] .\n  op send-resp-nsl : Role -> Msg [ctor] .\n  op send-init-db : Role -> Msg [ctor] .\n  op send-resp-db : Role -> Msg [ctor] .\n\n\n  --- Example protocol rules (replace with your own)\n  --- Add more rules as needed\n    rl [init-nsl-rule] :\n      send-init-nsl(init-nsl) -> init-nsl-message .\n    rl [resp-nsl-rule] :\n      send-resp-nsl(resp-nsl) -> resp-nsl-message .\n    rl [init-db-rule] :\n      send-init-db(init-db) -> init-db-message .\n    rl [resp-db-rule] :\n      send-resp-db(resp-db) -> resp-db-message .\n    \n    \n  --- Add more rules for sending and receiving messages\n  --- based on your protocol's requirements.\n\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\nprotecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n--- Rules for message passing and protocol execution.\n--- Placeholder rules. Replace with your specific rules.\n\nendfm"]], "MAUDE-1/legacyMetaGetVariant.maude": [[false, "```\nElem\n  X\n  Y\n  Z\n  cst1 cst2 cst3 cst4 : Elem .\n\n  subsort Elem < XOR .\n  op _+_ : XOR XOR -> XOR [assoc comm] .\n  op 0 : -> XOR .\n  op a : -> XOR .\n\n  vars X Y Z : XOR .\n\n\n  eq Y + 0 = Y [variant] .\n  eq X + X = 0 [variant] .\n  eq X + X + Y = Y [variant] .\nendfm\n\nfmod TEST is\n  inc XOR .\n  inc META-LEVEL .\nendfm\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(upModule('XOR, false), upTerm(X:XOR + cst1), empty, 0, 0) .\n\nred metaGetVariant(['XOR], upTerm(X:XOR + cst1), empty, 10, 0) .\n\nred metaGetVariant(['XOR'], upTerm(cst1 + cst2), empty, 0, 0) .\n```"]], "MAUDE-1/mapToParameterTheory.maude": [[true, "fmod T is\n  sort Elt .\n  op _+_ : Elt Elt -> Elt .\n  vars X Y : Elt .\n  eq X + Y = Y + X .  *** commutative law\n  eq X + 0 = X .   *** 0 is the neutral element\n  eq X + s(Y) = s(X + Y) .  *** s(Y) means Y+1.\n  op 0 : -> Elt .  *** zero\n  op s : Elt -> Elt .\n  op ____(OP_18)____ : Elt -> Elt .\n  eq s(X) = X + 1 .\nendfm\n\nfmod T2 is\n  sort Elt2 .\n  op _+_ : Elt2 Elt2 -> Elt2 .\n  op 0 : -> Elt2 .\n  op s : Elt2 -> Elt2 .\n  vars X Y : Elt2 .\n  eq X + Y = Y + X .\n  eq X + 0 = X .\n  eq X + s(Y) = s(X + Y) .\n  op ____(OP_18)____ : Elt2 -> Elt2 .\nendfm\n\nfmod M{X :: T} is\n  sort Elt .  *** corrected sort to Elt\n  op ____(OP_19)____ : X$Elt -> X$Elt .  *** corrected to X$Elt\n  var X : X$Elt .\n  eq g(X) = X + X .  *** corrected to X + X\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .   *** mapping fromTheory sort to parameterTheory sort\n  *** _+_ in fromTheory is implicitly mapped to _+_ in parameterTheory\nendv\n\nfmod C is\n  sort Bar .\n  op _+_ : Bar Bar -> Bar .  *** corrected operator name\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\n  op _+_ to summation .\nendv\n\nfmod M2{Y :: T2} is\n  op h : Y$Elt2 Y$Elt2 -> Y$Elt2 .\n  vars X Y : Y$Elt2 .\n  eq h(X, Y) = X + Y .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all ."]], "MAUDE-1/metaApplyNov2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\treduction of the subject are not counted twice for\n***\tmetaApply()/metaXapply()\n***\n\nmod APPLY is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  ops a c  : -> Bar .\n  op b : -> Foo .\n  op f : Bar Foo -> Foo [assoc comm id: b] .  \n\n  eq a = c .\n  mb c : Foo .\n  rl f(X:Foo, Y:Foo) => X:Foo [label k] .\nendm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo < 'b.Foo) .\nred in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0)"]], "MAUDE-1/metaAutoOoIncludeFebruary2023.maude": [[true, "set show timing off .\n\n***\n***\tTest that auto object-oriented includes show up in the unflattened result of upModule().\n***\n\nmod FOO is\n  protecting NAT .\n  sort Foo .\n  op foo : -> Foo [ctor] .\n  op bar : Foo -> Nat [ctor] .\n\n  vars N : Nat .\n  op test : Foo -> Nat .\n  eq test(foo) = 0 .\n  eq test(bar(X)) = X + 1 .\n\n  op show : Foo -> String .\n  eq show(foo) = \"foo\" .\n  eq show(bar(N)) = \"bar(\" ++ show(N) ++ \")\" .\nendm\n\nred in META-LEVEL : upModule('FOO, false) ."]], "MAUDE-1/metaIntMatchOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that mb applications and eq rewrites for the initial\n***\tsort computations in the subject are not counted twice for\n***\tmetaMatch()/metaXmatch()/getMatch()/getXmatch().\n***\n\nfmod MATCH is\n  sorts Foo Bar .\n  subsorts Foo < Bar .\n  op f : Foo Bar -> Bar [assoc comm id: b] .  \n  ops g h : Foo -> Foo .\n  ops a b c d e : -> Foo .\n\nvars X Y : Bar .\nvar Z : Foo .\n\n  cmb f(X, Y) : Foo if h(X) = g(Y) .\n  eq h(a) = b .\n  eq g(c) = b .\n  eq h(c) = d .\n  eq g(a) = d .\nendfm\n\nset trace on .\nset show breakdown on .\n\nred in META-LEVEL : metaMatch(['MATCH f(a,c)]) ."]], "MAUDE-1/multiset-algebra.maude": [[false, "```\nset include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  ---- protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars N M K : Nat .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n  ---- protecting NAT .\n\n  ---- TRUTH\n  op if_then_else_fi : Bool Mult Mult -> Mult [strat (if_then_else_fi 2 3 0)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n  ---- TRUTH\n\n  sort Mult .\n  subsort Nat Mult .\n  op _+_ : Mult Mult -> Mult [comm assoc id: 0] .\n  op _*_ : Mult Mult -> Mult [comm assoc id: 1] .\n  op _-_ : Mult Mult -> Mult [assoc comm id: 0] .\n\n\nendfm\n\nfmod PROTOCOL is\n  protecting MULTISET-ALGEBRA .\n  sort Event .\n  op a : -> Event .\n  op b : -> Event .\n  op send : Event -> Event [strat (send 1)].\n  op recv : Event -> Event [strat (recv 1)].\n  op _|_ : Event Event -> Event [comm assoc id: 0].\n\n  op init : -> Event .\n  op _| : Event Event -> Event [comm assoc id: init].\n  op _||_ : Event Event -> Event [comm assoc id: init].\n\n  vars E F : Event.\n  eq init | E = E | init .\n\nendfm\n\nfmod PROTOCOL-SPEC is\n  protecting PROTOCOL .\n\n  op p : -> Event .\n  op q : -> Event .\n  eq p | q = q | p .\n\nendfm\n\nfmod TEST-PROTOCOL is\n  protecting PROTOCOL-SPEC .\n  vars E F : Event.\n\n  op test : -> Event .\n    eq test = p | q .\nendfm\n\n```\n```maude\n```"]], "MAUDE-1/numbers-ACU-proofs.maude": [[false, "```\nNzNat\n  sort NzNat .\n  op 0 : -> NzNat [ctor] .\n  op s : NzNat -> NzNat [ctor] .\n  op gcd : NzNat NzNat -> NzNat [assoc comm id: 1] .\n  op quot : NzNat NzNat -> NzNat .\nendfm\n\nmod PROOFS is\n  pr BOOL .\n  pr RAT-ACU .\n  vars N' M' : NzNat .\n  eq gcd(1, 1) = 1 .\n  eq quot(N', 1) = N' .\n  eq - (I:Int / J:Int) = - I:Int / J:Int .\n  eq - - I:Int = I:Int .\n  eq gcd(N', M') > 1 = tt .\nendfm\n\n---(\nred -(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == - 1 / @2:NzNat .\n---(\nrewrites: 13 in 0ms cpu (270833 rewrites/second)\nresult Bool: true\n---)\n\nred -(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == - (N':NzNat + M':NzNat) / @2:NzNat .\n---(\nrewrites: 6 in 0ms cpu (0ms real) (93750 rewrites/s)\nresult Bool: true\n---)\n```"]], "MAUDE-1/objectMessageOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that object-message rewriting fake rewrites are ignored\n***\tby trace/break/profile code.\n***\n\nmod FOO is\n  inc CONFIGURATION .\n  op User : -> Cid .\n  ops me other : -> Oid .\n  op no-op : Oid Oid -> Msg [msg] .\n\nvars X Y : Oid .\nvar AS : AttributeSet .\n  rl < X : User | AS >  no-op(X, Y) => < X : User | AS > .\nendm\n\nset break on .\nbreak select no-op .\n\nset trace on .\nset trace whole on .\nset profile on .\n\nfrew < me : User | none > no-op(me, other) .\n\n*** we expect a single break to debugger\nresume .\n\nshow profile ."]], "MAUDE-1/opRenamingParseErrorMarch2023.maude": [[true, "fmod FOO is\n  sorts Foo to .\n  op f : String -> Foo .\nendfm\n\nfmod BAR is\n  inc FOO * (op rename : Foo to -> Foo to String) .\nendfm\n\nshow desugared ."]], "MAUDE-1/operatorNames.maude": [[false, "```\nhouzhui\n***\n***\tCheck that strange operator names print correctly in awkward places.\n***\n\nfth T is\n  sort Elt .\n  op ({_}:{_}) : Elt Elt -> Elt .\n  op {a}to{_} : Elt Elt -> Elt .\n  op two to : -> Elt .\n  op ([:]) : -> Elt .\nendfth\n\nfmod M is\n  sort Elt .\n  op term{_,_} : Elt Elt -> Elt .\n  op {b}.{_} : Elt Elt -> Elt .\n  op term{} : -> Elt .\n  op }.{ : -> Elt .\nendfm\n\nview V from T to M is\n  op ({_}:{_}) to (term{_,_}) .\n  op ({_}to{_}) to ({b}.{_}) .\n  op (two to) to (term{}) .\n  op ([:]) to (}.{) .\nendv\n\nfth T2 is\n  inc T * (op ({_}:{_}) to (f[_,_]),\n           op ({_}to{_}) to (_,_),\n           op (two to\n```"]], "MAUDE-1/signed_dh.maude": [[false, "```\n***)\nfmod PROTOCOL is\n  protecting NAT .\n  protecting XOR .\n\n  sort Msg .\n  op A B : -> Msg .\n  op exp : Msg Nat -> Msg [assoc comm id: 1].\n  op sign : Msg Msg -> Msg .\n  op secret : Msg Msg -> Msg .\n  op e : Msg Msg -> Msg .\n  op d : Msg Msg -> Msg .\n\n\n  vars N_A N_B : Nat .\n  var M : Msg .\n  var K : Msg .\n\n  crl [exp_assoc] :\n    exp(exp(X, Y), Z) -> exp(X, Y * Z).\n\n  crl [dec_enc] :\n    e(K, d(K, M)) -> M .\n  crl [enc_dec] :\n    d(K, e(K, M)) -> M .\n\n  op verify : Msg Msg Msg -> Bool .\n  eq verify(A, sign(A, M), M) = true .\n\n  op honest : Msg -> Bool .\n    eq honest(A) = true .\n    eq honest(B) = true .\n\n\n  rl [A_to_B] :\n     A --> B : A ; B ; exp(g, N_A) ; sign(A, B ; exp(g, N_A)) .\n\n  rl [B_to_A] :\n     B --> A : A ; B ; exp(g, N_B) ; sign(B, A ; exp(g, N_B)) .\n\n\nendfm\n\nfmod MAIN is\n  protecting PROTOCOL .\n\n  vars N_A N_B : Nat .\n  var A B : Msg .\n\n\nendfm\n\n```"]], "MAUDE-1/orphanedViewInstantiationFebruary2023.maude": [[false, "```\n***\n***\tTest that orphaned view instantiation is garbage collected.\n***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\n  sort Foo .\n  op f : Foo -> Foo .\n  op g : Foo -> Foo .\n  op h : Foo -> Foo .\n  op init : -> Foo .\n\n  vars X : Foo .\n  var L : List{Set{Nat}} .\n\n  op garbage_collect : -> Bool .\n  eq garbage_collect = true .\n\n  vars N : Nat .\n\n  rl [init-view] : init  -> f(init) .\n  rl [f-view] : f(X) -> g(X) .\n  rl [g-view] : g(X) -> h(X) .\n  rl [h-view] : h(X) -> X .\nendfm\n\nshow modules .\nshow views .\n\nmod TEST is\n  inc FOO .\n\n  vars X Y : Foo .\n  var L : List{Set{Nat}} .\n\n  op run : -> Bool .\n  eq run = garbage_collect .\n\nendm\n\n----\n-- Running the test:\n----\nred run .\n\n----\n-- The garbage collection should happen at the end of the execution.\n-- If there's no error, it means the orphaned view is garbage collected successfully.\n----\n\n```"]], "MAUDE-1/parallel-maude-npa.maude": [[true, "fmod MANAGER-PROTOCOL is\n  protecting NAT .\n\n  sort Manager .\n  sort Worker .\n  sort Job .\n  sort MI .\n  sort Task .\n  sort IS .\n  sort IST .\n\n  op _ |_ : Worker Worker -> Worker [assoc comm id: nil] .\n  op < > : Manager -> Manager [ctor] .\n  op #workers : Manager -> Nat .\n  op status : Manager -> String .\n  op workers : Manager -> Worker .\n  op jobs : Manager -> IS IST .\n  op loading : Manager -> Bool .\n  op pending : Manager -> List MI .\n  op insertedModule : Manager Job MI -> Manager .\n  op qsize : Worker -> Nat .\n\n\n  vars O : Manager\n      MI MI1 : MI\n      W W1 : Worker\n      N : Nat\n      IS : IS\n      IST : IST\n      A : Manager .\n  eq qsize(nil) = 0 .\n  eq qsize((MI1 | W1)) = 1 + qsize(W1) .\n\n\n  op print : String -> Unit [ctor] .\n  vars S : String .\n  eq print(S) = print(S) .  -- Dummy equation, needed for syntax\n\n  \n  op _ > : Manager Manager -> Manager [ctor assoc id: < >] .\n\n  crl [Initializing] : < O : Manager |\n        status : initializing,\n        workers : W,\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n    => < O : Manager |\n        status : initializing,\n        workers : W,\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n    .\n\n\n  crl [LoadModule] : < O : Manager |\n        status : initializing,\n        workers : W,\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n    => < O : Manager |\n        status : loading,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : nil),\n        A >\n    if MI = \"module1\" [print \"[Loading] \" MI] .\n\n  crl [LoadModuleFailed] : < O : Manager |\n        status : loading,\n        workers : W,\n        (loading[MI] : true),\n        (pending[MI] : nil),\n        A >\n    => < O : Manager |\n        status : initializing,\n        workers : W,\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n    if MI = \"module2\" [print \"[Failed to load] \" MI] .\n  \n  crl [InsertModule] : < O : Manager |\n        status : initializing,\n        workers : W,\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n        insertedModule(O, MI)\n    => < O : Manager |\n        status : initializing,\n        workers : (W | MI),\n        (loading[MI] : false),\n        (pending[MI] : nil),\n        A >\n        [print \"[Loaded] \" MI] .\n\n  crl [CreatedWorkersDone] : < O : Manager |\n        status : initializing,\n        #workers : N,\n        workers : W,\n        A >\n    => < O : Manager |\n        status : working,\n        #workers : N,\n        workers : W,\n        A >\n    if qsize(W) == N [print \"[CreatedWorkersDone]\"] .\n\n  crl [AssignJob] : < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        A >\n    => < O : Manager |\n        status : working,\n        jobs : (IS IST),\n        workers : (MI | W),\n        A >\n    [print \"[AssignedJob]\"] .\n\n\nendfm"]], "MAUDE-1/parameterizedPolymorphicConstantMarch2023.maude": [[true, "fmod FOO{X :: TRIV} is\n  op c : X -> Universal [poly (0)] .\nendfm\n\nfmod BAR{Y :: TRIV} is\n  inc FOO{Y} .\n  op b : -> Bool .\n  eq b = c{Y} .\nendfm\n\nshow all ."]], "MAUDE-1/physArgIndexOct2018.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that we are not confusing nominal and physical\n***\targument indices for AC(U) terms with arguments having\n***\tmultiplicity > 1.\n***\n\nmod VENDING-MACHINE is\n  sorts Coin Item Place Marking .\n  subsorts Coin Item < Place < Marking .\n  op + : Marking Marking -> Marking [ctor assoc comm id: 0] .\n  op empty : -> Marking [ctor] .\n  op $ : -> Coin [ctor] .\n  op q : -> Item [ctor] .\n  op a : -> Item [ctor] .\n  op slot : -> Place [ctor] .\n  op coin : -> Marking [ctor] .\n\n  op disp : Marking -> Marking [memo] .\n  eq disp(empty) = empty .\n  eq disp(+ (M1 M2)) = + (disp(M1) disp(M2)) .\n\n  vars M1 M2 : Marking .\n  rl disp(coin) = empty .\n  rl disp(slot) = empty .\n  rl disp(q) = empty .\n  rl disp(a) = empty .\n\n  op money : Coin -> Marking [memo] .\n  eq money($) = coin .\n\n  op put : Place Coin -> Place [memo] .\n  eq put(slot, $) = slot .\n\n  op take : Place Item -> Place [memo] .\n  eq take(slot, q) = slot .\n  eq take(slot, a) = slot .\n\n\nendm"]], "MAUDE-1/polymorphicParsingBugsNovember2020.maude": [[false, "```\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for failure to parse polymorphic operators using\n***\tflattened assoc or iter syntax.\n***\n\nfmod POLY-ASSOC is\n  protecting BOOL .\n  sort Poly .\n  op f : Poly Poly -> Poly [assoc comm id: true] .\nendfm\n\nred f(X:Bool, Y:Bool, Z:Bool) .\n\n\nfmod POLY-ITER is\n  protecting BOOL .\n  sort Poly .\n  op f : Poly+ -> Poly [iter] .\nendfm\n\nred f^12345(X:Bool) .\n```"]], "MAUDE-1/quotedTokenMarch2023.maude": [[false, "```\nmaude\nfmod FOO is\n  pr NAT .\n  op \"s\" : Nat -> Nat [ctor] .\n  op \"f\"g : Nat Nat -> Nat [iter] .\n  op f : Nat -> Nat [ctor] .\n  op g : Nat -> Nat [ctor] .\n  vars X Y Z : Nat .\n  eq \"s\"(X) = X + 1 .\n  eq \"f\"g(f(X),g(Y)) = X + Y .\nendfm\n\nred \"X\":Nat .\nred \"X:Y\":NzNat .\nred \"X:Y\"Z:NzNat .\nred \"X\":[Nat] .\n\nred \"s\"^42(0) .\nred \"f\"g^2(0) .\nred \"f\"g(f(2),g(3)) .\nred \"s\"(f(2)) .\nred \"s\"(0) .\nred \"f\"g(f(0),g(0)) .\nendm\n```"]], "MAUDE-1/pseudoParameterTheoryConstantMarch2023.maude": [[true, "***\n***\tTest for instantiation of pseudo-parameters in constants.\n***\n\nfth T is\n  sort Elt .\n  op c{X} : -> Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort Elt .\n  op c{X} : -> Elt .\n  op d : Elt -> Bool .\n  vars X : Elt .\n  eq d(c{X}) = true .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\n  op e : -> Elt .\n  eq e = c{Y} .\nendfm\n\nmod MAIN is\n  inc T .\n  inc FOO{Int} .\n  inc BAR{Int} .\n  \n  op main : -> Bool .\n  eq main = d(c{1}) .\nendm\n\nred main .\nshow all ."]], "MAUDE-1/RAT-ACU-original.maude": [[false, "```\nfmod NAT-FVP is\n  protecting NAT .\n\n  op _~_ : Nat Nat -> Bool [assoc comm] .\n\n  vars N M : Nat .\n\n  eq [nat-fvp01]: 0 ~ 0 = tt [variant] .\n  eq [nat-fvp02]: 1 ~ 1 = tt [variant] .\n  eq [nat-fvp03]: N ~ (N + 0) = tt [variant] .\n  eq [nat-fvp04]: (N + 1) ~ (N + 1) = tt [variant] .\n  eq [nat-fvp05]: N ~ (M + 1) = ff [variant] .\n  eq [nat-fvp06]: (N + 1) ~ M = ff [variant] .\n  eq [nat-fvp07]: N ~ N = tt [variant] .\n  eq [nat-fvp08]: (N + 1) ~ N = ff [variant] .\n  eq [nat-fvp09]: M + N + 1 > N = tt [variant] .\n  eq [nat-fvp10]: N > N + M = ff [variant] .\nendfm\n\n\nfmod NAT-ACU is\n  protecting NAT-FVP .\n  op quot : Nat NzNat -> Nat .            *** quotient\n  op gcd : NzNat NzNat -> NzNat [comm] .  *** greatest common divisor\n  op _*_ : Nat Nat -> Nat [assoc comm prec 31] .\n  op _*_ : NzNat NzNat -> NzNat [assoc comm] .\n\n  vars N M K : Nat   vars X Y : NzNat .\n\n  eq [nat-acu01]: quot(N + M, X) = (N / X) + (M / X) .\n  eq [nat-acu02]: gcd(X, X) = X .\n  eq [nat-acu03]: gcd(X, 0) = X .\n  eq [nat-acu04]: gcd(X, Y) = gcd(Y, X) .\n  eq [nat-acu05]: gcd(X, Y) = gcd(Y, X mod Y) .\n\nendfm\n```"]], "MAUDE-1/redBlackNGA_April2023.maude": [[false, "```\nset show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run if there is an non-ground alien.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\n\nvar S : Set .\nvar M : Nat .\n  op h : Set -> Set .\n  op i : Nat -> Nat .\n  ceq h(f(g(N), S, i(M))) = 0 if N > 0 .\nendfm\n\nred h(g(7)) .\nred h(g(s 0)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .\nendfm\n```"]], "MAUDE-1/redBlackNonLinearApril2023.maude": [[false, "```\nhouzhui\nset show timing off .\n***\n***\tTest that red-black ACU stripper-collector full matcher isn't run on nonlinear patterns.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  op _+_ : Set Set -> Set [assoc comm] .\n  eq g(0) = 0 .\n  eq g(s N) = g(N) + s N .\n\nvar S : Set .\n  op h : Set -> Set .\n  ceq h(f(N, N, S)) = S if N > 0 .\nendfm\n\nred h(f(2, g(0))) .\nred h(f(2, g(7))) .\nred h(f(2, g(20))) .\n```"]], "MAUDE-1/abstract-bakeryAC-checks.maude": [[true, "fmod NAT> is\n  protecting NAT .\n\n  op _>_ : Nat Nat -> Bool .\n\n  vars n : Nat .\n  eq n > 0 = tt .\n  eq 0 > n = ff .\n  eq n > n = ff .\n  eq n > n + 1 = ff .\n  eq n > n' = ff [owise] .\n  eq 0 > 0 = ff .\n  eq 1 > 0 = tt .\n  eq 2 > 1 = tt .\n  eq 1 > 2 = ff .\n  eq 2 > 2 = ff .\n  eq n > n = ff .\n  eq n > n' = tt if n > n' .\n  eq n > n' = ff if n' > n .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n\n  sorts Mode BState .\n\n  ops sleep wait crit : -> Mode [ctor] .\n  op <sleep,wait,crit> : Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n\n  vars Q : Mode .\n  vars X Y : Nat .\n\n  eq initial = < sleep, 0, sleep, 0 > .\n  \n  rl [p1_sleep] : < sleep, X, Q, Y > => < wait, Y + 1, Q, Y > .\n  rl [p1_wait] : < wait, X, Q, 0 > => < crit, X, Q, 0 > .\n  crl [p1_wait] : < wait, X, Q, Y > => < crit, X, Q, Y > if  X > Y .\n  \nendm"]], "MAUDE-1/redBlackTooFewSubjectsApril2023.maude": [[false, "```\nset show timing off .\n***\n***\tTest red-black ACU stripper-collector full matcher when 1 or 0 subjects are left.\n***\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Nat .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), N) .\n\nvar S : Set .\n  op h : Set -> Nat .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, S)) = 0 .\nendfm\n\nred h(f(g(1), 0)) .\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Nat .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), N) .\n\nvar S : Set .\n  op h : Set -> Nat .\n  ceq h(f(N, S)) = h(S) if N > 0 .\n  ceq h(f(0, S)) = 0 .\nendfm\n\n```"]], "MAUDE-1/renamingInstantiationMarch2023.maude": [[false, "```\nhouzhui\n***\n***\tTest that renamings involving parameterized constants are instantiated correctly.\n***\n\nfmod FOO{X :: TRIV} is\n  sort Foo{X} .\n  op f{X} : -> Foo{X} .\nendfm\n\nfmod BAR{X :: TRIV} is\n  pr FOO{X} * (op f{X} to g) .\n  eq g = g .\nendfm\n\nfmod TEST is\n  inc BAR{Nat} .\nendfm\n\nshow all .\n\n\nomod FOO{X :: TRIV} is\n  sort Foo{X} .\n  op f{X} : -> Foo{X} .\n  op x : -> X .\n  vars X : X .\n  eq f{X} = f{x} .\n\n  op toString : Foo{X} -> String .\n  op toString : X -> String .\n  eq toString(f{X}) = \"f\" .\n  eq toString(x) = \"x\" .\nendom\n\nomod BAR{X :: TRIV} is\n  pr FOO{X} * (op f{X} to g, op x to y) .\n  op className : -> Cid .\n  eq className = Bar{X} .\n  vars X : X .\n  eq g = g .\n  eq y = y .\n\n  op toString : Bar{X} -> String .\n  eq toString(g) = \"g\" .\n  eq toString(y) = \"y\" .\nendom\n\nomod TEST is\n  inc BAR{Nat} .\n  op test : -> Bool .\n  eq test = true .\nendm\n\nshow all .\n```"]], "MAUDE-1/rent-a-car-store.maude": [[true, "set show timing off .\nset show advisories off .\nset verbose on .\n\n  ---- adapted\n  ---- from the book All About Maude\n  ---- from the Maude Manual\n  ---- by the Maude team\n\nomod RENT-A-CAR-STORE is\n  pr INT .\n  pr QID .\n\n  subsort Qid < Oid .\n\n  class Customer | cash : Nat, debt : Nat, suspended : Bool .\n  class Car | available : Bool, rate : Nat .\n  class EconomyCar .\n  class MidSizeCar .\n  class FullSizeCar .\n  subclasses EconomyCar MidSizeCar FullSizeCar < Car .\n\n  class Rental | deposit  : Nat, dueDate : Nat, pickUpDate : Nat,\n                 customer : Oid, car     : Oid .\n\n  class Calendar | date : Nat .\n\n  vars F Oid Rt NumDays M N Amnt P\n\n  op rent : Oid Car Nat Nat -> Rental [ctor] .\n  op return : Rental -> Bool .\n  op calculate : Rental -> Nat .\n  op deposit : Rental -> Nat .\n  op dueDate : Rental -> Nat .\n  op pickUpDate : Rental -> Nat .\n  op customer : Rental -> Oid .\n  op car : Rental -> Oid .\n\n  eq return(rent(C C1 D1 D2)) = true [owise] .\n  eq calculate(rent(C C1 D1 D2)) = D1 * Rt [owise] .\n  eq deposit(rent(C C1 D1 D2)) = D1 [owise] .\n  eq dueDate(rent(C C1 D1 D2)) = D2 [owise] .\n  eq pickUpDate(rent(C C1 D1 D2)) = D1 [owise] .\n  eq customer(rent(C C1 D1 D2)) = C [owise] .\n  eq car(rent(C C1 D1 D2)) = C1 [owise] .\n\n\n  op rentEconomy : Oid Nat Nat -> Rental [ctor] .\n  op rentMidSize : Oid Nat Nat -> Rental [ctor] .\n  op rentFullSize : Oid Nat Nat -> Rental [ctor] .\n  op rateEconomy : -> Nat .\n  op rateMidSize : -> Nat .\n  op rateFullSize : -> Nat .\n\n\n  eq rateEconomy() = 20 [owise] .\n  eq rateMidSize() = 30 [owise] .\n  eq rateFullSize() = 40 [owise] .\n  eq rent(C E D1 D2) = rentEconomy(C D1 D2) [owise] .\n  eq rent(C M D1 D2) = rentMidSize(C D1 D2) [owise] .\n  eq rent(C F D1 D2) = rentFullSize(C D1 D2) [owise] .\n  eq rentEconomy(C D1 D2) = rent(C EconomyCar D1 D2) [owise] .\n  eq rentMidSize(C D1 D2) = rent(C MidSizeCar D1 D2) [owise] .\n  eq rentFullSize(C D1 D2) = rent(C FullSizeCar D1 D2) [owise] .\n\n\nendm"]], "MAUDE-1/showModuleJune2018.maude": [[true, "op showModule : Oid -> Module .\n  eq showModule(me) = BAR .\nendm\n\nmod MAIN is\n  protecting TEST .\n\n  op main : -> Bool .\n  eq main = true .\n\n  op showModuleImports : Module -> Set [ctor] .\n  op _in_ : Module Set -> Set [ctor assoc comm id: {}] .\n  op showImports : Module -> Set .\n  eq showImports(M) = showModuleImports(M) .\n  eq showModuleImports(BAR) = {'FOO} .\nendm"]], "MAUDE-1/smodStrategyNameJanuary2023.maude": [[false, "```\n***\n***\tTest for bad strategy name in advisory.\n***\n\nsth T is\n  sorts Prop State .\n  strat expand : Prop @ State .\nendsth\n\nsmod M{X :: T} is\n  op expand' : Prop State -> State [strat] .\n  vars P : Prop .\n  eq expand'(P, _) = P .  (* Example:  Just replace the state *)\nendsm\n\nsmod TEST{X :: T} is\n  inc M{X} * (strat expand : Prop @ State to expand') .\n\n  op badStrat : -> Prop [ctor] .\n  op goodStrat : -> Prop [ctor] .\n\n  vars S : State .\n  eq expand'(badStrat, S) = S .  (* Example:  Do nothing for badStrat *)\n  eq expand'(goodStrat, S) = S . (* Example: Do nothing for goodStrat *)\n  \n  op initial : -> State [ctor] .\n  \n  rl  expand(badStrat, initial)  -> initial .  (* Example:  Bad strategy, no change *)\n  rl  expand(goodStrat, initial)  -> initial . (* Example: Good strategy, no change *)\n  \n  \n  \n  op bad_advisory : -> Prop [ctor] .\n  \n  rl expand(bad_advisory, initial)  -> initial .\n\nendmodule\n```"]], "MAUDE-1/sortCollapseMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug that we weren't warning about a collapse\n***\tup the sort hierarchy for declarations at the kind level.\n***\n\nfmod FOO is\n  sort Foo .\n  op app(OP_1) : Foo [Foo] -> Foo [id: app] .\n  op e : -> Foo .\nendfm\n\nparse f(e, X:[Foo]) .\nred f(e, X:[Foo]) ."]], "MAUDE-1/specificOpMappingPrintFebruary2023.maude": [[true, "***\n***\tTest that specific op maps print correctly.\n***\n\nmod FOO is\n  sorts Foo Bar .\n  op f(Foo) : Foo -> Bar .\nendm\n\nmod BAR is\n  inc FOO * (op f : Foo -> Bar to f) .\nendm\n\nshow desugared ."]], "MAUDE-1/staleViewJune2018.maude": [[false, "```\nset show timing off .\nset show advisories off .\n\n*** Check that we don't look the mapping for _<_\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [assoc comm id: false] .\n  op p_ : Bool -> Bool [prec 100] .\nendfm\n\nview V from STRICT-TOTAL-ORDER to FOO is\n  sort Elt to Bool .\n  op X:Elt < Y:Elt to term p X + Y .\nendv\n\nshow view V .\n\nfmod FOO is\n  op _+_ : Bool Bool -> Bool [prec 20] .\n  op not_ : Bool -> Bool [prec 10] .\nendfm\n\nshow view V .\n\n*** Check the same issue at the metalevel.\n\nfmod FOO is\n  op and_ : Bool Bool -> Bool [assoc comm id: true] .\n  op false_ : -> Bool [prec 0] .\nendfm\n```"]], "MAUDE-1/stringToRatConversionMarch2024.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where certain strings did not convert.\n***\n\nselect CONVERSION .\n\nred rat(\"-0\", 0) .\n\nred rat(\"0/1\", 10) .\n\nred rat(\"-0/1\", 10) .\nred rat(\"1/2\", 0.5) .\nred rat(\"-1/2\", -0.5) .\nred rat(\"22/7\", 22/7.0) .\nred rat(\"100000/1\", 100000) .\nred rat(\"100000/0\", 0) .\n\nop rat(String, Real) .\nop rat(String, Int) .\nop EQ_0 -> Int .\n\neq rat(\"-0\", 0) .\neq rat(\"0/1\", 0) .\neq rat(\"-0/1\", 0) .\neq rat(\"1/2\", 0.5) .\neq rat(\"-1/2\", -0.5) .\neq rat(\"22/7\", 3.142857142857143) .\neq rat(\"100000/1\", 100000) .\neq rat(\"100000/0\", 0) .\neq EQ_0 = 0 .\n\nop rat_err(String) .\n\nred rat(\"abc\", rat_err(\"abc\")) .\nred rat(\"1/0\", rat_err(\"1/0\")) .\nred rat(\"1/a\", rat_err(\"1/a\")) .\nred rat(\"10000000000000000000000/1\", rat_err(\"10000000000000000000000/1\")) .\nred rat(\"\", rat_err(\"\")) .\n\n\n\n```"]], "MAUDE-1/stripperCollectorSwitchMay2023.maude": [[true, "fmod FOO is\n  pr NAT .\n  sorts Set Elt .\n  subsort Elt < Set .\nvar S : Set .\nvar E : Elt .\nvar N : Nat .\n  op dummy : Set -> Set .\n  eq dummy(S) = S .\n\n  op z : -> Elt .\n  op p : Elt -> Elt .\n  op g : Nat Elt -> Set .\n  eq g(s N, E) = f(g(N, p E), E) .\n  \n  op f : Set Elt -> Set [comm] .\n  op h : Set -> Bool .\n  ceq h(f(S, E)) = true if E = z .\nendfm\n\nred h(g(7, z)) ."]], "MAUDE-1/ACU_MissingUnifiersMay2020.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op g(Nat) : Nat -> NzNat [assoc comm id:0] .\n  op _+_ : Nat Nat -> Nat [comm assoc id:0] .\n  op 0 : -> Zero .\n  op succ : Nat -> NzNat .\nendfm\n\nmod FOO-TESTS is\n  protecting FOO .\n\n  op test1 : -> Bool .\n  eq test1 = unify N:Nat =? g(M:Nat + Z:Zero) .\nendm"]], "MAUDE-1/uninitIterExtSeptember2021.maude": [[true, "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in handling of extension information for iter symbols.\n***\n\nmod UNINITIALIZED-BUG is\n  protecting NAT .\n  vars N M : Nat .\n  crl [rwc] : s N => M if N => M [nonexec] .\nendm\n\nsrew 3 using rwc{idle} ."]], "MAUDE-1/upTheoryJanuary2023.maude": [[true, "fth FOO is\n  sort Foo .\n  op foo : Foo -> Bool .\nendfth\n\nmod FOO-IMPL is\n  protecting FOO .\n  sort Foo .\n  op foo : Foo -> Bool [ctor] .\n  op f1 : -> Foo [ctor] .\n  op f2 : -> Foo [ctor] .\n  vars X : Foo .\n  eq foo(f1) = true .\n  eq foo(f2) = false .\nendm\n\nshow desugared FOO .\n\nred in META-LEVEL : upModule('FOO, false) ."]], "MAUDE-1/variantUnifyJune2020.maude": [[false, "```\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck for substitution size bug that affected both UnifierFilter\n***\tand VariantFolder, because subpatterns were being compiled before\n***\tall abstraction variables were added.\n***\n\nfmod A-UNIF is\n  sorts List Elt .\n  subsort Elt < List .\n  op [] : -> List [ctor] .\n  op _ ++ _ : List List -> List [assoc comm id: []] .\n  op f(_ , _ , _) : Elt Elt List -> List [ctor] .\n  op j(_ , _) : List List -> List [ctor] .\n  vars A B C D G H I \n       S U V W X Y Z : List .\n  var E  : Elt .\nendfm\n\nvariant unify j(A, f(B, E, C), f(D, E, j(G, H), I)) =?\n  j(U, f(V, W), f(X, j(Y, Z), S)) .\n```"]], "MAUDE-1/renaming.maude": [[false, "```\nhouzhui\nset show timing off .\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, sort Bar to Quux) .\nendfm\n\nshow mod .\nshow all .\n\nfmod ONE is\n  sorts Foo Bar .\n  subsort Foo < Bar .\nendfm\n\nfmod TWO is\n  inc ONE * (sort Foo to Baz) .\n  sort Quux .\n  subsort Quux < Baz .\nendfm\n\nfmod THREE is\n  inc TWO * (sort Foo to Foo', sort Baz to Baz', sort Quux to Quux') .\n  sort Jaz .\n  subsort Jaz < Baz' .\nendfm\n\nshow mod .\nshow all .\n\n\nfmod FOO is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\nendfm\n\nfmod BAR is \n  inc FOO * (sort Foo to Baz, op a to b) .\nendfm\n\nshow mod .\nshow all .\n\nfmod FOO' is\n  sorts Foo Bar .\n  subsort Foo < Bar .\n  op a : -> Foo .\n  op b : -> Bar .\n\n  vars X : Foo .\n  eq b(a) = X .\nendfm\n\nshow mod .\nshow all .\n```"]], "MAUDE-1/Carlsen_Secret_Key_Initiator.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort\n  sort Key Init Request.\n  sort Key Init Response.\n  sort Key Exchange Request.\n  sort Key Exchange Response.\n  sort SessionKey.\n  sort Acknowledgement.\n\n  op _isFresh : Fresh -> Bool .\n  op _isPublic : Public -> Bool .\n\n  op keyInitRequest(Key,Public) : Key Init Request .\n  op keyInitResponse(Key,Public) : Key Init Response .\n  op keyExchangeRequest(SessionKey,Public) : Key Exchange Request .\n  op keyExchangeResponse(SessionKey,Public) : Key Exchange Response .\n  op ack(Public) : Acknowledgement.\n\n\n  --- subsorts\n   subsort Key Init Request Key Init Response Key Exchange Request Key Exchange Response SessionKey Acknowledgement < Msg .\n  \n  --- Example of a rule to generate a fresh key\n  op freshKey : -> Fresh .\n  \n  --- Example of a rule to generate a public key\n  op generatePublic : -> Public .\n    \nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Rules\n   --- Key initiation\n  rl [keyInitRequest-rule]\n    keyInitRequest(K,P) -> keyInitResponse(K,P).\n    \n   --- Key exchange\n  rl [keyExchangeRequest-rule]\n    keyExchangeRequest(SK,P) -> keyExchangeResponse(SK,P).\n\n  --- Acknowledgement\n  rl [ack-rule]\n    ack(P) ->  ack(P).\n  \nendfm"]], "MAUDE-1/ltv-F-tmn.maude": [[true, "fmod PROTOCOL-F is\n  protecting NAT-SEMIRING with\n  protecting SET-THEORY with\n  protecting BOOL-SEMIRING.\n\n  sort Principal .\n  sort Key .\n  sort Message .\n\n  op a  : -> Principal [ctor].\n  op b  : -> Principal [ctor].\n  op s  : -> Principal [ctor].\n  op i  : -> Principal [ctor].\n\n  op ka : -> Key [ctor].\n  op kb : -> Key [ctor].\n  op kp : -> Key [ctor].\n  op ki : -> Key [ctor].\n\n  op msg-1 : Principal Principal Key -> Message [ctor assoc comm].\n  op msg-2 : Principal -> Message [ctor].\n  op msg-3 : Principal Key -> Message [ctor].\n  op msg-4 : Principal Key Key -> Message [ctor].\n\n  vars A B S I : Principal.\n  vars KA KB KP KI : Key.\n\n  crl [step-1]\n    (a, b, ka) --> (a, b, ka, s, kp, msg-1(b, ka, kp)) .\n\n  crl [step-2]\n    (a, b, ka, s, kp, msg-1(b, ka, kp)) --> (a, b, ka, s, kp, msg-2(s)) .\n\n  crl [step-3]\n    (a, b, ka, s, kp, msg-2(s)) --> (a, b, ka, s, kp, msg-3(b, kb)) .\n\n  crl [step-4]\n    (a, b, ka, s, kp, msg-3(b, kb)) --> (a, b, ka, s, kp, msg-4(s, kb, ka)) .\n\n  crl [intruder-1]\n    (a, b, ka, s, kp, msg-1(b, ka, kp)) --> (a, b, ka, s, kp, msg-2(i)) .\n\n  crl [intruder-2]\n    (a, b, ka, s, kp, msg-2(i)) --> (a, b, ka, s, kp, msg-3(i, ki)) .\n\n  crl [intruder-3]\n    (a, b, ka, s, kp, msg-3(i, ki)) --> (a, b, ka, s, kp, msg-4(s, b, ki * ka)) .\n\nendfm"]], "MAUDE-1/ltv-F-tmn2-asy.maude": [[true, "Maude 3.0.1\n> red A -[msg(B, S, sym_enc(KA, PKS))]-> S .\n> red S -[msg(A, B, A)]-> B .\n> red B -[msg(A, S, sym_enc(KB, PKS))]-> S .\n> red S -[msg(B, A, sym_dec(KB, sym_dec(KA, fresh)))]-> A .\n> quit"]], "MAUDE-1/dh.maude": [[false, "```\n***)\nfmod PROTOCOL is\n  protecting NAT .\n  protecting XOR .\n  \n  sorts Msg Key Nonce .\n  subsort Nonce < Msg .\n  subsort Key < Msg .\n  \n  op exp : Msg Nat -> Msg [assoc comm] .\n  op enc : Key Msg -> Msg .\n  op d : Key Msg -> Msg .\n  op secret : Nat Nat -> Key .\n\n\n  vars N_A N_B : Nat .\n  vars X Y Z : Msg .\n  vars K : Key .\n  vars M : Msg .\n  \n  eq exp(exp(X,Y),Z) = exp(X,Y * Z) .\n  eq enc(K,d(K,M)) = M .\n  eq d(K,enc(K,M)) = M .\n  \n  op a_init : -> Msg .\n  op b_init : -> Msg .\n  op a_msg1 : Msg -> Msg .\n  op b_msg1 : Msg -> Msg .\n  op a_msg2 : Msg -> Msg .\n  op b_msg2 : Msg -> Msg .\n  \n  eq a_init = (A;B;exp(g,N_A)) .\n  eq b_init = (A;B;exp(g,N_B)) .\n  \n  eq a_msg1(exp(g,N_B)) = enc(exp(exp(g,N_B),N_A),secret(A,B)) .\n  eq b_msg1(exp(g,N_A)) = enc(exp(exp(g,N_A),N_B),secret(B,A)) .\n  eq a_msg2(exp(g,N_B)) = a_init ; b_init ; a_msg1(exp(g,N_B)) .\n  eq b_msg2(exp(g,N_A)) = b_init ; a_init ; b_msg1(exp(g,N_A)) .\n\nendfm\n\n```"]], "MAUDE-1/esorics12-asy.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort  Nonce < NNSet .\n  subsort  Null < Msg ;\n  subsort  Nul < Msg .\n  \n  --- Constant/Variable Declarations (e.g., empty set)\n  op emptyNNSet : -> NNSet [ctor] .\n  op add : NNSet Nonce -> NNSet [ctor assoc comm id: emptyNNSet] .\n\n  --- Other operation declarations as needed\n  --- Example:\n  op make-name : -> Name [ctor] .\n  op make-nonce : -> Nonce [ctor] .\n  op make-null : -> Null [ctor] .\n\n  --- Add more sorts, subsorts, and operators as required by your protocol\n  vars N1 N2 : Name .\n  vars N : Nonce .\n  vars S : NNSet .\n endfm\n```"]], "MAUDE-1/esorics12-variant.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet Null .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Null < Public .\n  subsort Nonce < NNSet .\n  subsort  Nonce < Fresh .\n\n  --- Operation Information (Add more as needed)\n  op  createName : -> Name [ctor].\n  op  createNonce : -> Nonce [ctor].\n  op  createNNSet : -> NNSet [ctor].\n\n  --- Operations for NNSet (Add more as needed)\n  op  emptyNNSet : -> NNSet [ctor assoc comm id: emptyNNSet].\n  op  addNonceToNNSet : NNSet Nonce -> NNSet [assoc comm id: emptyNNSet].\n\n\n  vars N : Nonce .\n  vars S : NNSet .\n  vars N1 N2 : Name .\n\n\nendfm"]], "MAUDE-1/ACU_TreeVariableSubproblem.maude": [[false, "```\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Nat Set -> Set [assoc id:1] .\n  op g : Nat -> Set .\n  eq g(N) = {N} .\n  eq f(N, {M}) = {N,M} .\n  eq f(N, {}) = {N} .\nendfm\n\nmod ACU_TreeVariableSubproblem is\n  pr FOO .\n  \n  vars S T : Set .\n  var N : Nat .\n  \n  op solve : Set Set -> Set .\n  eq solve({N}, {N}) = {N} .\n  eq solve({}, {N}) = {} .\n  eq solve({N}, {}) = {} .\nendm\n\n```"]], "MAUDE-1/homo-hpc.maude": [[true, "----\n----\n----\n----\n----"]], "MAUDE-1/homo-nsl.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ------------------------------------------------------\n  sorts Msg Fresh Public GhostData .\n  subsort Fresh Public GhostData < Msg .\n  \n  op Na : -> Fresh [ctor] .\n  op Nb : -> Fresh [ctor] .\n  op A : -> Public [ctor] .\n  op B : -> Public [ctor] .\n  \n  op _PK_ : Public Msg -> Msg [assoc comm id: {}] .\n  op _PK_ : Msg Msg -> Msg [assoc comm id: {}] .\n\n  op {_,_} : Fresh Fresh Public -> Msg [ctor assoc comm id: {}] .\n  op {_,_,_} : Fresh Fresh Public -> Msg [ctor assoc comm id: {}] .\n  \n  vars M1 M2 : Msg .\n  var F : Fresh .\n  vars P1 P2 : Public .\n\n  --- Rules for the protocol\n  rl [A-to-B-1] :\n    A PK(B) -> {Na,A}PK(B) .\n  rl [B-to-A-1] :\n    {Na,Nb,B}PK(A) -> B PK(A) .\n  rl [A-to-B-2] :\n    Nb PK(B) -> {Nb}PK(B) .\n  \nendfm\n```"]], "MAUDE-1/Kao-Chow_Repeated_Authentication.maude": [[true, "mod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting STRING .\n  \n  --- Server name\n  op s : ->  SName . \n  sort SName .\n  op \"server\" : -> SName [ctor] .\n\n  --- MKey\n  op mk : Name -> Masterkey [frozen] .\n  sort Masterkey .\n  sort Name .\n  op \"alice\" : -> Name [ctor] .\n  op \"bob\" : -> Name [ctor] .\n  op \"nonce1\" : -> Nonce [ctor] .\n  op \"nonce2\" : -> Nonce [ctor] .\n  sort Nonce .\n  sort Sessionkey .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  sort Key .\n  sort Msg .\n  op \"message\" : -> Msg [ctor] .\n  op d : Key Msg -> Msg [frozen] .\n\n--- successor\n op p : Msg -> Msg [frozen] .\n\n\n--- Concatenation\n  op ++ : Msg Msg -> Msg [frozen gather (left E)] .\n\nendm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  op mk : Name -> Masterkey [ctor] .\n\n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n  \n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n\n--- Concatenation\n  op ++ : Msg Msg -> Msg [frozen gather (left E)] .\n  \n  vars M1 M2 : Msg .\n  eq M1 ++ M2 = M2 .\n  \nendfm"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Handshake_Key.maude": [[true, "----\n----   Protocol Example\n----\n----   This example shows a simple protocol with\n----   some messages and rules.  Modify these\n----   to match your protocol.\n----\n\n\n---- Add necessary modules here.\n----\n---- Include the following modules, or their equivalents, if needed:\n----\n---- - DEFINITION-PROTOCOL-RULES\n---- - (If you need to define your own sorts, etc.)\n----\n\n---- Example using the provided modules:\n----\n----   (The following is an example, and may need modification based\n----    on the actual required imports)\n----\n----\n----\n----\n----\n----\n----\n\n\n----\n----  Replace the following with your protocol's modules.\n----\n----  These examples are very basic and should be replaced\n----  with your protocol's actual specification.\n----\n----\n----\n\n\n----  Start of the actual specification.\n----  This part will need significant modification to reflect\n----  your protocol.\n\n\n----\n----  Verification of the completed protocol example.\n----\n----  (This part will need substantial expansion to include\n----   the verification methods specific to your protocol).\n----\n\n\n----  End of the actual specification.\n----\n\n\n\n----\n----   Example of a verification step (needs significant expansion).\n----   Replace with your specific verification logic.\n----\n----\n----\n\n\n----\n----  Verification results (will need to be populated with the\n----  results of the verification process).\n----\n----\n----\n\n\n----\n----   End of the protocol example.\n----\n----\n\n----\n----  End of the file.\n----"]], "MAUDE-1/Kao-Chow_Repeated_Authentication_Ticket.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n  sorts\n    A B C Msg Fresh Public .\n  op\n    a : -> A [ctor]\n    b : -> B [ctor]\n    c : -> C [ctor]\n    fresh : -> Fresh [ctor]\n    pub : -> Public [ctor]\n    \n    msg_a : A -> Msg [ctor]\n    msg_b : B -> Msg [ctor]\n    msg_c : C -> Msg [ctor]\n\tmsg_fresh : Fresh -> Msg [ctor]\n\tmsg_pub : Public -> Msg [ctor]\n\t\n    send_a : A -> Msg [ctor]\n    send_b : B -> Msg [ctor]\n    send_c : C -> Msg [ctor]\n\tsend_fresh : Fresh -> Msg [ctor]\n\tsend_pub : Public -> Msg [ctor]\n\n    \n    \n    \n\t\n    \n    \n    \n    \n  op\n    empty : -> Msg [ctor]\n    \n    \n  vars\n    M : Msg\n    F : Fresh\n    P : Public\n  eq\n    msg_a(a) = send_a(a) .\n    msg_b(b) = send_b(b) .\n    msg_c(c) = send_c(c) .\n    msg_fresh(fresh) = send_fresh(fresh) .\n    msg_pub(pub) = send_pub(pub) .\n    \n\n  \n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  vars\n    M : Msg\n    F : Fresh\n    P : Public\n  \n  --- Example rule (replace with your rules)\n  \n  \n  \n  \n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-INIT is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  op\n    init : -> Msg .\n  eq\n    init = msg_a(a) .\n  \nendfm\n```"]], "MAUDE-1/mpOTR_connect.maude": [[false, "```\n***\nfmod COMMUNICATION-SETUP is\n  protecting NATURALS .\n\n  sort Client .\n  sort Message .\n\n  op client1 client2 client3 : -> Client [ctor] .\n  op fx-mess : -> Message [ctor] .\n\n  vars C1 C2 C3 : Client .\n  var M : Message .\n\n  op send : Client Client Message -> Rule .\n\n  eq send(client1, client2, fx-mess) =\n      client1 -> client2 : client1 ; fx-mess .\n  eq send(client1, client3, fx-mess) =\n      client1 -> client3 : client1 ; fx-mess .\n  eq send(client2, client1, fx-mess) =\n      client2 -> client1 : client2 ; fx-mess .\n  eq send(client2, client3, fx-mess) =\n      client2 -> client3 : client2 ; fx-mess .\n  eq send(client3, client1, fx-mess) =\n      client3 -> client1 : client3 ; fx-mess .\n  eq send(client3, client2, fx-mess) =\n      client3 -> client2 : client3 ; fx-mess .\n\nendfm\n```"]], "MAUDE-1/mpOTR_dh.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  sorts Msg Fresh Public .\n  subsorts Fresh < Public .\n\n  op g : -> Public .\n  op e : Public Msg -> Msg [ctor] .\n  op d : Public Msg -> Msg [ctor] .\n  op exp : Public Nat -> Public [ctor] .\n  op _*_ : Nat Nat -> Nat [assoc comm id: 0] .  \n  op _^_ : Public Nat -> Public .\n  op 0 : -> Nat .\n  op 1 : -> Nat .\n  op _+_ : Nat Nat -> Nat [comm assoc id: 0] .\n\n  vars M1 M2 : Msg .\n  vars K1 K2 : Public .\n  var X : Public .\n  var Y Z : Nat .\n\n\n  eq exp(g, Y + Z) = exp(g, Y) ^ exp(g, Z).\n  eq exp(g, 0) = g.\n  eq exp(g, 1) = g.\n    eq e(K1, d(K1, M1)) = M1 .\n  eq d(K1, e(K1, M1)) = M1 .\n\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Add your protocol rules here.\n  --- Example (replace with your actual rules):\n  rl [exp-assoc]:\n    exp(exp(X,Y),Z) = exp(X, Y * Z) .\n  rl [exp-g-base]:\n    exp(g, 0) = g .\n  rl [exp-g-1]:\n    exp(g, 1) = g .\n  rl [exp-g-plus]:\n    exp(g, Y + Z) = exp(g, Y) ^ exp(g, Z).\n\nendfm\n\nmod PROTOCOL-EXAMPLE-INIT is\n  protecting PROTOCOL-EXAMPLE-RULES .\n\n  --- Add your initial states here.\n  --- Example:\n  op init : -> State .\n  eq init = ... . \nendm"]], "MAUDE-1/Needham_Schroeder.maude": [[false, "```\nhouzhui\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your prot\n  sort Msg .\n  sort Public .\n  sort Nonce .\n  sort Secret .\n\n  op pk : Public Msg -> Msg [assoc comm id: 1].\n  op sk : Secret Msg -> Msg .\n  op _ ; _ : Msg Msg -> Msg [assoc comm id: 1].\n  op nonce : -> Nonce .\n\n  vars A B K M N_A N_B : Public .\n  var N : Nonce .\n  vars M1 M2 M3 : Msg .\n  \n  --- This is the key for the verification\n  eq pk(K, sk(K, M)) = M .\n  eq sk(K, pk(K, M)) = M .\n\n  \n  --- Define the protocol rules\n  op initA : -> Msg .\n  op initB : -> Msg .\n\n  eq initA = pk(B, A ; nonce) .\n  eq initB = pk(A, nonce ; N_B) .\n\n  op msgA2B : Msg -> Msg .\n  eq msgA2B(pk(B, A ; nonce)) = pk(B, N_B) .\n\n  op msgB2A : Msg -> Msg .\n  eq msgB2A(pk(A, nonce ; N_B)) = nil .\n  \n  --- Add more rules if needed\n\nendfm\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_ECB.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  sorts Msg Fresh Public GhostData .\n  subsorts Fresh Public GhostData < Msg .\n  op _PK : Public Public -> Public [assoc comm id: []].\n\n  op Na : -> Fresh .\n  op Nb : -> Fresh .\n  op A : -> Public .\n  op B : -> Public .\n  \n  vars M1 M2 : Msg .\n  vars N : Fresh .\n  vars P1 P2 : Public .\n  \n  --- Define the messages.  Crucial for NPA\n  op msg1 : Fresh Public Public -> Msg [ctor].\n  op msg2 : Fresh Fresh Public Public -> Msg [ctor].\n  op msg3 : Fresh Public -> Msg [ctor].\n\n  ---  Complete the protocol rules according to the description\n  rl [rule1]\n    msg1(Na, A, B) -> msg2(Na, Nb, B, A)\n    [macro].\n\n  rl [rule2]\n    msg2(Na, Nb, B, A) -> msg3(Nb, A)\n    [macro].\n\n  rl [rule3]\n    msg3(Nb, B) -> msg1(Nb, B)\n    [macro].\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- No need to modify this part for this simple example\n  op _PK : Public Public -> Public [assoc comm id: []].\n\n  --- Add any other rules needed.\n  \n  vars N1 N2 : Fresh .\n  vars P1 P2 : Public .\n  \n  rl [rule1]\n    msg1(Na, A, B) -> msg2(Na, Nb, B, A)\n    [macro].\n\n  rl [rule2]\n    msg2(Na, Nb, B, A) -> msg3(Nb, A)\n    [macro].\n\n  rl [rule3]\n    msg3(Nb, B) -> msg1(Nb, B)\n    [macro].\n\nendfm"]], "MAUDE-1/Needham_Schroeder_Lowe_Modified.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting NAT .\n  sort Nonce .\n  sort Key .\n  sort Message .\n  op pk : Key Nonce -> Message [assoc comm id: 0].\n  op sk : Key Message -> Message [assoc comm id: 0].\n  op _*_ : Nonce Nonce -> Nonce [assoc comm id: 0].\n  op _*_ : Nonce Nonce -> Nonce [assoc comm id: 0].\n\n  vars N A B : Nonce .\n  var K : Key .\n\n  ***\n  eq pk(K, sk(K, M)) = M .\n  eq sk(K, pk(K, M)) = M .\n  eq N * N = 0 .\n  eq N * N * N1 = N1 .\n  eq N * 0 = N .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  op A_to_B1 : -> Message .\n  op A_to_B2 : -> Message .\n  op B_to_A : -> Message .\n\n  eq A_to_B1 = pk(B, (A * N)) .\n  eq A_to_B2 = pk(B, N) .\n  eq B_to_A = pk(A, (A * B * N)) .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-SECS is\n  protecting PROTOCOL-EXAMPLE-RULES .\n  sort Sec .\n  op a_to_b1 : -> Sec .\n  op a_to_b2 : -> Sec .\n  op b_to_a : -> Sec .\n  op _to_ : Sec Message -> Sec [assoc comm id: 0].\n\n  eq a_to_b1 = A_to_B1 to_ B.\n  eq a_to_b2 = A_to_B2 to_ B.\n  eq b_to_a = B_to_A to_ A.\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ATTACK is\n  protecting PROTOCOL-EXAMPLE-SECS .\n  op attack : -> Sec .\n\n  eq attack = a_to_b1 .\n\n  -- attack using the exclusive or.\n  eq pk(B, (A * N)) = pk(B, (A * N)) .\n  eq pk(A, (A * B * N)) = pk(A, (A * B * N)) .\n\n\nendfm\n```"]], "MAUDE-1/ascentFunctionsJanuary2020.maude": [[false, "```\nhouzhui\nset show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule(BAD, nil) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts(nil, false) .\nred in META-LEVEL : upSubsortDecls(nil, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .\n```"]], "MAUDE-1/Needham_Schroeder_Lowe_XOR.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting NAT .\n\n  sorts Msg Nonce Key  .\n  subsort Nonce < Msg .\n  subsort Key < Msg .\n\n  op pk : Msg Msg -> Msg [assoc comm id: 0] .\n  op sk : Msg Msg -> Msg [assoc comm id: 0] .\n  op * : Msg Msg -> Msg .\n\n  vars X Y Z : Msg .\n  eq pk(X,sk(X,Y)) = Y .\n  eq sk(X,pk(X,Y)) = Y .\n  eq X * X = 0 .\n  eq X * X * Y = Y .\n  eq X * 0 = X .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-SYNTAX is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  op a : -> Msg .\n  op b : -> Msg .\n\n  op n_a : -> Nonce .\n  op n_b : -> Nonce .\n\n  op msg1 : Msg Msg -> Msg .\n  op msg2 : Msg Msg Msg -> Msg .\n  op msg3 : Msg Msg -> Msg .\n\n  op msg1 : Msg Msg -> Msg [ctor] .\n  eq msg1(a,pk(b,msg1(n_a,a))) = a --> b : pk(b,n_a ; a) .\n  eq msg2(b,pk(a,msg2(n_a,b,n_b))) = b --> a : pk(a,n_a ; b * n_b) .\n  eq msg3(a,pk(b,n_b)) = a --> b : pk(b,n_b) .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-SEMANTICS is\n  protecting PROTOCOL-EXAMPLE-SYNTAX .\n\n  vars M1 M2 M3 : Msg .\n  var K : Key .\n  var N : Nonce .\n\n  rl [A-1] : a --> b : pk(b,n_a ; a) => a --> b : pk(b,msg1(n_a,a)) .\n  rl [B-1] : b --> a : pk(a,n_a ; b * n_b) => b --> a : pk(a,msg2(n_a,b,n_b)) .\n  rl [C-1] : a --> b : pk(b,n_b) => a --> b : pk(b,n_b) .\n\nendfm\n\n\n```"]], "MAUDE-1/nspk.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  sorts Name Nonce Key .\n  subsort Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  op pk : Key -> Msg [ctor] .\n  op sign : Key Msg -> Msg [ctor] .\n\n  op n : Name -> Nonce [ctor] .\n  \n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  op _;_ : Msg Msg -> Msg [gather (e left)] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n\n  var Z : Msg .\n  var Ke : Key .\n\n  op alice_to_bob : -> Msg [ctor] .\n  op bob_to_alice : -> Msg [ctor] .\n  op intruder_to_bob : -> Msg [ctor] .\n\n  eq alice_to_bob = pk(a) ; n(a) .\n  eq bob_to_alice = sign(b, n(b)) .\n  eq intruder_to_bob = pk(i) ; n(i) .\n\nendfm\n```"]], "MAUDE-1/secret06.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES . --- Importing sort Msg, Fresh, Public\n  \n  sorts Msg Fresh Public .\n  op _ ; _ : Msg Msg -> Msg [assoc comm id: nil].\n  op sk_(_,_): Public Msg -> Msg .\n  op pk_(_,_): Public Msg -> Msg .\n  op n_S : -> Fresh .\n  op n_A : -> Fresh .\n\n  vars N_S N_A : Fresh .\n  vars A B : Public .\n  \n  crl\n    sk(A, n_S ; B) -> sk(A, n_S) ; sk(A, B) .\n  \n  crl\n    sk(A, n_A ; n_S ; B) -> sk(A, n_A) ; sk(A, n_S) ; sk(A, B) .\n\n  crl\n    pk(A, sk(A, M)) -> M .\n  \n  crl\n    sk(A, pk(A, M)) -> M .\n  \n  vars M : Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  op init : -> Msg .\n  op _->_: Msg Msg -> Msg .\n\n  vars S A B : Public .\n  \n  eq init = n_S .\n  eq S -> A : N_S = sk(S, n_S) .  \n  eq A -> B : sk(A, N_S ; S) = sk(A, sk(A, N_S) ; sk(A, S)) . \n  eq A -> B : sk(A, B ; N_A ; S) = sk(A, sk(A, B) ; sk(A, N_A) ; sk(A, S)) . \n\nendfm"]], "MAUDE-1/secret07.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting NAT-SORT with\n    sort Msg .\n  protecting STRING-SORT with\n    sort Public .\n  sort Fresh .\n\n  op g : -> Public .\n  op exp : Public Msg -> Msg [assoc comm id: 1] .\n  op _*_ : Msg Msg -> Msg [assoc comm id: 1] .\n\n  op A : -> Msg .\n  op B : -> Msg .\n\n  vars N_A N_B : Fresh .\n  vars X Y Z : Public .\n  vars M1 M2 M3 : Msg .\n  \n  eq exp(exp(g,M1),M2) = exp(g, M1 * M2).\nendfm\n\nfmod PROTOCOL-EXAMPLE-SYNTAX is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  sort Message .\n  op a : -> Message .\n  op b : -> Message .\n  op expMsg : Public Fresh -> Message .\n\n  op _!_ : Message Message -> Message [ctor assoc comm id: 1] .\n\n  vars N : Fresh .\n  vars P : Public .\n  \n  eq a ! b = a!b.\n  eq b ! a = b!a.\n  eq expMsg(g, N) = exp(g, N).\n  \n  --- Add more rules for other message types\n  --- If needed\nendfm\n\n\nfmod PROTOCOL-EXAMPLE-SEMANTICS is\n  protecting PROTOCOL-EXAMPLE-SYNTAX .\n\n  vars M1 M2 : Message .\n  vars N1 N2 : Fresh .\n  vars G : Public .\n  \n  --- Define your protocol rules here.\n  --- Example:\n  rl [A-to-B-1] : a -> b!a .\n  rl [A-to-B-2] : a -> b!b .\n  rl [A-to-B-3] : a -> expMsg(g,N1)!a .\n  rl [B-to-A-1] : b -> a!b .\n  rl [B-to-A-2] : b -> a!a .\n  rl [B-to-A-3] : b -> expMsg(g,N2)!b .\n\n\n  \nendfm"]], "MAUDE-1/Wide_Mouthed_Frog.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sort Msg .\n  sort Fresh .\n  sort Public .\n  \n  subsorts Fresh Public < Msg .\n  \n  op msg1 : -> Msg [ctor] .\n  op msg2 : -> Msg [ctor] .\n  op msg3 : -> Msg [ctor] .\n  op msg4 : -> Fresh [ctor] .\n  op msg5 : -> Public [ctor] .\n  \n  vars M : Msg .\n  vars F : Fresh .\n  vars P : Public .\n  \n  --- Example Rules (replace with your protocol rules)\n  op rule1 : Msg Msg -> Msg [ctor assoc comm id: msg1] .\n  op rule2 : Msg Fresh -> Msg [ctor assoc comm id: msg2] .\n  op rule3 : Msg Public -> Msg [ctor assoc comm id: msg3] .\n  \n  --- Example rule for freshness\n  eq rule4(msg4(),msg1()) = msg2() .\n  \n  --- Example rule for public\n  eq rule5(msg5(),msg1()) = msg3() .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Example rules for the protocol (replace with your rules)\n  op rule1 : Msg Msg -> Msg [ctor assoc comm id: msg1] .\n  op rule2 : Msg Fresh -> Msg [ctor assoc comm id: msg2] .\n  op rule3 : Msg Public -> Msg [ctor assoc comm id: msg3] .\n  \n  vars M1 M2 : Msg .\n  vars F : Fresh .\n  vars P : Public .\n  \n  --- Add your protocol rules here.\n  --- Example freshness rule\n  crl [fresh-rule]\n    msg4() -> msg4()\n  \n  --- Example public rule\n  crl [public-rule]\n    msg5() -> msg5() .\n   \n  \nendfm"]], "MAUDE-1/Woo-Lam_Authentication.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Inf\n  sort Inf .\n  subsort Inf < Msg .\n  op w_id : -> Inf [ctor] .\n  op l_id : -> Inf [ctor] .\n\n  --- Example messages (add more as needed)\n  op msg1 :  Fresh Public -> Inf [ctor] .\n  op msg2 :  Inf -> Inf [ctor] .\n  op msg3 :  Inf -> Inf [ctor] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Example rules (add more as needed)\n  --- Example rule for Woo and Lam protocol\n  rl [woo-lam-auth-1]:\n     msg1(F, P)\n     -> l_id .\n  rl [woo-lam-auth-2]:\n    l_id\n    -> msg2(w_id) .\n  rl [woo-lam-auth-3]:\n     msg2(M)\n     -> msg3(M) .\nendfm\n\nmod PROTOCOL-EXAMPLE is\n  protecting PROTOCOL-EXAMPLE-RULES .\nendm"]], "MAUDE-1/xor-nsl.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting NAT .\n  sort Nonce .\n  sort PublicKey .\n  sort PrivateKey .\n  sort Message .\n\n  op pk(PublicKey, Message) : PublicKey Message -> Message [assoc comm id: 0].\n  op sk(PrivateKey, Message) : PrivateKey Message -> Message [assoc comm id: 0].\n  op _*_ : Nonce Nonce -> Nonce [assoc comm id: 0].\n  op 0 : -> Nonce .\n\n  vars N A B : Nonce .\n  vars K : PublicKey .\n  vars M : Message .\n\n  eq pk(K, sk(K, M)) = M .\n  eq sk(K, pk(K, M)) = M .\n  eq N * N = 0 .\n  eq N * N * N = N .\n  eq N * 0 = N .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Defining the protocol rules\n\n  op a1 : -> Message .\n  op a2 : -> Message .\n  op a3 : -> Message .\n\n  eq a1 = pk(B, N * A) .\n  eq a2 = pk(A, N * B * N2) .\n  eq a3 = pk(B, N2) .\n\n  vars N N2 : Nonce .\n  vars A B : PublicKey .\n\n\n  crl [decrypt-a1] :\n    pk(B, N * A) -> N * A [owise].\n  crl [decrypt-a2] :\n    pk(A, N * B * N2) -> N * B * N2 [owise].\n  crl [decrypt-a3] :\n    pk(B, N2) -> N2 [owise].\n\n\nendfm"]], "MAUDE-1/Yahalom.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  U .\n  subsort U < Msg .\n  \n  op  u1 : -> U [ctor] .\n  op  u2 : -> U [ctor] .\n  --- other message constructors as needed\n    --- Example:\n  op  msg1 : Nat Nat -> U [ctor] .\n  op  msg2 : Nat -> U [ctor] .\n  \n  vars N1 N2 : Nat .\n  \n  --- Example of a message\n  op  printMsg : Msg -> String .\n  eq printMsg(u1) = \"Message u1\" .\n  eq printMsg(u2) = \"Message u2\" .\n  eq printMsg(msg1(N1,N2)) = \"Message msg1(\" ++ string(N1) ++ \",\" ++ string(N2) ++ \")\" .\n  eq printMsg(msg2(N1)) = \"Message msg2(\" ++ string(N1) ++ \")\" .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the rules of your protocol\n  ----------------------------------------------------------\n  \n  --- Example of a rule (replace with your rules)\n  crl [example-rule] :\n      u1 -> u2 .\nendfm\n\nfmod PROTOCOL-EXAMPLE-INIT is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the initialisation\n  ----------------------------------------------------------\n  \n  op  init : -> Msg .\n  eq  init = u1 .\nendfm\n\nmod PROTOCOL-EXAMPLE is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS PROTOCOL-EXAMPLE-RULES PROTOCOL-EXAMPLE-INIT .\nendm"]], "MAUDE-1/ISO_5_Pass_Authentication.maude": [[false, "```\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  -------------------------------------------------------\n  sorts\n    A B C D E F  Msg Fresh Public .\n  subsort\n    A B C D E F  < Msg .\n  op\n      a  : -> A [ctor]\n      b  : -> B [ctor]\n      c  : -> C [ctor]\n      d  : -> D [ctor]\n      e  : -> E [ctor]\n      f  : -> F [ctor]\n      fresh : -> Fresh [ctor]\n      pub : -> Public [ctor]\n  \n  vars\n    m : Msg\n    f : Fresh\n    p : Public .\nendfm\n\nfmod PROTOCOL-EXAMPLE-RULES is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n  --- Your protocol rules go here\n  --- Example:\n  --- rl\n  ---  (send a (fresh f)  ) --> (receive a (fresh f)) .\n  \n  ops\n      send_a_f : A Fresh -> Msg\n      receive_a_f : A Fresh -> Msg\n      send_b_pub : B Public -> Msg\n      receive_b_pub : B Public -> Msg\n      send_c_m : C Msg -> Msg\n      receive_c_m : C Msg -> Msg\n      send_d_m : D Msg -> Msg\n      receive_d_m : D Msg -> Msg\n      send_e_m : E Msg -> Msg\n      receive_e_m : E Msg -> Msg\n      send_f_m : F Msg -> Msg\n      receive_f_m : F Msg -> Msg\n      \n      \n      msg_a : A -> Msg\n      msg_b : B -> Msg\n      msg_c : C -> Msg\n      msg_d : D -> Msg\n      msg_e : E -> Msg\n      msg_f : F -> Msg\n      \n  \n  --- Example (Replace with your rules):\n  rl\n    send_a_f(x,y)  -> receive_a_f(x,y)\n  [owise] .\n  rl\n    send_b_pub(x,y)  -> receive_b_pub(x,y)\n  [owise] .\n  rl\n    send_c_m(x,y)  -> receive_c_m(x,y)\n  [owise] .\n  rl\n    send_d_m(x,y)  -> receive_d_m(x,y)\n  [owise] .\n  rl\n    send_e_m(x,y)  -> receive_e_m(x,y)\n  [owise] .\n  rl\n    send_f_m(x,y)  -> receive_f_m(x,y)\n  [owise] .\n    \n  \n  rl\n    send_a_f(a, fresh(f)) -> receive_a_f(a, fresh(f))\n      [owise].\n  rl\n    send_b_pub(b,pub(p)) -> receive_b_pub(b,pub(p))\n      [owise].\n\n\nendfm\n\n```"]], "MAUDE-1/Otway-Rees.maude": [[true, "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sort\n    A B C Msg Fresh Public .\n  op\n    a : -> A .\n    b : -> B .\n    c : -> C .\n    msg1 : -> Msg .\n    msg2 : -> Msg .\n    fresh1 : -> Fresh .\n    fresh2 : -> Fresh .\n    public1 : -> Public .\n  \n  --- Additional operations (replace with your protocol's operations)\n  op\n    keygen : -> (Fresh Public) .\n    enc : Fresh Msg -> Msg .\n    dec : Fresh Msg -> Msg .\n    sign : Fresh Msg -> Msg .\n    verify : Fresh Msg -> Bool .\n\n  ---  Example:  Operations for the Otway-Rees protocol\n  ---  Replace with your specific syntax.\n  vars M1 M2 : Msg .\n  vars F1 F2 : Fresh .\n  vars P1 P2 : Public .\n\n\n  eq enc(F1, M1) = M1 .\n  eq dec(F1, enc(F1,M1)) = M1 .\n  eq sign(F1, M1) = M1 .\n  eq verify(F1, sign(F1,M1)) = true .\n    \nendfm\n\nfmod OTWAY-REES-PROTOCOL is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  --- Protocol rules\n  vars A B C : Msg .\n  vars F1 F2 : Fresh .\n  vars P1 P2 : Public .\n  \n  --- Client to Server\n  rl [client-to-server-1] :\n    A -> A .\n  rl [client-to-server-2] :\n    A -> B .\n  \n  --- Server to Client\n  rl [server-to-client-1] :\n    B -> C .\n    \nendfm\n\nmod OTWAY-REES-INIT is\n  protecting OTWAY-REES-PROTOCOL .\n\n  sort Init .\n  op init : -> Init .\n  \n  vars M1 M2 : Msg .\n  vars F1 F2 : Fresh .\n  vars P1 P2 : Public .\n\n  eq init = a .\n\nendm"]]}