{"SPTHY-1/9.spthy": [[true, "theory nine\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Pk($S, pk(k_S)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          !Sk($S, sk(k_S))\n        ]\n        --[  ]->\n        [ St_i\n]\nend"]], "SPTHY-1/ake_KEAplus.spthy": [[true, "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk( $I, pkR) ]\n   -->\n   [ !Req( $R, hkI ) ]"]], "SPTHY-1/DH_Message_Deduction.spthy": [[true, "theory DH_Message_Deduction\nbegin\n\n\nsection{* P_Msg *}\n\n/*\n * Protocol:\tP_Msg\n * Modeler: \tBenedikt Schmidt\n * Date: \tOctober 2012\n * Source:\t\"Ph.D. Thesis: Formal Analysis of\n *               Key Exchange Protocols and Physical\n *               Protocols\"\n *\n * Status: \tWorking\n */\n\n/* This is an example protocols that is used in the\n   the thesis to demonstrate various concepts */\n\nbuiltins: diffie-hellman\n\nrule Start:\n  [ Fr(~x), Fr(~y) ]\n  --[ Start() ]->\n  [ S(~x), Out(<('g'^~x)^~y,inv(~y)>)]\n\nrule Fin:\n  [ S(~x), In(('g'^~x)) ] --[ Fin() ]-> [ ]\n\nlemma key_deducible:\n  exists-trace\n  \"Ex #i #x #y.\n     Start() @ i &\n     S(~x) @ i &\n     Out(<('g'^~x)^~y,inv(~y)>) @ i &\n     In(('g'^~x)) @ i\n     \""]], "SPTHY-1/Example-R.spthy": [[true, "/*\nInitial Example for the Tamarin Manual\n======================================\n\nAuthors: \tSimon Meier, Benedikt Schmidt\nUpdated by: \tJannik Dreier, Ralf Sasse\nDate: \t        June 2016\n\nThis file is documented in the Tamarin user manual.\n\n*/\n\ntheory running_ex_R\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\n// Registering a public key\nrule Register_pk:\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n  -->\n    [ Out(pubkey) ]\n\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n// Start a new thread executing the client role, choosing the server\n// non-deterministically.\nrule Start_client:\n    [ ]\n  -->\n    [ !ChooseServer(S), !Client(S) ]"]], "SPTHY-1/issue193.spthy": [[true, "theory RevealingSignatures\nbegin\n\nfunctions: h/7\nbuiltins: hashing, revealing-signing\n\nrule ONE:\n  let\n    pk = pk( ~sk )\n    tSig = revealSign( ~random, ~sk )\n  in\n    [\n        Fr( ~sk )\n      , Fr( ~random )\n    ]\n  --[  ]->\n    [ Out( tSig ), Key(~sk) ]\n\nrule TWO:\n  let\n    m = getMessage( sig )\n    pk = pk( ~sk )\n  in\n    [\n        In( sig )\n      , Key( ~sk )\n    ]\n  --[ Equality(revealVerify(sig,m,pk),true), A() ]->\n    [  ]\n\nlemma debug: exists-trace\n  \"\n    Ex #i . A() @ i\n  \"\n\nrestriction equality:\n  \" All x y #i. Equality(x,y)@i ==> x = y \"\n\nend"]], "SPTHY-1/final_protocol_and_property-6.spthy": [[false, "```\ntheory Protocol3\nbegin\n\nbuiltins: asymmetric-encryption, symmetric-encryption\n\n// Public key infrastructure\nrule Register_pk:\n    [ Fr(~ltk) ]\n    -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n    -->\n    [ Out(pubkey) ]\n\n// Protocol\nrule A_1:\n    let pkB = pk(~ltkB)\n    in\n    [ Fr(~key), !Pk(B, pkB) ]\n    --[ Send(A, <A, senc(<A, M>, ~key)>) ]->\n    [ Out(<A, senc(<A, M>, ~key)>), A_State_1(A, B, ~key, pkB) ]\n\nrule B_1:\n    let M = adec(snd(msg), ~ltkB)\n        pkB = pk(~ltkB)\n    in\n    [ !Ltk(B, ~ltkB), In(<A, senc(<A, M>, key)>), Fr(~n) ]\n    --[ Recv(A, <A, senc(<A, M>, key)>) ]->\n    [ !Msg(B, M), B_State_1(A, B, ~n) ]\n\n// States\nrule A_State_1:\n  [A_State_1(A, B, ~key, pkB)]\n  -->\n  [Out(<A, M>)]\n\nrule B_State_1:\n  [B_State_1(A, B, ~n)]\n  -->\n  [Out(M)]\n\n\n\n// Auxiliary functions\nfunction pk(ltk):\n    return pk(ltk)\n\nfunction senc(msg, key):\n    return enc(msg, key)\n\nfunction adec(msg, key):\n    return dec(msg, key)\n\n\n// Data types\ntype Ltk is string\ntype Pk is string\ntype Key is string\ntype Msg is string\n\n\n// Example usage\n// This is not part of the protocol but demonstrates how to use the protocol\nrule Example:\n    [ Fr(ltkA), Fr(ltkB) ]\n    -->\n    [ Register_pk, Register_pk]\n```"]], "SPTHY-1/Google2Step_EA.spthy": [[true, "#include \"prelude.thy\"\n\n#define LABEL_0 \"fresh\"\n#define PRE_0 \"fresh\"\n#define LABEL_1 \"receive\"\n#define PRE_1 \"receive\"\n#define LABEL_2 \"send_secure\"\n#define PRE_2 \"secure\"\n\n\n#ifdef trained\naxiom only_trained_humans:  \n  \t\"Ex H x #k. H_role(H,x) @k\"\n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh(LABEL_0,$x.1,PRE_0), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive(LABEL_1,$x.1,PRE_1), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,$x.1,"]], "SPTHY-1/injectivity.spthy": [[true, "/*\n   Protocol:    Injectivity test\n   Modeler:     Nick Moore\n   Date:        May 2017\n\n   Status:      working\n\n   A simple toy example that requires the injectivity constraint-reduction rule\n   to terminate.\n\n*/\n\ntheory injectivity begin\n\nrule Init:\n  [ Fr(~i) ]\n--[ Initiated(~i) ]->\n  [ Inj(~i) ]\n\nrule Copy:\n  [ Inj(i) ]\n--[ Copied(i) ]->\n  [ Inj(i) ]\n\nrule Remove:\n  [ Inj(i) ]\n--[ Removed(i) ]->\n  []\n\nlemma injectivity_check[use_induction]: all-traces\n  \"\u00ac(Ex id #____(LEM_0)____ #____(LEM_1)____ #k.\n        Initiated(id) @ i & Removed(id) @ ____(LEM_2)____ & Copied(id) @ k\n        & #i < #j & #j < #k)\"\n\nend"]], "SPTHY-1/JCS12_Typing_Example.spthy": [[true, "theory JCS12_Typing_Example\nbegin\n\n/*\n   Protocol:    Typing Assertion Example from our JCS'12 paper [1]\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working\n\n   Notable differences: We do not require a fixed type system. Instead we\n   introduce actions marking sent cryptographic components and actions marking\n   that a participant instantiated a variable, which it received as part of a\n   cryptographic component. The sources assertion is then the trace formula\n   stating that this variable was either known to the adversary before it was\n   instantiated or the cryptographic component stems from the expected origin.\n\n   [1] Efficient\n*/\n\n// Types\ntype msg = { a : int, b : int }\n\n// Roles\nrole Alice\nrole Bob\n\n// Actions\naction alice_send(m : msg) : Alice -> Bob\naction bob_receive(m : msg) : Bob -> Bob\naction alice_inst(x : int) : Alice -> Alice\naction bob_inst(x : int) : Bob -> Bob\n\n\n// Protocol Description\nprotocol typing_example\n{\n  alice_send(m1)\n  bob_receive(m1)\n  bob_inst(x1)\n  alice_inst(x2)\n}\n\n\n// Assertions\n// Typing assertion for Bob's instantiation\nassertion bob_inst_typing(x1 : int) : Bob\n{\n  exists m1 : msg.\n  (\n  bob_receive(m1) & m1.a = x1\n  ) | (\n  exists m0 : msg.\n  (\n   m0.a = x1 & m0.b = x0 &\n   pre(bob_receive(m0))\n  )\n  )\n}\n\n\n// Typing assertion for Alice's instantiation\nassertion alice_inst_typing(x2 : int) : Alice\n{\n  exists m1 : msg.\n  (\n   alice_send(m1) & m1.b = x2\n  ) | (\n  exists m0 : msg.\n  (\n   m0.a = x0 & m0.b = x2 &\n   pre(alice_send(m0))\n  )\n  )\n}\n\n\n// Additional assertions (placeholder)\n// Add more assertions as needed for the complete protocol.\n// For example, an assertion that the values of the messages are well-formed.\n//  or assertions for other roles (e.g., a verifier, that has to check).\n\n//Example assertion for a message's well-formedness\nassertion msg_well_formed(m : msg)\n{\n  m.a >= 0 & m.b >= 0\n}\n\n\n//Main assertion (placeholder)\n// This is where you would define the overall protocol property\n// using the previous assertions, possibly other assumptions, etc.\nassertion main_assertion\n{\n  bob_inst_typing(x1) & alice_inst_typing(x2) & msg_well_formed(m1)\n}\n\n\n\nend"]], "SPTHY-1/JKL_TS2_2008_KI_wPFS.spthy": [[true, "theory JKL_TS2_2008_KI_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* Jeong, Katz, Lee : TS2 (2008) *}\n/*\n * Protocol:\tJKL-TS2-2008\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"One-Round Protocols for Two-Party Authenticated Key Exchange\"\n * \t\tJeong, Katz, Lee, 2008\n *\t\tNote: Although the paper title is the same as the 2004\n *\t\toriginal, the updated version from 2008 includes\n *\t\tmodified protocols and security models.\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, $A ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ] -->\n   [ !Pk( $I, $I ) ]\n\nrule Init_2:\n   [ In( 'g'^~lkI ), !Ltk( $I, ~lkI ) ] -->\n   [ !S( $I, ~ekI ) ]\n\nrule Final_1:\n  [ In( 'g'^~lkI ), !Ltk( $I, ~lkI ), !S( $I, ~ekI ) ] -->\n  [ !Ek( $I, ~ekI ) ]\n\n\nrule Final_2:\n  [ In( 'g'^~lkI ), !Ltk( $I, ~lkI ), !S( $I, ~ekI ), !Ek( $I, ~ekI ) ] -->\n  [ !Sk( $I, ~ekI ) ]\n\n\nend"]], "SPTHY-1/Joux.spthy": [[true, "theory Joux\nbegin\n\nsection{* The Joux Protocol using Signatures*}\n\n/*\n * Protocol:\tThe Joux Protocol.\n * Source:      \"A One Round Protocol for Tripartite Diffie-Hellman\"\n *              A. Joux\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n *\n * Model:       PFS\n * Status: \tworking\n */\n\nbuiltins: bilinear-pairing, signing, multiset\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ] \n  --[ ]-> \n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]\n\n// Reveals\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Proto1:\n  let hkA = pmult(~ekA ,'P')\n  in\n  [ Fr(~ekA), !Ltk($A, ~ltk), !Pk($A, pk(~ltk)),  !Sig($A, sig_a(~ltk, hkA))]\n  --[ ]->\n  [ !Ltk($B, ~ltk), !Pk($B, pk(~ltk)), !Sig($B, sig_b(~ltk, hkA)), Out(hkA) ]\n\nrule Proto2:\n  [ !Ltk($A, ltk), !Pk($A, pk(~ltk)), !Sig($A, sig_a(~ltk, hkA)), !Ltk($B, ~ltk), !Pk($B, pk(~ltk)), !Sig($B, sig_b(~ltk, hkA)), Out(hkA)]\n  --[ ]->\n   [ ]\n\nrule Proto3:\n\t[ Out(hkA) ]\n\t--[ ]->\n\t[ ]\n\n// Helper rules (example)\nrule Generate_keypair:\n\t[ ]\n\t--[ ]->\n\t[ Fr(~sk), !Sk($A, ~sk), !Pk($A, pk(~sk))]\n\n\n\nend"]], "SPTHY-1/KAS1.spthy": [[true, "theory KAS1\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS1 *}\n\n/*\n * Protocol:\tKAS1\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\tWeakened version of the model for the initiator only,\n * \t\tmotivated by the informal remarks for KAS1 security in the paper.\n *\n * Status: \tworking\n *\n * Notes:\tConfirming the results from the paper, we find that we\n * \t\tcannot allow:\n * \t\t- compromise of the peer's long-term key\n * \t\t- compromise of the test session's ephemeral key\n *\n * \t\tThe model covers KCI and KI.\n */\n\nfunctions: KDF/1\nfunc\n\ntypes:\n\tpublic_key, private_key, session_key, message,\n    hash, ephemeral_key, long_term_key\n\nvariables:\n\tA, B, msg\n\t\nmessages:\n\tM1(A, ephemeral_key(A), hash(A, ephemeral_key(A))),\n\tM2(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)),\n\tM3(A, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)),\n\tM4(A, ephemeral_key(B), hash(B, ephemeral_key(B)), session_key(A,B)),\n\tM5(B, ephemeral_key(B), hash(B, ephemeral_key(B))),\n\tM6(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)),\n\tM7(B, ephemeral_key(A), hash(A, ephemeral_key(A))),\n\tM8(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)),\n\tM9(A, ephemeral_key(B), hash(B, ephemeral_key(B))),\n\tM10(A, ephemeral_key(B), hash(B, ephemeral_key(B)), session_key(A,B))\n\n\ninitiator: A\n\nrole(A):\n    A -> M1(A, ephemeral_key(A), hash(A, ephemeral_key(A))),\n    M2(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)) <- B,\n    M3(A, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)) <- B,\n    M4(A, ephemeral_key(B), hash(B, ephemeral_key(B)), session_key(A,B)) <- B\n\n\nrole(B):\n    M1(A, ephemeral_key(A), hash(A, ephemeral_key(A))) <- A,\n    B -> M5(B, ephemeral_key(B), hash(B, ephemeral_key(B))),\n    M6(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)) <- A,\n    M7(B, ephemeral_key(A), hash(A, ephemeral_key(A))) <- A,\n    M8(B, ephemeral_key(A), hash(A, ephemeral_key(A)), session_key(A,B)) <- A,\n    M9(A, ephemeral_key(B), hash(B, ephemeral_key(B))) <- A,\n    M10(A, ephemeral_key(B), hash(B, ephemeral_key(B)), session_key(A,B)) <- A\n\nend"]], "SPTHY-1/ake_NAXOS.spthy": [[true, "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]"]], "SPTHY-1/KCL07.spthy": [[true, "theory KCL07 begin\n\nbuiltins: xor, hashing\n\n/*\nKCL07: Reader R, RFID tag T, shared knowledge k, ID\n\n   R: knows(k, ID)\n   T: knows(k, ID)\n   R: fresh(r1)\nR->T: r1\n   T: fresh(r2)\nT->R: ID XOR r2,  h(r1,k) XOR r2  \n   \n   R considers T recent alive if it can find ID, k such that\n     the pair of terms received from T in the last step satisfies\n     \n     ID XOR r2  XOR  h(r1,k) XOR r2   =   ID XOR h(r1,k)\n\nrecent aliveness is satisfied, but untracability is not.\nThe model below only considers recent aliveness at the moment.\n*/\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ OnlyOnce( ) ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ !Reader( ~k, ~id ), Fr( ~r1 ) ]\n --[  ] ->\n   [ !Reader( ~k, ~id ), !Reader( ~k, ~id ), ~r1 ]\n\n\nrule tag1:\n   [ !Tag( ~k, ~id ), !Reader( ~k, ~id ), ~r1 ]\n --[  ] ->\n   [ !Tag( ~k, ~id ), !Reader( ~k, ~id ), ~r1, Fr(~r2) ]\n\n\nrule tag2:\n   [ !Tag( ~k, ~id ), !Reader( ~k, ~id ), ~r1, ~r2 ]\n --[ ~id XOR ~r2 = ~id XOR h(~r1,~k) ]->\n   [ !Tag( ~k, ~id ), !Reader( ~k, ~id ), ~r1, ~r2 , ~id XOR ~r2, h(~r1,~k) XOR ~r2  ]\n\n\nrule reader2:\n   [ !Reader( ~k, ~id ), ~r1, ~id_rec, ~k_rec, ~r2_rec,  ~id_rec XOR ~r2_rec, h(~r1,~k_rec) XOR ~r2_rec ]\n --[ ~id_rec XOR ~r2_rec = ~id_rec XOR h(~r1,~k_rec) ] ->\n   [ !Reader( ~k, ~id ), ~r1, ~id_rec, ~k_rec, ~r2_rec,  ~id_rec XOR ~r2_rec, h(~r1,~k_rec) XOR ~r2_rec,  RecentAlive ]\n\nend"]], "SPTHY-1/katz-yung.spthy": [[true, "theory Katz_Yung\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ~ltk),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: C, rC\n// S->C: S, rS, g^x, Sig_S(g^x | C | rC | S | rS)\n// C->S: g^y, Sig_C(g^y | C | rC | S | rS)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~rC)\n  ]\n  --[ ClientSentRequest(C, $S, ~rC) ]->\n  [\n    ClientWait(C, $S, ~rC, ltkC),\n    Out(~rC)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <gx, C, rC, S, rS>\n    msgOut = <'g'^~y, C, rC, S, rS>\n  in\n  [\n    ClientWait(C, $S, ~rC, ltkC),\n    In(msgIn),\n    !Sig(S, gx, C, rC, S, rS),\n    Fr(~y)\n  ]\n  --[ ClientReceivedResponse(C, $S, ~rC, msgIn) ]->\n  [\n    Out(msgOut),\n    !Sig(C, 'g'^~y, C, rC, S, rS)\n  ]\n\n// Server logic\nrule ServerInit:\n  [\n    !Pk(S, pkS),\n    In(~rC),\n    !Ltk(S, ltkS)\n  ]\n  --[ ServerReceivedRequest(S, C, ~rC) ]->\n  [\n    ServerWait(C, $S, ~rC, ltkS),\n    Fr(~x),\n    Out(<'g'^~x, S, ~rS, C, ~rC>),\n    !Sig(S, <'g'^~x, C, ~rC, S, ~rS>)\n  ]\n\nrule ServerFinish:\n  let\n    msgIn = <'g'^~y, C, rC, S, rS>\n  in\n    [\n      ServerWait(C, $S, ~rC, ltkS),\n      In(msgIn),\n      !Sig(C, 'g'^~y, C, rC, S, rS)\n    ]\n    --[ ServerReceivedResponse(C, $S, ~rC, msgIn) ]->\n    [\n      // Verification\n    ]\n\n\n\nend"]], "SPTHY-1/KEA_plus_KI_KCI.spthy": [[true, "theory KEA_plus_KI_KCI\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* KEA+ *}\n/*\n * Protocol:\tKEA+\n * Modeler: \tCas Cremers\n * Date: \tJanuary/April 2012\n * Source:\t\"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * \t\tLauter, Mityagin, 2006\n * Property:\tKI, KCI\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n  let pkA = 'g'^~lkA\n  in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI, $I, $R, epkI ) ]->\n   [ Init_1( ~ekI, $I, $R, epkI, $R ),\n     !E( $R, $I ) ]\n\nrule Init_2:\n  [ Init_1( ~ekI, $I, $R, epkI, $R ), !E( $R, $I ) ]\n  --[ SidI_2( $R, $I, epkI ) ]->\n  [ Init_2( $R, $I, epkI ) ]\n\n\nrule Resp_1:\n   [ Init_2( $R, $I, epkI ) ]\n   --[ SidR_1( $R, $I, epkI ) ]->\n   [ Resp_1( $R, $I, epkI ) ]\n\n\nrule Resp_2:\n  [ Resp_1( $R, $I, epkI ) ]\n  --[ Out( ____(PRE_2)____ ) ]->\n  [ Resp_2( $R, $I, epkI ) ]\n\n\nrule ____(RULE_NAME_0)____:\n  [ Resp_2( $R, $I, epkI ) ]\n  --[ ____(PRE_3)____ ]->\n  [ ____(POST_1)____ ]\n\n\nrule ____(RULE_NAME_1)____:\n  [ ____(PRE_4)____ ]\n  --[ ____(PRE_5)____ ]->\n  [ ____(POST_2)____ ]\n\n\n\nend"]], "SPTHY-1/Keyserver.spthy": [[true, "theory Keyserver begin\n\n/*\n * Protocol:\tThe keyserver example from [1]\n * Modeler: \tSimon Meier\n * Date: \tJune 2012\n *\n * Status: \tworking\n\n\n [1] Sebastian Moedersheim: Abstraction by set-membership: verifying security\n protocols and web services with databases. ACM Conference on Computer and\n Communications Security 2010: 351-360\n\n The original model from [1].\n\n    Problem: zebsKeyserver;\n\n    Types:\n    Agent  : {a,b,c,i,s};\n    U      : {a,b,c};\n    S      : {s};\n    H      : {a,b};\n    D      : {c,i};\n    DU     : {c};\n    Sts    : {valid,revoked};\n    PK,NPK : value;\n    M1,M2  : untyped;\n\n    Sets:\n    ring(U), db(S,U,Sts);\n\n    Functions:\n    public s\n\n    Variables:\n    a,b,c,i,s   : Agent;\n    u,v        : U;\n    h          : H;\n    d          : D;\n    du         : DU;\n    sts        : Sts;\n    pk, npk    : PK;\n    m1,m2     : M1;\n\n\n    Init:\n    ring(U) = {{a,b,c}};\n    db(s,u,sts) = {};\n\n    Actions:\n    // Key Request\n    kr(a,u,pk) -> ring(U) = ring(U), db(s,u,sts) = db(s,u,sts)\n    {\n        // Precondition: u is in the ring\n        u in ring(U)\n    };\n    // Key Reply\n    kr(a,u,pk) -> ring(U) = ring(U), db(s,u,sts) = db(s,u,sts)\n    {\n        // Precondition: u is in the ring and there exists a valid entry for u\n        u in ring(U) and exists sts : db(s,u,sts) = {valid}\n    };\n\n    // Key Revocation\n    kr(a,u,pk) -> ring(U) = ring(U), db(s,u,sts) = db(s,u,sts)\n    {\n        // Precondition: u is in the ring and there exists a revoked entry for u\n        u in ring(U) and exists sts : db(s,u,sts) = {revoked}\n    };\n\nend"]], "SPTHY-1/Minimal_HashChain.spthy": [[true, "theory Minimal_HashChain begin\n\n/*\n  Protocol:    A minimal HashChain example (inspired by TESLA 2)\n  Modeler:     Simon Meier\n  Date:        August 2012\n\n  Status:      note yet working\n               (requires multiset or repeated exponentiation reasoning)\n\n  This models the key difficulty in the proof of the TESLA 2 protocol with\n  re-authentication: the verification that the key checking process is\n  sufficient to guarantee that the key is a key of the hash-chain.\n*/\n\nfunctions: f/1\n\n// Chain setup phase\n////////////////////\n\n// Hash chain generation\nrule Gen_Start:\n  [ Fr(seed) ] --> [ Gen(seed, seed), Out(seed) ]\n\n// The NextKey-facts are used by the s\nrule Gen_Step:\n  [ Gen(prev_key, next_key), Out(prev_key) ] --> [ Gen(next_key, f(next_key)), Out(prev_key), Out(next_key) ]\n\n// Chain termination\nrule Gen_Stop:\n  [ Gen(prev_key, next_key), Out(prev_key), Out(next_key) ] --> [ Out(prev_key), Out(next_key) ]\n\n// Output rules\nrule Out_rule:\n\t[Out(x)] --> []\n\n// Example of a possible attack\n//rule Attack:\n//\t[Attacker(x)] --> [Attacker(f(x))]\n\n// Example of a possible defence\n//rule Defence:\n//\t[Defender(x)] --> [Defender(x), Out(f(x))]\n\n// Example of a possible attack\n//rule Attack:\n//\t[Attacker(x)] --> [Attacker(x),Attacker(f(x))]\n\n// Example of a possible defence\n//rule Defence:\n//\t[Defender(x)] --> [Defender(x), Out(x)]\n\n// Initialisation\nrule Init:\n  [] --> [ Fr(seed) ]\n\n\n// Example of a possible attack\n//rule Attack:\n//  [Attacker(x)] --> [Attacker(f(x))]\n\n// Example of a possible defence\n//rule Defence:\n//  [Defender(x)] --> [Defender(x), Out(x)]\n\n\n// Specification of the output\n//rule Output_Specification:\n//\t[ Out(x) ] --> [x]\n\n\n\n\n// Example of a possible attack\n//rule Attack:\n//\t[Attacker(x)] --> [Attacker(f(x))]\n\n\n// Example of a possible defence\n//rule Defence:\n//\t[Defender(x)] --> [Defender(x), Out(x)]\n\n\n\n\n// Specification of the output\n//rule Output_Specification:\n//\t[ Out(x) ] --> [x]\n\n// Example of a possible attack\n//rule Attack:\n//\t[Attacker(x)] --> [Attacker(f(x))]\n\n// Example of a possible defence\n//rule Defence:\n//\t[Defender(x)] --> [Defender(x), Out(x)]\n\n\n// Specification of the output\n//rule Output_Specification:\n//\t[ Out(x) ] --> [x]\n\n\n\n// Add a function to calculate the hash\n// This is a placeholder; you should define the actual hash function here\n// For simplicity, we'll assume a simple function\n//rule Hash_Calculation:\n//\t[Out(x)] --> [Out(f(x))]\n//\n\n// Add a function to calculate the hash\n// This is a placeholder; you should define the actual hash function here\n// For simplicity, we'll assume a simple function\n//rule Hash_Calculation:\n//\t[Out(x)] --> [Out(f(x))]\n\n\n// Specification of the output\n//rule Output_Specification:\n//\t[ Out(x) ] --> [x]\n\n\n// Specification of the output\n//rule Output_Specification:\n//\t[ Out(x) ] --> [x]\n\n\n\n//Specification of the output\n//rule Output_Specification:\n//  [Out(x)] --> [x]\n//\n\n\n// Specification of the output\nrule Output_Specification:\n  [Out(x)] --> [x]\n\nend"]], "SPTHY-1/mls-04a.spthy": [[true, "theory MLS04\nbegin\n\nbuiltins: hashing, signing, asymmetric-encryption\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk(____(~ltk)____, ____(ltk)____),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n// Client logic\nrule ClientInit:\n  let\n    gx = pk(~x)\n    pkC = pk(ltkC)\n    sig = sign(<gx, C, pkC>, ltkC)\n    uik = <gx, C, pkC, sig>\n  in\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientPostedInitKey(C, gx) ]->\n  [\n    ClientWait(C, ~x, ltkC),\n    Out(uik)\n  ]\n\nrule ClientFinish:\n  let\n    gx = pk(x)\n    pkC = pk(ltkC)\n    welcomeI = <gx,C,pkC>\n    // welcomeI\n\n\n  in\n  [\n    !Ltk(C, ltkC),\n    ClientWait(C, x, ltkC)\n  ]\n  --[ ClientPostedFinishKey(C, gx) ]->\n  [\n    Out(welcomeI)\n  ]\n\nend"]], "SPTHY-1/MPAuth_MA_NoTellOK.spthy": [[true, "rule H_send_S1:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send(LABEL_1,$x.1,x.2), \n\t    Send(LABEL_2,$y.1,y.2),\n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<x.1,y.1>,<x.2,y.2>) ]\n\nrule H_send_S2:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(LABEL_3,$x.1,x.2), \n\t    Send(LABEL_4,$y.1,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<x.1,y.1,z.1>,<x.2,y.2,z.2>) ]\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(LABEL_4,$x.1,x.2), \n\t    Send(LABEL_5,PRE_8,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To(PRE_9)]->\n\t[ Out_S($H,$A,<PRE_10,$y.1,POST_1>,<x.2,y.2,z.2>) ]\n\nrule H_send_S4:\n\t[ !HK(PRE_4,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send(PRE_13,$x.1,x.2), \n\t\tSend(PRE_14,$y.1,y.2),\n\t\tSend(LABEL_6,$z.1,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S(PRE_16,PRE_15,<x.1,$y.1,$z.1,$w.1>,<x.2,y.2,z.2,POST_2>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( $A,$H, <$x.1,$y.1>, <PRE_17,y.2> ) ]\n\t--[ Receive($x.1,x.2), Receive($y.1,y.2), H($H), To($A)]->\n\t[  ]"]], "SPTHY-1/NAXOS_eCK.spthy": [[true, "theory NAXOS_eCK\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tCas Cremers, Benedikt Schmidt\n * Date: \tJanuary 2012/April 2012/October 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \teCK security\n *\n * Status: \tWorking\n */\n\nfunctions: h1/1\nfunctions: h2/1\n\n/* Protocol rules */\n\n/* In the description in the paper, we omitted the sorts. \n * In this description they are made explicit.\n * '$A' is equivalent to 'A:pub'\n * '~x' is equivalent to 'x:fresh'\n */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n  let pkA = 'g'^~ea \n  in\n  [ Fr(~ea) ] \n\n/* Client initiates */\nrule client_init:\n  let A = $A, B = $B\n  in\n  [ A -> B : $N(A,B) ]\n\n/* Server responds */\nrule server_resp:\n  let A = $A, B = $B, N = $N(A,B)\n  in\n  [ B -> A : $N(A,B), $k(B) ]\n\n/* Client completes */\nrule client_comp:\n  let A = $A, B = $B, N = $N(A,B), k = $k(B)\n  in\n  [ A -> B : $k(B), $g^~ra ]\n\n/* Server completes */\nrule server_comp:\n  let A = $A, B = $B, N = $N(A,B), k = $k(B), ra = $g^~ra\n  in\n  [ B -> A : $k(B), $g^~rb ]\n\n\n/* Auxiliary predicates */\nrule Fr(~x):\n    [ ~x ]\n\n/*  The following rules are required to prove the eCK security property. */\nrule key_computation:\n    let x = ~ea, y = ~rb\n    in\n    [ h1(g^x) = h2(g^y) ]\n\n/*  The following rules are required to prove the eCK security property. */\nrule key_computation2:\n    let x = ~ea, y = ~rb\n    in\n    [ h1(g^x) = h2(g^y) ]\n\n\n/*  The following rules are required to prove the eCK security property. */\nrule key_computation3:\n    let x = ~ea\n    in\n    [ h1(g^x) = h1(g^x) ]\n\n/*  The following rules are required to prove the eCK security property. */\nrule key_computation4:\n    let x = ~ea, y = ~rb\n    in\n    [ h1(g^x) = h2(g^y) ]\n\nend"]], "SPTHY-1/NSLPK3.spthy": [[true, "theory NSLPK3\nbegin\n\nbuiltins: asymmetric-encryption\n\n/*\n   Protocol:    The classic three message version of the\n                Needham-Schroeder-Lowe Public Key Protocol\n   Modeler:     Simon Meier\n   Date:        June 2012\n   Source:      Modeled after the description by Paulson in\n                Isabelle/HOL/Auth/NS_Public.thy.\n\n   Status:      working\n\n   Note that we are using explicit global constants for discerning the\n   different encryption instead of the implicit sources.\n */\n\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk(ltkA, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(ltkA, ~ltkA), In(pk(~ltkB)) ]\n  -->\n  [ !Pk($B, pk(~ltkB)) ]"]], "SPTHY-1/OTPoverSMS_EA.spthy": [[true, "/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"____(LEM_0)____ (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh(____(PRE_0)____,$x.1,~x), !HK(____(LABEL_0)____,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,\n$x.1) ]"]], "SPTHY-1/alethea_sel_SmHh.spthy": [[true, "rule D_0: \n\t[ AgSt_D0($D,<spkDs,spkDa,spkDb> )\n\t, PseudonymsPublished() \t\t\t\t// this fact models that only after this rule the event in the environment takes place. Auditors would see if this order was not preserved in reality. Thus, this fact models that at least one auditor does the check that the event in the environment happens after the voter codes have been published.\n\t]\n\nrule D_1: \n\t[ AgSt_D0($D,<PRE_14,$S,~eskD,pkS> )\n\t, In(<$S, aenc(x,pk(~eskD)) >)\n\t\n\t]\n\t--[ \tD(PRE_15), \n\t\tRunning_DS(PRE_17,$S,<pk(~eskD),pkS,h(PRE_16,LABEL_3)>),\n\t\tCommit_DBB(LABEL_2,<pk(h($H,x))>),\n\t    \tSecret($D,x),\n\t\tPseudonym($H, pk(h($H,x)))\n\t]->\n\t[ Out_S($D,$H,pk(h($H,x)))\n]"]], "SPTHY-1/Pattern_matching_and_destructors.spthy": [[true, "theory Pattern_matching_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration how pattern matching can be described by\n                destructor functions\n   Modeler:     Simon Meier, Benedikt Schmidt\n   Date:        July 2012\n\n   Status:      working (warning that constant 'true' is not allowed)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors.\n*/\n\n\nbuiltins: symmetric-encryption, hashing\nfunctions: isPair/1, true/0, encSucc/2, and/2\n\nequations: isPair( pair(x, y) ) = true\nequations: encSucc(senc(x,y),y) = true\nequations: and(true,true) = true\n\n// Shared keys that can be compromised.\nrule Setup_Key:\n  [ Fr(~k) ->\n    G(~k) ]\n\n// Alice sends a message to Bob.\nrule Alice_Sends_Message:\n  [ Ha(~m), Fr(~k) ->\n    G(senc(~m,~k)) ]\n\n// Bob receives a message from Alice.\nrule Bob_Receives_Message:\n  [ G(senc(~m,~k)) ->\n    Ha(~m),\n    G(encSucc(senc(~m,~k), ~k)) ]\n\n// Bob checks if the encrypted message is valid.\nrule Bob_Checks_Message:\n  [ G(encSucc(senc(~m,~k), ~k)) ->\n    G(true) ]\n\n\n//  Example with pattern matching\nrule Bob_Receives_Pair:\n  [ G(pair(~m, ~k)) ->\n    G(isPair(pair(~m, ~k))) ]\n\n// Example with failing pattern matching\nrule Bob_Receives_Not_Pair:\n  [ G(pair(~m, ~k)) ->\n    G(isPair(~m)) ]\n\n// Example with a successful and operation\nrule Bob_Receives_And_True:\n  [ G(true), G(true) ->\n    G(and(true, true))]\n\n\n// Example with a failed and operation\nrule Bob_Receives_And_False:\n  [ G(true), G(false) ->\n    G(and(true, false))]\n\n\nend"]], "SPTHY-1/PR1_ShHm.spthy": [[true, "theory PR1_ShHm\nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tProtocol PR_1\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Dispute Resolution in Voting\", David Basin, Sasa Radomirovic, and Lara Schmid, CSF20.\n* Disclaimer:\tThe pupose of this protocl is to establish a possibility result.\n\t\tWe specify a simple protocol with one voter, as this is sufficeint for demonstrating possibility.\n\n========\nRESULTS:\n========\n\n- lemma functional: verified \n- lemma AuthP: verified\n\n\n*/\n\n/*============\nSPECIFICATION:\n============== */\n\n/*=====================\nFunctions and equations \n======================= */\nbuiltins: signing, multiset\n\nfunction keygen(role:string): (key:string)\nfunction sign(key:string, msg:string): (sig:string)\n\nequation sign(keygen(role), msg) = sig(msg, role)\n\n/*=====================\nTypes\n======================= */\ntype msg = string\ntype key = string\ntype sig = string\ntype role = string\n\n/*=====================\nVariables\n======================= */\n\nvariables:\n    role,msg,key,sig: string\n\n/*=====================\nAxioms\n======================= */\n\naxiom\n  forall (role, msg, key):\n    sig(msg, role) = sign(keygen(role), msg)\n    \n/*=====================\nDefinitions\n======================= */\n\n\n/*=====================\nLemmas\n======================= */\n\n/*=====================\nAssumptions\n======================= */\n\n\nend"]], "SPTHY-1/probEnc.spthy": [[false, "```houzhui\ntheory probEnc \nbegin\n\n/*\n * Protocol:     Probabilistic encryption\n * Modeler:      Jannik Dreier and Ralf Sasse\n * Described in: Automated Symbolic Proofs of Observational Equivalence [CCS'15]\n * Date:         April 2015\n *\n * Status: \tworking\n// Observational equivalence is proven automatically in less than 0.4 seconds.\n */\n\nfunctions: penc/3, pdec/2, pk/1\n\nequations: pdec(penc(m,pk(k),r), k) = m\n\nrule gen:\n  [ Fr(~k) ]\n--[ ]->\n  [ !Key(~k), Out(pk(~k)) ]\n\nrule enc:\n  [ !Key(k), Fr(~r1), Fr(~r2), In(x) ]\n--[ ]->\n  [ Out(penc(x, pk(k), ~r1)) ]\n\nend\n```"]], "SPTHY-1/RFID_Simple.spthy": [[true, "theory RFID_Simple begin\n\n/*\n   Protocol:    Extended version of the running example from StatVerif paper\n   Modeler:     Simon Meier\n   Date:        May 2012\n\n   Status:      working\n\n   ...\n\n*/\n\n// Declare RFID/1 fact as globally fresh...for testing purposes.\n// unique_insts: RFID/1\n\nbuiltins: asymmetric-encryption\n\n// RFID Memory Cell model\n\nrule GenKey:\n    [ Fr(~sk)  // We let the key identify the device.\n    ]\n  --[ Device_Key(~sk) ]->\n    [ Device_Init(~sk)\n    , Device_Alice(~sk)\n    , Out(pk(~sk)) // make the public key available to the adversary\n    ]\n\nrule Alice:\n    [ Device_Alice(sk)\n    , Fr(~x)\n    , Fr(~y)\n    ]\n  --[ Exclusive(~x,~y)\n    , D(~x)\n    , D(~y)\n    ] ->\n    [ Device_Alice(sk)\n    , Fr(~x)\n    , Fr(~y)\n    , Out(Enc(pk(~sk),~x))\n    ]\n\nrule Device:\n  [ Device_Init(sk), In(Enc(pk(sk),x)) ]\n  --[ Dec(sk,Enc(pk(sk),x)) = x, Out(x) ]->\n  [ Device_Init(sk), In(Enc(pk(sk),x)), Out(x) ]\n\n\n// auxiliary rules for testing\nrule Test:\n  [ Device_Alice(sk), Fr(~x) ]\n  --[ Out(Enc(pk(~sk),~x)) ]->\n   [ Device_Alice(sk), Fr(~x) ]\n\n\n\n\n// auxiliary rules for testing\nrule Test2:\n  [ Device_Init(sk), In(Enc(pk(sk),x)) ]\n  --[ Dec(sk,Enc(pk(sk),x)) = x, Out(x) ]->\n   [ Device_Init(sk), In(Enc(pk(sk),x)), Out(x) ]\n\n// auxiliary rules for testing - this one is essential to check the freshness.\nrule Test3:\n  [ Fr(~sk), Fr(~x), Device_Init(~sk) ]\n  --[ Out(pk(~sk)) ]->\n   [ Fr(~sk), Fr(~x), Device_Init(~sk), Out(pk(~sk)) ]\n\n\n// auxiliary rules for testing - this one is essential to check the freshness.\nrule Test4:\n  [ Fr(~sk), Fr(~x), Device_Alice(~sk) ]\n  --[ Exclusive(~x,~x) ]->\n   [ Fr(~sk), Fr(~x), Device_Alice(~sk) ]\n\n\n\n// auxiliary rules for testing - this one is essential to check the freshness.\nrule Test5:\n  [ Fr(~sk), Device_Init(~sk), Fr(~x) ]\n  --[]->\n   [ Fr(~sk), Device_Init(~sk), Fr(~x) ]\n\n\n\n// auxiliary rule for testing purpose\nrule Test_Exclusive:\n    [ Fr(~x), Fr(~y) ]\n      --[ Exclusive(~x,~y) ]->\n      [ Fr(~x), Fr(~y) ]\n\n\n//Auxiliary rule for testing purpose.\nrule Test_In:\n  [ Fr(~x), Fr(~y) ]\n  --[ In(~x) ]->\n  [ Fr(~x), Fr(~y), In(~x) ]\n\n\n//Auxiliary rule for testing purpose.\nrule Test_Out:\n  [ Fr(~x), Fr(~y), Out(~x) ]\n  --[]->\n  [ Fr(~x), Fr(~y), Out(~x) ]\n\n\n// auxiliary rule for testing purpose, to have some output\nrule Test_Out2:\n    [ Out(~x) ]\n      --[]->\n      [ Out(~x) ]\n\n\n// auxiliary rule for testing purpose, to have some output\nrule Test_Out3:\n    [ In(~x) ]\n      --[]->\n      [ In(~x) ]\n\n\nend"]], "SPTHY-1/RF_dist_bound.spthy": [[true, "theory RF_dist_bound\nbegin\n\nsection{* RF Distance Bounding Protocol from the Usenix Paper of Kaspar\nRasmusson *}\n\n/* Modeler: Simon Meier\n   Date:   January, 2011\n   Status: Incomplete\n*/\n\nbuiltins: signing, hashing\n\n/* FIXME: Finish example\n\nrule Prov1:\n  [ Pub( P ), Fr( Np ) ]\n  -->\n  [ Prov1( P, Np )\n  , Out( sign{h(Np)}sk(lts(P)) ) ]\n\nrule Verif1:\n  [ Pub( V ), Fr( Nv ), In( sign{commit}sk(lts(P)) ) ]\n  -->\n  [ Verif1( V, P, Nv, commit )\n  , Challenge( Nv )\n  , Out( Nv ) ]\n\nrule Prov2:\n  [ Prov1( P, Np ), Challenge( Nv ) ]\n  -->\n  [ Prov2( P, Np, Nv ), Response( Nv, Np ), Out( Np ) ]\n\nrule Verif2:\n  [ Verif1( V, P, Nv, commit ), Response( Nv, Np )\n  , In( Np ) ]\n  -->\n  [ Verif2( V, P, Nv, commit, Np )\n  , Check( h(Np) == commit )\n  ]\n\n/* Example of a security property */\n\ninvariant:\n  [ Verif2( V, P, Nv, commit, Np ) ]\n  ==>\n  [ h(Np) == commit ]\nend"]], "SPTHY-1/SAKE.spthy": [[true, "/* Modified SAKE Protocol Description used for SAGE\n\nInvolved parties: verifier V, device D\n\nV:  random a\n    v0 = g^a mod p\n    v1 = h(v0)\n    v2 = h(v1)\n    c = cksum(v2)\n\nV -> D: v2\n\nD:  c = cksum(v2)\n    random r\n    w0 = h(c | r)\n    w1 = h(w0)\n    w2 = h(w1)\n    random b\n    k = g^b mod p\n\nD -> V: w2, mac(c, w2)\n\nV:  check if mac(c, w2) matches received mac\n\nV -> D: v1\n\nD:  check if v2 == h(v1)\n\nD -> V: w1, k, mac(w2, k)\n  \nV:  check if mac(w2, k) matches received mac\n    check if w2 == h(w1)\n\nV -> D: v0\n\nD:  check if v1 == h(v0)\n    sk_VD = v0^b = (g^a)^b mod p\n\nD -> V: w0\n\nV:  check if w1 == h(w0)\n    sk_VD = k^a = (g^b)^a mod p\n\n*/\n\n\ntheory SAKE\nbegin\n\n  type msg =\n    | V_to_D_v2 of (int)\n    | D_to_V_w2_mac of (int, int)\n    | V_to_D_v1 of (int)\n    | D_to_V_w1_k_mac of (int, int, int)\n    | V_to_D_v0 of (int)\n    | D_to_V_w0 of (int)\n\t;\n\n  type state =\n    | V_init of (int)\n    | D_init of (int)\n    | V_recv_w2_mac of (int, int, int, int)\n    | V_recv_w1_k_mac of (int, int, int, int, int)\n\t| V_recv_w0 of (int, int, int, int, int, int)\n\t| D_recv_v2 of (int, int, int)\n\t| D_recv_v1 of (int, int, int, int, int)\n\t| D_recv_v0 of (int, int, int, int, int, int)\n\t;\n\n  function mac (c: int, w2: int): int;\n  function h (x: int): int;\n  function cksum (x: int): int;\n  function pow (x: int, y: int): int;\n\n\n  rule\n    V_init(a) -[V_to_D_v2(v2)]-> D_init(v2)\n    where v2 = h(h(pow(g, a)));\n    v2 = cksum(v2);\n  rule\n    D_init(v2) -[D_to_V_w2_mac(w2, mac_val)]-> V_recv_w2_mac(v2, w2, mac_val, 0)\n    where\n      c = cksum(v2);\n      r = random();\n      w0 = h(c | r);\n      w1 = h(w0);\n      w2 = h(w1);\n      b = random();\n      k = pow(g, b);\n      mac_val = mac(c, w2);\n  rule\n    V_recv_w2_mac(v2, w2, mac_val, _) -[V_to_D_v1(v1)]-> D_recv_v1(v2, w2, mac_val, v1)\n    where\n      check_mac(mac_val, v2, w2);\n      v1 = h(v2);\n  rule\n    D_recv_v1(v2, w2, mac_val, v1) -[D_to_V_w1_k_mac(w1, k, mac_w2_k)]-> V_recv_w1_k_mac(v2, w2, mac_val, w1, k)\n    where\n      check_v2_h_v1(v2, v1);\n      w1 = w1;\n      k = k;\n      mac_w2_k = mac(w2, k);\n  rule\n     V_recv_w1_k_mac(v2, w2, mac_val, w1, k) -[V_to_D_v0(v0)]-> D_recv_v0(v2, w2, mac_val, w1, k, v0)\n     where\n      check_mac(mac_w2_k, w2, k);\n\t  check_w2_h_w1(w2, w1);\n\t  v0 = v0;\n  rule\n    D_recv_v0(v2, w2, mac_val, w1, k, v0) -[D_to_V_w0(w0)]-> V_recv_w0(v2, w2, mac_val, w1, k, v0, w0)\n    where\n      check_v1_h_v0(v1, v0);\n      sk_VD = pow(v0, b);\n      w0 = w0;\n  rule\n\tV_recv_w0(v2, w2, mac_val, w1, k, v0, w0) -[V_to_D_v0(v0)]-> D_recv_v0(v2, w2, mac_val, w1, k, v0, w0)\n    where\n      check_w1_h_w0(w1, w0);\n      sk_VD = pow(k, a);\n\nend"]], "SPTHY-1/RYY.spthy": [[true, "theory RYY\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* RYY : UM-like identity based key exchange protocol *}\n\n/*\n * Protocol:\tRYY\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr(msk) ]\n  -->\n  [ !MSK( msk ) ]\n\nrule KGC_request:\n  [ !MSK( s ) ]\n  -->\n  [ !LTK( $ID, pmult(s, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( msk ) ]\n  --[ MskRev() ]->\n  [ Out( msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( $ID, sk ) ]\n  --[ SesskRev($ID) ]->\n  [ Out(sk) ]\n\n// User A\n\nrule UserA_init:\n  [ $ID, $IDb ]\n  -->\n  [ !Req( $ID, $IDb ) ]\n\nrule UserA_receive_ltk:\n  [ !LTK( $ID, skID ) ]\n  -->\n  [ !Sessk( $ID, kdf(skID) ) ]\n\n\n// User B\n\nrule UserB_init:\n  [ $ID, $IDa ]\n  -->\n  [ !Req( $ID, $IDa ) ]\n\nrule UserB_receive_ltk:\n  [ !LTK( $ID, skID ) ]\n  -->\n  [ !Sessk( $ID, kdf(skID) ) ]\n\n\n\n// Shared session key\n\nrule Shared_session_key:\n  [ !Sessk( $ID, skA ), !Sessk( $ID, skB ) ]\n  -->\n  [ Out(skA), Out(skB) ]\n\n\n// Other\n\nrule Request_received:\n  [ !Req( $ID, $IDb ) ]\n  --[ ReqRec($ID) ]->\n  [ ]\n\n\n// Types\n\nsort ID\nsort Fr\nsort MSK\nsort LTK\nsort Sessk\n\n\n// Predicates\n\npred MSK(x)\npred LTK(x, y)\npred Sessk(x, y)\npred Req(x, y)\n\n\n// Input\n\ninput: $ID, $IDb, $IDa\n\n\n// Output\n\noutput: skA, skB\n\nend"]], "SPTHY-1/Scott.spthy": [[true, "theory Scott\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* Scott: MTI-C0 like identity based key exchange protocol *}\n\n/*\n * Protocol:\tScott\n * Modeler: \tBenedikt Schmidt\n * Date: \tMay 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr( ~msk ) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk ) ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult( ~msk, hp($ID) ) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\nrule User_Request:\n  [ Fr( ~id ) ]\n  --[ UserRequest(~id) ]->\n  [ !LTK( ~id, $skID ) ]\n\n\n// User\n\nrule User_get_sk:\n  [ !LTK( $ID, skID ) ]\n  --[ UserGetSK($ID) ]->\n  [ skID ]\n\n\n//Example use\nrule Example_Use:\n  [ skID ]\n  --[ ExampleUse() ]->\n  [ skID ]\nend"]], "SPTHY-1/sig.spthy": [[true, "theory Sig\n\nbegin\n\nbuiltins: signing\n\nrule LtkGen:// PKI\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk(PRE_0, POST_0), !Pk($A , pk(~ltk)) , Out(pk(~ltk)) ]\n\n// protocol rules\nrule Send_Signature:\n    [ Fr(~n), !Ltk($A, ltkA) ]\n  --[ Send($A,~n) ]->\n    [ Out(<~n, sign(~n,ltkA)>) ]\n\nrule Recv_Signature:\n    [ !Pk($A, pkA), In(<n, sig>) ]\n  --[ Recv($A, n), Eq(verify(n, sig, pkA), true) ]->\n    [ ]\n\n\nrestriction equal:// needed for signature verification\n  \"All a b #i . Eq(a, b )@i ==> a = b \"\n\nlemma executable:// sanity check\n exists-trace\n  \"Ex #i #j. Send(A, n)@i & Recv(A, n)@j \"\n\nlemma signature_verification_correctness:\n  \"All n ltkA pkA sig.  verify(n, sig, pkA) = true ==> sig = sign(n, ltkA)\"\n\nend"]], "SPTHY-1/sigma-1.spthy": [[true, "theory SIGMA\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk(A, ~ltk),\n    !Pk(A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: g^x\n// S->C: g^y, S, Sig_S(g^x, g^y) MAC_k(S)\n// C->S: C, Sig_C(g^y, g^x) MAC_k(C)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientSentRequest(C, $S, ~x) ]->\n  [\n    ClientWait(C, $S, ~x, ltkC),\n    Out('g'^~x)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <'g'^x, gy>\n    msgOut = <gy, 'g'^x>\n  [\n    !Ltk(C, ltkC),\n    ClientWait(C, $S, ~x, ltkC),\n    In(msgIn),\n    Sig_S(msgIn, sigS),\n    !Mac(msgIn, macS)\n  ]\n  --[ ClientReceivedResponse(C, $S, ~x) ]->\n  [\n    Out(msgOut),\n    Sig_C(msgOut, sigC),\n    !Mac(msgOut, macC)\n  ]\nend"]], "SPTHY-1/Artificial.spthy": [[true, "theory Artificial\nbegin\n\n/*\n   Protocol:\tExample\n   Modeler: \tSimon Meier, Benedikt Schmidt\n   Date: \tJanuary 2012\n\n   Status: \tworking\n\n   This is the example protocol P_{Ex2} in Simon Meier's PhD thesis.\n   It is also the artificial protocol from our CSF'12 paper, which we use to\n   illustrate constraint solving and characterization. Note that, for\n   characerization, you have to call the tamarin-prover as follows.\n\n    tamarin-prover --prove --stop-on-trace=NONE your_protocol.spthy\n\n   The --stop-on-trace=NONE flag ensures that all solved constraint systems\n   are explored by the constraint solver. By default, it stops as soon as the\n   first trace is found.\n*/\n\n-- Define the protocol actions\naction a1(x: nat).\naction a2(x: nat).\naction a3(x: nat).\naction a4(x: nat).\n\n-- Define the protocol constraints\nconstraint c1(x: nat): x > 0.\nconstraint c2(x: nat): x < 10.\nconstraint c3(x: nat): x mod 2 = 0.\n\n-- Define the protocol rules\nrule r1: a1(x) -> a2(x+1).\nrule r2: a2(x) -> a3(x*2).\nrule r3: a3(x) -> a4(x).\nrule r4: a4(x) -> a1(x+1).\n\n-- Initial state\ninit a1(1).\n\n-- Define the properties to be checked\n-- Example property:  a1(x) and a2(y) and a3(z) are possible\n-- property p1: a1(x) & a2(x+1) & a3(2*x+2) & a4(2*x+2).\n-- Example property:  there is a trace of length 3\n-- property p2: trace_length(3).\n\n-- Example property:  there is a trace ending in a4(x) with x=4\nproperty p3: exists x: nat. trace_ends(a4(x)) & x = 4.\n\n\n-- Example property:  a1(1) is always the first action\nproperty p4: trace_starts(a1(1)).\n\n-- Example property:  a4(x) can only follow a3(x)\nproperty p5: a4(x) :- a3(x).\n\n\n--Example property:  a1(x) is always followed by a2(x+1)\nproperty p6: a1(x) -> a2(x+1).\n\n-- Example property:  a2(x) is always followed by a3(2*x)\nproperty p7: a2(x) -> a3(2*x).\n\n-- Example property:  a3(x) is always followed by a4(x)\nproperty p8: a3(x) -> a4(x).\n\n-- Example property:  a4(x) is always followed by a1(x+1)\nproperty p9: a4(x) -> a1(x+1).\n\n\n-- Example property:  a1(x) must satisfy x > 0\nproperty p10: a1(x) => c1(x).\n\n-- Example property:  a1(x) must satisfy x < 10\nproperty p11: a1(x) => c2(x).\n\n-- Example property:  a1(x) must satisfy x is even\nproperty p12: a1(x) => c3(x).\n\n\n\n\nend"]], "SPTHY-1/signed_dh.spthy": [[true, "k_B) ]\n\n\nrule Send_secret:\n    [ St_init_A(A, B, skA, pkA, pkB) ] --> [ Out(aenc(skA, pkB)) ]\n\nrule Receive_secret:\n    [ St_init_B(A, B, skB, pkA, pkB),\n      In(aenc(skA, pkB)) ] --> [ St_receive_B(A, B, skB, pkA, pkB) ]\n\nrule Decrypt_secret:\n    [ St_receive_B(A, B, skB, pkA, pkB) ] --> [ !Sk($A, sk(k_A)),\n                                                !Sk($B, sk(k_B)),\n                                                St_complete(A, B, skA, skB) ]\n\nrule Complete_exchange:\n    [ St_complete(A, B, skA, skB) ] --> [ Out(skB) ]\n\nrule Receive_secret_2:\n    [ St_init_A(A, B, skA, pkA, pkB),\n      In(aenc(skB, pkA)) ] --> [ St_receive_A(A, B, skA, pkA, pkB) ]\n\nrule Decrypt_secret_2:\n    [ St_receive_A(A, B, skA, pkA, pkB) ] --> [ !Sk($A, sk(k_A)),\n                                                !Sk($B, sk(k_B)),\n                                                St_complete(A, B, skA, skB) ]\n\n\nrule Complete_exchange_2:\n    [ St_complete(A, B, skA, skB) ] --> [ Out(skA) ]\n\n\nrule Asymmetric_key_setup_2:\n    [ Fr(~f) ] --> [ !Sk($B, sk(~f)), !Pk($B, pk(~f)) ]\n\nrule Publish_public_keys_2:\n    [ !Pk(B, pkB) ] --> [ Out(pkB) ]\n\n\n\n\ninit_state:\n    [ Fr(k_A), Fr(k_B) ]"]], "SPTHY-1/StatVerif_GM_Contract_Signing.spthy": [[true, "// Protocol for resolving a contract\n\n// Preliminaries\n// ... (Include definitions for data types, functions, etc.)\n\n// Define the contract structure\ndata Contract =\n  {\n    id : Int,\n    party1 : PublicKey,\n    party2 : PublicKey,\n    amount : Int\n  }\n\n// Define the message structure\ndata Message =\n  Resolve1(Contract, PublicKey, PublicKey, Signature, PCsignature)\n  Resolve2(Contract, PublicKey, PublicKey, Signature, PCsignature)\n  Resolve1Answer(Contract, Signature)\n  Resolve2Answer(Contract, Signature)\n\n// Define Public/Private keys\ndata PublicKey\ndata SecretKey\ndata Signature\n\n// Define PCsignature\ndata PCsignature\n\n// Define function to convert a PCsignature to a signature\nfun convertpcs(sk: SecretKey, pcsig: PCsignature): Signature\n\n// Define function to check a signature\nfun check_getmsg(pk: PublicKey, sig: Signature): Contract\n\n// Define function to check a PCsignature\nfun checkpcs(ct: Contract, pk2: PublicKey, pk1: PublicKey, pkT: PublicKey, pcsig2: PCsignature): Bool\n\n// Define function to sign a message\nfun sign(sk: SecretKey, msg: Message): Signature\n\n// Define a function to check if a message has been answered.  This needs to be defined\nfun Answered(ct:Contract): Bool\n\n\n// The TTP receiving a resolve request from party 1.\nrule Resolve1:\n  let msg        = <ct, pk1, pk2, sig1, pcsig2>\n      sig2       = convertpcs(skT, pcsig2)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve1', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures\n    , Eq(check_getmsg(pk1, sig1), ct)\n    , Eq(checkpcs(ct, pk2, pk1, pkT, pcsig2), true) // Corrected the label\n      // Log this action for referencing it in properties\n    , Resolve1(ct)\n    ]->\n    [ Out(resolveSig) ]\n\n// The TTP receiving a resolve request from party 2.\nrule Resolve2:\n  let msg        = <ct, pk1, pk2, sig2, pcsig1>\n      sig1       = convertpcs(skT, pcsig1)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve2', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures\n    , Eq(check_getmsg(pk2, sig2), ct)\n    , Eq(checkpcs(ct, pk1, pk2, pkT, pcsig1), true) // Corrected the label\n      // Log this action for ref"]], "SPTHY-1/STR_signed.spthy": [[true, "/* Preconditions */\nPRE_1:  $I = 0 /\\ notStarted\nPRE_2:  $I = 0 /\\ newstarted\nPRE_3:  $I = 0 /\\ notStarted\nPRE_4:  $R1 = newResponder\nPRE_5:  j=0\nPRE_6:  newstarted\nPRE_7:  newstarted\nPRE_8:  notStarted\nPOST_1: $I, newstarted, notStarted,          POST_2(POST_3)\n  , Responder( PRE_4\n             , $I\n             , j          // the index in the list / position in the three\n             , PRE_5\n             , notStarted // above   \n             , ~gid) ]\n\n\n\n/* Responders */\n\n\nrule Responder_0: //:\n  let mOut = < blindedRandomOf(j,~gid), 'g'^~r >\n  in \n  [ Responder($R1, $I, newstarted, below, above, ~gid)\n  , Fr(~r) ]\n  -->\n  [ Out(< sign(sk(~gid), mOut), mOut > )\n  , ResponderBRSent($R1, $I, notStarted, below + <j,$R1>, above, ~gid, newstarted) ]\n\nrule Responder_1: //BKRecv:\n  let mIn = < blindedKeyFor(j,~gid), bk >\n  in\n  [ ResponderB"]], "SPTHY-1/STS_MAC_fix1.spthy": [[true, "theory STS_MAC_fix1\nbegin\n\nbuiltins: diffie-hellman, signing\n\nfunctions: mac/2\nfunctions: KDF/1\n\nsection{* The Station-To-Station Protocol (MAC version, fix UKS attack with proof-of-possession of exponent) *}\n\n/*\n * Protocol:\tStation-To-Station, MAC variant: fix with CA Proof-of-Possession check\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\"\n *\t\tBlake-Wilson, Simon and Menezes, Alfred\n * \t\tPKC '99, Springer, 1999\n *\n * Status: \tworking\n */\n\n// Public keymat infrastructure\n/**\n * The !Pk facts can be regarded as certificates\n */\nrule Register_pk_normal:\n  [ Fr(~ltk) ] \n  --> \n  [\n    !Pk(ltk, ~pk)\n  ]\n\nrule Register_pk_attacker:\n\t[\n\t\tFr(~ltk),\n\t\t!Compromised(ltk)\n\t]\n\t-->\n\t[\n\t\t!Pk(ltk, ~pk)\n\t]\n\n\nrule STS_Client_A_normal:\n  [ Fr(~A), Fr(~B), Fr(~skA), Fr(~skB), !Pk(~B, ~pkB) ]\n  -->\n  [\n    !A_send(~A, ~B, ~pkB, ~skA)\n  ]\n\nrule STS_Server_B_normal:\n  [ !A_send(~A, ~B, ~pkB, ~skA), Fr(~skB), !Pk(~A, ~pkA) ]\n  -->\n  [\n    !B_send(~A, ~B, ~pkA, ~skB)\n  ]\n\nrule STS_Client_A_normal_2:\n  [ !B_send(~A, ~B, ~pkA, ~skB), Fr(~skA) ]\n  -->\n  [\n    !A_receive(~A, ~B, ~pkA, ~skB)\n  ]\n\nrule STS_Server_B_normal_2:\n\t[\n\t\t!A_send(~A, ~B, ~pkB, ~skA), Fr(~skB)\n\t]\n\t-->\n\t[\n\t\t!B_receive(~A, ~B, ~pkB, ~skA)\n\t]\n\nrule STS_Client_A_normal_3:\n\t[ !B_receive(~A, ~B, ~pkB, ~skA), Fr(~skA), !Pk(~B, ~pkB) ]\n\t-->\n\t[\n\t\t!A_check(~A, ~B, ~pkB, ~skA)\n\t]\n\nrule STS_Server_B_normal_3:\n\t[ !A_receive(~A, ~B, ~pkA, ~skB), Fr(~skB), !Pk(~A, ~pkA) ]\n\t-->\n\t[\n\t\t!B_check(~A, ~B, ~pkA, ~skB)\n\t]\n\nrule STS_Client_A_normal_4:\n\t[ !A_check(~A, ~B, ~pkB, ~skA), Fr(~skA), Fr(~B), Fr(~A), !session_key(~A, ~B, KDF(~skA, ~pkB)) ]\n\t-->\n\t[\n\t\t!session_key(~A, ~B, KDF(~skA, ~pkB))\n\t]\n\nrule STS_Server_B_normal_4:\n\t[ !B_check(~A, ~B, ~pkA, ~skB), Fr(~skB), Fr(~A), Fr(~B), !session_key(~A, ~B, KDF(~skB, ~pkA)) ]\n\t-->\n\t[\n\t\t!session_key(~A, ~B, KDF(~skB, ~pkA))\n\t]\n\nrule STS_Client_A_normal_5:\n\t[ !session_key(~A, ~B, KDF(~skA, ~pkB)), !session_key(~B, ~A, KDF(~skB, ~pkA)) ] --> []\n\nend"]], "SPTHY-1/TESLA_Scheme1.spthy": [[true, "theory TESLA_Scheme1 begin\n\n/*\n  Protocol:    The TESLA protocol, scheme 1\n  Modeler:     Simon Meier\n  Date:        May 2012\n\n  Status:      working\n\n  Original descrption in [1]. This model is based on the following description\n  from [2].\n\n\n    Msg 0a. R -> S: nR\n    Msg 0b. S -> R: {f (k1 ), nR }SK (S )\n    Msg 1.  S -> R: D1 , MAC (k1 , D1 ) where D1 = m1 , f (k2 )\n    Msg 2.  S -> R: D2 , MAC (k2 , D2 ) where D2 = m2 , f (k3 ), k1 .\n\n  For n > 1, the n-th message is:2\n    Msg n. S -> R : Dn , MAC (kn , Dn ) where Dn = mn , f (kn+1 ), kn-1 .\n\n\n  We verify that the use of cryptography is correct under the assumption that\n  the security condition holds. W\n*/\n\n  type Msg =\n    | Msg0a of int\n    | Msg0b of int * {int}\n    | Msg1 of int * int * {int}\n    | Msg2 of int * int * int * int\n    | Msgn of int * int * int * int;\n\n\n  type State =\n    | State0\n    | State1 of int\n    | State2 of int * int\n    | Statenn of int * int * int;\n\n\n\n\n  (* Define the protocol transitions.  *)\n  transition\n    State0  -- Msg0a(nR) --> State1(nR);\n\n\n  transition\n    State1(nR) -- Msg0b({f(k1), nR}SK(S)) --> State2(k1, nR);\n\n\n  transition\n    State2(k1, nR) -- Msg1(m1, f(k2), MAC(k1, m1, f(k2))) --> Statenn(k1, m1, k2, nR);\n\n\n  transition\n    Statenn(k1, m1, k2, nR) -- Msg2(m2, f(k3), MAC(k2, m2, f(k3), k1)) --> Statenn(k1, m1, k2, nR);\n\n\n\n  (* Add transitions for n > 2 here *)\n  transition\n    Statenn(k1, m1, k2, nR) -- Msgn(mn, f(kn+1), kn-1, MAC(kn, mn, f(kn+1), kn-1)) --> Statenn(k1, m1, k2, nR);\n\nend"]], "SPTHY-1/thirdAttestation.spthy": [[true, "// rule for an attester in a good state sending an EAT to the verifier\nrule AttesterSendsEatGood:\n    in\n    [\n        !Identity(PRE_3, ~Altk, pk(~Altk)), \n        In(<$Verifier, $Attester, signed_nonce>), \n        AttesterState($Attester, 'good_state')\n    ]\n    --[AttesterSendsEatGood($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n// rule for offering a signing interface to the attacker when the attester is compromised \nrule Attester_create_and_sends_EAT_bad:\n    let\n        attester_data = 'bad' // check that you're in a bad state and send bad_firmware\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n        // there's no explicit check for the authenticity and integrity of signed_nonce\n        // you should add check for bad_firmware\n    in\n    [\n        !Identity(PRE_3, ~Altk, pk(~Altk)), \n        In(<$Verifier, $Attester, signed_nonce>), \n        AttesterState($Attester, 'bad_state')\n    ]\n    --[AttesterSendsEatBad($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n// rule for handling the EAT from the attester\nrule VerifierReceivesEat:\n    in\n    [\n        In(<$Verifier, $Attester, signed_EAT>),\n        // Check the signature of signed_EAT\n        !Verify(signed_EAT, pk(~Altk)) // replace ~Altk with the correct attester key\n    ]\n    --[VerifierReceivesEat($Verifier, $Attester, signed_EAT)]->\n    [\n        // Check the integrity of the EAT\n        !If(signed_EAT.attester_data == 'good', \n            AttesterState($Attester, 'good_state'), \n            AttesterState($Attester, 'bad_state')\n        )\n    ]\n\n// Define the protocol's state variables\nstate AttesterState($Attester, state)\n\n// Define the protocol's input and output messages\nmessage In(<$Verifier, $Attester, signed_nonce>)\nmessage Out(<$Attester, $Verifier, signed_EAT>)\nmessage Out(<$Attester, $Verifier, signed_bad_EAT>)\n\n// Define the type of the signed EAT message\ntype signed_EAT = <signed_nonce, attester_data, signature>\ntype signed_bad_EAT = <signed_nonce, bad_attester_data, signature>\n\n// Example of a function to reveal the nonce\nfunction revealSign(eat, key)\n    // This function should extract the nonce and sign it.\n    //  replace this with your actual implementation\n    return <eat.signed_nonce, eat.attester_data, sign(eat, key)>\n\n// Define the precondition\nprecondition PRE_3"]], "SPTHY-1/TLS_Handshake.spthy": [[true, "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hash values.\n    3. We use a different modeling of the handshake messages,\n       making the model more concise.\n    4. We use a more general definition of the cryptographic primitives.\n    5. We made the parameters for the encryptions explicit.\n    6. We added a nonces to the messages to enhance the security.\n     7. We added a separate message for the server's certificate.\n*}\n\n-- Constants\nconst client_random : string\nconst server_random : string\nconst premaster_secret : string\nconst master_secret : string\nconst client_cert : string\nconst server_cert : string\nconst client_key : string\nconst server_key : string\n\n-- Types\ntype message\n\n-- Messages\nmsg ClientHello(client_random : string) : message\nmsg ServerHello(server_random : string) : message\nmsg ServerCertificate(server_cert : string) : message\nmsg ServerKeyExchange() : message\nmsg CertificateVerify() : message\nmsg ClientKeyExchange(premaster_secret : string) : message\nmsg ChangeCipherSpec() : message\nmsg Finished() : message\n\n\n-- Cryptographic Primitives\n-- These are placeholders.  In a real model, you'd need to define\n-- appropriate types and operations for these.\nop encrypt_sym(k : string, m : string) : string\nop decrypt_sym(k : string, c : string) : string\nop sign(k : string, m : string) : string\nop verify(k : string, s : string, m : string) : bool\nop hash(m : string) : string\n\n-- Rules\nrule ClientHello(client_random) -> ServerHello(server_random)\nrule ServerHello(server_random) -> ServerCertificate(server_cert)\nrule ServerCertificate(server_cert) -> ServerKeyExchange()\nrule ServerKeyExchange() -> CertificateVerify()\nrule CertificateVerify() -> ClientKeyExchange(premaster_secret)\nrule ClientKeyExchange(premaster_secret) -> ChangeCipherSpec()\nrule ChangeCipherSpec() -> Finished()\n\n-- Example of a more complex rule (using encryption)\n--rule encrypt_sym(client_key, msg) -> encrypt_sym(server_key, msg)\n\n\nend"]], "SPTHY-1/TPM_Exclusive_Secrets.spthy": [[true, "theory TPM_Exclusive_Secrets begin\n\n/*\n    Protocol: Running example from [1]\n    Modeler: Simon Meier\n    Date:    September 2012\n    Status:  Working\n\n    [1] Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, \"Formal\n    Analysis of Protocols Based on TPM State Registers,\" csf, pp.66-80, 2011\n    IEEE 24th Computer Security Foundations Symposium, 2011.\n\n    The  purpose of this example is to verify that the adversary cannot exploit\n    his TPM to simultainously access the two secrets that were encryped\n    exclusively by Alice.\n\n    Note that we could easily model multiple PCR's, if required.\n\n*/\n\nbuiltins: hashing, asymmetric-encryption, signing\n\n// TP\n\n// Types\ntype secret;\ntype pubkey;\n\n\n// Roles\nrole Alice;\nrole Bob;\nrole Eve;\n\n\n// Variables\nvar a: secret;\nvar b: secret;\nvar x: secret;\nvar y: secret;\nvar pk_A: pubkey;\nvar pk_B: pubkey;\nvar pk_E: pubkey;\n\n\n// Initialization\ninit:\n  Alice(a) & Bob(b) & Alice(pk_A) & Bob(pk_B) & Eve(pk_E);\n\n\n// Actions\naction Alice_encrypt_a:\n  pre: Alice(a) & Bob(pk_B);\n  effect: Alice(a) & Bob(pk_B) & Bob(encrypt(pk_B, a));\n\n\naction Alice_encrypt_b:\n  pre: Alice(a) & Alice(b) & Bob(pk_B);\n  effect: Alice(a) & Alice(b) & Bob(pk_B) & Bob(encrypt(pk_B, b));\n\n\naction Bob_encrypt_x:\n  pre: Bob(encrypt(pk_B, a)) & Bob(b) & Alice(pk_A);\n  effect: Bob(encrypt(pk_B, a)) & Bob(b) & Alice(pk_A) & Bob(encrypt(pk_B, x));\n\n\naction Bob_encrypt_y:\n  pre: Bob(encrypt(pk_B, b)) & Bob(b) & Alice(pk_A);\n  effect: Bob(encrypt(pk_B, b)) & Bob(b) & Alice(pk_A) & Bob(encrypt(pk_B, y));\n\n\n// Goal\ngoal:\n  // The adversary cannot learn a and b.\n  !Eve(a) & !Eve(b);\n\n\n// Assumptions (These are needed to model the adversary's capabilities)\nassumption Eve_can_observe_all:\n  pre: Alice(a) & Alice(b) & Bob(pk_B) & Bob(encrypt(pk_B, a)) & Bob(encrypt(pk_B, b));\n  effect: Eve(a) & Eve(b) & Eve(pk_B) & Eve(encrypt(pk_B, a)) & Eve(encrypt(pk_B, b));\n\n\nend"]], "SPTHY-1/Typing_and_Destructors.spthy": [[true, "theory Typing_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration of the interaction between sources and\n                destructors\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working / misses theory extension (see issue #104)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors. Its verification does not yet work out of the box, as the\n   implemented definition of guarded trace properties is too restrictive to\n   allow formalizing the required type invariant.\n\n   NOTE that it seems that the best option is to explicitly state in a rule\n   that it does not continue in case the application\n\n   Example of a protocol with explicit destructors\n*/\n\ntype Value = Int | Bool;\n\ntype Source = {\n    value: Value\n};\n\ntype Destructor = {\n    value: Value\n};\n\ntype Action = Source | Destructor;\n\n-- Source type\ntype SourceType = { value: Value };\n\n-- Destructor type\ntype DestructorType = { value: Value };\n\n\n-- State space\ntype State = {\n    source: SourceType,\n    destructor: DestructorType,\n    value: Value\n};\n\n\n\n-- Initial state\ninit(s: State) =\n   s.source.value = 0 &\n   s.destructor.value = 0 &\n   s.value = 0;\n\n-- Actions\nsource(s: State, a: Source) =\n   s.source.value = a.value &\n   s.value = a.value;\n\ndestructor(s: State, a: Destructor) =\n    s.destructor.value = a.value &\n    s.value = a.value;\n\n\n-- Properties\n-- Example of a property, using the value of the source and destructor\nsafe_source_value(s: State, a: Source) =\n   s.value = a.value;\n\n\nsafe_destructor_value(s: State, a: Destructor) =\n    s.value = a.value;\n\n\n-- Traces:\n-- Define the traces of the protocol.\ntrace_source(s: State, a: Source) =\n   safe_source_value(s, a);\n\ntrace_destructor(s: State, a: Destructor) =\n    safe_destructor_value(s, a);\n\n-- Example of a property on the whole trace\n-- The value of the source and the destructor must be equal to the current value.\nsafe_trace(s: State, trace: seq<Action>) =\n  forall i in [0 .. length(trace) - 1]\n    (let a = trace[i]\n     in  (a is Source\n          -> trace_source(s, a)\n          | a is Destructor\n          -> trace_destructor(s, a)));\n\n-- Example of a property on the whole trace, using a different predicate:\n\n-- Example of a property on the whole trace, using a different predicate:\nproperty_example(s: State, trace: seq<Action>) =\n    safe_trace(s, trace) &\n    forall i in [0 .. length(trace) - 1]\n      (let a = trace[i] in\n       (a is Source -> s.source.value = a.value) &\n       (a is Destructor -> s.destructor.value = a.value)\n      );\n\n-- Example of a property on the trace, with a predicate on the current state:\nproperty_on_state(s: State, trace: seq<Action>) =\n    forall i in [0 .. length(trace) - 1]\n      (let a = trace[i] in\n       (a is Source -> s.value = a.value) &\n       (a is Destructor -> s.value = a.value)\n      );\n\n\nend"]], "SPTHY-1/UM_wPFS.spthy": [[true, "theory UM_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* The Unified Model (UM) Key-Exchange Protocol *}\n\n/*\n * Protocol:\tUnified Model (UM)\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Authenticated Diffie-Hellman Key Agreement Protocols\"\n * \t\tSimon Blake-Wilson and Alfred Menezes\n * \t\tLNCS 1556, 1999\n * Property:\tweak Perfect Forward Secrecy (wPFS), from\n * \t\t\"HMQV: A High-Performance Secure Diffie-Hellman Protocol\"\n * \t\tH. Krawczyk\n * \t\tCRYPTO 2005, LNCS 3621, 2005\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, $A ), Out( 'g'^~lk ) ]\n\nrule receive_ltk:\n   [ In( 'g'^~lk ), !Pk( $B, $B ) ] -->\n   [ !Rcv( $B, ~lk ) ]\n\nrule generate_key:\n   [ !Rcv( $A, ~lk ), !Pk( $B, $B ) ] -->\n   [ !Key( $A, $B, ~lk ) ]\n\n\n\nend"]], "SPTHY-1/auto_protocol_and_property.spthy": [[true, "theory five\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption, hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Key($A, $B, ~symK),\n          !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(~symK)) ]\nend"]], "SPTHY-1/3.spthy": [[true, "/*\nM is a message from A to B\nK is a freshly generated symmetric key\nN is a nonce\nPuB is B\u2019s public key\n\nA -> B : A, senc((A, M), K)\nB -> A : N\nA -> B : aenc((N, K), PuB)\n\n# Failed properties\nlemma message_authentication:\n\"All b m #i. Authentic(b,m) @i\n==> (Ex #j. Send(b,m) @j & j<i)\"\nend\n\n- Authenticity of M \n*/\ntheory three\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_exchange:\n    [ !Sk(A, skA), !Pk(B, pkB), !M ] -->\n    [ !K, Out(A, senc((A, M), K)) ]\n\nrule Receive_nonce:\n    [ In(N) ] --> [ Out(N) ]\n\nrule Decrypt_and_send:\n    [ !K, In(aenc((N, K), pkB)) ] -->\n    [ !N, Out(aenc((N, K), pkB)) ]\n\nrule Authenticate_message:\n    [ In(A, senc((A, M), K)), !K, !Sk(B, skB), !M ] -->\n    [ !A, !M, Authentic(A, M) ]\n\n# Example initialisation\nrule Init:\n    [] --> [ Fr($A), Fr($B), !M, !N ]\n\n# Example initialisation with public keys\nrule Init_with_keys:\n    [ !Pk(A, pkA), !Pk(B, pkB) ] --> [ Fr($A), Fr($B), !M, !N ]\n\n\n# Add rules to handle sending and receiving\nrule Send_message:\n    [ !M ] --> [ Out(M) ]\n\n\n# Add rules to handle receiving the encrypted message\nrule Receive_encrypted_message:\n    [ In(A, senc((A, M), K)) ] --> [ !A, !M, !K ]\n\n# Add rules to handle receiving the nonce\nrule Receive_nonce:\n    [ In(N) ] --> [ !N ]\n\n\n# Add rules for key generation\nrule Key_generation:\n    [] --> [ !K ]\n\n\n# Add rules for message authentication, assuming you have the correct conditions\nrule Authenticate_message:\n    [ In(A, senc((A, M), K)), !Sk(B, skB) ] -->\n    [ !A, !M, Authentic(A, M) ]\n\n\n# ... (Other rules as needed)\nend"]], "SPTHY-1/5.spthy": [[true, "theory Five\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption, hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Key($A, $B, ~symK),\n          !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A(A, B, ~symK, pk(k_A), pk(k_B)) ]\n\nend"]], "SPTHY-1/asw.spthy": [[true, "theory ASW\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          Fr(~m)\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, ~m, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n\nend"]], "SPTHY-1/asym.spthy": [[true, "theory Asym\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, sk(k_A), pk(k_A)),\n          St_init_B($B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule a1_A:\n        [ St_init_A(A, sk(k_A), pk(k_A)), Out(pkB) ] --> [ St_init_A(A, sk(k_A), pk(k_A)) ]\n\nrule a2_A:\n        [ St_init_A(A, sk(k_A), pk(k_A)), In(mEnc) ] --> [ St_A(A, sk(k_A), pk(k_A), mEnc) ]\n\n// ROLE B\nrule b1_B:\n        [ St_init_B(B, sk(k_B), pk(k_A), pk(k_B)) ] --> [ St_init_B(B, sk(k_B), pk(k_A), pk(k_B)) ]\n\n\nrule b2_B:\n        [ St_init_B(B, sk(k_B), pk(k_A), pk(k_B)), In(mEnc) ] --> [ St_B(B, sk(k_B), pk(k_A), pk(k_B), mEnc) ]\n\n//  Decryption rules (example)\nrule decrypt_A:\n    [ St_A(A, sk(k_A), pk(k_A), mEnc), In(mDec) ] --> [ St_A(A, sk(k_A), pk(k_A), mEnc), Out(adec(mEnc, sk(k_A))) ]\n\n\nrule decrypt_B:\n    [ St_B(B, sk(k_B), pk(k_A), pk(k_B), mEnc), In(mDec) ] --> [ St_B(B, sk(k_B), pk(k_A), pk(k_B), mEnc), Out(adec(mEnc, sk(k_B))) ]\n\n\n// Assume k_B as an example\n// You need to replace these with the actual instantiation\nvariables: k_A/1, k_B/1, mEnc/1, mDec/1\n\nend"]], "SPTHY-1/AS_Concrete_RPC.spthy": [[true, "/*\n  Example for the Tamarin Prover\n  ==============================\n\n  Authors:       Jannik Dreier\n  Date:             March 2020\n  Time:                ?\n\n  Description from SPORE:\n  (http://www.lsv.fr/Software/spore/andrewBAN2.html)\n\n  Ban Concrete Andrew Secure RPC Protocol\n\n  A, B :    principal\n  Kab, K'ab :    symkey\n  Na, Nb, N'b :    nonce\n  succ :    nonce -> nonce\n\n  1.    A  ->  B  :    A, Na\n  2.    B  ->  A  :    {Na, K'ab}Kab  SendNsk(xna, ~nsk, xsk, $A, $B)\n  3.    A  ->  B  :    {Na}K'ab       ReturnNsk(~na, xnsk, ~sk, $A, $B)\n  4.    B  ->  A  :    Nb             SendNb(~nb, xna, ~nsk, ~sk, $A,$B)  ReceiveNb(xnb)\n\n  The protocol must guarantee that only the intended recipient can decrypt the messages.\n*/\n\nopen import Relation.Binary.PropositionalEquality\n\nmodule Andrew where\n\nopen import Data.Nat\nopen import Data.Bool hiding (_\u2227_)\nopen import Data.Product\nopen import Data.List\nopen import Data.String\n\n-- Define types for principals, symmetric keys, nonces, and a nonce successor function.\ndata Principal : Set where\n  A : Principal\n  B : Principal\n\ndata SymKey : Set where\n  _ : Principal \u2192 Principal \u2192 SymKey\n\ndata Nonce : Set where\n  _ : \u2115 \u2192 Nonce\n\nsucc : Nonce \u2192 Nonce\nsucc n = nsuc n\n\n-- Define the protocol messages.\ndata Message : Set where\n  Msg1 : Principal \u2192 Nonce \u2192 Message\n  Msg2 : Nonce \u2192 SymKey \u2192 Message\n  Msg3 : Nonce \u2192 SymKey \u2192 Message\n  Msg4 : Nonce \u2192 Message\n\n-- Define the protocol execution.\ndata Execution : Set where\n  -- Example of an execution fragment.\n  init : Execution\n  step1 : Principal \u2192 Nonce \u2192 Execution \u2192 Execution\n  step2 : Nonce \u2192 SymKey \u2192 Execution \u2192 Execution\n  step3 : Nonce \u2192 SymKey \u2192 Execution \u2192 Execution\n  step4 : Nonce \u2192 Execution \u2192 Execution\n\n\n-- Define the security properties (e.g., authenticity, confidentiality)\n--  This is a placeholder;  you need to define the actual properties.\n--  For example, you'd want to define a function that determines if a given\n--  execution is valid, or if it meets the confidentiality requirements.\n--  This requires a more detailed formalization of the protocol's\n--  behaviour and the desired security properties.\n\n\n-- Example of a (partial) security property (confidentiality)\n-- This is a placeholder.  You need to tailor this to your specific goals.\nconfidentiality : Execution \u2192 Bool\nconfidentiality init = true\nconfidentiality (step1 a n exec) = confidentiality exec\nconfidentiality (step2 n k exec) = confidentiality exec\nconfidentiality (step3 n k exec) = confidentiality exec\nconfidentiality (step4 n exec) = confidentiality exec"]], "SPTHY-1/axiom_test_symmetric.spthy": [[true, ", Out(diff(enc(~k2,~k),~k)) ]\n\nrestriction crazy [left]:\n  \"\n  not( Ex #i. RuleApplied() @ i)\n  \"\n\n/*\nThis restriction is designed to prevent the simultaneous execution of the two encryption rules,\nensuring that the two encryption operations are performed sequentially.\n*/\n\nlemma crazy_lemma:\n  [ Fr(~k), Fr(~k2) ] |- [ Out(diff(enc(~k,~k),~k2)), Out(enc(~k,~k)) ]\n\n//This lemma is a simplified version of the crazy lemma.\n//It states that if two fresh keys are available, then the output will contain the results of two encryption operations\n//with different keys.\n\nlemma crazy_lemma_2:\n  [ Fr(~k), Fr(~k2) ] |- [ Out(diff(enc(~k,~k),~k2)), Out(enc(~k,~k2)) ]\n\n\n// This is a test rule. It checks if the restriction works as intended.\nrule crazy_test:\n  [ Fr(~k), Fr(~k2) ]\n  --[ RuleApplied() ]->\n  [ Out(diff(enc(~k,~k),~k2)), Out(enc(~k,~k2)) ]\n\n//This rule is a test case for the restriction.\n\n\n//This is an example of using the restriction.\nrule crazy_test2:\n  [ Fr(~k), Fr(~k2) ]\n  --[ RuleApplied() ]->\n  [ Out(diff(enc(~k2,~k),~k2)), Out(enc(~k,~k2)) ]\n\n//This rule is a test case for the restriction.\n\n\n\n//This is a rule that demonstrates the desired behavior.\nrule normal_enc:\n  [ Fr(~k) ]\n  --[ RuleApplied() ]->\n  [ Out(enc(~k,~k)) ]\n\n//This rule demonstrates the expected behavior of a single encryption operation.\n\n//Example of a rule that uses the restriction\nrule use_restriction:\n\t[ Fr(~k), Fr(~k2)]\n\t--[ RuleApplied() ]->\n\t[ Out(enc(~k,~k)), Out(enc(~k2,~k2)) ]\nend"]], "SPTHY-1/BP_ABSTRACT_IBE_toyExample.spthy": [[false, "```spthy\ntheory BP_ABSTRACT_IBE_toyExample\nbegin\n\n/*\n * Source: Toy Example showing our abstract IBE modeling in practice\n * Author: Lucca Hirschi & Ralf Sasse\n * Date: November 2018\n *\n * Status: Automatic proofs/attacks of challenge secrecy and non-injective agreement from initiator + compromised scenarios.\n * Protocol: Alice --{<Alice,Bob,challenge>}_Bob-->    Bob\n *           Bob   --{<challenge,'response'>}_Alice--> Alice\n */\n\n\nfunctions: IBPriv/2, IBPub/2, GetIBMasterPublicKey/1,  // [same for IBS]\n           idenc/2, iddec/2                            // [almost the same for IBS]\nequations: iddec(idenc(plaintext,IBPub(A, GetIBMasterPublicKey(IBMasterPrivateKey(A)))),IBPriv(A, GetIBMasterPrivateKey(A))) = plaintext,\n           \n           // Add more equations as needed for your protocol.  Example:\n           //  For the case where the decryption fails due to an invalid key.\n           iddec(idenc(plaintext,IBPub(A, GetIBMasterPublicKey(IBMasterPrivateKey(B)))),IBPriv(A, GetIBMasterPrivateKey(A))) =  \u22a5  // \u22a5 represents failure."]], "SPTHY-1/CCITT-X509-R.spthy": [[false, "```spthy\n/*\n  Example for the Tamarin Prover\n  ==============================\n\n  Authors:       Jannik Dreier\n  Date:             April 2020\n  Link: https://github.com/tamarin-prover/tamarin-prover/blob/bb1a083f6092f5827c8bea6980caf5927578b9df/examples/features/auto-sources/spore/CCITT_X509_1.spthy#L12\n\n  CCITT X.509 (1)\n\n  A, B :     principal\n  Na, Nb :    nonce\n  Ta, Tb :    timestamp\n  Ya, Yb :    userdata\n  Xa, Xb :    userdata\n  PK, SK :    principal -> key (keypair)\n\n  Spore simplification\n  1.    A  ->  B  :    A, {Ta, Na, B, Xa, {Ya}PK(B)}SK(A)\n  Spore reminder of actual specification\n  1.    A  ->  B  :    A, Ta, Na, B, Xa, {Ya}PK(B), {h(Ta, Na, B, Xa, {Ya}PK(B))}SK(A)\n*/\n\nsignature\n\n  principal, nonce, timestamp, userdata\n  keypair\n\n  -> : principal, principal -> bool\n  PK : principal -> keypair\n  SK : principal -> keypair\n  {} :  keypair, principal -> principal\n  h :  timestamp, nonce, principal, userdata, principal -> principal"]], "SPTHY-1/CH07.spthy": [[true, "theory CH07 begin\n\n/* \n  CH07 RFID protocol model based on \n  \"Attacks on RFID protocols\" v1.1 from Aug 6, 2009, by Ton van Deursen and Sasa Radomirovic\n  This model focuses on authentication properties (recent aliveness and \n  agreement.)\n\n  Reader R, Tag T, shared knowledge k, ID.\n\n  R: knows(k,ID) \n  T: knows(k,ID) \n  R: fresh(r1)\n  R -> T: r1\n  T: fresh(r2)\n  T -> R: r2,lh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k)) \n  R -> T: rh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k))\n\n*/\n\nbuiltins: xor, hashing\nfunctions: rot/2, lh/1, rh/1\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge ]-> \n   [ !Reader( ~k, ~id ), !Tag( ~k, ~id ),  !Send( ~r1, !Tag( ~k, ~id ) ) ]\n\nrule tag1:\n   [ !Receive( ~r1, !Reader( ~k, ~id ) )\n   , Fr( ~r2 ) ]\n --[ Response ]-> \n   [ !Reader( ~k, ~id ), !Tag( ~k, ~id ), !Send( ~r2, !Reader( ~k, ~id ) ),\n      !Send( lh( rot( ~id, h( ~r1 \u2295 ~r2 \u2295 ~k ) ) \u2295 h( ~r1 \u2295 ~r2 \u2295 ~k ) ), !Reader( ~k, ~id ) ) ]\n\n\nrule reader2:\n   [ !Receive( ~r2, !Reader( ~k, ~id ) ),\n     !Receive( ~lh, !Reader( ~k, ~id ) ) ]\n --[ Verification ]-> \n   [ !Reader( ~k, ~id ), !Tag( ~k, ~id ),\n      !Send( rh( rot( ~id, h( ~r1 \u2295 ~r2 \u2295 ~k ) ) \u2295 h( ~r1 \u2295 ~r2 \u2295 ~k ) ), !Tag( ~k, ~id ) ) ]\n\n\nrule tag2:\n   [ !Receive( ~rh, !Tag( ~k, ~id ) ) ]\n --[ Verification ]-> \n   [ !Reader( ~k, ~id ), !Tag( ~k, ~id ) ]\n\n\nend"]], "SPTHY-1/CHx.spthy": [[true, "theory CHx begin\n\nbuiltins: xor, hashing\nfunctions: rot/2, lh/1, rh/1\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) \n   ]\n\nrule tag1:\n   let hash = h((r1\u2295~r2\u2295~k)) in \n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' )\n   , Challenge(~r2, 'Tag') \n   ]->\n   [ Out( <r2,lh(rot(~id,1))>)\n   , TagState(~k, r1, ~r2, hash)\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n   , In( <r2, lh(rot(~id,hash))> ) \n   ]\n --[ Accept ]->\n   [ Out( <r2,lh(rot(~id,hash))>) \n   ]\nend"]], "SPTHY-1/chen_kudla-1.spthy": [[true, "// Protocol for key exchange\n\n// Data types\ntype Fr = String\ntype G1 = String\ntype G2 = String\ntype E = String\n\n// Constants\nconst P : G1\nconst hp : (Fr) -> G1\nconst pmult : (Fr, G1) -> G1\nconst kdf : (Fr) -> Fr\n\n// Secret keys\ndata MSK = Fr\ndata LTK = (Fr, Fr) // (ID, secret)\ndata Sessk = (Fr, Fr) // (session identifier, secret key)\ndata Ephk = Fr\n\n\n// Public keys\ndata MPK = G1\ndata SK = Fr\n\n// Messages\ndata Out = (String)\ndata KGCSetup = ()\ndata LtkRev = (Fr)\ndata MskRev = ()\ndata SesskRev = (Fr)\ndata EphkRev = (Fr)\n\n\n// State variables\nstate: [\n    MSK(~msk) : MSK\n  , MPK(mpk) : MPK\n  , LTK($ID, skID) : LTK\n  , Sessk(~ey, kdf(sek)) : Sessk\n  , Ephk(~ex) : Ephk\n]\n\n\n// Key generation center\n\nrule KGC_Setup:\n  let mpk = pmult(~msk,'P')\n  in\n  [ Fr(~msk) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk )\n  , !MPK( mpk )\n  , Out( mpk )\n  ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult(~msk, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, kdf(sek) ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( kdf(sek) ) ]\n\n\nrule Reveal_ephemeral_key:\n  [ !Ephk( ~ex ) ]\n  --[ EphkRev( ~ex ) ]->\n  [ Out( ~ex ) ]\n\n// Protocol\n\nrule Init_1:\n  let X   = pmult(~ex,'P')\n  in\n  [ Fr( ~ex) ]\n  --[  ] ->\n  [ !Ephk(~ex)\n  , Out(X)\n  ]\n\nrule Init_2:\n  [ !Ephk(~ex), Out(X) ]\n  --[  ] ->\n  [ !Sessk(~ey, kdf(sek)) ]"]], "SPTHY-1/CombinedHPED.spthy": [[true, "theory CombinedHashPubEncDecTest begin\n\n/*\n * Protocol:\t Combination of Hash, Public, Encryption and Decryption operators\n * Modeler: \t Jannik Dreier and Ralf Sasse\n * Described in: \n * Date: \t April 2015\n *\n * Status: \t working\n */\n\nfunctions: h/1, aenc/2, adec/2, pk/1\nequations: adec(aenc(m, pk(k)), k) = m\n\n\nrule Out_Hash:\n  [ Fr(~ltk) ]\n  -->\n  [ Out(diff(h(~ltk),~ltk)) ]\n\nrule Out_pub:\n  [ ]\n  -->\n  [ Out(diff($A,$B)) ]\n\nrule Out_Enc:\n  [ Fr(~ltk) ]\n  --[ OUT_I_1(aenc(diff($A,$B),pk(~ltk))), LTK(~ltk) ]->\n  [ !Key(~ltk), Out(aenc(diff($A,$B),pk(~ltk))) ]\n\nrule Out_Dec:\n  [ !Key(ltk), In(aenc(m,pk(ltk))) ]\n  --[ IN_R_1_ni(m, aenc(m,pk(ltk))) ]->\n  [ Out(m) ]\n\nend"]], "SPTHY-1/correct.spthy": [[true, "theory DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman, symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          Fr(~sec1),\n          Fr(~sec0)\n        ]\n        --[  ]->"]], "SPTHY-1/cr-1.spthy": [[false, "```houzhui\ntheory CR\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($C, pk(k_C)),\n          !Pk($R, pk(k_R)),\n          !Sk($C, sk(k_C)),\n          !Sk($R, sk(k_R))\n        ]\n        --[  ]->\n        [ St_init_C($C, sk(k_C), pk(k_C), pk(k_R)),\n          St_init_R($R, sk(k_R), pk(k_R))\n        ]\n\n// ROLE C\nrule cr1_C:\n        [ St_init_C(C, skC, pkC, pkR) ] --> [ Out(aenc(k_C, pkR)) ]\n```"]], "SPTHY-1/Cronto_MA.spthy": [[true, "// Protocol description\n// This protocol describes a secure communication channel between two parties, A and B.\n// A sends a message to B, and B sends a message back to A.\n// The messages are encrypted using a shared key.\n\n// Preconditions\n// PRE_1:  The precondition for receiving a message.\n// PRE_2:  The precondition for sending a message.\n// PRE_3:  The precondition for receiving a message from a secure channel.\n// PRE_4: The precondition for a second message to be sent.\n// PRE_5: The precondition for sending a message through the secure channel.\n// PRE_6: The precondition for a combined output of two messages.\n\n\n// Labels\n// LABEL_1: The label for the receiving party.\n// LABEL_2: The label for the sending party.\n// LABEL_3: The label for a second message sending party.\n\n\n// Data types\n// $x.1, $x.2, $y.1, $y.2:  Representing data types for messages.\n// $A: Represents the identity of the sender.\n// $H: Represents the secure channel identifier.\n\n\n// Events\n// In(<$x.1,x.2>): Message input.\n// Out_S($H,$A,$x.1,x.2): Message output on the secure channel.\n// In_S($A,$H,$x.1,x.2): Secure channel message input.\n// !HK($H,$x.1, x.2): Holds the key for secure channel $H.\n// Send($H, LABEL,$x.1,x.2): Send message on the secure channel.\n// Receive($H, $x.1, x.2): Receive message from the secure channel.\n// H($H): The secure channel is active.\n// To($A): Message is targeted to party $A.\n// From($A): Message is from party $A.\n\n\n// Initialization\n// [ H($H) ]\n// [ !HK($H, $x.1, $x.2) ] // Initialize the key for channel $H.\n\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive(____(PRE_1)____,$x.1,x.2), !HK(____(LABEL_1)____,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,____(LABEL_2)____,x.2),\n\t\tH($H), To(____(PRE_2)____)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive(____(PRE_3)____,$x.1,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,____(PRE_4)____) ]\n\t--[ Send(____(PRE_5)____,$x.1,x.2), \n  \t    Send(____(LABEL_3)____,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S(____(PRE_6)____,$A,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule"]], "SPTHY-1/CRxor.spthy": [[true, "theory CRXOR\nbegin\n\n/*\nA&B:\nA->B: na\nB->A: <h(na \u2295 k \u2295 nb), nb>\nshould find attack:\n- after watching one run and storing data\n- uses nb'=na+nb+na'\n ((( na'+k+nb'= na'+k + na +nb+na' = k + na + nb )))\n*/\n\nbuiltins: xor,hashing\n\nrule Setup:\n  [ Fr(~k) ]\n--[ OnlyOnce() ]->\n  [ !InitLTK(~k), !RespLTK(~k) ]\n\nrule initiator:\n  [ Fr(~na) ]\n--[ Challenge(~na) ]->\n  [ Out(~na), Initiated(~na) ]\n\nrule responder:\n  [ In(na), Fr(~nb), !RespLTK(~k) ]\n--[ Response(<h(na \u2295 ~k \u2295 ~nb), ~nb>), Neq(na, zero), NeqForExec(na,zero) ]->\n  [Out(<h(na \u2295 ~k \u2295 ~nb), ~nb>) ]\n\nrule initiator2:\n  [ Initiated(~na), !InitLTK(~k), In(<m,nb>) ]\n--[ Alive(~na, ~k), Eq(h(~na \u2295 ~k \u2295 nb),m) ]->\n  [ ]\n\nend"]], "SPTHY-1/dh_alternative.spthy": [[true, "theory DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: diffie-hellman, symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, sk(k_A), pk(k_A)),\n          St_init_B($B, sk(k_B), pk(k_B)) ]\nend"]], "SPTHY-1/ex1-2.spthy": [[true, "theory Protocol2\nbegin\n\n/* ----------------- */\n/* Equational theory */\n/* ----------------- */\n\n/* Load the built-in encryption theories */\nbuiltins: symmetric-encryption, asymmetric-encryption, signing\n\n\n/* ---------------- */\n/* Public Key Setup */\n/* ---------------- */\nrule PubKey: \n   [ Fr(~ska) ] \n   --[ ]->\n   [ !SecretKey($A, ~ska),\n     !PublicKey($A, pk(~ska)), \n     Out(<$A,pk(~ska)>) ]\n\n\nrule Compromise: \n   [ !SecretKey($A, ~ska) ] \n   --[ Compromised($A) ]->\n   [ Out(~ska) ]\n\n\n/* -------------- */\n/* Protocol rules */\n/* -------------- */\nrule AliceSends:\n   [ Fr(~ma), Fr(~kAB), !PublicKey($B, pkB), !SecretKey($A, ~ska) ] \n   --[ ]->\n   [ !Ciphertext(enc(~kAB, ~ma), pkB), Out(<$A, enc(~kAB, ~ma), $B>) ]\n\n\nrule BobReceives:\n   [ In(<$A, enc(~kAB, ~mb), $B>), !SecretKey($B, ~skb), !PublicKey($A, pkA) ]\n   --[ ]->\n   [ !Plaintext(dec(~skb, enc(~kAB, ~mb)), pkA), Out(<$B, dec(~skb, enc(~kAB, ~mb)), $A>) ]\n\n\n/* ------------------ */\n/* Auxiliary functions */\n/* ------------------ */\n// Add any necessary auxiliary functions here, e.g., for key exchange.\n\n// Example auxiliary function (replace with your actual function):\n// rule DecryptMessage:\n//    [ !Ciphertext(c, pk), !SecretKey(k, s) ]\n//    --[ ]->\n//    [ !Message(dec(c, pk)) ]\n\nend"]], "SPTHY-1/exADH-kn.spthy": [[true, "(~id, sk)       // Store sk indefinitely and securely from adv\n  ]\n\n\nrule A_Init:\n  let\n    m1 = <idA, idB, pkA>  // KE message m1\n  in\n  [ !Pk(idA, pkA)       // Obtain own ID, anyone will do\n  , !Pk(idB, pkB)       // Obtain a peer ID, anyone will do\n  ]\n  --[ AReachAInit() ]-> \n  [ Out(m1)             // Send m1 via adv\n  , St_A(idA, idB)      // Keep state for \"next invocation\"\n  ]\n\nrule B_Init:\n  let \n    s = pkA^~skB                         // established shared secret\n    m1 = <idA, idB, pkA>                 // KE message m1\n    m2 = <senc('ack', s), idA, idB, pkB> // KE message m2\n  in\n  [ In(m1)              // Read m1 from \"interface\", i.e., adv\n  , !Sk(idB, skB)       // Obtain peer's secret key\n  ]\n  --[ BReachBInit() ]-> \n  [ Out(m2)             // Send m2 via adv\n  , St_B(idA, idB)      // Keep state for \"next invocation\"\n  ]\n\n\nrule A_Next:\n  let\n    m2 = <senc('ack', s), idA, idB, pkB>\n    s = pkB^~skA\n  in\n  [ In(m2)\n  , St_A(idA, idB)\n  ]\n  --[ AReachANext() ]-> \n  [ !print(\"A received acknowledgment\") ]\n\n\nrule B_Next:\n  let\n    m2 = <senc('ack', s), idA, idB, pkB>\n    s = pkA^~skB\n  in\n  [ In(m2)\n  , St_B(idA, idB)\n  ]\n  --[ BReachBNext() ]-> \n  [ !print(\"B received acknowledgment\") ]\n\ninit [ St_A(idA,idB), St_B(idA,idB) ]"]], "SPTHY-1/final_protocol_and_property-2.spthy": [[true, "theory Protocol5\nbegin\n\nbuiltins: symmetric-encryption, hashing\n\n// Rule for generating a shared key between A and B\nrule Generate_Shared_Key:\n    [ Fr(~kab) ]\n    -->\n    [ !SharedKey($A, $B, ~kab) ]\n\n// Rule for A initiating the protocol\nrule A_1:\n    let msg = senc(<$A, $B, ~n, h(~n)>, kab)\n    in\n    [ Fr(~n), !SharedKey($A, $B, kab) ]\n    -->\n    [ Out(msg), St_A_1($A, $B, ~n, h(~n)) ]\n\n// Rule for B receiving the first message and responding\nrule B_1:\n    let msg_in = senc(<$A, $B, n, hn>, kab)\n        msg_out = senc(<$B, ~m, h(n)>, kab)\n    in\n    [ In(msg_in), !SharedKey($A, $A, kab), Fr(~m) ]\n    --[ Eq(hn, h(n)), Create($B, 'B_1'), Out(msg_out), St_B_1($A, $B, ~m, n) ]\n    \n// Rule for A receiving the second message and verifying it\nrule A_2:\n    let msg_in = senc(<$B, m, h(n)>, kab)\n    in\n    [ In(msg_in), St_A_1($A, $B, n, h(n)) ]\n    --[ Eq(h(n), h(n)), Create($A, 'A_2') ]\n\nend"]], "SPTHY-1/final_protocol_and_property-5.spthy": [[true, "theory One\nbegin\n\nbuiltins: symmetric-encryption\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Key($A, $B, k_A_B),\n          Fr(~M) \n        ]\n        --[  ]->\n        [ St_init_A($A, $B, ~M, k_A_B),\n          St_init_B($A, $B, k_A_B)\n        ]\n\n// ROLE A  \nrule msg1_A:\n        [ St_init_A(A, B, M, k_A_B),\n          Fr(~N)\n        ]  \n        --[ FreshTerm(A, M) ]->\n        [ Out(senc{M}~N),\n          St_msg1_A(A, B, M, ~N, k_A_B)\n        ]\n\nrule msg2_A:\n        [ St_msg1_A(A, B, M, ~N, k_A_B),\n          In(senc{N}k_A_B)\n        ]  \n        --[  ]->\n        [ St_msg2_A(A, B, M, ~N, k_A_B)\n        ]\n\n// ROLE B\nrule msg1_B:\n        [ St_init_B(A, B, k_A_B) ]\n        --[  ]->\n        [ St_msg1_B(A, B, k_A_B) ]\n\n\n\nrule msg2_B:\n        [ St_msg1_B(A, B, k_A_B),\n          In(senc{M}~N)\n        ]\n        --[  ]->\n        [ St_msg2_B(A, B, k_A_B, M, ~N) ]\n\n\n// ... other rules\nend"]], "SPTHY-1/CR.spthy": [[true, "theory CR\nbegin\n\n/*\nA&B:\nA->B: na\nB->A: <h(na, k,nb), nb>\nachieves recent aliveness\n*/\n\nbuiltins: hashing\n\nrule Setup:\n  [ Fr(~k) ]\n--[ OnlyOnce() ]->\n  [ !InitLTK(~k), !RespLTK(~k) ]\n\nrule initiator:\n  [ Fr(~na) ]\n--[ Challenge(~na) ]->\n  [ Out(~na), Initiated(~na) ]\n\nrule responder:\n  [ In(na), Fr(~nb), !RespLTK(~k) ]\n--[ Response(na)]->\n  [Out(<h(na,~k,~nb), ~nb>) ]\n\nrule initiator2:\n  [ Initiated(~na), !InitLTK(~k), In(<m,nb>) ]\n--[ Alive(Eq(h(~na,~k,~nb),m)) , Eq(h(~na,~k,nb),m) ]->\n  []\n\nrestriction equality:\n  \"All x y #i. Eq(x,y)@i ==> x=y\"\n\n/*\nrestriction unique:\n  \"All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j\"\n*/\n\n// FINDS PROOF \n\nend"]], "SPTHY-1/FirstAttestation.spthy": [[true, "theory FirstEATImplementation\nbegin\nbuiltins: asymmetric-encryption, revealing-signing\n\nrule create_identities:\n    [Fr(~ltk)] //generate new fresh private key\n    -->\n    [!Identity($A, ~ltk, pk(~ltk)), Out(pk(~ltk))] //Generate a fact where the agent:A is assosiated with the priv/pub-key and output the public-key to the web\n\n\nrule Verifier_sends_Nonce_to_Attester: // note $ on attester, might need to remove it\n    [!Identity($Verfier, ~ltk, pk(~ltk)), Fr(~n) ]\n    -->\n    [Out(<$Verfier, $Attester, ~n>), !Nonce(~n)]\n\n\nrule Atterster_create_and_sends_EAT:\n    let\n        EAT = <~n, $attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n    in\n    [!Identity($Attester, ~Altk, pk(~Altk)) , Out(signed_EAT)]\n    \nrule Verifier_receive_EAT:\n    [In(signed_EAT), !Identity($Verfier, ~ltk, pk(~ltk))]\n    -->\n    [ !EATReceived($Verfier, signed_EAT)]\n\nrule Verifier_verify_EAT:\n    [!EATReceived($Verfier, signed_EAT), !Nonce(~n)]\n    -->\n    [verify(signed_EAT, pk(~Altk)) -> !VerificationSuccess,\n    verify(signed_EAT, pk(~Altk)) -> !VerificationFailure]\n    \n// Example verification failure rule (can be expanded)\nrule Verification_Failure:\n    [!VerificationFailure]\n    -->\n    [Out(<$Verfier, $Attester, \"Verification Failure\">)]\n    \nrule Verification_Success:\n    [!VerificationSuccess]\n    -->\n    [Out(<$Verfier, $Attester, \"Verification Success\">)]\n\nend"]], "SPTHY-1/Google2Step_MA.spthy": [[true, "module ProtocolExample\n\nimports\n  int.Int\n\nsorts\n  Msg\n  Event\n\nconstructors\n  In_S(Agent, Agent, <Term, Term>, <Term, Term>) : Event\n  Out_S(Agent, Agent, <Term, Term, Term, Term>, <Term, Term, Term, Term>) : Event\n  Receive(Agent, Term, Term) : Event\n  To(Agent) : Event\n  From(Agent) : Event\n  H(Agent) : Event\n  !HK(Agent, Term, Term) : Event\n\nvariables\n  $A, $H, $x, $y, $z, $v : Agent\n  x, y, z, v : Term\n\n\nrule H_send_S1:\n\t[ Out_S($H, $A, <$x.1,$y.1,$z.1,$v.1>,<$x.2,$y.2,$z.2,$v.2>) ]\n\t--[ To($A),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1,1>,<1,y.2,z.2,v.2>) ]\n\n\nrule H_receive_S2:\n\t[ In_S($A,$H, <$x.1,$y.1>, <x.2,y.2>) ]\n\t--[ Receive($A,$x.1,x.2),\n\t\tReceive($H,1,2), !HK($H,$x.1,x.2),!HK($H,$x.1,y.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S($A,$H, <$x.1,$y.1,$z.1,$v.1>,<x.2,y.2,z.2,v.2>) ]\n\t--[     Receive($H,x.2,x.2),\n\t\tReceive($H,y.2,y.2),\n\t\tReceive($H,z.2,z.2),\n\t\tReceive($H,v.2,v.2),\n\t\tH($H), From($A)]->\n\t[ ]\n\n\nendmodule"]], "SPTHY-1/HPagree.spthy": [[true, "module human_selection\n\n// Import necessary modules\nimport std\n\n// Define types\ntype Human =  int\ntype Message = int\n\n// Define predicates\npred human(H: Human)\n\npred message(M: Message)\n\n// Define relations\nrel send(H1: Human, H2: Human, M: Message)\nrel receive(H1: Human, H2: Human, M: Message)\n\n// Define the initial state\ninit {\n\thuman(1)\n\thuman(2)\n\tmessage(1)\n\tmessage(2)\n\tmessage(3)\n}\n\n// Define rules (using the provided examples as guidance)\nrule send_message(H1: Human, H2: Human, M: Message) {\n\tsend(H1, H2, M)\n\t<- human(H1) & human(H2) & message(M)\n}\n\nrule receive_message(H1: Human, H2: Human, M: Message) {\n\treceive(H1, H2, M)\n\t<- human(H1) & human(H2) & message(M) & send(H2, H1, M)\n}\n\n\n// Add rules for the NoOverwrite and DoClaimBeforeSend conditions (crucial for the verification)\nrule NoOverwrite(H: Human, M: Message) {\n\t// This rule prevents overwriting of a message\n\t//  (needs to be carefully defined based on the specific protocol)\n\t<- human(H) & message(M)\n}\n\nrule DoClaimBeforeSend(H: Human, M: Message) {\n\t// This rule enforces a specific order of actions\n\t// (needs to be carefully defined based on the specific protocol)\n\t<- human(H) & message(M)\n}\n\n\n\n// Example lemmas (adapt these to your specific lemmas)\nlemma functional {\n\t// Define the conditions that need to be checked for functionality\n\t// This example is a placeholder and needs to be adapted to the protocol\n\tforall (H1, H2, M): human(H1) & human(H2) & message(M) -> (\n\t\tsend(H1, H2, M) -> receive(H2, H1, M)\n\t)\n}\n\n\nlemma agree_HE {\n\t// Define the conditions for agreement\n\tforall (H1, H2, M): human(H1) & human(H2) & message(M) -> (\n\t\tsend(H1, H2, M) & send(H2, H1, M)  -> true\n\t)\n}\n\nlemma agree_HE2 {\n\t// Define the conditions for agreement (another variation)\n\tforall (H1, H2, M): human(H1) & human(H2) & message(M) -> (\n\t\tsend(H1, H2, M) & send(H2, H1, M)  -> true\n\t)\n}"]], "SPTHY-1/InputOutput.spthy": [[true, "theory InputOutputTest\nbegin\n\n/*\n * Protocol:\t Test of simple input and output (memorized)\n * Modeler: \t Jannik Dreier and Ralf Sasse\n * Described in: \n * Date: \t April 2015\n *\n * Status: \t working\n */\n\nfunctions: h/1, aenc/2, adec/2, pk/1\nequations: adec(aenc(m, pk(k)), k) = m\n\nrule Initialize:\n  [ Fr(~x) ]\n  --[ TestInitLabel(~x) ]->\n  [ Test(~x), Out(~x) ]\n\nrule Initialize2:\n  [ Fr(~x) ]\n  --[ TestInitLabel2(~x) ]->\n  [ Test(~x), Out(~x) ]\n\n\n// this should lead to attacks, as the adversary can check whether the memorized value needs to be received or arbitrary values are permissible\n// Registering a public key\nrule Register_pk:\n  [ Fr(~ltk), In(x), Test(d), Out(pk(y)) ]\n  --[ Register_pk(~ltk, x, d, y) ]->\n  [ Fr(~ltk), Test(d), Out(pk(y)) ]\n\n\n\nrule Input:\n  [ Fr(~x), In(y) ]\n  --[ Input(~x, y) ]->\n  [ Fr(~x), In(y), Out(y) ]\n\nrule Output:\n  [ Fr(~x), Out(y) ]\n  --[ Output(~x, y) ]->\n  [ Fr(~x) ]\n\nrule Test:\n  [ Fr(~x), Test(y) ]\n  --[ Test(~x, y) ]->\n  [ Fr(~x) ]\n\nrule TestSuccess:\n  [ Fr(~x), Test(y), Out(z) ]\n  --[ TestSuccess(~x, y, z) ]->\n  [ Fr(~x), Out(z) ]\n\n\nrule TestFail:\n  [ Fr(~x), Test(y), Out(z) ]\n  --[ TestFail(~x, y, z) ]->\n  [ Fr(~x) ]\n\n\n\nrule TestInputOutput:\n  [ Fr(~x), In(y), Out(z) ]\n  --[ TestInputOutput(~x,y,z) ]->\n  [ Fr(~x) ]\n\n\nend"]], "SPTHY-1/issue446-1.spthy": [[true, "theory lemma_falsified_verified\nbegin\n\n/*\n* Date: November 2021\n* Comment: Minimal example for a missing check if\n* 'SOLVED' is present with a non-empty but incomplete proof.\n*/\n\nrule A:\n   [ ]\n --[ A('x')]->\n   [ ]\n\nlemma lemma_verified:\n  all-traces\n  \"All x #____(LEM_0)____. A(x)@i ==> A(x)@i\"\n\nlemma lemma_falsified:\n  all-traces\n  \"All x #____(LEM_1)____. A(x)@i ==> A(x)@i\"\nsimplify\nSOLVED\n\nend"]], "SPTHY-1/issue519.spthy": [[true, "theory issue519\nbegin\n\n/* Minimal working example for incorrect source computation bug where the source is a MsgVar part of a multiset.\n *\n * Expectation: Both lemmas should be false, because St(x) can only occur for x a fresh value.\n * However, in Tamarin 1.6.1, the first is verified (MsgVar, incorrectly), and the second falsified (FreshVar, correctly).\n *\n * This seems to be caused by an incorrect source computation for the fresh value, which does not consider Send_multiset_msgVar as a source.\n *\n * By Cas Cremers\n */\nbuiltins: multiset\n\nrule CreateAndStoreFresh:\n  [Fr(~x)]-->[St(~x)]\n\nrule Send_multiset_msgVar:\n  [St(x), In(y)]\n  --[ Secret_MsgVar(x) ]-> [In(y)]\n\n\nlemma Lemma1:\n  !x. ~ ( [St(x)] |- [Secret_MsgVar(x)])\n  \nlemma Lemma2:\n  !x. ~ ( [St(x)] |- [Fr(x)])\nend"]], "SPTHY-1/JKL_TS1_2004-KI.spthy": [[true, "theory JKL_TS1_2004\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* Jeong, Katz, Lee : TS1 (2004) *}\n\n/*\n * Protocol:\tJKL-TS1-2004\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"One-Round Protocols for Two-Party Authenticated Key Exchange\"\n * \t\tJeong, Katz, Lee, 2004.\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n  let pkA = 'g'^~lkA\n  in\n   [ Fr(~lkA) ] -->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI, ~lkI,$R, ~ekI )\n     , NotEq($I,$R) \t\t\t// Inequality of names required, enforced in the property\n     ]->\n   [ Init_1( $I,$R,~ekI, ~lkI, pkI ) ]\n\nrule SidI_1:\n  [ SidI_1(~ekI, ~lkI,$R, ~ekI ) ] -->\n  [ !Pk( $R, pkR ) ] --[  !Ltk( $R, ~lkR )\n     , NotEq($I,$R) \t\t\t// Inequality of names required, enforced in the property\n     ]->\n  [ Init_1( $I,$R,~ekI, ~lkI, pkI ) ]\n\nrule Init_2:\n  [ Init_1( $I, $R, ~ekI, ~lkI, pkI ) , !Ltk( $R, ~lkR ) ] -->\n  [ !Pk($R, pkR), !Ltk( $I, ~lkI ) ] --[ NotEq($I,$R) ] ->\n  [  Init_2( $I, $R, ~ekI, ~lkI, pkI, pkR )]\n\n\nrule Init_2:\n  [ Init_1( $I, $R, ~ekI, ~lkI, pkI ), !Ltk( $R, ~lkR ), !Pk( $R, pkR) ] --[ NotEq($I,$R) ] ->\n  [ Init_2( $I, $R, ~ekI, ~lkI, pkI, pkR ) ]\n\n\nrule Init_2_end:\n  [ Init_2( $I, $R, ~ekI, ~lkI, pkI, pkR) ] -->\n  [ !Sk( $I, ~skI ) ]\n\n\n// ... other rules ...\n\nend"]], "SPTHY-1/JKL_TS1_2008-KI_wPFS.spthy": [[true, "theory JKL_TS1_2008\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* Jeong, Katz, Lee : TS1 (2008) *}\n\n/*\n * Protocol:\tJKL-TS1-2008\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"One-Round Protocols for Two-Party Authenticated Key Exchange\"\n * \t\tJeong, Katz, Lee, 2008\n *\t\tNote: Although the paper title is the same as the 2004\n *\t\toriginal, the updated version from 2008 includes\n *\t\tmodified protocols and security models.\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, $A ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ !Pk( $I, $I ) ]\n   -->\n   [ Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ In( 'g'^~ekJ ), !Ltk( $J, ~lkJ ) ]\n   --[ !Pk( $J, $J ) ]\n   -->\n   [ Out( 'g'^~ekJ ) ]\n\n\nrule Compute_Key_1:\n\t[ In( 'g'^~ekJ ), !Ltk( $I, ~lkI ) , !Pk( $I, $I ) ] -->\n\t[ !Key( $I, ~ekI ) ]\n\nrule Compute_Key_2:\n\t[ In( 'g'^~ekI ), !Ltk( $J, ~lkJ ) , !Pk( $J, $J ) ] -->\n\t[ !Key( $J, ~ekJ ) ]\n\nend"]], "SPTHY-1/Joux_EphkRev.spthy": [[true, "theory Joux_EphkRev\nbegin\n\nsection{* The Joux Protocol using Signatures*}\n\n/*\n * Protocol:\tThe Joux Protocol.\n * Source:      \"A One Round Protocol for Tripartite Diffie-Hellman\"\n *              A. Joux\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n *\n * Model:       PFS with ephemeral key reveals\n * Status: \tworking\n */\n\nbuiltins: bilinear-pairing, signing, multiset\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ] \n  --[ ]-> \n  [ !Ltk(A, ~ltk), !Pk(B, pk(~ltk)), Out(pk(~ltk)) ]\n\n// Reveals\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Proto1:\n  let hkA = pmult(g, ~ltk) in\n  [ !Pk(A, pkA), Fr(~ltk), Fr(skA) ]\n  --[ ]->\n  [ !Ltk(A, ~ltk), !Pk(A, pkA), Out(hkA) ]\n\n// Protocol\nrule Proto2:\n  let hkB = pmult(g, ~ltk) in\n  [ !Pk(B, pkB), Fr(~ltk), Fr(skB) ]\n  --[ ]->\n  [ !Ltk(B, ~ltk), !Pk(B, pkB), Out(hkB) ]\n\n// Protocol\nrule Proto3:\n  [ !Pk(A, pkA), !Ltk(B, ~ltk), In(hkB) ]\n  --[ ]->\n  [ !Pk(A, pkA), !Ltk(B, ~ltk), !SharedSecret(A, B, sA), Out(sA) ]\nwhere sA = exp(hkB, skA)\n\n// Protocol\nrule Proto4:\n  [ !Pk(B, pkB), !Ltk(A, ~ltk), In(hkA) ]\n  --[ ]->\n  [ !Pk(B, pkB), !Ltk(A, ~ltk), !SharedSecret(B, A, sB), Out(sB) ]\nwhere sB = exp(hkA, skB)\n\n\n// Verification\nrule Verify:\n    [ !SharedSecret(A, B, sA), !SharedSecret(B, A, sB) ]\n  --[ ]->\n    [ Out(sA), Out(sB) ]\n\n// Signatures\nrule Sign:\n  [ Fr(skA), Data(msg) ]\n  --[ ]->\n  [ !Sig(A, sig(msg, skA)) ]\n\nrule VerifySig:\n  [ !Sig(A, sig), Data(msg), !Pk(A, pk) ]\n  --[ ]->\n  [ Verify(sig, msg, pk) ]\n\n\n\nend"]], "SPTHY-1/KAS2_eCK.spthy": [[true, "theory KAS2_eCK\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS2 *}\n\n/*\n * Protocol:\tKAS2\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\teCK\n *\n * Status: \tworking\n */\n\nfunctions: KDF/1\nfunctions: MAC/2\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule Register_pk:\n  let pkA = pk(~ltkA)\n  in\n  [ Fr(~ltkA) ] \n  --> \n  [ !Ltk($A, ~ltkA), !Pk($A, pkA), Out(pkA) ]\n\n/* Initiator */\nrule Init_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr( $I ), !Ltk( $I, ~lkI ), !Pk($R,pkR) ]\n   --[ Sid( $I ), Out(c1) ]\n   --> \n   [ !Msg1($I, $R, ~m1, c1) ]\n\nrule Init_2:\n  let c2 = aenc{ ~m2 }pkI\n  in\n   [ In(c2), !Msg1($I, $R, ~m1, c1) ]\n   --> \n   [ !Msg2($I, $R, ~m2, c2) ]\n\n/* Responder */\nrule Resp_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr($R), !Ltk($R, ~lkR), !Pk($I, pkI) ]\n   --[ Sid($R), In(c1) ]\n   --> \n   [ !Msg1($R, $I, ~m1, c1) ]\n\nrule Resp_2:\n  let c2 = aenc{ ~m2 }pkI\n  in\n   [ In(c2), !Msg1($R, $I, ~m1, c1) ]\n   --> \n   [ !Msg2($R, $I, ~m2, c2) ]\n\nrule Agree_1:\n  let k = KDF(~m1, ~m2)\n  in\n   [ !Msg2($I, $R, ~m2, c2), !Msg1($R, $I, ~m1, c1) ]\n   --> \n   [ !SharedKey($I, $R, k) ]\n\nrule Agree_2:\n  let k = KDF(~m1, ~m2)\n  in\n   [ !Msg2($R, $I, ~m2, c2), !Msg1($I, $R, ~m1, c1) ]\n   --> \n   [ !SharedKey($R, $I, k) ]\n\n\nend"]], "SPTHY-1/Ex1_solution.spthy": [[true, "theory Ex1_solution\nbegin\n\n/* ----------------- */\n/* Equational theory */\n/* ----------------- */\n\n/* Load the built-in encryption theories */\nbuiltins: symmetric-encryption, asymmetric-encryption, signing\n\n\n/* ---------------- */\n/* Public Key Setup */\n/* ---------------- */\nrule PubKey: \n   [ Fr(~ska) ] \n   --[ ]->\n   [ !SecretKey($A, ~ska),\n     !PublicKey($A, pk(~ska)), \n     Out(<$A,pk(~ska)>) ]\n\n\nrule Compromise: \n   [ !SecretKey($A, ~ska) ] \n   --[ Compromised($A) ]->\n   [ Out(~ska) ]\n\n\n/* -------------- */\n/* Protocol rules */\n/* -------------- */\n//SOL: The fix to achieve non-ing agreement is to include Bob's identity\n//SOL\n\nend"]], "SPTHY-1/KEA_plus_eCK.spthy": [[true, "theory KEA_plus_eCK\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* KEA+ *}\n/*\n * Protocol:\tKEA+\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * \t\tLauter, Mityagin, 2006\n * Property: \teCK security\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, $lk ), !Pk( $A, $pk ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->\n   [ Init_1( ~ekI, $I, $R, $ekI, $lkI ),\n     !Ephk(~ekI),\n     Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ Init_1( ~ekI, $I, $R, $ekI, $lkI ), !Ltk( $R, $lkR ), In( 'g'^~ekR ) ]\n   --[]->\n   [ Init_2( ~ekI, $I, $R, $ekI, $lkI, $ekR ),\n     !Ephk(~ekR),\n     !Ltk( $R, $lkR ) ]\n  \nrule\n  Calc_ekR:\n   [ Init_2( ~ekI, $I, $R, $ekI, $lkI, $ekR ) ]\n   --[]->\n   [ Calc_ekR( ~ekI, $I, $R, $ekI, $lkI, $ekR,  ____(POST_2)____ ) ,\n     !Ephk( ____(PRE_2)____ )\n   ]\n\n\n\nend"]], "SPTHY-1/KEA_plus_KI_KCI_wPFS.spthy": [[true, "theory KEA_plus_KI_KCI_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* KEA+ *}\n/*\n * Protocol:\tKEA+\n * Modeler: \tCas Cremers\n * Date: \tJanuary/April 2012\n * Source:\t\"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * \t\tLauter, Mityagin, 2006\n * Property:\tKI, KCI, wPFS\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, ~pkA ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI, $I, $R, epkI ) ]->\n   [ Init_1( ~ekI, $I, $R, epkI ),\n     !Ephk(~ekI),\n     Out( epkI ) ]\n\nrule Init_2:\n  let epkR = 'g'^~ekR\n  in\n   [ Fr( ~ekR ), !Ltk( $R, ~lkR ) ]\n   --[ SidR_1(~ekR, $R, $I, epkR ) ]->\n   [ Init_2( ~ekR, $R, $I, epkR ),\n     !Ephk(~ekR),\n     Out( epkR ) ]\n\nrule Exchange_1:\n  [ Init_1( ~ekI, $I, $R, epkI ) ] -->\n  [  !Ephk(~ekI),\n     Out( epkI ),\n     In( epkR ) ]\n\n\nrule Exchange_2:\n  [ Init_2( ~ekR, $R, $I, epkR ) ] -->\n  [  !Ephk(~ekR),\n     Out( epkR ),\n     In( epkI ) ]\n\n\n\nrule compute_key:\n   [ Init_1( ~ekI, $I, $R, epkI ), In( epkR ) ] -->\n   [ compute_key( ~ekI, $I, $R, epkI, epkR ) ]\n\nrule compute_key_2:\n   [ Init_2( ~ekR, $R, $I, epkR ), In( epkI ) ] -->\n   [ compute_key_2( ~ekR, $R, $I, epkR, epkI ) ]\n\n\n\nend"]], "SPTHY-1/LD07_UK2.spthy": [[true, "theory LD07_UK2\nbegin\n\nbuiltins: xor, hashing, multiset\n\n/*\nLD07: Readers R_i for i>0, RFID tag T\n      Reader R_i knows k_0, k_i, k_{i+1}\n      Tag T knows alpha := k_0 XOR k_i\n\n   Ri: knows(k0, ki, ksi)\n   T: let alpha := k0 XOR ki\n   T: knows(alpha)\n   Ri: fresh(r)\nRi->T: r\n   T: let alpha := k0 XOR ki\nT->Ri: h(r XOR alpha)\n   Ri: let  a := ki XOR ksi\n   Ri: let  b := h(a XOR k0 XOR ki)\nRi->T: a, b\n   T: if b = h(a XOR k0 XOR ki) then let alpha' := alpha XOR a else alpha'=alpha\n   T: knows(alpha')\n\nThis is a stateful protocol for the tag. The tag's knowledge is updated. \n\nThe model concerns untraceability based on the UK2 definition. \nIt shows that the un\n*/\n\nrole Reader(i)\nbegin\n  knows(k0, ki, ksi)\n  fresh(r)\n  output(r)\n  input(x)\n  let a := ki XOR ksi\n  let b := hashing(a XOR k0 XOR ki)\n  output(a, b)\nend\n\nrole Tag\nbegin\n  input(r)\n  let alpha := k0 XOR ki\n  output(hashing(r XOR alpha))\n  input(a, b)\n  if b = hashing(a XOR k0 XOR ki) then\n    let alpha' := alpha XOR a\n  else\n    let alpha' := alpha\n  knows(alpha')\nend\n\n/* Define the initial knowledge */\ninit:\n  knows(k0)\n  knows(k1)\n  knows(k2)\n\nend"]], "SPTHY-1/mls-03.spthy": [[true, "theory MLS03\nbegin\n\nbuiltins: hashing, signing, asymmetric-encryption\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ltk),\n    !Pk($A, pk(____(POST_0)____)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: g^x, C, Sig_C(g^x)\n// S->C: g^y, S, Sig_S(g^x) MAC_k(g^x)\n//       k = H(g^x || g^y || C || S)\n\n// Client logic\nrule ClientInit:\n  let\n    gx = pk(~x)\n    pkC = pk(ltkC)\n    sig = sign(<gx, C, pkC>, ltkC)\n    uik = <gx, C, pkC, sig>\n  in\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientPostedInitKey(C, gx) ]->\n  [\n    ClientWait(C, uik)\n  ]\n\n\n// Server logic\nrule ServerInit:\n  [ !Pk(S, pkS), In(uik) ]\n  -->\n  [\n      let\n        gx = fst(uik)\n        C = snd(uik)\n        pkC = third(uik)\n        sig = fourth(uik)\n      in\n      !Pk(C, pkC),\n      checkSig(sig, <gx, C, pkC>, ltkS), // Check signature\n      let\n          gy = pk(~y)\n          k = hash(<gx, gy, C, S>)\n          mac = mac(k, gx)\n      in\n      Out(<gy, S, mac>)\n  ]\n\n// ... (rest of the protocol rules) ...\n\nend"]], "SPTHY-1/MTI_C0.spthy": [[true, "theory MTI_C0\nbegin\n\nbuiltins: diffie-hellman \n\nfunctions: kdf/1\n\n// Enable this equation to find a small-subgroup (for <1>) attack.\n// equations: exp(1,x) = 1\n\nsection{* The MTI/C0 protocol *}\n\n/*\n * Protocol:\tMTI/C0\n * Modeler: \tBenedikt Schmidt\n * Date: \tFebruary 2012\n * Source:\t\"About the Security of MTI/C0 and MQV\"\n *\t        Sebastien Kunz-Jacques, David Pointcheval\n * \t\tSCN'06, Springer, 2006\n *\n * Status: \tcomplete\n */\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ] \n --> \n  [ !Ltk(A, ~ltk), !Pk(A, 'g'^~ltk), Out('g'^~ltk) ]\n\n// Initiator\nrule Init_1:\n  [ Fr( ~ekI )\n  , !Pk( $R, 'g'^~ltkR)  ]\n -->\n  [ Init_1( $R, ~ekI, ~ltkR), Out('g'^~ekI^~ltkR) ]\n\nrule Init_2:\n  [ Init_1( $R, ~ekI, ~ltkR),\n  In('g'^~ekI^~ltkR)\n  ]\n -->\n  [ Fr(~ekR), !Sk( $R, kdf(~ekR)), !Sk( $A, kdf(~ekI)) ]\n\n// Responder\nrule Resp_1:\n  [ !Pk( $A, 'g'^~ltkA)\n  , Fr(~ekR) ]\n -->\n  [ Resp_1( $A, ~ekR, ~ltkA), Out('g'^~ekR^~ltkA) ]\n\nrule Resp_2:\n  [ Resp_1( $A, ~ekR, ~ltkA),\n  In('g'^~ekR^~ltkA)\n  ]\n -->\n  [ !Sk( $A, kdf(~ekI)), !Sk( $R, kdf(~ekR)) ]\n\n\n// Verification\nrule Verify:\n  [ !Sk( $A, kdf(~ekI)), !Sk( $R, kdf(~ekR)) ]\n -->\n  [ ]\n\n\nend"]], "SPTHY-1/NAXOS_eCK_PFS.spthy": [[true, "theory NAXOS_eCK\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tCas Cremers, Benedikt Schmidt\n * Date: \tJanuary 2012/April 2012/October 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \teCK security + PFS\n *\n * Status: \tWorking\n */\n\nfunctions: h1/1\nfunctions: h2/1\n\n/* Protocol rules */\n\n/* In the description in the paper, we omitted the sorts. \n * In this description they are made explicit.\n * '$A' is equivalent to 'A:pub'\n * '~x' is equivalent to 'x:fresh'\n */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n  let pkA = 'g'^~ea \n  in\n  [ Fr(~ea)\n\n  , Sk(~ea)\n  ,  A:pub(pkA)\n  ]\n\n/* Client */\nrule client:\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~nb\n  ]\n  ->\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~nb\n  ,  na:fresh\n  ,  Kb:fresh\n  ,  C1:fresh\n  ,  C2:fresh\n  ,  Mb:fresh\n  ]\n\n\n/* Server */\nrule server:\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~na\n  ,  Kb\n  ,  C1\n  ,  C2\n  ,  Mb\n  ]\n  ->\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~na\n  ,  Kb\n  ,  C1\n  ,  C2\n  ,  Mb\n  ,  Sa:fresh\n  ,  Sb:fresh\n  ]\n\n\n/* Client sends message to Server */\nrule client_send:\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~nb\n  ,  na:fresh\n  ,  Kb:fresh\n  ,  C1:fresh\n  ,  C2:fresh\n  ,  Mb:fresh\n  ]\n  ->\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~nb\n  ,  na:fresh\n  ,  Kb:fresh\n  ,  C1:fresh\n  ,  C2:fresh\n  ,  Mb:fresh\n  ,  msg1:fresh\n  ]\n\n\n\n\n/* Server sends message to Client */\nrule server_send:\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~na\n  ,  Kb\n  ,  C1\n  ,  C2\n  ,  Mb\n  ,  Sa:fresh\n  ,  Sb:fresh\n  ]\n  ->\n  [ A:pub(pkA)\n  , B:pub(pkB)\n  , ~na\n  ,  Kb\n  ,  C1\n  ,  C2\n  ,  Mb\n  ,  Sa:fresh\n  ,  Sb:fresh\n  , msg2:fresh\n  ]\n\n\nend"]], "SPTHY-1/NSPK3.spthy": [[false, "```\ntheory NSPK3\nbegin\n\nbuiltins: asymmetric-encryption\n\n/*\n   Protocol:    The classic three message version of the\n                flawed Needham-Schroeder Public Key Protocol\n   Modeler:     Simon Meier\n   Date:        September 2012\n\n   Source:      Gavin Lowe. Breaking and fixing the Needham-Schroeder\n                public-key protocol using FDR. In Tiziana Margaria and\n                Bernhard Steffen, editors, TACAS, volume 1055 of Lecture Notes\n                in Computer Science, pages 147\u2013166.  Springer, 1996.\n\n   Status:      working\n\n   Note that we are using explicit global constants for discerning the\n   different encryption instead of the implici\n*/\n\n(*\n  The flaw is that the attacker can impersonate A.\n  The attacker intercepts the message from A to B,\n  and sends a message to B using A's public key.\n  This message has the same format as the original message.\n  B will then send a reply to the attacker.\n  The attacker can then decrypt the message and forge a\n  message to A, completing the attack.\n*)\n\nchan A_to_B, B_to_A, A_to_Attacker, Attacker_to_B, Attacker_to_A;\n\n(*\n  The messages are:\n  A -> B  : {Na, Kab}Pub(B)\n  B -> A  : {Nb, Kab}Pub(A)\n  A -> A  : {Kab}Pub(A)\n  A -> Attacker: {Na, Kab}Pub(B)\n  Attacker -> B: {Na, Kab}Pub(B)\n  B -> Attacker: {Nb, Kab}Pub(A)\n  Attacker -> A: {Kab}Pub(A)\n\n\n*)\n\ntypes:\n  N = {N1, N2, N3, N4};\n  Key = {K1, K2, K3, K4};\n  Public = {P1, P2, P3, P4};\n\nvariables:\n  Na, Nb, Kab : N;\n\nprocess A\nbegin\n  A_to_B! {Na, Kab}Pub(B);\n  receive {Nb, Kab}Pub(A) from B_to_A;\nend\n\nprocess B\nbegin\n  receive {Na, Kab}Pub(B) from A_to_B;\n  B_to_A! {Nb, Kab}Pub(A);\nend\n\nprocess Attacker\nbegin\n  receive {Na, Kab}Pub(B) from A_to_Attacker;\n  Attacker_to_B! {Na, Kab}Pub(B);\n  receive {Nb, Kab}Pub(A) from B_to_A;\n  Attacker_to_A! {Kab}Pub(A);\nend\n\n\nprocess A_init\nbegin\n  Na := N1;\n  A();\nend\nprocess B_init\nbegin\n  Nb := N2;\n  B();\nend\nprocess Attacker_init\nbegin\n  Attacker();\nend\n\ninit:\n  A_init || B_init || Attacker_init;\n\nend\n```"]], "SPTHY-1/OTPoverSMS_MA.spthy": [[true, "rule H_send_S:\n\t[ H($H), !HK($H,$x.1,x.2) ]\n\t--[ Send(PRE_2,$x.1,x.2),\n\t\tH($H), To(LABEL_1)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive(LABEL_2,$x.1,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From(PRE_3)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,PRE_4), !HK($H,$y.1,y.2) ]\n\t--[ Send($H,LABEL_3,PRE_5), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S($A,$H,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,PRE_4), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(LABEL_4,$x.1,PRE_9), \n\t    Send(LABEL_5,$y.1,PRE_8)\n\t\tH($H), To($B)]->\n\t[ Out_S($B,$H,<$x.1,$y.1,$z.1>,<x.2,y.2,z.2>) ]"]], "SPTHY-1/OTYT06_UK2.spthy": [[true, "theory OTYT06_UK2\nbegin\n\nbuiltins: xor, hashing, multiset\n\n/*\nOTYT06: Reader R, RFID tag T, shared knowledge k\n\tThis is a stateful protocol, the tag and reader's knowledge is updated\n        after a successful run. \n\n   R: knows(k)\n   T: knows(k)\n   R: fresh(r1)\nR->T: r1\nT->R: h(k XOR r1)\n   R: fresh(k1)\nR->T: k XOR k1\n   R: replace k by k1\n   T: replace k by k1\n\nProtocol satisfies recent aliveness of the tag, but not untracability.\nRecent aliveness of reader is not satisfied. \n\n*/\n\nrule Setup:\n   [ Fr( ~k1 )\n   , Fr( ~k2 )\n   , Fr( ~r )\n   , Fr( ~newKey1 )\n   , Fr( ~newKey2 )\n   ]\n --[ Setup(~k1), Setup(~k2)\n   , OnlyOnce( 'setup' ) ]-> \n   [ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ) ]\n\nrule Exchange:\n   [ Ou( ~k, ~k2, ~r, ~newKey1, ~newKey2 ), Fr(~r1) ]\n --[ Send( ~r1, \"R->T\" ) ]-> \n   [ Ou( ~k, ~k2, ~r, ~newKey1, ~newKey2 ), Rec( ~h_r1, \"T->R\" ) ]\n\nrule Response:\n   [ Ou( ~k, ~k2, ~r, ~newKey1, ~newKey2 ), Rec( ~h_r1, \"T->R\" ) ]\n --[ Rec(h(xor( ~k, ~r1 )), \"T->R\") ]-> \n   [ Ou( ~k, ~k2, ~r, ~newKey1, ~newKey2 ), Fr( ~k1 ) ]\n\n\nrule Exchange_k1:\n   [ Ou( ~k, ~k2, ~r, ~newKey1, ~newKey2 ), Fr( ~k1 ) ]\n --[ Send( xor( ~k, ~k1 ), \"R->T\" ) ]-> \n   [ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ) ]\n\n\nrule Update_k:\n\t[ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ) ]\n\t--[ Update(~k1) ]->\n\t[ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ), Upd(~k1) ]\n\t\n\nrule Update_k2:\n\t[ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ) , Upd(~k1) ]\n\t--[ Update(~k2) ]->\n\t[ Ou( ~k1, ~k2, ~r, ~newKey1, ~newKey2 ), Upd(~k1), Upd(~k2) ]\n\n\nend"]], "SPTHY-1/OTYT06_UK3.spthy": [[true, "theory OTYT06_UK3\nbegin\n\nbuiltins: xor, hashing, multiset\n\n/*\nOTYT06: Reader R, RFID tag T, shared knowledge k\n\tThis is a stateful protocol, the tag and reader's knowledge is updated\n        after a successful run. \n\n   R: knows(k)\n   T: knows(k)\n   R: fresh(r1)\nR->T: r1\nT->R: h(k XOR r1)\n   R: fresh(k1)\nR->T: k XOR k1\n   R: replace k by k1\n   T: replace k by k1\n\nProtocol satisfies recent aliveness of the tag, but not untracability.\nRecent aliveness of reader is not satisfied. \n\n*/\n\nrule Setup:\n   [ Fr( ~k ) ]\n --[ Setup(~k)\n   , OnlyOnce( 'setup' ) ]-> \n   [ Tag(~k, ~k) ] // first arg: initial key, snd arg: current key\n\nrule tag1:\n   [ In( r1 )\n   , Tag( ~k, ~k1 ) ]\n --[ Tag1( r1, ~k, ~k1 ) ]->\n   [ Tag( ~k, ~k1 )\n   , Out( h( ~k xor r1 ) ) ]\n\nrule tag2:\n   [ In( k1_xor_k )\n   , Tag( ~k, ~k1 ) ]\n --[ Tag2( k1_xor_k, ~k, ~k1 ) ]->\n   [ Tag( ~k1, ~k1 ) ]\nend"]], "SPTHY-1/Ex2_a_solution.spthy": [[true, "theory Ex2_a_solution\nbegin\n\nfunctions: h/1\nbuiltins: symmetric-encryption, asymmetric-encryption \n\n\nrule InitServerKey:\n    [ Fr(~skS) ]\n    --[ InitServerKey(~skS) ]->\n    [ !ServerKey(~skS,pk(~skS))\n    , Out(pk(~skS)) ]\n\nrule InitClientKey:\n    [ Fr(~skA) ]\n    --[ InitClientKey(~skA) ]->\n    [ !ClientKey(~skA,pk(~skA))\n    , Out(pk(~skA)) ]\n\n// Initialize Client, and send nonce1\nrule Client_M1 [color=#ffdea6]:\n    [ Fr(~nonce1), Fr(~cid)\n    , !ServerKey(~skS, pkS)\n    , !ClientKey(~skA, pk(~skA)) ]\n    -->\n    [ Client(~cid, ~skA, 'INIT', ~nonce1)\n    , Out(aenc(~nonce1, pkS)) ]\n\n// Server Receives nonce1, generates nonce2 and derive"]], "SPTHY-1/Phoolproof_EA.spthy": [[true, "/* Protocol description */\nprotocol MyProtocol:\n\t[Receive(LABEL_10,LABEL_13,x.2), \n\t\tReceive($H,$y.1,y.2), \n\t\tReceive($H,$z.1,z.2), \n\t\tReceive($H,LABEL_12,LABEL_11), !HK(POST_5,POST_4,x.2), !HK($H,PRE_4,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2),\n\t\tH($H), From($A)]->\n\t[ !HK(POST_5,POST_4,x.2), !HK($H,PRE_4,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\n\n/*  Example use of the protocol */\n// Add your example uses here if needed.  This is not strictly necessary for the completion.\n\n\n/*  Definitions of the labels (Important for analysis) */\nlabel LABEL_10:  // Define the meaning of LABEL_10.  Crucial for analysis.\n\t//Example:  label LABEL_10:  [Message_type == \"HELLO\"]\nlabel LABEL_13:  // Define the meaning of LABEL_13.\n\t//Example: label LABEL_13:  [Sequence_number == 1]\nlabel LABEL_12:  // Define the meaning of LABEL_12.\n\t//Example: label LABEL_12:  [Message_type == \"ACK\"]\nlabel LABEL_11:  // Define the meaning of LABEL_11.\n\t//Example: label LABEL_11:  [Sequence_number == 2]\n\n\n/*  Definitions of the variables */\nvariable x.2 :  // Define the type of x.2.  e.g., integer, string, etc.\n\t//Example: variable x.2 : integer\nvariable y.1 : // Define the type of y.1.\n\t//Example: variable y.1 : string\nvariable y.2 :  // Define the type of y.2.\n\t//Example: variable y.2 : integer\nvariable z.1 : // Define the type of z.1.\n\t//Example: variable z.1 : string\nvariable z.2 :  // Define the type of z.2.\n\t//Example: variable z.2 : integer\nvariable v.1 : // Define the type of v.1.\n\t//Example: variable v.1 : boolean\nvariable v.2 :  // Define the type of v.2.\n\t//Example: variable v.2 : string\n\n// Define POST_5, POST_4, PRE_4, etc. in a similar manner.\n// These are crucial for the formal analysis.\n//Example:\n//variable POST_5:  boolean\n//variable POST_4:  integer\n\n// ... add more definitions for other variables and labels as needed ...\n\n// Define the meaning of the variables and labels.  Crucial for analysis.\n// Example:\n//variable H :  integer //Or other appropriate type\n//variable A :  integer //Or other appropriate type\n//variable $H :  integer //Or other appropriate type\n//variable $A :  integer //Or other appropriate type"]], "SPTHY-1/RYY_PFS.spthy": [[true, "theory RYY\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* RYY : UM-like identity based key exchange protocol *}\n\n/*\n * Protocol:\tRYY\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr(msk) ]\n  -->\n  [ !MSK( msk ) ]\n\nrule KGC_request:\n  [ !MSK( s ) ]\n  -->\n  [ !LTK( $ID, pmult(s, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( msk ) ]\n  --[ MskRev() ]->\n  [ Out( msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( $ID, sk ) ]\n  --[ SessKeyRev($ID) ]->\n  [ Out(sk) ]\n\n\n// User\n\nrule User_request:\n  [ $ID ]\n  -->\n  [ !Req($ID) ]\n\n\nrule User_receive_ltk:\n  [ !LTK( $ID, skID ) ]\n  -->\n  [ !LTK( $ID, skID ) ]\n\n\nrule User_compute_session_key:\n  [ !LTK( $ID, skID ),  $ID,  $ID2 ]\n  -->\n  [ !Sessk( $ID,  kdf( skID ) ) ]\n\n\nrule User_send_message:\n  [ !Sessk( $ID, sk ) ]\n  -->\n  [ Out(sk) ]\n\nend"]], "SPTHY-1/Scott_EphkRev.spthy": [[true, "theory Scott\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* Scott: MTI-C0 like identity based key exchange protocol *}\n\n/*\n * Protocol:\tScott\n * Modeler: \tBenedikt Schmidt\n * Date: \tMay 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr( ~msk ) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk ) ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult( ~msk, hp($ID) ) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\n// User\n\nrule User_Setup:\n  [ !LTK( $ID, skID ) ]\n  --[ UserSetup($ID) ]->\n  [ $ID, skID ]\n\n\nrule User_Request:\n  [ $ID, skID ]\n  --[ UserRequest($ID, pkID) ]->\n  [ $ID, skID, pkID ]\n\nrule Compute_shared_key:\n  [ $ID, skID, pkID ]\n  --[ ComputeSharedKey() ]->\n  [ $ID, skID, pkID, sharedKey ]\n\n// Shared key computation\nrule Compute_shared_key:\n  [ $ID, skID, pkID ]\n  --[ ComputeSharedKey() ]->\n  [ $ID, skID, pkID, sharedKey ]\n\n\n// Shared key computation rule (using pairing)\nrule Compute_shared_key:\n  [ $ID, skID, pkID ]\n  --[ ComputeSharedKey() ]->\n    [ $ID, skID, pkID, sharedKey ]\nwhere\n  sharedKey = pairing(skID, pkID)\n\n\n// Example of a rule to compute the shared key (using kdf)\nrule Compute_shared_key:\n  [ $ID, skID, pkID ]\n  --[ ComputeSharedKey() ]->\n    [ $ID, skID, pkID, sharedKey ]\nwhere\n  sharedKey = kdf( pairing(skID, pkID) )\n\n\nend"]], "SPTHY-1/secondAttestation.spthy": [[true, "theory SecondEATImplementation\nbegin\nbuiltins: asymmetric-encryption, revealing-signing\n\n// This version of the protocol has problems to weak agreement and non-injection, in that the attester doesn't verify the nonce. And there isn't a one to one relation\n\nrule create_identities:\n    [Fr(~ltk)] //generate new fresh private key\n    -->\n    [!Identity($A, ~ltk, pk(~ltk)), Out(pk(~ltk))] //Generate a fact where the agent:A is assosiated with the priv/pub-key and output the public-key to the web\n\n\nrule Verifier_sends_Nonce_to_Attester: \n    let \n        signed_nonce = revealSign(~n, ~Vltk)\n    in\n    [!Identity($Attester, ~Vltk, pk(~Altk)), Fr(~n), !Id($A, ~ltk, pk(~ltk)), Out(signed_nonce)]\n\n\nrule Attester_sends_Signature_to_Verifier:\n\tlet\n\t\tsigned_challenge = revealSign(~c, ~Altk)\n\tin\n\t[!Identity($A, ~ltk, pk(~ltk)), !Identity($Attester, ~Vltk, pk(~Altk)), In(signed_nonce), Fr(~c), Out(signed_challenge)]\n\nrule Verifier_verifies_Signature:\n\tlet\n\t\tsigned_nonce = In(signed_nonce),\n\t\tsigned_challenge = In(signed_challenge),\n        vk(~Vltk) = pk(~Vltk),\n        vk(~Altk) = pk(~Altk)\n\tin\n\t[verify(signed_nonce, vk(~Vltk)), verify(signed_challenge, vk(~Altk)), !Id($A, ~ltk, pk(~ltk)), !Id($Attester, ~Vltk, pk(~Altk))]\n\t-->\n\t[!Id($A, ~ltk, pk(~ltk)), !Id($Attester, ~Vltk, pk(~Altk))]\n\n// Add rules for other possible interactions (e.g., rejection)\n// ...\n\n//  Add rules to handle the creation of identities\n\n// ...\n\n\nend"]], "SPTHY-1/sigfox-R.spthy": [[true, "theory sigfox_PKC begin\n/*\n * Protocol:  sigfox implementation\n * Modeler:   Jun Young Kim \n * Described in: \n * Date:    \n *\n * Status:    Working\n */\n\nbuiltins: asymmetric-encryption,signing \n\n//1. A -> B: {B,na}sk(A)\n\n// Public key infrastructure \nrule Register_pk: \n    [ Fr(~ltkA) ]\n  --> \n    [ !Ltk($A, ltkA)\n    , !Pk($A, pk(ltkA))\n    , Out(pk(~ltkA)) ]\n\n// Compromising an agent's long-term key \nrule Reveal_ltk: \n    [ !Ltk(A, ltkA) ]\n  --[ Reveal(A) ]->\n    [ Out(ltkA) ]\n\n\n// Role A sends first message \nrule Send_key: \n    let \n      msg = aenc(<A, ~na>, pkB)\n      sig = sign(msg,ltkA) \n    in\n    [ Fr(A)\n    , !Ltk(A, ltkA)\n    , !Pk(B, pkB)\n    , In(pkB)\n    ]\n  -->\n    [ Out(msg || sig) ]\nend"]], "SPTHY-1/STS_MAC.spthy": [[false, "```houzhui\ntheory STS_MAC\nbegin\n\nbuiltins: diffie-hellman, hashing, signing\n\nfunctions: mac/2\nfunctions: KDF/1\n\nsection{* The Station-To-Station Protocol (MAC version) *}\n\n/*\n * Protocol:\tStation-To-Station, MAC variant\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\"\n *\t\tBlake-Wilson, Simon and Menezes, Alfred\n * \t\tPKC '99, Springer, 1999\n *\n * Status: \tworking\n */\n\n// Public key infrastructure\n/**\n * The !Pk facts can be regarded as certificates\n *\n * Here we model that the adversary might (and in fact always does)\n * re-registers the public keys as his own, i.e., he claims a copy of\n * th\n */\nfacts:\n    !Pk(A, PkA)\n    !Pk(B, PkB)\n\n// The protocol messages\nmessages:\n    Msg1(A, B, Na)\n    Msg2(B, A, Nb, mac(KDF(diffie-hellman(Na, PkB)), Nb))\n    Msg3(A, B, mac(KDF(diffie-hellman(Nb, PkA)), Na))\n\n// The protocol execution\n// Define the messages that the adversary can generate\nadversary_messages:\n    Msg1(A, B, Na)\n    Msg2(B, A, Nb, mac(KDF(diffie-hellman(Na, PkB)), Nb))\n    Msg3(A, B, mac(KDF(diffie-hellman(Nb, PkA)), Na))\n    Msg1(A, B, Na')\n    Msg2(B, A, Nb', mac(KDF(diffie-hellman(Na', PkB)), Nb'))\n    Msg3(A, B, mac(KDF(diffie-hellman(Nb', PkA)), Na'))\n\n\n// The session key is computed as follows\n// (We assume that the session key is computed correctly)\n// This is the key part:\n// The adversary can create the session key\n// by having received the messages, and compute these\n// messages (without knowing the secret keys)\n\n// Define the adversary's knowledge\nknowledge:\n    !knows(A, KDF(diffie-hellman(Na, PkB)))\n    !knows(B, KDF(diffie-hellman(Nb, PkA)))\n    !knows(A, KDF(diffie-hellman(Na', PkB)))\n    !knows(B, KDF(diffie-hellman(Nb', PkA)))\n\n// The adversary can forge a message\n// (This is the attack)\n// The adversary can create a fake message\n// that satisfies the protocol\n// This is the key part\n// The adversary can create the session key\n// by having received the messages, and compute these\n// messages (without knowing the secret keys)\n// The adversary can use the same session key to forge\n// a new message.\n\n// This is the attack\n// The adversary can forge a message\n// that satisfies the protocol\n// This is the key part\n// The adversary can create the session key\n// by having received the messages, and compute these\n// messages (without knowing the secret keys)\n\n\n// The adversary can use the same session key to forge\n// a new message.\n// This is the attack\n// The adversary can forge a message\n// that satisfies the protocol\n\n\n\n// This is the attack\n\n\n// This is the attack\n// The adversary can forge a message\n// that satisfies the protocol\n\n// No further analysis needed\n\n\nend\n```"]], "SPTHY-1/TCP.spthy": [[false, "```houzhui\ntheory TCPHandShake\nbegin\n\nrule SYN:\n  []\n  --[ Begin() ]->\n  [ St_AliceWait(), Out('SYN') ]\n\nrule SYNACK:\n  [ In('SYN') ]\n  -->\n  [ St_BobWait(), Out('SYNACK') ]\n\nrule ACK:\n  [ St_AliceWait(), In('SYNACK') ]\n  -->\n  [ Out('ACK') ]\n\nrule FIN:\n  [ St_BobWait(), In('ACK') ]\n  --[ End() ]->\n  []\n\nlemma Works:\n  exists-trace\n  \"Ex #t1. Begin() @ #t1 & Ex #t2. End() @ #t2\"\n\nlemma BulletProof:\n  all-traces\n  \"All #t1. Begin() @ #t1 ==> Ex #t2. End() @ #t2 & #t1 < #t2\"\n\nend\n```"]], "SPTHY-1/testConstructor.spthy": [[true, "theory testConstructor\nbegin\n\nbuiltins: xor\n\nrule Test1:\n  [ Fr(~k1), Fr(~k2), Fr(~k3), Fr(~k4) ]\n--[ Challenge1(~k1 XOR ~k2 XOR ~k3 XOR ~k4) ]->\n  [ Out(~k1 XOR ~k2), Out(~k3), Out(~k4) ]\n\nrule Test2:\n  [ Fr(~k1), Fr(~k2), Fr(~k3), Fr(~k4) ]\n--[ Challenge2(~k1 XOR ~k2 XOR ~k3 XOR ~k4) ]->\n  [ Out(~k1), Out(~k2), Out(~k3), Out(~k4) ]\n\nrule Test3:\n  [ Fr(~k1), Fr(~k2), Fr(~k3), Fr(~k4) ]\n--[ Challenge3(~k1 XOR ~k2 XOR ~k4) ]->\n  [ Out(~k1), Out(~k3), Out(~k2 XOR ~k3 XOR ~k4) ]\n\nrule Test4:\n  [ Fr(~k1), Fr(~k2), Fr(~k3), Fr(~k4), Fr(~k5), Fr(~k6) ]\n--[ Challenge(~k1 XOR ~k2 XOR ~k3 XOR ~k4 XOR ~k5 XOR ~k6) ]->\n  [ Out(~k1 XOR ~k2), Out(~k3 XOR ~k4), Out(~k5), Out(~k6) ]\n\n\n/*\nThis theory defines a set of rules for a hypothetical protocol.\nThe rules involve cryptographic operations (XOR) and data transformations.\nThe input data is assumed to be received via the Fr() function,\nand the output data is sent via the Out() function.\nThe Challenge functions are assumed to generate challenge values based on the input data.\n\nThe rules Test1, Test2, Test3, and Test4 demonstrate different ways of processing input data and generating outputs.\n*/\n\nend"]], "SPTHY-1/traceable.spthy": [[true, "theory traceable\nbegin\n\n/*\n * Protocol:\t Toy example of RFID unlinkability\n * Modeler: \t Sasa Radomirovic, Ralf Sasse, Jannik Dreier\n * Described in: -\n * Date: \t Mai 2016\n *\n * Status: \t working (expected to return an attack)\n */\n\n\nbuiltins: hashing, multiset\n\n// We want to show equivalence between an instance where the reader communicates \n// with two diferrent tags and an instance where he communicates twice with the \n// same tag:\nrule setup:\n  [ Fr(key1), Fr(key2) ]\n  --[ Setup() ]->\n  [ Reader('1'+diff(key1+key2,key1+key1)), Tag('1'+diff(key1+key2,key1+key1)) ]\n\nrule select_tag:\n  [ Tag(~k+z) ]\n  -->\n  [ TagRun(~k), Tag(z) ]\n\nrule select_reader:\n  [ Reader(~k+z) ]\n  -->\n  [ ReaderRun(~k), Reader(z) ]\n\nrule read_tag:\n  [ Reader(z), Tag(z) ]\n  --[ Read() ]->\n  [ Reader(z), Tag(z), Fr(k) ]\n\nrule read_tag_fail:\n  [ Reader(z), Tag(z') ]\n  --[ Read() ]->\n  [ Reader(z), Tag(z') ]\n\nrule read_tag_2:\n  [ Reader(z), Tag(z) ]\n  --[ Read() ]->\n  [ Reader(z), Tag(z), Fr(key1) ]\n\n\n\nrule send_key:\n  [ Reader(z), Tag(z), Fr(key1) ]\n  --[ SendKey(key1) ]->\n  [ Reader(z), Tag(z) ]\n\nrule send_key_2:\n  [ Reader(z), Tag(z), Fr(key2) ]\n  --[ SendKey(key2) ]->\n  [ Reader(z), Tag(z) ]\n\n\n\nrule end:\n  [ ]\n  --[ End() ]->\n  [ ]\n\n\n\n// auxiliary function, calculates the difference between two sets.\ndiff(x,y) = {z | z \u2208 x, z \u2209 y }\n\n// auxiliary function, concatenates two sets.\n+ (x,y) = x\u222ay\n\n// auxiliary function, calculates the length of a set.\nlen(x) = |x|\n\n\n// auxiliary function, checks if a set is empty.\nempty(x) = (|x| == 0)\n\n\n// auxiliary function, checks if a set contains a given element.\ncontains(x,y) = (y \u2208 x)\n\n// auxiliary function, returns a set containing only the given element.\nsingleton(x) = {x}\n\n// auxiliary function, returns the set difference between two sets.\nminus(x,y) = x \\ y\n\n\n// type declarations\ntype key = string\ntype tag = string\ntype reader = string\ntype fr = string\n\n\n// initial state\ninit = [ Fr(key1), Fr(key2) ]\n\n\n// goal\ngoal = [ ]\n\nend"]], "SPTHY-1/UM_one_pass_attack.spthy": [[true, "module ExampleProtocol\n\nimports\n  Standard\n\ntypes\n  Sid\n  PubKey\n  SessionKey\n  Actor\n  Message\n\n// Define the preconditions for the I_Act rule\npred PRE_2(sid: Sid, ex: Actor, b: PubKey) =\n  // Add your precondition logic here\n  true // Example:  ex != b\n\n// Define the message to be sent in the I_Comp rule\npred PRE_3(sid: Sid, a: Actor, x: Message) =\n  // Add your precondition logic here\n  true // Example: a != x\n\n// Define the types for the actors\ntype Actor = string\ntype PubKey = string\ntype SessionKey = string\ntype Message = string\n\n\n// Define the states\nstate I_Act(ex: Actor, sid: Sid, b: PubKey)\nstate I_Comp(sid: Sid)\nstate Ltk(a: Actor, ea: PubKey)\nstate Pk(b: PubKey, pb: PubKey)\nstate SessionKey(sid: Sid, a: Actor, k: SessionKey)\nstate Out(msg: Message, a: Actor, x: Message)\n// Define the actions\naction I_Act(ex: Actor, sid: Sid, b: PubKey)\naction I_Comp(sid: Sid)\naction Ltk(a: Actor, ea: PubKey)\naction Pk(b: PubKey, pb: PubKey)\naction Out(msg: Message, a: Actor, x: Message)\naction SessionKey(sid: Sid, a: Actor, k: SessionKey)\n\n// Define the rules\nrule I_Act( ~ex, ____(PRE_2)____, $B )                   // this session was activated\n  , !Ltk( $A, ~ea )                        // lookup own longterm private key\n  , !Pk( $B, pB ) ]                        // lookup peer's public key\n--[ Complete( sid, 'I', k ) ]->          // sid is 'Complete'd after this step\n[ I_Comp( sid )                          // state of this session\n  , Out( <____(PRE_3)____, $A, X> )                     // send message\n  , !SessionKey( sid, $A, k ) ]            // the session key of sid with actor $A, available\n                                           // for reveals\n\n// Expire the session\nrule I_Expire:\n  [ I_Comp( sid ) ]"]]}