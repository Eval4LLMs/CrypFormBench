{"EC-1/AAPI.ec": [[true, "(** An API call *)\ntype call.\n(** An API response *)\ntype response.\n\n(** An interaction buffer *)\ntype buffer.\n\n(** An API *)\nclass api.\n  var mem : buffer.\n  var pub : int.\n  var sec : int.\n\n  method call (c : call) : response.\n\n  method response (r : response) : unit.\nend.\n\n(**\n  An API call consists of an operation and some parameters.\n  The operation defines the computation to be performed by the API.\n  The parameters are the inputs to the computation.\n*)\ntype op =\n  | Add of int * int\n  | Sub of int * int\n  | Mult of int * int\n  | Div of int * int.\n\ntype call = { op : op; params : int list }.\n\n\n(**\n  An API response is a tuple containing the result of the computation\n  and the updated internal memory.\n*)\n\ntype response = { res : int; new_mem : buffer }.\n\n(** Example API implementation *)\nmodule ApiImpl : api.\n  var mem : buffer.\n  var pub : int.\n  var sec : int.\n\n  method call (c : call) : response =\n    match c.op with\n    | Add (x, y) => { res = x + y; new_mem = mem }\n    | Sub (x, y) => { res = x - y; new_mem = mem }\n    | Mult (x, y) => { res = x * y; new_mem = mem }\n    | Div (x, y) => {\n      if y = 0 then { res = 0; new_mem = mem } else { res = x / y; new_mem = mem }\n    }\n  end.\n\n  method response (r : response) : unit =\n   mem <- r.new_mem.\nend.\n\n(** Example usage *)\nmodule Main.\n\n  let api : api = new ApiImpl.\n\n  let call1 : call = { op = Add (5, 3); params = [] }.\n  let res1 : response = api#call call1.\n\n  let call2 : call = { op = Sub (10, 2); params = [] }.\n  let res2 : response = api#call call2.\n\n  let call3 : call = { op = Mult (4, 7); params = [] }.\n  let res3 : response = api#call call3.\n\n  let call4 : call = { op = Div (12, 2); params = [] }.\n  let res4 : response = api#call call4.\n\n\n  let call5 : call = { op = Div (12, 0); params = [] }.\n  let res5 : response = api#call call5.\n\n\nend."]], "EC-1/abstract-ind-ror.ec": [[false, "```\n(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting \n\n*)\n\n(* Example of IND-RoR game *)\n\n(* Define the type of messages *)\ntype message = int;\n\n(* Define the type of the secret key *)\ntype secret_key = int;\n\n(* Define the type of the public key *)\ntype public_key = int;\n\n(* Define the encryption function *)\nlet encrypt (pk: public_key) (m: message) : message =\n  pk * m;\n\n(* Define the decryption function *)\nlet decrypt (sk: secret_key) (c: message) : message =\n  c / sk;\n\n(* Define the key generation function *)\nlet gen_key () : (public_key * secret_key) =\n  let sk = 7 in\n  let pk = sk * 2 in\n  (pk, sk);\n\n(* Define the protocol *)\nlet protocol (m:message) : message =\n  let (pk, sk) = gen_key() in\n  let c = encrypt pk m in\n  c;\n\n\n(* Define the adversary's view *)\nlet adversary_view (m:message) : message =\n  let c = protocol m in\n  c;\n\n\n(* Theorem stating the indistinguishability *)\nlet theorem () : unit =\n  let m0 = 1 in\n  let m1 = 2 in\n  let c0 = adversary_view m0 in\n  let c1 = adversary_view m1 in\n  let indistinguishable =\n    forall (m0:message) (m1:message) .\n    eq_dist (adversary_view m0) (adversary_view m1)\n  in\n  assert indistinguishable;\n  ();\n```"]], "EC-1/basic-hash-single-tag.ec": [[true, "(* EasyCrypt file: protocol.ec *)\n\n(*-----------------------------------------------------------------------*)\n(* Imports *)\n\ninclude \"easycrypt.ec\".\n\n(*-----------------------------------------------------------------------*)\n(* Types *)\n\ntype key = int.\ntype ptxt = int.\ntype dnonce = int.\ntype dkey = int.\n\n(*-----------------------------------------------------------------------*)\n(* Parameters *)\n\n(* Parameters for the protocol *)\nconst n : int.\nconst m : int.\nconst dnonce_len : int.\nconst dkey_len : int.\n\n(*-----------------------------------------------------------------------*)\n(* Randomness assumptions *)\n\n(* Assumption: dnonce is a uniformly random variable *)\nlemma dnonce_uni (LEMMA_0: int) : is_uniform dnonce dnonce_len by smt (dnonce_lluni).\n\nhint exact random : dnonce.\n\n(* Assumption: dkey is a uniformly random variable *)\nlemma dkey_uni (LEMMA_1: int) : is_uniform dkey dkey_len by smt (dkey_lluni).\n\nhint exact random : dkey.\n\n(*-----------------------------------------------------------------------*)\n(* PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRF = {\n  proc init () : unit\n  proc f(x : ptxt) : ptxt\n  proc check(x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRF_Oracles = {\n  include PRF[-init]\n}.\n\nmodule PRF = {\n  var k : key\n  \n  proc init() : unit = {\n    PRF.k <$ dkey;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    return F k x;\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable encryption *)\n(* ... (rest of the protocol) ... *)"]], "EC-1/br93.ec": [[false, "```\n(* EasyCrypt code for a simplified BR93 protocol *)\n\n(* This code is a simplified version of the BR93 protocol for demonstration purposes.\n   A complete and robust analysis would require a more detailed model. *)\n\nmodule BR93.\n\n(* Protocol description *)\n(* ... *)\n\n(* Game definitions *)\n(* ... *)\n\n(* Security definition *)\n(* ... *)\n\nsection BR93_CPA.\n\n(* Definition of the BR93 CPA game. *)\n(* ... *)\n\n(* Games for the proof *)\n(* ... *)\n\n(* Lemma stating that the probability of success in the BR93 CPA game *)\n(* is at most half of the probability of success in the OW game. *)\n\nlemma Pr_BR93_CPA_le_Pr_OW:\n  forall (A: {proc}).\n  Pr[BR93_CPA(A).main() : res] <= 1%r/2%r + Pr[OW(I(A)).main() : res].\nproof.\n(* Proof outline: *)\n(* 1. Define intermediate games *)\n(* 2. Establish inequalities between probabilities of consecutive games. *)\n(* 3. Use the triangle inequality to bound the probability of success in the final game. *)\n(* 4. Simplify using properties of the games. *)\n\n(* Game 0: The original BR93_CPA game *)\n(* Game 1: ... *)\n(* Game 2: ... *)\n(* Game 3: ... *)\n\n(* Intermediate lemmas *)\n(* ... *)\n\n(* Proof steps *)\n(* 1. Define intermediate games *)\n(* ... *)\n(* 2. Establish inequalities between probabilities of consecutive games. *)\n(* ... *)\n(* 3. Use the triangle inequality to bound the probability of success in the final game. *)\n(* ... *)\n(* 4. Simplify using properties of the games. *)\n(* ... *)\n(* 5. Apply the lemma about the probability of success in the OW game. *)\n(* ... *)\n\n(* Use the fact that Pr[OW(I(A)).main() : res] <= 1%r/2%r. *)\n(* ... *)\n\n(* Example using a simple (and incorrect) proof step *)\n(*  by rewrite h. *)\n\n(* Correct proof steps (replace with actual lemmas/rewrites) *)\n(* ... *)\n(* Example: *)\n(* by auto. *)\n\n\n(* Note: This is a placeholder.  The actual proof would require *)\n(* detailed definitions of the games, intermediate lemmas, and *)\n(* applications of EasyCrypt's proof tools (e.g., sim, rewrite, auto). *)\n(* ... *)\n\n(* The following is a placeholder for a more complete proof. *)\n(*  by auto=> /> [pk sk] ->. *)\n(*  This should be replaced with actual EasyCrypt proof steps. *)\n(*  The following steps are examples and should be replaced with the *)\n(*  correct proof obligations. *)\n(*  by auto=> /> [pk sk] ->. *)\n(*  by auto; call (: ={glob Log, glob LRO}); 1: by sim. *)\n(*  swap{1} 6 -2. *)\n(*  by auto; call (: ={glob Log, glob LRO}); 1: by sim. *)\n\n(*  by auto; call (: ={glob Log, glob LRO}); 1: by sim. *)\n(*  by auto=> /> [pk sk] ->. *)\n\n(*  by auto=> /> [pk sk] ->. *)\n\n(*  by auto. *)\n\n(* This is a placeholder, replace with actual proof steps. *)\n(* ... *)\nqed.\n\nend section.\n\nend BR93.\n```"]], "EC-1/cfold.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore Distr.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldStopIf.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      var d : int;\n      \n      c <- 0;\n      d <- c + 1;\n      c <- b + a;\n      \n      if (a + b = c) {\n        c <- 0;\n        a <- c;\n      } else {\n        c <- 1;\n        b <- c;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : forall a b:int.\n    M.f(a,b) = 0  \\/  M.f(a,b) = 1.\n  proof.\n  proc.\n  cfold 1.\n  case (a + b = c).\n  (* Case 1: a + b = c *)\n  by auto => /> ?; apply addzC.\n  (* Case 2: a + b <> c *)\n  by auto => /> ?; apply addzC.\n  qed.\n  \n  lemma L1 : forall a b:int.\n    M.f(a,b) = 0  \\/  M.f(a,b) = 1.\n  proof.\n  proc.\n  cfold 1.\n  case (a + b = c).\n  (* Case 1: a + b = c *)\n  by auto => /> ?; apply addzC.\n  (* Case 2: a + b <> c *)\n  by auto => /> ?; apply addzC.\n  qed.\n\n\n  lemma L2 : forall a b:int.\n      M.f(a, b) = 0  ->  a + b = 0.\n  proof.\n    proc.\n    cfold 1.\n    case (a + b = c).\n    (* Case 1: a + b = c *)\n    by auto => /> ?; apply addzC.\n    (* Case 2: a + b <> c *)\n    by auto => /> ?; apply addzC.\n  (*  by auto; apply addzC;  *)\n  qed.\n\n\n  lemma L3 : forall a b:int.\n      M.f(a,b) = 1 -> a+b <> 0.\n  proof.\n    proc.\n    cfold 1.\n    case (a + b = c).\n    (* Case 1: a + b = c *)\n    by auto => /> ?; apply addzC.\n    (* Case 2: a + b <> c *)\n    by auto => /> ?; apply addzC.\n  (*  by auto; apply addzC;  *)\n  qed.\n\nend CfoldStopIf.\n\n(* --------------------------"]], "EC-1/CommitmentSpecial.ec": [[true, "require import AllCore Distr List DBool.\n\n\ntype commitment, opening, message.\n\nop Com  : message -> (commitment * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() {\n        var c1, m1, o1, c2, m2, o2 : message;\n        var commit1, commit2 : commitment;\n        var open1, open2 : opening;\n        var b : bool;\n        \n        (commit1, open1)  <- Com m1;\n        (commit2, open2)  <- Com m2;\n\n        (c1, m1, o1, c2, m2, o2)  <- B.bind();\n\n        b  <- (Ver (m1, (commit1, open1))) && (Ver (m2, (commit2, open2)));\n        assert b;\n    }\n}"]], "EC-1/ddh-1.ec": [[true, "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* identity *)\n\nop (++) : exp -> exp -> exp. (* binary operation *)\n\naxiom e_l (x : exp) : e ++ x = x.\n\naxiom e_r (x : exp) : x ++ e = x.\n\naxiom plus_comm (x y : exp) : x ++ y = y ++ x.\n\naxiom plus_assoc (x y z : exp) : x ++ (y ++ z) = (x ++ y) ++ z.\n\n\n(* **************************** DDH ***************************** *)\n\n(* DDH assumption *)\n\n(* The parameters are hardcoded to make the proof easier *)\nop g : key.\nop p : key.\n\n(* random key generation *)\nop rand_exp : unit -> exp.\n\n(* for simplicity, we assume that rand_exp returns a value between 0 and 10 *)\naxiom rand_exp_spec (x : unit) : 0 <= exp_val (rand_exp x) <= 10.\n\n\n(* Function to compute the result of the protocol *)\nop ddh_result (a b c : key) : bool.\n\n(* Assumption: if a, b, c are generated randomly, then the result is random *)\naxiom ddh_random_result (a b c : key) :\n  forall x : bool,\n    Pr[ddh_result a b c = x | a <- rand_key; b <- rand_key; c <- rand_key] = 1/2.\n\n(* Function to generate random key *)\nop rand_key : unit -> key.\n\n(* Assumption: rand_key returns a random key *)\naxiom rand_key_spec (x : unit) :\n  forall k : key,\n    Pr[rand_key x = k | a <- rand_key; b <- rand_key; c <- rand_key] = 1/size_key.\n\n\n(* size of the key space *)\nop size_key : nat."]], "EC-1/elgamal.ec": [[true, "pe ptxt <- ptxt,\n  type ctxt <- ctxt,\n  module PKE.enc = PKE.enc,\n  module PKE.dec = PKE.dec.\n\n(* ------------------ Our Protocol ----------------------------------- *)\n\n(* Our Key Exchange Protocol *)\n\n(* Key Generation *)\nmodule KeyGen = {\n  proc keygen() : (pkey, skey) = {\n    var g, h : group.\n    g <- group.random();\n    h <- group.random();\n    return (g, h);\n  }\n}.\n\n(* Encryption *)\nmodule Enc = {\n  proc encrypt(pk : pkey, m : ptxt) : ctxt = {\n    var k : group.\n    k <- pk;\n    var c1 : group.\n    c1 <- group.exp(k, ____(EXP_0)____);\n    var c2 : group.\n    c2 <- group.mult(m, group.exp(k, ____(EXP_1)____));\n    return (c1, c2);\n  }\n}.\n\n(* Decryption *)\nmodule Dec = {\n  proc decrypt(sk : skey, ct : ctxt) : ptxt = {\n    var (c1, c2) : ctxt.\n    (c1, c2) <- ct;\n    var m : ptxt.\n    m <- group.mult(c2, group.exp(____(EXP_2)____, group.neg(sk)));\n    return m;\n  }\n}.\n\n\n(* ------------------ Verification -------------------------------- *)\n(* We want to prove that decryption does what it should. *)\nmodule Correctness = {\n  proc verify(pk : pkey, sk : skey, m : ptxt) : (ctxt) = {\n    var ct : ctxt.\n    ct <- Enc.encrypt(pk, m);\n    return ct;\n  }\n\n  lemma decrypt_correct(pk : pkey, sk : skey, m : ptxt) :\n    let ct <- Enc.encrypt(pk, m) in\n    Dec.decrypt(sk, ct) = m.\n  {\n    (* Proof obligation:  Show that decryption with the correct secret key returns the original message. *)\n    let (c1, c2) = Enc.encrypt(pk, m) in\n     let m' = Dec.decrypt(sk, (c1, c2)) in\n     assert (m' = m);\n  }\n}.\n\n\n\n(* ------------------ Assumptions --------------------------------- *)\n(* We assume the underlying group operations are well-behaved. *)"]], "EC-1/EventPartitioning.ec": [[true, "module ListPartitioning.\n  abstract theory FSetPartitioning.\n  require import FSet.\n\n  type partition.\n\n  section.\n  declare module ListPartitioning : T.\n\n  local clone import ListPartitioning with\n    type partition <- partition.\n\n  lemma fset_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition fset) &m:\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) (elems P)\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem P (phi i (glob M) res)].\n  proof.\n  by rewrite memE; exact/(@list_partition_lemma i E phi P).\n  end.\nend."]], "EC-1/FMapAux.ec": [[true, "(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed."]], "EC-1/FundamentalLemma.ec": [[true, "require import Distr Real StdOrder.\n(*---*) import RealOrder.\n\nop max (x y : real) = if x <= y then y else x.\n\ntype state.\n\n(* We want the bad event to be defined on both sides, *\n * so we assume that all the variables that are used  *\n * to define victory conditions and bad events are    *\n * stored in a separate module. (Note: the empty      *\n * signature could be instantiated with anything,     *\n * including the concrete experiment themselves       *\n * if their glob types match.)                        *)\nmodule type Mem = { }.\n\nmodule type Exp = {\n  proc main(): state\n}.\n\nlemma Pr_split (G <: Exp) (Mem <: Mem) (\n  bad_event: state -> bool\n) :\n  Pr (fun s:state => bad_event s) (G.main()) <=\n  Pr (fun s:state => bad_event s) (G.main()) /\\\n  Pr (fun s:state => bad_event s) (G.main()) <=\n  Pr (fun s:state => bad_event s) (G.main())."]], "EC-1/generalize-module-aliases.ec": [[true, "module type T = {\n  proc f(): bool\n}.\n\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare (M_T1 : T).\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule A2 = F(M_T1).M.\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof.\n  wp A1.N.g;\n  trivial.\nqed.\n\nhoare L2: A2.N.g: true ==> true.\nproof.\n  wp A2.N.g;\n  trivial.\nqed.\n\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed."]], "EC-1/AES.ec": [[true, "(* --------------------------------------------------------------- *)\n(* Operations on state                      *)\ntype state = W128.t.\n\nop AddRoundKey (state : state) (key : W128.t) = \n  state ^ key.\n\nop SubBytes (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 (map Sbox w).\n\nop InvSubBytes (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 (map InvSbox w).\n\nop ShiftRows (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 [w 0; w 1; w 2; w 3]. (* Dummy, needs to be corrected *)\n\nop InvShiftRows (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 [w 0; w 1; w 2; w 3]. (* Dummy, needs to be corrected *)\n\nop MixColumns (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 [w 0; w 1; w 2; w 3]. (* Dummy, needs to be corrected *)\n\nop InvMixColumns (state : state) = \n  let w = W128.unpack4 state in\n  W128.pack4 [w 0; w 1; w 2; w 3]. (* Dummy, needs to be corrected *)\n\n\n(* --------------------------------------------------------------- *)\n(*  AES encryption                                              *)\n\nop AESEnc (state : state) (key : state) : state = \n  let rec loop (state : state) =\n  if false then state else\n   loop (AddRoundKey state key).\n\nlemma AESEncK state key : AESEnc state key = state.\n\n(* --------------------------------------------------------------- *)\n(*  AES decryption                                              *)\n\nop AESDec (state : state) (key : state) : state = \n  let rec loop (state : state) =\n  if false then state else\n   loop (AddRoundKey state key).\n\nlemma AESDecK state key : AESDec state key = state.\n\n\n(* --------------------------------------------------------------- *)\n(* Example usage                                                 *)\n(* --------------------------------------------------------------- *)\n\nexample AESEncExample (state : state) (key : state) :\n  AESEnc state key = state.\n\nexample AESDecExample (state : state) (key : state) :\n  AESDec state key = state."]], "EC-1/hashed_elgamal_generic.ec": [[true, "(* EasyCrypt code for a simplified Hashed ElGamal encryption scheme *)\n\n(* Define the cryptographic primitives (replace with your actual implementations) *)\nmodule BA = {\n  function choose(x: {0, 1}) : ({0, 1}, {0, 1}) = (0, 1);\n  function guess((x, y): ({0, 1}, {0, 1}) * {0, 1}) : bool = true;\n};\n\n\nmodule H = {\n  function init() : unit = ();\n  function hash(x: {0, 1} * {0, 1}) : {0, 1} * {0, 1} = (0, 1);\n};\n\n\n(* ElGamal encryption scheme *)\nmodule S = {\n  function enc(x: {0, 1} * {0, 1}, y: {0, 1} * {0, 1}, b: {0, 1}) : ({0, 1} * {0, 1}, {0, 1} * {0, 1}) =\n    (x, y);\n};\n\n(* Protocol definition *)\nmodule G0 = {\n  function main() : bool = {\n      (* Key generation (replace with your key generation logic) *)\n      var dt;\n\n      (* Encryption *)\n      var g, x, y, m0, m1, b, h, c, b';\n\n      (* Initialize the hash function *)\n      H.init();\n      \n      (* Random inputs *)\n      x       <$ dt;\n      y       <$ dt;\n      \n      (* ElGamal-like encryption *)\n      g       <$ {0, 1};  (* Example:  g is a generator *)\n      var gx;\n      gx      <- g ^ x;  (*  g^x, where ^ denotes exponentiation modulo a prime.  *)\n      var gxy;\n      gxy     <- gx ^ y; (* gx^y *)\n      (m0,m1) <@ BA.choose(gx); (* Example: choosing two random messages *)\n      b       <$ {0, 1}; (* Random bit *)\n      h       <@ H.hash(gxy); (* Hash of gxy *)\n      c       <- (g ^ y, h +^ (b ? m1 : m0)); (* ElGamal-like ciphertext *)\n      b'      <@ BA.guess(c); (* Guess the bit b' *)\n      return (b' = b);\n    }\n  }.\n\n(* CPA security property *)\nmodule CPA = {\n  function main(S, BA) : bool = {\n    var x, y, b, c;\n    x <$ {0,1};\n    y <$ {0,1};\n    b <$ {0,1};\n    c <@ S.enc(x, y, b);\n    return BA.guess(c);\n  }\n};\n\n(* CPA security proof *)\nlocal equiv CPA_G0: CPA(S,BA).main ~ G0.main: ={glob A} ==> ={res}.\nproof.\n  proc.\n  inline Hashed_ElGamal(H).kg Hashed_ElGamal(H).enc.\n  swap{1} 8 -5.\n  call (_: ={glob H, Log.qs}); first by sim.\n  wp; call (_: ={glob H}); first by sim.\n  wp; rnd.\n  call (_: ={glob H, Log.qs}); first by sim.\n  wp; do !rnd.\n  by call (_: true ==> ={glob H}); first by sim.\n  wp; rnd.\n  (* Add more proof steps as needed, e.g., using the properties of BA and H *)\n  (* Example: use sim to prove the equivalency, with appropriate assumptions *)\n  (* ... *)\n  (* This proof needs to be completed with appropriate EasyCrypt proof steps *)\n  (* The specific proof steps will depend on the properties of the primitives *)\n  (* and the structure of the protocol. *)\n  (* ... *)\n  (* Use the properties of the hash function, randomness, and the guessing game. *)\n  (* ... *)\n  (* Example proof step: *)\n  (* by rnd. *)\n  (* by sim. *)\n  (* ... *)\n  (* Finally, conclude the proof. *)\n  qed."]], "EC-1/hashed_elgamal_std.ec": [[false, "```\n(* Description:\n   A simple Diffie-Hellman key exchange protocol.\n   This example demonstrates a basic Diffie-Hellman key exchange\n   with a fixed group size.\n\n   The protocol is vulnerable to man-in-the-middle attacks if\n   not implemented correctly.\n*)\n\n(* Alice's strategy *)\nmodule Alice = {\n  proc run(g : bits, p : bits) : bits {\n    (* Generate a random secret key *)\n    a <- dbits(n);\n    (* Compute Alice's public key *)\n    A <- pow_mod(g, a, p);\n    (* Send her public key to Bob *)\n    return A;\n  }\n}.\n\n(* Bob's strategy *)\nmodule Bob = {\n  proc run(g : bits, p : bits, A : bits) : bits {\n    (* Generate a random secret key *)\n    b <- dbits(n);\n    (* Compute Bob's public key *)\n    B <- pow_mod(g, b, p);\n    (* Send his public key to Alice *)\n    return B;\n  }\n}.\n\n(* Shared secret key computation *)\nmodule SharedSecret = {\n  proc run(a : bits, b : bits, g : bits, p : bits) : bits {\n    (* Compute the shared secret key *)\n    K <- pow_mod(A, b, p);\n    return K;\n  }\n}.\n\n(* Example instantiation *)\nop n : int.\nop p : bits.\nop g : bits.\n\n(* Protocol instantiation *)\nmodule Protocol = {\n  proc run() : unit {\n    A <- Alice.run(g, p);\n    B <- Bob.run(g, p, A);\n    K_Alice <- SharedSecret.run(a, b, g, p);\n    K_Bob <- SharedSecret.run(b, a, g, p);\n    assert (K_Alice == K_Bob);\n  }\n}.\n\n(* Verification of the protocol *)\nproc verify() {\n  (* We assume the DDH assumption holds for a given group *)\n  assert (forall a b g p, pow_mod(g, a + b, p) == pow_mod(g, a, p) * pow_mod(g, b, p) mod p);\n  (* ... (Add more assertions as needed) ... *)\n}\n\n(* Example usage (to be added or modified as needed) *)\n(*\nproc main() {\n  (* ... (Example instantiation and execution) ... *)\n}\n*)\n```"]], "EC-1/KEMDEM.ec": [[true, "module B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct, k : key) = {\n    var r;\n    r <@ B_kem_0.distinguish(pk, k, c);\n    return r;\n  }\n}."]], "EC-1/KEM_ROM.ec": [[true, "module CPA_L (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nmodule CPA_R (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n    var b : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b       <$ {true, false};\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return b';\n  }\n}."]], "EC-1/MPAPISemantics.ec": [[false, "```\nec\n(** Multiparty semantics for a language parameterised by an API *)\nrequire import AllCore List SmtMap.\n\nrequire import AAPI ALanguage AMPSemantics SPAPISemantics.\n\n(**\n  We define a particular multiparty semantics that works for languages\n  where the computation of secret operations is carried out\n  by an external API, whlist public operations remain in the\n  domain of the language itself.\n\n  This semantics is essentially a realisation of the multiparty\n  semantics, that extends it with new datatypes and operations to interpolate \n  between the evaluation of the program and the API calls that are requested.\n\n  The interaction with the API is done via the [api] function.\n*)\n\ntype api_call = ApiCall of (list (int * int)) (* list of (party, value) pairs *)\n\n(* Example: API call to compute the XOR of two secrets *)\n(* This is a placeholder for the API call implementation *)\n(*  In a real implementation, this would involve invoking the API *)\n\n(* Note:  In a real implementation, this would need to be a function that takes the API call as input and returns a result.  This is a simplified example. *)\nfunction api_call_result (call : api_call) : int =\n  match call with\n  | ApiCall(pairs) =>\n      let (p1, v1) = pairs.(0)\n      and (p2, v2) = pairs.(1)\n      in v1 land v2\n  end.\n\n(* Semantics of the language extended with API calls *)\nmodule type MPSemantics = {\n  module Lang : ALanguage.\n  val semantics :\n    Lang.expr ->\n    (list (int * int)) -> (* list of (party, value) pairs *)\n    (list (int * int)) -> (* list of (party, value) pairs *)\n    (list (int * int)) -> (* list of (party, value) pairs *)\n    Lang.value.\n}.\n\nmodule API_MPSemantics (Lang : ALanguage) : MPSemantics = {\n  module Lang = Lang.\n  val semantics = (fun e p1_v p2_v p3_v =>\n    match e with\n    | Lang.Const i => Lang.Const i\n    | Lang.Var x =>\n       let (p,v) = (List.find (fun (p, v) -> p = x) p1_v) in v\n    | Lang.Add(e1, e2) =>\n       let v1 = semantics e1 p1_v p2_v p3_v\n       and v2 = semantics e2 p1_v p2_v p3_v\n       in Lang.Add(v1,v2)\n    | Lang.Xor(e1,e2) =>\n       let v1 = semantics e1 p1_v p2_v p3_v\n       and v2 = semantics e2 p1_v p2_v p3_v\n       in Lang.Const(v1 land v2)\n    end\n  ).\n}.\n\n\n(* Example use *)\nmodule ExampleLang : ALanguage = {\n  type expr = int | expr * expr | Var of int | Const of int | Xor of expr * expr | Add of expr * expr.\n  type value = int.\n  val add = (fun (e1:expr) (e2:expr) => Add(e1,e2)).\n  val const = (fun i => Const i).\n  val var = (fun i => Var i).\n  val xor = (fun (e1:expr) (e2:expr) => Xor(e1,e2)).\n}.\n```"]], "EC-1/MPCProtocolLibrary.ec": [[true, "(* EasyCrypt formal analysis of a secure protocol *)\n\nRequire Import EasyCrypt.\n\n(* Define types *)\ntype value_t = nat.\ntype inputs_t = list nat.\ntype leakage_t =\n  | LeakedValue of value_t\n  | LeakedShares of inputs_t.\ntype trace_t = list (nat * nat).\n\n\ntype sideInfo_t =\n  { leakage: leakage_t option ; trace: trace_t }.\n\n\n(* Define operations *)\nop leakage_shares (x: leakage_t) : inputs_t option =\n  with x = LeakedShares s => Some s\n  with x = LeakedValue v => None.\n\n\n(** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\ntype sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n(** Side information constructors *)\nop Leak (v: value_t) : sideInfo_t =\n  {| leakage = Some (LeakedValue v); trace = [] |}.\nop CorruptedShares (s: inputs_t) : sideInfo_t =\n  {| leakage = Some (LeakedShares s); trace = [] |}.\nop Trace (l: leakage_t option) t : sideInfo_t = {| leakage=l; trace=t |}.\n\n(** Gets the leakage from the side information *)\nop getLeakage (si: sideInfo_t) : leakage_t option = si.leakage.\n\n(** Example usage (you would replace this with your protocol) *)\nDefinition example_protocol (v: value_t) (s: inputs_t) : sideInfo_t =\n  match s with\n  | [] => Leak v\n  | _::_ => CorruptedShares s\n  end.\n\n(* Example verification (you would replace this with your security property) *)\nTheorem example_leakage_property :\n  forall v s,\n  match example_protocol v s with\n  | Leak v' => True\n  | CorruptedShares s' => True\n  end.\nProof.\n  intros v s.\n  unfold example_protocol.\n  destruct s; auto.\nQed."]], "EC-1/NbPRFEnc.ec": [[false, "```ec\nmodule ModifiedScheme = {\n   include Scheme [-enc,kg]\n  \n   proc kg() : key = { \n     RF.init();\n     return witness;\n   }\n\n   proc enc(k : key, n : nonce, p : plaintext) : ciphertext = {\n    var mask : plaintext;\n    var c : ciphertext;\n    \n    mask <@ RF.f(n);\n    c <- mask ^"]], "EC-1/ind_ow_pke.ec": [[false, "```ec\nrequire import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption"]], "EC-1/otp.ec": [[true, "require import AllCore.\nrequire BitWord.\n\nop l : { int | 0 < l } = 8. (* Example: block size 8 bits *)\n\nclone import BitWord as Bits with\n  op n <- l\nproof gt0_n by exact/gt0_l\nrename\n  \"word\" as \"bitstring\"\n  \"dunifin\" as \"dbitstring\".\n\nimport DWord.\n\ntype message = bitstring. (* Example: message type is bitstring *)\ntype ciphertext = bitstring.\ntype key = bitstring.\n\nop [lossless] dmsg : message distr = ____(OP_2)____.  (* Example: uniform distribution *)\n\n\nmodule OTP = {\n  var m: message\n  var c: ciphertext\n\n  proc kg() : key = {\n    var k;\n\n    k <$ dbitstring(l); (* Generate a key of length l *)\n    return k;\n  }\n\n  proc enc(k: key, m: message) : ciphertext = {\n    return (k +^ m); (* XOR operation *)\n  }\n\n  proc main() : unit = {\n    var k;\n\n    m <$ dmsg;\n    k <@ kg();\n    c <@ enc(k, m);\n  }\n}.\n\nm"]], "EC-1/passCertRPG_ref.ec": [[true, "require import AllCore IntDiv DInterval List UpdateList.\nrequire (Int.Int) RPGTh.\n\nclone include RPGTh.\n\nmodule RPGRef : RPG_T = {\n\n  var lowercaseSet, uppercaseSet, numbersSet, specialSet : charSet\n\n  proc rng(range:int) : int = {\n    \n    var value, maxValue, modValue : int;\n\n    (* check how much we should remove from 2^64 - 1 in order to get a multiple of range *)\n    modValue <- (2^64 - 1) %% range;\n\n    (* if the mod is range - 1, it means we can sample from 2^64 - 1 and have an uniform distribution *)\n    if(modValue = range - 1) {\n      maxValue <- (2^64 - 1);\n    (* else, we need to remove the unnecessary values*)\n    } else {\n      maxValue <- (2^64 - 1 - modValue);\n    }\n\n    value <- (RND.int maxValue);\n    return value %% range;\n  }\n\n  proc gen_char_set(charset : charSet) : char = {\n    var index : int;\n    index <- rng(length charset);\n    return charset[index];\n  }\n\n  proc gen_password(length:int) : string = {\n    var password : string;\n    var i : int;\n    password <- \"\";\n    for i <- (0) to (length - 1) {\n      var char : char;\n      char <- gen_char_set(lowercaseSet);\n      password <- password ++ char;\n    }\n    return password;\n  }\n}"]], "EC-1/AMPSemantics.ec": [[false, "```\n(** Abstract class for multiparty semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The multiparty semantics class is establishes how a program can\n  be collaboratively animated. We define the multiparty semantics\n  assuming that program evaluation is carried out by three computing\n  nodes, each one holding a description of the program in pottentially\n  different languages. We restrict the multiparty semantics\n  to only three parties due to tool limitations. Nevertheless,\n  having a three-party set is explanatory enough to demonstrate\n  the concepts we want to explore in this work and the definitions\n  he\n *)\nmodule MultiPartySemantics.\n\n  (** A type for the set of parties in the protocol. *)\n  type party = int.\n  \n  (** The set of parties. *)\n  const PARTIES : set party = {0; 1; 2}.\n\n  (**\n    A type representing the state of a party.  This type should\n    be sufficiently expressive to capture all the necessary\n    information for a party during the execution of a protocol.\n  *)\n  type state.\n\n  (**\n    The function that describes the initial state of a party.\n    It takes the party's index and returns its initial state.\n  *)\n  function init_state (p: party) : state.\n  (** Replace ____()___ with your implementation. *)\n  (* Example implementation: *)\n  let init_state p = match p with\n    | 0 => {local_data: 0; shared_data: 0}\n    | 1 => {local_data: 1; shared_data: 0}\n    | 2 => {local_data: 2; shared_data: 0}\n    | _ => assert false\n  end\n  where {\n    type state = {local_data: int; shared_data: int}.\n  }\n  \n  (**\n    The function that describes the transition from one state to another.\n    It takes the party's index, the current state, and a message received\n    from another party, and returns the next state.\n  *)\n  function step (p: party) (s: state) (msg: int) : state.\n  (** Replace ____()___ with your implementation. *)\n  (* Example implementation: *)\n  let step p s msg = match p with\n    | 0 => {local_data: s.local_data + msg; shared_data: s.shared_data + msg}\n    | 1 => {local_data: s.local_data + msg; shared_data: s.shared_data + msg}\n    | 2 => {local_data: s.local_data + msg; shared_data: s.shared_data + msg}\n    | _ => assert false\n  end.\n\n  (** The function that describes the output of a party. *)\n  function output (p: party) (s: state) : int.\n  (** Replace ____()___ with your implementation. *)\n  (* Example implementation: *)\n  let output p s = s.local_data.\n\nend\n```ec\n```\n```"]], "EC-1/pedersen-1.ec": [[false, "```\nCM.message     <- message,\n  type CM.commitment <- commitment,\n  type CM.openingkey <- openingkey.\n\n(* Pedersen commitment *)\nmodule Pedersen.\n  (* Commit *)\n  fun commit (sk: value) (r: message): commitment =\n    let g = group.generator in\n    g ** sk * (group.generator ** r).\n\n  (* Open *)\n  fun open (commit: commitment) (sk: value) (r: message): bool =\n    (commit = commit sk r).\n\n  (* Correctness *)\n  lemma commit_correctness (sk: value) (r: message):\n    open (commit sk r) sk r = true.\n  proof.\n    unfold commit, open.\n    rewrite (group.exp_mul_assoc).\n    reflexivity.\n  qed.\n\n  (* Security *)\n  lemma commit_security (sk1 sk2: value) (r1 r2: message):\n    (forall x: value,\n     commit sk1 r1 = commit sk2 r2).\n  proof.\n    unfold commit.\n    (* To be completed *)\n    (* This is an information-theoretic secure scheme, so we need to prove\n     * that it is hard to compute sk from the commitment *)\n    (* We can't prove this here, as it's a very difficult theorem *)\n    (* This is a placeholder, and needs to be filled with a real proof *)\n    (* if sk1 = sk2 then r1 = r2 else false *)\n    (* This is a very weak security statement.  A real proof would require\n     * more complex reasoning to show that knowing the commitment doesn't\n     * reveal anything about sk.  This is typically done by showing that\n     * the discrete logarithm problem is hard. *)\n    (* This is a placeholder, use an appropriate security argument *)\n    (* Example for a stronger statement (though still a placeholder): *)\n    (*  apply (DL.dlog_injective). *)\n    (* The above would be incorrect.  There is no such lemma in this theory. *)\n    (* Replace this placeholder with a proper security proof.  The correct\n     * proof will depend on the specific properties of the underlying group. *)\n    (* ... *)\n    (* We need to use the properties of the underlying group (e.g., the fact\n     * that the discrete logarithm problem is hard), but this cannot be done\n     * without more context. *)\n    (* For example, if the group is a subgroup of a prime order group, we can\n     * use properties of the discrete logarithm problem to prove security. *)\n    (* For now, we just assume security. *)\n    (* This is a placeholder for a proof *)\n    (* ... *)\n    (* Replace the above comment with a real proof, if possible *)\n    (* ... *)\n    (* For now, we just assume security *)\n    admit.\n  qed.\n\nend Pedersen.\n\n(* Export the Pedersen module *)\nexport Pedersen.\n\n(* Example usage *)\n(* This is just an example, not a formal proof *)\nexample.\n  let g = group.generator in\n  let sk = 1 in\n  let r = 2 in\n  let commit = Pedersen.commit sk r in\n  let is_opened = Pedersen.open commit sk r in\n  assert (is_opened = true).\n  (* This would be true if the open function is correctly defined *)\n  (* ... *)\n  (* There are no further proofs here, this is just an example *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n    (* ... *)\n    (* ... *)\n    (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n    (* ... *)\n    (* ... *)\n    (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n    (* ... *)\n    (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n    (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n    (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n    (* ... *)\n  (* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n\n    (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n(* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n    (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n  (* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n   (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n    (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n(* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n   (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n(* ... *)\n\n\n  (* ... *)\n(* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n(* ... *)\n\n\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n(* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n\n\n  (* ... *)\n\n  (* ... *)\n\n\n\n(* ... *)\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n\n\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n  (* ... *)\n\n\n  (* ... *)\n\n\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n\n  (* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n  (* ... *)\n\n\n(* ... *)\n\n(* ... *)\n  (* ... *)\n\n  (* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n (* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n  (* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n  (* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n  (* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n  (* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n  (* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n  (* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n  (* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n\n  (* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n  (* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n  (* ... *)\n  (* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n  (* ... *)\n  (* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n  (* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n  (* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n\n  (* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n(* ... *)\n\n\n\n\n(* ... *)\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n(* ... *)\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n(* ... *)\n\n\n(* ... *)\n\n(* ... *)"]], "EC-1/Plug_and_Pray_example.ec": [[false, "```\nrequire import AllCore List Int Real IntDiv.\nrequire import Distr DInterval.\nrequire (*--*) Plug_and_Pray.\n\nconst q : int { 0 < q } as gt0_q.\n\nmodule type Orcl = {\n  proc query(n : int) : int\n}.\n\nmodule type Adv (O : Orcl) = {\n  proc run() : bool\n}.\n\nmodule G0 (AF : Adv) = {\n  var b : bool\n  var k : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    k <- 0;\n    b <@ A.run();\n    k <- k %% q;\n  }\n}.\n\nmodule G1(AF : Adv) = {\n  var b : bool\n  var k : int\n  var i : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      i <- 0;\n      while (i < 10) {\n        k <- k + 1;\n        i <- i + 1;\n      }\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    k <- 0;\n    b <@ A.run();\n  }\n}.\n```"]], "EC-1/PRG.ec": [[true, "(* Protocol description *)\n(* This protocol describes a resampling process. *)\n\n(* Variables *)\nvariable A : nat;\nvariable F : nat;\nvariable Plog : seq nat;\n\n(* Functions *)\nfunction size (l:seq nat) : nat = ... (* Replace with actual size function *)\n\n(* Procedures *)\nprocedure Resample.resample() returns (res : bool) {\n  (* Implementation of the resampling procedure *)\n  (* ... *)\n    res := true;\n  }\n\n(* Protocol definition *)\nprocedure Main() {\n  var n : nat;\n  var s : nat;\n\n  (* Initialization *)\n  input n; input s;\n  A := 0; F := 0;\n  Plog := [];\n\n  (* Main loop *)\n  while (size(Plog) < n - 1) {\n    Resample.resample();\n  }\n}\n\n(* Specification *)\n(* ... Add your specification here ... *)\nlemma dseed_ll :\n  forall n s: nat.\n    (size(Plog) < n - 1) /\\ (n = n{1} + 1) ==>\n    (size(Plog) < n - 1{1}) /\\ (size(Plog) < n - 1{1} + 1) ==>\n    (size(Plog) < n - 1{1}) /\\ (n{1} = n - 1{1} + 1) /\\ (n{1} = n - 1) /\\ (n = n{1} + 1);\n\n(* Verification *)\nproof Main() {\n  (* ... Add your verification steps here ... *)\n    (* Example *)\n    splitwhile {2} 5 : (size P.logP < n - 1);\n    conseq (_ : _ ==> ={P.logP})=> //;\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2});\n    (* ... *)\n  }"]], "EC-1/PrIntervalToSum.ec": [[true, "require import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, iat.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare module A <: RunMain.\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = big predT\n        (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ])\n        (range s (s + e + 1)).\nmove => a f P s. apply ge0ind.\nsmt().\nprogress . \nhave ->: Pr[A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = sum (range s (s + e + 1)) (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ]).\n  apply sum_range_eq.\n  smt().\nQed.\n\nend."]], "EC-1/ProtocolAPI.ec": [[true, "(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol API we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some \n    functions\n    - [oblivious] protocols - that enable oblivious transfer\n    - [secure] protocols - that enable secure computation\n    - [general] protocols - that may encompass all the above\n*)\n\ntype protocol_type =\n| Sop\n| Oblivious\n| Secure\n| General.\n\n(* Protocols that securely compute some functions. *)\nmodule Sop(P:Protocol) = {\n  proc secure_computation(inputs: list int) returns (output: int) = {\n    output := P#secure_computation(inputs)\n  }\n}.\n\n(* Protocols that enable oblivious transfer. *)\nmodule Oblivious(P:Protocol) = {\n  proc oblivious_transfer(choice: int, input0: int, input1: int) returns (output: int) = {\n    output := P#oblivious_transfer(choice, input0, input1)\n  }\n}.\n\n(* Protocols that enable secure computation. *)\nmodule Secure(P:Protocol) = {\n  proc secure_computation(inputs: list int) returns (output: int) = {\n    output := P#secure_computation(inputs)\n  }\n}.\n\n\n(* Protocols that may encompass all the above. *)\nmodule General(P:Protocol) = {\n  proc general_protocol(ptype: protocol_type, args: list int) returns (output: int) = {\n    match ptype with\n    | Sop => output := P#secure_computation(args)\n    | Oblivious => output := P#oblivious_transfer(args[0], args[1], args[2])\n    | Secure => output := P#secure_computation(args)\n    | General => output := P#general_protocol(args) (* Placeholder *)\n    end\n  }\n}.\n\n\n(* Example usage (assuming a concrete Protocol implementation exists). *)\nmodule ExampleProtocol = {\n  proc secure_computation(inputs: list int) returns (output: int) = {\n    output := (fold_left (fun acc x -> acc + x) 0 inputs)\n  }\n  proc oblivious_transfer(choice: int, input0: int, input1: int) returns (output: int) = {\n    output := if choice = 0 then input0 else input1\n  }\n  proc general_protocol(args: list int) returns (output: int) = {\n    output := 0\n  }\n}.\n\n(* Example using the API *)\nmodule Main = {\n  proc main() = {\n    var p: Protocol := ExampleProtocol.\n    var api_sop := Sop(p).\n    var api_oblivious := Oblivious(p).\n    var api_general := General(p).\n\n    var result_sop : int.\n    var result_oblivious : int.\n    var result_general : int.\n\n    result_sop := api_sop#secure_computation([1; 2; 3]).\n    result_oblivious := api_oblivious#oblivious_transfer(0, 10, 20).\n    result_general := api_general#general_protocol(General, [0; 10; 20]).\n  }\n}."]], "EC-1/PseudoRandFun.ec": [[true, "(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\n(* PRF *)\n\nop prf : key -> text -> bool.\n\n(* security requirements *)\n\naxiom prf_indep (k:key) (t1 t2:text):\n  prf k t1 = true => prf k t2 = true.\n\n(* correctness *)\n\naxiom prf_correctness (k:key) (t:text):\n  prf k t = true => exists t':text, t' = t.\n\n(* security definition *)\n\naxiom prf_security (k:key) (t:text):\n    prf k t = true => exists t':text, t' = t.\n(* security requirements *)\n\n(* This is a placeholder, you need to define the actual security\n   properties for your PRF.  Here we assume that the PRF is\n   indistinguishable from a random oracle.\n   You need a more specific and detailed definition of the\n   security of your PRF.  This is a crucial step in the security\n   analysis.\n *)"]], "EC-1/RewMultRule.ec": [[false, "```\nRequire Import EasyCrypt.\nRequire Import List.\n\n(* Description: This is a simplified example of a two-party protocol.\n   Party A sends a message to Party B.  The protocol ensures that\n   the message is received correctly.  The analysis uses EasyCrypt\n   to verify the correctness of the protocol.\n*)\n\n(* Protocol *)\n\nDefinition send_msg (msg:nat) : nat := msg.\n\nDefinition recv_msg (msg:nat) : nat := msg.\n\n(* Protocol specification *)\n\nInductive P : Type :=\n| P_run : nat -> P.\n\nInductive Q : Type :=\n| Q_run : nat -> nat -> Q.\n\n\n(* Preconditions and Postconditions *)\n\n(*  Modify these to reflect the actual pre and post conditions for your protocol *)\n\nDefinition P_pre (x:nat) : Prop := true.\nDefinition P_post (x y : nat) (res:nat) : Prop := res = x.\n\nDefinition Q_pre (x y:nat) : Prop := true.\nDefinition Q_post (x y : nat) (res:nat) : Prop := res = y.\n\n(* Auxiliary functions (if needed) *)\n\n(*  Add any auxiliary functions for the protocol here *)\n\n(* Formal Analysis *)\n\nLemma protocol_correctness :\n  forall x y,\n  Pr[ P.run(x) @ &0 : exists r, Q.run(x) @ &0: r = y ] = 1.\nProof.\n  unfold P.unfold Q.\n  (*  Complete the proof here *)\n  \n  (* This is a skeleton, replace with the actual proof steps *)\n  intros x y.\n  (* Step 1:  Use the definition of Pr to break the probabilistic statement into a Hoare triple *)\n  unfold Pr.\n  (* Step 2:  Use the definitions of P_run and Q_run *)\n  (* Step 3:  Use the definitions of P_pre and P_post to derive the necessary preconditions *)\n  (* Step 4:  Use the definitions of Q_pre and Q_post to derive the necessary preconditions *)\n  (* Step 5:  Use the definitions of send_msg and recv_msg *)\n  (* Step 6:  Use the fact that send_msg and recv_msg are deterministic (if applicable) to simplify *)\n  (* Step 7:  Use the properties of the random number generator (if used) *)\n  (* Step 8:  Use the properties of the message exchange to link the two processes *)\n  (* Step 9: Use the rules of EasyCrypt to prove the statement *)\n  (* Example (replace with your actual proof): *)\n  rewrite send_msg.\n  rewrite recv_msg.\n  (*  Use tactics like rewrite, smt, progress, and others as necessary *)\n  reflexivity.\nQed.\n\n```"]], "EC-1/RewSumBindingAux.ec": [[true, "(* EasyCrypt protocol specification *)\n\n(* Description: This protocol describes a simplified authentication protocol.\n   Alice (A) wants to authenticate Bob (B).  Bob sends a message\n   containing a nonce and a challenge. Alice responds with an\n   acknowledgment and a secret.  The protocol ensures that only Bob can\n   initiate the authentication process.\n*)\n\n(* Protocol Variables *)\ntype msg = { nonce: nat; challenge: nat; secret: nat };\n\n(* Preconditions *)\nlet pre_A = { A: nat; ix: nat }\n\nlet pre_B = { B: nat; ix: nat; M: msg }\n\n\n(* Procedures *)\nproc A(A: nat; ix: nat) : msg =\n  let nonce = fresh_nat() in\n  let challenge = fresh_nat() in\n  { nonce; challenge; secret = A }\n\nproc B(B: nat; ix: nat; M: msg) =\n  if M.nonce = 1 then\n    let secret = 123 in\n    { secret }\n  else\n    { secret = 0 }\n\n(* Main Protocol *)\nlet protocol =\n  seq 1 1 : (={glob A, ix}). call A. skip. auto.\n  seq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\n  call(_:true).\n  rnd. rnd. skip. smt(). sp.\n  if{2}.\n  seq 2 3 :  (i0{2} = ix{2} /\\ ={ix, glob A, r1, M.x1, s} /\\ M.x1{1} /\\  x0{2} = M.x2{1}).\n  call (_:true). wp. call(_:true). skip. smt(). sp.\n  if{2}. wp.\n  call {1} (_:true ==> true). apply Agl. wp.\n  call {2} (_:true ==> true). apply Afl.\n  skip. smt().\n  wp. call (_:true).\n  skip. smt().\n  seq 4 3 : (!M.x1{1}).\n  wp. call {2} (_: true ==> true). apply Ass.\n  wp. call {1} (_: true ==> true). apply Agl.\n  call {1} (_: true ==> true). apply Agl\n\n\n(* Verification *)\nlet spec =\n  (* Add your specification here, e.g.,\n     ensures { ... } *)\n  true\n\nlet main =\n  prove (forall (A: nat)(ix: nat)(B: nat)(M: msg).\n    pre_A A ix /\\ pre_B B ix M ==> protocol)"]], "EC-1/RingCloning.ec": [[true, "(* This theory should make use of theories for groups.\n   It is currently mostly being developed towards getting\n   fixed-length bitstrings formalized as boolean rings,\n   automatically yielding many useful lemmas from a\n   small number of simple core axioms. *)\ntheory Ring.\n  type bit.\n  type ring.\n\n  (** Ring addition *)\n  const zero : ring.\n  op ( + ) : ring -> ring -> ring.\n  op [ - ] : ring -> ring.\n\n  axiom addrA (r1 r2 r3 : ring):\n    (r1 + r2) + r3 = r1 + (r2 + r3).\n\n  axiom addrC (r1 r2 : ring):\n    r1 + r2 = r2 + r1.\n\n  axiom add0r (r : ring):\n    zero + r = r.\n\n  axiom addNr (r : ring):\n    r + -r = zero.\n\n  (** Ring multiplication *)\n  const one : ring.\n  op ( * ) : ring -> ring -> ring.\n\n  axiom multA (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = r1 * (r2 * r3).\n\n  axiom multC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n\n  axiom mult1r (r : ring):\n    one * r = r.\n\n  axiom distrL (r1 r2 r3 : ring):\n    r1 * (r2 + r3) = r1 * r2 + r1 * r3.\n\n  axiom distrR (r1 r2 r3 : ring):\n    (r1 + r2) * r3 = r1 * r3 + r2 * r3.\n\n  (** Examples of ring elements *)\n  const a b c : ring.\n\n\nend Ring."]], "EC-1/SchnorrPK.ec": [[true, "(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type challenge    = F.t.\n  type response     = F.t.\n  type proof        = (message * challenge * response).\n\n  (* Type of a Schnorr scheme *)\n  type schnorr_scheme = {\n    g: group;\n    h: group;\n    g_exp: F.t -> group;\n    h_exp: F.t -> group;\n    hash: group -> F.t;\n    gen_challenge: group -> F.t;\n    gen_response: F.t -> F.t -> F.t;\n    verify: group -> F.t -> F.t -> bool\n  }.\nend.\n\n(* Schnorr protocol *)\ntheory SchnorrProtocol.\n  include SchnorrTypes.\n\n  (* Schnorr scheme *)\n  clone import SchnorrScheme.\n  let schnorr_scheme = {\n    g = g;\n    h = h;\n    g_exp = g_exp;\n    h_exp = h_exp;\n    hash = hash;\n    gen_challenge = gen_challenge;\n    gen_response = gen_response;\n    verify = verify\n  }.\n\n\n  (* Client's message *)\n  let client_message (sk: secret) : message =\n    g_exp sk.\n\n  (* Server's message *)\n  let server_message (pk: message) : message =\n    h.\n\n  (* Challenge generation *)\n  let challenge (m: message) : challenge =\n    gen_challenge m.\n\n  (* Response generation *)\n  let response (sk: secret) (c: challenge) : response =\n    gen_response sk c.\n\n  (* Proof construction *)\n  let proof (sk: secret) (m: message) : proof =\n    let c = challenge m in\n    let r = response sk c in\n    (m, c, r).\n\n  (* Verification *)\n  let verify (pk: message) (c: challenge) (r: response) : bool =\n    verify pk c r.\nend."]], "EC-1/AProtocolLibrary.ec": [[true, "(* Abstract class for protocol libraries *)\nrequire import AllCore List.\n\n(**\n  An abstract protocol library provides a set of secure\n  protocols that can be used to compute operations over\n  confidential data.\n\n  The library discloses protocols for secret operators,\n  input, output and a special declassification command that\n  reveals secret values. The last three protocols are concrete,\n  whereas the secret operators are left underspecified as it\n  is a general enough interface for protocols for secret operations.\n\n  Besides dealing with secret inputs, protocols also tolerate plain\n  values, that are assumed to be publicly known to all parties, as inputs.\n*)\n\ntype secret_op.\ntype plain_val.\n\nmodule type PROTOCOL_LIB = {\n  proc secret_op_protocol(op : secret_op, inputs : list secret) : secret;\n  proc input_protocol(input_type : type) : (input : input_type) {input};\n  proc output_protocol(output : plain_val);\n  proc declassify_protocol(secret : secret) : plain_val;\n}."]], "EC-1/SHA.ec": [[true, "require import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 m2: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0)))."]], "EC-1/SimpleCondProb.ec": [[true, "in_t) (p : glob P) (y : out_t) :\n  (forall x : in_t,\n    prop a x p (P.main(x, a)) = true) ->\n  (Sampler(P).main(a) = y) = (prop a v p y = true).\nend.\n\n\n(* Example instantiation *)\nmodule Example (P : Provided) = {\n  proc main(x : in_t, aux : aux_t) : out_t = {\n    var y : out_t;\n    y <- x;\n    return y;\n  }\n}."]], "EC-1/SimplifiedLangSMC.ec": [[true, "(* This file defines the formal analysis for a simplified protocol.\n   It uses EasyCrypt to verify the protocol's security properties. *)\n\n(* Import necessary modules *)\nfrom EasyCrypt.lib.list import *\nfrom EasyCrypt.lib.option import *\nfrom EasyCrypt.lib.set import *\nfrom EasyCrypt.lib.pair import *\n\n(* Assume modules for the protocol components *)\nmodule SLS:\n  type lconf_t;\n  type lcallSt;\n  type any;\n  op init(P:lconf_t): unit;\n  op step(): any option;\n  op other_leak_t: type;\n  op trace_t: type;\n\nmodule SLT:\n  type lconf_t;\n  type lcallSt;\n  op init(P:lconf_t): unit;\n  op step(): option (SideInfo);\n  op other_leak_t: type;\n  op trace_t: type;\n\nmodule API:\n  type SideInfo;\n\n(* Define types for the protocol *)\ntype LS.lconf_t = SLS.lconf_t;\ntype LS.lcallSt = SLS.lcallSt;\ntype LT.lconf_t = SLT.lconf_t;\ntype LT.lcallSt = SLT.lcallSt;\n\n(* Define the protocol's state and actions *)\n\n(* Type definitions for protocol states *)\ntype LS.other_leak_t = SLS.other_leak_t;\ntype LS.trace_t = SLS.trace_t;\ntype LT.other_leak_t = SLT.other_leak_t;\ntype LT.trace_t = SLT.trace_t;\n\n(* Certified compiler abstraction *)\nmodule CertifiedCompiler:\n  op comp(P: LS.lconf_t): LT.lconf_t;\n\n(* Define the types for the protocol *)\ntype LS.other_leak_t <- SLS.other_leak_t,\n      type LS.trace_t <- SLS.trace_t,\n      type LT.other_leak_t <- SLT.other_leak_t,\n      type LT.trace_t <- SLT.trace_t,\n      type API.SideInfo <- SideInfo,\n      type any <- SLS.any.\n\n(* certified compiler assumption *)\nclone CertifiedCompiler as Comp\n with theory LS <- LS,\n      theory LT <- LT.\n\n(* [sync] predicate - checks if lconf is at a sync. point *)\nop syncS (st: LS.lconf_t) : bool = LS.lcallSt st <> None.\nop syncT (st: LT.lconf_t) : bool = LT.lcallSt st <> None.\n \n(* Ideal target semantics simulator (D) - Fig. 8 *)\nmodule DSem(ISem: SLS.Sim_Sem_t): SLT.Sim_Sem_t = {\n  proc init(P:LS.L): unit = { \n    SLS.SimIdealSem.init(P);\n    SLT.SimIdealSem.init(Comp.comp(P));\n  }\n  proc step(): SideInfo option = {\n    var tau;\n    tau <- ISem.step();\n    match tau {\n      Some(x) => return Some(x);\n      None => return None;\n    }\n  }\n}"]], "EC-1/SimpLogic.ec": [[false, "```\n(* SimpLogic.ec *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nlemma fa_imp_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) => ! exists (x : 'a), ! P x.\nproof.\nmove => fa_x_P_x.\ncase (exists x, ! P x) => [[] x not_P_x | //].\nhave // : P x by apply fa_x_P_x.\nqed.\n\nlemma not_ex_not_imp_fa (P : 'a -> bool) :\n  ! (exists (x : 'a), ! P x) => forall (x : 'a), P x.\nproof.\nmove => not_ex_x_not_P_x x.\ncase (P x) => [// | not_P_x].\nhave // : exists x, ! P x by exists x.\n  apply not_P_x.\nqed.\n\nlemma fa_iff_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) <=> ! exists (x : 'a), ! P x.\nproof.\nsplit; [apply fa_imp_not_ex_not | apply not_ex_not_imp_fa].\nqed.\n\n(* we can do the above using the following tactic:\n  apply (fa_iff_not_ex_not P) *)\n```"]], "EC-1/SMC.ec": [[true, "(* Secure Message Communication via a One-time Pad, Formalized\n   in Ordinary (Non-UC) Real/Ideal Paradigm Style *)\n\nprover [\"\"].  (* no use of smt *)\n\nrequire import AllCore Distr.\n\n(* minimal axiomatization of bitstrings *)\n\nop n : int.  (* length of bitstrings *)\n\naxiom ge0_n : 0 <= n.\n\ntype bits.  (* type of bit strings of length n *)\n\nop zero : bits.  (* the all zero bitstring *)\n\nop (^^) : bits -> bits -> bits.  (* pointwise exclusive or *)\n\naxiom xorC (x y : bits) :\n  x ^^ y = y ^^ x.\n\naxiom xorA (x y z : bits) :\n  x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom xor0_ (x : bits) :\n  zero ^^ x = x.\n\nlemma xor_0 (x : bits) :\n  x ^^ zero = x.\nproof.\nby rewrite xorC xor0_.\nqed.\n\n(* Define a function to generate a random bitstring of length n *)\nop rand_bits : bits.\naxiom rand_bits_distr :\n  forall (x : bits),\n    Pr[rand_bits = x] = 1 / (2^n).\n\n\n(* Define a function for encryption *)\nop encrypt (m k : bits) : bits.\n  m ^^ k.\n\n(* Define a function for decryption *)\nop decrypt (c k : bits) : bits.\n  c ^^ k.\n\n(* Example lemma *)\nlemma decrypt_encrypt (m k : bits) :\n  decrypt (encrypt m k) k = m.\nproof.\n  by rewrite /encrypt /decrypt xor_0 xorC xorA.\nqed."]], "EC-1/SymEnc.ec": [[true, "(* encryption oracle limit before game's encryption\n\n   this says limit_pre has type int and the axiom ge0_limit_pre says\n   limit_pre is non-negative *)\nop limit_pre : int {____(OP_0)____ | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* encryption oracle limit before game's encryption,\n   this says limit_pre has type int and the axiom ge0_limit_pre says\n   limit_pre is non-negative *)\nop limit_pre : int {____(OP_0)____ | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* encryption oracle limit before game's encryption\n\n   this says limit_pre has type int and the axiom ge0_limit_pre says\n   limit_pre is non-negative *)\nop limit_pre : int {____(OP_0)____ | 0 <= limit_pre} as ge0_limit_pre.\n\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n(* decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n\n(* IND-CPA game *)\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t.\n\n(* IND-CPA game (completed) *)\n\n(* Encryption oracle *)\nop encrypt : key -> text -> cipher.\n\n(* Decryption oracle *)\nop decrypt : key -> cipher -> text.\n\n(* Encryption oracle correctness *)\naxiom enc_dec : forall k t,\n  decrypt k (encrypt k t) = t."]], "EC-1/SymEncPRF.ec": [[true, "(*\n  This file defines the formal analysis of a protocol related to a clash detection mechanism.\n  The protocol involves a counter and a failure event.  The analysis aims to bound the probability\n  of the failure event occurring.\n*)\n\n(* Parameters *)\ntext_len : nat;\nlimit_post : nat;\n\n(* Events *)\ntype event = EO_I.event;\n\n(* Counter *)\ntype counter = nat;\n\n(* State *)\ntype state = {\n  ctr : counter;\n  clash : bool;\n};\n\n(* Initial state *)\nlet init_state : state = {\n  ctr = 0;\n  clash = false;\n};\n\n(* Protocol (G3.main) *)\nlet rec G3_main (s : state) : event * state =\n  match s.ctr with\n  | n when n < limit_post ->\n    let new_state = { ctr = n + 1; clash = s.clash };\n    (EO_I.event_none, new_state)\n  | _ ->\n    (EO_I.event_clash, s)\n  ;\n\n(* Auxiliary function *)\nlet rec G3_main_aux (s : state) (n : nat) : event * state =\n  if n = 0 then G3_main s\n  else\n    let (e, s') = G3_main s in\n    if e = EO_I.event_none then G3_main_aux s' (n - 1)\n    else (e, s');\n\n\n(* Lemma: Probability of failure event is bounded *)\nlocal lemma G3_main_clash_ub &m :\n  Pr[G3.main() @ &m : EO_I.clash_post] <= limit_post%r / (2 ^ text_len)%r.\nproof.\n  fel\n  (* number of lines of G3.main needed to initialize counter, failure\n     event and invariant *)\n  1\n  EO_I.ctr_post  (* counter *)\n  (* upper bound in terms of current counter of probability that failure\n     event is set during one run of oracle *)\n  (fun n, 1%r / (2 ^ text_len)%r)\n  limit_post  (* counter limit *)\n  EO_I.clash_post  (* failure event *)\n  (* precondition on enc_post: if it holds, then counter goes up *)\n  (*  Using a simple probabilistic model where each step has probability 1/2^text_len to fail *)\n  (* The loop continues until the counter reaches the limit_post. *)\n  (*  The probability of a clash is the probability of the counter reaching or exceeding the limit in the given number of steps. *)\n  (*  The probability of a clash is thus at most the number of steps (limit_post) multiplied by the probability of a clash in each step. *)\n  by (sum_bound (fun n, 1%r / (2 ^ text_len)%r) limit_post).\nqed."]], "EC-1/theory-alias.ec": [[true, "theory T.\n  theory V.\n    op foo : unit -> int.\n  end V.\n\n  theory U = V.\nend T.\n\nimport T.\n\nop bar : int = U.foo().\n\nprint T."]], "EC-1/tut.ec": [[true, "require import Distr AllCore FSet SmtMap DProd List.\n\n(* A Stateful Random Generator *)\n\ntype seed.\n\nop dseed: seed distr.\naxiom dseed_ll: is_lossless dseed.\n\ntype state.\n\nop dstate: state distr.\naxiom dstate_uf: is_uniform dstate.\naxiom dstate_fu: is_full dstate.\n\ntype output.\n\nop dout: output distr.\naxiom dout_uf: is_uniform dout.\n\nop Fc : seed -> state -> state * output.\n\nmodule SRG = {\n  var s : seed\n  var st: state\n\n  proc init(): unit = {\n    s <$ dseed;\n    st <$ dstate;\n  }\n\n  proc next(): output = {\n    var r;\n    (st,r) <- Fc s st;\n    return r;\n  }\n}.\n\n(* A Pseudo-Random Generator *)\n\ntheory PRG.\n  type output.\n  op dout: output distr."]], "EC-1/WF-examp.ec": [[true, "(* example use of well-founded recursion and induction\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* define well-founded relation on lists: lt_list_size xs ys <=>\n   size xs < size ys *)\n\nop lt_list_size : list list rel = wf_pre size lt_nat.\n\nlemma wf_lt_list_size ['a] : wf lt_list_size.\nproof.\nrewrite wf_pre wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP (xs ys : 'a list) :\n  lt_list_size xs ys <=> size xs < size ys.\nproof.\nby rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* body of well-founded recursive definition that \"chunkifies\" an 'a\n   list \n\n   The goal is to define a function that splits a list into chunks of\n   a given size.  We use well-founded recursion to ensure termination.\n *)\n\n(* Define the function chunk.  Input is a list and chunk size.\n   Output is a list of lists. *)\nfunction chunk (l : 'a list) (n : nat) : list ('a list) {\n  requires (n > 0).\n} =\n  match l with\n  | [] => []\n  | h :: t =>\n    match n with\n    | 0 => []\n    | S m =>\n      h :: (chunk t n)\n    end\n  end.\n\nlemma chunk_size (l : 'a list) (n : nat) :\n  requires (n > 0).\n  ensures (size (chunk l n) <= (size l + n - 1) / n).\nproof.\n  induction l; simpl.\n  - (* case l = [] *)\n    rewrite size_nil.\n    by rewrite div_0.\n  - (* case l = h :: t *)\n    rewrite size_cons.\n    case (n).\n    + (* case n = 0 *)\n      by rewrite size_nil.\n    + (* case n = S m *)\n      rewrite size_cons.\n      rewrite size_cons.\n      rewrite plus_comm.\n      rewrite plus_assoc.\n      rewrite <- div_add.\n      apply (le_trans (size t + n - 1) / n).\n      apply le_div_le_div_add.\n      apply IHl.\n      rewrite size_cons.\n      by apply le_trans.\nqed.\n\n\nlemma chunk_correctness (l : 'a list) (n : nat) :\n  requires (n > 0).\n  ensures (concat (chunk l n) = l).\nproof.\n  induction l; simpl.\n  - (* case l = [] *)\n    by rewrite size_nil.\n  - (* case l = h :: t *)\n    rewrite size_cons.\n    case (n).\n    + (* case n = 0 *)\n      by rewrite size_nil.\n    + (* case n = S m *)\n      rewrite size_cons.\n      rewrite concat_cons.\n      rewrite concat_nil.\n      by rewrite IHl.\nqed."]], "EC-1/ASecretSharingScheme.ec": [[false, "```\nec\n(** Abstract class for secret sharing schemes *)\nrequire import List.\n\n(** \n  A secret sharing scheme is a cryptographic primitive whose\n  goal is to \"split\" some value into _n_ shares, such that the\n  knowledge of _t_ shares (_t_ < _n_) does not reveal any\n  sensitive information about the original value that was\n  shared.\n*)\ntheory SecretSharingScheme.\n\n  (** Party identifier *)\n  type partyId_t. (* 0..n_parties-1 *)\n\n  (** Number of parties *)\n  op n_parties : int.\n  (** Threshold of corrupt parties *)\n  op t : int.\n\n  (** Values *)\n  type value_t.\n  (** Individual shares *)\n  type share_t.\n  (** Set of all shares *)\n  type sharedValue_t = share_t list.\n\n  (** Secret sharing *)\n  op share (v : value_t) : sharedValue_t.\n\n  (** Reconstruction *)\n  op recover (shares : sharedValue_t) : value_t.\n\n  (** Check that the scheme is correct *)\n  lemma share_recover (v : value_t) :\n    recover (share v) = v.\n\n  (** Check that the scheme is secure, i.e., no information\n     about the secret can be revealed when knowing less\n     than t shares. *)\n  lemma security :\n    forall (v1 v2 : value_t) (shares1 shares2 : sharedValue_t),\n      (forall i : int, i < t -> shares1.[i] = shares2.[i]) ->\n      v1 = v2.\nend\n```"]], "EC-1/WhileSampling.ec": [[true, "require import Real Distr.\n\ntype t.\n\nop sample: t distr.\naxiom sample_ll: is_lossless sample.\n\nop test: t -> bool.\naxiom pr_ntest: 0%r < mu sample (predC test).\n\nmodule Sample = {\n  proc sample () : t = {\n    var r : t;\n\n    r <$ sample;\n    while (test r) {\n      r <$ sample;\n    }\n    return r;\n  }\n}.\n\nlemma islossless_sample: islossless Sample.sample.\nproof.\nproc; seq  1: true=> //.\n+ by auto=> />; exact/sample_ll.\nwhile true (if test r then 1 else 0) 1 (mu sample (predC test))=> //.\n+ by move=> _ r; case: (test r).\n+ move=> ih; seq  1: true=> //.\n  by auto; rewrite sample_ll.\n+ by auto; rewrite sample_ll.\nrewrite pr_ntest=> /=\n  by auto.\nqed."]], "EC-1/W64_SchnorrProtocol.ec": [[true, "require import AllCore.\nrequire import JModel.\n\n\nrequire import W64_SchnorrExtract.\nrequire import BigNum_spec.\n\nmodule ____(MODULE_0)____ = M(Syscall).\nmodule JVerifier = M(Syscall).\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power:W64xN.R.t,\n                 challenge:W64xN.R.t) : W64xN.R.t \n  proc commitment () : W64xN.R.t * W64xN.R.t  \n}.\n\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t \n  proc response(challenge:W64xN.R.t) : W64xN.R.t \n}.\n\n\nmodule type ZKVerifierJ = {\n   proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) :\n    W64.t  \n  proc challenge(statement : W64xN.R.t, commitment : W64xN.R.t) : W64xN.R.t\n}."]], "EC-1/async-while.ec": [[false, "```\nrequire import AllCore IntDiv Ring StdRing StdOrder.\n(*---*) import IntID IntOrder RealOrder.\n\ntype value.\n\nop n : { int | 0 <= n} as n_ge0.\nop k : { int | 0 <  k} as gt0_k.\n\nlemma ge0_k : 0 <= k.\nproof. by rewrite ltrW ?gt0_k. qed.\n\nmodule type I = {\n  proc step(i : int, x : value) : value\n}.\n\nmodule M(A : I) = {\n  proc f(x : value) = {\n    var i <- 0;\n\n    while (i < n * k) {\n      x <@ A.step(i, x);\n      i <- i + 1;\n    }\n\n    return x;\n  }\n\n  proc g(x : value) = {\n    var i <- 0;\n    var j;\n\n    while (i < n) {\n      j <- 0;\n      while (j < k) {\n        x <@ A.step(k * i + j, x);\n        j <- j + 1;\n      }\n      i <- i + 1;\n    }\n\n    return x;\n  }\n}.\n```"]], "EC-1/ambient-logic.ec": [[true, "(* Example: Proving associativity of integer addition *)\n\n(*\nThis file demonstrates a simple example of using EasyCrypt to prove\nthe associativity of integer addition.\n*)\n\nlemma int_assoc (x y z: int): x + (y + z) = (x + y) + z.\nproof.\n  (*\n  We can use the tactic \"trivial\" to prove simple equalities.\n  However, for more complex cases, we need more elaborate tactics.\n  *)\n  trivial.\nqed.\n\nlemma int_comm (x y: int): x + y = y + x.\nproof.\n  (*\n  We use the tactic \"admit\" to bypass the proof for now.\n  In a real proof, we would use tactics like \"split\", \"left\", \"right\", etc.,\n  depending on the structure of the goal.\n  *)\n  admit.\nqed.\n\n\n(* Example: Proving a simple arithmetic property *)\n\nlemma int_sub_1 (x: int): x - 10 = x - 9 - 1.\nproof.\n  (*\n   We can use the tactics like \"rewrite\" or \"simpl\" to rewrite the expression.\n   *)\n  rewrite int_comm.\n  rewrite int_assoc.\n  (*\n  Now we can use the tactic \"trivial\" to prove the equality.\n  *)\n  trivial.\nqed.\n\n\n(* Example: Proving a lemma about associativity and commutativity *)\n\n(*\nThis lemma combines associativity and commutativity of integer addition.\n*)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\n  split.\n  (* First goal: x + (y + z) = (x + y) + z *)\n  rewrite int_assoc. (* Use the associativity of addition *)\n  trivial.\n  (* Second goal: x + y = y + x *)\n  rewrite int_comm. (* Use the commutativity of addition *)\n  trivial.\nqed.\n\n(* Example demonstrating the use of \"left\" and \"right\" for disjunctions *)\n\n(*\nThis example is more complex, but shows how to use \"left\" and \"right\"\nto navigate disjunctions in a proof.\n*)\n\nlemma example_disjunction (x : int) : x = 0 \\/ x <> 0.\nproof.\n  (*\n  Use \"case\" when facing disjunctions.\n  *)\n  case (x = 0).\n  left.  (* x = 0 case *)\n  trivial.\n  right. (* x <> 0 case *)\n  admit. (* We admit the proof for now *)\nqed."]], "EC-1/asgncase.ec": [[true, "(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[M.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y' = 1).\n- by auto.\n- by auto.\nqed."]], "EC-1/adversary.ec": [[true, "require import AllCore List StdOrder Distr Real Int RealExp.\n(*---*) import RealOrder.\nrequire import Xreal RealSeries.\n(*---*) import StdBigop.Bigreal.\n\ntype r.\nop [lossless] dr : r distr.\n\nop test : r -> bool.\n\nop p = mu dr test.\naxiom dr_mu_test : 0%r < p.\n\nop eps : real.\naxiom dr_mu1 : forall (x:r), mu1 dr x <= eps.\n\nlemma eps_ge0: 0%r <= eps. by smt(dr_mu1 mu_bounded). qed.\n\nmodule type Oracle = { \n  proc o () : unit \n}.\n\nmodule type Adv (O:Oracle) = {\n  proc adv () : unit\n}.\n\nop Q : int.\naxiom Q_nneg : 0 <= Q.\n\nmodule O = {\n\n  var c : int \n  var log : r list\n  var bad : bool\n\n  proc extend_log () = {\n    var t, r;\n    t <- dr;\n    r <- ____(R_0)____;\n    log <- log ++ [r];\n  }\n\n  proc o () = {\n    c <- 0;\n    log <- [];\n    bad <- false;\n    while (c < Q) {\n      extend_log();\n      c <- c + 1;\n    }\n    if (bad) {\n      return;\n    }\n    ____(RETURN_0)____\n  }\n}.\n\nmodule Adv (O:Oracle) = {\n  proc adv () = {\n    O.o();\n  }\n}."]], "EC-1/ArrayFiniteness.ec": [[true, "require import AllCore List.\n\n\nrequire import WArray256.\nrequire import JModel.\n\nop all_8lists = alltuples (fun i => 8) [true;false]. \n\nlemma all_8lists_full (l : bool list) : size l = 8\n => l \\in all_8lists. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 8 l [true;false]).\nsplit. auto. smt(@List).\nqed.\n\n\nlemma all_8lists_size  : \n size all_8lists = 2 ^ 8.\nrewrite /all_8lists. rewrite size_alltuples.\nsimplify. rewrite /max. simplify. auto.\nqed.\n\n\nlemma all_8lists_uniq  : \n uniq all_8lists.\nsmt(@List).\nqed.\n\nop all_8words = map W8.bits2w all_8lists.\n\nlemma all_8words_full (w : W8.t) : \n  w \\in all_8words.\nrewrite /all_8words.\nhave : (W8.w_of_bits l) \\in all_8words\n  by rewrite /all_8words; apply (in_mapP (fun l => W8.w_of_bits l) l).\nhave : l \\in all_8lists.\nby apply all_8lists_full; rewrite size_map.\nhave : size l = 8.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : size l = 8.\nby apply all_8lists_full.\nhave : l \\in all_8lists.\nby apply all_8lists_full.\nhave : (W8.w_of_bits l) \\in all_8words.\nby apply (in_mapP (fun l => W8.w_of_bits l) l).\nhave : (W8.w_of_bits l) = w.\nby apply all_8lists_full.\nhave : size l = 8.\nby apply all_8lists_full.\nhave :  l \\in all_8lists.\nby apply all_8lists_full.\nexact (in_mapP (fun l => W8.w_of_bits l) l).\nqed."]], "EC-1/AuxLemmas.ec": [[true, "require import AllCore Distr Finite List.\n\n\nrequire import BitEncoding.\nimport BS2Int.\n\nrequire import JWord.\n\n\n\nmodule Skip = {\n  proc run() = {}\n}.\n\nlemma skip_run &m : Pr[Skip.run()@&m : true] = 1%r.\nbyphoare. proc. auto. auto. auto. qed.\n\n\n\nlemma kok (a b c : real) : 0%r <= a => 0%r < b => 1%r < c =>\n a <= b / c => a < b.\nsmt(@Real).\nqed.\n\n\nlemma w64oneP : forall x, 0 < x < 64 => W64.one.[x] = false. \nprogress. \nrewrite /W64.one.\nrewrite - of_intE.\nrewrite of_intwE.\nhave -> : (0 <= x && x < 64) = true. smt(). simplify.\nrewrite /int_bit.\nsmt(@IntDiv @W64).\nqed.\n\nop is_prime (x:int) : bool =\n  (x <= 1) ? false :\n  (x mod 2 = 0) ? false :\n  (forall i : int, 2 <= i < x, x mod i <> 0).\n\n\nop is_prime_helper (x : int) (i:int) : bool =\n  (i < x) ? (x mod i <> 0) && is_prime_helper (x) (i+1) : true.\n\nop is_prime_aux (x : int) : bool =\n  (x <= 1) ? false :\n  (x mod 2 = 0) ? false : is_prime_helper(x, 3).\n\n\nop ____(OP_1)____ (x:int):bool = is_prime_aux(x).\nop ____(OP_0)____ = int.\nop ____(OP_2)____ (x:int) : bool = is_prime_aux(x).\nop ____(OP_3)____ = int."]], "EC-1/AuxResults.ec": [[false, "```\n(* EasyCrypt formal analysis of a protocol *)\n\n(* Description: This protocol analyzes the relationship between two functions F1 and F2, and their sums over a list of values.  It also defines lemmas concerning exponents and their bounds. *)\n\nRequire Import EasyCrypt.\n\n(* Define the types for F1 and F2.  Assume 'a is a type supporting real numbers and list operations. *)\nParameter F1 : forall 'a, 'a -> real.\nParameter F2 : forall 'a, 'a -> real.\n\n(* Define big P0, assuming it's an aggregation function over a list. *)\nParameter big_P0 : (forall 'a, 'a -> real) -> 'a list -> real.\n\n\n(* Lemma 1: Distributive property for big P0 over subtraction. *)\nLemma big_distrib :\n  forall 'a (s : 'a list),\n    big_P0 (fun (i : 'a) => F1 i - F2 i) s = big_P0 F1 s - big_P0 F2 s.\nProof.\n  intros 'a s.\n  (* Use induction on the list s. *)\n  induction s; simpl; intros.\n  - (* Base case: empty list *)\n    reflexivity.\n  - (* Inductive step: non-empty list *)\n    rewrite big_P0_cons.\n    rewrite big_P0_cons.\n    rewrite IHs.\n    reflexivity.\nQed.\n\n\n(* Lemma 2: Bounded exponentiation. *)\nLemma multn :\n  forall p n,\n    0%r <= p <= 1%r -> 0 <= n -> 0%r <= p^n <= 1%r.\nProof.\n  intros p n cs.\n  induction n; simpl; intros.\n  - (* Base case: n = 0 *)\n    rewrite pow_0.\n    reflexivity.\n  - (* Inductive step: n+1 *)\n    rewrite pow_succ.\n    destruct (le_0_lt_1 p) as [Hp | H1].\n    + (* Case 1: 0 <= p <= 1 *)\n      apply mult_le_mono with (1%r).\n      apply le_trans with (p^n).\n      apply IHn.\n      assumption.\n      assumption.\n    + (* Case 2: 1 < p *)\n      (* We can't proceed without further constraints on p.  The lemma is incomplete as stated. *)\n      (* This case would need further reasoning, potentially involving the assumption that 0 <= p. *)\n      (* It is likely an error in the original statement or missing assumptions. *)\n      (* For now, we will use a placeholder. *)\n      (* smt().  *)\n      (* This should be a proof by induction, considering possible cases. *)\n      (*  If p = 1, then p^n = 1 for all n. *)\n      (*  If 0 <= p < 1, then p^n decreases as n increases. *)\n      (*  If 1 < p, then p^n increases as n increases. *)\n      (*  The proof should use the induction hypothesis to derive the desired inequality. *)\n      (* Or, this could be a bug in the original proof. *)\n      discriminate. (* Placeholder *)\nQed.\n\n\n\n(* Lemma 3: Bounded exponentiation with upper bound q. *)\nLemma multn2 :\n  forall p q n,\n    0%r <= p <= q -> 0 <= n -> p^n <= q^n.\nProof.\n  intros p q n cs.\n  induction n; simpl; intros.\n  - (* Base case: n = 0 *)\n    rewrite pow_0.\n    reflexivity.\n  - (* Inductive step: n+1 *)\n    rewrite pow_succ.\n    rewrite pow_succ.\n    apply mult_le_mono with (q^n).\n    apply IHn.\n    assumption.\n    assumption.\nQed.\n\n```\n\n```ec\n```"]], "EC-1/BarrettRedInt.ec": [[true, "require import RealExp CoreReal Real StdOrder.\n\nimport RealOrder.\n\n\nop r(n k : real) : real = (floor (4%r^k  / n))%r .\nop t' (x n k : real) = (floor (x * r n k / 4%r^k))%r.\nop t (x n k : real)  : real = x - (t' x n k) * n.\n\n\n\nlemma r_pos n (k : real): \n   0%r <= n < 2%r^k =>\n  r n k >= 0%r. rewrite /r. move => Q. smt(@Real @RealExp).  qed.\n\n  \nlemma nn_bound n (k : real) : \n  0%r <= n < 2%r^k =>\n  n*n < 4%r^k. \n  have -> : 4%r = 2%r ^ 2%r. smt(@RealExp).\n  have -> : 2%r ^ 2%r ^ k = (2%r ^ k) * (2%r ^ k). smt(@RealExp).\n  smt().\nqed.  \n\n\nlemma st1 (x n k : real) (LEMMA_1 : 0%r <= n < 2%r^k) : (x / n - 1%r) < r n k <= (4%r^k / n)\nproof.\n  rewrite /r.\n  assert (H1 : 0%r <= 4%r^k / n).\n  by rewrite /r; smt(@Real @RealExp).\n  assert (H2 : n > 0%r).\n  by smt().\n  assert (H3 : 4%r^k / n >= 1%r).\n  by smt(@RealExp).\n  assert (H4 : r n k = (floor (4%r^k / n))%r).\n  by rewrite /r.\n  assert (H5 : (floor (4%r^k / n))%r <= (4%r^k / n)).\n  by smt(@Real).\n  assert (H6 : (x/n - 1%r) < (4%r^k/n)).\n  by smt().\n  assert (H7 : (x/n - 1%r) < (floor (4%r^k/n))%r).\n  by smt().\n  assert (H8 : (floor (4%r^k/n))%r <= (4%r^k/n)).\n  by smt(@Real).\n  split.\n  - apply H7.\n  - apply H8.\nqed."]], "EC-1/ASPSemantics.ec": [[true, "(** The single pary semantics class is parameterised by a language and\n  should establish how programs written in that language\n  are animated.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary,\n*)\nmodule SinglePartySemantics(Language: LANGUAGE).\n\n  (* Type of the environment *)\n  type env.\n\n  (* Type of the adversary *)\n  type adversary.\n\n  (* Type of the program *)\n  type program.\n\n  (* Type of the state *)\n  type state.\n\n  (* Function to create a new environment *)\n  val init_env: (unit -> env).\n\n  (* Function to update the environment *)\n  val update_env: (env -> input -> env).\n\n  (* Function to get the output from the environment *)\n  val get_output: (env -> output).\n\n  (* Function to evaluate the program in a small-step basis *)\n  val eval_step: (adversary -> state -> state).\n\n  (* Function to get the initial state *)\n  val init_state: (program -> state).\n\n\n  (* A function to simulate the execution of a program *)\n  (* Input: program, adversary, initial environment *)\n  (* Output: output, final environment *)\n  (* The function should return the output of the program and the final environment *)\n  (* after the program has been executed by the adversary. *)\n  (* The initial environment is used to provide inputs to the program *)\n  (* and collect outputs. *)\n  (* The adversary is responsible for carrying out the small-step evaluation *)\n  (* of the program. *)\n  (* The function should return the output of the program and the final environment *)\n  (* after the program has been executed by the adversary. *)\n\n  (* Input : program, adversary, initial environment *)\n  (* Output : output, final environment *)\n  (* The function should return the output of the program and the final environment *)\n  (* after the program has been executed by the adversary. *)\n  (* The initial environment is used to provide inputs to the program *)\n  (* and collect outputs. *)\n  (* The adversary is responsible for carrying out the small-step evaluation *)\n  (* of the program. *)\n\n  val simulate:\n    (program -> adversary -> env -> (output * env)).\n\n\n\nend."]], "EC-1/BarrettReduction_Abstract.ec": [[false, "```\nrequire import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n\n(* equiv mulm_eq: *)\n(*  CSpecFp.mulm ~ ASpecFp.mulm:  *)\n(*   a{1} = Zp.asint a{2} /\\ b{1} = Zp.asint b{2} /\\ p{1} = Zp.p *)\n(*     ==> res{1} = Zp.asint res{2}. *)\n(* proof.  proc. inline*. wp.  skip. progress. *)\n(* smt(@Zp). *)\n(* qed. *)\n\n\n(* parameter for the Barrett reduction  *)\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm: ={a, p} /\\ r{2} = (4 ^ k{2} %/ p{2}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  /\\ 0 <= k{2} ==> ={res}.\nproc. inline*. wp. skip. progress.\nrewr\n  (a{2} = p{2} * (a{2} / p{2}) + a{2} % p{2}) by arith.\nrewr (a{2} % p{2} = a{2} mod p{2}).\nrewr (a{2} / p{2} = a{2} / p{2}).\nrewr (a{2} mod p{2} = a{2} - (a{2} / p{2}) * p{2}).\nrewr (a{2} / p{2} = a{2} / p{2}).\nrewrite /redm.\nrewrite /redm'.\nwp.\nassert (res{1} = a{2} mod p{2}).\nby smt().\nassert (res{2} = a{2} mod p{2}).\nby smt().\nrewrite <-  (mod_small_lemma a{2} p{2}).\nrewrite <- (mod_small_lemma a{2} p{2}).\nby smt().\n```"]], "EC-1/basic-hash-unlink.ec": [[false, "```\n(*-----------------------------------------------------------------------*)\n(* Assuming there are no collision, the single and multiple sessions\n   protocols coincide. *)\nlemma eq_single_mult &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) :\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] =\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.\n  byequiv => //; proc; inline *; sp 5 5. \n  seq 4 4 : (#pre /\\ ={Multiple0.s_cpt, i} /\\ \n             (forall j, (0 <= j < n_tag) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{2} = Single0.s_cpt.[j]{2}) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{1} = Single0.s_cpt.[j]{1}) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{3} = Single0.s_cpt.[j]{3}) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{4} = Single0.s_cpt.[j]{4})\n             => /#.\n  rewrite /Multiple0.s_cpt /Single0.s_cpt.\n  by auto.\nqed.\n```"]], "EC-1/BigNum_proofs.ec": [[false, "```\nRequire Import EasyCrypt.\nRequire Import Lib.\n\n(* Description: This code defines a protocol for swapping two values. *)\n\n(* Variables *)\nVariable a b c : W64.\nVariable x y : W64.\nVariable swap_0 : bool.\nVariable mask : W64.\n\n(* Protocol definition *)\nDefinition swapr (a b : W64) (swap_0 : bool) : W64 :=\n  if swap_0 then a else b.\n\n(* Specification *)\nDefinition CSpecFp_swapr (x y c : W64) : W64 :=\n  if (as_bool (as_w64 c)) then x else y.\n\n(* Lemma to prove *)\nLemma swap_lemma_cspec :\n  equiv[ M.swapr ~ CSpecFp.swapr :\n              a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} ==> ={res}].\nProof.\n  proc.  simplify.\n  seq 2 0 : (i{1} = 0 /\\ a{2} = x{1} /\\ b{2} = y{1} /\\ swap_0{1} = as_w64 c{2} /\\ \n   ((as_bool swap_0{1} => mask{1} = (of_int 18446744073709551615)%W64 )\n              /\\ (as_bool swap_0{1} = false => mask{1} = (of_int 0)%W64))).\n  wp. skip. progress. smt(@W64). smt(@W64).\n  destruct (as_bool swap_0{1}).\n  - rewrite W64.bits.\n    rewrite W64.of_int.\n    reflexivity.\n  - rewrite W64.bits.\n    rewrite W64.of_int.\n    reflexivity.\n  (* Add the missing cases *)\n  (*  - apply W64.of_int_spec. *)\n  (*  - apply W64.of_int_spec. *)\n  (*  - apply W64.bits_spec. *)\n  (*  - apply W64.bits_spec. *)\n  (*  Use smt to prove the remaining cases *)\n  smt().\n  auto. smt().\n  qed.\n\n```"]], "EC-1/BinUniSample_spec.ec": [[true, "require import AllCore Distr DInterval List IntDiv.\n\nmodule SampleByte = {\n  proc sampleInt() = {\n    var x;\n    x <$ [0..255];\n    return x;\n  }\n\n  proc run() = {\n    var x : int;\n    x <@ sampleInt();\n    x <- x %% 2;\n    return x;\n  }\n}.\n\n\nlemma sample_prob0 : phoare[SampleByte.run : true ==> res = 0 ] = (inv 128%r/256%r).\nproc. inline*.\nwp. rnd. skip. progress.\nrewrite duniformE.\nhave ->: (undup (range 0 256)) = (range 0 256).\nsmt(@List).\nhave ->: (size (range 0 256)) = 256. smt(@List).\nhave ->: (count (fun (x : int) => x %% 2 = 0) (range 0 256)) = 128.\ndo (rewrite range_ltn /=; first by trivial). \nby rewrite /b2i;rewrite range_geq;simplify;done.\nauto.\nqe"]], "EC-1/check-easycrypt-install.ec": [[true, "(* SPDX-FileCopyrightText: 2021 Alley Stoughton *)\n(* SPDX-License-Identifier: TODO *)\n\n(* if EasyCrypt is able to successfully check this file, then\n   it and the SMT solvers Alt-Ergo and Z3 are properly installed\n   and configured *)\n\nrequire import AllCore.  (* load the \"core\" EasyCrypt theories, in\n                            particular giving us the relation < on the\n                            type int of integers *)\n\nprover quorum=2 [\"Alt-Ergo\" \"Z3\"].  (* the smt tactic will only\n                                       succeed if both Alt-Ergo and\n                                       Z3 are able to solve the goal *)\n\nlemma foo (x y : int) :\n  x < y = (exists k : int, y = x + k /\\ k > 0)."]], "EC-1/ConstantsValidation.ec": [[false, "```\nhouzhui\nrequire Ring.\nrequire import Int.\nimport Ring.IntID.\nrequire Constants.\nrequire import IntDiv.\n\n\nsection.\n\nop [opaque] square_and_multiply_state (x y z m : int) = ((x ^ y) * z) %% m.\n\nlocal lemma red_exp' (x' x'' m : int) : forall y, 0 <= y =>  x' %% m = x'' %% m \n  => x' ^ y %% m = x'' ^ y %% m.\napply intind. simplify. progress.\nprogress.\nhave ->: x' ^ (i + 1)  = x' * (x' ^ i). smt(@Ring.IntID).\nhave ->: x'' ^ (i + 1)  = x'' * (x'' ^ i). smt(@Ring.IntID).\nhave ->: x' * x' ^ i %% m = x' %% m * (x' ^ i %% m) %% m. smt(@IntDiv).\nrewrite H0. apply H1. rewrite H1.\nsmt(@IntDiv).\nqed.\n\n\nlocal lemma red_exp (x x' m : int) : forall y, 0 <= y => x' = x %% m => x ^ y %% m = (x' ^ y) %% m.\napply red_exp'.\nsmt(@Ring.IntID).\nsimplify.\nprogress.\nhave H0 : x' = x %% m.\nhave H1 : 0 <= y.\nhave H2 : x' ^ y %% m = (x %% m) ^ y %% m.\nhave -> : (x %% m) ^ y %% m = x ^ y %% m. smt(@IntDiv).\nrewrite H2.\nsmt(@Ring.IntID).\nqed.\n\n\nend.\n```"]], "EC-1/cramer_shoup.ec": [[true, "require import AllCore List Distr Dexcepted PKE.\nrequire import StdOrder StdBigop.\nimport RField RealOrder Bigreal.\n\nrequire TCR RndExcept.\n\n(** DiffieHellman *)\nrequire DiffieHellman.\nclone DiffieHellman as DH.\nimport DH.DDH DH.G DH.GP DH.FD DH.GP.ZModE.\n\nclone DH.GP.ZModE.ZModpField as ZPF.\n\nlemma gt1_q : 1 < order by smt(ge2_p).\n\ntheory Ad1.\n\n  clone import RndExcept as RndE with\n    type input <- unit,\n    type t     <- exp,\n    op   d     <- fun _ => dt,\n    type out   <- bool\n    proof *.\n    realize d_ll. move=> _;apply dt_ll. qed.\n\n  clone include Adversary1_1 with\n    op n <- order\n    proof *.\n  realize gt1_n by apply gt1_q.\n  realize d_uni.\n  proof.\n    move=> x.\n    apply (d_uni_impl _ _).\n  qed.\n\nend Ad1."]], "EC-1/Djoinmap.ec": [[true, "pragma Goals:printall.\nrequire import AllCore DBool Bool List Distr Int IntDiv AuxResults FSet.\n\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA.\nimport BRM.\n\ntype a, b.\n\nop djoinmap (d : a -> b distr) (l : a list) : b list distr =\n  (fun () => map (fun x => (x $ d)) l).\n\n\nop ____(OP_0)____ : a -> b distr.\n\nop merge ['a] = (fun (xs : 'a list * 'a list) => xs.`1 ++ xs.`2).\nop splitf ['a] (n : int) = (fun (l : 'a list) => (take n l, drop n l)).\n\n\nmodule DJM = {\n\n  proc main1(l1 : a list, l2 : a list) = {\n    var x1, x2;\n    x1 <$ djoinmap d l1;\n    x2 <$ djoinmap d l2;\n    return (x1, x2);\n  }\n\n\n  proc main2(l1 : a list, l2 : a list) = {\n    var x;\n    x <$ djoinmap d l1 `*` djoinmap d l2;\n    return x;\n  }\n}"]], "EC-1/DoubleBigNum_proofs.ec": [[false, "```\n(* EasyCrypt code for conditional move *)\n\n(* Definitions *)\nmodule Spec = struct\n  type w64x2n = int\n  val valR : bool -> w64x2n -> w64x2n\n  let valR cf x = if cf then x else 0 (* Example implementation *)\nend\n\n(* Specification *)\nmodule DBn_cmov_spec = struct\n  let dbn_cmov_correct cf z x r =\n    Spec.valR cf x = r\nend\n\n(* Protocol *)\nmodule DBn_copy_spec = struct\n  let dbn_copy_correct x r =\n    x = r\nend\n\nmodule Dsubc_spec = struct\n  let dsubc_spec p a r =\n    a < p\nend\n\n\n(* Main function *)\nlet main () =\n  let open Spec in\n  let open DBn_cmov_spec in\n  let open DBn_copy_spec in\n  let open Dsubc_spec in\n  \n  let cf1 = true in (* Example: cf is true *)\n  let z1 = 10 in (* Example values for z1 *)\n  let x1 = 20 in (* Example values for x1 *)\n  let r2 = 20 in (* Example value for r2 *)\n  let p1 = 30 in (* Example value for p1 *)\n  let p2 = 25 in (* Example value for p2 *)\n  let a2 = 15 in (* Example value for a2 *)\n  let c2 = true in (* Example value for c2 *)\n  let x2 = 15 in\n\n\n  (* Proof *)\n  let _ = assert (DBn_cmov_spec.dbn_cmov_correct cf1 z1 x1 r2) in\n  let _ = assert (DBn_copy_spec.dbn_copy_correct x1 x1) in\n  let _ = assert (Dsubc_spec.dsubc_spec p1 a2 r2) in\n  let _ = assert (cf1 = c2) in\n  let _ = assert (valR z1 = x2) in\n  let _ = assert ((valR p1) = p2) in\n  let _ = assert ((valR x1) = a2) in\n  let _ = assert (0 <= p2) in\n  let _ = assert (a2 < p2) in (* Crucial assertion *)\n\n  (* The following are now redundant as the condition is already in the assert statement above*)\n  (* let _ = assert (a2 < p2 = true) in *)\n  (* let _ = assert (a2 < p2 = false) in *)\n  ()\n;;\n\n```\n\n```\n(* EasyCrypt output *)\n\n(* ... (EasyCrypt output, potentially containing proof details) ... *)\n```"]], "EC-1/FMap.ec": [[false, "```\nec\nRequire Import EasyCrypt.\n\n(* Description: This code defines a restricted map that only keeps entries with a specific value for the second component. *)\n\n(* Type definitions *)\nParameter key_type : Type.\nParameter value_type : Type.\nParameter filter_type : Type.\n\n(* Map type *)\nInductive fmap : key_type -> option (value_type * filter_type) :=\n| fmap_nil : forall k, fmap k None\n| fmap_cons : forall k v f k',\n    fmap k' (Some (v, f)) -> fmap k (Some (v, f)).\n\n\n(* Function to restrict a map to entries with a specific filter value *)\nFixpoint restr (f : filter_type) (m : key_type -> option (value_type * filter_type)) : key_type -> option value_type :=\n  fun k =>\n    match m k with\n    | Some (v, f') => if beq_dec f f' then Some v else None\n    | None => None\n    end.\n\n(* Helper function to update a map at a specific key *)\nFixpoint get_set (m : key_type -> option (value_type * filter_type)) (k : key_type) (v : value_type) (f : filter_type) : key_type -> option (value_type * filter_type) :=\n  fun k' =>\n    match k' with\n    | k => Some (v, f)\n    | k' => m k'\n    end.\n\n(* Predicate to check if a key exists in a map with a specific filter value *)\nDefinition in_dom_with (m : key_type -> option (value_type * filter_type)) k f : Prop :=\n  exists v, m k = Some (v, f).\n\n\n(* Lemma 1:  This lemma defines the behaviour of the restr function, checking that only entries with the given filter value are kept. *)\nlemma restr_def ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x : (restr f m).[x] =\n  obind (fun (p : _ * _) => if p.`2 = f then Some p.`1 else None) m.[x].\nproof.\nrewrite /restr /= mapE filterE /=.\nby case (m.[x])=> //= -[x1 f'] /=; case (f' = f).\nqed.\n\nlemma dom_restr ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f x :\n  dom (restr f m) x <=> in_dom_with m x f.\nproof.\nrewrite /in_dom_with !domE; case: (m.[x]) (restrP m f x)=> //= -[t f'] /=.\nby case (f' = f)=> [_ -> |].\nqed.\n\nlemma restr_set ['k, 'v, 'f] (m : ('k, 'v * 'f) fmap) f1 f2 x y :\n  restr f1 m.[x <- (y, f2)]\n    = if f1 = f2 then (restr f1 m).[x <- y] else rem (restr f1 m) x.\nproof.\nrewrite -fmap_eqP=> k; case: (f1 = f2) => [->|neq_f12].\n+ by rewrite !(restrP, get_setE); case: (m k); last by rewrite rem_not_in.\n+ by rewrite !(restrP, get_setE); case: (m k); last by rewrite rem_not_in.\nqed.\n\n```\n\n```\nec\n```"]], "EC-1/bad_abs.ec": [[false, "```\nec\nrequire import AllCore Distr.\n\ntype input_a.\ntype output_a.\n\nmodule type Adv = {\n  proc a(x:input_a) : output_a\n}.\n\ntype input_m.\n\nmodule type Main(A:Adv) = {\n  proc main(x:input_m): bool\n}.\n\nmodule type NegA (A:Adv) = {\n  proc a(x:input_a) : output_a {A.a}\n}.\n\nsection TEST.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool)\n            (x1 x2 : input_m) (g1 g2 : glob M1) (g3 g4 : glob M2)\n     (pre x1 x2 g1 g2) ->\n     (E1 g1 A.a true) ->\n     (E2 g2 A.a true) ->\n     (B g3 A.a true) ->\n     (M1.main x1) = (M2.main x2).\nend.\n```"]], "EC-1/Forking.ec": [[true, "type query_t, response_t.\nconst Q : {query_t -> response_t}.\n\n(* Protocol *)\nmodule Protocol = {\n  proc run(input : in_t, aux : aux_t) : (out : out_t, aux' : aux_t)\n    requires true\n    ensures true\n}.\n\n(* Security game *)\nmodule Game = {\n  proc main(input : in_t, aux : aux_t) : (out : out_t, aux' : aux_t)\n    requires true\n    ensures true\n}.\n\n(* Forking lemma *)\nlemma forking_lemma(input : in_t, aux : aux_t) :\n  exists (out : out_t, aux' : aux_t).\n    (Game.main(input, aux) == (out, aux')) /\\\n    (Protocol.run(input, aux) == (out, aux'))\nproof.\n  (* Proof sketch *)\n  (* 1. Assume a distinguisher. *)\n  (* 2. Construct a forking game. *)\n  (* 3. Show that the forking game is indistinguishable from the security game. *)\n  (* 4. Show that the forking game has a successful forking strategy. *)\n  (* 5. Conclude that the security game has a successful attack. *)\n  (* Detailed proof steps omitted. *)\n  (* FIXME: Fill in the missing details. *)\n  exists (out : out_t, aux' : aux_t).\n    (Game.main(input, aux) == (out, aux')) /\\\n    (Protocol.run(input, aux) == (out, aux'))\n  (* FIXME: Add the actual proof steps. *)\n  (* Example:  by []. *)\n  (* The above is just a placeholder. *)\n  by [].\n}\n\n(* Example instantiation *)\nmodule Example = {\n  type in_t = int.\n  type aux_t = int.\n  type out_t = int.\n  type query_t = int.\n  type response_t = int.\n  const Q : {int -> int}.\n  \n  module Protocol = {\n    proc run(input : int, aux : int) : (out : int, aux' : int)\n      requires true\n      ensures true {\n      out := input + aux;\n      aux' := aux;\n    }\n  };\n  \n  module Game = {\n    proc main(input : int, aux : int) : (out : int, aux' : int)\n      requires true\n      ensures true {\n      out := input + aux;\n      aux' := aux;\n    }\n  }\n}\n\n(* Example usage (placeholder) *)\n(*\nmodule Main = {\n  proc main() {\n    Example.forking_lemma(10, 20)\n  }\n}\n*)"]], "EC-1/ForkingRO.ec": [[true, "module ForkStoppingRO(F : ForkableRO) = {\n  type in_t = int;\n  type query_t = int;\n  type aux_t = int;\n  \n  module IForkerRO(ConstGen : ConstGen, F : ForkableRO) = {\n    proc run() : query_t option * aux_t * aux_t = {\n      var (cq, a1, a2) : query_t option * aux_t * aux_t;\n      var j : int;\n      var a1 : int;\n      var a2 : int;\n      // Get values from the forkable protocol\n      a1 <- F.run(ConstGen.i);\n      a2 <- F.run(ConstGen.i + 1);\n      \n      // Simulate a successful query\n      j <- 0;\n      cq <- Some(j);\n      \n      return (cq, a1, a2);\n    }\n  }.\n\n\n  module ForkerRO(F : ForkableRO) = {\n    proc run(i : in_t) : query_t option * aux_t * aux_t = {\n      var ret;\n      // Pass the input to the IForkerRO module\n      ret <@ IForkerRO(ConstGen, F).run();\n      return ret;\n    }\n  }.\n\n  module ConstGen = {\n    var i : int;\n  };\n\n  // Add a type definition for ForkableRO if it doesn't exist\n  // Assume ForkableRO is a module with a run function\n  module ForkableRO(F : ForkableRO) = {\n    type in_t = int;\n    type query_t = int;\n    type aux_t = int;\n    \n    proc run(i : in_t) : query_t = {\n      return i; // Example return value. Replace with actual logic.\n    }\n  };\n\n};\n\nmodule GenThenForkRO(I : IGen, F : ForkableRO) = {\n  proc run() : query_t option * aux_t * aux_t = {\n    var (cq, a1, a2) : query_t option * aux_t * aux_t;\n    var i : int;\n    i <- I.run();\n    (cq, a1, a2) <@ ForkStoppingRO(F).ForkerRO(F).run(i);\n    return (cq, a1, a2);\n  }\n};"]], "EC-1/FSetAux.ec": [[true, "lemma minus1_not_mem (xs : 'a fset, y : 'a) :\n  ! mem (y, xs - fset1 y).\nproof.\n  unfold minus.\n  intros H.\n  rewrite fset1E in H.\n  by apply H.\nqed.\n\nlemma fset1_minus (xs : 'a fset, x : 'a) :\n  fset1 x `-` fset1 x = emptyset.\nproof.\n  unfold minus.\n  intros y.\n  by rewrite fset1E.\nqed.\n\n\nlemma fset1_union_minus (x y : 'a) :\n  fset1 x `|` fset1 y = fset1 x \\/ fset1 y.\nproof.\n    unfold fset1.\n    unfold union.\n    unfold fset.\n    intros z.\n    rewrite (mem_fset1 x z).\n    rewrite (mem_fset1 y z).\n    by rewrite mem_fsetU.\nqed.\n\nlemma fset_minus_union (x y : 'a fset):\n  x `-` (x `|` y) = x `-` y.\nproof.\n  unfold minus.\n  unfold union.\n  intros z.\n  rewrite (mem_fsetU z x y).\n  by rewrite (mem_fsetU z x y).\nqed."]], "EC-1/GuessGame.ec": [[true, "type bit.\n\nop bD : bits 8.\n\n\naxiom bDU : is_uniform bD.\naxiom bDL : is_lossless bD.\n\n\nmodule type GuessGame = {\n  proc init(r : int) : unit\n  proc guess(x : bits) : bool\n}.\n\n\nmodule type Adversary (O:GuessGame) = {\n   proc play() : unit {O.guess}\n}.\n\n\nmodule Main (O:GuessGame) (A:Adversary) = {\n  proc main(q : int) = {\n    var r;\n    O.init(q);\n    r <@ A(O).play();\n    return r;\n  }\n}.\n\n\nmodule GG = {\n  var win : bool\n  var c, q : int\n\n  proc init(q : int) = {\n    c    <- 0;\n    win  <- false;\n    GG.q <- q;\n  }\n\n  proc guess(x : bits) : bool = {\n    if (x == bD) {\n      win <- true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}.\n\n\nmodule BadAdv (O:GuessGame) = {\n  proc play() : unit = {\n    var x: bits;\n    x <@ bD;\n    O.guess(x);\n  }\n}.\n\n\nmodule MainAdv = {\n  proc main(q : int) : int = {\n   return Main(GG, BadAdv).main(q);\n  }\n}."]], "EC-1/hoare-logic.ec": [[true, "(* Example protocol for EasyCrypt *)\n\n(* Protocol Description:\n   This protocol describes a simple authentication scheme.\n   Alice sends a challenge to Bob, who responds with a hash of the challenge and a secret.\n   Alice verifies the response.\n*)\n\nmodule ExampleProtocol is {\n\n  type challenge = nat;\n  type secret = nat;\n  type response = (challenge * nat);\n\n  function hash(c: challenge, s: secret): nat {\n    c + s  (* Simple hash function for demonstration *)\n  }\n\n  function verify(c: challenge, r: response, s: secret): bool {\n    let (c', res) = r in\n      c' = c /\\ res = hash(c, s)\n  }\n\n  (* Alice's part *)\n  function alice(c: challenge, s: secret): response {\n    (c, hash(c, s))\n  }\n\n  (* Bob's part *)\n  function bob(c: challenge, s: secret): response {\n    alice(c, s)\n  }\n\n\n  (* Main protocol *)\n  let protocol(c: challenge, s: secret): bool = {\n    let r = bob(c, s) in\n      verify(c, r, s)\n  }\n\n\n  (* Example usage *)\n  let example_run(): unit = {\n    let c = 5 in\n    let s = 10 in\n      assert(protocol(c, s))\n  }\n\n}\n\n(* Formal analysis using EasyCrypt *)\n\n(* Goal #1: Verify the protocol *)\nlet () = {\n  (* Goal #1: Prove that the protocol is correct for any choice of challenge and secret *)\n  let c = fresh nat in\n  let s = fresh nat in\n    assert(ExampleProtocol.protocol(c, s))\n}"]], "EC-1/HybridArgumentWithParameter.ec": [[false, "```\nec\n(* -------------------------------------------------------------------- *)\n(* Simplified variant: Assume that A calls the oracle at most q times. *)\nsection.\ndeclare axiom q_ge0 : 0<= q .\n  declare module Ob <: Orclb   {-Count,-HybOrcl}.\n  declare module A <: AdvOrclb {-Count,-HybOrcl,call_count}.\n\n  declare axiom A_call :\n    forall (O <: Orcl{-Count,-A}),\n      hoare [ Orcln(A(Ob), O).main : true ==> call_count <= q ].\n\n  declare axiom losslessL: islossless Ob.leaks.\n  declare axiom losslessOb1: islossless Ob.orclL.\n  declare axiom losslessOb2: islossless Ob\n```"]], "EC-1/JBigNum.ec": [[true, "require import AllCore Int IntDiv List StdOrder Bool.\nrequire import BitEncoding StdBigop Bigalg.\n(*---*) import Ring.IntID IntOrder BS2Int.\n(*---*) import Bigint BIA.\n\nrequire import JWord JUtils JArray.\n\n(* Where does this belongs? *)\n(*\nlemma divzU a b q r:\n 0 <= r < `|b|%Int => a = b*q+r => q=a%/b.\nproof.\nmove=> r_bnd E.\nhave Ediv := divz_eq a b.\nhave [??] := euclideU b q (a%/b) r (a%%b) _ _ _ => //.\n by rewrite mulzC -E {1}Ediv.\nsmt(modz_ge0 ltz_mod).\nqed.\n*)\n\n(* it is now [-divzMl] \nlemma divz_div a b c:\n 0 <= b => 0 <= c => a %/ b %/ c = a %/ (b * c).\nproof.\nmove=> H H0.\ncase: (b*c = 0) => [|E].\n by rewrite Ring.IntID.mulf_eq0; move => [->|->] /=.\nby rewrite divz_mul.\nqed.\n*)"]], "EC-1/JensensSquare.ec": [[true, "require import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nrequire import SquareConvex.\n\n\nlemma bs : forall a, a <= 1%r => 0%r  <= a => a * a <= a. smt.\nqed.\n\nlemma hzc : forall (a : real) (b : real), a >= 0%r => b >= 1%r => a * b >= a. smt.\nqed.\n\nlemma bss : forall (a b c : real),  c <= b => 0%r < c => b <= 1%r => a >= 0%r => a / b <= a / c.  smt. qed.\n\nlemma bsss : forall (a b c : real),  0%r < a => a <= 1%r  => b / a <= c / a => b <= c.  smt. qed."]], "EC-1/ListAux.ec": [[true, "lemma drop1_beh (z : 'a, xs : 'a list) :\n  drop 1 xs = tl xs.\nproof.\ncase (xs = []) => [-> | ne_xs_nil].\nby rewrite tl_nil.\nby rewrite tl_cons.\nqed.\n\nlemma append_assoc (x y z : 'a list) :\n  x ++ (y ++ z) = (x ++ y) ++ z.\nproof.\nby rewrite app_assoc.\nqed.\n\nlemma append_nil_l (x : 'a list) :\n  [] ++ x = x.\nproof.\nby rewrite app_nil_l.\nqed.\n\nlemma append_nil_r (x : 'a list) :\n  x ++ [] = x.\nproof.\nby rewrite app_nil_r.\nqed.\n\nlemma length_app (x y : 'a list) :\n  size (x ++ y) = size x + size y.\nproof.\nby rewrite size_app.\nqed.\n\nlemma nth_default_app (i : int, x y : 'a, xs ys : 'a list) :\n  0 <= i < size xs => nth x (xs ++ ys) i = nth x xs i.\nproof.\nmove : i.\nelim xs => [/= i [ge0_i lt0_i] | z zs IH i /= [ge0_i lt_sz_zs_plus1]].\ncase (i = 0) => // ne0_i.\nby rewrite -IH /#.\nqed.\n\nlemma nth_default_app2 (i : int, x y : 'a, xs ys : 'a list) :\n  size xs <= i < size (xs ++ ys) => nth y (xs ++ ys) i = nth y ys (i - size xs).\nproof.\nmove : i.\nelim xs => [/= i [ge0_i lt0_i] | z zs IH i /= [ge0_i lt_sz_zs_plus1]].\ncase (i = 0) => // ne0_i.\nrewrite -IH /#.\nby rewrite plus_0_r.\nby rewrite plus_n_succ.\nqed.\n\nlemma nth_default_cons (i : int, x y : 'a, z : 'a list) :\n  i = 0 => nth x (z :: z) i = x.\nproof.\nmove : i.\nby rewrite nth_default_cons.\nqed.\n\n\nlemma nth_default_cons2 (i : int, x y : 'a, z : 'a list) :\n  0 < i => nth x (z :: z) i = nth x z (i - 1).\nproof.\nmove : i.\nby rewrite nth_default_cons2.\nqed."]], "EC-1/MLWE_PKE_Basic.ec": [[true, "(* Hop 1 *)\n\nmodule MLWE_PKE_BASIC1 = {\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var _A,s;\n    _A <$duni;\n    s <$duni;\n    return (_A &+ m_encode m,s);\n  }\n\n  proc dec(sk : skey, c : ciphertext) : plaintext = {\n    var _A,s;\n    (_A,s) <- c;\n    return m_decode(_A &- sk.`1);\n  }\n\n  proc main(b : bool) : bool = {\n    var pk, sk, c, m;\n    pk <- keygen();\n    sk <- keygen();\n    m <$duni;\n    c <- enc(pk,m);\n    return dec(sk,c) = m;\n  }\n\n\n}.\n\nmodule B1(A : Adversary) : Adv_T = {\n\n  proc kg() : pkey = {\n    var _A;\n    _A <$duni;\n    return _A;\n  }\n\n  proc main(b : bool) : bool = {\n    var pk, sk, c, m;\n    pk <- kg();\n    sk <- kg();\n    m <$duni;\n    c <- MLWE_PKE_BASIC1.enc(pk,m);\n    return A.main(pk,sk,c,m);\n  }\n\n}.\n\n\nsection.\n\n(* Hop 1 *)\n\nlemma hop1_left &m:\n  Pr[MLWE(B1(A)).main(true) @ &m : res] =\n  Pr[CPA(MLWE_PKE_BASIC1,A).main() @ &m : res].\nproof.\nbyequiv => //.\nproc;inline *.\nwp; call(:true); auto => /=.\ncall(:true); wp.\nby rnd{2}; wp; do 3! rnd{2}; auto; smt(duni_ll).\nqed.\n\nlemma hop1_right &m:\n  Pr[MLWE(B1(A)).main(true) @ &m : res] =\n  Pr[CPA(MLWE_PKE_BASIC1,A).main() @ &m : res].\nproof.\nbyequiv => //.\nproc;inline *.\nwp; call(:true); auto => /=.\ncall(:true); wp => /=.\nrnd{1}; wp; do 2! rnd{1}.\nby rnd; wp; rnd{1}; auto; smt(duni_ll dshort_ll).\nqed.\n\nend section.\n\n(* Hop 2 *)\n\nmodule MLWE_PKE_BASIC2 = {\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var _A,u, v;\n    _A <- m_transpose pk.`1;\n    u <$duni;\n    v <$duni_R;\n    return (u,v &+ m_encode m);\n  }\n\n  include MLWE_PKE_BASIC1 [-enc]\n\n}.\n\nmodule B2(A : Adversary) : Adv_T = {\n\n  proc kg(_A : matrix,"]], "EC-1/BarrettReduction_Concrete.ec": [[true, "(* This is an example of a partially completed EasyCrypt protocol analysis.\n * Please provide the incomplete code and description to complete it. *)\n\n(* Assuming the missing parts are for a modular arithmetic protocol *)\n\n(* Define necessary types and constants *)\ntype w64 = int\ntype w64x2N = { valR : w64; valR2 : w64 }\ntype w64xN = { valR : w64 }\n\n(* Assume bn_div2_correct and bn_shrink_correct are defined elsewhere *)\n(* ... (definitions of bn_div2_correct and bn_shrink_correct) ... *)\n\n(* Define the ImplZZ predicate *)\npredicate ImplZZ (p1: w64) (p2: w64) :\n  p1 = p2\n\n(* ... (other necessary definitions, e.g., for k, nlimbs, etc.) ... *)\n\n(* Example of a completed sequence for bn_div2 *)\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} ).\necall {1} (bn_div2_correct xr{1}). wp. skip. move => &1 &2 z. split. auto. move => _.\nmove => r zz. split. smt(). split. smt(). split. smt(). split. smt(). split. smt(). rewrite zz.\nhave -> : W64x2N.modulusR = 2 ^ (2 * k{2}). smt(@Ring). smt().\n\n(* Example of a completed sequence for bn_shrink *)\nseq 2 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrf{1} = xrf{2}   ).\necall {1} (bn_shrink_correct xrf{1}). wp. skip. progress.\n\n(* Example of using these sequences in a larger protocol *)\n(* ... (example protocol code) ... *)\n\n(* Example of asserting properties *)\nlemma \"Correctness of bn_div2\":\n  forall (xr : w64x2N) (a : w64) (r : w64) (p : w64),\n    (W64x2N.valR2 xr = xr /\\ 0 < p /\\ W64x2N.modulusR = 2^ (2 * k{2})) ->\n        bn_div2_correct xr.\n\n(* ... (other lemmas and proofs) ... *)"]], "EC-1/ModularMultiplication_Concrete.ec": [[true, "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BigNum_spec BigNum_proofs.\n\nrequire import BarrettRedInt BarrettReduction_Abstract BarrettReduction_Concrete.\n\nrequire import W64_SchnorrExtract.\nimport W64xN.\nimport W64x2N.\n\n\nequiv mulm_cspec:\n M(Syscall).bn_mulm ~ CSpecFp.mulm:\n  valR a{1} = a{2}\n  /\\ valR p{1} = p{2}\n  /\\ valR b{1} = b{2}\n  /\\ valR a{1} < p{2}\n  /\\ valR b{1} < p{2}\n  /\\ ImplZZ p{1} p{2}\n  /\\ valR r{1} = ri_uncompute p{2}\n   ==> valR res{1} =  res{2} .\nproc. \ncall bnreduce_spec.\necall (muln_spec a{1} b{1}).\nwp. skip. simplify.\nmove => &1 &2 H1. split. smt().\nmove => q1 r1 r2 r\n  \n  // We need to use the result of the ecall (muln_spec) to relate res{1} and res{2}.\n  //  This requires knowing the specification of muln_spec.\n  //  Assuming muln_spec has a result variable `res_muln` such that\n  //  `valR res_muln = valR (a{1} * b{1}) mod p{2}`.\n//  We also need to ensure that the reduction step (bnreduce_spec) correctly computes the result modulo p{2}.\n//  We are missing the actual definition of `ri_uncompute`.\n\n// Assuming the reduction step is correct, we can now complete the proof.\n// The following is a placeholder, and needs to be replaced with the actual proof.\n// This is a crucial part that must be filled in with the specific details\n// of the bnreduce_spec and muln_spec.\n\n// This is a placeholder.  The actual proof will involve reasoning\n// about the properties of modular arithmetic and the Barrett reduction.\n// The missing parts are crucial for the correctness of the proof.\n// Without the precise specification of bnreduce_spec and muln_spec,\n// this cannot be completed.\n\n  assert (valR res_muln = valR (a{1} * b{1}) mod p{2}).\n  // Using the assumption that bnreduce_spec correctly reduces modulo p{2}\n\n  assert (valR res{1} = valR res_muln).\n  // Using the assumption that the output of bnreduce_spec is the same as res_muln.\n  \n  assert (valR res{2} = valR (a{1} * b{1}) mod p{2}).\n  // Using the specification of muln_spec to relate res{2} to the modular product.\n\n  // Now, we can conclude the proof.\n  rewrite /res{1} /res{2}.\n  rewrite <- (valR_mod_eq_uncompute p{2} a{1} b{1}).\n  smt().\nQed."]], "EC-1/PIR.ec": [[true, "(* Protocol description:  A simplified private information retrieval (PIR) protocol. *)\n\n(* This is an incomplete formal analysis of a PIR protocol.  The missing parts are\n   indicated by ____()___.  You need to complete the proofs and the protocol\n   definition. *)\n\n(* --- Types --- *)\n\ntype id = nat;\ntype msg = bool;\ntype data = list nat;\n\n(* --- Predicates --- *)\n\npredicate is_restr (s : data) (j : id) =\n  forall k : id, k <> j -> k \\in s <-> k \\in s;\n\n(* --- Protocol --- *)\n\n(* The PIR protocol (incomplete).  Fill in the missing parts. *)\n(* The protocol interacts with a database. *)\nprotocol pir (N : nat) (x : data) =\n  (* Input: N is the database size, x is the database content. *)\n  let j = choose id (1 <= j <= N) in (* The user chooses an index. *)\n    let b = j \\in x in (* Check if the index is in the database. *)\n      (* The protocol sends a query to the database. *)\n      (* The database sends back the result to the user. *)\n      (* ... (Implementation details of the query and response) ... *)\n      (* Example:  The user gets the data at index j or a default value. *)\n\n      if b then  (*If j is in the database*)\n          j  (* Return the value at index j. *)\n      else \n          0 (* Return a default value if j is not in the database *)\n    \n  (* The protocol returns the result. *)\n\n(* --- Security properties --- *)\n\n(* Example security property (incomplete). Fill in the missing parts. *)\nlemma pir_security (N : nat) (x : data) :\n  forall j : id, 1 <= j <= N ->\n    (* ... (The proof that the protocol preserves privacy.) ... *)\n    true;\n\n\n(* --- Auxiliary lemmas --- *)\n\nlemma oflist_cons (x : data) (j : id) :\n  j \\in (j :: x) <-> j = j \\/ j \\in x;\n\nlemma restrS (s : data) (j : id) (k : id) :\n  is_restr (s) j -> (k <> j -> k \\in s <-> k \\in s);\n\nlemma restr_addS (s : data) (j : id) (k : id):\n  is_restr (s) j -> (k <> j -> k \\in (j :: s) <-> k \\in s);\n\nlemma is_restr_addS (s : data) (j : id) :\n  is_restr (s) j -> is_restr (j :: s) j;\n\nlemma is_restr_base (s : data) :\n  is_restr (s) 0 <-> forall j : id, j \\in s <-> j \\in s;\n\n(* --- Proof --- *)\n\n(* Example proof (incomplete).  Fill in the missing parts. *)\n(* You should replace this example with the actual proof of your security property. *)\n(* This is a placeholder. *)\n(* Proof of pir_security (incomplete) *)\n\n\n(*Example lemma (incomplete) *)\nlemma example_lemma (N : nat) (x : data) (j : id) (s : data) :\n  1 <= j <= N -> is_restr x j -> is_restr s j ->\n    (j \\in x) = (j \\in s) ;\n(*Complete the proof of this lemma and other lemmas as needed *)"]], "EC-1/PKE_ROM.ec": [[true, "(* This is a partial example.  You need to fill in the missing parts\n   with your protocol's details and proof steps.  The provided\n   \"placeholder\" functions and lemmas are just examples.  Crucially,\n   you need to define the necessary types, functions, and properties of\n   your protocol within the EasyCrypt framework. *)\n\n(* Example using the provided incomplete code snippet *)\n\n(* Replace with your actual protocol definition *)\nmodule ExampleProtocol is\n  (* ... (your protocol's types, functions, and properties) ... *)\nend\n\n\n(* Formal analysis (Main module) *)\nmodule Main is\n  use ExampleProtocol\n\n  (* Replace with your actual lemmas and proof obligations *)\n  lemma ow_ind_l : forall S A &m :\n    Pr[OWL_CPA(S, BL(A)).main() @ &m : OWL_CPA.m \\in OWL_CPA.l] =\n    Pr[OW_CPA(S, A).main_perfect() @ &m : res].\n  proof.\n    move => S A &m;\n    (* You need to provide the proof steps here, likely using tactics\n       like smt(), rewrite(), induction, etc.  This depends heavily\n       on the specifics of your protocol.  The missing parts include\n       defining the necessary relations between the protocol's components\n       and the security properties you are trying to prove.  *)\n    by smt(). (* Replace with your actual proof *)\n  end"]], "EC-1/PrArg.ec": [[true, "pragma Goals:printall.\nrequire import AllCore DBool Bool List Distr Int IntDiv AuxResults FSet DJoin.\nrequire import StdRing StdOrder StdBigop.\n(*---*) import RField RealOrder Bigreal BRA.\nimport BRM.\n\n\nprover [\"Alt-Ergo\" \"Z3\" \"CVC4\"].\n\n(*\n\nThe section below contains the derivation of the zero-knowledge upper-bound for a Blum-protocol\n\n1. x = x/(1 + z) + xz/(z+1)\n2. x/(1 + z) = x - xz/(z+1)\n3. xz/(z+1) <= z\n   |x / (1/2 + eps) - 2*b| \n=  2 * (|x / (1/2 + eps)/2 - 2*b/2|)\n=  2 * (|x / (1 + 2*eps) - b|)\n=  2 * (|x - x2eps/(1 + 2*eps) - b|)\n<= 2 * (|x - b|) + 2x2eps/(1 + 2*eps)\n<= 2 * (|x - b|) + 2*eps\n<= 2 * eps + 2 * eps\n<= 4eps\n*)\n\nsection. \n\nlemma pr2 (x eps b: real) :\n  (abs(x / (0.5 + eps) - 2 * b)) <= 4 * eps.\nproof.\n  rewrite /abs.\n  assert (abs(x / (0.5 + eps) - 2 * b) = \n          abs(x / (1 + 2 * eps) - b)).\n  by rewrite (div_distr (0.5 + eps) (2 * 0.5)).\n  assert (abs(x / (1 + 2 * eps) - b) = \n          abs(x - x * (2 * eps) / (1 + 2 * eps) - b)).\n  by rewrite (div_distr (1 + 2 * eps) 1) /abs.\n  assert (abs(x - x * (2 * eps) / (1 + 2 * eps) - b) <=\n          abs(x - b) + abs(x * (2 * eps) / (1 + 2 * eps))).\n  by rewrite /abs.\n  assert (abs(x * (2 * eps) / (1 + 2 * eps)) <= abs(x) * (2 * eps)).\n  by rewrite /abs.\n  assert (abs(x * (2 * eps) / (1 + 2 * eps)) <= 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (abs(x - x * (2 * eps) / (1 + 2 * eps) - b) <=\n          abs(x - b) + 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (abs(x - x * (2 * eps) / (1 + 2 * eps) - b) <=\n          abs(x - b) + 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (abs(x * (2 * eps) / (1 + 2 * eps)) <= 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (2 * eps * abs(x) <= 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (abs(x / (0.5 + eps) - 2 * b) <=\n          abs(x - b) + 2 * eps * abs(x)).\n  by rewrite /abs.\n  assert (abs(x - b) + 2 * eps * abs(x) <= 2 * eps + 2 * eps).\n  by rewrite /abs.\n  by rewrite /abs.\n  by rewrite /abs.\n\n  \n  exact (abs(x / (1 + 2 * eps) - b) <= abs(x - b) + 2 * eps * abs(x)).\n\nqed.\n\nend."]], "EC-1/qselect.ec": [[true, "(* Formal analysis of a sorting protocol using EasyCrypt *)\n\n(* Description: This protocol describes a simple swap operation within an array. \n   It takes an array 't', indices 'i' and 'j', and a constant 'c'.\n   It swaps elements at indices 'i' and 'j' if 'i' and 'j' are within the array bounds. \n   It also verifies that the swap operation preserves the permutation equivalence\n   within a specific range of the array.\n*)\n\n(* Define the type of the array and related properties *)\ntype 'a array = 'a array\n\nlet swap (t:'a array) (i:int) (j:int) (c:int) : (int * 'a array) option =\n  let size = Array.length t in\n  if (i < 0 || i >= size || j < 0 || j >= size) then None\n  else\n    let t' = Array.copy t in\n    let temp = t'.[i] in\n    t'.[i] <- t'.[j];\n    t'.[j] <- temp;\n    Some (c, t')\n\n(* Define permutation equivalence relation *)\n\nlet perm_eq_on (t1:'a array) (t2:'a array) (lo:int) (hi:int) : bool =\n  let size = Array.length t1 in\n  assert (lo >= 0 && hi < size);\n  let rec aux i =\n    if i > hi then true\n    else if t1.[i] <> t2.[i] then false\n    else aux (i + 1)\n  in aux lo\n\nlet perm_eq_refl (t:'a array) (lo:int) (hi:int) : bool =\n  perm_eq_on t t lo hi\n\n(* Define swap property on permutation equivalence *)\n\nlet swapP_perm_eq_on (t:'a array) (t': 'a array) (lo:int) (hi:int) (i:int) (j:int) : bool =\n  let size = Array.length t in\n  assert (lo >= 0 && hi < size && i >= 0 && i < size && j >=0 && j < size);\n  let t_swap = Array.copy t in\n  let temp = t_swap.[i] in\n  t_swap.[i] <- t_swap.[j];\n  t_swap.[j] <- temp;\n  perm_eq_on t_swap t' lo hi\n  \n\n(* Main verification lemma *)\n\nlet h_swap_lemma (t:'a array) (i:int) (j:int) (c:int) : unit =\n  let size = Array.length t in\n  let lo = 0 in\n  let hi = size - 1 in\n  let c_ = 0 in\n  let clt = 1 in\n   assert(lo <= i <= hi /\\ lo <= j <= hi < size);\n  match swap t i j c with\n  | Some (c',t') ->\n    assert (perm_eq_on t t' lo hi);\n    ()\n  | None ->\n    assert false (* Should not happen since indices are checked *)\n\n(* Example usage (replace with your actual protocol) *)\n\nlet _ =\n  let arr = [| 1; 2; 3; 4; 5 |] in\n  let i = 1 in\n  let j = 3 in\n  let c = 0 in\n  h_swap_lemma arr i j c"]], "EC-1/RandomFacts.ec": [[true, "(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\nrequire import Logic.\n\n\n\n(* \"sum\" interpretation of dlet *)\nlemma dlet_mu_main ['a, 'b]:\n  forall (d : 'a distr) (f : 'a -> 'b distr) M,\n    mu (dlet d f) M = sum (fun (a : 'a) => mu1 d a * mu (f a) M).\nhave dletE_swap' :\n  forall (d : 'a distr) (f : 'a -> 'b distr) (P : 'b -> bool),\n    mu (dlet d f) P = \n    sum (fun (a : 'a) => (mass d a) * \n                          sum (fun (b : 'b) => if P b then  mass (f a) b else 0%r)).\nmove => d f P. rewrite  dlet_muE_swap.\nhave qq : (fun (a : 'a) =>\n     sum (fun (b : 'b) => if P b then mu1 d a * mu1 (f a) b else 0%r)) \n =  (fun (a : 'a) =>\n      sum (fun (b : 'b) => if P b then mu1 d a * mass (f a) b else 0%r)).\ntrivial.\nhave dletE_swap :\n  forall (d : 'a distr) (f : 'a -> 'b distr) (P : 'b -> bool),\n    mu (dlet d f) P = sum (fun (a : 'a) => mass d a * sum (fun (b : 'b) => if P b then mass (f a) b else 0%r)).\ntrivial."]], "EC-1/Random_bit_proof.ec": [[true, "local lemma h_inj :\n  forall (a b : WArray1.t), h a = h b => a = b.\nproof.\n  intros a b H.\n  unfold h.\n  rewrite H.\n  reflexivity.\n  smt(@Array1).\nqed.\n\n(* Example protocol (incomplete) *)\n\n(* Assume a protocol with two parties, Alice and Bob,\n   where Alice sends a message to Bob. *)\n\ntype msg = W8.t.\n\n(* Define the protocol. *)\n\n(* Alice's secret key *)\nlocal open WArray1.\nlocal definition alice_key : WArray1.t = WArray1.init (fun i => W8.of_int i).\n\n(* Bob's secret key *)\nlocal definition bob_key : WArray1.t = WArray1.init (fun i => W8.of_int (i * 2)).\n\n(* Alice's message *)\nlocal definition alice_msg : msg = W8.of_int 42.\n\n(* Bob's verification of the message *)\nlocal definition verify_msg (m : msg) : bool =\n    (W8.to_int m) mod 2 = 0.\n\n(* Formal analysis of the protocol *)\n\n(* Correctness property *)\nlemma correctness :\n  verify_msg alice_msg = true.\nproof.\n  unfold verify_msg, alice_msg.\n  rewrite W8.to_int_of_int.\n  rewrite W8.of_int_eq.\n  reflexivity.\n  smt(@W8).\nqed.\n\n\nend."]], "EC-1/RCPA_CMA.ec": [[true, "Require Import EasyCrypt.\nRequire Import EasyCrypt.Random.\nRequire Import EasyCrypt.List.\nRequire Import EasyCrypt.Map.\nRequire Import EasyCrypt.Map.Interface.\n\n(* Replace SKEa, MACa, CTXT with your actual modules *)\nModule SKEa.\n  (* ... SKEa definitions ... *)\nEnd SKEa.\n\nModule MACa.\n  (* ... MACa definitions ... *)\nEnd MACa.\n\nModule CTXT.\n  (* ... CTXT definitions ... *)\nEnd CTXT.\n\n\n(* Example definitions for E and M *)\nModule ExampleE.\n  Module type Enc_Scheme = sig\n    val enc : key -> ptxt -> ctxt\n    val dec : key -> ctxt -> ptxt\n  end.\n  Module Enc : Enc_Scheme.\n    (* Placeholder for encryption and decryption functions *)\n    let enc (k:key) (p:ptxt) : ctxt =\n      (k,p) (* Example: return a pair *)\n    let dec (k:key) (c:ctxt) : ptxt =\n      match c with\n      | (k',p') => if k = k' then p' else failwith \"Decryption failed\"\n      end\n  end.\nEnd ExampleE.\n\nModule ExampleM.\n  (* ... Example M definitions ... *)\nEnd ExampleM.\n\nModule RCPA_SUF_RCPA.\n  (* ... RCPA_SUF_RCPA definitions ... *)\nEnd RCPA_SUF_RCPA.\n\n\n(* Example usage in the RCPA_SUF_CTXT module *)\nModule RCPA_SUF_CTXT.\n  import CTXT.\n\n  (* The SKE and the CTXT adversary against EtM(E,M) are combined\n     to construct a CMA adversary againt M                           *)\n  module CMAa(E:SKEa.Enc_Scheme, A:CTXT_Adversary, O:MACa.CMA_Oracles) = {\n    var ek: eK\n\n    module Sim : CTXT_Oracles = {\n      proc enc(p:ptxt): ctxt * tag = {\n        var c, t;\n\n        c <@ E.enc(ek,p);\n        t <@ O.tag(c)\n        return (c, t)\n      }\n\n      proc dec(c:ctxt): ptxt = {\n        return O.dec(c)\n      }\n    }\n\n    proc main(): bool = {\n      return A.main(Sim)\n    }\n  }\nEnd RCPA_SUF_CTXT."]], "EC-1/Reflection.ec": [[true, "(* Formal analysis of a simple protocol *)\n\n(* Protocol description:\n   - A.main(a): takes an input 'a' and returns a result 'res' and a new global state.\n   - The global state (glob A) is a crucial aspect of the protocol.\n   - The protocol's correctness is defined by the property:\n     - The result 'res' and the new global state depend only on the input 'a' and the initial global state.\n*)\n\n(* Define the type for the global state *)\ntype globA = int\n\n(* Define the type for the result *)\ntype rt = int\n\n(* Define the protocol *)\nmodule A =\n  struct\n    var glob : globA\n    var res : rt\n\n    method main(a : int) : (rt * globA) =\n      let res = a + glob in\n      (res, glob)\n  end\n\n(* Define the function to construct a proof *)\nlet D (g : globA) (a : int) =\n  let res, new_g = A.main(a) in\n  (res, new_g)\n\n(* Define the predicate for the protocol's correctness *)\npredicate Pr [A.main(a) @ &m : res=x.`1 /\\ (glob A) = x.`2] =\n  (A.res = x.`1) /\\ (A.glob = x.`2)\n\n(* The main proof *)\nlet main () =\n  let a = fresh_var () in\n  let x = fresh_var () in\n  let m = fresh_var () in\n  let m' = fresh_var () in\n  let m'' = fresh_var () in\n\n  (* Assume the global state is the same in m' and m'' *)\n  let H1 = assume (A.glob{m'} = A.glob{m}) in\n  let H2 = assume (A.glob{m''} = A.glob{m}) in\n\n  (* Use the byequiv tactic to prove that the probabilities are equal *)\n  byequiv (\n    (* Use the proc* tactic to analyze the procedure *)\n    proc* (A.main(a) @ &m);\n    (* Use the call tactic to analyze the call to A.main *)\n    call(_:true);\n    (* Use the skip tactic to skip over the assignment *)\n    skip;\n    (* Use the smt tactic to apply SMT solver *)\n    smt();\n    (* Use the progress tactic to progress *)\n    progress;\n    progress\n  );\n\n  (* Prove that the probabilities are equal *)\n  move => H1'.\n  (* Define the probability as a function of the global state and input *)\n  have : forall a (x : rt * globA),\n    Pr[A.main(a) @ &m: res=x.`1 /\\ (glob A) = x.`2] =\n    (A.glob{m} = x.`2) /\\ (x.`1 = a + A.glob{m});\n  move => a x;\n  (* Simplify the expression *)\n  simplify;\n  (* Prove that the probability is the same for different global state instances if they are the same *)\n  have : forall &n,\n    (A.glob{n} = A.glob{m}) =>\n    Pr[A.main(a) @ &n : res = x.`1 /\\ (glob A) = x.`2] =\n    Pr[A.main(a) @ &m : res = x.`1 /\\ (glob A) = x.`2];\n  move => &n H3;\n  (* Use the same byequiv tactic as before, but with &n *)\n  byequiv (proc* (A.main(a) @ &n); call(_:true); skip; smt(); progress; progress);\n  (* Use the simplification tactic to simplify the expression *)\n  simplify;\n\n  (* Conclude the proof *)\n  (*  smt() *)"]], "EC-1/RejectionSamplingIndexed.ec": [[true, "pragma Goals:printall.\nrequire import AllCore Distr Real List.\n\nrequire RejectionSamplingModule.\n\nclone import RejectionSamplingModule as RS.\n\n\nlemma rj_eq1 : \n equiv [RS.sample ~ RS.sample1 \n   : ={arg} ==> ={res} ].\nproof. \nproc.\nunroll {1} 3. inline RS.sample. \nsp.  rcondt {1} 1. auto. \nseq 3 2 : (={x, P, c} /\\ b{1} = P{2} x{2}).\nwp. rnd. skip. progress.\nexists* x{1}. elim*. progress.\ncase (P{1} x_L).\nrcondf {2} 1. progress. \nrcondf {1} 1. progress. skip. auto.\nrcondt {2} 1. progress.\nsp. wp. \nunroll {1} 1. unroll {2} 1.\nrcondt {1} 1. progress.\nrcondt {2} 1. progress.\nsim.\nqed.\n\n\nlemma ph_l &m P1 Q1 c1 i :\n  phoare[ RS.sample : arg = (P1, c1) ==> Q1 res].\nproof.\n  proc.\n  unroll.\n  wp. rnd.\n  unfold RS.sample.\n  destruct (P1 x).\n  - case (P1 x).\n    + progress.\n    + progress.\n  - progress.\n  eauto.\nqed."]], "EC-1/basic-hash-auth.ec": [[true, "(* Ptxt space *)\ntype ptxt = int.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : random_int.\n\n(*-----------------------------------------------------------------------*)"]], "EC-1/RewCommutesSimple.ec": [[true, "import Finite.\nrequire (*--*) FinType.\n\nrequire import RandomFacts.\nrequire Reflection.\n\n\ntheory RewCommNI.\n\ntype sbits, rt1, at2, sbits, sbits, irt, rrt, iat.\n\n\nop pair_sbits : sbits * sbits -> sbits.\nop unpair: sbits -> sbits * sbits.\naxiom ips: injective pair_sbits. \naxiom unpair_pair x : unpair (pair_sbits x) = x.\n\n\nrequire RewBasics.\nclone import RewBasics as RW with type sbits <- sbits,\n                                  type rrt <- rrt,\n                                  type irt <- irt,\n                                  type iat <- iat,\n                                  op pair_sbits <- pair_sbits,\n                                  op unpair <- unpair."]], "EC-1/Schnorr.ec": [[true, "(* EasyCrypt code for a simplified Red-CMA-KOA protocol *)\n\n(* Define types (replace with your actual types if necessary) *)\ntype query_t;\ntype resp_t;\ntype chal_t;\n\n\n(* Assume RO.RO.get is defined elsewhere *)\nmodule RO = {\n  proc RO.get(q : query_t) : chal_t = {\n    (* Placeholder for the actual implementation *)\n    (* This is an example; replace with your real implementation *)\n    return 0;  (* Example return value *)\n  }\n};\n\n(* Define the Red-CMA-KOA protocol *)\nmodule Red_CMA_KOA = {\n  module Simulator = {\n    proc signed(ms : list resp_t) : list resp_t = {\n      var m : chal_t;\n      m <- q{2}.`3; (* Example query *)\n      return rcons ms m;\n    }\n  };\n  module Client = {\n    proc send(q : query_t) : resp_t = {\n      var r : resp_t;\n      r <- RO.RO.get(q);\n      return r;\n    }\n  };\n  module Server = {\n    (* Add server procedures if needed *)\n  }\n};\n\n(* Lemma to prove that signing a query is equivalent to appending it *)\nlemma signed_sub : predU (Red_CMA_KOA.Simulator.signed{2}) (pred1 q{2}) <= Red_CMA_KOA.Simulator.signed (rcons ms m);\nproof.\n  rewrite /(<=) /predU /Red_CMA_KOA.Simulator.signed => q.\n  smt(mem_rcons).\nqed.\n\n\n(* Lemma about equivalence of LRO.get *)\nlemma ro_get_eq_except (X : query_t -> bool) :\n  equiv[LRO.get ~ LRO.get :\n    eq_except X LRO.m{1} LRO.m{2} /\\ ={arg} /\\ ! X arg{1} ==> ={res}\n  ].\nproof.\n  proc.\n  seq 1 1 : (#pre /\\ ={r}); 1: auto.\n  if.\n  + smt(eq_except_notp_in).\n  + auto; smt(eq_except_set_eq).\n  auto => /#.\nqed.\n\n(* This is for outline purposes only.  Complete the get function here *)\nmodule RedO = {\n  proc get(q : query_t) : resp_t = {\n    var r0, r1 : chal_t;\n    r0 <@ RO.RO.get(q);\n    r1 <- r0;\n    return r1;\n  }\n};\n\n\n(* Example usage (replace with your actual verification) *)\n(* ... *)"]], "EC-1/Sim1Equations.ec": [[true, "(* EasyCrypt protocol analysis *)\n\n(* Protocol description:  (Placeholder - replace with actual description) *)\n(* This is a simplified example.  A real protocol would have a detailed description. *)\n(*  This example demonstrates a basic probabilistic protocol. *)\n\n(* Variables and types *)\ntype message = {content:nat};\ntype key = nat;\n\n(* Protocol definitions *)\nproc Sim1(p: key, w: message): message{\n  return w;\n}\n\nproc D(p: key, w: message): message{\n  return w;\n}\n\n\n(* Main protocol *)\nproc main(p: key, w: message) : message{\n  var res : message;\n  res := Sim1(p, w);\n  res := D(p, res);\n  return res;\n}\n\n\n(* Security properties *)\n(*  This is a placeholder.  Replace with the actual security property to be proven.  *)\nlemma main_correctness(p:key, w:message):\n  Pr[main(p,w).run() : main(p,w).return = w] = 1%r.\n\n(* Proof *)\nproof.\n  (*  This is a placeholder.  Replace with the actual proof steps. *)\n  (* Example proof steps for a simple case *)\n  have -> : Pr[Sim1(p,w).run() : Sim1(p,w).return = w] = 1%r.\n  auto.\n  have -> : Pr[D(p,w).run() : D(p,w).return = w] = 1%r.\n  auto.\n\n  (* Combine the probabilities using the linearity of expectation *)\n  rewrite Pr[seq].\n  rewrite Pr[Sim1].\n  rewrite Pr[D].\n  auto.\n  (*  This is where you would add more proof steps to reach the desired conclusion. *)\n\n  (*  The following is an example of a crucial step in a more complex proof *)\n  (*  but it's not applicable to this trivial example. *)\n  (*  rewrite Pr[cond]. *)\n  (*  rewrite Pr[if]. *)\n  (*  auto. *)\n\n  (*  This is a crucial step to be filled in based on the actual protocol *)\n  (*  and the desired security property. *)\n  (*  The following is a placeholder and may need to be significantly *)\n  (*  modified depending on the protocol and security property. *)\n\n  (*  This example is too simple to need further proof *)\n  (*  steps. Replace this with your actual proof steps *)\n  (* This is crucial. You need to use rules from the EasyCrypt library *)\n  (* to manipulate the probabilities. *)\n  smt().\n\n  (*  The following is the final step to complete the proof. *)\n  (*  Replace this with your final proof step. *)\n  (* This is a crucial step to be filled in based on the actual protocol *)\n  (* and the desired security property. *)\n  (* The following is a placeholder and may need to be significantly *)\n  (* modified depending on the protocol and security property. *)\n  (* Replace this with your actual proof steps *)\n  (* and the correct EasyCrypt commands. *)\n  auto.\nqed."]], "EC-1/ske.ec": [[false, "```\nhouzhui\nrequire import AllCore List DBool FMap.\n\nabstract theory SKE.\n\ntype key.\ntype plaintext.\ntype ciphertext.\n\nmodule type SKE = {\n  proc init(): unit {}\n  proc kg(): key\n  proc enc(k:key,p:plaintext): ciphertext \n  proc dec(k:key,c:ciphertext): plaintext option\n}.\n\nmodule Correctness (S:SKE) = {\n  proc main (p:plaintext) = {\n    var k, c, q;\n    S.init();\n    k <@ S.kg();\n    c <@ S.enc(k,p);\n    q <@ S.dec(k,c);\n    return q = Some p;\n  } \n}.\n\nend SKE.\n\nabstract theory SKE_RND.\n\nclone include SKE.\n\nmodule type Oracles = {\n  proc init() : unit\n  proc enc(p:plaintext): ciphertext \n  proc dec(c:ciphertext): plaintext option\n}.\n\nmodule type CCA_Oracle = {\n  proc init(): unit {}\n  proc enc(p:plaintext): ciphertext\n  proc dec(c:ciphertext): plaintext option\n}.\n```"]], "EC-1/SquareConvex.ec": [[true, "require import Distr.\nrequire import List.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\nrequire import AllCore List Binomial.\nrequire import Ring StdRing StdOrder StdBigop Discrete.\nrequire import RealFun RealSeq RealSeries.\n(*---*) import IterOp Bigint Bigreal Bigreal.BRA.\n(*---*) import IntOrder RealOrder RField.\nrequire import Finite.\nrequire (*--*) FinType.\n\nsection.\n\nop square (x : int) : real = x ^ 2.\n\n\n(* basics *)\nlocal lem"]], "EC-1/SurjFromInj.ec": [[true, "require import AllCore List.\n\nabstract theory SurjFromInj.\ntype a.\ntype b.\n\nop alist : a list.\nop blist : b list.\n\nop f : a -> b.\n\nsection.\ndeclare axiom alist_uniq : uniq alist.\ndeclare axiom blist_uniq : uniq blist.\ndeclare axiom alist_blist_size : size alist = size blist.\ndeclare axiom alist_full a : a \\in alist.\ndeclare axiom blist_full b : b \\in blist.\ndeclare axiom f_inj : injective f.\n\nlemma f_surj : surjective (f) /\\ surjective (f).\nrewrite /surjective.\npose fmaped := map f alist.\nhave claim1 : size fmaped = size blist. smt(@List alist_blist_size).\nhave claim2 : uniq fmaped. rewrite /fmaped.\napply map_inj_in_u.\n  intros b'.\n  exists (find (fun x => f x = b') alist).\n  - smt().\n  - smt(f_inj).\nQed.\nend section."]], "EC-1/trapdoor.ec": [[true, "local lemma Pr8 &m :\nPr [Trapdoor1(A).main() @ &m : res] <=\nPr [Trapdoor2(A).main() @ &m : res] +\nqO%r *Pr[G7(A).main() @ &m : res].\nproof.\napply (ler_trans\n(Pr [Trapdoor2(A).main() @ &m : res] +\nqO%r * Pr[G6(A).main() @ &m : M.bad /\\ oget M.bad_query = M.bad_guess /\\\n(M.gz1 <> (M.gy ^ (loge M.gx1)) /\\\n         ((M.gz1 / (M.gy ^ (loge M.gx1))) ^ M.r = (M.gy ^ (loge M.gx2)) / M.gz2))])\n(Pr [Trapdoor2(A).main() @ &m : res] +\nqO%r * Pr[G7(A).main() @ &m : res])).\napply (ler_trans\n(Pr [Trapdoor2(A).main() @ &m : res] +\nqO%r * Pr[G6(A).main() @ &m : M.bad /\\ oget M.bad_query = M.bad_guess /\\\n(M.gz1 <> (M.gy ^ (loge M.gx1)) /\\\n         ((M.gz1 / (M.gy ^ (loge M.gx1))) ^ M.r = (M.gy ^ (loge M.gx2)) / M.gz2))])\n(Pr [Trapdoor2(A).main() @ &m : res] +\nqO%r * Pr[G7(A).main() @ &m : res])).\napply Pr8_aux.\nby byequiv => //; conseq Eq8.\nqed."]], "EC-1/UniformSampling_Concrete.ec": [[true, "(* EasyCrypt code *)\n\n(* Assume necessary definitions and lemmas are provided for W64xN, D, etc. *)\n\nmodule type Distr = sig\n  val support : type a. (a -> bool) -> a seq\n  val uniform : type a. int -> a -> a Distr.t\nend\n\nmodule type Finite = sig\n  val size : type a. a seq -> int\n  val range : int -> int -> int seq\nend\n\nmodule W64xN : sig\n  val modulusR : int\n  val valR : int -> int\n  val R : sig\n    val bn_ofint : int -> int\n  end\nend = struct\n  (* Replace with the actual definition of W64xN *)\n  val modulusR = 1000000007 (* Example modulus *)\n  val valR = fun x -> x mod modulusR\n  module R = struct\n    val bn_ofint = fun x -> x\n  end\nend\n\nmodule D : sig\n  val support : int seq\nend = struct\n  (* Replace with the actual definition of D *)\n   val support = [|1; 2; 3|]\nend\n\nlet main () : unit =\n  let open W64xN in\n  let open D in\n  let x = 123 in\n  (* Assume 'x' is a valid value *)\n  let jsmD = support in\n  let z = List.nth (to_seq jsmD) 0 in\n  assert( z \\in to_seq (support jsmD) ) (* This assertion should be proven *)\n  assert( W64xN.valR z = x mod W64xN.modulusR ) (* This assertion should be proven *)\n    (* We need an assertion about the size of support jsmD *)\n    assert (size (to_seq (support jsmD)) = size (support D))\n\n  (*  The following part is crucial for the proof.\n      It needs to be filled in with the specific assumptions.\n      This example is a placeholder, and needs to be adapted\n      based on the actual protocol. *)\n  let () =\n    let x' = W64xN.valR z in\n    assert (0 <= x' < W64xN.modulusR)\n    (* ...  (more assertions and lemmas) ... *)\n    (* ...  (more assertions and lemmas) ... *)\n\n    \n    \n  (* Proof obligations for the main theorem *)\n  (* ... (more assertions and lemmas) ... *)\n\n\n  (* The following is a placeholder.  The actual\n     proof obligations depend on the protocol definition. *)\n    let () =\n      assert(W64xN.valR z \\in range 0 W64xN.modulusR)\n      \n      assert( W64xN.valR z \\in duniform(range 0 W64xN.modulusR))\n\n\n  (* ... (more assertions and lemmas) ... *)\n  (* ... (more assertions and lemmas) ... *)\n  (* ... (more assertions and lemmas) ... *)\n\n\n  (* Example using exists *)\n  let () =\n    exists (W64xN.R.bn_ofint x) (fun z ->\n      z \\in to_seq (support jsmD) /\\ W64xN.valR z = x\n    )\n      (* ... (more assertions and lemmas for the existential quantifier) ... *)\n  \n  (* ... (rest of the proof obligations) ... *)\n\n  (* ... (rest of the proof obligations) ... *)\n  (* ... (rest of the proof obligations) ... *)"]], "EC-1/W64xN_Finite.ec": [[true, "require import BigNum_spec.\nrequire import AllCore List.\n\nimport W64xN.\nimport R.\n\n\nop all_w64xN(OP_0) : R.t list  = map R.bn_ofint (range 0 modulusR).\n\nlemma all_w64xN_uniq : uniq (all_w64xN).\napply map_inj_in_uniq. move => x y.\nmove => xi yi.\nhave f0 : 0 < modulusR. auto.\nhave f1 : 0 <= x < modulusR. split. smt(@List). move => _.\nsmt(@List).\nhave f2 : 0 <= y < modulusR. split. smt(@List). move => _.\nsmt(@List).\nclear xi yi.\nmove => ass.\nhave : valR (R.bn_ofint x) = valR (R.bn_ofint y).\nsmt().\nrewrite R.bn_ofintK.\nrewrite R.bn_ofintK. smt(@IntDiv).\nsmt(@List).\nqed.\n\nlemma modulusR_pos : 0 < modulusR. auto.\nqed.\n\n\nlemma LEMMA_0 : size (all_w64xN) = modulusR.\napply map_size_range.\nsmt(@List).\nqed."]], "EC-1/WhileNoSuccess.ec": [[true, "(* EasyCrypt code for a protocol analysis *)\n\n(* Protocol Description:  \n   This protocol involves a conditional statement.  The analysis aims to prove a \n   weaker property (whp) for the conditional, relating it to a similar property \n   for a sequential execution. *)\n\n(* Assume M(A) is a function representing the protocol step *)\n\n(* Types (replace with actual types if needed) *)\ntype state;\ntype input;\ntype output;\n\n(* Function definition (replace with actual function definition if needed) *)\nfunction M(A): state -> input -> state * output;\n\n(* Lemma to prove the relationship between whp_if_end and whp *)\nlocal lemma whp_split_if_end_le MyP i s e r p P :  \n  (phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] <= p)\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] <= p.\nproof. progress. bypr.\nprogress.\nhave zz : Pr[M(A).whp_if_end(i,MyP, s, e, r) @ &m : P res] <= p.\nbyphoare (_: arg = (i,MyP,s, e, r) ==> _).\nconseq H. auto. auto. \n(* Crucial step:  Use the definition of whp_if_end to decompose the probability *)\napply (lll Pr[M(A).whp_if_end(i, MyP,s, e, r) @ &m : P res] ).\n(* Use byequiv to relate the probability of the conditional to the probability of the sequential execution *)\nbyequiv.\n(*  Decompose the probability further based on the if-end structure *)\nconseq whp_split_if_end.\n(* Use smt() to apply the theorem prover to the remaining constraints. *)\nsmt().\n(* The following line is crucial for the proof to complete.  It should be the last step *)\nauto.\nqed.\n\n\n(* Example usage (replace with actual instantiation) *)\n(*\nexample :\n  phoare [ M(A).whp_if_end : arg = (i,MyP,s,e,r) ==> P res ] <= p\n   => phoare [ M(A).whp : arg = (i,MyP,s,e+1,r) ==> P res ] <= p.\nproof.\n  apply (whp_split_if_end_le MyP i s e r p P).\n  (* ... provide instantiation for the lemma ... *)\n  smt().\nqed.\n*)"]]}