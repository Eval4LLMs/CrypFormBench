[
    {
        "file": "MAUDE-1/nspk.maude",
        "falsecode": "> \n> search [1] in PROTOCOL-SPECIFICATION : ATTACK-STATE(0) =>* S:State .\n> \n>",
        "falseinfo": "However, the verification results of this file code illustrate that there were no security issues in the targeted protocol. This was a false negative, and there should be some problems with the protocol.",
        "code": "fmod PROTOCOL-EXAMPLE-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n\n  var Z : Msg .\n  var Ke : Key .\n  \n  eq pk(Ke,sk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n  eq sk(Ke,pk(Ke,Z)) = Z [nonexec metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r))), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  eq ATTACK-STATE(1)\n    = :: r :: \n    [ nil, -(pk(b,a ; N)), +(pk(a,  N ; n(b,r))), -(pk(b,n(b,r))) | nil ]\n     ||  empty\n     || nil\n     || nil\n     || never *** for authentication\n     (:: r' :: \n     [ nil, +(pk(b,a ; N)), -(pk(a,  N ; n(b,r))) | +(pk(b,n(b,r))), nil ] \n     & S:StrandSet  \n     || K:IntruderKnowledge)\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "logic": "---\n\n### Protocol Description: PROTOCOL-EXAMPLE\n\n**Overview:**\nThe PROTOCOL-EXAMPLE is a cryptographic protocol designed to facilitate secure communication between two parties, Alice and Bob, while protecting against potential intruder attacks. The protocol employs public key cryptography, where each party has a public and private key pair. The protocol's design incorporates nonce values to ensure freshness and prevent replay attacks.\n\n**Components:**\n\n1. **Sorts and Subsorts:**\n   - **Name:** Represents the identities of participants (Alice, Bob, and the intruder).\n   - **Nonce:** Represents unique values used to ensure freshness in messages.\n   - **Key:** Represents cryptographic keys used in the protocol.\n   - **Msg:** A general sort that encompasses all message types.\n\n2. **Operations:**\n   - `pk(Key, Msg)`: Represents the public key operation, encrypting a message with a public key.\n   - `sk(Key, Msg)`: Represents the private key operation, decrypting a message with a private key.\n   - `n(Name, Fresh)`: Generates a nonce associated with a specific name.\n   - `_ ; _`: Concatenates two messages.\n\n3. **Participants:**\n   - `a`: Represents Alice.\n   - `b`: Represents Bob.\n   - `i`: Represents the intruder.\n\n**Protocol Strands:**\nThe protocol consists of two main strands that detail the communication between Alice and Bob:\n\n- **STRANDS-DOLEVYAO:**\n   - This strand outlines the initial setup and communication between Alice and Bob. It includes message exchanges where:\n     - Alice sends her public key and identity.\n     - Bob responds with his public key and identity.\n\n- **STRANDS-PROTOCOL:**\n   - This strand details the main communication process:\n     - Alice sends a message to Bob, encrypted with Bob's public key, including a nonce for freshness.\n     - Bob responds with a message that includes a nonce for Alice, ensuring that both parties can verify the freshness of their communication.\n\n**Attack States:**\nThe protocol includes two attack states that demonstrate potential vulnerabilities if an intruder attempts to intercept and manipulate messages:\n\n- **ATTACK-STATE(0):**\n   - In this state, the intruder possesses knowledge of certain messages, which allows them to manipulate the communication between Alice and Bob.\n\n- **ATTACK-STATE(1):**\n   - This state shows a scenario where the intruder could potentially authenticate themselves as one of the participants by manipulating nonce values and message exchanges.\n\n**Execution and Analysis:**\nThe Maude-NPA tool will analyze the protocol to verify its security properties, identifying any potential vulnerabilities to intruder attacks. The analysis will explore the effectiveness of the nonce usage and the robustness of the public key operations against interception and replay attacks.\n\n---\n\n### Generating the Corresponding Maude File\n\nUsing the above description, you can generate the Maude file as follows:\n\n1. Define the necessary sorts, subsorts, and operations that represent the protocol components.\n2. Implement the strands that detail the protocol's operations and message exchanges.\n3. Define the attack states to analyze potential vulnerabilities.",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Fri May  2 19:41:04 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 6848023 in 7292ms cpu (7292ms real) (939114 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(pk(b, a ; N:Nonce)), \n   +(pk(a, N:Nonce ; n(b, r:Fresh))), \n   -(pk(b, n(b, r:Fresh))) | nil] \n|| \nn(b, r:Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 11452535 in 11336ms cpu (11332ms real) (1010280 rewrites/second)\nresult IdSystem: < 1 . 5 . 2 . 5 . 2 . 3 . 3 . 1 > (\n:: nil ::\n[ nil | \n   -(pk(i, n(b, #1:Fresh))), \n   +(n(b, #1:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(i, a ; n(a, #0:Fresh))), \n   +(a ; n(a, #0:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(n(b, #1:Fresh)), \n   +(pk(b, n(b, #1:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(pk(b, a ; n(a, #0:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(pk(i, a ; n(a, #0:Fresh))), \n   -(pk(a, n(a, #0:Fresh) ; n(b, #1:Fresh))), \n   +(pk(i, n(b, #1:Fresh))), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(pk(b, a ; n(a, #0:Fresh))), \n   +(pk(a, n(a, #0:Fresh) ; n(b, #1:Fresh))), \n   -(pk(b, n(b, #1:Fresh))), nil] )\n|| \npk(a, n(a, #0:Fresh) ; n(b, #1:Fresh)) !inI,\npk(b, n(b, #1:Fresh)) !inI,\npk(b, a ; n(a, #0:Fresh)) !inI,\npk(i, n(b, #1:Fresh)) !inI,\npk(i, a ; n(a, #0:Fresh)) !inI,\nn(b, #1:Fresh) !inI,\n(a ; n(a, #0:Fresh)) !inI\n|| \n+(pk(i, a ; n(a, #0:Fresh))), \n-(pk(i, a ; n(a, #0:Fresh))), \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(pk(b, a ; n(a, #0:Fresh))), \n-(pk(b, a ; n(a, #0:Fresh))), \n+(pk(a, n(a, #0:Fresh) ; n(b, #1:Fresh))), \n-(pk(a, n(a, #0:Fresh) ; n(b, #1:Fresh))), \n+(pk(i, n(b, #1:Fresh))), \n-(pk(i, n(b, #1:Fresh))), \n+(n(b, #1:Fresh)), \n-(n(b, #1:Fresh)), \n+(pk(b, n(b, #1:Fresh))), \n-(pk(b, n(b, #1:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                19.63043713569641
            ]
        ]
    },
    {
        "file": "MAUDE-1/xor-nsl.maude",
        "falsecode": "***(\n/* Protocol definition with Lowe's fix but with an attack using exclusive or.\n   This protocol is based on the informal journal-level description from [Hosc07]. */\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\n/* Here N_A and N_B are nonces, where pk(x,y) represents a message 'y' encrypted using\n   the public key of 'x', and sk(x,y) represents a message 'y' encrypted using the\n   private key of 'x'. The '*' symbol is the exclusive or operator. */\n\n/* Encryption/decryption have the following algebraic properties: */\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\n/* Exclusive or has the following algebraic properties: */\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\n/* Define the sorts and operators used in the protocol. */\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  /* Import the necessary sorts and protect the protocol rules. */\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  /* Define the sorts used in the protocol. */\n  sorts Name Nonce NNSet .\n  /* Specify the subsort relationships. */\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  /* Define the encryption and decryption operators. */\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  /* Define the concatenation operator. */\n  op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n  /* Define the nonce operator. */\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  /* Define the principals in the protocol. */\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  /* Define the exclusive or operator. */\n  op _*_ : NNSet NNSet -> NNSet [assoc comm frozen] .\n  op null : -> NNSet .\n\nendfm\n\n/* Define the algebraic properties of the protocol. */\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  /* Define the variables used for the algebraic properties. */\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  /* Encryption/Decryption cancellation laws. */\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  /* Exclusive or properties. */\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\n/* Define the protocol specification with strands. */\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  /* Define the variables used in the protocol specification. */\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  /* Define the strands for the Dolev-Yao model. */\n  eq STRANDS-DOLEVYAO\n   = /* ... */\n  [nonexec] .\n\n  /* Define the strands for the protocol. */\n  eq STRANDS-PROTOCOL\n  = /* ... */\n  [nonexec] .\n\n  /* Define the initial attack state. */\n  eq ATTACK-STATE(0)\n   = /* ... */\n  [nonexec] .\n\nendfm\n\n/* Select the MAUDE-NPA module to enable the protocol analysis. */\nselect MAUDE-NPA .",
        "falseinfo": "However, the verification results of this file code illustrate that there were no security issues in the targeted protocol. This was a false negative, and there should be some problems with the protocol.",
        "code": "***(\nLowe's fix but with an attack using exlusive or.\nThe informal journal-level description [Hosc07] of this protocol is as follows:\n\nA --> B: pk(B, N_A ; A)\nB --> A: pk(A, N_A ; B * N_B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x.\nSymbol * is the exclusive or operator.\nEncription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n\nAnd exclusive or has the following algebraic properties:\n\n  X * X = 0 .\n  X * X * Y = Y .\n  X * 0 = X .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NNSet .\n  subsort Name Nonce NNSet < Msg .\n  subsort Name < Public .\n  subsort Name Nonce < NNSet .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .\n  op sk : Name Msg -> Msg [frozen] .\n\n  --- Concatenation operator\n  op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Exclusive or\n  op _*_ : NNSet NNSet -> NNSet [assoc comm frozen] .\n  op null : -> NNSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var A : Name .\n  vars X Y Z : Msg .\n  vars XN YN : NNSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [metadata \"variant\"] .\n  eq sk(A,pk(A,Z)) = Z [metadata \"variant\"] .\n\n  *** Exclusive or properties\n  eq XN * XN = null    [metadata \"variant\"] .\n  eq XN * XN * YN = YN [metadata \"variant\"] .\n  eq XN * null = XN    [metadata \"variant\"] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n  vars XN YN : NNSet .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(XN), -(YN), +(XN * YN), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r   :: [ nil | +(n(i,r)), nil ] & \n     :: nil :: [ nil | +(A), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = :: r ::  *** Bob ***\n    [nil | +(pk(B, n(A,r) ; A)), \n           -(pk(A, n(A,r) ; B * YN)), \n           +(pk(B, YN)), nil] \n    &\n    :: r' :: *** Alice ***\n    [nil | -(pk(B, XN ; A)), \n           +(pk(A, XN ; B * n(B,r'))), \n           -(pk(B,n(B,r'))), nil]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r' :: *** Alice ***\n     [nil, -(pk(b, XN ; a)), \n           +(pk(a, XN ; b * n(b,r'))), \n           -(pk(b, n(b,r'))) | nil]\n     || n(b,r') inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "logic": "---\n\n### Protocol Description\n\n#### Overview\nThe protocol described is a variation of Lowe's fix, designed to facilitate secure communication between two parties, Alice (A) and Bob (B), while also addressing potential vulnerabilities through the use of exclusive OR (XOR) operations. The protocol is susceptible to an attack that exploits these XOR operations.\n\n#### Notation\n- **A and B**: Participants in the protocol, specifically Alice and Bob.\n- **N_A and N_B**: Nonce values generated by Alice and Bob, respectively, which are used to ensure freshness in the communication.\n- **pk(x, y)**: Represents a message `y` encrypted using the public key of `x`.\n- **sk(x, y)**: Represents a message `y` encrypted using the private key of `x`.\n- **XOR (denoted as `*`)**: An operation that combines two values in a way that is reversible and has specific algebraic properties.\n\n#### Communication Steps\n1. **Alice to Bob**: Alice sends a message to Bob containing her nonce `N_A` concatenated with her identity, encrypted with Bob's public key:\n   ```\n   A --> B: pk(B, N_A ; A)\n   ```\n   \n2. **Bob to Alice**: Bob responds to Alice with a message that includes Alice's nonce `N_A`, his own nonce `N_B`, and his identity, all encrypted with Alice's public key:\n   ```\n   B --> A: pk(A, N_A ; B * N_B)\n   ```\n   \n3. **Alice to Bob**: Finally, Alice sends her nonce `N_B` back to Bob, encrypted with Bob's public key:\n   ```\n   A --> B: pk(B, N_B)\n   ```\n\n#### Algebraic Properties\nThe protocol incorporates the following algebraic properties related to encryption and XOR:\n- **Encryption/Decryption**:\n  - \\( pk(K, sk(K, M)) = M \\) (Decrypting the message `M` encrypted with the corresponding public key returns `M`.)\n  - \\( sk(K, pk(K, M)) = M \\) (Encrypting the message `M` with the corresponding private key returns `M`.)\n  \n- **Exclusive OR Properties**:\n  - \\( X * X = 0 \\) (XORing a value with itself results in zero.)\n  - \\( X * X * Y = Y \\) (XORing a value with itself and then with another value yields the other value.)\n  - \\( X * 0 = X \\) (XORing a value with zero returns the original value.)\n\n#### Attack Scenario\nThe protocol is designed with an attack in mind that takes advantage of the properties of exclusive OR. The attack allows an intruder to manipulate the messages exchanged between Alice and Bob, potentially compromising the confidentiality and integrity of the communication.\n\n#### Strands of Execution\nThe protocol defines various strands of execution, capturing the interactions between Alice, Bob, and any potential intruder. Each strand represents a sequence of actions, including sending and receiving messages, and the operations of both the protocol participants and the intruder.\n\n---",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Wed Apr 30 23:30:40 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 89374648 in 82204ms cpu (82204ms real) (1087229 rewrites/second)\nresult IdSystem: < 1 > \n:: r':Fresh ::\n[ nil, \n   -(pk(b, XN:NNSet ; a)), \n   +(pk(a, XN:NNSet ; b * n(b, r':Fresh))), \n   -(pk(b, n(b, r':Fresh))) | nil] \n|| \nn(b, r':Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 117658971 in 120320ms cpu (120325ms real) (977883 rewrites/second)\nresult IdSystem: < 1 . 11 . 3 . 23 . 37 . 5 . 3 . 2 . 1 > (\n:: nil ::\n[ nil | \n   -(pk(i, n(a, #0:Fresh) ; a)), \n   +(n(a, #0:Fresh) ; a), nil]  & \n:: nil ::\n[ nil | \n   -(pk(i, b * i * n(b, #1:Fresh))), \n   +(b * i * n(b, #1:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(n(a, #0:Fresh) ; a), \n   +(pk(b, n(a, #0:Fresh) ; a)), nil]  & \n:: nil ::\n[ nil | \n   -(n(b, #1:Fresh)), \n   +(pk(b, n(b, #1:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(b * i), \n   -(b * i * n(b, #1:Fresh)), \n   +(n(b, #1:Fresh)), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(pk(i, n(a, #0:Fresh) ; a)), \n   -(pk(a, n(a, #0:Fresh) ; b * n(b, #1:Fresh))), \n   +(pk(i, b * i * n(b, #1:Fresh))), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(pk(b, n(a, #0:Fresh) ; a)), \n   +(pk(a, n(a, #0:Fresh) ; b * n(b, #1:Fresh))), \n   -(pk(b, n(b, #1:Fresh))), nil] )\n|| \npk(a, n(a, #0:Fresh) ; b * n(b, #1:Fresh)) !inI,\npk(b, n(a, #0:Fresh) ; a) !inI,\npk(b, n(b, #1:Fresh)) !inI,\npk(i, n(a, #0:Fresh) ; a) !inI,\npk(i, b * i * n(b, #1:Fresh)) !inI,\n(n(a, #0:Fresh) ; a) !inI,\nn(b, #1:Fresh) !inI,\n(b * i) !inI,\n(b * i * n(b, #1:Fresh)) !inI\n|| \n+(pk(i, n(a, #0:Fresh) ; a)), \n-(pk(i, n(a, #0:Fresh) ; a)), \n+(n(a, #0:Fresh) ; a), \n-(n(a, #0:Fresh) ; a), \n+(pk(b, n(a, #0:Fresh) ; a)), \ngeneratedByIntruder(b * i), \n-(pk(b, n(a, #0:Fresh) ; a)), \n+(pk(a, n(a, #0:Fresh) ; b * n(b, #1:Fresh))), \n-(pk(a, n(a, #0:Fresh) ; b * n(b, #1:Fresh))), \n+(pk(i, b * i * n(b, #1:Fresh))), \n-(pk(i, b * i * n(b, #1:Fresh))), \n+(b * i * n(b, #1:Fresh)), \n-(b * i), \n-(b * i * n(b, #1:Fresh)), \n+(n(b, #1:Fresh)), \n-(n(b, #1:Fresh)), \n+(pk(b, n(b, #1:Fresh))), \n-(pk(b, n(b, #1:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                203.59921550750732
            ]
        ]
    }
]