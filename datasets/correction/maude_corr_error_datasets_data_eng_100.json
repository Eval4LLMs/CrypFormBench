[
    {
        "file": "MAUDE-1/bank.maude",
        "errorcode": "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | active >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 30) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Bob, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 130) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Alice, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm",
        "errorinfo": "Line 10 is missing part of the content.",
        "code": "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | active >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 30) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Bob, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 130) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Alice, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm",
        "logic": "### Description of the Banking Protocol\n\n**Protocol Name:** Banking Protocol with Account Management\n\n**Overview:**\nThe banking protocol is designed to manage user accounts, facilitating operations such as crediting, debiting, and transferring funds between accounts. It also includes mechanisms for handling account statuses and limits on the number of accounts.\n\n**Key Components:**\n\n1. **Data Types:**\n   - **Account:** Represents a user account consisting of an identifier, balance, and status.\n   - **Status:** Indicates the state of the account. Possible statuses are \"active\" and \"blocked.\"\n   - **Message:** Represents operations that can be performed on accounts, such as credit, debit, and transfer.\n   - **State:** Represents the overall state of the banking system, including all accounts and operations.\n\n2. **Account Creation and Management:**\n   - Each account is created with an identifier (Id), an initial balance (Int), and a status (Status).\n   - A predefined set of preferred clients (Bob and Charlie) is established, which may have special conditions in the protocol.\n\n3. **Account Operations:**\n   - **Credit:** Increases the account balance of a specified account.\n   - **Debit:** Decreases the account balance of a specified account, which may lead to the account being blocked if the balance goes negative.\n   - **Transfer:** Moves funds from one account to another, adjusting both accounts' balances accordingly.\n\n4. **Initial States:**\n   - The protocol defines multiple initial states (init1, init2, init3) that set up various scenarios with different transactions, allowing for testing of the protocol's behavior under different conditions.\n\n5. **Account Limitations:**\n   - The protocol allows for the creation of new accounts but limits the total number of active accounts to a maximum of 10.\n   - Accounts can be closed if they are blocked and have a balance below a certain negative limit.\n\n6. **Rules and Conditionals:**\n   - The protocol includes rules for updating account statuses based on transactions. For example, if an account balance falls below zero, its status is changed to \"blocked.\"\n   - Additional rules for creating and closing accounts based on the number of existing accounts and account balance are defined.\n\n**Protocol Operations:**\n- `credit(ID, M)`: Credits the account with the identifier `ID` by the amount `M`.\n- `debit(ID, M)`: Debits the account with the identifier `ID` by the amount `M`.\n- `transfer(ID1, ID2, M)`: Transfers the amount `M` from account `ID1` to account `ID2`.\n- `updateStatus(Account)`: Updates the status of an account based on its balance.\n\n**Special Conditions:**\n- Accounts may be flagged as \"blocked\" if their balance falls below zero.\n- Special handling is provided for accounts belonging to preferred clients.\n\nThis protocol can be further extended or modified to include additional features or restrictions as needed. The structured nature of the protocol ensures clarity in operations, making it suitable for formal verification and analysis using tools like Maude-NPA.\n\n### Generation of Maude File\nThis description can be used to develop a new Maude file that accurately reflects the protocol's requirements and operations. You can specify additional features or modifications based on testing and evaluation of the protocol's functionality.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:49:20 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"bank-command\", line 4: bad token run.\nWarning: \"bank-command\", line 4: no parse for term.\nWarning: \"bank-command\", line 5: bad token initials.\nWarning: \"bank-command\", line 5: no parse for term.",
                0.628551721572876
            ]
        ]
    },
    {
        "file": "MAUDE-1/Carlsen_Secret_Key_Initiator.maude",
        "errorcode": "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB MS N M : Msg1 . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)), \n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))), \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "errorinfo": "The symbol in Line 80 is defined incorrectly.",
        "code": "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB MS N M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)), \n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))), \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "logic": "---\n\n### Carlsen's Secret Key Initiator Protocol\n\n**Overview:**\nCarlsen's Secret Key Initiator Protocol is a cryptographic protocol that facilitates secure communication between two parties (Alice and Bob) with the involvement of a server. The protocol employs a secret key mechanism, nonce values, and session keys to ensure the confidentiality and integrity of the messages exchanged.\n\n**Participants:**\n1. **Alice (A)** - The initiator of the communication.\n2. **Bob (B)** - The responder who receives messages from Alice.\n3. **Server (S)** - An entity that assists in the generation and distribution of keys.\n\n**Key Concepts:**\n1. **Nonce (N)** - A unique value generated for each session to prevent replay attacks.\n2. **Master Key (MKey)** - A long-term key shared between a participant and the server.\n3. **Session Key (SesKey)** - A temporary key generated for each session, used to encrypt messages between Alice and Bob.\n4. **Encryption (e)** and **Decryption (d)** - Functions used to secure and retrieve messages using keys.\n\n**Protocol Steps:**\n1. **Key Generation:** \n   - Alice generates a nonce `n(A, r)` where `A` is Alice's identifier and `r` is a fresh value to ensure uniqueness.\n   - Alice encrypts the nonce along with her identity and the session key `SK` using her master key with Bob's identity.\n\n2. **Message Exchange:**\n   - Alice sends an encrypted message containing the nonce, session key, and Bob\u2019s identity to Bob.\n   - Bob receives the message, decrypts it using his master key, and can respond with his own nonce and session key.\n\n3. **Server Role:**\n   - The server is responsible for facilitating the key exchange by providing keys to both Alice and Bob as needed.\n   - The server also encrypts the session keys before sending them to the respective parties.\n\n**Strands of the Protocol:**\n- **Alice's Strand:**\n  - Sends an initial message to Bob with an encrypted session key and nonce.\n  - Receives Bob's response encrypted with the session key.\n\n- **Bob's Strand:**\n  - Receives Alice's initial message and decrypts it using his master key.\n  - Sends back a response to Alice confirming the session.\n\n- **Server's Strand:**\n  - Facilitates the key exchange by sending encrypted session keys to both parties.\n\n**Security Goals:**\n- Confidentiality: Ensure that only the intended recipient can read the messages.\n- Integrity: Ensure that the messages are not altered during transmission.\n- Authentication: Confirm the identities of the communicating parties.\n\n**Conclusion:**\nCarlsen's Secret Key Initiator Protocol is designed to establish a secure communication channel between two participants using cryptographic techniques. The involvement of a server enhances the security of the key exchange process, making it robust against various attacks.\n\n---",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Thu May  1 00:31:33 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 15521224 in 11976ms cpu (11976ms real) (1296027 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh,r1:Fresh ::\n[ nil, \n   -(a ; NA:Nonce), \n   +(a ; NA:Nonce ; b ; n(b, r:Fresh)), \n   -(e(mkey(b, s), SK:Sessionkey ; n(b, r:Fresh) ; a) ; MA:Msg), \n   +(MA:Msg ; e(SK:Sessionkey, NA:Nonce) ; n(b, r1:Fresh)), \n   -(e(SK:Sessionkey, n(b, r1:Fresh))) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 168672374 in 125160ms cpu (125156ms real) (1347653 rewrites/second)\nresult IdSystem: < 1 . 4 . 3 . 6 . 2 . 1 > (\n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n   +(e(mkey(b, s), seskey(a, b, n(#1:UName, #2:Fresh)) ; n(b, #4:Fresh) ; a) ;\n    e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh)))),\n    nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))) ;\n    e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh)) ; n(b, #3:Fresh)), \n   +(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh))), nil]  & \n:: #3:Fresh,#4:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n   -(e(mkey(b, s), seskey(a, b, n(#1:UName, #2:Fresh)) ; n(b, #4:Fresh) ; a) ;\n    e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh)))), \n   +(e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))) ;\n    e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh)) ; n(b, #3:Fresh)), \n   -(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh))), nil] )\n|| \ne(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh)) !inI,\n(a ; n(a, #0:Fresh)) !inI,\n(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)) !inI,\n(e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh)) ; n(b, #3:Fresh))\n    !inI,\n(e(mkey(b, s), seskey(a, b, n(#1:UName, #2:Fresh)) ; n(b, #4:Fresh) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))))\n    !inI,\ninst(#1:UName)\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n-(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n+(e(mkey(b, s), seskey(a, b, n(#1:UName, #2:Fresh)) ; n(b, #4:Fresh) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh)))), \n-(e(mkey(b, s), seskey(a, b, n(#1:UName, #2:Fresh)) ; n(b, #4:Fresh) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh)))), \n+(e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh)) ; n(b, #3:Fresh)), \n-(e(mkey(a, s), n(a, #0:Fresh) ; b ; seskey(a, b, n(#1:UName, #2:Fresh))) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh)) ; n(b, #3:Fresh)), \n+(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh))), \n-(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                138.07218265533447
            ]
        ]
    },
    {
        "file": "MAUDE-1/Denning-Sacco.maude",
        "errorcode": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : \n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "errorinfo": "Line 27 is missing part of the content.",
        "code": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "logic": "---\n\n### Denning Sacco Protocol Description\n\n#### Overview\nThe Denning Sacco Protocol is a cryptographic protocol designed to facilitate secure communication between two users, Alice and Bob, through a trusted server. It employs public key encryption and session keys to ensure confidentiality and authentication during message exchanges.\n\n#### Participants\n1. **Alice (A)**: A user who initiates communication.\n2. **Bob (B)**: A user who receives messages from Alice.\n3. **Server (S)**: A trusted third party that facilitates the key exchange and communication between Alice and Bob.\n\n#### Key Components\n- **Keys**: \n  - **Master Key (mkey)**: A key associated with each user and the server, used for encryption and decryption of messages.\n  - **Session Key (seskey)**: A temporary key generated for a specific session between Alice and Bob.\n- **Nonces**: Random values generated during the protocol execution to ensure freshness and prevent replay attacks.\n- **Messages**: Encrypted and concatenated messages exchanged between the participants.\n\n#### Protocol Steps\n1. **Initial Setup**: \n   - Both Alice and Bob generate their respective Master Keys with the server's help.\n   - The server can derive the Master Key for communication with either Alice or Bob.\n   \n2. **Alice Initiates Communication**:\n   - Alice sends a message to the server containing her identity (A) and Bob's identity (B).\n   - This initiates the process of establishing a session key between Alice and Bob.\n\n3. **Server Responds**:\n   - The server generates a session key for Alice and Bob and sends an encrypted message back to Alice. This message includes:\n     - The session key.\n     - A timestamp (to prevent replay attacks).\n     - An additional encrypted message for Bob.\n\n4. **Bob Receives the Message**:\n   - Bob receives the encrypted message intended for him and uses his Master Key to decrypt it, obtaining the session key and the necessary information to communicate with Alice.\n\n5. **Alice and Bob Communicate**:\n   - After establishing a session key, Alice and Bob can securely exchange messages using this session key, ensuring confidentiality and integrity.\n\n#### Security Properties\n- **Confidentiality**: Messages are encrypted using keys, ensuring that only the intended recipient can read them.\n- **Authentication**: The use of Master Keys allows both users to verify the identity of each other through the server.\n- **Freshness**: Nonces are used to prevent replay attacks by ensuring that old messages cannot be reused in the session.\n\n#### Notation in Maude-NPA\n- `mkey(A, S)`: Denotes the Master Key for Alice with the server.\n- `seskey(A, B, nonce)`: Represents the Session Key for communication between Alice and Bob, with a nonce for freshness.\n- `e(key, message)`: Represents the encryption of a message using a specified key.\n- `d(key, message)`: Represents the decryption of a message using a specified key.\n- Concatenation of messages is denoted by `_ ; _`.\n\nThis structure encompasses the essential elements and processes of the Denning Sacco Protocol, guiding the construction of the corresponding Maude file for simulation and analysis using the Maude-NPA tool.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 12:40:03 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 6866858 in 7848ms cpu (7845ms real) (874981 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh,r':Fresh ::\n[ nil, \n   -(a ; b), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, r:Fresh)) ; t(s, r':Fresh) ; e(mkey(b,\n    s), a ; seskey(a, b, n(s, r:Fresh)) ; t(s, r':Fresh)))) | nil] \n|| \nseskey(a, b, n(s, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,5) .\nrewrites: 22831603 in 26820ms cpu (26822ms real) (851290 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                35.68860983848572
            ]
        ]
    },
    {
        "file": "MAUDE-1/Example1.maude",
        "errorcode": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting \n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .",
        "errorinfo": "Line 21 is missing part of the content.",
        "code": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .",
        "logic": "### Protocol Description\n\n#### Context\nIn this protocol, we are analyzing the behavior of a node \\( N \\) that is in a \"waiting\" state and is performing a lookup operation on a variable \\( X \\). The node will evaluate the result of the lookup and assign it to a local variable \\( x \\).\n\n#### Node Definition\n- **Node \\( N \\)**: This node is responsible for executing a lookup operation to retrieve the current value of a variable \\( X \\). The node's execution context is defined by various conditions that govern its behavior.\n\n#### Lookup Operation\n- The node executes the operation:\n  ```maude\n  x := LookUpNow(X);\n  ```\n  This means that at this point, node \\( N \\) is trying to obtain the value of \\( X \\) immediately.\n\n#### Assumptions\n1. The protocol assumes that there are **no other lookup operations** on variable \\( X \\) at the same time.\n2. The value obtained from the lookup operation is determined by the function \\( Sigma(i, X) \\), which is presumed to return the current value associated with \\( X \\).\n\n#### Execution Outcome\n- Since there are no monitors on variable \\( X \\), the execution of node \\( N \\) results in:\n  - The local variable \\( x \\) being assigned the value \\( Sigma(i, X) \\).\n  - The lookup operation evaluates to \\( Gamma(i, X) \\), which, by definition in this context, is equivalent to \\( Sigma(i, X) \\).\n\n#### Global State\n- The global state of the protocol is defined as follows:\n  - The node \\( N \\) is in an assignment state with specific parameters that dictate its behavior:\n    - **Status**: waiting\n    - **Outcome**: none\n    - **Active**: true\n    - **Condition Flags**: various flags controlling the node's execution (e.g., start condition, end condition, and post conditions).\n  - The variable \\( x \\) is categorized as memory with initial and active values.\n\n### Maude File Structure\nThe provided Maude file defines the following components:\n- **Module Declaration**: The module is defined as `EXAMPLE1`, which includes the protection of `PLEXILITE-PREDS`.\n- **Operations**:\n  - `Example1`: Represents the node's behavior and the lookup assignment.\n  - `Example1Env`: Defines the environment context containing the variable \\( X \\).\n  - `stateN`: Configures the global state of the protocol, capturing the current status of node \\( N \\) and the memory state of variable \\( x \\).\n\n### Execution\nThe execution of the protocol can be initiated using the command:\n```maude\nsrew stateN using micro ! .\n```\nThis command will simulate the execution of the protocol, allowing the Maude-NPA tool to analyze the behavior of the node and the interactions with the variable \\( X \\).\n\n### Summary\nThis protocol serves as a foundational example for demonstrating how a node can look up values in a shared context and how the state of the node can be represented and simulated using the Maude-NPA tool. The absence of concurrent lookups ensures that the lookup operation is straightforward, leading to predictable behavior in the protocol's execution.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Tue May 20 22:48:00 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"Example1.maude\", line 21 (mod EXAMPLE1): module PLEXILITE-PREDS does\n    not exist.\nWarning: \"Example1.maude\", line 23 (mod EXAMPLE1): undeclared sort Plexil.\nWarning: \"Example1.maude\", line 41 (mod EXAMPLE1): undeclared sort ContextList.\nWarning: \"Example1.maude\", line 44 (mod EXAMPLE1): undeclared sort\n    GlobalConfig.\nWarning: \"Example1.maude\", line 24 (mod EXAMPLE1): bad token assignment.\nWarning: \"Example1.maude\", line 24 (mod EXAMPLE1): no parse for statement\neq Example1 = assignment ('N, ('x : v (0)), ((startc: const (v (true))), (endc:\n    const (v (true))), (repeatc: const (v (false))), (inv: const (v (true))), (\n    post: const (v (true))), (pre: const (v (true))), (skip: const (v (\n    false))), (priority: 1)), (('x . 'N) := (lookup ('X)))) .\nWarning: \"Example1.maude\", line 42 (mod EXAMPLE1): bad token v.\nWarning: \"Example1.maude\", line 42 (mod EXAMPLE1): no parse for statement\neq Example1Env = ('X : v (1)) .\nWarning: \"Example1.maude\", line 46 (mod EXAMPLE1): bad token {.\nWarning: \"Example1.maude\", line 45 (mod EXAMPLE1): no parse for statement\neq stateN = {nilcontexts} > 'X : v (1) |- [< 'N : assignment | status: waiting,\n    outcome: none, active: true, repeatc: const (v (false)), startc: const (v (\n    true)), endc: const (v (true)), post: const (v (true)), skip: const (v (\n    false)), pre: const (v (true)), inv: const (v (true)), priority: 1,\n    loopenabled: true, ('x . 'N) := lookup ('X) > < 'x . 'N : memory | initVal:\n    v (0), actVal: v (0) >] {mtactions} {\"inactive-03\"} .\nWarning: \"Example1-command\", line 4: bad token run.\nWarning: \"Example1-command\", line 4: no parse for term.\nWarning: \"Example1-command\", line 5: bad token initials.\nWarning: \"Example1-command\", line 5: no parse for term.",
                0.6302318572998047
            ]
        ]
    },
    {
        "file": "MAUDE-1/hf-sets.maude",
        "errorcode": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44] S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)",
        "errorinfo": "Line 95 is missing part of the content.",
        "code": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)",
        "logic": "---\n\n### Protocol Description: HF-SETS\n\n**Purpose**: The `HF-SETS` module defines a formal framework for manipulating sets and their properties in a way that supports algebraic operations, particularly in the context of set theory.\n\n#### Components\n\n1. **Sorts**:\n   - **Magma**: A general term for a set equipped with a binary operation.\n   - **Set**: A specific type of Magma that represents a collection of elements.\n\n2. **Operations**:\n   - **Binary Operations**: Defined for `Magma`, allowing for the construction of ordered pairs.\n   - **Set Constructor**: `{}` denotes the empty set, and `{M}` creates a singleton set from an element `M`.\n\n3. **Equations**:\n   - **Idempotent Law**: `S U S = S` (union of a set with itself is the set).\n   - **Membership**: Defines whether an element belongs to a set using `_in_`.\n   - **Set Equality**: Two sets are equal if they contain the same elements.\n   - **Set Containment**: A set is contained within another if all its elements are also in the other set.\n   - **Union**: The union operation combines elements from two sets.\n   - **Powerset**: The operation `P` generates the powerset of a given set, which includes all subsets.\n   - **Augmentation**: Augments a set with an additional element, creating new subsets.\n   - **Intersection**: The intersection of two sets is defined along with conditions for checking membership.\n\n4. **Critical Pairs**:\n   - The module includes critical pairs that must be checked for joinability to ensure that the definitions are coherent and do not lead to inconsistencies.\n\n5. **Extending the Module**:\n   - The `HF-SETS-1`, `HF-SETS-2`, and `HF-SETS-3` modules build upon `HF-SETS` by adding new equations that address identified critical pairs, ensuring properties such as commutativity and associativity are preserved across operations.\n\n#### Key Properties\n- **Associativity**: Operations such as union and intersection are associative, meaning the grouping of the operation does not affect the result.\n- **Commutativity**: The order in which sets are combined does not change the outcome (e.g., `S U T = T U S`).\n- **Closure**: The operations defined ensure that the resulting sets remain within the defined sort of `Set`.\n\n#### Goals\n- To provide a clear and formal framework for reasoning about sets and their relationships.\n- To ensure that all operations and properties defined are valid through rigorous algebraic proofs.\n\n### Conclusion\nThis description encapsulates the functionality and structure of the `HF-SETS` module in Maude. By following this outline, one can generate a corresponding Maude file that defines a coherent and robust set theory framework suitable for further analysis and computation.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 09:44:04 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"hf-sets-command\", line 4: bad token run.\nWarning: \"hf-sets-command\", line 4: no parse for term.\nWarning: \"hf-sets-command\", line 5: bad token initials.\nWarning: \"hf-sets-command\", line 5: no parse for term.",
                0.627784013748169
            ]
        ]
    },
    {
        "file": "MAUDE-1/homo-hpc.maude",
        "errorcode": "***(\nThe informal journal-level description of this protocol is as follows:\n\n*** Taken from an e-mail by Cathy!!!\nIn this protocol, Alice and Bob each have secret data DA and DB.\nThere is a function f(DA,DB) that they want to have computed, but\n1- They cannot compute it themselves\n2- Even if they could, they don't want to share their data with each other\n\nThere is a server that can compute f, but they don't want the server to see DA and DB either.\nThe server is assumed to be \"honest but curious\", that is, it is trusted to follow the rules of the\nprotocol, but it will try to find out everything it can about DA and DB in the process.  \n\nThe protocol uses three public key algorithms.  \nOne, hpke is homomorphic with respect to f.  \nThe second, pke, is a regular pubic key encryption algorithm.  \nThe third, sign, is a digital signature algorithm.  \nUnlike the three encryption algorithms in the last example, \nwhose choice was completely arbitrary, \nthe use of these three algorithms is motivated by their roles in the protocol.\n\nThe protocol works as follows.  \n\n1.  A and B share public and private key pairs for the algorithm hpke.  Encryption of message\nM with hpke is thus modeled as hpke(M,k(A,B)).\n2.  A,B, and the server s are all able to digitally sign their messages using algorithm sign\n3.  The server possesses a public and private key pair for algorithm pke\n\nThe protocol is as follows\n\nA -> B   : sign( B ; NA ;  pke( hpke (DA, k(A,B)), s ),A)\nB -> A   : sign( NA ; NB ; pke( hpke (DB, k(A,B)), s ),B)\nA -> s   : sign( A ; B ; NA ; NB ; pke(hpke(DA,k(A,B)),s) ; pke(hpke(DB,k(A,B)), s), A)\ns -> A,B : sign( A ; B ; NA ; NB ; f( hpke(DA,k(A,B)) , hpke(DB,k(A,B)) ), s)\n\nIt has the following flaw when A and B final messages do not ask for f(X3,X4) from the server:\n\nA -> I_B : sign( B ; NA ;  pke( hpke (DA, k(A,B)), s ),A)\nI_B -> B : sign( B ; NA ; XE, i)\nB -> A   : sign( NA ; NB ; pke( hpke (DB, k(i,B)), s ),B)\nA -> s   : sign( A ; B ; NA ; NB ; pke(hpke(DA,k(A,B)),s) ; pke(hpke(DB,k(i,B)), s), A)\ns -> A,B : sign( A ; B ; NA ; NB ; f( hpke(DA,k(A,B)) , hpke(DB,k(i,B)) ), s)\n\nThe protocol may or may not have other flaws.  If it does, it would be interesting to see what\nhappens wrt Maude-NPA.\n\nI also think I've got a way to model the \"honest-but-curious\" behavior of the server \nin Maude-NPA so that it can be demonstrated that the server doesn't learn the secret data. \nIf this is the case, it would be a new contribution of the paper, because \nI don't believe anyone has tried to model honest-but curious in a Dolev-Yao based tool before.\n\n)\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n --- Importing sorts Msg, Fresh, Public, and GhostData\n protecting DEFINITION-PROTOCOL-RULES .\n\n ----------------------------------------------------------\n --- Overwrite this module with the syntax of your protocol\n --- Notes:\n --- * Sort Msg and Fresh are special and imported\n --- * Every sort must be a subsort of Msg\n --- * No sort can be a supersort of Msg\n ----------------------------------------------------------\n\n --- Sort Information \n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n --- Nonce operators\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n --- Principals\n op a : -> Name . --- Alice\n op b : -> Name . --- Bob\n op s : -> Name . --- Server\n op i : -> Name . --- Intruder\n\n--- Concatenation operator\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n--- Public and Private Key operators\n op pkey : Name Name -> Pkey [frozen] .\n\n--- f operator\n op f : Msg Msg -> HEnc [frozen] .\n\n--- Encryption Operators\n op pke : Msg Name -> Enc [frozen] .\n op hpke : Msg Pkey -> HEnc [frozen] .\n op sign : Msg Name -> Sign [frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n ----------------------------------------------------------\n --- Overwrite this module with the algebraic properties \n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y : Msg .\n var K : Pkey .\n\n ***Homomorphic encryption over f\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K)) \n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n ----------------------------------------------------------\n --- Overwrite this module with the strands \n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n\n\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] & \n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] & \n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] & \n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] &\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] & \n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] & \n    :: nil :: [ nil | +(A), nil ] \n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  r'  :: *** Alice ***\n    [ nil | +(sign( B ; n(A,r)  ; pke(hpke(data(A,r'),pkey(A,B)),s),A)),\n            -(sign( n(A,r) ; N ; Y1 , B)), \n            +(sign( A ; B ; n(A,r) ; N ; pke(hpke(data(A,r'),pkey(A,B)),s) ; Y1  , A)),\n\t    -(sign( A ; B ; n(A,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: ***Bob ***\n    [ nil | -(sign( B ; N1  ; Y2, A)),\n            +(sign( N1 ; n(B,r) ; pke(hpke(data(B,r'),pkey(A,B)),s), B)), \n\t    -(sign( A ; B ; N1 ; n(B,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: *** Server ***\n    [ nil | -(sign( A ; B ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , A)),\n            +(sign( A ; B ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  *** Alice ***\n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )), \n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty\n     || nil\n     || nil\n     || never(\n     *** Authentication ***\n     :: r1, r2  :: ***Bob ***\n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)),\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)),\n       nil ] \n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "errorinfo": "Line 151 is missing part of the content.",
        "code": "***(\nThe informal journal-level description of this protocol is as follows:\n\n*** Taken from an e-mail by Cathy!!!\nIn this protocol, Alice and Bob each have secret data DA and DB.\nThere is a function f(DA,DB) that they want to have computed, but\n1- They cannot compute it themselves\n2- Even if they could, they don't want to share their data with each other\n\nThere is a server that can compute f, but they don't want the server to see DA and DB either.\nThe server is assumed to be \"honest but curious\", that is, it is trusted to follow the rules of the\nprotocol, but it will try to find out everything it can about DA and DB in the process.  \n\nThe protocol uses three public key algorithms.  \nOne, hpke is homomorphic with respect to f.  \nThe second, pke, is a regular pubic key encryption algorithm.  \nThe third, sign, is a digital signature algorithm.  \nUnlike the three encryption algorithms in the last example, \nwhose choice was completely arbitrary, \nthe use of these three algorithms is motivated by their roles in the protocol.\n\nThe protocol works as follows.  \n\n1.  A and B share public and private key pairs for the algorithm hpke.  Encryption of message\nM with hpke is thus modeled as hpke(M,k(A,B)).\n2.  A,B, and the server s are all able to digitally sign their messages using algorithm sign\n3.  The server possesses a public and private key pair for algorithm pke\n\nThe protocol is as follows\n\nA -> B   : sign( B ; NA ;  pke( hpke (DA, k(A,B)), s ),A)\nB -> A   : sign( NA ; NB ; pke( hpke (DB, k(A,B)), s ),B)\nA -> s   : sign( A ; B ; NA ; NB ; pke(hpke(DA,k(A,B)),s) ; pke(hpke(DB,k(A,B)), s), A)\ns -> A,B : sign( A ; B ; NA ; NB ; f( hpke(DA,k(A,B)) , hpke(DB,k(A,B)) ), s)\n\nIt has the following flaw when A and B final messages do not ask for f(X3,X4) from the server:\n\nA -> I_B : sign( B ; NA ;  pke( hpke (DA, k(A,B)), s ),A)\nI_B -> B : sign( B ; NA ; XE, i)\nB -> A   : sign( NA ; NB ; pke( hpke (DB, k(i,B)), s ),B)\nA -> s   : sign( A ; B ; NA ; NB ; pke(hpke(DA,k(A,B)),s) ; pke(hpke(DB,k(i,B)), s), A)\ns -> A,B : sign( A ; B ; NA ; NB ; f( hpke(DA,k(A,B)) , hpke(DB,k(i,B)) ), s)\n\nThe protocol may or may not have other flaws.  If it does, it would be interesting to see what\nhappens wrt Maude-NPA.\n\nI also think I've got a way to model the \"honest-but-curious\" behavior of the server \nin Maude-NPA so that it can be demonstrated that the server doesn't learn the secret data. \nIf this is the case, it would be a new contribution of the paper, because \nI don't believe anyone has tried to model honest-but curious in a Dolev-Yao based tool before.\n\n)\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n --- Importing sorts Msg, Fresh, Public, and GhostData\n protecting DEFINITION-PROTOCOL-RULES .\n\n ----------------------------------------------------------\n --- Overwrite this module with the syntax of your protocol\n --- Notes:\n --- * Sort Msg and Fresh are special and imported\n --- * Every sort must be a subsort of Msg\n --- * No sort can be a supersort of Msg\n ----------------------------------------------------------\n\n --- Sort Information \n sorts Name Nonce Pkey Data  Enc Sign HEnc .\n subsorts Nonce Pkey Data Name Enc Sign HEnc < Msg  .\n subsort Name < Public .\n\n --- Nonce operators\n op n : Name Fresh -> Nonce [frozen] .\n op data : Name Fresh -> Data [frozen] .\n\n --- Principals\n op a : -> Name . --- Alice\n op b : -> Name . --- Bob\n op s : -> Name . --- Server\n op i : -> Name . --- Intruder\n\n--- Concatenation operator\n op _;_ : Msg Msg -> Msg [gather (e E) frozen] .\n\n--- Public and Private Key operators\n op pkey : Name Name -> Pkey [frozen] .\n\n--- f operator\n op f : Msg Msg -> HEnc [frozen] .\n\n--- Encryption Operators\n op pke : Msg Name -> Enc [frozen] .\n op hpke : Msg Pkey -> HEnc [frozen] .\n op sign : Msg Name -> Sign [frozen] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n\n ----------------------------------------------------------\n --- Overwrite this module with the algebraic properties \n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y : Msg .\n var K : Pkey .\n\n ***Homomorphic encryption over f\n eq hpke(f(X,Y) , K) = f(hpke(X , K) , hpke(Y , K)) \n    [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n protecting PROTOCOL-EXAMPLE-SYMBOLS .\n protecting DEFINITION-PROTOCOL-RULES .\n protecting DEFINITION-CONSTRAINTS-INPUT .\n\n ----------------------------------------------------------\n --- Overwrite this module with the strands \n --- of your protocol\n ----------------------------------------------------------\n\n vars X Y Z W  : Msg .\n vars X1 X2 X3 X4 : HEnc .\n vars Y1 Y2 : Enc .\n vars Z1 Z2 : Sign .\n vars X' Y' Z' V' W' : Msg .\n vars r r' r'' r1 r2 r3 r4 : Fresh .\n vars N N1 N2 : Nonce .\n vars V P A B : Name .\n\n\n\n\n eq STRANDS-DOLEVYAO\n  = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n    :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n    :: nil :: [ nil | -(X), -(A),  +(pke(X, A)), nil ] & \n    :: nil :: [ nil | -(pke(X,i)), +(X), nil ] &\n    :: nil :: [ nil | -(X),   +(sign(X,i)), nil ] & \n    :: nil :: [ nil | -(sign(X,A)), +(X), nil ] & \n    :: nil :: [ nil | -(X), -(A), -(B),  +(hpke(X,pkey(A,B))), nil ] &\n    :: nil :: [ nil | -(hpke(X,pkey(A,i))),  +(X), nil ] & \n    :: nil :: [ nil | -(hpke(X,pkey(i,B))),  +(X), nil ] & \n    :: nil :: [ nil | +(A), nil ] \n [nonexec] .\n\n eq STRANDS-PROTOCOL\n  = :: r, r'  :: *** Alice ***\n    [ nil | +(sign( B ; n(A,r)  ; pke(hpke(data(A,r'),pkey(A,B)),s),A)),\n            -(sign( n(A,r) ; N ; Y1 , B)), \n            +(sign( A ; B ; n(A,r) ; N ; pke(hpke(data(A,r'),pkey(A,B)),s) ; Y1  , A)),\n\t    -(sign( A ; B ; n(A,r) ; N ; X1 , s )) ,\n      nil ] &\n    :: r, r'  :: ***Bob ***\n    [ nil | -(sign( B ; N1  ; Y2, A)),\n            +(sign( N1 ; n(B,r) ; pke(hpke(data(B,r'),pkey(A,B)),s), B)), \n\t    -(sign( A ; B ; N1 ; n(B,r) ; X2, s )) ,\n      nil ] &\n    :: nil :: *** Server ***\n    [ nil | -(sign( A ; B ; N1 ; N2 ; pke(X3 , s) ; pke(X4 , s) , A)),\n            +(sign( A ; B ; N1 ; N2 ; f(X3,X4) , s)) ,\n      nil ]\n [nonexec] .\n\n eq ATTACK-STATE(0)\n   = :: r, r' ::  *** Alice ***\n     [ nil , +(sign( b ; n(a,r) ; pke(hpke (data(a,r'),pkey(a,b)),s),a)),\n             -(sign( n(a,r) ; N ; Y1 ,b )), \n             +(sign( a ; b ; n(a,r) ; N ; pke(hpke (data(a,r'),pkey(a,b)),s) ; Y1 , a)),\n  \t     -(sign( a ; b ; n(a,r) ; N ; X1 , s )) |\n       nil ]\n     || empty\n     || nil\n     || nil\n     || never(\n     *** Authentication ***\n     :: r1, r2  :: ***Bob ***\n     [ nil | -(sign( b ; n(a,r) ; pke(hpke(data(a,r'),pkey(a,b)),s), a)),\n             +(sign( n(a,r) ; n(b,r1) ; pke(hpke(data(b,r2),pkey(a,b)),s), b)),\n       nil ] \n     & S:StrandSet || IK:IntruderKnowledge)\n [nonexec] .\n\nendfm\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "logic": "---\n\n## Protocol Description\n\n### Overview\n\nThis protocol facilitates a computation of a function \\( f(DA, DB) \\) between two parties, Alice (A) and Bob (B), who each possess secret data \\( DA \\) and \\( DB \\), respectively. The objective is to compute \\( f \\) without revealing the secret data to each other or to a trusted server \\( s \\). The server is assumed to be \"honest but curious,\" meaning it will not deviate from the protocol but might attempt to infer \\( DA \\) and \\( DB \\) through the protocol's operations.\n\n### Components\n\n1. **Participants**:\n   - Alice (A)\n   - Bob (B)\n   - Server (s)\n   - Intruder (i)\n\n2. **Secrets**:\n   - \\( DA \\): Secret data held by Alice.\n   - \\( DB \\): Secret data held by Bob.\n\n3. **Public Key Algorithms**:\n   - **hpke**: A homomorphic encryption algorithm that allows the server to compute \\( f \\) without knowing \\( DA \\) or \\( DB \\).\n   - **pke**: A regular public key encryption algorithm used for secure communication.\n   - **sign**: A digital signature algorithm used for authentication.\n\n4. **Nonces**:\n   - Unique nonces \\( N, N1, N2 \\) are used to ensure freshness and prevent replay attacks.\n\n### Protocol Steps\n\n1. **Key Exchange**: Alice and Bob generate their public and private key pairs for the homomorphic encryption algorithm \\( hpke \\). The encryption of a message \\( M \\) with \\( hpke \\) is modeled as \\( hpke(M, k(A,B)) \\).\n\n2. **Message Flow**:\n   - **Step 1**: Alice sends a signed message to Bob:\n     \\[\n     A \\to B : sign(B; N_A; pke(hpke(DA, k(A,B)), s), A)\n     \\]\n   - **Step 2**: Bob responds with a signed message to Alice:\n     \\[\n     B \\to A : sign(N_A; N_B; pke(hpke(DB, k(A,B)), s), B)\n     \\]\n   - **Step 3**: Alice sends a signed message to the server containing her nonce, Bob's nonce, and the encrypted data:\n     \\[\n     A \\to s : sign(A; B; N_A; N_B; pke(hpke(DA, k(A,B)), s); pke(hpke(DB, k(A,B)), s), A)\n     \\]\n   - **Step 4**: The server responds to both Alice and Bob with the computed function:\n     \\[\n     s \\to A, B : sign(A; B; N_A; N_B; f(hpke(DA, k(A,B)), hpke(DB, k(A,B))), s)\n     \\]\n\n### Flaw Description\n\nThe protocol has a potential flaw in scenarios where Alice and Bob do not request the function \\( f(X_3, X_4) \\) from the server. The modified message flow in such a case leads to the following sequence:\n\n1. Alice sends a message to an intermediary \\( I_B \\):\n   \\[\n   A \\to I_B : sign(B; N_A; pke(hpke(DA, k(A,B)), s), A)\n   \\]\n   - \\( I_B \\) forwards it to Bob.\n\n2. Bob responds to the intermediary:\n   \\[\n   I_B \\to B : sign(B; N_A; X_E, i)\n   \\]\n\n3. The rest of the protocol follows similarly, but the computation \\( f \\) is conducted with potentially manipulated data \\( hpke(DB, k(i,B)) \\).\n\n### Conclusion\n\nThis protocol highlights the use of homomorphic encryption and digital signatures to compute a shared function while maintaining data confidentiality. The flaw introduced by not properly managing the requests for function computations raises interesting questions about the security guarantees provided by the protocol and invites further exploration using the Maude-NPA tool.\n\n### Future Work\n\nInvestigating additional flaws that may exist within the protocol and modeling the \"honest-but-curious\" behavior of the server in Maude-NPA to demonstrate that the server does not learn the secret data, which could contribute novel insights to the existing literature on secure multi-party computation.\n\n---",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Thu May  1 00:10:07 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 40510768 in 38200ms cpu (38201ms real) (1060491 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh,r':Fresh ::\n[ nil, \n   +(sign(b ; n(a, r:Fresh) ; pke(hpke(data(a, r':Fresh), pkey(a, b)), s), a)),\n    \n   -(sign(n(a, r:Fresh) ; N:Nonce ; Y1:Enc, b)), \n   +(sign(a ; b ; n(a, r:Fresh) ; N:Nonce ; pke(hpke(data(a, r':Fresh), pkey(a,\n    b)), s) ; Y1:Enc, a)), \n   -(sign(a ; b ; n(a, r:Fresh) ; N:Nonce ; X1:HEnc, s)) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| never((S:StrandSet & \n:: r1:Fresh,r2:Fresh ::\n[ nil | \n   -(sign(b ; n(a, r:Fresh) ; pke(hpke(data(a, r':Fresh), pkey(a, b)), s), a)),\n    \n   +(sign(n(a, r:Fresh) ; n(b, r1:Fresh) ; pke(hpke(data(b, r2:Fresh), pkey(a,\n    b)), s), b)), nil] ) || IK:IntruderKnowledge)\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 82767281 in 410724ms cpu (410768ms real) (201515 rewrites/second)\nresult IdSystem: < 1 . 6 . 2 . 7 . 3 . 2 . 3 . 3 . 2 . 7 . 1 > (\n:: nil ::\n[ nil | \n   -(b), \n   -(n(a, #0:Fresh) ; #4:Enc), \n   +(b ; n(a, #0:Fresh) ; #4:Enc), nil]  & \n:: nil ::\n[ nil | \n   -(n(a, #0:Fresh)), \n   -(#4:Enc), \n   +(n(a, #0:Fresh) ; #4:Enc), nil]  & \n:: nil ::\n[ nil | \n   -(b ; n(a, #0:Fresh) ; #4:Enc), \n   +(sign(b ; n(a, #0:Fresh) ; #4:Enc, i)), nil]  & \n:: nil ::\n[ nil | \n   -(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n   +(n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), nil]  & \n:: nil ::\n[ nil | \n   -(n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n   +(n(a, #0:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(a, #1:Fresh),\n    pkey(a, b)), s) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)), s), a)), \n   +(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; f(hpke(data(a, #1:Fresh),\n    pkey(a, b)), hpke(data(b, #3:Fresh), pkey(i, b))), s)), nil]  & \n:: nil ::\n[ nil | \n   -(sign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s),\n    a)), \n   +(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), nil]  &\n    \n:: #1:Fresh,#0:Fresh ::\n[ nil | \n   +(sign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s),\n    a)), \n   -(sign(n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(b, #3:Fresh), pkey(i,\n    b)), s), b)), \n   +(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(a, #1:Fresh),\n    pkey(a, b)), s) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)), s), a)), \n   -(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; f(hpke(data(a, #1:Fresh),\n    pkey(a, b)), hpke(data(b, #3:Fresh), pkey(i, b))), s)), nil]  & \n:: #2:Fresh,#3:Fresh ::\n[ nil | \n   -(sign(b ; n(a, #0:Fresh) ; #4:Enc, i)), \n   +(sign(n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(b, #3:Fresh), pkey(i,\n    b)), s), b)), nil] )\n|| \n#4:Enc !inI,\nn(a, #0:Fresh) !inI,\n(b ; n(a, #0:Fresh) ; #4:Enc) !inI,\n(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)) !inI,\n(n(a, #0:Fresh) ; #4:Enc) !inI,\n(n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)) !inI,\nsign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(a, #1:Fresh),\n    pkey(a, b)), s) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)), s), a) !inI,\nsign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; f(hpke(data(a, #1:Fresh), pkey(\n    a, b)), hpke(data(b, #3:Fresh), pkey(i, b))), s) !inI,\nsign(b ; n(a, #0:Fresh) ; #4:Enc, i) !inI,\nsign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s), a) !inI,\nsign(n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)),\n    s), b) !inI\n|| \n+(sign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s), a)), \n-(sign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s), a)), \n+(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n-(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n+(n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n-(n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s)), \n+(n(a, #0:Fresh)), \ngeneratedByIntruder(#4:Enc), \n-(n(a, #0:Fresh)), \n-(#4:Enc), \n+(n(a, #0:Fresh) ; #4:Enc), \n-(b), \n-(n(a, #0:Fresh) ; #4:Enc), \n+(b ; n(a, #0:Fresh) ; #4:Enc), \n-(b ; n(a, #0:Fresh) ; #4:Enc), \n+(sign(b ; n(a, #0:Fresh) ; #4:Enc, i)), \n-(sign(b ; n(a, #0:Fresh) ; #4:Enc, i)), \n+(sign(n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(b, #3:Fresh), pkey(i,\n    b)), s), b)), \n-(sign(n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(b, #3:Fresh), pkey(i,\n    b)), s), b)), \n+(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(a, #1:Fresh),\n    pkey(a, b)), s) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)), s), a)), \n-(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; pke(hpke(data(a, #1:Fresh),\n    pkey(a, b)), s) ; pke(hpke(data(b, #3:Fresh), pkey(i, b)), s), a)), \n+(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; f(hpke(data(a, #1:Fresh),\n    pkey(a, b)), hpke(data(b, #3:Fresh), pkey(i, b))), s)), \n-(sign(a ; b ; n(a, #0:Fresh) ; n(b, #2:Fresh) ; f(hpke(data(a, #1:Fresh),\n    pkey(a, b)), hpke(data(b, #3:Fresh), pkey(i, b))), s))\n|| \nnil\n|| never((#5:StrandSet & \n:: #6:Fresh,#7:Fresh ::\n[ nil | \n   -(sign(b ; n(a, #0:Fresh) ; pke(hpke(data(a, #1:Fresh), pkey(a, b)), s),\n    a)), \n   +(sign(n(a, #0:Fresh) ; n(b, #6:Fresh) ; pke(hpke(data(b, #7:Fresh), pkey(a,\n    b)), s), b)), nil] ) || #8:IntruderKnowledge)\nMaude> Bye.",
                450.09152913093567
            ]
        ]
    },
    {
        "file": "MAUDE-1/homo-nsl.maude",
        "errorcode": "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Key -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var X Y : Msg .\n  var Z : Key .\n\n  eq pk(X ; Y, Z) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "errorinfo": "Line 86 is missing part of the content.",
        "code": "***(\nThe informal journal-level description of this protocol is as follows:\n\n1. A -> B : {Na, A}PK(B)\n2. B -> A : {Na, Nb, B}PK(A)\n3. A -> B : {Nb}PK(B)\n\nwhere PK is homomorphic over concatenation.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Msg Key -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var X Y : Msg .\n  var Z : Key .\n\n  eq pk(X ; Y, Z) = pk(X, Z) ; pk(Y, Z) [nonexec label homomorphism metadata \"builtin-unify\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N NA NB : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(pk(X,Ke)), nil ] &\n      :: nil :: [ nil | -(pk(X,i)), +(X), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(A ; n(A,r), B)), -(pk(n(A,r) ; NB ; B, A)), +(pk(NB, B)), nil ] &\n     :: r :: \n     [ nil | -(pk(A ; NA, B)), +(pk(NA ; n(B,r) ; B, A)), -(pk(n(B,r), B)), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(a ; NA, b)), +(pk(NA ; n(b,r) ; b,a)), -(pk(n(b,r), b)) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "logic": "---\n\n### Informal Description of the Protocol\n\n#### Protocol Overview\n\nThis protocol, which can be referred to as a nonce-based authentication protocol, involves two principal entities: Alice (A) and Bob (B). The protocol utilizes public key cryptography to ensure secure communication between the two parties and to validate their identities. The use of nonces (Na, Nb) serves to protect against replay attacks, ensuring that each session is unique.\n\n#### Steps of the Protocol\n\n1. **Step 1: Initiation by Alice**\n   - Alice sends a message to Bob that includes a nonce (Na) generated by her and her identity. The message is encrypted with Bob's public key (PK(B)).\n   - **Message Format**: \n     \\[\n     A \\rightarrow B : \\{Na, A\\}_{PK(B)}\n     \\]\n\n2. **Step 2: Response by Bob**\n   - Upon receiving the message, Bob decrypts it using his private key. He retrieves the nonce (Na) and Alice's identity. Bob then generates his own nonce (Nb) and sends back a message to Alice. This message includes both nonces (Na, Nb) and Bob's identity, encrypted with Alice's public key (PK(A)).\n   - **Message Format**: \n     \\[\n     B \\rightarrow A : \\{Na, Nb, B\\}_{PK(A)}\n     \\]\n\n3. **Step 3: Confirmation by Alice**\n   - Alice, upon receiving Bob's response, decrypts the message to retrieve the nonces (Na, Nb) and Bob's identity. She then sends a final message back to Bob, confirming that she has received his nonce (Nb) by sending it encrypted with Bob's public key (PK(B)).\n   - **Message Format**: \n     \\[\n     A \\rightarrow B : \\{Nb\\}_{PK(B)}\n     \\]\n\n### Key Properties of the Protocol\n\n- **Nonce Generation**: The protocol utilizes fresh nonces (Na, Nb) to prevent replay attacks, ensuring that each session is unique.\n- **Public Key Encryption**: The messages are encrypted using the recipients' public keys, ensuring that only the intended recipient can decrypt the messages using their private keys.\n- **Homomorphic Property**: The public key encryption is homomorphic over concatenation, allowing for the secure combination of messages.\n\n### Security Considerations\n\nThe protocol aims to achieve mutual authentication between Alice and Bob, ensuring that both parties can confirm each other's identities. The use of nonces prevents replay attacks, and the public key encryption ensures confidentiality.\n\n---",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Wed Apr 30 22:50:21 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 10804704 in 9356ms cpu (9355ms real) (1154842 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(pk(a ; NA:Nonce, b)), \n   +(pk(NA:Nonce ; n(b, r:Fresh) ; b, a)), \n   -(pk(n(b, r:Fresh), b)) | nil] \n|| \nn(b, r:Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 116072355 in 95480ms cpu (95480ms real) (1215671 rewrites/second)\nresult IdSystemSet: (< 1 . 2 . 9 . 12 . (2{1}) . 6 . 1 . 1 > (\n:: nil ::\n[ nil | \n   -(pk(i, b)), \n   -(pk(n(b, #1:Fresh), b)), \n   +(pk(i, b) ; pk(n(b, #1:Fresh), b)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #1:Fresh), i)), \n   +(n(b, #1:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #1:Fresh), i) ; pk(n(b, #2:Fresh), i) ; pk(b, i)), \n   +(pk(n(b, #1:Fresh), i)), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(pk(a ; n(a, #0:Fresh), b)), \n   +(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n   -(pk(n(b, #1:Fresh), b)), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(pk(i ; n(b, #1:Fresh), b)), \n   +(pk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i)), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(pk(a ; n(a, #0:Fresh), b)), \n   -(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n   +(pk(n(b, #1:Fresh), b)), nil] )\n|| \npk(i, b) !inI,\npk(n(b, #1:Fresh), b) !inI,\npk(n(b, #1:Fresh), i) !inI,\npk(a ; n(a, #0:Fresh), b) !inI,\npk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a) !inI,\npk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i) !inI,\nn(b, #1:Fresh) !inI,\n(pk(i, b) ; pk(n(b, #1:Fresh), b)) !inI\n|| \n+(pk(a ; n(a, #0:Fresh), b)), \n-(pk(a ; n(a, #0:Fresh), b)), \n+(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \ngeneratedByIntruder(pk(i, b)), \n-(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n+(pk(n(b, #1:Fresh), b)), \n-(pk(i, b)), \n-(pk(n(b, #1:Fresh), b)), \n+(pk(i, b) ; pk(n(b, #1:Fresh), b)), \n-(pk(i ; n(b, #1:Fresh), b)), \n+(pk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i)), \n-(pk(n(b, #1:Fresh), i) ; pk(n(b, #2:Fresh), i) ; pk(b, i)), \n+(pk(n(b, #1:Fresh), i)), \n-(pk(n(b, #1:Fresh), i)), \n+(n(b, #1:Fresh)), \n-(pk(n(b, #1:Fresh), b))\n|| \nnil\n|| \nnil)\n(< 1 . 3 . 2 . 5 . 7 . 2 . 4 . 6 . 1 > (\n:: nil ::\n[ nil | \n   -(pk(i, a)), \n   -(pk(n(b, #0:Fresh), a)), \n   +(pk(i, a) ; pk(n(b, #0:Fresh), a)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #0:Fresh), i)), \n   +(n(b, #0:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(n(b, #0:Fresh)), \n   +(pk(n(b, #0:Fresh), b)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(#1:Nonce, a) ; pk(n(b, #0:Fresh), a) ; pk(b, a)), \n   +(pk(n(b, #0:Fresh), a) ; pk(b, a)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #0:Fresh), a) ; pk(b, a)), \n   +(pk(n(b, #0:Fresh), a)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #0:Fresh), i) ; pk(n(a, #2:Fresh), i) ; pk(a, i)), \n   +(pk(n(b, #0:Fresh), i)), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(pk(i ; n(b, #0:Fresh), a)), \n   +(pk(n(b, #0:Fresh) ; n(a, #2:Fresh) ; a, i)), nil]  & \n:: #0:Fresh ::\n[ nil | \n   -(pk(a ; #1:Nonce, b)), \n   +(pk(#1:Nonce ; n(b, #0:Fresh) ; b, a)), \n   -(pk(n(b, #0:Fresh), b)), nil] )\n|| \npk(i, a) !inI,\npk(n(b, #0:Fresh), a) !inI,\npk(n(b, #0:Fresh), b) !inI,\npk(n(b, #0:Fresh), i) !inI,\npk(a ; #1:Nonce, b) !inI,\npk(#1:Nonce ; n(b, #0:Fresh) ; b, a) !inI,\npk(n(b, #0:Fresh) ; n(a, #2:Fresh) ; a, i) !inI,\nn(b, #0:Fresh) !inI,\n(pk(i, a) ; pk(n(b, #0:Fresh), a)) !inI,\n(pk(n(b, #0:Fresh), a) ; pk(b, a)) !inI\n|| \ngeneratedByIntruder(pk(i, a)), \ngeneratedByIntruder(pk(a ; #1:Nonce, b)), \n-(pk(a ; #1:Nonce, b)), \n+(pk(#1:Nonce ; n(b, #0:Fresh) ; b, a)), \n-(pk(#1:Nonce, a) ; pk(n(b, #0:Fresh), a) ; pk(b, a)), \n+(pk(n(b, #0:Fresh), a) ; pk(b, a)), \n-(pk(n(b, #0:Fresh), a) ; pk(b, a)), \n+(pk(n(b, #0:Fresh), a)), \n-(pk(i, a)), \n-(pk(n(b, #0:Fresh), a)), \n+(pk(i, a) ; pk(n(b, #0:Fresh), a)), \n-(pk(i ; n(b, #0:Fresh), a)), \n+(pk(n(b, #0:Fresh) ; n(a, #2:Fresh) ; a, i)), \n-(pk(n(b, #0:Fresh), i) ; pk(n(a, #2:Fresh), i) ; pk(a, i)), \n+(pk(n(b, #0:Fresh), i)), \n-(pk(n(b, #0:Fresh), i)), \n+(n(b, #0:Fresh)), \n-(n(b, #0:Fresh)), \n+(pk(n(b, #0:Fresh), b)), \n-(pk(n(b, #0:Fresh), b))\n|| \nnil\n|| \nnil)\n< 1 . 2 . 9 . 12 . (2{1}) . 6 . 1 . 3 . 2 . 2 > (\n:: nil ::\n[ nil | \n   -(pk(a, b)), \n   -(pk(n(a, #0:Fresh), b)), \n   +(pk(a, b) ; pk(n(a, #0:Fresh), b)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(i, b)), \n   -(pk(n(b, #1:Fresh), b)), \n   +(pk(i, b) ; pk(n(b, #1:Fresh), b)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #1:Fresh), i)), \n   +(n(b, #1:Fresh)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(a, b) ; pk(n(a, #0:Fresh), b)), \n   +(pk(n(a, #0:Fresh), b)), nil]  & \n:: nil ::\n[ nil | \n   -(pk(n(b, #1:Fresh), i) ; pk(n(b, #2:Fresh), i) ; pk(b, i)), \n   +(pk(n(b, #1:Fresh), i)), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(pk(a ; n(a, #0:Fresh), b)), \n   +(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n   -(pk(n(b, #1:Fresh), b)), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(pk(i ; n(b, #1:Fresh), b)), \n   +(pk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i)), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(pk(a ; n(a, #0:Fresh), b)), \n   -(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n   +(pk(n(b, #1:Fresh), b)), nil] )\n|| \npk(a, b) !inI,\npk(i, b) !inI,\npk(n(a, #0:Fresh), b) !inI,\npk(n(b, #1:Fresh), b) !inI,\npk(n(b, #1:Fresh), i) !inI,\npk(a ; n(a, #0:Fresh), b) !inI,\npk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a) !inI,\npk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i) !inI,\nn(b, #1:Fresh) !inI,\n(pk(a, b) ; pk(n(a, #0:Fresh), b)) !inI,\n(pk(i, b) ; pk(n(b, #1:Fresh), b)) !inI\n|| \n+(pk(a ; n(a, #0:Fresh), b)), \n-(pk(a, b) ; pk(n(a, #0:Fresh), b)), \n+(pk(n(a, #0:Fresh), b)), \ngeneratedByIntruder(pk(a, b)), \n-(pk(a, b)), \n-(pk(n(a, #0:Fresh), b)), \n+(pk(a, b) ; pk(n(a, #0:Fresh), b)), \n-(pk(a ; n(a, #0:Fresh), b)), \n+(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \ngeneratedByIntruder(pk(i, b)), \n-(pk(n(a, #0:Fresh) ; n(b, #1:Fresh) ; b, a)), \n+(pk(n(b, #1:Fresh), b)), \n-(pk(i, b)), \n-(pk(n(b, #1:Fresh), b)), \n+(pk(i, b) ; pk(n(b, #1:Fresh), b)), \n-(pk(i ; n(b, #1:Fresh), b)), \n+(pk(n(b, #1:Fresh) ; n(b, #2:Fresh) ; b, i)), \n-(pk(n(b, #1:Fresh), i) ; pk(n(b, #2:Fresh), i) ; pk(b, i)), \n+(pk(n(b, #1:Fresh), i)), \n-(pk(n(b, #1:Fresh), i)), \n+(n(b, #1:Fresh)), \n-(pk(n(b, #1:Fresh), b))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                105.98270344734192
            ]
        ]
    },
    {
        "file": "MAUDE-1/ISO_5_Pass_Authentication.maude",
        "errorcode": "----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce  Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  vars r r' r'' r''' r# r## r1 rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB MS N M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand. \n   ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , NB ; n(A,r))),\n             +(e(SK , n(A,r) ; NB)), \n             nil ]\n   &\n     :: r , r' :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r')),\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),\n             +(MA ; e(SK , n(B,r) ; NA)),\n             -(e(SK , NA ; n(B,r))), \n             nil ] \n   & \n     :: r  ::\n     --- Server's Strand \n    [ nil |  -(A ; NA ; B ; NB),\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A) \n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' ::\n    [ nil , -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(a ; NA),\n     \t\t -(e(mkey(a,s) , NA ; SK ; b) ; e(SK , n(b,r) ; NA)),\n     \t\t +(e(SK , NA ; n(b,r))), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "errorinfo": "Line 106 is missing part of the content.",
        "code": "----ISO Five-Pass Authentication Protocol. Cryptyc's version\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce  Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  vars r r' r'' r''' r# r## r1 rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB MS N M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n ---  A -> B : A, Ra\n ---  B -> S : A, Ra, B, Rb1\n ---  S -> B : E(Kbs:Rb1,Kab,A), E(Kas:Ra,Kab,B)\n ---  B -> A : E(Kas:Ra,Kab,B), E(Kab:Rb,Ra)\n ---  A -> B : E(Kab:Ra,Rb)\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; SK ; B) ; e(SK , NB ; n(A,r))),\n             +(e(SK , n(A,r) ; NB)), \n             nil ]\n   &\n     :: r , r' :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r')),\n             -(e(mkey(B,s) , n(B,r') ; SK ; A) ; MA),\n             +(MA ; e(SK , n(B,r) ; NA)),\n             -(e(SK , NA ; n(B,r))), \n             nil ] \n   & \n     :: r  ::\n     --- Server's Strand \n    [ nil |  -(A ; NA ; B ; NB),\n             +( e(mkey(B,s) , NB ; seskey(A , B , n(S,r)) ; A) \n              ; e(mkey(A,s) , NA ; seskey(A , B , n(S,r)) ; B) ), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r , r' ::\n--- A normal execution of the protocol \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\neq ATTACK-STATE(1) =\n:: r,r' ::\n--- An execution where the intruder finds out the Session key generated by the server \n    [ nil ,  -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n     || SK inI\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\n\neq ATTACK-STATE(2) =\n--- An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n:: r,r' ::\n    [ nil , -(a ; NA),\n     \t\t +(a ; NA ; b ; n(b,r')),\n     \t\t -(e(mkey(b,s) , n(b,r') ; SK ; a) ; MA),\n     \t\t +(MA ; e(SK , n(b,r) ; NA)),\n     \t\t -(e(SK , NA ; n(b,r))) | nil ]  \n|| empty\n|| nil\n|| nil\n|| never\n *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(a ; NA),\n     \t\t -(e(mkey(a,s) , NA ; SK ; b) ; e(SK , n(b,r) ; NA)),\n     \t\t +(e(SK , NA ; n(b,r))), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n \n[nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "logic": "---\n\n### ISO Five-Pass Authentication Protocol - Description\n\n**Overview:**\nThe ISO Five-Pass Authentication Protocol is a cryptographic protocol that facilitates secure communication between two parties, Alice (A) and Bob (B), with the involvement of a trusted server (S). The protocol employs a series of message exchanges to establish a session key (SK) while ensuring authentication and confidentiality.\n\n**Entities:**\n1. **Alice (A)**: The initiator of the protocol who wants to communicate securely with Bob.\n2. **Bob (B)**: The recipient of Alice's communication.\n3. **Server (S)**: A trusted third party that assists in the secure exchange of keys.\n\n**Key Components:**\n- **User Names (UName)**: Identifiers for Alice and Bob.\n- **Server Name (SName)**: Identifier for the server.\n- **Nonces (Nonce)**: Random numbers generated for each session to ensure freshness and prevent replay attacks.\n- **Master Keys (Masterkey)**: Secret keys shared between each user and the server, used for encrypting messages.\n- **Session Keys (Sessionkey)**: Keys generated for each session, utilized for secure communication during that session.\n- **Messages (Msg)**: The data exchanged between the entities, which can include encrypted and plain text.\n\n**Protocol Steps:**\n1. **Alice to Bob**: Alice sends her name and a nonce (Ra) to Bob. This initiates the authentication process.\n2. **Bob to Server**: Bob forwards Alice's name, the nonce Ra, and his own name to the server along with a new nonce (Rb1).\n3. **Server to Bob**: The server responds with two encrypted messages:\n   - The session key (Kab) encrypted with Bob's master key, including Bob's nonce and Alice's identity.\n   - Another message encrypted with Alice's master key, including the session key and Bob's identity.\n4. **Bob to Alice**: Bob sends the encrypted message containing Alice's nonce and the session key to Alice, confirming the session.\n5. **Alice to Bob**: Finally, Alice sends an encrypted message back to Bob containing her nonce and Bob's nonce, completing the authentication process.\n\n**Security Considerations:**\n- The use of nonces ensures that messages cannot be reused by an attacker (prevents replay attacks).\n- Encryption ensures that only the intended recipient can read the messages, maintaining confidentiality.\n- The involvement of a trusted server provides a mechanism for key distribution and enhances the security of the key exchange process.\n\n**Possible Attack Scenarios:**\n1. **Normal Execution**: The protocol executes as intended without any interference.\n2. **Session Key Exposure**: An attacker may gain knowledge of the session key generated by the server.\n3. **Man-in-the-Middle Attack**: Bob may end up communicating with an intruder instead of Alice, believing he is still in communication with her.\n\n**Conclusion:**\nThe ISO Five-Pass Authentication Protocol, as implemented in the Maude-NPA tool, provides a structured approach to secure communication between two parties while leveraging the capabilities of a trusted server. Its design incorporates essential cryptographic principles to safeguard against common threats in network communications.\n\n---",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Wed May 21 21:20:15 2025\n\n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 12711844 in 12652ms cpu (12651ms real) (1004730 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh,r':Fresh ::\n[ nil, \n   -(a ; NA:Nonce), \n   +(a ; NA:Nonce ; b ; n(b, r':Fresh)), \n   -(e(mkey(b, s), n(b, r':Fresh) ; SK:Sessionkey ; a) ; MA:Msg), \n   +(MA:Msg ; e(SK:Sessionkey, n(b, r:Fresh) ; NA:Nonce)), \n   -(e(SK:Sessionkey, NA:Nonce ; n(b, r:Fresh))) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,5) .\nrewrites: 91705658 in 69772ms cpu (69772ms real) (1314361 rewrites/second)\nresult IdSystem: < 1 . 4 . 3 . 6 . 2 . 1 > (\n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n   +(e(mkey(b, s), n(b, #4:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; a) ;\n    e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b)),\n    nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b) ;\n    e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh) ; n(a, #0:Fresh))), \n   +(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh) ; n(b, #3:Fresh))),\n    nil]  & \n:: #3:Fresh,#4:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n   -(e(mkey(b, s), n(b, #4:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; a) ;\n    e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b)), \n   +(e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b) ;\n    e(seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh) ; n(a, #0:Fresh))), \n   -(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh) ; n(b, #3:Fresh))),\n    nil] )\n|| \ne(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh) ; n(b, #3:Fresh)) !inI,\n(a ; n(a, #0:Fresh)) !inI,\n(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)) !inI,\n(e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh) ; n(a, #0:Fresh)))\n    !inI,\n(e(mkey(b, s), n(b, #4:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b))\n    !inI,\ninst(#1:UName)\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n-(a ; n(a, #0:Fresh) ; b ; n(b, #4:Fresh)), \n+(e(mkey(b, s), n(b, #4:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b)), \n-(e(mkey(b, s), n(b, #4:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; a) ; e(\n    mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b)), \n+(e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh) ; n(a, #0:Fresh))), \n-(e(mkey(a, s), n(a, #0:Fresh) ; seskey(a, b, n(#1:UName, #2:Fresh)) ; b) ; e(\n    seskey(a, b, n(#1:UName, #2:Fresh)), n(b, #3:Fresh) ; n(a, #0:Fresh))), \n+(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh) ; n(b, #3:Fresh))), \n-(e(seskey(a, b, n(#1:UName, #2:Fresh)), n(a, #0:Fresh) ; n(b, #3:Fresh)))\n|| \nnil\n|| \nnil\nBye.",
                83.60783362388611
            ]
        ]
    },
    {
        "file": "MAUDE-1/Kao-Chow_Repeated_Authentication.maude",
        "errorcode": "----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n--- successor\n\n op p : Msg -> Msg [frozen] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(A ; B ; NA),\n             -(MA ; e(SK, NA) ; n(b,r)),\n             +(e(SK, n(b,r))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "errorinfo": "Line 99 is missing part of the content.",
        "code": "----  The Kao Chow Repeated Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n--- successor\n\n op p : Msg -> Msg [frozen] .\n\n\n--- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K Kt : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n  --- A->S : A,B,Na\n  --- S->B : E(Kas:A, B, Na, Kab), E(Kbs:A, B, Na, Kab) \n  --- B->A : E(Kas:A, B, Na, Kab), E(Kab:Na), Nb\n  --- A->B : E(Kab:Nb)\n   --- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)),\n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB),\n            +(e(SK, NB)) , nil ]\n &\n    --- Bob's Strand\n    :: r :: \n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ] \n &\n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; B ; NA),\n            +( e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n    || empty\n    || nil\n    || nil\n    || nil\n[nonexec] .\n\neq ATTACK-STATE(1) =\n:: r ::\n--- An execution where the intruder finds out the Session key generated by the server \n[ nil,      -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) \n         | nil ]\n|| SK inI\n|| nil\n|| nil\n|| nil\n[nonexec] .\n\neq ATTACK-STATE(2) =\n:: r ::\n---An execution where Bob completed the protocol believing that talks to Alice, but it is not so\n    [ nil , -(MA ; e(mkey(b,s), a ; b ; NA ; SK)) , \n            +(MA ; e(SK, NA) ; n(b,r)),\n            -(e(SK, n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || never\n     *** Pattern for authentication\n     (:: R:FreshSet ::\n     [ nil | +(A ; B ; NA),\n             -(MA ; e(SK, NA) ; n(b,r)),\n             +(e(SK, n(b,r))),  nil ]\n      & S:StrandSet || K:IntruderKnowledge)\n  [nonexec] .\n\n  \n---eq USER-GRAMMARS\n---= (grl empty => e(#1:Key, #2:Msg) inL . ! S2) \n---[nonexec] .\n \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "logic": "### Description of the Kao Chow Repeated Authentication Protocol\n\nThe Kao Chow Repeated Authentication Protocol is a cryptographic protocol designed to facilitate secure authentication between users (Alice and Bob) and a server (s). The protocol employs key exchange and encryption techniques to ensure that both parties can verify each other's identities and securely communicate session keys. Below is a detailed description of the protocol's elements and steps, which serves as a basis for generating the corresponding Maude-NPA file.\n\n#### Key Components\n\n1. **Participants**: \n   - **Alice (A)**: A user who wants to authenticate to Bob via the server.\n   - **Bob (B)**: A user who wants to authenticate Alice and respond to her requests.\n   - **Server (S)**: A trusted third party that facilitates the authentication process.\n\n2. **Keys**:\n   - **Master Key (mkey)**: A symmetric key shared between each user and the server.\n   - **Session Key (seskey)**: A temporary key for a session, derived during the authentication process.\n\n3. **Nonces**:\n   - **Nonce (N)**: A unique number that can only be used once, preventing replay attacks.\n\n4. **Messages**:\n   - The protocol utilizes encrypted messages to ensure confidentiality and integrity.\n\n#### Protocol Steps\n\nThe protocol consists of the following steps:\n\n1. **Alice Initiates the Protocol**:\n   - Alice sends a message to the server that includes her identity, Bob's identity, and a nonce generated by her (Na).\n   - This message is encrypted using the master key shared between Alice and the server.\n\n2. **Server Responds**:\n   - The server responds to Alice with two encrypted messages:\n     - The first message contains the nonce Na and the session key (Kab) encrypted for Bob.\n     - The second message includes the same information encrypted for Alice.\n\n3. **Bob Receives the Message**:\n   - Bob receives the encrypted message from the server, which includes the session key (Kab) and the nonce (Na) meant for him.\n   - Bob decrypts the message using his master key.\n\n4. **Bob's Response**:\n   - Bob sends a confirmation back to Alice, encrypted with the session key, which includes a nonce generated by him (Nb).\n\n5. **Final Confirmation**:\n   - Alice receives Bob's response, decrypts it, and can now verify that she is communicating with Bob.\n\n#### Attack States\n\nThe protocol is susceptible to intruder attacks, which can be modeled in the Maude-NPA as follows:\n\n1. **Normal Execution**: Represents a successful execution of the protocol where no intruder interferes.\n2. **Session Key Discovery**: An attack where the intruder intercepts the session key generated by the server.\n3. **False Authentication**: An execution where Bob believes he is communicating with Alice, but he is actually being deceived by an intruder.\n\n### Maude File Generation\n\nBased on the description above, we can construct a Maude file that captures the structure and rules of the Kao Chow Repeated Authentication Protocol as follows:\n\n```maude\n---- The Kao Chow Repeated Authentication Protocol\n\nfmod KAOCHEW-PROTOCOL-SYMBOLS is\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  -- Sort Information \n  sorts  UName SName Name Key Nonce Masterkey Sessionkey .\n  subsort Name Nonce Key < Msg .\n  subsort Masterkey Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public .\n\n  -- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] .\n\n  -- User names\n  ops a b : -> UName .\n\n  -- Server name\n  op s : ->  SName . \n\n  -- Master key\n  op mkey : Name Name -> Masterkey [frozen] .\n\n  -- Session key\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  -- Encryption and Decryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  -- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod KAOCHEW-PROTOCOL-ALGEBRAIC is\n  protecting KAOCHEW-PROTOCOL-SYMBOLS .\n\n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod KAOCHEW-PROTOCOL-SPECIFICATION is\n  protecting KAOCHEW-PROTOCOL-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  var A B : UName .  \n  var D : Name .\n  var r r' r'' : Fresh .\n  vars NA NB : Nonce .\n  vars M1 M2 M N MA : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-PROTOCOL =\n    -- Alice's Strand\n    :: r ::\n    [ nil | +(A ; B ; n(A,r)), \n            -(e(mkey(A,s), A ; B ; n(A,r) ; SK) ; e(SK, n(A,r)) ; NB), \n            +(e(SK, NB)) , nil ]\n    &\n    -- Bob's Strand\n    :: r ::\n    [ nil | -(MA ; e(mkey(B,s), A ; B ; NA ; SK)), \n            +(MA ; e(SK, NA) ; n(B,r)),\n            -(e(SK, n(B,r))), nil ]\n    &\n    -- Server's Strand \n    :: r ::\n    [ nil | -(A ; B ; NA),\n            +(e(mkey(A,s), A ; B ; NA ; seskey(A,B,n(s,r))) \n             ; e(mkey(B,s), A ; B ; NA ; seskey(A,B,n(s,r)))), nil ]\n  [nonexec] .\n\nendfm\n\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm\n```\n\n### Explanation of the Maude File\n\n- The **KAOCHEW-PROTOCOL-SYMBOLS** module defines the sorts and operations used in the protocol.\n- The **KAOCHEW-PROTOCOL-ALGEBRAIC** module specifies the algebraic properties of encryption and decryption.\n- The **KAOCHEW-PROTOCOL-SPECIFICATION** module outlines the strands of the protocol, detailing the messages exchanged between Alice, Bob, and the server.\n- The **MAUDE-NPA** module is the final module that ties everything together and can be loaded into the Maude-NPA for analysis.\n\nThis representation captures the essential elements of the Kao Chow Repeated Authentication Protocol, allowing for verification of its security properties and potential vulnerabilities.",
        "results": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Wed Apr 30 22:33:52 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 13083357 in 11616ms cpu (11616ms real) (1126322 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(MA:Msg ; e(mkey(b, s), a ; b ; NA:Nonce ; SK:Sessionkey)), \n   +(MA:Msg ; e(SK:Sessionkey, NA:Nonce) ; n(b, r:Fresh)), \n   -(e(SK:Sessionkey, n(b, r:Fresh))) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 22021367 in 24028ms cpu (24026ms real) (916487 rewrites/second)\nresult IdSystem: < 1 . 4 . 1 . 5 . 1 > (\n:: #1:Fresh ::\n[ nil | \n   -(a ; b ; n(a, #0:Fresh)), \n   +(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    mkey(b, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh)))), nil] \n    & \n:: #2:Fresh ::\n[ nil | \n   -(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    mkey(b, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    seskey(a, b, n(s, #1:Fresh)), n(a, #0:Fresh)) ; n(b, #2:Fresh)), \n   -(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; b ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    seskey(a, b, n(s, #1:Fresh)), n(a, #0:Fresh)) ; n(b, #2:Fresh)), \n   +(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \ne(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh)) !inI,\n(a ; b ; n(a, #0:Fresh)) !inI,\n(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(mkey(\n    b, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    seskey(a, b, n(s, #1:Fresh)), n(a, #0:Fresh)) ; n(b, #2:Fresh)) !inI\n|| \n+(a ; b ; n(a, #0:Fresh)), \n-(a ; b ; n(a, #0:Fresh)), \n+(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    mkey(b, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    mkey(b, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    seskey(a, b, n(s, #1:Fresh)), n(a, #0:Fresh)) ; n(b, #2:Fresh)), \n-(e(mkey(a, s), a ; b ; n(a, #0:Fresh) ; seskey(a, b, n(s, #1:Fresh))) ; e(\n    seskey(a, b, n(s, #1:Fresh)), n(a, #0:Fresh)) ; n(b, #2:Fresh)), \n+(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                36.691041707992554
            ]
        ]
    }
]