[
    {
        "file": "SPTHY-1/9.spthy",
        "incomplete": "theory nine\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(____(PRE_1)____)),\n          !Pk(____(PRE_0)____, pk(k_S)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          !Sk($S, sk(k_S))\n        ]\n        --[  ]->\n        [ St_init_A(____(PRE_4)____, $B, ____(PRE_3)____, sk(____(POST_2)____), pk(k_A)),\n          St_init_S(____(POST_1)____, $B, $S, sk(____(POST_0)____), pk(k_A), pk(k_S)),\n          St_init_B($A, $B, $S, sk(____(PRE_2)____), pk(k_B), pk(k_S))\n        ]\n\n// ROLE A\nrule msg1_A:\n        [ St_init_A(A, B, S, sk(____(PRE_5)____), pk(k_A))\n        ]\n        --[  ]->\n        [ Out(aenc{<____(PRE_6)____, pk(k_A)>}sk(k_A)),\n          St_msg1_A(____(POST_3)____, B, S, sk(k_A), pk(k_A))\n        ]\n\nrule msg4_A:\n        [ St_msg1_A(A, ____(PRE_7)____, S, sk(k_A), pk(k_A)),\n          In(aenc{M}pk(k_A))\n        ]\n        --[  ]->\n        [ St_msg4_A(A, B, ____(PRE_8)____, S, sk(____(POST_4)____), pk(k_A))\n        ]\n\n// ROLE S\nrule msg1_S:\n    let\n        alpha = aenc{<A, pk(k_A)>}sk(k_A)\n    in\n        [ St_init_S(____(PRE_9)____, B, S, sk(k_S), pk(k_A), pk(k_S)),\n          In(alpha)\n        ]\n        --[  ]->\n        [ St_msg1_S(A, ____(PRE_10)____, S, sk(____(POST_5)____), pk(k_A), pk(k_S), alpha)\n        ]\n\nrule msg2_S:\n    let\n        alpha = aenc{<A, pk(k_A)>}sk(k_A)\n    in\n        [ St_msg1_S(A, ____(PRE_10)____, S, sk(____(POST_5)____), pk(k_A), pk(k_S), alpha),\n          In(aenc{<A, Kb>}pk(k_S))\n        ]\n        --[  ]->\n        [ St_msg2_S(A, B, Kb, S, sk(____(POST_6)____), pk(k_A), pk(k_S), ____(PRE_12)____)\n        ]\n\nrule msg3_S:\n        [ St_msg2_S(A, B, Kb, S, sk(____(POST_6)____), pk(k_A), pk(k_S), ____(PRE_12)____)\n        ]\n        --[  ]->\n        [ Out(senc{pk(k_A)}____(PRE_14)____),\n          St_msg3_S(A, B, Kb, S, sk(k_S), pk(k_A), pk(k_S), alpha)\n        ]\n\n// ROLE B\nrule msg2_B:\n        [ St_init_B(A, B, S, sk(k_B), pk(k_B), pk(____(PRE_15)____)),\n          Fr(~Kb)\n        ]\n        --[  ]->\n        [ Out(aenc{<A, ~Kb>}pk(____(POST_7)____)),\n          St_msg2_B(A, B, ~Kb, S, sk(____(PRE_16)____), pk(k_B), pk(k_S))\n        ]\n\nrule msg3_B:\n        [ St_msg2_B(A, B, Kb, S, sk(____(PRE_17)____), pk(k_B), pk(k_S)),\n          In(senc{pk(k_A)}Kb)\n        ]\n        --[  ]->\n        [ St_msg3_B(A, B, Kb, S, sk(____(POST_8)____), pk(____(PRE_18)____), pk(k_B), pk(k_S))\n        ]\n\nrule msg4_B:\n        [ St_msg3_B(A, B, Kb, S, sk(____(POST_8)____), pk(____(PRE_18)____), pk(k_B), pk(k_S)),\n          Fr(~M)\n        ]\n        --[  Secret(~M)]->\n        [ Out(aenc{____(PRE_21)____}pk(____(POST_10)____)),\n          St_msg4_B(A, ____(POST_9)____, Kb, ~M, S, sk(____(PRE_20)____), pk(k_A), pk(k_B), pk(k_S))\n        ]\n\nlemma secrecy:\n\"____(LEM_0)____ x #i.\n____(LEM_1)____(x) @i ==> not (Ex #j. K(x)@j)\"\nend",
        "complete:": "theory nine\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Pk($S, pk(k_S)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          !Sk($S, sk(k_S))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, $S, sk(k_A), pk(k_A)),\n          St_init_S($A, $B, $S, sk(k_S), pk(k_A), pk(k_S)),\n          St_init_B($A, $B, $S, sk(k_B), pk(k_B), pk(k_S))\n        ]\n\n// ROLE A\nrule msg1_A:\n        [ St_init_A(A, B, S, sk(k_A), pk(k_A))\n        ]\n        --[  ]->\n        [ Out(aenc{<A, pk(k_A)>}sk(k_A)),\n          St_msg1_A(A, B, S, sk(k_A), pk(k_A))\n        ]\n\nrule msg4_A:\n        [ St_msg1_A(A, B, S, sk(k_A), pk(k_A)),\n          In(aenc{M}pk(k_A))\n        ]\n        --[  ]->\n        [ St_msg4_A(A, B, M, S, sk(k_A), pk(k_A))\n        ]\n\n// ROLE S\nrule msg1_S:\n    let\n        alpha = aenc{<A, pk(k_A)>}sk(k_A)\n    in\n        [ St_init_S(A, B, S, sk(k_S), pk(k_A), pk(k_S)),\n          In(alpha)\n        ]\n        --[  ]->\n        [ St_msg1_S(A, B, S, sk(k_S), pk(k_A), pk(k_S), alpha)\n        ]\n\nrule msg2_S:\n    let\n        alpha = aenc{<A, pk(k_A)>}sk(k_A)\n    in\n        [ St_msg1_S(A, B, S, sk(k_S), pk(k_A), pk(k_S), alpha),\n          In(aenc{<A, Kb>}pk(k_S))\n        ]\n        --[  ]->\n        [ St_msg2_S(A, B, Kb, S, sk(k_S), pk(k_A), pk(k_S), alpha)\n        ]\n\nrule msg3_S:\n        [ St_msg2_S(A, B, Kb, S, sk(k_S), pk(k_A), pk(k_S), alpha)\n        ]\n        --[  ]->\n        [ Out(senc{pk(k_A)}Kb),\n          St_msg3_S(A, B, Kb, S, sk(k_S), pk(k_A), pk(k_S), alpha)\n        ]\n\n// ROLE B\nrule msg2_B:\n        [ St_init_B(A, B, S, sk(k_B), pk(k_B), pk(k_S)),\n          Fr(~Kb)\n        ]\n        --[  ]->\n        [ Out(aenc{<A, ~Kb>}pk(k_S)),\n          St_msg2_B(A, B, ~Kb, S, sk(k_B), pk(k_B), pk(k_S))\n        ]\n\nrule msg3_B:\n        [ St_msg2_B(A, B, Kb, S, sk(k_B), pk(k_B), pk(k_S)),\n          In(senc{pk(k_A)}Kb)\n        ]\n        --[  ]->\n        [ St_msg3_B(A, B, Kb, S, sk(k_B), pk(k_A), pk(k_B), pk(k_S))\n        ]\n\nrule msg4_B:\n        [ St_msg3_B(A, B, Kb, S, sk(k_B), pk(k_A), pk(k_B), pk(k_S)),\n          Fr(~M)\n        ]\n        --[  Secret(~M)]->\n        [ Out(aenc{~M}pk(k_A)),\n          St_msg4_B(A, B, Kb, ~M, S, sk(k_B), pk(k_A), pk(k_B), pk(k_S))\n        ]\n\nlemma secrecy:\n\"All x #i.\nSecret(x) @i ==> not (Ex #j. K(x)@j)\"\nend"
    },
    {
        "file": "SPTHY-1/ake_KEAplus.spthy",
        "incomplete": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( ____(PRE_0)____, ~lkA ), !Pk( $A, ____(POST_0)____ ), Out( pkA ) ]\n\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk(____(PRE_1)____, pkR) ]\n   -->\n   [   Init_1( ____(PRE_2)____, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(____(POST_1)____, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( ____(PRE_3)____ ) ]\n   --[ //Accept( ____(LABEL_1)____, ____(PRE_4)____, ____(LABEL_0)____, ____(PRE_5)____)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(____(PRE_6)____)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk(____(PRE_7)____, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ____(LABEL_2)____, ____(PRE_10)____, ____(PRE_9)____, ____(LABEL_3)____ )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(____(PRE_11)____, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\nlemma executable:\n  exists-trace\n  \" Ex #____(LEM_1)____ #j ____(LEM_0)____. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend",
        "complete:": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk($R, pkR) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( Y ) ]\n   --[ //Accept( ~eskI, $I, $R, kI)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(kI)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ~eskR, $R, $I, kR )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\nlemma executable:\n  exists-trace\n  \" Ex #i #j k. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend"
    },
    {
        "file": "SPTHY-1/ake_NAXOS.spthy",
        "incomplete": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, ____(PRE_0)____ ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ____(POST_0)____, $I, $R, ~lkI, ____(PRE_1)____ )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ____(PRE_2)____ , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ____(PRE_4)____, $I, $R, kI)\n     , Sid( ____(PRE_5)____, < ____(LABEL_0)____, $I, $R, hkI, ____(PRE_3)____ >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, ____(LABEL_1)____ >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* Responder */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ____(PRE_10)____), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ____(LABEL_7)____, ____(PRE_13)____, ____(LABEL_6)____, kR )\n     , Sid( ~eskR, <____(PRE_11)____, $R, $I, ____(LABEL_5)____, ____(PRE_12)____ >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(____(PRE_14)____, ~eskR),\n       !Sessk( ~eskR, ____(POST_1)____) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n/*\nlemma eCK_PFS_key_secrecy:\n  /* \n   * The property specification very closely follows the original eCK\n   * (ProvSec) paper:\n   *\n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 ____(LEM_13)____ A B k.\n    Accept(____(LEM_14)____, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend",
        "complete:": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* Responder */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n/*\nlemma eCK_PFS_key_secrecy:\n  /* \n   * The property specification very closely follows the original eCK\n   * (ProvSec) paper:\n   *\n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/alethea_sel_SmHh.spthy",
        "incomplete": "theory alethea_sel_SmHh\nbegin\n\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tAlethea's selection phase\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n- lemma functional: \t\tverified w/o oracle (and checked)\n- lemma functional2:\t\tverified w/o oracle (and checked)\n- lemma functional3: \t\tverified w/o oracle (and checked)\n\n- lemma indivVerif_ps: \t\tverified w/o oracle\n- lemma indivVerif_sel: \tverified w/o oracle\n- lemma univVerif_sel: \t\tverified w/o oracle\n\n\n*/\n/*============\nSPECIFICATION:\n============== */\n\n/*=====================\nFunctions and equations \n======================= */\nbuiltins: signing, asymmetric-encryption, hashing, symmetric-encryption, multiset\n\n\n/* ==========\nChannel rules\n============= */\nrule ChanOut_S: [Out_S($A,$B,x)]--[ChanOut_S($A,$B,x)]->[!Sec($A,$B,x)]\nrule ChanIn_S: [!Sec($A,$B,x)]--[ChanIn_S($A,$B,x)]->[In_S($A,$B,x)]\n/*\nrule ChanOut_C:\t[Out_C($A,$B,x)]--[ChanOut_C($A,$B,x)]->[!Conf($B,x)]\nrule ChanIn_C:\t[!Conf($B,x), In($A)]--[ChanIn_C($A,$B,x)]->[In_C($A,$B,x)]\nrule ChanIn_CAdv: [In(<$A,$B,x>)]--[]->[In_C($A,$B,x)]\n*/\nrule ChanOut_A: [Out_A($A,x)]--[ChanOut_A($A,x)]->[!Auth($A,x), Out(<$A,x>)]\nrule ChanIn_A:\t[!Auth($A,x)]--[ChanIn_A($A,x)]->[In_A($A,x)]\n\n\n/* =====\nProtocol\n======== */\n\nrule publickeyinfrastructure:\n   [ Fr(~skX) ]--[ LongtermKey($X,~skX) ]-> [ !Ltk(____(PRE_0)____,____(POST_0)____), !Pk($X,pk(~skX)), Out(pk(~skX)) ]\n\n\nrule Setup: \n  \t[ !Ltk('S',____(PRE_1)____), !Ltk('D1',~eskD1), !Ltk('D2',~eskD2) ] \n  \t--[ \tSetup(), \n\t\tVoter(____(PRE_2)____), \n\t\tVoter('H2'),\n\t\tDevice(____(LABEL_0)____,'D1'),\n\t\tDevice('H2','D2')\n\n\t]-> \n\t[ AgSt_D0(____(PRE_8)____,<____(PRE_5)____,____(PRE_3)____,____(POST_1)____,pk(____(POST_2)____)> )\n\t, AgSt_D0(____(PRE_7)____,<____(POST_3)____,____(PRE_4)____,~eskD2,pk(~skS)> )\n\t\n\t, Out(<'S', <____(POST_4)____,~skS, ____(PRE_6)____,'D1',pk(~eskD1), 'H2','D2',pk(~eskD2) >>) \t\n\n\t, AgSt_A0('A',<'S','BB','E'>) \n\t, AgSt_BB0('BB',<'S'>) \n\t, Env('E')\n\t\n\t\n\t, AgSt_H0('H1',<'D1','BB'>)\n\t, AgSt_H0('H2',<'D2','BB'>)\n\n\t]\n\t// leave out explicit send of \"ev\" from S to BB, assume that everyone is measuring the environment at the same moment (which would be the moment specified by \"ev\")\n\n/* leave out rule S_1a, as S is malicous and modeled by adversary rules */\n\n/* leave out rule S_1b, as S is malicous and modeled by adversary rules */\n\t\nrule BB_1:\n\t[ AgSt_BB0($BB,<$S>) \n\t, In(<$S,<'spkDs',____(PRE_9)____,spkDb >>)\n\t]\n\t--[ \tBB_spkDs(____(LABEL_1)____,<'spkDs',spkDa,____(PRE_10)____ >), //corresponds to signal BBps in thesis\n\t\tRunning_DBB($BB,spkDa), \n\t\tRunning_DBB($BB,spkDb)\n\t]->\n\t[ AgSt_BB1(____(POST_5)____,<$S,____(PRE_11)____,spkDa,spkDb > )\n\t, Out_A($BB,<'spkDs',spkDa,spkDb >)\n\n\t]\n\nrule A_1:\n\t[ AgSt_A0($A,<$S,____(PRE_12)____,$E>)\n\t, In_A($BB,<'spkDs',spkDa,spkDb >)\n\t]\n\t--[ \t]->\n\t[ AgSt_A1($A,<____(PRE_13)____,$BB,$E,'spkDs',spkDa,spkDb > )\n\t, PseudonymsPublished() \t\t\t\t// this fact models that only after this rule the event in the environment takes place. Auditors would see if this order was not preserved in reality. Thus, this fact models that at least one auditor does the check that the event in the environment happens after the voter codes have been published.\n\t]\n\nrule D_1: \n\t[ AgSt_D0($D,<____(PRE_14)____,$S,~eskD,pkS> )\n\t, In(<$S, aenc(x,pk(~eskD)) >)\n\t\n\t]\n\t--[ \tD(____(PRE_15)____), \n\t\tRunning_DS(____(PRE_17)____,$S,<pk(~eskD),pkS,h(____(PRE_16)____,____(LABEL_3)____)>),\n\t\tCommit_DBB(____(LABEL_2)____,<pk(h($H,x))>),\n\t    \tSecret($D,x),\n\t\tPseudonym($H, pk(h($H,x)))\n\t]->\n\t[ Out_S($D,$H,pk(h($H,x)) ) ]\n\nrule H_5: \n\t[ AgSt_H0($H,< $D,$BB >)\n\t, In_S($D,$H,spkDD)\n\t, In_A($BB,<'spkDs',____(PRE_18)____,____(PRE_19)____ >)\n\t] \n\t--[ \tVerify_spkDD($____(LABEL_4)____,____(PRE_20)____,spkDa,spkDb)  // corresponds to signal verify_ps(H, pkD \\in [pkD]) in thesis\n\t]-> \n\t[ AgSt_H1(____(POST_6)____,<____(PRE_21)____,$BB,spkDD,spkDa,spkDb >)]\n\n//one of the rules environment_1 or environment_2 can be triggered (only once) after the voter codes have been published\nrule environment_1:\n\t[ Env($E), PseudonymsPublished()] \n\t--[ \tEnv_No($E,'1') ]->\n\t[ Out_A($E,'1')] \n\nrule environment_2:\n\t[ Env($E), PseudonymsPublished()]\n\t--[ \tEnv_No($E,'2') ]->\n\t[ Out_A($E,'2')]\n\n/* leave out rule S_2a, as S is malicous and modeled by adversary rules */\n\n/* leave out rule S_2b, as S is malicous and modeled by adversary rules */\n\nrule BB_2:\n\t[ AgSt_BB1($BB,<____(PRE_22)____,'spkDs',spkDa,spkDb > )\n\t, In(<$S,<'SG',spkDsel>>)\n\t]\n\t--[ \tBB_SG(____(PRE_23)____,<'SG',spkDsel >),\n\t\tCommit_SBB(____(LABEL_5)____,spkDsel)\n\t]->\n\t[ Out_A($BB,<'SG',spkDsel>)\n\t]\n\nrule H_9: \n\t[ AgSt_H1(____(POST_6)____,<____(PRE_21)____,$BB,spkDD,spkDa,spkDb >),\n\t  In_A($BB,<'SG',spkDsel>)\n\t]\n\t--[     Sel($H, spkDD, spkDsel) // corresponds to signal verify_sel(H,pkD\\in[pkDSG]) in thesis\n\t]->\n\t[ ]\n\nrule A_2:\n\t[ AgSt_A1($A,<$S,$BB,$E,____(PRE_25)____,spkDa,spkDb > ),\n\t  In_A($BB,<'SG',spkDsel>),\n\t  In_A($E,____(PRE_26)____)\n\t]\n\t--[ \tVerify_SG(____(LABEL_6)____,spkDsel,r,spkDa,____(PRE_27)____)\n\t]->\n\t[ ]\n\n\n/* =========\nRESTRICTIONS\n========== */\n\n// there is only one setup\nrestriction OneSetup:\n\t\"All #i #j. Setup() @i & Setup() @j ==> #i = #j \"\n\n\n/* ====\nLEMMAS \n======= */\n/* ==================\nFunctional properties\n=================== */\nlemma functional: exists-trace  //spkD2,spkD1 in list and spkD2 chosen in SG\n\t\" Ex H1 ____(LEM_4)____ #i1 #____(LEM_6)____ spkD2 ____(LEM_5)____ BB  #j #k #____(LEM_1)____  E #m #____(LEM_13)____ #____(LEM_7)____ #____(LEM_2)____ A #q \n\t      \t.\n\t\t____(LEM_3)____ (H1 = H2)\n\t\t& ____(LEM_0)____(H1, ____(LEM_8)____) @i1\n\t\t& Pseudonym(H2, spkD2) @i2\n\t\t& BB_spkDs(BB,<'spkDs',spkD2,____(LEM_9)____ >) @j\n\t\t& Verify_spkDD(H1,____(LEM_10)____,spkD2,spkD1 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD2,spkD1 ) @l\n\t\t& ____(LEM_11)____(E,'1')\t@m\n\t\t& BB_SG(BB,<'SG',spkD2 >) @n\n\t\t& ____(LEM_12)____(H1, spkD1, spkD2) @o\n\t\t& Sel(H2, spkD2, spkD2) @p\n\t\t& Verify_SG(A,spkD2,'1',spkD2,spkD1) @q \"\n\nlemma functional2: exists-trace //spkD2,spkD1 in list and spkD1 chosen in SG\n\t\" Ex H1 ____(LEM_21)____ #____(LEM_22)____ #i2 ____(LEM_19)____ ____(LEM_16)____ ____(LEM_15)____  #____(LEM_20)____ #k #l  E #m #n #____(LEM_14)____ #____(LEM_17)____ A #q \n\t      \t.\n\t\tnot (H1 = ____(LEM_23)____)\n\t\t& Pseudonym(H1, ____(LEM_18)____) @i1\n\t\t& Pseudonym(H2, spkD2) @i2\n\t\t& BB_spkDs(BB,<'spkDs',spkD2,spkD1 >) @j\n\t\t& ____(LEM_24)____(H1,spkD1,spkD2,spkD1 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD2,spkD1 ) @l\n\t\t& Env_No(E,'2')\t@m\n\t\t& BB_SG(BB,<'____(LEM_25)____',spkD1 >) @n\n\t\t& ____(LEM_27)____(H1, spkD1, spkD1) @____(LEM_26)____\n\t\t& Sel(H2, spkD2, spkD1) @p\n\t\t& Verify_SG(A,spkD1,'2',spkD2,spkD1) @q \"\n\nlemma functional3: exists-trace //spkD1,spkD2 in list and spkD2 chosen in SG\n\t\" Ex ____(LEM_31)____ H2 #i1 #____(LEM_40)____ ____(LEM_29)____ ____(LEM_36)____ BB  #j #k #l  E #____(LEM_28)____ #n #o #p A #____(LEM_30)____ \n\t      \t.\n\t\tnot (____(LEM_32)____ = H2)\n\t\t& ____(LEM_41)____(____(LEM_34)____, ____(LEM_38)____) @i1\n\t\t& Pseudonym(H2, ____(LEM_33)____) @i2 \n\t\t& BB_spkDs(BB,<'spkDs',spkD1,____(LEM_37)____ >) @j\n\t\t& Verify_spkDD(H1,spkD1,spkD1,spkD2 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD1,spkD2 ) @l\n\t\t& ____(LEM_39)____(E,'2')\t@m\n\t\t& ____(LEM_35)____(BB,<'SG',spkD2 >) @n\n\t\t& Sel(H1, spkD1, spkD2) @o\n\t\t& Sel(H2, spkD2, spkD2) @p\n\t\t& Verify_SG(A,spkD2,'2',spkD1,spkD2) @q \"\n\n\n\n/*=================================\nIndividual verifiability properties\n=================================*/\n\nlemma indivVerif_ps: // pkD \\in [pkD] from thesis is expressed as \"either pkD is first or ____(LEM_42)____ element of [pkD]\"\n\t\" (All H spkDD spkDb #i . \n\t\tVerify_spkDD(H,spkDD,spkDD,spkDb) @i  \n\t==> (Ex BB spkD2 x #j. \n\t\tBB_spkDs(BB,<'spkDs',spkDD,spkD2 >) @j\n\t\t& spkDD =pk(h(H,x))\n\t     )\n\t    |(Ex BB spkD2 x #j.  \n\t\tBB_spkDs(BB,<'spkDs',spkD2,spkDD >) @j\n\t\t& spkDD =pk(h(H,x)) \n\t     )\n\t )\n\t& (All H spkDD spkDb #i . \n\t\tVerify_spkDD(H,spkDD,spkDb,spkDD) @i  \n\t==> (Ex BB spkD2 x #j. \n\t\tBB_spkDs(BB,<'spkDs',spkDD,spkD2 >) @j\n\t\t& spkDD =pk(h(H,x))\n\t     )\n\t    |(Ex BB spkD2 x #j.  \n\t\tBB_spkDs(BB,<'spkDs',spkD2,spkDD >) @j\n\t\t& spkDD =pk(h(H,x)) \n\t     )\n\t )\t\n\t\"\n\nlemma indivVerif_sel:\n\t\" All H ____(LEM_44)____ #____(LEM_45)____ .\n\t\tSel(H, spkDD, spkDD) @i\n\t==> Ex ____(LEM_46)____ BB #j. \n\t\tBB_SG(BB,<'SG',spkDD >) @j\n\t\t& spkDD = ____(LEM_43)____(h(H,x)) \n\t\t\"\n\n/*================================\nUniversal verifiability properties\n================================*/\n// [spkDSG]=select(r,[spkD]) means \"no matter what environment chose, selection happened accordingly.\n// we divide this into \"either r chose '1' and the first element of [spkD] is correctly chosen to be [spkDSG] or r chose '2' and the second element of [spkD] is correctly chosen to be [spkDSG]\".\n//(Formally, we rewrite (A1 or A2 -> B) to (A1 -> B and A2 -> B) which is equivalent\n\nlemma univVerif_sel: \n\t\" All ____(LEM_58)____ ____(LEM_51)____ ____(LEM_53)____ #____(LEM_50)____.\n\t\tVerify_SG(A,spkD1,'1',spkD1,____(LEM_59)____) @a1\n\t  ==> Ex BB #____(LEM_54)____ #____(LEM_57)____ .  \n\t\t// the same lists [spkD] and [spkDSG] are on BB (with the same relation)\n\t\tBB_spkDs(BB,<'____(LEM_56)____',spkD1,spkD2 >) @b1\n\t\t& ____(LEM_49)____(BB,<'SG',spkD1 >) @b2\n\t& All A spkD1 spkD2 #a1.\n\t\tVerify_SG(A,spkD2,'____(LEM_60)____',spkD1,spkD2) @a1\n\t  ==> Ex BB #b1 #b2 .  \n\t\t// the same lists [spkD] and [spkDSG] are on BB (with the same relation)\n\t\tBB_spkDs(BB,<'____(LEM_61)____',spkD1,spkD2 >) @b1\n\t\t& BB_SG(BB,<'SG',spkD2 >) @b2\n\t\t\"\n\n\n\nend",
        "complete:": "theory alethea_sel_SmHh\nbegin\n\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tAlethea's selection phase\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n- lemma functional: \t\tverified w/o oracle (and checked)\n- lemma functional2:\t\tverified w/o oracle (and checked)\n- lemma functional3: \t\tverified w/o oracle (and checked)\n\n- lemma indivVerif_ps: \t\tverified w/o oracle\n- lemma indivVerif_sel: \tverified w/o oracle\n- lemma univVerif_sel: \t\tverified w/o oracle\n\n\n*/\n/*============\nSPECIFICATION:\n============== */\n\n/*=====================\nFunctions and equations \n======================= */\nbuiltins: signing, asymmetric-encryption, hashing, symmetric-encryption, multiset\n\n\n/* ==========\nChannel rules\n============= */\nrule ChanOut_S: [Out_S($A,$B,x)]--[ChanOut_S($A,$B,x)]->[!Sec($A,$B,x)]\nrule ChanIn_S: [!Sec($A,$B,x)]--[ChanIn_S($A,$B,x)]->[In_S($A,$B,x)]\n/*\nrule ChanOut_C:\t[Out_C($A,$B,x)]--[ChanOut_C($A,$B,x)]->[!Conf($B,x)]\nrule ChanIn_C:\t[!Conf($B,x), In($A)]--[ChanIn_C($A,$B,x)]->[In_C($A,$B,x)]\nrule ChanIn_CAdv: [In(<$A,$B,x>)]--[]->[In_C($A,$B,x)]\n*/\nrule ChanOut_A: [Out_A($A,x)]--[ChanOut_A($A,x)]->[!Auth($A,x), Out(<$A,x>)]\nrule ChanIn_A:\t[!Auth($A,x)]--[ChanIn_A($A,x)]->[In_A($A,x)]\n\n\n/* =====\nProtocol\n======== */\n\nrule publickeyinfrastructure:\n   [ Fr(~skX) ]--[ LongtermKey($X,~skX) ]-> [ !Ltk($X,~skX), !Pk($X,pk(~skX)), Out(pk(~skX)) ]\n\n\nrule Setup: \n  \t[ !Ltk('S',~skS), !Ltk('D1',~eskD1), !Ltk('D2',~eskD2) ] \n  \t--[ \tSetup(), \n\t\tVoter('H1'), \n\t\tVoter('H2'),\n\t\tDevice('H1','D1'),\n\t\tDevice('H2','D2')\n\n\t]-> \n\t[ AgSt_D0('D1',<'H1','S',~eskD1,pk(~skS)> )\n\t, AgSt_D0('D2',<'H2','S',~eskD2,pk(~skS)> )\n\t\n\t, Out(<'S', <'E',~skS, 'H1','D1',pk(~eskD1), 'H2','D2',pk(~eskD2) >>) \t\n\n\t, AgSt_A0('A',<'S','BB','E'>) \n\t, AgSt_BB0('BB',<'S'>) \n\t, Env('E')\n\t\n\t\n\t, AgSt_H0('H1',<'D1','BB'>)\n\t, AgSt_H0('H2',<'D2','BB'>)\n\n\t]\n\t// leave out explicit send of \"ev\" from S to BB, assume that everyone is measuring the environment at the same moment (which would be the moment specified by \"ev\")\n\n/* leave out rule S_1a, as S is malicous and modeled by adversary rules */\n\n/* leave out rule S_1b, as S is malicous and modeled by adversary rules */\n\t\nrule BB_1:\n\t[ AgSt_BB0($BB,<$S>) \n\t, In(<$S,<'spkDs',spkDa,spkDb >>)\n\t]\n\t--[ \tBB_spkDs($BB,<'spkDs',spkDa,spkDb >), //corresponds to signal BBps in thesis\n\t\tRunning_DBB($BB,spkDa), \n\t\tRunning_DBB($BB,spkDb)\n\t]->\n\t[ AgSt_BB1($BB,<$S,'spkDs',spkDa,spkDb > )\n\t, Out_A($BB,<'spkDs',spkDa,spkDb >)\n\n\t]\n\nrule A_1:\n\t[ AgSt_A0($A,<$S,$BB,$E>)\n\t, In_A($BB,<'spkDs',spkDa,spkDb >)\n\t]\n\t--[ \t]->\n\t[ AgSt_A1($A,<$S,$BB,$E,'spkDs',spkDa,spkDb > )\n\t, PseudonymsPublished() \t\t\t\t// this fact models that only after this rule the event in the environment takes place. Auditors would see if this order was not preserved in reality. Thus, this fact models that at least one auditor does the check that the event in the environment happens after the voter codes have been published.\n\t]\n\nrule D_1: \n\t[ AgSt_D0($D,<$H,$S,~eskD,pkS> )\n\t, In(<$S, aenc(x,pk(~eskD)) >)\n\t\n\t]\n\t--[ \tD($D), \n\t\tRunning_DS($D,$S,<pk(~eskD),pkS,h($H,x)>),\n\t\tCommit_DBB($D,<pk(h($H,x))>),\n\t    \tSecret($D,x),\n\t\tPseudonym($H, pk(h($H,x)))\n\t]->\n\t[ Out_S($D,$H,pk(h($H,x)) ) ]\n\nrule H_5: \n\t[ AgSt_H0($H,< $D,$BB >)\n\t, In_S($D,$H,spkDD)\n\t, In_A($BB,<'spkDs',spkDa,spkDb >)\n\t] \n\t--[ \tVerify_spkDD($H,spkDD,spkDa,spkDb)  // corresponds to signal verify_ps(H, pkD \\in [pkD]) in thesis\n\t]-> \n\t[ AgSt_H1($H,<$D,$BB,spkDD,spkDa,spkDb >)]\n\n//one of the rules environment_1 or environment_2 can be triggered (only once) after the voter codes have been published\nrule environment_1:\n\t[ Env($E), PseudonymsPublished()] \n\t--[ \tEnv_No($E,'1') ]->\n\t[ Out_A($E,'1')] \n\nrule environment_2:\n\t[ Env($E), PseudonymsPublished()]\n\t--[ \tEnv_No($E,'2') ]->\n\t[ Out_A($E,'2')]\n\n/* leave out rule S_2a, as S is malicous and modeled by adversary rules */\n\n/* leave out rule S_2b, as S is malicous and modeled by adversary rules */\n\nrule BB_2:\n\t[ AgSt_BB1($BB,<$S,'spkDs',spkDa,spkDb > )\n\t, In(<$S,<'SG',spkDsel>>)\n\t]\n\t--[ \tBB_SG($BB,<'SG',spkDsel >),\n\t\tCommit_SBB($BB,spkDsel)\n\t]->\n\t[ Out_A($BB,<'SG',spkDsel>)\n\t]\n\nrule H_9: \n\t[ AgSt_H1($H,<$D,$BB,spkDD,spkDa,spkDb >),\n\t  In_A($BB,<'SG',spkDsel>)\n\t]\n\t--[     Sel($H, spkDD, spkDsel) // corresponds to signal verify_sel(H,pkD\\in[pkDSG]) in thesis\n\t]->\n\t[ ]\n\nrule A_2:\n\t[ AgSt_A1($A,<$S,$BB,$E,'spkDs',spkDa,spkDb > ),\n\t  In_A($BB,<'SG',spkDsel>),\n\t  In_A($E,r)\n\t]\n\t--[ \tVerify_SG($A,spkDsel,r,spkDa,spkDb)\n\t]->\n\t[ ]\n\n\n/* =========\nRESTRICTIONS\n========== */\n\n// there is only one setup\nrestriction OneSetup:\n\t\"All #i #j. Setup() @i & Setup() @j ==> #i = #j \"\n\n\n/* ====\nLEMMAS \n======= */\n/* ==================\nFunctional properties\n=================== */\nlemma functional: exists-trace  //spkD2,spkD1 in list and spkD2 chosen in SG\n\t\" Ex H1 H2 #i1 #i2 spkD2 spkD1 BB  #j #k #l  E #m #n #o #p A #q \n\t      \t.\n\t\tnot (H1 = H2)\n\t\t& Pseudonym(H1, spkD1) @i1\n\t\t& Pseudonym(H2, spkD2) @i2\n\t\t& BB_spkDs(BB,<'spkDs',spkD2,spkD1 >) @j\n\t\t& Verify_spkDD(H1,spkD1,spkD2,spkD1 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD2,spkD1 ) @l\n\t\t& Env_No(E,'1')\t@m\n\t\t& BB_SG(BB,<'SG',spkD2 >) @n\n\t\t& Sel(H1, spkD1, spkD2) @o\n\t\t& Sel(H2, spkD2, spkD2) @p\n\t\t& Verify_SG(A,spkD2,'1',spkD2,spkD1) @q \"\n\nlemma functional2: exists-trace //spkD2,spkD1 in list and spkD1 chosen in SG\n\t\" Ex H1 H2 #i1 #i2 spkD2 spkD1 BB  #j #k #l  E #m #n #o #p A #q \n\t      \t.\n\t\tnot (H1 = H2)\n\t\t& Pseudonym(H1, spkD1) @i1\n\t\t& Pseudonym(H2, spkD2) @i2\n\t\t& BB_spkDs(BB,<'spkDs',spkD2,spkD1 >) @j\n\t\t& Verify_spkDD(H1,spkD1,spkD2,spkD1 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD2,spkD1 ) @l\n\t\t& Env_No(E,'2')\t@m\n\t\t& BB_SG(BB,<'SG',spkD1 >) @n\n\t\t& Sel(H1, spkD1, spkD1) @o\n\t\t& Sel(H2, spkD2, spkD1) @p\n\t\t& Verify_SG(A,spkD1,'2',spkD2,spkD1) @q \"\n\nlemma functional3: exists-trace //spkD1,spkD2 in list and spkD2 chosen in SG\n\t\" Ex H1 H2 #i1 #i2 spkD2 spkD1 BB  #j #k #l  E #m #n #o #p A #q \n\t      \t.\n\t\tnot (H1 = H2)\n\t\t& Pseudonym(H1, spkD1) @i1\n\t\t& Pseudonym(H2, spkD2) @i2 \n\t\t& BB_spkDs(BB,<'spkDs',spkD1,spkD2 >) @j\n\t\t& Verify_spkDD(H1,spkD1,spkD1,spkD2 ) @k\n\t\t& Verify_spkDD(H2,spkD2,spkD1,spkD2 ) @l\n\t\t& Env_No(E,'2')\t@m\n\t\t& BB_SG(BB,<'SG',spkD2 >) @n\n\t\t& Sel(H1, spkD1, spkD2) @o\n\t\t& Sel(H2, spkD2, spkD2) @p\n\t\t& Verify_SG(A,spkD2,'2',spkD1,spkD2) @q \"\n\n\n\n/*=================================\nIndividual verifiability properties\n=================================*/\n\nlemma indivVerif_ps: // pkD \\in [pkD] from thesis is expressed as \"either pkD is first or second element of [pkD]\"\n\t\" (All H spkDD spkDb #i . \n\t\tVerify_spkDD(H,spkDD,spkDD,spkDb) @i  \n\t==> (Ex BB spkD2 x #j. \n\t\tBB_spkDs(BB,<'spkDs',spkDD,spkD2 >) @j\n\t\t& spkDD =pk(h(H,x))\n\t     )\n\t    |(Ex BB spkD2 x #j.  \n\t\tBB_spkDs(BB,<'spkDs',spkD2,spkDD >) @j\n\t\t& spkDD =pk(h(H,x)) \n\t     )\n\t )\n\t& (All H spkDD spkDb #i . \n\t\tVerify_spkDD(H,spkDD,spkDb,spkDD) @i  \n\t==> (Ex BB spkD2 x #j. \n\t\tBB_spkDs(BB,<'spkDs',spkDD,spkD2 >) @j\n\t\t& spkDD =pk(h(H,x))\n\t     )\n\t    |(Ex BB spkD2 x #j.  \n\t\tBB_spkDs(BB,<'spkDs',spkD2,spkDD >) @j\n\t\t& spkDD =pk(h(H,x)) \n\t     )\n\t )\t\n\t\"\n\nlemma indivVerif_sel:\n\t\" All H spkDD #i .\n\t\tSel(H, spkDD, spkDD) @i\n\t==> Ex x BB #j. \n\t\tBB_SG(BB,<'SG',spkDD >) @j\n\t\t& spkDD = pk(h(H,x)) \n\t\t\"\n\n/*================================\nUniversal verifiability properties\n================================*/\n// [spkDSG]=select(r,[spkD]) means \"no matter what environment chose, selection happened accordingly.\n// we divide this into \"either r chose '1' and the first element of [spkD] is correctly chosen to be [spkDSG] or r chose '2' and the second element of [spkD] is correctly chosen to be [spkDSG]\".\n//(Formally, we rewrite (A1 or A2 -> B) to (A1 -> B and A2 -> B) which is equivalent\n\nlemma univVerif_sel: \n\t\" All A spkD1 spkD2 #a1.\n\t\tVerify_SG(A,spkD1,'1',spkD1,spkD2) @a1\n\t  ==> Ex BB #b1 #b2 .  \n\t\t// the same lists [spkD] and [spkDSG] are on BB (with the same relation)\n\t\tBB_spkDs(BB,<'spkDs',spkD1,spkD2 >) @b1\n\t\t& BB_SG(BB,<'SG',spkD1 >) @b2\n\t& All A spkD1 spkD2 #a1.\n\t\tVerify_SG(A,spkD2,'2',spkD1,spkD2) @a1\n\t  ==> Ex BB #b1 #b2 .  \n\t\t// the same lists [spkD] and [spkDSG] are on BB (with the same relation)\n\t\tBB_spkDs(BB,<'spkDs',spkD1,spkD2 >) @b1\n\t\t& BB_SG(BB,<'SG',spkD2 >) @b2\n\t\t\"\n\n\n\nend"
    },
    {
        "file": "SPTHY-1/Artificial.spthy",
        "incomplete": "theory Artificial\nbegin\n\n/*\n   Protocol:\tExample\n   Modeler: \tSimon Meier, Benedikt Schmidt\n   Date: \tJanuary 2012\n\n   Status: \tworking\n\n   This is the example protocol P_{Ex2} in Simon Meier's PhD thesis.\n   It is also the artificial protocol from our CSF'12 paper, which we use to\n   illustrate constraint solving and characterization. Note that, for\n   characerization, you have to call the tamarin-prover as follows.\n\n    tamarin-prover --prove --stop-on-trace=NONE your_protocol.spthy\n\n   The --stop-on-trace=NONE flag ensures that all solved constraint systems\n   are explored by the constraint solver. By default, it stops as soon as the\n   first trace is found. Note that depending on the protocol,\n   characterization might take a long time, as there are many slightly\n   different possible traces.\n\n   As a more interesting example try characterizing the setup of a session-key\n   between two honest agents in the TLS.spthy example, which models a TLS\n   handshake using signatures.\n\n     tamarin-prover --prove --stop-on-trace=NONE TLS.spthy +RTS -N\n\n   Note that we add the +RTS -N to tell the Haskell runtime system that it\n   should use as many cores as your system provides. For TLS, this speeds-up\n   the proof generation/characterization quite a bit. After this call, the\n   tool will output the complete set of cases, which it had to explore for\n   finding all counter-examples to this property. Exactly, two of the cases\n   will be of the form\n\n     SOLVED // trace found\n\n   They correspond to the _only_ two ways of setting up a session-key between\n   honest agents: one for the client and one for the server.\n\n */\n\nbuiltins: symmetric-encryption\n\nrule Step1:\n  [ Fr(x), Fr(k) ] --> [ St(x, ____(PRE_0)____), Out(senc(x,k)), Key(k) ]\n\nrule Step2:\n  [ St(x, k), In(x) ] --[ Fin(x, k) ]-> [ ]\n\nrule Reveal_key:\n    [ Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\n// We search for trace-existence, as we want to characterize the possible\n// traces satisfying the given formula.\nlemma Characterize_Fin:\n  exists-trace\n  \"Ex ____(LEM_0)____ S #i.  Fin(S, k) @ i\"\n\nlemma Fin_unique:\n  \"____(LEM_3)____ S ____(LEM_1)____ #i #____(LEM_2)____. Fin(S, k) @ i & Fin(S, k) @ j ==> #i = #j\"\n\nlemma Keys_must_be_revealed:\n  \"All ____(LEM_5)____ ____(LEM_6)____ #i.  ____(LEM_4)____(S, k) @ i ==> Ex #j. Rev(k) @ j & j < i\"\n\n\nend",
        "complete:": "theory Artificial\nbegin\n\n/*\n   Protocol:\tExample\n   Modeler: \tSimon Meier, Benedikt Schmidt\n   Date: \tJanuary 2012\n\n   Status: \tworking\n\n   This is the example protocol P_{Ex2} in Simon Meier's PhD thesis.\n   It is also the artificial protocol from our CSF'12 paper, which we use to\n   illustrate constraint solving and characterization. Note that, for\n   characerization, you have to call the tamarin-prover as follows.\n\n    tamarin-prover --prove --stop-on-trace=NONE your_protocol.spthy\n\n   The --stop-on-trace=NONE flag ensures that all solved constraint systems\n   are explored by the constraint solver. By default, it stops as soon as the\n   first trace is found. Note that depending on the protocol,\n   characterization might take a long time, as there are many slightly\n   different possible traces.\n\n   As a more interesting example try characterizing the setup of a session-key\n   between two honest agents in the TLS.spthy example, which models a TLS\n   handshake using signatures.\n\n     tamarin-prover --prove --stop-on-trace=NONE TLS.spthy +RTS -N\n\n   Note that we add the +RTS -N to tell the Haskell runtime system that it\n   should use as many cores as your system provides. For TLS, this speeds-up\n   the proof generation/characterization quite a bit. After this call, the\n   tool will output the complete set of cases, which it had to explore for\n   finding all counter-examples to this property. Exactly, two of the cases\n   will be of the form\n\n     SOLVED // trace found\n\n   They correspond to the _only_ two ways of setting up a session-key between\n   honest agents: one for the client and one for the server.\n\n */\n\nbuiltins: symmetric-encryption\n\nrule Step1:\n  [ Fr(x), Fr(k) ] --> [ St(x, k), Out(senc(x,k)), Key(k) ]\n\nrule Step2:\n  [ St(x, k), In(x) ] --[ Fin(x, k) ]-> [ ]\n\nrule Reveal_key:\n    [ Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\n// We search for trace-existence, as we want to characterize the possible\n// traces satisfying the given formula.\nlemma Characterize_Fin:\n  exists-trace\n  \"Ex k S #i.  Fin(S, k) @ i\"\n\nlemma Fin_unique:\n  \"All S k #i #j. Fin(S, k) @ i & Fin(S, k) @ j ==> #i = #j\"\n\nlemma Keys_must_be_revealed:\n  \"All k S #i.  Fin(S, k) @ i ==> Ex #j. Rev(k) @ j & j < i\"\n\n\nend"
    },
    {
        "file": "SPTHY-1/auto_protocol_and_property.spthy",
        "incomplete": "theory five\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption, hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Key(____(PRE_1)____, $B, ____(PRE_0)____),\n          !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(____(PRE_3)____), pk(k_A), ____(PRE_2)____),\n          St_init_B($A, $B, sk(____(POST_0)____), pk(k_B), k_A_B)\n        ]\n\n// ROLE A\nrule msg1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), ____(PRE_4)____),\n          Fr(~N)\n        ]\n        --[  ]->\n        [ Out(senc{<A, B, ____(PRE_5)____, h(____(POST_1)____)>}____(POST_2)____),\n          St_msg1_A(A, B, ~N, sk(____(PRE_6)____), pk(k_A), k_A_B)\n        ]\n\nrule msg2_A:\n        [ St_msg1_A(A, B, N, sk(k_A), pk(k_A), k_A_B),\n          In(senc{____(PRE_7)____}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg2_A(____(POST_3)____, B, M, N, sk(k_A), pk(k_A), ____(PRE_8)____)\n        ]\n\nrule msg3_A:\n        [ St_msg2_A(____(POST_3)____, B, M, N, sk(k_A), pk(k_A), ____(PRE_8)____)\n        ]\n        --[  ]->\n        [ Out(senc{h(M)}k_A_B),\n          St_msg3_A(____(PRE_10)____, B, M, N, sk(____(POST_4)____), pk(k_A), k_A_B)\n        ]\n\n// ROLE B\nrule msg1_B:\n        [ St_init_B(____(PRE_11)____, B, sk(k_B), pk(k_B), k_A_B),\n          In(senc{<A, B, N, h(N)>}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg1_B(A, ____(PRE_12)____, N, sk(k_B), pk(k_B), k_A_B)\n        ]\n\nrule msg2_B:\n        [ St_msg1_B(A, ____(PRE_12)____, N, sk(k_B), pk(k_B), k_A_B),\n          Fr(~M)\n        ]\n        --[  ]->\n        [ Out(senc{____(POST_5)____}____(PRE_14)____),\n          St_msg2_B(A, B, ~M, N, sk(k_B), pk(k_B), k_A_B)\n        ]\n\nrule msg3_B:\n        [ St_msg2_B(A, ____(PRE_15)____, M, N, sk(k_B), pk(k_B), k_A_B),\n          In(senc{h(M)}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg3_B(A, B, M, N, sk(____(PRE_16)____), pk(k_B), ____(POST_6)____)\n        ]\n\nend",
        "complete:": "theory five\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption, hashing\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Key($A, $B, k_A_B),\n          !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), k_A_B),\n          St_init_B($A, $B, sk(k_B), pk(k_B), k_A_B)\n        ]\n\n// ROLE A\nrule msg1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), k_A_B),\n          Fr(~N)\n        ]\n        --[  ]->\n        [ Out(senc{<A, B, ~N, h(~N)>}k_A_B),\n          St_msg1_A(A, B, ~N, sk(k_A), pk(k_A), k_A_B)\n        ]\n\nrule msg2_A:\n        [ St_msg1_A(A, B, N, sk(k_A), pk(k_A), k_A_B),\n          In(senc{M}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg2_A(A, B, M, N, sk(k_A), pk(k_A), k_A_B)\n        ]\n\nrule msg3_A:\n        [ St_msg2_A(A, B, M, N, sk(k_A), pk(k_A), k_A_B)\n        ]\n        --[  ]->\n        [ Out(senc{h(M)}k_A_B),\n          St_msg3_A(A, B, M, N, sk(k_A), pk(k_A), k_A_B)\n        ]\n\n// ROLE B\nrule msg1_B:\n        [ St_init_B(A, B, sk(k_B), pk(k_B), k_A_B),\n          In(senc{<A, B, N, h(N)>}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg1_B(A, B, N, sk(k_B), pk(k_B), k_A_B)\n        ]\n\nrule msg2_B:\n        [ St_msg1_B(A, B, N, sk(k_B), pk(k_B), k_A_B),\n          Fr(~M)\n        ]\n        --[  ]->\n        [ Out(senc{~M}k_A_B),\n          St_msg2_B(A, B, ~M, N, sk(k_B), pk(k_B), k_A_B)\n        ]\n\nrule msg3_B:\n        [ St_msg2_B(A, B, M, N, sk(k_B), pk(k_B), k_A_B),\n          In(senc{h(M)}k_A_B)\n        ]\n        --[  ]->\n        [ St_msg3_B(A, B, M, N, sk(k_B), pk(k_B), k_A_B)\n        ]\n\nend"
    },
    {
        "file": "SPTHY-1/chen_kudla-1.spthy",
        "incomplete": "theory Chen_Kudla\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1, h/1\n\nsection{* A variant of the Chen-Kudla protocol that uses ordered concatenation instead \n          addition of points *}\n\n/*\n * Protocol:\tChen-Kudla (with concatenation)\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  let mpk = pmult(~msk,'P')\n  in\n  [ Fr(~msk) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk )\n  , !MPK( mpk )\n  , Out( mpk )\n  ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult(~msk, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, kdf(sek) ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( kdf(sek) ) ]\n\n\nrule Reveal_ephemeral_key:\n  [ !Ephk( ~ex ) ]\n  --[ EphkRev( ~ex ) ]->\n  [ Out( ~ex ) ]\n\n// Protocol\n\nrule Init_1:\n  let X   = pmult(~ex,'P')\n  in\n  [ Fr( ~ex )\n  ]\n  -->\n  [ Init( ____(POST_0)____, ____(PRE_0)____, $B )\n  , Out( X )\n  , !Ephk( ~ex )\n  ]\n\nrule Init_2:\n  let skA = pmult(~s1, hp($A))\n      mpk = pmult(~s2,'P')\n      X   = pmult(~ex,'P')\n      sessKey = kdf( em(hp($B), mpk)^~ex, em(skA, Y), pmult(~ex,Y), $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, $B )\n  , !MPK( ____(PRE_1)____ )\n  , !LTK( $A, skA )\n  , In( Y )\n  ]\n  --[ Accept( ____(PRE_2)____, ____(LABEL_2)____, ____(LABEL_0)____, sessKey )\n    , Sid( ~ex, <'Init',$A,$B,____(LABEL_1)____,____(PRE_3)____> )\n    // a matching session for ~ex has the following sid\n    , Match( ~ex, <____(PRE_4)____,$B,$A,X,Y> )\n    ]->\n  [ !Sessk( ~ex, sessKey ) ]\n\nrule Resp_1:\n  let skB = pmult(~msk, hp($B))\n      mpk = pmult(~msk, 'P')\n      Y = pmult(~ey,'P')\n      // instead of multiplying the two em-terms, we concatenate them\n      sessKey = kdf( em(skB, X), em(hp($A), mpk)^~ey, pmult(~ey,X), $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , !MPK( mpk )\n  , In( ____(PRE_5)____ )\n  ]\n  --[ Accept( ~ey, $B, ____(PRE_7)____, sessKey )\n    , Sid( ~ey, <'Resp',$B,____(LABEL_3)____,____(LABEL_4)____,____(PRE_6)____> )\n    // a matching session for ~ey has the following sid\n    , Match( ~ey, <____(PRE_8)____,$A,$B,____(LABEL_5)____,Y> )\n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  , !Ephk(~ey)\n  ]\n\n#ifdef executable\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #____(LEM_2)____ #j ____(LEM_0)____ ____(LEM_1)____ SID ____(LEM_4)____ t2 k.\n        Accept(t1, A, ____(LEM_3)____, k)  @ i\n      & Match(t1,  SID) @ i\n      & Accept(t2, B, A, k)  @ j\n      & Sid(t2, SID)   @ j\"\n\n#endif\n\n#ifdef secure\n\nlemma key_secrecy_ephemeral_no_WPFS:\n  /* \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(____(LEM_8)____ #i1 #i2 ____(LEM_7)____ ____(LEM_5)____ B k.\n    Accept(test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGCSetup\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (matching's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( B ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( matching ) @ i5 ))\n\n             // both ephemeral keys are revealed, this is allowed in eCK\n             // the corresponding attack uses em(hp(A),mpk)^ekmatch ...\n             | (  (Ex #i5. EphkRev( matching ) @ i5 )\n                & (Ex #i5. EphkRev( test ) @ i5 )\n               )\n\n             // (test's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( A ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( test ) @ i5 ))\n\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the ephemeral key of test was revealed\n          // in eCK, this would be allowed as long as the longterm key of test is not revealed.\n          | (Ex #i3. EphkRev( test ) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n\n#endif\n\n#ifdef attack\n\n/* For this property, there is an attack where\n   both ephemeral keys are revealed.\n*/\nlemma key_secrecy_eCK_like:\n  /* \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #____(LEM_12)____ #____(LEM_11)____ test A B ____(LEM_9)____.\n    Accept(test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGCSetup\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (matching's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( B ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( matching ) @ i5 ))\n\n             // (test's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( A ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( test ) @ i5 ))\n\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the ephemeral key of test was revealed\n          // in eCK, this would be allowed as long as the longterm key of test is not revealed.\n          | (Ex #i3. EphkRev( test ) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n#endif\n\nend",
        "complete:": "theory Chen_Kudla\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1, h/1\n\nsection{* A variant of the Chen-Kudla protocol that uses ordered concatenation instead \n          addition of points *}\n\n/*\n * Protocol:\tChen-Kudla (with concatenation)\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  let mpk = pmult(~msk,'P')\n  in\n  [ Fr(~msk) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk )\n  , !MPK( mpk )\n  , Out( mpk )\n  ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult(~msk, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, kdf(sek) ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( kdf(sek) ) ]\n\n\nrule Reveal_ephemeral_key:\n  [ !Ephk( ~ex ) ]\n  --[ EphkRev( ~ex ) ]->\n  [ Out( ~ex ) ]\n\n// Protocol\n\nrule Init_1:\n  let X   = pmult(~ex,'P')\n  in\n  [ Fr( ~ex )\n  ]\n  -->\n  [ Init( ~ex, $A, $B )\n  , Out( X )\n  , !Ephk( ~ex )\n  ]\n\nrule Init_2:\n  let skA = pmult(~s1, hp($A))\n      mpk = pmult(~s2,'P')\n      X   = pmult(~ex,'P')\n      sessKey = kdf( em(hp($B), mpk)^~ex, em(skA, Y), pmult(~ex,Y), $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, $B )\n  , !MPK( mpk )\n  , !LTK( $A, skA )\n  , In( Y )\n  ]\n  --[ Accept( ~ex, $A, $B, sessKey )\n    , Sid( ~ex, <'Init',$A,$B,X,Y> )\n    // a matching session for ~ex has the following sid\n    , Match( ~ex, <'Resp',$B,$A,X,Y> )\n    ]->\n  [ !Sessk( ~ex, sessKey ) ]\n\nrule Resp_1:\n  let skB = pmult(~msk, hp($B))\n      mpk = pmult(~msk, 'P')\n      Y = pmult(~ey,'P')\n      // instead of multiplying the two em-terms, we concatenate them\n      sessKey = kdf( em(skB, X), em(hp($A), mpk)^~ey, pmult(~ey,X), $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , !MPK( mpk )\n  , In( X )\n  ]\n  --[ Accept( ~ey, $B, $A, sessKey )\n    , Sid( ~ey, <'Resp',$B,$A,X,Y> )\n    // a matching session for ~ey has the following sid\n    , Match( ~ey, <'Init',$A,$B,X,Y> )\n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  , !Ephk(~ey)\n  ]\n\n#ifdef executable\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #i #j A B SID t1 t2 k.\n        Accept(t1, A, B, k)  @ i\n      & Match(t1,  SID) @ i\n      & Accept(t2, B, A, k)  @ j\n      & Sid(t2, SID)   @ j\"\n\n#endif\n\n#ifdef secure\n\nlemma key_secrecy_ephemeral_no_WPFS:\n  /* \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 test A B k.\n    Accept(test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGCSetup\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (matching's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( B ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( matching ) @ i5 ))\n\n             // both ephemeral keys are revealed, this is allowed in eCK\n             // the corresponding attack uses em(hp(A),mpk)^ekmatch ...\n             | (  (Ex #i5. EphkRev( matching ) @ i5 )\n                & (Ex #i5. EphkRev( test ) @ i5 )\n               )\n\n             // (test's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( A ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( test ) @ i5 ))\n\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the ephemeral key of test was revealed\n          // in eCK, this would be allowed as long as the longterm key of test is not revealed.\n          | (Ex #i3. EphkRev( test ) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n\n#endif\n\n#ifdef attack\n\n/* For this property, there is an attack where\n   both ephemeral keys are revealed.\n*/\nlemma key_secrecy_eCK_like:\n  /* \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 test A B k.\n    Accept(test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGCSetup\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (matching's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( B ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( matching ) @ i5 ))\n\n             // (test's longterm key or master key) and ephemeral key was revealed\n             | (  ((Ex #i5. LtkRev( A ) @ i5 ) | (Ex #i5. MskRev() @ i5 ))\n                & (Ex #i5. EphkRev( test ) @ i5 ))\n\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the ephemeral key of test was revealed\n          // in eCK, this would be allowed as long as the longterm key of test is not revealed.\n          | (Ex #i3. EphkRev( test ) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n#endif\n\nend"
    },
    {
        "file": "SPTHY-1/CR.spthy",
        "incomplete": "theory CR\nbegin\n\n/*\nA&B:\nA->B: na\nB->A: <h(na, k,nb), nb>\nachieves recent aliveness\n*/\n\nbuiltins: hashing\n\nrule Setup:\n  [ Fr(~k) ]\n--[ OnlyOnce() ]->\n  [ !InitLTK(~k), !RespLTK(~k) ]\n\nrule initiator:\n  [ Fr(~na) ]\n--[ Challenge(~na) ]->\n  [ Out(~na), Initiated(~na) ]\n\nrule responder:\n  [ In(na), Fr(~nb), !RespLTK(~k) ]\n--[ Response(na)]->\n  [Out(<h(na,~k,~nb), ~nb>) ]\n\nrule initiator2:\n  [ Initiated(~na), !InitLTK(~k), In(<m,nb>) ]\n--[ Alive(____(PRE_0)____) , Eq(h(~na,~k,____(LABEL_0)____),m) ]->\n  []\n\nrestriction equality:\n  \"All x y #i. Eq(x,y)@i ==> x=y\"\n\n/*\nrestriction unique:\n  \"All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j\"\n*/\n\n// FINDS PROOF AUTOMATICALLY (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma alive:\n  \"All ____(LEM_0)____ #i. Alive(x) @i ==> ____(LEM_1)____ #j. Response(x)@j\"\n\n// FINDS PROOF AUTOMATICALLY (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma recentalive:\n  \"All x #____(LEM_4)____ #____(LEM_2)____. Challenge(x)@i & Alive(x)@k ==> Ex #____(LEM_3)____. Response(x)@j & i < j & j < k\"\n  \n// SHOWS CORRECT EXECUTION (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma executable:\n  exists-trace\n  \"Ex x #____(LEM_5)____ #____(LEM_6)____. Alive(x)@i & Response(x)@j\"\n\nend",
        "complete:": "theory CR\nbegin\n\n/*\nA&B:\nA->B: na\nB->A: <h(na, k,nb), nb>\nachieves recent aliveness\n*/\n\nbuiltins: hashing\n\nrule Setup:\n  [ Fr(~k) ]\n--[ OnlyOnce() ]->\n  [ !InitLTK(~k), !RespLTK(~k) ]\n\nrule initiator:\n  [ Fr(~na) ]\n--[ Challenge(~na) ]->\n  [ Out(~na), Initiated(~na) ]\n\nrule responder:\n  [ In(na), Fr(~nb), !RespLTK(~k) ]\n--[ Response(na)]->\n  [Out(<h(na,~k,~nb), ~nb>) ]\n\nrule initiator2:\n  [ Initiated(~na), !InitLTK(~k), In(<m,nb>) ]\n--[ Alive(~na) , Eq(h(~na,~k,nb),m) ]->\n  []\n\nrestriction equality:\n  \"All x y #i. Eq(x,y)@i ==> x=y\"\n\n/*\nrestriction unique:\n  \"All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j\"\n*/\n\n// FINDS PROOF AUTOMATICALLY (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma alive:\n  \"All x #i. Alive(x) @i ==> Ex #j. Response(x)@j\"\n\n// FINDS PROOF AUTOMATICALLY (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma recentalive:\n  \"All x #i #k. Challenge(x)@i & Alive(x)@k ==> Ex #j. Response(x)@j & i < j & j < k\"\n  \n// SHOWS CORRECT EXECUTION (2017-11-03, e17bd87c47ebfdef2aef8c8ab36b5ce8ad6ebc5d)\nlemma executable:\n  exists-trace\n  \"Ex x #i #j. Alive(x)@i & Response(x)@j\"\n\nend"
    },
    {
        "file": "SPTHY-1/Ex1_solution.spthy",
        "incomplete": "theory Ex1_solution\nbegin\n\n/* ----------------- */\n/* Equational theory */\n/* ----------------- */\n\n/* Load the built-in encryption theories */\nbuiltins: symmetric-encryption, asymmetric-encryption, signing\n\n\n/* ---------------- */\n/* Public Key Setup */\n/* ---------------- */\nrule PubKey: \n   [ Fr(~ska) ] \n   --[ ]->\n   [ !SecretKey(____(POST_0)____, ____(PRE_0)____),\n     !PublicKey($A, pk(~ska)), \n     Out(<$A,pk(~ska)>) ]\n\n\nrule Compromise: \n   [ !SecretKey($A, ~ska) ] \n   --[ Compromised($A) ]->\n   [ Out(~ska) ]\n\n\n/* -------------- */\n/* Protocol rules */\n/* -------------- */\n//SOL: The fix to achieve non-ing agreement is to include Bob's identity\n//SOL: in the signature\nrule AliceSends:\n   [ Fr(~ma), Fr(~kAB), !PublicKey($B, pkB), !SecretKey(____(PRE_1)____, ~ska) ] \n   --[ RunningA($A, $B, ~ma) ]->\n   [  Out(<____(PRE_2)____, aenc(____(PRE_3)____, ____(POST_1)____), senc(<~ma, sign(<~ma, ____(POST_2)____>, ~ska)>,~kAB)>),\n   AliceSent($A,~ma,$B, ~kAB) ]\n\n\n//SOL: Include $B in signature verification\nrule BobReceived:\nlet kAB = adec(key, ~skb)\n    mtup = sdec(mess, kAB)\n    ma = fst(mtup)\n    masign = snd(mtup)\nin \n   [ In(<____(PRE_4)____, key, mess>), Fr(~mb), !SecretKey($B, ~skb), !PublicKey($A, pka) ] \n   --[  Eq(verify(masign, <____(LABEL_0)____, ____(PRE_6)____>, ____(PRE_5)____), ____(LABEL_1)____),\n        SecretB($B, $A, ~mb),  \n        FinishedB($B, $A,ma, ~mb)  ]->\n   [ Out(senc(~mb, kAB)) ]\n\nrule AliceReceives:\n// SOL: Need to do actual pattern matching, otherwise alice accepts anything.\n// SOL: Need to make `mb` fresh via `~mb`, otherwise alice accepts non _atomic_\n// terms, e.g., `<~mb, sign(...)>'\nlet messB = senc(~mb, ~kAB)\nin\n[ AliceSent($A,~ma,$B, ~kAB)\n  , In(____(PRE_7)____) ]\n--[ SecretA(____(LABEL_2)____, $B, ____(PRE_8)____), FinishedA($A, $B, ~ma, ~mb)\n   // SOL: Need to add `Neq` restriction to avoid replay of `~ma`.\n   // SOL: This is reasonable (even in a computational setting) since Bob generates\n   // SOL: the same bitstring with only negligible probability.\n   , Neq(~ma, ~mb)  ]->\n[]\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Nequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n/* ---------- */\n/* Properties */\n/* ---------- */\n\n/* Executability check: */\n//should verify\nlemma executable:\nexists-trace \"Ex #____(LEM_1)____ #j ____(LEM_0)____ B ma ____(LEM_3)____.\nFinishedA(____(LEM_2)____, B, ma, mb)@i & FinishedB(B,A,ma,mb)@j& not (A=B)\"\n \n//should verify\nlemma secrecyA:\n\"All #i m ____(LEM_8)____ ____(LEM_5)____.\n SecretA(A, ____(LEM_7)____, m) @ i ==> ( (not (____(LEM_6)____ #____(LEM_4)____. K(m) @ j)) | (Ex #j. Compromised(A)@j) | (Ex #j. Compromised(B)@j))\"\n\n//should falsify\nlemma secrecyB:\n\"____(LEM_10)____ #i m B A. \n____(LEM_11)____(B, A, m) @ i ==>  ( (not (Ex #____(LEM_9)____. ____(LEM_13)____(m) @ ____(LEM_12)____)) | (Ex #j. Compromised(A)@j) | (Ex #j. Compromised(B)@j))\"\n\n//SOL: should verify\n//SOL: Actually a bit more than aliveness since A and B agree on the message `ma`.\nlemma alivesness_B:\n\"____(LEM_14)____ #____(LEM_15)____ ma mb A ____(LEM_18)____.\nFinishedB(B, A, ma, mb) @ i ==> (Ex ____(LEM_17)____ #____(LEM_16)____. RunningA(A, C, ma) @ j) | (Ex #j. Compromised(A) @ j)\"\n\n//SOL: should verify in the 'fixed' version but not in the original version\nlemma non_inj_agreement_B:\n\"All #i ma mb ____(LEM_21)____ ____(LEM_19)____.\nFinishedB(____(LEM_20)____, A, ma, mb) @ i ==> (Ex  #____(LEM_22)____. RunningA(A, B, ma) @ j) | (Ex #j. Compromised(A) @ j)\"\n\n//SOL: should verify\nlemma non_inj_agreement_A:\n\"All #____(LEM_23)____ ma mb A ____(LEM_24)____.\nFinishedA(A, ____(LEM_26)____, ma, mb) @ i ==> (Ex #____(LEM_25)____. FinishedB(B, A, ma, mb) @ ____(LEM_27)____) | (Ex #j. Compromised(B) @ j)\"\n\n//SOL: should verify\n//SOL: Instead of writing a new authentication lemma, we can prove uniqueness\n//SOL: of `FinishedA` to get the injective agreement.\nlemma FinishedA_unique:\n\"All #i #j ____(LEM_30)____ mb ____(LEM_31)____ B1 ____(LEM_28)____ B2.\nFinishedA(A1, B1, ma, mb) @ i & FinishedA(____(LEM_29)____, B2, ma, mb) @ j ==> #i = #j\"\n\nend",
        "complete:": "theory Ex1_solution\nbegin\n\n/* ----------------- */\n/* Equational theory */\n/* ----------------- */\n\n/* Load the built-in encryption theories */\nbuiltins: symmetric-encryption, asymmetric-encryption, signing\n\n\n/* ---------------- */\n/* Public Key Setup */\n/* ---------------- */\nrule PubKey: \n   [ Fr(~ska) ] \n   --[ ]->\n   [ !SecretKey($A, ~ska),\n     !PublicKey($A, pk(~ska)), \n     Out(<$A,pk(~ska)>) ]\n\n\nrule Compromise: \n   [ !SecretKey($A, ~ska) ] \n   --[ Compromised($A) ]->\n   [ Out(~ska) ]\n\n\n/* -------------- */\n/* Protocol rules */\n/* -------------- */\n//SOL: The fix to achieve non-ing agreement is to include Bob's identity\n//SOL: in the signature\nrule AliceSends:\n   [ Fr(~ma), Fr(~kAB), !PublicKey($B, pkB), !SecretKey($A, ~ska) ] \n   --[ RunningA($A, $B, ~ma) ]->\n   [  Out(<$A, aenc(~kAB, pkB), senc(<~ma, sign(<~ma, $B>, ~ska)>,~kAB)>),\n   AliceSent($A,~ma,$B, ~kAB) ]\n\n\n//SOL: Include $B in signature verification\nrule BobReceived:\nlet kAB = adec(key, ~skb)\n    mtup = sdec(mess, kAB)\n    ma = fst(mtup)\n    masign = snd(mtup)\nin \n   [ In(<$A, key, mess>), Fr(~mb), !SecretKey($B, ~skb), !PublicKey($A, pka) ] \n   --[  Eq(verify(masign, <ma, $B>, pka), true),\n        SecretB($B, $A, ~mb),  \n        FinishedB($B, $A,ma, ~mb)  ]->\n   [ Out(senc(~mb, kAB)) ]\n\nrule AliceReceives:\n// SOL: Need to do actual pattern matching, otherwise alice accepts anything.\n// SOL: Need to make `mb` fresh via `~mb`, otherwise alice accepts non _atomic_\n// terms, e.g., `<~mb, sign(...)>'\nlet messB = senc(~mb, ~kAB)\nin\n[ AliceSent($A,~ma,$B, ~kAB)\n  , In(messB) ]\n--[ SecretA($A, $B, ~ma), FinishedA($A, $B, ~ma, ~mb)\n   // SOL: Need to add `Neq` restriction to avoid replay of `~ma`.\n   // SOL: This is reasonable (even in a computational setting) since Bob generates\n   // SOL: the same bitstring with only negligible probability.\n   , Neq(~ma, ~mb)  ]->\n[]\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Nequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n/* ---------- */\n/* Properties */\n/* ---------- */\n\n/* Executability check: */\n//should verify\nlemma executable:\nexists-trace \"Ex #i #j A B ma mb.\nFinishedA(A, B, ma, mb)@i & FinishedB(B,A,ma,mb)@j& not (A=B)\"\n \n//should verify\nlemma secrecyA:\n\"All #i m A B.\n SecretA(A, B, m) @ i ==> ( (not (Ex #j. K(m) @ j)) | (Ex #j. Compromised(A)@j) | (Ex #j. Compromised(B)@j))\"\n\n//should falsify\nlemma secrecyB:\n\"All #i m B A. \nSecretB(B, A, m) @ i ==>  ( (not (Ex #j. K(m) @ j)) | (Ex #j. Compromised(A)@j) | (Ex #j. Compromised(B)@j))\"\n\n//SOL: should verify\n//SOL: Actually a bit more than aliveness since A and B agree on the message `ma`.\nlemma alivesness_B:\n\"All #i ma mb A B.\nFinishedB(B, A, ma, mb) @ i ==> (Ex C #j. RunningA(A, C, ma) @ j) | (Ex #j. Compromised(A) @ j)\"\n\n//SOL: should verify in the 'fixed' version but not in the original version\nlemma non_inj_agreement_B:\n\"All #i ma mb A B.\nFinishedB(B, A, ma, mb) @ i ==> (Ex  #j. RunningA(A, B, ma) @ j) | (Ex #j. Compromised(A) @ j)\"\n\n//SOL: should verify\nlemma non_inj_agreement_A:\n\"All #i ma mb A B.\nFinishedA(A, B, ma, mb) @ i ==> (Ex #j. FinishedB(B, A, ma, mb) @ j) | (Ex #j. Compromised(B) @ j)\"\n\n//SOL: should verify\n//SOL: Instead of writing a new authentication lemma, we can prove uniqueness\n//SOL: of `FinishedA` to get the injective agreement.\nlemma FinishedA_unique:\n\"All #i #j ma mb A1 B1 A2 B2.\nFinishedA(A1, B1, ma, mb) @ i & FinishedA(A2, B2, ma, mb) @ j ==> #i = #j\"\n\nend"
    },
    {
        "file": "SPTHY-1/Ex2_a_solution.spthy",
        "incomplete": "theory Ex2_a_solution\nbegin\n\nfunctions: h/1\nbuiltins: symmetric-encryption, asymmetric-encryption \n\n\nrule InitServerKey:\n    [ Fr(~skS) ]\n    --[ InitServerKey(~skS) ]->\n    [ !ServerKey(~skS,pk(~skS))\n    , Out(pk(~skS)) ]\n\nrule InitClientKey:\n    [ Fr(~skA) ]\n    --[ InitClientKey(~skA) ]->\n    [ !ClientKey(~skA,pk(~skA))\n    , Out(pk(~skA)) ]\n\n// Initialize Client, and send nonce1\nrule Client_M1 [color=#ffdea6]:\n    [ Fr(~nonce1), Fr(~cid)\n    , !ServerKey(~skS, pkS)\n    , !ClientKey(____(PRE_0)____, pk(~skA)) ]\n    -->\n    [ Client(~cid, ~skA, 'INIT', ____(PRE_1)____)\n    , Out(aenc(~nonce1, pkS)) ]\n\n// Server Receives nonce1, generates nonce2 and derives the session key\nrule Server_Rcv_M1 [color=#ffdea6]:\n    let\n        msg = aenc(~nonce1, pk(~skS))\n        session_key = h(~nonce1, ~nonce2)\n    in\n    [ !ServerKey(~skS,pk(~skS))\n    , !ClientKey(~skA,pk(~skA))\n    , Fr(~sid), Fr(~nonce2), In(____(PRE_2)____) ]\n    -->\n    [ ServerState(~sid, ____(POST_0)____)\n    , Out(aenc(<____(PRE_3)____, ~nonce2>, pk(~skA))) ]\n\n// Client receives nonce2 and derives session key \nrule Client_Rcv_M2 [color=#b5f5f7]:\n    let\n        session_key = h(~nonce1, ~nonce2)\n    in\n    [ Client(~cid, ~skA, 'INIT', ____(PRE_4)____)\n    , !ServerKey(~skS, pkS)\n    , In(aenc(<~nonce1, ~nonce2>, pk(~skA))) ]\n    --[ ClientStartSession(~cid, session_key) ]->\n    [ Client(~cid, ~skA, 'SESSION', session_key) ]\n\n\n// Client sends message\nrule Client_Send_Payload [color=#b5f5f7]:\n    let\n        message = senc(~plaintext, key)\n    in\n    [ Client(____(PRE_5)____, ~skA, 'SESSION', key)\n    , Fr(~plaintext) ]\n    --[ ClientSendPayload(~cid, key) ]->\n    [ Client(____(POST_1)____, ____(PRE_6)____, 'SESSION', key),\n      Out(message) ]\n\n\nrule Server_Receive_Payload:\n    [ ServerState(~sid, key)\n    , In(senc(plaintext, key)) ]\n    -->\n    [ ServerState(~sid, key) ]\n\n// CLient ends session\nrule Client_End:\n    [ Client(~cid, ~skA, 'SESSION', key) ]\n    --[ ClientEndSession(~cid, key) ]->\n    [Client(____(PRE_7)____, ~skA, 'End', key)\n     , Out('End') ]\n\n\nrestriction one_server:\n\"All sk1 sk2 #i #j. InitServerKey(sk1) @ i & InitServerKey(sk2) @ j ==> #i = #j\"\n\nrestriction one_client:\n\"All sk1 sk2 #i #j. InitClientKey(sk1) @ i & InitClientKey(sk2) @ j ==> #i = #j\"\n\nlemma ClientWellfounded[reuse, use_induction]:\n    \"All ____(LEM_0)____ key #i .\n        ClientSendPayload(____(LEM_1)____, key) @ i\n            ==> (Ex #t. ClientStartSession(cid, key) @ t)\"\n\n\nlemma Secrecy[use_induction]:\n    \"All cid ____(LEM_2)____ #i .\n        ClientEndSession(cid, key) @ i\n            ==> not(____(LEM_3)____ #t. K(key) @ t)\"\n\n\nend",
        "complete:": "theory Ex2_a_solution\nbegin\n\nfunctions: h/1\nbuiltins: symmetric-encryption, asymmetric-encryption \n\n\nrule InitServerKey:\n    [ Fr(~skS) ]\n    --[ InitServerKey(~skS) ]->\n    [ !ServerKey(~skS,pk(~skS))\n    , Out(pk(~skS)) ]\n\nrule InitClientKey:\n    [ Fr(~skA) ]\n    --[ InitClientKey(~skA) ]->\n    [ !ClientKey(~skA,pk(~skA))\n    , Out(pk(~skA)) ]\n\n// Initialize Client, and send nonce1\nrule Client_M1 [color=#ffdea6]:\n    [ Fr(~nonce1), Fr(~cid)\n    , !ServerKey(~skS, pkS)\n    , !ClientKey(~skA, pk(~skA)) ]\n    -->\n    [ Client(~cid, ~skA, 'INIT', ~nonce1)\n    , Out(aenc(~nonce1, pkS)) ]\n\n// Server Receives nonce1, generates nonce2 and derives the session key\nrule Server_Rcv_M1 [color=#ffdea6]:\n    let\n        msg = aenc(~nonce1, pk(~skS))\n        session_key = h(~nonce1, ~nonce2)\n    in\n    [ !ServerKey(~skS,pk(~skS))\n    , !ClientKey(~skA,pk(~skA))\n    , Fr(~sid), Fr(~nonce2), In(msg) ]\n    -->\n    [ ServerState(~sid, session_key)\n    , Out(aenc(<~nonce1, ~nonce2>, pk(~skA))) ]\n\n// Client receives nonce2 and derives session key \nrule Client_Rcv_M2 [color=#b5f5f7]:\n    let\n        session_key = h(~nonce1, ~nonce2)\n    in\n    [ Client(~cid, ~skA, 'INIT', ~nonce1)\n    , !ServerKey(~skS, pkS)\n    , In(aenc(<~nonce1, ~nonce2>, pk(~skA))) ]\n    --[ ClientStartSession(~cid, session_key) ]->\n    [ Client(~cid, ~skA, 'SESSION', session_key) ]\n\n\n// Client sends message\nrule Client_Send_Payload [color=#b5f5f7]:\n    let\n        message = senc(~plaintext, key)\n    in\n    [ Client(~cid, ~skA, 'SESSION', key)\n    , Fr(~plaintext) ]\n    --[ ClientSendPayload(~cid, key) ]->\n    [ Client(~cid, ~skA, 'SESSION', key),\n      Out(message) ]\n\n\nrule Server_Receive_Payload:\n    [ ServerState(~sid, key)\n    , In(senc(plaintext, key)) ]\n    -->\n    [ ServerState(~sid, key) ]\n\n// CLient ends session\nrule Client_End:\n    [ Client(~cid, ~skA, 'SESSION', key) ]\n    --[ ClientEndSession(~cid, key) ]->\n    [Client(~cid, ~skA, 'End', key)\n     , Out('End') ]\n\n\nrestriction one_server:\n\"All sk1 sk2 #i #j. InitServerKey(sk1) @ i & InitServerKey(sk2) @ j ==> #i = #j\"\n\nrestriction one_client:\n\"All sk1 sk2 #i #j. InitClientKey(sk1) @ i & InitClientKey(sk2) @ j ==> #i = #j\"\n\nlemma ClientWellfounded[reuse, use_induction]:\n    \"All cid key #i .\n        ClientSendPayload(cid, key) @ i\n            ==> (Ex #t. ClientStartSession(cid, key) @ t)\"\n\n\nlemma Secrecy[use_induction]:\n    \"All cid key #i .\n        ClientEndSession(cid, key) @ i\n            ==> not(Ex #t. K(key) @ t)\"\n\n\nend"
    },
    {
        "file": "SPTHY-1/DH_Message_Deduction.spthy",
        "incomplete": "theory DH_Message_Deduction\nbegin\n\n\nsection{* P_Msg *}\n\n/*\n * Protocol:\tP_Msg\n * Modeler: \tBenedikt Schmidt\n * Date: \tOctober 2012\n * Source:\t\"Ph.D. Thesis: Formal Analysis of\n *               Key Exchange Protocols and Physical\n *               Protocols\"\n *\n * Status: \tWorking\n */\n\n/* This is an example protocols that is used in the\n   the thesis to demonstrate various concepts */\n\nbuiltins: diffie-hellman\n\nrule Start:\n  [ Fr(~x), Fr(~y) ]\n  --[ Start() ]->\n  [ S(~x), Out(<('g'^~x)^~y,inv(~y)>)]\n\nrule Fin:\n  [ S(~x), In(('g'^~x)) ] --[ Fin() ]-> [ ]\n\nlemma key_deducible:\n  exists-trace\n  \"Ex #i #____(LEM_1)____.\n     ____(LEM_0)____() @ i & ____(LEM_2)____() @ j\n   & (All #k. Start() @ k ==> #k = #i)\n   & (All #k. Fin() @ k   ==> #k = #j)\"\n\nend",
        "complete:": "theory DH_Message_Deduction\nbegin\n\n\nsection{* P_Msg *}\n\n/*\n * Protocol:\tP_Msg\n * Modeler: \tBenedikt Schmidt\n * Date: \tOctober 2012\n * Source:\t\"Ph.D. Thesis: Formal Analysis of\n *               Key Exchange Protocols and Physical\n *               Protocols\"\n *\n * Status: \tWorking\n */\n\n/* This is an example protocols that is used in the\n   the thesis to demonstrate various concepts */\n\nbuiltins: diffie-hellman\n\nrule Start:\n  [ Fr(~x), Fr(~y) ]\n  --[ Start() ]->\n  [ S(~x), Out(<('g'^~x)^~y,inv(~y)>)]\n\nrule Fin:\n  [ S(~x), In(('g'^~x)) ] --[ Fin() ]-> [ ]\n\nlemma key_deducible:\n  exists-trace\n  \"Ex #i #j.\n     Start() @ i & Fin() @ j\n   & (All #k. Start() @ k ==> #k = #i)\n   & (All #k. Fin() @ k   ==> #k = #j)\"\n\nend"
    },
    {
        "file": "SPTHY-1/Example-R.spthy",
        "incomplete": "/*\nInitial Example for the Tamarin Manual\n======================================\n\nAuthors: \tSimon Meier, Benedikt Schmidt\nUpdated by: \tJannik Dreier, Ralf Sasse\nDate: \t        June 2016\n\nThis file is documented in the Tamarin user manual.\n\n*/\n\ntheory running_ex_R\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\n// Registering a public key\nrule Register_pk:\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n  -->\n    [ Out(pubkey) ]\n\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n// Start a new thread executing the client role, choosing the server\n// non-deterministically.\nrule Client_1:\n    [ Fr(~k)\n    // lookup public-key of server\n    , !Pk($S, pkS)   ]\n  -->\n    [ Client_1( $S, ~k )    // Store server and key for next step of thread\n    , Out( aenc(~k, pkS) ) ]\n\nrule Client_2:\n    [ Client_1(S, k)   // Retrieve server and session key from previous step\n    , In( h(k) ) ]\n  --[ SessKeyC( S, k ) ]-> // State that the session key 'k'\n    []                     // was setup with server 'S'\n\n\nrule Serv_1:\n    [ !Ltk($S, ~ltkS)\n    , In( request ) ]\n  --[ AnswerRequest($S, adec(request, ~ltkS)) ]-> // Explanation below\n    [ Out( h(adec(request, ~ltkS)) ) ]            // Return the hash of the\n                                                  // decrypted request.\n\n\nlemma Client_session_key_secrecy:\n  \" /* It cannot be that a  */\n    not(\n      Ex ____(LEM_2)____ ____(LEM_0)____ #i #j.\n        /* client has set up a session key 'k' with a server'S' */\n        SessKeyC(S, k) @ #i\n        /* and the adversary knows 'k' */\n      & K(k) @ #j\n        /* without having performed a long-term key reveal on 'S'. */\n      & not(Ex #____(LEM_7)____. ____(LEM_3)____(S) @ r)\n    )\n  \"\n\nlemma Client_auth:\n  \" /* For all session keys 'k' setup by clients with a server 'S' */\n    ( All S k #i.  SessKeyC(S, k) @ #i\n       ==>\n         /* there is a server that answered the request */\n       ( (____(LEM_19)____ #a. ____(LEM_13)____(S, k) @ a)\n         /* or the adversary performed a long-term key reveal on 'S'\n            before the key was setup. */\n       | (Ex #____(LEM_16)____. LtkReveal(S) @ r & r < i)\n       )\n    )\n  \"\n\nlemma Client_auth_injective:\n  \" /* For all session keys 'k' setup by clients with a server 'S' */\n    ( All ____(LEM_26)____ k #____(LEM_22)____.  SessKeyC(____(LEM_27)____, k) @ #____(LEM_25)____\n       ==>\n         /* there is a server that answered the request */\n       ( (Ex #a. AnswerRequest(S, k) @ a\n           /* and there is no other client that had the same request */\n           & (All #j. SessKeyC(S, k) @ #j ==> #i = #j)\n       )\n         /* or the adversary performed a long-term key reveal on 'S'\n            before the key was setup. */\n       | (Ex #r. ____(LEM_33)____(S) @ r & r < i)\n       )\n    )\n  \"\n\nlemma Client_session_key_honest_setup:\n  exists-trace\n  \" Ex S ____(LEM_36)____ #____(LEM_37)____.\n        SessKeyC(S, k) @ #i\n      & not(Ex #r. LtkReveal(S) @ r)\n  \"\n\nend",
        "complete:": "/*\nInitial Example for the Tamarin Manual\n======================================\n\nAuthors: \tSimon Meier, Benedikt Schmidt\nUpdated by: \tJannik Dreier, Ralf Sasse\nDate: \t        June 2016\n\nThis file is documented in the Tamarin user manual.\n\n*/\n\ntheory running_ex_R\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\n// Registering a public key\nrule Register_pk:\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n  -->\n    [ Out(pubkey) ]\n\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n// Start a new thread executing the client role, choosing the server\n// non-deterministically.\nrule Client_1:\n    [ Fr(~k)\n    // lookup public-key of server\n    , !Pk($S, pkS)   ]\n  -->\n    [ Client_1( $S, ~k )    // Store server and key for next step of thread\n    , Out( aenc(~k, pkS) ) ]\n\nrule Client_2:\n    [ Client_1(S, k)   // Retrieve server and session key from previous step\n    , In( h(k) ) ]\n  --[ SessKeyC( S, k ) ]-> // State that the session key 'k'\n    []                     // was setup with server 'S'\n\n\nrule Serv_1:\n    [ !Ltk($S, ~ltkS)\n    , In( request ) ]\n  --[ AnswerRequest($S, adec(request, ~ltkS)) ]-> // Explanation below\n    [ Out( h(adec(request, ~ltkS)) ) ]            // Return the hash of the\n                                                  // decrypted request.\n\n\nlemma Client_session_key_secrecy:\n  \" /* It cannot be that a  */\n    not(\n      Ex S k #i #j.\n        /* client has set up a session key 'k' with a server'S' */\n        SessKeyC(S, k) @ #i\n        /* and the adversary knows 'k' */\n      & K(k) @ #j\n        /* without having performed a long-term key reveal on 'S'. */\n      & not(Ex #r. LtkReveal(S) @ r)\n    )\n  \"\n\nlemma Client_auth:\n  \" /* For all session keys 'k' setup by clients with a server 'S' */\n    ( All S k #i.  SessKeyC(S, k) @ #i\n       ==>\n         /* there is a server that answered the request */\n       ( (Ex #a. AnswerRequest(S, k) @ a)\n         /* or the adversary performed a long-term key reveal on 'S'\n            before the key was setup. */\n       | (Ex #r. LtkReveal(S) @ r & r < i)\n       )\n    )\n  \"\n\nlemma Client_auth_injective:\n  \" /* For all session keys 'k' setup by clients with a server 'S' */\n    ( All S k #i.  SessKeyC(S, k) @ #i\n       ==>\n         /* there is a server that answered the request */\n       ( (Ex #a. AnswerRequest(S, k) @ a\n           /* and there is no other client that had the same request */\n           & (All #j. SessKeyC(S, k) @ #j ==> #i = #j)\n       )\n         /* or the adversary performed a long-term key reveal on 'S'\n            before the key was setup. */\n       | (Ex #r. LtkReveal(S) @ r & r < i)\n       )\n    )\n  \"\n\nlemma Client_session_key_honest_setup:\n  exists-trace\n  \" Ex S k #i.\n        SessKeyC(S, k) @ #i\n      & not(Ex #r. LtkReveal(S) @ r)\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/issue193.spthy",
        "incomplete": "theory RevealingSignatures\nbegin\n\nfunctions: h/7\nbuiltins: hashing, revealing-signing\n\nrule ONE:\n  let\n    pk = pk( ~sk )\n    tSig = revealSign( ~random, ~sk )\n  in\n    [\n        Fr( ~sk )\n      , Fr( ~random )\n    ]\n  --[  ]->\n    [ Out( tSig ), Key(~sk) ]\n\nrule TWO:\n  let\n    m = getMessage( sig )\n    pk = pk( ~sk )\n  in\n    [\n        In( sig )\n      , Key( ~sk )\n    ]\n  --[ Equality(revealVerify(sig,m,pk),____(LABEL_0)____), A() ]->\n    [  ]\n\nlemma debug: exists-trace\n  \"\n    Ex #i . A() @ i\n  \"\n\nrestriction equality:\n  \" All x y #i. Equality(x,y)@i ==> x = y \"\n\nend",
        "complete:": "theory RevealingSignatures\nbegin\n\nfunctions: h/7\nbuiltins: hashing, revealing-signing\n\nrule ONE:\n  let\n    pk = pk( ~sk )\n    tSig = revealSign( ~random, ~sk )\n  in\n    [\n        Fr( ~sk )\n      , Fr( ~random )\n    ]\n  --[  ]->\n    [ Out( tSig ), Key(~sk) ]\n\nrule TWO:\n  let\n    m = getMessage( sig )\n    pk = pk( ~sk )\n  in\n    [\n        In( sig )\n      , Key( ~sk )\n    ]\n  --[ Equality(revealVerify(sig,m,pk),true), A() ]->\n    [  ]\n\nlemma debug: exists-trace\n  \"\n    Ex #i . A() @ i\n  \"\n\nrestriction equality:\n  \" All x y #i. Equality(x,y)@i ==> x = y \"\n\nend"
    },
    {
        "file": "SPTHY-1/final_protocol_and_property-6.spthy",
        "incomplete": "theory Protocol3\nbegin\n\nbuiltins: asymmetric-encryption, symmetric-encryption\n\n// Public key infrastructure\nrule Register_pk:\n    [ Fr(~ltk) ]\n    -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n    -->\n    [ Out(pubkey) ]\n\n// Protocol\nrule A_1:\n    let pkB = pk(~ltkB)\n    in\n    [ Fr(~key), !Pk(B, pkB) ]\n    --[ Send(____(PRE_0)____, <A, senc(<A, M>, ____(LABEL_0)____)>) ]->\n    [ Out(<____(POST_0)____, senc(<A, M>, ____(PRE_1)____)>), A_State_1(A, B, ~key, pkB) ]\n\nrule B_1:\n    let M = adec(snd(msg), ~ltkB)\n        pkB = pk(~ltkB)\n    in\n    [ !Ltk(____(PRE_2)____, ~ltkB), In(<A, senc(<A, M>, key)>), Fr(~n) ]\n    --[ Recv(____(LABEL_1)____, <____(PRE_3)____, senc(<A, M>, key)>), Send(B, ~n) ]->\n    [ Out(~n), B_State_1(____(PRE_4)____, ____(POST_1)____, key, ~n, pkB) ]\n\nrule A_2:\n    [ A_State_1(A, B, ____(PRE_5)____, pkB), In(n) ]\n    --[ Send(A, aenc(<n, key>, pkB)) ]->\n    [ Out(aenc(<n, key>, pkB)) ]\n\nrule B_2:\n    let pkB = pk(~ltkB)\n    in\n    [ B_State_1(____(PRE_6)____, ____(PRE_7)____, key, n, pkB), !Ltk(B, ~ltkB), In(aenc(<n, key>, pkB)) ] \n    --[ Authentic(____(LABEL_2)____, ____(PRE_8)____), Recv(B, aenc(<n, key>, pkB)) ]->\n    []\n\n// Property\nlemma message_authentication:\n    \"All ____(LEM_0)____ ____(LEM_2)____ #____(LEM_1)____. Authentic(b,m) @i \n    ==> (Ex #j. Send(b,m) @j & j<i)\"\n\nend",
        "complete:": "theory Protocol3\nbegin\n\nbuiltins: asymmetric-encryption, symmetric-encryption\n\n// Public key infrastructure\nrule Register_pk:\n    [ Fr(~ltk) ]\n    -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n    [ !Pk(A, pubkey) ]\n    -->\n    [ Out(pubkey) ]\n\n// Protocol\nrule A_1:\n    let pkB = pk(~ltkB)\n    in\n    [ Fr(~key), !Pk(B, pkB) ]\n    --[ Send(A, <A, senc(<A, M>, ~key)>) ]->\n    [ Out(<A, senc(<A, M>, ~key)>), A_State_1(A, B, ~key, pkB) ]\n\nrule B_1:\n    let M = adec(snd(msg), ~ltkB)\n        pkB = pk(~ltkB)\n    in\n    [ !Ltk(B, ~ltkB), In(<A, senc(<A, M>, key)>), Fr(~n) ]\n    --[ Recv(B, <A, senc(<A, M>, key)>), Send(B, ~n) ]->\n    [ Out(~n), B_State_1(B, A, key, ~n, pkB) ]\n\nrule A_2:\n    [ A_State_1(A, B, key, pkB), In(n) ]\n    --[ Send(A, aenc(<n, key>, pkB)) ]->\n    [ Out(aenc(<n, key>, pkB)) ]\n\nrule B_2:\n    let pkB = pk(~ltkB)\n    in\n    [ B_State_1(B, A, key, n, pkB), !Ltk(B, ~ltkB), In(aenc(<n, key>, pkB)) ] \n    --[ Authentic(B, n), Recv(B, aenc(<n, key>, pkB)) ]->\n    []\n\n// Property\nlemma message_authentication:\n    \"All b m #i. Authentic(b,m) @i \n    ==> (Ex #j. Send(b,m) @j & j<i)\"\n\nend"
    },
    {
        "file": "SPTHY-1/Google2Step_EA.spthy",
        "incomplete": "theory Google2Step_EA\nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tGoogle 2-step\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=infallible\n- lemma functional (exists-trace): verified (7 steps)\n- lemma entity_authentication (all-traces): verified (7 steps)\n- lemma device_authentication (all-traces): verified (7 steps)\n\n\n\n// for -D=untrained\n- lemma functional (exists-trace): verified (7 steps)\n- lemma entity_authentication (all-traces): verified (5 steps)\n- lemma device_authentication (all-traces): verified (5 steps)\n\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing\nfunctions: pw/1, code/1  // used to give password and code a type.\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"____(LEM_0)____ (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh(____(LABEL_0)____,$x.1,____(PRE_0)____), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive(____(LABEL_1)____,$x.1,____(PRE_1)____), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send(____(LABEL_2)____,$x.1,x.2),\n\t\tH($H), To(____(PRE_2)____)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive(____(PRE_3)____,$x.1,____(LABEL_3)____), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,____(PRE_4)____,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send($H,____(LABEL_4)____,x.2), \n  \t    Send($H,____(PRE_5)____,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S(____(PRE_6)____,____(POST_0)____,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,____(PRE_4)____,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(____(PRE_8)____,$x.1,x.2), \n\t    Send(____(PRE_9)____,$y.1,y.2),\n\t    Send($H,____(LABEL_5)____,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1>,<x.2,____(PRE_10)____,____(POST_1)____>) ]\n\nrule H_send_S4:\n\t[ !HK($H,____(PRE_4)____,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send(____(LABEL_6)____,____(LABEL_7)____,x.2), \n\t\tSend($H,____(PRE_13)____,y.2),\n\t\tSend($H,____(PRE_14)____,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S(____(PRE_16)____,____(PRE_15)____,<$x.1,$y.1,$z.1,____(POST_2)____>,<x.2,y.2,z.2,____(POST_3)____>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( ____(PRE_17)____,$H, <$x.1,$y.1>, <x.2,y.2> ) ]\n\t--[ Receive(____(PRE_19)____,____(PRE_18)____,x.2), \n\t\tReceive($H,____(LABEL_8)____,y.2), !HK(____(PRE_20)____,$x.1,x.2),!HK($H,____(POST_4)____,y.2),\n\t\tH($H), From(____(LABEL_9)____)]->\n\t[ !HK(____(PRE_20)____,$x.1,x.2),!HK($H,____(POST_4)____,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,$H, <____(PRE_21)____,$y.1,$z.1,____(PRE_22)____>,<x.2,y.2,z.2,v.2> ) ]\n\t--[     Receive(____(LABEL_10)____,$x.1,x.2), \n\t\tReceive(____(LABEL_12)____,$y.1,y.2), \n\t\tReceive($H,____(LABEL_13)____,z.2), \n\t\tReceive($H,____(LABEL_11)____,____(LABEL_14)____), !HK(____(POST_6)____,____(PRE_4)____,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,____(POST_5)____,v.2),\n\t\tH($H), From($A)]->\n\t[ !HK(____(POST_6)____,____(PRE_4)____,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,____(POST_5)____,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth(____(POST_7)____,xn,____(PRE_30)____), Out(<$A,$B,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\nrule passworddistribution:\n\t[Fr(~pw)]\n\t--[PasswordHS($X,$Y,~pw)]->\n\t[!Password($X,$Y,~pw)]\n\nrule Setup:\n  \t[ !Password($H,$S,~pw) ] \n  \t--[ Setup(____(PRE_33)____), Roles(____(PRE_34)____,____(PRE_32)____,____(LABEL_17)____,____(PRE_31)____), Device(____(LABEL_18)____,$D)\n\t\t,InitK($H,____(LABEL_15)____,$D),InitK($H,'P',$P),InitK($H,'S',____(LABEL_19)____),InitK($H,'pw',pw(~pw)),InitK($H,'H',$H), InitK($H,____(PRE_35)____,____(LABEL_16)____)\n \t]-> \n  \t[AgSt_D0($D,'D_0',< ____(PRE_36)____ >),\n\tAgSt_S0(____(PRE_38)____,'S_0',< ____(PRE_37)____, ____(POST_10)____, $D, pw(____(PRE_41)____) >) \n\n\t,!HK(____(PRE_39)____,'D',$D),!HK(____(PRE_40)____,'P',$P),!HK(____(POST_11)____,'S',$S),!HK($H,'pw',pw(____(POST_9)____)),!HK($H,'H',$H), !HK($H,'idH',$idH)\n\t, AgSt_H0($H,____(POST_8)____,< $P, $D, $S, pw(____(PRE_48)____), $idH >)\n  \t]\n\n/* agent rules */\nrule D_3:\n\t[ AgSt_D0($D,____(PRE_42)____,< $H >), In_C($S,$D,'l',code(~c))]\n\t--[Dfin(), D($D)]->\n\t[ Out_S($D,$H,'code',code(~c)) ]\n\nrule S_2:\n\t[ AgSt_S0($S,'S_0',< $H, $idH, $D, pw(____(PRE_43)____) >), In($idH), Fr(~c)] \n\t--[ Sstart($S) ]->\n \t[ AgSt_S3(____(PRE_45)____,____(PRE_44)____,< $H, $idH, $D, pw(~pw), code(~c) >), Out_C(____(POST_12)____,$D,'l',code(~c))]\nrule S_6:\n\t[ AgSt_S3($S,'S_3',< $H, $idH, $D, pw(~pw), code(____(PRE_46)____) >), In(<code(~c),pw(~pw)>)]\n\t--[Commit(____(PRE_47)____,$H,pw(~pw)), CommitCA($S,$H) ]->\n\t[]\n\n\n/* human agent rules */\nrule H_1:\n\t[ AgSt_H0($H,'H_0',< $P, $D, $S, pw(____(PRE_48)____), $idH >) ]\n\t--[H_role(____(PRE_50)____,'1'), Send($H,____(LABEL_21)____,$S), Send($H,'idH',$idH), Send($H,____(PRE_49)____,pw(____(LABEL_20)____)) ]->\n\t[ AgSt_H1($H,'H_1',< $P, $D, ____(POST_13)____, pw(____(PRE_52)____), ____(PRE_51)____ >), Out(< <'S','idH','pw' >,<$S,$idH,pw(~pw)> >)]\n\nrule H_4:\n\t[ AgSt_H1($H,'H_1',< $P, $D, $S, pw(~pw), $idH >), In_S($D,$H,____(PRE_53)____,code(____(PRE_54)____))]\n\t--[H_role(____(LABEL_22)____,____(PRE_55)____), Receive(____(LABEL_23)____,'code',code(____(PRE_56)____)), Send($H,'S',$S), Send($H,'code',code(~c))]->\n\t[ Out(< <'S','code'>,<$S,code(~c)> >)]\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\t\n\n/* lemmas */\n\n/* Functionality Lemma */\n\nlemma functional: exists-trace\n\t\"(All H1 ____(LEM_5)____ #____(LEM_3)____ #____(LEM_1)____. Setup(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (____(LEM_4)____ #k #____(LEM_2)____ S m \n\t\t.\n\t\tDfin() @k\n\t\t& Commit(S,'Human',m) @n\n\t\t\n\t\t)\"\n\n/* Entity and Device Authentication */\n\nlemma entity_authentication: \n\t\"All S m #____(LEM_9)____. Commit(S,'Human',m) @k ==> \n\t\t(Ex #____(LEM_7)____ #____(LEM_6)____. Sstart(S)@____(LEM_10)____ & H('Human') @j & ____(LEM_11)____<j &j<k) \t\t//in case ____(LEM_12)____ untrained human ____(LEM_8)____ ____(LEM_15)____ used\n\t\t|(Ex x #____(LEM_13)____ #j. Sstart(S)@i & H_role('Human',x) @j& i<j &j<k) \t//in case when (infallible) human agent ____(LEM_14)____ are used\n\t\t\n\t\"\n\nlemma device_authentication: \n\t\"All S #k. CommitCA(S,'Human') @k ==> \n\t\t(____(LEM_18)____ ____(LEM_16)____ #i #____(LEM_17)____ #____(LEM_19)____. Sstart(S)@i & D(D) @____(LEM_20)____ & i<j &j<k & Device('Human',D) @s )\t\t\n\t\"\n\n\n\n\n\n\nend",
        "complete:": "theory Google2Step_EA\nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tGoogle 2-step\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=infallible\n- lemma functional (exists-trace): verified (7 steps)\n- lemma entity_authentication (all-traces): verified (7 steps)\n- lemma device_authentication (all-traces): verified (7 steps)\n\n\n\n// for -D=untrained\n- lemma functional (exists-trace): verified (7 steps)\n- lemma entity_authentication (all-traces): verified (5 steps)\n- lemma device_authentication (all-traces): verified (5 steps)\n\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing\nfunctions: pw/1, code/1  // used to give password and code a type.\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"not (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh($H,$x.1,~x), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send($H,$x.1,x.2), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send($H,$x.1,x.2), \n\t    Send($H,$y.1,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1>,<x.2,y.2,z.2>) ]\n\nrule H_send_S4:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send($H,$x.1,x.2), \n\t\tSend($H,$y.1,y.2),\n\t\tSend($H,$z.1,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1,$w.1>,<x.2,y.2,z.2,w.2>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( $A,$H, <$x.1,$y.1>, <x.2,y.2> ) ]\n\t--[ Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), !HK($H,$x.1,x.2),!HK($H,$y.1,y.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,$H, <$x.1,$y.1,$z.1,$v.1>,<x.2,y.2,z.2,v.2> ) ]\n\t--[     Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), \n\t\tReceive($H,$z.1,z.2), \n\t\tReceive($H,$v.1,v.2), !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth($A,xn,x), Out(<$A,$B,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\nrule passworddistribution:\n\t[Fr(~pw)]\n\t--[PasswordHS($X,$Y,~pw)]->\n\t[!Password($X,$Y,~pw)]\n\nrule Setup:\n  \t[ !Password($H,$S,~pw) ] \n  \t--[ Setup($H), Roles($H,$D,$P,$S), Device($H,$D)\n\t\t,InitK($H,'D',$D),InitK($H,'P',$P),InitK($H,'S',$S),InitK($H,'pw',pw(~pw)),InitK($H,'H',$H), InitK($H,'idH',$idH)\n \t]-> \n  \t[AgSt_D0($D,'D_0',< $H >),\n\tAgSt_S0($S,'S_0',< $H, $idH, $D, pw(~pw) >) \n\n\t,!HK($H,'D',$D),!HK($H,'P',$P),!HK($H,'S',$S),!HK($H,'pw',pw(~pw)),!HK($H,'H',$H), !HK($H,'idH',$idH)\n\t, AgSt_H0($H,'H_0',< $P, $D, $S, pw(~pw), $idH >)\n  \t]\n\n/* agent rules */\nrule D_3:\n\t[ AgSt_D0($D,'D_0',< $H >), In_C($S,$D,'l',code(~c))]\n\t--[Dfin(), D($D)]->\n\t[ Out_S($D,$H,'code',code(~c)) ]\n\nrule S_2:\n\t[ AgSt_S0($S,'S_0',< $H, $idH, $D, pw(~pw) >), In($idH), Fr(~c)] \n\t--[ Sstart($S) ]->\n \t[ AgSt_S3($S,'S_3',< $H, $idH, $D, pw(~pw), code(~c) >), Out_C($S,$D,'l',code(~c))]\nrule S_6:\n\t[ AgSt_S3($S,'S_3',< $H, $idH, $D, pw(~pw), code(~c) >), In(<code(~c),pw(~pw)>)]\n\t--[Commit($S,$H,pw(~pw)), CommitCA($S,$H) ]->\n\t[]\n\n\n/* human agent rules */\nrule H_1:\n\t[ AgSt_H0($H,'H_0',< $P, $D, $S, pw(~pw), $idH >) ]\n\t--[H_role($H,'1'), Send($H,'S',$S), Send($H,'idH',$idH), Send($H,'pw',pw(~pw)) ]->\n\t[ AgSt_H1($H,'H_1',< $P, $D, $S, pw(~pw), $idH >), Out(< <'S','idH','pw' >,<$S,$idH,pw(~pw)> >)]\n\nrule H_4:\n\t[ AgSt_H1($H,'H_1',< $P, $D, $S, pw(~pw), $idH >), In_S($D,$H,'code',code(~c))]\n\t--[H_role($H,'4'), Receive($H,'code',code(~c)), Send($H,'S',$S), Send($H,'code',code(~c))]->\n\t[ Out(< <'S','code'>,<$S,code(~c)> >)]\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\t\n\n/* lemmas */\n\n/* Functionality Lemma */\n\nlemma functional: exists-trace\n\t\"(All H1 H2 #i #j. Setup(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (Ex #k #n S m \n\t\t.\n\t\tDfin() @k\n\t\t& Commit(S,'Human',m) @n\n\t\t\n\t\t)\"\n\n/* Entity and Device Authentication */\n\nlemma entity_authentication: \n\t\"All S m #k. Commit(S,'Human',m) @k ==> \n\t\t(Ex #i #j. Sstart(S)@i & H('Human') @j & i<j &j<k) \t\t//in case when untrained human rules are used\n\t\t|(Ex x #i #j. Sstart(S)@i & H_role('Human',x) @j& i<j &j<k) \t//in case when (infallible) human agent rules are used\n\t\t\n\t\"\n\nlemma device_authentication: \n\t\"All S #k. CommitCA(S,'Human') @k ==> \n\t\t(Ex D #i #j #s. Sstart(S)@i & D(D) @j & i<j &j<k & Device('Human',D) @s )\t\t\n\t\"\n\n\n\n\n\n\nend"
    },
    {
        "file": "SPTHY-1/injectivity.spthy",
        "incomplete": "/*\n   Protocol:    Injectivity test\n   Modeler:     Nick Moore\n   Date:        May 2017\n\n   Status:      working\n\n   A simple toy example that requires the injectivity constraint-reduction rule\n   to terminate.\n\n*/\n\ntheory injectivity begin\n\nrule Init:\n  [ Fr(~i) ]\n--[ Initiated(~i) ]->\n  [ Inj(~i) ]\n\nrule Copy:\n  [ Inj(i) ]\n--[ Copied(i) ]->\n  [ Inj(i) ]\n\nrule Remove:\n  [ Inj(i) ]\n--[ Removed(i) ]->\n  []\n\nlemma injectivity_check[use_induction]: all-traces\n  \"\u00ac(Ex id #____(LEM_0)____ #____(LEM_1)____ #k.\n        Initiated(id) @ i & Removed(id) @ ____(LEM_2)____ & Copied(id) @ k\n        & #i < #j & #j < #k)\"\n\nend",
        "complete:": "/*\n   Protocol:    Injectivity test\n   Modeler:     Nick Moore\n   Date:        May 2017\n\n   Status:      working\n\n   A simple toy example that requires the injectivity constraint-reduction rule\n   to terminate.\n\n*/\n\ntheory injectivity begin\n\nrule Init:\n  [ Fr(~i) ]\n--[ Initiated(~i) ]->\n  [ Inj(~i) ]\n\nrule Copy:\n  [ Inj(i) ]\n--[ Copied(i) ]->\n  [ Inj(i) ]\n\nrule Remove:\n  [ Inj(i) ]\n--[ Removed(i) ]->\n  []\n\nlemma injectivity_check[use_induction]: all-traces\n  \"\u00ac(Ex id #i #j #k.\n        Initiated(id) @ i & Removed(id) @ j & Copied(id) @ k\n        & #i < #j & #j < #k)\"\n\nend"
    },
    {
        "file": "SPTHY-1/JCS12_Typing_Example.spthy",
        "incomplete": "theory JCS12_Typing_Example\nbegin\n\n/*\n   Protocol:    Typing Assertion Example from our JCS'12 paper [1]\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working\n\n   Notable differences: We do not require a fixed type system. Instead we\n   introduce actions marking sent cryptographic components and actions marking\n   that a participant instantiated a variable, which it received as part of a\n   cryptographic component. The sources assertion is then the trace formula\n   stating that this variable was either known to the adversary before it was\n   instantiated or the cryptographic component stems from the expected origin.\n\n   [1] Efficient Construction of Machine-Checked Symbolic Protocol Security\n   Proofs.  S. Meier, C. Cremers, D. Basin.  Journal of Computer Security.  To\n   appear.\n*/\n\n\nbuiltins: asymmetric-encryption, hashing\n\n// Public-Key Infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ]\n  -->\n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n  [ !Pk(A, pk) ]\n  -->\n  [ Out(pk) ]\n\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Client_1:\n  let request = aenc{'1', <$C, ~k>}pkS\n  in\n    [ Fr(~k), !Pk($S, pkS)\n    ]\n  --[ Out_Client_1(request)\n    ]->\n    [ Client_1( $C, $S, ~k ), Out( request ) ]\n\nrule Client_2:\n    [ Client_1(____(PRE_0)____, S, k), In( aenc{'2',k}pk(ltkC) ), !Ltk(C, ltkC) ]\n  --[ SessKeyC( C, S, k ) ]->\n    []\n\n// A server thread answering in one-step to a session-key setup request from\n// some client.\nrule Serv_1:\n  let msg = adec(request, ~ltkS)\n      tag = fst(msg)\n      C   = fst(snd(msg))\n      k   = snd(snd(msg))\n  in\n    [ !Ltk($S, ~ltkS)\n    , In( request )\n    , !Pk(____(PRE_1)____, pkC)\n    ]\n  --[ Eq(tag, '1')  // This check is crucial to avoid receiving the\n                    // message output in this step as a client\n                    // message. Try proving the Client_auth lemma\n                    // without it to see the problem. (If you bound\n                    // the proof depth and use the GUI, then you can see that\n                    // there is the option that, without this check, servers\n                    // just forward messages to further servers.)\n    , ReceivedKey(C, ____(LABEL_0)____, k)\n    , In_Serv_1(____(PRE_2)____, k)\n    ]->\n    [ Out( aenc{'2',k}pkC ) ]\n\n/* This is our sources assertion. It follows the construction outline above and\n * uses the same trick as [1] to account for the interaction of the adversary,\n * who doesn't have to follow a typing discipline.\n */\nlemma typing_assertion [sources]:\n  \"(All m ____(LEM_1)____ #____(LEM_3)____. In_Serv_1(m, v) @ i ==>\n      ( (____(LEM_2)____ #j. KU(v) @ j & j < i)\n      | (Ex #j. ____(LEM_0)____(m) @ j)\n      )\n   )\n  \"\n\n/* We formulate the following lemma over the actions on adversary message\n * deductions.  This is the core secrecy lemma, which verify for the traces of\n * the normal form dependency graphs of the protocol. We afterwards reuse it\n * in the proof of the two security properties formulated over the standard\n * traces of the protocol.\n */\nlemma Client_session_key_secrecy_raw [reuse]:\n  \"  /* For all traces, we have that */\n     All S ____(LEM_13)____ ____(LEM_4)____ #____(LEM_12)____ #j.\n        /* if client setup a session key 'k' with a server'S' */\n        ____(LEM_14)____(C, S, ____(LEM_8)____) @ #i\n        /* and the adversary deduced 'k' */\n      & KU(k) @ #j\n        /* the he must have performed a long-term key reveal on 'S' or 'C'\n         * before learning the key 'k'. */\n      ==>\n       ( (Ex #r. ____(LEM_11)____(S) @ r & r < j)\n       | (Ex #r. LtkReveal(C) @ r & r < j)\n       )\n  \"\n\n// Check the proof of this lemma. It consists only of showing that the above\n// lemma implies this one.\nlemma Client_session_key_secrecy:\n  \"  /* For all traces, we have that */\n     All S ____(LEM_23)____ ____(LEM_18)____ #i #____(LEM_21)____.\n        /* if client setup a session key 'k' with a server'S' */\n        SessKeyC(____(LEM_24)____, S, k) @ #i\n        /* and the adversary knows 'k' */\n      & K(k) @ #j\n        /* the he must have performed a long-term key reveal on 'S' or 'C'\n         * before learning the key 'k'. */\n      ==>\n       ( (Ex #r. LtkReveal(S) @ r & r < j)\n       | (Ex #r. LtkReveal(C) @ r & r < j)\n       )\n  \"\n\nlemma Client_auth:\n  /* For all traces satisfying all equality checks */\n  \" (All x y #____(LEM_33)____. ____(LEM_41)____(x,y) @ ____(LEM_34)____ ==> x = y)\n  ==>\n    ( All ____(LEM_30)____ ____(LEM_39)____ k #____(LEM_36)____.  SessKeyC(____(LEM_42)____, S, k) @ #____(LEM_37)____\n       /* for all session keys 'k' setup by clients with a server 'S' */\n       ==>\n         /* there is a server that answered the request */\n       ( (Ex #a. ReceivedKey(C, S, k) @ a)\n         /* or the intruder performed a long-term key reveal on 'S' or 'C'\n            before the key was setup. */\n       | (Ex #r. LtkReveal(S) @ r & r < i)\n       | (Ex #r. LtkReveal(C) @ r & r < i)\n       )\n    )\n  \"\n\nend",
        "complete:": "theory JCS12_Typing_Example\nbegin\n\n/*\n   Protocol:    Typing Assertion Example from our JCS'12 paper [1]\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working\n\n   Notable differences: We do not require a fixed type system. Instead we\n   introduce actions marking sent cryptographic components and actions marking\n   that a participant instantiated a variable, which it received as part of a\n   cryptographic component. The sources assertion is then the trace formula\n   stating that this variable was either known to the adversary before it was\n   instantiated or the cryptographic component stems from the expected origin.\n\n   [1] Efficient Construction of Machine-Checked Symbolic Protocol Security\n   Proofs.  S. Meier, C. Cremers, D. Basin.  Journal of Computer Security.  To\n   appear.\n*/\n\n\nbuiltins: asymmetric-encryption, hashing\n\n// Public-Key Infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ]\n  -->\n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]\n\nrule Get_pk:\n  [ !Pk(A, pk) ]\n  -->\n  [ Out(pk) ]\n\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Client_1:\n  let request = aenc{'1', <$C, ~k>}pkS\n  in\n    [ Fr(~k), !Pk($S, pkS)\n    ]\n  --[ Out_Client_1(request)\n    ]->\n    [ Client_1( $C, $S, ~k ), Out( request ) ]\n\nrule Client_2:\n    [ Client_1(C, S, k), In( aenc{'2',k}pk(ltkC) ), !Ltk(C, ltkC) ]\n  --[ SessKeyC( C, S, k ) ]->\n    []\n\n// A server thread answering in one-step to a session-key setup request from\n// some client.\nrule Serv_1:\n  let msg = adec(request, ~ltkS)\n      tag = fst(msg)\n      C   = fst(snd(msg))\n      k   = snd(snd(msg))\n  in\n    [ !Ltk($S, ~ltkS)\n    , In( request )\n    , !Pk(C, pkC)\n    ]\n  --[ Eq(tag, '1')  // This check is crucial to avoid receiving the\n                    // message output in this step as a client\n                    // message. Try proving the Client_auth lemma\n                    // without it to see the problem. (If you bound\n                    // the proof depth and use the GUI, then you can see that\n                    // there is the option that, without this check, servers\n                    // just forward messages to further servers.)\n    , ReceivedKey(C, $S, k)\n    , In_Serv_1(request, k)\n    ]->\n    [ Out( aenc{'2',k}pkC ) ]\n\n/* This is our sources assertion. It follows the construction outline above and\n * uses the same trick as [1] to account for the interaction of the adversary,\n * who doesn't have to follow a typing discipline.\n */\nlemma typing_assertion [sources]:\n  \"(All m v #i. In_Serv_1(m, v) @ i ==>\n      ( (Ex #j. KU(v) @ j & j < i)\n      | (Ex #j. Out_Client_1(m) @ j)\n      )\n   )\n  \"\n\n/* We formulate the following lemma over the actions on adversary message\n * deductions.  This is the core secrecy lemma, which verify for the traces of\n * the normal form dependency graphs of the protocol. We afterwards reuse it\n * in the proof of the two security properties formulated over the standard\n * traces of the protocol.\n */\nlemma Client_session_key_secrecy_raw [reuse]:\n  \"  /* For all traces, we have that */\n     All S C k #i #j.\n        /* if client setup a session key 'k' with a server'S' */\n        SessKeyC(C, S, k) @ #i\n        /* and the adversary deduced 'k' */\n      & KU(k) @ #j\n        /* the he must have performed a long-term key reveal on 'S' or 'C'\n         * before learning the key 'k'. */\n      ==>\n       ( (Ex #r. LtkReveal(S) @ r & r < j)\n       | (Ex #r. LtkReveal(C) @ r & r < j)\n       )\n  \"\n\n// Check the proof of this lemma. It consists only of showing that the above\n// lemma implies this one.\nlemma Client_session_key_secrecy:\n  \"  /* For all traces, we have that */\n     All S C k #i #j.\n        /* if client setup a session key 'k' with a server'S' */\n        SessKeyC(C, S, k) @ #i\n        /* and the adversary knows 'k' */\n      & K(k) @ #j\n        /* the he must have performed a long-term key reveal on 'S' or 'C'\n         * before learning the key 'k'. */\n      ==>\n       ( (Ex #r. LtkReveal(S) @ r & r < j)\n       | (Ex #r. LtkReveal(C) @ r & r < j)\n       )\n  \"\n\nlemma Client_auth:\n  /* For all traces satisfying all equality checks */\n  \" (All x y #i. Eq(x,y) @ i ==> x = y)\n  ==>\n    ( All C S k #i.  SessKeyC(C, S, k) @ #i\n       /* for all session keys 'k' setup by clients with a server 'S' */\n       ==>\n         /* there is a server that answered the request */\n       ( (Ex #a. ReceivedKey(C, S, k) @ a)\n         /* or the intruder performed a long-term key reveal on 'S' or 'C'\n            before the key was setup. */\n       | (Ex #r. LtkReveal(S) @ r & r < i)\n       | (Ex #r. LtkReveal(C) @ r & r < i)\n       )\n    )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/JKL_TS2_2008_KI_wPFS.spthy",
        "incomplete": "theory JKL_TS2_2008_KI_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* Jeong, Katz, Lee : TS2 (2008) *}\n/*\n * Protocol:\tJKL-TS2-2008\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"One-Round Protocols for Two-Party Authenticated Key Exchange\"\n * \t\tJeong, Katz, Lee, 2008\n *\t\tNote: Although the paper title is the same as the 2004\n *\t\toriginal, the updated version from 2008 includes\n *\t\tmodified protocols and security models.\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( ____(PRE_0)____, ~lk ), !Pk( $A, ____(POST_0)____ ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->\n   [ Init_1( ____(PRE_1)____, $I, $R, ____(POST_1)____, 'g'^~ekI ),\n     !Ephk(~ekI),\n     Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R,____(PRE_2)____ ) ]\n   --[SidI_2( ____(PRE_3)____, $I, ____(LABEL_0)____, hkI, ____(PRE_4)____,\n       h( < $I, $R, hkI, Y, Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]->\n   [ !Sessk( ~ekI,\n       h( < $I, ____(PRE_5)____, hkI, Y, Y^~ekI, (____(POST_2)____)^~lkI > ) ) ]\n\nrule Resp_1:\n   [ In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, ____(PRE_6)____) ]\n   --[ SidR_1( ____(PRE_8)____, $I, $R, ____(PRE_7)____, 'g'^~ekR ,\n       h( < $I, $R, ____(LABEL_1)____, 'g'^~ekR, X^~ekR, ('g'^~lkI)^~lkR > ) ) ]->\n   [ Out( ____(PRE_9)____ ),\n     !Ephk(____(POST_3)____),\n     !Sessk( ~ekR,\n       h( < $I, $R, X, 'g'^~ekR, X^~ekR, ('g'^~lkI)^~lkR > ) ) ]\n\nrule Sessk_reveal:\n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma JKL2008_2_initiator_key:\n  \"not (____(LEM_22)____ #____(LEM_15)____ #i2 ____(LEM_9)____ ____(LEM_21)____ R k ____(LEM_24)____ hkR.\n            SidI_2(____(LEM_10)____, I, R, hkI, hkR, k) @ i1 & ____(LEM_23)____( k ) @ i2\n\n            /* Not ephemeral-key-reveal */\n            & (All #____(LEM_27)____ t. EphkRev( t ) @ ____(LEM_30)____ ==> F)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not session-key-reveal of partner thread. */\n            & (All #i3 #____(LEM_5)____ ____(LEM_13)____ kpartner.\n                   ____(LEM_14)____( ____(LEM_25)____,I,R,hkI,hkR,kpartner ) @i3\n\t\t   & SesskRev( ____(LEM_28)____ ) @ ____(LEM_6)____ ==> F)\n\n\t    /* If there is no partner thread, then there is no longterm-key-reveal for\n\t       the intended partner.\n\t       (We model wpfs, for pfs, add i1 < i3 to conclusion) */\n            & (All #i3. LtkRev( I ) @ i3 ==>\n\t          (Ex #i4 tpartner kpartner.\n                      /* (i1 < i3) | */\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4))\n            & (All #i3. LtkRev( R ) @ i3 ==>\n\t          (Ex #i4 tpartner kpartner.\n                      /* (i1 < i3) | */\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4))\n    )\"\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma JKL2008_2_responder_key:\n  \"not (____(LEM_56)____ #____(LEM_55)____ #____(LEM_34)____ ttest ____(LEM_35)____ ____(LEM_58)____ k ____(LEM_37)____ hkR.\n            SidR_1(ttest, ____(LEM_36)____, R, hkI, hkR, k) @ i1 & ____(LEM_54)____( k ) @ i2\n\n            /* Not ephemeral-key-reveal */\n            & (All #____(LEM_33)____ ____(LEM_51)____. EphkRev( t ) @ ____(LEM_50)____ ==> ____(LEM_45)____)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.\n\t       A session key reveal can only happen after SidI_2 is logged anyways.\n\t    */\n            & (All #i3 #____(LEM_42)____ ____(LEM_39)____ kpartner.\n                   SidI_2( ____(LEM_41)____,____(LEM_43)____,R,hkI,hkR,kpartner ) @i3\n\t\t   & SesskRev( ____(LEM_47)____ ) @ ____(LEM_49)____ ==> F)\n\n\t    /* If there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or intended partner.\n\t       (We model wpfs, for pfs, add i1 < i3 to conclusion)\n\t       */\n            & (All #i3. LtkRev( I ) @ i3 ==>\n\t          (Ex #____(LEM_52)____ tpartner.\n                       /* (i1 < i3) | */\n                       SidI_1( tpartner,I,R,hkI ) @i4))\n            & (All #i3. LtkRev( R ) @ i3 ==>\n\t          (Ex #i4 tpartner.\n                       /* (i1 < i3) | */\n                       SidI_1( tpartner,I,R,hkI ) @i4))\n    )\"\n\nend",
        "complete:": "theory JKL_TS2_2008_KI_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* Jeong, Katz, Lee : TS2 (2008) *}\n/*\n * Protocol:\tJKL-TS2-2008\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"One-Round Protocols for Two-Party Authenticated Key Exchange\"\n * \t\tJeong, Katz, Lee, 2008\n *\t\tNote: Although the paper title is the same as the 2004\n *\t\toriginal, the updated version from 2008 includes\n *\t\tmodified protocols and security models.\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, 'g'^~lk ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->\n   [ Init_1( ~ekI, $I, $R, ~lkI, 'g'^~ekI ),\n     !Ephk(~ekI),\n     Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R,'g'^~lkR ) ]\n   --[SidI_2( ~ekI, $I, $R, hkI, Y,\n       h( < $I, $R, hkI, Y, Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]->\n   [ !Sessk( ~ekI,\n       h( < $I, $R, hkI, Y, Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]\n\nrule Resp_1:\n   [ In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, 'g'^~lkI) ]\n   --[ SidR_1( ~ekR, $I, $R, X, 'g'^~ekR ,\n       h( < $I, $R, X, 'g'^~ekR, X^~ekR, ('g'^~lkI)^~lkR > ) ) ]->\n   [ Out( 'g'^~ekR ),\n     !Ephk(~ekR),\n     !Sessk( ~ekR,\n       h( < $I, $R, X, 'g'^~ekR, X^~ekR, ('g'^~lkI)^~lkR > ) ) ]\n\nrule Sessk_reveal:\n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma JKL2008_2_initiator_key:\n  \"not (Ex #i1 #i2 ttest I R k hkI hkR.\n            SidI_2(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n            /* Not ephemeral-key-reveal */\n            & (All #i3 t. EphkRev( t ) @ i3 ==> F)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not session-key-reveal of partner thread. */\n            & (All #i3 #i4 tpartner kpartner.\n                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3\n\t\t   & SesskRev( tpartner ) @ i4 ==> F)\n\n\t    /* If there is no partner thread, then there is no longterm-key-reveal for\n\t       the intended partner.\n\t       (We model wpfs, for pfs, add i1 < i3 to conclusion) */\n            & (All #i3. LtkRev( I ) @ i3 ==>\n\t          (Ex #i4 tpartner kpartner.\n                      /* (i1 < i3) | */\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4))\n            & (All #i3. LtkRev( R ) @ i3 ==>\n\t          (Ex #i4 tpartner kpartner.\n                      /* (i1 < i3) | */\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4))\n    )\"\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma JKL2008_2_responder_key:\n  \"not (Ex #i1 #i2 ttest I R k hkI hkR.\n            SidR_1(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n            /* Not ephemeral-key-reveal */\n            & (All #i3 t. EphkRev( t ) @ i3 ==> F)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.\n\t       A session key reveal can only happen after SidI_2 is logged anyways.\n\t    */\n            & (All #i3 #i4 tpartner kpartner.\n                   SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3\n\t\t   & SesskRev( tpartner ) @ i4 ==> F)\n\n\t    /* If there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or intended partner.\n\t       (We model wpfs, for pfs, add i1 < i3 to conclusion)\n\t       */\n            & (All #i3. LtkRev( I ) @ i3 ==>\n\t          (Ex #i4 tpartner.\n                       /* (i1 < i3) | */\n                       SidI_1( tpartner,I,R,hkI ) @i4))\n            & (All #i3. LtkRev( R ) @ i3 ==>\n\t          (Ex #i4 tpartner.\n                       /* (i1 < i3) | */\n                       SidI_1( tpartner,I,R,hkI ) @i4))\n    )\"\n\nend"
    },
    {
        "file": "SPTHY-1/Joux.spthy",
        "incomplete": "theory Joux\nbegin\n\nsection{* The Joux Protocol using Signatures*}\n\n/*\n * Protocol:\tThe Joux Protocol.\n * Source:      \"A One Round Protocol for Tripartite Diffie-Hellman\"\n *              A. Joux\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n *\n * Model:       PFS\n * Status: \tworking\n */\n\nbuiltins: bilinear-pairing, signing, multiset\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ] \n  --[ ]-> \n  [ !Ltk($A, ____(PRE_0)____), !Pk($A, pk(____(POST_0)____)), Out(pk(~ltk)) ]\n\n// Reveals\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Proto1:\n  let hkA = pmult(~ekA ,'P')\n  in\n  [ Fr(~ekA), !Ltk($A, ltkA) ]\n  --[ ]->\n  [ PState( $A, ____(PRE_1)____, ~ekA )\n  , Out( <____(POST_1)____, sign{$A, $B + $C, hkA }ltkA> )\n  ]\n\nrule Proto2:\n    [ PState( $A, $B + ____(PRE_4)____, ~ekA)\n    , !Pk($B, pk(____(PRE_2)____))\n    , !Pk($C, pk(____(PRE_3)____))\n    , In( < XB, sign{$B, $A + $C, XB}ltkB > )\n    , In( < XC, sign{$C, $A + $B, XC}ltkC > )\n    ]\n  --[ SessionKey($A, $B + $C, em(XB,XC) ^ ~ekA) ]->\n    []\n\nlemma session_key_establish:\n  exists-trace\n  \"____(LEM_4)____ ____(LEM_3)____ ____(LEM_0)____ ____(LEM_6)____ #ia #ib #ic k.\n      ( SessionKey(A,____(LEM_2)____ + ____(LEM_7)____, k) @ ia &\n        SessionKey(____(LEM_9)____,____(LEM_8)____ + A, k) @ ib &\n        SessionKey(C,B + A, k) @ ic &\n        not (A = B) &\n        not (B = C) &\n        not (A = C) &\n        not ( ____(LEM_5)____ #____(LEM_1)____. LtkReveal(A) @ j ) &\n        not ( Ex #j. LtkReveal(B) @ j ) &\n        not ( Ex #j. LtkReveal(C) @ j ))\"\n\n\nlemma Session_Key_Secrecy_PFS:\n  \"(All A B C ____(LEM_15)____ #____(LEM_16)____ #____(LEM_13)____. \n           SessionKey(A,B + C,sessKey) @ i &\n           K(sessKey) @ k\n         ==>\n             (____(LEM_14)____ #____(LEM_10)____. ____(LEM_11)____(A) @ ____(LEM_12)____ & l < i )\n           | (Ex #l. LtkReveal(B) @ l & l < i )\n           | (Ex #l. LtkReveal(C) @ l & l < i ))\"\n\nend",
        "complete:": "theory Joux\nbegin\n\nsection{* The Joux Protocol using Signatures*}\n\n/*\n * Protocol:\tThe Joux Protocol.\n * Source:      \"A One Round Protocol for Tripartite Diffie-Hellman\"\n *              A. Joux\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n *\n * Model:       PFS\n * Status: \tworking\n */\n\nbuiltins: bilinear-pairing, signing, multiset\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltk) ] \n  --[ ]-> \n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]\n\n// Reveals\nrule Reveal_ltk:\n    [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n    [ Out(ltk) ]\n\n\n// Protocol\nrule Proto1:\n  let hkA = pmult(~ekA ,'P')\n  in\n  [ Fr(~ekA), !Ltk($A, ltkA) ]\n  --[ ]->\n  [ PState( $A, $B + $C, ~ekA )\n  , Out( <hkA, sign{$A, $B + $C, hkA }ltkA> )\n  ]\n\nrule Proto2:\n    [ PState( $A, $B + $C, ~ekA)\n    , !Pk($B, pk(ltkB))\n    , !Pk($C, pk(ltkC))\n    , In( < XB, sign{$B, $A + $C, XB}ltkB > )\n    , In( < XC, sign{$C, $A + $B, XC}ltkC > )\n    ]\n  --[ SessionKey($A, $B + $C, em(XB,XC) ^ ~ekA) ]->\n    []\n\nlemma session_key_establish:\n  exists-trace\n  \"Ex A B C #ia #ib #ic k.\n      ( SessionKey(A,B + C, k) @ ia &\n        SessionKey(B,C + A, k) @ ib &\n        SessionKey(C,B + A, k) @ ic &\n        not (A = B) &\n        not (B = C) &\n        not (A = C) &\n        not ( Ex #j. LtkReveal(A) @ j ) &\n        not ( Ex #j. LtkReveal(B) @ j ) &\n        not ( Ex #j. LtkReveal(C) @ j ))\"\n\n\nlemma Session_Key_Secrecy_PFS:\n  \"(All A B C sessKey #i #k. \n           SessionKey(A,B + C,sessKey) @ i &\n           K(sessKey) @ k\n         ==>\n             (Ex #l. LtkReveal(A) @ l & l < i )\n           | (Ex #l. LtkReveal(B) @ l & l < i )\n           | (Ex #l. LtkReveal(C) @ l & l < i ))\"\n\nend"
    },
    {
        "file": "SPTHY-1/KAS1.spthy",
        "incomplete": "theory KAS1\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS1 *}\n\n/*\n * Protocol:\tKAS1\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\tWeakened version of the model for the initiator only,\n * \t\tmotivated by the informal remarks for KAS1 security in the paper.\n *\n * Status: \tworking\n *\n * Notes:\tConfirming the results from the paper, we find that we\n * \t\tcannot allow:\n * \t\t- compromise of the peer's long-term key\n * \t\t- compromise of the test session's ephemeral key\n *\n * \t\tThe model covers KCI and KI.\n */\n\nfunctions: KDF/1\nfunctions: MAC/2\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule Register_pk:\n  let pkA = pk(~ltkA)\n  in\n  [ Fr(~ltkA) ] \n  --> \n  [ !Ltk(____(PRE_0)____, ~ltkA), !Pk($A, ____(POST_0)____), Out(pkA) ]\n\n/* Initiator */\nrule Init_K1_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr( ~m1 ), !Ltk( $I, ____(PRE_1)____ ), !Pk($R,pkR) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, ____(PRE_2)____, c1>) ]->\n   [ Init_1( ____(PRE_3)____, $I, $R, ~lkI, ~m1, ____(POST_1)____), !Ephk( ~m1,~m1 ), Out( c1 ) ]\n\nrule Resp_K1_1:\n  let m1     = adec(c1, ~lkR)\n      nonceB = ~m2\n      key    = KDF(< m1, $I, $R, nonceB, c1 >)\n      tagB   = MAC(key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ____(PRE_4)____ ), !Pk($I,pkI) ]\n   --[  SidR ( ____(PRE_5)____, ____(LABEL_2)____, $I, <$R, $I, 'Resp', ____(PRE_7)____, c1>)\n     ,  Match( ____(PRE_6)____, <$I, $R, ____(LABEL_1)____, c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1, ____(LABEL_0)____>)\n     ]->\n   [ Out(< nonceB , tagB >), !Sessk( ~m2, key ) ]\n\nrule Init_K1_2:\n  let m2   = adec(nonceB, ~lkI)\n      key  = KDF(< ~m1, $I, $R, nonceB, c1 >)\n      tagB = MAC( key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ) , In(< nonceB, ____(PRE_8)____ >) ]\n   --[ SidI ( ____(PRE_11)____, ____(PRE_9)____, ____(LABEL_5)____, <$I, $R, 'Init', ____(PRE_10)____, nonceB> )\n     , Match( ____(LABEL_3)____, <$R, $I, ____(LABEL_4)____, nonceB, c1> )\n     , Accept( ~m1, $I, $R, key) \n     ]->\n   [ !Sessk( ~m1, key ) ]\n\n\n\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, lkA) ]\n   --[ LtkRev($A) ]->\n   [ Out(lkA) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ]\n   --[ EphkRev(~s) ]->\n   [ Out(~ek) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\nlemma KAS1_key_secrecy:\n  \"not (____(LEM_11)____ #i1 #i2 ____(LEM_15)____ ____(LEM_17)____ ____(LEM_20)____ k .\n\t    Accept(____(LEM_24)____, A, B, k) @ i1 & K( k ) @ i2 \n\n            /* No session-key-reveal of test thread. */\n            & not(____(LEM_12)____ #____(LEM_8)____. SesskRev( s ) @ ____(LEM_19)____ )\n\n            /* No ephemeral key reveal of the test thread */\n\t    & not(____(LEM_18)____ #____(LEM_21)____. ____(LEM_9)____( s ) @ i4 )\n\n\t    /* If matching session exists (for all matching sessions...) */\n\t    & (All ____(LEM_23)____ #i4 #____(LEM_10)____ ____(LEM_5)____ D ____(LEM_7)____.\n\t           ( ____(LEM_27)____ ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5)\n\t\t     ==>\n\t\t   ( not(Ex #____(LEM_13)____    . SesskRev( ss ) @ ____(LEM_22)____ )\n\t\t   & not(Ex #____(LEM_26)____    . ____(LEM_6)____  ( B ) @ i6  )\n\t\t   & not(Ex #i6 #____(LEM_28)____. LtkRev  ( A ) @ i6  & LtkRev  ( B  ) @ i7 )\n\t\t   )\n\t      )\n\n\t    /* No matching session exists */\n\t    & ( ( not(Ex ss #i4 #i5 C D ms.\n\t           SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5 ) )\n\t\t     ==>\n\t\t   ( not(Ex #i6. LtkRev  ( B ) @ i6 & i6 < i1 )\n\t\t   )\n\t      )\n  )\"\n\nend",
        "complete:": "theory KAS1\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS1 *}\n\n/*\n * Protocol:\tKAS1\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\tWeakened version of the model for the initiator only,\n * \t\tmotivated by the informal remarks for KAS1 security in the paper.\n *\n * Status: \tworking\n *\n * Notes:\tConfirming the results from the paper, we find that we\n * \t\tcannot allow:\n * \t\t- compromise of the peer's long-term key\n * \t\t- compromise of the test session's ephemeral key\n *\n * \t\tThe model covers KCI and KI.\n */\n\nfunctions: KDF/1\nfunctions: MAC/2\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule Register_pk:\n  let pkA = pk(~ltkA)\n  in\n  [ Fr(~ltkA) ] \n  --> \n  [ !Ltk($A, ~ltkA), !Pk($A, pkA), Out(pkA) ]\n\n/* Initiator */\nrule Init_K1_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr( ~m1 ), !Ltk( $I, ~lkI ), !Pk($R,pkR) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1>) ]->\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1), !Ephk( ~m1,~m1 ), Out( c1 ) ]\n\nrule Resp_K1_1:\n  let m1     = adec(c1, ~lkR)\n      nonceB = ~m2\n      key    = KDF(< m1, $I, $R, nonceB, c1 >)\n      tagB   = MAC(key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !Pk($I,pkI) ]\n   --[  SidR ( ~m2, $R, $I, <$R, $I, 'Resp', nonceB, c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1, nonceB>)\n     ]->\n   [ Out(< nonceB , tagB >), !Sessk( ~m2, key ) ]\n\nrule Init_K1_2:\n  let m2   = adec(nonceB, ~lkI)\n      key  = KDF(< ~m1, $I, $R, nonceB, c1 >)\n      tagB = MAC( key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ) , In(< nonceB, tagB >) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1, nonceB> )\n     , Match( ~m1, <$R, $I, 'Resp', nonceB, c1> )\n     , Accept( ~m1, $I, $R, key) \n     ]->\n   [ !Sessk( ~m1, key ) ]\n\n\n\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, lkA) ]\n   --[ LtkRev($A) ]->\n   [ Out(lkA) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ]\n   --[ EphkRev(~s) ]->\n   [ Out(~ek) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\nlemma KAS1_key_secrecy:\n  \"not (Ex #i1 #i2 s A B k .\n\t    Accept(s, A, B, k) @ i1 & K( k ) @ i2 \n\n            /* No session-key-reveal of test thread. */\n            & not(Ex #i4. SesskRev( s ) @ i4 )\n\n            /* No ephemeral key reveal of the test thread */\n\t    & not(Ex #i4. EphkRev( s ) @ i4 )\n\n\t    /* If matching session exists (for all matching sessions...) */\n\t    & (All ss #i4 #i5 C D ms.\n\t           ( SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5)\n\t\t     ==>\n\t\t   ( not(Ex #i6    . SesskRev( ss ) @ i6 )\n\t\t   & not(Ex #i6    . LtkRev  ( B ) @ i6  )\n\t\t   & not(Ex #i6 #i7. LtkRev  ( A ) @ i6  & LtkRev  ( B  ) @ i7 )\n\t\t   )\n\t      )\n\n\t    /* No matching session exists */\n\t    & ( ( not(Ex ss #i4 #i5 C D ms.\n\t           SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5 ) )\n\t\t     ==>\n\t\t   ( not(Ex #i6. LtkRev  ( B ) @ i6 & i6 < i1 )\n\t\t   )\n\t      )\n  )\"\n\nend"
    },
    {
        "file": "SPTHY-1/KCL07.spthy",
        "incomplete": "theory KCL07 begin\n\nbuiltins: xor, hashing\n\n/*\nKCL07: Reader R, RFID tag T, shared knowledge k, ID\n\n   R: knows(k, ID)\n   T: knows(k, ID)\n   R: fresh(r1)\nR->T: r1\n   T: fresh(r2)\nT->R: ID XOR r2,  h(r1,k) XOR r2  \n   \n   R considers T recent alive if it can find ID, k such that\n     the pair of terms received from T in the last step satisfies\n     \n     ID XOR r2  XOR  h(r1,k) XOR r2   =   ID XOR h(r1,k)\n\nrecent aliveness is satisfied, but untracability is not.\nThe model below only considers recent aliveness at the moment.\n*/\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ OnlyOnce( ) ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) \n   ]\n\nrule tag1:\n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' )\n   ]->\n   [ Out( <~id XOR ~r2, h(<r1,~k>) XOR ~r2>)\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n//   , In( <idr2, hashr2> ) // This is how it should be\n   , In( xoredhash )        // This is the only way I can make it work\n   ]\n --[ Alive( ~k, 'Tag' )\n//   , Eq( idr2 XOR hashr2, ~id XOR h(<~r1,~k>) ) // How it should be\n   , Eq( ____(LABEL_0)____, ~id XOR h(<~r1,~k>) )  // how it works\n   ]->\n   []\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\"\n\nrestriction unique:\n  \"\u2200 #i #j. ((OnlyOnce( ) @ #i) \u2227 (OnlyOnce( ) @ #j)) \u21d2 (#i = #j)\"\n\n\n// PROOF FOUND AUTOMATICALLY\nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 ____(LEM_0)____ #j #____(LEM_1)____. ____(LEM_3)____(y, 'Reader') @k & ____(LEM_2)____( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n\n// SHOWS CORRECT EXECUTION\nlemma executable:\n  exists-trace \"\u2203 x #i #____(LEM_4)____. (Alive( x, 'Tag' ) @ #i) \u2227 (____(LEM_5)____( x, 'Tag' ) @ #j)\n     // further restriction to automatically get the desired execution\n     \u2227 (____(LEM_7)____ Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend",
        "complete:": "theory KCL07 begin\n\nbuiltins: xor, hashing\n\n/*\nKCL07: Reader R, RFID tag T, shared knowledge k, ID\n\n   R: knows(k, ID)\n   T: knows(k, ID)\n   R: fresh(r1)\nR->T: r1\n   T: fresh(r2)\nT->R: ID XOR r2,  h(r1,k) XOR r2  \n   \n   R considers T recent alive if it can find ID, k such that\n     the pair of terms received from T in the last step satisfies\n     \n     ID XOR r2  XOR  h(r1,k) XOR r2   =   ID XOR h(r1,k)\n\nrecent aliveness is satisfied, but untracability is not.\nThe model below only considers recent aliveness at the moment.\n*/\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ OnlyOnce( ) ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) \n   ]\n\nrule tag1:\n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' )\n   ]->\n   [ Out( <~id XOR ~r2, h(<r1,~k>) XOR ~r2>)\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n//   , In( <idr2, hashr2> ) // This is how it should be\n   , In( xoredhash )        // This is the only way I can make it work\n   ]\n --[ Alive( ~k, 'Tag' )\n//   , Eq( idr2 XOR hashr2, ~id XOR h(<~r1,~k>) ) // How it should be\n   , Eq( xoredhash, ~id XOR h(<~r1,~k>) )  // how it works\n   ]->\n   []\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\"\n\nrestriction unique:\n  \"\u2200 #i #j. ((OnlyOnce( ) @ #i) \u2227 (OnlyOnce( ) @ #j)) \u21d2 (#i = #j)\"\n\n\n// PROOF FOUND AUTOMATICALLY\nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Reader') @k & Response( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n\n// SHOWS CORRECT EXECUTION\nlemma executable:\n  exists-trace \"\u2203 x #i #j. (Alive( x, 'Tag' ) @ #i) \u2227 (Response( x, 'Tag' ) @ #j)\n     // further restriction to automatically get the desired execution\n     \u2227 (not Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend"
    },
    {
        "file": "SPTHY-1/katz-yung.spthy",
        "incomplete": "theory Katz_Yung\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ____(PRE_0)____),\n    !Pk($A, pk(____(POST_0)____)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: C, rC\n// S->C: S, rS, g^x, Sig_S(g^x | C | rC | S | rS)\n// C->S: g^y, Sig_C(g^y | C | rC | S | rS)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~rC)\n  ]\n  --[ ClientSentRequest(C, $S, ~rC) ]->\n  [\n    ClientWait(____(POST_1)____, $S, ____(PRE_1)____, ltkC),\n    Out(~rC)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <gx, C, rC, S, rS>\n    msgOut = <'g'^~y, C, rC, S, rS>\n    sigOut = sign(msgOut, ltkC)\n    k = gx^~y\n  in\n  [\n    In(<gx, ____(PRE_2)____, rS, ____(PRE_3)____>),\n    ClientWait(C, S, rC, ltkC),\n    !Pk(S, pkS),\n    Fr(~y)\n  ]\n  --[ Eq(verify(sigIn, ____(LABEL_0)____, pkS), true),\n      ClientDone(C, ____(PRE_4)____, gx, 'g'^~y, k) ]->\n  [\n    Out(<'g'^~y, sigOut>)\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <'g'^~x, C, rC, S, ~rS>\n    sig = sign(msg, ltkS)\n  in\n  [\n    In(<C, rC>),\n    !Ltk(S, ____(PRE_5)____),\n    Fr(~rS),\n    Fr(~x)\n  ]\n  --[ ServerResponded(S, C, 'g'^~x) ]->\n  [\n    ServerWait(S, C, rC, ____(PRE_6)____, ~x),\n    Out(<'g'^~x, S, ____(POST_2)____, sig>)\n  ]\n\nrule ServerFinish:\n  let\n    msg = <gy, C, rC, S, rS>\n    k = gy^x\n  in\n  [\n    In(<gy, sig>),\n    !Pk(C, ____(PRE_7)____),\n    ServerWait(S, C, rC, rS, x)\n  ]\n  --[ Neq(gy, ____(PRE_9)____),\n      Eq(verify(____(LABEL_2)____, msg, pkC), true),\n      ServerDone(S, ____(PRE_8)____, ____(LABEL_1)____, gy, k) ]->\n  []\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy ____(LEM_3)____ #____(LEM_0)____ #j.\n        ClientDone(C, S, gx, gy, ____(LEM_4)____) @ #i\n      & ____(LEM_2)____(S, C, gx, gy, k) @ #j\n      & not(Ex ____(LEM_1)____ #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(____(LEM_5)____ ____(LEM_10)____ S ____(LEM_8)____ ____(LEM_7)____ k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k\n      & not(Ex #____(LEM_11)____. ____(LEM_9)____(C) @ #rc)\n      & not(Ex #____(LEM_6)____. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All ____(LEM_15)____ ____(LEM_14)____ gx gy k #____(LEM_12)____.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (____(LEM_13)____ #____(LEM_16)____. (ServerResponded(S, C, gx) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #____(LEM_17)____. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a request from a client\nlemma ClientLiveness:\n  \"\n  All C S ____(LEM_18)____ ____(LEM_24)____ ____(LEM_19)____ #____(LEM_22)____.\n    ServerDone(S, C, gx, gy, ____(LEM_20)____) @ #____(LEM_23)____\n    ==> ( (Ex #____(LEM_21)____. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S ____(LEM_27)____ gy ____(LEM_25)____ #i.\n    ServerDone(S, C, gx, gy, ____(LEM_26)____) @ #i\n    ==> ( not(____(LEM_30)____ C2 ____(LEM_29)____ ____(LEM_28)____ ____(LEM_31)____ #i2.\n              ServerDone(S2, C2, gx2, gy2, ____(LEM_32)____) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend",
        "complete:": "theory Katz_Yung\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ~ltk),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: C, rC\n// S->C: S, rS, g^x, Sig_S(g^x | C | rC | S | rS)\n// C->S: g^y, Sig_C(g^y | C | rC | S | rS)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~rC)\n  ]\n  --[ ClientSentRequest(C, $S, ~rC) ]->\n  [\n    ClientWait(C, $S, ~rC, ltkC),\n    Out(~rC)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <gx, C, rC, S, rS>\n    msgOut = <'g'^~y, C, rC, S, rS>\n    sigOut = sign(msgOut, ltkC)\n    k = gx^~y\n  in\n  [\n    In(<gx, S, rS, sigIn>),\n    ClientWait(C, S, rC, ltkC),\n    !Pk(S, pkS),\n    Fr(~y)\n  ]\n  --[ Eq(verify(sigIn, msgIn, pkS), true),\n      ClientDone(C, S, gx, 'g'^~y, k) ]->\n  [\n    Out(<'g'^~y, sigOut>)\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <'g'^~x, C, rC, S, ~rS>\n    sig = sign(msg, ltkS)\n  in\n  [\n    In(<C, rC>),\n    !Ltk(S, ltkS),\n    Fr(~rS),\n    Fr(~x)\n  ]\n  --[ ServerResponded(S, C, 'g'^~x) ]->\n  [\n    ServerWait(S, C, rC, ~rS, ~x),\n    Out(<'g'^~x, S, ~rS, sig>)\n  ]\n\nrule ServerFinish:\n  let\n    msg = <gy, C, rC, S, rS>\n    k = gy^x\n  in\n  [\n    In(<gy, sig>),\n    !Pk(C, pkC),\n    ServerWait(S, C, rC, rS, x)\n  ]\n  --[ Neq(gy, 'g'^x),\n      Eq(verify(sig, msg, pkC), true),\n      ServerDone(S, C, 'g'^x, gy, k) ]->\n  []\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #i #j.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex C S gx gy k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k\n      & not(Ex #rc. LtkReveal(C) @ #rc)\n      & not(Ex #rs. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All C S gx gy k #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ServerResponded(S, C, gx) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a request from a client\nlemma ClientLiveness:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( not(Ex C2 S2 gx2 gy2 #i2.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/KEA_plus_KI_KCI.spthy",
        "incomplete": "theory KEA_plus_KI_KCI\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* KEA+ *}\n/*\n * Protocol:\tKEA+\n * Modeler: \tCas Cremers\n * Date: \tJanuary/April 2012\n * Source:\t\"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * \t\tLauter, Mityagin, 2006\n * Property:\tKI, KCI\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n  let pkA = 'g'^~lkA\n  in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, ____(PRE_0)____ ), Out( pkA ) ]\n\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI, $I, $R, epkI ) ]->\n   [ Init_1( ~ekI, $I, $R, ____(PRE_1)____, ____(POST_0)____ ),\n     !Ephk(~ekI),\n     Out( epkI ) ]\n\nrule Init_2:\n  let pkR  = 'g'^~lkR\n      key  = h( <Y^~lkI, pkR^~ekI, $I, $R > ) \n  in\n   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R, ____(PRE_2)____ ) ]\n   --[SidI_2( ~ekI, $I, $R, hkI, ____(PRE_3)____, key ) ]->\n   [ !Sessk( ~ekI, key ) ]\n\n\nrule Resp_1:\n  let pkI  = 'g'^~lkI\n      epkR = 'g'^~ekR\n      key  = h(< pkI^~ekR, X^~lkR, $I, $R >)\n  in\n   [ In( ____(PRE_4)____ ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, pkI) ]\n   --[ SidR_1( ~ekR, $I, ____(PRE_5)____, X, epkR , ____(LABEL_0)____ ) ]->\n   [ Out( 'g'^~ekR ),\n     !Ephk(~ekR),\n     !Sessk( ~ekR, key) ]\n\n\n\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n/* Security notion.\n *\n * We model the claims in the KEA+ paper except for the (non-standard)\n * weakened notion of wPFS, in which the adversary can learn A or B's\n * key after the test thread ends, but not both. \"Real\" wPFS does not\n * hold for this protocol anyway.\n * However, by modeling KCI attacks, we are also modeling half of\n * KEA+'s wPFS notion: the adversary can learn the long-term key of the\n * actor (and thus also after the end of the test session).\n *\n * We model ephemeral key reveals for non-partner threads.  This\n * corresponds to a session-state-reveal analysis where the\n * session-state is defined as the randomness generated by the parties.\n * This property is not implied by the proof (sketch) in the KEA+ paper.\n */\n\n/* An attack is valid in the security notion if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma keaplus_initiator_key:\n  \" /* If every agent registered at most one public key */\n    (____(LEM_7)____ ____(LEM_9)____ #i #j. ____(LEM_6)____(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==>\n    /* then there is not attack */\n    (not(____(LEM_15)____ #i1 #i2 ____(LEM_10)____ ____(LEM_27)____ R k ____(LEM_12)____ ____(LEM_19)____.\n            SidI_2(ttest, I, R, ____(LEM_28)____, hkR, k) @ i1 & ____(LEM_26)____( k ) @ i2\n\n            /* No ephemeral-key-reveal of test thread */\n            & (All #____(LEM_18)____. EphkRev( ttest ) @ ____(LEM_29)____ ==> ____(LEM_13)____)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #____(LEM_30)____. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not ephemeral-key-reveal of partner thread. */\n            & (All #i3 #____(LEM_21)____ ____(LEM_23)____ kpartner.\n                   ____(LEM_8)____( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                 & EphkRev( tpartner ) @ i4 ==> F)\n\n            /* Not session-key-reveal of partner thread. */\n            & (All #i3 #i4 tpartner kpartner.\n                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                 & SesskRev( tpartner ) @ i4 ==> F)\n\n            /* Not longterm-key-reveal of intended peer. */\n            & (All #i3. LtkRev( R ) @ i3 ==> F)\n    )   )\"\n\n/* An attack is valid in the security notion if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma keaplus_responder_key:\n  \" /* If every agent registered at most one public key */\n    (____(LEM_39)____ A #i #j. ____(LEM_53)____(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==>\n    /* then there is not attack */\n    (not (____(LEM_33)____ #i1 #____(LEM_61)____ ttest ____(LEM_62)____ R ____(LEM_37)____ hkI ____(LEM_31)____.\n              SidR_1(ttest, I, R, hkI, ____(LEM_51)____, ____(LEM_56)____) @ i1 & K( k ) @ i2\n\n              /* Not ephemeral-key-reveal of test thread. */\n              & (____(LEM_43)____ #____(LEM_35)____. EphkRev( ttest ) @ ____(LEM_40)____ ==> ____(LEM_34)____)\n\n              /* Not session-key-reveal of test thread. */\n              & (All #____(LEM_41)____. SesskRev( ttest ) @ ____(LEM_49)____ ==> ____(LEM_45)____)\n\n              /* Not ephemeral-key-reveal of partner thread. */\n              /* Note we distinguish explicitly between an incomplete\n               * and complete partner thread case.\n               */\n              & (All #____(LEM_59)____ #____(LEM_54)____ ____(LEM_50)____ ____(LEM_32)____.\n                     SidI_1( tpartner,I,R,lki ) @____(LEM_63)____\n                     & EphkRev( tpartner ) @ ____(LEM_55)____ ==> F) \n              & (All #i3 #i4 tpartner ____(LEM_36)____.\n                     SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                     & EphkRev( tpartner ) @ i4 ==> F)\n\n              /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.\n                 A session key reveal can only happen after SidI_2 is logged anyways.\n              */\n              & (All #i3 #i4 tpartner kpartner.\n                     SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                     & SesskRev( tpartner ) @ i4 ==> F)\n\n              /* Not longterm-key-reveal of intended peer. */\n              & (All #i3. LtkRev( I ) @ i3 ==> F)\n    )   )\"\n\nend",
        "complete:": "theory KEA_plus_KI_KCI\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* KEA+ *}\n/*\n * Protocol:\tKEA+\n * Modeler: \tCas Cremers\n * Date: \tJanuary/April 2012\n * Source:\t\"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * \t\tLauter, Mityagin, 2006\n * Property:\tKI, KCI\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n  let pkA = 'g'^~lkA\n  in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI, $I, $R, epkI ) ]->\n   [ Init_1( ~ekI, $I, $R, ~lkI, epkI ),\n     !Ephk(~ekI),\n     Out( epkI ) ]\n\nrule Init_2:\n  let pkR  = 'g'^~lkR\n      key  = h( <Y^~lkI, pkR^~ekI, $I, $R > ) \n  in\n   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R, pkR ) ]\n   --[SidI_2( ~ekI, $I, $R, hkI, Y, key ) ]->\n   [ !Sessk( ~ekI, key ) ]\n\n\nrule Resp_1:\n  let pkI  = 'g'^~lkI\n      epkR = 'g'^~ekR\n      key  = h(< pkI^~ekR, X^~lkR, $I, $R >)\n  in\n   [ In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, pkI) ]\n   --[ SidR_1( ~ekR, $I, $R, X, epkR , key ) ]->\n   [ Out( 'g'^~ekR ),\n     !Ephk(~ekR),\n     !Sessk( ~ekR, key) ]\n\n\n\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n/* Security notion.\n *\n * We model the claims in the KEA+ paper except for the (non-standard)\n * weakened notion of wPFS, in which the adversary can learn A or B's\n * key after the test thread ends, but not both. \"Real\" wPFS does not\n * hold for this protocol anyway.\n * However, by modeling KCI attacks, we are also modeling half of\n * KEA+'s wPFS notion: the adversary can learn the long-term key of the\n * actor (and thus also after the end of the test session).\n *\n * We model ephemeral key reveals for non-partner threads.  This\n * corresponds to a session-state-reveal analysis where the\n * session-state is defined as the randomness generated by the parties.\n * This property is not implied by the proof (sketch) in the KEA+ paper.\n */\n\n/* An attack is valid in the security notion if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma keaplus_initiator_key:\n  \" /* If every agent registered at most one public key */\n    (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==>\n    /* then there is not attack */\n    (not(Ex #i1 #i2 ttest I R k hkI hkR.\n            SidI_2(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n            /* No ephemeral-key-reveal of test thread */\n            & (All #i3. EphkRev( ttest ) @ i3 ==> F)\n\n            /* Not session-key-reveal of test thread. */\n            & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n            /* Not ephemeral-key-reveal of partner thread. */\n            & (All #i3 #i4 tpartner kpartner.\n                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                 & EphkRev( tpartner ) @ i4 ==> F)\n\n            /* Not session-key-reveal of partner thread. */\n            & (All #i3 #i4 tpartner kpartner.\n                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                 & SesskRev( tpartner ) @ i4 ==> F)\n\n            /* Not longterm-key-reveal of intended peer. */\n            & (All #i3. LtkRev( R ) @ i3 ==> F)\n    )   )\"\n\n/* An attack is valid in the security notion if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma keaplus_responder_key:\n  \" /* If every agent registered at most one public key */\n    (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==>\n    /* then there is not attack */\n    (not (Ex #i1 #i2 ttest I R k hkI hkR.\n              SidR_1(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n              /* Not ephemeral-key-reveal of test thread. */\n              & (All #i3. EphkRev( ttest ) @ i3 ==> F)\n\n              /* Not session-key-reveal of test thread. */\n              & (All #i3. SesskRev( ttest ) @ i3 ==> F)\n\n              /* Not ephemeral-key-reveal of partner thread. */\n              /* Note we distinguish explicitly between an incomplete\n               * and complete partner thread case.\n               */\n              & (All #i3 #i4 tpartner lki.\n                     SidI_1( tpartner,I,R,lki ) @i3\n                     & EphkRev( tpartner ) @ i4 ==> F) \n              & (All #i3 #i4 tpartner kpartner.\n                     SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                     & EphkRev( tpartner ) @ i4 ==> F)\n\n              /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.\n                 A session key reveal can only happen after SidI_2 is logged anyways.\n              */\n              & (All #i3 #i4 tpartner kpartner.\n                     SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3\n                     & SesskRev( tpartner ) @ i4 ==> F)\n\n              /* Not longterm-key-reveal of intended peer. */\n              & (All #i3. LtkRev( I ) @ i3 ==> F)\n    )   )\"\n\nend"
    },
    {
        "file": "SPTHY-1/Keyserver.spthy",
        "incomplete": "theory Keyserver begin\n\n/*\n * Protocol:\tThe keyserver example from [1]\n * Modeler: \tSimon Meier\n * Date: \tJune 2012\n *\n * Status: \tworking\n\n\n [1] Sebastian Moedersheim: Abstraction by set-membership: verifying security\n protocols and web services with databases. ACM Conference on Computer and\n Communications Security 2010: 351-360\n\n The original model from [1].\n\n    Problem: zebsKeyserver;\n\n    Types:\n    Agent  : {a,b,c,i,s};\n    U      : {a,b,c};\n    S      : {s};\n    H      : {a,b};\n    D      : {c,i};\n    DU     : {c};\n    Sts    : {valid,revoked};\n    PK,NPK : value;\n    M1,M2  : untyped;\n\n    Sets:\n    ring(U), db(S,U,Sts);\n\n    Functions:\n    public sign/2, pair/2;\n    private inv/1;\n\n    Facts:\n    iknows/1, attack/0;\n\n    Rules:\n\n    \\Agent. => iknows(Agent);\n    iknows(sign(M1,M2)) => iknows(M2);\n    iknows(M1).iknows(M2) => iknows(sign(M1,M2));\n    iknows(pair(M1,M2)) => iknows(M1).iknows(M2);\n    iknows(M1).iknows(M2) => iknows(pair(M1,M2));\n\n    \\H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);\n\n    \\S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);\n\n    \\H.\n    iknows(PK).PK in ring(H)\n    =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));\n\n    \\S,U.\n    iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).\n    forall U,Sts. NPK notin db(S,U,Sts)\n    =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));\n\n    \\S,H.\n    iknows(inv(PK)).PK in db(S,H,valid)\n    =>attack;\n\n  Unfortunately, there are no comments. Moreover, public keys are converted\n  freely to private keys, which is not always faithful. We comment on this\n  below.\n*/\n\nbuiltins: signing\n\n/* We also setup a server key to allow server signatures. */\nrule SetupServerKey:\n    [ Fr(~sk) ]\n  -->\n    [ !ServerSK(~sk), !ServerPK(pk(~sk)), Out(pk(~sk)) ]\n\n/*\n  The non-deterministic choice between the rules SetupHonestKey and\n  SetupDishonestKey determines whether an agent is honest or not.\n\n  The rule below models\n\n    \\H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);\n\n  Note that servers store public keys and clients store their private key.\n  There may be several registered keys at the same time, as there may be\n  multiple ServerKey-facts in the state at the same time.\n*/\nrule SetupHonestKey:\n    [ Fr(~sk) ]\n  --[ HonestKey(~sk) ]->\n    [ Out(pk(~sk)) , ClientKey(____(PRE_0)____, ~sk) , ServerDB($A, pk(~sk)) ]\n\n\n/* The intruder may register any private key for any agent.\n\n    \\S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);\n\n*/\nrule SetupDishonestKey:\n    [ In(sk) ] --> [ ServerDB($A, pk(sk)) ]\n\n/* A client may renew one of his keys by sending a renew request. In [1], the\n   server then leaks the corresponding private key. This is not really\n   possible, as the server does not know the private keys corresponding to\n   newly setup keys. We model that the key waits for a confirmation of his\n   request and only then leaks his key\n\n   The original client request rule was:\n\n     \\H.\n     iknows(PK).PK in ring(H)\n     =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));\n*/\nrule Client_RenewKey:\n  let pkNew      = pk(~skNew)\n      request    = <'renew', $A, pkNew>\n      requestSig = sign{request}~sk\n  in\n    [ ClientKey($A, ~sk), Fr(~skNew) ]\n  --[ HonestKey(~skNew) ]->\n    [ Out( <____(PRE_1)____, ____(POST_0)____> )\n    , ClientKey($A, ~skNew)\n    , AwaitConfirmation(requestSig,~sk)\n    ]\n\nrule Client_LeakKey:\n    [ AwaitConfirmation(request,sk)\n    , !ServerPK(pkServer)\n    , In(sig)\n    ]\n  --[ Eq(verify(sig, <____(PRE_2)____, request>, pkServer), true)\n    , Revoked(sk)\n    ]->\n    [ Out(sk) ]\n\n/* The server updating his database. See the comment above for the change in\n   leaking the private key. The original rule in [1] is\n\n     \\S,U.\n     iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).\n     forall U,Sts. NPK notin db(S,U,Sts)\n     =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));\n\n   The leaking of 'inv(PK)' is unrealistic as the server only learns the\n   public key of new messages.\n*/\nrule Server_RenewKey:\n  let request = <'renew', A, pkNew>\n  in\n    [ In( <request, requestSig> )\n    , ServerDB(____(PRE_3)____, pk(sk))\n    , !ServerSK(skServer)\n    ]\n  --[ Eq(verify(requestSig, request, pk(sk)), true)\n    ]->\n    [ ServerDB(A, pkNew)\n    , Out(sign{'confirm', requestSig}skServer)\n    ]\n\n// We assume that rule's are only executed if their equality checks succeed.\nrestriction Eq_checks_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n/* The following property proven in Moedersheim's paper is rather easy to\n   prove, as it depends only on the fact that secret keys are not leaked by\n   any other means than the \"RenewKey\" rule. The \"RenewKey\" rule always log's\n   that the key is \"Revoked\", which directly implies the lemma below.\n\n     \\S,H.\n     iknows(inv(PK)).PK in db(S,H,valid)\n     =>attack;\n*/\n\nlemma Knows_Honest_Key_imp_Revoked:\n  \"All sk #____(LEM_0)____ #d. HonestKey(sk) @ i & K(sk) @ d ==>\n      (____(LEM_2)____ #r. ____(LEM_1)____(sk) @ r)\n  \"\n\n/*\n/* Sanity check. Commented out for runtime comparison to [1]. */\nlemma Honest_Revoked_Known_Reachable:\n  exists-trace\n  \"(Ex ____(LEM_4)____ #i #j #____(LEM_3)____. HonestKey(sk) @ i\n                  & K(sk) @ j\n                  & Revoked(sk) @ r\n   )\"\n*/\n\nend",
        "complete:": "theory Keyserver begin\n\n/*\n * Protocol:\tThe keyserver example from [1]\n * Modeler: \tSimon Meier\n * Date: \tJune 2012\n *\n * Status: \tworking\n\n\n [1] Sebastian Moedersheim: Abstraction by set-membership: verifying security\n protocols and web services with databases. ACM Conference on Computer and\n Communications Security 2010: 351-360\n\n The original model from [1].\n\n    Problem: zebsKeyserver;\n\n    Types:\n    Agent  : {a,b,c,i,s};\n    U      : {a,b,c};\n    S      : {s};\n    H      : {a,b};\n    D      : {c,i};\n    DU     : {c};\n    Sts    : {valid,revoked};\n    PK,NPK : value;\n    M1,M2  : untyped;\n\n    Sets:\n    ring(U), db(S,U,Sts);\n\n    Functions:\n    public sign/2, pair/2;\n    private inv/1;\n\n    Facts:\n    iknows/1, attack/0;\n\n    Rules:\n\n    \\Agent. => iknows(Agent);\n    iknows(sign(M1,M2)) => iknows(M2);\n    iknows(M1).iknows(M2) => iknows(sign(M1,M2));\n    iknows(pair(M1,M2)) => iknows(M1).iknows(M2);\n    iknows(M1).iknows(M2) => iknows(pair(M1,M2));\n\n    \\H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);\n\n    \\S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);\n\n    \\H.\n    iknows(PK).PK in ring(H)\n    =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));\n\n    \\S,U.\n    iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).\n    forall U,Sts. NPK notin db(S,U,Sts)\n    =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));\n\n    \\S,H.\n    iknows(inv(PK)).PK in db(S,H,valid)\n    =>attack;\n\n  Unfortunately, there are no comments. Moreover, public keys are converted\n  freely to private keys, which is not always faithful. We comment on this\n  below.\n*/\n\nbuiltins: signing\n\n/* We also setup a server key to allow server signatures. */\nrule SetupServerKey:\n    [ Fr(~sk) ]\n  -->\n    [ !ServerSK(~sk), !ServerPK(pk(~sk)), Out(pk(~sk)) ]\n\n/*\n  The non-deterministic choice between the rules SetupHonestKey and\n  SetupDishonestKey determines whether an agent is honest or not.\n\n  The rule below models\n\n    \\H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);\n\n  Note that servers store public keys and clients store their private key.\n  There may be several registered keys at the same time, as there may be\n  multiple ServerKey-facts in the state at the same time.\n*/\nrule SetupHonestKey:\n    [ Fr(~sk) ]\n  --[ HonestKey(~sk) ]->\n    [ Out(pk(~sk)) , ClientKey($A, ~sk) , ServerDB($A, pk(~sk)) ]\n\n\n/* The intruder may register any private key for any agent.\n\n    \\S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);\n\n*/\nrule SetupDishonestKey:\n    [ In(sk) ] --> [ ServerDB($A, pk(sk)) ]\n\n/* A client may renew one of his keys by sending a renew request. In [1], the\n   server then leaks the corresponding private key. This is not really\n   possible, as the server does not know the private keys corresponding to\n   newly setup keys. We model that the key waits for a confirmation of his\n   request and only then leaks his key\n\n   The original client request rule was:\n\n     \\H.\n     iknows(PK).PK in ring(H)\n     =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));\n*/\nrule Client_RenewKey:\n  let pkNew      = pk(~skNew)\n      request    = <'renew', $A, pkNew>\n      requestSig = sign{request}~sk\n  in\n    [ ClientKey($A, ~sk), Fr(~skNew) ]\n  --[ HonestKey(~skNew) ]->\n    [ Out( <request, requestSig> )\n    , ClientKey($A, ~skNew)\n    , AwaitConfirmation(requestSig,~sk)\n    ]\n\nrule Client_LeakKey:\n    [ AwaitConfirmation(request,sk)\n    , !ServerPK(pkServer)\n    , In(sig)\n    ]\n  --[ Eq(verify(sig, <'confirm', request>, pkServer), true)\n    , Revoked(sk)\n    ]->\n    [ Out(sk) ]\n\n/* The server updating his database. See the comment above for the change in\n   leaking the private key. The original rule in [1] is\n\n     \\S,U.\n     iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).\n     forall U,Sts. NPK notin db(S,U,Sts)\n     =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));\n\n   The leaking of 'inv(PK)' is unrealistic as the server only learns the\n   public key of new messages.\n*/\nrule Server_RenewKey:\n  let request = <'renew', A, pkNew>\n  in\n    [ In( <request, requestSig> )\n    , ServerDB(A, pk(sk))\n    , !ServerSK(skServer)\n    ]\n  --[ Eq(verify(requestSig, request, pk(sk)), true)\n    ]->\n    [ ServerDB(A, pkNew)\n    , Out(sign{'confirm', requestSig}skServer)\n    ]\n\n// We assume that rule's are only executed if their equality checks succeed.\nrestriction Eq_checks_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n/* The following property proven in Moedersheim's paper is rather easy to\n   prove, as it depends only on the fact that secret keys are not leaked by\n   any other means than the \"RenewKey\" rule. The \"RenewKey\" rule always log's\n   that the key is \"Revoked\", which directly implies the lemma below.\n\n     \\S,H.\n     iknows(inv(PK)).PK in db(S,H,valid)\n     =>attack;\n*/\n\nlemma Knows_Honest_Key_imp_Revoked:\n  \"All sk #i #d. HonestKey(sk) @ i & K(sk) @ d ==>\n      (Ex #r. Revoked(sk) @ r)\n  \"\n\n/*\n/* Sanity check. Commented out for runtime comparison to [1]. */\nlemma Honest_Revoked_Known_Reachable:\n  exists-trace\n  \"(Ex sk #i #j #r. HonestKey(sk) @ i\n                  & K(sk) @ j\n                  & Revoked(sk) @ r\n   )\"\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/Minimal_HashChain.spthy",
        "incomplete": "theory Minimal_HashChain begin\n\n/*\n  Protocol:    A minimal HashChain example (inspired by TESLA 2)\n  Modeler:     Simon Meier\n  Date:        August 2012\n\n  Status:      note yet working\n               (requires multiset or repeated exponentiation reasoning)\n\n  This models the key difficulty in the proof of the TESLA 2 protocol with\n  re-authentication: the verification that the key checking process is\n  sufficient to guarantee that the key is a key of the hash-chain.\n*/\n\nfunctions: f/1\n\n// Chain setup phase\n////////////////////\n\n// Hash chain generation\nrule Gen_Start:\n  [ Fr(seed) ] --> [ Gen(seed, seed), Out(seed) ]\n\n// The NextKey-facts are used by the sender rules to store the link between\n// the keys in the chain.\nrule Gen_Step:\n    [ Gen(seed, chain) ]\n  --[ ChainKey(chain)\n    ]->\n    [ Gen(seed, f(chain) ) ]\n\n// At some point the sender decides to stop the hash-chain precomputation.\nrule Gen_Stop:\n    [ Gen(seed, kZero) ]\n  --[ ChainKey(kZero) ]->\n    [ !Final(kZero) ]\n\n// Key checking\n///////////////\n\n// Start checking an arbitrary key. Use a loop-id to allow connecting\n// different statements about the same loop.\nrule Check0:\n    [ In(kOrig)\n    , Fr(loopId)\n    ]\n  --[ Start(loopId, kOrig)\n    ]->\n    [ Loop(loopId, kOrig, kOrig) ]\n\nrule Check:\n    [ Loop(loopId, k,    kOrig) ]\n  --[ Loop(loopId, k,    kOrig) ]->\n    [ Loop(loopId, f(k), kOrig) ]\n\nrule Success:\n    [ Loop(loopId, kZero, kOrig), !Final(kZero) ]\n  --[ Success(loopId, kOrig)\n    ]-> []\n\n\n// Provable: restricts the search space\nlemma Loop_Start [use_induction, reuse]:\n  \"All ____(LEM_0)____ k ____(LEM_1)____ #i. Loop(____(LEM_2)____, k, kOrig) @ i ==>\n    Ex #j. Start(lid, kOrig) @ j & j < i\"\n\n// Provable: restricts the search space\nlemma Loop_Success_ord [use_induction, reuse]:\n  \"____(LEM_3)____ lid k kOrig1 kOrig2 #____(LEM_5)____ #j.\n       Loop(lid, k, kOrig1) @ i\n     & ____(LEM_4)____(lid, kOrig2) @ j\n    ==>\n     ( i < j)\n  \"\n\n// Provable: connects an arbitrary loop step with its start.\nlemma Loop_charn [use_induction]:\n  \"All lid k ____(LEM_6)____ #____(LEM_8)____. Loop(lid, k, kOrig) @ i ==>\n     Ex #____(LEM_7)____. Loop(lid, kOrig, kOrig) @ j\"\n\nlemma Helper_Loop_and_success[use_induction,reuse]:\n  \"All ____(LEM_13)____ kOrig k1 k2 #x #____(LEM_12)____ #z.\n      Loop(lid, k1, kOrig) @ #x & Loop(lid, k2, kOrig) @ #y & #y < #x\n      & ____(LEM_9)____(k1) @ #z\n    ==> ____(LEM_10)____ #t. ____(LEM_11)____(k2) @ #t\"\n\nlemma Loop_and_success:\n  \"All ____(LEM_14)____ k kOrig1 kOrig2 #____(LEM_15)____ #____(LEM_17)____.\n       Loop(____(LEM_16)____, k, kOrig1) @ i\n     & Success(lid, kOrig2) @ j\n    ==>\n     (Ex #j. ChainKey(k) @ j)\n  \"\n\nlemma Helper_Success_charn[use_induction,reuse]:\n  \"All ____(LEM_18)____ k kOrig #x #____(LEM_19)____.\n      ChainKey(k) @ #x & Loop(lid, k, kOrig) @ #____(LEM_20)____\n    ==> Ex #z. ChainKey(kOrig) @ #z\"\n\nlemma Success_charn:\n  \"____(LEM_22)____ lid k #____(LEM_21)____. Success(lid, k) @ i ==>\n    Ex #j. ChainKey(k) @ j\"\n\n\n\n/* A try on building the required 'smaller' relation in an axiomatic fashion.\n   This interacts too strongly with\n\n   Does not really work! We need a better way to express this stuff.\n\nrule Succ_to_Smaller:\n    [ !Succ(x, y) ] --[ IsSmaller(x, y) ]-> [!Smaller(x, y)]\n\nrule Smaller_Extend:\n    [ !Succ(x, y), !Smaller(y, z) ]\n  --[ IsSmaller(x, z) ]->\n    [ !Smaller(x, z) ]\n\nrestriction force_succ_smaller:\n    \"All #t1 2 a b c. IsSucc(a,b)@t1\n       ==> Ex #t2 . IsSmaller(a,b)@t2 \"\n\nrestriction transitivity:\n    \"All #t1 #t2 a b c. IsSmaller(a,b)@t1 & IsSmaller(b,c)@t2\n       ==> Ex #t3 . IsSmaller(a,c)@t3 \"\n*/\nend",
        "complete:": "theory Minimal_HashChain begin\n\n/*\n  Protocol:    A minimal HashChain example (inspired by TESLA 2)\n  Modeler:     Simon Meier\n  Date:        August 2012\n\n  Status:      note yet working\n               (requires multiset or repeated exponentiation reasoning)\n\n  This models the key difficulty in the proof of the TESLA 2 protocol with\n  re-authentication: the verification that the key checking process is\n  sufficient to guarantee that the key is a key of the hash-chain.\n*/\n\nfunctions: f/1\n\n// Chain setup phase\n////////////////////\n\n// Hash chain generation\nrule Gen_Start:\n  [ Fr(seed) ] --> [ Gen(seed, seed), Out(seed) ]\n\n// The NextKey-facts are used by the sender rules to store the link between\n// the keys in the chain.\nrule Gen_Step:\n    [ Gen(seed, chain) ]\n  --[ ChainKey(chain)\n    ]->\n    [ Gen(seed, f(chain) ) ]\n\n// At some point the sender decides to stop the hash-chain precomputation.\nrule Gen_Stop:\n    [ Gen(seed, kZero) ]\n  --[ ChainKey(kZero) ]->\n    [ !Final(kZero) ]\n\n// Key checking\n///////////////\n\n// Start checking an arbitrary key. Use a loop-id to allow connecting\n// different statements about the same loop.\nrule Check0:\n    [ In(kOrig)\n    , Fr(loopId)\n    ]\n  --[ Start(loopId, kOrig)\n    ]->\n    [ Loop(loopId, kOrig, kOrig) ]\n\nrule Check:\n    [ Loop(loopId, k,    kOrig) ]\n  --[ Loop(loopId, k,    kOrig) ]->\n    [ Loop(loopId, f(k), kOrig) ]\n\nrule Success:\n    [ Loop(loopId, kZero, kOrig), !Final(kZero) ]\n  --[ Success(loopId, kOrig)\n    ]-> []\n\n\n// Provable: restricts the search space\nlemma Loop_Start [use_induction, reuse]:\n  \"All lid k kOrig #i. Loop(lid, k, kOrig) @ i ==>\n    Ex #j. Start(lid, kOrig) @ j & j < i\"\n\n// Provable: restricts the search space\nlemma Loop_Success_ord [use_induction, reuse]:\n  \"All lid k kOrig1 kOrig2 #i #j.\n       Loop(lid, k, kOrig1) @ i\n     & Success(lid, kOrig2) @ j\n    ==>\n     ( i < j)\n  \"\n\n// Provable: connects an arbitrary loop step with its start.\nlemma Loop_charn [use_induction]:\n  \"All lid k kOrig #i. Loop(lid, k, kOrig) @ i ==>\n     Ex #j. Loop(lid, kOrig, kOrig) @ j\"\n\nlemma Helper_Loop_and_success[use_induction,reuse]:\n  \"All lid kOrig k1 k2 #x #y #z.\n      Loop(lid, k1, kOrig) @ #x & Loop(lid, k2, kOrig) @ #y & #y < #x\n      & ChainKey(k1) @ #z\n    ==> Ex #t. ChainKey(k2) @ #t\"\n\nlemma Loop_and_success:\n  \"All lid k kOrig1 kOrig2 #i #j.\n       Loop(lid, k, kOrig1) @ i\n     & Success(lid, kOrig2) @ j\n    ==>\n     (Ex #j. ChainKey(k) @ j)\n  \"\n\nlemma Helper_Success_charn[use_induction,reuse]:\n  \"All lid k kOrig #x #y.\n      ChainKey(k) @ #x & Loop(lid, k, kOrig) @ #y\n    ==> Ex #z. ChainKey(kOrig) @ #z\"\n\nlemma Success_charn:\n  \"All lid k #i. Success(lid, k) @ i ==>\n    Ex #j. ChainKey(k) @ j\"\n\n\n\n/* A try on building the required 'smaller' relation in an axiomatic fashion.\n   This interacts too strongly with\n\n   Does not really work! We need a better way to express this stuff.\n\nrule Succ_to_Smaller:\n    [ !Succ(x, y) ] --[ IsSmaller(x, y) ]-> [!Smaller(x, y)]\n\nrule Smaller_Extend:\n    [ !Succ(x, y), !Smaller(y, z) ]\n  --[ IsSmaller(x, z) ]->\n    [ !Smaller(x, z) ]\n\nrestriction force_succ_smaller:\n    \"All #t1 2 a b c. IsSucc(a,b)@t1\n       ==> Ex #t2 . IsSmaller(a,b)@t2 \"\n\nrestriction transitivity:\n    \"All #t1 #t2 a b c. IsSmaller(a,b)@t1 & IsSmaller(b,c)@t2\n       ==> Ex #t3 . IsSmaller(a,c)@t3 \"\n*/\nend"
    },
    {
        "file": "SPTHY-1/mls-04a.spthy",
        "incomplete": "theory MLS04\nbegin\n\nbuiltins: hashing, signing, asymmetric-encryption\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk(____(PRE_0)____, ____(POST_0)____),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n// Client logic\nrule ClientInit:\n  let\n    gx = pk(~x)\n    pkC = pk(ltkC)\n    sig = sign(<gx, C, pkC>, ltkC)\n    uik = <gx, C, pkC, sig>\n  in\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientPostedInitKey(C, gx) ]->\n  [\n    ClientWait(C, ~x, ltkC),\n    Out(uik)\n  ]\n\nrule ClientFinish:\n  let\n    gx = pk(x)\n    pkC = pk(ltkC)\n\n    // welcomeInfo = <gy, k, S, pkS>\n    welcomeInfo = adec(welcome, x)\n    gy = fst(welcomeInfo)\n    k = fst(snd(welcomeInfo))\n    S = fst(snd(snd(welcomeInfo)))\n    pkS = snd(snd(snd(welcomeInfo)))\n\n    // add = <'add', gx, C, pkC, sig>\n    addTag = fst(add)\n    gxIn = fst(snd(add))\n    CIn = fst(snd(snd(add)))\n    pkCIn = fst(snd(snd(snd(add))))\n\n    macData = add\n    state = <C, S, pkC, pkS, gx, gy>\n    confirmKey = mac(k, state)\n    macValVer = mac(confirmKey, macData)\n  in\n  [\n    ClientWait(____(PRE_1)____, x, ltkC),\n    !Pk(S, pkS),\n    In(<welcome, add, addMAC, addSig>)\n  ]\n  --[ Neq(____(LABEL_3)____, ____(LABEL_1)____),\n      Eq(addTag, '____(PRE_4)____'),\n      Eq(____(PRE_2)____, gx),\n      Eq(CIn, ____(LABEL_0)____),\n      Eq(pkCIn, pkC),\n      Eq(verify(addSig, <add, addMAC>, pkS), ____(PRE_3)____),\n      Eq(____(PRE_5)____, addMAC),\n      ClientDone(C, S, gx, gy, ____(LABEL_2)____) ]->\n  []\n\n// Server logic\nrule ServerInit:\n  let\n    uik = <gx, C, pkC, sig>\n\n    gy = pk(~y)\n    pkS = pk(ltkS)\n    welcomeInfo = <gy, ~k, S, pkS>\n    welcome = aenc(welcomeInfo, gx)\n\n\n    add = <'add', uik>\n\n    macData = add\n    state = <C, S, pkC, pkS, gx, gy>\n    confirmKey = mac(~k, state)\n    addMAC = mac(confirmKey, macData)\n\n    sigData = <add, addMAC>\n    addSig = sign(sigData, ltkS)\n  in\n  [\n    In(<gx, C, sig>),\n    !Pk(C, pkC),\n    !Ltk(____(PRE_6)____, ltkS),\n    Fr(~y),\n    Fr(~k)\n  ]\n  --[ Eq(verify(sig, <gx, ____(PRE_7)____, ____(LABEL_4)____>, pkC), true),\n      ServerDone(S, ____(PRE_8)____, gx, gy, ~k) ]->\n  [\n    Out(<welcome, add, addSig, addMAC>)\n  ]\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestServerTrace:\n  exists-trace\n  \"\n    ____(LEM_1)____ C S ____(LEM_0)____ gy ____(LEM_2)____ #____(LEM_3)____.\n        ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C ____(LEM_5)____ gx ____(LEM_4)____ k #____(LEM_7)____ #____(LEM_8)____.\n        ClientDone(C, ____(LEM_6)____, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex C S ____(LEM_9)____ gy ____(LEM_14)____ #i #j #k.\n        ClientDone(C, S, ____(LEM_13)____, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & ____(LEM_11)____(k) @ #k\n      & not(Ex #____(LEM_12)____. ____(LEM_10)____(C) @ #rc)\n      & not(Ex #____(LEM_15)____. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All ____(LEM_21)____ ____(LEM_22)____ ____(LEM_16)____ gy ____(LEM_19)____ #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (____(LEM_17)____ #____(LEM_18)____. (ServerDone(S, C, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #____(LEM_20)____. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a client's init key\nlemma ClientLiveness:\n  \"\n  All C S ____(LEM_23)____ ____(LEM_26)____ k #____(LEM_27)____.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (____(LEM_25)____ #j. (ClientPostedInitKey(C, gx) @ #j) & (#j < #i))\n        | (Ex #____(LEM_24)____. LtkReveal(C) @ #____(LEM_28)____)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S ____(LEM_33)____ gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( ____(LEM_31)____(Ex C2 ____(LEM_35)____ gx2 gy2 #____(LEM_29)____.\n              ServerDone(____(LEM_36)____, C2, gx2, gy2, k) @ #i2\n             & ____(LEM_32)____(#i2 = #i)\n             )\n        | (Ex #____(LEM_30)____. LtkReveal(C) @ #rc)\n        | (Ex #____(LEM_34)____. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend",
        "complete:": "theory MLS04\nbegin\n\nbuiltins: hashing, signing, asymmetric-encryption\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ~ltk),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n// Client logic\nrule ClientInit:\n  let\n    gx = pk(~x)\n    pkC = pk(ltkC)\n    sig = sign(<gx, C, pkC>, ltkC)\n    uik = <gx, C, pkC, sig>\n  in\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientPostedInitKey(C, gx) ]->\n  [\n    ClientWait(C, ~x, ltkC),\n    Out(uik)\n  ]\n\nrule ClientFinish:\n  let\n    gx = pk(x)\n    pkC = pk(ltkC)\n\n    // welcomeInfo = <gy, k, S, pkS>\n    welcomeInfo = adec(welcome, x)\n    gy = fst(welcomeInfo)\n    k = fst(snd(welcomeInfo))\n    S = fst(snd(snd(welcomeInfo)))\n    pkS = snd(snd(snd(welcomeInfo)))\n\n    // add = <'add', gx, C, pkC, sig>\n    addTag = fst(add)\n    gxIn = fst(snd(add))\n    CIn = fst(snd(snd(add)))\n    pkCIn = fst(snd(snd(snd(add))))\n\n    macData = add\n    state = <C, S, pkC, pkS, gx, gy>\n    confirmKey = mac(k, state)\n    macValVer = mac(confirmKey, macData)\n  in\n  [\n    ClientWait(C, x, ltkC),\n    !Pk(S, pkS),\n    In(<welcome, add, addMAC, addSig>)\n  ]\n  --[ Neq(gx, gy),\n      Eq(addTag, 'add'),\n      Eq(gxIn, gx),\n      Eq(CIn, C),\n      Eq(pkCIn, pkC),\n      Eq(verify(addSig, <add, addMAC>, pkS), true),\n      Eq(macValVer, addMAC),\n      ClientDone(C, S, gx, gy, k) ]->\n  []\n\n// Server logic\nrule ServerInit:\n  let\n    uik = <gx, C, pkC, sig>\n\n    gy = pk(~y)\n    pkS = pk(ltkS)\n    welcomeInfo = <gy, ~k, S, pkS>\n    welcome = aenc(welcomeInfo, gx)\n\n\n    add = <'add', uik>\n\n    macData = add\n    state = <C, S, pkC, pkS, gx, gy>\n    confirmKey = mac(~k, state)\n    addMAC = mac(confirmKey, macData)\n\n    sigData = <add, addMAC>\n    addSig = sign(sigData, ltkS)\n  in\n  [\n    In(<gx, C, sig>),\n    !Pk(C, pkC),\n    !Ltk(S, ltkS),\n    Fr(~y),\n    Fr(~k)\n  ]\n  --[ Eq(verify(sig, <gx, C, pkC>, pkC), true),\n      ServerDone(S, C, gx, gy, ~k) ]->\n  [\n    Out(<welcome, add, addSig, addMAC>)\n  ]\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestServerTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #j.\n        ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #i #j.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex C S gx gy k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k\n      & not(Ex #rc. LtkReveal(C) @ #rc)\n      & not(Ex #rs. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All C S gx gy k #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ServerDone(S, C, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a client's init key\nlemma ClientLiveness:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientPostedInitKey(C, gx) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( not(Ex C2 S2 gx2 gy2 #i2.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/MPAuth_MA_NoTellOK.spthy",
        "incomplete": "theory MPAuth_MA_NoTellOK\nbegin\n\n\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tMP-Auth_MA\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=ruleBased with Rule3($H,'noTell','ok')\n- lemma functional (exists-trace): falsified - no trace found (27 steps)\n\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing, symmetric-encryption\nfunctions: f/1,  m/1  // f/1 used for function in protocol, m/1 used to give message a type.\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"not (Ex #k. ____(LEM_0)____('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh(____(PRE_0)____,____(LABEL_0)____,~x), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive($H,$x.1,____(PRE_1)____), !HK($H,$x.1, ____(LABEL_1)____),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send(____(LABEL_2)____,$x.1,x.2),\n\t\tH($H), To(____(PRE_2)____)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive($H,____(PRE_3)____,x.2), !HK($H,____(LABEL_3)____,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK(____(PRE_4)____,$x.1,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send(____(PRE_5)____,$x.1,x.2), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S(____(PRE_6)____,$A,<$x.1,$y.1>,<x.2,____(POST_0)____>) ]\n\n\nrule H_send_S3:\n\t[ !HK(____(PRE_4)____,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(____(LABEL_4)____,$x.1,x.2), \n\t    Send(____(LABEL_5)____,____(PRE_8)____,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To(____(PRE_9)____)]->\n\t[ Out_S($H,$A,<____(PRE_10)____,$y.1,____(POST_1)____>,<x.2,y.2,z.2>) ]\n\nrule H_send_S4:\n\t[ !HK(____(PRE_4)____,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send(____(PRE_13)____,$x.1,x.2), \n\t\tSend(____(PRE_14)____,$y.1,y.2),\n\t\tSend(____(LABEL_6)____,$z.1,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S(____(PRE_16)____,____(PRE_15)____,<$x.1,$y.1,$z.1,$w.1>,<x.2,y.2,z.2,____(POST_2)____>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( $A,$H, <$x.1,$y.1>, <____(PRE_17)____,y.2> ) ]\n\t--[ Receive(____(LABEL_7)____,____(PRE_19)____,____(LABEL_8)____), \n\t\tReceive($H,$y.1,y.2), !HK(____(PRE_20)____,____(POST_3)____,x.2),!HK($H,$y.1,y.2),\n\t\tH($H), From(____(PRE_18)____)]->\n\t[ !HK(____(PRE_20)____,____(POST_3)____,x.2),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,$H, <$x.1,$y.1,____(PRE_22)____,$v.1>,<x.2,____(PRE_21)____,z.2,v.2> ) ]\n\t--[     Receive(____(LABEL_9)____,$x.1,x.2), \n\t\tReceive(____(LABEL_11)____,$y.1,y.2), \n\t\tReceive(____(LABEL_12)____,____(LABEL_10)____,z.2), \n\t\tReceive(____(LABEL_13)____,$v.1,v.2), !HK(____(PRE_4)____,$x.1,x.2), !HK(____(POST_4)____,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,____(POST_5)____),\n\t\tH($H), From($A)]->\n\t[ !HK(____(PRE_4)____,$x.1,x.2), !HK(____(POST_4)____,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,____(POST_5)____) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth($A,____(POST_6)____,x), Out(<$A,____(PRE_30)____,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\nrule passworddistribution:\n\t[Fr(~pw)]\n\t--[PasswordHS($X,$Y,~pw)]->\n\t[!Password($X,$Y,~pw)]\nrule publickeyinfrastructure:\n\t[Fr(~skX)]\n\t--[LontermKey($X,~skX)]->\n\t[!Ltk(____(POST_7)____, ____(PRE_31)____),!Pk($X, pk(~skX)), Out(pk(~skX)) ]\n\nrule SetupAfterEA: \n  \t[ !Password(____(PRE_32)____,$S,~pw), !Ltk($S, ~skS), Fr(~m), Fr(~rS), Fr(~rD)] \n  \t--[ Setup(____(PRE_33)____), Roles(____(LABEL_14)____,____(PRE_34)____,$P,____(LABEL_15)____), Device(____(LABEL_16)____,$D)\n\t\t, InitK($H,____(PRE_37)____,$D), InitK($H,____(PRE_36)____,$P), InitK($H,____(PRE_38)____,$S), InitK($H,'m',m(~m)), InitK($H,'idH',$idH), InitK($H,____(LABEL_17)____,$idS), InitK($H,____(PRE_35)____,'ok')\n\t\t, Rule3($H,'noTell','ok')          \t\t\n\t]-> \n  \t[ AgSt_D11(____(POST_10)____,____(POST_11)____,< ____(PRE_39)____, $idH, pk(~skS), ____(POST_12)____, ____(PRE_44)____, ____(PRE_46)____, ____(POST_15)____ >)\n\t, AgSt_S9(____(PRE_47)____,'S_9',< ~skS, ____(POST_13)____, ____(PRE_45)____, $idH, ~rS, ~rD >) \n\t                  \n\t, !HK(____(POST_14)____,'D',$D), !HK($H,'P',____(PRE_42)____), !HK($H,____(PRE_43)____,____(POST_8)____), !HK($H,'m',m(____(PRE_41)____)), !HK($H,'idH',$idH), !HK($H,'idS',$idS), !HK($H,'ok','ok')\t\n\t, AgSt_H11($H,____(PRE_40)____,< $D, $P, ____(POST_9)____, m(~m), $idH, $idS >)\n  \t]\n\n/* agent rules */\nrule D_15: \n\t[ AgSt_D11($D,'D_7',< $H, ____(PRE_48)____, pk(~skS), $idS, ____(PRE_49)____, ~rS, ~rD >), In( senc(<m(~m),~rS2>,f(~rS,~rD)) ) ]\n \t--[ D($D) ]->\n\t[ AgSt_D16(____(PRE_52)____,'D_16',< ____(POST_18)____, $idH, pk(____(PRE_50)____), $idS, $S, ____(POST_16)____, ~rD, m(~m), ____(PRE_51)____ >), Out_S(____(POST_17)____,$H,'m',m(~m)) ]\nrule D_17: \n\t[ AgSt_D16($D,____(PRE_55)____,< $H, $idH, pk(~skS), $idS, $S, ~rS, ____(PRE_53)____, m(~m), ~rS2 >), In_S($H,$D,____(PRE_54)____,'ok') ]\n \t--[ Dfin(), DfromHx($D,$H,____(PRE_56)____,'ok')]->\n\t[  Out(senc( f(m(~m),~rS2), f(~rS,~rD)) ) ]\n\t\t\n rule S_13:\n\t[ AgSt_S9($S,'S_9',< ~skS, ____(PRE_58)____, $H, $idH, ____(PRE_57)____, ~rD >), In(m(~m)), Fr(~rS2) ]\n\t--[ ]->\n\t[ AgSt_S14($S,'S_14',< ~skS, ____(PRE_59)____, $H, $idH, ~rS, ____(POST_19)____, m(____(PRE_60)____), ~rS2 >), Out( senc(<m(~m),~rS2>,f(~rS,~rD)) ) ]\nrule S_19:\n\t[ AgSt_S14($S,'S_14',< ~skS, $idS, $H, ____(PRE_62)____, ~rS, ~rD, m(~m), ____(PRE_61)____ >), In( senc( f(m(~m),~rS2), f(~rS,~rD)) )]\n\t--[ Commit($S,$H,m(~m)) ]->\n\t[ ]\n\n/* human agent rules */\nrule H_12:\n\t[ AgSt_H11($H,'H_11',< ____(PRE_63)____, $P, $S, m(~m), $idH, $idS >) ]\n\t--[H_role($H,'1'), Send($H,____(PRE_64)____,m(~m)) ]->\n\t[ AgSt_H12($H,'H_12',< $D, $P, ____(PRE_66)____, m(____(PRE_65)____), $idH, $idS >), Out(<'m',m(~m)>) ]\nrule H_16:           \n\t[ AgSt_H12($H,____(PRE_68)____,< $D, $P, $S, m(~m), $idH, ____(PRE_67)____ >), In_S($D,$H,'m',m(~m)) ]\n\t--[H_role(____(LABEL_18)____,'5'), Receive($H,'m',m(____(PRE_69)____)), Send($H,'ok','ok'), To($D) ]->\n\t[ Out_S($H,$D,'ok','ok') ]\n\n#ifdef ruleBased\n/* Rule-Based Human Rules */\n\naxiom noTell:\n\t\"All l m #s #i. Rule3('Human','noTell',l) @s & Send('Human',l,m) @i ==> F \"\n\naxiom noTellEx:\n\t\"All P l m #i #s. Rule4('Human','noTellEx',l,P)@s & Send('Human',l,m) @i ==> To(P) @i\"\n\naxiom noGet:\t\n\t\"( All l x #s #i. Rule3('Human','noGet',l) @s & Receive('Human',l,x) @i ==> F)\"\n\naxiom noGetEx:\t\n\t\"( All l x P #s #i. Rule4('Human','noGetEx',l,P) @s & Receive('Human',l,x) @i ==> From(P) @i)\"\n\naxiom ICompare:\n\t\" All l y #s #i. Rule3('Human','ICompare',l)@s &  Receive('Human',l,y) @i ==> Ex #j. InitK('Human',l,y) @j\"\n\n\n#endif\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\n/* lemmas */\n\nlemma functional: exists-trace \n\t\"(All ____(LEM_4)____ H2 #i #____(LEM_3)____. ____(LEM_2)____(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (Ex #n S m.\n\t\tCommit(S,'____(LEM_1)____',m) @n\n\t\t)\"\n\nend",
        "complete:": "theory MPAuth_MA_NoTellOK\nbegin\n\n\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tMP-Auth_MA\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=ruleBased with Rule3($H,'noTell','ok')\n- lemma functional (exists-trace): falsified - no trace found (27 steps)\n\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing, symmetric-encryption\nfunctions: f/1,  m/1  // f/1 used for function in protocol, m/1 used to give message a type.\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"not (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh($H,$x.1,~x), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send($H,$x.1,x.2), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send($H,$x.1,x.2), \n\t    Send($H,$y.1,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1>,<x.2,y.2,z.2>) ]\n\nrule H_send_S4:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send($H,$x.1,x.2), \n\t\tSend($H,$y.1,y.2),\n\t\tSend($H,$z.1,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1,$w.1>,<x.2,y.2,z.2,w.2>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( $A,$H, <$x.1,$y.1>, <x.2,y.2> ) ]\n\t--[ Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), !HK($H,$x.1,x.2),!HK($H,$y.1,y.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,$H, <$x.1,$y.1,$z.1,$v.1>,<x.2,y.2,z.2,v.2> ) ]\n\t--[     Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), \n\t\tReceive($H,$z.1,z.2), \n\t\tReceive($H,$v.1,v.2), !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth($A,xn,x), Out(<$A,$B,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\nrule passworddistribution:\n\t[Fr(~pw)]\n\t--[PasswordHS($X,$Y,~pw)]->\n\t[!Password($X,$Y,~pw)]\nrule publickeyinfrastructure:\n\t[Fr(~skX)]\n\t--[LontermKey($X,~skX)]->\n\t[!Ltk($X, ~skX),!Pk($X, pk(~skX)), Out(pk(~skX)) ]\n\nrule SetupAfterEA: \n  \t[ !Password($H,$S,~pw), !Ltk($S, ~skS), Fr(~m), Fr(~rS), Fr(~rD)] \n  \t--[ Setup($H), Roles($H,$D,$P,$S), Device($H,$D)\n\t\t, InitK($H,'D',$D), InitK($H,'P',$P), InitK($H,'S',$S), InitK($H,'m',m(~m)), InitK($H,'idH',$idH), InitK($H,'idS',$idS), InitK($H,'ok','ok')\n\t\t, Rule3($H,'noTell','ok')          \t\t\n\t]-> \n  \t[ AgSt_D11($D,'D_7',< $H, $idH, pk(~skS), $idS, $S, ~rS, ~rD >)\n\t, AgSt_S9($S,'S_9',< ~skS, $idS, $H, $idH, ~rS, ~rD >) \n\t                  \n\t, !HK($H,'D',$D), !HK($H,'P',$P), !HK($H,'S',$S), !HK($H,'m',m(~m)), !HK($H,'idH',$idH), !HK($H,'idS',$idS), !HK($H,'ok','ok')\t\n\t, AgSt_H11($H,'H_11',< $D, $P, $S, m(~m), $idH, $idS >)\n  \t]\n\n/* agent rules */\nrule D_15: \n\t[ AgSt_D11($D,'D_7',< $H, $idH, pk(~skS), $idS, $S, ~rS, ~rD >), In( senc(<m(~m),~rS2>,f(~rS,~rD)) ) ]\n \t--[ D($D) ]->\n\t[ AgSt_D16($D,'D_16',< $H, $idH, pk(~skS), $idS, $S, ~rS, ~rD, m(~m), ~rS2 >), Out_S($D,$H,'m',m(~m)) ]\nrule D_17: \n\t[ AgSt_D16($D,'D_16',< $H, $idH, pk(~skS), $idS, $S, ~rS, ~rD, m(~m), ~rS2 >), In_S($H,$D,'ok','ok') ]\n \t--[ Dfin(), DfromHx($D,$H,'ok','ok')]->\n\t[  Out(senc( f(m(~m),~rS2), f(~rS,~rD)) ) ]\n\t\t\n rule S_13:\n\t[ AgSt_S9($S,'S_9',< ~skS, $idS, $H, $idH, ~rS, ~rD >), In(m(~m)), Fr(~rS2) ]\n\t--[ ]->\n\t[ AgSt_S14($S,'S_14',< ~skS, $idS, $H, $idH, ~rS, ~rD, m(~m), ~rS2 >), Out( senc(<m(~m),~rS2>,f(~rS,~rD)) ) ]\nrule S_19:\n\t[ AgSt_S14($S,'S_14',< ~skS, $idS, $H, $idH, ~rS, ~rD, m(~m), ~rS2 >), In( senc( f(m(~m),~rS2), f(~rS,~rD)) )]\n\t--[ Commit($S,$H,m(~m)) ]->\n\t[ ]\n\n/* human agent rules */\nrule H_12:\n\t[ AgSt_H11($H,'H_11',< $D, $P, $S, m(~m), $idH, $idS >) ]\n\t--[H_role($H,'1'), Send($H,'m',m(~m)) ]->\n\t[ AgSt_H12($H,'H_12',< $D, $P, $S, m(~m), $idH, $idS >), Out(<'m',m(~m)>) ]\nrule H_16:           \n\t[ AgSt_H12($H,'H_12',< $D, $P, $S, m(~m), $idH, $idS >), In_S($D,$H,'m',m(~m)) ]\n\t--[H_role($H,'5'), Receive($H,'m',m(~m)), Send($H,'ok','ok'), To($D) ]->\n\t[ Out_S($H,$D,'ok','ok') ]\n\n#ifdef ruleBased\n/* Rule-Based Human Rules */\n\naxiom noTell:\n\t\"All l m #s #i. Rule3('Human','noTell',l) @s & Send('Human',l,m) @i ==> F \"\n\naxiom noTellEx:\n\t\"All P l m #i #s. Rule4('Human','noTellEx',l,P)@s & Send('Human',l,m) @i ==> To(P) @i\"\n\naxiom noGet:\t\n\t\"( All l x #s #i. Rule3('Human','noGet',l) @s & Receive('Human',l,x) @i ==> F)\"\n\naxiom noGetEx:\t\n\t\"( All l x P #s #i. Rule4('Human','noGetEx',l,P) @s & Receive('Human',l,x) @i ==> From(P) @i)\"\n\naxiom ICompare:\n\t\" All l y #s #i. Rule3('Human','ICompare',l)@s &  Receive('Human',l,y) @i ==> Ex #j. InitK('Human',l,y) @j\"\n\n\n#endif\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\n/* lemmas */\n\nlemma functional: exists-trace \n\t\"(All H1 H2 #i #j. Setup(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (Ex #n S m.\n\t\tCommit(S,'Human',m) @n\n\t\t)\"\n\nend"
    },
    {
        "file": "SPTHY-1/NAXOS_eCK.spthy",
        "incomplete": "theory NAXOS_eCK\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tCas Cremers, Benedikt Schmidt\n * Date: \tJanuary 2012/April 2012/October 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \teCK security\n *\n * Status: \tWorking\n */\n\nfunctions: h1/1\nfunctions: h2/1\n\n/* Protocol rules */\n\n/* In the description in the paper, we omitted the sorts. \n * In this description they are made explicit.\n * '$A' is equivalent to 'A:pub'\n * '~x' is equivalent to 'x:fresh'\n */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n  let pkA = 'g'^~ea \n  in\n  [ Fr(~ea) ] \n  --[ RegKey($A) ]->\n  [ !Ltk( ____(PRE_0)____, ~ea ), !Pk( $A, ____(POST_0)____ ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let X = 'g'^h1(<~ex, ~ea >)\n  in\n  [ Fr( ~ex ), !Ltk( $A, ~ea ) ]\n  -->\n  [ Init_1( ~ex, $A, $B, ~ea )\n  , !Ephk(~ex, ~ex)\n  , Out( ____(PRE_1)____ ) ]\n\nrule Init_2:\n  let KB  = 'g'^~eb\n      X = 'g'^h1(<~ex, ~ea >)\n      exp = h1(< ~ex, ~ea >)\n      key = h2(< Y^~ea, KB^exp, Y^exp, $A, $B >) \n  in\n  [ Init_1( ~ex, $A, $B, ~ea)\n  , !Pk( $B, KB ), In( ____(PRE_2)____ ) ]\n  --[ Accept( ~ex, ____(LABEL_0)____)\n    , Sid( ~ex, < $A, $B, X, Y, ____(PRE_3)____ >)\n    ]->\n   [ !Sessk( ~ex, key) ]\n\n/* Responder */\nrule Resp_1:\n  let KA  = 'g'^~lkI\n      exp = h1(< ~ey, ~eb >)\n      Y   = 'g'^exp\n      key = h2(< KA^exp, X^~eb, X^exp, $A, $B >) \n  in\n   [   Fr( ~ey ), !Ltk(____(PRE_4)____, ~eb), !Pk($A, KA), In( X ) ]\n   --[ Accept( ~ey, key )\n     , Sid( ~ey, < $B, ____(LABEL_1)____, Y, ____(PRE_5)____, 'Resp' > )\n     ]->\n   [   Out( Y ),\n       !Ephk(____(PRE_6)____, ~ey),\n       !Sessk( ~ey, key) ]\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~s, k) ] --[ RevealSessk(~s) ]-> [ Out(k) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, ea) ] --[ RevealLtk($A) ]-> [ Out(ea) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ] --[ RevealEphk(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n\nlemma eCK_key_secrecy:\n  /* \n   * The property specification is a (logically equivalent) simplified\n   * version of the one in the original eCK (ProvSec) paper:\n   *\n   * If there exists a test session whose key k is known to the\n   * Adversary with some session-id, then...\n   */\n  \"(All #____(LEM_12)____ #____(LEM_16)____ #i3 test ____(LEM_14)____ ____(LEM_13)____ k sent recvd ____(LEM_17)____.\n    Accept(test, k) @ i1 & ____(LEM_15)____( k ) @ i2 & Sid(test, < A, B, sent, recvd, role> ) @ i3\n    ==> ( \n    /* ... the test session must be \"not clean\".\n     * test is not clean if one of the following has happened:\n     */\n    /* 1. The adversary has revealed the session key of the test session. */\n      (Ex #i3. RevealSessk( test ) @ i3 )\n    \n    /* 2. The adversary has revealed both the longterm key of A and the\n          ephemeral key of the test session */\n    |  (Ex #i5 #i6. RevealLtk  ( A ) @ i5  & RevealEphk ( test  ) @ i6 )\n\n    /* 3. There is a matching session and */\n    | (Ex matchingSession #i3 matchingRole.\n           (   Sid ( matchingSession, < B, A, recvd, sent, matchingRole > ) @ i3 \n             & not ( matchingRole = role ) )\n\t   & (\n             /* (a) the adversary has revealed the session key of the matching session, or */\n\t       (Ex #i5. RevealSessk( matchingSession ) @ i5 )\n\n             /* (b) the adversary has revealed the longterm key of B and the ephemeral\n                    key of the matching session. */\n             | (Ex #i5 #i6. RevealLtk  ( B ) @ i5  & RevealEphk ( matchingSession ) @ i6 )\n\t   )\n      )\n    /* 4. There is no matching session and */\n    | ( ( not(Ex matchingSession #i3 matchingRole.\n           ( Sid ( matchingSession, < B, A, recvd, sent, matchingRole > ) @ i3 \n             & not ( matchingRole = role ) )))\n\n           /* the adversary has revealed the longterm key of B. */\n\t   & ( (Ex #i5. RevealLtk (B) @ i5 )\n\t   )\n      )\n    )\n  )\"\n\nend",
        "complete:": "theory NAXOS_eCK\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tCas Cremers, Benedikt Schmidt\n * Date: \tJanuary 2012/April 2012/October 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \teCK security\n *\n * Status: \tWorking\n */\n\nfunctions: h1/1\nfunctions: h2/1\n\n/* Protocol rules */\n\n/* In the description in the paper, we omitted the sorts. \n * In this description they are made explicit.\n * '$A' is equivalent to 'A:pub'\n * '~x' is equivalent to 'x:fresh'\n */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n  let pkA = 'g'^~ea \n  in\n  [ Fr(~ea) ] \n  --[ RegKey($A) ]->\n  [ !Ltk( $A, ~ea ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let X = 'g'^h1(<~ex, ~ea >)\n  in\n  [ Fr( ~ex ), !Ltk( $A, ~ea ) ]\n  -->\n  [ Init_1( ~ex, $A, $B, ~ea )\n  , !Ephk(~ex, ~ex)\n  , Out( X ) ]\n\nrule Init_2:\n  let KB  = 'g'^~eb\n      X = 'g'^h1(<~ex, ~ea >)\n      exp = h1(< ~ex, ~ea >)\n      key = h2(< Y^~ea, KB^exp, Y^exp, $A, $B >) \n  in\n  [ Init_1( ~ex, $A, $B, ~ea)\n  , !Pk( $B, KB ), In( Y ) ]\n  --[ Accept( ~ex, key)\n    , Sid( ~ex, < $A, $B, X, Y, 'Init' >)\n    ]->\n   [ !Sessk( ~ex, key) ]\n\n/* Responder */\nrule Resp_1:\n  let KA  = 'g'^~lkI\n      exp = h1(< ~ey, ~eb >)\n      Y   = 'g'^exp\n      key = h2(< KA^exp, X^~eb, X^exp, $A, $B >) \n  in\n   [   Fr( ~ey ), !Ltk($B, ~eb), !Pk($A, KA), In( X ) ]\n   --[ Accept( ~ey, key )\n     , Sid( ~ey, < $B, $A, Y, X, 'Resp' > )\n     ]->\n   [   Out( Y ),\n       !Ephk(~ey, ~ey),\n       !Sessk( ~ey, key) ]\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~s, k) ] --[ RevealSessk(~s) ]-> [ Out(k) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, ea) ] --[ RevealLtk($A) ]-> [ Out(ea) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ] --[ RevealEphk(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n\nlemma eCK_key_secrecy:\n  /* \n   * The property specification is a (logically equivalent) simplified\n   * version of the one in the original eCK (ProvSec) paper:\n   *\n   * If there exists a test session whose key k is known to the\n   * Adversary with some session-id, then...\n   */\n  \"(All #i1 #i2 #i3 test A B k sent recvd role.\n    Accept(test, k) @ i1 & K( k ) @ i2 & Sid(test, < A, B, sent, recvd, role> ) @ i3\n    ==> ( \n    /* ... the test session must be \"not clean\".\n     * test is not clean if one of the following has happened:\n     */\n    /* 1. The adversary has revealed the session key of the test session. */\n      (Ex #i3. RevealSessk( test ) @ i3 )\n    \n    /* 2. The adversary has revealed both the longterm key of A and the\n          ephemeral key of the test session */\n    |  (Ex #i5 #i6. RevealLtk  ( A ) @ i5  & RevealEphk ( test  ) @ i6 )\n\n    /* 3. There is a matching session and */\n    | (Ex matchingSession #i3 matchingRole.\n           (   Sid ( matchingSession, < B, A, recvd, sent, matchingRole > ) @ i3 \n             & not ( matchingRole = role ) )\n\t   & (\n             /* (a) the adversary has revealed the session key of the matching session, or */\n\t       (Ex #i5. RevealSessk( matchingSession ) @ i5 )\n\n             /* (b) the adversary has revealed the longterm key of B and the ephemeral\n                    key of the matching session. */\n             | (Ex #i5 #i6. RevealLtk  ( B ) @ i5  & RevealEphk ( matchingSession ) @ i6 )\n\t   )\n      )\n    /* 4. There is no matching session and */\n    | ( ( not(Ex matchingSession #i3 matchingRole.\n           ( Sid ( matchingSession, < B, A, recvd, sent, matchingRole > ) @ i3 \n             & not ( matchingRole = role ) )))\n\n           /* the adversary has revealed the longterm key of B. */\n\t   & ( (Ex #i5. RevealLtk (B) @ i5 )\n\t   )\n      )\n    )\n  )\"\n\nend"
    },
    {
        "file": "SPTHY-1/NSLPK3.spthy",
        "incomplete": "theory NSLPK3\nbegin\n\nbuiltins: asymmetric-encryption\n\n/*\n   Protocol:    The classic three message version of the\n                Needham-Schroeder-Lowe Public Key Protocol\n   Modeler:     Simon Meier\n   Date:        June 2012\n   Source:      Modeled after the description by Paulson in\n                Isabelle/HOL/Auth/NS_Public.thy.\n\n   Status:      working\n\n   Note that we are using explicit global constants for discerning the\n   different encryption instead of the implicit sources.\n */\n\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk(____(POST_0)____, ____(PRE_0)____), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following protocol\n\n  protocol NSLPK3 {\n    1. I -> R: {'1',ni,I}pk(R)\n    2. I <- R: {'2',ni,nr,R}pk(I)\n    3. I -> R: {'3',nr}pk(R)\n  }\n*/\n\nrule I_1:\n  let m1 = aenc{'1', ~ni, $I}pkR\n  in\n    [ Fr(~ni)\n    , !Pk($R, pkR)\n    ]\n  --[ OUT_I_1(m1)\n    ]->\n    [ Out( m1 )\n    , St_I_1($I, $R, ~ni)\n    ]\n\nrule R_1:\n  let m1 = aenc{'1', ni, I}pk(ltkR)\n      m2 = aenc{'2', ni, ~nr, $R}pkI\n  in\n    [ !Ltk($R, ltkR)\n    , In( m1 )\n    , !Pk(____(PRE_1)____, pkI)\n    , Fr(~nr)\n    ]\n  --[ IN_R_1_ni( ____(LABEL_0)____, m1 )\n    , OUT_R_1( m2 )\n    , Running(____(PRE_2)____, $R, <'init',ni,~nr>)\n    ]->\n    [ Out( ____(PRE_3)____ )\n    , St_R_1($R, I, ni, ____(POST_1)____)\n    ]\n\nrule I_2:\n  let m2 = aenc{'2', ni, nr, R}pk(ltkI)\n      m3 = aenc{'3', nr}pkR\n  in\n    [ St_I_1(I, ____(PRE_4)____, ni)\n    , !Ltk(I, ltkI)\n    , In( m2 )\n    , !Pk(R, pkR)\n    ]\n  --[ IN_I_2_nr( ____(LABEL_2)____, m2)\n    , Commit (____(PRE_5)____, ____(PRE_6)____, <'init',ni,nr>)  // need to log identities explicitely to\n    , Running(R, ____(LABEL_1)____, <'resp',ni,nr>)  // specify that they must not be\n                                     // compromised in the property.\n    ]->\n    [ Out( ____(PRE_7)____ )\n    , Secret(____(POST_2)____,R,nr)\n    , Secret(I,R,ni)\n    ]\n\nrule R_2:\n    [ St_R_1(____(PRE_8)____, I, ni, nr)\n    , !Ltk(R, ltkR)\n    , In( aenc{'3', nr}pk(ltkR) )\n    ]\n  --[ Commit (____(PRE_9)____, I, <'resp',ni,nr>)\n    ]->\n    [ Secret(R,____(PRE_10)____,nr)\n    , Secret(R,I,ni)\n    ]\n\n/* TODO: Also model session-key reveals and adapt security properties. */\nrule Secrecy_claim:\n  [ Secret(A, B, m) ] --[ Secret(A, B, m) ]-> []\n\n\n\n/* Note that we are using an untyped protocol model.\nThe contents of the 'ni' variable in rule R_1 may therefore in general be any\nmessage. This leads to unsolved chain constraints when checking what message\ncan be extracted from the message sent by rule R_1. In order to get rid of\nthese constraints, we require the following sources invariant that relates the\npoint of instantiation to the point of sending by either the adversary or the\ninitiator.\n\nIn order to understand the use of this sources invariant you might try the\nfollowing experiment. Comment out this sources invariant and then check the\nprecomputed case distinctions in the GUI. Try to complete the proof of the\n'nonce_secrecy' lemma.\n*/\nlemma types [sources]:\n  \" (All ____(LEM_6)____ ____(LEM_1)____ #i.\n       IN_R_1_ni( ni, m1) @ i\n       ==>\n       ( (____(LEM_4)____ #____(LEM_0)____. ____(LEM_5)____(ni) @ j & j < i)\n       | (Ex #j. ____(LEM_7)____( m1 ) @ j)\n       )\n    )\n  & (All nr ____(LEM_3)____ #i.\n       IN_I_2_nr( nr, m2) @ i\n       ==>\n       ( (Ex #j. KU(nr) @ j & j < i)\n       | (Ex #j. ____(LEM_2)____( m2 ) @ j)\n       )\n    )\n  \"\n\n// Nonce secrecy from the perspective of both the initiator and the responder.\nlemma nonce_secrecy:\n  \" /* It cannot be that */\n    not(\n        ____(LEM_14)____ A ____(LEM_10)____ s #____(LEM_17)____.\n          /* somebody claims to have setup a shared secret, */\n          Secret(A, ____(LEM_15)____, s) @ i\n          /* but the adversary knows it */\n        & (Ex #j. K(s) @ j)\n          /* without having performed a long-term key reveal. */\n        & not (Ex #____(LEM_11)____. RevLtk(A) @ ____(LEM_12)____)\n        & not (Ex #r. RevLtk(B) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor ____(LEM_33)____ params #____(LEM_28)____.\n        ____(LEM_19)____(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (____(LEM_25)____ #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex ____(LEM_31)____ ____(LEM_24)____ #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #____(LEM_30)____. RevLtk(actor) @ ____(LEM_32)____)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n// Consistency check: ensure that secrets can be shared between honest agents.\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* It is possible that */\n    Ex A B s #____(LEM_37)____.\n      /* somebody claims to have setup a shared secret, */\n      Secret(A, B, s) @ i\n      /* without the adversary having performed a long-term key reveal. */\n    & ____(LEM_40)____ (Ex #r. RevLtk(A) @ r)\n    & not (Ex #r. RevLtk(B) @ r)\n  \"\n\nend",
        "complete:": "theory NSLPK3\nbegin\n\nbuiltins: asymmetric-encryption\n\n/*\n   Protocol:    The classic three message version of the\n                Needham-Schroeder-Lowe Public Key Protocol\n   Modeler:     Simon Meier\n   Date:        June 2012\n   Source:      Modeled after the description by Paulson in\n                Isabelle/HOL/Auth/NS_Public.thy.\n\n   Status:      working\n\n   Note that we are using explicit global constants for discerning the\n   different encryption instead of the implicit sources.\n */\n\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following protocol\n\n  protocol NSLPK3 {\n    1. I -> R: {'1',ni,I}pk(R)\n    2. I <- R: {'2',ni,nr,R}pk(I)\n    3. I -> R: {'3',nr}pk(R)\n  }\n*/\n\nrule I_1:\n  let m1 = aenc{'1', ~ni, $I}pkR\n  in\n    [ Fr(~ni)\n    , !Pk($R, pkR)\n    ]\n  --[ OUT_I_1(m1)\n    ]->\n    [ Out( m1 )\n    , St_I_1($I, $R, ~ni)\n    ]\n\nrule R_1:\n  let m1 = aenc{'1', ni, I}pk(ltkR)\n      m2 = aenc{'2', ni, ~nr, $R}pkI\n  in\n    [ !Ltk($R, ltkR)\n    , In( m1 )\n    , !Pk(I, pkI)\n    , Fr(~nr)\n    ]\n  --[ IN_R_1_ni( ni, m1 )\n    , OUT_R_1( m2 )\n    , Running(I, $R, <'init',ni,~nr>)\n    ]->\n    [ Out( m2 )\n    , St_R_1($R, I, ni, ~nr)\n    ]\n\nrule I_2:\n  let m2 = aenc{'2', ni, nr, R}pk(ltkI)\n      m3 = aenc{'3', nr}pkR\n  in\n    [ St_I_1(I, R, ni)\n    , !Ltk(I, ltkI)\n    , In( m2 )\n    , !Pk(R, pkR)\n    ]\n  --[ IN_I_2_nr( nr, m2)\n    , Commit (I, R, <'init',ni,nr>)  // need to log identities explicitely to\n    , Running(R, I, <'resp',ni,nr>)  // specify that they must not be\n                                     // compromised in the property.\n    ]->\n    [ Out( m3 )\n    , Secret(I,R,nr)\n    , Secret(I,R,ni)\n    ]\n\nrule R_2:\n    [ St_R_1(R, I, ni, nr)\n    , !Ltk(R, ltkR)\n    , In( aenc{'3', nr}pk(ltkR) )\n    ]\n  --[ Commit (R, I, <'resp',ni,nr>)\n    ]->\n    [ Secret(R,I,nr)\n    , Secret(R,I,ni)\n    ]\n\n/* TODO: Also model session-key reveals and adapt security properties. */\nrule Secrecy_claim:\n  [ Secret(A, B, m) ] --[ Secret(A, B, m) ]-> []\n\n\n\n/* Note that we are using an untyped protocol model.\nThe contents of the 'ni' variable in rule R_1 may therefore in general be any\nmessage. This leads to unsolved chain constraints when checking what message\ncan be extracted from the message sent by rule R_1. In order to get rid of\nthese constraints, we require the following sources invariant that relates the\npoint of instantiation to the point of sending by either the adversary or the\ninitiator.\n\nIn order to understand the use of this sources invariant you might try the\nfollowing experiment. Comment out this sources invariant and then check the\nprecomputed case distinctions in the GUI. Try to complete the proof of the\n'nonce_secrecy' lemma.\n*/\nlemma types [sources]:\n  \" (All ni m1 #i.\n       IN_R_1_ni( ni, m1) @ i\n       ==>\n       ( (Ex #j. KU(ni) @ j & j < i)\n       | (Ex #j. OUT_I_1( m1 ) @ j)\n       )\n    )\n  & (All nr m2 #i.\n       IN_I_2_nr( nr, m2) @ i\n       ==>\n       ( (Ex #j. KU(nr) @ j & j < i)\n       | (Ex #j. OUT_R_1( m2 ) @ j)\n       )\n    )\n  \"\n\n// Nonce secrecy from the perspective of both the initiator and the responder.\nlemma nonce_secrecy:\n  \" /* It cannot be that */\n    not(\n        Ex A B s #i.\n          /* somebody claims to have setup a shared secret, */\n          Secret(A, B, s) @ i\n          /* but the adversary knows it */\n        & (Ex #j. K(s) @ j)\n          /* without having performed a long-term key reveal. */\n        & not (Ex #r. RevLtk(A) @ r)\n        & not (Ex #r. RevLtk(B) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor peer params #i.\n        Commit(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (Ex #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex actor2 peer2 #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #r. RevLtk(actor) @ r)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n// Consistency check: ensure that secrets can be shared between honest agents.\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* It is possible that */\n    Ex A B s #i.\n      /* somebody claims to have setup a shared secret, */\n      Secret(A, B, s) @ i\n      /* without the adversary having performed a long-term key reveal. */\n    & not (Ex #r. RevLtk(A) @ r)\n    & not (Ex #r. RevLtk(B) @ r)\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/OTPoverSMS_EA.spthy",
        "incomplete": "theory OTPoverSMS_EA \nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tOTP over SMS\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=infallible\n- lemma functional (exists-trace): verified (6 steps)\n- lemma entity_authentication (all-traces): verified (6 steps)\n- lemma device_authentication (all-traces): verified (6 steps)\n\n// for -D=untrained\n- lemma functional (exists-trace): verified (6 steps)\n- lemma entity_authentication (all-traces): verified (4 steps)\n- lemma device_authentication (all-traces): verified (4 steps)\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"____(LEM_0)____ (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh(____(PRE_0)____,$x.1,~x), !HK(____(LABEL_0)____,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive(____(LABEL_1)____,$x.1,____(PRE_1)____), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send(____(LABEL_2)____,____(PRE_2)____,x.2),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive(____(PRE_3)____,____(LABEL_3)____,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,x.2), !HK($H,____(PRE_4)____,y.2) ]\n\t--[ Send(____(LABEL_4)____,$x.1,x.2), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To(____(PRE_5)____)]->\n\t[ Out_S($H,$A,<$x.1,$y.1>,<x.2,____(PRE_6)____>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,x.2), !HK($H,____(PRE_4)____,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send(____(PRE_8)____,$x.1,x.2), \n\t    Send(____(LABEL_5)____,$y.1,____(PRE_9)____),\n\t    Send(____(LABEL_6)____,$z.1,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1>,<x.2,____(PRE_10)____,____(POST_0)____>) ]\n\nrule H_send_S4:\n\t[ !HK($H,$x.1,x.2), !HK($H,____(PRE_4)____,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send(____(LABEL_7)____,$x.1,x.2), \n\t\tSend($H,____(PRE_14)____,____(LABEL_8)____),\n\t\tSend($H,____(PRE_13)____,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S(____(PRE_16)____,$A,<$x.1,$y.1,____(POST_1)____,$w.1>,<____(PRE_15)____,y.2,z.2,____(POST_2)____>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( ____(PRE_17)____,$H, <$x.1,$y.1>, <x.2,y.2> ) ]\n\t--[ Receive(____(PRE_18)____,$x.1,____(LABEL_9)____), \n\t\tReceive(____(LABEL_10)____,____(PRE_19)____,y.2), !HK($H,$x.1,____(PRE_20)____),!HK($H,$y.1,y.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,____(PRE_20)____),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,____(PRE_22)____, <$x.1,$y.1,____(PRE_21)____,$v.1>,<x.2,y.2,z.2,v.2> ) ]\n\t--[     Receive(____(LABEL_11)____,$x.1,x.2), \n\t\tReceive(____(LABEL_12)____,$y.1,y.2), \n\t\tReceive(____(LABEL_13)____,$z.1,____(LABEL_15)____), \n\t\tReceive($H,$v.1,v.2), !HK(____(POST_4)____,____(POST_3)____,x.2), !HK($H,____(PRE_4)____,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2),\n\t\tH($H), From(____(LABEL_14)____)]->\n\t[ !HK(____(POST_4)____,____(POST_3)____,x.2), !HK($H,____(PRE_4)____,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth(____(PRE_30)____,xn,x), Out(<____(POST_5)____,$B,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\n\nrule Setup: \n  \t[ ] \n  \t--[ Setup(____(PRE_31)____), Roles($H,$D,$P,$S), Device($H,$D)\n\t\t, InitK($H,____(PRE_32)____,$D), InitK($H,'P',$P), InitK($H,____(PRE_33)____,$S), InitK($H,____(LABEL_17)____,____(LABEL_16)____)\t\n\t]-> \n  \t[ AgSt_D0(____(PRE_35)____,'D_0',< ____(PRE_34)____ >)\n    \t, AgSt_S0($S,'S_0',< ____(PRE_38)____, ____(PRE_37)____, $idH >) \n\t\t\n\t, !HK(____(POST_8)____,'D',____(POST_6)____), !HK($H,'P',____(PRE_36)____), !HK($H,____(POST_7)____,$S), !HK($H,____(POST_9)____,$idH)\t\n\t, AgSt_H0(____(PRE_45)____,'H_0',< $D, $P, $S, $idH >) \n  \t]\n\n/* agent rules */\nrule D_4: \n\t[ AgSt_D0($D,'D_0',< $H >), In_C(____(PRE_39)____,$D,'l',~otpw) ]\n \t--[Dfin(), D($D)]->\n\t[ Out_S($D,$H,'otpw',~otpw) ]\n\nrule S_2:\n\t[ AgSt_S0($S,'S_0',< $H, ____(PRE_40)____, $idH >), In($idH), Fr(~otpw) ]\n\t--[ Sstart($S) ]->\n\t[ AgSt_S3(____(POST_10)____,'S_3',< $H, $D, ____(PRE_41)____, ____(PRE_42)____ >), Out_C($S,$D,'l',~otpw) ]\nrule S_6:\n\t[ AgSt_S3($S,'S_3',< $H, $D, $idH, ____(PRE_43)____ >), In(~otpw) ]\n\t--[ Commit(____(PRE_44)____,$H,~otpw), CommitCA(____(LABEL_18)____,$H) ]->\n\t[ ]\n\n/* human agent rules */\nrule H_1:\n\t[ AgSt_H0(____(PRE_45)____,'H_0',< $D, $P, $S, $idH >)  ]\n\t--[H_role(____(LABEL_19)____,____(PRE_46)____), Send($H,'S',$S), Send($H,'idH',$idH) ]->\n\t[ AgSt_H1($H,____(POST_11)____,< ____(PRE_48)____, $P, $S, ____(PRE_47)____ >), Out(< <'S','idH' >,<$S,$idH > >) ]\nrule H_4:           \n\t[ AgSt_H1($H,'H_1',< $D, $P, $S, ____(PRE_50)____ >), In_S($D,$H,____(PRE_49)____,~otpw) ]\n\t--[H_role(____(PRE_51)____,'4'), Receive($H,____(LABEL_20)____,~otpw), Send($H,'otpw',~otpw) ]->\n\t[ Out(<'otpw',~otpw>)]\n\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\n\n/* lemmas */\n\n/* Functionality Lemma */\n\nlemma functional: exists-trace\n\t\"(____(LEM_5)____ ____(LEM_4)____ H2 #i #____(LEM_3)____. ____(LEM_1)____(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (Ex #____(LEM_2)____ #n S m \n\t\t.\n\t\tDfin() @k\n\t\t& Commit(S,'Human',m) @n\n\t\t\n\t\t)\"\n\n/* Entity and Device Authentication */\n\nlemma entity_authentication: \n\t\"All S ____(LEM_6)____ #k. Commit(S,'Human',m) @k ==> \n\t\t(____(LEM_9)____ #____(LEM_7)____ #____(LEM_10)____. Sstart(S)@____(LEM_15)____ & H('Human') @____(LEM_11)____ & i<____(LEM_12)____ &j<k) \t\t//in ____(LEM_8)____ when ____(LEM_14)____ human ____(LEM_13)____ are used\n\t\t|(Ex x #i #j. Sstart(S)@i & H_role('Human',x) @j& i<j &j<k) \t//in case when (infallible) human agent rules are used\n\t\t\n\t\"\n\nlemma device_authentication: \n\t\"All S #k. CommitCA(S,'____(LEM_20)____') @k ==> \n\t\t(____(LEM_18)____ ____(LEM_16)____ #i #j #s. Sstart(S)@i & ____(LEM_17)____(____(LEM_19)____) @j & i<j &j<k & Device('Human',D) @s )\t\t\n\t\"\n\n\n\n\n\n\nend",
        "complete:": "theory OTPoverSMS_EA \nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tOTP over SMS\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Advancing the Formal Foundations for Voting Protocols\", Lara Schmid, PhD Thesis, ETH Z\u00fcrich.\n\n=========\nRESULTS: \n=========\n\n// for -D=infallible\n- lemma functional (exists-trace): verified (6 steps)\n- lemma entity_authentication (all-traces): verified (6 steps)\n- lemma device_authentication (all-traces): verified (6 steps)\n\n// for -D=untrained\n- lemma functional (exists-trace): verified (6 steps)\n- lemma entity_authentication (all-traces): verified (4 steps)\n- lemma device_authentication (all-traces): verified (4 steps)\n\n*/\n\n\n/* built-ins */\nbuiltins: signing, asymmetric-encryption, hashing\n\n\n/* only allow human agent rules (corresponding to infallible human) */\n#ifdef infallible\naxiom only_infallible_humans:  \n  \t\"not (Ex #k. H('Human') @k)\" \n#endif\n\n/* only allow for untrained human rules (corresponding to fallible human) */\n#ifdef ruleBased\naxiom only_fallible_humansRB:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\" \n#endif\n#ifdef untrained\naxiom only_fallible_humansU:  \n  \t\"not (Ex H x #k. H_role(H,x) @k)\"\n#endif\n\n\n/* untrained human rules*/ \n// insecure channels\nrule H_fresh:\n        [ Fr(~x) ]\n\t--[ Fresh($H,$x.1,~x), !HK($H,$x.1,~x),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1,~x)]\n\nrule H_send: \n\t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H) ]->\n\t[ Out(<$x.1,x.2>)]\n\nrule H_receive: \n\t[ In( <$x.1,x.2>) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1, x.2),\n\t\tH($H) ]->\n\t[ !HK($H,$x.1, x.2) ]\n\n// secure channel\nrule H_send_S:\n  \t[ !HK($H,$x.1,x.2) ]\n\t--[ Send($H,$x.1,x.2),\n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,$x.1,x.2) ]\n\nrule H_receive_S:\n\t[ In_S( $A,$H, $x.1, x.2 ) ]\n\t--[ Receive($H,$x.1,x.2), !HK($H,$x.1,x.2), \n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2) ]\n\nrule H_send_S2: \n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2) ]\n\t--[ Send($H,$x.1,x.2), \n  \t    Send($H,$y.1,y.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1>,<x.2,y.2>) ]\n\n\nrule H_send_S3:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2) ]\n\t--[ Send($H,$x.1,x.2), \n\t    Send($H,$y.1,y.2),\n\t    Send($H,$z.1,z.2), \n\t    H($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1>,<x.2,y.2,z.2>) ]\n\nrule H_send_S4:\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$w.1,w.2) ]\n\t--[     Send($H,$x.1,x.2), \n\t\tSend($H,$y.1,y.2),\n\t\tSend($H,$z.1,z.2), \n\t\tSend($H,$w.1,w.2), \n\t\tH($H), To($A)]->\n\t[ Out_S($H,$A,<$x.1,$y.1,$z.1,$w.1>,<x.2,y.2,z.2,w.2>) ]\n\n\nrule H_receive_S2:\n\t[ In_S( $A,$H, <$x.1,$y.1>, <x.2,y.2> ) ]\n\t--[ Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), !HK($H,$x.1,x.2),!HK($H,$y.1,y.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2),!HK($H,$y.1,y.2) ]\n\n\nrule H_receive_S4:\n\t[ In_S( $A,$H, <$x.1,$y.1,$z.1,$v.1>,<x.2,y.2,z.2,v.2> ) ]\n\t--[     Receive($H,$x.1,x.2), \n\t\tReceive($H,$y.1,y.2), \n\t\tReceive($H,$z.1,z.2), \n\t\tReceive($H,$v.1,v.2), !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2),\n\t\tH($H), From($A)]->\n\t[ !HK($H,$x.1,x.2), !HK($H,$y.1,y.2), !HK($H,$z.1,z.2), !HK($H,$v.1,v.2) ]\n\n\n\n/* Channel rules */\nrule ChanOut_S:\n\t[Out_S($A,$B,xn,x)]\n\t--[ChanOut_S($A,$B,xn,x)]->\n\t[!Sec($A,$B,xn,x)]\n\nrule ChanIn_S:\n\t[!Sec($A,$B,xn,x)]\n\t--[ChanIn_S($A,$B,xn,x)]->\n\t[In_S($A,$B,xn,x)]\n\nrule ChanOut_C:\n\t[Out_C($A,$B,xn,x)]\n\t--[ChanOut_C($A,$B,xn,x)]->\n\t[!Conf($B,xn,x)]\n\nrule ChanIn_C:\n\t[!Conf($B,xn,x), In($A)]\n\t--[ChanIn_C($A,$B,xn,x)]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanIn_CAdv:\n\t[In(<$A,$B,xn,x>)]\n\t--[]->\n\t[In_C($A,$B,xn,x)]\n\nrule ChanOut_A:\n\t[Out_A($A,$B,xn,x)]\n\t--[ChanOut_A($A,$B,xn,x)]->\n\t[!Auth($A,xn,x), Out(<$A,$B,xn,x>)]\nrule ChanIn_A:\n\t[!Auth($A,xn,x), In($B)]\n\t--[ChanIn_A($A,$B,xn,x)]->\n\t[In_A($A,$B,xn,x)]\n\n\n/* setup */\n\nrule Setup: \n  \t[ ] \n  \t--[ Setup($H), Roles($H,$D,$P,$S), Device($H,$D)\n\t\t, InitK($H,'D',$D), InitK($H,'P',$P), InitK($H,'S',$S), InitK($H,'idH',$idH)\t\n\t]-> \n  \t[ AgSt_D0($D,'D_0',< $H >)\n    \t, AgSt_S0($S,'S_0',< $H, $D, $idH >) \n\t\t\n\t, !HK($H,'D',$D), !HK($H,'P',$P), !HK($H,'S',$S), !HK($H,'idH',$idH)\t\n\t, AgSt_H0($H,'H_0',< $D, $P, $S, $idH >) \n  \t]\n\n/* agent rules */\nrule D_4: \n\t[ AgSt_D0($D,'D_0',< $H >), In_C($S,$D,'l',~otpw) ]\n \t--[Dfin(), D($D)]->\n\t[ Out_S($D,$H,'otpw',~otpw) ]\n\nrule S_2:\n\t[ AgSt_S0($S,'S_0',< $H, $D, $idH >), In($idH), Fr(~otpw) ]\n\t--[ Sstart($S) ]->\n\t[ AgSt_S3($S,'S_3',< $H, $D, $idH, ~otpw >), Out_C($S,$D,'l',~otpw) ]\nrule S_6:\n\t[ AgSt_S3($S,'S_3',< $H, $D, $idH, ~otpw >), In(~otpw) ]\n\t--[ Commit($S,$H,~otpw), CommitCA($S,$H) ]->\n\t[ ]\n\n/* human agent rules */\nrule H_1:\n\t[ AgSt_H0($H,'H_0',< $D, $P, $S, $idH >)  ]\n\t--[H_role($H,'1'), Send($H,'S',$S), Send($H,'idH',$idH) ]->\n\t[ AgSt_H1($H,'H_1',< $D, $P, $S, $idH >), Out(< <'S','idH' >,<$S,$idH > >) ]\nrule H_4:           \n\t[ AgSt_H1($H,'H_1',< $D, $P, $S, $idH >), In_S($D,$H,'otpw',~otpw) ]\n\t--[H_role($H,'4'), Receive($H,'otpw',~otpw), Send($H,'otpw',~otpw) ]->\n\t[ Out(<'otpw',~otpw>)]\n\n\n/* axioms assumptions */\n\n/* Every Human starts in the initial state */\naxiom setup_for_IK:\n\t\"All H #i. H(H) @i ==> Ex #j. Setup(H) @j & j<i\"\n\n/* No secure channels between humans exist. Humans\n   must communicate over incecure channels.         \n   This assumption is necessary to remove unsolved chains\n   in the protocol model. It is not a strong restriction\n   because the protocols do not rely on human to human \n   for security. */\naxiom not_Chan_S_human_to_human:\n\t\"All A B mn m #i #j #k.\n\t\tChanOut_S(A,B,mn,m) @i & H(A) @j & H(B) @k ==> F\"\n\n/* Assumption: Two distinct roles are not executed by the same agent */\naxiom notSameRole:\n\t\"All H1 H2 D1 D2 P1 P2 S1 S2 #i #j. Roles(H1,D1,P1,S1) @i & Roles(H2,D2,P2,S2) @j ==>\n\t\t  not H1 = D1\n\t\t& not H1 = D2\n\t\t& not H1 = P1\n\t\t& not H1 = P2\n\t\t& not H1 = S1\n\t\t& not H1 = S2\n\t\t& not D1 = P1\n\t\t& not D1 = P2\n\t\t& not D1 = S1\n\t\t& not D1 = S2\n\t\t& not P1 = S1\n\t\t& not P1 = S2\n\t\"\n/* Assumption: Two humans do not share a single device */\naxiom Device:\n\t\"All H1 H2 D #i #j. Device(H1,D) @i & Device (H2,D) @j ==> H1=H2 \"\n\n\n\n\n\n/* lemmas */\n\n/* Functionality Lemma */\n\nlemma functional: exists-trace\n\t\"(All H1 H2 #i #j. Setup(H1) @i & Setup(H2) @j ==> #i = #j) \n\t& (Ex #k #n S m \n\t\t.\n\t\tDfin() @k\n\t\t& Commit(S,'Human',m) @n\n\t\t\n\t\t)\"\n\n/* Entity and Device Authentication */\n\nlemma entity_authentication: \n\t\"All S m #k. Commit(S,'Human',m) @k ==> \n\t\t(Ex #i #j. Sstart(S)@i & H('Human') @j & i<j &j<k) \t\t//in case when untrained human rules are used\n\t\t|(Ex x #i #j. Sstart(S)@i & H_role('Human',x) @j& i<j &j<k) \t//in case when (infallible) human agent rules are used\n\t\t\n\t\"\n\nlemma device_authentication: \n\t\"All S #k. CommitCA(S,'Human') @k ==> \n\t\t(Ex D #i #j #s. Sstart(S)@i & D(D) @j & i<j &j<k & Device('Human',D) @s )\t\t\n\t\"\n\n\n\n\n\n\nend"
    },
    {
        "file": "SPTHY-1/Pattern_matching_and_destructors.spthy",
        "incomplete": "theory Pattern_matching_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration how pattern matching can be described by\n                destructor functions\n   Modeler:     Simon Meier, Benedikt Schmidt\n   Date:        July 2012\n\n   Status:      working (warning that constant 'true' is not allowed)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors.\n*/\n\n\nbuiltins: symmetric-encryption, hashing\nfunctions: isPair/1, true/0, encSucc/2, and/2\n\nequations: isPair( pair(x, y) ) = true\nequations: encSucc(senc(x,y),y) = true\nequations: and(true,true) = true\n\n// Shared keys that can be compromised.\nrule Setup_Key:\n  [ Fr(~k) ] --[ IsKey(~k) ]-> [ !Key(~k) ]\n\nrule Reveal_Key:\n  [ !Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\nrule Initiator:\n  let msg = senc{~sec,~pub}k\n  in\n    [ !Key(k), Fr(~sec), Fr(~pub) ]\n  --[ Out_Initiator(msg)\n    , Public(~pub)\n    ]->\n    [ Out( msg ) ]\n\nrule Responder:\n  // We use explicit destructors instead of the pattern matching\n  //\n  //     msg = senc{sec,pub}key\n  //\n  // Since we also check that the destructors succeed, this is trace-equivalent to\n  // the pattern-matching version.\n  // This can be seen after checking the variants of the rule and removing all variants\n  // with isTrue(t) such that there is no sigma with t\\sigma =AC true.\n  // Note that using isEq(x,x) -> true, equality checks can also be handled with IsTrue.\n  //\n  let body = sdec{msg}key\n      sec  = fst(body)\n      pub  = snd(body)\n  in\n    [ !Key(key), In( msg )\n    ]\n  --[ In_Responder(msg, pub)\n    , Secret(sec, ____(PRE_0)____)\n    , IsTrue( and( encSucc(msg,key), isPair(____(LABEL_0)____) ) )\n    ]->\n    [ Out( pub ) ]\n\nrestriction True_is_true:\n      \"All x #i. IsTrue(x) @ i ==> x = true()\"\n\n// This type assertion does not hold, as 'pub' could be an failure term. See the\n// case marked below for the missing piece of the puzzle.\n// Note that we interpret its formula modulo AC.\nlemma type_assertion [sources]:\n  /* For all messages received by the responder */\n  \"(All ____(LEM_0)____ pub #i. In_Responder(____(LEM_7)____, pub) @ i ==>\n        /* they either came from the adversary and he therefore knows the\n         * contained 'k' variable before it was instantiated */\n      ( (Ex #____(LEM_8)____. ____(LEM_5)____(pub) @ j & j < i)\n        /* or there is an initiator that sent 'm'. */\n      | (Ex #j. Out_Initiator(m) @ j)\n      )\n   )\n  \"\n\n/* The secret part of the message received by Responder is secret provided the\n * key has not been compromised.\n */\nlemma Responder_secrecy:\n  \" All ____(LEM_10)____ key #i #j.\n        Secret(____(LEM_11)____, key) @ #i\n      & K(sec) @ #j\n      ==>\n       (____(LEM_9)____ #r. Rev(key) @ r)\n  \"\n\n/* Sanity check: the public part is accessible to the adversary without\n * performing a key reveal.\n */\nlemma Public_part_public:\n  exists-trace\n  \"  /* No key reveal has been performed */\n    ____(LEM_18)____ (____(LEM_15)____ ____(LEM_13)____ #i. Rev(k) @ i)\n    /* and the public part of a message is known to the adversary. */\n  & (Ex pub #i #j. Public(pub) @ i & K(pub) @ j )\n  \"\n\n\nend",
        "complete:": "theory Pattern_matching_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration how pattern matching can be described by\n                destructor functions\n   Modeler:     Simon Meier, Benedikt Schmidt\n   Date:        July 2012\n\n   Status:      working (warning that constant 'true' is not allowed)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors.\n*/\n\n\nbuiltins: symmetric-encryption, hashing\nfunctions: isPair/1, true/0, encSucc/2, and/2\n\nequations: isPair( pair(x, y) ) = true\nequations: encSucc(senc(x,y),y) = true\nequations: and(true,true) = true\n\n// Shared keys that can be compromised.\nrule Setup_Key:\n  [ Fr(~k) ] --[ IsKey(~k) ]-> [ !Key(~k) ]\n\nrule Reveal_Key:\n  [ !Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\nrule Initiator:\n  let msg = senc{~sec,~pub}k\n  in\n    [ !Key(k), Fr(~sec), Fr(~pub) ]\n  --[ Out_Initiator(msg)\n    , Public(~pub)\n    ]->\n    [ Out( msg ) ]\n\nrule Responder:\n  // We use explicit destructors instead of the pattern matching\n  //\n  //     msg = senc{sec,pub}key\n  //\n  // Since we also check that the destructors succeed, this is trace-equivalent to\n  // the pattern-matching version.\n  // This can be seen after checking the variants of the rule and removing all variants\n  // with isTrue(t) such that there is no sigma with t\\sigma =AC true.\n  // Note that using isEq(x,x) -> true, equality checks can also be handled with IsTrue.\n  //\n  let body = sdec{msg}key\n      sec  = fst(body)\n      pub  = snd(body)\n  in\n    [ !Key(key), In( msg )\n    ]\n  --[ In_Responder(msg, pub)\n    , Secret(sec, key)\n    , IsTrue( and( encSucc(msg,key), isPair(body) ) )\n    ]->\n    [ Out( pub ) ]\n\nrestriction True_is_true:\n      \"All x #i. IsTrue(x) @ i ==> x = true()\"\n\n// This type assertion does not hold, as 'pub' could be an failure term. See the\n// case marked below for the missing piece of the puzzle.\n// Note that we interpret its formula modulo AC.\nlemma type_assertion [sources]:\n  /* For all messages received by the responder */\n  \"(All m pub #i. In_Responder(m, pub) @ i ==>\n        /* they either came from the adversary and he therefore knows the\n         * contained 'k' variable before it was instantiated */\n      ( (Ex #j. KU(pub) @ j & j < i)\n        /* or there is an initiator that sent 'm'. */\n      | (Ex #j. Out_Initiator(m) @ j)\n      )\n   )\n  \"\n\n/* The secret part of the message received by Responder is secret provided the\n * key has not been compromised.\n */\nlemma Responder_secrecy:\n  \" All sec key #i #j.\n        Secret(sec, key) @ #i\n      & K(sec) @ #j\n      ==>\n       (Ex #r. Rev(key) @ r)\n  \"\n\n/* Sanity check: the public part is accessible to the adversary without\n * performing a key reveal.\n */\nlemma Public_part_public:\n  exists-trace\n  \"  /* No key reveal has been performed */\n    not (Ex k #i. Rev(k) @ i)\n    /* and the public part of a message is known to the adversary. */\n  & (Ex pub #i #j. Public(pub) @ i & K(pub) @ j )\n  \"\n\n\nend"
    },
    {
        "file": "SPTHY-1/PR1_ShHm.spthy",
        "incomplete": "theory PR1_ShHm\nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tProtocol PR_1\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Dispute Resolution in Voting\", David Basin, Sasa Radomirovic, and Lara Schmid, CSF20.\n* Disclaimer:\tThe pupose of this protocl is to establish a possibility result.\n\t\tWe specify a simple protocol with one voter, as this is sufficeint for demonstrating possibility.\n\n========\nRESULTS:\n========\n\n- lemma functional: verified \n- lemma AuthP: verified\n\n\n*/\n\n/*============\nSPECIFICATION:\n============== */\n\n/*=====================\nFunctions and equations \n======================= */\nbuiltins: signing, multiset\n\nfunctions: sg/2, ver/2 //new signing function\n\nequations:\n// our equation for modeling the verification of signatures\nver(sg(m, sk), pk(sk)) = m \n\n\n\n\n/* ==========\nChannel rules\n============= */\n\nrule ChanOut_A: [Out_A($A,x)]--[ChanOut_A($A,x)]->[!Auth($A,x), Out(<$A,x>)]\nrule ChanIn_A:\t[!Auth($A,x)]--[ChanIn_A($A,x)]->[In_A($A,x)]\n\n\n//reliable insecure channel: all messages sent on a reliable channel, are received unchanged\n\nrule ChanOut_IR:  \t[ Out_IR($A,$B,m) ]--[ ChanOut_IR($A,$B,m) ]->[ Out(<$A,$B,m>) ] \nrule ChanIn_IR:  \t[ In(<$A,$B,m>) ]--[ ChanIn_IR($A,$B,m) ]->[ In_IR($A,$B,m) ] \n\n//undeniable insecure channel: all messages sent on a undeniable channel, are received unchanged\n\nrule ChanOut_IU:   \t[ Out_IU($A,$B,m) ] --[ ChanOut_IU($A,$B,m) ]->[ Out(<$A,$B,m>) ] \nrule ChanIn_IU:   \t[ In(<$A,$B,m>) ] --[ ChanIn_IU($A,$B,m) ]-> [ In_IU($A,$B,m) ] \nrestriction Chan_U: \n\t\"All A ____(LEM_0)____ ____(LEM_1)____ #i. Send_U(A,____(LEM_2)____,m) @i ==> Ex #j. Receive_U(A,B,m) @j \"\n\n/* ======================\nAdversary's fake evidence\n====================== */\n// the adversary can claim any term that he knows to be evidence\nrule fakeEvidence:\n\t[ In(<ballot,evidence>) ] --[ Evidence(ballot,evidence) ]-> [ ] \n\n\n/* =====\nProtocol\n======== */\n\nrule publickeyinfrastructure:\n  [ Fr(~skX) ]--[ LongtermKey($X,~skX) ]-> [ !Ltk($X,____(PRE_0)____), !Pk($X,pk(____(POST_0)____)), Out(pk(~skX)) ]\n\nrule Setup: \n  \t[ ] \n  \t--[ \tSetup(),\n\t\tVoter('H'),\n\t\tServer('S'), Honest('S')\n\t]-> \n  \t[ Out(<'H',< ____(PRE_1)____,'P',____(POST_1)____>>)\n\t, AgSt_BB0('BB',<____(PRE_2)____>)\n\t, AgSt_P0('P',<____(POST_2)____>)\n\t, AgSt_S0('S',<'empty'>)\n\t\t\t\n  \t]\n\n/* rule H_1 omitted as H is modeled by the adversary rules */\n\nrule P: // P is partially trusted to forward messages from H to S\n\t[ AgSt_P0(____(PRE_3)____,<$S>), In_IR($H,$P,b)] \n\t--[ Receive_R($H,____(PRE_4)____,____(LABEL_0)____),\n\t    Send_U($P,$S,b),\n\t    Pub($P,$S,b)\n\t]->\n\t[  Out_IU($P,$S,b) ]\n\nrule S_1: \n\t[ AgSt_S0($S, <____(PRE_5)____>), \n\t  In_IU($P,$S,<$v,$H>) // S implicitly (by pattern matching) only accepts ballots of the right format\n\t ] \n\t--[ Receive_U($P,$S,<____(PRE_6)____,____(LABEL_1)____>),\n\t    Pub($P,$S,<$v,$H>)\n\t]->\n\t[ Out_A(____(PRE_7)____, <'bs', <$v,$H> >),\n\t  Out_A($S, <'vs', $v>)\n\t]\n\nrule BB: \n\t[ AgSt_BB0(____(PRE_8)____,<$S>)\n\t, In_A($S, <'bs', bs >)\n\t, In_A($S, <'vs', vs >)\n\t]\n \t--[     BB_recorded($BB,<'bs', bs >),\n\t\tBB_tallied($BB,<'____(LABEL_2)____', vs >),\n\t\tEnd()\n\t]->  \n\t[ Out_A(____(PRE_9)____, <'bs', bs >)\n\t, Out_A(____(POST_3)____, <'vs', vs >)\n\t]\n\n/* rule H_5 omitted as H is modeled by the adversary rules */ \n\n\n/* =========\nRESTRICTIONS\n============ */\n// there is only one setup\nrestriction OneSetup: \n\t\"All #i #j. Setup() @i & Setup() @j ==> #i = #j \"\n\n\n/* ====\nLEMMAS \n======= */\n\nlemma functional: exists-trace\n \t\" ____(LEM_4)____  BB #____(LEM_3)____ \n\t\t.\n\t\tBB_recorded(BB,<'bs', <'v','H'>>) @k\n\t\t& BB_tallied(BB,<'vs','v'>) @k\n\n\t\t\"\n\n/*===========================\nDispute Resolution Properties\n===========================*/\nlemma AuthP: \n\t\"All ____(LEM_6)____ #i.\n\t\tHonest(S) @i \n\t==> // ____(LEM_8)____ Faulty\n\tnot (Ex BB ____(LEM_5)____ P b1 #k #l H2 ____(LEM_9)____. \n\t\tBB_recorded(BB,<'bs', b1 >) @k\n\t\t& not (b1=____(LEM_7)____)  \n\t\t& Pub(P,S,____(LEM_10)____) @l\n\t\t& b=<v,H2>\n\t\t)\"\n\nend",
        "complete:": "theory PR1_ShHm\nbegin\n\n/* \n============\nINTRODUCTION\n============\n* Protocol:\tProtocol PR_1\n* Modeler: \tLara Schmid\n* Date: \tMarch 2020\n* Source:\t[1] \"Dispute Resolution in Voting\", David Basin, Sasa Radomirovic, and Lara Schmid, CSF20.\n* Disclaimer:\tThe pupose of this protocl is to establish a possibility result.\n\t\tWe specify a simple protocol with one voter, as this is sufficeint for demonstrating possibility.\n\n========\nRESULTS:\n========\n\n- lemma functional: verified \n- lemma AuthP: verified\n\n\n*/\n\n/*============\nSPECIFICATION:\n============== */\n\n/*=====================\nFunctions and equations \n======================= */\nbuiltins: signing, multiset\n\nfunctions: sg/2, ver/2 //new signing function\n\nequations:\n// our equation for modeling the verification of signatures\nver(sg(m, sk), pk(sk)) = m \n\n\n\n\n/* ==========\nChannel rules\n============= */\n\nrule ChanOut_A: [Out_A($A,x)]--[ChanOut_A($A,x)]->[!Auth($A,x), Out(<$A,x>)]\nrule ChanIn_A:\t[!Auth($A,x)]--[ChanIn_A($A,x)]->[In_A($A,x)]\n\n\n//reliable insecure channel: all messages sent on a reliable channel, are received unchanged\n\nrule ChanOut_IR:  \t[ Out_IR($A,$B,m) ]--[ ChanOut_IR($A,$B,m) ]->[ Out(<$A,$B,m>) ] \nrule ChanIn_IR:  \t[ In(<$A,$B,m>) ]--[ ChanIn_IR($A,$B,m) ]->[ In_IR($A,$B,m) ] \n\n//undeniable insecure channel: all messages sent on a undeniable channel, are received unchanged\n\nrule ChanOut_IU:   \t[ Out_IU($A,$B,m) ] --[ ChanOut_IU($A,$B,m) ]->[ Out(<$A,$B,m>) ] \nrule ChanIn_IU:   \t[ In(<$A,$B,m>) ] --[ ChanIn_IU($A,$B,m) ]-> [ In_IU($A,$B,m) ] \nrestriction Chan_U: \n\t\"All A B m #i. Send_U(A,B,m) @i ==> Ex #j. Receive_U(A,B,m) @j \"\n\n/* ======================\nAdversary's fake evidence\n====================== */\n// the adversary can claim any term that he knows to be evidence\nrule fakeEvidence:\n\t[ In(<ballot,evidence>) ] --[ Evidence(ballot,evidence) ]-> [ ] \n\n\n/* =====\nProtocol\n======== */\n\nrule publickeyinfrastructure:\n  [ Fr(~skX) ]--[ LongtermKey($X,~skX) ]-> [ !Ltk($X,~skX), !Pk($X,pk(~skX)), Out(pk(~skX)) ]\n\nrule Setup: \n  \t[ ] \n  \t--[ \tSetup(),\n\t\tVoter('H'),\n\t\tServer('S'), Honest('S')\n\t]-> \n  \t[ Out(<'H',< 'BB','P',$v>>)\n\t, AgSt_BB0('BB',<'S'>)\n\t, AgSt_P0('P',<'S'>)\n\t, AgSt_S0('S',<'empty'>)\n\t\t\t\n  \t]\n\n/* rule H_1 omitted as H is modeled by the adversary rules */\n\nrule P: // P is partially trusted to forward messages from H to S\n\t[ AgSt_P0($P,<$S>), In_IR($H,$P,b)] \n\t--[ Receive_R($H,$P,b),\n\t    Send_U($P,$S,b),\n\t    Pub($P,$S,b)\n\t]->\n\t[  Out_IU($P,$S,b) ]\n\nrule S_1: \n\t[ AgSt_S0($S, <'empty'>), \n\t  In_IU($P,$S,<$v,$H>) // S implicitly (by pattern matching) only accepts ballots of the right format\n\t ] \n\t--[ Receive_U($P,$S,<$v,$H>),\n\t    Pub($P,$S,<$v,$H>)\n\t]->\n\t[ Out_A($S, <'bs', <$v,$H> >),\n\t  Out_A($S, <'vs', $v>)\n\t]\n\nrule BB: \n\t[ AgSt_BB0($BB,<$S>)\n\t, In_A($S, <'bs', bs >)\n\t, In_A($S, <'vs', vs >)\n\t]\n \t--[     BB_recorded($BB,<'bs', bs >),\n\t\tBB_tallied($BB,<'vs', vs >),\n\t\tEnd()\n\t]->  \n\t[ Out_A($BB, <'bs', bs >)\n\t, Out_A($BB, <'vs', vs >)\n\t]\n\n/* rule H_5 omitted as H is modeled by the adversary rules */ \n\n\n/* =========\nRESTRICTIONS\n============ */\n// there is only one setup\nrestriction OneSetup: \n\t\"All #i #j. Setup() @i & Setup() @j ==> #i = #j \"\n\n\n/* ====\nLEMMAS \n======= */\n\nlemma functional: exists-trace\n \t\" Ex  BB #k \n\t\t.\n\t\tBB_recorded(BB,<'bs', <'v','H'>>) @k\n\t\t& BB_tallied(BB,<'vs','v'>) @k\n\n\t\t\"\n\n/*===========================\nDispute Resolution Properties\n===========================*/\nlemma AuthP: \n\t\"All S #i.\n\t\tHonest(S) @i \n\t==> // not Faulty\n\tnot (Ex BB b P b1 #k #l H2 v. \n\t\tBB_recorded(BB,<'bs', b1 >) @k\n\t\t& not (b1=b)  \n\t\t& Pub(P,S,b) @l\n\t\t& b=<v,H2>\n\t\t)\"\n\nend"
    },
    {
        "file": "SPTHY-1/probEnc.spthy",
        "incomplete": "theory probEnc \nbegin\n\n/*\n * Protocol:     Probabilistic encryption\n * Modeler:      Jannik Dreier and Ralf Sasse\n * Described in: Automated Symbolic Proofs of Observational Equivalence [CCS'15]\n * Date:         April 2015\n *\n * Status: \tworking\n// Observational equivalence is proven automatically in less than 0.4 seconds.\n */\n\nfunctions: penc/3, pdec/2, pk/1\n\nequations: pdec(penc(m,pk(k),r), k) = m\n\nrule gen:\n  [ Fr(~k) ]\n--[ ]->\n  [ !Key(~k), Out(pk(~k)) ]\n\nrule enc:\n  [ !Key(k), Fr(~r1), Fr(~r2), In(x) ]\n--[ ]->\n  [ Out(diff(~r1, penc(x, pk(k), ~r2))) ]\n\nend",
        "complete:": "theory probEnc \nbegin\n\n/*\n * Protocol:     Probabilistic encryption\n * Modeler:      Jannik Dreier and Ralf Sasse\n * Described in: Automated Symbolic Proofs of Observational Equivalence [CCS'15]\n * Date:         April 2015\n *\n * Status: \tworking\n// Observational equivalence is proven automatically in less than 0.4 seconds.\n */\n\nfunctions: penc/3, pdec/2, pk/1\n\nequations: pdec(penc(m,pk(k),r), k) = m\n\nrule gen:\n  [ Fr(~k) ]\n--[ ]->\n  [ !Key(~k), Out(pk(~k)) ]\n\nrule enc:\n  [ !Key(k), Fr(~r1), Fr(~r2), In(x) ]\n--[ ]->\n  [ Out(diff(~r1, penc(x, pk(k), ~r2))) ]\n\nend"
    },
    {
        "file": "SPTHY-1/RFID_Simple.spthy",
        "incomplete": "theory RFID_Simple begin\n\n/*\n   Protocol:    Extended version of the running example from StatVerif paper\n   Modeler:     Simon Meier\n   Date:        May 2012\n\n   Status:      working\n\n   ...\n\n*/\n\n// Declare RFID/1 fact as globally fresh...for testing purposes.\n// unique_insts: RFID/1\n\nbuiltins: asymmetric-encryption\n\n// RFID Memory Cell model\n\nrule GenKey:\n    [ Fr(~sk)  // We let the key identify the device.\n    ]\n  --[ Device_Key(~sk) ]->\n    [ Device_Init(~sk)\n    , Device_Alice(~sk)\n    , Out(pk(~sk)) // make the public key available to the adversary\n    ]\n\nrule Alice:\n    [ Device_Alice(sk)\n    , Fr(~x)\n    , Fr(~y)\n    ]\n  --[ Exclusive(~x,~y)\n    , Device_Use(sk)\n    ]->\n    [ Device_Alice(sk)\n    , Out( aenc{~x,~y}pk(sk) )\n    ]\n\nrule DeviceToBob:\n    [ Device_Init(sk), Device_Alice(sk) ]\n  --[ ToBob(sk) ]->\n    [ Device_Select(sk) ]\n\nrule Select_Left:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Left(sk) ]\n\nrule Select_Right:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Right(sk) ]\n\nrule Decrypt_Left:\n    [ !Device_Left(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(x) ]->\n    [ Out(x) ]\n\nrule Decrypt_Right:\n    [ !Device_Right(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(y) ]->\n    [ Out(y) ]\n\nlemma types [sources]:\n  \"All ____(LEM_1)____ #____(LEM_4)____. Access(____(LEM_2)____) @ i ==>\n      (Ex   #____(LEM_0)____. ____(LEM_3)____(m) @ j & j < i)\n    | (Ex x #j. Exclusive(x,m) @ j)\n    | (Ex y #j. Exclusive(m,y) @ j)\n  \"\n\nlemma Device_ToBob [use_induction]:\n  \"All ____(LEM_6)____ #____(LEM_5)____. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\"\n\nlemma Device_Init_Use_Set [reuse, use_induction]:\n  \"All ____(LEM_9)____ #i. Device_Use(sk) @ i ==>\n      (All #____(LEM_8)____. ToBob(sk) @ j ==> i < j)\n    & (____(LEM_10)____ #j. ____(LEM_7)____(sk) @ j & j < i)\"\n\n// attackable\nlemma reachability_left:\n  exists-trace\n  \"Ex x ____(LEM_11)____ #i #j. Exclusive(x,____(LEM_12)____) @i & K(x) @ j\"\n\nend\n\n/*\nlemma reachability_right:\n  exists-trace\n  \"Ex x y #i #k.  Exclusive(x,y) @i & K(y) @ k\"\n\nlemma secrecy:\n  \"not(Ex x y #i #k1 #k2.\n         Exclusive(x,y) @i & K(x) @ k1 & K(y) @ k2\n      )\n  \"\n\n/*\n// We cannot prove this lemma with the current system. We cannot state that\n// the ressource \"Device_Alice\" is no longer available after the device has\n// been handed to Bob.\n//\n// The fundamental problem is that we cannot express the multiplicity of a\n// fact in the *state* in our formula language, as we are always talking about\n// the whole history. It's also unclear how to exploit such state use_inductions\n// in our backwards approach.\nlemma Alice_before_to_bob:\n  \"All sk #i #j. Device_Use(sk) @ i & ToBob(sk) @ j ==> i < j\"\n\n*/\n*/\n*/\n\nend",
        "complete:": "theory RFID_Simple begin\n\n/*\n   Protocol:    Extended version of the running example from StatVerif paper\n   Modeler:     Simon Meier\n   Date:        May 2012\n\n   Status:      working\n\n   ...\n\n*/\n\n// Declare RFID/1 fact as globally fresh...for testing purposes.\n// unique_insts: RFID/1\n\nbuiltins: asymmetric-encryption\n\n// RFID Memory Cell model\n\nrule GenKey:\n    [ Fr(~sk)  // We let the key identify the device.\n    ]\n  --[ Device_Key(~sk) ]->\n    [ Device_Init(~sk)\n    , Device_Alice(~sk)\n    , Out(pk(~sk)) // make the public key available to the adversary\n    ]\n\nrule Alice:\n    [ Device_Alice(sk)\n    , Fr(~x)\n    , Fr(~y)\n    ]\n  --[ Exclusive(~x,~y)\n    , Device_Use(sk)\n    ]->\n    [ Device_Alice(sk)\n    , Out( aenc{~x,~y}pk(sk) )\n    ]\n\nrule DeviceToBob:\n    [ Device_Init(sk), Device_Alice(sk) ]\n  --[ ToBob(sk) ]->\n    [ Device_Select(sk) ]\n\nrule Select_Left:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Left(sk) ]\n\nrule Select_Right:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Right(sk) ]\n\nrule Decrypt_Left:\n    [ !Device_Left(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(x) ]->\n    [ Out(x) ]\n\nrule Decrypt_Right:\n    [ !Device_Right(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(y) ]->\n    [ Out(y) ]\n\nlemma types [sources]:\n  \"All m #i. Access(m) @ i ==>\n      (Ex   #j. KU(m) @ j & j < i)\n    | (Ex x #j. Exclusive(x,m) @ j)\n    | (Ex y #j. Exclusive(m,y) @ j)\n  \"\n\nlemma Device_ToBob [use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\"\n\nlemma Device_Init_Use_Set [reuse, use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\n    & (Ex #j. Device_Key(sk) @ j & j < i)\"\n\n// attackable\nlemma reachability_left:\n  exists-trace\n  \"Ex x y #i #j. Exclusive(x,y) @i & K(x) @ j\"\n\nend\n\n/*\nlemma reachability_right:\n  exists-trace\n  \"Ex x y #i #k.  Exclusive(x,y) @i & K(y) @ k\"\n\nlemma secrecy:\n  \"not(Ex x y #i #k1 #k2.\n         Exclusive(x,y) @i & K(x) @ k1 & K(y) @ k2\n      )\n  \"\n\n/*\n// We cannot prove this lemma with the current system. We cannot state that\n// the ressource \"Device_Alice\" is no longer available after the device has\n// been handed to Bob.\n//\n// The fundamental problem is that we cannot express the multiplicity of a\n// fact in the *state* in our formula language, as we are always talking about\n// the whole history. It's also unclear how to exploit such state use_inductions\n// in our backwards approach.\nlemma Alice_before_to_bob:\n  \"All sk #i #j. Device_Use(sk) @ i & ToBob(sk) @ j ==> i < j\"\n\n*/\n*/\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/RF_dist_bound.spthy",
        "incomplete": "theory RF_dist_bound\nbegin\n\nsection{* RF Distance Bounding Protocol from the Usenix Paper of Kaspar\nRasmusson *}\n\n/* Modeler: Simon Meier\n   Date:   January, 2011\n   Status: Incomplete\n*/\n\nbuiltins: signing, hashing\n\n/* FIXME: Finish example\n\nrule Prov1:\n  [ Pub( P ), Fr( Np ) ]\n  -->\n  [ Prov1( P, Np )\n  , Out( sign{h(Np)}sk(lts(P)) ) ]\n\nrule Verif1:\n  [ Pub( V ), Fr( Nv ), In( sign{commit}sk(lts(P)) ) ]\n  -->\n  [ Verif1( V, P, Nv, commit )\n  , Challenge( Nv )\n  , Out( Nv ) ]\n\nrule Prov2:\n  [ Prov1( P, Np ), Challenge( Nv ) ]\n  -->\n  [ Prov2( P, Np, Nv ), Response( Nv, Np ), Out( Np ) ]\n\nrule Verif2:\n  [ Verif1( V, P, Nv, commit ), Response( Nv, Np )\n  -->\n  [ Verif2( V, P, Nv, Np, commit ), Out( <Nv, Np> ) ]\n\nrule Prov3:\n  [ Prov2( P, Np, Nv ), Pub(V) ]\n  -->\n  [ Prov3( P, V, Np, Nv ), Out( sign{V, Np, Nv}sk(lts(P)) ) ]\n\nrule Verif3:\n  [ Verif2( V, P, Nv, Np, commit ), In( sign{V, Np, Nv}sk(lts(P)) ) ]\n  -->\n  [ Verif3( V, P, Nv, Np, commit ) ]\n\n\n/*\nlemma Verif_auth:\n  \" vv :> Verif3( V, P, Nv, Np, commit ) & commit = h(Np) &\n    vr :> Response( Np, Nv )\n    ==>\n    (Ex vp. vp :> Prov3( P, V, Np, Nv ) )\n  \"\n\n*/\n\n\n/*\nlemma lts_secrecy:\n  \"vk <: Msg(lts(x)) ==>\n   (Ex vr. vr :> Ltsr(x) & vr >+> vk)\n  \"\n*/\n\nlemma C_k_secrecy:\n  \"vc :> CR_C_1( S, k) &\n   ____(LEM_7)____ <: Msg(k)\n   ==>\n   (Ex vr. vr :> Ltsr(S) & vr >+> ____(LEM_8)____)\n  \"\n\nlemma C_niagree:\n  \" ____(LEM_11)____ :> CR_C_2(____(LEM_9)____, ____(LEM_10)____)\n    ==>\n    (Ex sS sk vs.\n        vs :> CR_S_1(sS, sk) &\n        <sS, sk> = <cS, ____(LEM_12)____>\n    )\n    |\n    (Ex vr. vr :> Ltsr(cS) & vr >+> vc)\n  \"\n*/\n\nend",
        "complete:": "theory RF_dist_bound\nbegin\n\nsection{* RF Distance Bounding Protocol from the Usenix Paper of Kaspar\nRasmusson *}\n\n/* Modeler: Simon Meier\n   Date:   January, 2011\n   Status: Incomplete\n*/\n\nbuiltins: signing, hashing\n\n/* FIXME: Finish example\n\nrule Prov1:\n  [ Pub( P ), Fr( Np ) ]\n  -->\n  [ Prov1( P, Np )\n  , Out( sign{h(Np)}sk(lts(P)) ) ]\n\nrule Verif1:\n  [ Pub( V ), Fr( Nv ), In( sign{commit}sk(lts(P)) ) ]\n  -->\n  [ Verif1( V, P, Nv, commit )\n  , Challenge( Nv )\n  , Out( Nv ) ]\n\nrule Prov2:\n  [ Prov1( P, Np ), Challenge( Nv ) ]\n  -->\n  [ Prov2( P, Np, Nv ), Response( Nv, Np ), Out( Np ) ]\n\nrule Verif2:\n  [ Verif1( V, P, Nv, commit ), Response( Nv, Np )\n  -->\n  [ Verif2( V, P, Nv, Np, commit ), Out( <Nv, Np> ) ]\n\nrule Prov3:\n  [ Prov2( P, Np, Nv ), Pub(V) ]\n  -->\n  [ Prov3( P, V, Np, Nv ), Out( sign{V, Np, Nv}sk(lts(P)) ) ]\n\nrule Verif3:\n  [ Verif2( V, P, Nv, Np, commit ), In( sign{V, Np, Nv}sk(lts(P)) ) ]\n  -->\n  [ Verif3( V, P, Nv, Np, commit ) ]\n\n\n/*\nlemma Verif_auth:\n  \" vv :> Verif3( V, P, Nv, Np, commit ) & commit = h(Np) &\n    vr :> Response( Np, Nv )\n    ==>\n    (Ex vp. vp :> Prov3( P, V, Np, Nv ) )\n  \"\n\n*/\n\n\n/*\nlemma lts_secrecy:\n  \"vk <: Msg(lts(x)) ==>\n   (Ex vr. vr :> Ltsr(x) & vr >+> vk)\n  \"\n*/\n\nlemma C_k_secrecy:\n  \"vc :> CR_C_1( S, k) &\n   vk <: Msg(k)\n   ==>\n   (Ex vr. vr :> Ltsr(S) & vr >+> vk)\n  \"\n\nlemma C_niagree:\n  \" vc :> CR_C_2(cS, ck)\n    ==>\n    (Ex sS sk vs.\n        vs :> CR_S_1(sS, sk) &\n        <sS, sk> = <cS, ck>\n    )\n    |\n    (Ex vr. vr :> Ltsr(cS) & vr >+> vc)\n  \"\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/SAKE.spthy",
        "incomplete": "/* Modified SAKE Protocol Description used for SAGE\n\nInvolved parties: verifier V, device D\n\nV:  random a\n    v0 = g^a mod p\n    v1 = h(v0)\n    v2 = h(v1)\n    c = cksum(v2)\n\nV -> D: v2\n\nD:  c = cksum(v2)\n    random r\n    w0 = h(c | r)\n    w1 = h(w0)\n    w2 = h(w1)\n    random b\n    k = g^b mod p\n\nD -> V: w2, mac(c, w2)\n\nV:  check if mac(c, w2) matches received mac\n\nV -> D: v1\n\nD:  check if v2 == h(v1)\n\nD -> V: w1, k, mac(w2, k)\n  \nV:  check if mac(w2, k) matches received mac\n    check if w2 == h(w1)\n\nV -> D: v0\n\nD:  check if v1 == h(v0)\n    sk_VD = v0^b = (g^a)^b mod p\n\nD -> V: w0\n\nV:  check if w1 == h(w0)\n    sk_VD = k^a = (g^b)^a mod p\n\n*/\n\n\ntheory SAKE\nbegin\n\nbuiltins: hashing, diffie-hellman\nfunctions: g/0, mac/2, cksum/1\n\n/* Channel rules for authentic channels */\n\nrule ChanOut_A:\n    [ Out_A($A,$B,x) ]\n    --[ ChanOut_A($A,$B,x) ]->\n    [ !Auth(____(PRE_0)____,x), Out(<$A,____(POST_0)____,x>) ]\n\nrule ChanIn_A:\n    [ !Auth($A,x), In($B) ]\n    --[ ChanIn_A($A,$B,x) ]->\n    [ In_A($A,$B,x) ]\n\n\n/* Model of protocol */\n\nrule Verifier_1:\n    let v0 = g^(~a)\n        v1 = h(v0)\n        v2 = h(v1)\n        c  = cksum(v2)\n    in\n    [ Fr(~a) ]\n  --[ Neq( $V, $D )\n    , StartV( $V )\n    ]->\n    [ Verifier_1( $V, $D, ~a, v0, v1, ____(POST_1)____ )\n    , Out( ____(PRE_1)____ )\n    ]\n\nrule Verifier_2:\n    let w2 = fst( w2_msg )\n        w2_mac = snd( w2_msg )\n    in\n    [ Verifier_1( ____(PRE_3)____, $D, ____(PRE_2)____, v0, v1, c )\n    , In_A( $V, $D, <w2_msg, $D> )\n    ]\n  --[ Eq(mac(c, w2), w2_mac) ]->\n    [ Verifier_2( $V, $D, ____(PRE_4)____, ____(POST_2)____, v1, w2 )\n    , Out( v1 )\n    ]\n\nrule Verifier_3:\n    let w1 = fst( w1_msg )\n        k = snd(fst( w1_msg ))\n        w1_mac = snd(snd( w1_msg ))\n    in\n    [ Verifier_2( $V, ____(PRE_5)____, a, v0, v1, w2 )\n    , In( w1_msg )\n    ]\n  --[ Eq(mac(____(PRE_6)____, k), w1_mac)\n    , Eq(h(w1), w2)\n    ]->\n    [ Verifier_3( $V, $D, a, v0, ____(POST_3)____, ____(PRE_7)____, w1, k )\n    , Out( v0 ) \n    ]\n\nrule Verifier_4:\n    let sk = k^a\n    in\n    [ Verifier_3( $V, $D, ____(PRE_8)____, v0, v1, w2, w1, k )\n    , In( w0 )\n    ]\n  --[ SecretV( ____(LABEL_0)____ )\n    , Eq(h(w0), w1)\n    , Commit( $V, ____(PRE_9)____, sk)\n    ]->\n    [  ]\n\n\n\nrule Device_1:\n    let c  = cksum(v2)\n        w0 = h(c, ~r)\n        w1 = h(w0)\n        w2 = h(w1)\n        k = g^(~b)\n    in\n    [ Fr(~r), Fr(~b)\n    , In( v2 )\n    ]\n  --[ AliveD( $D ) ]->\n    [ Out_A( $D, ____(POST_5)____, <<____(POST_4)____, mac(c, w2)>, $D> )\n    , Device_1( $D, $V, ____(PRE_11)____, ____(PRE_10)____, w1, w2, k, v2 )\n    ]\n\nrule Device_2:\n    [ Device_1( $D, $V, b, w0, w1, ____(PRE_12)____, k, v2 )\n    , In( v1 )\n    ]\n  --[ Eq(h(v1), v2)\n    , AliveD( $D )\n    ]->\n    [ Device_2( ____(PRE_14)____, ____(PRE_13)____, ____(POST_6)____, w0, w1, w2, ____(POST_7)____, v2, v1 )\n    , Out( <w1, k, mac(w2, k)> )\n    ]\n\nrule Device_3:\n    let sk = v0^b\n    in\n    [ Device_2( $D, $V, b, w0, w1, w2, ____(PRE_16)____, v2, v1 )\n    , In( ____(PRE_15)____ )\n    ]\n  --[ Eq(h(v0), ____(LABEL_1)____)\n    , Running( $D, ____(PRE_17)____, sk )\n    , AliveD( $D )\n    ]->\n    [ Out( w0 )\n    ]\n\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\n\nrestriction Inequality:\n  \"All x #i. Neq(x,x) @ #i ==> F\"\n\n\nlemma secrecyV:\n  \"____(LEM_1)____ x #i. \n    SecretV(x) @i ==> not (Ex #____(LEM_0)____. K(x)@j)\"\n    \nlemma weak_agreement:\n  \"All a ____(LEM_3)____ ____(LEM_2)____ #i. \n    Commit(a,b,key) @i\n    ==> (Ex #____(LEM_4)____. Running(b,a,key) @j)\"\n\nlemma recent_aliveness:\n  \"All a ____(LEM_7)____ key #i. \n    Commit(a,b,key) @i\n    ==> (____(LEM_5)____ #____(LEM_6)____ #k. ____(LEM_8)____(b) @j & StartV(a) @k & #k < #j & #j < #i)\"\n\nend",
        "complete:": "/* Modified SAKE Protocol Description used for SAGE\n\nInvolved parties: verifier V, device D\n\nV:  random a\n    v0 = g^a mod p\n    v1 = h(v0)\n    v2 = h(v1)\n    c = cksum(v2)\n\nV -> D: v2\n\nD:  c = cksum(v2)\n    random r\n    w0 = h(c | r)\n    w1 = h(w0)\n    w2 = h(w1)\n    random b\n    k = g^b mod p\n\nD -> V: w2, mac(c, w2)\n\nV:  check if mac(c, w2) matches received mac\n\nV -> D: v1\n\nD:  check if v2 == h(v1)\n\nD -> V: w1, k, mac(w2, k)\n  \nV:  check if mac(w2, k) matches received mac\n    check if w2 == h(w1)\n\nV -> D: v0\n\nD:  check if v1 == h(v0)\n    sk_VD = v0^b = (g^a)^b mod p\n\nD -> V: w0\n\nV:  check if w1 == h(w0)\n    sk_VD = k^a = (g^b)^a mod p\n\n*/\n\n\ntheory SAKE\nbegin\n\nbuiltins: hashing, diffie-hellman\nfunctions: g/0, mac/2, cksum/1\n\n/* Channel rules for authentic channels */\n\nrule ChanOut_A:\n    [ Out_A($A,$B,x) ]\n    --[ ChanOut_A($A,$B,x) ]->\n    [ !Auth($A,x), Out(<$A,$B,x>) ]\n\nrule ChanIn_A:\n    [ !Auth($A,x), In($B) ]\n    --[ ChanIn_A($A,$B,x) ]->\n    [ In_A($A,$B,x) ]\n\n\n/* Model of protocol */\n\nrule Verifier_1:\n    let v0 = g^(~a)\n        v1 = h(v0)\n        v2 = h(v1)\n        c  = cksum(v2)\n    in\n    [ Fr(~a) ]\n  --[ Neq( $V, $D )\n    , StartV( $V )\n    ]->\n    [ Verifier_1( $V, $D, ~a, v0, v1, c )\n    , Out( v2 )\n    ]\n\nrule Verifier_2:\n    let w2 = fst( w2_msg )\n        w2_mac = snd( w2_msg )\n    in\n    [ Verifier_1( $V, $D, a, v0, v1, c )\n    , In_A( $V, $D, <w2_msg, $D> )\n    ]\n  --[ Eq(mac(c, w2), w2_mac) ]->\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , Out( v1 )\n    ]\n\nrule Verifier_3:\n    let w1 = fst( w1_msg )\n        k = snd(fst( w1_msg ))\n        w1_mac = snd(snd( w1_msg ))\n    in\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , In( w1_msg )\n    ]\n  --[ Eq(mac(w2, k), w1_mac)\n    , Eq(h(w1), w2)\n    ]->\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , Out( v0 ) \n    ]\n\nrule Verifier_4:\n    let sk = k^a\n    in\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , In( w0 )\n    ]\n  --[ SecretV( sk )\n    , Eq(h(w0), w1)\n    , Commit( $V, $D, sk)\n    ]->\n    [  ]\n\n\n\nrule Device_1:\n    let c  = cksum(v2)\n        w0 = h(c, ~r)\n        w1 = h(w0)\n        w2 = h(w1)\n        k = g^(~b)\n    in\n    [ Fr(~r), Fr(~b)\n    , In( v2 )\n    ]\n  --[ AliveD( $D ) ]->\n    [ Out_A( $D, $V, <<w2, mac(c, w2)>, $D> )\n    , Device_1( $D, $V, ~b, w0, w1, w2, k, v2 )\n    ]\n\nrule Device_2:\n    [ Device_1( $D, $V, b, w0, w1, w2, k, v2 )\n    , In( v1 )\n    ]\n  --[ Eq(h(v1), v2)\n    , AliveD( $D )\n    ]->\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , Out( <w1, k, mac(w2, k)> )\n    ]\n\nrule Device_3:\n    let sk = v0^b\n    in\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , In( v0 )\n    ]\n  --[ Eq(h(v0), v1)\n    , Running( $D, $V, sk )\n    , AliveD( $D )\n    ]->\n    [ Out( w0 )\n    ]\n\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\n\nrestriction Inequality:\n  \"All x #i. Neq(x,x) @ #i ==> F\"\n\n\nlemma secrecyV:\n  \"All x #i. \n    SecretV(x) @i ==> not (Ex #j. K(x)@j)\"\n    \nlemma weak_agreement:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j. Running(b,a,key) @j)\"\n\nlemma recent_aliveness:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j #k. AliveD(b) @j & StartV(a) @k & #k < #j & #j < #i)\"\n\nend"
    },
    {
        "file": "SPTHY-1/RYY.spthy",
        "incomplete": "theory RYY\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* RYY : UM-like identity based key exchange protocol *}\n\n/*\n * Protocol:\tRYY\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr(msk) ]\n  -->\n  [ !MSK( msk ) ]\n\nrule KGC_request:\n  [ !MSK( s ) ]\n  -->\n  [ !LTK( $ID, pmult(s, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( msk ) ]\n  --[ MskRev() ]->\n  [ Out( msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, sek ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( sek ) ]\n\n\n// Protocol\n\nrule Init_1:\n  [ Fr( ~ex ) ]\n  -->\n  [ Init( ~ex, $A, $B )\n  , Out( 'g'^~ex )\n  ]\n\nrule Init_2:\n  let X = 'g'^~ex\n      sessKey = kdf( Y^~ex, em(hp($B), skA), $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, ____(PRE_0)____ )\n  , !LTK( $A, skA )\n  , In( Y )\n  ]\n  --[ Accept( ~ex, sessKey )\n    , Sid(    ~ex, <____(PRE_1)____,$B,____(LABEL_0)____,Y,'Init'> )\n    ]->\n  [ !Sessk( ~ex, sessKey )]\n\n\nrule Resp_1:\n  let Y = 'g'^~ey\n      sessKey = kdf(X^~ey, em(skB, hp($A)), $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , In( X )\n  ]\n  --[ Accept( ~ey, sessKey )\n    , Sid(    ~ey, <____(LABEL_1)____,$A,____(PRE_2)____,X,'Resp'> )\n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  ]\n\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #i #j ____(LEM_4)____ B ____(LEM_2)____ Y t1 ____(LEM_6)____ k role1 ____(LEM_1)____.\n        ____(LEM_0)____(t1, k) @ i\n      & Sid(t1, <A,B,X,Y,role1>) @ i\n      & Accept(t2, k) @ j\n      & Sid(t2, <B,A,Y,X,____(LEM_3)____>) @ j\n      & ____(LEM_5)____ (role1 = role2)\"\n\n\nlemma key_secrecy_WPFS:\n  /* \n   * We do not consider ephemeral key reveals for RYY\n   * \n   * If there exists a test session whose key k is known to the\n   * Adversary with some session id, then...\n   */\n  \"(All #____(LEM_10)____ #i2 test ____(LEM_7)____ B X ____(LEM_9)____ ____(LEM_8)____ k.\n    Accept(test, k) @ ____(LEM_11)____ & K( k ) @ i2 & Sid(test, <A,B,X,Y,role1>) @ i1\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // 1. The adversary has revealed the test's session key.\n      (Ex #i3. SesskRev( test ) @ i3 )\n\n    // 2. There is a matching session and\n    | (Ex matching #i3 role2.\n           ( Sid ( matching, <B,A,Y,X,role2>  ) @ i3 & not (role1 = role2))\n\t   & ( \n             // (a) the adversary has revealed the session key of the matching sesssion, or\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (b) the adversary revealed the longterm key of test's peer before test finished, or\n             | (Ex #i5. LtkRev( B ) @ i5 & i5 < i1)\n\n             // (c) the adversary revealed the longterm key of test's actor before test finished, or\n             | (Ex #i5. LtkRev( A ) @ i5 & i5 < i1 )\n\n             // (d) the adversary revealed the master key before test finished.\n             | (Ex #i5. MskRev() @ i5 & i5 < i1 )\n\t   )\n      )\n\n    // 3. There is no matching session and\n    | (  (not (Ex matching #i3 role2.\n           ( Sid ( matching, <B,A,Y,X,role2>  ) @ i3 & not (role1 = role2))))\n\n        & (  \n          // (a) the adversary revealed the longterm key of test's peer, or\n            (Ex #i5. LtkRev( B ) @ i5)\n\n          // (b) the adversary revealed the longterm key of test's actor, or\n          | (Ex #i3. LtkRev(A) @ i3)\n          \n          // (c) the adversary revealed the master key.\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n    )\n  )\"\n\nend",
        "complete:": "theory RYY\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* RYY : UM-like identity based key exchange protocol *}\n\n/*\n * Protocol:\tRYY\n * Modeler: \tBenedikt Schmidt\n * Date: \tJuly 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr(msk) ]\n  -->\n  [ !MSK( msk ) ]\n\nrule KGC_request:\n  [ !MSK( s ) ]\n  -->\n  [ !LTK( $ID, pmult(s, hp($ID)) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( msk ) ]\n  --[ MskRev() ]->\n  [ Out( msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, sek ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( sek ) ]\n\n\n// Protocol\n\nrule Init_1:\n  [ Fr( ~ex ) ]\n  -->\n  [ Init( ~ex, $A, $B )\n  , Out( 'g'^~ex )\n  ]\n\nrule Init_2:\n  let X = 'g'^~ex\n      sessKey = kdf( Y^~ex, em(hp($B), skA), $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, $B )\n  , !LTK( $A, skA )\n  , In( Y )\n  ]\n  --[ Accept( ~ex, sessKey )\n    , Sid(    ~ex, <$A,$B,X,Y,'Init'> )\n    ]->\n  [ !Sessk( ~ex, sessKey )]\n\n\nrule Resp_1:\n  let Y = 'g'^~ey\n      sessKey = kdf(X^~ey, em(skB, hp($A)), $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , In( X )\n  ]\n  --[ Accept( ~ey, sessKey )\n    , Sid(    ~ey, <$B,$A,Y,X,'Resp'> )\n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  ]\n\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #i #j A B X Y t1 t2 k role1 role2.\n        Accept(t1, k) @ i\n      & Sid(t1, <A,B,X,Y,role1>) @ i\n      & Accept(t2, k) @ j\n      & Sid(t2, <B,A,Y,X,role2>) @ j\n      & not (role1 = role2)\"\n\n\nlemma key_secrecy_WPFS:\n  /* \n   * We do not consider ephemeral key reveals for RYY\n   * \n   * If there exists a test session whose key k is known to the\n   * Adversary with some session id, then...\n   */\n  \"(All #i1 #i2 test A B X Y role1 k.\n    Accept(test, k) @ i1 & K( k ) @ i2 & Sid(test, <A,B,X,Y,role1>) @ i1\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // 1. The adversary has revealed the test's session key.\n      (Ex #i3. SesskRev( test ) @ i3 )\n\n    // 2. There is a matching session and\n    | (Ex matching #i3 role2.\n           ( Sid ( matching, <B,A,Y,X,role2>  ) @ i3 & not (role1 = role2))\n\t   & ( \n             // (a) the adversary has revealed the session key of the matching sesssion, or\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\n             // (b) the adversary revealed the longterm key of test's peer before test finished, or\n             | (Ex #i5. LtkRev( B ) @ i5 & i5 < i1)\n\n             // (c) the adversary revealed the longterm key of test's actor before test finished, or\n             | (Ex #i5. LtkRev( A ) @ i5 & i5 < i1 )\n\n             // (d) the adversary revealed the master key before test finished.\n             | (Ex #i5. MskRev() @ i5 & i5 < i1 )\n\t   )\n      )\n\n    // 3. There is no matching session and\n    | (  (not (Ex matching #i3 role2.\n           ( Sid ( matching, <B,A,Y,X,role2>  ) @ i3 & not (role1 = role2))))\n\n        & (  \n          // (a) the adversary revealed the longterm key of test's peer, or\n            (Ex #i5. LtkRev( B ) @ i5)\n\n          // (b) the adversary revealed the longterm key of test's actor, or\n          | (Ex #i3. LtkRev(A) @ i3)\n          \n          // (c) the adversary revealed the master key.\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n    )\n  )\"\n\nend"
    },
    {
        "file": "SPTHY-1/Scott.spthy",
        "incomplete": "theory Scott\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* Scott: MTI-C0 like identity based key exchange protocol *}\n\n/*\n * Protocol:\tScott\n * Modeler: \tBenedikt Schmidt\n * Date: \tMay 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr( ~msk ) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk ) ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult( ~msk, hp($ID) ) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, sek ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( sek ) ]\n\n\n// Protocol\n\nrule Init_1:\n  let skA = pmult( ~s, hp($A) )\n      X   = em( skA, hp($B) )^~ex\n  in \n  [ Fr( ~ex )\n  , !LTK( $A, skA )\n  ]\n  -->\n  [ Init( ____(PRE_0)____, $A, $B, ____(POST_0)____ )\n  , Out( X )\n  ]\n\nrule Init_2:\n  let sessKey = kdf( Y^~ex, $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, ____(PRE_1)____, X )\n  , In( Y )\n  ]\n  --[ Accept( ____(PRE_4)____, $A, ____(LABEL_0)____, sessKey )\n    , Sid( ____(LABEL_1)____, <____(PRE_2)____,$A,$B,X,Y> )\n    // a matching session for ~ex has the following sid\n    , Match( ~ex, <____(PRE_3)____,$B,$A,X,Y> )\n    , NotNeutral(Y)\n    ]->\n  [ !Sessk( ~ex, sessKey ) ]\n\n\nrule Resp_1:\n  let skB     = pmult( ~s, hp($B))\n      Y       = em(hp($A), skB)^~ey\n      sessKey = kdf(X^~ey, $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , In( X )\n  ]\n  --[ Accept( ____(PRE_6)____, ____(LABEL_2)____, $A, ____(PRE_7)____ )\n    , Sid( ~ey, <'Resp',$B,$A,X,____(PRE_5)____> )\n    // a matching session for ~ey has the following sid\n    , Match( ~ey, <____(LABEL_4)____,$A,$B,X,____(LABEL_3)____> )\n    , NotNeutral(X)    \n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  ]\n\nrestriction notneutral:\n \"All x #i. NotNeutral(x)@i ==> not(x=DH_neutral)\"\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #i #j A ____(LEM_0)____ ____(LEM_3)____ t1 ____(LEM_1)____ k.\n        Accept(t1, A, ____(LEM_2)____, k)  @ i\n      & Match(t1,  SID) @ i\n      & Accept(____(LEM_4)____, B, A, k)   @ j\n      & Sid(t2, SID)   @ j\"\n\n\n\nlemma key_secrecy:\n  /* \n   * We do not consider ephemeral key reveals here.\n   * There is a simple attack where another session of\n   * A is used to get em(hp(A), hp(B))^s which is then sent\n   * to A as Y. Then A uses X = em(hp(A), hp(B))^(s*ex) as\n   * input for the kdf.\n   * \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #____(LEM_6)____ test ____(LEM_5)____ B k.\n    Accept(test, A, B, k) @ i1 & K( k ) @ ____(LEM_8)____\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGC\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the longterm key of test.actor was revealed\n          | (Ex #i3. LtkRev(A) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n\nend",
        "complete:": "theory Scott\nbegin\n\nbuiltins: bilinear-pairing\n\nfunctions: kdf/1, hp/1\n\nsection{* Scott: MTI-C0 like identity based key exchange protocol *}\n\n/*\n * Protocol:\tScott\n * Modeler: \tBenedikt Schmidt\n * Date: \tMay 2012\n * Source:\tBoyd overview identity based key exchange protocols\n *\n * Status: \tWorking\n */\n\n\n// Key generation center\n\nrule KGC_Setup:\n  [ Fr( ~msk ) ]\n  --[ KGCSetup() ]->\n  [ !MSK( ~msk ) ]\n\nrule KGC_request:\n  [ !MSK( ~msk ) ]\n  -->\n  [ !LTK( $ID, pmult( ~msk, hp($ID) ) ) ]\n\n\n// Reveals\n\nrule Reveal_ltk:\n  [ !LTK( $ID, skID ) ]\n  --[ LtkRev($ID) ]->\n  [ Out(skID) ]\n\nrule Reveal_master_key:\n  [ !MSK( ~msk ) ]\n  --[ MskRev() ]->\n  [ Out( ~msk ) ]\n\nrule Reveal_session_key:\n  [ !Sessk( ~ey, sek ) ]\n  --[ SesskRev( ~ey ) ]->\n  [ Out( sek ) ]\n\n\n// Protocol\n\nrule Init_1:\n  let skA = pmult( ~s, hp($A) )\n      X   = em( skA, hp($B) )^~ex\n  in \n  [ Fr( ~ex )\n  , !LTK( $A, skA )\n  ]\n  -->\n  [ Init( ~ex, $A, $B, X )\n  , Out( X )\n  ]\n\nrule Init_2:\n  let sessKey = kdf( Y^~ex, $A, $B, X, Y )\n  in\n  [ Init( ~ex, $A, $B, X )\n  , In( Y )\n  ]\n  --[ Accept( ~ex, $A, $B, sessKey )\n    , Sid( ~ex, <'Init',$A,$B,X,Y> )\n    // a matching session for ~ex has the following sid\n    , Match( ~ex, <'Resp',$B,$A,X,Y> )\n    , NotNeutral(Y)\n    ]->\n  [ !Sessk( ~ex, sessKey ) ]\n\n\nrule Resp_1:\n  let skB     = pmult( ~s, hp($B))\n      Y       = em(hp($A), skB)^~ey\n      sessKey = kdf(X^~ey, $A, $B, X, Y)\n  in\n  [ Fr( ~ey )\n  , !LTK( $B, skB )\n  , In( X )\n  ]\n  --[ Accept( ~ey, $B, $A, sessKey )\n    , Sid( ~ey, <'Resp',$B,$A,X,Y> )\n    // a matching session for ~ey has the following sid\n    , Match( ~ey, <'Init',$A,$B,X,Y> )\n    , NotNeutral(X)    \n    ]->\n  [ Out( Y )\n  , !Sessk( ~ey, sessKey )\n  ]\n\nrestriction notneutral:\n \"All x #i. NotNeutral(x)@i ==> not(x=DH_neutral)\"\n\nlemma key_agreement_reachable:\n  exists-trace\n  \"Ex #i #j A B SID t1 t2 k.\n        Accept(t1, A, B, k)  @ i\n      & Match(t1,  SID) @ i\n      & Accept(t2, B, A, k)   @ j\n      & Sid(t2, SID)   @ j\"\n\n\n\nlemma key_secrecy:\n  /* \n   * We do not consider ephemeral key reveals here.\n   * There is a simple attack where another session of\n   * A is used to get em(hp(A), hp(B))^s which is then sent\n   * to A as Y. Then A uses X = em(hp(A), hp(B))^(s*ex) as\n   * input for the kdf.\n   * \n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 test A B k.\n    Accept(test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    // ... the test session must be \"not clean\".\n    // test is not clean if one of the following has happened:\n    //\n    // session-key-reveal of test thread.\n      (Ex #i3. SesskRev( test ) @ i3 )\n    \n    // more than one KGC\n    | (Ex #i3 #i4. KGCSetup() @ i3 & KGCSetup() @ i4 & not (#i3 = #i4))\n    \n    // there is a matching session\n    | (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)\n\t   & ( \n             // matching's session key was revealed\n\t       (Ex #i5. SesskRev( matching ) @ i5 )\n\t   )\n      )\n\n    // there is no matching session\n    | (  (not (Ex matching #i3 #i4 sid.\n    \t   // matching's 'sid' info matches with test\n           ( Sid ( matching, sid ) @ i3 & Match( test, sid ) @ i4)))\n\n        & (  \n          // the longterm key of test.peer was revealed\n            (Ex #i5. LtkRev( B ) @ i5 )\n\n          // the longterm key of test.actor was revealed\n          | (Ex #i3. LtkRev(A) @ i3 )\n          \n          // the master key was revealed\n          | (Ex #i3. MskRev() @ i3)\n          )\n      )\n\n    )\n  )\"\n\nend"
    },
    {
        "file": "SPTHY-1/sig.spthy",
        "incomplete": "theory Sig\n\nbegin\n\nbuiltins: signing\n\nrule LtkGen:// PKI\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk(____(PRE_0)____, ____(POST_0)____), !Pk($A , pk(~ltk)) , Out(pk(~ltk)) ]\n\n// protocol rules\nrule Send_Signature:\n    [ Fr(~n), !Ltk($A, ltkA) ]\n  --[ Send($A,~n) ]->\n    [ Out(<~n, sign{~n}ltkA>) ]\n\nrule Recv_Signature:\n    [ !Pk($A, pkA), In(<n, sig>) ]\n  --[ Recv($A, n), Eq(verify(____(PRE_1)____, n, pkA), ____(LABEL_0)____) ]->\n    [ ]\n\n\nrestriction equal:// needed for signature verification\n  \"All a b #i . Eq(a, b )@i ==> a = b \"\n\nlemma executable:// sanity check\n exists-trace\n  \"Ex ____(LEM_0)____ ____(LEM_1)____ #i #j. Send(A, n)@i & Recv(A, n)@j \"\n\nlemma signature_sent_by_agent:// property to be verified\n  \"All A ____(LEM_2)____ #____(LEM_3)____ . Recv (A, n)@i ==> Ex #j. Send(A, n)@j \"\n\nend",
        "complete:": "theory Sig\n\nbegin\n\nbuiltins: signing\n\nrule LtkGen:// PKI\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk($A, ~ltk), !Pk($A , pk(~ltk)) , Out(pk(~ltk)) ]\n\n// protocol rules\nrule Send_Signature:\n    [ Fr(~n), !Ltk($A, ltkA) ]\n  --[ Send($A,~n) ]->\n    [ Out(<~n, sign{~n}ltkA>) ]\n\nrule Recv_Signature:\n    [ !Pk($A, pkA), In(<n, sig>) ]\n  --[ Recv($A, n), Eq(verify(sig, n, pkA), true) ]->\n    [ ]\n\n\nrestriction equal:// needed for signature verification\n  \"All a b #i . Eq(a, b )@i ==> a = b \"\n\nlemma executable:// sanity check\n exists-trace\n  \"Ex A n #i #j. Send(A, n)@i & Recv(A, n)@j \"\n\nlemma signature_sent_by_agent:// property to be verified\n  \"All A n #i . Recv (A, n)@i ==> Ex #j. Send(A, n)@j \"\n\nend"
    },
    {
        "file": "SPTHY-1/sigma-1.spthy",
        "incomplete": "theory SIGMA\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk(____(PRE_0)____, ____(POST_0)____),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: g^x\n// S->C: g^y, S, Sig_S(g^x, g^y) MAC_k(S)\n// C->S: C, Sig_C(g^y, g^x) MAC_k(C)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientSentRequest(C, $S, ~x) ]->\n  [\n    ClientWait(C, ____(POST_1)____, ~x, ltkC),\n    Out(____(PRE_1)____)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <'g'^x, gy>\n    msgOut = <gy, 'g'^x>\n    sigOut = sign(msgOut, ltkC)\n    k = gy^x\n    macOut = mac(C, k)\n  in\n  [\n    In(<gy, sigIn, macIn>),\n    ClientWait(____(PRE_2)____, S, x, ltkC),\n    !Pk(S, pkS)\n  ]\n  --[ Neq(gy, 'g'^x),\n      Eq(mac(____(PRE_4)____, ____(LABEL_0)____), ____(PRE_3)____),\n      Eq(verify(sigIn, msgIn, pkS), ____(LABEL_1)____),\n      ClientDone(C, S, 'g'^x, gy, k) ]->\n  [\n    Out(<C, sigOut, macOut>)\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <gx, 'g'^~y>\n    sig = sign(msg, ltkS)\n    k = gx^~y\n    macVal = mac(k, S)\n  in\n  [\n    In(<gx>),\n    !Ltk(S, ltkS),\n    Fr(~y)\n  ]\n  --[ ServerResponded(S, gx, 'g'^~y) ]->\n  [\n    ServerWait(S, gx, ____(POST_2)____, k),\n    Out(<'g'^~y, sig, ____(PRE_5)____>)\n  ]\n\nrule ServerFinish:\n  let\n    msg = <'g'^y, gx>\n  in\n  [\n    In(<____(PRE_6)____, sig, macVal>),\n    !Pk(C, pkC),\n    ServerWait(S, gx, y, k)\n  ]\n  --[ Eq(mac(k, C), macVal),\n      Eq(verify(____(PRE_8)____, ____(LABEL_3)____, ____(LABEL_2)____), true),\n      ServerDone(____(PRE_7)____, C, gx, 'g'^y, k) ]->\n  []\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex ____(LEM_3)____ S gx gy ____(LEM_1)____ #i #____(LEM_0)____.\n        ____(LEM_2)____(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #____(LEM_4)____\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex ____(LEM_6)____ ____(LEM_10)____ gx gy k #i #____(LEM_11)____ #k.\n        ClientDone(____(LEM_9)____, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & ____(LEM_7)____(k) @ #k\n      & not(Ex #____(LEM_5)____. LtkReveal(C) @ #____(LEM_8)____)\n      & not(Ex #rs. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All C S gx ____(LEM_15)____ ____(LEM_17)____ #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (____(LEM_14)____ #____(LEM_12)____. (ServerResponded(S, gx, gy) @ #j) & (#j < #i))\n        | (Ex #____(LEM_13)____. ____(LEM_16)____(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a request from a client\nlemma ClientLiveness:\n  \"\n  All ____(LEM_23)____ ____(LEM_20)____ ____(LEM_24)____ gy ____(LEM_21)____ #____(LEM_18)____.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #____(LEM_22)____. ____(LEM_19)____(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S ____(LEM_31)____ gy ____(LEM_25)____ #i.\n    ServerDone(S, C, gx, gy, ____(LEM_29)____) @ #i\n    ==> ( ____(LEM_26)____(Ex C2 S2 gx2 ____(LEM_27)____ #____(LEM_28)____.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #____(LEM_32)____. ____(LEM_30)____(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend",
        "complete:": "theory SIGMA\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ~ltk),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: g^x\n// S->C: g^y, S, Sig_S(g^x, g^y) MAC_k(S)\n// C->S: C, Sig_C(g^y, g^x) MAC_k(C)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientSentRequest(C, $S, ~x) ]->\n  [\n    ClientWait(C, $S, ~x, ltkC),\n    Out('g'^~x)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <'g'^x, gy>\n    msgOut = <gy, 'g'^x>\n    sigOut = sign(msgOut, ltkC)\n    k = gy^x\n    macOut = mac(C, k)\n  in\n  [\n    In(<gy, sigIn, macIn>),\n    ClientWait(C, S, x, ltkC),\n    !Pk(S, pkS)\n  ]\n  --[ Neq(gy, 'g'^x),\n      Eq(mac(k, S), macIn),\n      Eq(verify(sigIn, msgIn, pkS), true),\n      ClientDone(C, S, 'g'^x, gy, k) ]->\n  [\n    Out(<C, sigOut, macOut>)\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <gx, 'g'^~y>\n    sig = sign(msg, ltkS)\n    k = gx^~y\n    macVal = mac(k, S)\n  in\n  [\n    In(<gx>),\n    !Ltk(S, ltkS),\n    Fr(~y)\n  ]\n  --[ ServerResponded(S, gx, 'g'^~y) ]->\n  [\n    ServerWait(S, gx, ~y, k),\n    Out(<'g'^~y, sig, macVal>)\n  ]\n\nrule ServerFinish:\n  let\n    msg = <'g'^y, gx>\n  in\n  [\n    In(<C, sig, macVal>),\n    !Pk(C, pkC),\n    ServerWait(S, gx, y, k)\n  ]\n  --[ Eq(mac(k, C), macVal),\n      Eq(verify(sig, msg, pkC), true),\n      ServerDone(S, C, gx, 'g'^y, k) ]->\n  []\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #i #j.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex C S gx gy k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k\n      & not(Ex #rc. LtkReveal(C) @ #rc)\n      & not(Ex #rs. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All C S gx gy k #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ServerResponded(S, gx, gy) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a request from a client\nlemma ClientLiveness:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( not(Ex C2 S2 gx2 gy2 #i2.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/signed_dh.spthy",
        "incomplete": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(____(PRE_0)____)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A(____(POST_0)____, ____(PRE_2)____, sk(____(PRE_1)____), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(____(PRE_3)____), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<____(PRE_4)____, ____(POST_2)____, B, (g() ^ ~x)>}sk(____(PRE_5)____)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(____(POST_1)____))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(____(PRE_6)____)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, ____(POST_3)____, sk(k_A), pk(k_A), pk(____(PRE_7)____), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(____(PRE_8)____, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(____(PRE_9)____), pk(k_A), pk(k_B), beta, ____(POST_4)____)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(____(PRE_9)____), pk(k_A), pk(k_B), beta, ____(POST_4)____),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', ____(PRE_11)____, A, (g() ^ ~y)>}sk(____(POST_5)____)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), ____(PRE_12)____, alpha)\n        ]\n\nlemma key_secret:\n    \" ____(LEM_1)____(\n        Ex msg #i1 #i2 #j .\n            ____(LEM_0)____(msg) @ #i1 &\n            ____(LEM_2)____(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex ____(LEM_4)____ #____(LEM_3)____ #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex ____(LEM_6)____ #____(LEM_5)____ #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "complete:": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend"
    },
    {
        "file": "SPTHY-1/StatVerif_GM_Contract_Signing.spthy",
        "incomplete": "theory StatVerif_GM_Contract_Signing begin\n\n/*\n   Protocol:    Contract Signing Protocol (Example 2 from [1])\n   Modeler:     Simon Meier <iridcode@gmail.com>\n   Date:        September 2012\n\n   Status:      working\n\n   This is the contract signing example presented in Section V.B of the\n   following paper.\n\n   [1] M. Arapinis, E. Ritter and M. Ryan. StatVerif: Verification of Stateful\n   Processes. In CSF'11. IEEE Computer Society Press, pages 33-47 , 2011.\n\n   It models the two-party version of the contract signing protocol proposed\n   in\n\n   [2] Juan A. Garay, Markus Jakobsson, and Philip D. MacKenzie. Abuse-free\n   optimistic contract signing. In Michael J. Wiener, editor, CRYPTO, volume\n   1666 of Lecture Notes in Computer Science, pages 449\u2013466. Springer, 1999.\n\n   Note that in contrast to [1], we do not require any protocol-specific\n   abstraction, as we support reasoning about state under replication.\n\n*/\n\nfunctions:\n  pk/1, sign/2, pcs/3, check_getmsg/2, checkpcs/5, true/0, convertpcs/2\n\nequations:\n  // Checking and getting the message in a standard signature\n    check_getmsg(pk(xsk), sign(xsk, xm)) = xm\n\n  , checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xsk, xc), ypk, zpk)) = true()\n\n  , convertpcs(zsk, pcs(sign(xsk, xc), ypk, pk(zsk))) = sign(xsk, xc)\n  /*\n    The above two equations are inspired by the following design decisions.\n    We model a private signature of a contract 'xc' that is\n      - meant for 'y' identified by his public key 'ypk'\n      - privately signed by 'x' using his private key 'xsk'\n      - to be converted by the trusted party 'z' identified by its public key\n        'zpk'\n     using the term 'pcs(sign(xsk, xc), ypk, zpk)'.\n\n     This term chan be checked against 'xc', 'pk(xsk)', ypk, and zpk using\n     the 'checkpcs' algorithm.\n\n     It can be converted to a standard signature using the 'convertpcs'\n     algorithm provided one has access to the private key of the trusted\n     party.\n\n     Note that we embedd the proper standard signature immediately into the\n     'pcs' term, as the resulting equational theory is not subterm-convergent\n     otherwise.\n  */\n\n// Setting up the trusted third party, i.e., choose its signing key\nrule Setup_TTP:\n  [ Fr(seed) ] --> [ !TTP(seed), Out(pk(seed)) ]\n\n// Our goal is to check that the TTP cannot be abused to provide the adversary\n// with both a certificate that the contract was resolved and a certificate\n// that the contract was aborted.\n\n// The TTP answering an 'abort' request.\nrule Abort1:\n  let msg      = <ct, pk1, pk2, pcsig1>\n      abortSig = sign(skT, pcsig1)\n  in\n    [ !TTP(skT)\n    , In(<'abort', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures. This is essential. Try uncommenting it and check\n      // the resulting attacks.\n    , Eq(checkpcs(ct, pk1, ____(LABEL_0)____, pk(skT), ____(PRE_0)____), true)\n      // Log this action for referencing it in properties\n    , Abort1(ct)\n    ]->\n    [ Out(abortSig) ]\n\n// We refrain from modelling the repeated answering with the same answer.\n// It would be easy to model, but does obviously not strengthen the adversary.\n\n// The TTP answering a resolve request by party 2.\nrule Resolve2:\n  let msg        = <ct, pk1, pk2, pcsig1, sig2>\n      sig1       = convertpcs(skT, pcsig1)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve2', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(____(LABEL_2)____)\n      // Check signatures\n    , Eq(check_getmsg(____(PRE_1)____, sig2), ct)\n    , Eq(checkpcs(ct, pk1, pk2, pk(skT), ____(LABEL_1)____), ____(PRE_2)____)\n      // Log this action for referencing it in properties\n    , Resolve2(ct)\n    ]->\n    [ Out(resolveSig) ]\n\n// The TTP answering a resolve request by party 1.\nrule Resolve1:\n  let msg        = <ct, pk1, pk2, sig1, pcsig2>\n      sig2       = convertpcs(skT, pcsig2)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve1', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(____(PRE_3)____)\n      // Check signatures\n    , Eq(check_getmsg(pk1, sig1), ct)\n    , Eq(checkpcs(ct, ____(LABEL_3)____, pk1, pk(____(PRE_4)____), pcsig2), ____(LABEL_4)____)\n      // Log this action for referencing it in properties\n    , Resolve1(ct)\n    ]->\n    [ Out(resolveSig) ]\n\n\n// Witnessing aborted contracts.\nrule Witness_Aborted:\n  let abortC = sign(skT, pcs(sign(sk1, ct), pk(ysk), pk(skT)))\n  in\n    [ In(abortC), !TTP(skT) ] --[ AbortCert(ct) ]-> []\n\n// Witnessing resolved contracts.\nrule Witness_Resolved:\n  let resolveC = sign(skT, <sign(sk1, ct), sign(sk2, ct)>)\n  in\n    [ In(resolveC), !TTP(skT) ] --[ ResolveCert(ct) ]-> []\n\n\n// Axiom: the TTP does not answer any request twice\nrestriction Answered_unique:\n    \"All x #i #j. Answered(x) @ i & Answered(x) @ j ==> #i = #j\"\n\n// Axiom: the TTP stops if an equality check fails\nrestriction Eq_checks_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/*\nOur desired goal: there is not contract where the adversary can present\nboth an abort-certificate and a resolve-certificate. This is what is\nverified in [1]. It is almost trivial, as it only relies on the uniqueness\ncheck and properly checking the signatures.\n\nTODO: Investigate more interesting properties. Especially properties from the\nperspective of the local agents.\n*/\nlemma aborted_and_resolved_exclusive:\n  \"____(LEM_0)____ (Ex ct #i #____(LEM_1)____. AbortCert(ct) @ i & ResolveCert(ct) @ j)\"\n\n// Sanity checks: The terms reductions behave as expected.\nlemma aborted_contract_reachable:\n  exists-trace\n  \" (Ex ct #____(LEM_3)____. AbortCert(ct) @ ____(LEM_6)____ )\n    // Ensure that this is possible with at most one Abort step.\n  & (____(LEM_7)____ ____(LEM_5)____ ct2 #i1 #i2 .\n       Abort1(ct1) @ i1 & Abort1(ct2) @ i2 ==> #i1 = #i2)\n  & (____(LEM_9)____ ct #i. ____(LEM_2)____(ct) @ i ==> F)\n  & (All ct #i. Resolve2(ct) @ i ==> F)\n  \"\n\nlemma resolved1_contract_reachable:\n  exists-trace\n  \" (Ex ____(LEM_12)____ #i. ResolveCert(____(LEM_13)____) @ i)\n    // Ensure that this is possible with at most one Resolve1 step.\n  & (All ct #i. Abort1(ct) @ i ==> F)\n  & (All ct1 ct2 #i1 #i2 .\n       ____(LEM_15)____(ct1) @ i1 & ____(LEM_16)____(ct2) @ i2 ==> #i1 = #i2)\n  & (All ct #i. Resolve2(ct) @ i ==> F)\n  \"\n\nlemma resolved2_contract_reachable:\n  exists-trace\n  \"(____(LEM_20)____ ____(LEM_21)____ #i. ResolveCert(ct) @ i)\n    // Ensure that this is possible with at most one Resolve1 step.\n  & (____(LEM_24)____ ct #i. Abort1(ct) @ i ==> F)\n  & (All ct #i. Resolve1(ct) @ i ==> F)\n  & (All ____(LEM_25)____ ct2 #____(LEM_22)____ #i2 .\n       Resolve2(ct1) @ i1 & Resolve2(ct2) @ i2 ==> #i1 = #i2)\n  \"\n\n\n/*\nOriginal code from [1]. There is a strange discrepance between the description\nof the protocol in [1, Figure 5] and the implementation here. The Abort1\nprocess does not check for a private contract signature, but for a standard\nsignature. However, the query listed on [1, page 12] considers a TTP-signed\npcs as the abort-certificate.\n*/\n\n/*\n\nfree c.\nfree init.\nfree ok.\nfree abort.\nfree resolve1.\nfree resolve2.\nfree aborted.\nfree resolved.\nfree wtn_contract.\nfree skA.\nfree skB.\n\nfun pair/2.\nfun pk/1.\nfun sign/2.\nfun pcs/4.\n\nreduc projl(pair(xl, xr)) = xl.\nreduc projr(pair(xl, xr)) = xr.\n\nreduc check_getmsg(pk(xsk), sign(xsk, xm)) = xm.\n\nreduc checkpcs(xc, pk(xsk), ypk, zpk, pcs(xsk, ypk, zpk, xc)) = ok.\nreduc convertpcs(zsk, pcs(xsk, ypk, pk(zsk), xc)) = sign(xsk, xc).\n\nlet T =\n  new skT; (out(c, pk(skT)) | ! C)\n\nlet C =\n  new s; new ct;\n  [s -> pair(init, init)] |\n    out(c, ct); in(c, xpk1); in(c, xpk2);\n    ( ! Abort1 | ! Resolve2 | ! Resolve1 )\n\nlet Abort1 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = abort then\n    let y = projr(x) in\n    let yl = projl(y) in\n    let ycontract = projl(yl) in\n    let yparties = projr(yl) in\n    if yparties = pair(xpk1, xpk2) then\n      if ycontract = ct then\n        let ysig = projr(y) in\n        let ym = check_getmsg(xpk1, ysig) in\n        if ym = yl then\n          read s as ys;\n          let ystatus = projl(ys) in\n          (if ystatus = aborted then\n            let ysigs = projr(ys) in\n            out(c, ysigs); unlock) |\n          (if ystatus = init then\n            s := pair(aborted, sign(skT, y));\n            out(c, sign(skT, y)); unlock)\n\nlet Resolve2 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = resolve2 then\n    let y = projr(x) in\n    let ypcs1 = projl(y) in\n    let ysig2 = projr(y) in\n    let ycontract = check_getmsg(xpk2, ysig2) in\n    if ycontract = ct then\n      let ycheck = checkpcs(ct, xpk1, xpk2, pk(skT), ypcs1) in\n      if ycheck = ok then\n        read s as ys;\n        let ystatus = projl(ys) in\n        (if ystatus = resolved2 then\n          let ysigs = projr(ys) in\n          out(c, ysigs); unlock) |\n        (if ystatus = init then\n          let ysig1 = convertpcs(skT, ypcs1) in\n          s := pair(resolved2, sign(skT, pair(ysig1, ysig2)));\n          out(c, sign(skT, pair(ysig1, ysig2))); unlock)\n\nlet Resolve1 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = resolve1 then\n    let y = projr(x) in\n    let ysig1 = projl(y) in\n    let ypcs2 = projr(y) in\n    let ycontract = check_getmsg(xpk1, ysig1) in\n    if ycontract = ct then\n      let ycheck = checkpcs(ct, xpk2, xpk1, pk(skT), ypcs2) in\n      if ycheck = ok then\n        read s as ys;\n        let ystatus = projl(ys) in\n        (if ystatus = resolved1 then\n          let ysigs = projr(ys) in\n          out(c, ysigs); unlock) |\n        (if ystatus = init then\n          let ysig2 = convertpcs(skT, ypcs2) in\n          s := pair(resolved1, sign(skT, pair(ysig1, ysig2)));\n          out(c, sign(skT, pair(ysig1,ysig2))); unlock)\n\n*/\n\nend",
        "complete:": "theory StatVerif_GM_Contract_Signing begin\n\n/*\n   Protocol:    Contract Signing Protocol (Example 2 from [1])\n   Modeler:     Simon Meier <iridcode@gmail.com>\n   Date:        September 2012\n\n   Status:      working\n\n   This is the contract signing example presented in Section V.B of the\n   following paper.\n\n   [1] M. Arapinis, E. Ritter and M. Ryan. StatVerif: Verification of Stateful\n   Processes. In CSF'11. IEEE Computer Society Press, pages 33-47 , 2011.\n\n   It models the two-party version of the contract signing protocol proposed\n   in\n\n   [2] Juan A. Garay, Markus Jakobsson, and Philip D. MacKenzie. Abuse-free\n   optimistic contract signing. In Michael J. Wiener, editor, CRYPTO, volume\n   1666 of Lecture Notes in Computer Science, pages 449\u2013466. Springer, 1999.\n\n   Note that in contrast to [1], we do not require any protocol-specific\n   abstraction, as we support reasoning about state under replication.\n\n*/\n\nfunctions:\n  pk/1, sign/2, pcs/3, check_getmsg/2, checkpcs/5, true/0, convertpcs/2\n\nequations:\n  // Checking and getting the message in a standard signature\n    check_getmsg(pk(xsk), sign(xsk, xm)) = xm\n\n  , checkpcs(xc, pk(xsk), ypk, zpk, pcs(sign(xsk, xc), ypk, zpk)) = true()\n\n  , convertpcs(zsk, pcs(sign(xsk, xc), ypk, pk(zsk))) = sign(xsk, xc)\n  /*\n    The above two equations are inspired by the following design decisions.\n    We model a private signature of a contract 'xc' that is\n      - meant for 'y' identified by his public key 'ypk'\n      - privately signed by 'x' using his private key 'xsk'\n      - to be converted by the trusted party 'z' identified by its public key\n        'zpk'\n     using the term 'pcs(sign(xsk, xc), ypk, zpk)'.\n\n     This term chan be checked against 'xc', 'pk(xsk)', ypk, and zpk using\n     the 'checkpcs' algorithm.\n\n     It can be converted to a standard signature using the 'convertpcs'\n     algorithm provided one has access to the private key of the trusted\n     party.\n\n     Note that we embedd the proper standard signature immediately into the\n     'pcs' term, as the resulting equational theory is not subterm-convergent\n     otherwise.\n  */\n\n// Setting up the trusted third party, i.e., choose its signing key\nrule Setup_TTP:\n  [ Fr(seed) ] --> [ !TTP(seed), Out(pk(seed)) ]\n\n// Our goal is to check that the TTP cannot be abused to provide the adversary\n// with both a certificate that the contract was resolved and a certificate\n// that the contract was aborted.\n\n// The TTP answering an 'abort' request.\nrule Abort1:\n  let msg      = <ct, pk1, pk2, pcsig1>\n      abortSig = sign(skT, pcsig1)\n  in\n    [ !TTP(skT)\n    , In(<'abort', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures. This is essential. Try uncommenting it and check\n      // the resulting attacks.\n    , Eq(checkpcs(ct, pk1, pk2, pk(skT), pcsig1), true)\n      // Log this action for referencing it in properties\n    , Abort1(ct)\n    ]->\n    [ Out(abortSig) ]\n\n// We refrain from modelling the repeated answering with the same answer.\n// It would be easy to model, but does obviously not strengthen the adversary.\n\n// The TTP answering a resolve request by party 2.\nrule Resolve2:\n  let msg        = <ct, pk1, pk2, pcsig1, sig2>\n      sig1       = convertpcs(skT, pcsig1)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve2', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures\n    , Eq(check_getmsg(pk2, sig2), ct)\n    , Eq(checkpcs(ct, pk1, pk2, pk(skT), pcsig1), true)\n      // Log this action for referencing it in properties\n    , Resolve2(ct)\n    ]->\n    [ Out(resolveSig) ]\n\n// The TTP answering a resolve request by party 1.\nrule Resolve1:\n  let msg        = <ct, pk1, pk2, sig1, pcsig2>\n      sig2       = convertpcs(skT, pcsig2)\n      resolveSig = sign(skT, <sig1, sig2>)\n  in\n    [ !TTP(skT)\n    , In(<'resolve1', msg>)\n    ]\n  --[ // The TTP answers at most once per contract.\n      Answered(ct)\n      // Check signatures\n    , Eq(check_getmsg(pk1, sig1), ct)\n    , Eq(checkpcs(ct, pk2, pk1, pk(skT), pcsig2), true)\n      // Log this action for referencing it in properties\n    , Resolve1(ct)\n    ]->\n    [ Out(resolveSig) ]\n\n\n// Witnessing aborted contracts.\nrule Witness_Aborted:\n  let abortC = sign(skT, pcs(sign(sk1, ct), pk(ysk), pk(skT)))\n  in\n    [ In(abortC), !TTP(skT) ] --[ AbortCert(ct) ]-> []\n\n// Witnessing resolved contracts.\nrule Witness_Resolved:\n  let resolveC = sign(skT, <sign(sk1, ct), sign(sk2, ct)>)\n  in\n    [ In(resolveC), !TTP(skT) ] --[ ResolveCert(ct) ]-> []\n\n\n// Axiom: the TTP does not answer any request twice\nrestriction Answered_unique:\n    \"All x #i #j. Answered(x) @ i & Answered(x) @ j ==> #i = #j\"\n\n// Axiom: the TTP stops if an equality check fails\nrestriction Eq_checks_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/*\nOur desired goal: there is not contract where the adversary can present\nboth an abort-certificate and a resolve-certificate. This is what is\nverified in [1]. It is almost trivial, as it only relies on the uniqueness\ncheck and properly checking the signatures.\n\nTODO: Investigate more interesting properties. Especially properties from the\nperspective of the local agents.\n*/\nlemma aborted_and_resolved_exclusive:\n  \"not (Ex ct #i #j. AbortCert(ct) @ i & ResolveCert(ct) @ j)\"\n\n// Sanity checks: The terms reductions behave as expected.\nlemma aborted_contract_reachable:\n  exists-trace\n  \" (Ex ct #i. AbortCert(ct) @ i )\n    // Ensure that this is possible with at most one Abort step.\n  & (All ct1 ct2 #i1 #i2 .\n       Abort1(ct1) @ i1 & Abort1(ct2) @ i2 ==> #i1 = #i2)\n  & (All ct #i. Resolve1(ct) @ i ==> F)\n  & (All ct #i. Resolve2(ct) @ i ==> F)\n  \"\n\nlemma resolved1_contract_reachable:\n  exists-trace\n  \" (Ex ct #i. ResolveCert(ct) @ i)\n    // Ensure that this is possible with at most one Resolve1 step.\n  & (All ct #i. Abort1(ct) @ i ==> F)\n  & (All ct1 ct2 #i1 #i2 .\n       Resolve1(ct1) @ i1 & Resolve1(ct2) @ i2 ==> #i1 = #i2)\n  & (All ct #i. Resolve2(ct) @ i ==> F)\n  \"\n\nlemma resolved2_contract_reachable:\n  exists-trace\n  \"(Ex ct #i. ResolveCert(ct) @ i)\n    // Ensure that this is possible with at most one Resolve1 step.\n  & (All ct #i. Abort1(ct) @ i ==> F)\n  & (All ct #i. Resolve1(ct) @ i ==> F)\n  & (All ct1 ct2 #i1 #i2 .\n       Resolve2(ct1) @ i1 & Resolve2(ct2) @ i2 ==> #i1 = #i2)\n  \"\n\n\n/*\nOriginal code from [1]. There is a strange discrepance between the description\nof the protocol in [1, Figure 5] and the implementation here. The Abort1\nprocess does not check for a private contract signature, but for a standard\nsignature. However, the query listed on [1, page 12] considers a TTP-signed\npcs as the abort-certificate.\n*/\n\n/*\n\nfree c.\nfree init.\nfree ok.\nfree abort.\nfree resolve1.\nfree resolve2.\nfree aborted.\nfree resolved.\nfree wtn_contract.\nfree skA.\nfree skB.\n\nfun pair/2.\nfun pk/1.\nfun sign/2.\nfun pcs/4.\n\nreduc projl(pair(xl, xr)) = xl.\nreduc projr(pair(xl, xr)) = xr.\n\nreduc check_getmsg(pk(xsk), sign(xsk, xm)) = xm.\n\nreduc checkpcs(xc, pk(xsk), ypk, zpk, pcs(xsk, ypk, zpk, xc)) = ok.\nreduc convertpcs(zsk, pcs(xsk, ypk, pk(zsk), xc)) = sign(xsk, xc).\n\nlet T =\n  new skT; (out(c, pk(skT)) | ! C)\n\nlet C =\n  new s; new ct;\n  [s -> pair(init, init)] |\n    out(c, ct); in(c, xpk1); in(c, xpk2);\n    ( ! Abort1 | ! Resolve2 | ! Resolve1 )\n\nlet Abort1 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = abort then\n    let y = projr(x) in\n    let yl = projl(y) in\n    let ycontract = projl(yl) in\n    let yparties = projr(yl) in\n    if yparties = pair(xpk1, xpk2) then\n      if ycontract = ct then\n        let ysig = projr(y) in\n        let ym = check_getmsg(xpk1, ysig) in\n        if ym = yl then\n          read s as ys;\n          let ystatus = projl(ys) in\n          (if ystatus = aborted then\n            let ysigs = projr(ys) in\n            out(c, ysigs); unlock) |\n          (if ystatus = init then\n            s := pair(aborted, sign(skT, y));\n            out(c, sign(skT, y)); unlock)\n\nlet Resolve2 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = resolve2 then\n    let y = projr(x) in\n    let ypcs1 = projl(y) in\n    let ysig2 = projr(y) in\n    let ycontract = check_getmsg(xpk2, ysig2) in\n    if ycontract = ct then\n      let ycheck = checkpcs(ct, xpk1, xpk2, pk(skT), ypcs1) in\n      if ycheck = ok then\n        read s as ys;\n        let ystatus = projl(ys) in\n        (if ystatus = resolved2 then\n          let ysigs = projr(ys) in\n          out(c, ysigs); unlock) |\n        (if ystatus = init then\n          let ysig1 = convertpcs(skT, ypcs1) in\n          s := pair(resolved2, sign(skT, pair(ysig1, ysig2)));\n          out(c, sign(skT, pair(ysig1, ysig2))); unlock)\n\nlet Resolve1 =\n  lock;\n  in(c, x);\n  let xcmd = projl(x) in\n  if xcmd = resolve1 then\n    let y = projr(x) in\n    let ysig1 = projl(y) in\n    let ypcs2 = projr(y) in\n    let ycontract = check_getmsg(xpk1, ysig1) in\n    if ycontract = ct then\n      let ycheck = checkpcs(ct, xpk2, xpk1, pk(skT), ypcs2) in\n      if ycheck = ok then\n        read s as ys;\n        let ystatus = projl(ys) in\n        (if ystatus = resolved1 then\n          let ysigs = projr(ys) in\n          out(c, ysigs); unlock) |\n        (if ystatus = init then\n          let ysig2 = convertpcs(skT, ypcs2) in\n          s := pair(resolved1, sign(skT, pair(ysig1, ysig2)));\n          out(c, sign(skT, pair(ysig1,ysig2))); unlock)\n\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/STR_signed.spthy",
        "incomplete": "theory STR_signed // based on: ml_authentic_channel_2args_intruder_can_corrupt_rulenamechange\nbegin\n\nbuiltins: diffie-hellman, multiset\n\nfunctions: blindedRandomOf/1, blindedKeyFor/1\nfunctions: te/1, te_inv/1  // convert group element to exponent\nequations: te_inv(te(x)) = x // te is not hiding\n\n/* We use the private function symbol sk to model the longterm secret\n   key of an agent. For example, sk('A') is 'A's longterm secret key.\n   We also allow recipients to check who the sender was in the form of\n   matching for \"m, sign(sk(A),m)\" for expected sender A. */\nfunctions: sk/1 [private]\nfunctions: sign/2\n\n\n/* Determine group participants */\nrule StartGroup_1: //Init:\n  [ Fr(~gid) ] -->\n  [ StartGroup( $I             // the initiator\n              , 1              // number of responders\n              , <1,$R> + 'nil' // the list of responders (*)\n              , ____(PRE_0)____)          // the group id, not secret\n  , Out(~gid)\n  ]\n\n// (*) we encode lists [x1,..,xk] as multisets <i,x_1> + <i+1,x_2> + .. + <i+k,x_k> + 'nil'\n// we also use pairs ([x_1, .., x_j], [x_{j+1},..,x_k])  to traverse a list\n\nrule StartGroup_2: //Extend:\n  let nextnum = num + 1\n  in\n  [ StartGroup( $I, num,     resps                , ~gid) ]\n  -->\n  [ StartGroup( $I, ____(PRE_1)____, resps + <____(POST_0)____, $R>, ~gid) ]\n\n\n\n/* Start one Initiator and Responders */\n\nrule StartGroup_0: //:\n  [ StartGroup( $I, num, resps, ~gid) ]\n  -->\n  [ Initiator($I, resps, ~gid)\n  , StartGroupResponders( ____(PRE_2)____\n                        , $I     // the initiator\n                        , 'nil'  // list of started responders\n                        , ____(POST_1)____\n                        , ~gid) ]\n\nrule StartGroup_3: //Responders:\n  let newstarted = started + <j,$R>\n  in\n  [ StartGroupResponders(____(PRE_3)____,     $I, started,    <j,$R> + notStarted, ~gid) ]\n  -->\n  [ StartGroupResponders(____(POST_2)____, $I, newstarted, notStarted,          ____(POST_3)____)\n  , Responder( ____(PRE_4)____\n             , $I\n             , j          // the index in the list / position in the three\n             , ____(PRE_5)____\n             , notStarted // above   \n             , ~gid) ]\n\n\n\n/* Responders */\n\n\nrule Responder_0: //:\n  let mOut = < blindedRandomOf(j,~gid), 'g'^~r >\n  in \n  [ Responder($R1, $I, ____(PRE_6)____, below, above, ~gid)\n  , Fr(~r) ]\n  -->\n  [ Out(< sign(sk(____(POST_4)____), mOut), mOut > )\n  , ResponderBRSent($R1, $I, ____(PRE_8)____, below + <j,$R1>, above, ~gid, ____(PRE_7)____) ]\n\nrule Responder_1: //BKRecv:\n  let mIn = < blindedKeyFor(j,~gid), bk >\n  in\n  [ ResponderBRSent(____(PRE_9)____, $I, j, ____(PRE_10)____, above, ~gid, ~r)\n  , In(< sign(sk($I), mIn), mIn > )\n  ]\n  -->\n  [ ResponderLoop( ____(PRE_11)____\n                 , ____(POST_5)____\n                 , j      // index of $R1 in list\n                 , j + 1  // index of first element of above\n                 , below\n                 , above\n                 , ~gid\n                 , bk ^ ~r) ]\n  \n\nrule Responder_2: //Loop:\n    let mIn  = < blindedRandomOf(k, ~gid), br >\n    in\n    [ ResponderLoop( $R1, $I, j, ____(PRE_13)____, below, <k, $R2> + above, ~gid, key )\n    , In(< sign(sk($R2), ____(PRE_12)____), mIn >  ) \n    ]\n    --[ IKey( $R1, below + <____(PRE_14)____,____(LABEL_0)____>, ~gid, key ) ]->\n    [ ResponderLoop($R1, $I, j, k + 1, <k, $R2> + below, ____(POST_6)____, ____(PRE_15)____, br ^ te(key)) ]\n\nrule Responder_3: //Done:\n  [ ResponderLoop($R1, $I, j, ____(PRE_16)____, below, 'nil', ~gid, key) ]\n  --[  Key($R1, below + <____(PRE_18)____,$I>, ____(LABEL_1)____, ____(PRE_17)____ )\n    , IKey($R1, below + <'zero',$I>, ____(LABEL_2)____, key ) ]-> []\n\n/* Initiator */\n\nrule Initiator_0: //:\n  let key  = br^~r  // here, ~r is an exponent and can be directly used\n      mIn  = < blindedRandomOf(1, ~gid), br>\n      mOut = < blindedKeyFor(1, ~gid), 'g'^~r> \n  in\n  [ Initiator($I, resps + <1,____(PRE_19)____>, ~gid)\n  , Fr(~r)\n  , In(< sign(sk($R1), mIn), mIn > ) ]\n  -->\n  [ InitiatorLoop( $I\n                 , 1 + 1            // index of first not-done\n                 , <1,____(POST_8)____> + 'nil'  // done\n                 , ____(PRE_20)____\n                 , ____(PRE_21)____\n                 , ____(POST_7)____)\n  , Out(< sign(sk($I), mOut), mOut > ) ]\n\nrule Initiator_1: //Loop:\n  let newkey = br^te(key) // here, key is a group element and has to be converted to\n      mIn  = < blindedRandomOf(j, ~gid), br>\n      mOut = < blindedKeyFor(j, ~gid), 'g'^te(key)>\n  in\n  [ InitiatorLoop($I, j, handled, <j,$R1> + notHandled, ~gid, ____(PRE_22)____)\n  , In(< sign(sk($R1), ____(PRE_23)____), mIn >  ) ]\n  --[ IKey($I, handled + <'zero',$I>, ____(LABEL_3)____, ____(PRE_24)____ ) ]->\n  [ Out(< sign(sk($I), mOut), mOut > )\n  , InitiatorLoop($I, j + 1, <j,____(POST_9)____> + handled, ____(PRE_25)____, ____(PRE_26)____, ____(POST_10)____) ]\n\nrule Initiator_2: //Done:\n  [ InitiatorLoop($I, j_, handled, 'nil', ____(PRE_27)____, key) ]\n  --[ Key($I, handled + <'zero',$I>, ~gid, key )\n    , IKey($I, handled + <'zero',$I>, ____(LABEL_3)____, ____(PRE_24)____ )\n  ]-> []\n\nrule IntruderCorrupts:\n  [] \n  --[Corrupt($A)]-> \n  [Out(sk($A))]\n\n#ifdef secure\nlemma key_secrecy_with_corruption[use_induction]:\n  all-traces\n  \"(____(LEM_3)____ #i1 I ____(LEM_4)____ gid key #____(LEM_1)____.\n          IKey( I,  group, gid, key ) @ i1 \n        & KU( key ) @ i2\n   ==> Ex A ____(LEM_0)____ others #____(LEM_2)____. \n             (____(LEM_5)____(A) @ i3\n            & i3 < i1\n            & others + <indexA, A> = group))\"\n\n#endif\n\n#ifdef executable\n\nlemma key_reachable_2:\n  exists-trace\n  \"Ex #i1 I ____(LEM_6)____ ____(LEM_12)____ ____(LEM_7)____ #i2.\n         ____(LEM_10)____(I,  <'zero', I> + <1, ____(LEM_9)____> + 'nil', gid, key ) @ i1\n       & ____(LEM_11)____(R1, <'zero', I> + <1, R1> + 'nil', gid, key ) @ i2\n       & ____(LEM_8)____ (I = R1)\n       & not (Ex A #i5. Corrupt(A) @ i5) \n\"\n\nlemma key_reachable_3:\n  exists-trace\n  \"Ex #____(LEM_24)____ I ____(LEM_13)____ ____(LEM_15)____ ____(LEM_20)____ key #i2 #i3.\n         ____(LEM_17)____( I,  <'____(LEM_19)____', I> + <1, ____(LEM_16)____> + <1+1, ____(LEM_22)____> + '____(LEM_14)____', gid, key ) @ i1\n       & Key( R1, <'zero', I> + <1, R1> + <1+1, ____(LEM_23)____> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i3\n       & ____(LEM_21)____ (I = R1)\n       & not (R1 = R2)\n       & not (I = R2)\n       & not (Ex A #i5. ____(LEM_18)____(A) @ i5) \n\"\n\nlemma key_reachable_4:\n  exists-trace\n  \"Ex #____(LEM_41)____ ____(LEM_30)____ ____(LEM_38)____ ____(LEM_35)____ ____(LEM_29)____ ____(LEM_34)____ ____(LEM_33)____ #i2 #i3 #____(LEM_39)____.\n         Key( ____(LEM_42)____,  <'zero', I> + <____(LEM_26)____, R1> + <____(LEM_31)____+____(LEM_36)____, ____(LEM_37)____> + <1+1+1, ____(LEM_32)____> + 'nil', ____(LEM_40)____, key ) @ i1\n       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, ____(LEM_43)____> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, ____(LEM_44)____> + 'nil', gid, key ) @ i3\n       & Key( R3, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i4\n       & ____(LEM_25)____ (I = R1)\n       & ____(LEM_27)____ (R1 = R2)\n       & not (I = R2)\n       & not (I = R3)\n       & not (R1 = R3)\n       & not (R2 = R3)\n       & not (Ex A #i5. ____(LEM_28)____(A) @ i5) \n\" \n\nlemma key_reachable_5:\n  exists-trace\n  \"____(LEM_54)____ #____(LEM_47)____ ____(LEM_46)____ ____(LEM_70)____ ____(LEM_49)____ ____(LEM_57)____ ____(LEM_60)____ ____(LEM_51)____ ____(LEM_68)____ #____(LEM_52)____ #____(LEM_67)____ #i4 #i5.\n         Key( ____(LEM_50)____,  <'____(LEM_58)____', ____(LEM_53)____> + <____(LEM_48)____, ____(LEM_73)____> + <____(LEM_56)____+____(LEM_62)____, ____(LEM_55)____> + <____(LEM_63)____+____(LEM_64)____+____(LEM_66)____, ____(LEM_65)____> + <____(LEM_69)____+____(LEM_71)____+____(LEM_76)____+1, R4> + 'nil', gid, key ) @ i1\n       & Key( ____(LEM_75)____, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, ____(LEM_72)____> + <1+1+1+1, R4> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i3\n       & Key( R3, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i4\n       & Key( R4, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i5\n       & ____(LEM_45)____ (I = R1)\n       & ____(LEM_59)____ (R1 = R2)\n       & ____(LEM_74)____ (I = R2)\n       & not (I = R3)\n       & not (R1 = R3)\n       & not (R2 = R3)\n       & not (I = R4)\n       & not (R1 = R4)\n       & not (R2 = R4)\n       & not (R3 = R4)\n       & not (Ex ____(LEM_61)____ #i6. Corrupt(A) @ i6) \n\" \n\n#endif\n\nend",
        "complete:": "theory STR_signed // based on: ml_authentic_channel_2args_intruder_can_corrupt_rulenamechange\nbegin\n\nbuiltins: diffie-hellman, multiset\n\nfunctions: blindedRandomOf/1, blindedKeyFor/1\nfunctions: te/1, te_inv/1  // convert group element to exponent\nequations: te_inv(te(x)) = x // te is not hiding\n\n/* We use the private function symbol sk to model the longterm secret\n   key of an agent. For example, sk('A') is 'A's longterm secret key.\n   We also allow recipients to check who the sender was in the form of\n   matching for \"m, sign(sk(A),m)\" for expected sender A. */\nfunctions: sk/1 [private]\nfunctions: sign/2\n\n\n/* Determine group participants */\nrule StartGroup_1: //Init:\n  [ Fr(~gid) ] -->\n  [ StartGroup( $I             // the initiator\n              , 1              // number of responders\n              , <1,$R> + 'nil' // the list of responders (*)\n              , ~gid)          // the group id, not secret\n  , Out(~gid)\n  ]\n\n// (*) we encode lists [x1,..,xk] as multisets <i,x_1> + <i+1,x_2> + .. + <i+k,x_k> + 'nil'\n// we also use pairs ([x_1, .., x_j], [x_{j+1},..,x_k])  to traverse a list\n\nrule StartGroup_2: //Extend:\n  let nextnum = num + 1\n  in\n  [ StartGroup( $I, num,     resps                , ~gid) ]\n  -->\n  [ StartGroup( $I, nextnum, resps + <nextnum, $R>, ~gid) ]\n\n\n\n/* Start one Initiator and Responders */\n\nrule StartGroup_0: //:\n  [ StartGroup( $I, num, resps, ~gid) ]\n  -->\n  [ Initiator($I, resps, ~gid)\n  , StartGroupResponders( 1      // number of responders that have been started\n                        , $I     // the initiator\n                        , 'nil'  // list of started responders\n                        , resps  // list of responders that have not been started yet\n                        , ~gid) ]\n\nrule StartGroup_3: //Responders:\n  let newstarted = started + <j,$R>\n  in\n  [ StartGroupResponders(j,     $I, started,    <j,$R> + notStarted, ~gid) ]\n  -->\n  [ StartGroupResponders(j + 1, $I, newstarted, notStarted,          ~gid)\n  , Responder( $R\n             , $I\n             , j          // the index in the list / position in the three\n             , started    // below\n             , notStarted // above   \n             , ~gid) ]\n\n\n\n/* Responders */\n\n\nrule Responder_0: //:\n  let mOut = < blindedRandomOf(j,~gid), 'g'^~r >\n  in \n  [ Responder($R1, $I, j, below, above, ~gid)\n  , Fr(~r) ]\n  -->\n  [ Out(< sign(sk($R1), mOut), mOut > )\n  , ResponderBRSent($R1, $I, j, below + <j,$R1>, above, ~gid, ~r) ]\n\nrule Responder_1: //BKRecv:\n  let mIn = < blindedKeyFor(j,~gid), bk >\n  in\n  [ ResponderBRSent($R1, $I, j, below, above, ~gid, ~r)\n  , In(< sign(sk($I), mIn), mIn > )\n  ]\n  -->\n  [ ResponderLoop( $R1\n                 , $I\n                 , j      // index of $R1 in list\n                 , j + 1  // index of first element of above\n                 , below\n                 , above\n                 , ~gid\n                 , bk ^ ~r) ]\n  \n\nrule Responder_2: //Loop:\n    let mIn  = < blindedRandomOf(k, ~gid), br >\n    in\n    [ ResponderLoop( $R1, $I, j, k, below, <k, $R2> + above, ~gid, key )\n    , In(< sign(sk($R2), mIn), mIn >  ) \n    ]\n    --[ IKey( $R1, below + <'zero',$I>, ~gid, key ) ]->\n    [ ResponderLoop($R1, $I, j, k + 1, <k, $R2> + below, above, ~gid, br ^ te(key)) ]\n\nrule Responder_3: //Done:\n  [ ResponderLoop($R1, $I, j, k_, below, 'nil', ~gid, key) ]\n  --[  Key($R1, below + <'zero',$I>, ~gid, key )\n    , IKey($R1, below + <'zero',$I>, ~gid, key ) ]-> []\n\n/* Initiator */\n\nrule Initiator_0: //:\n  let key  = br^~r  // here, ~r is an exponent and can be directly used\n      mIn  = < blindedRandomOf(1, ~gid), br>\n      mOut = < blindedKeyFor(1, ~gid), 'g'^~r> \n  in\n  [ Initiator($I, resps + <1,$R1>, ~gid)\n  , Fr(~r)\n  , In(< sign(sk($R1), mIn), mIn > ) ]\n  -->\n  [ InitiatorLoop( $I\n                 , 1 + 1            // index of first not-done\n                 , <1,$R1> + 'nil'  // done\n                 , resps            // not-done\n                 , ~gid\n                 , key)\n  , Out(< sign(sk($I), mOut), mOut > ) ]\n\nrule Initiator_1: //Loop:\n  let newkey = br^te(key) // here, key is a group element and has to be converted to\n      mIn  = < blindedRandomOf(j, ~gid), br>\n      mOut = < blindedKeyFor(j, ~gid), 'g'^te(key)>\n  in\n  [ InitiatorLoop($I, j, handled, <j,$R1> + notHandled, ~gid, key)\n  , In(< sign(sk($R1), mIn), mIn >  ) ]\n  --[ IKey($I, handled + <'zero',$I>, ~gid, key ) ]->\n  [ Out(< sign(sk($I), mOut), mOut > )\n  , InitiatorLoop($I, j + 1, <j,$R1> + handled, notHandled, ~gid, newkey) ]\n\nrule Initiator_2: //Done:\n  [ InitiatorLoop($I, j_, handled, 'nil', ~gid, key) ]\n  --[ Key($I, handled + <'zero',$I>, ~gid, key )\n    , IKey($I, handled + <'zero',$I>, ~gid, key )\n  ]-> []\n\nrule IntruderCorrupts:\n  [] \n  --[Corrupt($A)]-> \n  [Out(sk($A))]\n\n#ifdef secure\nlemma key_secrecy_with_corruption[use_induction]:\n  all-traces\n  \"(All #i1 I group gid key #i2.\n          IKey( I,  group, gid, key ) @ i1 \n        & KU( key ) @ i2\n   ==> Ex A indexA others #i3. \n             (Corrupt(A) @ i3\n            & i3 < i1\n            & others + <indexA, A> = group))\"\n\n#endif\n\n#ifdef executable\n\nlemma key_reachable_2:\n  exists-trace\n  \"Ex #i1 I R1 gid key #i2.\n         Key(I,  <'zero', I> + <1, R1> + 'nil', gid, key ) @ i1\n       & Key(R1, <'zero', I> + <1, R1> + 'nil', gid, key ) @ i2\n       & not (I = R1)\n       & not (Ex A #i5. Corrupt(A) @ i5) \n\"\n\nlemma key_reachable_3:\n  exists-trace\n  \"Ex #i1 I R1 R2 gid key #i2 #i3.\n         Key( I,  <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i1\n       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i3\n       & not (I = R1)\n       & not (R1 = R2)\n       & not (I = R2)\n       & not (Ex A #i5. Corrupt(A) @ i5) \n\"\n\nlemma key_reachable_4:\n  exists-trace\n  \"Ex #i1 I R1 R2 R3 gid key #i2 #i3 #i4.\n         Key( I,  <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i1\n       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i3\n       & Key( R3, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i4\n       & not (I = R1)\n       & not (R1 = R2)\n       & not (I = R2)\n       & not (I = R3)\n       & not (R1 = R3)\n       & not (R2 = R3)\n       & not (Ex A #i5. Corrupt(A) @ i5) \n\" \n\nlemma key_reachable_5:\n  exists-trace\n  \"Ex #i1 I R1 R2 R3 R4 gid key #i2 #i3 #i4 #i5.\n         Key( I,  <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i1\n       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i2\n       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i3\n       & Key( R3, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i4\n       & Key( R4, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + <1+1+1+1, R4> + 'nil', gid, key ) @ i5\n       & not (I = R1)\n       & not (R1 = R2)\n       & not (I = R2)\n       & not (I = R3)\n       & not (R1 = R3)\n       & not (R2 = R3)\n       & not (I = R4)\n       & not (R1 = R4)\n       & not (R2 = R4)\n       & not (R3 = R4)\n       & not (Ex A #i6. Corrupt(A) @ i6) \n\" \n\n#endif\n\nend"
    },
    {
        "file": "SPTHY-1/STS_MAC_fix1.spthy",
        "incomplete": "theory STS_MAC_fix1\nbegin\n\nbuiltins: diffie-hellman, signing\n\nfunctions: mac/2\nfunctions: KDF/1\n\nsection{* The Station-To-Station Protocol (MAC version, fix UKS attack with proof-of-possession of exponent) *}\n\n/*\n * Protocol:\tStation-To-Station, MAC variant: fix with CA Proof-of-Possession check\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\"\n *\t\tBlake-Wilson, Simon and Menezes, Alfred\n * \t\tPKC '99, Springer, 1999\n *\n * Status: \tworking\n */\n\n// Public keymat infrastructure\n/**\n * The !Pk facts can be regarded as certificates\n */\nrule Register_pk_normal:\n  [ Fr(~ltk) ] \n  --> \n  [ !Ltk($A, ____(PRE_0)____), !Pk($A, pk(____(POST_0)____)), Out(pk(~ltk)) ]\n\n// Can register a key, but only if we know the exponent\n// Models proof-of-possession check.\nrule Register_pk_evil:\n  [ In(ltk) ] \n  --[ Corrupt($E) ]-> \n  [ !Ltk($E, ____(PRE_1)____), !Pk($E, pk(____(POST_1)____)), Out(pk(ltk)) ]\n\n// Protocol\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n  [ Fr(~ekI), !Ltk($I, ~ltkI) ]\n  -->\n  [ Init_1( ____(POST_2)____, ____(PRE_2)____, ~ltkI, ~ekI )\n  , Out( <$I, $R, epkI> ) ]\n\nrule Init_2:\n  let epkI = 'g'^~ekI\n      sigI = sign{ epkI, Y }~ltkI\n      sigR = sign{ Y, epkI }~ltkR\n      keymat = Y^~ekI\n      key = KDF(keymat)\n  in\n    [ Init_1( ____(PRE_4)____, ____(PRE_3)____, ~ltkI, ~ekI )\n    , !Pk($R, pk(~ltkR))\n    , In( <$R, $I, Y, sigR, mac( keymat, sigR)\n      > ) ]\n  --[ AcceptedI(~ekI,$I,$R,____(PRE_5)____,Y, key) ]->\n    [ Out( <____(POST_3)____, $R, ____(PRE_6)____, mac( keymat, sigI) > ),\n      !SessionKey(~ekI,$I,$R, key)\n    ]\n\nrule Resp_1:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Ltk($R, ~ltkR)\n    , Fr(____(PRE_7)____)\n    , In( <$I, $R, X > ) ]\n  -->\n    [ Resp_1( ____(PRE_9)____, ____(POST_4)____, ~ltkR, ~ekR, ____(PRE_8)____ )\n    , Out(< $R, $I, epkR, ____(POST_5)____, mac( keymat, sigR ) >) \n    ]\n\n\nrule Resp_2:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Pk($I, pk(~ltkI))\n    , Resp_1( $I, ____(PRE_11)____, ~ltkR, ____(PRE_10)____, X )\n    , In( <$I, $R, sigI, mac( keymat, sigI ) >)\n    ]\n  --[ AcceptedR(~ekR,____(PRE_12)____,____(LABEL_0)____,X,epkR, key ) ]->\n    [ !SessionKey(~ekR,$I,$R, key) ]\n\n\n\nrule Sessionkey_Reveal:\n    [ !SessionKey(~tid, $I,$R,k) ]\n  --[ SesskRev(~tid) ]->\n    [ Out(k) ]\n\n\n\nlemma KI_Perfect_Forward_Secrecy_I:\n  \"____(LEM_8)____ (____(LEM_1)____ ttest ____(LEM_2)____ ____(LEM_3)____ ____(LEM_6)____ #____(LEM_5)____ #k hki ____(LEM_4)____.\n     AcceptedI(ttest,____(LEM_11)____,R,hki,hkr,sessKey) @ i1 &\n     ____(LEM_9)____ (Ex #r. Corrupt(I) @ r) &\n     not (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session keymat reveal of test\n     not (Ex #____(LEM_0)____. SesskRev(ttest) @ ____(LEM_10)____) &\n     // No session keymat reveal of partner\n     not (Ex #i3 #i4 ____(LEM_7)____ kpartner. SesskRev(tpartner) @ i3\n          & AcceptedR(tpartner,I,R,hki,hkr,kpartner) @ i4\n         ) \n     )\n  \"\n\nlemma KI_Perfect_Forward_Secrecy_R:\n  \"____(LEM_16)____ (Ex ttest ____(LEM_18)____ ____(LEM_15)____ ____(LEM_22)____ #i1 #____(LEM_13)____ ____(LEM_14)____ hkr.\n     AcceptedR(ttest,I,____(LEM_23)____,hki,hkr,sessKey) @ i1 &\n     ____(LEM_20)____ (Ex #r. Corrupt(I) @ r) &\n     ____(LEM_21)____ (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session keymat reveal of test\n     not (Ex #i2. SesskRev(ttest) @ i2) &\n     // No session keymat reveal of partner\n     not (Ex #i2 #i3 ____(LEM_25)____ kpartner. SesskRev(tpartner) @ i2\n          & AcceptedI(tpartner,I,R,hki,hkr,kpartner) @ i3\n         ) \n     )\n  \"\n\nend",
        "complete:": "theory STS_MAC_fix1\nbegin\n\nbuiltins: diffie-hellman, signing\n\nfunctions: mac/2\nfunctions: KDF/1\n\nsection{* The Station-To-Station Protocol (MAC version, fix UKS attack with proof-of-possession of exponent) *}\n\n/*\n * Protocol:\tStation-To-Station, MAC variant: fix with CA Proof-of-Possession check\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\"\n *\t\tBlake-Wilson, Simon and Menezes, Alfred\n * \t\tPKC '99, Springer, 1999\n *\n * Status: \tworking\n */\n\n// Public keymat infrastructure\n/**\n * The !Pk facts can be regarded as certificates\n */\nrule Register_pk_normal:\n  [ Fr(~ltk) ] \n  --> \n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]\n\n// Can register a key, but only if we know the exponent\n// Models proof-of-possession check.\nrule Register_pk_evil:\n  [ In(ltk) ] \n  --[ Corrupt($E) ]-> \n  [ !Ltk($E, ltk), !Pk($E, pk(ltk)), Out(pk(ltk)) ]\n\n// Protocol\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n  [ Fr(~ekI), !Ltk($I, ~ltkI) ]\n  -->\n  [ Init_1( $I, $R, ~ltkI, ~ekI )\n  , Out( <$I, $R, epkI> ) ]\n\nrule Init_2:\n  let epkI = 'g'^~ekI\n      sigI = sign{ epkI, Y }~ltkI\n      sigR = sign{ Y, epkI }~ltkR\n      keymat = Y^~ekI\n      key = KDF(keymat)\n  in\n    [ Init_1( $I, $R, ~ltkI, ~ekI )\n    , !Pk($R, pk(~ltkR))\n    , In( <$R, $I, Y, sigR, mac( keymat, sigR)\n      > ) ]\n  --[ AcceptedI(~ekI,$I,$R,epkI,Y, key) ]->\n    [ Out( <$I, $R, sigI, mac( keymat, sigI) > ),\n      !SessionKey(~ekI,$I,$R, key)\n    ]\n\nrule Resp_1:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Ltk($R, ~ltkR)\n    , Fr(~ekR)\n    , In( <$I, $R, X > ) ]\n  -->\n    [ Resp_1( $I, $R, ~ltkR, ~ekR, X )\n    , Out(< $R, $I, epkR, sigR, mac( keymat, sigR ) >) \n    ]\n\n\nrule Resp_2:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Pk($I, pk(~ltkI))\n    , Resp_1( $I, $R, ~ltkR, ~ekR, X )\n    , In( <$I, $R, sigI, mac( keymat, sigI ) >)\n    ]\n  --[ AcceptedR(~ekR,$I,$R,X,epkR, key ) ]->\n    [ !SessionKey(~ekR,$I,$R, key) ]\n\n\n\nrule Sessionkey_Reveal:\n    [ !SessionKey(~tid, $I,$R,k) ]\n  --[ SesskRev(~tid) ]->\n    [ Out(k) ]\n\n\n\nlemma KI_Perfect_Forward_Secrecy_I:\n  \"not (Ex ttest I R sessKey #i1 #k hki hkr.\n     AcceptedI(ttest,I,R,hki,hkr,sessKey) @ i1 &\n     not (Ex #r. Corrupt(I) @ r) &\n     not (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session keymat reveal of test\n     not (Ex #i3. SesskRev(ttest) @ i3) &\n     // No session keymat reveal of partner\n     not (Ex #i3 #i4 tpartner kpartner. SesskRev(tpartner) @ i3\n          & AcceptedR(tpartner,I,R,hki,hkr,kpartner) @ i4\n         ) \n     )\n  \"\n\nlemma KI_Perfect_Forward_Secrecy_R:\n  \"not (Ex ttest I R sessKey #i1 #k hki hkr.\n     AcceptedR(ttest,I,R,hki,hkr,sessKey) @ i1 &\n     not (Ex #r. Corrupt(I) @ r) &\n     not (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session keymat reveal of test\n     not (Ex #i2. SesskRev(ttest) @ i2) &\n     // No session keymat reveal of partner\n     not (Ex #i2 #i3 tpartner kpartner. SesskRev(tpartner) @ i2\n          & AcceptedI(tpartner,I,R,hki,hkr,kpartner) @ i3\n         ) \n     )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/TESLA_Scheme1.spthy",
        "incomplete": "theory TESLA_Scheme1 begin\n\n/*\n  Protocol:    The TESLA protocol, scheme 1\n  Modeler:     Simon Meier\n  Date:        May 2012\n\n  Status:      working\n\n  Original descrption in [1]. This model is based on the following description\n  from [2].\n\n\n    Msg 0a. R -> S: nR\n    Msg 0b. S -> R: {f (k1 ), nR }SK (S )\n    Msg 1.  S -> R: D1 , MAC (k1 , D1 ) where D1 = m1 , f (k2 )\n    Msg 2.  S -> R: D2 , MAC (k2 , D2 ) where D2 = m2 , f (k3 ), k1 .\n\n  For n > 1, the n-th message is:2\n    Msg n. S -> R : Dn , MAC (kn , Dn ) where Dn = mn , f (kn+1 ), kn-1 .\n\n\n  We verify that the use of cryptography is correct under the assumption that\n  the security condition holds. We do not verify that the timing schedule\n  works, as we do not have a notion of time. For a manual, but machine-checked\n  verification of the Scheme 2 of the TESLA protocol with time see [3].\n\n\n  [1] Perrig, Adrian, Ran Canetti, Dawn Song, and Doug Tygar. \"The TESLA\n  Broadcast Authentication Protocol.\" In RSA Cryptobytes, Summer 2002.\n\n  [2] Philippa J. Hopcroft, Gavin Lowe: Analysing a stream authentication\n  protocol using model checking. Int. J. Inf. Sec. 3(1): 2-13 (2004)\n\n  [3] David A. Basin, Srdjan Capkun, Patrick Schaller, Benedikt Schmidt:\n  Formal Reasoning about Physical Properties of Security Protocols. ACM Trans.\n  Inf. Syst. Secur. 14(2): 16 (2011)\n\n*/\n\nbuiltins: signing\n\nfunctions: MAC/2, f/1\n\n// PKI\n//////\n\nrule Generate_Keypair:\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk(____(POST_0)____, ____(PRE_0)____), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]\n\n// We assume an active adversary.\nrule Reveal_Ltk:\n    [ !Ltk(A, ltk) ]\n  --[ RevealLtk(A) ]->\n    [ Out(ltk) ]\n\n\n// Setup phase\n//////////////\n\n// A sender knows is own identity $S. He chooses a fresh key to start sending\n// a new authenticated stream. We provide facts for sending the stream and for\n// answering receiver connection requests.\nrule Sender_Setup:\n    [ Fr(~k1) ]\n  -->\n    [ Sender1($S, ~k1), !Sender0a($S, ~k1) ]\n\n// Everybody can listen in by sending a request for the commitment to the\n// first key.\nrule Sender0a:\n    [ !Sender0a(S, k1)\n    , In( < ____(PRE_1)____, S, nR> )\n    , !Ltk(S, ltkS)\n    ]\n  -->\n    [ Out( <____(PRE_2)____, R, f(____(POST_1)____), sign{ f(k1), nR}ltkS> ) ]\n\n// Receivers start by requesting the commitment to the first key and verifying\n// the signature on this commitment. We use the receiver nonce to identify\n// receivers.\nrule Receiver0a:\n    [ Fr( ~nR ) ]\n  -->\n    [ Out( < $R, ____(PRE_3)____, ~nR > )\n    , Receiver0b( ~nR, $R, $S ) ]\n\nrule Receiver0b:\n    [ Receiver0b ( ____(PRE_4)____, R, ____(PRE_5)____ )\n    , !Pk( S, pkS)\n    , In( <S, R, commit_k1, signature> )\n    , Fr(~rid)             // Fresh name used to identify this receiver thread\n    ]\n  --[ Setup(~rid) ]->\n    [ Receiver0b_check( ~rid, S, ____(PRE_6)____\n                      , verify(signature, <commit_k1, ____(POST_2)____>, pkS)) ]\n\nrule Receiver0b_check:\n    [ Receiver0b_check(nR, ____(PRE_7)____, commit_k1, true), Fr(~rid) ]\n  -->\n    [ Receiver1( nR, S, commit_k1 ) ]\n\n\n// Authenticated broadcasting\nrule Send1:\n  let data1 = <~m1, f(~k2)>\n  in\n    [ Sender1(S, ~k1)\n    , Fr(~m1)\n    , Fr(~k2)\n    ]\n  --[ Sent(S, data1)\n    ]->\n    [ Sender(S, ~k1, ~k2)\n    , Out( < ____(PRE_8)____, MAC{data1}~k1 > )\n    ]\n\nrule Recv1:\n  let data1 = <m1, commit_k2>\n  in\n    [ Receiver1(rid, S, commit_k1)\n    , In( <data1, ____(PRE_9)____> )\n    ]\n  --[ AssumeCommitNotExpired(rid, commit_k1)\n    ]->\n    [ Receiver(rid, ____(PRE_10)____, data1, mac1, commit_k1, commit_k2) ]\n\nrule SendN:\n  let data = <~m, f(~kNew), ~kOld>\n  in\n    [ Sender(____(PRE_11)____, ~kOld, ~k)\n    , Fr(~m)\n    , Fr(~kNew)\n    ]\n  --[ Sent(S, data)\n    , CommitExpired(f(~kOld))\n    ]->\n    [ Sender(S, ~k, ____(PRE_12)____)\n    , Out( <data, MAC{data}~k> )\n    ]\n\nrule RecvN:\n  let data = <m, commit_kNew, kOld>\n  in\n    [ In(< data, mac >)\n    , Receiver(rid, S, ____(PRE_13)____, MAC{dataOld}kOld, f(kOld), commit_k)\n    ]\n  --[ FromSender(rid, S, ____(LABEL_0)____)\n    , AssumeCommitNotExpired(rid, ____(PRE_14)____)\n    ]->\n    [ Receiver(rid, ____(PRE_15)____, ____(POST_3)____, mac, commit_k, commit_kNew) ]\n\n\n/*\nThe desired security property: if all expiredness assumptions of the test\nthread are given and the server that is sending was not compromised before,\nthen received data was sent by the server.\n*/\nlemma authentic [use_induction]:\n  /* For every reciever claiming that it received data 'm' from the server, */\n  \"(____(LEM_0)____ ____(LEM_11)____ S m #____(LEM_2)____. FromSender(rid, S, m) @ ____(LEM_3)____ ==>\n       /* the server actually sent that data */\n       ( (Ex #____(LEM_7)____. Sent(S, m) @ ____(LEM_12)____ & ____(LEM_13)____ < ____(LEM_8)____)\n       /* or the server's longterm key was compromised before the receiver's\n          setup was complete */\n       | (Ex #s #j. ____(LEM_5)____(rid) @ s & RevealLtk(S) @ j & j < s)\n       /* or one of the receivers expiredness assumptions before the claim\n          was not met. */\n       | (Ex ____(LEM_9)____ #ne #e. ____(LEM_4)____(rid, ____(LEM_10)____) @ ne\n                          & CommitExpired(commit) @ e\n                          & e < ne\n                          & ne < i)\n       )\n   )\n  \"\n\n// Ensure that the above lemma is not vacuous due to the filtering condition.\nlemma authentic_reachable [use_induction]:\n  exists-trace\n  \"(All ____(LEM_17)____ commit #____(LEM_16)____ #____(LEM_18)____ .\n        AssumeCommitNotExpired(rid, commit) @ i\n      & CommitExpired(commit) @ j\n        ==> i < j\n   ) &\n   (Ex rid S m #i. ____(LEM_15)____(rid, S, m) @ i) \"\n\n\nend",
        "complete:": "theory TESLA_Scheme1 begin\n\n/*\n  Protocol:    The TESLA protocol, scheme 1\n  Modeler:     Simon Meier\n  Date:        May 2012\n\n  Status:      working\n\n  Original descrption in [1]. This model is based on the following description\n  from [2].\n\n\n    Msg 0a. R -> S: nR\n    Msg 0b. S -> R: {f (k1 ), nR }SK (S )\n    Msg 1.  S -> R: D1 , MAC (k1 , D1 ) where D1 = m1 , f (k2 )\n    Msg 2.  S -> R: D2 , MAC (k2 , D2 ) where D2 = m2 , f (k3 ), k1 .\n\n  For n > 1, the n-th message is:2\n    Msg n. S -> R : Dn , MAC (kn , Dn ) where Dn = mn , f (kn+1 ), kn-1 .\n\n\n  We verify that the use of cryptography is correct under the assumption that\n  the security condition holds. We do not verify that the timing schedule\n  works, as we do not have a notion of time. For a manual, but machine-checked\n  verification of the Scheme 2 of the TESLA protocol with time see [3].\n\n\n  [1] Perrig, Adrian, Ran Canetti, Dawn Song, and Doug Tygar. \"The TESLA\n  Broadcast Authentication Protocol.\" In RSA Cryptobytes, Summer 2002.\n\n  [2] Philippa J. Hopcroft, Gavin Lowe: Analysing a stream authentication\n  protocol using model checking. Int. J. Inf. Sec. 3(1): 2-13 (2004)\n\n  [3] David A. Basin, Srdjan Capkun, Patrick Schaller, Benedikt Schmidt:\n  Formal Reasoning about Physical Properties of Security Protocols. ACM Trans.\n  Inf. Syst. Secur. 14(2): 16 (2011)\n\n*/\n\nbuiltins: signing\n\nfunctions: MAC/2, f/1\n\n// PKI\n//////\n\nrule Generate_Keypair:\n    [ Fr(~ltk) ]\n  -->\n    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]\n\n// We assume an active adversary.\nrule Reveal_Ltk:\n    [ !Ltk(A, ltk) ]\n  --[ RevealLtk(A) ]->\n    [ Out(ltk) ]\n\n\n// Setup phase\n//////////////\n\n// A sender knows is own identity $S. He chooses a fresh key to start sending\n// a new authenticated stream. We provide facts for sending the stream and for\n// answering receiver connection requests.\nrule Sender_Setup:\n    [ Fr(~k1) ]\n  -->\n    [ Sender1($S, ~k1), !Sender0a($S, ~k1) ]\n\n// Everybody can listen in by sending a request for the commitment to the\n// first key.\nrule Sender0a:\n    [ !Sender0a(S, k1)\n    , In( < R, S, nR> )\n    , !Ltk(S, ltkS)\n    ]\n  -->\n    [ Out( <S, R, f(k1), sign{ f(k1), nR}ltkS> ) ]\n\n// Receivers start by requesting the commitment to the first key and verifying\n// the signature on this commitment. We use the receiver nonce to identify\n// receivers.\nrule Receiver0a:\n    [ Fr( ~nR ) ]\n  -->\n    [ Out( < $R, $S, ~nR > )\n    , Receiver0b( ~nR, $R, $S ) ]\n\nrule Receiver0b:\n    [ Receiver0b ( nR, R, S )\n    , !Pk( S, pkS)\n    , In( <S, R, commit_k1, signature> )\n    , Fr(~rid)             // Fresh name used to identify this receiver thread\n    ]\n  --[ Setup(~rid) ]->\n    [ Receiver0b_check( ~rid, S, commit_k1\n                      , verify(signature, <commit_k1, nR>, pkS)) ]\n\nrule Receiver0b_check:\n    [ Receiver0b_check(nR, S, commit_k1, true), Fr(~rid) ]\n  -->\n    [ Receiver1( nR, S, commit_k1 ) ]\n\n\n// Authenticated broadcasting\nrule Send1:\n  let data1 = <~m1, f(~k2)>\n  in\n    [ Sender1(S, ~k1)\n    , Fr(~m1)\n    , Fr(~k2)\n    ]\n  --[ Sent(S, data1)\n    ]->\n    [ Sender(S, ~k1, ~k2)\n    , Out( < data1, MAC{data1}~k1 > )\n    ]\n\nrule Recv1:\n  let data1 = <m1, commit_k2>\n  in\n    [ Receiver1(rid, S, commit_k1)\n    , In( <data1, mac1> )\n    ]\n  --[ AssumeCommitNotExpired(rid, commit_k1)\n    ]->\n    [ Receiver(rid, S, data1, mac1, commit_k1, commit_k2) ]\n\nrule SendN:\n  let data = <~m, f(~kNew), ~kOld>\n  in\n    [ Sender(S, ~kOld, ~k)\n    , Fr(~m)\n    , Fr(~kNew)\n    ]\n  --[ Sent(S, data)\n    , CommitExpired(f(~kOld))\n    ]->\n    [ Sender(S, ~k, ~kNew)\n    , Out( <data, MAC{data}~k> )\n    ]\n\nrule RecvN:\n  let data = <m, commit_kNew, kOld>\n  in\n    [ In(< data, mac >)\n    , Receiver(rid, S, dataOld, MAC{dataOld}kOld, f(kOld), commit_k)\n    ]\n  --[ FromSender(rid, S, dataOld)\n    , AssumeCommitNotExpired(rid, commit_k)\n    ]->\n    [ Receiver(rid, S, data, mac, commit_k, commit_kNew) ]\n\n\n/*\nThe desired security property: if all expiredness assumptions of the test\nthread are given and the server that is sending was not compromised before,\nthen received data was sent by the server.\n*/\nlemma authentic [use_induction]:\n  /* For every reciever claiming that it received data 'm' from the server, */\n  \"(All rid S m #i. FromSender(rid, S, m) @ i ==>\n       /* the server actually sent that data */\n       ( (Ex #j. Sent(S, m) @ j & j < i)\n       /* or the server's longterm key was compromised before the receiver's\n          setup was complete */\n       | (Ex #s #j. Setup(rid) @ s & RevealLtk(S) @ j & j < s)\n       /* or one of the receivers expiredness assumptions before the claim\n          was not met. */\n       | (Ex commit #ne #e. AssumeCommitNotExpired(rid, commit) @ ne\n                          & CommitExpired(commit) @ e\n                          & e < ne\n                          & ne < i)\n       )\n   )\n  \"\n\n// Ensure that the above lemma is not vacuous due to the filtering condition.\nlemma authentic_reachable [use_induction]:\n  exists-trace\n  \"(All rid commit #i #j .\n        AssumeCommitNotExpired(rid, commit) @ i\n      & CommitExpired(commit) @ j\n        ==> i < j\n   ) &\n   (Ex rid S m #i. FromSender(rid, S, m) @ i) \"\n\n\nend"
    },
    {
        "file": "SPTHY-1/thirdAttestation.spthy",
        "incomplete": "theory ThirdEATImplementation\nbegin\nbuiltins: revealing-signing \n\n// In this model the verifier and the relying party are the same entity\n// this is a reasonable simplification since the verifier and relying party trust each other\n// and in some instances they are the same identity\n\n//The attester state represents the actual state that the attester is in.\n//In the model the Attester state can be in three different states:\n// * good_state\n// * bad_state - either compromised and the TPM notices or just has bad values like old software update\n// * partialCompromise - an adversary is able to trick the TPM to sign of bad attester data as if it was good attester data.\n\n\n// Attester_data is the state that the TPM reports, meaning if an attester and its TPM \n// is compromised then the attester is in a compromised state, but the TPM can report that\n// it is in a good state. The state is either 'good' or 'bad'\n\nrule create_identities:\n    [Fr(~ltk)]\n    --[CreateIdent($A, ~ltk)]->\n    [!Identity($A, ____(PRE_0)____, pk(~ltk)), Out(pk(~ltk)), AttesterState($A, ____(POST_0)____)]  \n\n\nrule Verifier_sends_Nonce_to_Attester: \n    let \n        signed_nonce = revealSign(~n, ~Vltk)\n    in\n    [!Identity($Attester, ____(PRE_1)____, pk(~Altk)), Fr(~n), !Identity($Verifier, ~Vltk, pk(~Vltk))]\n    --[VerifierSendsNonce($Attester, $Verifier, signed_nonce)]-> \n    [Out(<$Verifier, $Attester, signed_nonce>), Nonce(~n), Verifier0($Verifier, $Attester, pk(____(PRE_2)____), ~n, ~Vltk)]\n\n\n// rule attester gets compromised or has bad EAT data\nrule Attester_Gets_In_Bad_State:\n    [AttesterState($Attester, 'good_state')]\n    --[AttesterGetsBadState($Attester)]->\n    [AttesterState($Attester, 'bad_state')]\n\n// Rule for an attester to get partially compromised -> meaning that an adversary compromises the attester and is able to make the TPM sign of information as if it was in a good state.\nrule Attester_Gets_Partially_Compromised:\n    [AttesterState($Attester, 'good_state')]\n    --[AttesterGetsPartiallyCompromise($Attester)]->\n    [AttesterState($Attester, 'partially_Compromised')]\n\n\n// AttesterState($Attester, 'good') -[CompleteCompromise($Attester)]-> Out(~Altk)\n// AttesterState($Attester, 'bad') -[RegainControl($Attester)]-> AttesterState($Attester, 'good')\n\n\n//=========================================================================================================================================\n\n\nrule Attester_create_and_sends_EAT_good:\n    let\n        attester_data = 'good' // Check that you're in a good state and send good firmware\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n    in\n    [\n        !Identity(____(PRE_3)____, ~Altk, pk(~Altk)), \n        In(<$Verifier, $Attester, signed_nonce>), \n        AttesterState($Attester, 'good_state')\n    ]\n    --[AttesterSendsEatGood($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n// rule for offering a signing interface to the attacker when the attester is compromised \nrule Attester_create_and_sends_EAT_bad:\n    let\n        attester_data = 'bad' // check that you're in a bad state and send bad_firmware\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n        // there's no explicit check for the authenticity and integrity of signed_nonce\n    in\n    [ \n        !Identity($Attester, ~Altk, pk(~Altk)),\n        In(<$Verifier, $Atterster, ____(PRE_4)____>),\n        AttesterState($Attester, 'bad_state')\n    ]\n    --[AttesterSendsEatBad($Attester, $Verifier, signed_EAT, signed_nonce )]->\n    [Out(<$Attester, $Verifier, signed_EAT>)] \n\nrule Attester_create_and_sends_EAT_partial_Compromised:\n    let\n        attester_data = 'good'\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n    in\n    [\n        !Identity($Attester, ~Altk, pk(~Altk)), \n        In(<____(PRE_5)____, $Attester, signed_nonce>), \n        AttesterState($Attester, 'partially_Compromised')\n    ]\n    --[AttesterSendsEatPartialCompromise($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n//=========================================================================================================================================\n\n\n\nrule Verifier_receive_and_verify_EAT:\n    let \n        EAT = getMessage(signed_EAT) // Get message without key, only something a \"simulator actor\" can do\n        check_signature = revealVerify(signed_EAT, EAT, pk(~Altk))\n\n        unpacked_nonce = fst(EAT)\n        unpacked_state = snd(EAT)\n    in    \n    [Verifier0(____(PRE_7)____, $Attester, pk(~Altk), ~n, ~Vltk), Nonce(~n), !Identity($Attester, ~Altk, pk(~Altk)),  In(<$Attester, $Verifier, ____(PRE_6)____>)]\n    --[VerifierVerifiesEat(____(LABEL_0)____, ____(PRE_9)____, signed_EAT, ~n),\n        Eq(____(PRE_8)____, ~n),\n        Eq(check_signature, true),\n        Eq(____(LABEL_1)____, 'good')\n      ]->\n    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]\n    \n\n\nrule verification_Success:\n    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]\n    --[VerificationSuccess($Attester, $Verifier, signed_EAT, ~n)]->\n    []\n\n\nrestriction Equality:\n   \"All x y #i . Eq(x,y) @i ==> x=y \"    \n\n\nrestriction OnlyOneIdentity:\n    \"All A ltk1 ltk2 #i #j. CreateIdent(A,ltk1) @i & CreateIdent(A,ltk2) @j ==> ltk1=ltk2\"\n\n\n\n\n//==========================================================================================================================================================\n// Lemmas\n//==========================================================================================================================================================\n\n\n\n// sanity check: the protocol gets to the end (i.e. we reach the event Verification_success) \n//even if the AttesterGetsPartiallyCompromise event happens\nlemma sanity_check:\n\"\nAll ____(LEM_0)____ Verifier signed_EAT ____(LEM_4)____ #____(LEM_1)____ .\n    (\n        VerificationSuccess(____(LEM_7)____, Verifier, signed_EAT, n) @k\n    ) \n    ==> \n    (\n        (____(LEM_2)____ ____(LEM_6)____ vltk #t #____(LEM_5)____ .\n           VerifierSendsNonce(Attester, Verifier, revealSign(n, vltk)) @t &\n           AttesterSendsEatGood(Attester, Verifier1, signed_EAT, n) @i &\n            #t < #k & \n            #i < #k) |\n            (Ex #____(LEM_3)____. AttesterGetsPartiallyCompromise(Attester) @j & #j < #k) \n            \n    )\n\"\n\n//The verifier can't successfully verify an attester that is in a \"bad state\".\n//The verifier can't successfully verify an eat with a wrong nonce\nlemma cannot_Verify_A_Bad_EAT_or_Compromised_Attester:\n\"\n____(LEM_12)____ Attester ____(LEM_15)____ ____(LEM_17)____ ____(LEM_11)____ #k .\n    (\n        VerificationSuccess(Attester, Verifier, signed_EAT, n) @k\n    ) \n    ==> \n    (\n        ((____(LEM_8)____ vltk ____(LEM_14)____ #____(LEM_10)____ #i .\n            ____(LEM_13)____(Attester, Verifier, revealSign(n, vltk)) @t &\n            AttesterSendsEatGood(Attester, Verifier1, signed_EAT, n) @i &\n            #t < #k & \n            #t < #i &\n            #i < #k & \n            (not (____(LEM_9)____ #____(LEM_16)____. AttesterGetsBadState(Attester) @j & #j < #i)))\n        ) |\n        (Ex #j. AttesterGetsPartiallyCompromise(Attester) @j & #j < #k) \n    )\n\" \n\n\n\n//K never learns the attesters long term key\nlemma attester_private_key_compromised:\n \"\n All Attester Verifier signed_EAT ____(LEM_21)____ ____(LEM_22)____ #____(LEM_19)____ #k .\n    ( \n        CreateIdent(Attester, ltk) @k &\n        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i \n    )\n    ==> not(____(LEM_20)____ #____(LEM_18)____ .\n                K(ltk) @j & #j<#i &\n                #k<#i)\n \"\n\n //K never learns the verifiers long term key\nlemma verifier_private_key_compromised:\n \"\n All ____(LEM_27)____ Verifier signed_EAT Altk ____(LEM_28)____ ____(LEM_25)____ #____(LEM_26)____ #____(LEM_24)____ #i .\n    ( \n        CreateIdent(Attester, Altk) @c1 &\n        CreateIdent(Verifier, Vltk) @c2 &\n        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i \n    )\n    ==> not(____(LEM_29)____ #j .\n                ____(LEM_23)____(Vltk) @j & #j<#i & \n                ((#c1<#i)&(#c2<#i)) \n            )\n \"\n\n\nlemma nonce_freshness_across_sessions:\n \"\n All ____(LEM_32)____ ____(LEM_30)____ n #i #j .\n     (\n        VerifierSendsNonce(Attester, ____(LEM_31)____, n) @i &\n        VerifierSendsNonce(Attester, Verifier, n) @j\n     )\n     ==> #i = #j\n \"\n\n\n// add a lemma that shows that agreement doesn't hold from the attester's point of view\nlemma attester_does_not_agree_on_nonce_origin:\nexists-trace\n\"\n____(LEM_34)____ ____(LEM_35)____ ____(LEM_36)____ signed_EAT n #t .\n    (\n        AttesterSendsEatGood(Attester, Verifier, signed_EAT, n) @t\n    )\n    ==> \n        not (Ex ____(LEM_37)____ #____(LEM_33)____ .\n            VerifierSendsNonce(Attester, Verifier, revealSign(n, vltk)) @j &\n            #j < #t\n    )\n\"\n\n\n//Lemma shows that an adversary learns the values in the EAT\nlemma adversary_learns_the_EAT_information:\n \"\n ____(LEM_42)____ Attester ____(LEM_38)____ ____(LEM_39)____ n #i . \n     (\n        VerificationSuccess(Attester, Verifier, ____(LEM_47)____, n) @i\n     )\n     ==> (\n            (____(LEM_44)____ verifier1 ____(LEM_41)____ ____(LEM_45)____ #____(LEM_40)____ . AttesterSendsEatGood(Attester, verifier1, ____(LEM_46)____(____(LEM_43)____, Altk), n) @j) | \n            (Ex verifier1 EAT Altk #j . AttesterSendsEatPartialCompromise(Attester, verifier1, revealSign(EAT, Altk), n) @j)\n         ) &\n        ((Ex EAT #k . K(EAT) @k) & (Ex n #k1 . K(n) @k1))\n \"\n\n\nend",
        "complete:": "theory ThirdEATImplementation\nbegin\nbuiltins: revealing-signing \n\n// In this model the verifier and the relying party are the same entity\n// this is a reasonable simplification since the verifier and relying party trust each other\n// and in some instances they are the same identity\n\n//The attester state represents the actual state that the attester is in.\n//In the model the Attester state can be in three different states:\n// * good_state\n// * bad_state - either compromised and the TPM notices or just has bad values like old software update\n// * partialCompromise - an adversary is able to trick the TPM to sign of bad attester data as if it was good attester data.\n\n\n// Attester_data is the state that the TPM reports, meaning if an attester and its TPM \n// is compromised then the attester is in a compromised state, but the TPM can report that\n// it is in a good state. The state is either 'good' or 'bad'\n\nrule create_identities:\n    [Fr(~ltk)]\n    --[CreateIdent($A, ~ltk)]->\n    [!Identity($A, ~ltk, pk(~ltk)), Out(pk(~ltk)), AttesterState($A, 'good_state')]  \n\n\nrule Verifier_sends_Nonce_to_Attester: \n    let \n        signed_nonce = revealSign(~n, ~Vltk)\n    in\n    [!Identity($Attester, ~Altk, pk(~Altk)), Fr(~n), !Identity($Verifier, ~Vltk, pk(~Vltk))]\n    --[VerifierSendsNonce($Attester, $Verifier, signed_nonce)]-> \n    [Out(<$Verifier, $Attester, signed_nonce>), Nonce(~n), Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk)]\n\n\n// rule attester gets compromised or has bad EAT data\nrule Attester_Gets_In_Bad_State:\n    [AttesterState($Attester, 'good_state')]\n    --[AttesterGetsBadState($Attester)]->\n    [AttesterState($Attester, 'bad_state')]\n\n// Rule for an attester to get partially compromised -> meaning that an adversary compromises the attester and is able to make the TPM sign of information as if it was in a good state.\nrule Attester_Gets_Partially_Compromised:\n    [AttesterState($Attester, 'good_state')]\n    --[AttesterGetsPartiallyCompromise($Attester)]->\n    [AttesterState($Attester, 'partially_Compromised')]\n\n\n// AttesterState($Attester, 'good') -[CompleteCompromise($Attester)]-> Out(~Altk)\n// AttesterState($Attester, 'bad') -[RegainControl($Attester)]-> AttesterState($Attester, 'good')\n\n\n//=========================================================================================================================================\n\n\nrule Attester_create_and_sends_EAT_good:\n    let\n        attester_data = 'good' // Check that you're in a good state and send good firmware\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n    in\n    [\n        !Identity($Attester, ~Altk, pk(~Altk)), \n        In(<$Verifier, $Attester, signed_nonce>), \n        AttesterState($Attester, 'good_state')\n    ]\n    --[AttesterSendsEatGood($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n// rule for offering a signing interface to the attacker when the attester is compromised \nrule Attester_create_and_sends_EAT_bad:\n    let\n        attester_data = 'bad' // check that you're in a bad state and send bad_firmware\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n        // there's no explicit check for the authenticity and integrity of signed_nonce\n    in\n    [ \n        !Identity($Attester, ~Altk, pk(~Altk)),\n        In(<$Verifier, $Atterster, signed_nonce>),\n        AttesterState($Attester, 'bad_state')\n    ]\n    --[AttesterSendsEatBad($Attester, $Verifier, signed_EAT, signed_nonce )]->\n    [Out(<$Attester, $Verifier, signed_EAT>)] \n\nrule Attester_create_and_sends_EAT_partial_Compromised:\n    let\n        attester_data = 'good'\n        EAT = <signed_nonce, attester_data>\n        signed_EAT = revealSign(EAT, ~Altk)\n    in\n    [\n        !Identity($Attester, ~Altk, pk(~Altk)), \n        In(<$Verifier, $Attester, signed_nonce>), \n        AttesterState($Attester, 'partially_Compromised')\n    ]\n    --[AttesterSendsEatPartialCompromise($Attester, $Verifier, signed_EAT, signed_nonce)]->\n    [Out(<$Attester, $Verifier, signed_EAT>)]\n\n//=========================================================================================================================================\n\n\n\nrule Verifier_receive_and_verify_EAT:\n    let \n        EAT = getMessage(signed_EAT) // Get message without key, only something a \"simulator actor\" can do\n        check_signature = revealVerify(signed_EAT, EAT, pk(~Altk))\n\n        unpacked_nonce = fst(EAT)\n        unpacked_state = snd(EAT)\n    in    \n    [Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk), Nonce(~n), !Identity($Attester, ~Altk, pk(~Altk)),  In(<$Attester, $Verifier, signed_EAT>)]\n    --[VerifierVerifiesEat($Attester, $Verifier, signed_EAT, ~n),\n        Eq(unpacked_nonce, ~n),\n        Eq(check_signature, true),\n        Eq(unpacked_state, 'good')\n      ]->\n    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]\n    \n\n\nrule verification_Success:\n    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]\n    --[VerificationSuccess($Attester, $Verifier, signed_EAT, ~n)]->\n    []\n\n\nrestriction Equality:\n   \"All x y #i . Eq(x,y) @i ==> x=y \"    \n\n\nrestriction OnlyOneIdentity:\n    \"All A ltk1 ltk2 #i #j. CreateIdent(A,ltk1) @i & CreateIdent(A,ltk2) @j ==> ltk1=ltk2\"\n\n\n\n\n//==========================================================================================================================================================\n// Lemmas\n//==========================================================================================================================================================\n\n\n\n// sanity check: the protocol gets to the end (i.e. we reach the event Verification_success) \n//even if the AttesterGetsPartiallyCompromise event happens\nlemma sanity_check:\n\"\nAll Attester Verifier signed_EAT n #k .\n    (\n        VerificationSuccess(Attester, Verifier, signed_EAT, n) @k\n    ) \n    ==> \n    (\n        (Ex Verifier1 vltk #t #i .\n           VerifierSendsNonce(Attester, Verifier, revealSign(n, vltk)) @t &\n           AttesterSendsEatGood(Attester, Verifier1, signed_EAT, n) @i &\n            #t < #k & \n            #i < #k) |\n            (Ex #j. AttesterGetsPartiallyCompromise(Attester) @j & #j < #k) \n            \n    )\n\"\n\n//The verifier can't successfully verify an attester that is in a \"bad state\".\n//The verifier can't successfully verify an eat with a wrong nonce\nlemma cannot_Verify_A_Bad_EAT_or_Compromised_Attester:\n\"\nAll Attester Verifier signed_EAT n #k .\n    (\n        VerificationSuccess(Attester, Verifier, signed_EAT, n) @k\n    ) \n    ==> \n    (\n        ((Ex vltk Verifier1 #t #i .\n            VerifierSendsNonce(Attester, Verifier, revealSign(n, vltk)) @t &\n            AttesterSendsEatGood(Attester, Verifier1, signed_EAT, n) @i &\n            #t < #k & \n            #t < #i &\n            #i < #k & \n            (not (Ex #j. AttesterGetsBadState(Attester) @j & #j < #i)))\n        ) |\n        (Ex #j. AttesterGetsPartiallyCompromise(Attester) @j & #j < #k) \n    )\n\" \n\n\n\n//K never learns the attesters long term key\nlemma attester_private_key_compromised:\n \"\n All Attester Verifier signed_EAT ltk n #i #k .\n    ( \n        CreateIdent(Attester, ltk) @k &\n        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i \n    )\n    ==> not(Ex #j .\n                K(ltk) @j & #j<#i &\n                #k<#i)\n \"\n\n //K never learns the verifiers long term key\nlemma verifier_private_key_compromised:\n \"\n All Attester Verifier signed_EAT Altk Vltk n #c1 #c2 #i .\n    ( \n        CreateIdent(Attester, Altk) @c1 &\n        CreateIdent(Verifier, Vltk) @c2 &\n        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i \n    )\n    ==> not(Ex #j .\n                K(Vltk) @j & #j<#i & \n                ((#c1<#i)&(#c2<#i)) \n            )\n \"\n\n\nlemma nonce_freshness_across_sessions:\n \"\n All Attester Verifier n #i #j .\n     (\n        VerifierSendsNonce(Attester, Verifier, n) @i &\n        VerifierSendsNonce(Attester, Verifier, n) @j\n     )\n     ==> #i = #j\n \"\n\n\n// add a lemma that shows that agreement doesn't hold from the attester's point of view\nlemma attester_does_not_agree_on_nonce_origin:\nexists-trace\n\"\nAll Attester Verifier signed_EAT n #t .\n    (\n        AttesterSendsEatGood(Attester, Verifier, signed_EAT, n) @t\n    )\n    ==> \n        not (Ex vltk #j .\n            VerifierSendsNonce(Attester, Verifier, revealSign(n, vltk)) @j &\n            #j < #t\n    )\n\"\n\n\n//Lemma shows that an adversary learns the values in the EAT\nlemma adversary_learns_the_EAT_information:\n \"\n All Attester Verifier signed_EAT n #i . \n     (\n        VerificationSuccess(Attester, Verifier, signed_EAT, n) @i\n     )\n     ==> (\n            (Ex verifier1 EAT Altk #j . AttesterSendsEatGood(Attester, verifier1, revealSign(EAT, Altk), n) @j) | \n            (Ex verifier1 EAT Altk #j . AttesterSendsEatPartialCompromise(Attester, verifier1, revealSign(EAT, Altk), n) @j)\n         ) &\n        ((Ex EAT #k . K(EAT) @k) & (Ex n #k1 . K(n) @k1))\n \"\n\n\nend"
    },
    {
        "file": "SPTHY-1/TLS_Handshake.spthy",
        "incomplete": "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hashes of the relevant information.\n       Due to our support for composed keys, we do not need any custom\n       axiomatization as Paulson does.\n\n*}\n\nfunctions: PRF/1\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk(____(POST_0)____, ____(PRE_0)____), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following signature based TLS handshake.\n\n  protocol TLS {\n    1. C -> S: C, nc, sid, pc\n    2. C <- S: ns, sid, ps\n\n    3. C -> S: { '31', pms                     }pk(S) ,\n               sign{ '32', h('32', ns, S, pms) }pk(C) ,\n               { '33', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('clientKey', nc, ns, PRF(pms, nc, ns))\n\n    4. C <- S: { '4', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('serverKey', nc, ns, PRF(pms, nc, ns))\n  }\n*/\n\nrule C_1:\n    [ Fr(~nc)\n    , Fr(~sid)\n    ]\n  --[]->\n    [ Out(\n        <$C, ____(PRE_1)____, ~sid, $pc>\n      )\n    , St_C_1($C, ~nc, ~sid, $pc)\n    ]\n\nrule S_1:\n    [ In(\n        <____(PRE_2)____, nc, sid, pc>\n      )\n    , Fr(~ns)\n    ]\n  --[]->\n    [ Out(\n        <____(POST_2)____, ____(PRE_4)____, ____(PRE_3)____, ____(POST_1)____>\n      )\n    , St_S_1($S, $C, sid, nc, pc, ~ns, $ps)\n    ]\n\nrule C_2:\n  let\n      MS   = PRF(~pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_1(____(PRE_5)____, ____(PRE_6)____, sid, pc)\n    , In(\n        <S, ns, sid, ps>\n      )\n    , Fr(~pms)\n    , !Pk(S, pkS)\n    , !Ltk(C, ltkC)\n    ]\n  --[ Running(S, C, <'server', ____(PRE_7)____, ____(LABEL_0)____, Ckey>)\n    ]->\n    [ Out(\n        < aenc{ '31', ____(POST_3)____ }pkS\n        , sign{ '32', h('32', ns, ____(POST_6)____, ~pms) }ltkC\n        , senc{ ____(POST_4)____, ____(PRE_11)____, MS, ____(POST_5)____, ____(PRE_8)____, C, ns, ____(PRE_9)____, S}Ckey\n        >\n      )\n    , St_C_2(S, C, sid, nc, ____(PRE_10)____, ns, ps, ~pms)\n    ]\n\nrule S_2:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_S_1(S, ____(PRE_15)____, sid, nc, ____(PRE_13)____, ____(PRE_14)____, ____(PRE_12)____)\n    , In(\n        < aenc{ '31', pms }pk(ltkS)\n        , signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , !Pk(C, pkC)\n    , !Ltk(S, ltkS)\n    ]\n    /* Explicit equality check, enforced as part of the property. */\n  --[ Eq(verify(signature, <'32', h('32', ____(LABEL_1)____, S, pms)>, pkC), true )\n    , SessionKeys( S, ____(PRE_19)____, ____(PRE_16)____, ____(PRE_17)____ )\n    , Running(____(LABEL_2)____, S, <'client', ____(PRE_18)____, ____(LABEL_3)____, Ckey>)\n    , Commit(S, ____(LABEL_4)____, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        senc{ '4', sid, ____(PRE_20)____, nc, pc, C, ____(POST_7)____, ps, S}Skey\n      )\n    ]\n\nrule C_3:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_2(S, C, sid, nc, ____(PRE_21)____, ____(PRE_22)____, ps, pms)\n    , In( senc{ '4', sid, ____(PRE_23)____, nc, pc, C, ns, ps, S}Skey )\n    ]\n  --[ Commit(____(LABEL_6)____, ____(PRE_25)____, <'client', MS, ____(PRE_24)____, Ckey>)\n    , SessionKeys( S, C, ____(LABEL_5)____, Ckey )\n    ]->\n    []\n\n\n/* TODO: Also model session-key reveals and adapt security properties. */\n\nrestriction Eq_check_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/* Session key secrecy from the perspective of both the server and the client\n * for both the key of the server and the key of the client. Note that this\n * lemma thus captures four security properties at once. */\nlemma session_key_secrecy:\n     /* It cannot be that */\n   \"____(LEM_1)____(\n         ____(LEM_5)____ S C keyS ____(LEM_6)____ #k.\n           /* somebody claims to have setup session keys, */\n           SessionKeys(S, C, keyS, keyC) @ k\n           /* but the adversary knows one of them */\n         & ( (Ex #____(LEM_2)____. K(keyS) @ i)\n           | (Ex #i. K(keyC) @ i)\n           )\n           /* without having performed a long-term key reveal. */\n         & not (Ex #____(LEM_7)____. RevLtk(S) @ r)\n         & not (Ex #r. RevLtk(C) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All ____(LEM_19)____ peer params #i.\n        ____(LEM_25)____(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (____(LEM_16)____ #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(____(LEM_20)____ actor2 peer2 #____(LEM_24)____.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #____(LEM_18)____. RevLtk(actor) @ ____(LEM_21)____)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n/* Consistency check: ensure that session-keys can be setup between honest\n * agents. */\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* There is a trace satisfying all equality checks */\n     (All ____(LEM_31)____ ____(LEM_35)____ #i. Eq(x,y) @ i ==> x = y)\n  &  /* Session keys have been setup */\n     (Ex S C ____(LEM_32)____ ____(LEM_37)____ #k.  ____(LEM_33)____(S, C, ____(LEM_36)____, keyC) @ k\n      /* without having performed a long-term key reveal. */\n      & not (Ex #r. ____(LEM_27)____(S) @ r)\n      & not (Ex #r. RevLtk(C) @ r)\n      )\n   \"\n\nend",
        "complete:": "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hashes of the relevant information.\n       Due to our support for composed keys, we do not need any custom\n       axiomatization as Paulson does.\n\n*}\n\nfunctions: PRF/1\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following signature based TLS handshake.\n\n  protocol TLS {\n    1. C -> S: C, nc, sid, pc\n    2. C <- S: ns, sid, ps\n\n    3. C -> S: { '31', pms                     }pk(S) ,\n               sign{ '32', h('32', ns, S, pms) }pk(C) ,\n               { '33', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('clientKey', nc, ns, PRF(pms, nc, ns))\n\n    4. C <- S: { '4', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('serverKey', nc, ns, PRF(pms, nc, ns))\n  }\n*/\n\nrule C_1:\n    [ Fr(~nc)\n    , Fr(~sid)\n    ]\n  --[]->\n    [ Out(\n        <$C, ~nc, ~sid, $pc>\n      )\n    , St_C_1($C, ~nc, ~sid, $pc)\n    ]\n\nrule S_1:\n    [ In(\n        <$C, nc, sid, pc>\n      )\n    , Fr(~ns)\n    ]\n  --[]->\n    [ Out(\n        <$S, ~ns, sid, $ps>\n      )\n    , St_S_1($S, $C, sid, nc, pc, ~ns, $ps)\n    ]\n\nrule C_2:\n  let\n      MS   = PRF(~pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_1(C, nc, sid, pc)\n    , In(\n        <S, ns, sid, ps>\n      )\n    , Fr(~pms)\n    , !Pk(S, pkS)\n    , !Ltk(C, ltkC)\n    ]\n  --[ Running(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        < aenc{ '31', ~pms }pkS\n        , sign{ '32', h('32', ns, S, ~pms) }ltkC\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , St_C_2(S, C, sid, nc, pc, ns, ps, ~pms)\n    ]\n\nrule S_2:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_S_1(S, C, sid, nc, pc, ns, ps)\n    , In(\n        < aenc{ '31', pms }pk(ltkS)\n        , signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , !Pk(C, pkC)\n    , !Ltk(S, ltkS)\n    ]\n    /* Explicit equality check, enforced as part of the property. */\n  --[ Eq(verify(signature, <'32', h('32', ns, S, pms)>, pkC), true )\n    , SessionKeys( S, C, Skey, Ckey )\n    , Running(C, S, <'client', MS, Skey, Ckey>)\n    , Commit(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey\n      )\n    ]\n\nrule C_3:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_2(S, C, sid, nc, pc, ns, ps, pms)\n    , In( senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey )\n    ]\n  --[ Commit(C, S, <'client', MS, Skey, Ckey>)\n    , SessionKeys( S, C, Skey, Ckey )\n    ]->\n    []\n\n\n/* TODO: Also model session-key reveals and adapt security properties. */\n\nrestriction Eq_check_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/* Session key secrecy from the perspective of both the server and the client\n * for both the key of the server and the key of the client. Note that this\n * lemma thus captures four security properties at once. */\nlemma session_key_secrecy:\n     /* It cannot be that */\n   \"not(\n         Ex S C keyS keyC #k.\n           /* somebody claims to have setup session keys, */\n           SessionKeys(S, C, keyS, keyC) @ k\n           /* but the adversary knows one of them */\n         & ( (Ex #i. K(keyS) @ i)\n           | (Ex #i. K(keyC) @ i)\n           )\n           /* without having performed a long-term key reveal. */\n         & not (Ex #r. RevLtk(S) @ r)\n         & not (Ex #r. RevLtk(C) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor peer params #i.\n        Commit(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (Ex #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex actor2 peer2 #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #r. RevLtk(actor) @ r)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n/* Consistency check: ensure that session-keys can be setup between honest\n * agents. */\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* There is a trace satisfying all equality checks */\n     (All x y #i. Eq(x,y) @ i ==> x = y)\n  &  /* Session keys have been setup */\n     (Ex S C keyS keyC #k.  SessionKeys(S, C, keyS, keyC) @ k\n      /* without having performed a long-term key reveal. */\n      & not (Ex #r. RevLtk(S) @ r)\n      & not (Ex #r. RevLtk(C) @ r)\n      )\n   \"\n\nend"
    },
    {
        "file": "SPTHY-1/TPM_Exclusive_Secrets.spthy",
        "incomplete": "theory TPM_Exclusive_Secrets begin\n\n/*\n    Protocol: Running example from [1]\n    Modeler: Simon Meier\n    Date:    September 2012\n    Status:  Working\n\n    [1] Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, \"Formal\n    Analysis of Protocols Based on TPM State Registers,\" csf, pp.66-80, 2011\n    IEEE 24th Computer Security Foundations Symposium, 2011.\n\n    The  of this example is to verify that the adversary cannot exploit\n    his TPM to simultainously access the two secrets that were encryped\n    exclusively by Alice.\n\n    Note that we could easily model multiple PCR's, if required.\n\n*/\n\nbuiltins: hashing, asymmetric-encryption, signing\n\n// TPM Model with support for a single PCRs\n///////////////////////////////////////////\n\nrule PCR_Init:\n    [ Fr(~aik)          // Authentication identity key\n    ]\n  --[ PCR_Init('pcr0',~aik)\n    , UniqueInit()      // For removing traces that have multiple initializations\n    ]->\n    [ PCR('pcr0')       // the initial PCR value is 'pcr0'\n    , !AIK(~aik)        // the auth. id. key is persistent\n    , Out(pk(~aik))     // publish the public key of the attest. ident. key\n    ]\n\n\n// Disabled, as the protocol is not secure under reboots.\n//\n// Note that we miss the attack, as we do not consider collapsing different\n// PCR_Unbind nodes by default. The general construction would require\n// distinctness constraints on temporal variables. We can however simulate it\n// by proving a simple case distinction lemma with a 'reuse' attribute, as\n// demonstrated below.\n//\n// rule PCR_Reboot:\n//    [ PCR(x) ] --> [ PCR('pcr0') ]  // reset the PCR to 'pcr0'\n\n// Extending the PCR register with the value 'y'\nrule PCR_Extend:\n    [ PCR(x) , In(y) ] --[ PCR_Extend(x,y,h(x,y)) ]-> [ PCR(h(x,y)) ]\n\n// Create a fresh  key that is bound to 'pcr0' extended with a public\n// constant.\nrule PCR_CreateKey:\n    [ Fr(~ska) ] --> [ !KeyTable(h('pcr0',$a), ~ska) ]\n\n// Certifying a key using the TPM's Attestation Identity Key (AIK)\nrule PCR_CertKey:\n    [ !AIK(aik)\n    , !KeyTable(x, sk)   // Any key in the keytable can be certified.\n    ]\n  --[ PCR_CertKey_Inst(x)\n    ]->\n    [ Out(sign{'certkey', x, pk(sk)}aik) ]\n\n// Keys in the keytable are bound to a fixed PCR value. If this value, agrees\n// with the actual PCR value, then the TPM can be used to decrypt messages\n// encrypted with these keys.\nrule PCR_Unbind:\n    [ PCR(x)\n    , !KeyTable(x, sk)\n    , In( aenc{m}pk(sk) )\n    ]\n  --[ PCR_Unbind(x,sk,m)\n    ]->\n    [ PCR(x) , Out(m) ]\n\n// Alice generates two secrets and accepts two *different* keys signed by the\n// TPM to provide exlusive access to them. We are a bit lazy here and use\n// pattern matching for the signature verification.\nrule Alice_Init:\n    [ Fr(~s0)\n    , Fr(____(PRE_0)____)\n    , !AIK(aik)\n    , In(sign{'certkey', x0, pk0}aik)\n    , In(sign{'certkey', x1, pk1}aik)\n    ]\n  --[ InEq(x0, x1)\n    , Secrets(~s0,~s1)\n    ]->\n    [ Out(aenc{~s0}pk0)\n    , Out(aenc{~s1}pk1)\n    ]\n\n\n\n// Axioms; i.e., restrictions on the set of traces of interest\n//////////////////////////////////////////////////////////////\n\nrestriction UniqueInit_unique:\n  \" All #i #j. UniqueInit() @ j & UniqueInit() @ i ==> #i = #j \"\n\nrestriction Ineq_checks_succeed:\n  \" All t #e. InEq(t,t) @ e ==> F \"\n\n\n// Security Properties\n//////////////////////\n\n\n// A type invariant characterizing the values that can be learned using the\n// TPM to Unbind (i.e., decrypt) messages.\nlemma types [sources]:\n  \" (All ____(LEM_0)____ d1 d2 #i. PCR_Unbind(d1, d2, m) @ i ==>\n        (____(LEM_1)____ #____(LEM_2)____.   KU(m) @ ____(LEM_3)____ & j < i)\n      | (Ex ____(LEM_4)____ #j. ____(LEM_5)____(m, s) @ j)\n      | (Ex s #j. Secrets(s, m) @ j)\n    )\n  \"\n\n// Characterizing the unbinding operation. This is the key lemma. It allows us\n// to jump backwards to smaller values of the PCR register during reasoning.\nlemma Unbind_PCR_charn [reuse, use_induction]:\n    \"All x ____(LEM_15)____ ____(LEM_14)____ #____(LEM_10)____.\n        // If the key 'sk' bound to PCR value 'x' is used to extract the body\n        // 'm' of an encryption, then\n        PCR_Unbind(x, sk, m) @ ____(LEM_11)____\n        ==>\n        // 'x' is the initial PCR value\n        ( (Ex aik #____(LEM_7)____.     PCR_Init(x, aik) @ j  )\n        // or it was the result of an extension.\n        | (Ex y xPrev #j. ____(LEM_16)____(xPrev,y,x) @ j)\n        )\n    \"\n\n// Uncomment to perform case distinctions on the identity of different\n// PCR_Unbind nodes. This is required to find the attack when using reboots.\n/*\nlemma PCR_Unbind_case_distinctions [reuse]:\n  \"All d11 d21 m1 #i1 d12 d22 m2 #i2.\n      PCR_Unbind(d11, d21, m1) @ i1\n    & PCR_Unbind(d12, d22, m2) @ i2\n    ==>\n      (#i1 = #i2) | not(#i1 = #i2)\n  \"\n*/\n\n// The desired security property\nlemma exclusive_secrets:\n  \" not(____(LEM_22)____ ____(LEM_23)____ s1 #i #____(LEM_24)____ #d1.\n           Secrets(s0, s1) @ i\n         & K(s0) @ d0\n         & K(s1) @ d1\n       )\"\n\n// Sanity check: both secrets can be accessed individually.\nlemma left_reachable:\n  exists-trace\n  \" Ex ____(LEM_25)____ s1 #____(LEM_26)____ #j.  Secrets(s0, s1) @ i & K(s0) @ j \"\n\nlemma right_reachable:\n  exists-trace\n  \" Ex s0 s1 #i #____(LEM_27)____.  Secrets(s0, s1) @ i & K(s1) @ ____(LEM_28)____ \"\n\n\nend",
        "complete:": "theory TPM_Exclusive_Secrets begin\n\n/*\n    Protocol: Running example from [1]\n    Modeler: Simon Meier\n    Date:    September 2012\n    Status:  Working\n\n    [1] Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, \"Formal\n    Analysis of Protocols Based on TPM State Registers,\" csf, pp.66-80, 2011\n    IEEE 24th Computer Security Foundations Symposium, 2011.\n\n    The  of this example is to verify that the adversary cannot exploit\n    his TPM to simultainously access the two secrets that were encryped\n    exclusively by Alice.\n\n    Note that we could easily model multiple PCR's, if required.\n\n*/\n\nbuiltins: hashing, asymmetric-encryption, signing\n\n// TPM Model with support for a single PCRs\n///////////////////////////////////////////\n\nrule PCR_Init:\n    [ Fr(~aik)          // Authentication identity key\n    ]\n  --[ PCR_Init('pcr0',~aik)\n    , UniqueInit()      // For removing traces that have multiple initializations\n    ]->\n    [ PCR('pcr0')       // the initial PCR value is 'pcr0'\n    , !AIK(~aik)        // the auth. id. key is persistent\n    , Out(pk(~aik))     // publish the public key of the attest. ident. key\n    ]\n\n\n// Disabled, as the protocol is not secure under reboots.\n//\n// Note that we miss the attack, as we do not consider collapsing different\n// PCR_Unbind nodes by default. The general construction would require\n// distinctness constraints on temporal variables. We can however simulate it\n// by proving a simple case distinction lemma with a 'reuse' attribute, as\n// demonstrated below.\n//\n// rule PCR_Reboot:\n//    [ PCR(x) ] --> [ PCR('pcr0') ]  // reset the PCR to 'pcr0'\n\n// Extending the PCR register with the value 'y'\nrule PCR_Extend:\n    [ PCR(x) , In(y) ] --[ PCR_Extend(x,y,h(x,y)) ]-> [ PCR(h(x,y)) ]\n\n// Create a fresh  key that is bound to 'pcr0' extended with a public\n// constant.\nrule PCR_CreateKey:\n    [ Fr(~ska) ] --> [ !KeyTable(h('pcr0',$a), ~ska) ]\n\n// Certifying a key using the TPM's Attestation Identity Key (AIK)\nrule PCR_CertKey:\n    [ !AIK(aik)\n    , !KeyTable(x, sk)   // Any key in the keytable can be certified.\n    ]\n  --[ PCR_CertKey_Inst(x)\n    ]->\n    [ Out(sign{'certkey', x, pk(sk)}aik) ]\n\n// Keys in the keytable are bound to a fixed PCR value. If this value, agrees\n// with the actual PCR value, then the TPM can be used to decrypt messages\n// encrypted with these keys.\nrule PCR_Unbind:\n    [ PCR(x)\n    , !KeyTable(x, sk)\n    , In( aenc{m}pk(sk) )\n    ]\n  --[ PCR_Unbind(x,sk,m)\n    ]->\n    [ PCR(x) , Out(m) ]\n\n// Alice generates two secrets and accepts two *different* keys signed by the\n// TPM to provide exlusive access to them. We are a bit lazy here and use\n// pattern matching for the signature verification.\nrule Alice_Init:\n    [ Fr(~s0)\n    , Fr(~s1)\n    , !AIK(aik)\n    , In(sign{'certkey', x0, pk0}aik)\n    , In(sign{'certkey', x1, pk1}aik)\n    ]\n  --[ InEq(x0, x1)\n    , Secrets(~s0,~s1)\n    ]->\n    [ Out(aenc{~s0}pk0)\n    , Out(aenc{~s1}pk1)\n    ]\n\n\n\n// Axioms; i.e., restrictions on the set of traces of interest\n//////////////////////////////////////////////////////////////\n\nrestriction UniqueInit_unique:\n  \" All #i #j. UniqueInit() @ j & UniqueInit() @ i ==> #i = #j \"\n\nrestriction Ineq_checks_succeed:\n  \" All t #e. InEq(t,t) @ e ==> F \"\n\n\n// Security Properties\n//////////////////////\n\n\n// A type invariant characterizing the values that can be learned using the\n// TPM to Unbind (i.e., decrypt) messages.\nlemma types [sources]:\n  \" (All m d1 d2 #i. PCR_Unbind(d1, d2, m) @ i ==>\n        (Ex #j.   KU(m) @ j & j < i)\n      | (Ex s #j. Secrets(m, s) @ j)\n      | (Ex s #j. Secrets(s, m) @ j)\n    )\n  \"\n\n// Characterizing the unbinding operation. This is the key lemma. It allows us\n// to jump backwards to smaller values of the PCR register during reasoning.\nlemma Unbind_PCR_charn [reuse, use_induction]:\n    \"All x sk m #i.\n        // If the key 'sk' bound to PCR value 'x' is used to extract the body\n        // 'm' of an encryption, then\n        PCR_Unbind(x, sk, m) @ i\n        ==>\n        // 'x' is the initial PCR value\n        ( (Ex aik #j.     PCR_Init(x, aik) @ j  )\n        // or it was the result of an extension.\n        | (Ex y xPrev #j. PCR_Extend(xPrev,y,x) @ j)\n        )\n    \"\n\n// Uncomment to perform case distinctions on the identity of different\n// PCR_Unbind nodes. This is required to find the attack when using reboots.\n/*\nlemma PCR_Unbind_case_distinctions [reuse]:\n  \"All d11 d21 m1 #i1 d12 d22 m2 #i2.\n      PCR_Unbind(d11, d21, m1) @ i1\n    & PCR_Unbind(d12, d22, m2) @ i2\n    ==>\n      (#i1 = #i2) | not(#i1 = #i2)\n  \"\n*/\n\n// The desired security property\nlemma exclusive_secrets:\n  \" not(Ex s0 s1 #i #d0 #d1.\n           Secrets(s0, s1) @ i\n         & K(s0) @ d0\n         & K(s1) @ d1\n       )\"\n\n// Sanity check: both secrets can be accessed individually.\nlemma left_reachable:\n  exists-trace\n  \" Ex s0 s1 #i #j.  Secrets(s0, s1) @ i & K(s0) @ j \"\n\nlemma right_reachable:\n  exists-trace\n  \" Ex s0 s1 #i #j.  Secrets(s0, s1) @ i & K(s1) @ j \"\n\n\nend"
    },
    {
        "file": "SPTHY-1/Typing_and_Destructors.spthy",
        "incomplete": "theory Typing_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration of the interaction between sources and\n                destructors\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working / misses theory extension (see issue #104)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors. Its verification does not yet work out of the box, as the\n   implemented definition of guarded trace properties is too restrictive to\n   allow formalizing the required type invariant.\n\n   NOTE that it seems that the best option is to explicitly state in a rule\n   that it does not continue in case the application of a deconstructor was\n   not successful using an restriction like 'No_failure_terms'. This considerably\n   simplifies the verification.\n*/\n\n\nbuiltins: symmetric-encryption, hashing\n\n// Shared keys that can be compromised.\nrule Setup_Key:\n  [ Fr(~k) ] --[ IsKey(~k) ]-> [ !Key(~k) ]\n\nrule Reveal_Key:\n  [ !Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\nrule Initiator:\n  let msg = senc{~sec,~pub}k\n  in\n    [ !Key(k), Fr(~sec), Fr(~pub) ]\n  --[ Out_Initiator(msg)\n    , Public(~pub)\n    ]->\n    [ Out( msg ) ]\n\nrule Responder:\n  // We use explicit destructors instead of the pattern matching\n  //\n  //     msg = senc{sec,pub}key\n  //\n  // This explicit use of destructors is more permissive (i.e., allows more\n  // traces), as it allows the rule to fire even if an failure term is sent.\n  //\n  let body = sdec{msg}key\n      sec  = fst(body)\n      pub  = snd(body)\n  in\n    [ !Key(key), In( msg )\n    ]\n  --[ In_Responder(____(PRE_0)____, pub)\n    , Secret(____(LABEL_0)____, key)\n    // We can simulate pattern matching by logging that the 'pub' term must\n    // not be an failure term.\n    , NoFailureTerm(pub)\n    ]->\n    [ Out( pub ) ]\n\n// Commented out to test the type assertion.\n//\n// // This restriction then filters all traces with disallowed failure terms.\n// // Note that we interpret its formula modulo AC.\n// restriction No_failure_terms:\n//     \"(All x #i. NoFailureTerm(snd(x)) @ i ==> F)\"\n//     // Here we should also exclude all other possible shapes of failure terms.\n\n// This type assertion does not hold, as 'pub' could be an failure term. See the\n// case marked below for the missing piece of the puzzle.\n// Note that we interpret its formula modulo AC.\nlemma type_assertion [sources]:\n  /* For all messages received by the responder */\n  \"(All ____(LEM_14)____ ____(LEM_4)____ #____(LEM_22)____. In_Responder(m, ____(LEM_23)____) @ i ==>\n        /* they either came from the adversary and he therefore knows the\n         * contained 'k' variable before it was instantiated */\n      ( (____(LEM_26)____ #____(LEM_3)____. KU(pub) @ ____(LEM_5)____ & j < i)\n        /* or there is an initiator that sent 'm'. */\n      | (Ex #j. Out_Initiator(m) @ j)\n      // These two cases cover the failure cases and make the type assertion\n      // valid. They are also sufficient to prove the statements below.\n      // They are currently not wellformed because 'snd' and 'sdec' are not\n      // allowed in formulas.\n      | (Ex ____(LEM_0)____ #j. KU(____(LEM_1)____) @ j\n                   & pub = ____(LEM_9)____(body) & j < i)\n      | (Ex body key #j #k. IsKey(key)@k & KU(body) @ j\n                          & pub = snd(sdec{body}key) & j < i)\n      // Note that I thinkg that these two cases might be sufficient. They\n      // would however require that equalities can also be guarding.\n      // | (Ex body.     pub = snd(body))\n      // | (Ex body key. pub = snd(sdec{body}key))\n      )\n   )\n  \"\n\n/* The secret part of the message received by Responder is secret provided the\n * key has not been compromised.\n */\nlemma Responder_secrecy:\n  \" All sec ____(LEM_31)____ #____(LEM_29)____ #j.\n        Secret(sec, key) @ #i\n      & K(sec) @ #j\n      ==>\n       (Ex #r. ____(LEM_30)____(key) @ r)\n  \"\n\n/* Sanity check: the public part is accessible to the adversary without\n * performing a key reveal.\n */\nlemma Public_part_public:\n  exists-trace\n  \"  /* No key reveal has been performed */\n    not (Ex k #____(LEM_37)____. ____(LEM_33)____(k) @ i)\n    /* and the public part of a message is known to the adversary. */\n  & (Ex ____(LEM_35)____ #i #____(LEM_32)____. Public(pub) @ i & K(pub) @ j )\n  \"\n\n\nend",
        "complete:": "theory Typing_and_Destructors\nbegin\n\n/*\n   Protocol:    Demonstration of the interaction between sources and\n                destructors\n   Modeler:     Simon Meier\n   Date:        July 2012\n\n   Status:      working / misses theory extension (see issue #104)\n\n   This protocol is a variant of 'Minimal_Typing_Example' that uses explicit\n   destructors. Its verification does not yet work out of the box, as the\n   implemented definition of guarded trace properties is too restrictive to\n   allow formalizing the required type invariant.\n\n   NOTE that it seems that the best option is to explicitly state in a rule\n   that it does not continue in case the application of a deconstructor was\n   not successful using an restriction like 'No_failure_terms'. This considerably\n   simplifies the verification.\n*/\n\n\nbuiltins: symmetric-encryption, hashing\n\n// Shared keys that can be compromised.\nrule Setup_Key:\n  [ Fr(~k) ] --[ IsKey(~k) ]-> [ !Key(~k) ]\n\nrule Reveal_Key:\n  [ !Key(k) ] --[ Rev(k) ]-> [ Out(k) ]\n\nrule Initiator:\n  let msg = senc{~sec,~pub}k\n  in\n    [ !Key(k), Fr(~sec), Fr(~pub) ]\n  --[ Out_Initiator(msg)\n    , Public(~pub)\n    ]->\n    [ Out( msg ) ]\n\nrule Responder:\n  // We use explicit destructors instead of the pattern matching\n  //\n  //     msg = senc{sec,pub}key\n  //\n  // This explicit use of destructors is more permissive (i.e., allows more\n  // traces), as it allows the rule to fire even if an failure term is sent.\n  //\n  let body = sdec{msg}key\n      sec  = fst(body)\n      pub  = snd(body)\n  in\n    [ !Key(key), In( msg )\n    ]\n  --[ In_Responder(msg, pub)\n    , Secret(sec, key)\n    // We can simulate pattern matching by logging that the 'pub' term must\n    // not be an failure term.\n    , NoFailureTerm(pub)\n    ]->\n    [ Out( pub ) ]\n\n// Commented out to test the type assertion.\n//\n// // This restriction then filters all traces with disallowed failure terms.\n// // Note that we interpret its formula modulo AC.\n// restriction No_failure_terms:\n//     \"(All x #i. NoFailureTerm(snd(x)) @ i ==> F)\"\n//     // Here we should also exclude all other possible shapes of failure terms.\n\n// This type assertion does not hold, as 'pub' could be an failure term. See the\n// case marked below for the missing piece of the puzzle.\n// Note that we interpret its formula modulo AC.\nlemma type_assertion [sources]:\n  /* For all messages received by the responder */\n  \"(All m pub #i. In_Responder(m, pub) @ i ==>\n        /* they either came from the adversary and he therefore knows the\n         * contained 'k' variable before it was instantiated */\n      ( (Ex #j. KU(pub) @ j & j < i)\n        /* or there is an initiator that sent 'm'. */\n      | (Ex #j. Out_Initiator(m) @ j)\n      // These two cases cover the failure cases and make the type assertion\n      // valid. They are also sufficient to prove the statements below.\n      // They are currently not wellformed because 'snd' and 'sdec' are not\n      // allowed in formulas.\n      | (Ex body #j. KU(body) @ j\n                   & pub = snd(body) & j < i)\n      | (Ex body key #j #k. IsKey(key)@k & KU(body) @ j\n                          & pub = snd(sdec{body}key) & j < i)\n      // Note that I thinkg that these two cases might be sufficient. They\n      // would however require that equalities can also be guarding.\n      // | (Ex body.     pub = snd(body))\n      // | (Ex body key. pub = snd(sdec{body}key))\n      )\n   )\n  \"\n\n/* The secret part of the message received by Responder is secret provided the\n * key has not been compromised.\n */\nlemma Responder_secrecy:\n  \" All sec key #i #j.\n        Secret(sec, key) @ #i\n      & K(sec) @ #j\n      ==>\n       (Ex #r. Rev(key) @ r)\n  \"\n\n/* Sanity check: the public part is accessible to the adversary without\n * performing a key reveal.\n */\nlemma Public_part_public:\n  exists-trace\n  \"  /* No key reveal has been performed */\n    not (Ex k #i. Rev(k) @ i)\n    /* and the public part of a message is known to the adversary. */\n  & (Ex pub #i #j. Public(pub) @ i & K(pub) @ j )\n  \"\n\n\nend"
    },
    {
        "file": "SPTHY-1/UM_wPFS.spthy",
        "incomplete": "theory UM_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* The Unified Model (UM) Key-Exchange Protocol *}\n\n/*\n * Protocol:\tUnified Model (UM)\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Authenticated Diffie-Hellman Key Agreement Protocols\"\n * \t\tSimon Blake-Wilson and Alfred Menezes\n * \t\tLNCS 1556, 1999\n * Property:\tweak Perfect Forward Secrecy (wPFS), from\n * \t\t\"HMQV: A High-Performance Secure Diffie-Hellman Protocol\"\n * \t\tH. Krawczyk\n * \t\tCRYPTO 2005, LNCS 3621, 2005\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( ____(PRE_0)____, ~lk ), !Pk( $A, ____(POST_0)____ ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->\n   [ Init_1( ~ekI, $I, ____(POST_1)____, ____(PRE_1)____, 'g'^~ekI ),\n     !Ephk(~ekI),\n     Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ Init_1( ~ekI, $I, $R, ~lkI , ____(PRE_2)____), In( Y ), !Pk( $R,'g'^~lkR ) ]\n   --[SidI_2( ____(LABEL_0)____, $I, $R, hkI, Y,\n       h( <____(PRE_3)____, ('g'^~lkR)^~lkI > ) ) ]->\n   [ !Sessk( ~ekI, \n       h( <Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]\n\n\nrule Resp_1:\n   [ In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk(____(PRE_4)____, 'g'^~lkI) ]\n   --[ SidR_1( ~ekR, $I, $R, X, ____(LABEL_1)____ ,\n       h( <X^~ekR, (____(PRE_5)____)^~lkR > ) ) ]->\n   [ Out( 'g'^____(PRE_6)____ ),\n     !Ephk(~ekR),\n     !Sessk( ~ekR, \n       h( <X^~ekR, (____(POST_2)____)^~lkR > ) ) ]\n\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma wPFS_initiator_key:\n  \"not (Ex #____(LEM_24)____ #____(LEM_9)____ ____(LEM_10)____ ____(LEM_6)____ R k hkI ____(LEM_5)____.\n            SidI_2(ttest, I, R, hkI, ____(LEM_26)____, k) @ i1 & K( k ) @ i2\n\n            /* No ephemeral-key-reveal */\n            & (All #____(LEM_7)____ ____(LEM_15)____. EphkRev( ____(LEM_22)____ ) @ ____(LEM_16)____ ==> F)\n\n            /* No session-key-reveal */\n            & (All #____(LEM_20)____ t. SesskRev( t ) @ ____(LEM_21)____ ==> F)\n\n\t    /* Long-term key reveals are after the end of the test\n\t     * thread. Furthermore, if there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or the intended peer.\n\t       */\n            & (All #____(LEM_23)____. (LtkRev( I )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner ____(LEM_18)____.\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))\n            & (All #i3. (LtkRev( R )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner kpartner.\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))\n\t)\"\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma wPFS_responder_key:\n  \"not (Ex #____(LEM_28)____ #i2 ttest ____(LEM_29)____ R ____(LEM_44)____ ____(LEM_30)____ ____(LEM_39)____.\n            ____(LEM_37)____(ttest, ____(LEM_31)____, R, ____(LEM_41)____, hkR, k) @ i1 & K( k ) @ i2\n\n            /* No ephemeral-key-reveal */\n            & (All #____(LEM_27)____ t. EphkRev( t ) @ ____(LEM_40)____ ==> F)\n\n            /* No session-key-reveal */\n            & (All #____(LEM_42)____ t. SesskRev( t ) @ i3 ==> F)\n\n\t    /* Long-term key reveals are after the end of the test\n\t     * thread. Furthermore, if there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or the intended peer.\n\t       */\n            & (All #i3. (____(LEM_34)____( I )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #____(LEM_46)____ tpartner.\n                       SidI_1( tpartner,I,R,hkI ) @i4)))\n            & (All #i3. (____(LEM_45)____( R )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner.\n                       SidI_1( tpartner,I,R,hkI ) @i4)))\n\t)\"\n\nend",
        "complete:": "theory UM_wPFS\nbegin\n\nbuiltins: hashing, diffie-hellman\n\nsection{* The Unified Model (UM) Key-Exchange Protocol *}\n\n/*\n * Protocol:\tUnified Model (UM)\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Authenticated Diffie-Hellman Key Agreement Protocols\"\n * \t\tSimon Blake-Wilson and Alfred Menezes\n * \t\tLNCS 1556, 1999\n * Property:\tweak Perfect Forward Secrecy (wPFS), from\n * \t\t\"HMQV: A High-Performance Secure Diffie-Hellman Protocol\"\n * \t\tH. Krawczyk\n * \t\tCRYPTO 2005, LNCS 3621, 2005\n *\n * Status: \tworking\n */\n\n/* Protocol rules */\n\nrule generate_ltk:\n   [ Fr(~lk) ] -->\n   [ !Ltk( $A, ~lk ), !Pk( $A, 'g'^~lk ), Out( 'g'^~lk ) ]\n\nrule Init_1:\n   [ Fr( ~ekI ), !Ltk( $I, ~lkI ) ]\n   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->\n   [ Init_1( ~ekI, $I, $R, ~lkI, 'g'^~ekI ),\n     !Ephk(~ekI),\n     Out( 'g'^~ekI ) ]\n\nrule Init_2:\n   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R,'g'^~lkR ) ]\n   --[SidI_2( ~ekI, $I, $R, hkI, Y,\n       h( <Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]->\n   [ !Sessk( ~ekI, \n       h( <Y^~ekI, ('g'^~lkR)^~lkI > ) ) ]\n\n\nrule Resp_1:\n   [ In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, 'g'^~lkI) ]\n   --[ SidR_1( ~ekR, $I, $R, X, 'g'^~ekR ,\n       h( <X^~ekR, ('g'^~lkI)^~lkR > ) ) ]->\n   [ Out( 'g'^~ekR ),\n     !Ephk(~ekR),\n     !Sessk( ~ekR, \n       h( <X^~ekR, ('g'^~lkI)^~lkR > ) ) ]\n\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~ekI) ]\n   --[ EphkRev(~ekI) ]->\n   [ Out(~ekI) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, k) ]\n   --[ LtkRev($A) ]->\n   [ Out(k) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma wPFS_initiator_key:\n  \"not (Ex #i1 #i2 ttest I R k hkI hkR.\n            SidI_2(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n            /* No ephemeral-key-reveal */\n            & (All #i3 t. EphkRev( t ) @ i3 ==> F)\n\n            /* No session-key-reveal */\n            & (All #i3 t. SesskRev( t ) @ i3 ==> F)\n\n\t    /* Long-term key reveals are after the end of the test\n\t     * thread. Furthermore, if there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or the intended peer.\n\t       */\n            & (All #i3. (LtkRev( I )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner kpartner.\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))\n            & (All #i3. (LtkRev( R )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner kpartner.\n                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))\n\t)\"\n\n/* An attack is valid in the security model if the session key of the test session is deduced and\n   the test session is clean.\n*/\nlemma wPFS_responder_key:\n  \"not (Ex #i1 #i2 ttest I R k hkI hkR.\n            SidR_1(ttest, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2\n\n            /* No ephemeral-key-reveal */\n            & (All #i3 t. EphkRev( t ) @ i3 ==> F)\n\n            /* No session-key-reveal */\n            & (All #i3 t. SesskRev( t ) @ i3 ==> F)\n\n\t    /* Long-term key reveals are after the end of the test\n\t     * thread. Furthermore, if there is no partner thread, then there is no longterm-key-reveal for\n\t       the actor or the intended peer.\n\t       */\n            & (All #i3. (LtkRev( I )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner.\n                       SidI_1( tpartner,I,R,hkI ) @i4)))\n            & (All #i3. (LtkRev( R )@ i3 ) ==>\n\t          ( (i1 < i3) &\n\t            (Ex #i4 tpartner.\n                       SidI_1( tpartner,I,R,hkI ) @i4)))\n\t)\"\n\nend"
    },
    {
        "file": "SPTHY-1/3.spthy",
        "incomplete": "/*\nM is a message from A to B\nK is a freshly generated symmetric key\nN is a nonce\nPuB is B\u2019s public key\n\nA -> B : A, senc((A, M), K)\nB -> A : N\nA -> B : aenc((N, K), PuB)\n\n# Failed properties\nlemma message_authentication:\n\"All b m #i. Authentic(b,m) @i\n==> (Ex #j. Send(b,m) @j & j<i)\"\nend\n\n- Authenticity of M \n*/\ntheory three\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(____(PRE_0)____)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          Fr(~M)\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, ____(PRE_1)____, sk(____(POST_1)____), pk(k_A), pk(____(PRE_2)____)),\n          St_init_B($A, $B, sk(____(POST_0)____), pk(k_B))\n        ]\n\n// ROLE A\nrule m1_A:\n        [ St_init_A(A, B, M, sk(k_A), pk(k_A), pk(____(PRE_3)____)),\n          Fr(~Ks)\n        ]\n        --[ Send(B,M) ]->\n        [ Out(<____(PRE_4)____, senc{<A, ____(PRE_5)____>}____(POST_3)____>),\n          St_m1_A(A, B, ~Ks, M, sk(k_A), pk(k_A), pk(____(POST_2)____))\n        ]\n\nrule m2_A:\n        [ St_m1_A(A, ____(PRE_6)____, Ks, M, sk(k_A), pk(k_A), pk(k_B)),\n          In(N)\n        ]\n        --[  ]->\n        [ St_m2_A(____(PRE_7)____, B, Ks, M, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule m3_A:\n        [ St_m2_A(____(PRE_7)____, B, Ks, M, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n        --[  ]->\n        [ Out(aenc{<N, ____(PRE_9)____>}pk(____(PRE_10)____)),\n          St_m3_A(A, ____(POST_5)____, Ks, ____(POST_4)____, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\n// ROLE B\nrule m1_B:\n        [ St_init_B(A, B, sk(k_B), pk(k_B)),\n          In(<A, ____(PRE_11)____>)\n        ]\n        --[  ]->\n        [ St_m1_B(____(POST_6)____, B, sk(k_B), pk(k_B), ____(PRE_12)____)\n        ]\n\nrule m2_B:\n        [ St_m1_B(____(POST_6)____, B, sk(k_B), pk(k_B), ____(PRE_12)____),\n          Fr(~N)\n        ]\n        --[  ]->\n        [ Out(____(PRE_14)____),\n          St_m2_B(A, B, ~N, sk(k_B), pk(k_B), alpha)\n        ]\n\nrule m3_B:\n    let\n        alpha = senc{<A, M>}Ks\n    in\n        [ St_m2_B(A, B, ____(PRE_15)____, sk(k_B), pk(k_B), alpha),\n          In(aenc{<N, Ks>}pk(k_B))\n        ]\n        --[ Authentic(B,M)  ]->\n        [ St_m3_B(A, B, ____(POST_7)____, M, ____(PRE_16)____, sk(k_B), pk(k_B))\n        ]\n\n// lemma executable:\n// exists-trace\n//    \"Ex A B M N #i #j. SendA(A,M)@i & Recv(B,N) @j\"\n    \nlemma message_authentication:\n    \"All b ____(LEM_6)____ #i. Authentic(b,____(LEM_7)____) @i\n    ==> (Ex #j. ____(LEM_8)____(b,m) @j & j<i)\"\n\nend",
        "complete:": "/*\nM is a message from A to B\nK is a freshly generated symmetric key\nN is a nonce\nPuB is B\u2019s public key\n\nA -> B : A, senc((A, M), K)\nB -> A : N\nA -> B : aenc((N, K), PuB)\n\n# Failed properties\nlemma message_authentication:\n\"All b m #i. Authentic(b,m) @i\n==> (Ex #j. Send(b,m) @j & j<i)\"\nend\n\n- Authenticity of M \n*/\ntheory three\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2\n\nbuiltins: symmetric-encryption\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Symmetric_key_setup:\n    [ Fr(~symK) ] --> [ !Key($A, $B, ~symK) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B)),\n          Fr(~M)\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, ~M, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_B))\n        ]\n\n// ROLE A\nrule m1_A:\n        [ St_init_A(A, B, M, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~Ks)\n        ]\n        --[ Send(B,M) ]->\n        [ Out(<A, senc{<A, M>}~Ks>),\n          St_m1_A(A, B, ~Ks, M, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule m2_A:\n        [ St_m1_A(A, B, Ks, M, sk(k_A), pk(k_A), pk(k_B)),\n          In(N)\n        ]\n        --[  ]->\n        [ St_m2_A(A, B, Ks, M, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule m3_A:\n        [ St_m2_A(A, B, Ks, M, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n        --[  ]->\n        [ Out(aenc{<N, Ks>}pk(k_B)),\n          St_m3_A(A, B, Ks, M, N, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\n// ROLE B\nrule m1_B:\n        [ St_init_B(A, B, sk(k_B), pk(k_B)),\n          In(<A, alpha>)\n        ]\n        --[  ]->\n        [ St_m1_B(A, B, sk(k_B), pk(k_B), alpha)\n        ]\n\nrule m2_B:\n        [ St_m1_B(A, B, sk(k_B), pk(k_B), alpha),\n          Fr(~N)\n        ]\n        --[  ]->\n        [ Out(~N),\n          St_m2_B(A, B, ~N, sk(k_B), pk(k_B), alpha)\n        ]\n\nrule m3_B:\n    let\n        alpha = senc{<A, M>}Ks\n    in\n        [ St_m2_B(A, B, N, sk(k_B), pk(k_B), alpha),\n          In(aenc{<N, Ks>}pk(k_B))\n        ]\n        --[ Authentic(B,M)  ]->\n        [ St_m3_B(A, B, Ks, M, N, sk(k_B), pk(k_B))\n        ]\n\n// lemma executable:\n// exists-trace\n//    \"Ex A B M N #i #j. SendA(A,M)@i & Recv(B,N) @j\"\n    \nlemma message_authentication:\n    \"All b m #i. Authentic(b,m) @i\n    ==> (Ex #j. Send(b,m) @j & j<i)\"\n\nend"
    }
]