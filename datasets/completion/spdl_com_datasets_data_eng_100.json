[
    {
        "file": "SPDL-1/2r890-ex3-a.spdl",
        "incomplete": "/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(X,Y,____(ROLE_1)____)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(____(ROLE_1)____,X, ____(NONCE_1)____ );\n\t\trecv_2(X,____(ROLE_1)____, { ____(ROLE_1)____,____(NONCE_1)____ }sk(X) );\n\t\tsend_3(____(ROLE_1)____,Y, ny );\n\t\trecv_4(Y,____(ROLE_1)____, { ny,____(ROLE_1)____ }sk(Y) );\n\n\t\tclaim_i1(____(ROLE_1)____,Niagree);\n\t\tclaim_i2(____(ROLE_1)____,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(____(ROLE_1)____,X, ____(NONCE_1)____ );\n\t\tsend_2(X,____(ROLE_1)____, { ____(ROLE_1)____,____(NONCE_1)____ }sk(X) );\n\t}\n\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(____(ROLE_1)____,Y, ny );\n\t\tsend_4(Y,____(ROLE_1)____, { ny,____(ROLE_1)____ }sk(Y) );\n\t}\n}",
        "complete:": "/*\n * Course 2r890\n *\n * Assignment 0405-3\n *\n * Protocol a\n *\n * nisynch, niagree\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol course2r890year0405ex3(X,Y,I)\n{\n\trole I\n\t{\n\t\tfresh nx: Nonce;\n\t\tfresh ny: Nonce;\n\n\t\tsend_1(I,X, nx );\n\t\trecv_2(X,I, { I,nx }sk(X) );\n\t\tsend_3(I,Y, ny );\n\t\trecv_4(Y,I, { ny,I }sk(Y) );\n\n\t\tclaim_i1(I,Niagree);\n\t\tclaim_i2(I,Nisynch);\n\t}\t\n\t\n\trole X\n\t{\n\t\tvar nx: Nonce;\n\n\t\trecv_1(I,X, nx );\n\t\tsend_2(X,I, { I,nx }sk(X) );\n\t}\n\n\trole Y\n\t{\n\t\tvar ny: Nonce;\n\n\t\trecv_3(I,Y, ny );\n\t\tsend_4(Y,I, { ny,I }sk(Y) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/AccessRequestEvaluation_CRCBAC.spdl",
        "incomplete": "hashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (____(ROLE_1)____,GW){\n\nrole ____(ROLE_1)____{\n\nfresh T1:Nonce;\n\nvar ____(NONCE_1)____:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (____(ROLE_1)____,GW,M,T1);\n\nrecv_2(GW,____(ROLE_1)____,XOR(Concat(IDa,c,Resp),h(sk)),____(NONCE_1)____);\n\nclaim(____(ROLE_1)____,Secret,SKa);\n\nclaim(____(ROLE_1)____,Alive);\n\nclaim(____(ROLE_1)____,Weakagree);\n\nclaim(____(ROLE_1)____,Niagree);\n\nclaim(____(ROLE_1)____,Nisynch);}\n\nrole GW{\n\nfresh ____(NONCE_1)____:Nonce; \n\nvar T1:Nonce; \n\nconst IDa;\n\nrecv_1(____(ROLE_1)____,GW,M,T1);\n\nsend_2 (GW,____(ROLE_1)____,XOR(Concat(IDa,c,Resp),h(sk)),____(NONCE_1)____);\n\nclaim(GW,Alive);\n\nclaim(GW,Weakagree);\n\nclaim(GW,Niagree);\n\nclaim(GW,Nisynch);\n\nclaim(GW,Secret,SKa);}\n\n  }",
        "complete:": "hashfunction h;/* Secure hash function */\n\nconst XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst enforce:Function;\n\nconst Fresh: Function;\n\nconst Getrole:Function;\n\nconst GetCapability:Function;\n\nconst GetPermission:Function;\n\nconst Getpriority:Function;\n\nsecret SKa,Resp;\n\nconst cxt,c;\n\nmacro Rol= Getrole(IDa,cxt);\n\nmacro Cap=GetCapability(Rol);\n\nmacro Per=GetPermission(Cap);\n\nmacro resp=enforce(Rol,c);\n\nprotocol AccessRequest (Da,GW){\n\nrole Da{\n\nfresh T1:Nonce;\n\nvar T2:Nonce; \n\nconst IDa;\n\nmacro Rq=Concat(IDa,cxt,c);\n\nmacro M=XOR(Rq,h(SKa)); \n\nsend_1 (Da,GW,M,T1);\n\nrecv_2(GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(Da,Secret,SKa);\n\nclaim(Da,Alive);\n\nclaim(Da,Weakagree);\n\nclaim(Da,Niagree);\n\nclaim(Da,Nisynch);}\n\nrole GW{\n\nfresh T2:Nonce; \n\nvar T1:Nonce; \n\nconst IDa;\n\nrecv_1(Da,GW,M,T1);\n\nsend_2 (GW,Da,XOR(Concat(IDa,c,Resp),h(sk)),T2);\n\nclaim(GW,Alive);\n\nclaim(GW,Weakagree);\n\nclaim(GW,Niagree);\n\nclaim(GW,Nisynch);\n\nclaim(GW,Secret,SKa);}\n\n  }"
    },
    {
        "file": "SPDL-1/andrew-ban-1.spdl",
        "incomplete": "# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,____(ROLE_1)____)\n{\n    role I\n    {\n        fresh ____(NONCE_1)____: Nonce;\n        var ____(ENCRYPTED_1)____,nr2: Nonce;\n        var ____(KEY_1)____: SessionKey;\n\n        send_1(I,____(ROLE_1)____, I,{____(NONCE_1)____}k(I,____(ROLE_1)____) );\n        recv_2(____(ROLE_1)____,I, {____(NONCE_1)____,____(ENCRYPTED_1)____}k(I,____(ROLE_1)____) );\n        send_3(I,____(ROLE_1)____, {____(ENCRYPTED_1)____}k(I,____(ROLE_1)____) );\n        recv_4(____(ROLE_1)____,I, {____(KEY_1)____,nr2,____(NONCE_1)____}k(I,____(ROLE_1)____) );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Niagree);\n        claim_I3(I,Secret, ____(KEY_1)____);\n        claim_I5(I,Empty, (Fresh,____(KEY_1)____));\n    }    \n    \n    role ____(ROLE_1)____\n    {\n        var ____(NONCE_1)____: Nonce;\n        fresh ____(ENCRYPTED_1)____,nr2: Nonce;\n        fresh ____(KEY_1)____: SessionKey;\n\n        recv_1(I,____(ROLE_1)____, I,{____(NONCE_1)____}k(I,____(ROLE_1)____) );\n        send_2(____(ROLE_1)____,I, {____(NONCE_1)____,____(ENCRYPTED_1)____}k(I,____(ROLE_1)____) );\n        recv_3(I,____(ROLE_1)____, {____(ENCRYPTED_1)____}k(I,____(ROLE_1)____) );\n        send_4(____(ROLE_1)____,I, {____(KEY_1)____,nr2,____(NONCE_1)____}k(I,____(ROLE_1)____) );\n        claim_R1(____(ROLE_1)____,Nisynch);\n        claim_R2(____(ROLE_1)____,Niagree);\n        claim_R3(____(ROLE_1)____,Secret, ____(KEY_1)____);\n        claim_R5(____(ROLE_1)____,Empty, (Fresh,____(KEY_1)____));\n    }\n}",
        "complete:": "# BAN modified Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewBAN.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n# \n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-Ban(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr,nr2: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,{ni}k(I,R) );\n        recv_2(R,I, {ni,nr}k(I,R) );\n        send_3(I,R, {nr}k(I,R) );\n        recv_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Niagree);\n        claim_I3(I,Secret, kir);\n        claim_I5(I,Empty, (Fresh,kir));\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr,nr2: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,{ni}k(I,R) );\n        send_2(R,I, {ni,nr}k(I,R) );\n        recv_3(I,R, {nr}k(I,R) );\n        send_4(R,I, {kir,nr2,ni}k(I,R) );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Niagree);\n        claim_R3(R,Secret, kir);\n        claim_R5(R,Empty, (Fresh,kir));\n    }\n}"
    },
    {
        "file": "SPDL-1/andrew-lowe-ban.spdl",
        "incomplete": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(____(ROLE_1)____,R)\n{\n    role ____(ROLE_1)____\n    {\n        fresh ni: Nonce;\n        var ____(NONCE_1)____: Nonce;\n        var ____(KEY_1)____: SessionKey;\n\n        send_1(____(ROLE_1)____,R, ____(ROLE_1)____,ni );\n        recv_2(R,____(ROLE_1)____, {ni,____(KEY_1)____,R}k(____(ROLE_1)____,R) );\n        send_3(____(ROLE_1)____,R, {ni}____(KEY_1)____ );\n        claim_I1(____(ROLE_1)____,Nisynch);\n        claim_I2(____(ROLE_1)____,Secret, ____(KEY_1)____);\n        claim_I3(____(ROLE_1)____,Empty, (Fresh,____(KEY_1)____));\n        recv_4(R,____(ROLE_1)____, ____(NONCE_1)____ );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh ____(NONCE_1)____: Nonce;\n        fresh ____(KEY_1)____: SessionKey;\n\n        recv_1(____(ROLE_1)____,R, ____(ROLE_1)____,ni );\n        send_2(R,____(ROLE_1)____, {ni,____(KEY_1)____,R}k(____(ROLE_1)____,R) );\n        recv_3(____(ROLE_1)____,R, {ni}____(KEY_1)____ );\n        send_4(R,____(ROLE_1)____, ____(NONCE_1)____ );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, ____(KEY_1)____);\n        claim_R3(R,Empty, (Fresh,____(KEY_1)____));\n    }\n}",
        "complete:": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}"
    },
    {
        "file": "SPDL-1/athena-breaker.spdl",
        "incomplete": "/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\tsend_!1(____(ROLE_1)____,R, {{____(ROLE_1)____,____(NONCE_1)____}pk(R)}pk(R) );\n\n\t\tclaim_i1(____(ROLE_1)____,Secret,____(NONCE_1)____);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar T:Ticket;\n\n\t\trecv_!1(____(ROLE_1)____,R, {T}pk(R) );\n\t\tsend_!2(R,____(ROLE_1)____, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information",
        "complete:": "/* \n * Athena breaker protocol\n */\n\n// PKI infrastructure\n\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\n// The protocol description\n\nprotocol abreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_!1(I,R, {{I,ni}pk(R)}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar T:Ticket;\n\n\t\trecv_!1(I,R, {T}pk(R) );\n\t\tsend_!2(R,I, T );\n\n\t}\n}\n\n// The agents in the system\n\n\n// An untrusted agent, with leaked information"
    },
    {
        "file": "SPDL-1/Authentication_CRCBAC.spdl",
        "incomplete": "hashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,____(ROLE_1)____)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var ____(NONCE_1)____:Nonce;secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,____(ROLE_1)____,e,AID,Tr,T1);\n\n        recv_2(____(ROLE_1)____,D,Npr,____(NONCE_1)____);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role ____(ROLE_1)____\n\n     {\n\n          fresh Npr,____(NONCE_1)____:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,____(ROLE_1)____,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (____(ROLE_1)____,D,Npr,____(NONCE_1)____);\n\n          claim(____(ROLE_1)____,Alive);\n\n          claim(____(ROLE_1)____,Weakagree);\n\n          claim(____(ROLE_1)____,Commit,D,Npr);\n\n          claim(____(ROLE_1)____,Niagree);\n\n          claim(____(ROLE_1)____,Nisynch);\n\n          claim(____(ROLE_1)____,Secret,Krs);\n\n          claim(____(ROLE_1)____,Secret,K);\n\n      }\n\n}",
        "complete:": "hashfunction H;/* Secure hash function */\n\nsecret XOR:Function;/* XOR operation */\n\nconst Concat: Function;/*Concatenation Function */\n\nconst Fresh: Function;\n\nsecret Krs,Ts,V;\n\nsecret ID,PW,z;\n\nmacro Vpr=H(XOR(z,Ts));\n\nmacro e=XOR(Krs,Concat(Vpr,N));\n\nmacro Npr=H(N);\n\nprotocol Protocol (D,GW)\n\n{\n\n    role D\n\n      {      \n\n        fresh T1,N,Tr:Nonce;\n\n        var T2:Nonce;secret AID,Vpr;\n\n        macro K=H(Concat(Krs,N));\n\n        send_1 (D,GW,e,AID,Tr,T1);\n\n        recv_2(GW,D,Npr,T2);\n\n        claim(D,Secret,PW);\n\n        claim(D,Alive);\n\n        claim(D,Weakagree);\n\n        claim(D,Commit,D,N);\n\n        claim(D,Niagree);\n\n        claim(D,Nisynch);\n\n        claim(D,Secret,Krs);\n\n        claim(D,Secret,K);\n\n      }\n\n    role GW\n\n     {\n\n          fresh Npr,T2:Nonce;\n\n          var Tr,N:Nonce;\n\n          var T1:Nonce;\n\n          secret AID,Vpr;\n\n          recv_1(D,GW,e,AID,Tr,T1);\n\n          macro K=H(Concat(Krs,N));\n\n          send_2 (GW,D,Npr,T2);\n\n          claim(GW,Alive);\n\n          claim(GW,Weakagree);\n\n          claim(GW,Commit,D,Npr);\n\n          claim(GW,Niagree);\n\n          claim(GW,Nisynch);\n\n          claim(GW,Secret,Krs);\n\n          claim(GW,Secret,K);\n\n      }\n\n}"
    },
    {
        "file": "SPDL-1/base.spdl",
        "incomplete": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, ____(NONCE_1)____, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, ____(NONCE_1)____)}sk(M);\nmacro Sc = {hash(____(ROLE_1)____, IDc, IDm, a, ____(NONCE_1)____, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, ____(NONCE_1)____, t)}sk(____(ROLE_1)____);\n\n\nprotocol BaseCaseProtocol(M, C, ____(ROLE_1)____)\n{\n\trole M\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, ____(NONCE_1)____, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_3 (____(ROLE_1)____, M, IDt, a, ____(NONCE_1)____, t, Sb);\n\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tvar t: Timestamp;\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\t/*\n\t\t* Receive transaction request from merchant\n\t\t*/\n\t\trecv_1 (M, C, IDm, a, ____(NONCE_1)____, Sm);\n\n\t\t/*\n\t\t* Send transaction confirmation to bank\n\t\t*/\n\t\tsend_2 (C, ____(ROLE_1)____, IDc, IDm, a, ____(NONCE_1)____, Sm, Sc);\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_4 (____(ROLE_1)____, C, IDt, a, ____(NONCE_1)____, t, Sb);\n\n\t\tclaim (C, Alive);\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\t/*\n\t\t* Receive transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_2 (C, ____(ROLE_1)____, IDc, IDm, a, ____(NONCE_1)____, Sm, Sc);\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_3 (____(ROLE_1)____, M, IDt, a, ____(NONCE_1)____, t, Sb);\n\t\tsend_4 (____(ROLE_1)____, C, IDt, a, ____(NONCE_1)____, t, Sb);\n\n\t\tclaim (____(ROLE_1)____, Alive);\n\t\tclaim (____(ROLE_1)____, Nisynch);\n\t\tclaim (____(ROLE_1)____, Niagree);\n\t}\n}",
        "complete:": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nhashfunction hash;\nusertype UID, Timestamp, Amount;\nconst a: Amount;\n\nconst IDm, IDc: UID;\n\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(B, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\n\nprotocol BaseCaseProtocol(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh r: Nonce;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Send transaction request to customer\n\t\t*/\n\t\tsend_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_3 (B, M, IDt, a, r, t, Sb);\n\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tvar t: Timestamp;\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction request from merchant\n\t\t*/\n\t\trecv_1 (M, C, IDm, a, r, Sm);\n\n\t\t/*\n\t\t* Send transaction confirmation to bank\n\t\t*/\n\t\tsend_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive payment confirmation from bank\n\t\t*/\n\t\trecv_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar r: Nonce;\n\n\t\t/*\n\t\t* Receive transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_2 (C, B, IDc, IDm, a, r, Sm, Sc);\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_3 (B, M, IDt, a, r, t, Sb);\n\t\tsend_4 (B, C, IDt, a, r, t, Sb);\n\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}"
    },
    {
        "file": "SPDL-1/BCNP-1.spdl",
        "incomplete": "/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(ENCRYPTED_1)____: Nonce;\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\tsend_Compromise(I,I, ____(ENCRYPTED_1)____);\n\n\t\tsend_1(I,____(ROLE_1)____, I, { ____(ENCRYPTED_1)____ }pk(____(ROLE_1)____) );\n\t\trecv_2(____(ROLE_1)____,I, ____(ROLE_1)____, { ____(NONCE_1)____ }pk(I) );\n\n\t\tclaim(I,SKR, xor( Expd( Ext(____(ENCRYPTED_1)____), I, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____), ____(ROLE_1)____, {____(NONCE_1)____}pk(I)),\n\t\t                  Expd( Ext(____(NONCE_1)____), I, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____), ____(ROLE_1)____, {____(NONCE_1)____}pk(I))\n\t\t                )\n\t\t     );\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\tsend_Compromise(____(ROLE_1)____,____(ROLE_1)____, ____(NONCE_1)____);\n\n\t\trecv_1(I,____(ROLE_1)____, I, { ____(ENCRYPTED_1)____ }pk(____(ROLE_1)____) );\n\t\tsend_2(____(ROLE_1)____,I, ____(ROLE_1)____, { ____(NONCE_1)____ }pk(I) );\n\n\t\tclaim(____(ROLE_1)____,SKR, xor( Expd( Ext(____(ENCRYPTED_1)____), I, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____), ____(ROLE_1)____, {____(NONCE_1)____}pk(I)),\n\t\t                  Expd( Ext(____(NONCE_1)____), I, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____), ____(ROLE_1)____, {____(NONCE_1)____}pk(I))\n\t\t                )\n\t\t     );\n\t}\n}",
        "complete:": "/* \n * BoydCliffNietoPaterson 2008\n *\n */\n\nhashfunction Expd,Ext;\nhashfunction xor;\n\n\nprotocol @xorhelper(H1,H2,H3)\n{\n\trole H1\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(H1,H1, xor(X,Y) );\n\t\tsend_!2(H1,H1, xor(Y,X) );\n\t}\n\trole H2\n\t{\n\t\tvar X,Y,Z: Ticket;\n\n\t\trecv_!3(H2,H2, xor(X,xor(Y,Z)) );\n\t\tsend_!4(H2,H2, xor(xor(X,Y),Z) );\n\t}\n\trole H3\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!5(H3,H3, X,xor(X,Y) );\n\t\tsend_!6(H3,H3, Y );\n\t}\n}\n\n// The protocol description\n\nprotocol BCNP-1(I,R)\n{\n\trole I\n\t{\n\t\tfresh Kap: Nonce;\n\t\tvar Kbp: Nonce;\n\n\t\tsend_Compromise(I,I, Kap);\n\n\t\tsend_1(I,R, I, { Kap }pk(R) );\n\t\trecv_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(I,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar Kap: Nonce;\n\t\tfresh Kbp: Nonce;\n\n\t\tsend_Compromise(R,R, Kbp);\n\n\t\trecv_1(I,R, I, { Kap }pk(R) );\n\t\tsend_2(R,I, R, { Kbp }pk(I) );\n\n\t\tclaim(R,SKR, xor( Expd( Ext(Kap), I, {Kap}pk(R), R, {Kbp}pk(I)),\n\t\t                  Expd( Ext(Kbp), I, {Kap}pk(R), R, {Kbp}pk(I))\n\t\t                )\n\t\t     );\n\t}\n}"
    },
    {
        "file": "SPDL-1/BKE-1.spdl",
        "incomplete": "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar ____(KEY_1)____: SessionKey;\n\n\t\tsend_1 (____(ROLE_1)____,R, { ni,____(ROLE_1)____ }pk(R) );\n\t\trecv_2 (R,____(ROLE_1)____, { hash(ni),____(NONCE_1)____,R,____(KEY_1)____ }pk(____(ROLE_1)____) );\n\t\tsend_3 (____(ROLE_1)____,R, { hash(____(NONCE_1)____) }____(KEY_1)____ );\n\t\tclaim_4 (____(ROLE_1)____, Secret, ____(KEY_1)____ );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh ____(KEY_1)____: SessionKey;\n\n\t\trecv_1 (____(ROLE_1)____,R, { ni,____(ROLE_1)____ }pk(R) );\n\t\tsend_2 (R,____(ROLE_1)____, { hash(ni),____(NONCE_1)____,R,____(KEY_1)____ }pk(____(ROLE_1)____) );\n\t\trecv_3 (____(ROLE_1)____,R, { hash(____(NONCE_1)____) }____(KEY_1)____ );\n\t\tclaim_7 (R, Secret, ____(KEY_1)____ );\n\t\t//claim_8 (R, Niagree );\n\t\t//claim_9 (R, Nisynch );\n\t}\n}",
        "complete:": "/* \n\tBilateral Key Exchange with Public Key protocol (BKEPK)\n*/\n\nusertype SessionKey;\n\nhashfunction hash;\n\nprotocol bke(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: SessionKey;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr) }kir );\n\t\tclaim_4 (I, Secret, kir );\n\t\t//claim_5 (I, Niagree );\n\t\t//claim_6 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: SessionKey;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(ni),nr,R,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr) }kir );\n\t\tclaim_7 (R, Secret, kir );\n\t\t//claim_8 (R, Niagree );\n\t\t//claim_9 (R, Nisynch );\n\t}\n}"
    },
    {
        "file": "SPDL-1/bkepk-ce-1.spdl",
        "incomplete": "/* \n\tBilateral Key Exchange with Public Key protocol (bkeCE)\n\n\tVersion from Corin/Etalle: An Improved Constraint-Based System for the Verification of Security Protocols.\n\tTried to stay as close as possible to compare timing results.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkeCE(____(ROLE_1)____,B)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,____(ROLE_1)____, B,{ ____(NONCE_1)____,B }pk(____(ROLE_1)____) );\n\t\tsend_2 (____(ROLE_1)____,B, { hash(____(NONCE_1)____),na,____(ROLE_1)____,kab }pk(B) );\n\t\trecv_3 (B,____(ROLE_1)____, { hash(na) }kab );\n\n\t\tclaim_A1 (____(ROLE_1)____, Secret, na);\n\t\tclaim_A2 (____(ROLE_1)____, Secret, ____(NONCE_1)____);\n\t}\n\n\trole B\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,____(ROLE_1)____, B,{ ____(NONCE_1)____,B }pk(____(ROLE_1)____) );\n\t\trecv_2 (____(ROLE_1)____,B, { hash(____(NONCE_1)____),na,____(ROLE_1)____,kab }pk(B) );\n\t\tsend_3 (B,____(ROLE_1)____, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, ____(NONCE_1)____);\n\t}\n\n}\n\nconst Alice,Bob,Eve;",
        "complete:": "/* \n\tBilateral Key Exchange with Public Key protocol (bkeCE)\n\n\tVersion from Corin/Etalle: An Improved Constraint-Based System for the Verification of Security Protocols.\n\tTried to stay as close as possible to compare timing results.\n*/\n\nusertype Key;\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\n\ninversekeys (pk,sk);\ninversekeys (hash,unhash);\n\nprotocol bkeCE(A,B)\n{\n\trole A\n\t{\n\t\tvar nb: Nonce;\n\t\tfresh na: Nonce;\n\t\tfresh kab: Key;\n\n\t\trecv_1 (B,A, B,{ nb,B }pk(A) );\n\t\tsend_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\trecv_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_A1 (A, Secret, na);\n\t\tclaim_A2 (A, Secret, nb);\n\t}\n\n\trole B\n\t{\n\t\tfresh nb: Nonce;\n\t\tvar na: Nonce;\n\t\tvar kab: Key;\n\n\t\tsend_1 (B,A, B,{ nb,B }pk(A) );\n\t\trecv_2 (A,B, { hash(nb),na,A,kab }pk(B) );\n\t\tsend_3 (B,A, { hash(na) }kab );\n\n\t\tclaim_B1 (B, Secret, na);\n\t\tclaim_B2 (B, Secret, nb);\n\t}\n\n}\n\nconst Alice,Bob,Eve;"
    },
    {
        "file": "SPDL-1/boyd.spdl",
        "incomplete": "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,____(ROLE_1)____, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,____(ROLE_1)____), m(ni, m(ks,ni,____(NONCE_1)____)), ____(NONCE_1)____ );\n\t\tsend_4 (I,R, m(____(NONCE_1)____, m(ks,ni,____(NONCE_1)____)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,____(NONCE_1)____) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (____(ROLE_1)____,R, { I,R, ks }k(I,____(ROLE_1)____), { I,R, ks }k(R,____(ROLE_1)____), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,____(ROLE_1)____), m(ni, m(ks,ni,____(NONCE_1)____)), ____(NONCE_1)____ );\n\t\trecv_4 (I,R, m(____(NONCE_1)____, m(ks,ni,____(NONCE_1)____)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,____(NONCE_1)____));\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ni,____(NONCE_1)____: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,____(ROLE_1)____, I,R, ni );\n\t\tsend_2 (____(ROLE_1)____,R, { I,R, ks }k(I,____(ROLE_1)____), { I,R, ks }k(R,____(ROLE_1)____), ni );\n\t}\n}",
        "complete:": "usertype Sessionkey;\nusertype Macseed;\nconst m: Function;\nsecret unm: Function;\nconst f: Function;\n\ninversekeys (m, unm);\n\n/*\n * Boyd key agreement\n *\n * Boyd & Mathuria: Protocols for authentication and key establishment\n * (2003) p. 101\n *\n * Note that MAC_ks(x) has been interpreted as MAC(x,ks); this\n * assumption causes some possible false attacks.\n */\n\nprotocol boyd(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\tsend_1 (I,S, I,R, ni );\n\t\trecv_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\tsend_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_6 (I, Secret, m(ks,ni,nr) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tvar ks: Macseed;\n\n\t\trecv_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t\tsend_3 (R,I, { I,R, ks }k(I,S), m(ni, m(ks,ni,nr)), nr );\n\t\trecv_4 (I,R, m(nr, m(ks,ni,nr)) );\n\n\t\tclaim_10 (R, Secret, m(ks,ni,nr));\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tfresh ks: Macseed;\n\n\t\trecv_1 (I,S, I,R, ni );\n\t\tsend_2 (S,R, { I,R, ks }k(I,S), { I,R, ks }k(R,S), ni );\n\t}\n}"
    },
    {
        "file": "SPDL-1/CapabilityRevocation_CRCBAC.spdl",
        "incomplete": "hashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, ____(ROLE_1)____) \n\n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var ____(NONCE_1)____:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, ____(ROLE_1)____, M);\n\n    recv_2(____(ROLE_1)____, Da, XOR(Concat(IDa,Resp),h(SKa)),____(NONCE_1)____);\n\n    claim(Da, Secret, SKa);\n\n    claim(Da, Alive);\n\n    claim(Da, Weakagree);\n\n    claim(Da, Niagree);\n\n    claim(Da, Nisynch);\n\n}\n\nrole ____(ROLE_1)____ {\n\n    fresh ____(NONCE_1)____:Nonce; \n\n    var T1:Nonce; \n\n    secret IDa;\n\n    recv_1(Da, ____(ROLE_1)____, M);\n\n    macro M' = XOR(M,h(SKa));\n\n    macro rgb=getRoles(IDb,ctxb);\n\n    macro rga=getRoles(IDa,ctxa);\n\n    macro ver = Roleheirarchy(rgb,rga);\n\n    macro Cb= getCapabilities(rgb);\n\n    macro rgb =sub(rgb,c');\n\n    send_2 (____(ROLE_1)____, Da, XOR(Concat(IDa,Resp),h(SKa)),____(NONCE_1)____);\n\n    claim(____(ROLE_1)____, Alive);\n\n    claim(____(ROLE_1)____, Weakagree);\n\n    claim(____(ROLE_1)____, Niagree);\n\n    claim(____(ROLE_1)____, Nisynch);\n\n    claim(____(ROLE_1)____, Secret, SKa);\n\n} \n\n}",
        "complete:": "hashfunction h; /* Secure hash function */\n\nsecret XOR:Function; /* XOR operation */\n\nconst Concat: Function; /*Concatenation Function */\n\nconst Fresh: Function;\n\nconst Con:Function;\n\nconst getRoles:Function;\n\nconst getcapabilities:Function;\n\nconst sub:Function;\n\nconst enforce:Function;\n\nconst rgb,ctxa,ctxb,IDb,c';\n\nmacro Resp = enforce(rgb,c');\n\nsecret SKa;\n\nprotocol CapabilityRevoke (Da, GW) \n\n{\n\nrole Da {\n\n    fresh T1:Nonce;\n\n    var T2:Nonce; const IDa;\n\n    macro M=XOR(Concat(IDa,ctxa,c',IDb,ctxb,T1),h(SKa));\n\n    send_1 (Da, GW, M);\n\n    recv_2(GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(Da, Secret, SKa);\n\n    claim(Da, Alive);\n\n    claim(Da, Weakagree);\n\n    claim(Da, Niagree);\n\n    claim(Da, Nisynch);\n\n}\n\nrole GW {\n\n    fresh T2:Nonce; \n\n    var T1:Nonce; \n\n    secret IDa;\n\n    recv_1(Da, GW, M);\n\n    macro M' = XOR(M,h(SKa));\n\n    macro rgb=getRoles(IDb,ctxb);\n\n    macro rga=getRoles(IDa,ctxa);\n\n    macro ver = Roleheirarchy(rgb,rga);\n\n    macro Cb= getCapabilities(rgb);\n\n    macro rgb =sub(rgb,c');\n\n    send_2 (GW, Da, XOR(Concat(IDa,Resp),h(SKa)),T2);\n\n    claim(GW, Alive);\n\n    claim(GW, Weakagree);\n\n    claim(GW, Niagree);\n\n    claim(GW, Nisynch);\n\n    claim(GW, Secret, SKa);\n\n} \n\n}"
    },
    {
        "file": "SPDL-1/carkey-ni.spdl",
        "incomplete": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tconst ____(NONCE_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {____(ROLE_1)____,____(NONCE_1)____}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\tread_1(I,____(ROLE_1)____, {____(ROLE_1)____,____(NONCE_1)____}sk(I) );\n\t\tclaim_2(____(ROLE_1)____,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.____(ROLE_1)____(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.____(ROLE_1)____(Agent,Agent);",
        "complete:": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol carkeyni(I,R)\n{\n\trole I\n\t{\n\t\tconst ni: Nonce;\n\n\t\tsend_1(I,R, {R,ni}sk(I) );\n\t\tclaim_3(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\tread_1(I,R, {R,ni}sk(I) );\n\t\tclaim_2(R,Nisynch);\n\t}\n}\n\nconst Alice,Bob,Eve: Agent;\n\nuntrusted Eve;\nconst nc: Nonce;\ncompromised sk(Eve);\n\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);\nrun carkeyni.I(Agent,Agent);\nrun carkeyni.R(Agent,Agent);"
    },
    {
        "file": "SPDL-1/ccitt509-ban.spdl",
        "incomplete": "usertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(____(ROLE_1)____,R, ____(ROLE_1)____,{____(NONCE_1)____, R, xi, {yi}pk(R) }sk(____(ROLE_1)____) );\n\t\trecv_2(R,____(ROLE_1)____, R,{nr, ____(ROLE_1)____, ____(NONCE_1)____, xr, {yr}pk(____(ROLE_1)____) }sk(R) );\n\t\tsend_3(____(ROLE_1)____,R, ____(ROLE_1)____,{R,nr}sk(____(ROLE_1)____) );\n\n\t\tclaim_4(____(ROLE_1)____,Secret,yi);\n\t\tclaim_5(____(ROLE_1)____,Secret,yr);\n\t\tclaim_6(____(ROLE_1)____,Nisynch);\n\t\tclaim_7(____(ROLE_1)____,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar xi,yi: Data;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh yr,xr: Data;\n\n\t\trecv_1(____(ROLE_1)____,R, ____(ROLE_1)____,{____(NONCE_1)____, R, xi, {yi}pk(R) }sk(____(ROLE_1)____) );\n\t\tsend_2(R,____(ROLE_1)____, R,{nr, ____(ROLE_1)____, ____(NONCE_1)____, xr, {yr}pk(____(ROLE_1)____) }sk(R) );\n\t\trecv_3(____(ROLE_1)____,R, ____(ROLE_1)____,{R,nr}sk(____(ROLE_1)____) );\n\n\t\tclaim_8(R,Secret,yi);\n\t\tclaim_9(R,Secret,yr);\n\t\tclaim_10(R,Nisynch);\n\t\tclaim_11(R,Niagree);\n\t}\n}\n\n\nconst de: Data;",
        "complete:": "usertype Data;\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol ccitt509(I,R)\n{\n\trole I\n\t{\n\t\tfresh xi,yi: Data;\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar yr,xr: Data;\n\n\t\tsend_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\trecv_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\tsend_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_4(I,Secret,yi);\n\t\tclaim_5(I,Secret,yr);\n\t\tclaim_6(I,Nisynch);\n\t\tclaim_7(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar xi,yi: Data;\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh yr,xr: Data;\n\n\t\trecv_1(I,R, I,{ni, R, xi, {yi}pk(R) }sk(I) );\n\t\tsend_2(R,I, R,{nr, I, ni, xr, {yr}pk(I) }sk(R) );\n\t\trecv_3(I,R, I,{R,nr}sk(I) );\n\n\t\tclaim_8(R,Secret,yi);\n\t\tclaim_9(R,Secret,yr);\n\t\tclaim_10(R,Nisynch);\n\t\tclaim_11(R,Niagree);\n\t}\n}\n\n\nconst de: Data;"
    },
    {
        "file": "SPDL-1/cotes_de_porc-v0.spdl",
        "incomplete": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh ____(ENCRYPTED_1)____: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(____(ROLE_1)____, R, ____(ROLE_1)____, {____(ENCRYPTED_1)____}pk(R), {sec}pk(R), h(____(ROLE_1)____,sec));\n\t\trecv_2(R, ____(ROLE_1)____, {n2}pk(____(ROLE_1)____), h(sec,____(ENCRYPTED_1)____,n2));\n\t\tsend_3(____(ROLE_1)____, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(____(ROLE_1)____, R, ____(ROLE_1)____, {____(ENCRYPTED_1)____}pk(R), {sec}pk(R), h(____(ROLE_1)____,sec));\n\t\tsend_2(R, ____(ROLE_1)____, {n2}pk(____(ROLE_1)____), h(sec,____(ENCRYPTED_1)____,n2));\n\t\trecv_3(____(ROLE_1)____, R, n2);\n\t}\n}",
        "complete:": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\trecv_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, I, {n1}pk(R), {sec}pk(R), h(I,sec));\n\t\tsend_2(R, I, {n2}pk(I), h(sec,n1,n2));\n\t\trecv_3(I, R, n2);\n\t}\n}"
    },
    {
        "file": "SPDL-1/DHKE-1.spdl",
        "incomplete": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, ____(NONCE_1)____ );\n\n\t\tsend_1(I,____(ROLE_1)____,  g1(____(NONCE_1)____),____(ROLE_1)____,         { g1(____(NONCE_1)____),____(ROLE_1)____ }sk(I)        );\n\t\trecv_2(____(ROLE_1)____,I,  g1(____(NONCE_1)____),beta,i,I,  { g1(____(NONCE_1)____),beta,i,I }sk(____(ROLE_1)____) );\n\t\tsend_!3(I,____(ROLE_1)____,  h1( g2(beta,____(NONCE_1)____ ) ) );\n\n\t\tclaim(I,SKR, g2(beta,____(NONCE_1)____) );\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(____(ROLE_1)____,____(ROLE_1)____, y,i );\n\n\t\trecv_1(I,____(ROLE_1)____,  alpha,____(ROLE_1)____,          { alpha,____(ROLE_1)____ }sk(I)         );\n\t\tsend_2(____(ROLE_1)____,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(____(ROLE_1)____) );\n\t\trecv_!3(I,____(ROLE_1)____,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(____(ROLE_1)____,SKR, g2(alpha,y) );\n\t}\n}",
        "complete:": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/encryption2.spdl",
        "incomplete": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nsecret k: Function;\n\nhashfunction hash, MAC, KDF;\nusertype UID, Timestamp, Amount;\n\nmacro Kcm = KDF(k(M, C), Nm, ____(NONCE_1)____);\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(____(ROLE_1)____, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(____(ROLE_1)____);\n\nprotocol EncryptionProtocol2(M, C, ____(ROLE_1)____)\n{\n\trole M\n\t{\n\t\tfresh a: Amount;\n\t\tfresh Nm, r: Nonce;\n\t\tfresh IDm: UID;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar IDc: UID;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\n\t\tsend_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\trecv_2 (C, M, ____(NONCE_1)____, MAC(k(M, C), M, C, Nm, ____(NONCE_1)____));\n\n\t\t/*\n\t\t* Send encrypted transaction request to customer\n\t\t*/\n\t\tsend_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_5 (____(ROLE_1)____,M, { IDt, a, r, t, Sb }k(M,____(ROLE_1)____) );\n\n\t\tclaim (M, Secret, IDm);\n\t\tclaim (M, Secret, a);\n\t\tclaim (M, Secret, r);\n\t\tclaim (M, Secret, Kcm);\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh IDc: UID;\n\t\tvar IDm: UID;\n\t\tvar Nm, r: Nonce;\n\t\tvar t: Timestamp;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Authenticated key exchange with the merchant\n\t\t*/ \n\n\t\trecv_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\tsend_2 (C, M, ____(NONCE_1)____, MAC(k(M, C), M, C, Nm, ____(NONCE_1)____));\n\n\t\t/*\n\t\t* Receive encrypted transaction request from merchant\n\t\t*/\n\t\trecv_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Send encrypted transaction confirmation to bank\n\t\t*/\n\t\tsend_4 (C, ____(ROLE_1)____, { IDc, IDm, a, r, Sm, Sc }k(C,____(ROLE_1)____) );\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_6 (____(ROLE_1)____, C, { IDt, a, r, t, Sb }k(C,____(ROLE_1)____) );\n\n\t\tclaim (C, Secret, Kcm);\n\t\tclaim (C, Secret, IDc);\n\t\tclaim (C, Secret, Sc);\n\t\tclaim (C, Alive);\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar IDc, IDm: UID;\n\t\tvar r: Nonce;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Receive encrypted transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_4 (C, ____(ROLE_1)____, { IDc, IDm, a, r, Sm, Sc }k(C,____(ROLE_1)____) );\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send encrypted payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_5 (____(ROLE_1)____, M, { IDt, a, r, t, Sb }k(M, ____(ROLE_1)____) );\n\t\tsend_6 (____(ROLE_1)____, C, { IDt, a, r, t, Sb }k(C, ____(ROLE_1)____) );\n\n\t\tclaim (____(ROLE_1)____, Secret, IDt);\n\t\tclaim (____(ROLE_1)____, Secret, t);\n\t\tclaim (____(ROLE_1)____, Secret, Sb);\n\t\tclaim (____(ROLE_1)____, Alive);\n\t\tclaim (____(ROLE_1)____, Nisynch);\n\t\tclaim (____(ROLE_1)____, Niagree);\n\t}\n}",
        "complete:": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nsecret k: Function;\n\nhashfunction hash, MAC, KDF;\nusertype UID, Timestamp, Amount;\n\nmacro Kcm = KDF(k(M, C), Nm, Nc);\nmacro IDt = hash(a, r, IDc, IDm);\nmacro Sm = {hash(C, IDm, a, r)}sk(M);\nmacro Sc = {hash(B, IDc, IDm, a, r, Sm)}sk(C);\nmacro Sb = {hash(M, C, IDt, a, r, t)}sk(B);\n\nprotocol EncryptionProtocol2(M, C, B)\n{\n\trole M\n\t{\n\t\tfresh a: Amount;\n\t\tfresh Nm, r: Nonce;\n\t\tfresh IDm: UID;\n\t\tvar Nc: Nonce;\n\t\tvar IDc: UID;\n\t\tvar t: Timestamp;\n\n\t\t/*\n\t\t* Authenticated key exchange with the customer\n\t\t*/ \n\n\t\tsend_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\trecv_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Send encrypted transaction request to customer\n\t\t*/\n\t\tsend_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_5 (B,M, { IDt, a, r, t, Sb }k(M,B) );\n\n\t\tclaim (M, Secret, IDm);\n\t\tclaim (M, Secret, a);\n\t\tclaim (M, Secret, r);\n\t\tclaim (M, Secret, Kcm);\n\t\tclaim (M, Alive);\n\t\tclaim (M, Nisynch);\n\t\tclaim (M, Niagree);\n\t}\n\n\trole C\n\t{\n\t\tfresh Nc: Nonce;\n\t\tfresh IDc: UID;\n\t\tvar IDm: UID;\n\t\tvar Nm, r: Nonce;\n\t\tvar t: Timestamp;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Authenticated key exchange with the merchant\n\t\t*/ \n\n\t\trecv_1 (M, C, Nm, MAC(k(M, C), M, C, Nm));\n\t\tsend_2 (C, M, Nc, MAC(k(M, C), M, C, Nm, Nc));\n\n\t\t/*\n\t\t* Receive encrypted transaction request from merchant\n\t\t*/\n\t\trecv_3 (M, C, { IDm, a, r, Sm }Kcm );\n\n\t\t/*\n\t\t* Send encrypted transaction confirmation to bank\n\t\t*/\n\t\tsend_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\t/*\n\t\t* Claim non-injective synch and agreement before receiving the last message to prevent Scyther from flagging redirection of send_3 to C as an attack\n\t\t*/\n\t\tclaim (C, Nisynch);\n\t\tclaim (C, Niagree);\n\n\t\t/*\n\t\t* Receive encrypted payment confirmation from bank\n\t\t*/\n\t\trecv_6 (B, C, { IDt, a, r, t, Sb }k(C,B) );\n\n\t\tclaim (C, Secret, Kcm);\n\t\tclaim (C, Secret, IDc);\n\t\tclaim (C, Secret, Sc);\n\t\tclaim (C, Alive);\n\t}\n\n\trole B\n\t{\n\t\tvar IDc, IDm: UID;\n\t\tvar r: Nonce;\n\t\tvar a: Amount;\n\n\t\t/*\n\t\t* Receive encrypted transaction confirmation/payment request from customer\n\t\t*/\n\t\trecv_4 (C, B, { IDc, IDm, a, r, Sm, Sc }k(C,B) );\n\n\t\tfresh t: Timestamp;\n\n\t\t/*\n\t\t* Send encrypted payment confirmations to merchant and customer\n\t\t*/\n\t\tsend_5 (B, M, { IDt, a, r, t, Sb }k(M, B) );\n\t\tsend_6 (B, C, { IDt, a, r, t, Sb }k(C, B) );\n\n\t\tclaim (B, Secret, IDt);\n\t\tclaim (B, Secret, t);\n\t\tclaim (B, Secret, Sb);\n\t\tclaim (B, Alive);\n\t\tclaim (B, Nisynch);\n\t\tclaim (B, Niagree);\n\t}\n}"
    },
    {
        "file": "SPDL-1/en_y-v0.spdl",
        "incomplete": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\tsend_1(I, ____(ROLE_1)____, {sec, I}pk(____(ROLE_1)____), h(sec), {n1}pk(____(ROLE_1)____));\n\t\trecv_2(____(ROLE_1)____, I, {____(NONCE_1)____, ____(ROLE_1)____}pk(I), n1);\n\t\tsend_3(I, ____(ROLE_1)____, ____(NONCE_1)____);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(I, ____(ROLE_1)____, {sec, I}pk(____(ROLE_1)____), h(sec), {n1}pk(____(ROLE_1)____));\n\t\tsend_2(____(ROLE_1)____, I, {____(NONCE_1)____, ____(ROLE_1)____}pk(I), n1);\n\t\trecv_3(I, ____(ROLE_1)____, ____(NONCE_1)____);\n\t}\n}",
        "complete:": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tfresh n1: Nonce;\n\t\tvar n2: Nonce;\n\n\t\tsend_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\trecv_2(R, I, {n2, R}pk(I), n1);\n\t\tsend_3(I, R, n2);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tvar n1: Nonce;\n\t\tfresh n2: Nonce;\n\n\t\trecv_1(I, R, {sec, I}pk(R), h(sec), {n1}pk(R));\n\t\tsend_2(R, I, {n2, R}pk(I), n1);\n\t\trecv_3(I, R, n2);\n\t}\n}"
    },
    {
        "file": "SPDL-1/exchange-hash.spdl",
        "incomplete": "/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\n\n// Protocol description\n\nprotocol protocol2(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (____(ROLE_1)____,R, { ____(NONCE_1)____,____(ROLE_1)____ }pk(R) );\n\t\trecv_2 (R,____(ROLE_1)____, { hash(kir,____(NONCE_1)____,R),nr,kir }pk(____(ROLE_1)____) );\n\t\tsend_3 (____(ROLE_1)____,R, { hash(nr,____(NONCE_1)____) }kir );\n\t\tclaim_i1 (____(ROLE_1)____, Secret, kir );\n\t\tclaim_i2 (____(ROLE_1)____, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Key;\n\n\t\trecv_1 (____(ROLE_1)____,R, { ____(NONCE_1)____,____(ROLE_1)____ }pk(R) );\n\t\tsend_2 (R,____(ROLE_1)____, { hash(kir,____(NONCE_1)____,R),nr,kir }pk(____(ROLE_1)____) );\n\t\trecv_3 (____(ROLE_1)____,R, { hash(nr,____(NONCE_1)____) }kir );\n\t\tclaim_r1 (R, Secret, kir );\n\t\tclaim_r2 (R, Nisynch );\n\t}\n}",
        "complete:": "/* \n   A key exchange protocol\n*/\n\n// Hash function: nobody knows the inverse\n\nhashfunction hash;\n\n// User type declaration\n\nusertype Key;\n\n// Protocol description\n\nprotocol protocol2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Key;\n\n\t\tsend_1 (I,R, { ni,I }pk(R) );\n\t\trecv_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\tsend_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_i1 (I, Secret, kir );\n\t\tclaim_i2 (I, Nisynch );\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Key;\n\n\t\trecv_1 (I,R, { ni,I }pk(R) );\n\t\tsend_2 (R,I, { hash(kir,ni,R),nr,kir }pk(I) );\n\t\trecv_3 (I,R, { hash(nr,ni) }kir );\n\t\tclaim_r1 (R, Secret, kir );\n\t\tclaim_r2 (R, Nisynch );\n\t}\n}"
    },
    {
        "file": "SPDL-1/five-run-bound.spdl",
        "incomplete": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,____(ROLE_1)____)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,____(ROLE_1)____, ni );\n\t\tsend_!2 (____(ROLE_1)____,I, { ni }sk(____(ROLE_1)____) );\n\t\trecv_!3 (I,____(ROLE_1)____, {{{ {____(NONCE_1)____}pk(____(ROLE_1)____) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (____(ROLE_1)____,I, {k2}____(NONCE_1)____ );\n\n\t\tclaim_6 (____(ROLE_1)____, Secret, k2);\n\t}\n}",
        "complete:": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol r5bound(I,R)\n{\n\trole R\n\t{\n\t\tvar k1: Nonce;\n\t\tvar ni: Nonce;\n\t\tfresh k2: Nonce;\n\n\t\trecv_!1 (I,R, ni );\n\t\tsend_!2 (R,I, { ni }sk(R) );\n\t\trecv_!3 (I,R, {{{ {k1}pk(R) }sk(I)}sk(I)}sk(I) );\n\t\tsend_!4 (R,I, {k2}k1 );\n\n\t\tclaim_6 (R, Secret, k2);\n\t}\n}"
    },
    {
        "file": "SPDL-1/Fortified-Chain2.spdl",
        "incomplete": "const E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\n\nprotocol Fortified-Chain2(DeviceA,____(ROLE_1)____,DeviceB)\n{\nrole DeviceA {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh ____(NONCE_1)____:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUa:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\nrecv_!2(____(ROLE_1)____,DeviceA,P1);\n\nrecv_!4(DeviceB,DeviceA,Q1);\n\nmacro V0 = E(PUedge,H(IDdev));\nmacro Temp = H(RIa);\nmacro Temp1 = E(PRa,Temp);\nmacro DIsig = APN(Temp1,RIa);\nmacro V1 = E(PUb,____(NONCE_1)____,MATdiv,IDa,DIsig);\nmacro V2 = D(PRa,SessionKey,IDb,DIsigb,Timestamp);\nmacro V3 = E(SessionKey,msg);\nmacro V4 =  D(PRa,IDa,RIa,GIid,SIid,MATdiv);\n\nsend_!1(DeviceA,____(ROLE_1)____,V0);\nsend_!5(DeviceA,DeviceB,V1,V3);\nclaim_DeviceA2(DeviceA,Secret,SessionKey);\nclaim_DeviceA3(DeviceA,Niagree);\nclaim_DeviceA4(DeviceA, Nisynch);\n}\nrole ____(ROLE_1)____ {\nfresh PRedge,PUedge,PUa,PUb:key;\nfresh RNhc,MATdiv,GIid,SIid:Nonce;\nconst IDhc,RIa,IDa,RIa1,Hdev,MATdivb,MATdiv,RIb,IDb;\nconst P0,P1,P2;\nconst IDdev;\nrecv_!1(DeviceA,____(ROLE_1)____,V0);\n\nmacro P0 = D(PRedge,H(IDdev));\nmacro Hdev = H(IDdev);\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\nmacro RIa = H(RIa1);\nmacro IDa = XOR(RIa,Hdev);\nmacro  P1 = E(PUa,IDa,RIa,GIid,SIid,MATdiv);\nmacro P2 = E(PUb,IDb,RIb,GIid,SIid,MATdivb);\nsend_!2(____(ROLE_1)____,DeviceA,P1);\nsend_!3(____(ROLE_1)____,DeviceB,P2);\nclaim_Edge2(____(ROLE_1)____,Secret,PRedge);\nclaim_Edge3(____(ROLE_1)____,Niagree);\nclaim_Edge4(____(ROLE_1)____,Nisynch);\n}\n\nrole DeviceB {\nfresh PRb,PUedge,PUa,PUb,DIsigb:key;\nfresh RNb:Nonce;\nconst IDdevb,DIsigb,MATdivb,Q1,Q2,Q3,Q4,MATdivb,MATdiv,IDb;\nfresh RIb,RIa,RNb:Nonce;\nconst Temp2,Temp3,msg,____(NONCE_1)____;\nfresh SessionKey,Timestamp:key;\nrecv_!3(____(ROLE_1)____,DeviceB,P2);\n\nrecv_!5(DeviceA,DeviceB,V1,V3);\n\n\nmacro Temp3 = D(PUa,DIsig);\n\nmacro Temp2 = H(RIa); \n\n\nmacro Q2 = D(PRb,IDb,RIb,GIid,SIid,MATdivb);\nmacro Q3 = D(PUb,____(NONCE_1)____,MATdiv,IDa,DIsig);\nmatch(MATdiv,MATdivb);\nmatch(Temp2,Temp3);\nmacro SessionKey = POW(____(NONCE_1)____,RNb);\nmacro Q1 = E(PUa,SessionKey,IDb,DIsigb,Timestamp);\nmacro Q4 = D(SessionKey,msg);\nsend_!4(DeviceB,DeviceA,Q1);\nclaim_DeviceB2(DeviceB,Secret,msg);\nclaim_DeviceB3(DeviceB,Niagree);\nclaim_DeviceB4(DeviceB, Nisynch);\n}\n}",
        "complete:": "const E:Function;\nconst D:Function;\nhashfunction H;\nconst XOR:Function;\nconst POW:Function;\nusertype key;\nconst APN:Function;\nconst RIa,RIb,PUa,PUb,PUedge,IDdev,IDhc,RNhc,PRa,DIsigb,SIid,GIid,Q1,V1,V3,IDa;\n\nconst Hdev,RIa1,RIa;\n\nmacro Hdev = H(IDdev);\n\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\n\nmacro RIa = H(RIa1);\n\n\nprotocol Fortified-Chain2(DeviceA,Edge,DeviceB)\n{\nrole DeviceA {\nfresh RN:Nonce;\nconst IDdev,DIsig,MATdiv,IDa;\nfresh RNa:Nonce;\nconst msg,DIsigb,P1,RIa,PRa,IDa;\nconst Temp,Temp1;\nfresh PRa,PUedge,PUa:key;\nfresh SessionKey,Timestamp:key;\nconst V0,V1,V2,V3,V4;\nrecv_!2(Edge,DeviceA,P1);\n\nrecv_!4(DeviceB,DeviceA,Q1);\n\nmacro V0 = E(PUedge,H(IDdev));\nmacro Temp = H(RIa);\nmacro Temp1 = E(PRa,Temp);\nmacro DIsig = APN(Temp1,RIa);\nmacro V1 = E(PUb,RNa,MATdiv,IDa,DIsig);\nmacro V2 = D(PRa,SessionKey,IDb,DIsigb,Timestamp);\nmacro V3 = E(SessionKey,msg);\nmacro V4 =  D(PRa,IDa,RIa,GIid,SIid,MATdiv);\n\nsend_!1(DeviceA,Edge,V0);\nsend_!5(DeviceA,DeviceB,V1,V3);\nclaim_DeviceA2(DeviceA,Secret,SessionKey);\nclaim_DeviceA3(DeviceA,Niagree);\nclaim_DeviceA4(DeviceA, Nisynch);\n}\nrole Edge {\nfresh PRedge,PUedge,PUa,PUb:key;\nfresh RNhc,MATdiv,GIid,SIid:Nonce;\nconst IDhc,RIa,IDa,RIa1,Hdev,MATdivb,MATdiv,RIb,IDb;\nconst P0,P1,P2;\nconst IDdev;\nrecv_!1(DeviceA,Edge,V0);\n\nmacro P0 = D(PRedge,H(IDdev));\nmacro Hdev = H(IDdev);\nmacro RIa1 = XOR(RNhc,Hdev,IDhc);\nmacro RIa = H(RIa1);\nmacro IDa = XOR(RIa,Hdev);\nmacro  P1 = E(PUa,IDa,RIa,GIid,SIid,MATdiv);\nmacro P2 = E(PUb,IDb,RIb,GIid,SIid,MATdivb);\nsend_!2(Edge,DeviceA,P1);\nsend_!3(Edge,DeviceB,P2);\nclaim_Edge2(Edge,Secret,PRedge);\nclaim_Edge3(Edge,Niagree);\nclaim_Edge4(Edge,Nisynch);\n}\n\nrole DeviceB {\nfresh PRb,PUedge,PUa,PUb,DIsigb:key;\nfresh RNb:Nonce;\nconst IDdevb,DIsigb,MATdivb,Q1,Q2,Q3,Q4,MATdivb,MATdiv,IDb;\nfresh RIb,RIa,RNb:Nonce;\nconst Temp2,Temp3,msg,RNa;\nfresh SessionKey,Timestamp:key;\nrecv_!3(Edge,DeviceB,P2);\n\nrecv_!5(DeviceA,DeviceB,V1,V3);\n\n\nmacro Temp3 = D(PUa,DIsig);\n\nmacro Temp2 = H(RIa); \n\n\nmacro Q2 = D(PRb,IDb,RIb,GIid,SIid,MATdivb);\nmacro Q3 = D(PUb,RNa,MATdiv,IDa,DIsig);\nmatch(MATdiv,MATdivb);\nmatch(Temp2,Temp3);\nmacro SessionKey = POW(RNa,RNb);\nmacro Q1 = E(PUa,SessionKey,IDb,DIsigb,Timestamp);\nmacro Q4 = D(SessionKey,msg);\nsend_!4(DeviceB,DeviceA,Q1);\nclaim_DeviceB2(DeviceB,Secret,msg);\nclaim_DeviceB3(DeviceB,Niagree);\nclaim_DeviceB4(DeviceB, Nisynch);\n}\n}"
    },
    {
        "file": "SPDL-1/fourway-HSDDM05.spdl",
        "incomplete": "# 1 \"fourway-HSDDM05.cpp\"\n# 1 \"<built-in>\"\n# 1 \"<command line>\"\n# 1 \"fourway-HSDDM05.cpp\"\n# 10 \"fourway-HSDDM05.cpp\"\nusertype Params, String;\n\nconst hash: Function;\nsecret unhash: Function;\ninversekeys(hash,unhash);\nsecret pmk: Function;\n\nconst msg1,msg2,msg3,msg4: String;\n\nconst Alice, Bob, Eve: Agent;\n\nprotocol fourway(____(ROLE_1)____,Y)\n{\n        role ____(ROLE_1)____\n        {\n                fresh ____(NONCE_1)____: Nonce;\n                var y: Nonce;\n\n                send_1( ____(ROLE_1)____,Y, ____(NONCE_1)____,msg1 );\n                recv_2( Y,____(ROLE_1)____, y,msg2,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),y,msg2 ) );\n                send_3( ____(ROLE_1)____,Y, ____(NONCE_1)____,msg3,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),____(NONCE_1)____,msg3 ) );\n                recv_4( Y,____(ROLE_1)____, msg4,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),msg4 ) );\n\n                claim_X1( ____(ROLE_1)____, Secret, hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ) );\n                claim_X2( ____(ROLE_1)____, Niagree );\n        }\n\n        role Y\n        {\n                var ____(NONCE_1)____: Nonce;\n                fresh y: Nonce;\n\n                recv_1( ____(ROLE_1)____,Y, ____(NONCE_1)____,msg1 );\n                send_2( Y,____(ROLE_1)____, y,msg2,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),y,msg2 ) );\n                recv_3( ____(ROLE_1)____,Y, ____(NONCE_1)____,msg3,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),____(NONCE_1)____,msg3 ) );\n                send_4( Y,____(ROLE_1)____, msg4,hash( hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ),msg4 ) );\n\n                claim_Y1( Y, Secret, hash( pmk(____(ROLE_1)____,Y),____(NONCE_1)____,y ) );\n                claim_Y2( Y, Niagree );\n        }\n}",
        "complete:": "# 1 \"fourway-HSDDM05.cpp\"\n# 1 \"<built-in>\"\n# 1 \"<command line>\"\n# 1 \"fourway-HSDDM05.cpp\"\n# 10 \"fourway-HSDDM05.cpp\"\nusertype Params, String;\n\nconst hash: Function;\nsecret unhash: Function;\ninversekeys(hash,unhash);\nsecret pmk: Function;\n\nconst msg1,msg2,msg3,msg4: String;\n\nconst Alice, Bob, Eve: Agent;\n\nprotocol fourway(X,Y)\n{\n        role X\n        {\n                fresh x: Nonce;\n                var y: Nonce;\n\n                send_1( X,Y, x,msg1 );\n                recv_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                send_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                recv_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_X1( X, Secret, hash( pmk(X,Y),x,y ) );\n                claim_X2( X, Niagree );\n        }\n\n        role Y\n        {\n                var x: Nonce;\n                fresh y: Nonce;\n\n                recv_1( X,Y, x,msg1 );\n                send_2( Y,X, y,msg2,hash( hash( pmk(X,Y),x,y ),y,msg2 ) );\n                recv_3( X,Y, x,msg3,hash( hash( pmk(X,Y),x,y ),x,msg3 ) );\n                send_4( Y,X, msg4,hash( hash( pmk(X,Y),x,y ),msg4 ) );\n\n                claim_Y1( Y, Secret, hash( pmk(X,Y),x,y ) );\n                claim_Y2( Y, Niagree );\n        }\n}"
    },
    {
        "file": "SPDL-1/gros_pigeons-v0.spdl",
        "incomplete": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(____(ROLE_1)____,R)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ____(ENCRYPTED_1)____: MySecret;\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\tsend_1(____(ROLE_1)____, R, {____(ENCRYPTED_1)____}pk(R));\n\t\trecv_2(R, ____(ROLE_1)____, h(____(ENCRYPTED_1)____), {____(NONCE_1)____}pk(____(ROLE_1)____));\n\t\tsend_3(____(ROLE_1)____, R, h(____(NONCE_1)____));\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ____(ENCRYPTED_1)____: MySecret;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(____(ROLE_1)____, R, {____(ENCRYPTED_1)____}pk(R));\n\t\tsend_2(R, ____(ROLE_1)____, h(____(ENCRYPTED_1)____), {____(NONCE_1)____}pk(____(ROLE_1)____));\n\t\trecv_3(____(ROLE_1)____, R, h(____(NONCE_1)____));\n\t}\n}",
        "complete:": "hashfunction h;\nusertype Msg;\nusertype MySecret;\n\nprotocol myProtocol(I,R)\n{\n\trole I\n\t{\n\t\tfresh sec: MySecret;\n\t\tvar n: Nonce;\n\n\t\tsend_1(I, R, {sec}pk(R));\n\t\trecv_2(R, I, h(sec), {n}pk(I));\n\t\tsend_3(I, R, h(n));\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar sec: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(I, R, {sec}pk(R));\n\t\tsend_2(R, I, h(sec), {n}pk(I));\n\t\trecv_3(I, R, h(n));\n\t}\n}"
    },
    {
        "file": "SPDL-1/HMQV.spdl",
        "incomplete": "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,____(ROLE_3)____,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,____(ROLE_3)____\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,____(ROLE_3)____\n\t\t  ));\n\t}\n\trole ____(ROLE_3)____\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(____(ROLE_3)____,____(ROLE_3)____, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,____(ROLE_3)____\n\t\t  ));\n\t\tsend_!4(____(ROLE_3)____,____(ROLE_3)____, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,____(ROLE_3)____\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,____(ROLE_3)____\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,____(ROLE_3)____\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,____(ROLE_2)____)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole ____(ROLE_2)____\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(____(ROLE_2)____,____(ROLE_2)____, mult(X,Y) );\n\t\tsend_!4(____(ROLE_2)____,____(ROLE_2)____, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,____(ROLE_2)____)\n{\n\trole I\n\t{\n\t\tvar x,____(NONCE_1)____: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(____(NONCE_1)____),exp(gexp(sk(____(ROLE_2)____)),H(gexp(____(NONCE_1)____),I))),add(x,mult(H(gexp(x),____(ROLE_2)____),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),____(ROLE_2)____))),add(____(NONCE_1)____,mult(H(gexp(____(NONCE_1)____),I),sk(____(ROLE_2)____))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,____(ROLE_2)____)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,____(ROLE_2)____, gexp(x) );\n\t\trecv_2(____(ROLE_2)____,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(____(ROLE_2)____)),H(Y,I))),add(x,mult(H(gexp(x),____(ROLE_2)____),sk(I))))) );\n\t}\t\n\t\n\trole ____(ROLE_2)____\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,____(ROLE_2)____, X );\n\t\tsend_2(____(ROLE_2)____,I, gexp(____(NONCE_1)____) );\n\n\t\tclaim(____(ROLE_2)____,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,____(ROLE_2)____))),add(____(NONCE_1)____,mult(H(gexp(____(NONCE_1)____),I),sk(____(ROLE_2)____))))) );\n\t}\n}",
        "complete:": "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/ikev1-quick.spdl",
        "incomplete": "# 1 \"ikev1-quick.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-quick.cpp\"\n# 16 \"ikev1-quick.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 126 \"common.h\"\n  var ____(ROLE_1)____, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(k(____(ROLE_1)____,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,____(ROLE_1)____),h(g(i),r),Ni,Nr) );\n\n }\n\n\n}\n# 17 \"ikev1-quick.cpp\" 2\n# 28 \"ikev1-quick.cpp\"\nprotocol ikev1-quick(____(ROLE_1)____, R)\n{\n role ____(ROLE_1)____ {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( ____(ROLE_1)____, R, mid, {prf(k(____(ROLE_1)____,R), mid, list, Ni, g(i), ____(ROLE_1)____, R), list, Ni, g(i), ____(ROLE_1)____, R}k(____(ROLE_1)____,R) );\n  recv_!2( R, ____(ROLE_1)____, mid, {prf(k(____(ROLE_1)____,R), mid, Ni, algo, Nr, Gr, ____(ROLE_1)____, R), algo, Nr, Gr, ____(ROLE_1)____, R}k(____(ROLE_1)____,R) );\n  claim( ____(ROLE_1)____, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( ____(ROLE_1)____, R, mid, {prf(k(____(ROLE_1)____,R), mid, Ni, Nr)}k(____(ROLE_1)____,R) );\n\n\n  claim( ____(ROLE_1)____, SKR, KDF(k(____(ROLE_1)____,R),h(Gr,i),Ni,Nr) );\n\n  claim( ____(ROLE_1)____, Alive );\n  claim( ____(ROLE_1)____, Weakagree );\n  claim( ____(ROLE_1)____, Commit, R, Ni, Nr, g(i), Gr );\n\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( ____(ROLE_1)____, R, mid, {prf(k(R,____(ROLE_1)____), mid, list, Ni, Gi, ____(ROLE_1)____, R), list, Ni, Gi, ____(ROLE_1)____, R}k(____(ROLE_1)____,R) );\n  claim( R, Running, ____(ROLE_1)____, Ni, Nr, Gi, g(r) );\n  send_!2( R, ____(ROLE_1)____, mid, {prf(k(R,____(ROLE_1)____), mid, Ni, algo, Nr, g(r), ____(ROLE_1)____, R), algo, Nr, g(r), ____(ROLE_1)____, R}k(____(ROLE_1)____,R) );\n  recv_!3( ____(ROLE_1)____, R, mid, {prf(k(R,____(ROLE_1)____), mid, Ni, Nr)}k(____(ROLE_1)____,R) );\n\n\n\n  claim( R, SKR, KDF(k(R,____(ROLE_1)____),h(Gi,r),Ni,Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, ____(ROLE_1)____, Ni, Nr, Gi, g(r) );\n\n }\n}",
        "complete:": "# 1 \"ikev1-quick.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev1-quick.cpp\"\n# 16 \"ikev1-quick.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 126 \"common.h\"\n  var I, R: Agent;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(k(I,R),h(g(r),i),Ni,Nr) );\n  send_!SWAP2( SWAP, SWAP, KDF(k(R,I),h(g(i),r),Ni,Nr) );\n\n }\n\n\n}\n# 17 \"ikev1-quick.cpp\" 2\n# 28 \"ikev1-quick.cpp\"\nprotocol ikev1-quick(I, R)\n{\n role I {\n  fresh i, Ni, Ci, mid, list: Nonce;\n  var Nr, Cr, algo: Nonce;\n  var Gr: Ticket;\n\n  send_!1( I, R, mid, {prf(k(I,R), mid, list, Ni, g(i), I, R), list, Ni, g(i), I, R}k(I,R) );\n  recv_!2( R, I, mid, {prf(k(I,R), mid, Ni, algo, Nr, Gr, I, R), algo, Nr, Gr, I, R}k(I,R) );\n  claim( I, Running, R, Ni, Nr, g(i), Gr );\n  send_!3( I, R, mid, {prf(k(I,R), mid, Ni, Nr)}k(I,R) );\n\n\n  claim( I, SKR, KDF(k(I,R),h(Gr,i),Ni,Nr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni, Nr, g(i), Gr );\n\n }\n\n role R {\n  fresh r, Nr, Cr, algo: Nonce;\n  var Ni, Ci, mid, list: Nonce;\n  var Gi: Ticket;\n\n  recv_!1( I, R, mid, {prf(k(R,I), mid, list, Ni, Gi, I, R), list, Ni, Gi, I, R}k(I,R) );\n  claim( R, Running, I, Ni, Nr, Gi, g(r) );\n  send_!2( R, I, mid, {prf(k(R,I), mid, Ni, algo, Nr, g(r), I, R), algo, Nr, g(r), I, R}k(I,R) );\n  recv_!3( I, R, mid, {prf(k(R,I), mid, Ni, Nr)}k(I,R) );\n\n\n\n  claim( R, SKR, KDF(k(R,I),h(Gi,r),Ni,Nr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni, Nr, Gi, g(r) );\n\n }\n}"
    },
    {
        "file": "SPDL-1/ikev2-mac.spdl",
        "incomplete": "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, ____(ROLE_1)____) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role ____(ROLE_1)____ {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( ____(ROLE_1)____, ____(ROLE_1)____, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( ____(ROLE_1)____, ____(ROLE_1)____, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n }\n\n\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector;\nconst O: Number;\nconst SA1 ,SA2, SA3: SecurityAssociation;\nconst TSi, TSr: TrafficSelector;\n\n\n\n\n\n\nprotocol @executability(E) {\n\n\n role E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {____(ENCRYPTED_1)____}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n\n }\n\n\n}\n\n\nprotocol ikev2-mac(I, R)\n{\n\n role I {\n  fresh i, Ni, SPIi: Nonce;\n  var Nr, SPIr: Nonce;\n  var Gr: Ticket;\n\n\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni );\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr );\n\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr);\n  send_!3( I, R, (SPIi,SPIr), {____(ENCRYPTED_2)____}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr);\n\n }\n\n role R {\n  fresh r, Nr, SPIr: Nonce;\n  var Ni, SPIi: Nonce;\n  var Gi: Ticket;\n\n\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni );\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr );\n\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr);\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr);\n }\n}",
        "complete:": "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n }\n\n\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector;\nconst O: Number;\nconst SA1 ,SA2, SA3: SecurityAssociation;\nconst TSi, TSr: TrafficSelector;\n\n\n\n\n\n\nprotocol @executability(E) {\n\n\n role E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {R, MAC(k(I,R), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n\n }\n\n\n}\n\n\nprotocol ikev2-mac(I, R)\n{\n\n role I {\n  fresh i, Ni, SPIi: Nonce;\n  var Nr, SPIr: Nonce;\n  var Gr: Ticket;\n\n\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni );\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr );\n\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr);\n  send_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr);\n\n }\n\n role R {\n  fresh r, Nr, SPIr: Nonce;\n  var Ni, SPIi: Nonce;\n  var Gi: Ticket;\n\n\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni );\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr );\n\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr);\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr);\n }\n}"
    },
    {
        "file": "SPDL-1/iso25-tag.spdl",
        "incomplete": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * four-pass\n * mutual\n *\n * Modeling notes:\n * - The use of TNb in message 4, as specified by the ISO standard, is\n *   different from other models, in which it was TNa.\n */\nusertype SessionKey;\nusertype Tag;\n\nconst t1,t2a,t2b,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-5(A,B,____(ROLE_1)____)\n{\n\trole A\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNa: Nonce;\n\t\tvar TNb: Nonce;\n\t\tvar ____(KEY_1)____: SessionKey;\n\t\tfresh Text1,Text5,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\tsend_1(A,____(ROLE_1)____, ____(NONCE_1)____, B, Text1);\n\t\trecv_2(____(ROLE_1)____,A, Text4, { t2a, ____(NONCE_1)____, ____(KEY_1)____, B, Text3 }k(A,____(ROLE_1)____), T );\n\t\tclaim(A,Running,B,____(KEY_1)____,Text5);\n\t\tsend_3(A,B, Text6, T, { t3, TNa, B, Text5 }____(KEY_1)____ );\n\t\trecv_4(B,A, Text8, { t4, TNb, A, Text7 }____(KEY_1)____ );\n\n\t\tclaim(A,Commit,B,____(KEY_1)____,Text5,Text7);\n\t\tclaim(A,Secret,____(KEY_1)____);\n\t\tclaim(A,Secret,Text5);\n\t\tclaim(A,Secret,Text7);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNp: Nonce;\n\t\tvar TNa: Nonce;\n\t\tfresh TNb: Nonce;\n\t\tvar ____(KEY_1)____: SessionKey;\n\t\tfresh Text7,Text8: Ticket;\n\t\tvar Text2,Text5,Text6: Ticket;\n\n\t\trecv_3(A,B, Text6, { t2b, TNp, ____(KEY_1)____, A, Text2  }k(B,____(ROLE_1)____), {\n\t\tt3, TNa, B, Text5 }____(KEY_1)____ );\n\t\tclaim(B,Running,A,____(KEY_1)____,Text5,Text7);\n\t\tsend_4(B,A, Text8, { t4, TNb, A, Text7 }____(KEY_1)____ );\n\n\t\tclaim(B,Commit,A,____(KEY_1)____,Text5);\n\t\tclaim(B,Secret,____(KEY_1)____);\n\t\tclaim(B,Secret,Text5);\n\t\tclaim(B,Secret,Text7);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh TNp: Nonce;\n\t\tfresh ____(KEY_1)____: SessionKey;\n\t\tfresh Text2,Text3,Text4: Ticket;\n\t\tvar Text1: Ticket;\n\n\t\trecv_1(A,____(ROLE_1)____, ____(NONCE_1)____, B, Text1);\n\t\tsend_2(____(ROLE_1)____,A, Text4, { t2a, ____(NONCE_1)____, ____(KEY_1)____, B, Text3 }k(A,____(ROLE_1)____),\n\t\t\t\t  { t2b, TNp, ____(KEY_1)____, A, Text2  }k(B,____(ROLE_1)____) );\n\t}\n}",
        "complete:": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * ttp\n * four-pass\n * mutual\n *\n * Modeling notes:\n * - The use of TNb in message 4, as specified by the ISO standard, is\n *   different from other models, in which it was TNa.\n */\nusertype SessionKey;\nusertype Tag;\n\nconst t1,t2a,t2b,t3,t4,t5: Tag;\n\nprotocol isoiec-9798-2-5(A,B,P)\n{\n\trole A\n\t{\n\t\tfresh TVPa: Nonce;\n\t\tvar T: Ticket;\n\t\tfresh TNa: Nonce;\n\t\tvar TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text1,Text5,Text6: Ticket;\n\t\tvar Text3,Text4,Text7,Text8: Ticket;\n\n\t\tsend_1(A,P, TVPa, B, Text1);\n\t\trecv_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P), T );\n\t\tclaim(A,Running,B,Kab,Text5);\n\t\tsend_3(A,B, Text6, T, { t3, TNa, B, Text5 }Kab );\n\t\trecv_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(A,Commit,B,Kab,Text5,Text7);\n\t\tclaim(A,Secret,Kab);\n\t\tclaim(A,Secret,Text5);\n\t\tclaim(A,Secret,Text7);\n\t\tclaim(A,Alive);\n\t\tclaim(A,Weakagree);\n\t}\n\trole B\n\t{\n\t\tvar TNp: Nonce;\n\t\tvar TNa: Nonce;\n\t\tfresh TNb: Nonce;\n\t\tvar Kab: SessionKey;\n\t\tfresh Text7,Text8: Ticket;\n\t\tvar Text2,Text5,Text6: Ticket;\n\n\t\trecv_3(A,B, Text6, { t2b, TNp, Kab, A, Text2  }k(B,P), {\n\t\tt3, TNa, B, Text5 }Kab );\n\t\tclaim(B,Running,A,Kab,Text5,Text7);\n\t\tsend_4(B,A, Text8, { t4, TNb, A, Text7 }Kab );\n\n\t\tclaim(B,Commit,A,Kab,Text5);\n\t\tclaim(B,Secret,Kab);\n\t\tclaim(B,Secret,Text5);\n\t\tclaim(B,Secret,Text7);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n\trole P\n\t{\n\t\tvar TVPa: Nonce;\n\t\tfresh TNp: Nonce;\n\t\tfresh Kab: SessionKey;\n\t\tfresh Text2,Text3,Text4: Ticket;\n\t\tvar Text1: Ticket;\n\n\t\trecv_1(A,P, TVPa, B, Text1);\n\t\tsend_2(P,A, Text4, { t2a, TVPa, Kab, B, Text3 }k(A,P),\n\t\t\t\t  { t2b, TNp, Kab, A, Text2  }k(B,P) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/isoiec-9798-2-1.spdl",
        "incomplete": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(____(ROLE_1)____,B)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,____(ROLE_1)____, { T, ____(ROLE_1)____, Text }k(____(ROLE_1)____,B) );\n\t\tsend_!2(____(ROLE_1)____,B, { T, ____(ROLE_1)____, Text }k(B,____(ROLE_1)____) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(____(ROLE_1)____,B, { T, B, Text }k(____(ROLE_1)____,B) );\n\t\tsend_!4(B,____(ROLE_1)____, { T, B, Text }k(B,____(ROLE_1)____) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(____(ROLE_1)____,B)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(____(ROLE_1)____,Running,B,____(NONCE_1)____,Text1);\n\t\tsend_1(____(ROLE_1)____,B, Text2, { ____(NONCE_1)____, B, Text1 }k(____(ROLE_1)____,B) );\n\t}\n\trole B\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(____(ROLE_1)____,B, Text2, { ____(NONCE_1)____, B, Text1 }k(____(ROLE_1)____,B) );\n\n\t\tclaim(B,Commit,____(ROLE_1)____,____(NONCE_1)____,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}",
        "complete:": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}"
    },
    {
        "file": "SPDL-1/isoiec11770-2-13.spdl",
        "incomplete": "usertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, ____(NONCE_1)____);\n\t\trecv_4 (R,I, { ____(NONCE_1)____,kir,R }k(I,____(ROLE_1)____) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, ____(NONCE_1)____);\n\t\tsend_2 (R,____(ROLE_1)____, { nr,____(NONCE_1)____,I,kir }k(R,____(ROLE_1)____) );\n\t\trecv_3 (____(ROLE_1)____,R, { nr, I }k(R,____(ROLE_1)____), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____,nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\trecv_2 (R,____(ROLE_1)____, { nr,____(NONCE_1)____,I,kir }k(R,____(ROLE_1)____) );\n\t\tsend_3 (____(ROLE_1)____,R, { nr, I }k(R,____(ROLE_1)____), { ____(NONCE_1)____,kir,R }k(I,____(ROLE_1)____) );\n\t}\n}",
        "complete:": "usertype Sessionkey;\nusertype Ticket;\n\nprotocol isoiec11770213(I,R,S)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\tsend_1 (I,R, ni);\n\t\trecv_4 (R,I, { ni,kir,R }k(I,S) );\n\n\t\tclaim_5 (I, Secret, kir);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh kir: Sessionkey;\n\t\tvar T;\n\n\t\trecv_1 (I,R, ni);\n\t\tsend_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\trecv_3 (S,R, { nr, I }k(R,S), T );\n\t\tsend_4 (R,I, T );\n\n\t\tclaim_6 (R, Secret, kir);\n\t}\n\n\trole S\n\t{\n\t\tvar ni,nr: Nonce;\n\t\tvar kir: Sessionkey;\n\n\t\trecv_2 (R,S, { nr,ni,I,kir }k(R,S) );\n\t\tsend_3 (S,R, { nr, I }k(R,S), { ni,kir,R }k(I,S) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/KAS1.spdl",
        "incomplete": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(____(ROLE_2)____,RB,RC)\n{\n\trole ____(ROLE_2)____\n\t{\n\t\tsend_!1(____(ROLE_2)____,____(ROLE_2)____, g1(sk(____(ROLE_2)____)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(____(ROLE_2)____,RB,RC)\n{\n\trole ____(ROLE_2)____\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(____(ROLE_2)____,____(ROLE_2)____, g2(g1(T1),T2) );\n\t\tsend_!2(____(ROLE_2)____,____(ROLE_2)____, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,____(ROLE_2)____) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,____(ROLE_2)____) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, ____(NONCE_1)____);\n\t\tsend_2(R,I, g1(____(NONCE_1)____) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),____(NONCE_1)____),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}",
        "complete:": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tsend_!1(RA,RA, g1(sk(RA)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,RA) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,RA) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}"
    },
    {
        "file": "SPDL-1/KEA+.spdl",
        "incomplete": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(____(ROLE_2)____,RB,RC)\n{\n\trole ____(ROLE_2)____\n\t{\n\t\tsend_!1(____(ROLE_2)____,____(ROLE_2)____, g1(sk(____(ROLE_2)____)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(____(ROLE_2)____,RB,RC)\n{\n\trole ____(ROLE_2)____\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(____(ROLE_2)____,____(ROLE_2)____, g2(g1(T1),T2) );\n\t\tsend_!2(____(ROLE_2)____,____(ROLE_2)____, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,____(ROLE_2)____) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,____(ROLE_2)____) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, ____(NONCE_1)____);\n\t\tsend_2(R,I, g1(____(NONCE_1)____) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),____(NONCE_1)____),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}",
        "complete:": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tsend_!1(RA,RA, g1(sk(RA)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,RA) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,RA) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}"
    },
    {
        "file": "SPDL-1/kerberos-rddm.spdl",
        "incomplete": "/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(____(ROLE_1)____,____(ROLE_2)____)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role ____(ROLE_1)____\n    {\n        var ____(ROLE_3)____:Ticket;\n\n\n        recv_!X1(____(ROLE_2)____,____(ROLE_1)____,{____(ROLE_3)____}ktk(____(ROLE_1)____,____(ROLE_2)____));\n        send_!X2(____(ROLE_1)____,____(ROLE_2)____,{____(ROLE_3)____}ktk(____(ROLE_2)____,____(ROLE_1)____));\n    }\n    role ____(ROLE_2)____\n    {\n    }\n}\nprotocol @swapkey-kck(____(ROLE_1)____,____(ROLE_2)____)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role ____(ROLE_1)____\n    {\n        var ____(ROLE_3)____:Ticket;\n\n\n        recv_!X1(____(ROLE_2)____,____(ROLE_1)____,{____(ROLE_3)____}kck(____(ROLE_1)____,____(ROLE_2)____));\n        send_!X2(____(ROLE_1)____,____(ROLE_2)____,{____(ROLE_3)____}kck(____(ROLE_2)____,____(ROLE_1)____));\n    }\n    role ____(ROLE_2)____\n    {\n    }\n}\nprotocol @swapkey-kst(____(ROLE_1)____,____(ROLE_2)____)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role ____(ROLE_1)____\n    {\n        var ____(ROLE_3)____:Ticket;\n\n\n        recv_!X1(____(ROLE_2)____,____(ROLE_1)____,{____(ROLE_3)____}kst(____(ROLE_1)____,____(ROLE_2)____));\n        send_!X2(____(ROLE_1)____,____(ROLE_2)____,{____(ROLE_3)____}kst(____(ROLE_2)____,____(ROLE_1)____));\n    }\n    role ____(ROLE_2)____\n    {\n    }\n}\n\nprotocol kerberos(C,K,____(ROLE_3)____,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,____(ROLE_3)____,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,____(ROLE_3)____ }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,____(ROLE_3)____, tgt, { C }AKey,C,S,____(NONCE_1)____ );\n\t\trecv_4(____(ROLE_3)____,C, C, st, { SKey, ____(NONCE_1)____, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,____(ROLE_3)____,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(____(ROLE_3)____,K), { AKey,n1,____(ROLE_3)____ }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole ____(ROLE_3)____ {\n\t\tvar AKey: Sessionkey;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,____(ROLE_3)____, { AKey, C }ktk(____(ROLE_3)____,K), { C }AKey,C,S,____(NONCE_1)____ );\n\t\tsend_4(____(ROLE_3)____,C, C,{ SKey, C }kst(S,____(ROLE_3)____), { SKey, ____(NONCE_1)____, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(____(ROLE_3)____,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(____(ROLE_3)____,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(____(ROLE_3)____,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,____(ROLE_3)____), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted",
        "complete:": "/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}ktk(I,R));\n        send_!X2(I,R,{T}ktk(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kck(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}kck(I,R));\n        send_!X2(I,R,{T}kck(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kst(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}kst(I,R));\n        send_!X2(I,R,{T}kst(R,I));\n    }\n    role R\n    {\n    }\n}\n\nprotocol kerberos(C,K,T,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,T,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,T }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,T, tgt, { C }AKey,C,S,n2 );\n\t\trecv_4(T,C, C, st, { SKey, n2, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,T,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(T,K), { AKey,n1,T }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole T {\n\t\tvar AKey: Sessionkey;\n\t\tvar n2: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,T, { AKey, C }ktk(T,K), { C }AKey,C,S,n2 );\n\t\tsend_4(T,C, C,{ SKey, C }kst(S,T), { SKey, n2, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(T,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(T,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(T,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,T), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted"
    },
    {
        "file": "SPDL-1/localclaims-breaker.spdl",
        "incomplete": "/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {I,ni}pk(____(ROLE_1)____) );\n\t\trecv_2(____(ROLE_1)____,I, {ni,____(NONCE_1)____,____(ROLE_1)____}pk(I) );\n\t\tsend_3(I,____(ROLE_1)____, {____(NONCE_1)____,I}pk(____(ROLE_1)____) );\n\n\t\trecv_x1(____(ROLE_1)____,I, { x }pk(I) );\n\t\tsend_x2(I,____(ROLE_1)____, { x }ni );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,____(NONCE_1)____);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh x: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {I,ni}pk(____(ROLE_1)____) );\n\t\tsend_2(____(ROLE_1)____,I, {ni,____(NONCE_1)____,____(ROLE_1)____}pk(I) );\n\t\trecv_3(I,____(ROLE_1)____, {____(NONCE_1)____,I}pk(____(ROLE_1)____) );\n\n\t\tsend_x1(____(ROLE_1)____,I, { x }pk(I) );\n\t\trecv_x2(I,____(ROLE_1)____, { x }ni );\n\n\t\tclaim_r1(____(ROLE_1)____,Secret,ni);\n\t\tclaim_r2(____(ROLE_1)____,Secret,____(NONCE_1)____);\n\t}\n}",
        "complete:": "/*\n * Breaker for localclaims protocol\n *\n * Starts out as NSL3; last message (label3) has added name to avoid\n * confusion with the later messages.\n *\n * Added messages labeled with x1 and x2 to allow for breaking the other\n * protocol.\n */\nconst pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\n\nprotocol lcbreaker(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\t\tvar x: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr,I}pk(R) );\n\n\t\trecv_x1(R,I, { x }pk(I) );\n\t\tsend_x2(I,R, { x }ni );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\t\tfresh x: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr,I}pk(R) );\n\n\t\tsend_x1(R,I, { x }pk(I) );\n\t\trecv_x2(I,R, { x }ni );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t}\n}"
    },
    {
        "file": "SPDL-1/myProt.spdl",
        "incomplete": "hashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(____(ROLE_1)____,B)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tfresh K: MySecret;\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\n\t\tsend_1(____(ROLE_1)____, B, h(____(ROLE_1)____, K), {K}pk(B));\n\t\trecv_2(B, ____(ROLE_1)____, h(B, K, ____(ENCRYPTED_1)____), {____(ENCRYPTED_1)____}pk(____(ROLE_1)____));\n\t\tsend_3(____(ROLE_1)____, B, h(____(ENCRYPTED_1)____));\n\n\t\tclaim_4(____(ROLE_1)____, Secret, K);\n\t\tclaim_6(____(ROLE_1)____, Nisynch);\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar V: MySecret;\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(____(ROLE_1)____, B, h(____(ROLE_1)____, V), {V}pk(B));\n\t\tsend_2(B, ____(ROLE_1)____, h(B, V, ____(NONCE_1)____), {____(NONCE_1)____}pk(____(ROLE_1)____));\n\t\trecv_3(____(ROLE_1)____, B, h(____(NONCE_1)____));\n\n\t\tclaim_5(B, Secret, V);\n\t\tclaim_7(B, Nisynch);\n\t}\n}",
        "complete:": "hashfunction h;\nusertype MySecret;\n\nprotocol myProtocol(A,B)\n{\n\trole A\n\t{\n\t\tfresh K: MySecret;\n\t\tvar W: Nonce;\n\n\t\tsend_1(A, B, h(A, K), {K}pk(B));\n\t\trecv_2(B, A, h(B, K, W), {W}pk(A));\n\t\tsend_3(A, B, h(W));\n\n\t\tclaim_4(A, Secret, K);\n\t\tclaim_6(A, Nisynch);\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar V: MySecret;\n\t\tfresh n: Nonce;\n\n\t\trecv_1(A, B, h(A, V), {V}pk(B));\n\t\tsend_2(B, A, h(B, V, n), {n}pk(A));\n\t\trecv_3(A, B, h(n));\n\n\t\tclaim_5(B, Secret, V);\n\t\tclaim_7(B, Nisynch);\n\t}\n}"
    },
    {
        "file": "SPDL-1/NAXOS.spdl",
        "incomplete": "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,____(ROLE_1)____,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,____(ROLE_1)____\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,____(ROLE_1)____\n\t\t  ));\n\t}\n\trole ____(ROLE_1)____\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(____(ROLE_1)____,____(ROLE_1)____, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,____(ROLE_1)____\n\t\t  ));\n\t\tsend_!4(____(ROLE_1)____,____(ROLE_1)____, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,____(ROLE_1)____\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,____(ROLE_1)____\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,____(ROLE_1)____\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(____(ROLE_2)____,R2,R3)\n{\n\trole ____(ROLE_2)____\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(____(ROLE_2)____,____(ROLE_2)____, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\t____(ROLE_2)____,R2));\n\t\tsend_!2(____(ROLE_2)____,____(ROLE_2)____, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\t____(ROLE_2)____,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,____(ROLE_2)____));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,____(ROLE_2)____));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(____(NONCE_1)____,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(____(NONCE_1)____,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(____(NONCE_1)____,sk(R))),\n\t\t\tI,R));\n\t}\n}",
        "complete:": "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}"
    },
    {
        "file": "SPDL-1/needham-schroeder-sk.spdl",
        "incomplete": "# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroedersk(____(ROLE_1)____,R,S)\n{\n    role ____(ROLE_1)____\n    {\n        fresh ____(NONCE_1)____: Nonce;\n        var Nr: Nonce;\n        var ____(KEY_1)____: SessionKey;\n        var T: Ticket;\n        \n        send_1(____(ROLE_1)____,S,(____(ROLE_1)____,R,____(NONCE_1)____));\n        recv_2(S,____(ROLE_1)____, {____(NONCE_1)____,R,____(KEY_1)____,T}k(____(ROLE_1)____,S));\n        send_3(____(ROLE_1)____,R,T);\n        recv_4(R,____(ROLE_1)____,{Nr}____(KEY_1)____);\n        send_5(____(ROLE_1)____,R,{{Nr}dec}____(KEY_1)____);\n        claim_I2(____(ROLE_1)____,Secret,____(KEY_1)____);\n        claim_I3(____(ROLE_1)____,Nisynch);\n        claim_I4(____(ROLE_1)____,Empty,(Fresh,____(KEY_1)____));\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var ____(KEY_1)____: SessionKey;\n        \n        recv_3(____(ROLE_1)____,R,{____(KEY_1)____,____(ROLE_1)____}k(R,S));\n        send_4(R,____(ROLE_1)____,{Nr}____(KEY_1)____);\n        recv_5(____(ROLE_1)____,R,{{Nr}dec}____(KEY_1)____);\n        claim_R1(R,Secret,____(KEY_1)____);\n        claim_R3(R,Nisynch);\n        claim_R4(R,Empty,(Fresh,____(KEY_1)____));\n    }\n\n    role S\n    {\n        var ____(NONCE_1)____: Nonce;\n        fresh ____(KEY_1)____: SessionKey;\n        recv_1(____(ROLE_1)____,S,(____(ROLE_1)____,R,____(NONCE_1)____));\n        send_2(S,____(ROLE_1)____,{____(NONCE_1)____,R,____(KEY_1)____,{____(KEY_1)____,____(ROLE_1)____}k(R,S)}k(____(ROLE_1)____,S));\n    }\n}",
        "complete:": "# Needham Schroeder Symmetric Key\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/nssk.html\n#\n#\n\n\n# Model dec that is invertible by inc\nconst dec,inc: Function;\ninversekeys(dec,inc);\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol needhamschroedersk(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var Kir: SessionKey;\n        var T: Ticket;\n        \n        send_1(I,S,(I,R,Ni));\n        recv_2(S,I, {Ni,R,Kir,T}k(I,S));\n        send_3(I,R,T);\n        recv_4(R,I,{Nr}Kir);\n        send_5(I,R,{{Nr}dec}Kir);\n        claim_I2(I,Secret,Kir);\n        claim_I3(I,Nisynch);\n        claim_I4(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh Nr: Nonce;\n        var Kir: SessionKey;\n        \n        recv_3(I,R,{Kir,I}k(R,S));\n        send_4(R,I,{Nr}Kir);\n        recv_5(I,R,{{Nr}dec}Kir);\n        claim_R1(R,Secret,Kir);\n        claim_R3(R,Nisynch);\n        claim_R4(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni: Nonce;\n        fresh Kir: SessionKey;\n        recv_1(I,S,(I,R,Ni));\n        send_2(S,I,{Ni,R,Kir,{Kir,I}k(R,S)}k(I,S));\n    }\n}"
    },
    {
        "file": "SPDL-1/nsl3.spdl",
        "incomplete": "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}pk(____(ROLE_1)____) );\n\t\trecv_2(____(ROLE_1)____,I, {____(NONCE_1)____,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\tsend_3(I,____(ROLE_1)____, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_i1(I,Secret,____(NONCE_1)____);\n\t\tclaim_i2(I,Secret,____(ENCRYPTED_1)____);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tfresh ____(ENCRYPTED_1)____: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}pk(____(ROLE_1)____) );\n\t\tsend_2(____(ROLE_1)____,I, {____(NONCE_1)____,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\trecv_3(I,____(ROLE_1)____, {____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_r1(____(ROLE_1)____,Secret,____(NONCE_1)____);\n\t\tclaim_r2(____(ROLE_1)____,Secret,____(ENCRYPTED_1)____);\n\t\tclaim_r3(____(ROLE_1)____,Niagree);\n\t\tclaim_r4(____(ROLE_1)____,Nisynch);\n\t}\n}",
        "complete:": "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}"
    },
    {
        "file": "SPDL-1/nuts-auth.spdl",
        "incomplete": "hashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, ____(ROLE_1)____), ____(NONCE_1)____, Rb);\n\nprotocol NUTSAuth (GS,____(ROLE_1)____) {\n\n    role GS {\n        var ____(NONCE_1)____: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, ____(ROLE_1)____, Rb, MAC(k(GS, ____(ROLE_1)____), GS, ____(ROLE_1)____, Rb));\n        recv_2(____(ROLE_1)____, GS, ____(NONCE_1)____, MAC(k(GS, ____(ROLE_1)____), ____(ROLE_1)____, GS, ____(NONCE_1)____, Rb));\n        send_3(GS, ____(ROLE_1)____, SAprop, MAC(k(GS, ____(ROLE_1)____), GS, ____(ROLE_1)____, SAprop, ____(NONCE_1)____));\n        recv_4(____(ROLE_1)____, GS, SA, MAC(Ks, ____(ROLE_1)____, GS, SA));\n\n        # Send command\n        send_5(GS, ____(ROLE_1)____, CMD, MAC(Ks, Cseq1, CMD));\n        recv_6(____(ROLE_1)____, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Send another command (repeat CMDs for scyther to spot replay attacks)\n        send_7(GS, ____(ROLE_1)____, CMD, MAC(Ks, Cseq2, CMD));\n        recv_8(____(ROLE_1)____, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(GS, Alive);\n        claim(GS, Secret, Ks);\n        claim(GS, Weakagree);\n        claim(GS, Niagree);\n        claim(GS, Nisynch);\n    };\n\n    role ____(ROLE_1)____ {\n        fresh ____(NONCE_1)____: Nonce;\n        var Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        recv_1(GS, ____(ROLE_1)____, Rb, MAC(k(GS, ____(ROLE_1)____), GS, ____(ROLE_1)____, Rb));\n        send_2(____(ROLE_1)____, GS, ____(NONCE_1)____, MAC(k(GS, ____(ROLE_1)____), ____(ROLE_1)____, GS, ____(NONCE_1)____, Rb));\n        recv_3(GS, ____(ROLE_1)____, SAprop, MAC(k(GS, ____(ROLE_1)____), GS, ____(ROLE_1)____, SAprop, ____(NONCE_1)____));\n        send_4(____(ROLE_1)____, GS, SA, MAC(Ks, ____(ROLE_1)____, GS, SA));\n\n        # Receive command\n        recv_5(GS, ____(ROLE_1)____, CMD, MAC(Ks, Cseq1, CMD));\n        send_6(____(ROLE_1)____, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Receive second command\n        recv_7(GS, ____(ROLE_1)____, CMD, MAC(Ks, Cseq2, CMD));\n        send_8(____(ROLE_1)____, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(____(ROLE_1)____, Alive);\n        claim(____(ROLE_1)____, Secret, Ks);\n        claim(____(ROLE_1)____, Weakagree);\n        claim(____(ROLE_1)____, Niagree);\n        claim(____(ROLE_1)____, Nisynch);\n    };\n}",
        "complete:": "hashfunction MAC, KDF;\nusertype SecurityAssociation, Command, SequenceNumber;\nconst SAprop, SA: SecurityAssociation;\nconst Sseq1, Sseq2, Cseq1, Cseq2: SequenceNumber;\nconst CMD, ACK: Command;\nmacro Ks = KDF(k(GS, Sat), Ra, Rb);\n\nprotocol NUTSAuth (GS,Sat) {\n\n    role GS {\n        var Ra: Nonce;\n        fresh Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        send_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        recv_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        send_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        recv_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Send command\n        send_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        recv_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Send another command (repeat CMDs for scyther to spot replay attacks)\n        send_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        recv_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(GS, Alive);\n        claim(GS, Secret, Ks);\n        claim(GS, Weakagree);\n        claim(GS, Niagree);\n        claim(GS, Nisynch);\n    };\n\n    role Sat {\n        fresh Ra: Nonce;\n        var Rb: Nonce;\n\n        # Key exchange and mutual authentication\n        recv_1(GS, Sat, Rb, MAC(k(GS, Sat), GS, Sat, Rb));\n        send_2(Sat, GS, Ra, MAC(k(GS, Sat), Sat, GS, Ra, Rb));\n        recv_3(GS, Sat, SAprop, MAC(k(GS, Sat), GS, Sat, SAprop, Ra));\n        send_4(Sat, GS, SA, MAC(Ks, Sat, GS, SA));\n\n        # Receive command\n        recv_5(GS, Sat, CMD, MAC(Ks, Cseq1, CMD));\n        send_6(Sat, GS, ACK, MAC(Ks, Sseq1, ACK));\n\n        # Receive second command\n        recv_7(GS, Sat, CMD, MAC(Ks, Cseq2, CMD));\n        send_8(Sat, GS, ACK, MAC(Ks, Sseq2, ACK));\n\n        claim(Sat, Alive);\n        claim(Sat, Secret, Ks);\n        claim(Sat, Weakagree);\n        claim(Sat, Niagree);\n        claim(Sat, Nisynch);\n    };\n}"
    },
    {
        "file": "SPDL-1/oakley-a.spdl",
        "incomplete": "# 1 \"oakley-a.cpp\"\n# 1 \"<command-line>\"\n# 1 \"oakley-a.cpp\"\n# 18 \"oakley-a.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 141 \"common.h\"\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 19 \"oakley-a.cpp\" 2\n\n\n\nusertype String;\nconst list, algo: String;\n\nprotocol oakley-a(I, ____(ROLE_1)____)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, ____(ROLE_1)____, Ci, g(i), list, I, ____(ROLE_1)____, Ni, {I, ____(ROLE_1)____, Ni, g(i), list}sk(I) );\n  recv_2( ____(ROLE_1)____, I, Cr, Ci, Gr, algo, ____(ROLE_1)____, I, Nr, Ni, {____(ROLE_1)____, I, Nr, Ni, g(i), Gr, algo}sk(____(ROLE_1)____) );\n  send_3( I, ____(ROLE_1)____, Ci, Cr, g(i), algo, I, ____(ROLE_1)____, Ni, Nr, {I, ____(ROLE_1)____, Ni, Nr, g(i), Gr, algo}sk(I) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role ____(ROLE_1)____ {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, ____(ROLE_1)____, Ci, Gi, list, I, ____(ROLE_1)____, Ni, {I, ____(ROLE_1)____, Ni, Gi, list}sk(I) );\n  send_2( ____(ROLE_1)____, I, Cr, Ci, g(r), algo, ____(ROLE_1)____, I, Nr, Ni, {____(ROLE_1)____, I, Nr, Ni, Gi, g(r), algo}sk(____(ROLE_1)____) );\n  recv_3( I, ____(ROLE_1)____, Ci, Cr, Gi, algo, I, ____(ROLE_1)____, Ni, Nr, {I, ____(ROLE_1)____, Ni, Nr, Gi, g(r), algo}sk(I) );\n\n\n  claim( ____(ROLE_1)____, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( ____(ROLE_1)____, Alive );\n  claim( ____(ROLE_1)____, Weakagree );\n\n }\n}",
        "complete:": "# 1 \"oakley-a.cpp\"\n# 1 \"<command-line>\"\n# 1 \"oakley-a.cpp\"\n# 18 \"oakley-a.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 141 \"common.h\"\n  var Ci, Cr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni, Nr, h(g(r),i), Ci, Cr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni, Nr, h(g(i),r), Ci, Cr) );\n\n }\n\n\n}\n# 19 \"oakley-a.cpp\" 2\n\n\n\nusertype String;\nconst list, algo: String;\n\nprotocol oakley-a(I, R)\n{\n role I {\n  fresh i, Ni, Ci: Nonce;\n  var Nr, Cr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, Ci, g(i), list, I, R, Ni, {I, R, Ni, g(i), list}sk(I) );\n  recv_2( R, I, Cr, Ci, Gr, algo, R, I, Nr, Ni, {R, I, Nr, Ni, g(i), Gr, algo}sk(R) );\n  send_3( I, R, Ci, Cr, g(i), algo, I, R, Ni, Nr, {I, R, Ni, Nr, g(i), Gr, algo}sk(I) );\n\n\n  claim( I, SKR, KDF(Ni, Nr, h(Gr,i), Ci, Cr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr, Cr: Nonce;\n  var Ni, Ci: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Ci, Gi, list, I, R, Ni, {I, R, Ni, Gi, list}sk(I) );\n  send_2( R, I, Cr, Ci, g(r), algo, R, I, Nr, Ni, {R, I, Nr, Ni, Gi, g(r), algo}sk(R) );\n  recv_3( I, R, Ci, Cr, Gi, algo, I, R, Ni, Nr, {I, R, Ni, Nr, Gi, g(r), algo}sk(I) );\n\n\n  claim( R, SKR, KDF(Ni, Nr, h(Gi,r), Ci, Cr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"
    },
    {
        "file": "SPDL-1/pkmv2rsacorrected.spdl",
        "incomplete": "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,____(ROLE_1)____)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,____(ROLE_1)____, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(____(ROLE_1)____,MS, {____(ENCRYPTED_1)____}pk(MS),____(ROLE_1)____}sk(____(ROLE_1)____) );\n\t\tsend_rsa3(MS,____(ROLE_1)____, {bsrand,____(ROLE_1)____}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,____(ROLE_1)____, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(____(ROLE_1)____,MS, {____(ENCRYPTED_1)____}pk(MS),____(ROLE_1)____}sk(____(ROLE_1)____) );\n\t\trecv_rsa3(MS,____(ROLE_1)____, {bsrand,____(ROLE_1)____}sk(MS) );\n\n\t\tclaim_rsar3(____(ROLE_1)____,Niagree);\n\t\tclaim_rsar4(____(ROLE_1)____,Nisynch);\n\t\tclaim_rsar5(____(ROLE_1)____,SKR,prepak);\n\t}\n}",
        "complete:": "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// The protocol description\n\nprotocol pkmv2rsa(MS,BS)\n{\n\trole MS\n\t{\n\t\tfresh msrand, said: Nonce;\n\t\tvar prepak, bsrand: Nonce;\n\n\t\tsend_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\trecv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n\t\tsend_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsai3(MS,Niagree);\n\t\tclaim_rsai4(MS,Nisynch);\n\t\tclaim_rsai5(MS,SKR,prepak);\n\t}\t\n\t\n\trole BS\n\t{\n\t\tvar msrand, said: Nonce;\n\t\tfresh prepak, bsrand: Nonce;\n\n\t\trecv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n\t\tsend_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n\t\trecv_rsa3(MS,BS, {bsrand,BS}sk(MS) );\n\n\t\tclaim_rsar3(BS,Niagree);\n\t\tclaim_rsar4(BS,Nisynch);\n\t\tclaim_rsar5(BS,SKR,prepak);\n\t}\n}"
    },
    {
        "file": "SPDL-1/pqr.spdl",
        "incomplete": "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(____(ROLE_1)____,BS)\n\n{\n  role ____(ROLE_1)____\n  {\n    fresh msrand, msrand', said, ____(ENCRYPTED_1)____: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    send_rsa1(____(ROLE_1)____,BS, {msrand, said, ____(ROLE_1)____}sk(____(ROLE_1)____) );\n    recv_rsa2(BS,____(ROLE_1)____, {msrand, bsrand,{prepak,____(ROLE_1)____}pk(____(ROLE_1)____),BS}sk(BS) );\n    send_rsa3(____(ROLE_1)____,BS, {bsrand, BS}sk(____(ROLE_1)____) );\n\n    recv_satek1(BS,____(ROLE_1)____, bsrand',akid,\n      hash(d,prepak,BS,____(ROLE_1)____,bsrand',akid) );\n    send_satek2(____(ROLE_1)____,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,____(ROLE_1)____,msrand',bsrand',akid) );\n    recv_satek3(BS,____(ROLE_1)____,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    send_tekup1(____(ROLE_1)____,BS,{____(ENCRYPTED_1)____}hash(prepak));\n    recv_tekup2(BS,____(ROLE_1)____,{____(ENCRYPTED_1)____,tek2,tek3}hash(prepak));\n\n    claim_rsai3(____(ROLE_1)____,Niagree);\n    claim_rsai4(____(ROLE_1)____,Nisynch);\n    claim_rsai5(____(ROLE_1)____,SKR,prepak);\n    claim_rsai6(____(ROLE_1)____,SKR,tek0);\n    claim_rsai7(____(ROLE_1)____,SKR,tek1);\n    claim_rsar8(____(ROLE_1)____,SKR,tek2);\n    claim_rsar9(____(ROLE_1)____,SKR,tek3);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said, ____(ENCRYPTED_1)____: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    recv_rsa1(____(ROLE_1)____,BS, {msrand, said, ____(ROLE_1)____}sk(____(ROLE_1)____) );\n    send_rsa2(BS,____(ROLE_1)____, {msrand, bsrand,{prepak,____(ROLE_1)____}pk(____(ROLE_1)____),BS}sk(BS) );\n    recv_rsa3(____(ROLE_1)____,BS, {bsrand, BS}sk(____(ROLE_1)____) );\n\n    send_satek1(BS,____(ROLE_1)____, bsrand',akid,\n      hash(d,prepak,BS,____(ROLE_1)____,bsrand',akid) );\n    recv_satek2(____(ROLE_1)____,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,____(ROLE_1)____,msrand',bsrand',akid) );\n    send_satek3(BS,____(ROLE_1)____,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    recv_tekup1(____(ROLE_1)____,BS,{____(ENCRYPTED_1)____}hash(prepak));\n    send_tekup2(BS,____(ROLE_1)____,{____(ENCRYPTED_1)____,tek2,tek3}hash(prepak));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar5(BS,SKR,prepak);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n    claim_rsar8(BS,SKR,tek2);\n    claim_rsar9(BS,SKR,tek3);\n  }\n}",
        "complete:": "/* \n * PKMv2-RSA\n *\n * Initial model by:\tSjouke Mauw, Sasa Radomirovic (2007)\n * Model changes:\tCas Cremers (Nov 2012)\n *\n * Analysed in:\t\t\"A framework for compositional verification of security protocols\"\n * \t\t\tWith S. Andova, K. Gjosteen, S. Mauw, S. Mjolsnes, and S. Radomirovic.\n * \t\t\tInformation and Computation, Special issue on Computer Security: \n * \t\t\tFoundations and Automated Reasoning, Volume 206, Issues 2-4, pp. 425-459,\n * \t\t\tElsevier, 2008. \n */\n\n// Setup\n\nhashfunction hash;\nhashfunction prepak;\nconst akid;\nconst u,d;\n\n// The protocol description\n\nprotocol rsaplussatek(MS,BS)\n\n{\n  role MS\n  {\n    fresh msrand, msrand', said, c: Nonce;\n    var prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    send_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    recv_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    send_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    recv_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    send_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    recv_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    send_tekup1(MS,BS,{c}hash(prepak));\n    recv_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsai3(MS,Niagree);\n    claim_rsai4(MS,Nisynch);\n    claim_rsai5(MS,SKR,prepak);\n    claim_rsai6(MS,SKR,tek0);\n    claim_rsai7(MS,SKR,tek1);\n    claim_rsar8(MS,SKR,tek2);\n    claim_rsar9(MS,SKR,tek3);\n  } \n  \n  role BS\n  {\n    var msrand, msrand', said, c: Nonce;\n    fresh prepak, bsrand, bsrand', tek0, tek1, tek2, tek3: Nonce;\n\n    recv_rsa1(MS,BS, {msrand, said, MS}sk(MS) );\n    send_rsa2(BS,MS, {msrand, bsrand,{prepak,MS}pk(MS),BS}sk(BS) );\n    recv_rsa3(MS,BS, {bsrand, BS}sk(MS) );\n\n    send_satek1(BS,MS, bsrand',akid,\n      hash(d,prepak,BS,MS,bsrand',akid) );\n    recv_satek2(MS,BS, msrand',bsrand',akid,\n      hash(u,prepak,BS,MS,msrand',bsrand',akid) );\n    send_satek3(BS,MS,\n    msrand',bsrand',akid,{tek0,tek1}hash(prepak),\n      hash(d,prepak,msrand',bsrand',akid,{tek0,tek1}hash(prepak)));\n\n    recv_tekup1(MS,BS,{c}hash(prepak));\n    send_tekup2(BS,MS,{c,tek2,tek3}hash(prepak));\n\n    claim_rsar3(BS,Niagree);\n    claim_rsar4(BS,Nisynch);\n    claim_rsar5(BS,SKR,prepak);\n    claim_rsar6(BS,SKR,tek0);\n    claim_rsar7(BS,SKR,tek1);\n    claim_rsar8(BS,SKR,tek2);\n    claim_rsar9(BS,SKR,tek3);\n  }\n}"
    },
    {
        "file": "SPDL-1/protocol0-symm.spdl",
        "incomplete": "/* \n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}k(I,____(ROLE_1)____) );\n\t\tclaim_i(I,Secret,____(NONCE_1)____);\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}k(I,____(ROLE_1)____) );\n\t\tclaim_r(____(ROLE_1)____,Secret,____(NONCE_1)____);\n\t}\n}",
        "complete:": "/* \n * Secrecy protocol\n *\n * Uses symmetric encryption\n */\n\n// The protocol description\n\nprotocol protocol0symm(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_i(I,Secret,ni);\n\t}\n\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}k(I,R) );\n\t\tclaim_r(R,Secret,ni);\n\t}\n}"
    },
    {
        "file": "SPDL-1/Signed-DH.spdl",
        "incomplete": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(____(ROLE_1)____)\n{\n\trole ____(ROLE_1)____\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(____(ROLE_1)____,____(ROLE_1)____, g2(g1(T1),T2) );\n\t\tsend_!2(____(ROLE_1)____,____(ROLE_1)____, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(____(NONCE_1)____), { R,s,g1(____(NONCE_1)____),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(____(NONCE_1)____),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,____(NONCE_1)____) );\n\t}\n}",
        "complete:": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/skeme-basic.spdl",
        "incomplete": "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (____(ROLE_1)____, SWAP) {\n\n\n\n\n\n\n\n role ____(ROLE_1)____ {\n  var i, r: Nonce;\n\n  recv_!DH1( ____(ROLE_1)____, ____(ROLE_1)____, h(g(r),i) );\n  send_!DH2( ____(ROLE_1)____, ____(ROLE_1)____, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, ____(NONCE_1)____, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, ____(NONCE_1)____: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, ____(NONCE_1)____}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(____(NONCE_1)____,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(____(NONCE_1)____,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var ____(NONCE_1)____: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, ____(NONCE_1)____}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(____(NONCE_1)____,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(____(NONCE_1)____,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}",
        "complete:": "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"
    },
    {
        "file": "SPDL-1/soph.spdl",
        "incomplete": "protocol soph(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}pk(____(ROLE_1)____) );\n\t\trecv_2(____(ROLE_1)____,I, ____(NONCE_1)____ );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {I,____(NONCE_1)____}pk(____(ROLE_1)____) );\n\t\tsend_2(____(ROLE_1)____,I, ____(NONCE_1)____ );\n\t}\n}",
        "complete:": "protocol soph(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, ni );\n\t\tclaim_3(I,Niagree);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, ni );\n\t}\n}"
    },
    {
        "file": "SPDL-1/sts-modified.spdl",
        "incomplete": "# 1 \"sts-modified.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-modified.cpp\"\n# 17 \"sts-modified.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (____(ROLE_1)____, SWAP) {\n\n\n\n\n\n\n\n role ____(ROLE_1)____ {\n  var i, ____(NONCE_1)____: Nonce;\n\n  recv_!DH1( ____(ROLE_1)____, ____(ROLE_1)____, h(g(____(NONCE_1)____),i) );\n  send_!DH2( ____(ROLE_1)____, ____(ROLE_1)____, h(g(i),____(NONCE_1)____) );\n }\n\n\n\n\n role SWAP {\n  var i, ____(NONCE_1)____, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(____(NONCE_1)____),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),____(NONCE_1)____)) );\n\n }\n\n\n}\n# 18 \"sts-modified.cpp\" 2\n\n\n\n\nprotocol sts-modified(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_2( R, I, Gr, {Gr, g(i), I}sk(R) );\n  send_3( I, R, {g(i), Gr, R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh ____(NONCE_1)____: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_2( R, I, g(____(NONCE_1)____), {g(____(NONCE_1)____), Gi, I}sk(R) );\n  recv_3( I, R, {Gi, g(____(NONCE_1)____), R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,____(NONCE_1)____)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}",
        "complete:": "# 1 \"sts-modified.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-modified.cpp\"\n# 17 \"sts-modified.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 18 \"sts-modified.cpp\" 2\n\n\n\n\nprotocol sts-modified(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_2( R, I, Gr, {Gr, g(i), I}sk(R) );\n  send_3( I, R, {g(i), Gr, R}sk(I) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_2( R, I, g(r), {g(r), Gi, I}sk(R) );\n  recv_3( I, R, {Gi, g(r), R}sk(I) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}"
    },
    {
        "file": "SPDL-1/th-1par2.spdl",
        "incomplete": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {P1,I,ni}pk(____(ROLE_1)____) );\n\t\trecv_1b(____(ROLE_1)____,I, {____(ENCRYPTED_1)____}pk(I) );\n\t\trecv_2(____(ROLE_1)____,I, {P1,ni,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\tsend_3(I,____(ROLE_1)____, {P1,____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh ____(ENCRYPTED_1)____: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {P1,I,ni}pk(____(ROLE_1)____) );\n\t\tsend_1b(____(ROLE_1)____,I, {____(ENCRYPTED_1)____}pk(I) );\n\t\tsend_2(____(ROLE_1)____,I, {P1,ni,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\trecv_3(I,____(ROLE_1)____, {P1,____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_r(____(ROLE_1)____,Nisynch);\n\t}\n}\n\n\n\n\nprotocol nsl3th2(I,____(ROLE_1)____)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar ____(ENCRYPTED_1)____: Nonce;\n\n\t\tsend_1(I,____(ROLE_1)____, {P2,I,ni}pk(____(ROLE_1)____) );\n\t\trecv_1b(____(ROLE_1)____,I, {____(ENCRYPTED_1)____}pk(I) );\n\t\trecv_2(____(ROLE_1)____,I, {P2,ni,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\tsend_3(I,____(ROLE_1)____, {P2,____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh ____(ENCRYPTED_1)____: Nonce;\n\n\t\trecv_1(I,____(ROLE_1)____, {P2,I,ni}pk(____(ROLE_1)____) );\n\t\tsend_1b(____(ROLE_1)____,I, {____(ENCRYPTED_1)____}pk(I) );\n\t\tsend_2(____(ROLE_1)____,I, {P2,ni,____(ENCRYPTED_1)____,____(ROLE_1)____}pk(I) );\n\t\trecv_3(I,____(ROLE_1)____, {P2,____(ENCRYPTED_1)____}pk(____(ROLE_1)____) );\n\n\t\tclaim_r(____(ROLE_1)____,Nisynch);\n\t}\n}",
        "complete:": "const pk: Function;\nsecret sk: Function;\ninversekeys (pk,sk);\nconst P1;\nconst P2;\n\nprotocol nsl3th1(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P1,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P1,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P1,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P1,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}\n\n\n\n\nprotocol nsl3th2(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {P2,I,ni}pk(R) );\n\t\trecv_1b(R,I, {nr}pk(I) );\n\t\trecv_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_i(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {P2,I,ni}pk(R) );\n\t\tsend_1b(R,I, {nr}pk(I) );\n\t\tsend_2(R,I, {P2,ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {P2,nr}pk(R) );\n\n\t\tclaim_r(R,Nisynch);\n\t}\n}"
    },
    {
        "file": "SPDL-1/tls-BM-1.spdl",
        "incomplete": "/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/* below is just Scyther input and no further macro definitions */\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\nprotocol tls-bm-1(A,____(ROLE_1)____)\n{\n\trole A\n\t{\n\t\tfresh ____(NONCE_1)____: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( A,____(ROLE_1)____, ____(NONCE_1)____ );\n\t\trecv_2( ____(ROLE_1)____,A, nb );\n\t\tsend_3( A,____(ROLE_1)____, { pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A)) }hash(pmk,____(NONCE_1)____,nb) );\n\t\trecv_4( ____(ROLE_1)____,A, { ____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A)) }hash(pmk,____(NONCE_1)____,nb) }hash(pmk,____(NONCE_1)____,nb) );\n\n\t\tclaim_A1( A, Secret, hash(pmk,____(NONCE_1)____,nb) );\n\t\tclaim_A2( A, Nisynch );\n\t}\t\n\t\n\trole ____(ROLE_1)____\n\t{\n\t\tvar ____(NONCE_1)____: Nonce;\n\t\tvar pmk: Nonce;\n\t\tfresh nb: Nonce;\n\n\t\trecv_1( A,____(ROLE_1)____, ____(NONCE_1)____ );\n\t\tsend_2( ____(ROLE_1)____,A, nb );\n\t\trecv_3( A,____(ROLE_1)____, { pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A)) }hash(pmk,____(NONCE_1)____,nb) );\n\t\tsend_4( ____(ROLE_1)____,A, { ____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____),{ hash(____(NONCE_1)____,nb,{ pmk }pk(____(ROLE_1)____)) }sk(A)) }hash(pmk,____(NONCE_1)____,nb) }hash(pmk,____(NONCE_1)____,nb) );\n\n\t\tclaim_B1( ____(ROLE_1)____, Secret, hash(pmk,____(NONCE_1)____,nb) );\n\t\tclaim_B2( ____(ROLE_1)____, Nisynch );\n\t}\n}",
        "complete:": "/*\n * This is a model of a version of the TLS protocol as modeled in\n * Boyd, Mathuria \"Protocols for Authentication and key establishment\"\n *\n * It's a very simplified form.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/* below is just Scyther input and no further macro definitions */\n\nconst pk,hash: Function;\nsecret sk,unhash: Function;\ninversekeys(pk,sk);\ninversekeys(hash,unhash);\n\nconst Alice, Bob, Eve: Agent;\nconst Terence: Agent;\n\nprotocol tls-bm-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh na: Nonce;\n\t\tfresh pmk: Nonce;\n\t\tvar nb: Nonce;\n\n\t\tsend_1( A,B, na );\n\t\trecv_2( B,A, nb );\n\t\tsend_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\trecv_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_A1( A, Secret, hash(pmk,na,nb) );\n\t\tclaim_A2( A, Nisynch );\n\t}\t\n\t\n\trole B\n\t{\n\t\tvar na: Nonce;\n\t\tvar pmk: Nonce;\n\t\tfresh nb: Nonce;\n\n\t\trecv_1( A,B, na );\n\t\tsend_2( B,A, nb );\n\t\trecv_3( A,B, { pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) );\n\t\tsend_4( B,A, { na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A),{ hash(na,nb,{ pmk }pk(B),{ hash(na,nb,{ pmk }pk(B)) }sk(A)) }hash(pmk,na,nb) }hash(pmk,na,nb) );\n\n\t\tclaim_B1( B, Secret, hash(pmk,na,nb) );\n\t\tclaim_B2( B, Nisynch );\n\t}\n}"
    },
    {
        "file": "SPDL-1/wmf-brutus.spdl",
        "incomplete": "usertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,____(ROLE_1)____,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { ____(ROLE_1)____,kab }k(A,S) );\n\t}\n\n\trole ____(ROLE_1)____\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,____(ROLE_1)____, { A, kab }k(____(ROLE_1)____,S) );\n\n\t\tclaim_3(____(ROLE_1)____, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { ____(ROLE_1)____,kab }k(A,S) );\n\t\tsend_2(S,____(ROLE_1)____, { A, kab }k(____(ROLE_1)____,S) );\n\t}\n}",
        "complete:": "usertype SesKey, Server;\n\n/* Version from the Brutus reports\n*/\n\nprotocol wmfbrutus(A,B,S)\n{\n\trole A\n\t{\n\t\tfresh kab : SesKey;\n\n\t\tsend_1(A,S, A, { B,kab }k(A,S) );\n\t}\n\n\trole B\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_2(S,B, { A, kab }k(B,S) );\n\n\t\tclaim_3(B, Secret,kab);\n\t}\n\n\trole S\n\t{\n\t\tvar kab : SesKey;\n\n\t\trecv_1(A,S, A, { B,kab }k(A,S) );\n\t\tsend_2(S,B, { A, kab }k(B,S) );\n\t}\n}"
    }
]