[
    {
        "file": "EC-1/AAPI.ec",
        "incomplete": "(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type ____(TYPE_1)____.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type ____(TYPE_0)____.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : ____(OP_0)____ option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API.",
        "complete:": "(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type outputs_t.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type apiRes_data.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API."
    },
    {
        "file": "EC-1/abstract-ind-ror.ec",
        "incomplete": "(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype ____(TYPE_0)____.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop ____(OP_0)____: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        (* Set m to be an authentic message. *)\n      } else {\n        (* Set m to be a random string. *)\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed.",
        "complete:": "(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype cip.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop dec: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        (* Set m to be an authentic message. *)\n      } else {\n        (* Set m to be a random string. *)\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed."
    },
    {
        "file": "EC-1/AES.ec",
        "incomplete": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : ____(OP_5)____.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (____(OP_1)____:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (____(OP_0)____ : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (____(OP_3)____ : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : ____(LEMMA_2)____ (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: ____(OP_2)____.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state ____(OP_4)____: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ ____(LEMMA_0)____ k : ____(LEMMA_1)____ s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.",
        "complete:": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed."
    },
    {
        "file": "EC-1/AMPSemantics.ec",
        "incomplete": "(** Abstract class for multiparty semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The multiparty semantics class is establishes how a program can\n  be collaboratively animated. We define the multiparty semantics\n  assuming that program evaluation is carried out by three computing\n  nodes, each one holding a description of the program in pottentially\n  different languages. We restrict the multiparty semantics\n  to only three parties due to tool limitations. Nevertheless,\n  having a three-party set is explanatory enough to demonstrate\n  the concepts we want to explore in this work and the definitions\n  here presented can easily be extended to other party configurations.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of either request some local party\n  execution or a synchronised execution, where all parties, executing\n  at the same time, have the ability to perform distributed protocols\n  that require party interaction.\n\n  Finally, the semantics here specified contemplates the possiblity\n  of the execution disclosing the communication trace that is left by operations\n  that result from the collaboration of parties.\n*)\ntheory MultiPartySemantics.\n\n  (** Language L1 *)\n  clone import Language as L1.\n  (** Language L2 *)\n  clone import Language as L2.\n  (** Language L3 *)\n  clone import Language as L3.\n\n  (** Communication trace *)\n  type sideInfo_t.\n\n  (** Party identifiers for multiparty semantics *)\n  type partyId_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [stepP(id)] - localy executes party [id]. This procedure\n      is only used in multiparty semantics.\n      - [stepS] - inside a multiparty semantics, executes the entire\n      set of parties at the same time. This procedure should be used\n      to perform operations that require party synchronisation in the\n      multiparty setting.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P1 : L1.L, P2 : L2.L, P3 : L3.L) : unit\n    proc stepP(id : partyId_t) : bool\n    proc stepS() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n      - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type ____(TYPE_0)____.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc stepP(id: partyId_t): bool\n    proc stepS(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    include Sem [-init, setInput, getOutput]\n    proc init = Sem.init\n    proc setInput (x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P1 : L1.L, P2 : L2.L, P3 : L3.L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P1,P2,P3);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend MultiPartySemantics.",
        "complete:": "(** Abstract class for multiparty semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The multiparty semantics class is establishes how a program can\n  be collaboratively animated. We define the multiparty semantics\n  assuming that program evaluation is carried out by three computing\n  nodes, each one holding a description of the program in pottentially\n  different languages. We restrict the multiparty semantics\n  to only three parties due to tool limitations. Nevertheless,\n  having a three-party set is explanatory enough to demonstrate\n  the concepts we want to explore in this work and the definitions\n  here presented can easily be extended to other party configurations.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of either request some local party\n  execution or a synchronised execution, where all parties, executing\n  at the same time, have the ability to perform distributed protocols\n  that require party interaction.\n\n  Finally, the semantics here specified contemplates the possiblity\n  of the execution disclosing the communication trace that is left by operations\n  that result from the collaboration of parties.\n*)\ntheory MultiPartySemantics.\n\n  (** Language L1 *)\n  clone import Language as L1.\n  (** Language L2 *)\n  clone import Language as L2.\n  (** Language L3 *)\n  clone import Language as L3.\n\n  (** Communication trace *)\n  type sideInfo_t.\n\n  (** Party identifiers for multiparty semantics *)\n  type partyId_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [stepP(id)] - localy executes party [id]. This procedure\n      is only used in multiparty semantics.\n      - [stepS] - inside a multiparty semantics, executes the entire\n      set of parties at the same time. This procedure should be used\n      to perform operations that require party synchronisation in the\n      multiparty setting.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P1 : L1.L, P2 : L2.L, P3 : L3.L) : unit\n    proc stepP(id : partyId_t) : bool\n    proc stepS() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n      - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type output_event_t.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc stepP(id: partyId_t): bool\n    proc stepS(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    include Sem [-init, setInput, getOutput]\n    proc init = Sem.init\n    proc setInput (x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P1 : L1.L, P2 : L2.L, P3 : L3.L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P1,P2,P3);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend MultiPartySemantics."
    },
    {
        "file": "EC-1/AProtocolLibrary.ec",
        "incomplete": "(* Abstract class for protocol libraries *)\nrequire import AllCore List.\n\n(**\n  An abstract protocol library provides a set of secure\n  protocols that can be used to compute operations over\n  confidential data.\n\n  The library discloses protocols for secret operators,\n  input, output and a special declassification command that\n  reveals secret values. The last three protocols are concrete,\n  whereas the secret operators are left underspecified as it\n  is a general enough interface for protocols for secret operations.\n\n  Besides dealing with secret inputs, protocols also tolerate plain\n  values, that are assumed to be publicly known to all parties, as inputs.\n  Protocols leave a communication trace resulting from party interaction.\n\n  The library also provides a set of simulators that are\n  part of the security assumpiton made over the multiparty\n  protocols: the protocol is secure if there exists a simulator\n  that is able to reproduce the communication trace and output\n  shares of the corrupt parties.\n*)\ntheory ProtocolLibrary.\n\n  (** Number of parties involved in the protocol *)\n  op n : int.\n\n  (** Type of party identifiers *)\n  type partyId_t. \n\n  (** Raw values *)\n  type value_t.\n  (** Secret inputs *)\n  type ____(TYPE_2)____.\n  (** Secret outputs *)\n  type outputs_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: ____(TYPE_0)____ option ; trace: ____(TYPE_1)____ }.\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: ____(OP_3)____ list, sargs: value_t list) : value_t ____(OP_4)____ leakage_t ____(OP_2)____.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t ____(OP_1)____ sideInfo_t) ____(OP_0)____.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(a: inputs_t, l: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(x: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(x: inputs_t, y: leakage_t): trace_t distr.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\nend ProtocolLibrary.",
        "complete:": "(* Abstract class for protocol libraries *)\nrequire import AllCore List.\n\n(**\n  An abstract protocol library provides a set of secure\n  protocols that can be used to compute operations over\n  confidential data.\n\n  The library discloses protocols for secret operators,\n  input, output and a special declassification command that\n  reveals secret values. The last three protocols are concrete,\n  whereas the secret operators are left underspecified as it\n  is a general enough interface for protocols for secret operations.\n\n  Besides dealing with secret inputs, protocols also tolerate plain\n  values, that are assumed to be publicly known to all parties, as inputs.\n  Protocols leave a communication trace resulting from party interaction.\n\n  The library also provides a set of simulators that are\n  part of the security assumpiton made over the multiparty\n  protocols: the protocol is secure if there exists a simulator\n  that is able to reproduce the communication trace and output\n  shares of the corrupt parties.\n*)\ntheory ProtocolLibrary.\n\n  (** Number of parties involved in the protocol *)\n  op n : int.\n\n  (** Type of party identifiers *)\n  type partyId_t. \n\n  (** Raw values *)\n  type value_t.\n  (** Secret inputs *)\n  type inputs_t.\n  (** Secret outputs *)\n  type outputs_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: value_t list, sargs: value_t list) : value_t * leakage_t option.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t * sideInfo_t) distr.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(a: inputs_t, l: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(x: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(x: inputs_t, y: leakage_t): trace_t distr.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\nend ProtocolLibrary."
    },
    {
        "file": "EC-1/ASecretSharingScheme.ec",
        "incomplete": "(** Abstract class for secret sharing schemes *)\nrequire import List.\n\n(** \n  A secret sharing scheme is a cryptographic primitive whose\n  goal is to \"split\" some value into _n_ shares, such that the\n  knowledge of _t_ shares (_t_ < _n_) does not reveal any\n  sensitive information about the original value that was\n  shared.\n*)\ntheory SecretSharingScheme.\n\n  (** Party identifier *)\n  type partyId_t. (* 0..n_parties-1 *)\n\n  (** Number of parties *)\n  op ____(OP_0)____ : int.\n  (** Threshold of corrupt parties *)\n  op t : int.\n\n  (** Values *)\n  type value_t.\n  (** Individual shares *)\n  type ____(TYPE_0)____.\n  (** Set of all shares *)\n  type sharedValue_t = share_t list.\n\n  (** Shares a value among n-shares *)\n  op [lossless] nshr : int -> value_t -> sharedValue_t distr.\n  (** Unshares a shared value *)\n  op unshr: sharedValue_t -> value_t.\n\nend SecretSharingScheme.",
        "complete:": "(** Abstract class for secret sharing schemes *)\nrequire import List.\n\n(** \n  A secret sharing scheme is a cryptographic primitive whose\n  goal is to \"split\" some value into _n_ shares, such that the\n  knowledge of _t_ shares (_t_ < _n_) does not reveal any\n  sensitive information about the original value that was\n  shared.\n*)\ntheory SecretSharingScheme.\n\n  (** Party identifier *)\n  type partyId_t. (* 0..n_parties-1 *)\n\n  (** Number of parties *)\n  op n : int.\n  (** Threshold of corrupt parties *)\n  op t : int.\n\n  (** Values *)\n  type value_t.\n  (** Individual shares *)\n  type share_t.\n  (** Set of all shares *)\n  type sharedValue_t = share_t list.\n\n  (** Shares a value among n-shares *)\n  op [lossless] nshr : int -> value_t -> sharedValue_t distr.\n  (** Unshares a shared value *)\n  op unshr: sharedValue_t -> value_t.\n\nend SecretSharingScheme."
    },
    {
        "file": "EC-1/ASPSemantics.ec",
        "incomplete": "(** Abstract class for single party semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The single pary semantics class is parameterised by a language and\n  should establish how programs written in that language\n  are animated.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of requesting the execution\n  of one program statement at a time. The semantics also contemplates \n  the possiblity some side information being leaked by language instructions.\n*)\ntheory SinglePartySemantics.\n\n  (** Language *)\n  clone import Language.\n\n  (** Side information *)\n  type sideInfo_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [step] - sequential semantics procedures, that executes one\n      instruction of the program.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P : L) : unit\n    proc step() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n        - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type ____(TYPE_0)____.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc step(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    proc init = Sem.init\n    proc setInput(x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P : L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend SinglePartySemantics.",
        "complete:": "(** Abstract class for single party semantics *)\nrequire import AllCore List SmtMap.\n\nrequire import ALanguage ASecretSharingScheme.\n\n(**\n  The single pary semantics class is parameterised by a language and\n  should establish how programs written in that language\n  are animated.\n\n  Our semantics formalisation is based on adversarial code,\n  influenced by the UC model. Program evaluation is managed\n  by an environment, that can provide inputs to the program\n  being interpreted and also collect outputs at any time.\n  Furthermore, the environment can request the evaluation of\n  the program in a small-step basis. This evaluation is carried\n  out by an adversary, that, at a high-level, models the\n  inside behaviour of the environment inside the program\n  execution.\n\n  The adversary has the possibility of requesting the execution\n  of one program statement at a time. The semantics also contemplates \n  the possiblity some side information being leaked by language instructions.\n*)\ntheory SinglePartySemantics.\n\n  (** Language *)\n  clone import Language.\n\n  (** Side information *)\n  type sideInfo_t.\n\n  (** Semantics interface *)\n  (**\n    The semantics interface discloses 6 procedures:\n      - [init(P)] - initialises the evaluation with initial program P\n      - [step] - sequential semantics procedures, that executes one\n      instruction of the program.\n      - [stepInput(x)] - processes the input [x] provided by the environment\n      - [getOutput] - releases output to the environment\n  *)\n  module type Semantics = {\n    proc init(P : L) : unit\n    proc step() : sideInfo_t option\n    proc setInput(x : secret_t) : bool\n    proc getOutput() : secret_t option\n  }.\n\n  (** Environment semantics interface *)\n  (**\n    The environment semantics interface specifies how the\n    environment interacts with the program evaluation. It\n    discloses three procedures:\n      - [stepInput(x)] - provides input [x] to the program\n        - [getOutput] - collects output from the program\n      - [activate] - activates the adversary so that it can\n      procede with the actual program evaluation\n  *)\n  module type EnvSemInterface = {\n    proc setInput(x: secret_t): bool\n    proc getOutput(): secret_t option\n    proc activate(): sideInfo_t option\n  }.\n\n  (** Output event type *)\n  type output_event_t.\n\n  (** Environment *)\n  (** \n    The environment has oracle access to the environment \n    semantics interface in order to animate some program\n    via the [animate] procedure\n  *)\n  module type Environment (ESI: EnvSemInterface) = {\n    proc animate(): output_event_t \n  }.\n\n  (** Adversary semantics interface *)\n  (**\n    The adversary semantics interface specifies how the adversary\n    interacts with the program evaluation. It discloses two procedures:\n      - [stepP(id)] - locally executes party [id]\n      - [stepS] - performs a synchronised execution of the entire set\n      of parties\n  *)\n  module type AdvSemInterface = {\n    proc step(): sideInfo_t option\n  }.\n\n  (** Adversary *)\n  (**\n    The adversary has oracles access to the adversary\n    semantics interface in order to execute one instruction of\n    a program via the [step] procedure\n  *)\n  module type Adversary (ASI : AdvSemInterface) = {\n    proc step() : sideInfo_t option\n  }.\n\n  (** Concrete environment semantics interface *)\n  module EnvironmentSemanticsInterface (Sem : Semantics) (A : Adversary) = {\n    proc init = Sem.init\n    proc setInput(x: secret_t): bool = {\n      var r;\n      r <@ Sem.setInput(x);\n      return r;\n    }\n    proc getOutput(): secret_t option = {\n      var r;\n      r <@ Sem.getOutput();\n      return r;\n    }\n    proc activate(): sideInfo_t option = {\n      var r;\n      r <@ A(Sem).step();\n      return r;\n    }\n  }.\n\n  (** General evaluation strategy *)\n  module Eval(Sem : Semantics, Z : Environment, A : Adversary) = {\n    proc eval(P : L) = {\n      var b;\n      EnvironmentSemanticsInterface(Sem,A).init(P);\n      b <@ Z(EnvironmentSemanticsInterface(Sem,A)).animate();\n      return (b);\n    }\n  }.\n\nend SinglePartySemantics."
    },
    {
        "file": "EC-1/bad_abs.ec",
        "incomplete": "require import AllCore Distr.\n\ntype input_a.  \ntype ____(TYPE_0)____.  \n\nmodule type Adv = {\n  proc a(x:input_a) : output_a\n}.\n\ntype input_m.\n\nmodule type Main(A:Adv) = {\n  proc main(x:input_m): bool\n}.  \n\nmodule type NegA (A:Adv) = {\n  proc a(x:input_a) : output_a {A.a}\n}.\n\nsection TEST.\n\n\n   declare module M1 <: Main.\n   declare ____(DECLARE_0)____ M2 <: Main.\n   declare module N <: NegA.\n   declare module ____(DECLARE_1)____ <: Adv.\n\n   lemma test : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (forall &m vx,  Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] =\n                       1%r - Pr[M1(A).main(vx) @ &m : E1 (glob M1) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = \n                       1%r - Pr[M2(A).main(vx) @ &m : E2 (glob M2) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : B (glob M2) (glob A)] = Pr[M2(A).main(vx) @ &m : B (glob M2) (glob A)]) =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA N1 N2 NB &m1 &m2 vx1 vx2 Hpre HglobA. \n     case: (Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]) => Hle.\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] - Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] by smt ().     \n     have : Pr[M1(N(A)).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(N(A)).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eNA => // &1 &2 /#. \n     rewrite Pr [mu_or]; rewrite (N1 &m1 vx1) (N2 &m2 vx2) (NB &m2 vx2); smt (mu_bounded).\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] -Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] by smt ().  \n     have : Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eA => // &1 &2 /#. \n     rewrite Pr [mu_or]; smt (mu_bounded).\n   qed.\n  \nend section TEST.\n\nsection TEST1.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test1 : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [ M1(N(A)).main ~ M1(A).main : ={glob M1, glob A}  ==> (E1 (glob M1) (glob A) res){1} = !(E1 (glob M1) (glob A) res){2}]) =>\n       (equiv [ M2(N(A)).main ~ M2(A).main : ={glob M2, glob A}  ==> (E2 (glob M2) (glob A) res){1} = !(E2 (glob M2) (glob A) res){2} /\\\n                                                                     (B (glob M2) (glob A)){1} = (B (glob M2) (glob A)){2}]) => \n       islossless M1(A).main =>\n       islossless M2(A).main =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA e1 e2 ll1 ll2 &m1 &m2 vx1 vx2 Hpre HglobA. \n     apply (test M1 M2 N A pre E1 E2 B eA eNA _ _ _ &m1 &m2 vx1 vx2 Hpre HglobA).\n     + move=> &m vx. \n       have -> : Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] = Pr[M1(A).main(vx) @ &m : !E1 (glob M1) (glob A) res].\n       + byequiv e1 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll1.\n     + move=> &m vx. \n       have -> : Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = Pr[M2(A).main(vx) @ &m : !E2 (glob M2) (glob A) res].\n       + byequiv e2 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll2.\n     by move=> &m vx;byequiv e2 => // /#.\n   qed.\n\nend section TEST1.",
        "complete:": "require import AllCore Distr.\n\ntype input_a.  \ntype output_a.  \n\nmodule type Adv = {\n  proc a(x:input_a) : output_a\n}.\n\ntype input_m.\n\nmodule type Main(A:Adv) = {\n  proc main(x:input_m): bool\n}.  \n\nmodule type NegA (A:Adv) = {\n  proc a(x:input_a) : output_a {A.a}\n}.\n\nsection TEST.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (forall &m vx,  Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] =\n                       1%r - Pr[M1(A).main(vx) @ &m : E1 (glob M1) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = \n                       1%r - Pr[M2(A).main(vx) @ &m : E2 (glob M2) (glob A) res]) =>\n       (forall &m vx,  Pr[M2(N(A)).main(vx) @ &m : B (glob M2) (glob A)] = Pr[M2(A).main(vx) @ &m : B (glob M2) (glob A)]) =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA N1 N2 NB &m1 &m2 vx1 vx2 Hpre HglobA. \n     case: (Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]) => Hle.\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] - Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] by smt ().     \n     have : Pr[M1(N(A)).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(N(A)).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eNA => // &1 &2 /#. \n     rewrite Pr [mu_or]; rewrite (N1 &m1 vx1) (N2 &m2 vx2) (NB &m2 vx2); smt (mu_bounded).\n     have ->: \n      `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res]| = \n      Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] -Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] by smt ().  \n     have : Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] <= \n            Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res \\/ B (glob M2) (glob A)].\n     + by byequiv eA => // &1 &2 /#. \n     rewrite Pr [mu_or]; smt (mu_bounded).\n   qed.\n  \nend section TEST.\n\nsection TEST1.\n\n\n   declare module M1 <: Main.\n   declare module M2 <: Main.\n   declare module N <: NegA.\n   declare module A <: Adv.\n\n   lemma test1 : \n     forall (pre : input_m -> input_m -> glob M1 -> glob M2 -> bool)\n            (E1: glob M1 -> glob A -> bool -> bool) \n            (E2: glob M2 -> glob A -> bool -> bool) \n            (B : glob M2 -> glob A -> bool),\n       (equiv [M1(A).main ~ M2(A).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [M1(N(A)).main ~ M2(N(A)).main : pre x{1} x{2} (glob M1){1} (glob M2){2} /\\ ={glob A} ==> \n                       !(B (glob M2) (glob A)){2} => \n                          (E1 (glob M1) (glob A) res){1} = (E2 (glob M2) (glob A) res){2}]) =>\n       (equiv [ M1(N(A)).main ~ M1(A).main : ={glob M1, glob A}  ==> (E1 (glob M1) (glob A) res){1} = !(E1 (glob M1) (glob A) res){2}]) =>\n       (equiv [ M2(N(A)).main ~ M2(A).main : ={glob M2, glob A}  ==> (E2 (glob M2) (glob A) res){1} = !(E2 (glob M2) (glob A) res){2} /\\\n                                                                     (B (glob M2) (glob A)){1} = (B (glob M2) (glob A)){2}]) => \n       islossless M1(A).main =>\n       islossless M2(A).main =>\n       forall &m1 &m2 vx1 vx2, pre vx1 vx2 (glob M1){m1} (glob M2){m2} => (glob A){m1} = (glob A){m2} => \n         `|Pr[M1(A).main(vx1) @ &m1 : E1 (glob M1) (glob A) res] - Pr[M2(A).main(vx2) @ &m2 : E2 (glob M2) (glob A) res] | <=\n          Pr[M2(A).main(vx2) @ &m2 : B (glob M2) (glob A)].\n   proof.\n     move=> pre E1 E2 B eA eNA e1 e2 ll1 ll2 &m1 &m2 vx1 vx2 Hpre HglobA. \n     apply (test M1 M2 N A pre E1 E2 B eA eNA _ _ _ &m1 &m2 vx1 vx2 Hpre HglobA).\n     + move=> &m vx. \n       have -> : Pr[M1(N(A)).main(vx) @ &m : E1 (glob M1) (glob A) res] = Pr[M1(A).main(vx) @ &m : !E1 (glob M1) (glob A) res].\n       + byequiv e1 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll1.\n     + move=> &m vx. \n       have -> : Pr[M2(N(A)).main(vx) @ &m : E2 (glob M2) (glob A) res] = Pr[M2(A).main(vx) @ &m : !E2 (glob M2) (glob A) res].\n       + byequiv e2 => // /#. \n       by rewrite Pr [mu_not];congr;byphoare ll2.\n     by move=> &m vx;byequiv e2 => // /#.\n   qed.\n\nend section TEST1."
    },
    {
        "file": "EC-1/BarrettReduction_Concrete.ec",
        "incomplete": "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BarrettReduction_Abstract BigNum_spec BigNum_proofs DoubleBigNum_proofs.\nrequire import W64_SchnorrExtract.\nrequire import AuxLemmas.\nimport W64x2N.\nimport W64xN.\n\n\nop ri_uncompute p = (nasty_id ri) p (dnlimbs * nlimbs).\nlemma ____(LEMMA_2)____ p : ____(LEMMA_0)____ (____(LEMMA_1)____ p)%W64xN = ri (valR p)%W64xN (dnlimbs * nlimbs).\n    rewrite /ri_uncompute nasty_id. trivial.\nqed.\n\n\nequiv breduce_cspec:\n M(Syscall).bn_breduce ~ CSpecFp.redm:\n     W64x2N.valR a{1} = a{2} \n /\\  W64x2N.valR r{1} = r{2} \n /\\  W64xN.valR p{1} = p{2}\n /\\  k{2} = 64 * nlimbs\n /\\  0 < p{2}\n   ==>  (W64xN.valR res{1}) = res{2}  %% W64xN.modulusR.\nproof. proc.\nsp.\nsimplify.\nseq 0 0 : (_a{1} = a{1} /\\ valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}). \nskip. auto.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} (* /\\ xr{2} = a{2} * r{2} *)).\ncall dmuln_spec. skip. progress.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64x2N.valR xrf{1} = xrf{2} ).\necall {1} (bn_div2_correct xr{1}). inline*. wp.  skip. move => &1 &2 z. split. auto. move => _.\nmove => r zz. split. smt(). split. smt(). split. smt(). split. smt(). split. smt(). rewrite zz.\nhave -> : W64x2N.modulusR = 2 ^ (2 * k{2}). smt(@Ring). smt().\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\  W64xN.valR xrfd{1} =  xrf{2}   ).\necall {1} (bn_shrink_correct xrf{1}). wp. skip. progress. \nseq 2 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ valR xrfd{1} = xrf{2} \n    /\\  W64x2N.valR xrfn{1} = xrfn{2}).\necall  (muln_spec xrfd{1} p{1}). wp. skip. progress.\nseq 3 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}).\ncall dsubc_spec. wp. skip. progress.\nseq 1 0 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}).\necall {1} (bn_expand_correct p{1}). skip. progress.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}\n    /\\ W64x2N.valR t{1} = t{2} ).\ncall dcminusP_spec. skip. progress.\nseq 1 0 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64xN.valR res_0{1} = W64x2N.valR t{1} %% W64xN.modulusR).\necall {1} (bn_shrink_correct t{1}). skip. progress.\nskip.  progress. \nqed.\n\n\nlemma modulusR_val : \nW64xN.modulusR =  2 ^ (dnlimbs * nlimbs). rewrite /W64xN.modulusR. smt(@Ring).\nqed.\n\nequiv bnreduce_spec:\n M(Syscall).bn_breduce ~ ASpecFp.redm:\n  valR a{1} = a{2}\n  /\\ ImplZZ p{1} p{2}\n  /\\ valR r{1} = ri_uncompute p{2} (* (ri p{2} (64 * nlimbs))   *)\n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 <= valR r{1} ==> valR res{1} = res{2} .\nproof. \n  have redm_simp:\n equiv [ ASpecFp.redm ~ ASpecFp.redm: ={arg} /\\ 0 < p{2} < W64xN.modulusR  ==> res{1} = res{2} %% W64xN.modulusR ].\n proc. wp.  skip. progress. \nrewrite (pmod_small (a{2} %% p{2})) . split.  apply modz_ge0. \nsmt().\nmove => q.\nsmt(ltz_pmod).\nauto.\nsymmetry. transitivity ASpecFp.redm\n (={arg} /\\ 0 < p{2} && p{2} < W64xN.modulusR ==> res{1} = res{2} %% W64xN.modulusR)\n (valR a{2} = a{1}\n  /\\ ImplZZ p{2} p{1}\n  /\\ valR r{2} =  (ri p{1} (64 * nlimbs))  \n  /\\ 0 < p{1} < W64xN.modulusR\n  /\\ 0 <= a{1} < p{1} * p{1}\n  /\\ 0 < p{1} < W64xN.modulusR\n  /\\ 0 <= valR r{2} ==> valR res{2} = res{1} %% W64xN.modulusR).\nsmt(ri_un).\nauto. conseq redm_simp. \nsymmetry.\ntransitivity CSpecFp.redm\n (W64x2N.valR a{1} = a{2} \n /\\  W64x2N.valR r{1} = r{2} \n /\\  W64xN.valR p{1} = p{2}\n /\\  k{2} = 64 * nlimbs \n /\\ 0 < p{2}\n   ==>  (W64xN.valR res{1}) = res{2}  %% W64xN.modulusR)\n (={a,p} /\\ r{1} = (ri p{2} k{1}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{1} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{1} \n  /\\ 0 <= k{1} ==> ={res}). \nmove => &1 &2 q. \nexists (valR a{1} , valR r{1} , 64 * nlimbs, valR p{1}). split. smt(). \nsplit. smt(). split. smt().   split.  smt(). \nsplit. smt(). split. split. smt().  move => ?. \nhave ->: (valR a{1}, valR r{1}, 64 * nlimbs).`3 = 64 * nlimbs. smt().\n have ->: 2 ^ (dnlimbs * nlimbs) = W64xN.modulusR. clear q. rewrite /W64xN.modulusR. smt(@Ring).\nsmt(). smt(). auto.\nconseq breduce_cspec.\nsymmetry. conseq redm_eq. \nsmt(). smt(). \nqed.\n\n\nlemma bnreduce_spec_ph aa pp:\n phoare [ M(Syscall).bn_breduce :  a = aa /\\ p = pp\n  /\\ valR r = ri_uncompute (valR p)\n  /\\ 0 < valR p < W64xN.modulusR\n  /\\ 0 <= valR a < valR p * valR p\n  /\\ 0 < valR p < W64xN.modulusR \n      ==> valR res = valR aa %% valR pp ] = 1%r.\nproof. bypr. progress.\n have <- : Pr[ASpecFp.redm(valR a{m}, valR p{m}) @ &m : valR a{m} %% valR p{m} = res] = 1%r. \n  byphoare (_: arg = (valR a{m}, valR p{m}) ==> _).\nproc. wp. skip. smt(). auto. auto.\nbyequiv. conseq bnreduce_spec.  \nprogress. \nsmt(@W64x2N). smt(). auto. auto.\nqed.\n\nop [____(OP_1)____] ____(OP_0)____ (n : int) = ____(OP_2)____ ^ (64 * nlimbs) %/ n.\nlemma bn_bnreduce_correct &m r x n:\n W64x2N.valR r =  big_value (W64xN.valR n)\n => 0 < (W64xN.valR n) \n => W64x2N.valR x < valR n * valR n\n => Pr[ M(Syscall).bn_breduce(r,x,n) @&m : W64xN.valR res = W64x2N.valR x %% W64xN.valR n ] = 1%r.\nproof.  move => eq1 c2 c3.\nbyphoare (_: arg = (r,x,n) ==> _).\nconseq (bnreduce_spec_ph x n).\nprogress. rewrite eq1. rewrite /big_value. rewrite /ri_uncompute nasty_id /ri. smt().\nsmt(@W64xN).\nsmt(@W64x2N).\nsmt(@W64xN).\nauto. auto.\nqed.\n\nlemma bnreduce_small_spec_ph aaa ppp:\n phoare [ M(Syscall).bn_breduce_small :  a = aaa /\\ p = ppp\n  /\\ valR r = ri_uncompute (valR p)\n  /\\ 0 < valR p < W64xN.modulusR\n  /\\ 0 <= valR a < valR p * valR p\n  /\\ 0 < valR p < W64xN.modulusR \n      ==> valR res = valR aaa %% valR ppp ] = 1%r.\nproc. \nsimplify.\nseq 3 : (  a = aaa /\\\n  p = ppp /\\\n  valR r = (ri_uncompute (valR p)) /\\\n  (0 < valR p && valR p < W64xN.modulusR) /\\\n  (0 <= valR a && valR a < valR p * valR p) /\\\n  0 < valR p && valR p < W64xN.modulusR /\\ \n  valR aa = valR a) 1%r.  \ncall (_:true). \nwhile (i <= 2*nlimbs /\\ aux = 2*nlimbs) .  wp.  skip. smt().\nwp. while (i <= 32) .  wp.  skip. smt(). wp. skip. progress. \nwp.  skip. auto.\ncall (bn_expand_correct aaa).  wp. skip. progress.\nexists* aa. elim*. move => aa0.\ncall (bnreduce_spec_ph aa0 ppp). skip. progress. smt(@W64xN). smt().\nsmt(). \nhoare. simplify. call (bn_expand_ho aaa). wp.  skip. progress. auto.\nqed.",
        "complete:": "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BarrettReduction_Abstract BigNum_spec BigNum_proofs DoubleBigNum_proofs.\nrequire import W64_SchnorrExtract.\nrequire import AuxLemmas.\nimport W64x2N.\nimport W64xN.\n\n\nop ri_uncompute p = (nasty_id ri) p (dnlimbs * nlimbs).\nlemma ri_un p : ri_uncompute (valR p)%W64xN = ri (valR p)%W64xN (dnlimbs * nlimbs).\n    rewrite /ri_uncompute nasty_id. trivial.\nqed.\n\n\nequiv breduce_cspec:\n M(Syscall).bn_breduce ~ CSpecFp.redm:\n     W64x2N.valR a{1} = a{2} \n /\\  W64x2N.valR r{1} = r{2} \n /\\  W64xN.valR p{1} = p{2}\n /\\  k{2} = 64 * nlimbs\n /\\  0 < p{2}\n   ==>  (W64xN.valR res{1}) = res{2}  %% W64xN.modulusR.\nproof. proc.\nsp.\nsimplify.\nseq 0 0 : (_a{1} = a{1} /\\ valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}). \nskip. auto.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} (* /\\ xr{2} = a{2} * r{2} *)).\ncall dmuln_spec. skip. progress.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64x2N.valR xrf{1} = xrf{2} ).\necall {1} (bn_div2_correct xr{1}). inline*. wp.  skip. move => &1 &2 z. split. auto. move => _.\nmove => r zz. split. smt(). split. smt(). split. smt(). split. smt(). split. smt(). rewrite zz.\nhave -> : W64x2N.modulusR = 2 ^ (2 * k{2}). smt(@Ring). smt().\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\  W64xN.valR xrfd{1} =  xrf{2}   ).\necall {1} (bn_shrink_correct xrf{1}). wp. skip. progress. \nseq 2 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ valR xrfd{1} = xrf{2} \n    /\\  W64x2N.valR xrfn{1} = xrfn{2}).\necall  (muln_spec xrfd{1} p{1}). wp. skip. progress.\nseq 3 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs  /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}).\ncall dsubc_spec. wp. skip. progress.\nseq 1 0 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}).\necall {1} (bn_expand_correct p{1}). skip. progress.\nseq 1 1 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}\n    /\\ W64x2N.valR t{1} = t{2} ).\ncall dcminusP_spec. skip. progress.\nseq 1 0 : (valR a{1} = a{2} /\\ valR r{1} = r{2} /\\ ImplZZ p{1} p{2} /\\ k{2} = 64 * nlimbs /\\  0 < p{2}\n    /\\ W64x2N.valR2 xr{1} = xr{2} /\\ W64xN.valR xrfd{1} = xrf{2} \n    /\\ W64x2N.valR xrfn{1} = xrfn{2}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64x2N.valR pp{1} = W64xN.valR p{1}\n    /\\ W64x2N.valR t{1} = t{2}\n    /\\ W64xN.valR res_0{1} = W64x2N.valR t{1} %% W64xN.modulusR).\necall {1} (bn_shrink_correct t{1}). skip. progress.\nskip.  progress. \nqed.\n\n\nlemma modulusR_val : \nW64xN.modulusR =  2 ^ (dnlimbs * nlimbs). rewrite /W64xN.modulusR. smt(@Ring).\nqed.\n\nequiv bnreduce_spec:\n M(Syscall).bn_breduce ~ ASpecFp.redm:\n  valR a{1} = a{2}\n  /\\ ImplZZ p{1} p{2}\n  /\\ valR r{1} = ri_uncompute p{2} (* (ri p{2} (64 * nlimbs))   *)\n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 <= valR r{1} ==> valR res{1} = res{2} .\nproof. \n  have redm_simp:\n equiv [ ASpecFp.redm ~ ASpecFp.redm: ={arg} /\\ 0 < p{2} < W64xN.modulusR  ==> res{1} = res{2} %% W64xN.modulusR ].\n proc. wp.  skip. progress. \nrewrite (pmod_small (a{2} %% p{2})) . split.  apply modz_ge0. \nsmt().\nmove => q.\nsmt(ltz_pmod).\nauto.\nsymmetry. transitivity ASpecFp.redm\n (={arg} /\\ 0 < p{2} && p{2} < W64xN.modulusR ==> res{1} = res{2} %% W64xN.modulusR)\n (valR a{2} = a{1}\n  /\\ ImplZZ p{2} p{1}\n  /\\ valR r{2} =  (ri p{1} (64 * nlimbs))  \n  /\\ 0 < p{1} < W64xN.modulusR\n  /\\ 0 <= a{1} < p{1} * p{1}\n  /\\ 0 < p{1} < W64xN.modulusR\n  /\\ 0 <= valR r{2} ==> valR res{2} = res{1} %% W64xN.modulusR).\nsmt(ri_un).\nauto. conseq redm_simp. \nsymmetry.\ntransitivity CSpecFp.redm\n (W64x2N.valR a{1} = a{2} \n /\\  W64x2N.valR r{1} = r{2} \n /\\  W64xN.valR p{1} = p{2}\n /\\  k{2} = 64 * nlimbs \n /\\ 0 < p{2}\n   ==>  (W64xN.valR res{1}) = res{2}  %% W64xN.modulusR)\n (={a,p} /\\ r{1} = (ri p{2} k{1}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{1} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{1} \n  /\\ 0 <= k{1} ==> ={res}). \nmove => &1 &2 q. \nexists (valR a{1} , valR r{1} , 64 * nlimbs, valR p{1}). split. smt(). \nsplit. smt(). split. smt().   split.  smt(). \nsplit. smt(). split. split. smt().  move => ?. \nhave ->: (valR a{1}, valR r{1}, 64 * nlimbs).`3 = 64 * nlimbs. smt().\n have ->: 2 ^ (dnlimbs * nlimbs) = W64xN.modulusR. clear q. rewrite /W64xN.modulusR. smt(@Ring).\nsmt(). smt(). auto.\nconseq breduce_cspec.\nsymmetry. conseq redm_eq. \nsmt(). smt(). \nqed.\n\n\nlemma bnreduce_spec_ph aa pp:\n phoare [ M(Syscall).bn_breduce :  a = aa /\\ p = pp\n  /\\ valR r = ri_uncompute (valR p)\n  /\\ 0 < valR p < W64xN.modulusR\n  /\\ 0 <= valR a < valR p * valR p\n  /\\ 0 < valR p < W64xN.modulusR \n      ==> valR res = valR aa %% valR pp ] = 1%r.\nproof. bypr. progress.\n have <- : Pr[ASpecFp.redm(valR a{m}, valR p{m}) @ &m : valR a{m} %% valR p{m} = res] = 1%r. \n  byphoare (_: arg = (valR a{m}, valR p{m}) ==> _).\nproc. wp. skip. smt(). auto. auto.\nbyequiv. conseq bnreduce_spec.  \nprogress. \nsmt(@W64x2N). smt(). auto. auto.\nqed.\n\nop [opaque] big_value (n : int) = 4 ^ (64 * nlimbs) %/ n.\nlemma bn_bnreduce_correct &m r x n:\n W64x2N.valR r =  big_value (W64xN.valR n)\n => 0 < (W64xN.valR n) \n => W64x2N.valR x < valR n * valR n\n => Pr[ M(Syscall).bn_breduce(r,x,n) @&m : W64xN.valR res = W64x2N.valR x %% W64xN.valR n ] = 1%r.\nproof.  move => eq1 c2 c3.\nbyphoare (_: arg = (r,x,n) ==> _).\nconseq (bnreduce_spec_ph x n).\nprogress. rewrite eq1. rewrite /big_value. rewrite /ri_uncompute nasty_id /ri. smt().\nsmt(@W64xN).\nsmt(@W64x2N).\nsmt(@W64xN).\nauto. auto.\nqed.\n\nlemma bnreduce_small_spec_ph aaa ppp:\n phoare [ M(Syscall).bn_breduce_small :  a = aaa /\\ p = ppp\n  /\\ valR r = ri_uncompute (valR p)\n  /\\ 0 < valR p < W64xN.modulusR\n  /\\ 0 <= valR a < valR p * valR p\n  /\\ 0 < valR p < W64xN.modulusR \n      ==> valR res = valR aaa %% valR ppp ] = 1%r.\nproc. \nsimplify.\nseq 3 : (  a = aaa /\\\n  p = ppp /\\\n  valR r = (ri_uncompute (valR p)) /\\\n  (0 < valR p && valR p < W64xN.modulusR) /\\\n  (0 <= valR a && valR a < valR p * valR p) /\\\n  0 < valR p && valR p < W64xN.modulusR /\\ \n  valR aa = valR a) 1%r.  \ncall (_:true). \nwhile (i <= 2*nlimbs /\\ aux = 2*nlimbs) .  wp.  skip. smt().\nwp. while (i <= 32) .  wp.  skip. smt(). wp. skip. progress. \nwp.  skip. auto.\ncall (bn_expand_correct aaa).  wp. skip. progress.\nexists* aa. elim*. move => aa0.\ncall (bnreduce_spec_ph aa0 ppp). skip. progress. smt(@W64xN). smt().\nsmt(). \nhoare. simplify. call (bn_expand_ho aaa). wp.  skip. progress. auto.\nqed."
    },
    {
        "file": "EC-1/basic-hash-auth.ec",
        "incomplete": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ____(TYPE_0)____.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : ____(HINT_0)____.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (____(LEMMA_0)____ : int) : ____(LEMMA_1)____ (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop ____(OP_0)____ : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed.",
        "complete:": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed."
    },
    {
        "file": "EC-1/basic-hash-single-tag.ec",
        "incomplete": "(* Authentication of a simplified Basic Hash protocol, with only one tag. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ____(TYPE_0)____.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (____(LEMMA_0)____ : int) : is_uniform dnonce ____(LEMMA_1)____ smt (dnonce_lluni).\n\nhint exact random : ____(HINT_0)____.\n\n(*-----------------------------------------------------------------------*)\n(* PRF *)\nop F : key -> ____(OP_0)____ -> ptxt.\n\nmodule type PRF = {\n  proc init () : unit\n  proc f(x : ptxt) : ptxt\n  proc check(x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRF_Oracles = {\n  include PRF[-init]\n}.\n\nmodule PRF = {\n  var k : key\n  \n  proc init() : unit = {\n    PRF.k <$ dkey;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    return F k x;\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable RF *)\n(* We assume that: \n   i) the hash function is indistinguishable from a lossless and uniform\n   distribution over ptxts (not full).\n   ii) the hash function is unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf: { ptxt distr |    is_lossless drf\n                       /\\ is_uniform drf } as drf_lluni.\n\nmodule EUF_RF = {\n  var m : (ptxt, ptxt) fmap\n  \n  proc init() : unit = {\n    m <- empty;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    var r : ptxt;\n    \n    if (x \\notin m) {\n      r <$ drf;\n      m.[x] <- r;\n    }\n    \n    return oget m.[x];\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (x \\in m && oget m.[x] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, with only one tag and one reader. *)\n\n(* Without initialization *)\nmodule BasicHash0 (H : PRF_Oracles) = {\n  proc tag () : ptxt * ptxt = {\n    var n, h;\n    n <$ dnonce;\n    h <@ H.f(n);\n    return (n, h);\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(n, h);\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRF) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(); \n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag () : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Basic Hash, 1 tag, with logs. *)\nmodule Log (BH : BasicHashT) = {\n  var tag_outputs   : (ptxt * ptxt) list\n  var reader_forged : (ptxt * ptxt) list\n\n  proc init () : unit = { \n    BH.init ();\n    tag_outputs <- [];\n    reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    tag_outputs <- x :: tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    (* We log messages accepted by the reader that the tag never send. *)\n    if (b && ! (mem tag_outputs m)){ \n      reader_forged <- m :: reader_forged;\n    }\n    return b;\n  }    \n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRF) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRF) = {\n  module BH = Log(BH(H))\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem Log.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Indistinguishability game for an unforgeable PRF. *)\nmodule type Distinguisher (F : PRF_Oracles) = {\n  proc distinguish(): bool\n}.\n\nmodule EUF_PRF_IND (F : PRF) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init();\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* In our PRF/RF distinguisher, we must use a slightly different log,\n   which is identical except that it does not initialize the BasicHash\n   protocol. *)\nmodule AuxLog (BH : BasicHashT0) = {\n  proc init () : unit = { \n    Log.tag_outputs <- [];\n    Log.reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    Log.tag_outputs <- x :: Log.tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    if (b && ! (mem Log.tag_outputs m)){ \n      Log.reader_forged <- m :: Log.reader_forged;\n    }\n    return b;\n  }    \n}.\n\nmodule type BasicHashF0 (H : PRF_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRF_Oracles) = {\n  module BH = AuxLog(BH(F))\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BH.init();\n    A.a();\n    return (exists x, mem Log.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {Log, BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {Log, BasicHash, PRF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: Log.reader_forged = [] /\\ \n           forall x y, (EUF_RF.m.[x] <> None && oget EUF_RF.m.[x] = y)\n                        => (x, y) \\in Log.tag_outputs{hr}); auto.\n  (* tag *)\n  + proc; inline *; auto.\n    seq 2: (#pre /\\ x0 = n); wp; 1 : by rnd => *; auto.\n    if; 2 : by auto; smt().\n    by wp; rnd; auto; smt(get_setE).\n\n  (* reader *)\n  + by proc; inline *; auto => /#.\n\n  + by move => *; smt. \nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRF,    D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  by rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); smt ().\nqed.",
        "complete:": "(* Authentication of a simplified Basic Hash protocol, with only one tag. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRF = {\n  proc init () : unit\n  proc f(x : ptxt) : ptxt\n  proc check(x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRF_Oracles = {\n  include PRF[-init]\n}.\n\nmodule PRF = {\n  var k : key\n  \n  proc init() : unit = {\n    PRF.k <$ dkey;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    return F k x;\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable RF *)\n(* We assume that: \n   i) the hash function is indistinguishable from a lossless and uniform\n   distribution over ptxts (not full).\n   ii) the hash function is unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf: { ptxt distr |    is_lossless drf\n                       /\\ is_uniform drf } as drf_lluni.\n\nmodule EUF_RF = {\n  var m : (ptxt, ptxt) fmap\n  \n  proc init() : unit = {\n    m <- empty;\n  }\n  \n  proc f(x : ptxt) : ptxt = {\n    var r : ptxt;\n    \n    if (x \\notin m) {\n      r <$ drf;\n      m.[x] <- r;\n    }\n    \n    return oget m.[x];\n  }\n\n  proc check(x : ptxt, s : ptxt) = {\n    return (x \\in m && oget m.[x] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, with only one tag and one reader. *)\n\n(* Without initialization *)\nmodule BasicHash0 (H : PRF_Oracles) = {\n  proc tag () : ptxt * ptxt = {\n    var n, h;\n    n <$ dnonce;\n    h <@ H.f(n);\n    return (n, h);\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(n, h);\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRF) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(); \n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag () : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Basic Hash, 1 tag, with logs. *)\nmodule Log (BH : BasicHashT) = {\n  var tag_outputs   : (ptxt * ptxt) list\n  var reader_forged : (ptxt * ptxt) list\n\n  proc init () : unit = { \n    BH.init ();\n    tag_outputs <- [];\n    reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    tag_outputs <- x :: tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    (* We log messages accepted by the reader that the tag never send. *)\n    if (b && ! (mem tag_outputs m)){ \n      reader_forged <- m :: reader_forged;\n    }\n    return b;\n  }    \n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRF) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRF) = {\n  module BH = Log(BH(H))\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem Log.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Indistinguishability game for an unforgeable PRF. *)\nmodule type Distinguisher (F : PRF_Oracles) = {\n  proc distinguish(): bool\n}.\n\nmodule EUF_PRF_IND (F : PRF) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init();\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* In our PRF/RF distinguisher, we must use a slightly different log,\n   which is identical except that it does not initialize the BasicHash\n   protocol. *)\nmodule AuxLog (BH : BasicHashT0) = {\n  proc init () : unit = { \n    Log.tag_outputs <- [];\n    Log.reader_forged <- [];\n  }\n\n  proc tag () : ptxt * ptxt = {\n    var x;\n    x <@ BH.tag ();\n    Log.tag_outputs <- x :: Log.tag_outputs;\n    return x;\n  }    \n\n  proc reader (m : ptxt * ptxt) : bool = {    \n    var b;\n    b <- BH.reader(m);\n    if (b && ! (mem Log.tag_outputs m)){ \n      Log.reader_forged <- m :: Log.reader_forged;\n    }\n    return b;\n  }    \n}.\n\nmodule type BasicHashF0 (H : PRF_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRF_Oracles) = {\n  module BH = AuxLog(BH(F))\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BH.init();\n    A.a();\n    return (exists x, mem Log.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {Log, BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {Log, BasicHash, PRF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: Log.reader_forged = [] /\\ \n           forall x y, (EUF_RF.m.[x] <> None && oget EUF_RF.m.[x] = y)\n                        => (x, y) \\in Log.tag_outputs{hr}); auto.\n  (* tag *)\n  + proc; inline *; auto.\n    seq 2: (#pre /\\ x0 = n); wp; 1 : by rnd => *; auto.\n    if; 2 : by auto; smt().\n    by wp; rnd; auto; smt(get_setE).\n\n  (* reader *)\n  + by proc; inline *; auto => /#.\n\n  + by move => *; smt. \nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {Log, BasicHash, PRF, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRF).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRF,    D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  by rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); smt ().\nqed."
    },
    {
        "file": "EC-1/br93.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire (*--*) BitWord OW ROM.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(* We start by proving Bellare and Rogaway's algorithm IND-CPA secure   *)\n(* on abstract datatypes with minimal structure. We then instantiate to *)\n(* semi-concrete fixed-length bitstrings (with abstract lengths).       *)\n(* -------------------------------------------------------------------- *)\nabstract theory BR93.\n(* -------------------------------------------------------------------- *)\n(* Let us consider the following abstract scenario construction. Given: *)\n(* -------------------------------------------------------------------- *)\n\n(* A set `ptxt` of plaintexts, equipped with an nilpotent addition (+^) *)\ntype ptxt.\n\nop (+^): ptxt -> ptxt -> ptxt.\naxiom addA p1 p2 p3: (p1 +^ p2) +^ p3 = p1 +^ (p2 +^ p3).\naxiom addC p1 p2: p1 +^ p2 = p2 +^ p1.\naxiom addKp p1 p2: (p1 +^ p1) +^ p2 = p2.\n\nlemma addpK p1 ____(LEMMA_2)____: p1 ____(LEMMA_3)____ p2 +^ p2 = p1.\nproof. by rewrite addC -addA addC -addA addKp. qed.\n\n(*                    and a lossless, full, uniform distribution dptxt; *)\nop dptxt: { ptxt distr |    is_lossless dptxt\n                         /\\ is_full dptxt\n                         /\\ is_uniform dptxt } as dptxt_llfuuni.\nlemma dptxt_ll: ____(LEMMA_4)____ dptxt by ____(LEMMA_5)____/(andWl _ dptxt_llfuuni).\nlemma dptxt_uni: is_uniform dptxt by have [#]:= dptxt_llfuuni.\nlemma dptxt_fu: is_full dptxt by have [#]:= dptxt_llfuuni.\nlemma dptxt_funi: is_funiform dptxt\nby exact/(is_full_funiform dptxt_fu dptxt_uni).\n\n(* A set `rand` of nonces, equipped with                                *)\n(*                              a lossless, uniform distribution drand; *)\ntype rand.\nop drand: { rand distr |    is_lossless drand\n                         /\\ is_uniform drand } as drand_lluni.\nlemma drand_ll: is_lossless drand by exact/(andWl _ drand_lluni).\nlemma drand_uni: is_uniform drand by exact/(andWr _ drand_lluni).\n\n(* A set `ctxt` of ciphertexts defined as                               *)\n(*                          the cartesian product of `rand` and `ptxt`; *)\ntype ctxt = rand ____(TYPE_0)____ ptxt.\n\n(* A set `pkey * skey` of keypairs, equipped with                       *)\n(*                        a lossless, full, uniform distribution dkeys; *)\ntype pkey, skey.\nop dkeys: { (pkey * skey) distr |    is_lossless dkeys\n                                  /\\ is_funiform dkeys } as dkeys_llfuni.\nlemma dkeys_ll: is_lossless dkeys by exact/(____(LEMMA_1)____ ____(LEMMA_0)____ dkeys_llfuni).\nlemma dkeys_funi: is_funiform dkeys by exact/(andWr _ dkeys_llfuni).\n\n(* A family `f` of trapdoor permutations over `rand`,                   *)\n(*       indexed by `pkey`, with inverse family `fi` indexed by `skey`; *)\nop f : ____(OP_1)____ -> rand -> rand.\nop fi: skey -> rand -> rand.\naxiom fK pk sk x: (pk,sk) \\in dkeys => fi sk (f pk x) = x.\n\nlemma fI pk x y: (exists sk, (pk,sk) \\in dkeys) =>\n  f pk x = f pk y => x = y.\nproof. by move=> [sk] + fx_eq_fy - /fK ^ /(_ x) <- /(_ y) <-; congr. qed.\n\n(* A random oracle from `rand` to `ptxt`, modelling a hash function H;  *)\n(* (we simply instantiate the generic theory of Random Oracles with     *)\n(*    the types and output distribution declared above, discharging all *)\n(*          assumptions on the instantiated parameters--there are none) *)\nclone import ROM as H with\n  type in_t    <- rand,\n  type out_t   <- ptxt,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <____(OP_2)____ dptxt.\nimport H.Lazy.\n\n(* We can define the Bellare-Rogaway 93 PKE Scheme.                     *)\n(* BR93 is a module that, given access to an oracle H from type         *)\n(*   `from` to type `rand` (see `print Oracle.`), implements procedures *)\n(*   `keygen`, `enc` and `dec` as follows described below.              *)\nmodule BR93 (H:Oracle) = {\n  (* `keygen` simply samples a key pair in `dkeys` *)\n  proc keygen() = {\n    var kp;\n\n    kp <$ dkeys;\n    return kp;\n  }\n\n  (* `enc` samples a random string `r` in `drand` and uses it to       *)\n  (*   produce a random mask `h` using the hash function, then returns *)\n  (*      the image of `r` by permutation `f` and the plaintext masked *)\n  (*                                                         with `h`. *)\n  proc enc(pk, m) = {\n    var r, h;\n\n    r <$ drand;\n    h <@ H.o(r);\n    return (f pk r,h +^ m);\n  }\n\n  (* `dec` parses its input as a nonce `r` and a masked plaintext `m` *)\n  (*  before recovering the original random string from `r` using the *)\n  (*      inverse permutation `fi` and computing its image `h` by the *)\n  (*  random oracle. The original plaintext is recovered by unmasking *)\n  (*                                                    `m` with `h`. *)\n  proc dec(sk, c) = {\n    var r, h, m;\n\n    (r,m) <- c;\n    r     <- fi sk r;\n    h     <- H.o(r);\n    return h +^ m;\n  }\n}.\n\n(* We can quickly prove it correct as a sanity check.                 *)\nsection Correctness.\nlocal module Correctness = {\n  proc main(m) = {\n    var pk, sk, c, m';\n\n    (pk,sk) <@ BR93(LRO).keygen();\n    c       <@ BR93(LRO).enc(pk,m);\n    m'      <@ BR93(LRO).dec(sk,c);\n    return (m = m');\n  }\n}.\n\nlocal lemma BR93_correct &m m: Pr[Correctness.main(m) @ &m: res] = 1%r.\nproof.\nbyphoare=> //; conseq (: _ ==> true) (: _ ==> res)=> //.\n+ proc; inline *.\n  rcondf 17.\n  + auto=> /> &hr [pk sk] kp_in_dkeys r _ y _ /=.\n    rewrite fK //; split=> [_ _ _|-> //].\n    by rewrite mem_set.\n  auto=> /> &hr [pk sk] kp_in_dkeys r _ y _ /=.\n  rewrite fK //; split=> [_ y' _|].\n  + by rewrite get_set_sameE -addA addKp.\n  rewrite domE; case: (LRO.m{hr}.[r])=> [|p] //= _ _.\n  by rewrite -addA addKp.\nby proc; inline *; auto=> />; rewrite dkeys_ll drand_ll dptxt_ll.\nqed.\nend section Correctness.\n\n(* However, what we are really interested in is proving that it is      *)\n(* IND-CPA secure if `f` is a one-way trapdoor permutation.             *)\n\n(* We use cloning to get definitions for OWTP security                  *)\nclone import OW as OW_rand with\n  type D           <- rand,\n  type R           <- rand,\n  type pkey        <- pkey,\n  type skey        <- skey,\n  op   dkeys       <- dkeys,\n  op   challenge _ <- drand,\n  op   f           <- f,\n  op   finv        <- fi\nproof dkeys_ll, finvof, challenge_ll, challenge_uni.\nrealize dkeys_ll by exact/dkeys_ll.\nrealize challenge_ll by move=> _ _; exact/drand_ll.\nrealize challenge_uni by move=> _ _; exact/drand_uni.\nrealize finvof by move=> pk sk x /fK ->.\n\n(* But we can't do it (yet) for IND-CPA because of the random oracle    *)\n(*             Instead, we define CPA for BR93 with that particular RO. *)\nmodule type Adv (ARO: POracle)  = {\n  proc a1(p:pkey): (ptxt * ptxt)\n  proc a2(c:ctxt): bool\n}.\n\n(* We need to log the random oracle queries made to the adversary       *)\n(*                               in order to express the final theorem. *)\nmodule Log (H:Oracle) = {\n  var qs: rand list\n\n  proc init() = {\n    qs <- [];\n          H.init();\n  }\n\n  proc o(x) = {\n    var r;\n\n    qs <- x::qs;\n    r  <@ H.o(x);\n    return r;\n  }\n}.\n\nmodule BR93_CPA(A:Adv) = {\n  proc main(): bool = {\n    var pk, sk, m0, m1, c, b, b';\n\n                Log(LRO).init();\n    (pk,sk)  <@ BR93(LRO).keygen();\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n    c        <@ BR93(LRO).enc(pk,b?m0:m1);\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\n(* We want to prove the following:                                      *)\n(*   forall (valid) CPA adversary A which makes at most q queries to H, *)\n(*     there exists a OW adversary I such that                          *)\n(*          `|Pr[BR_CPA(A): res] - 1/2| <= Pr[OW_f(I): res]             *)\n(* We construct I as follows, using A.a1 and A.a2 as black boxes        *)\nmodule I(A:Adv): Inverter = {\n  var x:rand\n\n  proc invert(pk:pkey,y:rand): rand = {\n    var m0, m1, h, b;\n\n               Log(LRO).init();\n    (m0,m1) <@ A(Log(LRO)).a1(pk);\n    h       <$ dptxt;\n    b       <@ A(Log(LRO)).a2(y,h);\n    x       <- nth witness Log.qs (find (fun p => f pk p = y) Log.qs);\n\n    return x;\n  }\n}.\n\n(* We now prove the result using a sequence of games                    *)\nsection.\n(* All lemmas in this section hold for all (valid) CPA adversary A      *)\ndeclare module ____(DECLARE_0)____ : Adv { LRO, Log }.\n\naxiom A_a1_ll (O <: POracle {A}): islossless O.o => islossless A(O).a1.\naxiom A_a2_ll (O <: POracle {A}): islossless O.o => islossless A(O).a2.\n\n(* Step 1: replace RO call with random sampling                         *)\nlocal module Game1 = {\n  var r: rand\n\n  proc main() = {\n    var pk, sk, m0, m1, b, h, c, b';\n                Log(LRO).init();\n    (pk,sk)  <$ dkeys;\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n\n    r        <$ drand;\n    h        <$ dptxt;\n    c        <- ((f pk r),h +^ (b?m0:m1));\n\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\nlocal lemma pr_Game0_Game1 &m:\n     Pr[BR93_CPA(A).main() @ &m: res]\n  <=   Pr[Game1.main() @ &m: res]\n     + Pr[Game1.main() @ &m: Game1.r \\in Log.qs].\nproof.\nbyequiv=> //; proc.\ninline BR93(LRO).enc BR93(LRO).keygen.\n(* Until the replaced RO call, the two games are in sync.               *)\n(*        In addition, the log's contents coincide with the RO queries. *)\nseq  8  5: (   ={glob A, glob LRO, glob Log, pk, sk, b}\n            /\\ pk0{1} = pk{2}\n            /\\ m{1} = (b?m0:m1){2}\n            /\\ r{1} = Game1.r{2}\n            /\\ (forall x, x \\in Log.qs{1} <=> x \\in LRO.m{1})).\n+ auto; call (:   ={glob Log, glob LRO}\n               /\\ (forall x, x \\in Log.qs{1} <=> x \\in LRO.m{1})).\n  + proc; inline LRO.o.\n    by auto=> /> &2 log_is_dom y _; smt(@SmtMap).\n  by inline *; auto=> /> _ _ x; rewrite mem_empty.\n(* We now deal with everything that happens after the programs differ: *)\n(*   - until r gets queried to the random oracle by the adversary      *)\n(*     (and if it wasn't already queried by a1), we guarantee that the *)\n(*     random oracles agree except on r                                *)\n(*   - if the adversary queries r to the random oracle (or if it has   *)\n(*     already done so in a1), we give up                              *)\n(* Because we reason up to bad, we need to prove that bad is stable    *)\n(* and that the adversary and its oracles are lossless                 *)\ncall (_: Game1.r \\in Log.qs,\n         eq_except (pred1 Game1.r{2}) LRO.m{1} LRO.m{2}).\n+ exact/A_a2_ll.\n+ proc; inline LRO.o.\n  auto=> /> &1 &2 _ m1_eqe_m2 yL y_in_dptxt; split.\n  + move=> x_notin_m; split.\n    + by rewrite !get_set_sameE eq_except_set_eq.\n    move: m1_eqe_m2 x_notin_m=> + + + r_neq_x.\n    by rewrite eq_exceptP pred1E !domE=> /(_ x{2} r_neq_x) ->.\n  move=> x_in_m; split.\n  + move: m1_eqe_m2 x_in_m=> + + + r_neq_x.\n    by rewrite eq_exceptP pred1E !domE=> /(_ x{2} r_neq_x) ->.\n  by move: m1_eqe_m2=> + _ r_neq_x- /eq_exceptP /(_ x{2}); rewrite pred1E=> /(_ r_neq_x) ->.\n+ by move=> &2 _; proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll.\n+ move=> _ /=; proc; inline *.\n  conseq (: true ==> true: =1%r) (: Game1.r \\in Log.qs ==> Game1.r \\in Log.qs)=> //=.\n  + by auto=> />.\n  by auto=> />; exact/dptxt_ll.\ninline LRO.o; case: ((r \\in LRO.m){1}).\n+ conseq (: _ ==> ={b} /\\ Game1.r{2} \\in Log.qs{2})=> //=.\n  + by move=> /> &1 &2 _ _ rR _ _ _ _ _ h /h [] -> //.\n  by auto=> /> &2 <- ->.\nrcondt{1} 3; 1:by auto.\nauto=> /> &2 log_is_dom r_notin_m y _; rewrite !get_set_sameE oget_some /=.\nsplit.\n+ by move=> _; rewrite eq_exceptP /pred1=> x; rewrite get_setE eq_sym=> ->.\nby move=> _ rR aL mL aR qsR mR h /h [] ->.\nqed.\n\n(* Step 2: replace h ^ m with h in the challenge encryption            *)\nlocal module Game2 = {\n  var r: rand\n\n  proc main() = {\n    var pk, sk, m0, m1, b, h, c, b';\n                Log(LRO).init();\n    (pk,sk)  <$ dkeys;\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n\n    r        <$ drand;\n    h        <$ dptxt;\n    c        <- ((f pk r),h);\n\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\nlocal equiv eq_Game1_Game2: Game1.main ~ Game2.main:\n  ={glob A} ==> ={glob Log, res} /\\ Game1.r{1} = Game2.r{2}.\nproof.\nproc.\ncall (: ={glob Log, glob LRO}); 1: by sim.\nwp; rnd (fun x=> x +^ (b?m0:m1){2}).\nauto; call (: ={glob Log, glob LRO}); 1: by sim.\ninline *; auto=> /> _ _ rR b _ rL _; split=> [|_].\n+ by move=> hR _; rewrite addpK.\nsplit=> [|_].\n+ by move=> hR _; exact/dptxt_funi.\nby move=> hL _; rewrite dptxt_fu /= addpK.\nqed.\n\nlocal lemma pr_Game1_Game2 &m:\n  Pr[Game1.main() @ &m: res] = Pr[Game2.main() @ &m: res].\nproof. by byequiv eq_Game1_Game2. qed.\n\nlocal lemma pr_bad_Game1_Game2 &m:\n    Pr[Game1.main() @ &m: Game1.r \\in Log.qs]\n  = Pr[Game2.main() @ &m: Game2.r \\in Log.qs].\nproof. by byequiv eq_Game1_Game2. qed.\n\nlocal lemma pr_Game2 &m: Pr[Game2.main() @ &m: res] = 1%r / 2%r.\nproof.\nbyphoare=> //=; proc.\nswap 4 4.\nwp; rnd (pred1 b')=> //=.\ninline *; call (_: true).\n+ exact A_a2_ll. (* adversary *)\n+ by proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll. (* oracle *)\nauto; call (_: true).\n+ exact A_a1_ll. (* adversary *)\n+ by proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll. (* oracle *)\nauto=> />; rewrite dkeys_ll drand_ll dptxt_ll /predT /=.\nby move=> _ _ _ _ _ _ r; rewrite dbool1E pred1E.\nqed.\n\n(* Step 3: The reduction step -- if A queries the RO with the randomness *)\n(*     used to encrypt the challenge, then I(A) inverts the OW challenge *)\n(* We need a version of the one-way game where the challenge is a global *)\nlocal module OWr (I : Inverter) = {\n  var x : rand\n\n  proc main() : bool = {\n    var x', pk, sk;\n\n    (pk,sk) <$ dkeys;\n    x       <$ drand;\n    x'      <@ I.invert(pk,f pk x);\n    return (x = x');\n  }\n}.\n\n(* We can easily prove that it is strictly equivalent to OW              *)\nlocal lemma OW_OWr &m (I <: Inverter {OWr}):\n  Pr[OW(I).main() @ &m: res]\n  = Pr[OWr(I).main() @ &m: res].\nproof. by byequiv=> //=; sim. qed.\n\nlocal lemma pr_Game2_OW &m:\n  Pr[Game2.main() @ &m: Game2.r \\in Log.qs]\n  <= Pr[OW(I(A)).main() @ &m: res].\nproof.\nrewrite (OW_OWr &m (I(A))). (* Note: we proved it forall (abstract) I    *)\nbyequiv => //=; proc; inline *; wp.\nconseq\n  (_ : _ ==>\n       support dkeys (pk0{2}, sk{2}) /\\\n       Game2.r{1} = OWr.x{2} /\\ Log.qs{1} = Log.qs{2} /\\\n       y{2} = f pk0{2} Game2.r{1}).\n+ move=> /> qs x pk sk vk x_in_qs; pose P := fun p => f _ p = _.\n  have h := nth_find witness P qs _.\n  + by rewrite hasP; exists x.\n  apply/(fI pk).\n  + by exists sk.\n  by rewrite h.\n(* rest of proof *)\ncall (: ={glob Log, glob LRO}); 1: by sim.\nswap{1} 6 -2.\nauto; call (: ={glob Log, glob LRO}); 1: by sim.\nby auto=> /> [pk sk] ->.\nqed.\n\nlemma Reduction &m:\n  Pr[BR93_CPA(A).main() @ &m : res] - 1%r/2%r\n  <= Pr[OW(I(A)).main() @ &m: res].\nproof.\nsmt(pr_Game0_Game1 pr_Game1_Game2 pr_bad_Game1_Game2 pr_Game2 pr_Game2_OW).\nqed.\nend section.\nend BR93.\n\n(* We now consider a concrete instance:                                 *)\n(*   - plaintexts are bitstrings of length k > 0                        *)\n(*   - nonces are bitstrings of length l > 0                            *)\n(*   - ciphertexts are bitstrings of length n = k + l                   *)\n\n(* Plaintexts                                                           *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Plaintext with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"ptxt\"\n  \"dunifin\" as \"dptxt\".\nimport DWord.\n\n(* Nonces                                                               *)\nop l : { int | 0 < l } as gt0_l.\n\nclone import BitWord as Randomness with\n  op n <- l\nproof gt0_n by exact/gt0_l\nrename\n  \"word\" as \"rand\"\n  \"dunifin\" as \"drand\".\nimport DWord.\n\n(* Ciphertexts                                                          *)\nop n = l + k.\nlemma gt0_n: 0 < n by smt(gt0_k gt0_l).\n\nclone import BitWord as Ciphertext with\n  op n <- n\nproof gt0_n by exact/Self.gt0_n\nrename \"word\" as \"ctxt\".\n\n(* Parsing and Formatting                                               *)\nop (||) (r:rand) (p:ptxt) : ctxt = mkctxt ((ofrand r) ++ (ofptxt p)).\nop parse (c:ctxt): rand * ptxt =\n  (mkrand (take l (ofctxt c)),mkptxt (drop l (ofctxt c))).\n\nlemma parseK r p: parse (r || p) = (r,p).\nproof.\nrewrite /parse /(||) ofctxtK 1:size_cat 1:size_rand 1:size_ptxt //=.\nby rewrite take_cat drop_cat size_rand take0 drop0 cats0 /= mkrandK mkptxtK.\nqed.\n\nlemma formatI (r : rand) (p : ptxt) r' p':\n  (r || p) = (r' || p') => (r,p) = (r',p').\nproof. by move=> h; rewrite -(@parseK r p) -(@parseK r' p') h. qed.\n\n(* A set `pkey * skey` of keypairs, equipped with                       *)\n(*                         a lossless, full, uniform distribution dkeys *)\ntype pkey, skey.\nop dkeys: { (pkey * skey) distr |    is_lossless dkeys\n                                  /\\ is_funiform dkeys } as dkeys_llfuni.\n\n(* A family `f` of trapdoor permutations over `rand`,                   *)\n(*        indexed by `pkey`, with inverse family `fi` indexed by `skey` *)\nop f : pkey -> rand -> rand.\nop fi: skey -> rand -> rand.\naxiom fK pk sk x: (pk,sk) \\in dkeys => fi sk (f pk x) = x.\n\n(* Random Oracle                                                        *)\nclone import ROM as H with\n  type in_t    <- rand,\n  type out_t   <- ptxt,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <- dptxt.\nimport Lazy.\n\n(* A Definition for OWTP Security                                       *)\nmodule type Inverter = {\n  proc invert(pk:pkey, x:rand): rand\n}.\n\nmodule Exp_OW (I : Inverter) = {\n  proc main(): bool = {\n    var pk, sk, x, x';\n\n    (pk,sk) <$ dkeys;\n    x       <$ drand;\n    x'      <@ I.invert(pk,f pk x);\n    return (x = x');\n  }\n}.\n\n(* A Definition for CPA Security                                        *)\nmodule type Scheme (RO : Oracle) = {\n  proc keygen(): (pkey * skey)\n  proc enc(pk:pkey, m:ptxt): ctxt\n}.\n\nmodule type Adv (ARO : POracle)  = {\n  proc a1(p:pkey): (ptxt * ptxt)\n  proc a2(c:ctxt): bool\n}.\n\nmodule CPA (O : Oracle) (S:Scheme) (A:Adv) = {\n  proc main(): bool = {\n    var pk, sk, m0, m1, c, b, b';\n\n               O.init();\n    (pk,sk) <@ S(O).keygen();\n    (m0,m1) <@ A(O).a1(pk);\n    b       <$ {0,1};\n    c       <@ S(O).enc(pk,b?m0:m1);\n    b'      <@ A(O).a2(c);\n    return b' = b;\n  }\n}.\n\n(* And a definition for the concrete Bellare-Rogaway Scheme             *)\nmodule (BR : Scheme) (H : Oracle) = {\n  proc keygen():(pkey * skey) = {\n    var pk, sk;\n\n    (pk,sk) <$ dkeys;\n    return (pk,sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var h, r;\n\n    r <$ drand;\n    h <@ H.o(r);\n    return ((f pk r) || m +^ h);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt = {\n    var r, p, h;\n\n    (r,p) <- parse c;\n    r     <- fi sk r;\n    h     <@ H.o(r);\n    return p +^ h;\n  }\n}.\n\n(* And our inverter                                                     *)\nmodule I (A:Adv) (H : Oracle) = {\n  var qs : rand list\n\n  module QRO = {\n    proc o(x:rand) = {\n      var r;\n\n      qs <- x::qs;\n      r  <@ H.o(x);\n      return r;\n    }\n  }\n\n  proc invert(pk:pkey,y:rand): rand = {\n    var x, m0, m1, h, b;\n\n    qs      <- [];\n               H.init();\n    (m0,m1) <@ A(QRO).a1(pk);\n    h       <$ dptxt;\n    b       <@ A(QRO).a2(y || h);\n    x       <- nth witness qs (find (fun p => f pk p = y) qs);\n\n    return x;\n  }\n}.\n\n(* We will need to turn a concrete CPA adversary into an abstract one.  *)\n(*      We do not need to do it for the inverter as the types coincide. *)\nmodule A_CPA (A : Adv) (H : POracle) = {\n  proc a1 = A(H).a1\n\n  proc a2(c:rand * ptxt): bool = {\n    var b;\n\n    b <@ A(H).a2(c.`1 || c.`2);\n    return b;\n  }\n}.\n\nsection.\ndeclare module A : Adv { LRO, I }.\n\naxiom A_a1_ll (O <: POracle {A}): islossless O.o => islossless A(O).a1.\naxiom A_a2_ll (O <: POracle {A}): islossless O.o => islossless A(O).a2.\n\nlocal clone import BR93 as Instance with\n  type pkey  <- pkey,\n  type skey  <- skey,\n  op   dkeys <- dkeys,\n  op   f     <- f,\n  op   fi    <- fi,\n  type ptxt  <- ptxt,\n  op   (+^)  <- ____(OP_0)____.(+^),\n  op   dptxt <- dptxt,\n  type rand  <- rand,\n  op   drand <- drand\nproof addA, addC, addKp, dptxt_llfuuni, drand_lluni, dkeys_llfuni, fK.\nrealize addA          by move=> p1 p2 p3; algebra.\nrealize addC          by move=> p1 p2; algebra.\nrealize addKp         by move=> p1 p2; algebra.\nrealize dptxt_llfuuni by smt(@Plaintext.DWord).\nrealize drand_lluni   by smt(@Randomness.DWord).\nrealize dkeys_llfuni  by exact/dkeys_llfuni.\nrealize fK            by exact/fK.\n\nlemma Reduction &m:\n     Pr[CPA(LRO, BR, A).main() @ &m : res] - 1%r / 2%r\n  <= Pr[Exp_OW(Self.I(A, LRO)).main() @ &m : res].\nproof.\nhave <-:   Pr[BR93_CPA(A_CPA(A)).main() @ &m: res]\n         = Pr[CPA(LRO,BR,A).main() @ &m: res].\n+ byequiv=> //=; proc.\n  inline A_CPA(A,Log(H.Lazy.LRO)).a2.\n  wp; call (: H.Lazy.LRO.m{1} = LRO.m{2}).\n  + by proc; inline *; auto.\n  inline BR93(H.Lazy.LRO).enc BR(LRO).enc H.Lazy.LRO.o LRO.o; auto.\n  call (: H.Lazy.LRO.m{1} = LRO.m{2}).\n  + by proc; inline *; auto.\n  inline *; auto=> /> [pk sk] _ [m0 m1] c b _ r _ h _ /=.\n  by rewrite addC /= addC.\nhave <-:   Pr[OW_rand.OW(I(A_CPA(A))).main() @ &m: res]\n         = Pr[Exp_OW(Self.I(A,LRO)).main() @ &m: res].\n+ byequiv=> //=; proc.\n  inline *; auto; call (: H.Lazy.LRO.m{1} = LRO.m{2} /\\ ={qs}(Log,Self.I)).\n  + by sim.\n  auto; call (: H.Lazy.LRO.m{1} = LRO.m{2} /\\ ={qs}(Log,Self.I)).\n  + by sim.\n  by auto.\napply/(Reduction (A_CPA(A)) _ _ &m).\n+ by move=> O O_o_ll; exact/(A_a1_ll O O_o_ll).\nby move=> O O_o_ll; proc; call (A_a2_ll O O_o_ll).\nqed.\nend section.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire (*--*) BitWord OW ROM.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(* We start by proving Bellare and Rogaway's algorithm IND-CPA secure   *)\n(* on abstract datatypes with minimal structure. We then instantiate to *)\n(* semi-concrete fixed-length bitstrings (with abstract lengths).       *)\n(* -------------------------------------------------------------------- *)\nabstract theory BR93.\n(* -------------------------------------------------------------------- *)\n(* Let us consider the following abstract scenario construction. Given: *)\n(* -------------------------------------------------------------------- *)\n\n(* A set `ptxt` of plaintexts, equipped with an nilpotent addition (+^) *)\ntype ptxt.\n\nop (+^): ptxt -> ptxt -> ptxt.\naxiom addA p1 p2 p3: (p1 +^ p2) +^ p3 = p1 +^ (p2 +^ p3).\naxiom addC p1 p2: p1 +^ p2 = p2 +^ p1.\naxiom addKp p1 p2: (p1 +^ p1) +^ p2 = p2.\n\nlemma addpK p1 p2: p1 +^ p2 +^ p2 = p1.\nproof. by rewrite addC -addA addC -addA addKp. qed.\n\n(*                    and a lossless, full, uniform distribution dptxt; *)\nop dptxt: { ptxt distr |    is_lossless dptxt\n                         /\\ is_full dptxt\n                         /\\ is_uniform dptxt } as dptxt_llfuuni.\nlemma dptxt_ll: is_lossless dptxt by exact/(andWl _ dptxt_llfuuni).\nlemma dptxt_uni: is_uniform dptxt by have [#]:= dptxt_llfuuni.\nlemma dptxt_fu: is_full dptxt by have [#]:= dptxt_llfuuni.\nlemma dptxt_funi: is_funiform dptxt\nby exact/(is_full_funiform dptxt_fu dptxt_uni).\n\n(* A set `rand` of nonces, equipped with                                *)\n(*                              a lossless, uniform distribution drand; *)\ntype rand.\nop drand: { rand distr |    is_lossless drand\n                         /\\ is_uniform drand } as drand_lluni.\nlemma drand_ll: is_lossless drand by exact/(andWl _ drand_lluni).\nlemma drand_uni: is_uniform drand by exact/(andWr _ drand_lluni).\n\n(* A set `ctxt` of ciphertexts defined as                               *)\n(*                          the cartesian product of `rand` and `ptxt`; *)\ntype ctxt = rand * ptxt.\n\n(* A set `pkey * skey` of keypairs, equipped with                       *)\n(*                        a lossless, full, uniform distribution dkeys; *)\ntype pkey, skey.\nop dkeys: { (pkey * skey) distr |    is_lossless dkeys\n                                  /\\ is_funiform dkeys } as dkeys_llfuni.\nlemma dkeys_ll: is_lossless dkeys by exact/(andWl _ dkeys_llfuni).\nlemma dkeys_funi: is_funiform dkeys by exact/(andWr _ dkeys_llfuni).\n\n(* A family `f` of trapdoor permutations over `rand`,                   *)\n(*       indexed by `pkey`, with inverse family `fi` indexed by `skey`; *)\nop f : pkey -> rand -> rand.\nop fi: skey -> rand -> rand.\naxiom fK pk sk x: (pk,sk) \\in dkeys => fi sk (f pk x) = x.\n\nlemma fI pk x y: (exists sk, (pk,sk) \\in dkeys) =>\n  f pk x = f pk y => x = y.\nproof. by move=> [sk] + fx_eq_fy - /fK ^ /(_ x) <- /(_ y) <-; congr. qed.\n\n(* A random oracle from `rand` to `ptxt`, modelling a hash function H;  *)\n(* (we simply instantiate the generic theory of Random Oracles with     *)\n(*    the types and output distribution declared above, discharging all *)\n(*          assumptions on the instantiated parameters--there are none) *)\nclone import ROM as H with\n  type in_t    <- rand,\n  type out_t   <- ptxt,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <- dptxt.\nimport H.Lazy.\n\n(* We can define the Bellare-Rogaway 93 PKE Scheme.                     *)\n(* BR93 is a module that, given access to an oracle H from type         *)\n(*   `from` to type `rand` (see `print Oracle.`), implements procedures *)\n(*   `keygen`, `enc` and `dec` as follows described below.              *)\nmodule BR93 (H:Oracle) = {\n  (* `keygen` simply samples a key pair in `dkeys` *)\n  proc keygen() = {\n    var kp;\n\n    kp <$ dkeys;\n    return kp;\n  }\n\n  (* `enc` samples a random string `r` in `drand` and uses it to       *)\n  (*   produce a random mask `h` using the hash function, then returns *)\n  (*      the image of `r` by permutation `f` and the plaintext masked *)\n  (*                                                         with `h`. *)\n  proc enc(pk, m) = {\n    var r, h;\n\n    r <$ drand;\n    h <@ H.o(r);\n    return (f pk r,h +^ m);\n  }\n\n  (* `dec` parses its input as a nonce `r` and a masked plaintext `m` *)\n  (*  before recovering the original random string from `r` using the *)\n  (*      inverse permutation `fi` and computing its image `h` by the *)\n  (*  random oracle. The original plaintext is recovered by unmasking *)\n  (*                                                    `m` with `h`. *)\n  proc dec(sk, c) = {\n    var r, h, m;\n\n    (r,m) <- c;\n    r     <- fi sk r;\n    h     <- H.o(r);\n    return h +^ m;\n  }\n}.\n\n(* We can quickly prove it correct as a sanity check.                 *)\nsection Correctness.\nlocal module Correctness = {\n  proc main(m) = {\n    var pk, sk, c, m';\n\n    (pk,sk) <@ BR93(LRO).keygen();\n    c       <@ BR93(LRO).enc(pk,m);\n    m'      <@ BR93(LRO).dec(sk,c);\n    return (m = m');\n  }\n}.\n\nlocal lemma BR93_correct &m m: Pr[Correctness.main(m) @ &m: res] = 1%r.\nproof.\nbyphoare=> //; conseq (: _ ==> true) (: _ ==> res)=> //.\n+ proc; inline *.\n  rcondf 17.\n  + auto=> /> &hr [pk sk] kp_in_dkeys r _ y _ /=.\n    rewrite fK //; split=> [_ _ _|-> //].\n    by rewrite mem_set.\n  auto=> /> &hr [pk sk] kp_in_dkeys r _ y _ /=.\n  rewrite fK //; split=> [_ y' _|].\n  + by rewrite get_set_sameE -addA addKp.\n  rewrite domE; case: (LRO.m{hr}.[r])=> [|p] //= _ _.\n  by rewrite -addA addKp.\nby proc; inline *; auto=> />; rewrite dkeys_ll drand_ll dptxt_ll.\nqed.\nend section Correctness.\n\n(* However, what we are really interested in is proving that it is      *)\n(* IND-CPA secure if `f` is a one-way trapdoor permutation.             *)\n\n(* We use cloning to get definitions for OWTP security                  *)\nclone import OW as OW_rand with\n  type D           <- rand,\n  type R           <- rand,\n  type pkey        <- pkey,\n  type skey        <- skey,\n  op   dkeys       <- dkeys,\n  op   challenge _ <- drand,\n  op   f           <- f,\n  op   finv        <- fi\nproof dkeys_ll, finvof, challenge_ll, challenge_uni.\nrealize dkeys_ll by exact/dkeys_ll.\nrealize challenge_ll by move=> _ _; exact/drand_ll.\nrealize challenge_uni by move=> _ _; exact/drand_uni.\nrealize finvof by move=> pk sk x /fK ->.\n\n(* But we can't do it (yet) for IND-CPA because of the random oracle    *)\n(*             Instead, we define CPA for BR93 with that particular RO. *)\nmodule type Adv (ARO: POracle)  = {\n  proc a1(p:pkey): (ptxt * ptxt)\n  proc a2(c:ctxt): bool\n}.\n\n(* We need to log the random oracle queries made to the adversary       *)\n(*                               in order to express the final theorem. *)\nmodule Log (H:Oracle) = {\n  var qs: rand list\n\n  proc init() = {\n    qs <- [];\n          H.init();\n  }\n\n  proc o(x) = {\n    var r;\n\n    qs <- x::qs;\n    r  <@ H.o(x);\n    return r;\n  }\n}.\n\nmodule BR93_CPA(A:Adv) = {\n  proc main(): bool = {\n    var pk, sk, m0, m1, c, b, b';\n\n                Log(LRO).init();\n    (pk,sk)  <@ BR93(LRO).keygen();\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n    c        <@ BR93(LRO).enc(pk,b?m0:m1);\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\n(* We want to prove the following:                                      *)\n(*   forall (valid) CPA adversary A which makes at most q queries to H, *)\n(*     there exists a OW adversary I such that                          *)\n(*          `|Pr[BR_CPA(A): res] - 1/2| <= Pr[OW_f(I): res]             *)\n(* We construct I as follows, using A.a1 and A.a2 as black boxes        *)\nmodule I(A:Adv): Inverter = {\n  var x:rand\n\n  proc invert(pk:pkey,y:rand): rand = {\n    var m0, m1, h, b;\n\n               Log(LRO).init();\n    (m0,m1) <@ A(Log(LRO)).a1(pk);\n    h       <$ dptxt;\n    b       <@ A(Log(LRO)).a2(y,h);\n    x       <- nth witness Log.qs (find (fun p => f pk p = y) Log.qs);\n\n    return x;\n  }\n}.\n\n(* We now prove the result using a sequence of games                    *)\nsection.\n(* All lemmas in this section hold for all (valid) CPA adversary A      *)\ndeclare module A : Adv { LRO, Log }.\n\naxiom A_a1_ll (O <: POracle {A}): islossless O.o => islossless A(O).a1.\naxiom A_a2_ll (O <: POracle {A}): islossless O.o => islossless A(O).a2.\n\n(* Step 1: replace RO call with random sampling                         *)\nlocal module Game1 = {\n  var r: rand\n\n  proc main() = {\n    var pk, sk, m0, m1, b, h, c, b';\n                Log(LRO).init();\n    (pk,sk)  <$ dkeys;\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n\n    r        <$ drand;\n    h        <$ dptxt;\n    c        <- ((f pk r),h +^ (b?m0:m1));\n\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\nlocal lemma pr_Game0_Game1 &m:\n     Pr[BR93_CPA(A).main() @ &m: res]\n  <=   Pr[Game1.main() @ &m: res]\n     + Pr[Game1.main() @ &m: Game1.r \\in Log.qs].\nproof.\nbyequiv=> //; proc.\ninline BR93(LRO).enc BR93(LRO).keygen.\n(* Until the replaced RO call, the two games are in sync.               *)\n(*        In addition, the log's contents coincide with the RO queries. *)\nseq  8  5: (   ={glob A, glob LRO, glob Log, pk, sk, b}\n            /\\ pk0{1} = pk{2}\n            /\\ m{1} = (b?m0:m1){2}\n            /\\ r{1} = Game1.r{2}\n            /\\ (forall x, x \\in Log.qs{1} <=> x \\in LRO.m{1})).\n+ auto; call (:   ={glob Log, glob LRO}\n               /\\ (forall x, x \\in Log.qs{1} <=> x \\in LRO.m{1})).\n  + proc; inline LRO.o.\n    by auto=> /> &2 log_is_dom y _; smt(@SmtMap).\n  by inline *; auto=> /> _ _ x; rewrite mem_empty.\n(* We now deal with everything that happens after the programs differ: *)\n(*   - until r gets queried to the random oracle by the adversary      *)\n(*     (and if it wasn't already queried by a1), we guarantee that the *)\n(*     random oracles agree except on r                                *)\n(*   - if the adversary queries r to the random oracle (or if it has   *)\n(*     already done so in a1), we give up                              *)\n(* Because we reason up to bad, we need to prove that bad is stable    *)\n(* and that the adversary and its oracles are lossless                 *)\ncall (_: Game1.r \\in Log.qs,\n         eq_except (pred1 Game1.r{2}) LRO.m{1} LRO.m{2}).\n+ exact/A_a2_ll.\n+ proc; inline LRO.o.\n  auto=> /> &1 &2 _ m1_eqe_m2 yL y_in_dptxt; split.\n  + move=> x_notin_m; split.\n    + by rewrite !get_set_sameE eq_except_set_eq.\n    move: m1_eqe_m2 x_notin_m=> + + + r_neq_x.\n    by rewrite eq_exceptP pred1E !domE=> /(_ x{2} r_neq_x) ->.\n  move=> x_in_m; split.\n  + move: m1_eqe_m2 x_in_m=> + + + r_neq_x.\n    by rewrite eq_exceptP pred1E !domE=> /(_ x{2} r_neq_x) ->.\n  by move: m1_eqe_m2=> + _ r_neq_x- /eq_exceptP /(_ x{2}); rewrite pred1E=> /(_ r_neq_x) ->.\n+ by move=> &2 _; proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll.\n+ move=> _ /=; proc; inline *.\n  conseq (: true ==> true: =1%r) (: Game1.r \\in Log.qs ==> Game1.r \\in Log.qs)=> //=.\n  + by auto=> />.\n  by auto=> />; exact/dptxt_ll.\ninline LRO.o; case: ((r \\in LRO.m){1}).\n+ conseq (: _ ==> ={b} /\\ Game1.r{2} \\in Log.qs{2})=> //=.\n  + by move=> /> &1 &2 _ _ rR _ _ _ _ _ h /h [] -> //.\n  by auto=> /> &2 <- ->.\nrcondt{1} 3; 1:by auto.\nauto=> /> &2 log_is_dom r_notin_m y _; rewrite !get_set_sameE oget_some /=.\nsplit.\n+ by move=> _; rewrite eq_exceptP /pred1=> x; rewrite get_setE eq_sym=> ->.\nby move=> _ rR aL mL aR qsR mR h /h [] ->.\nqed.\n\n(* Step 2: replace h ^ m with h in the challenge encryption            *)\nlocal module Game2 = {\n  var r: rand\n\n  proc main() = {\n    var pk, sk, m0, m1, b, h, c, b';\n                Log(LRO).init();\n    (pk,sk)  <$ dkeys;\n    (m0,m1)  <@ A(Log(LRO)).a1(pk);\n    b        <$ {0,1};\n\n    r        <$ drand;\n    h        <$ dptxt;\n    c        <- ((f pk r),h);\n\n    b'       <@ A(Log(LRO)).a2(c);\n    return b' = b;\n  }\n}.\n\nlocal equiv eq_Game1_Game2: Game1.main ~ Game2.main:\n  ={glob A} ==> ={glob Log, res} /\\ Game1.r{1} = Game2.r{2}.\nproof.\nproc.\ncall (: ={glob Log, glob LRO}); 1: by sim.\nwp; rnd (fun x=> x +^ (b?m0:m1){2}).\nauto; call (: ={glob Log, glob LRO}); 1: by sim.\ninline *; auto=> /> _ _ rR b _ rL _; split=> [|_].\n+ by move=> hR _; rewrite addpK.\nsplit=> [|_].\n+ by move=> hR _; exact/dptxt_funi.\nby move=> hL _; rewrite dptxt_fu /= addpK.\nqed.\n\nlocal lemma pr_Game1_Game2 &m:\n  Pr[Game1.main() @ &m: res] = Pr[Game2.main() @ &m: res].\nproof. by byequiv eq_Game1_Game2. qed.\n\nlocal lemma pr_bad_Game1_Game2 &m:\n    Pr[Game1.main() @ &m: Game1.r \\in Log.qs]\n  = Pr[Game2.main() @ &m: Game2.r \\in Log.qs].\nproof. by byequiv eq_Game1_Game2. qed.\n\nlocal lemma pr_Game2 &m: Pr[Game2.main() @ &m: res] = 1%r / 2%r.\nproof.\nbyphoare=> //=; proc.\nswap 4 4.\nwp; rnd (pred1 b')=> //=.\ninline *; call (_: true).\n+ exact A_a2_ll. (* adversary *)\n+ by proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll. (* oracle *)\nauto; call (_: true).\n+ exact A_a1_ll. (* adversary *)\n+ by proc; call (LRO_o_ll _); auto=> /=; apply: dptxt_ll. (* oracle *)\nauto=> />; rewrite dkeys_ll drand_ll dptxt_ll /predT /=.\nby move=> _ _ _ _ _ _ r; rewrite dbool1E pred1E.\nqed.\n\n(* Step 3: The reduction step -- if A queries the RO with the randomness *)\n(*     used to encrypt the challenge, then I(A) inverts the OW challenge *)\n(* We need a version of the one-way game where the challenge is a global *)\nlocal module OWr (I : Inverter) = {\n  var x : rand\n\n  proc main() : bool = {\n    var x', pk, sk;\n\n    (pk,sk) <$ dkeys;\n    x       <$ drand;\n    x'      <@ I.invert(pk,f pk x);\n    return (x = x');\n  }\n}.\n\n(* We can easily prove that it is strictly equivalent to OW              *)\nlocal lemma OW_OWr &m (I <: Inverter {OWr}):\n  Pr[OW(I).main() @ &m: res]\n  = Pr[OWr(I).main() @ &m: res].\nproof. by byequiv=> //=; sim. qed.\n\nlocal lemma pr_Game2_OW &m:\n  Pr[Game2.main() @ &m: Game2.r \\in Log.qs]\n  <= Pr[OW(I(A)).main() @ &m: res].\nproof.\nrewrite (OW_OWr &m (I(A))). (* Note: we proved it forall (abstract) I    *)\nbyequiv => //=; proc; inline *; wp.\nconseq\n  (_ : _ ==>\n       support dkeys (pk0{2}, sk{2}) /\\\n       Game2.r{1} = OWr.x{2} /\\ Log.qs{1} = Log.qs{2} /\\\n       y{2} = f pk0{2} Game2.r{1}).\n+ move=> /> qs x pk sk vk x_in_qs; pose P := fun p => f _ p = _.\n  have h := nth_find witness P qs _.\n  + by rewrite hasP; exists x.\n  apply/(fI pk).\n  + by exists sk.\n  by rewrite h.\n(* rest of proof *)\ncall (: ={glob Log, glob LRO}); 1: by sim.\nswap{1} 6 -2.\nauto; call (: ={glob Log, glob LRO}); 1: by sim.\nby auto=> /> [pk sk] ->.\nqed.\n\nlemma Reduction &m:\n  Pr[BR93_CPA(A).main() @ &m : res] - 1%r/2%r\n  <= Pr[OW(I(A)).main() @ &m: res].\nproof.\nsmt(pr_Game0_Game1 pr_Game1_Game2 pr_bad_Game1_Game2 pr_Game2 pr_Game2_OW).\nqed.\nend section.\nend BR93.\n\n(* We now consider a concrete instance:                                 *)\n(*   - plaintexts are bitstrings of length k > 0                        *)\n(*   - nonces are bitstrings of length l > 0                            *)\n(*   - ciphertexts are bitstrings of length n = k + l                   *)\n\n(* Plaintexts                                                           *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Plaintext with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"ptxt\"\n  \"dunifin\" as \"dptxt\".\nimport DWord.\n\n(* Nonces                                                               *)\nop l : { int | 0 < l } as gt0_l.\n\nclone import BitWord as Randomness with\n  op n <- l\nproof gt0_n by exact/gt0_l\nrename\n  \"word\" as \"rand\"\n  \"dunifin\" as \"drand\".\nimport DWord.\n\n(* Ciphertexts                                                          *)\nop n = l + k.\nlemma gt0_n: 0 < n by smt(gt0_k gt0_l).\n\nclone import BitWord as Ciphertext with\n  op n <- n\nproof gt0_n by exact/Self.gt0_n\nrename \"word\" as \"ctxt\".\n\n(* Parsing and Formatting                                               *)\nop (||) (r:rand) (p:ptxt) : ctxt = mkctxt ((ofrand r) ++ (ofptxt p)).\nop parse (c:ctxt): rand * ptxt =\n  (mkrand (take l (ofctxt c)),mkptxt (drop l (ofctxt c))).\n\nlemma parseK r p: parse (r || p) = (r,p).\nproof.\nrewrite /parse /(||) ofctxtK 1:size_cat 1:size_rand 1:size_ptxt //=.\nby rewrite take_cat drop_cat size_rand take0 drop0 cats0 /= mkrandK mkptxtK.\nqed.\n\nlemma formatI (r : rand) (p : ptxt) r' p':\n  (r || p) = (r' || p') => (r,p) = (r',p').\nproof. by move=> h; rewrite -(@parseK r p) -(@parseK r' p') h. qed.\n\n(* A set `pkey * skey` of keypairs, equipped with                       *)\n(*                         a lossless, full, uniform distribution dkeys *)\ntype pkey, skey.\nop dkeys: { (pkey * skey) distr |    is_lossless dkeys\n                                  /\\ is_funiform dkeys } as dkeys_llfuni.\n\n(* A family `f` of trapdoor permutations over `rand`,                   *)\n(*        indexed by `pkey`, with inverse family `fi` indexed by `skey` *)\nop f : pkey -> rand -> rand.\nop fi: skey -> rand -> rand.\naxiom fK pk sk x: (pk,sk) \\in dkeys => fi sk (f pk x) = x.\n\n(* Random Oracle                                                        *)\nclone import ROM as H with\n  type in_t    <- rand,\n  type out_t   <- ptxt,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <- dptxt.\nimport Lazy.\n\n(* A Definition for OWTP Security                                       *)\nmodule type Inverter = {\n  proc invert(pk:pkey, x:rand): rand\n}.\n\nmodule Exp_OW (I : Inverter) = {\n  proc main(): bool = {\n    var pk, sk, x, x';\n\n    (pk,sk) <$ dkeys;\n    x       <$ drand;\n    x'      <@ I.invert(pk,f pk x);\n    return (x = x');\n  }\n}.\n\n(* A Definition for CPA Security                                        *)\nmodule type Scheme (RO : Oracle) = {\n  proc keygen(): (pkey * skey)\n  proc enc(pk:pkey, m:ptxt): ctxt\n}.\n\nmodule type Adv (ARO : POracle)  = {\n  proc a1(p:pkey): (ptxt * ptxt)\n  proc a2(c:ctxt): bool\n}.\n\nmodule CPA (O : Oracle) (S:Scheme) (A:Adv) = {\n  proc main(): bool = {\n    var pk, sk, m0, m1, c, b, b';\n\n               O.init();\n    (pk,sk) <@ S(O).keygen();\n    (m0,m1) <@ A(O).a1(pk);\n    b       <$ {0,1};\n    c       <@ S(O).enc(pk,b?m0:m1);\n    b'      <@ A(O).a2(c);\n    return b' = b;\n  }\n}.\n\n(* And a definition for the concrete Bellare-Rogaway Scheme             *)\nmodule (BR : Scheme) (H : Oracle) = {\n  proc keygen():(pkey * skey) = {\n    var pk, sk;\n\n    (pk,sk) <$ dkeys;\n    return (pk,sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var h, r;\n\n    r <$ drand;\n    h <@ H.o(r);\n    return ((f pk r) || m +^ h);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt = {\n    var r, p, h;\n\n    (r,p) <- parse c;\n    r     <- fi sk r;\n    h     <@ H.o(r);\n    return p +^ h;\n  }\n}.\n\n(* And our inverter                                                     *)\nmodule I (A:Adv) (H : Oracle) = {\n  var qs : rand list\n\n  module QRO = {\n    proc o(x:rand) = {\n      var r;\n\n      qs <- x::qs;\n      r  <@ H.o(x);\n      return r;\n    }\n  }\n\n  proc invert(pk:pkey,y:rand): rand = {\n    var x, m0, m1, h, b;\n\n    qs      <- [];\n               H.init();\n    (m0,m1) <@ A(QRO).a1(pk);\n    h       <$ dptxt;\n    b       <@ A(QRO).a2(y || h);\n    x       <- nth witness qs (find (fun p => f pk p = y) qs);\n\n    return x;\n  }\n}.\n\n(* We will need to turn a concrete CPA adversary into an abstract one.  *)\n(*      We do not need to do it for the inverter as the types coincide. *)\nmodule A_CPA (A : Adv) (H : POracle) = {\n  proc a1 = A(H).a1\n\n  proc a2(c:rand * ptxt): bool = {\n    var b;\n\n    b <@ A(H).a2(c.`1 || c.`2);\n    return b;\n  }\n}.\n\nsection.\ndeclare module A : Adv { LRO, I }.\n\naxiom A_a1_ll (O <: POracle {A}): islossless O.o => islossless A(O).a1.\naxiom A_a2_ll (O <: POracle {A}): islossless O.o => islossless A(O).a2.\n\nlocal clone import BR93 as Instance with\n  type pkey  <- pkey,\n  type skey  <- skey,\n  op   dkeys <- dkeys,\n  op   f     <- f,\n  op   fi    <- fi,\n  type ptxt  <- ptxt,\n  op   (+^)  <- Plaintext.(+^),\n  op   dptxt <- dptxt,\n  type rand  <- rand,\n  op   drand <- drand\nproof addA, addC, addKp, dptxt_llfuuni, drand_lluni, dkeys_llfuni, fK.\nrealize addA          by move=> p1 p2 p3; algebra.\nrealize addC          by move=> p1 p2; algebra.\nrealize addKp         by move=> p1 p2; algebra.\nrealize dptxt_llfuuni by smt(@Plaintext.DWord).\nrealize drand_lluni   by smt(@Randomness.DWord).\nrealize dkeys_llfuni  by exact/dkeys_llfuni.\nrealize fK            by exact/fK.\n\nlemma Reduction &m:\n     Pr[CPA(LRO, BR, A).main() @ &m : res] - 1%r / 2%r\n  <= Pr[Exp_OW(Self.I(A, LRO)).main() @ &m : res].\nproof.\nhave <-:   Pr[BR93_CPA(A_CPA(A)).main() @ &m: res]\n         = Pr[CPA(LRO,BR,A).main() @ &m: res].\n+ byequiv=> //=; proc.\n  inline A_CPA(A,Log(H.Lazy.LRO)).a2.\n  wp; call (: H.Lazy.LRO.m{1} = LRO.m{2}).\n  + by proc; inline *; auto.\n  inline BR93(H.Lazy.LRO).enc BR(LRO).enc H.Lazy.LRO.o LRO.o; auto.\n  call (: H.Lazy.LRO.m{1} = LRO.m{2}).\n  + by proc; inline *; auto.\n  inline *; auto=> /> [pk sk] _ [m0 m1] c b _ r _ h _ /=.\n  by rewrite addC /= addC.\nhave <-:   Pr[OW_rand.OW(I(A_CPA(A))).main() @ &m: res]\n         = Pr[Exp_OW(Self.I(A,LRO)).main() @ &m: res].\n+ byequiv=> //=; proc.\n  inline *; auto; call (: H.Lazy.LRO.m{1} = LRO.m{2} /\\ ={qs}(Log,Self.I)).\n  + by sim.\n  auto; call (: H.Lazy.LRO.m{1} = LRO.m{2} /\\ ={qs}(Log,Self.I)).\n  + by sim.\n  by auto.\napply/(Reduction (A_CPA(A)) _ _ &m).\n+ by move=> O O_o_ll; exact/(A_a1_ll O O_o_ll).\nby move=> O O_o_ll; proc; call (A_a2_ll O O_o_ll).\nqed.\nend section."
    },
    {
        "file": "EC-1/cfold.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Distr.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldStopIf.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      var d : int;\n      \n      c <- 0;\n      d <- c + 1;\n      c <- b + a;\n      \n      if (a + b = c) {\n        c <- 0;\n        a <- c;\n      } else {\n        c <- 1;\n        b <- c;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : ____(LEMMA_0)____[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  by auto => /> ?; apply addzC.\n  qed.\nend CfoldStopIf.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldTuple.\n  module M = {\n    proc f( x : int * int) : int = {\n      var a : int;\n      var b : int;\n      var c : int <- 0;\n\n      x <- (0, 0);\n      a <- x.`1;\n      b <- snd x;\n\n      while (a + b <> b + a) {\n        c <- c + 1;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 2.\n  by rcondf ^while; auto.\n  qed.\nend CfoldTuple.\n\ntheory CfoldN.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      a <- c;\n      c <- 1;\n      b <- 2;\n      c <- 2;\n      a <- 3;\n      c <- 3;\n      if (a <> b) {\n        c <- 0;\n      } \n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1 4.\n  by auto => />.\n  qed.\nend CfoldN.\n\ntheory CfoldWhileUnroll.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      c <- c + 1;\n      c <- 0;\n      while (c < 10) {\n        a <- c;\n        c <- c + 1;\n      }\n      b <- c;\n      if (a <> b) {\n        c <- 0;\n      }\n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  unroll for 2.\n  by auto => />.\n  qed.\nend CfoldWhileUnroll.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Distr.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldStopIf.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      var d : int;\n      \n      c <- 0;\n      d <- c + 1;\n      c <- b + a;\n      \n      if (a + b = c) {\n        c <- 0;\n        a <- c;\n      } else {\n        c <- 1;\n        b <- c;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  by auto => /> ?; apply addzC.\n  qed.\nend CfoldStopIf.\n\n(* -------------------------------------------------------------------- *)\ntheory CfoldTuple.\n  module M = {\n    proc f( x : int * int) : int = {\n      var a : int;\n      var b : int;\n      var c : int <- 0;\n\n      x <- (0, 0);\n      a <- x.`1;\n      b <- snd x;\n\n      while (a + b <> b + a) {\n        c <- c + 1;\n      }\n      return c;\n    }\n  }.\n  \n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 2.\n  by rcondf ^while; auto.\n  qed.\nend CfoldTuple.\n\ntheory CfoldN.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      a <- c;\n      c <- 1;\n      b <- 2;\n      c <- 2;\n      a <- 3;\n      c <- 3;\n      if (a <> b) {\n        c <- 0;\n      } \n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1 4.\n  by auto => />.\n  qed.\nend CfoldN.\n\ntheory CfoldWhileUnroll.\n  module M = {\n    proc f(a : int, b : int) : int = {\n      var c : int;\n      c <- 0;\n      c <- c + 1;\n      c <- 0;\n      while (c < 10) {\n        a <- c;\n        c <- c + 1;\n      }\n      b <- c;\n      if (a <> b) {\n        c <- 0;\n      }\n      return c;\n    }\n  }.\n\n  lemma L : hoare[M.f : true ==> res = 0].\n  proof.\n  proc.\n  cfold 1.\n  unroll for 2.\n  by auto => />.\n  qed.\nend CfoldWhileUnroll."
    },
    {
        "file": "EC-1/CommitmentSpecial.ec",
        "incomplete": "require import AllCore Distr List DBool.\n\n\ntype commitment, opening, ____(TYPE_0)____.\n\nop Com  : message -> (____(OP_0)____ * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() : bool = {\n      var c, m, m', d, d', v, v';\n      (c, m, d, m', d') <@ B.bind();\n      v                 <- Ver (m, (c, d));\n      v'                <- Ver (m', (c, d'));\n      return v /\\ v' /\\ m <> m';\n    }\n}.\n\nmodule type Unhider  = {\n  proc choose() : message list * message list\n  proc guess(c : commitment list) : bool \n}.\n\n\n(* Below we give two different formulations of statistical hiding for commitement scheme  *)\nmodule HidingExperiment(U : Unhider) = {\n  proc main() : bool = {\n    var b : bool;\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    b <$ {0,1};\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b = b';\n  }\n}.\n\n\naxiom comm_scheme_hiding_eps2 &m: forall (U <: Unhider),\n  `|Pr[HidingExperiment(U).main() @ &m : res] -  1%r/2%r| <= eps2.\n\n\n\nmodule HidingGame(U : Unhider) = {\n  proc main(b:bool) : bool = {\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b';\n  }\n}.\n\naxiom comm_scheme_hiding_eps &m: forall (U <: Unhider),\n  `|Pr[HidingGame(U).main(true) @ &m : res] -  Pr[HidingGame(U).main(false) @ &m : res]| <= eps.",
        "complete:": "require import AllCore Distr List DBool.\n\n\ntype commitment, opening, message.\n\nop Com  : message -> (commitment * opening) distr.\nop Ver : message * (commitment * opening) -> bool.\n\naxiom Com_sound : forall (x : message * (commitment * opening)), x.`2 \\in Com x.`1 => Ver x.\naxiom Com_lossless : forall b, is_lossless (Com b).\n\n(* two negligible values which we use as upper bounds for statistical hiding  *)\nop eps, eps2 : real.  \naxiom eps_ge0 : 0%r <= eps.\naxiom eps2_ge0 : 0%r <= eps2 < 1%r/4%r.\n\n\nmodule type Binder = {\n   proc bind() : commitment * message * opening * message * opening\n}.\n\nmodule BindingExperiment (B:Binder) = {\n    proc main() : bool = {\n      var c, m, m', d, d', v, v';\n      (c, m, d, m', d') <@ B.bind();\n      v                 <- Ver (m, (c, d));\n      v'                <- Ver (m', (c, d'));\n      return v /\\ v' /\\ m <> m';\n    }\n}.\n\nmodule type Unhider  = {\n  proc choose() : message list * message list\n  proc guess(c : commitment list) : bool \n}.\n\n\n(* Below we give two different formulations of statistical hiding for commitement scheme  *)\nmodule HidingExperiment(U : Unhider) = {\n  proc main() : bool = {\n    var b : bool;\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    b <$ {0,1};\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b = b';\n  }\n}.\n\n\naxiom comm_scheme_hiding_eps2 &m: forall (U <: Unhider),\n  `|Pr[HidingExperiment(U).main() @ &m : res] -  1%r/2%r| <= eps2.\n\n\n\nmodule HidingGame(U : Unhider) = {\n  proc main(b:bool) : bool = {\n    var b' : bool;\n    var m0 : message list;\n    var m1 : message list;\n    var co : (commitment * opening) list;\n    (m0, m1) <@ U.choose();\n    co <$ djoinmap Com (if b then m0 else m1);\n    b' <@ U.guess(map fst co);\n    return b';\n  }\n}.\n\naxiom comm_scheme_hiding_eps &m: forall (U <: Unhider),\n  `|Pr[HidingGame(U).main(true) @ &m : res] -  Pr[HidingGame(U).main(false) @ &m : res]| <= eps."
    },
    {
        "file": "EC-1/ddh-1.ec",
        "incomplete": "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype ____(TYPE_0)____.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* some exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1%r) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.\n\naxiom dexp_fu : is_full dexp.\naxiom dexp_uni : is_uniform dexp.\naxiom dexp_ll : is_lossless dexp.\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* generator *)\n\nop (^) : key -> exp -> key.  (* exponentiation *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;\n    q1 <$ dexp; q2 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));\n    return b;\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);\n    return b;\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)",
        "complete:": "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* some exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1%r) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.\n\naxiom dexp_fu : is_full dexp.\naxiom dexp_uni : is_uniform dexp.\naxiom dexp_ll : is_lossless dexp.\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* generator *)\n\nop (^) : key -> exp -> key.  (* exponentiation *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;\n    q1 <$ dexp; q2 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));\n    return b;\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);\n    return b;\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)"
    },
    {
        "file": "EC-1/elgamal.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a PKE **)\ntype pkey = group.\ntype skey = F.t.\ntype ptxt = group.\ntype ctxt = ____(TYPE_0)____ * group.\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y;\n\n    y <$ dt;\n    return (g ^ y, pk ^ y * m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, gm;\n\n    (gy, gm) <- c;\n    return Some (gm * gy^(-sk));\n  }\n}.\n\n(** Reduction: from a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);\n    b        <$ {0,1};\n    b'       <@ A.guess(gy, gz * (b?m1:m0));\n    return b' = b;\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare ____(DECLARE_0)____ A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;\n      y       <$ FDistr.dt;\n      (m0,m1) <@ A.choose(g^x);\n      z       <$ FDistr.dt;\n      b'      <@ A.guess(g^y, g^z);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a PKE **)\ntype pkey = group.\ntype skey = F.t.\ntype ptxt = group.\ntype ctxt = group * group.\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y;\n\n    y <$ dt;\n    return (g ^ y, pk ^ y * m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, gm;\n\n    (gy, gm) <- c;\n    return Some (gm * gy^(-sk));\n  }\n}.\n\n(** Reduction: from a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);\n    b        <$ {0,1};\n    b'       <@ A.guess(gy, gz * (b?m1:m0));\n    return b' = b;\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;\n      y       <$ FDistr.dt;\n      (m0,m1) <@ A.choose(g^x);\n      z       <$ FDistr.dt;\n      b'      <@ A.guess(g^y, g^z);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion."
    },
    {
        "file": "EC-1/EventPartitioning.ec",
        "incomplete": "(* --------------------------------------------------------------------\n * Copyright (c) - 2012--2016 - IMDEA Software Institute\n * Copyright (c) - 2012--2018 - Inria\n * Copyright (c) - 2012--2018 - Ecole Polytechnique\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\nrequire import AllCore List Distr StdBigop StdRing StdOrder.\n(*---*) import Bigreal BRA RField IntOrder RealOrder.\n\npragma +implicits.\n\ntype input, output.\n\nmodule type T = {\n  proc f(_: input): output\n}.\n\nabstract theory ListPartitioning.\n  type ____(TYPE_1)____.\n\n  section.\n  declare module M : ____(DECLARE_0)____.\n\n  lemma list_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition list) &m:\n    uniq P =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) P\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem P (phi i (glob M) res)].\n  proof.\n  move=> uniq_P. rewrite Pr[mu_split (mem P (phi i (glob M) res))]; congr.\n  elim: P uniq_P=> /=; first by rewrite big_nil Pr[mu_false].\n  move=> x xs ih [] x_notin_xs uniq_xs /=.\n  rewrite {1}andb_orr Pr[mu_or] andbCA !andbA andbb.\n  have ->: Pr[M.f(i) @ &m: (   E i (glob M) res\n                            /\\ phi i (glob M) res = x)\n                           /\\ mem xs (phi i (glob M) res)]\n           = Pr[M.f(i) @ &m: false].\n  + by rewrite Pr[mu_eq] // => &hr /#.\n  by rewrite Pr[mu_false] //= big_cons {1}/predT /=; congr; exact/ih.\n  qed.\n  end section.\nend ListPartitioning.\n\nabstract theory FSetPartitioning.\n  require import FSet.\n\n  type partition.\n\n  section.\n  declare module ____(DECLARE_1)____ : T.\n\n  local clone import ListPartitioning with\n    type ____(TYPE_0)____ <- partition.\n\n  lemma fset_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition fset) &m:\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) (elems P)\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem P (phi i (glob M) res)].\n  proof.\n  by rewrite memE; exact/(@list_partitioning M i E phi (elems P) &m _)/uniq_elems.\n  qed.\n  end section.\nend FSetPartitioning.\n\nabstract theory FPredPartitioning.\n  require import Finite.\n\n  type partition.\n\n  section.\n  declare module M : T.\n\n  local clone import ListPartitioning with\n    type partition <- partition.\n\n  lemma fpred_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition -> bool) &m:\n    is_finite P =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) (to_seq P)\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !P (phi i (glob M) res)].\n  proof.\n  move=> ^/mem_to_seq <- /uniq_to_seq.\n  exact/(@list_partitioning M i E phi (to_seq P) &m).\n  qed.\n  end section.\nend FPredPartitioning.\n\ntheory ResultPartitioning.\n  section.\n  declare module M : T.\n\n  local clone import ListPartitioning with\n    type partition <- output.\n\n  lemma result_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (X : input -> output list)\n          &m:\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a=> Pr[M.f(i) @ &m: E i (glob M) res /\\ res = a]) (undup (X i))\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem (X i) res].\n  proof.\n  rewrite -mem_undup.\n  exact/(@list_partitioning M i E (fun _ _ x=> x) (undup (X i)) &m)/undup_uniq.\n  qed.\n  end section.\nend ResultPartitioning.\n\ntheory TotalResultPartitioning.\n  (*---*) import ResultPartitioning.\n\n  section.\n  declare module M : T.\n\n  lemma total_result_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (X : input -> output list)\n          &m:\n    (forall i, hoare [M.f: arg = i ==> mem (X i) res]) =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a => Pr[M.f(i) @ &m: E i (glob M) res /\\ res = a]) (undup (X i)).\n  proof.\n  move=> support_M.\n  rewrite (@result_partitioning M i E X &m).\n  have ->: Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem (X i) res]\n           = Pr[M.f(i) @ &m: false].\n    rewrite Pr[mu_false]; byphoare (_: arg = i ==> _)=> //=.\n    by hoare; conseq (support_M i)=> />.\n  by rewrite Pr[mu_false].\n  qed.\n  end section.\nend TotalResultPartitioning.\n\ntheory TotalSubuniformResultOnly.\n  import TotalResultPartitioning.\n\n  section.\n  declare module M : T.\n\n  axiom M_suf a b i (X:input -> output list) &m:\n       mem (X i) a\n    => mem (X i) b\n    => Pr[M.f(i) @ &m: res = a] = Pr[M.f(i) @ &m: res = b].\n\n  lemma subuniform_result i (X:input -> output list) a &m:\n       (forall i, hoare [M.f: arg = i ==> mem (X i) res])\n    => mem (X i) a\n    => Pr[M.f(i) @ &m: true] = (size (undup (X i)))%r * Pr[M.f(i) @ &m: res = a].\n  proof.\n  move=> support_M a_in_X.\n  rewrite\n    (@total_result_partitioning M i (fun _ _=> predT) X &m) //\n    big_seq (@eq_bigr _ _ (fun b=> Pr[M.f(i) @ &m: res = a])).\n  + by move=> b /=; rewrite mem_undup=> b_in_X; exact/(@M_suf b a i X &m).\n  rewrite -big_seq big_const count_predT -AddMonoid.iteropE -intmulpE 1:size_ge0.\n  by rewrite intmulr mulrC.\n  qed.\n  end section.\nend TotalSubuniformResultOnly.\n\ntheory SubuniformReference.\n  import TotalSubuniformResultOnly.\n  (*---*) import MUniform DScalar.\n\n  (* \"fun i=> Pr[M.f(i) @ &m: true]\" is not well-defined because of &m *)\n  op ____(OP_0)____ : { ____(OP_2)____ -> real | ____(OP_3)____ i, ____(OP_1)____ < k i <= 1%r } as k_in_unit.\n\n  lemma ____(LEMMA_0)____ ____(LEMMA_1)____: 0%r < k i  by move: (k_in_unit i).\n  lemma le1_k i: k i <= 1%r by move: (k_in_unit i).\n\n  module Ref = {\n    proc f(i : input, xs : output list): output = {\n      var r;\n\n      r <$ (k i) \\cdot (duniform xs);\n      return r;\n    }\n  }.\n\n  section.\n  declare module M : T.\n\n  axiom M_suf a b i X &m:\n       List.mem (X i) a\n    => mem (X i) b\n    => Pr[M.f(i) @ &m: res = a] = Pr[M.f(i) @ &m: res = b].\n\n  axiom weight_M: phoare [M.f: true ==> true] =(k arg).\n\n  lemma pr_res_notin_X a i X &m:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => !mem (X i) a\n    => Pr[M.f(i) @ &m: res = a] = 0%r.\n  proof.\n  move=> support_M a_notin_X.\n  byphoare (_: arg = i ==> _)=> //=; hoare; conseq (support_M i)=> /> r.\n  by apply/(@contra (r = a) (!r \\in (X i)))=> ->.\n  qed.\n\n  lemma is_subuniform i X a &m:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => mem (X i) a\n    => Pr[M.f(i) @ &m: res = a] = (k i)/(size (undup (X i)))%r.\n  proof.\n  move=> support_M a_in_X; have <-: Pr[M.f(i) @ &m: true] = (k i).\n  + by byphoare (_: arg = i ==> true)=> //=; conseq weight_M.\n  rewrite (@subuniform_result M M_suf i X a &m support_M a_in_X) mulrAC divff //.\n  rewrite eq_fromint size_eq0 undup_nilp -implybF=> h.\n  by move: a_in_X; rewrite h.\n  qed.\n\n  lemma eq_M_Ref &m X:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => (forall i, X i <> [])\n    => equiv [M.f ~ Ref.f: (i,xs){2} = (arg,X arg){1} ==> ={res}].\n  proof.\n  move=> support_M Xi_neq0.\n  bypr (res{1}) (res{2})=> //= &1 &2 a [] i_def xs_def.\n  case: (mem (X arg{1}) a); last first.\n  + move=> ^a_notin_X /(@pr_res_notin_X a arg{1} X &1 support_M) ->.\n    byphoare (_: (i,xs) = (arg,X arg){1} ==> _)=> //=.\n    hoare; proc; auto=> /> r.\n    rewrite supp_dscalar 1:gt0_k.\n    + by rewrite duniform_ll 1:Xi_neq0 // le1_k.\n    case: (r = a)=> [->|//];by rewrite supp_duniform.\n  move=> a_in_X. rewrite (@is_subuniform arg{1} X a &1 support_M a_in_X).\n  byphoare (_: (i,xs) = (i,xs){2} ==> _)=> //=; proc; rnd (pred1 a); auto=> />.\n  rewrite dscalar1E 1:ltrW 1:gt0_k.\n  + by rewrite duniform_ll 1:xs_def 1:Xi_neq0 //= le1_k.\n  by rewrite duniform1E i_def xs_def a_in_X.\n  qed.\n  end section.\nend SubuniformReference.",
        "complete:": "(* --------------------------------------------------------------------\n * Copyright (c) - 2012--2016 - IMDEA Software Institute\n * Copyright (c) - 2012--2018 - Inria\n * Copyright (c) - 2012--2018 - Ecole Polytechnique\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\nrequire import AllCore List Distr StdBigop StdRing StdOrder.\n(*---*) import Bigreal BRA RField IntOrder RealOrder.\n\npragma +implicits.\n\ntype input, output.\n\nmodule type T = {\n  proc f(_: input): output\n}.\n\nabstract theory ListPartitioning.\n  type partition.\n\n  section.\n  declare module M : T.\n\n  lemma list_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition list) &m:\n    uniq P =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) P\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem P (phi i (glob M) res)].\n  proof.\n  move=> uniq_P. rewrite Pr[mu_split (mem P (phi i (glob M) res))]; congr.\n  elim: P uniq_P=> /=; first by rewrite big_nil Pr[mu_false].\n  move=> x xs ih [] x_notin_xs uniq_xs /=.\n  rewrite {1}andb_orr Pr[mu_or] andbCA !andbA andbb.\n  have ->: Pr[M.f(i) @ &m: (   E i (glob M) res\n                            /\\ phi i (glob M) res = x)\n                           /\\ mem xs (phi i (glob M) res)]\n           = Pr[M.f(i) @ &m: false].\n  + by rewrite Pr[mu_eq] // => &hr /#.\n  by rewrite Pr[mu_false] //= big_cons {1}/predT /=; congr; exact/ih.\n  qed.\n  end section.\nend ListPartitioning.\n\nabstract theory FSetPartitioning.\n  require import FSet.\n\n  type partition.\n\n  section.\n  declare module M : T.\n\n  local clone import ListPartitioning with\n    type partition <- partition.\n\n  lemma fset_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition fset) &m:\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) (elems P)\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem P (phi i (glob M) res)].\n  proof.\n  by rewrite memE; exact/(@list_partitioning M i E phi (elems P) &m _)/uniq_elems.\n  qed.\n  end section.\nend FSetPartitioning.\n\nabstract theory FPredPartitioning.\n  require import Finite.\n\n  type partition.\n\n  section.\n  declare module M : T.\n\n  local clone import ListPartitioning with\n    type partition <- partition.\n\n  lemma fpred_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (phi : input -> (glob M) -> output -> partition)\n          (P : partition -> bool) &m:\n    is_finite P =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a =>\n                   Pr[M.f(i) @ &m: E i (glob M) res /\\ phi i (glob M) res = a]) (to_seq P)\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !P (phi i (glob M) res)].\n  proof.\n  move=> ^/mem_to_seq <- /uniq_to_seq.\n  exact/(@list_partitioning M i E phi (to_seq P) &m).\n  qed.\n  end section.\nend FPredPartitioning.\n\ntheory ResultPartitioning.\n  section.\n  declare module M : T.\n\n  local clone import ListPartitioning with\n    type partition <- output.\n\n  lemma result_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (X : input -> output list)\n          &m:\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a=> Pr[M.f(i) @ &m: E i (glob M) res /\\ res = a]) (undup (X i))\n      + Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem (X i) res].\n  proof.\n  rewrite -mem_undup.\n  exact/(@list_partitioning M i E (fun _ _ x=> x) (undup (X i)) &m)/undup_uniq.\n  qed.\n  end section.\nend ResultPartitioning.\n\ntheory TotalResultPartitioning.\n  (*---*) import ResultPartitioning.\n\n  section.\n  declare module M : T.\n\n  lemma total_result_partitioning\n          (i : input)\n          (E : input -> (glob M) -> output -> bool)\n          (X : input -> output list)\n          &m:\n    (forall i, hoare [M.f: arg = i ==> mem (X i) res]) =>\n    Pr[M.f(i) @ &m: E i (glob M) res]\n    = big predT (fun a => Pr[M.f(i) @ &m: E i (glob M) res /\\ res = a]) (undup (X i)).\n  proof.\n  move=> support_M.\n  rewrite (@result_partitioning M i E X &m).\n  have ->: Pr[M.f(i) @ &m: E i (glob M) res /\\ !mem (X i) res]\n           = Pr[M.f(i) @ &m: false].\n    rewrite Pr[mu_false]; byphoare (_: arg = i ==> _)=> //=.\n    by hoare; conseq (support_M i)=> />.\n  by rewrite Pr[mu_false].\n  qed.\n  end section.\nend TotalResultPartitioning.\n\ntheory TotalSubuniformResultOnly.\n  import TotalResultPartitioning.\n\n  section.\n  declare module M : T.\n\n  axiom M_suf a b i (X:input -> output list) &m:\n       mem (X i) a\n    => mem (X i) b\n    => Pr[M.f(i) @ &m: res = a] = Pr[M.f(i) @ &m: res = b].\n\n  lemma subuniform_result i (X:input -> output list) a &m:\n       (forall i, hoare [M.f: arg = i ==> mem (X i) res])\n    => mem (X i) a\n    => Pr[M.f(i) @ &m: true] = (size (undup (X i)))%r * Pr[M.f(i) @ &m: res = a].\n  proof.\n  move=> support_M a_in_X.\n  rewrite\n    (@total_result_partitioning M i (fun _ _=> predT) X &m) //\n    big_seq (@eq_bigr _ _ (fun b=> Pr[M.f(i) @ &m: res = a])).\n  + by move=> b /=; rewrite mem_undup=> b_in_X; exact/(@M_suf b a i X &m).\n  rewrite -big_seq big_const count_predT -AddMonoid.iteropE -intmulpE 1:size_ge0.\n  by rewrite intmulr mulrC.\n  qed.\n  end section.\nend TotalSubuniformResultOnly.\n\ntheory SubuniformReference.\n  import TotalSubuniformResultOnly.\n  (*---*) import MUniform DScalar.\n\n  (* \"fun i=> Pr[M.f(i) @ &m: true]\" is not well-defined because of &m *)\n  op k : { input -> real | forall i, 0%r < k i <= 1%r } as k_in_unit.\n\n  lemma gt0_k i: 0%r < k i  by move: (k_in_unit i).\n  lemma le1_k i: k i <= 1%r by move: (k_in_unit i).\n\n  module Ref = {\n    proc f(i : input, xs : output list): output = {\n      var r;\n\n      r <$ (k i) \\cdot (duniform xs);\n      return r;\n    }\n  }.\n\n  section.\n  declare module M : T.\n\n  axiom M_suf a b i X &m:\n       List.mem (X i) a\n    => mem (X i) b\n    => Pr[M.f(i) @ &m: res = a] = Pr[M.f(i) @ &m: res = b].\n\n  axiom weight_M: phoare [M.f: true ==> true] =(k arg).\n\n  lemma pr_res_notin_X a i X &m:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => !mem (X i) a\n    => Pr[M.f(i) @ &m: res = a] = 0%r.\n  proof.\n  move=> support_M a_notin_X.\n  byphoare (_: arg = i ==> _)=> //=; hoare; conseq (support_M i)=> /> r.\n  by apply/(@contra (r = a) (!r \\in (X i)))=> ->.\n  qed.\n\n  lemma is_subuniform i X a &m:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => mem (X i) a\n    => Pr[M.f(i) @ &m: res = a] = (k i)/(size (undup (X i)))%r.\n  proof.\n  move=> support_M a_in_X; have <-: Pr[M.f(i) @ &m: true] = (k i).\n  + by byphoare (_: arg = i ==> true)=> //=; conseq weight_M.\n  rewrite (@subuniform_result M M_suf i X a &m support_M a_in_X) mulrAC divff //.\n  rewrite eq_fromint size_eq0 undup_nilp -implybF=> h.\n  by move: a_in_X; rewrite h.\n  qed.\n\n  lemma eq_M_Ref &m X:\n       (forall i, hoare [M.f: arg = i ==> List.mem (X i) res])\n    => (forall i, X i <> [])\n    => equiv [M.f ~ Ref.f: (i,xs){2} = (arg,X arg){1} ==> ={res}].\n  proof.\n  move=> support_M Xi_neq0.\n  bypr (res{1}) (res{2})=> //= &1 &2 a [] i_def xs_def.\n  case: (mem (X arg{1}) a); last first.\n  + move=> ^a_notin_X /(@pr_res_notin_X a arg{1} X &1 support_M) ->.\n    byphoare (_: (i,xs) = (arg,X arg){1} ==> _)=> //=.\n    hoare; proc; auto=> /> r.\n    rewrite supp_dscalar 1:gt0_k.\n    + by rewrite duniform_ll 1:Xi_neq0 // le1_k.\n    case: (r = a)=> [->|//];by rewrite supp_duniform.\n  move=> a_in_X. rewrite (@is_subuniform arg{1} X a &1 support_M a_in_X).\n  byphoare (_: (i,xs) = (i,xs){2} ==> _)=> //=; proc; rnd (pred1 a); auto=> />.\n  rewrite dscalar1E 1:ltrW 1:gt0_k.\n  + by rewrite duniform_ll 1:xs_def 1:Xi_neq0 //= le1_k.\n  by rewrite duniform1E i_def xs_def a_in_X.\n  qed.\n  end section.\nend SubuniformReference."
    },
    {
        "file": "EC-1/FMapAux.ec",
        "incomplete": "(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => eq_exc X_x.\nby rewrite eq_except_sym eq_except_pred_set_l 1:eq_except_sym.\nqed.\n\nlemma eq_except_not_pred_get\n      (X : 'a -> bool) (x : 'a) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => ! X x => m1.[x] = m2.[x].\nproof.\nmove => /eq_exceptP eq_exc not_X_x.\nby rewrite eq_exc.\nqed.",
        "complete:": "(* FMapAux.ec *)\n\nrequire import AllCore FMap.\n\nlemma eq_except_pred_set\n      (X : 'a -> bool) (x : 'a) (y y' : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.[x <- y'].\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\ndo 2! rewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_l\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1.[x <- y] m2.\nproof.\nmove => /eq_exceptP eq_exc X_x.\nrewrite eq_exceptP => z not_X_z.\ncase (z = x) => [->> // |] ne_z_x.\nrewrite get_set_neqE //.\nby rewrite eq_exc.\nqed.\n\nlemma eq_except_pred_set_r\n      (X : 'a -> bool) (x : 'a) (y : 'b) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => X x => eq_except X m1 m2.[x <- y].\nproof.\nmove => eq_exc X_x.\nby rewrite eq_except_sym eq_except_pred_set_l 1:eq_except_sym.\nqed.\n\nlemma eq_except_not_pred_get\n      (X : 'a -> bool) (x : 'a) (m1 m2 : ('a, 'b) fmap) :\n  eq_except X m1 m2 => ! X x => m1.[x] = m2.[x].\nproof.\nmove => /eq_exceptP eq_exc not_X_x.\nby rewrite eq_exc.\nqed."
    },
    {
        "file": "EC-1/FundamentalLemma.ec",
        "incomplete": "require import Distr Real StdOrder.\n(*---*) import RealOrder.\n\nop max (x ____(OP_0)____ : real) = if x <= y ____(OP_2)____ y ____(OP_1)____ x.\n\ntype ____(TYPE_0)____.\n\n(* We want the bad event to be defined on both sides, *\n * so we assume that all the variables that are used  *\n * to define victory conditions and bad events are    *\n * stored in a separate module. (Note: the empty      *\n * signature could be instantiated with anything,     *\n * including the concrete experiment themselves       *\n * if their glob types match.)                        *)\nmodule type Mem = { }.\n\nmodule type Exp = {\n  proc main(): t\n}.\n\nlemma Pr_split (G <: Exp) (Mem <: Mem) (A: (glob Mem) -> t -> bool) (F: (glob Mem) -> t -> bool) &m:\n  Pr[G.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n  + Pr[G.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G.main() @ &m: A (glob Mem) res].\nproof.\nhave <-: Pr[G.main() @ &m: (A (glob Mem) res /\\ F (glob Mem) res) \\/\n                           (A (glob Mem) res /\\ !F (glob Mem) res)]\n         = Pr[G.main() @ &m: A (glob Mem) res].\n+ by rewrite Pr [mu_eq]=> /#.\nby rewrite Pr [mu_disjoint]=> /#.\nqed.\n\nlemma FundamentalLemma (G1 <: Exp) (G2 <: Exp) (Mem <: Mem)\n                       (A: (glob Mem) -> t -> bool) (B: (glob Mem) -> t -> bool)\n                       (F: (glob Mem) -> t -> bool) &m:\n  Pr[G1.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G2.main() @ &m: B (glob Mem) res /\\ !F (glob Mem) res] =>\n  `|Pr[G1.main() @ &m: A (glob Mem) res] - Pr[G2.main() @ &m: B (glob Mem) res]|\n  <= max Pr[G1.main() @ &m: F (glob Mem) res] Pr[G2.main() @ &m: F (glob Mem) res].\nproof.\nrewrite -(Pr_split G1 Mem A F &m) -(Pr_split G2 Mem B F &m)=> ->.\nhave ->: forall (x y z:real), x + y - (z + y) = x - z by smt().\napply (ler_trans (max Pr[G1.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n                      Pr[G2.main() @ &m: B (glob Mem) res /\\ F (glob Mem) res])).\n+ smt(ge0_mu).\nhave -> //: forall (x y x' y':real), x <= x' => y <= y' => max x y <= max x' y' by smt().\n+ by rewrite -(Pr_split G1 Mem F A &m) andbC; smt(ge0_mu).\nby rewrite -(Pr_split G2 Mem F B &m) andbC; smt(ge0_mu).\nqed.",
        "complete:": "require import Distr Real StdOrder.\n(*---*) import RealOrder.\n\nop max (x y : real) = if x <= y then y else x.\n\ntype t.\n\n(* We want the bad event to be defined on both sides, *\n * so we assume that all the variables that are used  *\n * to define victory conditions and bad events are    *\n * stored in a separate module. (Note: the empty      *\n * signature could be instantiated with anything,     *\n * including the concrete experiment themselves       *\n * if their glob types match.)                        *)\nmodule type Mem = { }.\n\nmodule type Exp = {\n  proc main(): t\n}.\n\nlemma Pr_split (G <: Exp) (Mem <: Mem) (A: (glob Mem) -> t -> bool) (F: (glob Mem) -> t -> bool) &m:\n  Pr[G.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n  + Pr[G.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G.main() @ &m: A (glob Mem) res].\nproof.\nhave <-: Pr[G.main() @ &m: (A (glob Mem) res /\\ F (glob Mem) res) \\/\n                           (A (glob Mem) res /\\ !F (glob Mem) res)]\n         = Pr[G.main() @ &m: A (glob Mem) res].\n+ by rewrite Pr [mu_eq]=> /#.\nby rewrite Pr [mu_disjoint]=> /#.\nqed.\n\nlemma FundamentalLemma (G1 <: Exp) (G2 <: Exp) (Mem <: Mem)\n                       (A: (glob Mem) -> t -> bool) (B: (glob Mem) -> t -> bool)\n                       (F: (glob Mem) -> t -> bool) &m:\n  Pr[G1.main() @ &m: A (glob Mem) res /\\ !F (glob Mem) res]\n  = Pr[G2.main() @ &m: B (glob Mem) res /\\ !F (glob Mem) res] =>\n  `|Pr[G1.main() @ &m: A (glob Mem) res] - Pr[G2.main() @ &m: B (glob Mem) res]|\n  <= max Pr[G1.main() @ &m: F (glob Mem) res] Pr[G2.main() @ &m: F (glob Mem) res].\nproof.\nrewrite -(Pr_split G1 Mem A F &m) -(Pr_split G2 Mem B F &m)=> ->.\nhave ->: forall (x y z:real), x + y - (z + y) = x - z by smt().\napply (ler_trans (max Pr[G1.main() @ &m: A (glob Mem) res /\\ F (glob Mem) res]\n                      Pr[G2.main() @ &m: B (glob Mem) res /\\ F (glob Mem) res])).\n+ smt(ge0_mu).\nhave -> //: forall (x y x' y':real), x <= x' => y <= y' => max x y <= max x' y' by smt().\n+ by rewrite -(Pr_split G1 Mem F A &m) andbC; smt(ge0_mu).\nby rewrite -(Pr_split G2 Mem F B &m) andbC; smt(ge0_mu).\nqed."
    },
    {
        "file": "EC-1/generalize-module-aliases.ec",
        "incomplete": "module type T = {\n  proc f(): bool\n}.\n\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare ____(DECLARE_0)____ M_T1 <: T.\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule ____(MODULE_0)____ = F(M_T1).\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof. admitted.\n\nhoare L2: A2(C).M.N.g: true ==> true.\nproof. admitted.\n\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed.\n\nhoare LL2 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L1 M1 C). qed. (* The module alias C can escape the section *)\n\nhoare LL3 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L2 M1). qed.",
        "complete:": "module type T = {\n  proc f(): bool\n}.\n\n\nmodule F(O1 : T, O2 : T) = {\n  module M = {\n    module N = {\n      proc g() = {\n        var r1, r2;\n    \n        r1 <@ O1.f();\n        r2 <@ O2.f();\n        return (r1, r2);\n      }\n    }\n  }\n}.\n\nmodule M : T = {\n  proc f() = {\n    return true;\n  }\n}.\n\nsection.\ndeclare module M_T1 <: T.\ndeclare module M_T2 <: T.\n\nmodule A1 = F(M_T1, M_T2).M.\nmodule A2 = F(M_T1).\n\nmodule C = M.\n\nhoare L1: A1.N.g: true ==> true.\nproof. admitted.\n\nhoare L2: A2(C).M.N.g: true ==> true.\nproof. admitted.\n\nend section.\n\nhoare LL1 (M1 <: T) (M2 <: T): F(M1, M2).M.N.g : true ==> true.\nproof. exact (L1 M1 M2). qed.\n\nhoare LL2 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L1 M1 C). qed. (* The module alias C can escape the section *)\n\nhoare LL3 (M1 <: T): F(M1, M).M.N.g : true ==> true.\nproof. exact (L2 M1). qed."
    },
    {
        "file": "EC-1/hashed_elgamal_generic.ec",
        "incomplete": "require import AllCore Int Real FSet StdOrder.\nrequire (*--*) BitWord Distr DInterval.\n(*---*) import RealOrder RField.\nrequire (*--*) DiffieHellman ROM PKE_CPA.\n\n(* The type of plaintexts: bitstrings of length k *)\nop ____(OP_0)____: { int | 0 < k } as ____(OP_1)____.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(* Upper bound on the number of calls to H *)\nop qH: { int | 0 < qH } as gt0_qH.\n\n(* Assumption: Set CDH *)\nclone import DiffieHellman.Set_CDH as SCDH with\n  op n <- qH.\nimport DiffieHellman G FDistr.\n\ntype pkey = ____(TYPE_0)____.\ntype skey = t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\n(* Goal: PK IND-CPA *)\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(* Some abstract hash oracle *)\nmodule type Hash = {\n  proc init(): unit\n  proc hash(x:group): bits\n}.\n\nmodule Hashed_ElGamal (H:Hash): Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    H.init();\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y, h;\n\n    y <$ dt;\n    h <@ H.hash(pk ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <@ H.hash(gy ^ sk);\n    return Some (h +^ hm);\n  }\n}.\n\nclone import ROM as RO with\n  type in_t    <- group,\n  type out_t   <- bits,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <- dbits.\nimport Lazy.\nclone import ROM_BadCall as ROC with\n  op qH <- qH.\n\n(* Adversary Definitions *)\nmodule type Adversary (O : POracle) = {\n  proc choose(pk:pkey): ptxt * ptxt\n  proc guess(c:ctxt)  : bool\n}.\n\n(* Specializing and merging the hash function *)\nmodule H : Hash = {\n  proc init(): unit = { LRO.init(); Log.qs <- fset0; }\n  proc hash(x:group): bits = { var y; y <@ LRO.o(x); return y; }\n}.\n\n(* The initial scheme *)\nmodule ____(MODULE_0)____ = Hashed_ElGamal(H).\n\n(* The reduction *)\nmodule SCDH_from_CPA(A:Adversary,O:Oracle): Top.SCDH.Adversary = {\n  module BA = A(Bound(O))\n\n  proc solve(gx:group, gy:group): group fset = {\n    var m0, m1, h, b';\n\n    H.init();\n    (m0,m1)  <@ BA.choose(gx);\n    h        <$ dbits;\n    b'       <@ BA.guess(gy, h);\n    return Log.qs;\n  }\n}.\n\n(* We want to bound the probability of A winning CPA(Bounder(A,RO),S) in terms of\n   the probability of B = CDH_from_CPA(SCDH_from_CPA(A,RO)) winning CDH(B) *)\nsection.\n  declare ____(DECLARE_0)____ A: Adversary { LRO, ____(DECLARE_1)____, OnBound.G1, OnBound.G_bad }.\n\n  axiom choose_ll (O <: POracle {A}): islossless O.o => islossless A(O).choose.\n  axiom guess_ll (O <: POracle {A}) : islossless O.o => islossless A(O).guess.\n\n  local module BA = A(Bound(LRO)).\n\n  local module G0 = {\n    var gxy:group\n\n    proc main(): bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <@ H.hash(gxy);\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local equiv CPA_G0: CPA(S,BA).main ~ G0.main: ={glob A} ==> ={res}.\n  proof.\n    proc.\n    inline Hashed_ElGamal(H).kg Hashed_ElGamal(H).enc.\n    swap{1} 8 -5.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; call (_: ={glob H}); first by sim.\n    wp; rnd.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; do !rnd.\n    by call (_: true ==> ={glob H}); first by sim.\n  qed.\n\n  local lemma Pr_CPA_G0 &m:\n    Pr[CPA(S,BA).main() @ &m: res] = Pr[G0.main() @ &m: res]\n  by byequiv CPA_G0.\n\n  local module G1 = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local module G2 = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return G2.gxy \\in Log.qs;\n    }\n  }.\n\n  local module (D : ROC.Dist) (H : POracle) = {\n    module A = A(H)\n\n    var y:t\n    var b:bool\n    var m0, m1:ptxt\n\n    proc a1(): group = {\n      var x, gxy, gx;\n\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ A.choose(gx);\n      b       <$ {0,1};\n      return gxy;\n    }\n\n    proc a2(x:bits): bool = {\n      var c, b';\n\n      c  <- (g ^ y, x +^ (b ? m1 : m0));\n      b' <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G0_D &m: Pr[G0.main() @ &m: res] = Pr[OnBound.G0(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G1_D &m: Pr[G1.main() @ &m: res] = Pr[OnBound.G1(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G2_D &m: Pr[G2.main() @ &m: res] = Pr[OnBound.G_bad(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={glob Log, b'} /\\ b{1} = D.b{2} /\\ G2.gxy{1} = x{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G0_G1_G2 &m:\n    Pr[G0.main() @ &m: res] <= Pr[G1.main() @ &m: res] + Pr[G2.main() @ &m: res].\n  proof.\n  rewrite (G0_D &m) (G1_D &m) (G2_D &m).\n  move: (OnBound.ROM_BadCall D _ _ _ &m tt true).\n  + move=> H H_o_ll; proc; auto; call (choose_ll H _)=> //; auto=> />.\n    by rewrite dt_ll DBool.dbool_ll.\n  + by move=> H H_o_ll; proc; auto; call (guess_ll H _)=> //; auto=> />.\n  + by move=> _; apply: dbits_ll.\n  by rewrite !eqT.\n  qed.\n\n  local module G1' = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h);\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G1_G1' &m: Pr[G1.main() @ &m: res] = Pr[G1'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then m1 else m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Pr_G1' &m: Pr[G1'.main() @ &m: res] = 1%r/2%r.\n  proof.\n    have LRO_o_ll := LRO_o_ll _; first by move=> /=; apply: dbits_ll.\n    byphoare (_: true ==> res)=> //.\n    proc.\n    swap 7 3.\n    rnd (pred1 b').\n    conseq (_: true) => />.\n    + by move=> b'; rewrite DBool.dbool1E /pred1 => />.\n    islossless.\n    + by apply (guess_ll (Bound(LRO))); islossless.\n    by apply (choose_ll (Bound(LRO))); islossless.\n  qed.\n\n  local module G2' = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x        <$ dt;\n      y        <$ dt;\n      gx       <- g ^ x;\n      gxy      <- gx ^ y;\n      (m0,m1)  <@ BA.choose(gx);\n      b        <$ {0,1};\n      h        <$ dbits;\n      c        <- (g ^ y, h);\n      b'       <@ BA.guess(c);\n      return gxy \\in Log.qs;\n    }\n  }.\n\n  local lemma G2_G2' &m: Pr[G2.main() @ &m: res] = Pr[G2'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then m1 else m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local equiv G2'_SCDH: G2'.main ~ SCDH(SCDH_from_CPA(A,LRO)).main:\n    ={glob A} ==> res{1} = res{2} /\\ card Log.qs{1} <= qH.\n  proof.\n    proc.\n    inline SCDH_from_CPA(A,LRO).solve.\n    swap{2} 5 -4; swap{1} 7 3.\n    rnd{1}; wp.\n    seq  8  7: (={glob BA} /\\\n                c{1} = (gy, h){2} /\\\n                G2'.gxy{1} = g ^ (x * y){2} /\\\n                card Log.qs{1} <= qH).\n      wp; rnd; call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n        proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> />.\n        by move=> &2 _ szqs_lt_qH _ _; rewrite fcardU fcard1; smt(fcard_ge0).\n      by inline H.init LRO.init; auto=> />; rewrite fcards0; smt(gt0_qH pow_pow).\n    call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n      proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> /> &2 _ szqs_lt_qH _ _.\n      by rewrite fcardU fcard1; smt(fcard_ge0).\n    by auto => />.\n  qed.\n\n  local lemma Pr_G2'_SCDH &m :\n    Pr[G2'.main() @ &m: res]\n    = Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m : res]\n  by byequiv G2'_SCDH.\n\n  local lemma Reduction &m :\n    Pr[CPA(S,BA).main() @ &m : res] <=\n    1%r / 2%r + Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m : res].\n  proof.\n    rewrite (Pr_CPA_G0 &m).\n    rewrite -(Pr_G1' &m) -(G1_G1' &m).\n    rewrite -(Pr_G2'_SCDH &m) -(G2_G2' &m).\n    by apply (G0_G1_G2 &m).\n  qed.\n\n  (** Composing reduction from CPA to SCDH with reduction from SCDH to CDH *)\n  lemma Security &m:\n      Pr[CPA(S,A(Bound(LRO))).main() @ &m: res] - 1%r / 2%r <=\n      qH%r * Pr[CDH.CDH(CDH_from_SCDH(SCDH_from_CPA(A,LRO))).main() @ &m: res].\n  proof.\n    apply (ler_trans (Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m: res])).\n    + smt(Reduction).\n    have:= Self.SCDH.Reduction (SCDH_from_CPA(A,LRO)) &m gt0_qH.    \n    by rewrite -mulrA mul1r mulrC ler_pdivr_mulr 1:lt_fromint 1:gt0_qH mulrC.\n  qed.\nend section.\n\nprint axiom Security.",
        "complete:": "require import AllCore Int Real FSet StdOrder.\nrequire (*--*) BitWord Distr DInterval.\n(*---*) import RealOrder RField.\nrequire (*--*) DiffieHellman ROM PKE_CPA.\n\n(* The type of plaintexts: bitstrings of length k *)\nop k: { int | 0 < k } as gt0_k.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(* Upper bound on the number of calls to H *)\nop qH: { int | 0 < qH } as gt0_qH.\n\n(* Assumption: Set CDH *)\nclone import DiffieHellman.Set_CDH as SCDH with\n  op n <- qH.\nimport DiffieHellman G FDistr.\n\ntype pkey = group.\ntype skey = t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\n(* Goal: PK IND-CPA *)\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(* Some abstract hash oracle *)\nmodule type Hash = {\n  proc init(): unit\n  proc hash(x:group): bits\n}.\n\nmodule Hashed_ElGamal (H:Hash): Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    H.init();\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y, h;\n\n    y <$ dt;\n    h <@ H.hash(pk ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <@ H.hash(gy ^ sk);\n    return Some (h +^ hm);\n  }\n}.\n\nclone import ROM as RO with\n  type in_t    <- group,\n  type out_t   <- bits,\n  type d_in_t  <- unit,\n  type d_out_t <- bool,\n  op   dout _  <- dbits.\nimport Lazy.\nclone import ROM_BadCall as ROC with\n  op qH <- qH.\n\n(* Adversary Definitions *)\nmodule type Adversary (O : POracle) = {\n  proc choose(pk:pkey): ptxt * ptxt\n  proc guess(c:ctxt)  : bool\n}.\n\n(* Specializing and merging the hash function *)\nmodule H : Hash = {\n  proc init(): unit = { LRO.init(); Log.qs <- fset0; }\n  proc hash(x:group): bits = { var y; y <@ LRO.o(x); return y; }\n}.\n\n(* The initial scheme *)\nmodule S = Hashed_ElGamal(H).\n\n(* The reduction *)\nmodule SCDH_from_CPA(A:Adversary,O:Oracle): Top.SCDH.Adversary = {\n  module BA = A(Bound(O))\n\n  proc solve(gx:group, gy:group): group fset = {\n    var m0, m1, h, b';\n\n    H.init();\n    (m0,m1)  <@ BA.choose(gx);\n    h        <$ dbits;\n    b'       <@ BA.guess(gy, h);\n    return Log.qs;\n  }\n}.\n\n(* We want to bound the probability of A winning CPA(Bounder(A,RO),S) in terms of\n   the probability of B = CDH_from_CPA(SCDH_from_CPA(A,RO)) winning CDH(B) *)\nsection.\n  declare module A: Adversary { LRO, Log, OnBound.G1, OnBound.G_bad }.\n\n  axiom choose_ll (O <: POracle {A}): islossless O.o => islossless A(O).choose.\n  axiom guess_ll (O <: POracle {A}) : islossless O.o => islossless A(O).guess.\n\n  local module BA = A(Bound(LRO)).\n\n  local module G0 = {\n    var gxy:group\n\n    proc main(): bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <@ H.hash(gxy);\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local equiv CPA_G0: CPA(S,BA).main ~ G0.main: ={glob A} ==> ={res}.\n  proof.\n    proc.\n    inline Hashed_ElGamal(H).kg Hashed_ElGamal(H).enc.\n    swap{1} 8 -5.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; call (_: ={glob H}); first by sim.\n    wp; rnd.\n    call (_: ={glob H, Log.qs}); first by sim.\n    wp; do !rnd.\n    by call (_: true ==> ={glob H}); first by sim.\n  qed.\n\n  local lemma Pr_CPA_G0 &m:\n    Pr[CPA(S,BA).main() @ &m: res] = Pr[G0.main() @ &m: res]\n  by byequiv CPA_G0.\n\n  local module G1 = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local module G2 = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h +^ (b ? m1 : m0));\n      b'      <@ BA.guess(c);\n      return G2.gxy \\in Log.qs;\n    }\n  }.\n\n  local module (D : ROC.Dist) (H : POracle) = {\n    module A = A(H)\n\n    var y:t\n    var b:bool\n    var m0, m1:ptxt\n\n    proc a1(): group = {\n      var x, gxy, gx;\n\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ A.choose(gx);\n      b       <$ {0,1};\n      return gxy;\n    }\n\n    proc a2(x:bits): bool = {\n      var c, b';\n\n      c  <- (g ^ y, x +^ (b ? m1 : m0));\n      b' <@ A.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G0_D &m: Pr[G0.main() @ &m: res] = Pr[OnBound.G0(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G1_D &m: Pr[G1.main() @ &m: res] = Pr[OnBound.G1(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={b'} /\\ b{1} = D.b{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G2_D &m: Pr[G2.main() @ &m: res] = Pr[OnBound.G_bad(D,LRO).main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    inline D(Bound(LRO)).a1 D(Bound(LRO)).a2; wp.\n    conseq (_: _ ==> ={glob Log, b'} /\\ b{1} = D.b{2} /\\ G2.gxy{1} = x{2})=> //.\n    by inline H.hash; sim.\n  qed.\n\n  local lemma G0_G1_G2 &m:\n    Pr[G0.main() @ &m: res] <= Pr[G1.main() @ &m: res] + Pr[G2.main() @ &m: res].\n  proof.\n  rewrite (G0_D &m) (G1_D &m) (G2_D &m).\n  move: (OnBound.ROM_BadCall D _ _ _ &m tt true).\n  + move=> H H_o_ll; proc; auto; call (choose_ll H _)=> //; auto=> />.\n    by rewrite dt_ll DBool.dbool_ll.\n  + by move=> H H_o_ll; proc; auto; call (guess_ll H _)=> //; auto=> />.\n  + by move=> _; apply: dbits_ll.\n  by rewrite !eqT.\n  qed.\n\n  local module G1' = {\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx, gxy;\n\n      H.init();\n      x       <$ dt;\n      y       <$ dt;\n      gx      <- g ^ x;\n      gxy     <- gx ^ y;\n      (m0,m1) <@ BA.choose(gx);\n      b       <$ {0,1};\n      h       <$ dbits;\n      c       <- (g ^ y, h);\n      b'      <@ BA.guess(c);\n      return (b' = b);\n    }\n  }.\n\n  local lemma G1_G1' &m: Pr[G1.main() @ &m: res] = Pr[G1'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then m1 else m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Pr_G1' &m: Pr[G1'.main() @ &m: res] = 1%r/2%r.\n  proof.\n    have LRO_o_ll := LRO_o_ll _; first by move=> /=; apply: dbits_ll.\n    byphoare (_: true ==> res)=> //.\n    proc.\n    swap 7 3.\n    rnd (pred1 b').\n    conseq (_: true) => />.\n    + by move=> b'; rewrite DBool.dbool1E /pred1 => />.\n    islossless.\n    + by apply (guess_ll (Bound(LRO))); islossless.\n    by apply (choose_ll (Bound(LRO))); islossless.\n  qed.\n\n  local module G2' = {\n    var gxy : group\n\n    proc main() : bool = {\n      var m0, m1, c, b, b';\n      var x, y, h, gx;\n\n      H.init();\n      x        <$ dt;\n      y        <$ dt;\n      gx       <- g ^ x;\n      gxy      <- gx ^ y;\n      (m0,m1)  <@ BA.choose(gx);\n      b        <$ {0,1};\n      h        <$ dbits;\n      c        <- (g ^ y, h);\n      b'       <@ BA.guess(c);\n      return gxy \\in Log.qs;\n    }\n  }.\n\n  local lemma G2_G2' &m: Pr[G2.main() @ &m: res] = Pr[G2'.main() @ &m: res].\n  proof.\n    byequiv (_: ={glob A} ==> ={res})=> //.\n    proc.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    wp; rnd (fun h, h +^ if b then m1 else m0){1}; rnd.\n    call (_: ={glob LRO, glob Log}); first by sim.\n    by inline H.init LRO.init; auto=> /> *; split => *; algebra.\n  qed.\n\n  local equiv G2'_SCDH: G2'.main ~ SCDH(SCDH_from_CPA(A,LRO)).main:\n    ={glob A} ==> res{1} = res{2} /\\ card Log.qs{1} <= qH.\n  proof.\n    proc.\n    inline SCDH_from_CPA(A,LRO).solve.\n    swap{2} 5 -4; swap{1} 7 3.\n    rnd{1}; wp.\n    seq  8  7: (={glob BA} /\\\n                c{1} = (gy, h){2} /\\\n                G2'.gxy{1} = g ^ (x * y){2} /\\\n                card Log.qs{1} <= qH).\n      wp; rnd; call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n        proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> />.\n        by move=> &2 _ szqs_lt_qH _ _; rewrite fcardU fcard1; smt(fcard_ge0).\n      by inline H.init LRO.init; auto=> />; rewrite fcards0; smt(gt0_qH pow_pow).\n    call (_: ={glob H} /\\ card Log.qs{1} <= qH).\n      proc; sp; if=> //; inline Log(LRO).o LRO.o; auto=> /> &2 _ szqs_lt_qH _ _.\n      by rewrite fcardU fcard1; smt(fcard_ge0).\n    by auto => />.\n  qed.\n\n  local lemma Pr_G2'_SCDH &m :\n    Pr[G2'.main() @ &m: res]\n    = Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m : res]\n  by byequiv G2'_SCDH.\n\n  local lemma Reduction &m :\n    Pr[CPA(S,BA).main() @ &m : res] <=\n    1%r / 2%r + Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m : res].\n  proof.\n    rewrite (Pr_CPA_G0 &m).\n    rewrite -(Pr_G1' &m) -(G1_G1' &m).\n    rewrite -(Pr_G2'_SCDH &m) -(G2_G2' &m).\n    by apply (G0_G1_G2 &m).\n  qed.\n\n  (** Composing reduction from CPA to SCDH with reduction from SCDH to CDH *)\n  lemma Security &m:\n      Pr[CPA(S,A(Bound(LRO))).main() @ &m: res] - 1%r / 2%r <=\n      qH%r * Pr[CDH.CDH(CDH_from_SCDH(SCDH_from_CPA(A,LRO))).main() @ &m: res].\n  proof.\n    apply (ler_trans (Pr[SCDH(SCDH_from_CPA(A,LRO)).main() @ &m: res])).\n    + smt(Reduction).\n    have:= Self.SCDH.Reduction (SCDH_from_CPA(A,LRO)) &m gt0_qH.    \n    by rewrite -mulrA mul1r mulrC ler_pdivr_mulr 1:lt_fromint 1:gt0_qH mulrC.\n  qed.\nend section.\n\nprint axiom Security."
    },
    {
        "file": "EC-1/hashed_elgamal_std.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman BitWord PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(** Assumption: DDH **)\n(*** WARNING: DiffieHellman is not up to speed with latest developments ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Assumption Entropy Smoothing *)\ntheory EntropySmoothing.\n  type ____(TYPE_0)____.\n\n  op dhkey: { ____(OP_1)____ distr | is_lossless dhkey } as ____(OP_0)____.\n  hint exact ____(HINT_0)____ : dhkey_ll.  \n\n  op hash : hkey -> group -> bits.\n\n  module type AdvES = {\n    proc guess(_: hkey * bits) : bool\n  }.\n\n  module ES0 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, h;\n      hk <$ dhkey;\n      h  <$ dbits;\n      b  <@ A.guess(hk,h);\n      return b;\n    }\n  }.\n\n  module ES1 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, z;\n      hk <$ dhkey;\n      z  <$ dt;\n      b  <@ A.guess(hk, hash hk (g ^ z));\n      return b;\n    }\n  }.\nend EntropySmoothing.\nimport EntropySmoothing.\n\n(** Construction: a PKE **)\ntype pkey = hkey * group.\ntype skey = hkey * F.t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\nclone import PKE_CPA as PKE_ with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule Hashed_ElGamal : Scheme = {\n  proc kg() = {\n    var hk,sk;\n\n    hk <$ dhkey;\n    sk <$ dt;\n    return ((hk,g ^ sk), (hk,sk));\n  }\n\n  proc enc(pk: pkey, m: ptxt) = {\n    var y, h;\n\n    y <$ dt;\n    h <- hash pk.`1 (pk.`2 ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <- hash sk.`1 (gy ^ sk.`2);\n    return Some (h +^ hm);\n  }\n}.\n\n(** Exact security *)\nmodule DDHAdv(A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var hk, m0, m1, b, b', h;\n    hk       <$ dhkey;\n    (m0, m1) <@ A.choose((hk,gx));\n    b        <$ {0,1};\n    h        <- hash hk gz;\n    b'       <@ A.guess(gy,h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nmodule ESAdv(A:Adversary) = {\n  proc guess (hk, h) : bool = {\n    var x, y, m0, m1, b, b';\n    x        <$ dt;\n    y        <$ dt;\n    (m0, m1) <@ A.choose((hk,g^x));\n    b        <$ {0,1};\n    b'       <@ A.guess(g^y, h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nsection Security.\n  declare module ____(DECLARE_0)____:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(Hashed_ElGamal,A).main() @ &m : res]\n    = Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 1 1; swap{1} 8 -6; swap{2} 6 -3.\n  auto; call (: true).\n  auto; call (: true).\n  by auto=> /> sk _ y _ hk _ [m0 m1] b _ /=; rewrite pow_pow.\n  qed.\n\n  local lemma ddh1_es1 &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res]\n    = Pr[ES1(ESAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -3; swap{2} [5..6] -4; swap{2} 4 -1.\n  auto; call (: true).\n  auto; call (:true).\n  by auto.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var hk, x, y, v,m0, m1, b, b';\n      hk      <$ dhkey;\n      x       <$ dt;\n      y       <$ dt;\n      (m0,m1) <@ A.choose(hk,g^x);\n      v       <$ dbits;\n      b'      <@ A.guess(g^y, v);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma es0_Gb &m:\n      Pr[ES0(ESAdv(A)).main() @ &m : res]\n    = Pr[Gb.main()@ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 2 1. swap{1} [3..4] 4. swap{2} 7 -2.\n  auto; call (: true); wp.\n  rnd (fun w, w +^ (b0{1} ? m1{1} : m0{1})).\n  auto; call (: true).\n  by auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd (pred1 b')=> /=; conseq (_:_ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  call Ag_ll; auto.\n  by call Ac_ll; auto=> />; rewrite dhkey_ll dt_ll dbits_ll.\n  qed.\n\n  lemma conclusion &m :\n       `| Pr[CPA(Hashed_ElGamal,A).main() @ &m : res] - 1%r/2%r |\n    <= `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n          - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |\n       + `| Pr[ES0(ESAdv(A)).main() @ &m : res]\n            - Pr[ES1(ESAdv(A)).main() @ &m : res]|.\n  proof.\n  rewrite (cpa_ddh0 &m) (ddh1_es1 &m) (es0_Gb &m) (Gb_half &m).\n  smt(@Real).\n  qed.\nend section Security.\n\nprint conclusion.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman BitWord PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(** Assumption: DDH **)\n(*** WARNING: DiffieHellman is not up to speed with latest developments ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Assumption Entropy Smoothing *)\ntheory EntropySmoothing.\n  type hkey.\n\n  op dhkey: { hkey distr | is_lossless dhkey } as dhkey_ll.\n  hint exact random : dhkey_ll.  \n\n  op hash : hkey -> group -> bits.\n\n  module type AdvES = {\n    proc guess(_: hkey * bits) : bool\n  }.\n\n  module ES0 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, h;\n      hk <$ dhkey;\n      h  <$ dbits;\n      b  <@ A.guess(hk,h);\n      return b;\n    }\n  }.\n\n  module ES1 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, z;\n      hk <$ dhkey;\n      z  <$ dt;\n      b  <@ A.guess(hk, hash hk (g ^ z));\n      return b;\n    }\n  }.\nend EntropySmoothing.\nimport EntropySmoothing.\n\n(** Construction: a PKE **)\ntype pkey = hkey * group.\ntype skey = hkey * F.t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\nclone import PKE_CPA as PKE_ with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule Hashed_ElGamal : Scheme = {\n  proc kg() = {\n    var hk,sk;\n\n    hk <$ dhkey;\n    sk <$ dt;\n    return ((hk,g ^ sk), (hk,sk));\n  }\n\n  proc enc(pk: pkey, m: ptxt) = {\n    var y, h;\n\n    y <$ dt;\n    h <- hash pk.`1 (pk.`2 ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <- hash sk.`1 (gy ^ sk.`2);\n    return Some (h +^ hm);\n  }\n}.\n\n(** Exact security *)\nmodule DDHAdv(A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var hk, m0, m1, b, b', h;\n    hk       <$ dhkey;\n    (m0, m1) <@ A.choose((hk,gx));\n    b        <$ {0,1};\n    h        <- hash hk gz;\n    b'       <@ A.guess(gy,h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nmodule ESAdv(A:Adversary) = {\n  proc guess (hk, h) : bool = {\n    var x, y, m0, m1, b, b';\n    x        <$ dt;\n    y        <$ dt;\n    (m0, m1) <@ A.choose((hk,g^x));\n    b        <$ {0,1};\n    b'       <@ A.guess(g^y, h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(Hashed_ElGamal,A).main() @ &m : res]\n    = Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 1 1; swap{1} 8 -6; swap{2} 6 -3.\n  auto; call (: true).\n  auto; call (: true).\n  by auto=> /> sk _ y _ hk _ [m0 m1] b _ /=; rewrite pow_pow.\n  qed.\n\n  local lemma ddh1_es1 &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res]\n    = Pr[ES1(ESAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -3; swap{2} [5..6] -4; swap{2} 4 -1.\n  auto; call (: true).\n  auto; call (:true).\n  by auto.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var hk, x, y, v,m0, m1, b, b';\n      hk      <$ dhkey;\n      x       <$ dt;\n      y       <$ dt;\n      (m0,m1) <@ A.choose(hk,g^x);\n      v       <$ dbits;\n      b'      <@ A.guess(g^y, v);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma es0_Gb &m:\n      Pr[ES0(ESAdv(A)).main() @ &m : res]\n    = Pr[Gb.main()@ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 2 1. swap{1} [3..4] 4. swap{2} 7 -2.\n  auto; call (: true); wp.\n  rnd (fun w, w +^ (b0{1} ? m1{1} : m0{1})).\n  auto; call (: true).\n  by auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd (pred1 b')=> /=; conseq (_:_ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  call Ag_ll; auto.\n  by call Ac_ll; auto=> />; rewrite dhkey_ll dt_ll dbits_ll.\n  qed.\n\n  lemma conclusion &m :\n       `| Pr[CPA(Hashed_ElGamal,A).main() @ &m : res] - 1%r/2%r |\n    <= `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n          - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |\n       + `| Pr[ES0(ESAdv(A)).main() @ &m : res]\n            - Pr[ES1(ESAdv(A)).main() @ &m : res]|.\n  proof.\n  rewrite (cpa_ddh0 &m) (ddh1_es1 &m) (es0_Gb &m) (Gb_half &m).\n  smt(@Real).\n  qed.\nend section Security.\n\nprint conclusion."
    },
    {
        "file": "EC-1/KEMDEM.ec",
        "incomplete": "(* As specified in Boneh and Shoup's \"Graduate Course in Applied Cryptography\"\n     https://toc.cryptobook.us/\n   (Exercise 11.9 of version 0.6.)\n*)\nrequire import AllCore Distr.\n\n(** A more mature proof would rely on libraries of definitions-generic\n    definitions have a lot more parameters than what we'd like to\n    expose a tutorial reader to.\n\n    Instead, we inline (and specialise) the definitions we care about.\n**)\n\n(* Given sets of public keys, secret keys, plaintexts, DEM keys, KEM\n   ciphertexts and DEM ciphertexts ... *)\ntype pkey, ____(TYPE_0)____, pt, key, kct, dct.\n\n(* ... and the uniform distribution over the DEM key space *)\nop [lossless full uniform] dkey : key ____(OP_0)____.\n\n\n(** A KEM is a triple of (potentially probabilistic and stateful)\n    algorithms:\n**)\nmodule type KEM = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey): key * kct\n  proc dec(sk : skey, k : kct): key option\n}.\n\n(** A CPA adversary against the KEM is an algorithm: **)\nmodule type KEM_CPA_Adv = {\n  proc distinguish(pk : pkey, k : key, c : kct): bool\n}.\n\n(** And we define the advantage of a CPA adversary A against a KEM E\n    as\n      `|   Pr[KEM_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[KEM_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where KEM_CPA_Exp is the experiment:\n**)\nmodule KEM_CPA_Exp (E : KEM) (A : KEM_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, k0, k1, k, c, r;\n\n    (pk, sk) <@ E.keygen();\n    (k0, c) <@ E.enc(pk);\n    k1 <$ dkey;\n    k <- if b then k1 else k0;\n    r <@ A.distinguish(pk, k, c);\n    return r;\n  }\n}.\n\n(** A DEM is a pair of algorithms: **)\nmodule type DEM = {\n  (* We force key generation to be sampling in `dkey` *)\n  proc enc(k : key, m : pt): dct\n  proc dec(k : key, c : dct): pt\n}.\n\n(** A passive/eavesdropping DEM adversary is a pair of algorithms: **)\nmodule type DEM_PAS_Adv = {\n  proc choose(): pt * pt\n  proc distinguish(c : dct): bool\n}.\n\n(** And we define the advantage of a passive adversary A against a DEM\n    as\n      `|   Pr[DEM_PAS_Exp(E, A).run(false) @ &m: res]\n         - Pr[DEM_PAS_Exp(E, A).run(true) @ &m: res]  |\n    where DEM_PAS_Exp is the experiment:\n**)\nmodule DEM_PAS_Exp (E : DEM) (A : DEM_PAS_Adv) = {\n  proc run(b : bool) = {\n    var k, m0, m1, c, r;\n\n    k <$ dkey;\n    (m0, m1) <@ A.choose();\n    c <@ E.enc(k, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(** We have defined our assumptions, we can now define our\n    constructive goal.\n\n    A public key encryption scheme (with structured ciphertexts!) is a\n    triple of algorithms:\n**)\nmodule type PKE = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey, m : pt): kct * dct\n  proc dec(sk : skey, c : kct * dct): pt option\n}.\n\n(** A CPA adversary against a PKE is a pair of algorithms: **)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey): pt * pt\n  proc distinguish(c : kct * dct): bool\n}.\n\n(** The advantage of a CPA adversary A against a PKE E is\n      `|   Pr[PKE_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[PKE_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where PKE_CPA_Exp is the experiment:\n**)\nmodule PKE_CPA_Exp (E : PKE) (A : PKE_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, c, r, m0, m1;\n\n    (pk, sk) <@ E.keygen();\n    (m0, m1) <@ A.choose(pk);\n    c <@ E.enc(pk, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(* (* Note: instead of defining a specialised notion of PKE with\n      structured ciphertexts, we could have obtained very similar\n      definitions by _instantiating_ a library definition.\n\n      However, note that the humongous variety of ways in which CPA\n      security for PKEs can be expressed makes developing such a\n      library a tricky proposition.\n   *)\nrequire PKE.\nclone PKE as KEM_Based_PKE with\n  type pkey <= pkey,\n  type skey <= skey,\n  type plaintext <= pt,\n  type ciphertext <= kct * dct.\n\nprint KEM_Based_PKE.Scheme.\n*)\n\n(** Finally, we can define our KEM/DEM composition **)\nmodule KEMDEM (E_kem : KEM) (E_s : DEM): PKE = {\n  proc keygen = E_kem.keygen\n\n  proc enc(pk : pkey, m : pt): kct * dct = {\n    var k, kc, c;\n\n    (k, kc) <@ E_kem.enc(pk);\n    c <@ E_s.enc(k, m);\n    return (kc, c);\n  }\n\n  proc dec(sk : skey, c : kct * dct): pt option = {\n    var kc, dc, r, k, m;\n\n    (kc, dc) <- c;\n    r <- None;\n    k <@ E_kem.dec(sk, kc);\n    if (k <> None) {\n      m <@ E_s.dec(oget k, dc);\n      r <- Some m;\n    }\n    return r;\n  }\n}.\n\n\n(*** And we prove its security: there exist reductions B_kem_0(E_s),\n       B_kem_1(E_s) and B_s(E_kem) such that ...\n***)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: ____(DECLARE_0)____ { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    (k0, kc) <@ E_kem.enc(pk);\n    k1 <$ dkey;\n    c <@ E_s.enc(k1, if b then m1 else m0);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} ^r<@.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} ^c<@.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} ^pk0<- -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd {2}.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} ^r<@.\nswap {1} ^pk0<- -3. swap {1} ^c0<- & +1 @^pk0<- & +1.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ c{1} = kc{2})=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} ^r<@.\n  swap {2} ^c0<- & +1 -2. swap {2} ^k<$ 2.\n  inline {2} 1.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} ^k<$ 1.\ninline {2} ^r<@.\nswap {2} ^c0<- & +1 -3.\ninline {2} 1.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} ^pk0<- -1. swap {1} 5 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd {2}; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} ^pk0<- -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem.",
        "complete:": "(* As specified in Boneh and Shoup's \"Graduate Course in Applied Cryptography\"\n     https://toc.cryptobook.us/\n   (Exercise 11.9 of version 0.6.)\n*)\nrequire import AllCore Distr.\n\n(** A more mature proof would rely on libraries of definitions-generic\n    definitions have a lot more parameters than what we'd like to\n    expose a tutorial reader to.\n\n    Instead, we inline (and specialise) the definitions we care about.\n**)\n\n(* Given sets of public keys, secret keys, plaintexts, DEM keys, KEM\n   ciphertexts and DEM ciphertexts ... *)\ntype pkey, skey, pt, key, kct, dct.\n\n(* ... and the uniform distribution over the DEM key space *)\nop [lossless full uniform] dkey : key distr.\n\n\n(** A KEM is a triple of (potentially probabilistic and stateful)\n    algorithms:\n**)\nmodule type KEM = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey): key * kct\n  proc dec(sk : skey, k : kct): key option\n}.\n\n(** A CPA adversary against the KEM is an algorithm: **)\nmodule type KEM_CPA_Adv = {\n  proc distinguish(pk : pkey, k : key, c : kct): bool\n}.\n\n(** And we define the advantage of a CPA adversary A against a KEM E\n    as\n      `|   Pr[KEM_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[KEM_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where KEM_CPA_Exp is the experiment:\n**)\nmodule KEM_CPA_Exp (E : KEM) (A : KEM_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, k0, k1, k, c, r;\n\n    (pk, sk) <@ E.keygen();\n    (k0, c) <@ E.enc(pk);\n    k1 <$ dkey;\n    k <- if b then k1 else k0;\n    r <@ A.distinguish(pk, k, c);\n    return r;\n  }\n}.\n\n(** A DEM is a pair of algorithms: **)\nmodule type DEM = {\n  (* We force key generation to be sampling in `dkey` *)\n  proc enc(k : key, m : pt): dct\n  proc dec(k : key, c : dct): pt\n}.\n\n(** A passive/eavesdropping DEM adversary is a pair of algorithms: **)\nmodule type DEM_PAS_Adv = {\n  proc choose(): pt * pt\n  proc distinguish(c : dct): bool\n}.\n\n(** And we define the advantage of a passive adversary A against a DEM\n    as\n      `|   Pr[DEM_PAS_Exp(E, A).run(false) @ &m: res]\n         - Pr[DEM_PAS_Exp(E, A).run(true) @ &m: res]  |\n    where DEM_PAS_Exp is the experiment:\n**)\nmodule DEM_PAS_Exp (E : DEM) (A : DEM_PAS_Adv) = {\n  proc run(b : bool) = {\n    var k, m0, m1, c, r;\n\n    k <$ dkey;\n    (m0, m1) <@ A.choose();\n    c <@ E.enc(k, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(** We have defined our assumptions, we can now define our\n    constructive goal.\n\n    A public key encryption scheme (with structured ciphertexts!) is a\n    triple of algorithms:\n**)\nmodule type PKE = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey, m : pt): kct * dct\n  proc dec(sk : skey, c : kct * dct): pt option\n}.\n\n(** A CPA adversary against a PKE is a pair of algorithms: **)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey): pt * pt\n  proc distinguish(c : kct * dct): bool\n}.\n\n(** The advantage of a CPA adversary A against a PKE E is\n      `|   Pr[PKE_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[PKE_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where PKE_CPA_Exp is the experiment:\n**)\nmodule PKE_CPA_Exp (E : PKE) (A : PKE_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, c, r, m0, m1;\n\n    (pk, sk) <@ E.keygen();\n    (m0, m1) <@ A.choose(pk);\n    c <@ E.enc(pk, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(* (* Note: instead of defining a specialised notion of PKE with\n      structured ciphertexts, we could have obtained very similar\n      definitions by _instantiating_ a library definition.\n\n      However, note that the humongous variety of ways in which CPA\n      security for PKEs can be expressed makes developing such a\n      library a tricky proposition.\n   *)\nrequire PKE.\nclone PKE as KEM_Based_PKE with\n  type pkey <= pkey,\n  type skey <= skey,\n  type plaintext <= pt,\n  type ciphertext <= kct * dct.\n\nprint KEM_Based_PKE.Scheme.\n*)\n\n(** Finally, we can define our KEM/DEM composition **)\nmodule KEMDEM (E_kem : KEM) (E_s : DEM): PKE = {\n  proc keygen = E_kem.keygen\n\n  proc enc(pk : pkey, m : pt): kct * dct = {\n    var k, kc, c;\n\n    (k, kc) <@ E_kem.enc(pk);\n    c <@ E_s.enc(k, m);\n    return (kc, c);\n  }\n\n  proc dec(sk : skey, c : kct * dct): pt option = {\n    var kc, dc, r, k, m;\n\n    (kc, dc) <- c;\n    r <- None;\n    k <@ E_kem.dec(sk, kc);\n    if (k <> None) {\n      m <@ E_s.dec(oget k, dc);\n      r <- Some m;\n    }\n    return r;\n  }\n}.\n\n\n(*** And we prove its security: there exist reductions B_kem_0(E_s),\n       B_kem_1(E_s) and B_s(E_kem) such that ...\n***)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: KEM { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    (k0, kc) <@ E_kem.enc(pk);\n    k1 <$ dkey;\n    c <@ E_s.enc(k1, if b then m1 else m0);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} ^r<@.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} ^c<@.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} ^pk0<- -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd {2}.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} ^r<@.\nswap {1} ^pk0<- -3. swap {1} ^c0<- & +1 @^pk0<- & +1.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ c{1} = kc{2})=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} ^r<@.\n  swap {2} ^c0<- & +1 -2. swap {2} ^k<$ 2.\n  inline {2} 1.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} ^k<$ 1.\ninline {2} ^r<@.\nswap {2} ^c0<- & +1 -3.\ninline {2} 1.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} ^pk0<- -1. swap {1} 5 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd {2}; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} ^pk0<- -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem."
    },
    {
        "file": "EC-1/KEM_ROM.ec",
        "incomplete": "require import AllCore List Distr DBool PROM.\nrequire (****) LorR.\n\nabstract theory KEM.\n\ntype ____(TYPE_2)____.\ntype ____(TYPE_0)____.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]____(OP_0)____ : key ____(OP_1)____.\n\nmodule type Scheme = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    (pk, sk) <@ S.kg();\n    (c,k)    <@ S.enc(pk);\n    k'       <@ S.dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type Adversary = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CPA (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    (pk, sk) <@ S.kg();\n    b        <$ {0,1};\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nmodule CPA_L (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, ck0.`2);\n    return b';\n  }\n}.\n\nmodule CPA_R (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, k1);\n    return b';\n  }\n}.\n\nsection.\n\n  clone import LorR as LR with\n     type input <- ____(TYPE_1)____.\n\n  declare module S<:Scheme.\n  declare module A<:Adversary{-S}.\n\n  lemma pr_CPA_LR &m:\n    islossless S.kg => islossless S.enc =>\n    islossless A.guess =>\n    `| Pr[CPA_L(S,A).main () @ &m : res] - Pr[CPA_R(S,A).main () @ &m : res] | =\n     2%r * `| Pr[CPA(S,A).main() @ &m : res] - 1%r/2%r |.\n  proof.\n    move => kg_ll enc_ll guess_ll.\n    have -> : Pr[CPA(S, A).main() @ &m : res] =\n              Pr[RandomLR(CPA_R(S,A), CPA_L(S,A)).main() @ &m : res].\n    + byequiv (_ : ={glob S, glob A} ==> ={res})=> //.\n      proc.\n      swap{1} 2-1; seq 1 1 : (={glob S, glob A, b}); first by rnd.\n      if{2}; inline *; wp; do 2! call (_: true); rnd; call(_:true); auto => /> /#.\n    rewrite -(pr_AdvLR_AdvRndLR (CPA_R(S,A)) (CPA_L(S,A)) &m) 2:/#.\n    byphoare => //; proc.\n    by call guess_ll; call enc_ll; rnd; call kg_ll; auto => />; smt(dkey_ll).\n  qed.\n\nend section.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA (S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S.dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    cstar    <- None;\n    (pk, sk) <@ S.kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S.enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM.\n\n(* Security definition in the ROM *)\nabstract theory KEM_ROM.\n\ntype pkey.\ntype skey.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]dkey : key distr.\n\nclone import FullRO as RO.\n\nmodule type Oracle = {\n  include FRO [init, get]\n}.\n\nmodule type POracle = {\n  include FRO [get]\n}.\n\n\nmodule type Scheme(O : POracle) = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(H : Oracle, S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    H.init();\n    (pk, sk) <@ S(H).kg();\n    (c,k)    <@ S(H).enc(pk);\n    k'       <@ S(H).dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (H : POracle, O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA(H : Oracle, S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S(H).dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(H,O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    H.init();\n    cstar    <- None;\n    (pk, sk) <@ S(H).kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S(H).enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM_ROM.\n\n(* The theory where we prove FO_UU and show that the\n   two RO model is actually a restatement of the single\n   RO model. The last part is a to do. *)\ntheory KEM_ROM_x2.\n\ntype pkey.\ntype skey.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]dkey : key distr.\n\nclone import FullRO as RO1.\nclone import FullRO as RO2.\n\nmodule type Oracle_x2 = {\n  proc init() : unit\n  proc get1(_: RO1.in_t) : RO1.out_t\n  proc get2(_: RO2.in_t) : RO2.out_t\n}.\n\nmodule type POracle_x2 = {\n  include Oracle_x2 [get1,get2]\n}.\n\nmodule RO_x2(____(MODULE_0)____ : RO1.RO, H2 : RO2.RO): Oracle_x2 = {\n  proc init() : unit = {\n     H1.init();\n     H2.init();\n  }\n  proc get1 = H1.get\n  proc get2 = H2.get\n}.\n\nmodule type Scheme(O : POracle_x2) = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(H : Oracle_x2, S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    H.init();\n    (pk, sk) <@ S(H).kg();\n    (c,k)    <@ S(H).enc(pk);\n    k'       <@ S(H).dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (H : POracle_x2, O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA(H : Oracle_x2, S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S(H).dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(H,O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    H.init();\n    cstar    <- None;\n    (pk, sk) <@ S(H).kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S(H).enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM_ROM_x2.",
        "complete:": "require import AllCore List Distr DBool PROM.\nrequire (****) LorR.\n\nabstract theory KEM.\n\ntype pkey.\ntype skey.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]dkey : key distr.\n\nmodule type Scheme = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    (pk, sk) <@ S.kg();\n    (c,k)    <@ S.enc(pk);\n    k'       <@ S.dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type Adversary = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CPA (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    (pk, sk) <@ S.kg();\n    b        <$ {0,1};\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nmodule CPA_L (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, ck0.`2);\n    return b';\n  }\n}.\n\nmodule CPA_R (S:Scheme, A:Adversary) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var k1 : key;\n    var ck0 : ciphertext * key;\n    var b' : bool;\n\n    (pk, sk) <@ S.kg();\n    k1        <$ dkey;\n    ck0      <@ S.enc(pk);\n    b'       <@ A.guess(pk, ck0.`1, k1);\n    return b';\n  }\n}.\n\nsection.\n\n  clone import LorR as LR with\n     type input <- unit.\n\n  declare module S<:Scheme.\n  declare module A<:Adversary{-S}.\n\n  lemma pr_CPA_LR &m:\n    islossless S.kg => islossless S.enc =>\n    islossless A.guess =>\n    `| Pr[CPA_L(S,A).main () @ &m : res] - Pr[CPA_R(S,A).main () @ &m : res] | =\n     2%r * `| Pr[CPA(S,A).main() @ &m : res] - 1%r/2%r |.\n  proof.\n    move => kg_ll enc_ll guess_ll.\n    have -> : Pr[CPA(S, A).main() @ &m : res] =\n              Pr[RandomLR(CPA_R(S,A), CPA_L(S,A)).main() @ &m : res].\n    + byequiv (_ : ={glob S, glob A} ==> ={res})=> //.\n      proc.\n      swap{1} 2-1; seq 1 1 : (={glob S, glob A, b}); first by rnd.\n      if{2}; inline *; wp; do 2! call (_: true); rnd; call(_:true); auto => /> /#.\n    rewrite -(pr_AdvLR_AdvRndLR (CPA_R(S,A)) (CPA_L(S,A)) &m) 2:/#.\n    byphoare => //; proc.\n    by call guess_ll; call enc_ll; rnd; call kg_ll; auto => />; smt(dkey_ll).\n  qed.\n\nend section.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA (S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S.dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    cstar    <- None;\n    (pk, sk) <@ S.kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S.enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM.\n\n(* Security definition in the ROM *)\nabstract theory KEM_ROM.\n\ntype pkey.\ntype skey.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]dkey : key distr.\n\nclone import FullRO as RO.\n\nmodule type Oracle = {\n  include FRO [init, get]\n}.\n\nmodule type POracle = {\n  include FRO [get]\n}.\n\n\nmodule type Scheme(O : POracle) = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(H : Oracle, S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    H.init();\n    (pk, sk) <@ S(H).kg();\n    (c,k)    <@ S(H).enc(pk);\n    k'       <@ S(H).dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (H : POracle, O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA(H : Oracle, S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S(H).dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(H,O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    H.init();\n    cstar    <- None;\n    (pk, sk) <@ S(H).kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S(H).enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM_ROM.\n\n(* The theory where we prove FO_UU and show that the\n   two RO model is actually a restatement of the single\n   RO model. The last part is a to do. *)\ntheory KEM_ROM_x2.\n\ntype pkey.\ntype skey.\ntype key.\ntype ciphertext.\n\nop [lossless uniform full]dkey : key distr.\n\nclone import FullRO as RO1.\nclone import FullRO as RO2.\n\nmodule type Oracle_x2 = {\n  proc init() : unit\n  proc get1(_: RO1.in_t) : RO1.out_t\n  proc get2(_: RO2.in_t) : RO2.out_t\n}.\n\nmodule type POracle_x2 = {\n  include Oracle_x2 [get1,get2]\n}.\n\nmodule RO_x2(H1 : RO1.RO, H2 : RO2.RO): Oracle_x2 = {\n  proc init() : unit = {\n     H1.init();\n     H2.init();\n  }\n  proc get1 = H1.get\n  proc get2 = H2.get\n}.\n\nmodule type Scheme(O : POracle_x2) = {\n  proc kg() : pkey * skey\n  proc enc(pk:pkey)  : ciphertext * key\n  proc dec(sk:skey, c:ciphertext) : key option\n}.\n\nmodule Correctness(H : Oracle_x2, S:Scheme) = {\n  proc main() : bool = {\n    var pk : pkey;\n    var sk : skey;\n    var c  : ciphertext;\n    var k  : key;\n    var k' : key option;\n\n    H.init();\n    (pk, sk) <@ S(H).kg();\n    (c,k)    <@ S(H).enc(pk);\n    k'       <@ S(H).dec(sk,c);\n    return (k' <> Some k);\n\n  }\n}.\n\nmodule type CCA_ORC = {\n  proc dec(c:ciphertext) : key option\n}.\n\nmodule type CCA_ADV (H : POracle_x2, O:CCA_ORC) = {\n  proc guess(pk : pkey, c:ciphertext, k : key) : bool\n}.\n\nmodule CCA(H : Oracle_x2, S:Scheme, A:CCA_ADV) = {\n  var cstar : ciphertext option\n  var sk : skey\n\n  module O = {\n    proc dec(c:ciphertext) : key option = {\n      var k : key option;\n\n      k <- None;\n      if (Some c <> cstar) {\n        k  <@ S(H).dec(sk, c);\n      }\n      return k;\n    }\n  }\n\n  module A = A(H,O)\n\n  proc main() : bool = {\n    var pk : pkey;\n    var k1 :key;\n    var ck0 : ciphertext * key;\n    var b, b' : bool;\n\n    H.init();\n    cstar    <- None;\n    (pk, sk) <@ S(H).kg();\n    k1 <$ dkey;\n    b        <$ {0,1};\n    ck0        <@ S(H).enc(pk);\n    cstar    <- Some ck0.`1;\n    b'       <@ A.guess(pk, ck0.`1, if b then k1 else ck0.`2);\n    return (b' = b);\n  }\n}.\n\nend KEM_ROM_x2."
    },
    {
        "file": "EC-1/MPAPISemantics.ec",
        "incomplete": "(** Multiparty semantics for a language parameterised by an API *)\nrequire import AllCore List SmtMap.\n\nrequire import AAPI ALanguage AMPSemantics SPAPISemantics.\n\n(**\n  We define a particular multiparty semantics that works for languages\n  where the computation of secret operations is carried out\n  by an external API, whlist public operations remain in the\n  domain of the language itself.\n\n  This semantics is essentially a realisation of the multiparty\n  semantics, that extends it with new datatypes and operations to interpolate \n  between the evaluation of the program and the API calls that are requested.\n\n  The interaction with the API is done via the [apiCallRes] buffer, with\n  each party having their own API interaction buffers. These buffers are\n  written everytime local computation reaches a secret operation. When\n  all parties fill their buffers, the API can proceed with the secret operation\n  computation, writing the individual outputs in the respective party\n  buffer. Observe that, in order for such interpolation to be realisable,\n  every local semantics must be given access to the same API module and their\n  local API interaction buffers must be of the same type.\n\n  Semantics configuration comprises the local configuration of each party\n  semantics, together with an input and output buffers, that override the\n  respective input and output buffers of local semantics. An update to a\n  configuration can be derived from either local party execution, synchronised\n  computation, or input and output commands.\n*)\ntheory MultiPartyAPISemantics.\n\n  (** Language L1 *)\n  clone import Language as L1.\n\n  (** Language L2 *)\n  clone import Language as L2.\n\n  (** Language L3 *)\n  clone import Language as L3.\n\n  (** API *)\n  clone import API.\n\n  (** Semantics of programs written in L1 *)\n  clone import SinglePartyAPISemantics as SemP1 with\n    theory Language <- L1,\n    type ____(TYPE_0)____.public_t = public_t,\n    type ____(TYPE_1)____.inputs_t = inputs_t,\n    type ____(TYPE_2)____.outputs_t = outputs_t,\n    type ____(TYPE_3)____.svar_t = svar_t,\n    type ____(TYPE_4)____.sop_t = sop_t,\n    type ____(TYPE_5)____.sideInfo_t = sideInfo_t,\n    type ____(TYPE_6)____.apiCall_data = apiCall_data,\n    type ____(TYPE_7)____.apiRes_data = apiRes_data,\n    type ____(TYPE_8)____.apiCallRes = apiCallRes,\n    op ____(OP_0)____.apiCall = apiCall,\n    op ____(OP_1)____.apiRes = apiRes.\n\n  (** Semantics of programs written in L2 *)\n  clone import SinglePartyAPISemantics as SemP2 with\n    theory Language <- L2,\n    type API.public_t = public_t,\n    type API.inputs_t = inputs_t,\n    type API.outputs_t = outputs_t,\n    type API.svar_t = svar_t,\n    type API.sop_t = sop_t,\n    type API.sideInfo_t = sideInfo_t,\n    type API.apiCall_data = apiCall_data,\n    type API.apiRes_data = apiRes_data,\n    type API.apiCallRes = apiCallRes,\n    op API.apiCall = apiCall,\n    op API.apiRes = apiRes.\n\n  (** Semantics of programs written in L3 *)\n  clone import SinglePartyAPISemantics as SemP3 with\n    theory Language <- L3,\n    type API.public_t = public_t,\n    type API.inputs_t = inputs_t,\n    type API.outputs_t = outputs_t,\n    type API.svar_t = svar_t,\n    type API.sop_t = sop_t,\n    type API.sideInfo_t = sideInfo_t,\n    type API.apiCall_data = apiCall_data,\n    type API.apiRes_data = apiRes_data,\n    type API.apiCallRes = apiCallRes,\n    op API.apiCall = apiCall,\n    op API.apiRes = apiRes.\n\n  (** Party identifier *)\n  type partyId_t.\n\n  (** Global configuration *)\n  type GlobalSt = { StP1 : SemP1.StateL\n                    ; StP2 : SemP2.StateL\n                    ; StP3 : SemP3.StateL\n                    ; ib : inputs_t option\n                    ; ob : outputs_t option\n                  }.\n\n  (** Updates a local state after a [stepP] *)\n  op upd_Sigma1 (newst1 : (L1.L, SemP1.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP1 = SemP1.st_from_step newst1 |}.\n  op upd_Sigma2 (newst2 : (L2.L, SemP2.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP2 = SemP2.st_from_step newst2 |}.\n  op upd_Sigma3 (newst3 : (L3.L, SemP3.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP3 = SemP3.st_from_step newst3 |}.    \n\n  (** Updates all local states after a [stepS] *)\n  op upd_SigmaAPI (r: apiRes_data option) (st: GlobalSt): GlobalSt =\n    {| st with StP1 = SemP1.updRes r st.`StP1 ; StP2 = SemP2.updRes r st.`StP2 ; StP3 = SemP3.updRes r st.`StP3 |}.\n\n  (** Updates the input buffer *)\n  op upd_ib (newib: inputs_t option) (st: GlobalSt): GlobalSt =\n    {| st with ib = newib |}.\n\n  (** Updates the output buffer *)\n  op upd_ob (newob: outputs_t option) (st: GlobalSt): GlobalSt =\n    {| st with ob = newob |}.\n\n  (** Collects all API calls from the local states *)\n  op allECalls (st: GlobalSt) : apiCall_data option * apiCall_data option * apiCall_data option =\n    (SemP1.callSt st.`StP1, SemP2.callSt st.`StP2, SemP3.callSt st.`StP3).\n\n  (** Initialises all local party states *)\n  op ____(OP_2)____ (Prog1: L1.L) (Prog2: L2.L) (Prog3: L3.L) : GlobalSt =\n    {| StP1 = SemP1.initSt (SemP1.initStateL Prog1)\n       ; StP2 = SemP2.initSt (SemP2.initStateL Prog2)\n       ; StP3 = SemP3.initSt (SemP3.initStateL Prog3)\n       ; ib = None\n       ; ob = None\n    |}.\n  \n  (** Semantics realisation *)\n  clone import MultiPartySemantics with\n    theory L1 <- L1,\n    theory L2 <- L2,\n    theory L3 <- L3,\n    type sideInfo_t = sideInfo_t,\n    type partyId_t = partyId_t.\n \nend MultiPartyAPISemantics.",
        "complete:": "(** Multiparty semantics for a language parameterised by an API *)\nrequire import AllCore List SmtMap.\n\nrequire import AAPI ALanguage AMPSemantics SPAPISemantics.\n\n(**\n  We define a particular multiparty semantics that works for languages\n  where the computation of secret operations is carried out\n  by an external API, whlist public operations remain in the\n  domain of the language itself.\n\n  This semantics is essentially a realisation of the multiparty\n  semantics, that extends it with new datatypes and operations to interpolate \n  between the evaluation of the program and the API calls that are requested.\n\n  The interaction with the API is done via the [apiCallRes] buffer, with\n  each party having their own API interaction buffers. These buffers are\n  written everytime local computation reaches a secret operation. When\n  all parties fill their buffers, the API can proceed with the secret operation\n  computation, writing the individual outputs in the respective party\n  buffer. Observe that, in order for such interpolation to be realisable,\n  every local semantics must be given access to the same API module and their\n  local API interaction buffers must be of the same type.\n\n  Semantics configuration comprises the local configuration of each party\n  semantics, together with an input and output buffers, that override the\n  respective input and output buffers of local semantics. An update to a\n  configuration can be derived from either local party execution, synchronised\n  computation, or input and output commands.\n*)\ntheory MultiPartyAPISemantics.\n\n  (** Language L1 *)\n  clone import Language as L1.\n\n  (** Language L2 *)\n  clone import Language as L2.\n\n  (** Language L3 *)\n  clone import Language as L3.\n\n  (** API *)\n  clone import API.\n\n  (** Semantics of programs written in L1 *)\n  clone import SinglePartyAPISemantics as SemP1 with\n    theory Language <- L1,\n    type API.public_t = public_t,\n    type API.inputs_t = inputs_t,\n    type API.outputs_t = outputs_t,\n    type API.svar_t = svar_t,\n    type API.sop_t = sop_t,\n    type API.sideInfo_t = sideInfo_t,\n    type API.apiCall_data = apiCall_data,\n    type API.apiRes_data = apiRes_data,\n    type API.apiCallRes = apiCallRes,\n    op API.apiCall = apiCall,\n    op API.apiRes = apiRes.\n\n  (** Semantics of programs written in L2 *)\n  clone import SinglePartyAPISemantics as SemP2 with\n    theory Language <- L2,\n    type API.public_t = public_t,\n    type API.inputs_t = inputs_t,\n    type API.outputs_t = outputs_t,\n    type API.svar_t = svar_t,\n    type API.sop_t = sop_t,\n    type API.sideInfo_t = sideInfo_t,\n    type API.apiCall_data = apiCall_data,\n    type API.apiRes_data = apiRes_data,\n    type API.apiCallRes = apiCallRes,\n    op API.apiCall = apiCall,\n    op API.apiRes = apiRes.\n\n  (** Semantics of programs written in L3 *)\n  clone import SinglePartyAPISemantics as SemP3 with\n    theory Language <- L3,\n    type API.public_t = public_t,\n    type API.inputs_t = inputs_t,\n    type API.outputs_t = outputs_t,\n    type API.svar_t = svar_t,\n    type API.sop_t = sop_t,\n    type API.sideInfo_t = sideInfo_t,\n    type API.apiCall_data = apiCall_data,\n    type API.apiRes_data = apiRes_data,\n    type API.apiCallRes = apiCallRes,\n    op API.apiCall = apiCall,\n    op API.apiRes = apiRes.\n\n  (** Party identifier *)\n  type partyId_t.\n\n  (** Global configuration *)\n  type GlobalSt = { StP1 : SemP1.StateL\n                    ; StP2 : SemP2.StateL\n                    ; StP3 : SemP3.StateL\n                    ; ib : inputs_t option\n                    ; ob : outputs_t option\n                  }.\n\n  (** Updates a local state after a [stepP] *)\n  op upd_Sigma1 (newst1 : (L1.L, SemP1.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP1 = SemP1.st_from_step newst1 |}.\n  op upd_Sigma2 (newst2 : (L2.L, SemP2.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP2 = SemP2.st_from_step newst2 |}.\n  op upd_Sigma3 (newst3 : (L3.L, SemP3.EnvL) ECall) (st: GlobalSt): GlobalSt =\n    {| st with StP3 = SemP3.st_from_step newst3 |}.    \n\n  (** Updates all local states after a [stepS] *)\n  op upd_SigmaAPI (r: apiRes_data option) (st: GlobalSt): GlobalSt =\n    {| st with StP1 = SemP1.updRes r st.`StP1 ; StP2 = SemP2.updRes r st.`StP2 ; StP3 = SemP3.updRes r st.`StP3 |}.\n\n  (** Updates the input buffer *)\n  op upd_ib (newib: inputs_t option) (st: GlobalSt): GlobalSt =\n    {| st with ib = newib |}.\n\n  (** Updates the output buffer *)\n  op upd_ob (newob: outputs_t option) (st: GlobalSt): GlobalSt =\n    {| st with ob = newob |}.\n\n  (** Collects all API calls from the local states *)\n  op allECalls (st: GlobalSt) : apiCall_data option * apiCall_data option * apiCall_data option =\n    (SemP1.callSt st.`StP1, SemP2.callSt st.`StP2, SemP3.callSt st.`StP3).\n\n  (** Initialises all local party states *)\n  op init_GlobalSt (Prog1: L1.L) (Prog2: L2.L) (Prog3: L3.L) : GlobalSt =\n    {| StP1 = SemP1.initSt (SemP1.initStateL Prog1)\n       ; StP2 = SemP2.initSt (SemP2.initStateL Prog2)\n       ; StP3 = SemP3.initSt (SemP3.initStateL Prog3)\n       ; ib = None\n       ; ob = None\n    |}.\n  \n  (** Semantics realisation *)\n  clone import MultiPartySemantics with\n    theory L1 <- L1,\n    theory L2 <- L2,\n    theory L3 <- L3,\n    type sideInfo_t = sideInfo_t,\n    type partyId_t = partyId_t.\n \nend MultiPartyAPISemantics."
    },
    {
        "file": "EC-1/MPCProtocolLibrary.ec",
        "incomplete": "(** Concrete protocol library working for share-based protocols *)\nrequire import AllCore List Distr.\n\nrequire import ASecretSharingScheme AProtocolLibrary.\n\n(**\n  The MPC protocol library provides a library of MPC protocols that work over\n  shares generated by a secret sharing scheme.\n\n  The protocol library here specified provides: a declassify protocol, an I/O\n  interface and a protocol that securely computes a class of secret operators.\n  Our goal is to identify the minimum security and correctness properties that\n  these protocols need to enjoy in order to be employed in our secure computation\n  framework. Therefore, we do not provide any concrete realisations of the\n  protocols and instead make concrete assumptions on their security and correctness.\n  This modular approach greatly reduces the complexity of future instantiations\n  of our stack: because our proof evolves around the assumptions made,\n  future instatiation will only need to assert that concrete protocols match\n  the properties assumed, without the need to concern about how the protocols\n  are inserted in the framework.\n\n  Security is established by the equivalence between an honest protocol execution\n  and a simulated one. The simulation of the protocol execution is done with\n  recourse to some side information, representing visible data that is generated\n  by the protocol. Then, together with the internal information (shares) of\n  the corrupt parties, the simulation algorithm must be able to reproduce the\n  communication trace of the corrupt parties.\n\n  Finally, we define the correctness of the protocols by comparing their output\n  against the expected functionality of the protocol. For protocols over secret\n  operators, we provide an underspecified operator [sop_spec] that specifies the\n  functional behaviour of such operators. For the remaining protocols of our suite,\n  we provide concrete functionalities that those protocols must follow.\n*)\ntheory MPCProtocolLibrary.\n\n  (** Secret sharing scheme *)\n  clone import SecretSharingScheme.\n\n  (** Number of parties involved in the protocol *)\n  op ____(OP_0)____ = n.\n\n  (** Type of party identifiers *)\n  type ____(TYPE_1)____ = partyId_t. \n\n  (** Raw values *)\n  type value_t = value_t.\n  (** Secret inputs *)\n  type inputs_t = sharedValue_t.\n  (** Secret outputs *)\n  type outputs_t = sharedValue_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t = [\n    | LeakedValue of value_t\n    | LeakedShares of inputs_t\n  ].\n\n  (** Leakage 'get' methods *)\n  op leakage_value (x: leakage_t) : value_t option =\n    with x = LeakedValue v => Some v\n    with x = LeakedShares _ => None.\n  op leakage_shares (x: leakage_t) : inputs_t option =\n    with x = LeakedValue v => None\n    with x = LeakedShares s => Some s.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type ____(TYPE_0)____ = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Side information constructors *)\n  op Leak (v: value_t) : sideInfo_t =\n    {| leakage = Some (LeakedValue v); trace = [] |}.\n  op CorruptedShares (s: inputs_t) : sideInfo_t =\n    {| leakage = Some (LeakedShares s); trace = [] |}.\n  op Trace (l: leakage_t option) t = {| leakage=l; trace=t |}.\n\n  (** Gets the leakage from the side information *)\n  op sideInfo_leak (x: sideInfo_t) : value_t option = obind leakage_value x.`leakage.\n  (** Gets the corrupted shares from the side information *)\n  op sideInfo_io (x: sideInfo_t) : inputs_t option = obind leakage_shares x.`leakage.\n  (** Gets the communication trace from the side information *)\n  op sideInfo_trace (x: sideInfo_t) : trace_t = x.`trace.\n\n  (** Extracts the leaked value on a declassify sideInfo *)\n  op leakedValue (l: sideInfo_t): value_t = oget (sideInfo_leak l).\n  (** Extracts the input corrupted shares from a input sideInfo *)\n  op corruptedShares (l: sideInfo_t): inputs_t = oget (sideInfo_io l).\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: value_t list, sargs: value_t list) : value_t * leakage_t option.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  axiom prot_declass_suppE (a: inputs_t) vto :\n    vto \\in prot_declass a => leakage_value (oget vto.`2.`leakage) = Some vto.`1.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t * sideInfo_t) distr.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(____(OP_1)____: inputs_t, ____(OP_2)____: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(____(OP_3)____: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(____(OP_5)____: inputs_t, y: leakage_t): trace_t ____(OP_4)____.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\n  clone import ProtocolLibrary with\n    op n = n,\n    type partyId_t = partyId_t,\n    type value_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type msg_data = msg_data,\n    type leakage_t = leakage_t,\n    type sideInfo_t = sideInfo_t,\n    type sop_t = sop_t,\n    op sop_spec = sop_spec,\n    op prot_declass = prot_declass,\n    op prot_in = prot_in,\n    op prot_out = prot_out,\n    op prot_sop = prot_sop,\n    op sim_declass = sim_declass,\n    op sim_in = sim_in,\n    op sim_out = sim_out,\n    op sim_sop = sim_sop\n  proof *.\n  realize prot_declass_ll by smt(prot_declass_ll).\n  realize prot_in_ll by smt(prot_in_ll).\n  realize prot_out_ll by smt(prot_out_ll).\n  realize prot_sop_ll by smt(prot_sop_ll).\n  realize sim_declass_ll by smt(sim_declass_ll).\n  realize sim_in_ll by smt(sim_in_ll).\n  realize sim_out_ll by smt(sim_out_ll).\n  realize sim_sop_ll by smt(sim_sop_ll).\n\n  (* Correctness and Security Assumptions are captured by\n  adequate pRHL assertions                                   *)\n  module APIsec = {\n    proc prot_declass(a: sharedValue_t): value_t * sideInfo_t = {\n      var x;\n      x <$ prot_declass a;\n      return x;\n    }\n    proc sim_declass(a: inputs_t, l: leakage_t): value_t * sideInfo_t = {\n      var t;\n      t <$ sim_declass a l;\n      return (oget (leakage_value l), Trace (Some l) t);\n    }\n    proc prot_in(a: sharedValue_t): sideInfo_t = {\n      var x;\n      x <$ prot_in a;\n      return x;\n    }\n    proc sim_in(l: leakage_t): sideInfo_t = {\n      var x;\n      x <$ sim_in l;\n      return Trace (Some l) x;\n    }\n    proc prot_out(a: sharedValue_t): sharedValue_t * sideInfo_t = {\n      var x;\n      x <$ prot_out a;\n      return x;\n    }\n    proc sim_out(a: sharedValue_t, l: leakage_t): sideInfo_t = {\n      var t;\n      t <$ sim_out a l;\n      return Trace (Some l) t;\n    }\n    proc spec_out(a: sharedValue_t): sharedValue_t * sideInfo_t = {\n      var x, y, l, tr;\n      x <$ nshr n (unshr a);\n      y <- take t x;\n      l <- LeakedShares y;\n      tr <@ sim_out (take t a, l);\n      return (x, tr);\n    }\n    proc prot_sop(o: sop_t, pargs: value_t list, sargs: sharedValue_t list): sharedValue_t * sideInfo_t = {\n      var x;\n      x <$ prot_sop o pargs sargs;\n      return x;\n    }\n    proc sim_sop(o: sop_t, pargs: value_t list, sargs: sharedValue_t list, l: leakage_t option): sharedValue_t * sideInfo_t = {\n      var x,t;\n      (x,t) <$ sim_sop o pargs sargs l;\n      return (x, Trace l t);\n    }\n  }.\n\n  axiom assumption_declass aa ll:\n    equiv [ APIsec.sim_declass ~ APIsec.prot_declass:\n            aa = a{2} /\\ ll = l{1} /\\ take t a{2} = a{1} /\\ l{1} = LeakedValue (unshr a{2})\n            ==> ={res} /\\ res{2}.`1 = unshr aa /\\ res{2}.`2.`leakage = Some ll ].\n\n  axiom assumption_in ll:\n    equiv [ APIsec.sim_in ~ APIsec.prot_in: ll = l{1} /\\ l{1} = LeakedShares (take t a{2})\n                                            ==> ={res} /\\ res{2}.`leakage = Some ll ].\n\n  axiom assumption_sop oo pp aa ll:\n   equiv [ APIsec.sim_sop ~ APIsec.prot_sop: ={o, pargs} /\\ aa = sargs{2} /\\ ll = l{1} /\\\n           l{1} = (sop_spec oo pp (map unshr aa)).`2 /\\ map (take t) sargs{2} = sargs{1}\n           ==> res{1}.`1 = take t res{2}.`1 /\\ res{1}.`2 = res{2}.`2 /\\\n               unshr res{2}.`1 = (sop_spec oo pp (map unshr aa)).`1 /\\\n               res{2}.`2.`leakage = ll ].\n\n(* the security notion for [prot_out] is stronger than for the\n remaining protocolos. The assumption resorts to an auxiliary\n procedure.                                                    *) \n(*axiom assumption_out:\n equiv [ APIsec.spec_out ~ APIsec.prot_out:\n         ={a} ==> ={res} ].*)\n  axiom assumption_out yy :\n    equiv [ APIsec.sim_out ~ APIsec.prot_out : \n           yy \\in nshr n (unshr a{2}) /\\ a{1} = take t a{2} /\\ l{1} = LeakedShares (take t yy) ==>\n           res{2}.`1 = yy /\\ res{1} = res{2}.`2].\n\nend MPCProtocolLibrary.",
        "complete:": "(** Concrete protocol library working for share-based protocols *)\nrequire import AllCore List Distr.\n\nrequire import ASecretSharingScheme AProtocolLibrary.\n\n(**\n  The MPC protocol library provides a library of MPC protocols that work over\n  shares generated by a secret sharing scheme.\n\n  The protocol library here specified provides: a declassify protocol, an I/O\n  interface and a protocol that securely computes a class of secret operators.\n  Our goal is to identify the minimum security and correctness properties that\n  these protocols need to enjoy in order to be employed in our secure computation\n  framework. Therefore, we do not provide any concrete realisations of the\n  protocols and instead make concrete assumptions on their security and correctness.\n  This modular approach greatly reduces the complexity of future instantiations\n  of our stack: because our proof evolves around the assumptions made,\n  future instatiation will only need to assert that concrete protocols match\n  the properties assumed, without the need to concern about how the protocols\n  are inserted in the framework.\n\n  Security is established by the equivalence between an honest protocol execution\n  and a simulated one. The simulation of the protocol execution is done with\n  recourse to some side information, representing visible data that is generated\n  by the protocol. Then, together with the internal information (shares) of\n  the corrupt parties, the simulation algorithm must be able to reproduce the\n  communication trace of the corrupt parties.\n\n  Finally, we define the correctness of the protocols by comparing their output\n  against the expected functionality of the protocol. For protocols over secret\n  operators, we provide an underspecified operator [sop_spec] that specifies the\n  functional behaviour of such operators. For the remaining protocols of our suite,\n  we provide concrete functionalities that those protocols must follow.\n*)\ntheory MPCProtocolLibrary.\n\n  (** Secret sharing scheme *)\n  clone import SecretSharingScheme.\n\n  (** Number of parties involved in the protocol *)\n  op n = n.\n\n  (** Type of party identifiers *)\n  type partyId_t = partyId_t. \n\n  (** Raw values *)\n  type value_t = value_t.\n  (** Secret inputs *)\n  type inputs_t = sharedValue_t.\n  (** Secret outputs *)\n  type outputs_t = sharedValue_t.\n\n  (** Messages *)\n  type msg_data.\n  (** Traces (lists of messages) *)\n  type trace_t = msg_data list.\n\n  (** Leakage used by simulators *)\n  type leakage_t = [\n    | LeakedValue of value_t\n    | LeakedShares of inputs_t\n  ].\n\n  (** Leakage 'get' methods *)\n  op leakage_value (x: leakage_t) : value_t option =\n    with x = LeakedValue v => Some v\n    with x = LeakedShares _ => None.\n  op leakage_shares (x: leakage_t) : inputs_t option =\n    with x = LeakedValue v => None\n    with x = LeakedShares s => Some s.\n\n  (** Side information represents side information that is passed around\n   (e.g. leakage or communication traces) *)\n  type sideInfo_t = { leakage: leakage_t option ; trace: trace_t }.\n\n  (** Side information constructors *)\n  op Leak (v: value_t) : sideInfo_t =\n    {| leakage = Some (LeakedValue v); trace = [] |}.\n  op CorruptedShares (s: inputs_t) : sideInfo_t =\n    {| leakage = Some (LeakedShares s); trace = [] |}.\n  op Trace (l: leakage_t option) t = {| leakage=l; trace=t |}.\n\n  (** Gets the leakage from the side information *)\n  op sideInfo_leak (x: sideInfo_t) : value_t option = obind leakage_value x.`leakage.\n  (** Gets the corrupted shares from the side information *)\n  op sideInfo_io (x: sideInfo_t) : inputs_t option = obind leakage_shares x.`leakage.\n  (** Gets the communication trace from the side information *)\n  op sideInfo_trace (x: sideInfo_t) : trace_t = x.`trace.\n\n  (** Extracts the leaked value on a declassify sideInfo *)\n  op leakedValue (l: sideInfo_t): value_t = oget (sideInfo_leak l).\n  (** Extracts the input corrupted shares from a input sideInfo *)\n  op corruptedShares (l: sideInfo_t): inputs_t = oget (sideInfo_io l).\n\n  (** Secret operators *)\n  type sop_t.\n\n  (** Functionality of secret operators *)\n  op sop_spec (sop: sop_t, pargs: value_t list, sargs: value_t list) : value_t * leakage_t option.\n\n  (** Protocols *)\n\n  (** Declassification protocol *)\n  op [lossless] prot_declass(a: inputs_t): (value_t * sideInfo_t) distr.\n  axiom prot_declass_suppE (a: inputs_t) vto :\n    vto \\in prot_declass a => leakage_value (oget vto.`2.`leakage) = Some vto.`1.\n  (** Input protocol *)\n  op [lossless] prot_in(inp: inputs_t): sideInfo_t distr.\n  (** Output protocol *)\n  op [lossless] prot_out(a: inputs_t): (outputs_t * sideInfo_t) distr.\n  (** Secret operator protocol *)\n  op [lossless] prot_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list)\n        : (outputs_t * sideInfo_t) distr.\n\n  (** Simulators *)\n\n  (** Declassification simulator *)\n  op [lossless] sim_declass(a: inputs_t, l: leakage_t): trace_t distr.\n  (** Input simulator *)\n  op [lossless] sim_in(x: leakage_t): trace_t distr.\n  (** Output simulator *)\n  op [lossless] sim_out(x: inputs_t, y: leakage_t): trace_t distr.\n  (** Secret operator simulator *)\n  op [lossless] sim_sop(sop: sop_t, pargs: value_t list, sargs: inputs_t list, l: leakage_t option)\n        : (outputs_t * trace_t) distr.\n\n  clone import ProtocolLibrary with\n    op n = n,\n    type partyId_t = partyId_t,\n    type value_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type msg_data = msg_data,\n    type leakage_t = leakage_t,\n    type sideInfo_t = sideInfo_t,\n    type sop_t = sop_t,\n    op sop_spec = sop_spec,\n    op prot_declass = prot_declass,\n    op prot_in = prot_in,\n    op prot_out = prot_out,\n    op prot_sop = prot_sop,\n    op sim_declass = sim_declass,\n    op sim_in = sim_in,\n    op sim_out = sim_out,\n    op sim_sop = sim_sop\n  proof *.\n  realize prot_declass_ll by smt(prot_declass_ll).\n  realize prot_in_ll by smt(prot_in_ll).\n  realize prot_out_ll by smt(prot_out_ll).\n  realize prot_sop_ll by smt(prot_sop_ll).\n  realize sim_declass_ll by smt(sim_declass_ll).\n  realize sim_in_ll by smt(sim_in_ll).\n  realize sim_out_ll by smt(sim_out_ll).\n  realize sim_sop_ll by smt(sim_sop_ll).\n\n  (* Correctness and Security Assumptions are captured by\n  adequate pRHL assertions                                   *)\n  module APIsec = {\n    proc prot_declass(a: sharedValue_t): value_t * sideInfo_t = {\n      var x;\n      x <$ prot_declass a;\n      return x;\n    }\n    proc sim_declass(a: inputs_t, l: leakage_t): value_t * sideInfo_t = {\n      var t;\n      t <$ sim_declass a l;\n      return (oget (leakage_value l), Trace (Some l) t);\n    }\n    proc prot_in(a: sharedValue_t): sideInfo_t = {\n      var x;\n      x <$ prot_in a;\n      return x;\n    }\n    proc sim_in(l: leakage_t): sideInfo_t = {\n      var x;\n      x <$ sim_in l;\n      return Trace (Some l) x;\n    }\n    proc prot_out(a: sharedValue_t): sharedValue_t * sideInfo_t = {\n      var x;\n      x <$ prot_out a;\n      return x;\n    }\n    proc sim_out(a: sharedValue_t, l: leakage_t): sideInfo_t = {\n      var t;\n      t <$ sim_out a l;\n      return Trace (Some l) t;\n    }\n    proc spec_out(a: sharedValue_t): sharedValue_t * sideInfo_t = {\n      var x, y, l, tr;\n      x <$ nshr n (unshr a);\n      y <- take t x;\n      l <- LeakedShares y;\n      tr <@ sim_out (take t a, l);\n      return (x, tr);\n    }\n    proc prot_sop(o: sop_t, pargs: value_t list, sargs: sharedValue_t list): sharedValue_t * sideInfo_t = {\n      var x;\n      x <$ prot_sop o pargs sargs;\n      return x;\n    }\n    proc sim_sop(o: sop_t, pargs: value_t list, sargs: sharedValue_t list, l: leakage_t option): sharedValue_t * sideInfo_t = {\n      var x,t;\n      (x,t) <$ sim_sop o pargs sargs l;\n      return (x, Trace l t);\n    }\n  }.\n\n  axiom assumption_declass aa ll:\n    equiv [ APIsec.sim_declass ~ APIsec.prot_declass:\n            aa = a{2} /\\ ll = l{1} /\\ take t a{2} = a{1} /\\ l{1} = LeakedValue (unshr a{2})\n            ==> ={res} /\\ res{2}.`1 = unshr aa /\\ res{2}.`2.`leakage = Some ll ].\n\n  axiom assumption_in ll:\n    equiv [ APIsec.sim_in ~ APIsec.prot_in: ll = l{1} /\\ l{1} = LeakedShares (take t a{2})\n                                            ==> ={res} /\\ res{2}.`leakage = Some ll ].\n\n  axiom assumption_sop oo pp aa ll:\n   equiv [ APIsec.sim_sop ~ APIsec.prot_sop: ={o, pargs} /\\ aa = sargs{2} /\\ ll = l{1} /\\\n           l{1} = (sop_spec oo pp (map unshr aa)).`2 /\\ map (take t) sargs{2} = sargs{1}\n           ==> res{1}.`1 = take t res{2}.`1 /\\ res{1}.`2 = res{2}.`2 /\\\n               unshr res{2}.`1 = (sop_spec oo pp (map unshr aa)).`1 /\\\n               res{2}.`2.`leakage = ll ].\n\n(* the security notion for [prot_out] is stronger than for the\n remaining protocolos. The assumption resorts to an auxiliary\n procedure.                                                    *) \n(*axiom assumption_out:\n equiv [ APIsec.spec_out ~ APIsec.prot_out:\n         ={a} ==> ={res} ].*)\n  axiom assumption_out yy :\n    equiv [ APIsec.sim_out ~ APIsec.prot_out : \n           yy \\in nshr n (unshr a{2}) /\\ a{1} = take t a{2} /\\ l{1} = LeakedShares (take t yy) ==>\n           res{2}.`1 = yy /\\ res{1} = res{2}.`2].\n\nend MPCProtocolLibrary."
    },
    {
        "file": "EC-1/NbPRFEnc.ec",
        "incomplete": "require import AllCore SmtMap List Distr.\nrequire import QCounter.\nrequire (****) PRFth NbEnc.\n\ntheory NbPRFEnc.\n\n(* Will work for arbitrary types *)\ntype nonce.\ntype ____(TYPE_0)____.\ntype key.\n\n(* These operators will replace the ones in the PRF theory,\n   so our assumption will be based on this function and\n   these distributions. *)\nop f : key -> nonce -> plaintext.\nop dkey : ____(OP_0)____ distr.\nop dplaintext : plaintext distr.\n\n(* We bring to the top level the assumptions on the \n   distributions required by the theories we will clone. *)\naxiom dkey_ll: is_lossless dkey.\naxiom dplaintext_ll: is_lossless dplaintext.\naxiom dplaintext_uni: is_uniform dplaintext.\naxiom dplaintext_full: is_full dplaintext.\n\n(* Cloning creates a sub-theory with definitions, \n   axioms and lemmas defined in the cloned theory.\n   The <- notation forgets the original type names via\n   substitution.\n   Using = keeps original names and creates an alias. *)\nclone import PRFth with\n  type input <- nonce,\n  type output <- plaintext,\n  type key <- key,\n  op f <- f,\n  op doutput <- dplaintext,\n  op dkey <- dkey\n  (* renaming is purely syntactic on all occurrences! *)\n  rename \"doutput\" as \"dplaintext\"\n  (* if we do not prove axioms in original theory, they\n     remain axioms, here we prove all of them under the\n     top level axioms above for clarity. *)\n  proof *.\n\nrealize dplaintext_ll by apply dplaintext_ll.\nrealize dplaintext_uni by apply dplaintext_uni.\nrealize dplaintext_full by apply dplaintext_full.\nrealize dkey_ll by apply dkey_ll.\n\n(* We get the syntax and security definitions for nonce-based\n   encryption by copying all the definitions in NbEnc with\n   some renamings.\n   The alternative = notation adds a type definition\n   with an alias.\n*)\nclone include NbEnc with\n  type key <- key,\n  type nonce <- nonce,\n  type plaintext <- plaintext,\n  type ciphertext = plaintext,\n  op dciphertext = dplaintext\n  proof *.\n\n(* Again we prove all axioms in the underlying theory\n   using the top-level ones for clarity *)\n\nrealize dciphertext_ll by apply dplaintext_ll.\nrealize dciphertext_uni by apply dplaintext_uni.\nrealize dciphertext_full by apply dplaintext_full.\n\n(* XOR operator over plaintexts with minimal properties *)\nop (^) : plaintext -> plaintext -> plaintext.\n\naxiom xor_idempotent1 x y : (x ^ y) ^ y = x.\naxiom xor_idempotent2 x y : x ^ (x ^ y) = y.\n\n(* Encryption and decryption operators *)\nop enc k n p = f k n ^ p.\nop dec k n c = f k n ^ c.\n\n(* We prove that decryption recovers an encrypted \n   message using the core logic. This lemma can\n   then be used to prove that the scheme is correct. *)\nlemma enc_dec_correct k n p :\n  dec k n (enc k n p) = p\n by  rewrite /enc /dec xor_idempotent2.\n\n(* The encryption scheme  in the correct syntax. *)\nmodule Scheme : Scheme_T = {\n\n  proc kg () = {\n    var k;\n    k <$ dkey;\n    return k;\n  }\n  \n  proc enc(k:key, n:nonce, p:plaintext) = {\n    var mask, c;\n    mask <- f k n;\n    c <- mask ^ p;\n    return c;\n  }\n\n  proc dec(k:key, n:nonce, c:ciphertext) = {\n    var mask, p;\n    mask <- f k n;\n    p <- mask ^ c;\n    return p;\n  }\n}.\n\n(*************************************************************)\n(*                      CORRECTNESS                          *)\n(*************************************************************)\n\n\n(* We prove partial correctness with respect to the functional\n   operators. I.e., correct if terminates.  *)\nlemma correct_enc_h k n p :\n  hoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p]\n   by proc; wp; skip; move => /> *; rewrite /enc. \n\n(* Encryption always terminates *)\nlemma correct_enc_ll : islossless Scheme.enc by islossless.\n\n(* Total correctness as a corollary. \n   This means we can always lift any call to\n   the enc procedure to a logical operation over its\n   inputs *)\nlemma correct_enc k n p :\n  phoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p] = 1%r\n  by conseq correct_enc_ll (correct_enc_h k n p). \n\n(* We do the same for decryption *)\nlemma correct_dec_h k n c :\n  hoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c]\n   by proc; wp; skip; move => /> *; rewrite /dec. \n\nlemma correct_dec_ll : islossless ____(LEMMA_0)____.dec by islossless.\n\nlemma correct_dec k n c :\n  phoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c] = 1%r\n  by conseq correct_dec_ll (correct_dec_h k n c). \n\n(* We can apply the above lemmas when we prove that the\n   construction is correct as a nonce-based encryption scheme:\n   lift encryption and decryption to logical operations and\n   then use the fact that the logical operators cancel as\n   proved in enc_dec_correct. *)\nlemma correctness &m _k _n _p:\n  Pr[ Correctness(Scheme).main(_k,_n,_p) @ &m : res ] = 1%r.\nbyphoare (_: arg = (_k,_n,_p) ==> _) => //.\nhave lossless: islossless Correctness(Scheme).main; first by islossless.\nhave correct : hoare [ Correctness(Scheme).main : arg = (_k, _n, _p) ==> res ].\n+ proc.\n  seq 1 : (#pre /\\ c = enc _k _n _p).\n  call (correct_enc_h _k _n _p); first by auto => />.\n  ecall (correct_dec_h _k _n c). \n  by auto => />; rewrite enc_dec_correct.\nby conseq lossless correct. \nqed.\n\n(*************************************************************)\n(*                          SECURITY                         *)\n(*************************************************************)\n\n(* B is a reduction that breaks PRF if A breaks encryption scheme  *)\n\nmodule (B(A:AdvCPA):Adv) (O:Orcl) = {\n  \n  module OCPA = {\n    proc init() = { }\n\n    proc enc (n:nonce, p:plaintext) = {\n      var r;\n      r <@ O.f(n);\n      return (r ^ p);\n    }\n  }\n\n  proc guess = CPA(A, OCPA).main\n\n}.\n\nsection PROOF.\n\n(*  Declaring an adversary in a section quantifies  universally\n    over A for all results in the section. The names in brackets\n    indicate that A cannot touch the internal states of these\n    modules. Otherwise the proof fails (e.g., A could just get\n    the PRF key! *)\ndeclare module A:AdvCPA {Real_Ideal, Real_PRF, RealScheme, RF, WO}.\n\n(* We prove equivalences between games using pRHL, which then\n   allow us to derive probability results as a consequence.\n   These equivalences talk about how events occurring in\n   one game relate to events occurring in the other game. *)\n\n(* If PRF game is uses PRF then we are using the real scheme.\n   There is a syntactic identity between the games modulo\n   renamings. \n   If A starts from the same state, then both games output \n   the same result res and the global counter has the same\n   value, so B makes same queries as A. *)\nlemma Real_CPA_PRF : \n  equiv [ CPA(A, RealScheme(Scheme)).main ~ Real_Ideal(B(A), Real_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc.\n inline *; wp. \ncall (: ={WO.nonces,QCounter.q} /\\ RealScheme.k{1} = Real_PRF.k{2}).\n+ by proc; inline *; auto => /> /#.\nby auto => />.\nqed.\n\n(* We introduce a game hop where we modify the scheme to use\n   a true random function instead of the PRF *)\nmodule ModifiedScheme = {\n   include Scheme [-enc,kg]\n  \n   proc kg() : key = { \n     RF.init();\n     return witness;\n   }\n\n   proc enc(k : key, n : nonce, p : plaintext) : ciphertext = {\n    var mask : plaintext;\n    var c : ciphertext;\n    \n    mask <@ RF.f(n);\n    c <- mask ^ p;\n    \n    return c;\n  }\n}.\n\n(* If PRF game uses RF then we are using the modified scheme.\n   Again the proof is simply a syntactic match. *)\nlemma Modified_CPA_PRF: \n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ Real_Ideal(B(A), Ideal_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,RF.m,QCounter.q}).\n+ by proc; inline *;sim.\nby auto.\nqed.\n\n(* Now we do a final step to show we have reached the ideal\n   game; we need to argue that the RF acts as a one-time pad\n   so ciphertexts do look totally random. *)\nlemma Modified_CPA_Ideal:\n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ CPA(A, IdealScheme).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n          (forall n, n \\in WO.nonces = n \\in RF.m){1}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{1} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{1}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* Our main theorem relates advantages of A and B, and it also relates\n   the number of queries both make. *)\nlemma incpa_security_hop &m q:\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n(* have -> introduces a new proof goal and immediately rewrites it once\n   proved. Here we use the equiv lemmas proved above to rewrite probability\n   equalities and wrap up the proof. *)\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[CPA(A,IdealScheme).main() @ &m : res]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have -> : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done ].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF) => // | by done ].\n\n+ have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done].\n\nqed.\n\nend section PROOF.\n\n(*************************************************************)\n(*                   Alternative Proof                       *)\n(*************************************************************)\n\n(* The same B above can be used to perform a direct reduction\n   proof, where we bridge directly the ideal scheme to \n   the ideal PRF game. *)\n\nsection PROOF.\n\ndeclare module A:____(DECLARE_0)____ {WO, Real_PRF, Ideal, RealScheme, ____(DECLARE_1)____}.\n\n(* If PRF game uses RF then we are using the ideal scheme.\n   We need to argue that xor acts as a one time pad to get the\n   equivalence.  *)\nlemma Ideal_CPA_PRF : \n  equiv [ CPA(A, IdealScheme).main ~ Real_Ideal(B(A), Ideal_PRF).main : \n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n            (forall n, n \\in WO.nonces = n \\in RF.m){2}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{2} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{2}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* The same result follows. *)\nlemma indcpa_security &m q :\n\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF A) => //.\n\n  have <- : (Pr[CPA(A,IdealScheme).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF A) => // | by done].\n\n+ have <- : (Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\nqed.\n\n\nend section PROOF.\n\n(* The hopping technique above can be extended to make explicit\n   the PRF-PRP bound if f is a permutation. \n\n   First modify the scheme to use a RP (rather than directly \n   an RF) and prove that any difference in the CPA game can be\n   used to win the PRP game against f. This will be the new\n   computational assumption in the final bound. \n\n   Then use generic RP-RF switching lemma to hop to the \n   modified scheme that uses the RF and proceed as above. \n   The EC library already includes the switching lemma. *)\n\n\nend NbPRFEnc.",
        "complete:": "require import AllCore SmtMap List Distr.\nrequire import QCounter.\nrequire (****) PRFth NbEnc.\n\ntheory NbPRFEnc.\n\n(* Will work for arbitrary types *)\ntype nonce.\ntype plaintext.\ntype key.\n\n(* These operators will replace the ones in the PRF theory,\n   so our assumption will be based on this function and\n   these distributions. *)\nop f : key -> nonce -> plaintext.\nop dkey : key distr.\nop dplaintext : plaintext distr.\n\n(* We bring to the top level the assumptions on the \n   distributions required by the theories we will clone. *)\naxiom dkey_ll: is_lossless dkey.\naxiom dplaintext_ll: is_lossless dplaintext.\naxiom dplaintext_uni: is_uniform dplaintext.\naxiom dplaintext_full: is_full dplaintext.\n\n(* Cloning creates a sub-theory with definitions, \n   axioms and lemmas defined in the cloned theory.\n   The <- notation forgets the original type names via\n   substitution.\n   Using = keeps original names and creates an alias. *)\nclone import PRFth with\n  type input <- nonce,\n  type output <- plaintext,\n  type key <- key,\n  op f <- f,\n  op doutput <- dplaintext,\n  op dkey <- dkey\n  (* renaming is purely syntactic on all occurrences! *)\n  rename \"doutput\" as \"dplaintext\"\n  (* if we do not prove axioms in original theory, they\n     remain axioms, here we prove all of them under the\n     top level axioms above for clarity. *)\n  proof *.\n\nrealize dplaintext_ll by apply dplaintext_ll.\nrealize dplaintext_uni by apply dplaintext_uni.\nrealize dplaintext_full by apply dplaintext_full.\nrealize dkey_ll by apply dkey_ll.\n\n(* We get the syntax and security definitions for nonce-based\n   encryption by copying all the definitions in NbEnc with\n   some renamings.\n   The alternative = notation adds a type definition\n   with an alias.\n*)\nclone include NbEnc with\n  type key <- key,\n  type nonce <- nonce,\n  type plaintext <- plaintext,\n  type ciphertext = plaintext,\n  op dciphertext = dplaintext\n  proof *.\n\n(* Again we prove all axioms in the underlying theory\n   using the top-level ones for clarity *)\n\nrealize dciphertext_ll by apply dplaintext_ll.\nrealize dciphertext_uni by apply dplaintext_uni.\nrealize dciphertext_full by apply dplaintext_full.\n\n(* XOR operator over plaintexts with minimal properties *)\nop (^) : plaintext -> plaintext -> plaintext.\n\naxiom xor_idempotent1 x y : (x ^ y) ^ y = x.\naxiom xor_idempotent2 x y : x ^ (x ^ y) = y.\n\n(* Encryption and decryption operators *)\nop enc k n p = f k n ^ p.\nop dec k n c = f k n ^ c.\n\n(* We prove that decryption recovers an encrypted \n   message using the core logic. This lemma can\n   then be used to prove that the scheme is correct. *)\nlemma enc_dec_correct k n p :\n  dec k n (enc k n p) = p\n by  rewrite /enc /dec xor_idempotent2.\n\n(* The encryption scheme  in the correct syntax. *)\nmodule Scheme : Scheme_T = {\n\n  proc kg () = {\n    var k;\n    k <$ dkey;\n    return k;\n  }\n  \n  proc enc(k:key, n:nonce, p:plaintext) = {\n    var mask, c;\n    mask <- f k n;\n    c <- mask ^ p;\n    return c;\n  }\n\n  proc dec(k:key, n:nonce, c:ciphertext) = {\n    var mask, p;\n    mask <- f k n;\n    p <- mask ^ c;\n    return p;\n  }\n}.\n\n(*************************************************************)\n(*                      CORRECTNESS                          *)\n(*************************************************************)\n\n\n(* We prove partial correctness with respect to the functional\n   operators. I.e., correct if terminates.  *)\nlemma correct_enc_h k n p :\n  hoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p]\n   by proc; wp; skip; move => /> *; rewrite /enc. \n\n(* Encryption always terminates *)\nlemma correct_enc_ll : islossless Scheme.enc by islossless.\n\n(* Total correctness as a corollary. \n   This means we can always lift any call to\n   the enc procedure to a logical operation over its\n   inputs *)\nlemma correct_enc k n p :\n  phoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p] = 1%r\n  by conseq correct_enc_ll (correct_enc_h k n p). \n\n(* We do the same for decryption *)\nlemma correct_dec_h k n c :\n  hoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c]\n   by proc; wp; skip; move => /> *; rewrite /dec. \n\nlemma correct_dec_ll : islossless Scheme.dec by islossless.\n\nlemma correct_dec k n c :\n  phoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c] = 1%r\n  by conseq correct_dec_ll (correct_dec_h k n c). \n\n(* We can apply the above lemmas when we prove that the\n   construction is correct as a nonce-based encryption scheme:\n   lift encryption and decryption to logical operations and\n   then use the fact that the logical operators cancel as\n   proved in enc_dec_correct. *)\nlemma correctness &m _k _n _p:\n  Pr[ Correctness(Scheme).main(_k,_n,_p) @ &m : res ] = 1%r.\nbyphoare (_: arg = (_k,_n,_p) ==> _) => //.\nhave lossless: islossless Correctness(Scheme).main; first by islossless.\nhave correct : hoare [ Correctness(Scheme).main : arg = (_k, _n, _p) ==> res ].\n+ proc.\n  seq 1 : (#pre /\\ c = enc _k _n _p).\n  call (correct_enc_h _k _n _p); first by auto => />.\n  ecall (correct_dec_h _k _n c). \n  by auto => />; rewrite enc_dec_correct.\nby conseq lossless correct. \nqed.\n\n(*************************************************************)\n(*                          SECURITY                         *)\n(*************************************************************)\n\n(* B is a reduction that breaks PRF if A breaks encryption scheme  *)\n\nmodule (B(A:AdvCPA):Adv) (O:Orcl) = {\n  \n  module OCPA = {\n    proc init() = { }\n\n    proc enc (n:nonce, p:plaintext) = {\n      var r;\n      r <@ O.f(n);\n      return (r ^ p);\n    }\n  }\n\n  proc guess = CPA(A, OCPA).main\n\n}.\n\nsection PROOF.\n\n(*  Declaring an adversary in a section quantifies  universally\n    over A for all results in the section. The names in brackets\n    indicate that A cannot touch the internal states of these\n    modules. Otherwise the proof fails (e.g., A could just get\n    the PRF key! *)\ndeclare module A:AdvCPA {Real_Ideal, Real_PRF, RealScheme, RF, WO}.\n\n(* We prove equivalences between games using pRHL, which then\n   allow us to derive probability results as a consequence.\n   These equivalences talk about how events occurring in\n   one game relate to events occurring in the other game. *)\n\n(* If PRF game is uses PRF then we are using the real scheme.\n   There is a syntactic identity between the games modulo\n   renamings. \n   If A starts from the same state, then both games output \n   the same result res and the global counter has the same\n   value, so B makes same queries as A. *)\nlemma Real_CPA_PRF : \n  equiv [ CPA(A, RealScheme(Scheme)).main ~ Real_Ideal(B(A), Real_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc.\n inline *; wp. \ncall (: ={WO.nonces,QCounter.q} /\\ RealScheme.k{1} = Real_PRF.k{2}).\n+ by proc; inline *; auto => /> /#.\nby auto => />.\nqed.\n\n(* We introduce a game hop where we modify the scheme to use\n   a true random function instead of the PRF *)\nmodule ModifiedScheme = {\n   include Scheme [-enc,kg]\n  \n   proc kg() : key = { \n     RF.init();\n     return witness;\n   }\n\n   proc enc(k : key, n : nonce, p : plaintext) : ciphertext = {\n    var mask : plaintext;\n    var c : ciphertext;\n    \n    mask <@ RF.f(n);\n    c <- mask ^ p;\n    \n    return c;\n  }\n}.\n\n(* If PRF game uses RF then we are using the modified scheme.\n   Again the proof is simply a syntactic match. *)\nlemma Modified_CPA_PRF: \n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ Real_Ideal(B(A), Ideal_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,RF.m,QCounter.q}).\n+ by proc; inline *;sim.\nby auto.\nqed.\n\n(* Now we do a final step to show we have reached the ideal\n   game; we need to argue that the RF acts as a one-time pad\n   so ciphertexts do look totally random. *)\nlemma Modified_CPA_Ideal:\n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ CPA(A, IdealScheme).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n          (forall n, n \\in WO.nonces = n \\in RF.m){1}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{1} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{1}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* Our main theorem relates advantages of A and B, and it also relates\n   the number of queries both make. *)\nlemma incpa_security_hop &m q:\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n(* have -> introduces a new proof goal and immediately rewrites it once\n   proved. Here we use the equiv lemmas proved above to rewrite probability\n   equalities and wrap up the proof. *)\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[CPA(A,IdealScheme).main() @ &m : res]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have -> : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done ].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF) => // | by done ].\n\n+ have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done].\n\nqed.\n\nend section PROOF.\n\n(*************************************************************)\n(*                   Alternative Proof                       *)\n(*************************************************************)\n\n(* The same B above can be used to perform a direct reduction\n   proof, where we bridge directly the ideal scheme to \n   the ideal PRF game. *)\n\nsection PROOF.\n\ndeclare module A:AdvCPA {WO, Real_PRF, Ideal, RealScheme, ModifiedScheme}.\n\n(* If PRF game uses RF then we are using the ideal scheme.\n   We need to argue that xor acts as a one time pad to get the\n   equivalence.  *)\nlemma Ideal_CPA_PRF : \n  equiv [ CPA(A, IdealScheme).main ~ Real_Ideal(B(A), Ideal_PRF).main : \n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n            (forall n, n \\in WO.nonces = n \\in RF.m){2}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{2} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{2}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* The same result follows. *)\nlemma indcpa_security &m q :\n\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF A) => //.\n\n  have <- : (Pr[CPA(A,IdealScheme).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF A) => // | by done].\n\n+ have <- : (Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\nqed.\n\n\nend section PROOF.\n\n(* The hopping technique above can be extended to make explicit\n   the PRF-PRP bound if f is a permutation. \n\n   First modify the scheme to use a RP (rather than directly \n   an RF) and prove that any difference in the CPA game can be\n   used to win the PRP game against f. This will be the new\n   computational assumption in the final bound. \n\n   Then use generic RP-RF switching lemma to hop to the \n   modified scheme that uses the RF and proceed as above. \n   The EC library already includes the switching lemma. *)\n\n\nend NbPRFEnc."
    },
    {
        "file": "EC-1/ind_ow_pke.ec",
        "incomplete": "require import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\n\n\n\n\nclone import PublicKeyEncryption as PKE.\n\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\n\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    \n    p <$ dptxtm pk;\n    p' <$ dptxtm pk;\n    \n    return (p, p');  \n  }\n  \n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;\n    \n    pinv <@ A.find(pk', c);\n    \n    return pinv = p'; \n  }\n}.\n\n\nsection.\n\ndeclare module S <: Scheme{____(DECLARE_0)____}.\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}.\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  \n\n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t\n  proc main() : bool = {\n    var pk : pk_t;\n    var sk : sk_t;\n    var p' : ptxt_t;\n    var c : ctxt_t;\n    \n    (pk, sk) <@ S.keygen();\n    p0 <$ dptxtm pk;\n    p1 <$ dptxtm pk;\n    c <@ S.enc(pk, p0);\n    p' <@ A.find(pk, c);\n    \n    return p' = p0;\n  }\n}.\n\nlocal equiv test : \nOW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll). \nqed.\n\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]\n  +\n  pmax_pk dptxtm.\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]).\n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section.",
        "complete:": "require import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\n\n\n\n\nclone import PublicKeyEncryption as PKE.\n\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\n\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    \n    p <$ dptxtm pk;\n    p' <$ dptxtm pk;\n    \n    return (p, p');  \n  }\n  \n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;\n    \n    pinv <@ A.find(pk', c);\n    \n    return pinv = p'; \n  }\n}.\n\n\nsection.\n\ndeclare module S <: Scheme{-R_IND_OW}.\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}.\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  \n\n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t\n  proc main() : bool = {\n    var pk : pk_t;\n    var sk : sk_t;\n    var p' : ptxt_t;\n    var c : ctxt_t;\n    \n    (pk, sk) <@ S.keygen();\n    p0 <$ dptxtm pk;\n    p1 <$ dptxtm pk;\n    c <@ S.enc(pk, p0);\n    p' <@ A.find(pk, c);\n    \n    return p' = p0;\n  }\n}.\n\nlocal equiv test : \nOW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll). \nqed.\n\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]\n  +\n  pmax_pk dptxtm.\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]).\n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section."
    },
    {
        "file": "EC-1/otp.ec",
        "incomplete": "require import AllCore.\nrequire BitWord.\n\nop l : { int | 0 < l } ____(OP_1)____ ____(OP_0)____.\n\nclone import BitWord as Bits with\n  op n <- l\nproof gt0_n by exact/gt0_l\nrename\n  \"word\" as \"bitstring\"\n  \"dunifin\" as \"dbitstring\".\n\nimport DWord.\n\ntype message = ____(TYPE_0)____.\ntype ciphertext = bitstring.\ntype key = bitstring.\n\nop [lossless] dmsg : message distr.\n\n\nmodule OTP = {\n  var m: message\n  var c: ciphertext\n\n  proc kg() : key = {\n    var k;\n\n    k <$ dbitstring;\n    return k;\n  }\n\n  proc enc(k: key, m: message) : ciphertext = {\n    return (k +^ m);\n  }\n\n  proc main() : unit = {\n    var k;\n\n    m <$ dmsg;\n    k <@ kg();\n    c <@ enc(k, m);\n  }\n}.\n\nmodule Uniform = {\n  var m: message\n  var c: ciphertext\n\n  proc main() : unit = {\n    m <$ dmsg;\n    c <$ dbitstring;\n  }\n}.\n\n\nlemma Secrecy : \n  equiv[ OTP.main ~ Uniform.main : true ==> (OTP.m, OTP.c){1} = (Uniform.m, Uniform.c){2} ].\nproof.\n  proc.\n  inline{1} OTP.kg OTP.enc.\n  wp.\n  rnd (fun k => k +^ OTP.m{1}).\n  rnd.\n  skip.\n  progress.\n  algebra.\nqed.",
        "complete:": "require import AllCore.\nrequire BitWord.\n\nop l : { int | 0 < l } as gt0_l.\n\nclone import BitWord as Bits with\n  op n <- l\nproof gt0_n by exact/gt0_l\nrename\n  \"word\" as \"bitstring\"\n  \"dunifin\" as \"dbitstring\".\n\nimport DWord.\n\ntype message = bitstring.\ntype ciphertext = bitstring.\ntype key = bitstring.\n\nop [lossless] dmsg : message distr.\n\n\nmodule OTP = {\n  var m: message\n  var c: ciphertext\n\n  proc kg() : key = {\n    var k;\n\n    k <$ dbitstring;\n    return k;\n  }\n\n  proc enc(k: key, m: message) : ciphertext = {\n    return (k +^ m);\n  }\n\n  proc main() : unit = {\n    var k;\n\n    m <$ dmsg;\n    k <@ kg();\n    c <@ enc(k, m);\n  }\n}.\n\nmodule Uniform = {\n  var m: message\n  var c: ciphertext\n\n  proc main() : unit = {\n    m <$ dmsg;\n    c <$ dbitstring;\n  }\n}.\n\n\nlemma Secrecy : \n  equiv[ OTP.main ~ Uniform.main : true ==> (OTP.m, OTP.c){1} = (Uniform.m, Uniform.c){2} ].\nproof.\n  proc.\n  inline{1} OTP.kg OTP.enc.\n  wp.\n  rnd (fun k => k +^ OTP.m{1}).\n  rnd.\n  skip.\n  progress.\n  algebra.\nqed."
    },
    {
        "file": "EC-1/passCertRPG_ref.ec",
        "incomplete": "require import AllCore IntDiv DInterval List UpdateList.\nrequire (****) RPGTh.\n\nclone include RPGTh.\n\nmodule RPGRef : RPG_T = {\n\n  var lowercaseSet, uppercaseSet, numbersSet, specialSet : charSet\n\n  proc rng(range:int) : int = {\n    \n    var value, maxValue, modValue : int;\n\n    (* check how much we should remove from 2^64 - 1 in order to get a multiple of range *)\n    modValue <- (2^64 - 1) %% range;\n\n    (* if the mod is range - 1, it means we can sample from 2^64 - 1 and have an uniform distribution *)\n    if(modValue = range - 1) {\n      maxValue <- (2^64 - 1);\n    (* else, we need to remove the unnecessary values*)\n    } else {\n      maxValue <- (2^64 - 1) - modValue - 1;\n    }\n\n    value <$ [0 .. (2^64 - 1)];\n\n    while (maxValue < value) {\n      value <$ [0 .. (2^64 - 1)]; (* Random Bytes Generator *)\n    }\n    \n    value <- value %% range;\n    \n    return value;\n    \n  }\n\n  \n  proc random_char_generator(set:charSet) : char = {\n    \n    var char : char;\n    var choice : int;\n    \n    choice <@ rng(size set);\n    char <- nth (-1) set choice;\n    \n    return (char);\n    \n  }\n\n  \n  proc permutation(pw:password) : password = {\n\n    var i : int;\n    var j : int;\n    var aux : char;\n    \n    i <- size pw;\n    \n    while (0 < i) {\n      j <@ rng(i);\n      i <- i - 1;\n      aux <- nth 0 pw i;\n      pw <- update (nth 0 pw j) pw i;\n      pw <- update aux pw j;\n    }\n    \n    return pw;\n \n  }\n\n\n  proc get_lowercaseSet() : charSet = {\n    \n    var set : charSet;\n    set <- [97; 98; 99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111; 112;\n           113; 114; 115; 116; 117; 118; 119; 120; 121; 122];\n    return set;\n\n  }\n\n\n  proc get_uppercaseSet() : charSet = {\n    \n    var set : charSet;\n    set <- [65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85;\n           86; 87; 88; 89; 90];\n    return set;\n\n  }\n\n\n  proc get_numbersSet() : charSet = {\n\n    var set : charSet;\n    set <- [48; 49; 50; 51; 52; 53; 54; 55; 56; 57];\n    return set;\n\n  }\n\n\n  proc get_specialSet() : charSet = {\n    \n    var set : charSet;\n    set <- [33; 63; 35; 36; 37; 38; 43; 45; 42; 95; 64; 58; 59; 61];\n    return set;\n\n  }\n\n\n  proc define_union_set(nLowercase:int, nUppercase:int, nNumbers:int, nSpecial:int,\n                        lowercaseSet:charSet, uppercaseSet:charSet,\n                        numbersSet:charSet, specialSet:charSet) : charSet = {\n\n    var unionSet, set : charSet;\n\n    unionSet <- [];\n    \n    if (0 < nLowercase) {\n      set <- lowercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nUppercase) {\n      set <- uppercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nNumbers) {\n      set <- numbersSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nSpecial) {\n      set <- specialSet;\n      unionSet <- unionSet ++ set;\n    }\n\n    return unionSet;    \n\n  }\n\n  \n  proc generate_password(policy:policy) : password option = {\n\n    var outputPassword : password option;\n    var generatedPassword : password;\n    var unionSet : charSet;\n    var randomChar : char;\n    var i : int;\n    var lowercaseAvailable, uppercaseAvailable, numbersAvailable, specialAvailable : int;\n\n    (* ---------------------------------------------- *)\n    (* If policy is satisfiable, return Some password *)\n    (* ---------------------------------------------- *)\n    if(satisfiablePolicy policy) {\n\n      (* initializer sets *)\n      lowercaseSet <@ get_lowercaseSet();\n      uppercaseSet <@ get_uppercaseSet();\n      numbersSet <@ get_numbersSet();\n      specialSet <@ get_specialSet();\n\n      (* initialize random password *)\n      generatedPassword <- [];\n    \n      (* check which sets are available to generate characters from (max > 0) *)\n\n      lowercaseAvailable <- policy.`lowercaseMax;\n      uppercaseAvailable <- policy.`uppercaseMax;\n      numbersAvailable <- policy.`numbersMax;\n      specialAvailable <- policy.`specialMax;\n\n      (* generate characters with min values defined *)     \n \n      if (0 < lowercaseAvailable) {\n        i <- 0;\n        while (i < policy.`lowercaseMin) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          randomChar <@ random_char_generator(lowercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < uppercaseAvailable) {\n        i <- 0;\n        while (i < policy.`uppercaseMin) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          randomChar <@ random_char_generator(uppercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < numbersAvailable) {\n        i <- 0;\n        while (i < policy.`numbersMin) {\n          numbersAvailable <- numbersAvailable - 1;\n          randomChar <@ random_char_generator(numbersSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < specialAvailable) {\n        i <- 0;\n        while (i < policy.`specialMin) {\n          specialAvailable <- specialAvailable - 1;\n          randomChar <@ random_char_generator(specialSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n\n      (* generate characters from the available sets of characters *)\n\n      unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                   specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                   specialSet);\n\n      while (size generatedPassword < policy.`length) {\n\n        randomChar <@ random_char_generator(unionSet);\n\n        if (randomChar \\in lowercaseSet) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          if (lowercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in uppercaseSet) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          if (uppercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in numbersSet) {\n          numbersAvailable <- numbersAvailable - 1;\n          if (numbersAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in specialSet) {\n          specialAvailable <- specialAvailable - 1;\n          if (specialAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n\n        generatedPassword <- generatedPassword ++ [randomChar];\n\n      }\n\n        generatedPassword <@ permutation(generatedPassword);\n   \n        outputPassword <- Some generatedPassword;\n\n    }\n\n    (* --------------------------------------- *)\n    (* If policy is unsatisfiable, return None *)\n    (* --------------------------------------- *)\n    else {\n\n      outputPassword <- None;\n\n    }\n\n    return outputPassword;\n    \n  }\n  \n}.\n\n\n\n(**********************************)\n(*        AUXILIARY LEMMAS        *)\n(**********************************)\n\n(* axiom -> rng always terminates *)\naxiom rng_ll : islossless RPGRef.rng.\n\n\n(* output of rng is smaller than range *)\nlemma rng_range _range :\n  hoare [RPGRef.rng : range = _range /\\ 0 < _range ==> 0 <= res /\\ res < _range].\nproof.\nproc.\nsp.\nseq 1 : (#pre /\\ 0 <= value).\n  auto.\n  move => &m /> h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nwp.\nwhile (0 <= value).\n  auto.\n  move => &m h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nskip.\nmove => &m /> h1 h2 value0 h3 h4.\nsplit.\n- by apply modn_ge0. \n- have h5 : range{m} = _range.\n  + smt().\n  have h6 : 0 < _range.\n  + smt().\n  by rewrite h5 ltz_pmod.\nqed.\n\n\n(* input set given to random char generator has the generated char *)\nlemma random_char_generator_has _set :\n  hoare [RPGRef.random_char_generator : set = _set /\\ 0 < size _set ==> res \\in _set].\nproof.\nproc.\nauto.\nseq 1 : (set = _set /\\ 0 <= choice /\\ choice < size set).\n  ecall (rng_range (size set)).\n  auto.\nauto.\nmove => &m [h1 h2].\nby rewrite -h1 mem_nth andaE.\nqed.\n\n\n(* permutation of a password does not change its size*)\nlemma permutation_size input :\n  hoare [RPGRef.permutation : pw = input ==> size res = size input].\nproof.\nproc.\nseq 1 : (size pw = size input).\n  auto.\nwhile (size pw = size input).\n  seq 1 : (size pw = size input).\n    ecall (rng_range i).\n    skip.\n    move => />.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n    move => &m /> h1.\n    by rewrite -size_update.\n  auto.\n  by rewrite -size_update.\n  by skip.\nqed.\n\n\n(* if the unionSet has characters from a given set, it means that that set is stil 'available'.\n   this happens if at least one of the sets is 'available'  *)\nlemma unionSet_available\n  (_nLowercase, _nUppercase, _nNumbers, _nSpecial:int)\n  (_lowercaseSet, _uppercaseSet, _numbersSet, _specialSet:charSet) :\nhoare [RPGRef.define_union_set :\n         nLowercase = _nLowercase /\\\n         nUppercase = _nUppercase /\\\n         nNumbers = _nNumbers /\\\n         nSpecial = _nSpecial /\\\n         lowercaseSet = _lowercaseSet /\\\n         uppercaseSet = _uppercaseSet /\\\n         numbersSet = _numbersSet /\\\n         specialSet = _specialSet /\\\n         0 <= _nLowercase /\\\n         0 <= _nUppercase /\\\n         0 <= _nNumbers /\\\n         0 <= _nSpecial /\\\n         0 < size _lowercaseSet /\\\n         0 < size _uppercaseSet /\\\n         0 < size _numbersSet /\\\n         0 < size _specialSet /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _numbersSet => ! (x \\in _specialSet))\n         ==>\n         (0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial => 0 < size res) /\\\n         (has (fun (x) => x \\in res) _lowercaseSet => 0 < _nLowercase) /\\\n         (has (fun (x) => x \\in res) _uppercaseSet => 0 < _nUppercase) /\\\n         (has (fun (x) => x \\in res) _numbersSet => 0 < _nNumbers) /\\\n         (has (fun (x) => x \\in res) _specialSet => 0 < _nSpecial) /\\\n         (forall x, x \\in res => x \\in _lowercaseSet \\/\n                                 x \\in _uppercaseSet\\/\n                                 x \\in _numbersSet \\/\n                                 x \\in _specialSet)].\nproof.\nproc.\nseq 1 : (#pre /\\ unionSet = []).\n  auto.\nif.\n- seq 2 : (nLowercase = _nLowercase /\\\n           nUppercase = _nUppercase /\\\n           nNumbers = _nNumbers /\\\n           nSpecial = _nSpecial /\\\n           lowercaseSet = _lowercaseSet /\\\n           uppercaseSet = _uppercaseSet /\\\n           numbersSet = _numbersSet /\\\n           specialSet = _specialSet /\\\n           0 < size _lowercaseSet /\\\n           0 < size _uppercaseSet /\\\n           0 < size _numbersSet /\\\n           0 < size _specialSet /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n           0 < nLowercase /\\\n           0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n           unionSet = lowercaseSet).\n    auto.\n    move => />.\n    smt(addz_gt0).\n  if.\n  + seq 2 : (nLowercase = _nLowercase /\\\n             nUppercase = _nUppercase /\\\n             nNumbers = _nNumbers /\\\n             nSpecial = _nSpecial /\\\n             lowercaseSet = _lowercaseSet /\\\n             uppercaseSet = _uppercaseSet /\\\n             numbersSet = _numbersSet /\\\n             specialSet = _specialSet /\\\n             0 < size _lowercaseSet /\\\n             0 < size _uppercaseSet /\\\n             0 < size _numbersSet /\\\n             0 < size _specialSet /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n             0 < nLowercase /\\\n             0 < nUppercase /\\\n             0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n             unionSet = lowercaseSet ++ uppercaseSet).\n      auto.\n    if.\n    - seq 2 : (nLowercase = _nLowercase /\\\n               nUppercase = _nUppercase /\\\n               nNumbers = _nNumbers /\\\n               nSpecial = _nSpecial /\\\n               lowercaseSet = _lowercaseSet /\\\n               uppercaseSet = _uppercaseSet /\\\n               numbersSet = _numbersSet /\\\n               specialSet = _specialSet /\\\n               0 < size _lowercaseSet /\\\n               0 < size _uppercaseSet /\\\n               0 < size _numbersSet /\\\n               0 < size _specialSet /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n               0 < nLowercase /\\\n               0 < nUppercase /\\\n               0 < nNumbers /\\\n               0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n               unionSet = lowercaseSet ++ uppercaseSet ++ numbersSet).\n        auto.\n      if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nUppercase /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ uppercaseSet ++ numbersSet ++ specialSet).\n          auto.\n          skip.\n          smt(size_cat addz_gt0 char_cat2).\n      + skip.\n        move => />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n    - if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nUppercase /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ uppercaseSet ++ specialSet).\n          auto.\n          skip.\n          move => />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n       + skip.\n         move => &m />.\n         smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n   + if.\n     - seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nNumbers /\\\n                 !(0 < nUppercase) /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ numbersSet).\n          auto.\n       if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ numbersSet ++ specialSet).\n            auto. \n      + skip.\n        move => &m />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n      skip.\n      move => &m />.\n      smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n     - if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 !(0 < nUppercase) /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ specialSet).\n            auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n       + skip.\n         move => &m />.\n         smt(charset_disjoint_hasnot).\n- if.\n  + seq 2 : (nLowercase = _nLowercase /\\\n             nUppercase = _nUppercase /\\\n             nNumbers = _nNumbers /\\\n             nSpecial = _nSpecial /\\\n             lowercaseSet = _lowercaseSet /\\\n             uppercaseSet = _uppercaseSet /\\\n             numbersSet = _numbersSet /\\\n             specialSet = _specialSet /\\\n             0 < size _lowercaseSet /\\\n             0 < size _uppercaseSet /\\\n             0 < size _numbersSet /\\\n             0 < size _specialSet /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n             !(0 < nLowercase) /\\\n             0 < nUppercase /\\\n             0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n             unionSet = uppercaseSet).\n      auto.\n      move => />.\n      smt(addz_gt0).\n    if.\n    - seq 2 : (nLowercase = _nLowercase /\\\n               nUppercase = _nUppercase /\\\n               nNumbers = _nNumbers /\\\n               nSpecial = _nSpecial /\\\n               lowercaseSet = _lowercaseSet /\\\n               uppercaseSet = _uppercaseSet /\\\n               numbersSet = _numbersSet /\\\n               specialSet = _specialSet /\\\n               0 < size _lowercaseSet /\\\n               0 < size _uppercaseSet /\\\n               0 < size _numbersSet /\\\n               0 < size _specialSet /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n               !(0 < nLowercase) /\\\n               0 < nUppercase /\\\n               0 < nNumbers /\\\n               0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n               unionSet = uppercaseSet ++ numbersSet).\n        auto.\n      if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 0 < nUppercase /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = uppercaseSet ++ numbersSet ++ specialSet).\n          auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n      + skip.\n        move => &m />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n    - if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 0 < nUppercase /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = uppercaseSet ++ specialSet).\n          auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).      \n       + skip.\n         move => &m />.\n         smt(charset_disjoint_hasnot).\n   + if.\n     - seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = numbersSet).\n          auto.\n          move => />.\n          smt(addz_gt0).\n       if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = numbersSet ++ specialSet).\n            auto.\n         skip.\n         move => &m />.\n         smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n      + skip.\n        move => &m />.\n        smt(charset_disjoint_hasnot).\n     - if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = specialSet).\n            auto.\n            move => />.\n            smt(addz_gt0).\n          skip.\n          move => &m />.\n          smt(charset_disjoint_hasnot).\n       + skip.\n         move => />.\n         smt(lezNgt charset_has_empty).\nqed.\n\n\n\n\n\n(*********************************)\n(*          CORRECTNESS          *)\n(*********************************)\n\n\n(* ---------------------------------------------------------------------------- *)\n(* If PCP is satisfiable, RPG Spec satisfies the length defined in the PCP (HL) *)\n(* ---------------------------------------------------------------------------- *)\nlemma rpg_correctness_length_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res)].\nproof.\nproc.\nif.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ size generatedPassword = 0).\n  auto.\nseq 1 : (#[/:]pre /\\ lowercaseAvailable = p.`lowercaseMax).\n  auto.\nseq 1 : (#[/:]pre /\\ uppercaseAvailable = p.`uppercaseMax).\n  auto.\nseq 1 : (#[/:]pre /\\ numbersAvailable = p.`numbersMax).\n  auto.\nseq 1 : (#[/:]pre /\\ specialAvailable = p.`specialMax).\n  auto.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = i /\\ i <= p.`lowercaseMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      move => />.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin + p.`uppercaseMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + i /\\ i <= p.`uppercaseMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      move => />.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + i /\\\n           i <= p.`numbersMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         size generatedPassword =\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + i /\\\n           i <= p.`specialMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (size generatedPassword = p.`length /\\ policy = p).\n  while (size generatedPassword <= p.`length /\\ policy = p).\n  seq 1 : (#pre).\n    inline *.\n    auto.\n    seq 5 : (#pre).\n      auto.\n    while true.\n      auto.\n    skip.\n    move => />.\n  seq 1 : (#pre).\n    if.\n    - seq 1 : (#pre).  \n        auto.\n        if.\n        + inline *.\n          auto.            \n        + skip => /#.\n    - if.\n      - seq 1 : (#pre).\n          auto.\n          if.        \n          + inline *.\n            auto.          \n          + skip => /#.\n      - if.\n        - seq 1 : (#pre).\n            auto.\n            if.\n            + inline *.\n              auto.\n            + skip => /#.\n        - if.\n          - seq 1 : (#pre).\n            auto.\n            if.\n            + inline *.\n              auto.\n            + skip => /# .\n    skip.\n    move => />.\n  auto.\n  move => />.\n  smt(size_cat).\nskip => /#.\nseq 1 : (#pre).\n- ecall (permutation_size generatedPassword).\n  skip => /#.  \nwp.\nskip => /#.\n* \nconseq (_: false ==> _).\nmove => &m /> /#.\ntrivial.\nqed.\n\n\n\n\n(* -------------------------------------------------------------------------------------------- *)\n(* If PCP is satisfiable, RPGSpec satisfies the different set bounds defined in the policy (HL) *)\n(* -------------------------------------------------------------------------------------------- *)\nlemma rpg_correctness_bounds_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesBounds p (oget res)].\nproof.\nproc.\nif.\n*\nseq 1 : (#pre /\\ 0 < size lowercaseSet /\\\n         RPGRef.lowercaseSet = lowercaseSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size uppercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size numbersSet /\\\n         RPGRef.numbersSet = numbersSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size specialSet /\\\n         RPGRef.specialSet = specialSet).\n  inline *.\n  auto.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         size generatedPassword = 0 /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         setOccurrences lowercaseSet generatedPassword = 0 /\\\n         setOccurrences uppercaseSet generatedPassword = 0 /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0).\n  auto.\n  move => &m /> *.\n  rewrite /lowercaseSet /uppercaseSet /numbersSet /specialSet.\n  do! split.\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\nseq 1 : (#pre /\\\n         lowercaseAvailable = p.`lowercaseMax /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         numbersAvailable = p.`numbersMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         specialAvailable = p.`specialMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 0 : (#pre /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword).\n  auto.\n  move => &m /> h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17.\n  by rewrite h17 /=.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = 0 /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable = p.`lowercaseMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = i /\\\n           setOccurrences uppercaseSet generatedPassword = 0 /\\\n           setOccurrences numbersSet generatedPassword = 0 /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`lowercaseMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable = (p.`lowercaseMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = i /\\\n               setOccurrences uppercaseSet generatedPassword = 0 /\\\n               setOccurrences numbersSet generatedPassword = 0 /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`lowercaseMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in lowercaseSet /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in numbersSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has lowercaseSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable = p.`uppercaseMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = i /\\\n           setOccurrences numbersSet generatedPassword = 0 /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`uppercaseMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable = (p.`uppercaseMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = i /\\\n               setOccurrences numbersSet generatedPassword = 0 /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`uppercaseMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in uppercaseSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in numbersSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has uppercaseSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable <= p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable <= p.`uppercaseMax /\\\n           numbersAvailable = p.`numbersMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n           setOccurrences numbersSet generatedPassword = i /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`numbersMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable <= p.`uppercaseMax /\\\n               numbersAvailable = (p.`numbersMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n               setOccurrences numbersSet generatedPassword = i /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`numbersMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in numbersSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has numbersSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable <= p.`numbersMax /\\\n         specialAvailable <= p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n         setOccurrences specialSet generatedPassword = p.`specialMin /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable <= p.`uppercaseMax /\\\n           numbersAvailable <= p.`numbersMax /\\\n           specialAvailable = p.`specialMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n           setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n           setOccurrences specialSet generatedPassword = i /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`specialMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable <= p.`uppercaseMax /\\\n               numbersAvailable <= p.`numbersMax /\\\n               specialAvailable = (p.`specialMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n               setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n               setOccurrences specialSet generatedPassword = i /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                 p.`specialMax /\\\n               i < policy.`specialMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in specialSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in numbersSet)).\n        ecall (random_char_generator_has specialSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (#pre /\\\n         (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable =>\n            0 < size unionSet) /\\\n         (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n         (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n         (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n         (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n         (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                      x \\in uppercaseSet \\/\n                                      x \\in numbersSet \\/\n                                      x \\in specialSet)).\n  ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                             specialAvailable lowercaseSet uppercaseSet\n                             numbersSet specialSet).\n  skip.\n  move => &m /> *.\n  do! split.\n  - smt().\n  - smt().\n  - smt().\n  - smt().\nseq 1 : (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax).\nwhile (policy = p /\\\n       p.`lowercaseMin <= p.`lowercaseMax /\\\n       p.`uppercaseMin <= p.`uppercaseMax /\\\n       p.`numbersMin <= p.`numbersMax /\\\n       p.`specialMin <= p.`specialMax /\\\n       RPGRef.lowercaseSet = lowercaseSet /\\\n       RPGRef.uppercaseSet = uppercaseSet /\\\n       RPGRef.numbersSet = numbersSet /\\\n       RPGRef.specialSet = specialSet /\\\n       0 < size lowercaseSet /\\\n       0 < size uppercaseSet /\\\n       0 < size numbersSet /\\\n       0 < size specialSet /\\\n       (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n       (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n       (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n       (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n       (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n       (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n       0 <= lowercaseAvailable /\\\n       0 <= uppercaseAvailable/\\\n       0 <= numbersAvailable /\\\n       0 <= specialAvailable /\\\n       (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n         => 0 < size unionSet) /\\\n       (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n       (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n       (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n       (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n       (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                    x \\in uppercaseSet \\/\n                                    x \\in numbersSet \\/\n                                    x \\in specialSet) /\\\n       p.`length <=\n         (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n         size generatedPassword /\\\n       setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n         p.`lowercaseMax /\\\n       setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n         p.`uppercaseMax /\\\n       setOccurrences numbersSet generatedPassword + numbersAvailable =\n         p.`numbersMax /\\\n       setOccurrences specialSet generatedPassword + specialAvailable =\n         p.`specialMax /\\\n       p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n       p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n       p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n       p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n       setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n       setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n       setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n       setOccurrences specialSet generatedPassword <= p.`specialMax).\n- seq 0 : (#pre /\\\n           0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable).\n    skip.\n    move => &m />.\n    smt(@Number).\n  seq 1 : (#pre /\\ randomChar \\in unionSet).\n    ecall (random_char_generator_has unionSet).\n    skip.\n    move => &m />.    \n  if.\n  + seq 2 : (policy = p /\\\n             randomChar \\in lowercaseSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < lowercaseAvailable).\n      - seq 1 : (policy = p /\\\n                 randomChar \\in lowercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 < lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n               (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n               (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n               (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m /> *.\n          smt(char_charset_size).\n        if.\n        + conseq (_ : false ==> _).\n          smt().\n          auto.\n        + skip => /#.\n      - seq 1 : (policy = p /\\\n                 randomChar \\in lowercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 = lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n               (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n               (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n               (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m /> *.\n          smt(charset_mem_has).\n      if.\n      + ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      + by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n+ if.\n  - seq 2 : (policy = p /\\\n             randomChar \\in uppercaseSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < uppercaseAvailable).\n      + seq 1 : (policy = p /\\\n                 randomChar \\in uppercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 < uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        - conseq (_ : false ==> _).\n          smt().\n          auto.\n        - skip => /#.\n      + seq 1 : (policy = p /\\\n                 randomChar \\in uppercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 = uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      - ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      - by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n- if.\n  + seq 2 : (policy = p /\\\n             randomChar \\in numbersSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < numbersAvailable).\n      - seq 1 : (policy = p /\\\n                 randomChar \\in numbersSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 < numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        + conseq (_ : false ==> _).\n          smt().\n          auto.\n        + skip => /#.\n      - seq 1 : (policy = p /\\\n                 randomChar \\in numbersSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 = numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      + ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      + by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n+ if.\n  - seq 2 : (policy = p /\\\n             randomChar \\in specialSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < specialAvailable).\n      + seq 1 : (policy = p /\\\n                 randomChar \\in specialSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 < specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        - conseq (_ : false ==> _).\n          smt().\n          auto.\n        - skip => /#.\n      + seq 1 : (policy = p /\\\n                 randomChar \\in specialSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 = specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      - ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      - by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\nconseq (_: false ==> _).\n  + move => &m />.\n    smt().\n  + auto.\n- skip.\n  move => &m />.\n  smt().\ninline RPGRef.permutation.\nseq 2 : (#pre /\\\n         i0 = size pw /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\nauto.\nseq 1 : (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\n  while (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax /\\\n         i0 <= size pw /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\n  - seq 1 : (#pre /\\ j < i0 /\\ 0 <= j).\n      ecall (rng_range i0).\n      skip => /#.\n    auto.\n    move => &m /> *.\n    split.\n    rewrite -size_update.\n    rewrite -size_update.\n    smt(@Number).\n    do! split.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n  - by skip.\nauto.\nmove => &m /> h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12.\ndo! split.\n- by rewrite -h9.\n- by rewrite -h9.\n- by rewrite -h10.\n- by rewrite -h10.\n- by rewrite -h11.\n- by rewrite -h11.\n- by rewrite -h12.\n- by rewrite -h12.\nconseq (_: false ==> _).\nmove => &m /> /#.\ntrivial.\nqed.\n\n\n\n\n(* ------------------------------------------------------------------------------------------ *)\n(* If PCP is satisfiable, RPGSpec satisfies both the length and the bounds defined in the PCP *)\n(* ------------------------------------------------------------------------------------------ *)\nlemma rpg_correctness_sat_pcp_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res) /\\ satisfiesBounds p (oget res)].\nproof.\nhave length_proof : (hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res)]).\nexact rpg_correctness_length_hl.\nhave bounds_proof : (hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesBounds p (oget res)]).\nexact rpg_correctness_bounds_hl.\nconseq length_proof bounds_proof.\nmove => &m h1.\nsplit.\nassumption.\nassumption.\nmove => &m />.\nqed.\n\n\n\n\n(* --------------------------------------------- *)\n(* If PCP is unsatisfiable, RPGSpec returns None *)\n(* --------------------------------------------- *)\nlemma rpg_correctness_unsat_pcp_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ !(satisfiablePolicy p)\n         ==> res = None].\nproof.\nproc.\nif.\n* conseq (_: false ==> _).\n  move => &m /> /#.\n  trivial.\n* by wp.\nqed.\n\n\n(* ------------------------- *)\n(* RPGSpec always terminates *)\n(* ------------------------- *)\nlemma rpg_ll :\n  islossless RPGRef.generate_password.\nproof.\nproc.\nislossless.\n  while true i.\n  - move => z.\n    seq 1 : (#pre).\n      auto.\n      call rng_ll.\n      auto.\n    auto.\n    smt().\n    hoare.\n    inline *.\n    auto.\n    seq 4 : (#pre).   \n    auto.\n    while true.\n    - auto.  \n    - skip.\n      smt().\n    smt().\n    skip.\n    smt().\n  while true (policy.`length - size generatedPassword).\n  - auto.\n    inline RPGRef.random_char_generator.\n    sp.\n    seq 1 : (#pre).\n      auto.\n      call rng_ll.\n      skip.\n      smt().\n    inline *.\n    auto.\n    move => &m /> *.\n    rewrite size_cat /=.\n    smt(@Number).\n    hoare.\n    inline *.\n    auto.\n    seq 4 : (#pre).    \n      auto.\n    while true.\n    - auto.\n    - skip.\n      smt().\n    smt().\n    skip => /#.\n  while true (policy.`specialMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt().\n  - skip => /#.\n  while true (policy.`numbersMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\n  while true (policy.`uppercaseMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\n  while true (policy.`lowercaseMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\nqed.\n\n\n\n(* ------------------ *)\n(* RPGSpec is correct *)\n(* ------------------ *)\nlemma rpg_correctness &m (p:policy) :\n  Pr[Correctness(RPGRef).main(p) @ &m : res] = 1%r.\nproof.\nbyphoare (_: policy = p ==> _).\nhave c_lossless: islossless Correctness(RPGRef).main.\n- proc.\n  wp.\n  call rpg_ll.\n  trivial.\nhave c_correct: hoare[Correctness(RPGRef).main : policy = p ==> res].\n- proc.\n  case (satisfiablePolicy policy).\n  + seq 1 : (#pre /\\\n             is_some pw /\\\n             satisfiesLength policy (oget pw) /\\\n             satisfiesBounds policy (oget pw)).\n    * call (rpg_correctness_sat_pcp_hl p).\n      skip => /#.\n    if.\n    * wp.\n      skip => /#.\n    * conseq (_: false ==> _).\n      smt().\n      trivial.\n  + seq 1 : (#pre /\\ is_none pw).\n    * call (rpg_correctness_unsat_pcp_hl p).\n      skip => /#.\n    if.\n    * conseq (_: false ==> _).\n      smt().\n      trivial.\n    * wp.\n      skip => /#.\nby conseq c_lossless c_correct.\nreflexivity.\ntrivial.\nqed.\n\n\n\n(*******************************)\n(*          SECURITY           *)\n(*******************************)\n\nlemma rng_uniform  :\n  equiv [RPGRef.rng ~ Test.uniformRangeDistr : ={range} ==> ={res}].\nproof.\nproc.\nadmitted.\n\n\nlemma rpg_security :\n  equiv [IdealRPG.generate_password ~ RPGRef.generate_password : ={policy} ==> ={res}].\nproof.\nproc.\nadmitted.",
        "complete:": "require import AllCore IntDiv DInterval List UpdateList.\nrequire (****) RPGTh.\n\nclone include RPGTh.\n\nmodule RPGRef : RPG_T = {\n\n  var lowercaseSet, uppercaseSet, numbersSet, specialSet : charSet\n\n  proc rng(range:int) : int = {\n    \n    var value, maxValue, modValue : int;\n\n    (* check how much we should remove from 2^64 - 1 in order to get a multiple of range *)\n    modValue <- (2^64 - 1) %% range;\n\n    (* if the mod is range - 1, it means we can sample from 2^64 - 1 and have an uniform distribution *)\n    if(modValue = range - 1) {\n      maxValue <- (2^64 - 1);\n    (* else, we need to remove the unnecessary values*)\n    } else {\n      maxValue <- (2^64 - 1) - modValue - 1;\n    }\n\n    value <$ [0 .. (2^64 - 1)];\n\n    while (maxValue < value) {\n      value <$ [0 .. (2^64 - 1)]; (* Random Bytes Generator *)\n    }\n    \n    value <- value %% range;\n    \n    return value;\n    \n  }\n\n  \n  proc random_char_generator(set:charSet) : char = {\n    \n    var char : char;\n    var choice : int;\n    \n    choice <@ rng(size set);\n    char <- nth (-1) set choice;\n    \n    return (char);\n    \n  }\n\n  \n  proc permutation(pw:password) : password = {\n\n    var i : int;\n    var j : int;\n    var aux : char;\n    \n    i <- size pw;\n    \n    while (0 < i) {\n      j <@ rng(i);\n      i <- i - 1;\n      aux <- nth 0 pw i;\n      pw <- update (nth 0 pw j) pw i;\n      pw <- update aux pw j;\n    }\n    \n    return pw;\n \n  }\n\n\n  proc get_lowercaseSet() : charSet = {\n    \n    var set : charSet;\n    set <- [97; 98; 99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111; 112;\n           113; 114; 115; 116; 117; 118; 119; 120; 121; 122];\n    return set;\n\n  }\n\n\n  proc get_uppercaseSet() : charSet = {\n    \n    var set : charSet;\n    set <- [65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85;\n           86; 87; 88; 89; 90];\n    return set;\n\n  }\n\n\n  proc get_numbersSet() : charSet = {\n\n    var set : charSet;\n    set <- [48; 49; 50; 51; 52; 53; 54; 55; 56; 57];\n    return set;\n\n  }\n\n\n  proc get_specialSet() : charSet = {\n    \n    var set : charSet;\n    set <- [33; 63; 35; 36; 37; 38; 43; 45; 42; 95; 64; 58; 59; 61];\n    return set;\n\n  }\n\n\n  proc define_union_set(nLowercase:int, nUppercase:int, nNumbers:int, nSpecial:int,\n                        lowercaseSet:charSet, uppercaseSet:charSet,\n                        numbersSet:charSet, specialSet:charSet) : charSet = {\n\n    var unionSet, set : charSet;\n\n    unionSet <- [];\n    \n    if (0 < nLowercase) {\n      set <- lowercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nUppercase) {\n      set <- uppercaseSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nNumbers) {\n      set <- numbersSet;\n      unionSet <- unionSet ++ set;\n    }\n    if (0 < nSpecial) {\n      set <- specialSet;\n      unionSet <- unionSet ++ set;\n    }\n\n    return unionSet;    \n\n  }\n\n  \n  proc generate_password(policy:policy) : password option = {\n\n    var outputPassword : password option;\n    var generatedPassword : password;\n    var unionSet : charSet;\n    var randomChar : char;\n    var i : int;\n    var lowercaseAvailable, uppercaseAvailable, numbersAvailable, specialAvailable : int;\n\n    (* ---------------------------------------------- *)\n    (* If policy is satisfiable, return Some password *)\n    (* ---------------------------------------------- *)\n    if(satisfiablePolicy policy) {\n\n      (* initializer sets *)\n      lowercaseSet <@ get_lowercaseSet();\n      uppercaseSet <@ get_uppercaseSet();\n      numbersSet <@ get_numbersSet();\n      specialSet <@ get_specialSet();\n\n      (* initialize random password *)\n      generatedPassword <- [];\n    \n      (* check which sets are available to generate characters from (max > 0) *)\n\n      lowercaseAvailable <- policy.`lowercaseMax;\n      uppercaseAvailable <- policy.`uppercaseMax;\n      numbersAvailable <- policy.`numbersMax;\n      specialAvailable <- policy.`specialMax;\n\n      (* generate characters with min values defined *)     \n \n      if (0 < lowercaseAvailable) {\n        i <- 0;\n        while (i < policy.`lowercaseMin) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          randomChar <@ random_char_generator(lowercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < uppercaseAvailable) {\n        i <- 0;\n        while (i < policy.`uppercaseMin) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          randomChar <@ random_char_generator(uppercaseSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < numbersAvailable) {\n        i <- 0;\n        while (i < policy.`numbersMin) {\n          numbersAvailable <- numbersAvailable - 1;\n          randomChar <@ random_char_generator(numbersSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n      if (0 < specialAvailable) {\n        i <- 0;\n        while (i < policy.`specialMin) {\n          specialAvailable <- specialAvailable - 1;\n          randomChar <@ random_char_generator(specialSet);\n          generatedPassword <- generatedPassword ++ [randomChar];\n          i <- i + 1;\n        }\n      }\n\n      (* generate characters from the available sets of characters *)\n\n      unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                   specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                   specialSet);\n\n      while (size generatedPassword < policy.`length) {\n\n        randomChar <@ random_char_generator(unionSet);\n\n        if (randomChar \\in lowercaseSet) {\n          lowercaseAvailable <- lowercaseAvailable - 1;\n          if (lowercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in uppercaseSet) {\n          uppercaseAvailable <- uppercaseAvailable - 1;\n          if (uppercaseAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in numbersSet) {\n          numbersAvailable <- numbersAvailable - 1;\n          if (numbersAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n        elif (randomChar \\in specialSet) {\n          specialAvailable <- specialAvailable - 1;\n          if (specialAvailable = 0) {\n            unionSet <@ define_union_set(lowercaseAvailable, uppercaseAvailable, numbersAvailable,\n                                         specialAvailable, lowercaseSet, uppercaseSet, numbersSet,\n                                         specialSet);\n          }\n        }\n\n        generatedPassword <- generatedPassword ++ [randomChar];\n\n      }\n\n        generatedPassword <@ permutation(generatedPassword);\n   \n        outputPassword <- Some generatedPassword;\n\n    }\n\n    (* --------------------------------------- *)\n    (* If policy is unsatisfiable, return None *)\n    (* --------------------------------------- *)\n    else {\n\n      outputPassword <- None;\n\n    }\n\n    return outputPassword;\n    \n  }\n  \n}.\n\n\n\n(**********************************)\n(*        AUXILIARY LEMMAS        *)\n(**********************************)\n\n(* axiom -> rng always terminates *)\naxiom rng_ll : islossless RPGRef.rng.\n\n\n(* output of rng is smaller than range *)\nlemma rng_range _range :\n  hoare [RPGRef.rng : range = _range /\\ 0 < _range ==> 0 <= res /\\ res < _range].\nproof.\nproc.\nsp.\nseq 1 : (#pre /\\ 0 <= value).\n  auto.\n  move => &m /> h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nwp.\nwhile (0 <= value).\n  auto.\n  move => &m h1 val d.\n  rewrite supp_dinter in d.\n  by case d.\nskip.\nmove => &m /> h1 h2 value0 h3 h4.\nsplit.\n- by apply modn_ge0. \n- have h5 : range{m} = _range.\n  + smt().\n  have h6 : 0 < _range.\n  + smt().\n  by rewrite h5 ltz_pmod.\nqed.\n\n\n(* input set given to random char generator has the generated char *)\nlemma random_char_generator_has _set :\n  hoare [RPGRef.random_char_generator : set = _set /\\ 0 < size _set ==> res \\in _set].\nproof.\nproc.\nauto.\nseq 1 : (set = _set /\\ 0 <= choice /\\ choice < size set).\n  ecall (rng_range (size set)).\n  auto.\nauto.\nmove => &m [h1 h2].\nby rewrite -h1 mem_nth andaE.\nqed.\n\n\n(* permutation of a password does not change its size*)\nlemma permutation_size input :\n  hoare [RPGRef.permutation : pw = input ==> size res = size input].\nproof.\nproc.\nseq 1 : (size pw = size input).\n  auto.\nwhile (size pw = size input).\n  seq 1 : (size pw = size input).\n    ecall (rng_range i).\n    skip.\n    move => />.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n  seq 1 : (size pw = size input).\n    auto.\n    move => &m /> h1.\n    by rewrite -size_update.\n  auto.\n  by rewrite -size_update.\n  by skip.\nqed.\n\n\n(* if the unionSet has characters from a given set, it means that that set is stil 'available'.\n   this happens if at least one of the sets is 'available'  *)\nlemma unionSet_available\n  (_nLowercase, _nUppercase, _nNumbers, _nSpecial:int)\n  (_lowercaseSet, _uppercaseSet, _numbersSet, _specialSet:charSet) :\nhoare [RPGRef.define_union_set :\n         nLowercase = _nLowercase /\\\n         nUppercase = _nUppercase /\\\n         nNumbers = _nNumbers /\\\n         nSpecial = _nSpecial /\\\n         lowercaseSet = _lowercaseSet /\\\n         uppercaseSet = _uppercaseSet /\\\n         numbersSet = _numbersSet /\\\n         specialSet = _specialSet /\\\n         0 <= _nLowercase /\\\n         0 <= _nUppercase /\\\n         0 <= _nNumbers /\\\n         0 <= _nSpecial /\\\n         0 < size _lowercaseSet /\\\n         0 < size _uppercaseSet /\\\n         0 < size _numbersSet /\\\n         0 < size _specialSet /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n         (forall (x : int),\n           x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n         (forall (x : int),\n           x \\in _numbersSet => ! (x \\in _specialSet))\n         ==>\n         (0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial => 0 < size res) /\\\n         (has (fun (x) => x \\in res) _lowercaseSet => 0 < _nLowercase) /\\\n         (has (fun (x) => x \\in res) _uppercaseSet => 0 < _nUppercase) /\\\n         (has (fun (x) => x \\in res) _numbersSet => 0 < _nNumbers) /\\\n         (has (fun (x) => x \\in res) _specialSet => 0 < _nSpecial) /\\\n         (forall x, x \\in res => x \\in _lowercaseSet \\/\n                                 x \\in _uppercaseSet\\/\n                                 x \\in _numbersSet \\/\n                                 x \\in _specialSet)].\nproof.\nproc.\nseq 1 : (#pre /\\ unionSet = []).\n  auto.\nif.\n- seq 2 : (nLowercase = _nLowercase /\\\n           nUppercase = _nUppercase /\\\n           nNumbers = _nNumbers /\\\n           nSpecial = _nSpecial /\\\n           lowercaseSet = _lowercaseSet /\\\n           uppercaseSet = _uppercaseSet /\\\n           numbersSet = _numbersSet /\\\n           specialSet = _specialSet /\\\n           0 < size _lowercaseSet /\\\n           0 < size _uppercaseSet /\\\n           0 < size _numbersSet /\\\n           0 < size _specialSet /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n           (forall (x : int),\n             x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n           (forall (x : int),\n             x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n           0 < nLowercase /\\\n           0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n           unionSet = lowercaseSet).\n    auto.\n    move => />.\n    smt(addz_gt0).\n  if.\n  + seq 2 : (nLowercase = _nLowercase /\\\n             nUppercase = _nUppercase /\\\n             nNumbers = _nNumbers /\\\n             nSpecial = _nSpecial /\\\n             lowercaseSet = _lowercaseSet /\\\n             uppercaseSet = _uppercaseSet /\\\n             numbersSet = _numbersSet /\\\n             specialSet = _specialSet /\\\n             0 < size _lowercaseSet /\\\n             0 < size _uppercaseSet /\\\n             0 < size _numbersSet /\\\n             0 < size _specialSet /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n             0 < nLowercase /\\\n             0 < nUppercase /\\\n             0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n             unionSet = lowercaseSet ++ uppercaseSet).\n      auto.\n    if.\n    - seq 2 : (nLowercase = _nLowercase /\\\n               nUppercase = _nUppercase /\\\n               nNumbers = _nNumbers /\\\n               nSpecial = _nSpecial /\\\n               lowercaseSet = _lowercaseSet /\\\n               uppercaseSet = _uppercaseSet /\\\n               numbersSet = _numbersSet /\\\n               specialSet = _specialSet /\\\n               0 < size _lowercaseSet /\\\n               0 < size _uppercaseSet /\\\n               0 < size _numbersSet /\\\n               0 < size _specialSet /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n               0 < nLowercase /\\\n               0 < nUppercase /\\\n               0 < nNumbers /\\\n               0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n               unionSet = lowercaseSet ++ uppercaseSet ++ numbersSet).\n        auto.\n      if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nUppercase /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ uppercaseSet ++ numbersSet ++ specialSet).\n          auto.\n          skip.\n          smt(size_cat addz_gt0 char_cat2).\n      + skip.\n        move => />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n    - if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nUppercase /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ uppercaseSet ++ specialSet).\n          auto.\n          skip.\n          move => />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n       + skip.\n         move => &m />.\n         smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n   + if.\n     - seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 0 < nNumbers /\\\n                 !(0 < nUppercase) /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ numbersSet).\n          auto.\n       if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ numbersSet ++ specialSet).\n            auto. \n      + skip.\n        move => &m />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n      skip.\n      move => &m />.\n      smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n     - if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 0 < nLowercase /\\\n                 !(0 < nUppercase) /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = lowercaseSet ++ specialSet).\n            auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n       + skip.\n         move => &m />.\n         smt(charset_disjoint_hasnot).\n- if.\n  + seq 2 : (nLowercase = _nLowercase /\\\n             nUppercase = _nUppercase /\\\n             nNumbers = _nNumbers /\\\n             nSpecial = _nSpecial /\\\n             lowercaseSet = _lowercaseSet /\\\n             uppercaseSet = _uppercaseSet /\\\n             numbersSet = _numbersSet /\\\n             specialSet = _specialSet /\\\n             0 < size _lowercaseSet /\\\n             0 < size _uppercaseSet /\\\n             0 < size _numbersSet /\\\n             0 < size _specialSet /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n             (forall (x : int),\n               x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n             (forall (x : int),\n               x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n             !(0 < nLowercase) /\\\n             0 < nUppercase /\\\n             0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n             unionSet = uppercaseSet).\n      auto.\n      move => />.\n      smt(addz_gt0).\n    if.\n    - seq 2 : (nLowercase = _nLowercase /\\\n               nUppercase = _nUppercase /\\\n               nNumbers = _nNumbers /\\\n               nSpecial = _nSpecial /\\\n               lowercaseSet = _lowercaseSet /\\\n               uppercaseSet = _uppercaseSet /\\\n               numbersSet = _numbersSet /\\\n               specialSet = _specialSet /\\\n               0 < size _lowercaseSet /\\\n               0 < size _uppercaseSet /\\\n               0 < size _numbersSet /\\\n               0 < size _specialSet /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n               (forall (x : int),\n                 x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n               (forall (x : int),\n                 x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n               !(0 < nLowercase) /\\\n               0 < nUppercase /\\\n               0 < nNumbers /\\\n               0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n               unionSet = uppercaseSet ++ numbersSet).\n        auto.\n      if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 0 < nUppercase /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = uppercaseSet ++ numbersSet ++ specialSet).\n          auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat3).\n      + skip.\n        move => &m />.\n        smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n    - if.\n      + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 0 < nUppercase /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = uppercaseSet ++ specialSet).\n          auto.\n          skip.\n          move => &m />.\n          smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).      \n       + skip.\n         move => &m />.\n         smt(charset_disjoint_hasnot).\n   + if.\n     - seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = numbersSet).\n          auto.\n          move => />.\n          smt(addz_gt0).\n       if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 0 < nNumbers /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = numbersSet ++ specialSet).\n            auto.\n         skip.\n         move => &m />.\n         smt(size_cat addz_gt0 disjoint_cat charset_disjoint_hasnot char_cat2).\n      + skip.\n        move => &m />.\n        smt(charset_disjoint_hasnot).\n     - if.\n       + seq 2 : (nLowercase = _nLowercase /\\\n                 nUppercase = _nUppercase /\\\n                 nNumbers = _nNumbers /\\\n                 nSpecial = _nSpecial /\\\n                 lowercaseSet = _lowercaseSet /\\\n                 uppercaseSet = _uppercaseSet /\\\n                 numbersSet = _numbersSet /\\\n                 specialSet = _specialSet /\\\n                 0 < size _lowercaseSet /\\\n                 0 < size _uppercaseSet /\\\n                 0 < size _numbersSet /\\\n                 0 < size _specialSet /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _uppercaseSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _lowercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _numbersSet)) /\\\n                 (forall (x : int),\n                   x \\in _uppercaseSet => ! (x \\in _specialSet)) /\\\n                 (forall (x : int),\n                   x \\in _numbersSet => ! (x \\in _specialSet)) /\\\n                 !(0 < nLowercase) /\\\n                 !(0 < nUppercase) /\\\n                 !(0 < nNumbers) /\\\n                 0 < nSpecial /\\\n                 0 < _nLowercase + _nUppercase + _nNumbers + _nSpecial /\\\n                 unionSet = specialSet).\n            auto.\n            move => />.\n            smt(addz_gt0).\n          skip.\n          move => &m />.\n          smt(charset_disjoint_hasnot).\n       + skip.\n         move => />.\n         smt(lezNgt charset_has_empty).\nqed.\n\n\n\n\n\n(*********************************)\n(*          CORRECTNESS          *)\n(*********************************)\n\n\n(* ---------------------------------------------------------------------------- *)\n(* If PCP is satisfiable, RPG Spec satisfies the length defined in the PCP (HL) *)\n(* ---------------------------------------------------------------------------- *)\nlemma rpg_correctness_length_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res)].\nproof.\nproc.\nif.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ size generatedPassword = 0).\n  auto.\nseq 1 : (#[/:]pre /\\ lowercaseAvailable = p.`lowercaseMax).\n  auto.\nseq 1 : (#[/:]pre /\\ uppercaseAvailable = p.`uppercaseMax).\n  auto.\nseq 1 : (#[/:]pre /\\ numbersAvailable = p.`numbersMax).\n  auto.\nseq 1 : (#[/:]pre /\\ specialAvailable = p.`specialMax).\n  auto.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = i /\\ i <= p.`lowercaseMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      move => />.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin + p.`uppercaseMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + i /\\ i <= p.`uppercaseMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      move => />.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         specialAvailable = p.`specialMax /\\\n         size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + i /\\\n           i <= p.`numbersMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\\n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         size generatedPassword =\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (size generatedPassword = p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + i /\\\n           i <= p.`specialMin /\\ policy = p).\n      seq 1 : (#pre).\n        auto.\n      seq 1 : (#pre).\n        inline *.\n        auto.\n        seq 5 : (#pre).\n          auto.\n        while true.\n          auto.\n        skip.\n        move => />.\n      auto.\n      smt(size_cat).\n      skip => /#.\n  - skip => /#.\nseq 1 : (#pre).\n  inline *.\n  auto.\nseq 1 : (size generatedPassword = p.`length /\\ policy = p).\n  while (size generatedPassword <= p.`length /\\ policy = p).\n  seq 1 : (#pre).\n    inline *.\n    auto.\n    seq 5 : (#pre).\n      auto.\n    while true.\n      auto.\n    skip.\n    move => />.\n  seq 1 : (#pre).\n    if.\n    - seq 1 : (#pre).  \n        auto.\n        if.\n        + inline *.\n          auto.            \n        + skip => /#.\n    - if.\n      - seq 1 : (#pre).\n          auto.\n          if.        \n          + inline *.\n            auto.          \n          + skip => /#.\n      - if.\n        - seq 1 : (#pre).\n            auto.\n            if.\n            + inline *.\n              auto.\n            + skip => /#.\n        - if.\n          - seq 1 : (#pre).\n            auto.\n            if.\n            + inline *.\n              auto.\n            + skip => /# .\n    skip.\n    move => />.\n  auto.\n  move => />.\n  smt(size_cat).\nskip => /#.\nseq 1 : (#pre).\n- ecall (permutation_size generatedPassword).\n  skip => /#.  \nwp.\nskip => /#.\n* \nconseq (_: false ==> _).\nmove => &m /> /#.\ntrivial.\nqed.\n\n\n\n\n(* -------------------------------------------------------------------------------------------- *)\n(* If PCP is satisfiable, RPGSpec satisfies the different set bounds defined in the policy (HL) *)\n(* -------------------------------------------------------------------------------------------- *)\nlemma rpg_correctness_bounds_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesBounds p (oget res)].\nproof.\nproc.\nif.\n*\nseq 1 : (#pre /\\ 0 < size lowercaseSet /\\\n         RPGRef.lowercaseSet = lowercaseSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size uppercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size numbersSet /\\\n         RPGRef.numbersSet = numbersSet).\n  inline *.\n  auto.\nseq 1 : (#pre /\\ 0 < size specialSet /\\\n         RPGRef.specialSet = specialSet).\n  inline *.\n  auto.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         size generatedPassword = 0 /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         setOccurrences lowercaseSet generatedPassword = 0 /\\\n         setOccurrences uppercaseSet generatedPassword = 0 /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0).\n  auto.\n  move => &m /> *.\n  rewrite /lowercaseSet /uppercaseSet /numbersSet /specialSet.\n  do! split.\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\n  - smt().\nseq 1 : (#pre /\\\n         lowercaseAvailable = p.`lowercaseMax /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         numbersAvailable = p.`numbersMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 1 : (#pre /\\\n         specialAvailable = p.`specialMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  auto.\n  move => &m /> *.\n  by ring.\nseq 0 : (#pre /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword).\n  auto.\n  move => &m /> h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17.\n  by rewrite h17 /=.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable = p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = 0 /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable = p.`lowercaseMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = i /\\\n           setOccurrences uppercaseSet generatedPassword = 0 /\\\n           setOccurrences numbersSet generatedPassword = 0 /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`lowercaseMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable = (p.`lowercaseMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = i /\\\n               setOccurrences uppercaseSet generatedPassword = 0 /\\\n               setOccurrences numbersSet generatedPassword = 0 /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`lowercaseMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in lowercaseSet /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in numbersSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has lowercaseSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable = p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = 0 /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable = p.`uppercaseMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = i /\\\n           setOccurrences numbersSet generatedPassword = 0 /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`uppercaseMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable = (p.`uppercaseMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = i /\\\n               setOccurrences numbersSet generatedPassword = 0 /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`uppercaseMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in uppercaseSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in numbersSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has uppercaseSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable <= p.`numbersMax /\\\n         specialAvailable = p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n         setOccurrences specialSet generatedPassword = 0 /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable <= p.`uppercaseMax /\\\n           numbersAvailable = p.`numbersMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n           setOccurrences numbersSet generatedPassword = i /\\\n           setOccurrences specialSet generatedPassword = 0 /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`numbersMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable <= p.`uppercaseMax /\\\n               numbersAvailable = (p.`numbersMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n               setOccurrences numbersSet generatedPassword = i /\\\n               setOccurrences specialSet generatedPassword = 0 /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable =\n                 p.`specialMax /\\\n               i < policy.`numbersMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in numbersSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in specialSet)).\n        ecall (random_char_generator_has numbersSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (policy = p /\\\n         p.`length <= 200 /\\\n         0 < p.`length /\\ \n         0 <= p.`lowercaseMin /\\\n         0 <= p.`uppercaseMin /\\\n         0 <= p.`numbersMin /\\\n         0 <= p.`specialMin /\\\n         0 <= p.`lowercaseMax /\\\n         0 <= p.`uppercaseMax /\\\n         0 <= p.`numbersMax /\\\n         0 <= p.`specialMax /\\\n         p.`lowercaseMin <= p.`lowercaseMax /\\\n         p.`uppercaseMin <= p.`uppercaseMax /\\\n         p.`numbersMin <= p.`numbersMax /\\\n         p.`specialMin <= p.`specialMax /\\\n         p.`lowercaseMin + p.`uppercaseMin + p.`numbersMin + p.`specialMin <= p.`length /\\\n         p.`length <= p.`lowercaseMax + p.`uppercaseMax + p.`numbersMax + p.`specialMax /\\\n         RPGRef.lowercaseSet = lowercaseSet /\\\n         RPGRef.uppercaseSet = uppercaseSet /\\\n         RPGRef.numbersSet = numbersSet /\\\n         RPGRef.specialSet = specialSet /\\\n         0 < size lowercaseSet /\\\n         0 < size uppercaseSet /\\\n         0 < size numbersSet /\\\n         0 < size specialSet /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n         (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n         (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n         lowercaseAvailable <= p.`lowercaseMax /\\\n         uppercaseAvailable <= p.`uppercaseMax /\\\n         numbersAvailable <= p.`numbersMax /\\\n         specialAvailable <= p.`specialMax /\\\n         p.`length <=\n           (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n           size generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n         setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n         setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n         setOccurrences specialSet generatedPassword = p.`specialMin /\\\n         setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n           p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n           p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword + numbersAvailable =\n           p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword + specialAvailable =\n           p.`specialMax).\n  if.\n  - seq 1 : (#pre /\\ i = 0).\n      auto.\n    while (policy = p /\\\n           RPGRef.lowercaseSet = lowercaseSet /\\\n           RPGRef.uppercaseSet = uppercaseSet /\\\n           RPGRef.numbersSet = numbersSet /\\\n           RPGRef.specialSet = specialSet /\\\n           0 < size lowercaseSet /\\\n           0 < size uppercaseSet /\\\n           0 < size numbersSet /\\\n           0 < size specialSet /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n           (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n           (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n           lowercaseAvailable <= p.`lowercaseMax /\\\n           uppercaseAvailable <= p.`uppercaseMax /\\\n           numbersAvailable <= p.`numbersMax /\\\n           specialAvailable = p.`specialMax - i /\\\n           p.`length <=\n             (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n             size generatedPassword /\\\n           setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n           setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n           setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n           setOccurrences specialSet generatedPassword = i /\\\n           setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n             p.`lowercaseMax /\\\n           setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n             p.`uppercaseMax /\\\n           setOccurrences numbersSet generatedPassword + numbersAvailable =\n             p.`numbersMax /\\\n           setOccurrences specialSet generatedPassword + specialAvailable =\n             p.`specialMax /\\\n           i <= p.`specialMin).\n    + seq 1 : (policy = p /\\\n               RPGRef.lowercaseSet = lowercaseSet /\\\n               RPGRef.uppercaseSet = uppercaseSet /\\\n               RPGRef.numbersSet = numbersSet /\\\n               RPGRef.specialSet = specialSet /\\\n               0 < size lowercaseSet /\\\n               0 < size uppercaseSet /\\\n               0 < size numbersSet /\\\n               0 < size specialSet /\\              \n               (forall (x), x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in lowercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n               (forall (x), x \\in uppercaseSet => !(x \\in specialSet)) /\\\n               (forall (x), x \\in numbersSet => !(x \\in specialSet)) /\\\n               lowercaseAvailable <= p.`lowercaseMax /\\\n               uppercaseAvailable <= p.`uppercaseMax /\\\n               numbersAvailable <= p.`numbersMax /\\\n               specialAvailable = (p.`specialMax - i) - 1 /\\\n               p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                 size generatedPassword + 1 /\\\n               setOccurrences lowercaseSet generatedPassword = p.`lowercaseMin /\\\n               setOccurrences uppercaseSet generatedPassword = p.`uppercaseMin /\\\n               setOccurrences numbersSet generatedPassword = p.`numbersMin /\\\n               setOccurrences specialSet generatedPassword = i /\\\n               setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                 p.`lowercaseMax /\\\n               setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                 p.`uppercaseMax /\\\n               setOccurrences numbersSet generatedPassword + numbersAvailable =\n                 p.`numbersMax /\\\n               setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                 p.`specialMax /\\\n               i < policy.`specialMin).\n        auto.\n        move => &m />.\n        smt(@Number).\n      seq 1 : (#pre /\\ randomChar \\in specialSet /\\\n             !(randomChar \\in lowercaseSet) /\\\n             !(randomChar \\in uppercaseSet) /\\\n             !(randomChar \\in numbersSet)).\n        ecall (random_char_generator_has specialSet).\n        skip.\n        move => &m />.\n        smt(disjoint_char).\n      auto.\n      move => &m /> *.\n      do! split.\n      - smt().\n      - smt(size_cat).\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_inset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - by rewrite -setocc_head_cat_right setocc_insert_notinset.\n      - smt(setocc_head_cat_right setocc_insert_inset).\n      - smt(@Number).\n    + skip => /#.\n  - skip => /#.\nseq 1 : (#pre /\\\n         (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable =>\n            0 < size unionSet) /\\\n         (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n         (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n         (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n         (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n         (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                      x \\in uppercaseSet \\/\n                                      x \\in numbersSet \\/\n                                      x \\in specialSet)).\n  ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                             specialAvailable lowercaseSet uppercaseSet\n                             numbersSet specialSet).\n  skip.\n  move => &m /> *.\n  do! split.\n  - smt().\n  - smt().\n  - smt().\n  - smt().\nseq 1 : (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax).\nwhile (policy = p /\\\n       p.`lowercaseMin <= p.`lowercaseMax /\\\n       p.`uppercaseMin <= p.`uppercaseMax /\\\n       p.`numbersMin <= p.`numbersMax /\\\n       p.`specialMin <= p.`specialMax /\\\n       RPGRef.lowercaseSet = lowercaseSet /\\\n       RPGRef.uppercaseSet = uppercaseSet /\\\n       RPGRef.numbersSet = numbersSet /\\\n       RPGRef.specialSet = specialSet /\\\n       0 < size lowercaseSet /\\\n       0 < size uppercaseSet /\\\n       0 < size numbersSet /\\\n       0 < size specialSet /\\\n       (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n       (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n       (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n       (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n       (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n       (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n       0 <= lowercaseAvailable /\\\n       0 <= uppercaseAvailable/\\\n       0 <= numbersAvailable /\\\n       0 <= specialAvailable /\\\n       (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n         => 0 < size unionSet) /\\\n       (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n       (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n       (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n       (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n       (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                    x \\in uppercaseSet \\/\n                                    x \\in numbersSet \\/\n                                    x \\in specialSet) /\\\n       p.`length <=\n         (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n         size generatedPassword /\\\n       setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n         p.`lowercaseMax /\\\n       setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n         p.`uppercaseMax /\\\n       setOccurrences numbersSet generatedPassword + numbersAvailable =\n         p.`numbersMax /\\\n       setOccurrences specialSet generatedPassword + specialAvailable =\n         p.`specialMax /\\\n       p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n       p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n       p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n       p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n       setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n       setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n       setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n       setOccurrences specialSet generatedPassword <= p.`specialMax).\n- seq 0 : (#pre /\\\n           0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable).\n    skip.\n    move => &m />.\n    smt(@Number).\n  seq 1 : (#pre /\\ randomChar \\in unionSet).\n    ecall (random_char_generator_has unionSet).\n    skip.\n    move => &m />.    \n  if.\n  + seq 2 : (policy = p /\\\n             randomChar \\in lowercaseSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < lowercaseAvailable).\n      - seq 1 : (policy = p /\\\n                 randomChar \\in lowercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 < lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n               (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n               (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n               (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m /> *.\n          smt(char_charset_size).\n        if.\n        + conseq (_ : false ==> _).\n          smt().\n          auto.\n        + skip => /#.\n      - seq 1 : (policy = p /\\\n                 randomChar \\in lowercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 = lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n               (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n               (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n               (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n               (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable + 1 =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m /> *.\n          smt(charset_mem_has).\n      if.\n      + ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      + by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n+ if.\n  - seq 2 : (policy = p /\\\n             randomChar \\in uppercaseSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < uppercaseAvailable).\n      + seq 1 : (policy = p /\\\n                 randomChar \\in uppercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 < uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        - conseq (_ : false ==> _).\n          smt().\n          auto.\n        - skip => /#.\n      + seq 1 : (policy = p /\\\n                 randomChar \\in uppercaseSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 = uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable + 1 =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      - ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      - by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n- if.\n  + seq 2 : (policy = p /\\\n             randomChar \\in numbersSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < numbersAvailable).\n      - seq 1 : (policy = p /\\\n                 randomChar \\in numbersSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 < numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        + conseq (_ : false ==> _).\n          smt().\n          auto.\n        + skip => /#.\n      - seq 1 : (policy = p /\\\n                 randomChar \\in numbersSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 = numbersAvailable /\\\n                 0 <= specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable + 1 =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      + ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      + by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n+ if.\n  - seq 2 : (policy = p /\\\n             randomChar \\in specialSet /\\\n             RPGRef.lowercaseSet = lowercaseSet /\\\n             RPGRef.uppercaseSet = uppercaseSet /\\\n             RPGRef.numbersSet = numbersSet /\\\n             RPGRef.specialSet = specialSet /\\\n             p.`lowercaseMin <= p.`lowercaseMax /\\\n             p.`uppercaseMin <= p.`uppercaseMax /\\\n             p.`numbersMin <= p.`numbersMax /\\\n             p.`specialMin <= p.`specialMax /\\\n             0 < size lowercaseSet /\\\n             0 < size uppercaseSet /\\\n             0 < size numbersSet /\\\n             0 < size specialSet /\\\n             (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n             (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n             (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n             0 <= lowercaseAvailable /\\\n             0 <= uppercaseAvailable /\\\n             0 <= numbersAvailable /\\\n             0 <= specialAvailable /\\\n             (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable\n                => 0 < size unionSet) /\\\n             (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n             (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n             (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n             (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n             p.`length <=\n               (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n               size generatedPassword + 1 /\\\n             setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n               p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n               p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword + numbersAvailable =\n               p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n               p.`specialMax /\\\n             p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n             p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n             p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n             p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n             setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n             setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n             setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n             setOccurrences specialSet generatedPassword <= p.`specialMax).\n      case (1 < specialAvailable).\n      + seq 1 : (policy = p /\\\n                 randomChar \\in specialSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 < specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (has (fun (x) => x \\in unionSet) specialSet => 0 < specialAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                  (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable)+\n                   size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(char_charset_size).\n        if.\n        - conseq (_ : false ==> _).\n          smt().\n          auto.\n        - skip => /#.\n      + seq 1 : (policy = p /\\\n                 randomChar \\in specialSet /\\\n                 RPGRef.lowercaseSet = lowercaseSet /\\\n                 RPGRef.uppercaseSet = uppercaseSet /\\\n                 RPGRef.numbersSet = numbersSet /\\\n                 RPGRef.specialSet = specialSet /\\\n                 p.`lowercaseMin <= p.`lowercaseMax /\\\n                 p.`uppercaseMin <= p.`uppercaseMax /\\\n                 p.`numbersMin <= p.`numbersMax /\\\n                 p.`specialMin <= p.`specialMax /\\\n                 0 < size lowercaseSet /\\\n                 0 < size uppercaseSet /\\\n                 0 < size numbersSet /\\\n                 0 < size specialSet /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in uppercaseSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in lowercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in numbersSet)) /\\\n                 (forall x, x \\in uppercaseSet => !(x \\in specialSet)) /\\\n                 (forall x, x \\in numbersSet => !(x \\in specialSet)) /\\\n                 0 <= lowercaseAvailable /\\\n                 0 <= uppercaseAvailable /\\\n                 0 <= numbersAvailable /\\\n                 0 = specialAvailable /\\\n                 (0 < lowercaseAvailable + uppercaseAvailable + numbersAvailable +\n                   specialAvailable => 0 < size unionSet) /\\\n                (has (fun (x) => x \\in unionSet) lowercaseSet => 0 < lowercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) uppercaseSet => 0 < uppercaseAvailable) /\\\n                (has (fun (x) => x \\in unionSet) numbersSet => 0 < numbersAvailable) /\\\n                (forall x, x \\in unionSet => x \\in lowercaseSet \\/\n                                 x \\in uppercaseSet\\/\n                                 x \\in numbersSet \\/\n                                 x \\in specialSet) /\\\n                p.`length <=\n                 (lowercaseAvailable + uppercaseAvailable + numbersAvailable + specialAvailable) +\n                  size generatedPassword + 1 /\\\n                 setOccurrences lowercaseSet generatedPassword + lowercaseAvailable =\n                   p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword + uppercaseAvailable =\n                   p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword + numbersAvailable =\n                   p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword + specialAvailable + 1 =\n                   p.`specialMax /\\\n                 p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n                 p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n                 p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n                 p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n                 setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n                 setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n                 setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n                 setOccurrences specialSet generatedPassword <= p.`specialMax).\n          auto.\n          move => &m />.\n          smt(charset_mem_has).\n      if.\n      - ecall (unionSet_available lowercaseAvailable uppercaseAvailable numbersAvailable\n                                  specialAvailable lowercaseSet uppercaseSet\n                                  numbersSet specialSet).\n        by skip.\n      - by skip.\n    auto.\n    move => &m /> *.\n    do! split.\n    - rewrite size_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\n    - rewrite setocc_cat /= /#.\nconseq (_: false ==> _).\n  + move => &m />.\n    smt().\n  + auto.\n- skip.\n  move => &m />.\n  smt().\ninline RPGRef.permutation.\nseq 2 : (#pre /\\\n         i0 = size pw /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\nauto.\nseq 1 : (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\n  while (policy = p /\\\n         p.`lowercaseMin <= setOccurrences lowercaseSet generatedPassword /\\\n         p.`uppercaseMin <= setOccurrences uppercaseSet generatedPassword /\\\n         p.`numbersMin <= setOccurrences numbersSet generatedPassword /\\\n         p.`specialMin <= setOccurrences specialSet generatedPassword /\\\n         setOccurrences lowercaseSet generatedPassword <= p.`lowercaseMax /\\\n         setOccurrences uppercaseSet generatedPassword <= p.`uppercaseMax /\\\n         setOccurrences numbersSet generatedPassword <= p.`numbersMax /\\\n         setOccurrences specialSet generatedPassword <= p.`specialMax /\\\n         i0 <= size pw /\\\n         setOccurrences lowercaseSet generatedPassword =\n         setOccurrences lowercaseSet pw /\\\n         setOccurrences uppercaseSet generatedPassword =\n         setOccurrences uppercaseSet pw /\\\n         setOccurrences numbersSet generatedPassword =\n         setOccurrences numbersSet pw /\\\n         setOccurrences specialSet generatedPassword =\n         setOccurrences specialSet pw).\n  - seq 1 : (#pre /\\ j < i0 /\\ 0 <= j).\n      ecall (rng_range i0).\n      skip => /#.\n    auto.\n    move => &m /> *.\n    split.\n    rewrite -size_update.\n    rewrite -size_update.\n    smt(@Number).\n    do! split.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n    rewrite setocc_swap; do! assumption.\n  - by skip.\nauto.\nmove => &m /> h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12.\ndo! split.\n- by rewrite -h9.\n- by rewrite -h9.\n- by rewrite -h10.\n- by rewrite -h10.\n- by rewrite -h11.\n- by rewrite -h11.\n- by rewrite -h12.\n- by rewrite -h12.\nconseq (_: false ==> _).\nmove => &m /> /#.\ntrivial.\nqed.\n\n\n\n\n(* ------------------------------------------------------------------------------------------ *)\n(* If PCP is satisfiable, RPGSpec satisfies both the length and the bounds defined in the PCP *)\n(* ------------------------------------------------------------------------------------------ *)\nlemma rpg_correctness_sat_pcp_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res) /\\ satisfiesBounds p (oget res)].\nproof.\nhave length_proof : (hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesLength p (oget res)]).\nexact rpg_correctness_length_hl.\nhave bounds_proof : (hoare [RPGRef.generate_password : policy = p /\\ satisfiablePolicy p\n         ==> is_some res /\\ satisfiesBounds p (oget res)]).\nexact rpg_correctness_bounds_hl.\nconseq length_proof bounds_proof.\nmove => &m h1.\nsplit.\nassumption.\nassumption.\nmove => &m />.\nqed.\n\n\n\n\n(* --------------------------------------------- *)\n(* If PCP is unsatisfiable, RPGSpec returns None *)\n(* --------------------------------------------- *)\nlemma rpg_correctness_unsat_pcp_hl (p:policy) :\n  hoare [RPGRef.generate_password : policy = p /\\ !(satisfiablePolicy p)\n         ==> res = None].\nproof.\nproc.\nif.\n* conseq (_: false ==> _).\n  move => &m /> /#.\n  trivial.\n* by wp.\nqed.\n\n\n(* ------------------------- *)\n(* RPGSpec always terminates *)\n(* ------------------------- *)\nlemma rpg_ll :\n  islossless RPGRef.generate_password.\nproof.\nproc.\nislossless.\n  while true i.\n  - move => z.\n    seq 1 : (#pre).\n      auto.\n      call rng_ll.\n      auto.\n    auto.\n    smt().\n    hoare.\n    inline *.\n    auto.\n    seq 4 : (#pre).   \n    auto.\n    while true.\n    - auto.  \n    - skip.\n      smt().\n    smt().\n    skip.\n    smt().\n  while true (policy.`length - size generatedPassword).\n  - auto.\n    inline RPGRef.random_char_generator.\n    sp.\n    seq 1 : (#pre).\n      auto.\n      call rng_ll.\n      skip.\n      smt().\n    inline *.\n    auto.\n    move => &m /> *.\n    rewrite size_cat /=.\n    smt(@Number).\n    hoare.\n    inline *.\n    auto.\n    seq 4 : (#pre).    \n      auto.\n    while true.\n    - auto.\n    - skip.\n      smt().\n    smt().\n    skip => /#.\n  while true (policy.`specialMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt().\n  - skip => /#.\n  while true (policy.`numbersMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\n  while true (policy.`uppercaseMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\n  while true (policy.`lowercaseMin - i).\n  - auto.\n    inline RPGRef.random_char_generator.\n    auto.\n    seq 2 : (#pre).\n      auto.\n      auto.    \n    call rng_ll.\n    auto.\n    smt().\n    hoare.\n    auto.\n    smt.\n  - skip => /#.\nqed.\n\n\n\n(* ------------------ *)\n(* RPGSpec is correct *)\n(* ------------------ *)\nlemma rpg_correctness &m (p:policy) :\n  Pr[Correctness(RPGRef).main(p) @ &m : res] = 1%r.\nproof.\nbyphoare (_: policy = p ==> _).\nhave c_lossless: islossless Correctness(RPGRef).main.\n- proc.\n  wp.\n  call rpg_ll.\n  trivial.\nhave c_correct: hoare[Correctness(RPGRef).main : policy = p ==> res].\n- proc.\n  case (satisfiablePolicy policy).\n  + seq 1 : (#pre /\\\n             is_some pw /\\\n             satisfiesLength policy (oget pw) /\\\n             satisfiesBounds policy (oget pw)).\n    * call (rpg_correctness_sat_pcp_hl p).\n      skip => /#.\n    if.\n    * wp.\n      skip => /#.\n    * conseq (_: false ==> _).\n      smt().\n      trivial.\n  + seq 1 : (#pre /\\ is_none pw).\n    * call (rpg_correctness_unsat_pcp_hl p).\n      skip => /#.\n    if.\n    * conseq (_: false ==> _).\n      smt().\n      trivial.\n    * wp.\n      skip => /#.\nby conseq c_lossless c_correct.\nreflexivity.\ntrivial.\nqed.\n\n\n\n(*******************************)\n(*          SECURITY           *)\n(*******************************)\n\nlemma rng_uniform  :\n  equiv [RPGRef.rng ~ Test.uniformRangeDistr : ={range} ==> ={res}].\nproof.\nproc.\nadmitted.\n\n\nlemma rpg_security :\n  equiv [IdealRPG.generate_password ~ RPGRef.generate_password : ={policy} ==> ={res}].\nproof.\nproc.\nadmitted."
    },
    {
        "file": "EC-1/pedersen-1.ec",
        "incomplete": "(*\n * A formal verification of the Pedersen commitment scheme\n *\n * Pedersen, Torben Pryds\n * \"Non-interactive and information-theoretic secure verifiable secret sharing\"\n *)\nrequire import Real.\nrequire (****) DLog.\n\nclone DLog as DL.\nimport DL.G DL.GP DL.FD DL.GP.ZModE.\n\nrequire (*--*) Commitment.\n\n(* Pedersen protocol types *)\ntheory PedersenTypes.\n  type value        = group.\n  type message      = exp.\n  type commitment   = group.\n  type openingkey   = exp.\nend PedersenTypes.\nexport PedersenTypes.\n\n(* Instantiate the Commitment scheme with the above types *)\nclone import Commitment as CM with\n  type ____(TYPE_0)____.value      <- value,\n  type ____(TYPE_1)____.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\nexport CommitmentProtocol.\n\nmodule Pedersen : CommitmentScheme = {\n  proc gen() : value = {\n    var x, h;\n    x <$ dt;\n    h <- g ^ x;\n    return h;\n  }\n\n  proc commit(h: value, m: message) : commitment * openingkey = {\n    var c, d;\n    d <$ dt;\n    c <- (g ^ d) * (h ^ m);\n    return (c, d);\n  }\n\n  proc verify(h: value, m: message, c: commitment, d: openingkey) : bool = {\n    var c';\n    c' <- (g ^ d) * (h ^ m);\n    return (c = c');\n  }\n}.\n\nmodule DLogAttacker(B:____(MODULE_0)____) : DL.DLog.Adversary = {\n  proc guess (h: group) : exp option = {\n\n    var x, c, m, m', d, d';\n    (c, m, d, m', d') <@ B.bind(h);\n    if ((c = g ^ d * h ^ m) /\\ (c = g ^ d' * h ^ m') /\\ (m <> m'))\n      x <- Some((d - d') * inv (m' - m));\n    else\n      x <- None;\n\n    return x;\n  }\n}.\n\nsection PedersenSecurity.\n\n  (* Correctness *)\n  lemma pedersen_correctness:\n    hoare[Correctness(Pedersen).main: true ==> res].\n  proof. proc; inline *;auto. qed.\n\n  local module FakeCommit(U:Unhider) = {\n    proc main() : bool = {\n      var b, b', x, h, c, d;\n      var m0, m1 : exp;\n\n      (* Clearly, there are many useless lines, but their presence helps for the proofs *)\n      x <$ dt;\n      h <- g^x;\n      (m0, m1) <@ U.choose(h);\n      b <$ {0,1};\n      d <$ dt;\n      c <- g^d; (* message independent - fake commitment *)\n      b' <@ U.guess(c);\n\n      return (b = b');\n    }\n  }.\n\n  local lemma hi_ll (U<:Unhider):\n    islossless U.choose =>\n    islossless U.guess =>\n    islossless FakeCommit(U).main.\n  proof.\n    by move => uc_ll ug_ll; islossless; (apply dt_ll || apply DBool.dbool_ll).\n  qed.\n\n  (* Perfect hiding *)\n  local lemma fakecommit_half (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[FakeCommit(U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    move => uc_ll ug_ll; byphoare => //.\n    proc; wp.\n    swap 4 3.\n    rnd (pred1 b'); call ug_ll; wp; rnd; call uc_ll; auto => />.\n    by rewrite dt_ll /= => v _ _ result; rewrite DBool.dbool1E.\n  qed.\n\n  local lemma phi_hi (U<:Unhider) &m:\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] =\n    Pr[FakeCommit(U).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    call (_:true); wp.\n    rnd (fun d, (d + x * (b?m1:m0)){2})\n        (fun d, (d - x * (b?m1:m0)){2}).\n    by wp; rnd; call (_: true); auto => />; progress; algebra.\n  qed.\n\n  (* Perfect hiding - QED *)\n  lemma pedersen_perfect_hiding (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    by move => uc_ll ug_ll; rewrite (phi_hi U &m) (fakecommit_half U &m).\n  qed.\n\n  (* Computational binding - QED *)\n  lemma pedersen_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] =\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    wp; call (_: true); auto => /> x _ [ c m d m' d'] /= comm comm' m_neq_m'.\n    rewrite eq_sym eqT.\n    have ->: (d - d') * inv (m' - m) = x <=> (d - d') = x * (m' - m).\n    + by split => [<- | ->]; field; apply: contra m_neq_m' => heq;ring heq.\n    have -> : d - d' = x * (m' - m) <=> d + x * m = d' + x * m'.\n    + by split => heq; ring heq.\n    by rewrite pow_bij !(expD, expM, -comm, -comm').\n  qed.\n\n  (*\n     The following two are to compare probability directly with book discrete\n     logarithm experiment. Not strictly necessary though, only for completeness.\n  *)\n  local lemma std_red_dl_bridge (B<:Binder) &m:\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; wp; inline{2} DL.StdRedAdversary(DLogAttacker(B)).guess; wp.\n    seq 2 3: (x'{1} = lx{2} /\\ x{1} = x{2}).\n    + by inline*; wp; call (_: true); auto.\n    by if{2}; auto => />; apply dt_ll.\n  qed.\n\n  lemma pedersen_std_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res]\n  by rewrite(pedersen_computational_binding B &m); apply (std_red_dl_bridge B &m).\n\nend section PedersenSecurity.\n\nprint pedersen_correctness.\nprint pedersen_perfect_hiding.\nprint pedersen_computational_binding.",
        "complete:": "(*\n * A formal verification of the Pedersen commitment scheme\n *\n * Pedersen, Torben Pryds\n * \"Non-interactive and information-theoretic secure verifiable secret sharing\"\n *)\nrequire import Real.\nrequire (****) DLog.\n\nclone DLog as DL.\nimport DL.G DL.GP DL.FD DL.GP.ZModE.\n\nrequire (*--*) Commitment.\n\n(* Pedersen protocol types *)\ntheory PedersenTypes.\n  type value        = group.\n  type message      = exp.\n  type commitment   = group.\n  type openingkey   = exp.\nend PedersenTypes.\nexport PedersenTypes.\n\n(* Instantiate the Commitment scheme with the above types *)\nclone import Commitment as CM with\n  type CommitmentProtocol.value      <- value,\n  type CommitmentProtocol.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\nexport CommitmentProtocol.\n\nmodule Pedersen : CommitmentScheme = {\n  proc gen() : value = {\n    var x, h;\n    x <$ dt;\n    h <- g ^ x;\n    return h;\n  }\n\n  proc commit(h: value, m: message) : commitment * openingkey = {\n    var c, d;\n    d <$ dt;\n    c <- (g ^ d) * (h ^ m);\n    return (c, d);\n  }\n\n  proc verify(h: value, m: message, c: commitment, d: openingkey) : bool = {\n    var c';\n    c' <- (g ^ d) * (h ^ m);\n    return (c = c');\n  }\n}.\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n  proc guess (h: group) : exp option = {\n\n    var x, c, m, m', d, d';\n    (c, m, d, m', d') <@ B.bind(h);\n    if ((c = g ^ d * h ^ m) /\\ (c = g ^ d' * h ^ m') /\\ (m <> m'))\n      x <- Some((d - d') * inv (m' - m));\n    else\n      x <- None;\n\n    return x;\n  }\n}.\n\nsection PedersenSecurity.\n\n  (* Correctness *)\n  lemma pedersen_correctness:\n    hoare[Correctness(Pedersen).main: true ==> res].\n  proof. proc; inline *;auto. qed.\n\n  local module FakeCommit(U:Unhider) = {\n    proc main() : bool = {\n      var b, b', x, h, c, d;\n      var m0, m1 : exp;\n\n      (* Clearly, there are many useless lines, but their presence helps for the proofs *)\n      x <$ dt;\n      h <- g^x;\n      (m0, m1) <@ U.choose(h);\n      b <$ {0,1};\n      d <$ dt;\n      c <- g^d; (* message independent - fake commitment *)\n      b' <@ U.guess(c);\n\n      return (b = b');\n    }\n  }.\n\n  local lemma hi_ll (U<:Unhider):\n    islossless U.choose =>\n    islossless U.guess =>\n    islossless FakeCommit(U).main.\n  proof.\n    by move => uc_ll ug_ll; islossless; (apply dt_ll || apply DBool.dbool_ll).\n  qed.\n\n  (* Perfect hiding *)\n  local lemma fakecommit_half (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[FakeCommit(U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    move => uc_ll ug_ll; byphoare => //.\n    proc; wp.\n    swap 4 3.\n    rnd (pred1 b'); call ug_ll; wp; rnd; call uc_ll; auto => />.\n    by rewrite dt_ll /= => v _ _ result; rewrite DBool.dbool1E.\n  qed.\n\n  local lemma phi_hi (U<:Unhider) &m:\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] =\n    Pr[FakeCommit(U).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    call (_:true); wp.\n    rnd (fun d, (d + x * (b?m1:m0)){2})\n        (fun d, (d - x * (b?m1:m0)){2}).\n    by wp; rnd; call (_: true); auto => />; progress; algebra.\n  qed.\n\n  (* Perfect hiding - QED *)\n  lemma pedersen_perfect_hiding (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    by move => uc_ll ug_ll; rewrite (phi_hi U &m) (fakecommit_half U &m).\n  qed.\n\n  (* Computational binding - QED *)\n  lemma pedersen_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] =\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    wp; call (_: true); auto => /> x _ [ c m d m' d'] /= comm comm' m_neq_m'.\n    rewrite eq_sym eqT.\n    have ->: (d - d') * inv (m' - m) = x <=> (d - d') = x * (m' - m).\n    + by split => [<- | ->]; field; apply: contra m_neq_m' => heq;ring heq.\n    have -> : d - d' = x * (m' - m) <=> d + x * m = d' + x * m'.\n    + by split => heq; ring heq.\n    by rewrite pow_bij !(expD, expM, -comm, -comm').\n  qed.\n\n  (*\n     The following two are to compare probability directly with book discrete\n     logarithm experiment. Not strictly necessary though, only for completeness.\n  *)\n  local lemma std_red_dl_bridge (B<:Binder) &m:\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; wp; inline{2} DL.StdRedAdversary(DLogAttacker(B)).guess; wp.\n    seq 2 3: (x'{1} = lx{2} /\\ x{1} = x{2}).\n    + by inline*; wp; call (_: true); auto.\n    by if{2}; auto => />; apply dt_ll.\n  qed.\n\n  lemma pedersen_std_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res]\n  by rewrite(pedersen_computational_binding B &m); apply (std_red_dl_bridge B &m).\n\nend section PedersenSecurity.\n\nprint pedersen_correctness.\nprint pedersen_perfect_hiding.\nprint pedersen_computational_binding."
    },
    {
        "file": "EC-1/Plug_and_Pray_example.ec",
        "incomplete": "require import AllCore List Int Real IntDiv.\nrequire import Distr DInterval.\nrequire (*--*) Plug_and_Pray.\n\nconst ____(CONST_1)____ : { int ____(CONST_0)____ 0 < q } as gt0_q.\n\nmodule type Orcl = {\n  proc query(n : int) : int\n}.\n\nmodule type Adv (O : Orcl) = {\n  proc run() : bool\n}.\n\nmodule G0 (AF : Adv) = {\n  var b : bool\n  var k : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    k <- 0;\n    b <@ A.run();\n    k <- k %% q;\n  }\n}.\n\nmodule G1(AF : Adv) = {\n  var b : bool\n  var k : int\n  var i : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    i <$ [0..q - 1];\n    k <- 0;\n    b <@ A.run();\n    k <- k %% q;\n  }\n}.\n\nclone import Plug_and_Pray as PnP with\n  type tres    <- unit,\n  type tval    <- int,\n  type tin     <- unit,\n  op   indices <- range 0 q\nproof indices_not_nil by smt(size_range gt0_q).\n\n(*\n   We first apply the general Lemma that yields\n     1 / q * Pr[ G0 : Ev] = Pr[ G0; i=$[0..q-1] : Ev /\\ i = G0.k]\n   where ``G0; i=$[0..q-1]'' is expressed as an application of the\n   ``Guess'' functor and we use an if-then-else to ensure that\n   G0.k is in [0..q-1].\n*)\nlemma Bound_aux &m (A <: Adv {-G0}):\n  (1%r/q%r) * Pr[ G0(A).main() @ &m : G0.b ]\n  = Pr[ Guess(G0(A)).main() @ &m :  G0.b /\\ res.`1 = G0.k ].\nproof.\npose phi:= fun (g : (glob G0(A))) (_ : unit)=> g.`2.\npose psi:= fun (g : (glob G0(A))) (_ : unit)=> if 0 <= g.`3 < q then g.`3 else 0.\nhave:= PBound (G0(A)) phi psi tt &m _.\n+ by move=> @/psi gG o /=; rewrite mem_range; case: (0 <= gG.`3 < q)=> //= _; exact/gt0_q.\nhave ->: card = q by rewrite undup_id 1:range_uniq size_range #smt:(gt0_q).\nhave -> //=: Pr[Guess(G0(A)).main() @ &m: phi (glob G0(A)) res.`2 /\\ res.`1 = psi (glob G0(A)) res.`2]\n             = Pr[Guess(G0(A)).main() @ &m: G0.b /\\ res.`1 = G0.k].\nbyequiv (: ={glob G0(A)} ==> _)=> //=.\nconseq (: _ ==> ={glob G0, res} /\\ 0 <= G0.k{1} < q); first by smt().\nproc; rnd; inline *; wp.\nconseq (: ={glob G0})=> //=.\n+ move=> &1 &2 _ bL kL bR kR [#] ->> ->> iL -> /=.\n  by rewrite modz_ge0 2:ltz_pmod; smt(gt0_q).\ncall (: ={G0.k}).\n+ by sim.\nby auto.\nqed.\n\n(*\n  We now transfer the previous lemma to G0 and G1 by relating\n  Guess(G0) with G1.\n*)\nlemma Bound &m (A <: Adv{-G1,-G0}):\n    (1%r/q%r) * Pr[ G0(A).main() @ &m : G0.b ]\n  = Pr[ G1(A).main() @ &m :  G1.b /\\ G1.k = G1.i].\nproof.\nrewrite (Bound_aux &m A).\nbyequiv (: ={glob A} ==> ={b,k}(G0,G1) /\\ res.`1{1} = G1.i{2} /\\ 0 <= G1.k{2} < q)=> //=.\nproc; inline G0(A).main.\nswap{2} 1 3; auto.\ncall (: ={k}(G0,G1)).\n+ by sim.\nauto=> /> k _ i h1 h2; split => [|_].\n+ by rewrite modz_ge0 #smt:(gt0_q).\n+ by rewrite ltz_pmod gt0_q.\nqed.",
        "complete:": "require import AllCore List Int Real IntDiv.\nrequire import Distr DInterval.\nrequire (*--*) Plug_and_Pray.\n\nconst q : { int | 0 < q } as gt0_q.\n\nmodule type Orcl = {\n  proc query(n : int) : int\n}.\n\nmodule type Adv (O : Orcl) = {\n  proc run() : bool\n}.\n\nmodule G0 (AF : Adv) = {\n  var b : bool\n  var k : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    k <- 0;\n    b <@ A.run();\n    k <- k %% q;\n  }\n}.\n\nmodule G1(AF : Adv) = {\n  var b : bool\n  var k : int\n  var i : int\n\n  module O = {\n    proc query(n : int) : int = {\n      k <- n;\n      return k;\n    }\n  }\n\n  module A = AF(O)\n\n  proc main(x : unit) : unit = {\n    i <$ [0..q - 1];\n    k <- 0;\n    b <@ A.run();\n    k <- k %% q;\n  }\n}.\n\nclone import Plug_and_Pray as PnP with\n  type tres    <- unit,\n  type tval    <- int,\n  type tin     <- unit,\n  op   indices <- range 0 q\nproof indices_not_nil by smt(size_range gt0_q).\n\n(*\n   We first apply the general Lemma that yields\n     1 / q * Pr[ G0 : Ev] = Pr[ G0; i=$[0..q-1] : Ev /\\ i = G0.k]\n   where ``G0; i=$[0..q-1]'' is expressed as an application of the\n   ``Guess'' functor and we use an if-then-else to ensure that\n   G0.k is in [0..q-1].\n*)\nlemma Bound_aux &m (A <: Adv {-G0}):\n  (1%r/q%r) * Pr[ G0(A).main() @ &m : G0.b ]\n  = Pr[ Guess(G0(A)).main() @ &m :  G0.b /\\ res.`1 = G0.k ].\nproof.\npose phi:= fun (g : (glob G0(A))) (_ : unit)=> g.`2.\npose psi:= fun (g : (glob G0(A))) (_ : unit)=> if 0 <= g.`3 < q then g.`3 else 0.\nhave:= PBound (G0(A)) phi psi tt &m _.\n+ by move=> @/psi gG o /=; rewrite mem_range; case: (0 <= gG.`3 < q)=> //= _; exact/gt0_q.\nhave ->: card = q by rewrite undup_id 1:range_uniq size_range #smt:(gt0_q).\nhave -> //=: Pr[Guess(G0(A)).main() @ &m: phi (glob G0(A)) res.`2 /\\ res.`1 = psi (glob G0(A)) res.`2]\n             = Pr[Guess(G0(A)).main() @ &m: G0.b /\\ res.`1 = G0.k].\nbyequiv (: ={glob G0(A)} ==> _)=> //=.\nconseq (: _ ==> ={glob G0, res} /\\ 0 <= G0.k{1} < q); first by smt().\nproc; rnd; inline *; wp.\nconseq (: ={glob G0})=> //=.\n+ move=> &1 &2 _ bL kL bR kR [#] ->> ->> iL -> /=.\n  by rewrite modz_ge0 2:ltz_pmod; smt(gt0_q).\ncall (: ={G0.k}).\n+ by sim.\nby auto.\nqed.\n\n(*\n  We now transfer the previous lemma to G0 and G1 by relating\n  Guess(G0) with G1.\n*)\nlemma Bound &m (A <: Adv{-G1,-G0}):\n    (1%r/q%r) * Pr[ G0(A).main() @ &m : G0.b ]\n  = Pr[ G1(A).main() @ &m :  G1.b /\\ G1.k = G1.i].\nproof.\nrewrite (Bound_aux &m A).\nbyequiv (: ={glob A} ==> ={b,k}(G0,G1) /\\ res.`1{1} = G1.i{2} /\\ 0 <= G1.k{2} < q)=> //=.\nproc; inline G0(A).main.\nswap{2} 1 3; auto.\ncall (: ={k}(G0,G1)).\n+ by sim.\nauto=> /> k _ i h1 h2; split => [|_].\n+ by rewrite modz_ge0 #smt:(gt0_q).\n+ by rewrite ltz_pmod gt0_q.\nqed."
    },
    {
        "file": "EC-1/PRG.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List Distr FSet SmtMap.\nrequire import IntDiv Mu_mem StdRing StdOrder StdBigop.\n(*---*) import Bigint Ring.IntID RField IntOrder RealOrder BIA.\nrequire (*--*) FinType.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(** A finite type of seeds equipped with its uniform distribution **)\nclone include MFinite\nrename\n  [type] \"t\" as \"seed\"\n  \"dunifin\" as \"dseed\"\n  \"duniform\" as \"dseed\".\n\n(* -------------------------------------------------------------------- *)\n(** Some output type equipped with some lossless distribution **)\ntype ____(TYPE_0)____.\nop dout: { output distr | is_lossless dout } as dout_ll.\nhint exact ____(HINT_0)____: dout_ll.\n\n(* -------------------------------------------------------------------- *)\n(** We use a public RF that, on input a seed, produces a seed and\n    an output...                                                        *)\nmodule type RF = {\n  proc * init() : unit\n  proc f(x:seed): seed * output\n}.\n\n(** ...to build a PRG that produces random outputs... **)\n(** We let our PRG have internal state, which we need to initialize **)\nmodule type PRG = {\n  proc * init(): unit\n  proc prg()   : output\n}.\n\n(* -------------------------------------------------------------------- *)\n(** Distinguishers can call\n  *   - the PRG at most qP times, and\n  *   - the PRF at most qF times, and\n  *   - return a boolean *)\nop ____(OP_1)____ : { int ____(OP_0)____ 0 <= qP } as ge0_qP.\nop qF : { int | 0 <= qF } as ge0_qF.\n\nmodule type ARF = {\n  proc f(_:seed): seed * output\n}.\n\nmodule type APRG = {\n  proc prg(): output\n}.\n\nmodule type Adv (F:ARF) (P:APRG) = {\n  proc a(): bool\n}.\n\nmodule Exp (A:Adv) (F:RF) (P:PRG) = {\n  module A = A(F,P)\n\n  proc main():bool = {\n    var b: bool;\n\n         F.init();\n         P.init();\n    b <@ A.a();\n    return b;\n  }\n}.\n\n(** A PRG is secure iff it is indistinguishable from sampling in $dout\n    by an adversary with access to the PRF and the PRG interfaces *)\nmodule PrgI = {\n  proc init () : unit = { }\n\n  proc prg(): output = {\n    var r;\n\n    r <$ dout;\n    return r;\n  }\n}.\n(* Adv^PRG_A,F,P = `| Exp(A,F,P) - Exp(A,F,PrgI) | *)\n\n(* -------------------------------------------------------------------- *)\n(* Concrete considerations                                              *)\n\n(* We use the following RF *)\nmodule F = {\n  var m:(seed,seed * output) fmap\n\n  proc init(): unit = {\n     m <- empty;\n  }\n\n  proc f (x:seed) : seed * output = {\n    var r1, r2;\n\n    r1 <$ dseed;\n    r2 <$ dout;\n    if (x \\notin m)\n      m.[x] <- (r1,r2);\n\n    return oget (m.[x]);\n  }\n}.\n\nlemma FfL: ____(LEMMA_0)____ F.f.\nproof. islossless. qed.\n\n(* And we are proving the security of the following PRG *)\nmodule P (F:RF) = {\n  var seed: seed\n  var logP: seed list\n\n  proc init(): unit = {\n    seed <$ dseed;\n  }\n\n  proc prg(): output = {\n    var r;\n\n    (seed,r) <@ F.f (seed);\n    return r;\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\n(* We use the following oracle in an intermediate game that links two\n   sections.                                                            *)\n\nmodule Psample = {\n  proc init(): unit = {\n    P.seed <$ dseed;\n    P.logP <- [];\n  }\n\n  proc prg(): output = {\n    var r1, r2;\n\n    r1     <$ dseed;\n    r2     <$ dout;\n    P.logP <- P.seed :: P.logP;\n    P.seed <- r1;\n    return r2;\n  }\n}.\n\nlemma PsampleprgL: islossless Psample.prg.\nproof. islossless. qed.\n\n(* -------------------------------------------------------------------- *)\n(* In preparation of the eager/lazy reasoning step                      *)\n(* -------------------------------------------------------------------- *)\nmodule Resample = {\n  proc resample() : unit = {\n    var n, r;\n\n    n      <- size P.logP;\n    P.logP <- [];\n    P.seed <$ dseed;\n    while (size P.logP < n) {\n      r      <$ dseed;\n      P.logP <- r :: P.logP;\n    }\n  }\n}.\n\nmodule Exp'(A:Adv) = {\n  module A = A(F,Psample)\n\n  proc main():bool = {\n    var b : bool;\n         F.init();\n         Psample.init();\n    b <@ A.a();\n         Resample.resample();\n    return b;\n  }\n}.\n\n(* The Proof                                                            *)\n\nsection.\n  (* Forall Adversary A that does not share memory with P or F... *)\n  declare module A:Adv {P,____(DECLARE_0)____}.\n\n  (* ... and whose a procedure is lossless whenever F.f and P.prg are *)\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* We show that the adversary can distinguish P from Psample only\n     when P.prg is called twice with the same input. *)\n\n  (* First, we add some logging so we can express the bad event *)\n  local module Plog = {\n    proc init(): unit = {\n      P.seed <$ dseed;\n      P.logP <- [];\n    }\n\n    proc prg(): output = {\n      var r;\n\n      P.logP     <- P.seed :: P.logP;\n      (P.seed,r) <@ F.f(P.seed);\n      return r;\n    }\n  }.\n\n  local lemma PlogprgL: islossless Plog.prg.\n  proof. by proc; call FfL; wp. qed.\n\n  local lemma P_Plog &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] = Pr[Exp(A,F,Plog).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //.\n  by do !sim.\n  qed.\n\n  (* Bad holds whenever:\n   *  - there is a cycle in the state, OR\n   *  - an adversary query collides with an internal seed. *)\n  inductive Bad logP (m : ('a,'b) fmap) =\n    | Cycle of (!uniq logP)\n    | Collision r of (mem logP r) & (r \\in m).\n\n  lemma negBadE logP (m : ('a,'b) fmap):\n    !Bad logP m <=>\n      (uniq logP /\\ forall r, !mem logP r \\/ r \\notin m).\n  proof.\n  rewrite -iff_negb negbK negb_and negb_forall /=.\n  rewrite (@ exists_iff _ (predI (mem logP) (dom m)) _).\n  + by move=> a /=; rewrite negb_or /predI.\n  split=> [[->|r r_in_log r_in_m]|[/(Cycle _ m)|[r] @/predI [] /(Collision _ m r)]] //.\n  by right; exists r.\n  qed.\n\n  (* In this game, we replace the PRF queries with fresh sampling operations *)\n  inductive inv (m1 m2 : ('a,'b) fmap) (logP : 'a list) =\n    | Invariant of\n          (forall r, r \\in m1 <=> (r \\in m2 \\/ mem logP r))\n        & (forall r, r \\in m2 => m1.[r] = m2.[r]).\n\n  local lemma Plog_Psample &m:\n    Pr[Exp(A,F,Plog).main() @ &m: res] <=\n      Pr[Exp(A,F,Psample).main() @ &m: res] +\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (ler_trans (Pr[Exp(A,F,Psample).main() @ &m: res \\/ Bad P.logP F.m]));\n    last by rewrite Pr [mu_or]; smt w=mu_bounded.\n  byequiv (_: ={glob A} ==> !(Bad P.logP F.m){2} => ={res})=> // [|/#].\n  proc.\n  call (_: Bad P.logP F.m, ={P.seed} /\\ inv F.m{1} F.m{2} P.logP{2}).\n    (* adversary is lossless *)\n    by apply AaL.\n    (* [Psample.prg ~ Plog.prg: I] when Bad does not hold *)\n    proc; inline F.f. swap{2} 3 -2.\n    auto=> /> &1 &2 _ [] m1_is_m2Ulog m2_le_m1 r1 _ r2 _.\n    rewrite negBadE; case: (P.seed{2} \\in F.m{1})=> [/#|//=].\n    rewrite !get_setE /=.\n    move=> seed_notin_m1 _; split.\n      by move=> r; rewrite mem_set m1_is_m2Ulog /#.\n    move=> r ^/m2_le_m1; rewrite !get_setE=> -> r_in_m2.\n    by move: (iffRL _ _ (m1_is_m2Ulog r)); rewrite r_in_m2 /#.\n    (* Plog.prg is lossless when Bad holds *)\n    by move=> _ _; islossless.\n    (* Psample.prg preserves bad *)\n    move=> *; proc; auto=> />; rewrite dseed_ll dout_ll /=.\n    move=> &hr + v1 _ _ v2 _ _; case=> [h|r r_in_log r_in_m].\n    + by apply/Cycle; rewrite /= h.\n    by apply/(@Collision _ _ r)=> /=; [rewrite r_in_log|rewrite r_in_m].\n    (* [F.f ~ F.f: I] when Bad does not hold *)\n    proc; auto=> /> &1 &2; rewrite !negBadE.\n    move=> -[] uniq_log r_notin_logIm [] m_is_mUlog m2_le_m1 r1L _ r2L _.\n    case: (x{2} \\in F.m{2})=> [/#|//=].\n    case: (x{2} \\in F.m{1})=> /=.\n    + rewrite negBadE uniq_log=> /= /m_is_mUlog + x_notin_m2 h'; rewrite x_notin_m2 /=.\n      by move: (h' x{2}); rewrite mem_set.\n    rewrite !get_setE /= => x_notin_m1 x_notin_m2 _; split.\n    + by move=> r; rewrite !mem_set m_is_mUlog /#.\n    by move=> r; rewrite !mem_set !get_setE=> -[/m2_le_m1|] ->.\n    (* F.f is lossless when Bad holds *)\n    by move=> _ _; apply FfL.\n    (* F.f preserves bad *)\n    move=> _ //=; proc.\n    case (x \\in F.m).\n    + by rcondf 3; auto=> />; rewrite dseed_ll dout_ll.\n    rcondt 3; first by do !rnd; wp.\n    auto=> />; rewrite dseed_ll dout_ll //= => &hr bad_init x_notin_m v _ _ v0 _ _.\n    case: bad_init=> [/(Cycle<:seed,seed * output>) -> //|r r_in_log r_in_m].\n    by apply/(@Collision _ _ r)=> //=; rewrite mem_set r_in_m.\n  (* Returning to main *)\n  call (_: ={glob F} ==> ={glob P} /\\ inv F.m{1} F.m{2} P.logP{2}).\n  + by proc; auto=> /> &2 _ _; split.\n  call (_: true ==> ={glob F}); first by sim.\n  by auto=> /#.\n  qed.\n\n  local lemma Psample_PrgI &m:\n    Pr[Exp(A,F,Psample).main() @ &m: res] = Pr[Exp(A,F,PrgI).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //; proc.\n  call (_: ={glob F})=> //.\n    (* Psample.prg ~ PrgI.prg *)\n  + by proc; wp; rnd; rnd{1}; auto=> />; rewrite dseed_ll.\n    (* F.f *)\n  + by sim.\n  conseq (_: _ ==> ={glob A, glob F})=> //.\n  by inline *; auto=> />; rewrite dseed_ll.\n  qed.\n\n  local lemma Resample_resampleL: islossless Resample.resample.\n  proof.\n  proc; while (true) (n - size P.logP);\n    first by move=> z; auto; rewrite dseed_ll /#.\n  by auto; rewrite dseed_ll /#.\n  qed.\n\n  local module Exp'A = Exp'(A).\n\n  local lemma ExpPsample_Exp' &m:\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m]\n    = Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_: ={glob A} ==> ={P.logP, F.m})=> //; proc.\n  transitivity{1} { F.init(); Psample.init(); Resample.resample(); b <@ Exp'A.A.a(); }\n     (={glob A} ==> ={F.m, P.logP})\n     (={glob A} ==> ={F.m, P.logP})=> //.\n    (* Equality on A's globals *)\n  + by move=> &1 &2 A; exists (glob A){1}.\n    (* no sampling ~ presampling *)\n  + sim; inline Resample.resample Psample.init F.init.\n    rcondf{2} 7;\n      first by move=> &hr; rnd; wp; conseq (_: _ ==> true) => //.\n    by wp; rnd; wp; rnd{2} predT; auto; rewrite dseed_ll.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob F, glob Plog}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob Plog} ==> ={glob Plog})\n    : (={glob A, glob Plog, glob F})=> //;\n    first by sim.\n  eager proc H (={glob Plog, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r;\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r;\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0;\n    cP <- 0;\n    b <@ A.a();\n    return b;\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f.\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg.\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n     islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a.\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}.\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r).\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)).\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List Distr FSet SmtMap.\nrequire import IntDiv Mu_mem StdRing StdOrder StdBigop.\n(*---*) import Bigint Ring.IntID RField IntOrder RealOrder BIA.\nrequire (*--*) FinType.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(** A finite type of seeds equipped with its uniform distribution **)\nclone include MFinite\nrename\n  [type] \"t\" as \"seed\"\n  \"dunifin\" as \"dseed\"\n  \"duniform\" as \"dseed\".\n\n(* -------------------------------------------------------------------- *)\n(** Some output type equipped with some lossless distribution **)\ntype output.\nop dout: { output distr | is_lossless dout } as dout_ll.\nhint exact random: dout_ll.\n\n(* -------------------------------------------------------------------- *)\n(** We use a public RF that, on input a seed, produces a seed and\n    an output...                                                        *)\nmodule type RF = {\n  proc * init() : unit\n  proc f(x:seed): seed * output\n}.\n\n(** ...to build a PRG that produces random outputs... **)\n(** We let our PRG have internal state, which we need to initialize **)\nmodule type PRG = {\n  proc * init(): unit\n  proc prg()   : output\n}.\n\n(* -------------------------------------------------------------------- *)\n(** Distinguishers can call\n  *   - the PRG at most qP times, and\n  *   - the PRF at most qF times, and\n  *   - return a boolean *)\nop qP : { int | 0 <= qP } as ge0_qP.\nop qF : { int | 0 <= qF } as ge0_qF.\n\nmodule type ARF = {\n  proc f(_:seed): seed * output\n}.\n\nmodule type APRG = {\n  proc prg(): output\n}.\n\nmodule type Adv (F:ARF) (P:APRG) = {\n  proc a(): bool\n}.\n\nmodule Exp (A:Adv) (F:RF) (P:PRG) = {\n  module A = A(F,P)\n\n  proc main():bool = {\n    var b: bool;\n\n         F.init();\n         P.init();\n    b <@ A.a();\n    return b;\n  }\n}.\n\n(** A PRG is secure iff it is indistinguishable from sampling in $dout\n    by an adversary with access to the PRF and the PRG interfaces *)\nmodule PrgI = {\n  proc init () : unit = { }\n\n  proc prg(): output = {\n    var r;\n\n    r <$ dout;\n    return r;\n  }\n}.\n(* Adv^PRG_A,F,P = `| Exp(A,F,P) - Exp(A,F,PrgI) | *)\n\n(* -------------------------------------------------------------------- *)\n(* Concrete considerations                                              *)\n\n(* We use the following RF *)\nmodule F = {\n  var m:(seed,seed * output) fmap\n\n  proc init(): unit = {\n     m <- empty;\n  }\n\n  proc f (x:seed) : seed * output = {\n    var r1, r2;\n\n    r1 <$ dseed;\n    r2 <$ dout;\n    if (x \\notin m)\n      m.[x] <- (r1,r2);\n\n    return oget (m.[x]);\n  }\n}.\n\nlemma FfL: islossless F.f.\nproof. islossless. qed.\n\n(* And we are proving the security of the following PRG *)\nmodule P (F:RF) = {\n  var seed: seed\n  var logP: seed list\n\n  proc init(): unit = {\n    seed <$ dseed;\n  }\n\n  proc prg(): output = {\n    var r;\n\n    (seed,r) <@ F.f (seed);\n    return r;\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\n(* We use the following oracle in an intermediate game that links two\n   sections.                                                            *)\n\nmodule Psample = {\n  proc init(): unit = {\n    P.seed <$ dseed;\n    P.logP <- [];\n  }\n\n  proc prg(): output = {\n    var r1, r2;\n\n    r1     <$ dseed;\n    r2     <$ dout;\n    P.logP <- P.seed :: P.logP;\n    P.seed <- r1;\n    return r2;\n  }\n}.\n\nlemma PsampleprgL: islossless Psample.prg.\nproof. islossless. qed.\n\n(* -------------------------------------------------------------------- *)\n(* In preparation of the eager/lazy reasoning step                      *)\n(* -------------------------------------------------------------------- *)\nmodule Resample = {\n  proc resample() : unit = {\n    var n, r;\n\n    n      <- size P.logP;\n    P.logP <- [];\n    P.seed <$ dseed;\n    while (size P.logP < n) {\n      r      <$ dseed;\n      P.logP <- r :: P.logP;\n    }\n  }\n}.\n\nmodule Exp'(A:Adv) = {\n  module A = A(F,Psample)\n\n  proc main():bool = {\n    var b : bool;\n         F.init();\n         Psample.init();\n    b <@ A.a();\n         Resample.resample();\n    return b;\n  }\n}.\n\n(* The Proof                                                            *)\n\nsection.\n  (* Forall Adversary A that does not share memory with P or F... *)\n  declare module A:Adv {P,F}.\n\n  (* ... and whose a procedure is lossless whenever F.f and P.prg are *)\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* We show that the adversary can distinguish P from Psample only\n     when P.prg is called twice with the same input. *)\n\n  (* First, we add some logging so we can express the bad event *)\n  local module Plog = {\n    proc init(): unit = {\n      P.seed <$ dseed;\n      P.logP <- [];\n    }\n\n    proc prg(): output = {\n      var r;\n\n      P.logP     <- P.seed :: P.logP;\n      (P.seed,r) <@ F.f(P.seed);\n      return r;\n    }\n  }.\n\n  local lemma PlogprgL: islossless Plog.prg.\n  proof. by proc; call FfL; wp. qed.\n\n  local lemma P_Plog &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] = Pr[Exp(A,F,Plog).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //.\n  by do !sim.\n  qed.\n\n  (* Bad holds whenever:\n   *  - there is a cycle in the state, OR\n   *  - an adversary query collides with an internal seed. *)\n  inductive Bad logP (m : ('a,'b) fmap) =\n    | Cycle of (!uniq logP)\n    | Collision r of (mem logP r) & (r \\in m).\n\n  lemma negBadE logP (m : ('a,'b) fmap):\n    !Bad logP m <=>\n      (uniq logP /\\ forall r, !mem logP r \\/ r \\notin m).\n  proof.\n  rewrite -iff_negb negbK negb_and negb_forall /=.\n  rewrite (@ exists_iff _ (predI (mem logP) (dom m)) _).\n  + by move=> a /=; rewrite negb_or /predI.\n  split=> [[->|r r_in_log r_in_m]|[/(Cycle _ m)|[r] @/predI [] /(Collision _ m r)]] //.\n  by right; exists r.\n  qed.\n\n  (* In this game, we replace the PRF queries with fresh sampling operations *)\n  inductive inv (m1 m2 : ('a,'b) fmap) (logP : 'a list) =\n    | Invariant of\n          (forall r, r \\in m1 <=> (r \\in m2 \\/ mem logP r))\n        & (forall r, r \\in m2 => m1.[r] = m2.[r]).\n\n  local lemma Plog_Psample &m:\n    Pr[Exp(A,F,Plog).main() @ &m: res] <=\n      Pr[Exp(A,F,Psample).main() @ &m: res] +\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (ler_trans (Pr[Exp(A,F,Psample).main() @ &m: res \\/ Bad P.logP F.m]));\n    last by rewrite Pr [mu_or]; smt w=mu_bounded.\n  byequiv (_: ={glob A} ==> !(Bad P.logP F.m){2} => ={res})=> // [|/#].\n  proc.\n  call (_: Bad P.logP F.m, ={P.seed} /\\ inv F.m{1} F.m{2} P.logP{2}).\n    (* adversary is lossless *)\n    by apply AaL.\n    (* [Psample.prg ~ Plog.prg: I] when Bad does not hold *)\n    proc; inline F.f. swap{2} 3 -2.\n    auto=> /> &1 &2 _ [] m1_is_m2Ulog m2_le_m1 r1 _ r2 _.\n    rewrite negBadE; case: (P.seed{2} \\in F.m{1})=> [/#|//=].\n    rewrite !get_setE /=.\n    move=> seed_notin_m1 _; split.\n      by move=> r; rewrite mem_set m1_is_m2Ulog /#.\n    move=> r ^/m2_le_m1; rewrite !get_setE=> -> r_in_m2.\n    by move: (iffRL _ _ (m1_is_m2Ulog r)); rewrite r_in_m2 /#.\n    (* Plog.prg is lossless when Bad holds *)\n    by move=> _ _; islossless.\n    (* Psample.prg preserves bad *)\n    move=> *; proc; auto=> />; rewrite dseed_ll dout_ll /=.\n    move=> &hr + v1 _ _ v2 _ _; case=> [h|r r_in_log r_in_m].\n    + by apply/Cycle; rewrite /= h.\n    by apply/(@Collision _ _ r)=> /=; [rewrite r_in_log|rewrite r_in_m].\n    (* [F.f ~ F.f: I] when Bad does not hold *)\n    proc; auto=> /> &1 &2; rewrite !negBadE.\n    move=> -[] uniq_log r_notin_logIm [] m_is_mUlog m2_le_m1 r1L _ r2L _.\n    case: (x{2} \\in F.m{2})=> [/#|//=].\n    case: (x{2} \\in F.m{1})=> /=.\n    + rewrite negBadE uniq_log=> /= /m_is_mUlog + x_notin_m2 h'; rewrite x_notin_m2 /=.\n      by move: (h' x{2}); rewrite mem_set.\n    rewrite !get_setE /= => x_notin_m1 x_notin_m2 _; split.\n    + by move=> r; rewrite !mem_set m_is_mUlog /#.\n    by move=> r; rewrite !mem_set !get_setE=> -[/m2_le_m1|] ->.\n    (* F.f is lossless when Bad holds *)\n    by move=> _ _; apply FfL.\n    (* F.f preserves bad *)\n    move=> _ //=; proc.\n    case (x \\in F.m).\n    + by rcondf 3; auto=> />; rewrite dseed_ll dout_ll.\n    rcondt 3; first by do !rnd; wp.\n    auto=> />; rewrite dseed_ll dout_ll //= => &hr bad_init x_notin_m v _ _ v0 _ _.\n    case: bad_init=> [/(Cycle<:seed,seed * output>) -> //|r r_in_log r_in_m].\n    by apply/(@Collision _ _ r)=> //=; rewrite mem_set r_in_m.\n  (* Returning to main *)\n  call (_: ={glob F} ==> ={glob P} /\\ inv F.m{1} F.m{2} P.logP{2}).\n  + by proc; auto=> /> &2 _ _; split.\n  call (_: true ==> ={glob F}); first by sim.\n  by auto=> /#.\n  qed.\n\n  local lemma Psample_PrgI &m:\n    Pr[Exp(A,F,Psample).main() @ &m: res] = Pr[Exp(A,F,PrgI).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //; proc.\n  call (_: ={glob F})=> //.\n    (* Psample.prg ~ PrgI.prg *)\n  + by proc; wp; rnd; rnd{1}; auto=> />; rewrite dseed_ll.\n    (* F.f *)\n  + by sim.\n  conseq (_: _ ==> ={glob A, glob F})=> //.\n  by inline *; auto=> />; rewrite dseed_ll.\n  qed.\n\n  local lemma Resample_resampleL: islossless Resample.resample.\n  proof.\n  proc; while (true) (n - size P.logP);\n    first by move=> z; auto; rewrite dseed_ll /#.\n  by auto; rewrite dseed_ll /#.\n  qed.\n\n  local module Exp'A = Exp'(A).\n\n  local lemma ExpPsample_Exp' &m:\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m]\n    = Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_: ={glob A} ==> ={P.logP, F.m})=> //; proc.\n  transitivity{1} { F.init(); Psample.init(); Resample.resample(); b <@ Exp'A.A.a(); }\n     (={glob A} ==> ={F.m, P.logP})\n     (={glob A} ==> ={F.m, P.logP})=> //.\n    (* Equality on A's globals *)\n  + by move=> &1 &2 A; exists (glob A){1}.\n    (* no sampling ~ presampling *)\n  + sim; inline Resample.resample Psample.init F.init.\n    rcondf{2} 7;\n      first by move=> &hr; rnd; wp; conseq (_: _ ==> true) => //.\n    by wp; rnd; wp; rnd{2} predT; auto; rewrite dseed_ll.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob F, glob Plog}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob Plog} ==> ={glob Plog})\n    : (={glob A, glob Plog, glob F})=> //;\n    first by sim.\n  eager proc H (={glob Plog, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r;\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r;\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0;\n    cP <- 0;\n    b <@ A.a();\n    return b;\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f.\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg.\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n     islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a.\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}.\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r).\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)).\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section."
    },
    {
        "file": "EC-1/PrIntervalToSum.ec",
        "incomplete": "require import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, ____(TYPE_0)____.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare ____(DECLARE_0)____ A <: RunMain.\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = big predT\n        (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ])\n        (range s (s + e + 1)).\nmove => a f P s. apply ge0ind.\nsmt().\nprogress . \nhave ->: Pr[A.run(a) @ &m : s <= f (glob A)  <= s /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : s  = f (glob A) /\\ P a res (glob A)].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: bigi predT \n              (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)]) \n              s (s + 1)\n       = Pr[A.run(a) @ &m : f (glob A) = s /\\ P a res (glob A) ].\nrewrite big_int1. auto. \nrewrite Pr[mu_eq]. auto. auto.\nprogress.\nhave ->: \n  Pr[A.run(a) @ &m : s <= f (glob A) <= s + (n + 1) /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ]\n = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A) ]\n + Pr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_disjoint]. progress. smt().\nauto.\nhave ->: bigi predT (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)] ) s (s + (n + 1) + 1)\n = Pr[A.run(a) @ &m : s <= f (glob A) <= s + n /\\ P a res (glob A)] +\nPr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A)].\nrewrite (big_int_recr). smt().  simplify.\nrewrite H0. auto. \nhave ->: (s + n + 1) = (s + (n + 1)).\nsmt().\nauto. auto.\nqed.\n\n\nlemma pr_interval_to_sum_lemma &m : forall (a : iat) \n  (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) \n  (s e : int),\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= e /\\ P a res (glob A) ]\n   = big predT\n      (fun i => Pr[ A.run(a) @ &m : f (glob A) = i \n                                   /\\ P a res (glob A) ])\n      (range s (e + 1)).\nproof. progress.\ncase (s <= e). move => sep.\nhave : exists e', 0 <= e' /\\ e = s + e'.\nexists (e - s). progress.\nsmt(). smt(). elim. progress.\napply (pr_interval_to_sum_lemma' &m a). auto. \nprogress.\nrewrite range_geq. smt(). \nrewrite big_nil.\nhave ->:  Pr[A.run(a) @ &m : (s <= f (glob A) && f (glob A) <= e) /\\ P a res (glob A)]\n = Pr[A.run(a) @ &m : false ].\nrewrite Pr[mu_eq]. smt(). auto.\nrewrite Pr[mu_false]. auto.\nqed.\n\nend section.",
        "complete:": "require import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, iat.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare module A <: RunMain.\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = big predT\n        (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ])\n        (range s (s + e + 1)).\nmove => a f P s. apply ge0ind.\nsmt().\nprogress . \nhave ->: Pr[A.run(a) @ &m : s <= f (glob A)  <= s /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : s  = f (glob A) /\\ P a res (glob A)].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: bigi predT \n              (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)]) \n              s (s + 1)\n       = Pr[A.run(a) @ &m : f (glob A) = s /\\ P a res (glob A) ].\nrewrite big_int1. auto. \nrewrite Pr[mu_eq]. auto. auto.\nprogress.\nhave ->: \n  Pr[A.run(a) @ &m : s <= f (glob A) <= s + (n + 1) /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ]\n = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A) ]\n + Pr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_disjoint]. progress. smt().\nauto.\nhave ->: bigi predT (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)] ) s (s + (n + 1) + 1)\n = Pr[A.run(a) @ &m : s <= f (glob A) <= s + n /\\ P a res (glob A)] +\nPr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A)].\nrewrite (big_int_recr). smt().  simplify.\nrewrite H0. auto. \nhave ->: (s + n + 1) = (s + (n + 1)).\nsmt().\nauto. auto.\nqed.\n\n\nlemma pr_interval_to_sum_lemma &m : forall (a : iat) \n  (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) \n  (s e : int),\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= e /\\ P a res (glob A) ]\n   = big predT\n      (fun i => Pr[ A.run(a) @ &m : f (glob A) = i \n                                   /\\ P a res (glob A) ])\n      (range s (e + 1)).\nproof. progress.\ncase (s <= e). move => sep.\nhave : exists e', 0 <= e' /\\ e = s + e'.\nexists (e - s). progress.\nsmt(). smt(). elim. progress.\napply (pr_interval_to_sum_lemma' &m a). auto. \nprogress.\nrewrite range_geq. smt(). \nrewrite big_nil.\nhave ->:  Pr[A.run(a) @ &m : (s <= f (glob A) && f (glob A) <= e) /\\ P a res (glob A)]\n = Pr[A.run(a) @ &m : false ].\nrewrite Pr[mu_eq]. smt(). auto.\nrewrite Pr[mu_false]. auto.\nqed.\n\nend section."
    },
    {
        "file": "EC-1/ProtocolAPI.ec",
        "incomplete": "(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol API we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = ____(TYPE_0)____.\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op ____(OP_0)____ = apiRes.\n\nend ProtocolAPI.",
        "complete:": "(** Concrete API working for an abstract protocol library *)\nrequire import AllCore List.\n\nrequire import AProtocolLibrary AAPI.\n\n(**\n  The protocol API class specifies the behaviour of an API\n  executing the MPC protocols disclosed by some protocol library.\n\n  Althogh the protocol API we provide here is designed to work\n  for any protocol library, we differentiate possible protocols that\n  could comprise the library and that would have different behaviours\n  in terms of API execution and how the program deals with the \n  outputs provided by the API.\n\n  Particularly, we characterise four protocol instances:\n    - [sop] protocols - that securely compute some secret operation [sop]\n    - [declassification] protocols - that declassify some secret value\n    revealing its value\n    - [input] protocols\n    - [output] protocols\n\n  Inside the API infrastructure, confidential values are stored \n  as secret variables, as secret data should not be used in the literal\n  format.\n*)\ntheory ProtocolAPI.\n\n  (** Protocol library *)\n  clone import ProtocolLibrary.\n\n  (** Secret variables *)\n  type svar_t.\n\n  (** API calls *)\n  (** \n    An API call can be either a call to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiCall_data = [\n    | Call_declass of svar_t\n    | Call_in of svar_t\n    | Call_out of svar_t\n    | Call_sop of sop_t & svar_t & value_t list & svar_t list\n  ].\n\n  (** API response *)\n  (** \n    The API can generate responses to the declassify protocol,\n    to an I/O operation to a secret operator protocol.\n  *)\n  type apiRes_data = value_t.\n\n  (** API interaction buffer *)\n  (**\n    The buffer used to interact with the API can be filled \n    either with an API call or with an API response\n  *)\n  type apiCallRes = [\n    | ApiCall of apiCall_data\n    | ApiRes of apiRes_data\n  ].\n\n  (** Extracts an API call from the buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option =\n    with x = ApiCall y => Some y\n    with x = ApiRes y => None.\n\n  (** Extracts an API response from the buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option =\n    with x = ApiCall y => None\n    with x = ApiRes y => Some y.\n\n  (** API realisation *)\n  clone import API with \n    type public_t = value_t,\n    type inputs_t = inputs_t,\n    type outputs_t = outputs_t,\n    type svar_t = svar_t,\n    type sop_t = sop_t,\n    type sideInfo_t = sideInfo_t,\n    type apiCall_data = apiCall_data,\n    type apiRes_data = apiRes_data,\n    type apiCallRes = apiCallRes,\n    op apiCall = apiCall,\n    op apiRes = apiRes.\n\nend ProtocolAPI."
    },
    {
        "file": "EC-1/PseudoRandFun.ec",
        "incomplete": "(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\n\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\nop F : key -> text -> text.  (* PRF *)\n\n(* end of theory parameters *)\n\n(* module type of random functions *)\n\nmodule type RF = {\n  (* initialization *)\n  proc init() : unit\n\n  (* application to a text *)\n  proc f(x : text) : text\n}.\n\n(* random function implementation using PRF *)\n\nmodule PRF : RF = {\n  var key : key\n\n  proc init() : unit = {\n    key <$ dkey;\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    y <- F key x;\n    return y;\n  }\n}.\n\n(* random function implemention using true randomness *)\n\nmodule TRF : RF = {\n  (* mp is a finite map associating texts with texts *)\n  var mp : (text, text) fmap\n\n  proc init() : unit = {\n    mp <- empty;  (* empty map *)\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    if (! x \\in mp) {   (* give x a random value in *)\n      y <$ dtext;  (* mp if not already in mp's domain *)\n      mp.[x] <- y;\n    }\n    return oget mp.[x];\n  }\n}.\n\n(* module type of random function adversaries, parameterized\n   by random function RF\n\n   adversary may only call RF.f (it can't initialize the random\n   function) *)\n\nmodule type RFA (RF : RF) = {\n  proc main() : bool {RF.f}\n}.\n\n(* random function game:\n\n   `|Pr[GRF(PRF, RFA).main() @ &m : res] -\n     Pr[GRF(TRF, RFA).main() @ &m : res]|\n\n   may be negligible, if F is \"good\", RFA is limited and RFA can't\n   read/write the global variables of PRF/TRF *)\n\nmodule GRF (RF : RF, RFA : RFA) = {\n  module A = RFA(RF)\n\n  proc main() : bool = {\n    var b : bool;\n    RF.init();\n    b <@ A.main();\n    return b;\n  }\n}.",
        "complete:": "(* PseudoRandFun.ec *)\n\n(* Pseudorandom Functions (PRFs) *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool FSet FMap.\n\n(* theory parameters *)\n\ntype key.  (* PRF keys *)\n\nop dkey : key distr.  (* full, uniform and lossless distribution on keys *)\n\n(* full means every element of type has non-zero value in\n   distribution; uniform means every element of type with non-zero\n   value in distribution has the same value in distribution; lossless\n   means the sum of the type's values in distribution is 1 *)\n\naxiom dkey_fu : is_full dkey.\naxiom dkey_uni : is_uniform dkey.\naxiom dkey_ll : is_lossless dkey.\n\ntype text.  (* texts *)\n\nop dtext : text distr.  (* full, uniform and lossless distribution on texts *)\n\naxiom dtext_fu : is_full dtext.\naxiom dtext_uni : is_uniform dtext.\naxiom dtext_ll : is_lossless dtext.\n\nop F : key -> text -> text.  (* PRF *)\n\n(* end of theory parameters *)\n\n(* module type of random functions *)\n\nmodule type RF = {\n  (* initialization *)\n  proc init() : unit\n\n  (* application to a text *)\n  proc f(x : text) : text\n}.\n\n(* random function implementation using PRF *)\n\nmodule PRF : RF = {\n  var key : key\n\n  proc init() : unit = {\n    key <$ dkey;\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    y <- F key x;\n    return y;\n  }\n}.\n\n(* random function implemention using true randomness *)\n\nmodule TRF : RF = {\n  (* mp is a finite map associating texts with texts *)\n  var mp : (text, text) fmap\n\n  proc init() : unit = {\n    mp <- empty;  (* empty map *)\n  }\n\n  proc f(x : text) : text = {\n    var y : text;\n    if (! x \\in mp) {   (* give x a random value in *)\n      y <$ dtext;  (* mp if not already in mp's domain *)\n      mp.[x] <- y;\n    }\n    return oget mp.[x];\n  }\n}.\n\n(* module type of random function adversaries, parameterized\n   by random function RF\n\n   adversary may only call RF.f (it can't initialize the random\n   function) *)\n\nmodule type RFA (RF : RF) = {\n  proc main() : bool {RF.f}\n}.\n\n(* random function game:\n\n   `|Pr[GRF(PRF, RFA).main() @ &m : res] -\n     Pr[GRF(TRF, RFA).main() @ &m : res]|\n\n   may be negligible, if F is \"good\", RFA is limited and RFA can't\n   read/write the global variables of PRF/TRF *)\n\nmodule GRF (RF : RF, RFA : RFA) = {\n  module A = RFA(RF)\n\n  proc main() : bool = {\n    var b : bool;\n    RF.init();\n    b <@ A.main();\n    return b;\n  }\n}."
    },
    {
        "file": "EC-1/RewMultRule.ec",
        "incomplete": "pragma Goals:printall.\nrequire import AllCore.\nrequire import RewBasics.\n\ntype ex1at, ex2at, ____(TYPE_0)____, ex2rt.\n\nmodule type RewEx1Ex2 = {\n  proc getState() : sbits\n  proc setState(b : sbits) : unit \n  proc ex1(x1 : ex1at) : ex1rt\n  proc ex2(x2 : ex2at) : ex2rt\n}.\n\n\nmodule GetExec1Set(A : RewEx1Ex2) = {\n  proc main(x1 : ex1at) = {\n    var s , r;\n    s <@ A.getState();\n    r <@ A.ex1(x1);\n    A.setState(s);\n    return r;\n  }\n}.\n\n\nmodule GetExec1SetExec2Conj(A : RewEx1Ex2) = {\n  module GRS = GetExec1Set(A)\n  proc main(x1 : ex1at, x2 : ex2at) = {\n    var  r1, r2, x11, x22;\n    x11 <- x1; (* PAPER: cannot prove x{hr} = x{hr} *)\n    x22 <- x2;\n    r1 <@ GRS.main(x11);\n    r2 <@ A.ex2(x22);\n    return (r1, r2); \n  }\n}.\n\n\nmodule MultTriv(A : RewRun, B : RewRun) = {\n  proc main(x : iat2, y : iat2) = {\n     var r1, r2;\n     r1 <@ A.run(x);\n     r2 <@ B.run(y);\n     return (r1, r2);\n  }\n}.\n\n\nlemma rew_mult_simple : forall (P <: RewRun) (Q <: RewRun{-P}) &m M1 M2  i1 i2,\n    islossless P.run => islossless Q.run =>\n    Pr[ MultTriv(P,Q).main(i1,i2) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ P.run(i1) @ &m : M1 res ] * Pr[ Q.run(i2) @ &m : M2 res ].\nproof. progress. byphoare (_: (glob P) = (glob P){m} /\\ (glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2 ==> _).\nproc. simplify.\npose p := (Pr[P.run(i1) @ &m : M1 res]).\npose q := (Pr[Q.run(i2) @ &m : M2 res]).\nseq 1 : (M1 r1) p q p (0%r) ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2 ).\ncall (_:true). skip. auto.\n   have ph1 : forall &n x, phoare[ P.run : z = x /\\ (glob P) = (glob P){n} ==> M1 res ] = (Pr[ P.run(x) @ &n : M1 res ]).\n   progress. bypr. progress. byequiv. proc*. call (_:true). skip. auto. auto. auto.\n   call (ph1 &m  i1). skip.  progress.\nconseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2). smt(). smt().\n   have ph2 : forall &n x, phoare[ Q.run : z = x /\\ (glob Q) = (glob Q){n} ==> M2 res ] = (Pr[ Q.run(x) @ &n : M2 res ]).\n   progress. bypr. progress. byequiv. proc*. call (_:true). skip.  progress. auto. auto.\n   rewrite /q. call (ph2 &m i2). skip.  progress.\nhoare. call (_:true). skip. smt().\nsmt().\nsmt().\nauto.\nqed.\n\n\nsection.\ndeclare module A <: RewEx1Ex2.\n\n\n(* getState lossless follows from rewindable_A, \n  but setState lossless does not, so we ask it *)\n(* PAPER: we cannot put these things globally into the section because \"op f : glob A -> sbits\" is not allowed *)\ndeclare axiom RewProp :\n  exists (f : glob A -> sbits),\n  injective f /\\\n  (forall &m, Pr[ A.getState() @ &m : (glob A) = ((glob A){m})\n                                   /\\ res = f ((glob A){m} ) ] = 1%r) /\\\n  (forall &m b (x: glob A), b = f x =>\n    Pr[A.setState(b) @ &m : glob A = x] = 1%r) /\\\n  islossless A.setState.\n\n\n\n(*  Double run and the respective probabilities: \n forall &m, if   Pr[ A.exec1 @ &m : r ] = p and\n                 Pr[ A.exec1 @ &m : r ] = q\n then Pr[  s <- A.getState; r1 <- A.exec1 ; \n          A.setState(s); r2 <- A.exec2 @ &m \n                       : r1 /\\ r2 ] = p * q  \n*)\nlocal lemma ex1ex2_1 M1 x1 : forall (ga : glob A),  forall (p : real),\n       phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ GetExec1Set(A).main :  arg = x1 /\\ (glob A) = ga ==> M1 res /\\ (glob A) = ga ] = p.\nproof.  move => ga p ph. \nproc. \nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nseq 2 : (M1 r) p (1%r) p  (0%r) (s = fA ga). \ncall (_:true).\ncall (s2h ga). skip. by progress.\ncall ph.\ncall (s2 ga). skip. auto.\ncall (s3 ga). skip. auto.\nhoare.\ncall (_:true). skip. progress. smt().\nauto. \nqed.\n\n\nlocal lemma ex1ex2_2 M1 x1 : forall (ga : glob A), forall (p : real),\n       phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p.\nproof. move => ga p ph.\nproc. \nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nseq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga). \ncall (_:true).\ncall (s2h ga). skip. by progress.\ncall ph.\ncall (s2 ga). skip. auto.\ncall (s3 ga). skip. auto.\nhoare.\ncall (_:true). skip. progress.  smt().\nqed.\n\n\nlemma rew_clean : forall &m  M1 i1 , \n     Pr[ GetExec1Set(A).main(i1) @ &m : M1 res /\\ (glob A) = (glob A){m} ] = Pr[ A.ex1(i1) @ &m : M1 res ].\nproof. move => &m M1 x1.\n  have ph1 : forall &n x1, phoare[ A.ex1 : arg = x1 /\\ (glob A) = (glob A){n} ==> M1 res ] = Pr[ A.ex1(x1) @ &n : M1 res ].\n  progress. bypr. progress. byequiv. proc*. call (_:true). skip. progress. auto. auto.\n  have ph2 : forall &n i1, phoare[ GetExec1Set(A).main : arg = i1 /\\ (glob A) = (glob A){n} ==> M1 res /\\ (glob A) = (glob A){n} ] \n                           = Pr[ A.ex1(i1) @ &n : M1 res ].\n  progress. proc*. call (ex1ex2_1 M1 i1  (glob A){n} (Pr[ A.ex1(i1) @ &n : M1 res ])).\n  apply ph1. skip. progress.\nbyphoare (_: arg = x1 /\\ (glob A) = (glob A){m} ==> _). proc*. call (ph2 &m x1). skip. auto. auto. auto.\nqed.\n\n    \nlocal lemma ex1ex2_3 &m M1 M2 a1 a2 : forall (ga : glob A), \n forall (p q : real),  (glob A){m} = ga\n    => phoare[ A.ex1 : arg = a1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ A.ex2 : arg = a2 /\\ (glob A) = ga ==> M2 res ] = q\n    => Pr[ GetExec1SetExec2Conj(A).main(a1,a2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof. move => ga p q se ph hp. \nbyphoare (_ : arg.`1 = a1 /\\ arg.`2 = a2 /\\ (glob A) = ga ==> _).\nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nproc.\nseq 3 : (M1 r1) p q p (0%r) ((glob A) = ga /\\ x11 = a1 /\\ x22 = a2). \ninline*.\nwp.\ncall (s3h ga).\ncall (_:true).\ncall (s2h ga).\nwp. skip.\nprogress. \nsp.\ncall (ex1ex2_2 M1 a1 ga p). \n skip. auto.\ncall hp.\nskip. progress.   auto. \nhoare.\ncall (_:true).\nauto. smt().\nauto.\nauto.\nauto.\nqed.\n\n\nlocal lemma ex1ex2_main  &m M1 M2 x1 x2 (ga: glob A) (p q : real) :  (glob A){m} = ga\n   => (forall &n, (glob A){n} = ga => Pr[ A.ex1(x1) @ &n : M1 res ] = p)\n   => (forall &n, (glob A){n} = ga => Pr[ A.ex2(x2) @ &n : M2 res ] = q)\n   => Pr[ GetExec1SetExec2Conj(A).main(x1,x2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof. move => gae pr1 pr2. \nhave z1 : phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p.\nbypr. progress. apply (pr1 &m0 ).\nauto. \nhave z2 : phoare[ A.ex2 : arg = x2 /\\ (glob A) = ga ==> M2 res ] = q.\nbypr. progress. apply (pr2 &m0 ).\nauto. \napply (ex1ex2_3 &m M1 M2 x1 x2 ga). assumption.\nconseq z1. apply z2. \nqed.\n\n\nlocal lemma ex1ex2_main_special &m M1 M2 i1 i2 (p q : real):\n      Pr[ A.ex1(i1) @ &m : M1 res ] = p =>\n      Pr[ A.ex2(i2) @ &m : M2 res ] = q =>\n      Pr[ GetExec1SetExec2Conj(A).main(i1,i2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof.\nmove => Hrun1 Hrun2.\napply(ex1ex2_main &m M1 M2 i1 i2 (glob A){m} p q).\nby reflexivity. \nhave se1 : Pr[A.ex1(i1) @ &m : M1 res] = Pr[A.ex1(i1) @ &m : M1 res].\nbyequiv (_:(={glob A, x1}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nrewrite - Hrun1.\nprogress.\nbyequiv (_:(={glob A, x1}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nhave se1 : Pr[A.ex2(i2) @ &m : M2 res] = Pr[A.ex2(i2) @ &m : M2 res].\nbyequiv (_:(={glob A, x2}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nrewrite - Hrun2.\nprogress.\nbyequiv (_:(={glob A, x2}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nqed.\n\n\nlemma rew_mult_law &m M1 M2 i1 i2:\n      Pr[ GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ A.ex1(i1) @ &m : M1 res ] * Pr[ A.ex2(i2) @ &m : M2 res ].\nproof. apply (ex1ex2_main_special &m M1 M2). auto. auto.\nqed.\n\n\nend section.",
        "complete:": "pragma Goals:printall.\nrequire import AllCore.\nrequire import RewBasics.\n\ntype ex1at, ex2at, ex1rt, ex2rt.\n\nmodule type RewEx1Ex2 = {\n  proc getState() : sbits\n  proc setState(b : sbits) : unit \n  proc ex1(x1 : ex1at) : ex1rt\n  proc ex2(x2 : ex2at) : ex2rt\n}.\n\n\nmodule GetExec1Set(A : RewEx1Ex2) = {\n  proc main(x1 : ex1at) = {\n    var s , r;\n    s <@ A.getState();\n    r <@ A.ex1(x1);\n    A.setState(s);\n    return r;\n  }\n}.\n\n\nmodule GetExec1SetExec2Conj(A : RewEx1Ex2) = {\n  module GRS = GetExec1Set(A)\n  proc main(x1 : ex1at, x2 : ex2at) = {\n    var  r1, r2, x11, x22;\n    x11 <- x1; (* PAPER: cannot prove x{hr} = x{hr} *)\n    x22 <- x2;\n    r1 <@ GRS.main(x11);\n    r2 <@ A.ex2(x22);\n    return (r1, r2); \n  }\n}.\n\n\nmodule MultTriv(A : RewRun, B : RewRun) = {\n  proc main(x : iat2, y : iat2) = {\n     var r1, r2;\n     r1 <@ A.run(x);\n     r2 <@ B.run(y);\n     return (r1, r2);\n  }\n}.\n\n\nlemma rew_mult_simple : forall (P <: RewRun) (Q <: RewRun{-P}) &m M1 M2  i1 i2,\n    islossless P.run => islossless Q.run =>\n    Pr[ MultTriv(P,Q).main(i1,i2) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ P.run(i1) @ &m : M1 res ] * Pr[ Q.run(i2) @ &m : M2 res ].\nproof. progress. byphoare (_: (glob P) = (glob P){m} /\\ (glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2 ==> _).\nproc. simplify.\npose p := (Pr[P.run(i1) @ &m : M1 res]).\npose q := (Pr[Q.run(i2) @ &m : M2 res]).\nseq 1 : (M1 r1) p q p (0%r) ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2 ).\ncall (_:true). skip. auto.\n   have ph1 : forall &n x, phoare[ P.run : z = x /\\ (glob P) = (glob P){n} ==> M1 res ] = (Pr[ P.run(x) @ &n : M1 res ]).\n   progress. bypr. progress. byequiv. proc*. call (_:true). skip. auto. auto. auto.\n   call (ph1 &m  i1). skip.  progress.\nconseq (_: ((glob Q) = (glob Q){m} /\\ x = i1 /\\ y = i2) ==> M2 r2). smt(). smt().\n   have ph2 : forall &n x, phoare[ Q.run : z = x /\\ (glob Q) = (glob Q){n} ==> M2 res ] = (Pr[ Q.run(x) @ &n : M2 res ]).\n   progress. bypr. progress. byequiv. proc*. call (_:true). skip.  progress. auto. auto.\n   rewrite /q. call (ph2 &m i2). skip.  progress.\nhoare. call (_:true). skip. smt().\nsmt().\nsmt().\nauto.\nqed.\n\n\nsection.\ndeclare module A <: RewEx1Ex2.\n\n\n(* getState lossless follows from rewindable_A, \n  but setState lossless does not, so we ask it *)\n(* PAPER: we cannot put these things globally into the section because \"op f : glob A -> sbits\" is not allowed *)\ndeclare axiom RewProp :\n  exists (f : glob A -> sbits),\n  injective f /\\\n  (forall &m, Pr[ A.getState() @ &m : (glob A) = ((glob A){m})\n                                   /\\ res = f ((glob A){m} ) ] = 1%r) /\\\n  (forall &m b (x: glob A), b = f x =>\n    Pr[A.setState(b) @ &m : glob A = x] = 1%r) /\\\n  islossless A.setState.\n\n\n\n(*  Double run and the respective probabilities: \n forall &m, if   Pr[ A.exec1 @ &m : r ] = p and\n                 Pr[ A.exec1 @ &m : r ] = q\n then Pr[  s <- A.getState; r1 <- A.exec1 ; \n          A.setState(s); r2 <- A.exec2 @ &m \n                       : r1 /\\ r2 ] = p * q  \n*)\nlocal lemma ex1ex2_1 M1 x1 : forall (ga : glob A),  forall (p : real),\n       phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ GetExec1Set(A).main :  arg = x1 /\\ (glob A) = ga ==> M1 res /\\ (glob A) = ga ] = p.\nproof.  move => ga p ph. \nproc. \nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nseq 2 : (M1 r) p (1%r) p  (0%r) (s = fA ga). \ncall (_:true).\ncall (s2h ga). skip. by progress.\ncall ph.\ncall (s2 ga). skip. auto.\ncall (s3 ga). skip. auto.\nhoare.\ncall (_:true). skip. progress. smt().\nauto. \nqed.\n\n\nlocal lemma ex1ex2_2 M1 x1 : forall (ga : glob A), forall (p : real),\n       phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ GetExec1Set(A).main : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p.\nproof. move => ga p ph.\nproc. \nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nseq 2 : (M1 r) p (1%r) p (0%r) (s = fA ga). \ncall (_:true).\ncall (s2h ga). skip. by progress.\ncall ph.\ncall (s2 ga). skip. auto.\ncall (s3 ga). skip. auto.\nhoare.\ncall (_:true). skip. progress.  smt().\nqed.\n\n\nlemma rew_clean : forall &m  M1 i1 , \n     Pr[ GetExec1Set(A).main(i1) @ &m : M1 res /\\ (glob A) = (glob A){m} ] = Pr[ A.ex1(i1) @ &m : M1 res ].\nproof. move => &m M1 x1.\n  have ph1 : forall &n x1, phoare[ A.ex1 : arg = x1 /\\ (glob A) = (glob A){n} ==> M1 res ] = Pr[ A.ex1(x1) @ &n : M1 res ].\n  progress. bypr. progress. byequiv. proc*. call (_:true). skip. progress. auto. auto.\n  have ph2 : forall &n i1, phoare[ GetExec1Set(A).main : arg = i1 /\\ (glob A) = (glob A){n} ==> M1 res /\\ (glob A) = (glob A){n} ] \n                           = Pr[ A.ex1(i1) @ &n : M1 res ].\n  progress. proc*. call (ex1ex2_1 M1 i1  (glob A){n} (Pr[ A.ex1(i1) @ &n : M1 res ])).\n  apply ph1. skip. progress.\nbyphoare (_: arg = x1 /\\ (glob A) = (glob A){m} ==> _). proc*. call (ph2 &m x1). skip. auto. auto. auto.\nqed.\n\n    \nlocal lemma ex1ex2_3 &m M1 M2 a1 a2 : forall (ga : glob A), \n forall (p q : real),  (glob A){m} = ga\n    => phoare[ A.ex1 : arg = a1 /\\ (glob A) = ga ==> M1 res ] = p\n    => phoare[ A.ex2 : arg = a2 /\\ (glob A) = ga ==> M2 res ] = q\n    => Pr[ GetExec1SetExec2Conj(A).main(a1,a2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof. move => ga p q se ph hp. \nbyphoare (_ : arg.`1 = a1 /\\ arg.`2 = a2 /\\ (glob A) = ga ==> _).\nelim (rewindable_A_plus A RewProp).\nmove => fA [s1 [s2 [s2h [s2ll [s3 [s3h ]]]] ]] s3ll.\nproc.\nseq 3 : (M1 r1) p q p (0%r) ((glob A) = ga /\\ x11 = a1 /\\ x22 = a2). \ninline*.\nwp.\ncall (s3h ga).\ncall (_:true).\ncall (s2h ga).\nwp. skip.\nprogress. \nsp.\ncall (ex1ex2_2 M1 a1 ga p). \n skip. auto.\ncall hp.\nskip. progress.   auto. \nhoare.\ncall (_:true).\nauto. smt().\nauto.\nauto.\nauto.\nqed.\n\n\nlocal lemma ex1ex2_main  &m M1 M2 x1 x2 (ga: glob A) (p q : real) :  (glob A){m} = ga\n   => (forall &n, (glob A){n} = ga => Pr[ A.ex1(x1) @ &n : M1 res ] = p)\n   => (forall &n, (glob A){n} = ga => Pr[ A.ex2(x2) @ &n : M2 res ] = q)\n   => Pr[ GetExec1SetExec2Conj(A).main(x1,x2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof. move => gae pr1 pr2. \nhave z1 : phoare[ A.ex1 : arg = x1 /\\ (glob A) = ga ==> M1 res ] = p.\nbypr. progress. apply (pr1 &m0 ).\nauto. \nhave z2 : phoare[ A.ex2 : arg = x2 /\\ (glob A) = ga ==> M2 res ] = q.\nbypr. progress. apply (pr2 &m0 ).\nauto. \napply (ex1ex2_3 &m M1 M2 x1 x2 ga). assumption.\nconseq z1. apply z2. \nqed.\n\n\nlocal lemma ex1ex2_main_special &m M1 M2 i1 i2 (p q : real):\n      Pr[ A.ex1(i1) @ &m : M1 res ] = p =>\n      Pr[ A.ex2(i2) @ &m : M2 res ] = q =>\n      Pr[ GetExec1SetExec2Conj(A).main(i1,i2) @ &m : M1 res.`1 /\\ M2 res.`2 ] = p * q.\nproof.\nmove => Hrun1 Hrun2.\napply(ex1ex2_main &m M1 M2 i1 i2 (glob A){m} p q).\nby reflexivity. \nhave se1 : Pr[A.ex1(i1) @ &m : M1 res] = Pr[A.ex1(i1) @ &m : M1 res].\nbyequiv (_:(={glob A, x1}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nrewrite - Hrun1.\nprogress.\nbyequiv (_:(={glob A, x1}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nhave se1 : Pr[A.ex2(i2) @ &m : M2 res] = Pr[A.ex2(i2) @ &m : M2 res].\nbyequiv (_:(={glob A, x2}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nrewrite - Hrun2.\nprogress.\nbyequiv (_:(={glob A, x2}) ==> _). proc*. call(_:true). skip. progress. auto. auto.\nqed.\n\n\nlemma rew_mult_law &m M1 M2 i1 i2:\n      Pr[ GetExec1SetExec2Conj(A).main(i1, i2) @ &m : M1 res.`1 /\\ M2 res.`2 ]\n    = Pr[ A.ex1(i1) @ &m : M1 res ] * Pr[ A.ex2(i2) @ &m : M2 res ].\nproof. apply (ex1ex2_main_special &m M1 M2). auto. auto.\nqed.\n\n\nend section."
    },
    {
        "file": "EC-1/RewSumBindingAux.ec",
        "incomplete": "pragma Goals:printall.\n\nrequire import AllCore Distr Real DBool.\nrequire RewBasics.\n\ntheory RSBH.\n\ntype sbits, irt, rrt,____(TYPE_0)____.\n\n\nop pair_sbits : sbits * sbits -> sbits.\nop unpair: sbits -> sbits * sbits.\naxiom ips: injective pair_sbits. \naxiom unpair_pair x : unpair (pair_sbits x) = x.\n\nclone import RewBasics as RW with type sbits <- sbits,\n                                  type rrt <- rrt,\n                                  type irt <- irt,\n                                  type iat <- iat,\n                                  op pair_sbits <- pair_sbits,\n                                  op unpair <____(OP_0)____ unpair.\n\n\n\nmodule type Initializer = {\n  proc init(i:iat) : irt\n}.\n\n\nmodule type RewRunExec1Exec2 = {\n  proc getState() : sbits\n  proc setState(b : sbits) : unit (* EasyCrypt removed support for \"proc *\" *)\n  proc run(i : irt) : rrt\n  proc ex1(i : irt) : rrt\n  proc ex2(i : irt) : rrt\n}.\n\n\nmodule SBB (A : RewRunExec1Exec2) = {\n  proc run(i : irt) = {\n    var r, x;\n    x <$ {0,1};    \n    if (x) {\n      r <@ A.ex1(i);\n    }else{\n      r <@ A.ex2(i);\n    }\n     return r;\n  }    \n\n  proc getState() : sbits = {\n    var s;\n    s <@ A.getState();\n    return s;\n  }\n  proc setState(b : sbits) : unit  = {\n    A.setState(b);\n  }\n}.\n\nmodule SB (A : RewRunExec1Exec2, B : Initializer) = {\n  module SBB = SBB(A)\n\n  proc main(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@  SBB.run(ix);\n    A.setState(s);\n    r2 <@ SBB.run(ix);\n    return (r1 , r2);\n  }\n\n  proc main_run(i:iat) = {\n    var ix,r;\n    ix <@ B.init(i);\n    r <@ SBB.run(ix);\n    return r;\n  }\n  \n  proc main_12(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n  \n  proc main_21(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n\n  proc main_11(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n\n  proc main_22(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n\n  proc main_1(i:iat) = {\n    var r,ix;\n    ix <@ B.init(i);\n    r <@ A.ex1(ix);\n    return r;\n  }\n\n  proc main_2(i:iat) = {\n    var r, ix;\n    ix <@ B.init(i);\n    r <@ A.ex2(ix);\n    return r;\n  }\n}.\n\n\nsection.\ndeclare module A <: RewRunExec1Exec2.\ndeclare module B <: Initializer.\n\ndeclare axiom Afl : islossless A.ex1.\ndeclare axiom Agl : islossless A.ex2.\ndeclare axiom Ass : islossless A.setState.\ndeclare axiom Bsens : equiv[ B.init ~ B.init : ={i, glob A, glob B} ==> ={glob A, res} ].\n\n\nlocal module M = {\n  var x1, x2 : bool\n  proc run(i : irt) = {\n    var r, x;\n    x <$ {0,1};    \n    if (x) {\n      r <@ A.ex1(i);\n    }else{\n      r <@ A.ex2(i);\n    }\n   return (r,x);\n  }  \n\n  proc main(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    (r1, x1) <@ run(ix);\n    A.setState(s);\n    (r2, x2) <@ run(ix);\n    return (r1,r2);\n  } \n\n  proc main_12(i:iat) = {\n    var ix,r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n\n  proc main_12'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_12(i);\n    return (r , x1 /\\ !x2);\n  }  \n\n  proc main_11(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1 , r2);\n  }\n  \n  proc main_11'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_11(i);\n    return (r, x1 /\\ x2);\n  }  \n\n  proc main_21(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n  \n  proc main_21'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_21(i);\n    return (r, !x1 /\\ x2);\n  }  \n\n  proc main_22(i:iat) = {\n    var ix,r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1,r2);\n  }\n  \n  proc main_22'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_22(i);\n    return (r, !x1 /\\ !x2);\n  }  \n\n  proc main_run(i:iat) = {\n    var ix, r;\n    ix <@ B.init(i);\n    (r,x1) <@ run(ix);\n    return r;\n  }\n\n  proc main_1(i:iat) = {\n    var ix,r;\n    ix <@ B.init(i);\n    r <@ A.ex1(ix);\n    return r;\n  }\n\n  proc main_1'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    r <@ main_1(i);\n    return (r, x1);\n  }  \n\n  proc main_2(i:iat) = {\n    var ix, r;\n    ix <@ B.init(i);\n    r <@ A.ex2(ix);\n    return r;\n  }\n\n  proc main_2'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    r <@ main_2(i);\n    return (r, !x1);\n  }  \n}.\n\n\nlocal lemma vau_uav_1 P : equiv [ M.main_run ~ M.main_1' : ={i, glob A, glob B} \n                                ==> P res{1} /\\ M.x1{1}  <=> P res{2}.`1 /\\ res{2}.`2 ].\nproof. proc. inline*.\nswap {2} [2..3] -1. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip.   progress.  sp.\nseq 1 1 : (i0{1} = ix{2} /\\ ={glob A, ix} /\\ x{1} = M.x1{2}).\nrnd. skip. progress.\nif {1}.\nwp. seq 1 1 : (={glob A, r0} /\\ x{1} = M.x1{2}).\ncall(_:true). skip. progress. skip. progress.\nwp. call {2} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Agl. skip. progress.\nqed.\nlocal lemma probEq_1 &m P i : Pr[ M.main_run(i) @ &m :  P res /\\ M.x1 ] = Pr[ M.main_1'(i) @ &m : P res.`1 /\\ res.`2 ].\nproof. byequiv. conseq (vau_uav_1 P). progress. smt(). smt(). auto. auto.\nqed.\nlocal lemma bitsout_1 &m P j : Pr[ M.main_1'(j) @ &m : P res.`1 /\\ res.`2 ] = Pr[ M.main_1(j) @ &m : P res ] / 2%r.\nproof.\nbyphoare (_: arg = j /\\  (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_1(j) @ &m : P res ].\nseq 1 : (M.x1) (1%r/2%r) z (1%r - 1%r/2%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd.  skip. progress.\nrnd.  skip. progress. smt(@DBool).\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r). smt(). smt().\nhave phl : phoare [ M.main_1 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ arg = j ==> P res ] \n           = Pr[ M.main_1(j) @ &m : P res ].\nbypr. move => &m0  pr1.\nbyequiv (_: ={i, glob A, glob B} /\\ i{1} = j  ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. progress.  \ncall (_:true). skip.  smt().  progress. smt().  smt(). smt(). auto. smt().  auto.\ncall phl. skip. auto. progress. \ninline*. wp. hoare. call (_:true). call(_:true).  wp.\nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_1 &m P i : Pr[ M.main_run(i) @ &m :  P res /\\ M.x1 ]\n                             = Pr[ M.main_1(i) @ &m : P res ] / 2%r.\nproof. rewrite probEq_1. rewrite bitsout_1. auto.\nqed.\n\n\nlocal lemma vau_uav_2 P  : equiv [ M.main_run ~ M.main_2' : ={glob A, glob B, i} \n                                 ==> P res{1} /\\ !M.x1{1} <=> P res{2}.`1 /\\ res{2}.`2 ].\nproof. proc. inline*.\nswap {2} [2..3] -1.\nseq 1 2 : (={glob A, ix}). sp. call Bsens. skip. auto. sp.\nseq 1 1 : (i0{1} = ix{1} /\\ ={glob A, ix} /\\ x{1} = M.x1{2}).\nrnd. skip. progress.\nif {1}.\nwp. call {2} (_: true ==> true). apply Agl.\ncall {1} (_: true ==> true). apply Afl. skip. progress.\nwp. call (_:true). skip. progress.\nqed.\nlocal lemma probEq_2  &m P j : Pr[ M.main_run(j) @ &m :  P res /\\ !M.x1 ] = Pr[ M.main_2'(j) @ &m : P res.`1 /\\ res.`2 ].\nproof. byequiv. conseq (vau_uav_2 P). progress. smt(). smt(). auto. auto.\nqed.\nlocal lemma bitsout_2 &m P j : Pr[ M.main_2'(j) @ &m : P res.`1 /\\ res.`2 ] = Pr[ M.main_2(j) @ &m : P res ] / 2%r.\nproof.\nbyphoare (_: i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_2(j) @ &m : P res ].\nseq 1 : (!M.x1) (1%r/2%r) z (1%r - 1%r/2%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd.  skip. progress.\nrnd.  skip. progress. smt(@DBool).\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r). smt(). smt().\nhave phl : phoare [ M.main_2 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res ] \n           = (Pr[ M.main_2(j) @ &m : P res ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={i,glob A, glob B} ==> _). proc. seq 1 1 : (={glob A,ix}). call Bsens.\nskip. auto.\ncall (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). wp. \nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_2 &m P j : Pr[ M.main_run(j) @ &m :  P res /\\ !M.x1 ]\n                             = Pr[ M.main_2(j) @ &m : P res ] / 2%r.\nproof. rewrite probEq_2. rewrite bitsout_2. auto.\nqed.\n\n\nlemma fact3 &m P j : Pr[SB(A,B).main_run(j) @ &m : P res ] = 1%r / 2%r * Pr[SB(A,B).main_1(j) @ &m : P res ] \n                                                           + 1%r / 2%r * Pr[SB(A,B).main_2(j) @ &m : P res ].\nproof.\nhave e0 : Pr[SB(A, B).main_run(j) @ &m : P res ] = Pr[M.main_run(j) @ &m : P res ].\nbyequiv (_: (={i, glob A, glob B}) ==> _). proc. inline*.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto. sp. wp.\nseq 1 1 : (i0{2} = ix{2} /\\ i0{1} = ix{1} /\\ ={glob A, ix,x}). rnd. skip. progress.\nif.  auto. call (_:true). skip. progress. call (_:true). skip. progress.\nauto. auto.\nhave e1 : Pr[SB(A, B).main_1(j) @ &m : P res] = Pr[M.main_1(j) @ &m : P res].\nbyequiv (_: (={i,glob A, glob B}) ==> _). proc. inline*. seq 1 1 : (={glob A, ix}). \ncall Bsens. skip. auto.  call (_:true). skip. progress.\nauto.  auto.\nhave e2 : Pr[SB(A, B).main_2(j) @ &m : P res] = Pr[M.main_2(j) @ &m : P res].\nbyequiv (_: (={glob A, glob B,i}) ==> _). proc.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). skip. progress.\nauto. auto.\nrewrite e0 e1 e2.\nrewrite Pr[mu_split M.x1]. rewrite main_lemma_1. rewrite main_lemma_2. smt(). \nqed.\n\n\nlocal lemma vau_22 P : equiv [ M.main ~ M.main_22' : ={arg, glob A, glob B} \n                       ==> P res{1}.`1 /\\ P res{1}.`2 /\\ !M.x1{1} /\\ !M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix} ). call Bsens. skip. auto.\nseq 3 3 : (={ix,glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}. simplify.\nseq 3 2 : (M.x1{1}).\nwp. call {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {2} (_: true ==> true). apply Agl. skip. progress. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nseq 3 2 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{1}.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall(_:true). skip. auto.\nqed.\nlocal lemma uav_22 P : equiv [ M.main_22' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ !M.x1{2} /\\ !M.x2{2} ].\n proc.  inline*. wp.\nswap {1} [3..4] -2. sp.\nswap {2} 4 -2.\nswap {2} 9 -6.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 : (M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {2} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Agl. skip. progress. sp.\nif{2}.  call {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Agl.\nskip. progress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nseq 2 3 : (={ix, glob A, r1, M.x1} /\\ !M.x1{2} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{2}.\ncall {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Agl.\nskip. smt().\ncall(_:true). skip. auto.\nqed.\nlocal lemma probEq_22 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n                               = Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n         <= Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_22 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n         >= Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2  /\\ res.`2 ].\nbyequiv. conseq (uav_22 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_22 &m P j : Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                               = Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: arg = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (!M.x1 /\\ !M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (!M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_22 : arg = j /\\ ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) ==> P res.`1 /\\ P res.`2 ] \n         = (Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={arg, glob A, glob B} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_22 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ]\n                             = Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.  rewrite probEq_22. rewrite bitsout_22. auto.\nqed.\n    \n\nlocal lemma vau_21 P : equiv [ M.main ~ M.main_21' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ !M.x1{1} /\\ M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1} /\\ M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {2} (_: true ==> true). apply Agl. skip. progress. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. progress.\nseq 3 2 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{1}. call(_:true). skip. progress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nqed.\nlocal lemma uav_21 P : equiv [ M.main_21' ~ M.main : ={arg, glob A, glob B} ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ !M.x1{2} /\\ M.x2{2} ].\nproc.  inline*. wp.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 : (i0{2} = ix{2} /\\ M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. progress. sp.\nif{2}.  call {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Afl.\nskip. smt(). call {2} (_:true ==> true). apply Agl.\ncall {1} (_:true ==> true). apply Afl.\nskip. progress.\nseq 2 3 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{2}. call(_:true). skip. progress.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\nqed.\nlocal lemma probEq_21 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n                             = Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n         <= Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_21 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n         >= Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_21 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_21 &m P j : Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                              = Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (!M.x1 /\\ M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (!M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: (i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_21 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={arg, glob A, glob B} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_21 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ]\n                             = Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.  rewrite probEq_21. rewrite bitsout_21. auto.\nqed.\n\n\nlocal lemma vau_11 P : equiv [ M.main ~ M.main_11' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ M.x1{1} /\\ M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp. \nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1}  /\\ ={ix, glob A, r1, M.x1} /\\ M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp. call(_:true). skip. progress. sp.\nif{1}. call(_:true). skip.\nprogress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nseq 3 2 : (i0{1} = ix{1}  /\\ !M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. auto. sp.\nif{1}. call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. progress.\nqed.\nlocal lemma uav_11 P : equiv [ M.main_11' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ M.x1{2} /\\ M.x2{2} ].\nproc. inline*.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 :  (i0{2} = ix{2} /\\ ={ix, glob A, r1, M.x1, s} /\\ M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp. call(_:true). skip. smt(). sp.\nif{2}. wp.\ncall(_:true). skip. progress.\nwp. call {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\nwp.\nseq 4 3 : (i0{2} = ix{2} /\\ !M.x1{1}).\nwp. call {2} (_: true ==> true). apply Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Ass.\ncall {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. auto. sp.\nif{2}.  wp. call {2} (_:true ==> true). apply Afl.\nskip. progress. wp. call {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma probEq_11 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n                               = Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n            <= Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_11 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n            >= Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_11 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_11 &m P j : Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                                = Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j ==> _).\nproc.\npose z := Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (M.x1 /\\ M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_11 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={glob A, glob B, i} /\\ i{1} = j ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto.  smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true). wp.\nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_11 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ]\n                             = Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof. rewrite probEq_11. rewrite bitsout_11. auto.\nqed.\n\n\nlocal lemma vau_12 P : equiv [ M.main ~ M.main_12' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ M.x1{1} /\\ !M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1} /\\ ={ix, glob A, r1, M.x1} /\\ M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp. call(_:true). skip. progress. sp.\nif{1}.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall (_:true).\nskip. smt().\nseq 3 2 : (i0{1} = ix{1}  /\\ !M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. auto. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma uav_12 P : equiv [ M.main_12' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ M.x1{2} /\\ !M.x2{2} ].\nproc. inline*.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp. \nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 :  (i0{2} = ix{2} /\\ ={ix, glob A, r1, M.x1, s} /\\ M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp. call(_:true). skip. smt(). sp.\nif{2}. wp.\ncall {1} (_:true ==> true). apply Agl. wp.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nwp. call (_:true).\nskip. smt().\nseq 4 3 : (!M.x1{1}).\nwp. call {2} (_: true ==> true). apply Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {1} (_: true ==> true). apply Ass.\ncall {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. auto. sp.\nif{2}.  wp. call {2} (_:true ==> true). apply Afl.\nskip. progress. wp. call {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma probEq_12 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n                               = Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n            <= Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_12 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n            >= Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_12 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_12 &m P j : Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                                = Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j ==> _).\nproc.\npose z := Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (M.x1 /\\ !M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_12 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={glob A, glob B, arg} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_12 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ]\n                             = Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof. rewrite probEq_12. rewrite bitsout_12. auto.\nqed.\n\n\nlocal lemma main_lemma &m P j : Pr[ M.main(j) @ &m : P res.`1 /\\ P res.`2 ]\n  = 1%r/4%r * Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nproof.\nrewrite Pr[mu_split M.x1]. rewrite Pr[mu_split M.x2].\nhave : Pr[M.main(j) @ &m : (P res.`1 /\\ P res.`2) /\\ !M.x1] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2]\n + Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2].\nrewrite Pr[mu_split M.x2].  auto.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ !M.x1) /\\ M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ !M.x1) /\\ !M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z. auto.\nmove => q. rewrite q. clear q.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ M.x1) /\\ M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ M.x1) /\\ !M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nrewrite (main_lemma_11 &m P). rewrite (main_lemma_12 &m). rewrite (main_lemma_21 &m).\nrewrite (main_lemma_22 &m). smt().\nqed.\n\n\nlemma fact2 &m ____(LEMMA_1)____ ____(LEMMA_0)____ : Pr[ SB(A,B).main(j) @ &m : P res.`1 /\\ P res.`2 ] \n  = 1%r/4%r * Pr[ SB(A,B).main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nproof.\nhave e0 : Pr[SB(A, B).main(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 ].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={glob A, i0, ix,s,x}). rnd. wp. call(_:true). skip. progress.\nif. auto.\nseq 5 5 : (={glob A, ix,s,x,r,i1,r1,i0,x0}). rnd.  wp. call (_:true). wp.  call(_:true).\nskip. progress. if. auto.\ncall (_:true). skip. progress. call (_:true). skip. progress.\nseq 5 5 : (={glob A, ix,s,x,r,r1,i1, i0,x0}). rnd.  wp. call (_:true). wp.  call(_:true).\nskip. progress.\nif.  auto. call(_:true). skip. progress. call(_:true). skip. progress. auto. auto.\nhave e1 : Pr[SB(A, B).main_12(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_12(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e2 : Pr[SB(A, B).main_21(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_21(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e3 : Pr[SB(A, B).main_11(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_11(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e4 : Pr[SB(A, B).main_22(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_22(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={arg, glob A, glob B}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nrewrite e0 e1 e2 e3 e4. apply main_lemma.\nqed.\n\n\nend section.\nend RSBH.",
        "complete:": "pragma Goals:printall.\n\nrequire import AllCore Distr Real DBool.\nrequire RewBasics.\n\ntheory RSBH.\n\ntype sbits, irt, rrt,iat.\n\n\nop pair_sbits : sbits * sbits -> sbits.\nop unpair: sbits -> sbits * sbits.\naxiom ips: injective pair_sbits. \naxiom unpair_pair x : unpair (pair_sbits x) = x.\n\nclone import RewBasics as RW with type sbits <- sbits,\n                                  type rrt <- rrt,\n                                  type irt <- irt,\n                                  type iat <- iat,\n                                  op pair_sbits <- pair_sbits,\n                                  op unpair <- unpair.\n\n\n\nmodule type Initializer = {\n  proc init(i:iat) : irt\n}.\n\n\nmodule type RewRunExec1Exec2 = {\n  proc getState() : sbits\n  proc setState(b : sbits) : unit (* EasyCrypt removed support for \"proc *\" *)\n  proc run(i : irt) : rrt\n  proc ex1(i : irt) : rrt\n  proc ex2(i : irt) : rrt\n}.\n\n\nmodule SBB (A : RewRunExec1Exec2) = {\n  proc run(i : irt) = {\n    var r, x;\n    x <$ {0,1};    \n    if (x) {\n      r <@ A.ex1(i);\n    }else{\n      r <@ A.ex2(i);\n    }\n     return r;\n  }    \n\n  proc getState() : sbits = {\n    var s;\n    s <@ A.getState();\n    return s;\n  }\n  proc setState(b : sbits) : unit  = {\n    A.setState(b);\n  }\n}.\n\nmodule SB (A : RewRunExec1Exec2, B : Initializer) = {\n  module SBB = SBB(A)\n\n  proc main(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@  SBB.run(ix);\n    A.setState(s);\n    r2 <@ SBB.run(ix);\n    return (r1 , r2);\n  }\n\n  proc main_run(i:iat) = {\n    var ix,r;\n    ix <@ B.init(i);\n    r <@ SBB.run(ix);\n    return r;\n  }\n  \n  proc main_12(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n  \n  proc main_21(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n\n  proc main_11(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n\n  proc main_22(i:iat) = {\n    var s,ix,r1,r2;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n\n  proc main_1(i:iat) = {\n    var r,ix;\n    ix <@ B.init(i);\n    r <@ A.ex1(ix);\n    return r;\n  }\n\n  proc main_2(i:iat) = {\n    var r, ix;\n    ix <@ B.init(i);\n    r <@ A.ex2(ix);\n    return r;\n  }\n}.\n\n\nsection.\ndeclare module A <: RewRunExec1Exec2.\ndeclare module B <: Initializer.\n\ndeclare axiom Afl : islossless A.ex1.\ndeclare axiom Agl : islossless A.ex2.\ndeclare axiom Ass : islossless A.setState.\ndeclare axiom Bsens : equiv[ B.init ~ B.init : ={i, glob A, glob B} ==> ={glob A, res} ].\n\n\nlocal module M = {\n  var x1, x2 : bool\n  proc run(i : irt) = {\n    var r, x;\n    x <$ {0,1};    \n    if (x) {\n      r <@ A.ex1(i);\n    }else{\n      r <@ A.ex2(i);\n    }\n   return (r,x);\n  }  \n\n  proc main(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    (r1, x1) <@ run(ix);\n    A.setState(s);\n    (r2, x2) <@ run(ix);\n    return (r1,r2);\n  } \n\n  proc main_12(i:iat) = {\n    var ix,r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1, r2);\n  }\n\n  proc main_12'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_12(i);\n    return (r , x1 /\\ !x2);\n  }  \n\n  proc main_11(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex1(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1 , r2);\n  }\n  \n  proc main_11'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_11(i);\n    return (r, x1 /\\ x2);\n  }  \n\n  proc main_21(i:iat) = {\n    var ix, r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex1(ix);\n    return (r1, r2);\n  }\n  \n  proc main_21'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_21(i);\n    return (r, !x1 /\\ x2);\n  }  \n\n  proc main_22(i:iat) = {\n    var ix,r1, r2, s;\n    ix <@ B.init(i);\n    s <@ A.getState();\n    r1 <@ A.ex2(ix);\n    A.setState(s);\n    r2 <@ A.ex2(ix);\n    return (r1,r2);\n  }\n  \n  proc main_22'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    x2 <$ {0,1};\n    r <@ main_22(i);\n    return (r, !x1 /\\ !x2);\n  }  \n\n  proc main_run(i:iat) = {\n    var ix, r;\n    ix <@ B.init(i);\n    (r,x1) <@ run(ix);\n    return r;\n  }\n\n  proc main_1(i:iat) = {\n    var ix,r;\n    ix <@ B.init(i);\n    r <@ A.ex1(ix);\n    return r;\n  }\n\n  proc main_1'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    r <@ main_1(i);\n    return (r, x1);\n  }  \n\n  proc main_2(i:iat) = {\n    var ix, r;\n    ix <@ B.init(i);\n    r <@ A.ex2(ix);\n    return r;\n  }\n\n  proc main_2'(i:iat) = {\n    var r;\n    x1 <$ {0,1};\n    r <@ main_2(i);\n    return (r, !x1);\n  }  \n}.\n\n\nlocal lemma vau_uav_1 P : equiv [ M.main_run ~ M.main_1' : ={i, glob A, glob B} \n                                ==> P res{1} /\\ M.x1{1}  <=> P res{2}.`1 /\\ res{2}.`2 ].\nproof. proc. inline*.\nswap {2} [2..3] -1. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip.   progress.  sp.\nseq 1 1 : (i0{1} = ix{2} /\\ ={glob A, ix} /\\ x{1} = M.x1{2}).\nrnd. skip. progress.\nif {1}.\nwp. seq 1 1 : (={glob A, r0} /\\ x{1} = M.x1{2}).\ncall(_:true). skip. progress. skip. progress.\nwp. call {2} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Agl. skip. progress.\nqed.\nlocal lemma probEq_1 &m P i : Pr[ M.main_run(i) @ &m :  P res /\\ M.x1 ] = Pr[ M.main_1'(i) @ &m : P res.`1 /\\ res.`2 ].\nproof. byequiv. conseq (vau_uav_1 P). progress. smt(). smt(). auto. auto.\nqed.\nlocal lemma bitsout_1 &m P j : Pr[ M.main_1'(j) @ &m : P res.`1 /\\ res.`2 ] = Pr[ M.main_1(j) @ &m : P res ] / 2%r.\nproof.\nbyphoare (_: arg = j /\\  (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_1(j) @ &m : P res ].\nseq 1 : (M.x1) (1%r/2%r) z (1%r - 1%r/2%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd.  skip. progress.\nrnd.  skip. progress. smt(@DBool).\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r). smt(). smt().\nhave phl : phoare [ M.main_1 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ arg = j ==> P res ] \n           = Pr[ M.main_1(j) @ &m : P res ].\nbypr. move => &m0  pr1.\nbyequiv (_: ={i, glob A, glob B} /\\ i{1} = j  ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. progress.  \ncall (_:true). skip.  smt().  progress. smt().  smt(). smt(). auto. smt().  auto.\ncall phl. skip. auto. progress. \ninline*. wp. hoare. call (_:true). call(_:true).  wp.\nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_1 &m P i : Pr[ M.main_run(i) @ &m :  P res /\\ M.x1 ]\n                             = Pr[ M.main_1(i) @ &m : P res ] / 2%r.\nproof. rewrite probEq_1. rewrite bitsout_1. auto.\nqed.\n\n\nlocal lemma vau_uav_2 P  : equiv [ M.main_run ~ M.main_2' : ={glob A, glob B, i} \n                                 ==> P res{1} /\\ !M.x1{1} <=> P res{2}.`1 /\\ res{2}.`2 ].\nproof. proc. inline*.\nswap {2} [2..3] -1.\nseq 1 2 : (={glob A, ix}). sp. call Bsens. skip. auto. sp.\nseq 1 1 : (i0{1} = ix{1} /\\ ={glob A, ix} /\\ x{1} = M.x1{2}).\nrnd. skip. progress.\nif {1}.\nwp. call {2} (_: true ==> true). apply Agl.\ncall {1} (_: true ==> true). apply Afl. skip. progress.\nwp. call (_:true). skip. progress.\nqed.\nlocal lemma probEq_2  &m P j : Pr[ M.main_run(j) @ &m :  P res /\\ !M.x1 ] = Pr[ M.main_2'(j) @ &m : P res.`1 /\\ res.`2 ].\nproof. byequiv. conseq (vau_uav_2 P). progress. smt(). smt(). auto. auto.\nqed.\nlocal lemma bitsout_2 &m P j : Pr[ M.main_2'(j) @ &m : P res.`1 /\\ res.`2 ] = Pr[ M.main_2(j) @ &m : P res ] / 2%r.\nproof.\nbyphoare (_: i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_2(j) @ &m : P res ].\nseq 1 : (!M.x1) (1%r/2%r) z (1%r - 1%r/2%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd.  skip. progress.\nrnd.  skip. progress. smt(@DBool).\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r). smt(). smt().\nhave phl : phoare [ M.main_2 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res ] \n           = (Pr[ M.main_2(j) @ &m : P res ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={i,glob A, glob B} ==> _). proc. seq 1 1 : (={glob A,ix}). call Bsens.\nskip. auto.\ncall (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). wp. \nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_2 &m P j : Pr[ M.main_run(j) @ &m :  P res /\\ !M.x1 ]\n                             = Pr[ M.main_2(j) @ &m : P res ] / 2%r.\nproof. rewrite probEq_2. rewrite bitsout_2. auto.\nqed.\n\n\nlemma fact3 &m P j : Pr[SB(A,B).main_run(j) @ &m : P res ] = 1%r / 2%r * Pr[SB(A,B).main_1(j) @ &m : P res ] \n                                                           + 1%r / 2%r * Pr[SB(A,B).main_2(j) @ &m : P res ].\nproof.\nhave e0 : Pr[SB(A, B).main_run(j) @ &m : P res ] = Pr[M.main_run(j) @ &m : P res ].\nbyequiv (_: (={i, glob A, glob B}) ==> _). proc. inline*.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto. sp. wp.\nseq 1 1 : (i0{2} = ix{2} /\\ i0{1} = ix{1} /\\ ={glob A, ix,x}). rnd. skip. progress.\nif.  auto. call (_:true). skip. progress. call (_:true). skip. progress.\nauto. auto.\nhave e1 : Pr[SB(A, B).main_1(j) @ &m : P res] = Pr[M.main_1(j) @ &m : P res].\nbyequiv (_: (={i,glob A, glob B}) ==> _). proc. inline*. seq 1 1 : (={glob A, ix}). \ncall Bsens. skip. auto.  call (_:true). skip. progress.\nauto.  auto.\nhave e2 : Pr[SB(A, B).main_2(j) @ &m : P res] = Pr[M.main_2(j) @ &m : P res].\nbyequiv (_: (={glob A, glob B,i}) ==> _). proc.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). skip. progress.\nauto. auto.\nrewrite e0 e1 e2.\nrewrite Pr[mu_split M.x1]. rewrite main_lemma_1. rewrite main_lemma_2. smt(). \nqed.\n\n\nlocal lemma vau_22 P : equiv [ M.main ~ M.main_22' : ={arg, glob A, glob B} \n                       ==> P res{1}.`1 /\\ P res{1}.`2 /\\ !M.x1{1} /\\ !M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix} ). call Bsens. skip. auto.\nseq 3 3 : (={ix,glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}. simplify.\nseq 3 2 : (M.x1{1}).\nwp. call {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {2} (_: true ==> true). apply Agl. skip. progress. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nseq 3 2 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{1}.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall(_:true). skip. auto.\nqed.\nlocal lemma uav_22 P : equiv [ M.main_22' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ !M.x1{2} /\\ !M.x2{2} ].\n proc.  inline*. wp.\nswap {1} [3..4] -2. sp.\nswap {2} 4 -2.\nswap {2} 9 -6.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 : (M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {2} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Agl. skip. progress. sp.\nif{2}.  call {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Agl.\nskip. progress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nseq 2 3 : (={ix, glob A, r1, M.x1} /\\ !M.x1{2} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{2}.\ncall {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Agl.\nskip. smt().\ncall(_:true). skip. auto.\nqed.\nlocal lemma probEq_22 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n                               = Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n         <= Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_22 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ] \n         >= Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2  /\\ res.`2 ].\nbyequiv. conseq (uav_22 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_22 &m P j : Pr[ M.main_22'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                               = Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: arg = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (!M.x1 /\\ !M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (!M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_22 : arg = j /\\ ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) ==> P res.`1 /\\ P res.`2 ] \n         = (Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={arg, glob A, glob B} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_22 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2 ]\n                             = Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.  rewrite probEq_22. rewrite bitsout_22. auto.\nqed.\n    \n\nlocal lemma vau_21 P : equiv [ M.main ~ M.main_21' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ !M.x1{1} /\\ M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1} /\\ M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {2} (_: true ==> true). apply Agl. skip. progress. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. progress.\nseq 3 2 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{1}. call(_:true). skip. progress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nqed.\nlocal lemma uav_21 P : equiv [ M.main_21' ~ M.main : ={arg, glob A, glob B} ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ !M.x1{2} /\\ M.x2{2} ].\nproc.  inline*. wp.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 : (i0{2} = ix{2} /\\ M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. progress. sp.\nif{2}.  call {2} (_:true ==> true). apply Afl.\ncall {1} (_:true ==> true). apply Afl.\nskip. smt(). call {2} (_:true ==> true). apply Agl.\ncall {1} (_:true ==> true). apply Afl.\nskip. progress.\nseq 2 3 : (={ix, glob A, r1, M.x1} /\\ !M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp.\ncall (_:true).\nskip. progress. sp.\nif{2}. call(_:true). skip. progress.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\nqed.\nlocal lemma probEq_21 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n                             = Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n         <= Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_21 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ] \n         >= Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_21 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_21 &m P j : Pr[ M.main_21'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                              = Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} ==> _).\nproc.\npose z := Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (!M.x1 /\\ M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (!M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: (i = j /\\ (glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_21 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={arg, glob A, glob B} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_21 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2 ]\n                             = Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.  rewrite probEq_21. rewrite bitsout_21. auto.\nqed.\n\n\nlocal lemma vau_11 P : equiv [ M.main ~ M.main_11' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ M.x1{1} /\\ M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp. \nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1}  /\\ ={ix, glob A, r1, M.x1} /\\ M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp. call(_:true). skip. progress. sp.\nif{1}. call(_:true). skip.\nprogress.\ncall {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nseq 3 2 : (i0{1} = ix{1}  /\\ !M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. auto. sp.\nif{1}. call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Afl.\nskip. progress.\nqed.\nlocal lemma uav_11 P : equiv [ M.main_11' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ M.x1{2} /\\ M.x2{2} ].\nproc. inline*.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 :  (i0{2} = ix{2} /\\ ={ix, glob A, r1, M.x1, s} /\\ M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp. call(_:true). skip. smt(). sp.\nif{2}. wp.\ncall(_:true). skip. progress.\nwp. call {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\nwp.\nseq 4 3 : (i0{2} = ix{2} /\\ !M.x1{1}).\nwp. call {2} (_: true ==> true). apply Ass.\nwp. call {1} (_: true ==> true). apply Afl.\ncall {1} (_: true ==> true). apply Ass.\ncall {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. auto. sp.\nif{2}.  wp. call {2} (_:true ==> true). apply Afl.\nskip. progress. wp. call {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma probEq_11 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n                               = Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n            <= Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_11 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ] \n            >= Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_11 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_11 &m P j : Pr[ M.main_11'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                                = Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j ==> _).\nproc.\npose z := Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (M.x1 /\\ M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. progress. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_11 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={glob A, glob B, i} /\\ i{1} = j ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto.  smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true). wp.\nskip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_11 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2 ]\n                             = Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof. rewrite probEq_11. rewrite bitsout_11. auto.\nqed.\n\n\nlocal lemma vau_12 P : equiv [ M.main ~ M.main_12' : ={arg, glob A, glob B} \n                             ==> P res{1}.`1 /\\ P res{1}.`2 /\\ M.x1{1} /\\ !M.x2{1} => P res{2}.`1.`1 /\\ P res{2}.`1.`2 /\\ res{2}.`2 ].\nproof. proc.  inline*. wp.\nswap {1} 4 -2.\nswap {1}  9 -6.\nswap {2} [3..4] -2. sp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{1} = M.x1{2} /\\ x0{1} = M.x2{2}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{1}.\nseq 3 2 : (i0{1} = ix{1} /\\ ={ix, glob A, r1, M.x1} /\\ M.x1{1} /\\  x0{1} = M.x2{2}).\ncall (_:true). wp. call(_:true). skip. progress. sp.\nif{1}.\ncall {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt().\ncall (_:true).\nskip. smt().\nseq 3 2 : (i0{1} = ix{1}  /\\ !M.x1{1}).\ncall {1} (_: true ==> true). apply  Ass.\ncall {2} (_: true ==> true). apply  Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {2} (_: true ==> true). apply Afl. skip. auto. sp.\nif{1}.  call {1} (_:true ==> true). apply Afl.\ncall {2} (_:true ==> true). apply Agl.\nskip. smt(). call {1} (_:true ==> true). apply Agl.\ncall {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma uav_12 P : equiv [ M.main_12' ~ M.main : ={arg, glob A, glob B} \n                             ==> P res{1}.`1.`1 /\\ P res{1}.`1.`2 /\\ res{1}.`2 => P res{2}.`1 /\\ P res{2}.`2 /\\ M.x1{2} /\\ !M.x2{2} ].\nproc. inline*.\nswap {2} 4 -2.\nswap {2}  9 -6.\nswap {1} [3..4] -2. sp. \nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={ix, glob A, s} /\\ x{2} = M.x1{1} /\\ x0{2} = M.x2{1}).\ncall(_:true).\nrnd. rnd. skip. smt(). sp.\nif{2}.\nseq 2 3 :  (i0{2} = ix{2} /\\ ={ix, glob A, r1, M.x1, s} /\\ M.x1{1} /\\  x0{2} = M.x2{1}).\ncall (_:true). wp. call(_:true). skip. smt(). sp.\nif{2}. wp.\ncall {1} (_:true ==> true). apply Agl. wp.\ncall {2} (_:true ==> true). apply Afl.\nskip. smt().\nwp. call (_:true).\nskip. smt().\nseq 4 3 : (!M.x1{1}).\nwp. call {2} (_: true ==> true). apply Ass.\nwp. call {1} (_: true ==> true). apply Agl.\ncall {1} (_: true ==> true). apply Ass.\ncall {1} (_:true ==> true). apply Afl. wp.\ncall {2} (_:true ==> true). apply Agl.\nskip. auto. sp.\nif{2}.  wp. call {2} (_:true ==> true). apply Afl.\nskip. progress. wp. call {2} (_:true ==> true). apply Agl.\nskip. progress.\nqed.\nlocal lemma probEq_12 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n                               = Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nproof.\nhave prle : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n            <= Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (vau_12 P). smt().   progress. progress.\nhave prge : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ] \n            >= Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ].\nbyequiv. conseq (uav_12 P). smt(). progress. progress.\nsmt().\nqed.\nlocal lemma bitsout_12 &m P j : Pr[ M.main_12'(j) @ &m : P res.`1.`1 /\\ P res.`1.`2 /\\ res.`2 ] \n                                = Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof.\nbyphoare (_: (glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j ==> _).\nproc.\npose z := Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ].\nseq 2 : (M.x1 /\\ !M.x2) (1%r/4%r) z (1%r - 1%r/4%r) 0%r ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m} /\\ i = j).\nrnd. rnd. skip. progress.\nseq 1 : (M.x1) (1%r/2%r) (1%r/2%r) (1%r/2%r) (0%r). rnd. auto.\nrnd. skip. progress. smt(@DBool).\nrnd.  skip. smt(@DBool). rnd. skip. progress. smt(@DBool).\nsmt().\nconseq (_: ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P r.`1 /\\ P r.`2). smt(). smt().\nhave phl : phoare [ M.main_12 : ((glob A) = (glob A){m} /\\ (glob B) = (glob B){m}) /\\ i = j ==> P res.`1 /\\ P res.`2 ] \n           = (Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ]).\nbypr. move => &m0  pr1.\nbyequiv (_: ={glob A, glob B, arg} ==> _). proc. seq 1 1 : (={glob A, ix}). call Bsens.\nskip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. smt(). auto. auto. smt(). auto.\ncall phl. skip. auto.\ninline*. wp. hoare. call (_:true). call(_:true). call(_:true). call(_:true). call(_:true).\nwp. skip. smt(). smt(). auto. auto.\nqed.\nlocal lemma main_lemma_12 &m P j : Pr[ M.main(j) @ &m :  P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2 ]\n                             = Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ] / 4%r.\nproof. rewrite probEq_12. rewrite bitsout_12. auto.\nqed.\n\n\nlocal lemma main_lemma &m P j : Pr[ M.main(j) @ &m : P res.`1 /\\ P res.`2 ]\n  = 1%r/4%r * Pr[ M.main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ M.main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nproof.\nrewrite Pr[mu_split M.x1]. rewrite Pr[mu_split M.x2].\nhave : Pr[M.main(j) @ &m : (P res.`1 /\\ P res.`2) /\\ !M.x1] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2]\n + Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2].\nrewrite Pr[mu_split M.x2].  auto.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ !M.x1) /\\ M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ !M.x1) /\\ !M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ !M.x1 /\\ !M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z. auto.\nmove => q. rewrite q. clear q.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ M.x1) /\\ M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ M.x1 /\\ M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nhave z : Pr[M.main(j) @ &m : ((P res.`1 /\\ P res.`2) /\\ M.x1) /\\ !M.x2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 /\\ M.x1 /\\ !M.x2].\nrewrite Pr[mu_eq]. auto. auto. rewrite z. clear z.\nrewrite (main_lemma_11 &m P). rewrite (main_lemma_12 &m). rewrite (main_lemma_21 &m).\nrewrite (main_lemma_22 &m). smt().\nqed.\n\n\nlemma fact2 &m P j : Pr[ SB(A,B).main(j) @ &m : P res.`1 /\\ P res.`2 ] \n  = 1%r/4%r * Pr[ SB(A,B).main_12(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_21(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_11(j) @ &m : P res.`1 /\\ P res.`2 ]\n  + 1%r/4%r * Pr[ SB(A,B).main_22(j) @ &m : P res.`1 /\\ P res.`2 ].\nproof.\nhave e0 : Pr[SB(A, B).main(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main(j) @ &m : P res.`1 /\\ P res.`2 ].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\nseq 3 3 : (={glob A, i0, ix,s,x}). rnd. wp. call(_:true). skip. progress.\nif. auto.\nseq 5 5 : (={glob A, ix,s,x,r,i1,r1,i0,x0}). rnd.  wp. call (_:true). wp.  call(_:true).\nskip. progress. if. auto.\ncall (_:true). skip. progress. call (_:true). skip. progress.\nseq 5 5 : (={glob A, ix,s,x,r,r1,i1, i0,x0}). rnd.  wp. call (_:true). wp.  call(_:true).\nskip. progress.\nif.  auto. call(_:true). skip. progress. call(_:true). skip. progress. auto. auto.\nhave e1 : Pr[SB(A, B).main_12(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_12(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e2 : Pr[SB(A, B).main_21(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_21(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e3 : Pr[SB(A, B).main_11(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_11(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={glob A, glob B, arg}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nhave e4 : Pr[SB(A, B).main_22(j) @ &m : P res.`1 /\\ P res.`2] = Pr[M.main_22(j) @ &m : P res.`1 /\\ P res.`2].\nbyequiv (_: (={arg, glob A, glob B}) ==> _). proc. inline*. wp.\nseq 1 1 : (={glob A, ix}). call Bsens. skip. auto.\ncall (_:true). call(_:true). call(_:true). call (_:true). skip. progress. auto. auto.\nrewrite e0 e1 e2 e3 e4. apply main_lemma.\nqed.\n\n\nend section.\nend RSBH."
    },
    {
        "file": "EC-1/RingCloning.ec",
        "incomplete": "(* This theory should make use of theories for groups.\n   It is currently mostly being developed towards getting\n   fixed-length bitstrings formalized as boolean rings,\n   automatically yielding many useful lemmas from a\n   small number of simple core axioms. *)\ntheory Ring.\n  type ____(TYPE_0)____.\n\n  (** Ring addition *)\n  const ____(CONST_0)____: ring.\n  op ( + ) : ring -> ring -> ring.\n  op [ - ] : ring -> ring.\n\n  axiom addrA (r1 r2 r3 : ring):\n    (r1 + r2) + r3 = r1 + (r2 + r3).\n\n  axiom addrC (r1 r2 : ring):\n    r1 + r2 = r2 + r1.\n\n  axiom add0r (r : ring):\n    zero + r = r.\n\n  axiom addNr (r : ring):\n    r + -r = zero.\n\n  (** Ring multiplication *)\n  const one: ring.\n  op ( * ): ring -> ring -> ring.\n\n  axiom mulrA (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = r1 * (r2 * r3).\n\n  axiom mul1r (r : ring):\n    one * r = r.\n\n  (** Distributivity of addition over multiplication *)\n  axiom mulrDadd (r1 r2 r3 : ring):\n    r1 * (r2 + r3)= (r1 * r2) + (r1 * r3).\n\n  axiom mulDradd (r1 r2 r3 : ring):\n    (r1 + r2) * r3 = (r1 * r3) + (r2 * r3).\nend Ring.\n\ntheory RingT.\n  clone import Ring.\n  abbrev ( - ) (r1 r2 : ring) = r1 + -r2.\n\n  (** Lemmas *)\n  lemma addr0 (r : ring):\n    r + zero = r.\n  proof strict.\n  by rewrite addrC add0r.\n  qed.\n\n  lemma addrN (r : ring):\n    -r + r = zero.\n  proof strict.\n  by rewrite addrC addNr.\n  qed.\n\n  lemma addIr (r r1 r2 : ring):\n    (r1 + r = r2 + r) =>\n    r1 = r2.\n  proof strict.\n  by move=> r1_r2;\n     rewrite -addr0 -(addr0 r2) -(addNr r) -2!addrA -r1_r2.\n  qed.\n\n  lemma addrI (r r1 r2 : ring):\n    (r + r1 = r + r2) =>\n    r1 = r2.\n  proof strict.\n  by rewrite 2!(addrC r)=> r1_r2; rewrite (addIr r r1 r2).\n  qed.\nend RingT.\n\ntheory CRing.\n  clone import Ring.\n\n  axiom mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\nend CRing.\n\ntheory CRingT.\n  clone        Ring.\n  clone        CRing with\n    theory Ring <- Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n\n  import Ring.\n  import CRing.\n  import RingT.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite mulrC.\n  qed.\n\n  lemma mulrCA (r1 r2 r3 : ring):\n    r1 * (r2 * r3) = r2 * (r1 * r3).\n  proof strict.\n  by rewrite -2!mulrA (mulrC r1).\n  qed.\n\n  lemma mulrAC (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = (r1 * r3) * r2.\n  proof strict.\n  by rewrite 2!mulrA (mulrC r2).\n  qed.\n\n  lemma mulrACA (r1 r2 r3 r4 : ring):\n    (r1 * r2) * (r3 * r4) = (r1 * r3) * (r2 * r4).\n  proof strict.\n  by rewrite mulrA (mulrCA r2) -mulrA.\n  qed.\nend CRingT.\n\ntheory BRing.\n  clone import Ring.\n\n  axiom mulrK (r : ring):\n    r * r = r.\nend BRing.\n\ntheory BRingT.\n  clone        Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n  clone        BRing with\n    theory Ring <- Ring.\n\n  import Ring.\n  import RingT.\n  import BRing.\n\n  lemma neg_is_id (r : ring):\n    r + r = zero.\n  proof strict.\n  by rewrite -(addIr (r + r) (r + r) zero) //\n             (add0r (r + r)) -(mulrK r) -{1 2}mulrDadd -mulDradd 2!mulrK.\n  qed.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite -(addIr (r2 * r1) (r1 * r2) (r2 * r1)) // (neg_is_id (r2 * r1))\n             -(addIr r2 (r1 * r2 + r2 * r1) zero) // (add0r r2) addrA\n             -{4}(addrI r1 (r1 * r2 + (r2 * r1 + r2)) r2) // -addrA\n             -{1}(mulrK r1) -{3}(mulrK r2) -2!mulrDadd -mulDradd mulrK.\n  qed.\nend BRingT.\n\n\n(*\n(* Example: Ring structures on bool *)\ntheory BoolRing.\nrequire import Bool.\nop id (b:bool) = b.\nclone Ring as RBool with\n  type ring = bool,\n  op zero = false,\n  op ( + ) = (^^),\n  op [ - ] = id,\n  op one = true,\n  op ( * ) = (/\\)\n  proof * by (delta; smt).\n\nclone BRing as BRBool with\n  theory Ring = RBool\n  proof * by (move=> r; delta; smt).\n\nclone BRingT as BRBoolT with\n  theory Ring = RBool.\n\nprint theory BRBoolT.\n*)",
        "complete:": "(* This theory should make use of theories for groups.\n   It is currently mostly being developed towards getting\n   fixed-length bitstrings formalized as boolean rings,\n   automatically yielding many useful lemmas from a\n   small number of simple core axioms. *)\ntheory Ring.\n  type ring.\n\n  (** Ring addition *)\n  const zero: ring.\n  op ( + ) : ring -> ring -> ring.\n  op [ - ] : ring -> ring.\n\n  axiom addrA (r1 r2 r3 : ring):\n    (r1 + r2) + r3 = r1 + (r2 + r3).\n\n  axiom addrC (r1 r2 : ring):\n    r1 + r2 = r2 + r1.\n\n  axiom add0r (r : ring):\n    zero + r = r.\n\n  axiom addNr (r : ring):\n    r + -r = zero.\n\n  (** Ring multiplication *)\n  const one: ring.\n  op ( * ): ring -> ring -> ring.\n\n  axiom mulrA (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = r1 * (r2 * r3).\n\n  axiom mul1r (r : ring):\n    one * r = r.\n\n  (** Distributivity of addition over multiplication *)\n  axiom mulrDadd (r1 r2 r3 : ring):\n    r1 * (r2 + r3)= (r1 * r2) + (r1 * r3).\n\n  axiom mulDradd (r1 r2 r3 : ring):\n    (r1 + r2) * r3 = (r1 * r3) + (r2 * r3).\nend Ring.\n\ntheory RingT.\n  clone import Ring.\n  abbrev ( - ) (r1 r2 : ring) = r1 + -r2.\n\n  (** Lemmas *)\n  lemma addr0 (r : ring):\n    r + zero = r.\n  proof strict.\n  by rewrite addrC add0r.\n  qed.\n\n  lemma addrN (r : ring):\n    -r + r = zero.\n  proof strict.\n  by rewrite addrC addNr.\n  qed.\n\n  lemma addIr (r r1 r2 : ring):\n    (r1 + r = r2 + r) =>\n    r1 = r2.\n  proof strict.\n  by move=> r1_r2;\n     rewrite -addr0 -(addr0 r2) -(addNr r) -2!addrA -r1_r2.\n  qed.\n\n  lemma addrI (r r1 r2 : ring):\n    (r + r1 = r + r2) =>\n    r1 = r2.\n  proof strict.\n  by rewrite 2!(addrC r)=> r1_r2; rewrite (addIr r r1 r2).\n  qed.\nend RingT.\n\ntheory CRing.\n  clone import Ring.\n\n  axiom mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\nend CRing.\n\ntheory CRingT.\n  clone        Ring.\n  clone        CRing with\n    theory Ring <- Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n\n  import Ring.\n  import CRing.\n  import RingT.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite mulrC.\n  qed.\n\n  lemma mulrCA (r1 r2 r3 : ring):\n    r1 * (r2 * r3) = r2 * (r1 * r3).\n  proof strict.\n  by rewrite -2!mulrA (mulrC r1).\n  qed.\n\n  lemma mulrAC (r1 r2 r3 : ring):\n    (r1 * r2) * r3 = (r1 * r3) * r2.\n  proof strict.\n  by rewrite 2!mulrA (mulrC r2).\n  qed.\n\n  lemma mulrACA (r1 r2 r3 r4 : ring):\n    (r1 * r2) * (r3 * r4) = (r1 * r3) * (r2 * r4).\n  proof strict.\n  by rewrite mulrA (mulrCA r2) -mulrA.\n  qed.\nend CRingT.\n\ntheory BRing.\n  clone import Ring.\n\n  axiom mulrK (r : ring):\n    r * r = r.\nend BRing.\n\ntheory BRingT.\n  clone        Ring.\n  clone        RingT with\n    theory Ring <- Ring.\n  clone        BRing with\n    theory Ring <- Ring.\n\n  import Ring.\n  import RingT.\n  import BRing.\n\n  lemma neg_is_id (r : ring):\n    r + r = zero.\n  proof strict.\n  by rewrite -(addIr (r + r) (r + r) zero) //\n             (add0r (r + r)) -(mulrK r) -{1 2}mulrDadd -mulDradd 2!mulrK.\n  qed.\n\n  lemma mulrC (r1 r2 : ring):\n    r1 * r2 = r2 * r1.\n  proof strict.\n  by rewrite -(addIr (r2 * r1) (r1 * r2) (r2 * r1)) // (neg_is_id (r2 * r1))\n             -(addIr r2 (r1 * r2 + r2 * r1) zero) // (add0r r2) addrA\n             -{4}(addrI r1 (r1 * r2 + (r2 * r1 + r2)) r2) // -addrA\n             -{1}(mulrK r1) -{3}(mulrK r2) -2!mulrDadd -mulDradd mulrK.\n  qed.\nend BRingT.\n\n\n(*\n(* Example: Ring structures on bool *)\ntheory BoolRing.\nrequire import Bool.\nop id (b:bool) = b.\nclone Ring as RBool with\n  type ring = bool,\n  op zero = false,\n  op ( + ) = (^^),\n  op [ - ] = id,\n  op one = true,\n  op ( * ) = (/\\)\n  proof * by (delta; smt).\n\nclone BRing as BRBool with\n  theory Ring = RBool\n  proof * by (move=> r; delta; smt).\n\nclone BRingT as BRBoolT with\n  theory Ring = RBool.\n\nprint theory BRBoolT.\n*)"
    },
    {
        "file": "EC-1/SchnorrPK.ec",
        "incomplete": "(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type ____(TYPE_0)____    = F.t.\n  type ____(TYPE_2)____     = F.t.\n\n  op R_DL h w       = (h = g^w).\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type ____(TYPE_1)____.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge <- challenge,\n  type SigmaProtocol.response  <- response,\n  op   ____(OP_0)____.R         = R_DL,\n  op   SigmaProtocol.de        = FDistr.dt.\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;\n    if (w = F.zero) { (* A loop would be better, however the support for while loops is poor *)\n      w <- -F.one;\n    }\n    h <- g^w;\n    return (h, w);\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;\n    a <- g^r;\n    return (a, r);\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;\n    return e;\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;\n    r <- snd ms;\n    z <- r + e*w;\n    return z;\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);\n    v' <- g^z;\n    return (v = v');\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));\n    v' <- (g^z' = a*(h^e'));\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');\n      sto <- Some(w);\n    } else {\n      sto <- None;\n    }\n\n    return sto;\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;\n    a  <- (g^z) * (h^(-e));\n\n    return (a, e, z);\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.\n  proof. by islossless; apply FDistr.dt_ll. qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n  (*  move : FDistr.dt_ll FDistr.dt_fu FDistr.dt1E; rewrite /is_full => dt_ll dt_fu dt_supp. *)\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk.",
        "complete:": "(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type challenge    = F.t.\n  type response     = F.t.\n\n  op R_DL h w       = (h = g^w).\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type SigmaProtocol.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge <- challenge,\n  type SigmaProtocol.response  <- response,\n  op   SigmaProtocol.R         = R_DL,\n  op   SigmaProtocol.de        = FDistr.dt.\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;\n    if (w = F.zero) { (* A loop would be better, however the support for while loops is poor *)\n      w <- -F.one;\n    }\n    h <- g^w;\n    return (h, w);\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;\n    a <- g^r;\n    return (a, r);\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;\n    return e;\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;\n    r <- snd ms;\n    z <- r + e*w;\n    return z;\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);\n    v' <- g^z;\n    return (v = v');\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));\n    v' <- (g^z' = a*(h^e'));\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');\n      sto <- Some(w);\n    } else {\n      sto <- None;\n    }\n\n    return sto;\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;\n    a  <- (g^z) * (h^(-e));\n\n    return (a, e, z);\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.\n  proof. by islossless; apply FDistr.dt_ll. qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n  (*  move : FDistr.dt_ll FDistr.dt_fu FDistr.dt1E; rewrite /is_full => dt_ll dt_fu dt_supp. *)\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk."
    },
    {
        "file": "EC-1/SHA.ec",
        "incomplete": "require import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: ____(OP_1)____.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 ____(OP_0)____: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 e0 f0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 a0 b0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2].",
        "complete:": "require import List.\nrequire import JUtils JWord.\n\nop ch (e f g: W32.t) : W32.t = (e `&` f) +^ (invw e `&` g).\n\nop maj (a b c: W32.t) : W32.t = a `&` b +^ a `&` c +^ b `&` c.\n\nop sum0 (a: W32.t) : W32.t = (a `|>>>|` 2) +^ (a `|>>>|` 13) +^ (a `|>>>|` 22).\nop sum1 (e: W32.t) : W32.t = (e `|>>>|` 6) +^ (e `|>>>|` 11) +^ (e `|>>>|` 25).\n\nop sigma0 (w: W32.t) : W32.t = (w `|>>>|` 7) +^ (w `|>>>|` 18) +^ (w `>>>` 3).\nop sigma1 (w: W32.t) : W32.t = (w `|>>>|` 17) +^ (w `|>>>|` 19) +^ (w `>>>` 10).\n\nop msg1 (m1 m2: W128.t) : W128.t =\n  let s1 = W4u32.to_list m1 in\n  pack4 (map2 (fun x y => x + sigma0 y) s1 (rcons (behead s1) (m2 \\bits32 0))).\n\nop msg2 (m1 m2: W128.t) : W128.t =\n  let w14 = m2 \\bits32 2 in\n  let w15 = m2 \\bits32 3 in\n  let w16 = (m1 \\bits32 0) + sigma1 w14 in\n  let w17 = (m1 \\bits32 1) + sigma1 w15 in\n  let w18 = (m1 \\bits32 2) + sigma1 w16 in\n  let w19 = (m1 \\bits32 3) + sigma1 w17 in\n  pack4 [w16; w17; w18; w19].\n\nop rnds2 (x y z: W128.t) : W128.t =\n  let unpack = fun m : W128.t => (m \\bits32 0, m \\bits32 1, m \\bits32 2, m \\bits32 3) in\n  let (h0, g0, d0, c0) = unpack x in\n  let (f0, e0, b0, a0) = unpack y in\n  let (wk0, wk1) = (z \\bits32 0, z \\bits32 1) in\n  let t0 = ch e0 f0 g0 + sum1 e0 + wk0 + h0 in\n  let a1 = t0 + maj a0 b0 c0 + sum0 a0 in\n  let e1 = t0 + d0 in\n  let t1 = ch e1 e0 f0 + sum1 e1 + wk1 + g0 in\n  let a2 = t1 + maj a1 a0 b0 + sum0 a1 in\n  let e2 = t1 + c0 in\n  pack4 [e1; e2; a1; a2]."
    },
    {
        "file": "EC-1/SimpleCondProb.ec",
        "incomplete": "require import AllCore Distr List.\nrequire import Finite.\nrequire (*--*) StdBigop.\n(*---*) import StdBigop.Bigreal.BRA.\n\n\nabstract theory Generic.\n\ntype in_t.\ntype out_t.\ntype ____(TYPE_0)____.\n\nop ____(OP_0)____ : in_t distr.\n\nmodule type Provided = {\n  proc main(x : in_t, aux : aux_t) : out_t\n}.\n\nmodule Sampler (P : Provided) = {\n  var x : in_t\n  \n  proc main(aux : aux_t) : out_t = {\n    var y : out_t;\n    \n    x <$ din;\n    y <@ P.main(x, aux);\n    \n    return y;\n  }\n}.\n\n\nsection.\n\ndeclare module ____(DECLARE_0)____ <: Provided {-Sampler}.\ndeclare op prop : aux_t -> in_t -> glob P -> out_t -> bool.\n\nlemma EqPr_SamplerConj_ProvidedCond &m (a : aux_t) (v : in_t) :\n  Pr[Sampler(P).main(a) @ &m : Sampler.x = v /\\ prop a (Sampler.x) (glob P) res] \n  = \n  (mu1 din v) *  Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproof.\nbyphoare (: glob P = (glob P){m} /\\ arg = a ==> _ ) => //.\npose prPCond := Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproc.\nseq 1 : (Sampler.x = v) (mu1 din v) prPCond _ 0%r (glob P = (glob P){m} /\\ aux = a) => //; 1,2: by rnd.\n+ call (: glob P = (glob P){m} /\\ arg = (v, a) ==> prop a v (glob P) res) => //.\n  rewrite /prPCond; bypr=> /> &m' eqGl ->.\n  by byequiv => //; proc true.\nby hoare; call(: true); skip => />. \nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_FinBig &m (a : aux_t) :\n  is_finite (support din) \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     big predT (fun (v : in_t) => (mu1 din v) * Pr[P.main(v, a) @ &m : prop a v (glob P) res]) \n               (to_seq (support din)).\nproof.\nmove=> finsup; rewrite Pr[mu_split (Sampler.x \\in to_seq (support din))].\nhave -> /=:\n  Pr[Sampler(P).main(a) @ &m : prop a Sampler.x (glob P) res /\\ ! (Sampler.x \\in to_seq (support din))]\n  =\n  0%r.\n+ byphoare => //=.\n  hoare => /=.\n  proc.\n  call (: true).\n  rnd; skip => /> x.\n  by rewrite (mem_to_seq _ _ finsup) => ->.\nelim: (to_seq (support din)) (uniq_to_seq (support din)) => /= [| x l ih /= [nxinl uql]].\n+ by rewrite big_nil; byphoare.\nrewrite big_cons /predT /= -/predT.\nby rewrite andb_orr Pr[mu_disjoint] 1:/# ih 1:// -EqPr_SamplerConj_ProvidedCond andbC.\nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_UniBig &m (a : aux_t) :\n  is_uniform din \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     weight din / (size (to_seq (support din)))%r\n     * big predT (fun (v : in_t) => Pr[P.main(v, a) @ &m : prop a v (glob P) res]) (to_seq (support din)).\nproof.\nmove=> ^ /uniform_finite finsup unidin.\nrewrite mulr_sumr /= (EqPr_SamplerConj_ProvidedCond_FinBig &m a finsup).\napply eq_big_seq => x /=.\nby rewrite (mem_to_seq _ _ finsup) (mu1_uni _ _ unidin) => ->.\nqed.\n\nend section.\n\nend Generic.\n\n\ntheory Indistinguishability.\nrequire import DBool.\n\nclone import Generic as IND with\n  type in_t <- bool,\n  type out_t <- bool,\n  type aux_t <- unit,\n  op din <- {0,1}.\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare axiom P_main_ll : islossless P.main.\n\nlemma RelPr_IndSampler_IndProvided &m :\n  2%r * Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r\n  =\n  Pr[P.main(true, tt) @ &m : res] - Pr[P.main(false, tt) @ &m : res].\nproof.\nrewrite (EqPr_SamplerConj_ProvidedCond_UniBig P (fun a v g b => b = v) &m tt dbool_uni) /=.\nrewrite (: support {0,1} = predT); 1: by rewrite fun_ext => b; rewrite supp_dbool.\nrewrite -Support.card_size_to_seq dboolE -(eq_big_perm predT _ _ _  Support.perm_eq_enum_to_seq). \nrewrite 2!big_cons big_nil /predT /= -/predT.\nrewrite -[_ = false]negbK Pr[mu_not] (: Pr[P.main(false, tt) @ &m : true] = 1%r) 2:/#.\nby byphoare P_main_ll.\nqed.\n\nlemma Rel_Ind_Formalizations &m :\n  2%r * `| Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r/2%r |\n  =\n  `| Pr[P.main(false, tt) @ &m : res] - Pr[P.main(true, tt) @ &m : res] |.\nproof. smt(RelPr_IndSampler_IndProvided). qed.\n\nend section.\n\nend Indistinguishability.",
        "complete:": "require import AllCore Distr List.\nrequire import Finite.\nrequire (*--*) StdBigop.\n(*---*) import StdBigop.Bigreal.BRA.\n\n\nabstract theory Generic.\n\ntype in_t.\ntype out_t.\ntype aux_t.\n\nop din : in_t distr.\n\nmodule type Provided = {\n  proc main(x : in_t, aux : aux_t) : out_t\n}.\n\nmodule Sampler (P : Provided) = {\n  var x : in_t\n  \n  proc main(aux : aux_t) : out_t = {\n    var y : out_t;\n    \n    x <$ din;\n    y <@ P.main(x, aux);\n    \n    return y;\n  }\n}.\n\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare op prop : aux_t -> in_t -> glob P -> out_t -> bool.\n\nlemma EqPr_SamplerConj_ProvidedCond &m (a : aux_t) (v : in_t) :\n  Pr[Sampler(P).main(a) @ &m : Sampler.x = v /\\ prop a (Sampler.x) (glob P) res] \n  = \n  (mu1 din v) *  Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproof.\nbyphoare (: glob P = (glob P){m} /\\ arg = a ==> _ ) => //.\npose prPCond := Pr[P.main(v, a) @ &m : prop a v (glob P) res].\nproc.\nseq 1 : (Sampler.x = v) (mu1 din v) prPCond _ 0%r (glob P = (glob P){m} /\\ aux = a) => //; 1,2: by rnd.\n+ call (: glob P = (glob P){m} /\\ arg = (v, a) ==> prop a v (glob P) res) => //.\n  rewrite /prPCond; bypr=> /> &m' eqGl ->.\n  by byequiv => //; proc true.\nby hoare; call(: true); skip => />. \nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_FinBig &m (a : aux_t) :\n  is_finite (support din) \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     big predT (fun (v : in_t) => (mu1 din v) * Pr[P.main(v, a) @ &m : prop a v (glob P) res]) \n               (to_seq (support din)).\nproof.\nmove=> finsup; rewrite Pr[mu_split (Sampler.x \\in to_seq (support din))].\nhave -> /=:\n  Pr[Sampler(P).main(a) @ &m : prop a Sampler.x (glob P) res /\\ ! (Sampler.x \\in to_seq (support din))]\n  =\n  0%r.\n+ byphoare => //=.\n  hoare => /=.\n  proc.\n  call (: true).\n  rnd; skip => /> x.\n  by rewrite (mem_to_seq _ _ finsup) => ->.\nelim: (to_seq (support din)) (uniq_to_seq (support din)) => /= [| x l ih /= [nxinl uql]].\n+ by rewrite big_nil; byphoare.\nrewrite big_cons /predT /= -/predT.\nby rewrite andb_orr Pr[mu_disjoint] 1:/# ih 1:// -EqPr_SamplerConj_ProvidedCond andbC.\nqed.\n\nlemma EqPr_SamplerConj_ProvidedCond_UniBig &m (a : aux_t) :\n  is_uniform din \n  => Pr[Sampler(P).main(a) @ &m : prop a (Sampler.x) (glob P) res] \n     = \n     weight din / (size (to_seq (support din)))%r\n     * big predT (fun (v : in_t) => Pr[P.main(v, a) @ &m : prop a v (glob P) res]) (to_seq (support din)).\nproof.\nmove=> ^ /uniform_finite finsup unidin.\nrewrite mulr_sumr /= (EqPr_SamplerConj_ProvidedCond_FinBig &m a finsup).\napply eq_big_seq => x /=.\nby rewrite (mem_to_seq _ _ finsup) (mu1_uni _ _ unidin) => ->.\nqed.\n\nend section.\n\nend Generic.\n\n\ntheory Indistinguishability.\nrequire import DBool.\n\nclone import Generic as IND with\n  type in_t <- bool,\n  type out_t <- bool,\n  type aux_t <- unit,\n  op din <- {0,1}.\n\nsection.\n\ndeclare module P <: Provided {-Sampler}.\ndeclare axiom P_main_ll : islossless P.main.\n\nlemma RelPr_IndSampler_IndProvided &m :\n  2%r * Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r\n  =\n  Pr[P.main(true, tt) @ &m : res] - Pr[P.main(false, tt) @ &m : res].\nproof.\nrewrite (EqPr_SamplerConj_ProvidedCond_UniBig P (fun a v g b => b = v) &m tt dbool_uni) /=.\nrewrite (: support {0,1} = predT); 1: by rewrite fun_ext => b; rewrite supp_dbool.\nrewrite -Support.card_size_to_seq dboolE -(eq_big_perm predT _ _ _  Support.perm_eq_enum_to_seq). \nrewrite 2!big_cons big_nil /predT /= -/predT.\nrewrite -[_ = false]negbK Pr[mu_not] (: Pr[P.main(false, tt) @ &m : true] = 1%r) 2:/#.\nby byphoare P_main_ll.\nqed.\n\nlemma Rel_Ind_Formalizations &m :\n  2%r * `| Pr[Sampler(P).main() @ &m : res = Sampler.x] - 1%r/2%r |\n  =\n  `| Pr[P.main(false, tt) @ &m : res] - Pr[P.main(true, tt) @ &m : res] |.\nproof. smt(RelPr_IndSampler_IndProvided). qed.\n\nend section.\n\nend Indistinguishability."
    },
    {
        "file": "EC-1/SimplifiedLangSMC.ec",
        "incomplete": "require import AllCore List SmtMap Distr FSet.\n\n(**\n\n  This is a simplified version of the formalisation the\n  \"Language-based Secure Multiparty Computation\", used\n  for illustration purposes in the companion article\n  \"A Formal Treatment of the Role of Verified Compilers in Secure\n  Computation\" (Journal of Logical and Algebraic Methods in\n  Programming, ...).\n  We structured this file by following the paper organization.\n  It includes definitions and theorem statements, but proofs have\n  been omitted -- instead, we add pointers to the corresponding\n  statements/proofs in the original development.\n\n  Remark: some types, such as 'S' and 'SideInfo', have been\n presented in the paper as abstract, for the sake of simplification.\n However, in order to provide definitions not included in the paper,\n we had to refine them is this file.\n*)\n\n(**\n Section 2 - Programming languages and semantics\n ===============================================\n*)\n\n\n(**\n 2.1. Programming Language\n*)\n\n(* Semantic domain of values *)\ntype V.\n\n(* Secret Operations *)\ntype sop_t.\n\n(** Variables and security API call data  *)\ntype var_t.\n\n(* Operation, public args, secret args handlers, secret result handler *)\ntype callData = ____(TYPE_1)____ list*V list*V option.\n\n\n(* Abstract Language *)\ntheory Lang.\n type L, lconf_t.\n op initial_lconf: L -> lconf_t.\n op ____(OP_5)____: lconf_t -> lconf_t option.\n op lcallSt: lconf_t -> callData option.\n op ____(OP_12)____: V -> lconf_t -> lconf_t.\n (* remark: absent from the paper, as it is not used there... *)\n op lstep_iter (k:int) (st:lconf_t): lconf_t option =\n   iter k (obind lstep) (Some st).\n axiom block_on_calls sigma:\n   lcallSt sigma <> None => lstep sigma = None.\nend Lang.\n\n(* secret-sharing scheme *)\ntheory SecretSharing.\nop n: int.\t\t(* Number of parties *)\ntype S = V list.\t(* shared values *)\nop [lossless] share: V -> S distr.\nop ____(OP_11)____: S -> V.\naxiom ss_size v s: s \\in share v => size s = n.\naxiom ss_correct v: dmap (share v) unshare = dunit v.\nend SecretSharing.\n\n\n(**\n 2.2. Computation over secret data\n*)\n\ntheory API.\n\nop n_parties, corrupted_parties: int.\naxiom corrupted_subset: 0 < corrupted_parties < n_parties.\n\nclone import SecretSharing with op n <- n_parties.\n\n\n(* corrupted shares - wlog, we assume the first\n  'corrupted_parties' to be corrupt *)\nop C (x:S) : S = take corrupted_parties x.\n\n\n(* SideInfo *)\ntype other_leak_t, trace_t.\ntype leak_t = [ leakCShares of S \n              | leakOther of other_leak_t ].\nop leakCshrs (x: leak_t) : S option = \n with x = leakCShares s => Some s\n with x = leakOther l => None.\n\ntype SideInfo =\n [ epsilon\n | leak of leak_t\n | trace of trace_t\n ].\nop leakage (x: SideInfo): leak_t option =\n with x = epsilon => None\n with x = leak l => Some l\n with x = trace t => None.\n\nop ctrace (x: SideInfo): trace_t option =\n with x = epsilon => None\n with x = leak l => None\n with x = trace t => Some t.\n\nop leakedCshrs (x: SideInfo): S option =\n obind leakCshrs (leakage x).\n\n\n\n(* Security API interface *)\nmodule type API_t = {\n  proc init(): unit\n  proc eval_sop(o: sop_t, pargs: V list, \n                sargs: V list, sres: V option): (V*SideInfo) option\n  proc set_input(x: S): bool \n  proc get_output(): S option\n}.\n\n\n(* sop arity *)\nop sop_ar (o: sop_t): (int*int*bool).\n\n(* input and output operations *)\nop sop_input: sop_t.\nop sop_output: sop_t.\naxiom arity_input: sop_ar sop_input = (0,0,true).\naxiom arity_output: sop_ar sop_output = (0,1,false).\n\n(* checks arity *)\nop sop_ar_check (o: sop_t, pargs: V list, sargs: V list, sres: V option): bool =\n  sop_ar o = (size pargs, size sargs, sres <> None).\n\n(* lsop specifications *)\nop Fsop: sop_t -> ____(OP_10)____ ____(OP_8)____ ____(OP_9)____ V list -> V * leak_t.\nop pubres: sop_t -> leak_t -> V. \n(* lsop protocols *)\nop [lossless] pi_sop\n : sop_t -> V list * S list -> (S * trace_t) distr.\nop leakXtr: sop_t -> trace_t -> leak_t. (* leakage extractor *)\n(* input and output protocols *)\nop [lossless] pi_input: S -> trace_t distr.\nop [____(OP_6)____] pi_output: S -> (S * trace_t) distr.\n\n\n\n(* lifting of env ops. *)\nop env_getlist ['a, 'b] (m: ('a, 'b) fmap) (l: 'a list)\n : ('b list) option =\n foldr (fun ov or=>obind (fun v=>(omap ((::) v) or)) ov)\n       (Some []) (map ((\"_.[_]\") m) l).\n\nop env_oupd ['a] (m: (V, 'a) fmap) (ov: V option) (x: 'a)\n : (V,'a) fmap =\n if ov = None then m else m.[oget ov <- x].\n\n(* Ideal security library (Fig. 3) *)\nmodule Alpha: API_t = {\n  var senv: (V, V) fmap\n  var ibuf: S option\n  var obuf: S option\n  proc init(): unit = {\n    senv <- empty;\n    ibuf <- None;\n    obuf <- None;\n  }\n  proc eval_sop(o: sop_t, pargs: V list,\n                sargs: V list, sres: V option): (V*SideInfo) option = {\n    var v, vs, v', r, vsargs, l;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input && ibuf <> None) {\n        v <- unshare (oget ibuf);\n        senv <- senv.[ oget sres <- v ];\n        r <- Some (witness, leak (leakCShares (C vs)));\n        ibuf <- None;\n      } else {\n        if (o = sop_output && obuf = None) {\n          v <- oget senv.[head witness sargs];\n          vs <$ share v;\n          obuf <- Some vs;\n          r <- Some (witness, leak (leakCShares (C vs)));\n        } else {\n          vsargs <- oget (env_getlist senv sargs);\n          (v', l) <- Fsop o (pargs,vsargs);\n          r <- Some (v', leak l);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n  proc set_input(x: S): bool = {\n    var r;\n    if (ibuf = None) {\n      ibuf <- Some x;\n      r <- true;\n    } else {\n      r <- false;\n    }\n    return r;\n  }\n  proc get_output(): S option = {\n    var r;\n    r <- obuf;\n    obuf <- None;\n    return r;\n  }\n}.\n\n(* Real security library (Fig. 4) *)\nmodule Beta: API_t = {\n  var senv: (V, S) fmap\n  var ibuf: S option\n  var obuf: S option\n  proc init(): unit = {\n    senv <- empty;\n    ibuf <- None;\n    obuf <- None;\n  }\n  proc eval_sop(o: sop_t, pargs: V list, sargs: V list, sres: V option): (V*SideInfo) option = { \n    var vs, r, t, svsargs, svs, v;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input && ibuf <> None) {\n        vs <- oget ibuf;\n        senv <- senv.[ oget sres <- vs ];\n        ibuf <- None;\n        t <$ pi_input vs;\n        r <- Some (witness, trace t);\n      } else {\n        if (o = sop_output && obuf = None) {\n          vs <- oget senv.[head witness sargs];\n          (svs, t) <$ pi_output vs;\n          obuf <- Some vs;\n          r <- Some (witness, trace t);\n        } else {\n          svsargs <- oget (env_getlist senv sargs);\n          (svs, t) <$ pi_sop o (pargs, svsargs);\n          v <- pubres o (leakXtr o t);\n          r <- Some (v, trace t);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n  proc set_input(x: S): bool = {\n    var r;\n    if (ibuf = None) {\n      ibuf <- Some x;\n      r <- true;\n    } else {\n      r <- false;\n    }\n    return r;\n  }\n  proc get_output(): S option = {\n    var r;\n    r <- obuf;\n    obuf <- None;\n    return r;\n  }\n}.\n\nend API.\n\n(**\n 2.3. Ideal- and Real-world semantics\n*)\n\n(* Single Language setting *)\ntheory SingleLanguage.\n\nclone import Lang as L.\n\nop n_parties, corrupted_parties: int.\naxiom corrupted_subset: 0 < corrupted_parties < n_parties.\n\nclone import API\n with op n_parties <- n_parties,\n      op corrupted_parties <- corrupted_parties\n      proof corrupted_subset by apply corrupted_subset.\n\nimport API.SecretSharing.\n\n\n(* Ideal-world Language Semantics *)\nmodule type IdealSem_t = {\n  proc init(P: L): unit\n  proc step(): SideInfo option\n}.\n\nmodule IdealSem : IdealSem_t = {\n  var st: lconf_t\n  proc init(P: L): unit = {\n    st <- initial_lconf P;\n  }\n  proc step(): SideInfo option = {\n    var cst, info, oc, o, pargs, sargs, sres, vp, l, oeval;\n    cst <- lcallSt st;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Alpha.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,l) <- oget oeval;\n        st <- lcallRet vp st;\n        info <- Some l;\n      }\n    } else {\n        oc <- lstep st;\n        if (oc <> None)\n        st <- oget oc;\n        info <- Some epsilon;\n    }\n    return info;\n  }\n}.\n\n\n(* Real-world Language Semantics *)\nmodule type RealSem_t = {\n  proc init(P: L): unit\n  proc stepP(i: int): bool\n  proc stepS(): SideInfo option\n}. \n\ntype gconf_t = (int, lconf_t) fmap.\n\n(* extract all call-states from a global conf. *)\nop allCallSts (st: gconf_t) : callData option list =\n map (fun i => lcallSt (oget (st.[i]))) (iota_ 1 n_parties).\n\n(* synchronization points:\n     - check if all confs have the same [apiCall_data] info              *)\nop allEqSome ['a] (l: 'a option list): 'a option =\n with l = \"[]\" => None\n with l = (::) x xs => if all (fun y => x=y) xs\n                       then x\n                       else None.\n\n(** callState of a global conf. *)\nop gcallSt (gst: gconf_t): callData option =\n allEqSome (allCallSts gst).\n\n(* predicate to check if a global conf. is at a sync. point *)\nop sync (gst: gconf_t): bool = gcallSt gst <> None.\n\n(** updates result in a global state *)\nop gcallRet (v: V) (st: gconf_t): gconf_t =\n foldr (fun i m => m.[i <- lcallRet v (oget m.[i])]) empty (iota_ 1 n_parties).\n\nmodule RealSem: RealSem_t = {\n  var sigma: (int, lconf_t) fmap\n  proc init(P: L): unit = {\n    sigma <- foldr (fun i x => x.[i <- initial_lconf (P)]) empty (iota_ 1 n_parties);\n  }\n  proc stepP(i: int): bool = {\n    var oc, r;\n    r <- false;\n    oc <- lstep (oget sigma.[i]);\n    if (0 < i <= n_parties && oc <> None) {\n      sigma <- sigma.[i <- oget oc];\n      r <- true;\n    }\n    return r;\n  }\n  proc stepS(): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- gcallSt sigma;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Beta.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- gcallRet vp sigma;\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* Remark: Multi-language real-world semantics presented bellow... *)\n\n\n(**\n Section 3 - Program-based secure computation\n ============================================\n*)\n\n(**\n 3.1. Security Model\n*)\n\n(** Adversarial interface *)\n\n(* Environment *)\nmodule type Z_IO_t = {\n  proc set_input(x: S): bool\n  proc get_output(): S option\n}.\ntype any.\nmodule type Z_Adv_t = {\n  proc activate(): any\n}.\nmodule type Z_t(Z_IO: Z_IO_t, Z_Adv: Z_Adv_t) = {\n  proc run(): bool\n}.\n\n(* Attacker *)\nmodule type Adv_Sem_t = {\n  proc stepP(i: int): bool\n  proc stepS(): SideInfo option\n}.\nmodule type Adv_t(Sem: Adv_Sem_t) = {\n  proc init(P:L): unit\n  proc activate(): any\n}.\n\n(* Simulator *)\nmodule type Sim_Sem_t = {\n  proc step(): SideInfo option\n}.\nmodule type Sim_t(Sem: Sim_Sem_t) = { \n  proc init(P:L): unit\n  proc activate(): any\n}.\n\n\n(** Ideal- and Real-world definitions *)\nmodule IDEAL(Z: Z_t, A: Sim_t) = {\n  module Adv = A(IdealSem)\n  proc game(P: L): bool = {\n    var b;\n    Alpha.init();\n    IdealSem.init(P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\nmodule REAL(Z: Z_t, A: Adv_t) = {\n  module Adv = A(RealSem)\n  proc game(P: L): bool = {\n    var b;\n    Beta.init();\n    RealSem.init(P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\n(**\n 4. Vertical dimension: single-program secure computation\n ========================================================\n*)\n\n(**\n 4.1. API security\n*)\n\n(* strong simulators *)\nop [lossless] sim_output: S * S -> trace_t distr.\n(* weak simulators *)\nop [lossless] sim_input: S -> trace_t distr.\nop [____(OP_1)____] ____(OP_2)____: sop_t -> ____(OP_3)____ list ____(OP_0)____ S list * leak_t -> (S * trace_t) distr.\n \n(* Simulator experiments (Fig. 6) *)\nmodule SimExp = {\n  proc outputSimL(vsarg: S): V * S * trace_t = {\n    var vout, vsout, t;\n    vout <- unshare vsarg;\n    vsout <$ share vout;\n    t <$ sim_output (vsarg, vsout);\n    return (vout, C vsout, t);\n  }\n  proc outputSimR(vsarg: S): V * S * trace_t = {\n    var vsout, t;\n    (vsout, t) <$ pi_output vsarg;\n   return (unshare vsout, C vsout, t);\n  }\n  proc inputSimL(vsin: S): trace_t = {\n    var t;\n    t <$ sim_input (C vsin);\n    return t;\n  }\n  proc inputSimR(vsin: S): trace_t = {\n    var t;\n    t <$ pi_input vsin;\n    return t;    \n  }\n  proc sopSimL(o: sop_t, vpargs: V list, vsargs: S list)\n              : V * S * leak_t * trace_t = {\n    var sv, l, svs, t;\n    (sv, l) <- Fsop o (vpargs, map unshare vsargs);\n    (svs,t) <$ sim_sop o (vpargs, map C vsargs, l);\n    return (sv, svs, l, t);\n  }\n  proc sopSimR(o: sop_t, vpargs: V list, vsargs: S list)\n              : V * S * leak_t * trace_t = {\n    var svs, t;\n    (svs, t) <$ pi_sop o (vpargs, vsargs);\n    return (unshare svs, C svs, leakXtr o t, t);\n  }\n}.\n\n(* Security assumptions (Def. 2) *)\naxiom APIsec_output:\n equiv [ SimExp.outputSimL ~ SimExp.outputSimR\n       :  ={vsarg} ==> ={res}\n       ].\naxiom APIsec_input:\n equiv [ SimExp.inputSimL ~ SimExp.inputSimR\n       :  ={vsin} ==> ={res}\n       ].\naxiom APIsec_sop:\n equiv [ SimExp.sopSimL ~ SimExp.sopSimR\n       :  ={o,vpargs,vsargs} ==> ={res}\n       ].\n\n\n(** Simulated library (corrupted-shares) - Fig. 7 *)\nmodule Gamma = {\n  var senv : (V, S) fmap\n  proc init(): unit = {\n    senv <- empty;\n  }\n  proc sim_sop( o: sop_t, pargs: V list, sargs: V list\n              , sres: V option, l: SideInfo)\n      : (V*SideInfo) option = {\n    var vs, r, t, svsargs, svs, v;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input) {\n        vs <- oget (leakedCshrs l);\n        senv <- senv.[ oget sres <- vs ];\n        t <$ sim_input vs;\n        r <- Some (witness, trace t);\n      } else {\n        if (o = sop_output) {\n          vs <- oget senv.[head witness sargs];\n          svs <- oget (leakedCshrs l);\n          t <$ sim_output (vs,svs);\n          r <- Some (witness, trace t);\n        } else {\n          svsargs <- oget (env_getlist senv sargs);\n          (svs, t) <$ sim_sop o (pargs, svsargs, oget (leakage l));\n          senv <- env_oupd senv sres svs;\n          v <- pubres o (leakXtr o t);\n          r <- Some (v, trace t);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n}.\n\n(**\n 4.2. Security Theorem\n*)\n\n(** Simulator *)\nmodule SimulatedRealSem = {\n  var sigma: (int, lconf_t) fmap\n  proc init(P: L): unit = {\n    sigma <- foldr (fun i x => x.[i <- initial_lconf (P)]) empty (iota_ 1 n_parties);\n  }\n  proc stepP(i: int): bool = {\n    var oc, r;\n    r <- false;\n    oc <- lstep (oget sigma.[i]);\n    if (0 < i <= n_parties && oc <> None) {\n      sigma <- sigma.[i <- oget oc];\n      r <- true;\n    }\n    return r;\n  }\n  proc stepS(l: SideInfo): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- gcallSt sigma;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Gamma.sim_sop(o,pargs,sargs,sres,l);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- gcallRet vp sigma;\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\nmodule SimSem(ISem: Sim_Sem_t): Adv_Sem_t = {\n  proc stepP(i: int): bool = {\n    var b;\n    if (i = 1) { ISem.step(); }\n    b <@ SimulatedRealSem.stepP(i);\n    return b;\n  }\n  proc stepS(): SideInfo option = {\n    var tau;\n    tau <- None;\n    if (sync(SimulatedRealSem.sigma)) {\n      tau <@ ISem.step();\n      tau <@ SimulatedRealSem.stepS(oget tau);\n    }\n    return tau;\n  }\n}.\n\nmodule Sim(A: Adv_t, ISem: Sim_Sem_t) = {\n  proc init = A(SimSem(ISem)).init\n  proc activate = A(SimSem(ISem)).activate\n}.\n\n\n(** THEOREM 1 *)\nequiv Thm1 (Z <: Z_t)(A <: Adv_t):\n REAL(Z, A).game ~ IDEAL(Z, Sim(A)).game\n : ={P} ==> ={res}.\nproof.\n(* The proof of this theorem can be found on file\n'Vertical.ec' (theorem 'Security'). *)\nadmitted.\n\n\n(**\n 5. Horizontal dimension: Multi-program secure computation\n =========================================================\n*)\n\n\n(** Simulated library (public-values only) *)\nmodule Lambda = {\n  proc init(): unit = { }\n  proc sim_sop( o: sop_t, pargs: V list, sargs: V list\n              , sres: V option, l: SideInfo)\n      : (V*SideInfo) option = {\n    var r;\n    if (sop_ar_check o pargs sargs sres) {\n      r <- Some (pubres o (oget (leakage l)), l);\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n}.\n\n(* Simulated ideal-world semantics *)\nmodule SimIdealSem = {\n  var st: lconf_t\n  proc init(P: L): unit = {\n    st <- initial_lconf P;\n  }\n  proc step(ll: SideInfo): SideInfo option = {\n    var cst, info, oc, o, pargs, sargs, sres, vp, l, oeval;\n    cst <- lcallSt st;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Lambda.sim_sop(o,pargs,sargs,sres,ll);\n      if (oeval <> None) {\n        (vp,l) <- oget oeval;\n        st <- lcallRet vp st;\n        info <- Some ll;\n      }\n    } else {\n        oc <- lstep st;\n        if (oc <> None)\n        st <- oget oc;\n        info <- Some epsilon;\n    }\n    return info;\n  }\n}.\n\nend SingleLanguage.\n\n(**\n 5.2. Program-based small-step simulation\n*)\n\ntheory CertifiedCompiler.\n\n(* source language *)\nclone import Lang as LS.\n(* target language *)\nclone Lang as LT.\n(* compiler *)\nop comp : ____(OP_7)____ -> LT.L.\n(* relation \u2248 *)\nop relLSt : lconf_t -> LT.lconf_t -> bool.\n(* Certified-compiler assumptions *)\naxiom relLSt_init P:\n relLSt (LS.initial_lconf P) (LT.initial_lconf (comp P)).\naxiom backwardsim ss st kt st':\n relLSt ss st =>\n LT.lstep_iter kt st = Some st' =>\n LT.lcallSt st' <> None =>\n (exists ks ss', LS.lstep_iter ks ss = Some ss'\n                 /\\ relLSt ss' st'\n                 /\\ 0 <= ks).\naxiom call_consistent sigma1 sigma2:\n  relLSt sigma1 sigma2 => LS.lcallSt sigma1 = LT.lcallSt sigma2.\nend CertifiedCompiler.\n\n(**\n 5.3. Ideal certified compilation\n*)\n\ntheory IdealCompilation.\n\n(* source language *)\nclone Lang as LS.\nclone SingleLanguage as SLS\n with theory L <- LS.\n\nimport SLS.API SLS.API.SecretSharing.\n\n(* target language *)\nclone Lang as LT.\nclone SingleLanguage as SLT\n with theory L <- LT,\n      type ____(TYPE_0)____.other_leak_t <- other_leak_t,\n      type ____(TYPE_2)____.trace_t <- trace_t,\n      type API.SideInfo <- SideInfo,\n      type any <- SLS.any.\n\n(* certified compiler assumption *)\nclone CertifiedCompiler as Comp\n with theory LS <- LS,\n      theory LT <- LT.\n\n(* [sync] predicate - checks if lconf is at a sync. point *)\nop syncS (st: LS.lconf_t) : bool = LS.lcallSt st <> None.\nop syncT (st: LT.lconf_t) : bool = LT.lcallSt st <> None.\n \n(* Ideal target semantics simulator (D) - Fig. 8 *)\nmodule DSem(ISem: SLS.Sim_Sem_t): SLT.Sim_Sem_t = {\n  proc init(P:LS.L): unit = { \n    SLS.SimIdealSem.init(P);\n    SLT.SimIdealSem.init(Comp.comp(P));\n  }\n  proc step(): SideInfo option = {\n    var tau;\n    if (! syncT SLT.SimIdealSem.st) {\n      tau <@ SLT.SimIdealSem.step(epsilon);\n    } else {\n      while (!syncS SLS.SimIdealSem.st) {\n        SLS.SimIdealSem.step(epsilon);\n        tau <@ ISem.step();\n      }\n      tau <@ ISem.step();\n      if (tau <> None) {\n        SLT.SimIdealSem.step(oget tau);\n        SLS.SimIdealSem.step(oget tau);\n      }\n    }\n    return tau;\n  }\n}.\nmodule D(A: SLT.Sim_t, ISem: SLS.Sim_Sem_t) = {\n  proc init(P: LS.L): unit = {\n    DSem(ISem).init(P);\n  }\n  proc activate = A(DSem(ISem)).activate\n}.\n\n(** Theorem 2 *)\nequiv Thm2 (Z <: SLT.Z_t)(A <: SLT.Sim_t):\n SLT.IDEAL(Z, A).game ~ SLS.IDEAL(Z, D(A)).game\n : P{1}=Comp.comp P{2} ==> ={res}.\nproof.\n(* This \"arrow\" of the diagram from Fig. 1 has not been included in\n the formalisation.\n However, its proof strategy is essentially that of theorem Thm3\n presented below.\n *)\nadmitted.\n\nend IdealCompilation.\n\n(**\n 5.4. Real certified compilation\n*)\n\ntheory MultiLanguage.\n(* remark: we instantiate the multi-language setting\n with 3 parties (1 corrupted) *)\n\n(* source language *)\nclone import SingleLanguage as LS\n with op n_parties <- 3,\n      op corrupted_parties <- 1\n      proof corrupted_subset by done.\n\nimport LS.API LS.API.SecretSharing.\n\n\n(* target languages *) \nclone Lang as L1.\nclone CertifiedCompiler as C1\n with theory LS <- LS.L,\n      theory LT <- L1.\nclone Lang as L2.\nclone CertifiedCompiler as C2\n with theory LS <- LS.L,\n      theory LT <- L2.\nclone Lang as L3.\nclone CertifiedCompiler as C3\n with theory LS <- LS.L,\n      theory LT <- L3.\n\n(* checks of global conf. is at a sync. point *)\nop sync (st:L1.lconf_t*L2.lconf_t*L3.lconf_t): bool =\n  L1.lcallSt st.`1 <> None\n  && L1.lcallSt st.`1 = L2.lcallSt st.`2\n  && L1.lcallSt st.`1 = L3.lcallSt st.`3.\n\n(* Real-world semantics (multi-language) *)\nmodule RealSemML = {\n  var sigma: L1.lconf_t * L2.lconf_t * L3.lconf_t\n  proc init(P1: L1.L, P2: L2.L, P3: L3.L): unit = {\n    sigma <- (L1.initial_lconf P1,\n              L2.initial_lconf P2,\n              L3.initial_lconf P3);\n  }\n  proc stepP(i: int): bool = {\n    var oc1, oc2, oc3, r;\n    r <- false;\n    if ( i = 1 ) {\n      oc1 <- L1.lstep sigma.`1;\n      if (oc1 <> None) {\n        sigma <- (oget oc1, sigma.`2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 2 ) {\n      oc2 <- L2.lstep sigma.`2;\n      if (oc2 <> None) {\n        sigma <- (sigma.`1, oget oc2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 3 ) {\n      oc3 <- L3.lstep sigma.`3;\n      if (oc3 <> None) {\n        sigma <- (sigma.`1, sigma.`2, oget oc3);\n        r <- true;\n      }\n    }\n    return r;\n  }\n  proc stepS(): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- if (sync sigma) then L1.lcallSt sigma.`1 else None;\n    info <- None;\n    if ( cst <> None ) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Beta.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- (L1.lcallRet vp sigma.`1,\n                  L2.lcallRet vp sigma.`2,\n                  L3.lcallRet vp sigma.`3);\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* multi-language 'REAL' security experiment *)\nmodule REAL_ML(Z: Z_t, A: Adv_t) = {\n  module Adv = A(RealSem)\n  proc game(P: LS.L.L): bool = {\n    var b;\n    Beta.init();\n    RealSemML.init(C1.comp P,C2.comp P,C3.comp P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\n(* Simulated (multi-language) real-world semantics *)\nmodule SimRealSemML = {\n  var sigma: L1.lconf_t * L2.lconf_t * L3.lconf_t\n  proc init(P1: L1.L, P2: L2.L, P3: L3.L): unit = {\n    sigma <- (L1.initial_lconf P1,\n              L2.initial_lconf P2,\n              L3.initial_lconf P3);\n  }\n  proc stepP(i: int): bool = {\n    var oc1, oc2, oc3, r;\n    r <- false;\n    if ( i = 1 ) {\n      oc1 <- L1.lstep sigma.`1;\n      if (oc1 <> None) {\n        sigma <- (oget oc1, sigma.`2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 2 ) {\n      oc2 <- L2.lstep sigma.`2;\n      if (oc2 <> None) {\n        sigma <- (sigma.`1, oget oc2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 3 ) {\n      oc3 <- L3.lstep sigma.`3;\n      if (oc3 <> None) {\n        sigma <- (sigma.`1, sigma.`2, oget oc3);\n        r <- true;\n      }\n    }\n    return r;\n  }\n  proc stepS(t: SideInfo): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- if (sync sigma) then L1.lcallSt sigma.`1 else None;\n    info <- None;\n    if ( cst <> None ) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Lambda.sim_sop(o,pargs,sargs,sres,leak (leakXtr o\n  (oget (ctrace t))));\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- (L1.lcallRet vp sigma.`1,\n                  L2.lcallRet vp sigma.`2,\n                  L3.lcallRet vp sigma.`3);\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* simulator (D) - Fig. 9 *)\nmodule DSem(RSem: ____(MODULE_0)____.Adv_Sem_t): LS.Adv_Sem_t = {\n  proc init(P:LS.L.L): unit = { \n    SimRealSemML.init(C1.comp P, C2.comp P, C3.comp P);\n  }\n  proc stepP(i: int): bool = {\n    var b;\n    b <@ SimRealSemML.stepP(i);\n    return b;\n  }\n  proc stepS(): SideInfo option = {\n    var tau, b;\n    tau <- None;\n    if ( sync SimRealSemML.sigma ) {\n      b <- true;\n      while (b) { b <@ RSem.stepP(1); }\n      b <- true;\n      while (b) { b <@ RSem.stepP(2); }\n      b <- true;\n      while (b) { b <@ RSem.stepP(3); }\n      tau <@ RSem.stepS();\n      SimRealSemML.stepS(oget tau);\n    }\n    return tau;\n  }\n}.\nmodule D(A: LS.Adv_t, RSem: LS.Adv_Sem_t) = {\n  proc init(P: LS.L.L): unit = {\n    DSem(RSem).init(P);\n  }\n  proc activate = A(DSem(RSem)).activate\n}.\n\n(** Theorem 3 *)\nequiv Thm3 (Z <: LS.Z_t)(A <: LS.Adv_t):\n REAL_ML(Z, A).game ~ LS.REAL(Z, D(A)).game\n : ={P} ==> ={res}.\nproof.\n(* The proof can be found at file 'Horizontal.ec'\n (theorem 'SecurityMT')  *)\nadmitted.\n\nend MultiLanguage.",
        "complete:": "require import AllCore List SmtMap Distr FSet.\n\n(**\n\n  This is a simplified version of the formalisation the\n  \"Language-based Secure Multiparty Computation\", used\n  for illustration purposes in the companion article\n  \"A Formal Treatment of the Role of Verified Compilers in Secure\n  Computation\" (Journal of Logical and Algebraic Methods in\n  Programming, ...).\n  We structured this file by following the paper organization.\n  It includes definitions and theorem statements, but proofs have\n  been omitted -- instead, we add pointers to the corresponding\n  statements/proofs in the original development.\n\n  Remark: some types, such as 'S' and 'SideInfo', have been\n presented in the paper as abstract, for the sake of simplification.\n However, in order to provide definitions not included in the paper,\n we had to refine them is this file.\n*)\n\n(**\n Section 2 - Programming languages and semantics\n ===============================================\n*)\n\n\n(**\n 2.1. Programming Language\n*)\n\n(* Semantic domain of values *)\ntype V.\n\n(* Secret Operations *)\ntype sop_t.\n\n(** Variables and security API call data  *)\ntype var_t.\n\n(* Operation, public args, secret args handlers, secret result handler *)\ntype callData = sop_t*V list*V list*V option.\n\n\n(* Abstract Language *)\ntheory Lang.\n type L, lconf_t.\n op initial_lconf: L -> lconf_t.\n op lstep: lconf_t -> lconf_t option.\n op lcallSt: lconf_t -> callData option.\n op lcallRet: V -> lconf_t -> lconf_t.\n (* remark: absent from the paper, as it is not used there... *)\n op lstep_iter (k:int) (st:lconf_t): lconf_t option =\n   iter k (obind lstep) (Some st).\n axiom block_on_calls sigma:\n   lcallSt sigma <> None => lstep sigma = None.\nend Lang.\n\n(* secret-sharing scheme *)\ntheory SecretSharing.\nop n: int.\t\t(* Number of parties *)\ntype S = V list.\t(* shared values *)\nop [lossless] share: V -> S distr.\nop unshare: S -> V.\naxiom ss_size v s: s \\in share v => size s = n.\naxiom ss_correct v: dmap (share v) unshare = dunit v.\nend SecretSharing.\n\n\n(**\n 2.2. Computation over secret data\n*)\n\ntheory API.\n\nop n_parties, corrupted_parties: int.\naxiom corrupted_subset: 0 < corrupted_parties < n_parties.\n\nclone import SecretSharing with op n <- n_parties.\n\n\n(* corrupted shares - wlog, we assume the first\n  'corrupted_parties' to be corrupt *)\nop C (x:S) : S = take corrupted_parties x.\n\n\n(* SideInfo *)\ntype other_leak_t, trace_t.\ntype leak_t = [ leakCShares of S \n              | leakOther of other_leak_t ].\nop leakCshrs (x: leak_t) : S option = \n with x = leakCShares s => Some s\n with x = leakOther l => None.\n\ntype SideInfo =\n [ epsilon\n | leak of leak_t\n | trace of trace_t\n ].\nop leakage (x: SideInfo): leak_t option =\n with x = epsilon => None\n with x = leak l => Some l\n with x = trace t => None.\n\nop ctrace (x: SideInfo): trace_t option =\n with x = epsilon => None\n with x = leak l => None\n with x = trace t => Some t.\n\nop leakedCshrs (x: SideInfo): S option =\n obind leakCshrs (leakage x).\n\n\n\n(* Security API interface *)\nmodule type API_t = {\n  proc init(): unit\n  proc eval_sop(o: sop_t, pargs: V list, \n                sargs: V list, sres: V option): (V*SideInfo) option\n  proc set_input(x: S): bool \n  proc get_output(): S option\n}.\n\n\n(* sop arity *)\nop sop_ar (o: sop_t): (int*int*bool).\n\n(* input and output operations *)\nop sop_input: sop_t.\nop sop_output: sop_t.\naxiom arity_input: sop_ar sop_input = (0,0,true).\naxiom arity_output: sop_ar sop_output = (0,1,false).\n\n(* checks arity *)\nop sop_ar_check (o: sop_t, pargs: V list, sargs: V list, sres: V option): bool =\n  sop_ar o = (size pargs, size sargs, sres <> None).\n\n(* lsop specifications *)\nop Fsop: sop_t -> V list * V list -> V * leak_t.\nop pubres: sop_t -> leak_t -> V. \n(* lsop protocols *)\nop [lossless] pi_sop\n : sop_t -> V list * S list -> (S * trace_t) distr.\nop leakXtr: sop_t -> trace_t -> leak_t. (* leakage extractor *)\n(* input and output protocols *)\nop [lossless] pi_input: S -> trace_t distr.\nop [lossless] pi_output: S -> (S * trace_t) distr.\n\n\n\n(* lifting of env ops. *)\nop env_getlist ['a, 'b] (m: ('a, 'b) fmap) (l: 'a list)\n : ('b list) option =\n foldr (fun ov or=>obind (fun v=>(omap ((::) v) or)) ov)\n       (Some []) (map ((\"_.[_]\") m) l).\n\nop env_oupd ['a] (m: (V, 'a) fmap) (ov: V option) (x: 'a)\n : (V,'a) fmap =\n if ov = None then m else m.[oget ov <- x].\n\n(* Ideal security library (Fig. 3) *)\nmodule Alpha: API_t = {\n  var senv: (V, V) fmap\n  var ibuf: S option\n  var obuf: S option\n  proc init(): unit = {\n    senv <- empty;\n    ibuf <- None;\n    obuf <- None;\n  }\n  proc eval_sop(o: sop_t, pargs: V list,\n                sargs: V list, sres: V option): (V*SideInfo) option = {\n    var v, vs, v', r, vsargs, l;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input && ibuf <> None) {\n        v <- unshare (oget ibuf);\n        senv <- senv.[ oget sres <- v ];\n        r <- Some (witness, leak (leakCShares (C vs)));\n        ibuf <- None;\n      } else {\n        if (o = sop_output && obuf = None) {\n          v <- oget senv.[head witness sargs];\n          vs <$ share v;\n          obuf <- Some vs;\n          r <- Some (witness, leak (leakCShares (C vs)));\n        } else {\n          vsargs <- oget (env_getlist senv sargs);\n          (v', l) <- Fsop o (pargs,vsargs);\n          r <- Some (v', leak l);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n  proc set_input(x: S): bool = {\n    var r;\n    if (ibuf = None) {\n      ibuf <- Some x;\n      r <- true;\n    } else {\n      r <- false;\n    }\n    return r;\n  }\n  proc get_output(): S option = {\n    var r;\n    r <- obuf;\n    obuf <- None;\n    return r;\n  }\n}.\n\n(* Real security library (Fig. 4) *)\nmodule Beta: API_t = {\n  var senv: (V, S) fmap\n  var ibuf: S option\n  var obuf: S option\n  proc init(): unit = {\n    senv <- empty;\n    ibuf <- None;\n    obuf <- None;\n  }\n  proc eval_sop(o: sop_t, pargs: V list, sargs: V list, sres: V option): (V*SideInfo) option = { \n    var vs, r, t, svsargs, svs, v;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input && ibuf <> None) {\n        vs <- oget ibuf;\n        senv <- senv.[ oget sres <- vs ];\n        ibuf <- None;\n        t <$ pi_input vs;\n        r <- Some (witness, trace t);\n      } else {\n        if (o = sop_output && obuf = None) {\n          vs <- oget senv.[head witness sargs];\n          (svs, t) <$ pi_output vs;\n          obuf <- Some vs;\n          r <- Some (witness, trace t);\n        } else {\n          svsargs <- oget (env_getlist senv sargs);\n          (svs, t) <$ pi_sop o (pargs, svsargs);\n          v <- pubres o (leakXtr o t);\n          r <- Some (v, trace t);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n  proc set_input(x: S): bool = {\n    var r;\n    if (ibuf = None) {\n      ibuf <- Some x;\n      r <- true;\n    } else {\n      r <- false;\n    }\n    return r;\n  }\n  proc get_output(): S option = {\n    var r;\n    r <- obuf;\n    obuf <- None;\n    return r;\n  }\n}.\n\nend API.\n\n(**\n 2.3. Ideal- and Real-world semantics\n*)\n\n(* Single Language setting *)\ntheory SingleLanguage.\n\nclone import Lang as L.\n\nop n_parties, corrupted_parties: int.\naxiom corrupted_subset: 0 < corrupted_parties < n_parties.\n\nclone import API\n with op n_parties <- n_parties,\n      op corrupted_parties <- corrupted_parties\n      proof corrupted_subset by apply corrupted_subset.\n\nimport API.SecretSharing.\n\n\n(* Ideal-world Language Semantics *)\nmodule type IdealSem_t = {\n  proc init(P: L): unit\n  proc step(): SideInfo option\n}.\n\nmodule IdealSem : IdealSem_t = {\n  var st: lconf_t\n  proc init(P: L): unit = {\n    st <- initial_lconf P;\n  }\n  proc step(): SideInfo option = {\n    var cst, info, oc, o, pargs, sargs, sres, vp, l, oeval;\n    cst <- lcallSt st;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Alpha.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,l) <- oget oeval;\n        st <- lcallRet vp st;\n        info <- Some l;\n      }\n    } else {\n        oc <- lstep st;\n        if (oc <> None)\n        st <- oget oc;\n        info <- Some epsilon;\n    }\n    return info;\n  }\n}.\n\n\n(* Real-world Language Semantics *)\nmodule type RealSem_t = {\n  proc init(P: L): unit\n  proc stepP(i: int): bool\n  proc stepS(): SideInfo option\n}. \n\ntype gconf_t = (int, lconf_t) fmap.\n\n(* extract all call-states from a global conf. *)\nop allCallSts (st: gconf_t) : callData option list =\n map (fun i => lcallSt (oget (st.[i]))) (iota_ 1 n_parties).\n\n(* synchronization points:\n     - check if all confs have the same [apiCall_data] info              *)\nop allEqSome ['a] (l: 'a option list): 'a option =\n with l = \"[]\" => None\n with l = (::) x xs => if all (fun y => x=y) xs\n                       then x\n                       else None.\n\n(** callState of a global conf. *)\nop gcallSt (gst: gconf_t): callData option =\n allEqSome (allCallSts gst).\n\n(* predicate to check if a global conf. is at a sync. point *)\nop sync (gst: gconf_t): bool = gcallSt gst <> None.\n\n(** updates result in a global state *)\nop gcallRet (v: V) (st: gconf_t): gconf_t =\n foldr (fun i m => m.[i <- lcallRet v (oget m.[i])]) empty (iota_ 1 n_parties).\n\nmodule RealSem: RealSem_t = {\n  var sigma: (int, lconf_t) fmap\n  proc init(P: L): unit = {\n    sigma <- foldr (fun i x => x.[i <- initial_lconf (P)]) empty (iota_ 1 n_parties);\n  }\n  proc stepP(i: int): bool = {\n    var oc, r;\n    r <- false;\n    oc <- lstep (oget sigma.[i]);\n    if (0 < i <= n_parties && oc <> None) {\n      sigma <- sigma.[i <- oget oc];\n      r <- true;\n    }\n    return r;\n  }\n  proc stepS(): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- gcallSt sigma;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Beta.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- gcallRet vp sigma;\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* Remark: Multi-language real-world semantics presented bellow... *)\n\n\n(**\n Section 3 - Program-based secure computation\n ============================================\n*)\n\n(**\n 3.1. Security Model\n*)\n\n(** Adversarial interface *)\n\n(* Environment *)\nmodule type Z_IO_t = {\n  proc set_input(x: S): bool\n  proc get_output(): S option\n}.\ntype any.\nmodule type Z_Adv_t = {\n  proc activate(): any\n}.\nmodule type Z_t(Z_IO: Z_IO_t, Z_Adv: Z_Adv_t) = {\n  proc run(): bool\n}.\n\n(* Attacker *)\nmodule type Adv_Sem_t = {\n  proc stepP(i: int): bool\n  proc stepS(): SideInfo option\n}.\nmodule type Adv_t(Sem: Adv_Sem_t) = {\n  proc init(P:L): unit\n  proc activate(): any\n}.\n\n(* Simulator *)\nmodule type Sim_Sem_t = {\n  proc step(): SideInfo option\n}.\nmodule type Sim_t(Sem: Sim_Sem_t) = { \n  proc init(P:L): unit\n  proc activate(): any\n}.\n\n\n(** Ideal- and Real-world definitions *)\nmodule IDEAL(Z: Z_t, A: Sim_t) = {\n  module Adv = A(IdealSem)\n  proc game(P: L): bool = {\n    var b;\n    Alpha.init();\n    IdealSem.init(P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\nmodule REAL(Z: Z_t, A: Adv_t) = {\n  module Adv = A(RealSem)\n  proc game(P: L): bool = {\n    var b;\n    Beta.init();\n    RealSem.init(P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\n(**\n 4. Vertical dimension: single-program secure computation\n ========================================================\n*)\n\n(**\n 4.1. API security\n*)\n\n(* strong simulators *)\nop [lossless] sim_output: S * S -> trace_t distr.\n(* weak simulators *)\nop [lossless] sim_input: S -> trace_t distr.\nop [lossless] sim_sop: sop_t -> V list * S list * leak_t -> (S * trace_t) distr.\n \n(* Simulator experiments (Fig. 6) *)\nmodule SimExp = {\n  proc outputSimL(vsarg: S): V * S * trace_t = {\n    var vout, vsout, t;\n    vout <- unshare vsarg;\n    vsout <$ share vout;\n    t <$ sim_output (vsarg, vsout);\n    return (vout, C vsout, t);\n  }\n  proc outputSimR(vsarg: S): V * S * trace_t = {\n    var vsout, t;\n    (vsout, t) <$ pi_output vsarg;\n   return (unshare vsout, C vsout, t);\n  }\n  proc inputSimL(vsin: S): trace_t = {\n    var t;\n    t <$ sim_input (C vsin);\n    return t;\n  }\n  proc inputSimR(vsin: S): trace_t = {\n    var t;\n    t <$ pi_input vsin;\n    return t;    \n  }\n  proc sopSimL(o: sop_t, vpargs: V list, vsargs: S list)\n              : V * S * leak_t * trace_t = {\n    var sv, l, svs, t;\n    (sv, l) <- Fsop o (vpargs, map unshare vsargs);\n    (svs,t) <$ sim_sop o (vpargs, map C vsargs, l);\n    return (sv, svs, l, t);\n  }\n  proc sopSimR(o: sop_t, vpargs: V list, vsargs: S list)\n              : V * S * leak_t * trace_t = {\n    var svs, t;\n    (svs, t) <$ pi_sop o (vpargs, vsargs);\n    return (unshare svs, C svs, leakXtr o t, t);\n  }\n}.\n\n(* Security assumptions (Def. 2) *)\naxiom APIsec_output:\n equiv [ SimExp.outputSimL ~ SimExp.outputSimR\n       :  ={vsarg} ==> ={res}\n       ].\naxiom APIsec_input:\n equiv [ SimExp.inputSimL ~ SimExp.inputSimR\n       :  ={vsin} ==> ={res}\n       ].\naxiom APIsec_sop:\n equiv [ SimExp.sopSimL ~ SimExp.sopSimR\n       :  ={o,vpargs,vsargs} ==> ={res}\n       ].\n\n\n(** Simulated library (corrupted-shares) - Fig. 7 *)\nmodule Gamma = {\n  var senv : (V, S) fmap\n  proc init(): unit = {\n    senv <- empty;\n  }\n  proc sim_sop( o: sop_t, pargs: V list, sargs: V list\n              , sres: V option, l: SideInfo)\n      : (V*SideInfo) option = {\n    var vs, r, t, svsargs, svs, v;\n    if (sop_ar_check o pargs sargs sres) {\n      if (o = sop_input) {\n        vs <- oget (leakedCshrs l);\n        senv <- senv.[ oget sres <- vs ];\n        t <$ sim_input vs;\n        r <- Some (witness, trace t);\n      } else {\n        if (o = sop_output) {\n          vs <- oget senv.[head witness sargs];\n          svs <- oget (leakedCshrs l);\n          t <$ sim_output (vs,svs);\n          r <- Some (witness, trace t);\n        } else {\n          svsargs <- oget (env_getlist senv sargs);\n          (svs, t) <$ sim_sop o (pargs, svsargs, oget (leakage l));\n          senv <- env_oupd senv sres svs;\n          v <- pubres o (leakXtr o t);\n          r <- Some (v, trace t);\n        }\n      }\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n}.\n\n(**\n 4.2. Security Theorem\n*)\n\n(** Simulator *)\nmodule SimulatedRealSem = {\n  var sigma: (int, lconf_t) fmap\n  proc init(P: L): unit = {\n    sigma <- foldr (fun i x => x.[i <- initial_lconf (P)]) empty (iota_ 1 n_parties);\n  }\n  proc stepP(i: int): bool = {\n    var oc, r;\n    r <- false;\n    oc <- lstep (oget sigma.[i]);\n    if (0 < i <= n_parties && oc <> None) {\n      sigma <- sigma.[i <- oget oc];\n      r <- true;\n    }\n    return r;\n  }\n  proc stepS(l: SideInfo): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- gcallSt sigma;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Gamma.sim_sop(o,pargs,sargs,sres,l);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- gcallRet vp sigma;\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\nmodule SimSem(ISem: Sim_Sem_t): Adv_Sem_t = {\n  proc stepP(i: int): bool = {\n    var b;\n    if (i = 1) { ISem.step(); }\n    b <@ SimulatedRealSem.stepP(i);\n    return b;\n  }\n  proc stepS(): SideInfo option = {\n    var tau;\n    tau <- None;\n    if (sync(SimulatedRealSem.sigma)) {\n      tau <@ ISem.step();\n      tau <@ SimulatedRealSem.stepS(oget tau);\n    }\n    return tau;\n  }\n}.\n\nmodule Sim(A: Adv_t, ISem: Sim_Sem_t) = {\n  proc init = A(SimSem(ISem)).init\n  proc activate = A(SimSem(ISem)).activate\n}.\n\n\n(** THEOREM 1 *)\nequiv Thm1 (Z <: Z_t)(A <: Adv_t):\n REAL(Z, A).game ~ IDEAL(Z, Sim(A)).game\n : ={P} ==> ={res}.\nproof.\n(* The proof of this theorem can be found on file\n'Vertical.ec' (theorem 'Security'). *)\nadmitted.\n\n\n(**\n 5. Horizontal dimension: Multi-program secure computation\n =========================================================\n*)\n\n\n(** Simulated library (public-values only) *)\nmodule Lambda = {\n  proc init(): unit = { }\n  proc sim_sop( o: sop_t, pargs: V list, sargs: V list\n              , sres: V option, l: SideInfo)\n      : (V*SideInfo) option = {\n    var r;\n    if (sop_ar_check o pargs sargs sres) {\n      r <- Some (pubres o (oget (leakage l)), l);\n    } else {\n        r <- None;\n    } \n    return r;\n  }\n}.\n\n(* Simulated ideal-world semantics *)\nmodule SimIdealSem = {\n  var st: lconf_t\n  proc init(P: L): unit = {\n    st <- initial_lconf P;\n  }\n  proc step(ll: SideInfo): SideInfo option = {\n    var cst, info, oc, o, pargs, sargs, sres, vp, l, oeval;\n    cst <- lcallSt st;\n    info <- None;\n    if (cst <> None) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Lambda.sim_sop(o,pargs,sargs,sres,ll);\n      if (oeval <> None) {\n        (vp,l) <- oget oeval;\n        st <- lcallRet vp st;\n        info <- Some ll;\n      }\n    } else {\n        oc <- lstep st;\n        if (oc <> None)\n        st <- oget oc;\n        info <- Some epsilon;\n    }\n    return info;\n  }\n}.\n\nend SingleLanguage.\n\n(**\n 5.2. Program-based small-step simulation\n*)\n\ntheory CertifiedCompiler.\n\n(* source language *)\nclone import Lang as LS.\n(* target language *)\nclone Lang as LT.\n(* compiler *)\nop comp : L -> LT.L.\n(* relation \u2248 *)\nop relLSt : lconf_t -> LT.lconf_t -> bool.\n(* Certified-compiler assumptions *)\naxiom relLSt_init P:\n relLSt (LS.initial_lconf P) (LT.initial_lconf (comp P)).\naxiom backwardsim ss st kt st':\n relLSt ss st =>\n LT.lstep_iter kt st = Some st' =>\n LT.lcallSt st' <> None =>\n (exists ks ss', LS.lstep_iter ks ss = Some ss'\n                 /\\ relLSt ss' st'\n                 /\\ 0 <= ks).\naxiom call_consistent sigma1 sigma2:\n  relLSt sigma1 sigma2 => LS.lcallSt sigma1 = LT.lcallSt sigma2.\nend CertifiedCompiler.\n\n(**\n 5.3. Ideal certified compilation\n*)\n\ntheory IdealCompilation.\n\n(* source language *)\nclone Lang as LS.\nclone SingleLanguage as SLS\n with theory L <- LS.\n\nimport SLS.API SLS.API.SecretSharing.\n\n(* target language *)\nclone Lang as LT.\nclone SingleLanguage as SLT\n with theory L <- LT,\n      type API.other_leak_t <- other_leak_t,\n      type API.trace_t <- trace_t,\n      type API.SideInfo <- SideInfo,\n      type any <- SLS.any.\n\n(* certified compiler assumption *)\nclone CertifiedCompiler as Comp\n with theory LS <- LS,\n      theory LT <- LT.\n\n(* [sync] predicate - checks if lconf is at a sync. point *)\nop syncS (st: LS.lconf_t) : bool = LS.lcallSt st <> None.\nop syncT (st: LT.lconf_t) : bool = LT.lcallSt st <> None.\n \n(* Ideal target semantics simulator (D) - Fig. 8 *)\nmodule DSem(ISem: SLS.Sim_Sem_t): SLT.Sim_Sem_t = {\n  proc init(P:LS.L): unit = { \n    SLS.SimIdealSem.init(P);\n    SLT.SimIdealSem.init(Comp.comp(P));\n  }\n  proc step(): SideInfo option = {\n    var tau;\n    if (! syncT SLT.SimIdealSem.st) {\n      tau <@ SLT.SimIdealSem.step(epsilon);\n    } else {\n      while (!syncS SLS.SimIdealSem.st) {\n        SLS.SimIdealSem.step(epsilon);\n        tau <@ ISem.step();\n      }\n      tau <@ ISem.step();\n      if (tau <> None) {\n        SLT.SimIdealSem.step(oget tau);\n        SLS.SimIdealSem.step(oget tau);\n      }\n    }\n    return tau;\n  }\n}.\nmodule D(A: SLT.Sim_t, ISem: SLS.Sim_Sem_t) = {\n  proc init(P: LS.L): unit = {\n    DSem(ISem).init(P);\n  }\n  proc activate = A(DSem(ISem)).activate\n}.\n\n(** Theorem 2 *)\nequiv Thm2 (Z <: SLT.Z_t)(A <: SLT.Sim_t):\n SLT.IDEAL(Z, A).game ~ SLS.IDEAL(Z, D(A)).game\n : P{1}=Comp.comp P{2} ==> ={res}.\nproof.\n(* This \"arrow\" of the diagram from Fig. 1 has not been included in\n the formalisation.\n However, its proof strategy is essentially that of theorem Thm3\n presented below.\n *)\nadmitted.\n\nend IdealCompilation.\n\n(**\n 5.4. Real certified compilation\n*)\n\ntheory MultiLanguage.\n(* remark: we instantiate the multi-language setting\n with 3 parties (1 corrupted) *)\n\n(* source language *)\nclone import SingleLanguage as LS\n with op n_parties <- 3,\n      op corrupted_parties <- 1\n      proof corrupted_subset by done.\n\nimport LS.API LS.API.SecretSharing.\n\n\n(* target languages *) \nclone Lang as L1.\nclone CertifiedCompiler as C1\n with theory LS <- LS.L,\n      theory LT <- L1.\nclone Lang as L2.\nclone CertifiedCompiler as C2\n with theory LS <- LS.L,\n      theory LT <- L2.\nclone Lang as L3.\nclone CertifiedCompiler as C3\n with theory LS <- LS.L,\n      theory LT <- L3.\n\n(* checks of global conf. is at a sync. point *)\nop sync (st:L1.lconf_t*L2.lconf_t*L3.lconf_t): bool =\n  L1.lcallSt st.`1 <> None\n  && L1.lcallSt st.`1 = L2.lcallSt st.`2\n  && L1.lcallSt st.`1 = L3.lcallSt st.`3.\n\n(* Real-world semantics (multi-language) *)\nmodule RealSemML = {\n  var sigma: L1.lconf_t * L2.lconf_t * L3.lconf_t\n  proc init(P1: L1.L, P2: L2.L, P3: L3.L): unit = {\n    sigma <- (L1.initial_lconf P1,\n              L2.initial_lconf P2,\n              L3.initial_lconf P3);\n  }\n  proc stepP(i: int): bool = {\n    var oc1, oc2, oc3, r;\n    r <- false;\n    if ( i = 1 ) {\n      oc1 <- L1.lstep sigma.`1;\n      if (oc1 <> None) {\n        sigma <- (oget oc1, sigma.`2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 2 ) {\n      oc2 <- L2.lstep sigma.`2;\n      if (oc2 <> None) {\n        sigma <- (sigma.`1, oget oc2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 3 ) {\n      oc3 <- L3.lstep sigma.`3;\n      if (oc3 <> None) {\n        sigma <- (sigma.`1, sigma.`2, oget oc3);\n        r <- true;\n      }\n    }\n    return r;\n  }\n  proc stepS(): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- if (sync sigma) then L1.lcallSt sigma.`1 else None;\n    info <- None;\n    if ( cst <> None ) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Beta.eval_sop(o,pargs,sargs,sres);\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- (L1.lcallRet vp sigma.`1,\n                  L2.lcallRet vp sigma.`2,\n                  L3.lcallRet vp sigma.`3);\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* multi-language 'REAL' security experiment *)\nmodule REAL_ML(Z: Z_t, A: Adv_t) = {\n  module Adv = A(RealSem)\n  proc game(P: LS.L.L): bool = {\n    var b;\n    Beta.init();\n    RealSemML.init(C1.comp P,C2.comp P,C3.comp P);\n    Adv.init(P);\n    b <@ Z(Alpha, Adv).run();\n    return b;\n  }\n}.\n\n(* Simulated (multi-language) real-world semantics *)\nmodule SimRealSemML = {\n  var sigma: L1.lconf_t * L2.lconf_t * L3.lconf_t\n  proc init(P1: L1.L, P2: L2.L, P3: L3.L): unit = {\n    sigma <- (L1.initial_lconf P1,\n              L2.initial_lconf P2,\n              L3.initial_lconf P3);\n  }\n  proc stepP(i: int): bool = {\n    var oc1, oc2, oc3, r;\n    r <- false;\n    if ( i = 1 ) {\n      oc1 <- L1.lstep sigma.`1;\n      if (oc1 <> None) {\n        sigma <- (oget oc1, sigma.`2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 2 ) {\n      oc2 <- L2.lstep sigma.`2;\n      if (oc2 <> None) {\n        sigma <- (sigma.`1, oget oc2, sigma.`3);\n        r <- true;\n      }\n    }\n    if ( i = 3 ) {\n      oc3 <- L3.lstep sigma.`3;\n      if (oc3 <> None) {\n        sigma <- (sigma.`1, sigma.`2, oget oc3);\n        r <- true;\n      }\n    }\n    return r;\n  }\n  proc stepS(t: SideInfo): SideInfo option = {\n    var cst, info, o, pargs, sargs, sres, oeval, vp, tau;\n    cst <- if (sync sigma) then L1.lcallSt sigma.`1 else None;\n    info <- None;\n    if ( cst <> None ) {\n      (o, pargs, sargs, sres) <- oget cst;\n      oeval <@ Lambda.sim_sop(o,pargs,sargs,sres,leak (leakXtr o\n  (oget (ctrace t))));\n      if (oeval <> None) {\n        (vp,tau) <- oget oeval;\n        sigma <- (L1.lcallRet vp sigma.`1,\n                  L2.lcallRet vp sigma.`2,\n                  L3.lcallRet vp sigma.`3);\n        info <- Some tau;\n      }\n    }\n    return info;\n  }\n}.\n\n(* simulator (D) - Fig. 9 *)\nmodule DSem(RSem: LS.Adv_Sem_t): LS.Adv_Sem_t = {\n  proc init(P:LS.L.L): unit = { \n    SimRealSemML.init(C1.comp P, C2.comp P, C3.comp P);\n  }\n  proc stepP(i: int): bool = {\n    var b;\n    b <@ SimRealSemML.stepP(i);\n    return b;\n  }\n  proc stepS(): SideInfo option = {\n    var tau, b;\n    tau <- None;\n    if ( sync SimRealSemML.sigma ) {\n      b <- true;\n      while (b) { b <@ RSem.stepP(1); }\n      b <- true;\n      while (b) { b <@ RSem.stepP(2); }\n      b <- true;\n      while (b) { b <@ RSem.stepP(3); }\n      tau <@ RSem.stepS();\n      SimRealSemML.stepS(oget tau);\n    }\n    return tau;\n  }\n}.\nmodule D(A: LS.Adv_t, RSem: LS.Adv_Sem_t) = {\n  proc init(P: LS.L.L): unit = {\n    DSem(RSem).init(P);\n  }\n  proc activate = A(DSem(RSem)).activate\n}.\n\n(** Theorem 3 *)\nequiv Thm3 (Z <: LS.Z_t)(A <: LS.Adv_t):\n REAL_ML(Z, A).game ~ LS.REAL(Z, D(A)).game\n : ={P} ==> ={res}.\nproof.\n(* The proof can be found at file 'Horizontal.ec'\n (theorem 'SecurityMT')  *)\nadmitted.\n\nend MultiLanguage."
    },
    {
        "file": "EC-1/SimpLogic.ec",
        "incomplete": "(* SimpLogic.ec *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nlemma fa_imp_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) => ! exists (x : 'a), ! P x.\nproof.\nmove => fa_x_P_x.\ncase (exists x, ! P x) => [[] x not_P_x | //].\nhave // : P x by apply fa_x_P_x.\nqed.\n\nlemma not_ex_not_imp_fa (P : 'a -> bool) :\n  ! (exists (x : 'a), ! P x) => forall (x : 'a), P x.\nproof.\nmove => not_ex_x_not_P_x x.\ncase (P x) => [// | not_P_x].\nhave // : exists x, ! P x by exists x.\nqed.\n\nlemma fa_iff_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) <=> ! exists (x : 'a), ! P x.\nproof.\nsplit; [apply fa_imp_not_ex_not | apply not_ex_not_imp_fa].\nqed.\n\n(* we can do the above using a lemma in the EasyCrypt Library: *)\n\nlemma fa_iff_not_ex_not' (P : 'a -> bool) :\n  (forall (x : 'a), P x) <=> ! exists (x : 'a), ! P x.\nproof.\n(* to see the lemma's statement, use\nprint negb_exists.\n*)\nby rewrite negb_exists.\nqed.",
        "complete:": "(* SimpLogic.ec *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nlemma fa_imp_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) => ! exists (x : 'a), ! P x.\nproof.\nmove => fa_x_P_x.\ncase (exists x, ! P x) => [[] x not_P_x | //].\nhave // : P x by apply fa_x_P_x.\nqed.\n\nlemma not_ex_not_imp_fa (P : 'a -> bool) :\n  ! (exists (x : 'a), ! P x) => forall (x : 'a), P x.\nproof.\nmove => not_ex_x_not_P_x x.\ncase (P x) => [// | not_P_x].\nhave // : exists x, ! P x by exists x.\nqed.\n\nlemma fa_iff_not_ex_not (P : 'a -> bool) :\n  (forall (x : 'a), P x) <=> ! exists (x : 'a), ! P x.\nproof.\nsplit; [apply fa_imp_not_ex_not | apply not_ex_not_imp_fa].\nqed.\n\n(* we can do the above using a lemma in the EasyCrypt Library: *)\n\nlemma fa_iff_not_ex_not' (P : 'a -> bool) :\n  (forall (x : 'a), P x) <=> ! exists (x : 'a), ! P x.\nproof.\n(* to see the lemma's statement, use\nprint negb_exists.\n*)\nby rewrite negb_exists.\nqed."
    },
    {
        "file": "EC-1/SMC.ec",
        "incomplete": "(* Secure Message Communication via a One-time Pad, Formalized\n   in Ordinary (Non-UC) Real/Ideal Paradigm Style *)\n\nprover [\"\"].  (* no use of smt *)\n\nrequire import AllCore Distr.\n\n(* minimal axiomatization of bitstrings *)\n\nop n : int.  (* length of bitstrings *)\n\naxiom ge0_n : 0 <= n.\n\ntype bits.  (* type of bit strings of length n *)\n\nop zero : bits.  (* the all zero bitstring *)\n\nop (^^) : bits -> bits -> bits.  (* pointwise exclusive or *)\n\naxiom xorC (x y : bits) :\n  x ^^ y = y ^^ x.\n\naxiom xorA (x y z : bits) :\n  x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom xor0_ (x : bits) :\n  zero ^^ x = x.\n\nlemma xor_0 (x : bits) :\n  x ^^ zero = x.\nproof.\nby rewrite xorC xor0_.\nqed.\n\naxiom xorK (x : bits) :\n  x ^^ x = zero.\n\nlemma xor_double_same_right (x y : bits) :\n  x ^^ y ^^ y = x.\nproof.\nby rewrite xorA xorK xor_0.\nqed.\n\nlemma xor_double_same_left (x y : bits) :\n  y ^^ y ^^ x = x.\nproof.\nby rewrite xorK xor0_.\nqed.\n\n(* uniform, full and lossless distribution on bitstrings *)\n\nop dbits : bits distr.\n\n(* the following two axioms tell us that the size of\n   bits is exactly 2 ^ n *)\n\naxiom dbits_ll : is_lossless dbits.  (* is a distribution *)\n\n(* every element x of bits has the same weight, \n   1%r / (2 ^ n)%r *)\n\naxiom dbits1E (x : bits) :\n  mu1 dbits x = 1%r / (2 ^ n)%r.\n\n(* so we can prove that dbits is full, i.e., every element\n   of the type has a non-zero weight *)\n\nlemma ____(LEMMA_0)____ : is_full dbits.\nproof.\nmove => x.\nrewrite /support dbits1E.\nby rewrite RField.div1r StdOrder.RealOrder.invr_gt0\n           lt_fromint StdOrder.IntOrder.expr_gt0.\nqed.\n\n(* module type of Adversaries *)\n\nmodule type ADV = {\n  (* ask Adversary for message to securely communicate *)\n\n  proc get() : bits\n\n  (* let Adversary observe encrypted message being communicated *)\n\n  proc obs(x : bits) : unit\n\n  (* give Adversary decryption of received message, and ask it for its\n     boolean judgment (the adversary is trying to differentiate the\n     real and ideal games) *)\n\n  proc put(x : bits) : bool\n}.\n\n(* Real Game, Parameterized by Adversary *)\n\nmodule GReal (Adv : ADV) = {\n  var pad : bits  (* one-time pad *)\n\n  (* generate the one-time pad, sharing with both parties; we're\n     assuming Adversary observes nothing when this happens\n\n     of course, it's not realistic that a one-time pad can be\n     generated and shared with the adversary learning nothing *)\n\n  proc gen() : unit = {\n    pad <$ dbits;\n  }\n\n  (* the receiving and sending parties are the same, as encrypting\n     and decrypting are the same *)\n\n  proc party(x : bits) : bits = {\n    return x ^^ pad;\n  }\n\n  proc main() : bool = {\n    var b : bool;\n    var x, y, z : bits;\n\n    x <@ Adv.get();    (* get message from Adversary, give to Party 1 *)\n    gen();             (* generate and share to parties one-time pad *)\n    y <@ party(x);     (* Party 1 encrypts x, yielding y *)\n    Adv.obs(y);        (* y is observed in transit between parties\n                          by Adversary *)\n    z <@ party(y);     (* y is decrypted by Party 2, yielding z *)\n    b <@ Adv.put(z);   (* z is given to Adversary by Party 2, and\n                          Adversary chooses boolean judgment *)\n    return b;          (* return boolean judgment as game's result *)\n  }    \n}.\n\n(* module type of Simulators *)\n\nmodule type SIM = {\n  (* choose gets no help to simulate encrypted message; we specify\n     below that choose can't read/write GReal.pad *)\n\n  proc choose() : bits\n}.\n\n(* Ideal Game, parameterized by both Simulator and Adversary *)\n\nmodule GIdeal(Sim : SIM, Adv : ADV) = {\n  proc main() : bool = {\n    var b : bool;\n    var x, y : bits;\n\n    x <@ Adv.get();     (* get message from Adversary *)\n    y <@ Sim.choose();  (* simulate message encryption *)\n    Adv.obs(y);         (* encryption simulation is observed by Adversary *)\n    b <@ Adv.put(x);    (* x is given back to Adversary *)\n    return b;           (* return Adversary's boolean judgment *)\n  }    \n}.\n\n(* our goal is to prove the following security theorem, saying the\n   Adversary is completely unable to distinguish the real and ideal\n   games:\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\n*)\n\n(* enter section, so Adversary is in scope *)\n\nsection.\n\n(* say Adv and GReal don't read/write each other's globals (GIdeal\n   has no globals) *)\n\ndeclare module ____(DECLARE_0)____ <: ADV{-GReal}.\n\n(* define simulator as a local module, as security theorem won't\n   depend upon it *)\n\nlocal module Sim : SIM = {\n  proc choose() : bits = {\n    var x : bits;\n    x <$ dbits;\n    return x;\n  }\n}.\n\nlocal lemma GReal_GIdeal :\n  equiv[GReal(Adv).main ~ GIdeal(Sim, Adv).main :\n        ={glob Adv} ==> ={res}].\nproof.\nproc.\ninline*.\nseq 1 1 : (={x, glob Adv}).\ncall (_ : true).  (* because Adv doesn't use oracle, invariant is \"true\" *)\nauto.\nseq 1 1 : (={x, glob Adv} /\\ x{1} ^^ GReal.pad{1} = x0{2}).\nrnd (fun z => x{1} ^^ z).\nauto => /> &2.\nsplit => [z _ | _].\nby rewrite -xorA xor_double_same_left.\nsplit => [z _ | _ z _].\nby rewrite 2!dbits1E.\nsplit => [| _].\napply dbits_fu.\nby rewrite -xorA xor_double_same_left.\ncall (_ : true).  (* last statement of each program must be call *)\nwp.\ncall (_ : true).\nauto => /> &1 &2.\nby rewrite xor_double_same_right.\nqed.\n\nlemma Sec &m :\n  exists (Sim <: SIM{-GReal}),\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\nexists Sim.\nby byequiv GReal_GIdeal.\nqed.\n\nend section.\n\n(* security theorem *)\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\napply (Sec Adv &m).\nqed.",
        "complete:": "(* Secure Message Communication via a One-time Pad, Formalized\n   in Ordinary (Non-UC) Real/Ideal Paradigm Style *)\n\nprover [\"\"].  (* no use of smt *)\n\nrequire import AllCore Distr.\n\n(* minimal axiomatization of bitstrings *)\n\nop n : int.  (* length of bitstrings *)\n\naxiom ge0_n : 0 <= n.\n\ntype bits.  (* type of bit strings of length n *)\n\nop zero : bits.  (* the all zero bitstring *)\n\nop (^^) : bits -> bits -> bits.  (* pointwise exclusive or *)\n\naxiom xorC (x y : bits) :\n  x ^^ y = y ^^ x.\n\naxiom xorA (x y z : bits) :\n  x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom xor0_ (x : bits) :\n  zero ^^ x = x.\n\nlemma xor_0 (x : bits) :\n  x ^^ zero = x.\nproof.\nby rewrite xorC xor0_.\nqed.\n\naxiom xorK (x : bits) :\n  x ^^ x = zero.\n\nlemma xor_double_same_right (x y : bits) :\n  x ^^ y ^^ y = x.\nproof.\nby rewrite xorA xorK xor_0.\nqed.\n\nlemma xor_double_same_left (x y : bits) :\n  y ^^ y ^^ x = x.\nproof.\nby rewrite xorK xor0_.\nqed.\n\n(* uniform, full and lossless distribution on bitstrings *)\n\nop dbits : bits distr.\n\n(* the following two axioms tell us that the size of\n   bits is exactly 2 ^ n *)\n\naxiom dbits_ll : is_lossless dbits.  (* is a distribution *)\n\n(* every element x of bits has the same weight, \n   1%r / (2 ^ n)%r *)\n\naxiom dbits1E (x : bits) :\n  mu1 dbits x = 1%r / (2 ^ n)%r.\n\n(* so we can prove that dbits is full, i.e., every element\n   of the type has a non-zero weight *)\n\nlemma dbits_fu : is_full dbits.\nproof.\nmove => x.\nrewrite /support dbits1E.\nby rewrite RField.div1r StdOrder.RealOrder.invr_gt0\n           lt_fromint StdOrder.IntOrder.expr_gt0.\nqed.\n\n(* module type of Adversaries *)\n\nmodule type ADV = {\n  (* ask Adversary for message to securely communicate *)\n\n  proc get() : bits\n\n  (* let Adversary observe encrypted message being communicated *)\n\n  proc obs(x : bits) : unit\n\n  (* give Adversary decryption of received message, and ask it for its\n     boolean judgment (the adversary is trying to differentiate the\n     real and ideal games) *)\n\n  proc put(x : bits) : bool\n}.\n\n(* Real Game, Parameterized by Adversary *)\n\nmodule GReal (Adv : ADV) = {\n  var pad : bits  (* one-time pad *)\n\n  (* generate the one-time pad, sharing with both parties; we're\n     assuming Adversary observes nothing when this happens\n\n     of course, it's not realistic that a one-time pad can be\n     generated and shared with the adversary learning nothing *)\n\n  proc gen() : unit = {\n    pad <$ dbits;\n  }\n\n  (* the receiving and sending parties are the same, as encrypting\n     and decrypting are the same *)\n\n  proc party(x : bits) : bits = {\n    return x ^^ pad;\n  }\n\n  proc main() : bool = {\n    var b : bool;\n    var x, y, z : bits;\n\n    x <@ Adv.get();    (* get message from Adversary, give to Party 1 *)\n    gen();             (* generate and share to parties one-time pad *)\n    y <@ party(x);     (* Party 1 encrypts x, yielding y *)\n    Adv.obs(y);        (* y is observed in transit between parties\n                          by Adversary *)\n    z <@ party(y);     (* y is decrypted by Party 2, yielding z *)\n    b <@ Adv.put(z);   (* z is given to Adversary by Party 2, and\n                          Adversary chooses boolean judgment *)\n    return b;          (* return boolean judgment as game's result *)\n  }    \n}.\n\n(* module type of Simulators *)\n\nmodule type SIM = {\n  (* choose gets no help to simulate encrypted message; we specify\n     below that choose can't read/write GReal.pad *)\n\n  proc choose() : bits\n}.\n\n(* Ideal Game, parameterized by both Simulator and Adversary *)\n\nmodule GIdeal(Sim : SIM, Adv : ADV) = {\n  proc main() : bool = {\n    var b : bool;\n    var x, y : bits;\n\n    x <@ Adv.get();     (* get message from Adversary *)\n    y <@ Sim.choose();  (* simulate message encryption *)\n    Adv.obs(y);         (* encryption simulation is observed by Adversary *)\n    b <@ Adv.put(x);    (* x is given back to Adversary *)\n    return b;           (* return Adversary's boolean judgment *)\n  }    \n}.\n\n(* our goal is to prove the following security theorem, saying the\n   Adversary is completely unable to distinguish the real and ideal\n   games:\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\n*)\n\n(* enter section, so Adversary is in scope *)\n\nsection.\n\n(* say Adv and GReal don't read/write each other's globals (GIdeal\n   has no globals) *)\n\ndeclare module Adv <: ADV{-GReal}.\n\n(* define simulator as a local module, as security theorem won't\n   depend upon it *)\n\nlocal module Sim : SIM = {\n  proc choose() : bits = {\n    var x : bits;\n    x <$ dbits;\n    return x;\n  }\n}.\n\nlocal lemma GReal_GIdeal :\n  equiv[GReal(Adv).main ~ GIdeal(Sim, Adv).main :\n        ={glob Adv} ==> ={res}].\nproof.\nproc.\ninline*.\nseq 1 1 : (={x, glob Adv}).\ncall (_ : true).  (* because Adv doesn't use oracle, invariant is \"true\" *)\nauto.\nseq 1 1 : (={x, glob Adv} /\\ x{1} ^^ GReal.pad{1} = x0{2}).\nrnd (fun z => x{1} ^^ z).\nauto => /> &2.\nsplit => [z _ | _].\nby rewrite -xorA xor_double_same_left.\nsplit => [z _ | _ z _].\nby rewrite 2!dbits1E.\nsplit => [| _].\napply dbits_fu.\nby rewrite -xorA xor_double_same_left.\ncall (_ : true).  (* last statement of each program must be call *)\nwp.\ncall (_ : true).\nauto => /> &1 &2.\nby rewrite xor_double_same_right.\nqed.\n\nlemma Sec &m :\n  exists (Sim <: SIM{-GReal}),\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\nexists Sim.\nby byequiv GReal_GIdeal.\nqed.\n\nend section.\n\n(* security theorem *)\n\nlemma Security (Adv <: ADV{-GReal}) &m :\n  exists (Sim <: SIM{-GReal}),  (* there is a simulator that can't read/write\n                                   GReal.pad *)\n  Pr[GReal(Adv).main() @ &m : res] =\n  Pr[GIdeal(Sim, Adv).main() @ &m : res].\nproof.\napply (Sec Adv &m).\nqed."
    },
    {
        "file": "EC-1/SymEnc.ec",
        "incomplete": "(* SymEnc.ec *)\n\n(* Symmetric Encryption *)\n\n(* definitions, including games for judging correctness and IND-CPA\n   (indistinguishability under chosen plaintext attack) security *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool.\n\n(* theory parameters *)\n\ntype key.  (* encryption keys *)\n\ntype text.  (* plaintexts *)\n\ntype cipher.  (* ciphertexts *)\n\nop ciph_def : cipher.  (* default ciphertext *)\n\n(* encryption oracle limit before game's encryption\n\n   this says limit_pre has type int and the axiom ge0_limit_pre says\n   limit_pre is non-negative *)\nop limit_pre : {____(OP_0)____ | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle limit after game's encryption *)\nop limit_post : {int | 0 <= limit_post} as ge0_limit_post.\n\n(* end theory parameters *)\n\n(* module type of encryption schemes\n\n   an encryption scheme Enc should be stateless, meaning that\n\n     forall (g1 g2 : glob Enc), g1 = g2 *)\n\nmodule type ENC = {\n  (* key generation *)\n  proc key_gen() : key\n\n  (* encryption *)\n  proc enc(k : key, x : text) : cipher\n\n  (* decryption *)\n  proc dec(k : key, c : cipher) : text\n}.\n\n(* module for checking correctness of encryption, parameterized\n   by encryption scheme\n\n   correctness means main returns true with probability 1, without any\n   assumptions about value of x *)\n\nmodule Cor (Enc : ENC) = {\n  proc main(x : text) : bool = {\n    var k : key; var c : cipher; var y : text;\n    k <@ Enc.key_gen();\n    c <@ Enc.enc(k, x);\n    y <@ Enc.dec(k, c);\n    return x = y;\n  }\n}.\n\n(* module type of encryption oracles *)\n\nmodule type EO = {\n  (* initialization *)\n  proc init() : unit\n\n  (* encryption of text by adversary before game's encryption *)\n  proc enc_pre(x : text) : cipher\n\n  (* one-time encryption of text by game *)\n  proc genc(x : text) : cipher\n\n  (* encryption of text by adversary after game's encryption *)\n  proc enc_post(x : text) : cipher\n}.\n\n(* standard encryption oracle, constructed from an encryption\n   scheme *)\n\nmodule EncO (Enc : ENC) : EO = {\n  var key : key\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() : unit = {\n    key <@ Enc.key_gen();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      c <@ Enc.enc(key, x);\n    }\n    else {\n      c <- ciph_def;  (* default result *)\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var c : cipher;\n    c <@ Enc.enc(key, x);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      c <@ Enc.enc(key, x);\n    }\n    else {\n      c <- ciph_def;  (* default result *)\n    }  \n    return c;\n  }\n}.\n\n(* encryption adversary, parameterized by encryption oracle, EO\n\n   choose may only call EO.enc_pre; guess may only call EO.enc_post *)\n\nmodule type ADV (EO : EO) = {\n  (* choose a pair of plaintexts, x1/x2 *)\n  proc choose() : text * text {EO.enc_pre}\n\n  (* given ciphertext c based on a random boolean b (the encryption\n     using EO.genc of x1 if b = true, the encryption of x2 if b =\n     false), try to guess b *)\n  proc guess(c : cipher) : bool {EO.enc_post}\n}.\n\n(* IND-CPA security game, parameterized by an encryption scheme Enc\n   and adversary Adv\n\n   an encryption scheme is secure iff the probability of main\n   returning true (Adv winning the game) is close to 1/2, i.e., Adv\n   isn't doing much better than always guessing the ciphertext comes\n   from the first plaintext, or of making a random guess\n\n   formally, we want that the absolute value of the difference between\n   the probability that main returns true and 1/2 to be small; this\n   says that Adv can neither win nor lose with probability much\n   different than 1/2 (if it could reliably lose, the addition of\n   a negation would result in an adversary that could reliably win)\n\n   because Adv can use EO to encrypt the plaintexts it chooses,\n   the encryption procedure of a secure encryption scheme is\n   necessarily probabilistic\n\n   Adv may directly use Enc (which is stateless) as much as it wants\n   (and in any case could simulate it), but the security theorem must\n   say it can't read/write the global variables of EncO *)\n\nmodule INDCPA (Enc : ENC, Adv : ADV) = {\n  module EO = EncO(Enc)        (* make EO from Enc *)\n  module A = Adv(EO)           (* connect Adv to EO *)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO.init();                 (* initialize EO *)\n    (x1, x2) <@ A.choose();    (* let A choose plaintexts x1/x2 *)\n    b <$ {0,1};                (* choose boolean b *)\n    c <@ EO.genc(b ? x1 : x2); (* encrypt x1 if b = true, x2 if b = false *)\n    b' <@ A.guess(c);          (* give ciphertext to A, which returns guess *)\n    return b = b';             (* see if A guessed correctly, winning game *)\n  }\n}.",
        "complete:": "(* SymEnc.ec *)\n\n(* Symmetric Encryption *)\n\n(* definitions, including games for judging correctness and IND-CPA\n   (indistinguishability under chosen plaintext attack) security *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool.\n\n(* theory parameters *)\n\ntype key.  (* encryption keys *)\n\ntype text.  (* plaintexts *)\n\ntype cipher.  (* ciphertexts *)\n\nop ciph_def : cipher.  (* default ciphertext *)\n\n(* encryption oracle limit before game's encryption\n\n   this says limit_pre has type int and the axiom ge0_limit_pre says\n   limit_pre is non-negative *)\nop limit_pre : {int | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle limit after game's encryption *)\nop limit_post : {int | 0 <= limit_post} as ge0_limit_post.\n\n(* end theory parameters *)\n\n(* module type of encryption schemes\n\n   an encryption scheme Enc should be stateless, meaning that\n\n     forall (g1 g2 : glob Enc), g1 = g2 *)\n\nmodule type ENC = {\n  (* key generation *)\n  proc key_gen() : key\n\n  (* encryption *)\n  proc enc(k : key, x : text) : cipher\n\n  (* decryption *)\n  proc dec(k : key, c : cipher) : text\n}.\n\n(* module for checking correctness of encryption, parameterized\n   by encryption scheme\n\n   correctness means main returns true with probability 1, without any\n   assumptions about value of x *)\n\nmodule Cor (Enc : ENC) = {\n  proc main(x : text) : bool = {\n    var k : key; var c : cipher; var y : text;\n    k <@ Enc.key_gen();\n    c <@ Enc.enc(k, x);\n    y <@ Enc.dec(k, c);\n    return x = y;\n  }\n}.\n\n(* module type of encryption oracles *)\n\nmodule type EO = {\n  (* initialization *)\n  proc init() : unit\n\n  (* encryption of text by adversary before game's encryption *)\n  proc enc_pre(x : text) : cipher\n\n  (* one-time encryption of text by game *)\n  proc genc(x : text) : cipher\n\n  (* encryption of text by adversary after game's encryption *)\n  proc enc_post(x : text) : cipher\n}.\n\n(* standard encryption oracle, constructed from an encryption\n   scheme *)\n\nmodule EncO (Enc : ENC) : EO = {\n  var key : key\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() : unit = {\n    key <@ Enc.key_gen();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      c <@ Enc.enc(key, x);\n    }\n    else {\n      c <- ciph_def;  (* default result *)\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var c : cipher;\n    c <@ Enc.enc(key, x);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      c <@ Enc.enc(key, x);\n    }\n    else {\n      c <- ciph_def;  (* default result *)\n    }  \n    return c;\n  }\n}.\n\n(* encryption adversary, parameterized by encryption oracle, EO\n\n   choose may only call EO.enc_pre; guess may only call EO.enc_post *)\n\nmodule type ADV (EO : EO) = {\n  (* choose a pair of plaintexts, x1/x2 *)\n  proc choose() : text * text {EO.enc_pre}\n\n  (* given ciphertext c based on a random boolean b (the encryption\n     using EO.genc of x1 if b = true, the encryption of x2 if b =\n     false), try to guess b *)\n  proc guess(c : cipher) : bool {EO.enc_post}\n}.\n\n(* IND-CPA security game, parameterized by an encryption scheme Enc\n   and adversary Adv\n\n   an encryption scheme is secure iff the probability of main\n   returning true (Adv winning the game) is close to 1/2, i.e., Adv\n   isn't doing much better than always guessing the ciphertext comes\n   from the first plaintext, or of making a random guess\n\n   formally, we want that the absolute value of the difference between\n   the probability that main returns true and 1/2 to be small; this\n   says that Adv can neither win nor lose with probability much\n   different than 1/2 (if it could reliably lose, the addition of\n   a negation would result in an adversary that could reliably win)\n\n   because Adv can use EO to encrypt the plaintexts it chooses,\n   the encryption procedure of a secure encryption scheme is\n   necessarily probabilistic\n\n   Adv may directly use Enc (which is stateless) as much as it wants\n   (and in any case could simulate it), but the security theorem must\n   say it can't read/write the global variables of EncO *)\n\nmodule INDCPA (Enc : ENC, Adv : ADV) = {\n  module EO = EncO(Enc)        (* make EO from Enc *)\n  module A = Adv(EO)           (* connect Adv to EO *)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO.init();                 (* initialize EO *)\n    (x1, x2) <@ A.choose();    (* let A choose plaintexts x1/x2 *)\n    b <$ {0,1};                (* choose boolean b *)\n    c <@ EO.genc(b ? x1 : x2); (* encrypt x1 if b = true, x2 if b = false *)\n    b' <@ A.guess(c);          (* give ciphertext to A, which returns guess *)\n    return b = b';             (* see if A guessed correctly, winning game *)\n  }\n}."
    },
    {
        "file": "EC-1/SymEncPRF.ec",
        "incomplete": "(* SymEncPRF.ec *)\n\n(* IND-CPA (indistinguishability under chosen plaintext attack)\n   security for symmetric encryption built out of pseudorandom\n   function *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool List FMap FSet Mu_mem.\nrequire import StdBigop. import Bigreal BRA.\nrequire import StdOrder. import RealOrder.\nrequire import StdRing. import RField.\nrequire import FMapAux.\nrequire BitWord FelTactic.\n\n(* require but don't import theories for symmetric encryption and\n   pseudorandom functions - then will be cloned below *)\n\nrequire SymEnc PseudoRandFun.\n\n(* PRF and encryption keys: bitstrings of length key_len *)\n\n(* this says key_len has type int, and the axiom gt0_key_len says\n   that key_len is positive *)\nop key_len : {int ____(OP_3)____ 0 < key_len} as gt0_key_len.\n\nclone BitWord as Key with\n  op n <- key_len\nproof gt0_n by apply gt0_key_len.\n\ntype ____(TYPE_0)____ = Key.word.\n\nop key0 : key = Key.zerow.  (* all 0 key *)\n\n(* full/uniform/lossless distribution *)\n\nop dkey : key distr = Key.DWord.dunifin.\n\nlemma dkey_fu : is_full ____(LEMMA_2)____.\nproof. apply Key.DWord.dunifin_fu. qed.\n\nlemma dkey_uni : is_uniform dkey.\nproof. apply Key.DWord.dunifin_uni. qed.\n\nlemma dkey_ll : is_lossless ____(LEMMA_0)____.\nproof. apply Key.DWord.dunifin_ll. qed.\n\n(* texts: bitstrings of length text_len *)\n\nop text_len : {int | 0 < text_len} as gt0_text_len.\n\nclone BitWord as Text with\n  op n <- text_len\nproof gt0_n by apply gt0_text_len.\n\ntype text = Text.word.\n\nop text0 : text = Text.zerow.  (* all 0 text *)\n\nop (+^) : text -> text -> text = Text.(+^).  (* bitwise exclusive or *)\n\nlemma text_xorK (x : text) : x +^ x = text0.\nproof. apply Text.xorwK. qed.\n\nlemma text_xorA (x y z : text) : x +^ (y +^ z) = x +^ y +^ z.\nproof. apply Text.xorwA. qed.\n\nlemma text_xorC (x y : text) : x +^ y = y +^ x.\nproof. apply Text.xorwC. qed.\n\nlemma ____(LEMMA_3)____ (____(LEMMA_4)____ : text) : x +^ text0 = x.\nproof. apply Text.xorw0. qed.\n\nlemma text_xor_lid (x : text) : text0 +^ x = x.\nproof. by rewrite text_xorC text_xor_rid. qed.\n\n(* full/uniform/lossless distribution *)\n\nop dtext : text distr = Text.DWord.dunifin.\n\nlemma dtext_fu : is_full dtext.\nproof. apply Text.DWord.dunifin_fu. qed.\n\nlemma dtext_uni : ____(LEMMA_1)____ dtext.\nproof. apply Text.DWord.dunifin_uni. qed.\n\nlemma dtext_ll : is_lossless dtext.\nproof. apply Text.DWord.dunifin_ll. qed.\n\nlemma mu1_dtext (x : text) : mu1 dtext x = 1%r / (2 ^ text_len)%r.\nproof. by rewrite Text.DWord.dunifin1E Text.word_card. qed.\n\nlemma mu_dtext_mem (xs : text fset) :\n  mu dtext (mem xs) = (card xs)%r / (2 ^ text_len)%r.\nproof.\napply (mu_mem _ _ (1%r / (2 ^ text_len)%r)) => x mem_xs_x.\napply mu1_dtext.\nqed.\n\n(* pseudorandom function (PRF)\n\n   the definition of F could be spelled out, and is considered public\n   -- i.e., any adversary is entitled to use F and know its\n   definition *)\n\nop F : key -> text -> text.  (* PRF *)\n\n(* clone and import pseudorandom function and symmetric encryption\n   theories, substituting for parameters, and proving the needed\n   axioms *)\n\nclone import PseudoRandFun as PRF with\n  type key  <- key,\n  op dkey   <- dkey,\n  type text <- text,\n  op dtext  <- dtext,\n  op F      <- F\nproof *.\nrealize dkey_fu. apply dkey_fu. qed.\nrealize dkey_uni. apply dkey_uni. qed.\nrealize dkey_ll. apply dkey_ll. qed.\nrealize dtext_fu. apply dtext_fu. qed.\nrealize dtext_uni. apply dtext_uni. qed.\nrealize dtext_ll. apply dtext_ll. qed.\n\ntype cipher = text * text.  (* ciphertexts *)\n\n(* encryption oracle limit before game's encryption *)\nop limit_pre : {int | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle limit after game's encryption *)\nop limit_post : {____(OP_1)____ | ____(OP_0)____ <= limit_post} as ge0_limit_post.\n\nclone import SymEnc as SE with\n  type key      <- key,\n  type text     <- text,\n  type cipher   <- cipher,\n  op ciph_def   <- (text0, text0),\n  op limit_pre  <- limit_pre,\n  op limit_post <- limit_post\nproof *.\nrealize ge0_limit_pre. apply ge0_limit_pre. qed.\nrealize ge0_limit_post. apply ge0_limit_post. qed.\n\n(* definition of encryption\n\n   key_gen and enc are probabilistic, but dec is deterministic\n\n   the module has no state *)\n\nmodule Enc : ENC = {\n  proc key_gen() : key = {\n    var k : key;\n    k <$ dkey;\n    return k;\n  }\n\n  proc enc(k : key, x : text) : cipher = {\n    var u : text;\n    u <$ dtext;\n    return (u, x +^ F k u);\n  }\n\n  proc dec(k : key, c : cipher) : text = {\n    var u, v : text;\n    (u, v) <- c;\n    return v +^ F k u;\n  }\n}.\n\n(* prove encryption scheme is stateless *)\n\nlemma enc_stateless (g1 g2 : glob Enc) : g1 = g2.\nproof. trivial. qed.\n\n(* lemma proving correctness of encryption *)\n\nlemma correctness : phoare[Cor(Enc).main : true ==> res] = 1%r.\nproof.\nproc; inline*; auto; progress.\napply dkey_ll.\napply dtext_ll.\nby rewrite -text_xorA text_xorK text_xor_rid.\nqed.\n\n(* module turning an encryption adversary Adv into a random function\n   adversary\n\n   used in upper bound of IND-CPA security theorem, but to understand\n   why it's defined the way it is, need to read proof\n\n   note that it doesn't interact with any other module (except though\n   its Adv and RF parameters) *)\n\nmodule (Adv2RFA (Adv : ADV) : RFA) (RF : RF) = {\n  module EO : EO = {  (* uses RF.f *)\n    var ctr_pre : int\n    var ctr_post : int\n\n    proc init() : unit = {\n      (* RF.init will be called by GRF *)\n      ctr_pre <- 0; ctr_post <- 0;\n    }\n\n    proc enc_pre(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      if (ctr_pre < limit_pre) {\n        ctr_pre <- ctr_pre + 1;\n        u <$ dtext;\n        v <@ RF.f(u);\n        c <- (u, x +^ v);\n      }\n      else {\n        c <- (text0, text0);\n      }\n      return c;\n    }\n\n    proc genc(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      u <$ dtext;\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n      return c;\n    }\n\n    proc enc_post(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      if (ctr_post < limit_post) {\n        ctr_post <- ctr_post + 1;\n        u <$ dtext;\n        v <@ RF.f(u);\n        c <- (u, x +^ v);\n      }\n      else {\n        c <- (text0, text0);\n      }\n      return c;\n    }\n  }\n\n  module A = Adv(EO)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.\n\n(* see after section for security theorem\n\n   in the proof, we connect the INDCPA game to a game that returns\n   true with probability 1/2, via a sequence of 3 intermediate\n   games *)\n\nsection.\n\n(* declare adversary with module restrictions: Adv can't\n   interact with EncO, PRF, TRF or Adv2RFA\n\n   the scope of Adv is the rest of the section *)\n\ndeclare ____(DECLARE_1)____ Adv <: ADV{____(DECLARE_0)____, -PRF, -TRF, -Adv2RFA}.\n\n(* axiomatize losslessness (termination for all arguments) of Adv's\n   procedures, for all encryption oracles whose accessible procedures\n   are themselves lossless\n\n   this is required for us to use up to bad reasoning, as well\n   as for the proof that the probability of the final game, G4,\n   returning true is 1%r / 2%r *)\n\ndeclare axiom Adv_choose_ll :\n  forall (EO <: EO{-Adv}),\n  islossless EO.enc_pre => islossless Adv(EO).choose.\n\ndeclare axiom Adv_guess_ll :\n  forall (EO <: EO{-Adv}),\n  islossless EO.enc_post => islossless Adv(EO).guess.\n\n(* version of encryption oracle that takes implementation of\n   RF as argument - instrumented to detect two distinct\n   kind of clashes *)\n\nlocal module EO_RF (RF : RF) : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var inps_pre : text fset\n  var clash_pre : bool\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    RF.init();\n    ctr_pre <- 0; ctr_post <- 0; inps_pre <- fset0;\n    clash_pre <- false; clash_post <- false;\n    genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      (* collect all of enc_pre's u's in set *)\n      inps_pre <- inps_pre `|` fset1 u;\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    if (mem inps_pre u) {  (* did u also arise in enc_pre? *)\n      clash_pre <- true;\n    }\n    genc_inp <- u;  (* save for reference in enc_post *)\n    v <@ RF.f(u);\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {  (* did u also arise in genc *)\n        clash_post <- true;\n      }\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game parameterized by implementation of RF, and using EO_RF *)\n\nlocal module G1 (RF : RF) = {\n  module E = EO_RF(RF)\n  module A = Adv(E)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    E.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ E.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_EO_RF_PRF_enc_pre :\n  equiv[EncO(Enc).enc_pre ~ EO_RF(PRF).enc_pre :\n        ={x} /\\ ={key}(EncO, PRF) /\\ ={ctr_pre}(EncO, EO_RF) ==>\n        ={res} /\\ ={ctr_pre}(EncO, EO_RF)].\nproof.\nproc; inline*; if => //; [wp; rnd; auto | auto].\nqed.\n\nlocal lemma EO_EO_RF_PRF_genc :\n  equiv[EncO(Enc).genc ~ EO_RF(PRF).genc :\n        ={x} /\\ ={key}(EncO, PRF) ==> ={res}].\nproof.\nproc; inline*; wp; rnd; auto.\nqed.\n\nlocal lemma EO_EO_RF_PRF_enc_post :\n  equiv[EncO(Enc).enc_post ~ EO_RF(PRF).enc_post :\n        ={x} /\\ ={key}(EncO, PRF) /\\ ={ctr_post}(EncO, EO_RF) ==>\n        ={res} /\\ ={ctr_post}(EncO, EO_RF)].\nproof.\nproc; inline*; if => //; [wp; rnd; auto | auto].\nqed.\n\nlocal lemma INDCPA_G1_PRF &m :\n  Pr[INDCPA(Enc, Adv).main() @ &m : res] = Pr[G1(PRF).main() @ &m : res].\nproof.\nbyequiv => //; proc.\ncall (_ : ={key}(EncO(Enc), PRF) /\\ ={ctr_post}(EncO(Enc), EO_RF)).\nby conseq EO_EO_RF_PRF_enc_post.\ncall EO_EO_RF_PRF_genc.\nrnd.\ncall (_ : ={key}(EncO(Enc), PRF) /\\ ={ctr_pre}(EncO(Enc), EO_RF)).\nby conseq EO_EO_RF_PRF_enc_pre.\ninline*; auto.\nqed.\n\nlocal lemma G1_GRF (RF <: RF{-EO_RF, -Adv, -Adv2RFA}) &m :\n  Pr[G1(RF).main() @ &m : res] =\n  Pr[GRF(RF, Adv2RFA(Adv)).main() @ &m : res].\nproof.\nbyequiv => //; proc.\ninline GRF(RF, Adv2RFA(Adv)).A.main G1(RF).E.init\n       Adv2RFA(Adv, RF).EO.init.\nwp; sim.\nqed.\n\nlocal lemma INDCPA_G1_TRF &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] -\n    Pr[G1(TRF).main() @ &m : res]| =\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]|.\nproof.\nby rewrite (INDCPA_G1_PRF &m) (G1_GRF PRF &m) (G1_GRF TRF &m).\nqed.\n\n(* version of encryption oracle using TRF, and where genc\n   (Obliviously) updates TRF.mp with randomly chosen u even if\n   clash_pre has happened *)\n\nlocal module EO_O : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var clash_pre : bool\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0; clash_pre <- false;\n    clash_post <- false; genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    if (u \\in TRF.mp) {\n      clash_pre <- true;\n    }\n    genc_inp <- u;\n    v <$ dtext;\n    TRF.mp.[u] <- v;  (* note *)\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {\n        clash_post <- true;\n      }\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_O *)\n\nlocal module G2 = {\n  module A = Adv(EO_O)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_O.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_O.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\n(* we use up to bad reasoning to connect G1(TRF) and G2 *)\n\nlocal lemma EO_O_enc_pre_ll : islossless EO_O.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_O_enc_post_ll : islossless EO_O.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_RF_TRF_enc_post_ll : islossless EO_RF(TRF).enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_enc_pre :\n  equiv\n  [EO_RF(TRF).enc_pre ~ EO_O.enc_pre :\n   ={x, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} ==>\n   ={res, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}].\nproof.\nproc.\nif => //.\nseq 2 2 :\n  (={u, x, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}).\nauto.\nwp; sp; inline*; wp; sp.\nif => //.\nauto; progress; by rewrite fdom_set.\nauto => /> &2 mem_u_mp.\nrewrite fsetP => x.\nrewrite in_fsetU in_fset1.\nsplit => [[] // -> | -> //]; by rewrite mem_fdom.\nauto.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_genc :\n  equiv\n  [EO_RF(TRF).genc ~ EO_O.genc :\n   ={x, TRF.mp} /\\ ={clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\\n   !EO_RF.clash_pre{1} ==>\n   ={clash_pre, genc_inp}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={res, TRF.mp})].\nproof.\nproc.\nseq 1 1 :\n  (={x, u, TRF.mp} /\\ ={clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\ !EO_RF.clash_pre{1}).\nauto.\nif.\nprogress; [by rewrite -mem_fdom | by rewrite mem_fdom].\nwp; sp; inline*; wp; sp.\nrcondf{1} 1.\nauto => />; by rewrite mem_fdom.\nauto; progress; apply dtext_ll.\nwp; sp; inline*; wp; sp.\nrcondt{1} 1.\nauto => />; by rewrite mem_fdom.\nauto; progress; by rewrite get_set_eqE.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_enc_post :\n  equiv\n  [EO_RF(TRF).enc_post ~ EO_O.enc_post :\n   ={x} /\\ ={TRF.mp} /\\ ={ctr_post, genc_inp}(EO_RF, EO_O) ==>\n   ={res} /\\ ={TRF.mp} /\\ ={ctr_post}(EO_RF, EO_O)].\nproof.\nproc.\nif => //.\nwp.\ncall (_ : ={TRF.mp}).\nsim.\nauto.\nauto.\nqed.\n\nlocal lemma G1_TRF_G2_main :\n  equiv\n  [G1(TRF).main ~ G2.main :\n   ={glob Adv} ==>\n   ={clash_pre}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={res})].\nproof.\nproc.\nseq 3 3 :\n  (={TRF.mp} /\\\n   ={x1, x2, b, glob Adv} /\\\n   ={ctr_pre, ctr_post, clash_pre, clash_post, genc_inp}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\\n   !EO_RF.clash_pre{1}).\nrnd.\ncall\n  (_ :\n   ={TRF.mp} /\\\n   ={ctr_pre, clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}).\nby conseq EO_RF_TRF_EO_O_enc_pre.\ninline*; auto; progress; by rewrite fdom0.\nseq 1 1 :\n  (={b} /\\\n   ={ctr_post, clash_pre, clash_post, genc_inp,\n     glob Adv}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={c, TRF.mp})).\ncall EO_RF_TRF_EO_O_genc.\nauto.\ncall\n  (_ :\n   ={ctr_post, clash_pre, clash_post, genc_inp}(EO_RF, EO_O) /\\\n   ={glob Adv} /\\\n   (! EO_RF.clash_pre{1} => ={c, TRF.mp}) ==>\n   (! EO_RF.clash_pre{1} => ={res})).\nproc\n  (EO_O.clash_pre)  (* bad event in second game *)\n  (={TRF.mp} /\\  (* when bad event is false *)\n   ={ctr_post, genc_inp, clash_pre}(EO_RF, EO_O))\n  (EO_RF.clash_pre{1}).  (* when bad event is true *)\nby move => />.\nmove => &1 &2.\nby case (EO_O.clash_pre{2}).\napply Adv_guess_ll.\nby conseq EO_RF_TRF_EO_O_enc_post.\nprogress; conseq EO_RF_TRF_enc_post_ll.\nprogress; conseq EO_O_enc_post_ll.\nskip => /> &1 &2 _ result_L result_R not_clash_imp /not_clash_imp //.\nqed.\n\nlocal lemma EO_O_enc_pre_pres_invar :\n  phoare\n  [EO_O.enc_pre :\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre  ==>\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre] =\n  (1%r).\nproof.\nproc.\nif.\nseq 2 :\n  (* intermediate condition (IC) *)\n  (card (fdom TRF.mp) < EO_O.ctr_pre <= limit_pre)\n  1%r   (* probability of termination of 1st part with IC from\n           precondition  *)\n  1%r   (* probability of termination of 2nd part with post\n           condition from IC *)\n  0%r   (* probability of termination of 1st part with !IC from\n           precondition *)\n  1%r.  (* probability of termination of 2nd part with post\n           condition from !IC *)\n(* the above can be abbreviated:\nseq 2 : (card (fdom TRF.mp) < EO_O.ctr_pre <= limit_pre)\n*)\nauto.\nrnd; auto; progress;\n  [by rewrite ltzS |\n   by rewrite addzC lez_add1r |\n   apply dtext_ll].\ninline*; wp; sp; if; wp.\nrnd predT. (* rnd without an argument doesn't work! *)\nauto => /> &hr lt_card_dom_mp_ctr _ not_mem_u_dom_mp.\nsplit => [| _ y _ _]; first apply dtext_ll.\nby rewrite fdom_set fcardUI_indep 1:fsetI1 1:mem_fdom\n           1:not_mem_u_dom_mp // fcard1 addzC lez_add1r.\nauto; progress; by rewrite ltzW.\nhoare; simplify.\nrnd; auto => /> &hr le_card_dom_mp_ctr _ lt_ctr_limit _ _.\nsplit => [| _]; [by rewrite ltzS | by rewrite addzC lez_add1r].\ntrivial.\nauto.\nqed.\n\nlocal lemma EO_O_genc_clash_up :\n  phoare\n  [EO_O.genc :\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre /\\ !EO_O.clash_pre ==>\n   EO_O.clash_pre] <=\n  (limit_pre%r / (2 ^ text_len)%r).\nproof.\nproc.\nseq 2 :\n  (EO_O.clash_pre)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - limit_pre)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nconseq\n  (_ :\n   card (fdom TRF.mp) <= limit_pre /\\ !EO_O.clash_pre ==>\n   _ : <=\n  (limit_pre%r / (2 ^ text_len)%r)).\nmove => /> &hr le_card_dom_mp_ctr le_ctr_limit _.\nby apply (lez_trans EO_O.ctr_pre{hr}).\nwp; simplify.\nconseq (_ : _ ==> u \\in fdom TRF.mp).\nmove => /> &hr le_card_dom_mp_limit _ u0.\nby rewrite mem_fdom.\nrnd; simplify; skip; progress.\nby rewrite mu_dtext_mem ler_wpmul2r 1:invr_ge0 1:le_fromint\n         1:StdOrder.IntOrder.expr_ge0 1:ltzW // le_fromint.\nauto; progress; by rewrite dtext_ll.\nhoare; inline*; auto; progress.\ntrivial.\nqed.\n\nlocal lemma G2_main_clash_ub &m :\n  Pr[G2.main() @ &m : EO_O.clash_pre] <=\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nbyphoare => //.\nproc.\nseq 3 :\n  (card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre /\\ !EO_O.clash_pre)\n  (1%r)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (0%r)\n  (1%r);\nlast 2 first.\nhoare.\ninline*; auto.\ncall (_ : card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre).\nconseq (_ : _ ==> _ : = (1%r)) => //.\napply EO_O_enc_pre_pres_invar.\nauto => />.\nrewrite fdom0 fcards0 /= ge0_limit_pre.\ntrivial.\ninline*; auto.\ninline*; auto.\nseq 1 :\n  (EO_O.clash_pre)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r);\nlast 2 first.\nhoare.\nconseq (_ : true ==> true).\ncall (_ : true).\nconseq (_ : _ ==> true : = (1%r)) => //.\napply EO_O_enc_post_ll.\nauto.\ntrivial.\ncall (_ : true); auto.\ncall EO_O_genc_clash_up.\nauto.\nconseq (_ : true ==> true : = (1%r)).\ncall (_ : true).\napply Adv_guess_ll.\napply EO_O_enc_post_ll.\nauto.\nqed.\n\nlocal lemma G1_TRF_G2 &m :\n  `|Pr[G1(TRF).main() @ &m : res] - Pr[G2.main() @ &m : res]| <=\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G2.main() @ &m : EO_O.clash_pre]);\n  last 1 apply (G2_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_pre}(EO_RF, EO_O)) /\\ (! EO_O.clash_pre{2} => ={res})) :\n  (EO_RF.clash_pre) => //.\nby conseq G1_TRF_G2_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality\n\n    |x - z| <= |x - y| + |y - z]\n\n   to summarize: *)\n\nlocal lemma INDCPA_G2 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G1(TRF).main() @ &m : res]| +\n    `|Pr[G1(TRF).main() @ &m : res] - Pr[G2.main() @ &m : res]|))\n  1:ler_dist_add (INDCPA_G1_TRF &m) ler_add2l (G1_TRF_G2 &m).\nqed.\n\n(* version of encryption oracle in which genc doesn't update TRF.mp at\n   all (I for Independent of map); we no longer need clash_pre *)\n\nlocal module EO_I : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n    clash_post <- false; genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    genc_inp <- u;\n    v <$ dtext;\n    (* note: map no longer updated *)\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {\n        clash_post <- true;\n      }\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_I *)\n\nlocal module G3 = {\n  module A = Adv(EO_I)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_I.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_I.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\n(* we use up to bad reasoning to connect G2 and G3 *)\n\nlocal lemma EO_O_enc_post_pres_clash_post :\n  phoare[EO_O.enc_post :\n         EO_O.clash_post ==> EO_O.clash_post] = 1%r.\nproof.\nproc.\nif.\nseq 2 : (EO_O.clash_post).\nauto.\nauto; progress; by rewrite dtext_ll.\nif.\nwp; sp; inline*; sp; wp.\nif; [auto; progress; by rewrite dtext_ll | auto].\ninline*; wp; sp.\nif; [auto; progress; by rewrite dtext_ll | auto].\nhoare; auto.\ntrivial.\nauto.\nqed.\n\nlocal lemma EO_I_enc_post_pres_clash_post :\n  phoare[EO_I.enc_post :\n         EO_I.clash_post ==> EO_I.clash_post] = 1%r.\nproof.\nproc.\nif.\nseq 2 : (EO_I.clash_post).\nauto.\nauto; progress; by rewrite dtext_ll.\nif.\nwp; sp; inline*; sp; wp.\nif; [auto; progress; by rewrite dtext_ll | auto].\ninline*; wp; sp.\nif; [auto; progress; by rewrite dtext_ll | auto].\nhoare; auto.\ntrivial.\nauto.\nqed.\n\n(* the following postcondition says that TRF.mp{1} and TRF.mp{2}\n   are equal except on EO_I.genc_inp{2} (= EO_O.genc_inp{1}) *)\n\nlocal lemma EO_O_EO_I_genc :\n  equiv[EO_O.genc ~ EO_I.genc :\n        ={x, TRF.mp} ==>\n        ={res} /\\ ={genc_inp}(EO_O, EO_I) /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}].\nproof.        \nproc.\nseq 2 1 : (={u, x, TRF.mp}); first auto.\nauto; progress; rewrite eq_except_setl.\nqed.\n\nlocal lemma EO_O_EO_I_enc_post :\n  equiv[EO_O.enc_post ~ EO_I.enc_post :\n        ={x} /\\\n        ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n        !EO_O.clash_post{1} /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} ==>\n        ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} /\\\n        (!EO_O.clash_post{1} => ={res})].\nproof.\nproc.\nif => //.\nseq 2 2 :\n  (={x, u} /\\ !EO_O.clash_post{1} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   EO_O.ctr_post{1} <= limit_post /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}).\nauto; progress; by rewrite -ltzE.\nif => //.\nwp; sp.\ninline*; wp; sp.\nif{1}; auto.\nif{2}; auto.\nmove => /> &1 &2 ? _ _ eq_exc _ _ mp _ mp0 _.\nby rewrite eq_except_pred_set.\nmove => /> &1 &2 ? _ _ eq_exc _ _ mp _.\nby rewrite eq_except_pred_set_l.\nif{2}; auto.\nmove => /> &1 &2 ? _ _ eq_exc _ _.\nmove => mp _.\nby rewrite eq_except_pred_set_r.\ninline*; wp; sp.\nif => //.\nmove => /> &1 &2 _ _ eq_exc ne_u_genc_inp.\nsplit => [u_in_dom_mp1 | u_in_dom_mp2].\nby apply (eq_except_notp_in (pred1 EO_I.genc_inp{2}) u{2} TRF.mp{1} TRF.mp{2}).\nrewrite (eq_except_notp_in (pred1 EO_I.genc_inp{2}) u{2} TRF.mp{2} TRF.mp{1})\n        1:eq_except_sym //.\nauto => /> &1 &2 _ _ eq_exc ne_u_genc_inp not_mem_u_dom_mp1 z _.\nsplit; first by rewrite eq_except_set_eq.\ncongr; by rewrite 2!get_set_sameE.\nauto => /> &1 &2 _ _ eq_exc ne_u_genc_inp _.\ncongr.\nby rewrite (eq_except_not_pred_get (pred1 EO_I.genc_inp{2})\n            _ TRF.mp{1} TRF.mp{2}).\nauto.\nqed.\n\nlocal lemma G2_G3_main :\n  equiv\n  [G2.main ~ G3.main :\n   ={glob Adv} ==>\n   ={clash_post}(EO_O, EO_I) /\\ (! EO_O.clash_post{1} => ={res})].\nproof.\nproc.\nseq 4 4 :\n  (={c, b, x1, x2, glob Adv} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   !EO_O.clash_post{1} /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}).\ncall EO_O_EO_I_genc.\nrnd.\ncall (_ : (={TRF.mp} /\\ ={ctr_pre}(EO_O, EO_I))).\nsim.\ninline*; auto.\ncall\n  (_ :\n   ={c, glob Adv} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   !EO_O.clash_post{1} /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} ==>\n   ={clash_post}(EO_O, EO_I) /\\\n   (!EO_O.clash_post{1} => ={res})).\nproc\n  (EO_I.clash_post)\n  (={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2})\n  (EO_O.clash_post{1}) => //.\nmove => &1 &2.\ncase (EO_I.clash_post{2}) => [_ -> // | //].\napply Adv_guess_ll.\nconseq EO_O_EO_I_enc_post => //.\nby move => />.\nprogress; apply EO_O_enc_post_pres_clash_post.\nprogress; conseq (EO_I_enc_post_pres_clash_post) => //.\nauto => /> &1 &2.\nmove => _ _ res_L res_R clash_R not_clash_R_imp\n        /not_clash_R_imp -> //.\nqed.\n\n(* use failure event lemma tactic (fel) to upper bound probability\n   that G2.main results in failure event being set\n\n   fel is applicable because, after initialization of the counter\n   (EO_I.ctr_post), failure event (EO_I.clash_post) and invariant\n   (EO_I.ctr_post < limit_post) by line 1 of G3.main, it's only\n   EO_I.clash_post that's capable of setting the failure event *)\n\nlocal lemma G3_main_clash_ub &m :\n  Pr[G3.main() @ &m : EO_I.clash_post] <= limit_post%r / (2 ^ text_len)%r.\nproof.\nfel\n  (* number of lines of G3.main needed to initialize counter, failure\n     event and invariant *)\n  1\n  EO_I.ctr_post  (* counter *)\n  (* upper bound in terms of current counter of probability that failure\n     event is set during one run of oracle *)\n  (fun n, 1%r / (2 ^ text_len)%r)\n  limit_post  (* counter limit *)\n  EO_I.clash_post  (* failure event *)\n  (* precondition on enc_post: if it holds, then counter goes up and\n     failure might happen; if it doesn't hold, then counter doesn't go\n     down, and failure status preserved *)\n  [EO_I.enc_post : (EO_I.ctr_post < limit_post)]\n  (* invariant *)\n  (EO_I.ctr_post <= limit_post) => //.\n(* 1 *)\nby rewrite sumr_const intmulr /= count_predT size_range /=\n           IntOrder.ler_maxr /= 1:ge0_limit_post.\n(* 2 *)\ninline*; auto; progress; rewrite ge0_limit_post.\n(* 3 *)\nproc; rcondt 1; first auto.\nwp; sp.\nseq 2 :\n  (EO_I.clash_post)\n  (1%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nwp.\nrnd (pred1 EO_I.genc_inp).\nauto => /> &hr ctr_post.\nby rewrite mu1_dtext.\nauto.\nhoare; inline*; wp; sp; if; auto.\ntrivial.\n(* 4 *)\nprogress; proc.\nrcondt 1; first auto.\nseq 2 : (c < EO_I.ctr_post <= limit_post).\nauto => /> lt_lim _ x _.\nsplit => [| _].\nrewrite ltzS lezz.\nrewrite addzC lez_add1r lt_lim.\nif; inline*; wp; sp; if; auto.\n(* 5 *)\nprogress; proc.\nrcondf 1; first auto.\nauto.\nqed.\n\nlocal lemma G2_G3 &m :\n  `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  limit_post%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G3.main() @ &m : EO_I.clash_post]);\n  last 1 apply (G3_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_post}(EO_O, EO_I)) /\\ (! EO_I.clash_post{2} => ={res})) :\n  (EO_O.clash_post) => //.\nby conseq G2_G3_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality to summarize: *)\n\nlocal lemma INDCPA_G3 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| +\n    `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]|))\n  1:ler_dist_add mulrDl addrA ler_add 1:(INDCPA_G2 &m) (G2_G3 &m).\nqed.\n\n(* version of encryption oracle in which right side of ciphertext\n   produced by genc doesn't reference plaintext at all (N stands for\n   No reference to plaintext); we no longer need any\n   instrumentation *)\n\nlocal module EO_N : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    v <$ dtext;\n    c <- (u, v);  (* note: no exclusive or *)\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_N, and where argument to EO_N.genc is independent\n   from x1/x2/b *)\n\nlocal module G4 = {\n  module A = Adv(EO_N)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_N.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_N.genc(text0);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_N_enc_pre_ll : islossless EO_N.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_enc_post_ll : islossless EO_N.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_genc_ll : islossless EO_N.genc.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\n(* note no assumption about genc's argument, x *)\n\nlocal lemma EO_I_EO_N_genc :\n  equiv[EO_I.genc ~ EO_N.genc : true ==> ={res}].\nproof.\nproc.\nwp.\nrnd (fun z => x{1} +^ z).\nauto; progress.\nby rewrite text_xorA text_xorK text_xor_lid.\nqed.\n\nlocal lemma G3_G4 &m :\n  Pr[G3.main() @ &m : res] = Pr[G4.main() @ &m : res].\nproof.\nbyequiv => //.\nproc.\ncall (_ : ={TRF.mp} /\\ ={ctr_post}(EO_I, EO_N)).\nsim.\ncall EO_I_EO_N_genc.\nrnd.\ncall (_ : ={TRF.mp} /\\ ={ctr_pre}(EO_I, EO_N)).\nsim.\ninline*; auto.\nqed.\n\nlocal lemma INDCPA_G4 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G4.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite -(G3_G4 &m) (INDCPA_G3 &m).\nqed.\n\n(* probability that G4.main returns true *)\n\nlocal lemma G4_prob &m :\n  Pr[G4.main() @ &m : res] = 1%r / 2%r.\nproof.\nbyphoare => //; proc.\nswap 3 2; rnd.\ncall (_ : true);\n  [apply Adv_guess_ll | apply EO_N_enc_post_ll | idtac].\ncall EO_N_genc_ll.\ncall (_ : true);\n  [apply Adv_choose_ll | apply EO_N_enc_pre_ll | idtac].\ninline*; auto => /= x; by rewrite dbool1E.\nqed.\n\nlemma INDCPA' &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof. rewrite -(G4_prob &m) (INDCPA_G4 &m). qed.\n\nend section.\n\n(* IND-CPA security theorem\n\n   we need to assume Adv is lossless and that it doesn't interact with\n   EncO (which INDCPA uses) or PRF/TRF/Adv2RFA (which appear in the\n   upper bound)\n\n   because Enc is stateless, Adv may use it (and in any event could\n   simulate it) *)\n\nlemma INDCPA (Adv <: ADV{-EncO, -PRF, -TRF, -Adv2RFA}) &m :\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_pre => islossless Adv(EO).choose) =>\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_post => islossless Adv(EO).guess) =>\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nmove => Adv_choose_ll Adv_guess_ll.\napply (INDCPA' Adv Adv_choose_ll Adv_guess_ll &m).\nqed.",
        "complete:": "(* SymEncPRF.ec *)\n\n(* IND-CPA (indistinguishability under chosen plaintext attack)\n   security for symmetric encryption built out of pseudorandom\n   function *)\n\nprover [\"\"].  (* no SMT solvers *)\n\nrequire import AllCore Distr DBool List FMap FSet Mu_mem.\nrequire import StdBigop. import Bigreal BRA.\nrequire import StdOrder. import RealOrder.\nrequire import StdRing. import RField.\nrequire import FMapAux.\nrequire BitWord FelTactic.\n\n(* require but don't import theories for symmetric encryption and\n   pseudorandom functions - then will be cloned below *)\n\nrequire SymEnc PseudoRandFun.\n\n(* PRF and encryption keys: bitstrings of length key_len *)\n\n(* this says key_len has type int, and the axiom gt0_key_len says\n   that key_len is positive *)\nop key_len : {int | 0 < key_len} as gt0_key_len.\n\nclone BitWord as Key with\n  op n <- key_len\nproof gt0_n by apply gt0_key_len.\n\ntype key = Key.word.\n\nop key0 : key = Key.zerow.  (* all 0 key *)\n\n(* full/uniform/lossless distribution *)\n\nop dkey : key distr = Key.DWord.dunifin.\n\nlemma dkey_fu : is_full dkey.\nproof. apply Key.DWord.dunifin_fu. qed.\n\nlemma dkey_uni : is_uniform dkey.\nproof. apply Key.DWord.dunifin_uni. qed.\n\nlemma dkey_ll : is_lossless dkey.\nproof. apply Key.DWord.dunifin_ll. qed.\n\n(* texts: bitstrings of length text_len *)\n\nop text_len : {int | 0 < text_len} as gt0_text_len.\n\nclone BitWord as Text with\n  op n <- text_len\nproof gt0_n by apply gt0_text_len.\n\ntype text = Text.word.\n\nop text0 : text = Text.zerow.  (* all 0 text *)\n\nop (+^) : text -> text -> text = Text.(+^).  (* bitwise exclusive or *)\n\nlemma text_xorK (x : text) : x +^ x = text0.\nproof. apply Text.xorwK. qed.\n\nlemma text_xorA (x y z : text) : x +^ (y +^ z) = x +^ y +^ z.\nproof. apply Text.xorwA. qed.\n\nlemma text_xorC (x y : text) : x +^ y = y +^ x.\nproof. apply Text.xorwC. qed.\n\nlemma text_xor_rid (x : text) : x +^ text0 = x.\nproof. apply Text.xorw0. qed.\n\nlemma text_xor_lid (x : text) : text0 +^ x = x.\nproof. by rewrite text_xorC text_xor_rid. qed.\n\n(* full/uniform/lossless distribution *)\n\nop dtext : text distr = Text.DWord.dunifin.\n\nlemma dtext_fu : is_full dtext.\nproof. apply Text.DWord.dunifin_fu. qed.\n\nlemma dtext_uni : is_uniform dtext.\nproof. apply Text.DWord.dunifin_uni. qed.\n\nlemma dtext_ll : is_lossless dtext.\nproof. apply Text.DWord.dunifin_ll. qed.\n\nlemma mu1_dtext (x : text) : mu1 dtext x = 1%r / (2 ^ text_len)%r.\nproof. by rewrite Text.DWord.dunifin1E Text.word_card. qed.\n\nlemma mu_dtext_mem (xs : text fset) :\n  mu dtext (mem xs) = (card xs)%r / (2 ^ text_len)%r.\nproof.\napply (mu_mem _ _ (1%r / (2 ^ text_len)%r)) => x mem_xs_x.\napply mu1_dtext.\nqed.\n\n(* pseudorandom function (PRF)\n\n   the definition of F could be spelled out, and is considered public\n   -- i.e., any adversary is entitled to use F and know its\n   definition *)\n\nop F : key -> text -> text.  (* PRF *)\n\n(* clone and import pseudorandom function and symmetric encryption\n   theories, substituting for parameters, and proving the needed\n   axioms *)\n\nclone import PseudoRandFun as PRF with\n  type key  <- key,\n  op dkey   <- dkey,\n  type text <- text,\n  op dtext  <- dtext,\n  op F      <- F\nproof *.\nrealize dkey_fu. apply dkey_fu. qed.\nrealize dkey_uni. apply dkey_uni. qed.\nrealize dkey_ll. apply dkey_ll. qed.\nrealize dtext_fu. apply dtext_fu. qed.\nrealize dtext_uni. apply dtext_uni. qed.\nrealize dtext_ll. apply dtext_ll. qed.\n\ntype cipher = text * text.  (* ciphertexts *)\n\n(* encryption oracle limit before game's encryption *)\nop limit_pre : {int | 0 <= limit_pre} as ge0_limit_pre.\n\n(* encryption oracle limit after game's encryption *)\nop limit_post : {int | 0 <= limit_post} as ge0_limit_post.\n\nclone import SymEnc as SE with\n  type key      <- key,\n  type text     <- text,\n  type cipher   <- cipher,\n  op ciph_def   <- (text0, text0),\n  op limit_pre  <- limit_pre,\n  op limit_post <- limit_post\nproof *.\nrealize ge0_limit_pre. apply ge0_limit_pre. qed.\nrealize ge0_limit_post. apply ge0_limit_post. qed.\n\n(* definition of encryption\n\n   key_gen and enc are probabilistic, but dec is deterministic\n\n   the module has no state *)\n\nmodule Enc : ENC = {\n  proc key_gen() : key = {\n    var k : key;\n    k <$ dkey;\n    return k;\n  }\n\n  proc enc(k : key, x : text) : cipher = {\n    var u : text;\n    u <$ dtext;\n    return (u, x +^ F k u);\n  }\n\n  proc dec(k : key, c : cipher) : text = {\n    var u, v : text;\n    (u, v) <- c;\n    return v +^ F k u;\n  }\n}.\n\n(* prove encryption scheme is stateless *)\n\nlemma enc_stateless (g1 g2 : glob Enc) : g1 = g2.\nproof. trivial. qed.\n\n(* lemma proving correctness of encryption *)\n\nlemma correctness : phoare[Cor(Enc).main : true ==> res] = 1%r.\nproof.\nproc; inline*; auto; progress.\napply dkey_ll.\napply dtext_ll.\nby rewrite -text_xorA text_xorK text_xor_rid.\nqed.\n\n(* module turning an encryption adversary Adv into a random function\n   adversary\n\n   used in upper bound of IND-CPA security theorem, but to understand\n   why it's defined the way it is, need to read proof\n\n   note that it doesn't interact with any other module (except though\n   its Adv and RF parameters) *)\n\nmodule (Adv2RFA (Adv : ADV) : RFA) (RF : RF) = {\n  module EO : EO = {  (* uses RF.f *)\n    var ctr_pre : int\n    var ctr_post : int\n\n    proc init() : unit = {\n      (* RF.init will be called by GRF *)\n      ctr_pre <- 0; ctr_post <- 0;\n    }\n\n    proc enc_pre(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      if (ctr_pre < limit_pre) {\n        ctr_pre <- ctr_pre + 1;\n        u <$ dtext;\n        v <@ RF.f(u);\n        c <- (u, x +^ v);\n      }\n      else {\n        c <- (text0, text0);\n      }\n      return c;\n    }\n\n    proc genc(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      u <$ dtext;\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n      return c;\n    }\n\n    proc enc_post(x : text) : cipher = {\n      var u, v : text; var c : cipher;\n      if (ctr_post < limit_post) {\n        ctr_post <- ctr_post + 1;\n        u <$ dtext;\n        v <@ RF.f(u);\n        c <- (u, x +^ v);\n      }\n      else {\n        c <- (text0, text0);\n      }\n      return c;\n    }\n  }\n\n  module A = Adv(EO)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.\n\n(* see after section for security theorem\n\n   in the proof, we connect the INDCPA game to a game that returns\n   true with probability 1/2, via a sequence of 3 intermediate\n   games *)\n\nsection.\n\n(* declare adversary with module restrictions: Adv can't\n   interact with EncO, PRF, TRF or Adv2RFA\n\n   the scope of Adv is the rest of the section *)\n\ndeclare module Adv <: ADV{-EncO, -PRF, -TRF, -Adv2RFA}.\n\n(* axiomatize losslessness (termination for all arguments) of Adv's\n   procedures, for all encryption oracles whose accessible procedures\n   are themselves lossless\n\n   this is required for us to use up to bad reasoning, as well\n   as for the proof that the probability of the final game, G4,\n   returning true is 1%r / 2%r *)\n\ndeclare axiom Adv_choose_ll :\n  forall (EO <: EO{-Adv}),\n  islossless EO.enc_pre => islossless Adv(EO).choose.\n\ndeclare axiom Adv_guess_ll :\n  forall (EO <: EO{-Adv}),\n  islossless EO.enc_post => islossless Adv(EO).guess.\n\n(* version of encryption oracle that takes implementation of\n   RF as argument - instrumented to detect two distinct\n   kind of clashes *)\n\nlocal module EO_RF (RF : RF) : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var inps_pre : text fset\n  var clash_pre : bool\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    RF.init();\n    ctr_pre <- 0; ctr_post <- 0; inps_pre <- fset0;\n    clash_pre <- false; clash_post <- false;\n    genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      (* collect all of enc_pre's u's in set *)\n      inps_pre <- inps_pre `|` fset1 u;\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    if (mem inps_pre u) {  (* did u also arise in enc_pre? *)\n      clash_pre <- true;\n    }\n    genc_inp <- u;  (* save for reference in enc_post *)\n    v <@ RF.f(u);\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {  (* did u also arise in genc *)\n        clash_post <- true;\n      }\n      v <@ RF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game parameterized by implementation of RF, and using EO_RF *)\n\nlocal module G1 (RF : RF) = {\n  module E = EO_RF(RF)\n  module A = Adv(E)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    E.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ E.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_EO_RF_PRF_enc_pre :\n  equiv[EncO(Enc).enc_pre ~ EO_RF(PRF).enc_pre :\n        ={x} /\\ ={key}(EncO, PRF) /\\ ={ctr_pre}(EncO, EO_RF) ==>\n        ={res} /\\ ={ctr_pre}(EncO, EO_RF)].\nproof.\nproc; inline*; if => //; [wp; rnd; auto | auto].\nqed.\n\nlocal lemma EO_EO_RF_PRF_genc :\n  equiv[EncO(Enc).genc ~ EO_RF(PRF).genc :\n        ={x} /\\ ={key}(EncO, PRF) ==> ={res}].\nproof.\nproc; inline*; wp; rnd; auto.\nqed.\n\nlocal lemma EO_EO_RF_PRF_enc_post :\n  equiv[EncO(Enc).enc_post ~ EO_RF(PRF).enc_post :\n        ={x} /\\ ={key}(EncO, PRF) /\\ ={ctr_post}(EncO, EO_RF) ==>\n        ={res} /\\ ={ctr_post}(EncO, EO_RF)].\nproof.\nproc; inline*; if => //; [wp; rnd; auto | auto].\nqed.\n\nlocal lemma INDCPA_G1_PRF &m :\n  Pr[INDCPA(Enc, Adv).main() @ &m : res] = Pr[G1(PRF).main() @ &m : res].\nproof.\nbyequiv => //; proc.\ncall (_ : ={key}(EncO(Enc), PRF) /\\ ={ctr_post}(EncO(Enc), EO_RF)).\nby conseq EO_EO_RF_PRF_enc_post.\ncall EO_EO_RF_PRF_genc.\nrnd.\ncall (_ : ={key}(EncO(Enc), PRF) /\\ ={ctr_pre}(EncO(Enc), EO_RF)).\nby conseq EO_EO_RF_PRF_enc_pre.\ninline*; auto.\nqed.\n\nlocal lemma G1_GRF (RF <: RF{-EO_RF, -Adv, -Adv2RFA}) &m :\n  Pr[G1(RF).main() @ &m : res] =\n  Pr[GRF(RF, Adv2RFA(Adv)).main() @ &m : res].\nproof.\nbyequiv => //; proc.\ninline GRF(RF, Adv2RFA(Adv)).A.main G1(RF).E.init\n       Adv2RFA(Adv, RF).EO.init.\nwp; sim.\nqed.\n\nlocal lemma INDCPA_G1_TRF &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] -\n    Pr[G1(TRF).main() @ &m : res]| =\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]|.\nproof.\nby rewrite (INDCPA_G1_PRF &m) (G1_GRF PRF &m) (G1_GRF TRF &m).\nqed.\n\n(* version of encryption oracle using TRF, and where genc\n   (Obliviously) updates TRF.mp with randomly chosen u even if\n   clash_pre has happened *)\n\nlocal module EO_O : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var clash_pre : bool\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0; clash_pre <- false;\n    clash_post <- false; genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    if (u \\in TRF.mp) {\n      clash_pre <- true;\n    }\n    genc_inp <- u;\n    v <$ dtext;\n    TRF.mp.[u] <- v;  (* note *)\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {\n        clash_post <- true;\n      }\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_O *)\n\nlocal module G2 = {\n  module A = Adv(EO_O)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_O.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_O.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\n(* we use up to bad reasoning to connect G1(TRF) and G2 *)\n\nlocal lemma EO_O_enc_pre_ll : islossless EO_O.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_O_enc_post_ll : islossless EO_O.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_RF_TRF_enc_post_ll : islossless EO_RF(TRF).enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_enc_pre :\n  equiv\n  [EO_RF(TRF).enc_pre ~ EO_O.enc_pre :\n   ={x, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} ==>\n   ={res, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}].\nproof.\nproc.\nif => //.\nseq 2 2 :\n  (={u, x, TRF.mp} /\\ ={ctr_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}).\nauto.\nwp; sp; inline*; wp; sp.\nif => //.\nauto; progress; by rewrite fdom_set.\nauto => /> &2 mem_u_mp.\nrewrite fsetP => x.\nrewrite in_fsetU in_fset1.\nsplit => [[] // -> | -> //]; by rewrite mem_fdom.\nauto.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_genc :\n  equiv\n  [EO_RF(TRF).genc ~ EO_O.genc :\n   ={x, TRF.mp} /\\ ={clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\\n   !EO_RF.clash_pre{1} ==>\n   ={clash_pre, genc_inp}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={res, TRF.mp})].\nproof.\nproc.\nseq 1 1 :\n  (={x, u, TRF.mp} /\\ ={clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\ !EO_RF.clash_pre{1}).\nauto.\nif.\nprogress; [by rewrite -mem_fdom | by rewrite mem_fdom].\nwp; sp; inline*; wp; sp.\nrcondf{1} 1.\nauto => />; by rewrite mem_fdom.\nauto; progress; apply dtext_ll.\nwp; sp; inline*; wp; sp.\nrcondt{1} 1.\nauto => />; by rewrite mem_fdom.\nauto; progress; by rewrite get_set_eqE.\nqed.\n\nlocal lemma EO_RF_TRF_EO_O_enc_post :\n  equiv\n  [EO_RF(TRF).enc_post ~ EO_O.enc_post :\n   ={x} /\\ ={TRF.mp} /\\ ={ctr_post, genc_inp}(EO_RF, EO_O) ==>\n   ={res} /\\ ={TRF.mp} /\\ ={ctr_post}(EO_RF, EO_O)].\nproof.\nproc.\nif => //.\nwp.\ncall (_ : ={TRF.mp}).\nsim.\nauto.\nauto.\nqed.\n\nlocal lemma G1_TRF_G2_main :\n  equiv\n  [G1(TRF).main ~ G2.main :\n   ={glob Adv} ==>\n   ={clash_pre}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={res})].\nproof.\nproc.\nseq 3 3 :\n  (={TRF.mp} /\\\n   ={x1, x2, b, glob Adv} /\\\n   ={ctr_pre, ctr_post, clash_pre, clash_post, genc_inp}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1} /\\\n   !EO_RF.clash_pre{1}).\nrnd.\ncall\n  (_ :\n   ={TRF.mp} /\\\n   ={ctr_pre, clash_pre}(EO_RF, EO_O) /\\\n   EO_RF.inps_pre{1} = fdom TRF.mp{1}).\nby conseq EO_RF_TRF_EO_O_enc_pre.\ninline*; auto; progress; by rewrite fdom0.\nseq 1 1 :\n  (={b} /\\\n   ={ctr_post, clash_pre, clash_post, genc_inp,\n     glob Adv}(EO_RF, EO_O) /\\\n   (! EO_RF.clash_pre{1} => ={c, TRF.mp})).\ncall EO_RF_TRF_EO_O_genc.\nauto.\ncall\n  (_ :\n   ={ctr_post, clash_pre, clash_post, genc_inp}(EO_RF, EO_O) /\\\n   ={glob Adv} /\\\n   (! EO_RF.clash_pre{1} => ={c, TRF.mp}) ==>\n   (! EO_RF.clash_pre{1} => ={res})).\nproc\n  (EO_O.clash_pre)  (* bad event in second game *)\n  (={TRF.mp} /\\  (* when bad event is false *)\n   ={ctr_post, genc_inp, clash_pre}(EO_RF, EO_O))\n  (EO_RF.clash_pre{1}).  (* when bad event is true *)\nby move => />.\nmove => &1 &2.\nby case (EO_O.clash_pre{2}).\napply Adv_guess_ll.\nby conseq EO_RF_TRF_EO_O_enc_post.\nprogress; conseq EO_RF_TRF_enc_post_ll.\nprogress; conseq EO_O_enc_post_ll.\nskip => /> &1 &2 _ result_L result_R not_clash_imp /not_clash_imp //.\nqed.\n\nlocal lemma EO_O_enc_pre_pres_invar :\n  phoare\n  [EO_O.enc_pre :\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre  ==>\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre] =\n  (1%r).\nproof.\nproc.\nif.\nseq 2 :\n  (* intermediate condition (IC) *)\n  (card (fdom TRF.mp) < EO_O.ctr_pre <= limit_pre)\n  1%r   (* probability of termination of 1st part with IC from\n           precondition  *)\n  1%r   (* probability of termination of 2nd part with post\n           condition from IC *)\n  0%r   (* probability of termination of 1st part with !IC from\n           precondition *)\n  1%r.  (* probability of termination of 2nd part with post\n           condition from !IC *)\n(* the above can be abbreviated:\nseq 2 : (card (fdom TRF.mp) < EO_O.ctr_pre <= limit_pre)\n*)\nauto.\nrnd; auto; progress;\n  [by rewrite ltzS |\n   by rewrite addzC lez_add1r |\n   apply dtext_ll].\ninline*; wp; sp; if; wp.\nrnd predT. (* rnd without an argument doesn't work! *)\nauto => /> &hr lt_card_dom_mp_ctr _ not_mem_u_dom_mp.\nsplit => [| _ y _ _]; first apply dtext_ll.\nby rewrite fdom_set fcardUI_indep 1:fsetI1 1:mem_fdom\n           1:not_mem_u_dom_mp // fcard1 addzC lez_add1r.\nauto; progress; by rewrite ltzW.\nhoare; simplify.\nrnd; auto => /> &hr le_card_dom_mp_ctr _ lt_ctr_limit _ _.\nsplit => [| _]; [by rewrite ltzS | by rewrite addzC lez_add1r].\ntrivial.\nauto.\nqed.\n\nlocal lemma EO_O_genc_clash_up :\n  phoare\n  [EO_O.genc :\n   card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre /\\ !EO_O.clash_pre ==>\n   EO_O.clash_pre] <=\n  (limit_pre%r / (2 ^ text_len)%r).\nproof.\nproc.\nseq 2 :\n  (EO_O.clash_pre)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - limit_pre)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nconseq\n  (_ :\n   card (fdom TRF.mp) <= limit_pre /\\ !EO_O.clash_pre ==>\n   _ : <=\n  (limit_pre%r / (2 ^ text_len)%r)).\nmove => /> &hr le_card_dom_mp_ctr le_ctr_limit _.\nby apply (lez_trans EO_O.ctr_pre{hr}).\nwp; simplify.\nconseq (_ : _ ==> u \\in fdom TRF.mp).\nmove => /> &hr le_card_dom_mp_limit _ u0.\nby rewrite mem_fdom.\nrnd; simplify; skip; progress.\nby rewrite mu_dtext_mem ler_wpmul2r 1:invr_ge0 1:le_fromint\n         1:StdOrder.IntOrder.expr_ge0 1:ltzW // le_fromint.\nauto; progress; by rewrite dtext_ll.\nhoare; inline*; auto; progress.\ntrivial.\nqed.\n\nlocal lemma G2_main_clash_ub &m :\n  Pr[G2.main() @ &m : EO_O.clash_pre] <=\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nbyphoare => //.\nproc.\nseq 3 :\n  (card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre /\\ !EO_O.clash_pre)\n  (1%r)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (0%r)\n  (1%r);\nlast 2 first.\nhoare.\ninline*; auto.\ncall (_ : card (fdom TRF.mp) <= EO_O.ctr_pre <= limit_pre).\nconseq (_ : _ ==> _ : = (1%r)) => //.\napply EO_O_enc_pre_pres_invar.\nauto => />.\nrewrite fdom0 fcards0 /= ge0_limit_pre.\ntrivial.\ninline*; auto.\ninline*; auto.\nseq 1 :\n  (EO_O.clash_pre)\n  (limit_pre%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r);\nlast 2 first.\nhoare.\nconseq (_ : true ==> true).\ncall (_ : true).\nconseq (_ : _ ==> true : = (1%r)) => //.\napply EO_O_enc_post_ll.\nauto.\ntrivial.\ncall (_ : true); auto.\ncall EO_O_genc_clash_up.\nauto.\nconseq (_ : true ==> true : = (1%r)).\ncall (_ : true).\napply Adv_guess_ll.\napply EO_O_enc_post_ll.\nauto.\nqed.\n\nlocal lemma G1_TRF_G2 &m :\n  `|Pr[G1(TRF).main() @ &m : res] - Pr[G2.main() @ &m : res]| <=\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G2.main() @ &m : EO_O.clash_pre]);\n  last 1 apply (G2_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_pre}(EO_RF, EO_O)) /\\ (! EO_O.clash_pre{2} => ={res})) :\n  (EO_RF.clash_pre) => //.\nby conseq G1_TRF_G2_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality\n\n    |x - z| <= |x - y| + |y - z]\n\n   to summarize: *)\n\nlocal lemma INDCPA_G2 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  limit_pre%r / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G1(TRF).main() @ &m : res]| +\n    `|Pr[G1(TRF).main() @ &m : res] - Pr[G2.main() @ &m : res]|))\n  1:ler_dist_add (INDCPA_G1_TRF &m) ler_add2l (G1_TRF_G2 &m).\nqed.\n\n(* version of encryption oracle in which genc doesn't update TRF.mp at\n   all (I for Independent of map); we no longer need clash_pre *)\n\nlocal module EO_I : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n  var clash_post : bool\n  var genc_inp : text\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n    clash_post <- false; genc_inp <- text0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    genc_inp <- u;\n    v <$ dtext;\n    (* note: map no longer updated *)\n    c <- (u, x +^ v);\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      if (u = genc_inp) {\n        clash_post <- true;\n      }\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_I *)\n\nlocal module G3 = {\n  module A = Adv(EO_I)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_I.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_I.genc(b ? x1 : x2);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\n(* we use up to bad reasoning to connect G2 and G3 *)\n\nlocal lemma EO_O_enc_post_pres_clash_post :\n  phoare[EO_O.enc_post :\n         EO_O.clash_post ==> EO_O.clash_post] = 1%r.\nproof.\nproc.\nif.\nseq 2 : (EO_O.clash_post).\nauto.\nauto; progress; by rewrite dtext_ll.\nif.\nwp; sp; inline*; sp; wp.\nif; [auto; progress; by rewrite dtext_ll | auto].\ninline*; wp; sp.\nif; [auto; progress; by rewrite dtext_ll | auto].\nhoare; auto.\ntrivial.\nauto.\nqed.\n\nlocal lemma EO_I_enc_post_pres_clash_post :\n  phoare[EO_I.enc_post :\n         EO_I.clash_post ==> EO_I.clash_post] = 1%r.\nproof.\nproc.\nif.\nseq 2 : (EO_I.clash_post).\nauto.\nauto; progress; by rewrite dtext_ll.\nif.\nwp; sp; inline*; sp; wp.\nif; [auto; progress; by rewrite dtext_ll | auto].\ninline*; wp; sp.\nif; [auto; progress; by rewrite dtext_ll | auto].\nhoare; auto.\ntrivial.\nauto.\nqed.\n\n(* the following postcondition says that TRF.mp{1} and TRF.mp{2}\n   are equal except on EO_I.genc_inp{2} (= EO_O.genc_inp{1}) *)\n\nlocal lemma EO_O_EO_I_genc :\n  equiv[EO_O.genc ~ EO_I.genc :\n        ={x, TRF.mp} ==>\n        ={res} /\\ ={genc_inp}(EO_O, EO_I) /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}].\nproof.        \nproc.\nseq 2 1 : (={u, x, TRF.mp}); first auto.\nauto; progress; rewrite eq_except_setl.\nqed.\n\nlocal lemma EO_O_EO_I_enc_post :\n  equiv[EO_O.enc_post ~ EO_I.enc_post :\n        ={x} /\\\n        ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n        !EO_O.clash_post{1} /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} ==>\n        ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n        eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} /\\\n        (!EO_O.clash_post{1} => ={res})].\nproof.\nproc.\nif => //.\nseq 2 2 :\n  (={x, u} /\\ !EO_O.clash_post{1} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   EO_O.ctr_post{1} <= limit_post /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}).\nauto; progress; by rewrite -ltzE.\nif => //.\nwp; sp.\ninline*; wp; sp.\nif{1}; auto.\nif{2}; auto.\nmove => /> &1 &2 ? _ _ eq_exc _ _ mp _ mp0 _.\nby rewrite eq_except_pred_set.\nmove => /> &1 &2 ? _ _ eq_exc _ _ mp _.\nby rewrite eq_except_pred_set_l.\nif{2}; auto.\nmove => /> &1 &2 ? _ _ eq_exc _ _.\nmove => mp _.\nby rewrite eq_except_pred_set_r.\ninline*; wp; sp.\nif => //.\nmove => /> &1 &2 _ _ eq_exc ne_u_genc_inp.\nsplit => [u_in_dom_mp1 | u_in_dom_mp2].\nby apply (eq_except_notp_in (pred1 EO_I.genc_inp{2}) u{2} TRF.mp{1} TRF.mp{2}).\nrewrite (eq_except_notp_in (pred1 EO_I.genc_inp{2}) u{2} TRF.mp{2} TRF.mp{1})\n        1:eq_except_sym //.\nauto => /> &1 &2 _ _ eq_exc ne_u_genc_inp not_mem_u_dom_mp1 z _.\nsplit; first by rewrite eq_except_set_eq.\ncongr; by rewrite 2!get_set_sameE.\nauto => /> &1 &2 _ _ eq_exc ne_u_genc_inp _.\ncongr.\nby rewrite (eq_except_not_pred_get (pred1 EO_I.genc_inp{2})\n            _ TRF.mp{1} TRF.mp{2}).\nauto.\nqed.\n\nlocal lemma G2_G3_main :\n  equiv\n  [G2.main ~ G3.main :\n   ={glob Adv} ==>\n   ={clash_post}(EO_O, EO_I) /\\ (! EO_O.clash_post{1} => ={res})].\nproof.\nproc.\nseq 4 4 :\n  (={c, b, x1, x2, glob Adv} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   !EO_O.clash_post{1} /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2}).\ncall EO_O_EO_I_genc.\nrnd.\ncall (_ : (={TRF.mp} /\\ ={ctr_pre}(EO_O, EO_I))).\nsim.\ninline*; auto.\ncall\n  (_ :\n   ={c, glob Adv} /\\\n   ={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   !EO_O.clash_post{1} /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2} ==>\n   ={clash_post}(EO_O, EO_I) /\\\n   (!EO_O.clash_post{1} => ={res})).\nproc\n  (EO_I.clash_post)\n  (={ctr_post, clash_post, genc_inp}(EO_O, EO_I) /\\\n   eq_except (pred1 EO_I.genc_inp{2}) TRF.mp{1} TRF.mp{2})\n  (EO_O.clash_post{1}) => //.\nmove => &1 &2.\ncase (EO_I.clash_post{2}) => [_ -> // | //].\napply Adv_guess_ll.\nconseq EO_O_EO_I_enc_post => //.\nby move => />.\nprogress; apply EO_O_enc_post_pres_clash_post.\nprogress; conseq (EO_I_enc_post_pres_clash_post) => //.\nauto => /> &1 &2.\nmove => _ _ res_L res_R clash_R not_clash_R_imp\n        /not_clash_R_imp -> //.\nqed.\n\n(* use failure event lemma tactic (fel) to upper bound probability\n   that G2.main results in failure event being set\n\n   fel is applicable because, after initialization of the counter\n   (EO_I.ctr_post), failure event (EO_I.clash_post) and invariant\n   (EO_I.ctr_post < limit_post) by line 1 of G3.main, it's only\n   EO_I.clash_post that's capable of setting the failure event *)\n\nlocal lemma G3_main_clash_ub &m :\n  Pr[G3.main() @ &m : EO_I.clash_post] <= limit_post%r / (2 ^ text_len)%r.\nproof.\nfel\n  (* number of lines of G3.main needed to initialize counter, failure\n     event and invariant *)\n  1\n  EO_I.ctr_post  (* counter *)\n  (* upper bound in terms of current counter of probability that failure\n     event is set during one run of oracle *)\n  (fun n, 1%r / (2 ^ text_len)%r)\n  limit_post  (* counter limit *)\n  EO_I.clash_post  (* failure event *)\n  (* precondition on enc_post: if it holds, then counter goes up and\n     failure might happen; if it doesn't hold, then counter doesn't go\n     down, and failure status preserved *)\n  [EO_I.enc_post : (EO_I.ctr_post < limit_post)]\n  (* invariant *)\n  (EO_I.ctr_post <= limit_post) => //.\n(* 1 *)\nby rewrite sumr_const intmulr /= count_predT size_range /=\n           IntOrder.ler_maxr /= 1:ge0_limit_post.\n(* 2 *)\ninline*; auto; progress; rewrite ge0_limit_post.\n(* 3 *)\nproc; rcondt 1; first auto.\nwp; sp.\nseq 2 :\n  (EO_I.clash_post)\n  (1%r / (2 ^ text_len)%r)\n  (1%r)\n  ((2 ^ text_len - 1)%r / (2 ^ text_len)%r)\n  (0%r).\nauto.\nwp.\nrnd (pred1 EO_I.genc_inp).\nauto => /> &hr ctr_post.\nby rewrite mu1_dtext.\nauto.\nhoare; inline*; wp; sp; if; auto.\ntrivial.\n(* 4 *)\nprogress; proc.\nrcondt 1; first auto.\nseq 2 : (c < EO_I.ctr_post <= limit_post).\nauto => /> lt_lim _ x _.\nsplit => [| _].\nrewrite ltzS lezz.\nrewrite addzC lez_add1r lt_lim.\nif; inline*; wp; sp; if; auto.\n(* 5 *)\nprogress; proc.\nrcondf 1; first auto.\nauto.\nqed.\n\nlocal lemma G2_G3 &m :\n  `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  limit_post%r / (2 ^ text_len)%r.\nproof.\nrewrite (RealOrder.ler_trans Pr[G3.main() @ &m : EO_I.clash_post]);\n  last 1 apply (G3_main_clash_ub &m).\nbyequiv\n  (_ :\n   ={glob Adv} ==>\n   (={clash_post}(EO_O, EO_I)) /\\ (! EO_I.clash_post{2} => ={res})) :\n  (EO_O.clash_post) => //.\nby conseq G2_G3_main.\nmove => &1 &2 [#] -> not_class_imp /=.\nby rewrite -eq_iff.\nqed.\n\n(* now we use triangular inequality to summarize: *)\n\nlocal lemma INDCPA_G3 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G3.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite\n  (ler_trans\n   (`|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G2.main() @ &m : res]| +\n    `|Pr[G2.main() @ &m : res] - Pr[G3.main() @ &m : res]|))\n  1:ler_dist_add mulrDl addrA ler_add 1:(INDCPA_G2 &m) (G2_G3 &m).\nqed.\n\n(* version of encryption oracle in which right side of ciphertext\n   produced by genc doesn't reference plaintext at all (N stands for\n   No reference to plaintext); we no longer need any\n   instrumentation *)\n\nlocal module EO_N : EO = {\n  var ctr_pre : int\n  var ctr_post : int\n\n  proc init() = {\n    TRF.init();\n    ctr_pre <- 0; ctr_post <- 0;\n  }\n\n  proc enc_pre(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_pre < limit_pre) {\n      ctr_pre <- ctr_pre + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n\n  proc genc(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    u <$ dtext;\n    v <$ dtext;\n    c <- (u, v);  (* note: no exclusive or *)\n    return c;\n  }\n\n  proc enc_post(x : text) : cipher = {\n    var u, v : text; var c : cipher;\n    if (ctr_post < limit_post) {\n      ctr_post <- ctr_post + 1;\n      u <$ dtext;\n      v <@ TRF.f(u);\n      c <- (u, x +^ v);\n    }\n    else {\n      c <- (text0, text0);\n    }  \n    return c;\n  }\n}.\n\n(* game using EO_N, and where argument to EO_N.genc is independent\n   from x1/x2/b *)\n\nlocal module G4 = {\n  module A = Adv(EO_N)\n\n  proc main() : bool = {\n    var b, b' : bool; var x1, x2 : text; var c : cipher;\n    EO_N.init();\n    (x1, x2) <@ A.choose();\n    b <$ {0,1};\n    c <@ EO_N.genc(text0);\n    b' <@ A.guess(c);\n    return b = b';\n  }\n}.    \n\nlocal lemma EO_N_enc_pre_ll : islossless EO_N.enc_pre.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_enc_post_ll : islossless EO_N.enc_post.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\nlocal lemma EO_N_genc_ll : islossless EO_N.genc.\nproof.\nproc; islossless; by rewrite dtext_ll.\nqed.\n\n(* note no assumption about genc's argument, x *)\n\nlocal lemma EO_I_EO_N_genc :\n  equiv[EO_I.genc ~ EO_N.genc : true ==> ={res}].\nproof.\nproc.\nwp.\nrnd (fun z => x{1} +^ z).\nauto; progress.\nby rewrite text_xorA text_xorK text_xor_lid.\nqed.\n\nlocal lemma G3_G4 &m :\n  Pr[G3.main() @ &m : res] = Pr[G4.main() @ &m : res].\nproof.\nbyequiv => //.\nproc.\ncall (_ : ={TRF.mp} /\\ ={ctr_post}(EO_I, EO_N)).\nsim.\ncall EO_I_EO_N_genc.\nrnd.\ncall (_ : ={TRF.mp} /\\ ={ctr_pre}(EO_I, EO_N)).\nsim.\ninline*; auto.\nqed.\n\nlocal lemma INDCPA_G4 &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - Pr[G4.main() @ &m : res]| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nrewrite -(G3_G4 &m) (INDCPA_G3 &m).\nqed.\n\n(* probability that G4.main returns true *)\n\nlocal lemma G4_prob &m :\n  Pr[G4.main() @ &m : res] = 1%r / 2%r.\nproof.\nbyphoare => //; proc.\nswap 3 2; rnd.\ncall (_ : true);\n  [apply Adv_guess_ll | apply EO_N_enc_post_ll | idtac].\ncall EO_N_genc_ll.\ncall (_ : true);\n  [apply Adv_choose_ll | apply EO_N_enc_pre_ll | idtac].\ninline*; auto => /= x; by rewrite dbool1E.\nqed.\n\nlemma INDCPA' &m :\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof. rewrite -(G4_prob &m) (INDCPA_G4 &m). qed.\n\nend section.\n\n(* IND-CPA security theorem\n\n   we need to assume Adv is lossless and that it doesn't interact with\n   EncO (which INDCPA uses) or PRF/TRF/Adv2RFA (which appear in the\n   upper bound)\n\n   because Enc is stateless, Adv may use it (and in any event could\n   simulate it) *)\n\nlemma INDCPA (Adv <: ADV{-EncO, -PRF, -TRF, -Adv2RFA}) &m :\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_pre => islossless Adv(EO).choose) =>\n  (forall (EO <: EO{-Adv}),\n   islossless EO.enc_post => islossless Adv(EO).guess) =>\n  `|Pr[INDCPA(Enc, Adv).main() @ &m : res] - 1%r / 2%r| <=\n  `|Pr[GRF(PRF, Adv2RFA(Adv)).main() @ &m : res] -\n    Pr[GRF(TRF, Adv2RFA(Adv)).main() @ &m : res]| +\n  (limit_pre%r + limit_post%r) / (2 ^ text_len)%r.\nproof.\nmove => Adv_choose_ll Adv_guess_ll.\napply (INDCPA' Adv Adv_choose_ll Adv_guess_ll &m).\nqed."
    },
    {
        "file": "EC-1/theory-alias.ec",
        "incomplete": "theory T.\n  theory V.\n    op foo : ____(OP_0)____.\n  end V.\n\n  theory U = V.\nend T.\n\nimport T.\n\nop bar : int = U.foo.\n\nprint T.",
        "complete:": "theory T.\n  theory V.\n    op foo : int.\n  end V.\n\n  theory U = V.\nend T.\n\nimport T.\n\nop bar : int = U.foo.\n\nprint T."
    },
    {
        "file": "EC-1/tut.ec",
        "incomplete": "require import Distr AllCore FSet SmtMap DProd List.\n\n(* A Stateful Random Generator *)\n\ntype seed.\n\nop dseed: seed distr.\naxiom dseed_ll: is_lossless dseed.\n\ntype state.\n\nop dstate: ____(OP_1)____ distr.\naxiom dstate_uf: is_uniform dstate.\naxiom dstate_fu: is_full dstate.\n\ntype output.\n\nop ____(OP_0)____: output distr.\naxiom dout_uf: is_uniform dout.\n\nop Fc : seed -> state -> state * output.\n\nmodule SRG = {\n  var s : seed\n  var st: state\n\n  proc init(): unit = {\n    s <$ dseed;\n    st <$ dstate;\n  }\n\n  proc next(): output = {\n    var r;\n    (st,r) <- Fc s st;\n    return r;\n  }\n}.\n\n(* A Pseudo-Random Generator *)\n\ntheory PRG.\n  type output.\n  op dout: output distr.\n\n  module type PRG = {\n    proc init(): unit\n    proc next(): output\n  }.\n\n  module type PRGA = {\n    proc next(): output\n  }.\n\n  module type Distinguisher(G: ____(MODULE_0)____) = { proc distinguish(): bool }.\n\n  module IND(G: PRG, D: Distinguisher) = {\n    module D = D(G)\n\n    proc main(): bool = {\n      var b;\n\n      G.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\n  module PRGi: PRG, PRGA = {\n    proc init(): unit = {}\n    proc next(): output = { var r; r <$ PRG.dout; return r; }\n  }.\n\nend PRG.\n\n(* PRF *)\n\ntheory PRF.\n  type D.\n\n  type ____(TYPE_1)____.\n\n  type ____(TYPE_0)____.\n\n  op dK: K distr.\n  axiom dK_ll: is_lossless dK.\n\n  op F: K -> D -> R.\n\n  module PRFr = {\n    var k: K\n    proc init(): unit = { k <$ dK; }\n    proc f(x : D): R = { return F k x; }\n  }.\n\n  op uR: R distr.\n  axiom uR_uf: is_uniform uR.\n\n  module PRFi = {\n    var m : (D, R) fmap\n\n    proc init(): unit = {\n      m <- empty;\n    }\n\n    proc f (x : D) : R = {\n      var r: R;\n      if (! x \\in m) {\n        r <$ uR;\n        m.[x] <- r;\n      }\n      return (oget m.[x]);\n    }\n  }.\n\n  module type PRF = {\n    proc init() : unit\n    proc f(x : D) : R\n  }.\n\n  module type PRFA = {\n    proc f(x : D) : R\n  }.\n\n  module type Distinguisher (F: PRFA) = {\n    proc distinguish (): bool\n  }.\n\n  module IND(F: PRF, D: Distinguisher) = {\n    module D = D(F)\n\n    proc main(): bool = {\n      var b;\n\n      F.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\nend PRF.\n\nclone PRF as PRFa\nwith\n  type D <- state,\n  type R <- state * output,\n  type K <- seed,\n  op dK <- dseed,\n  op F <- Fc,\n  op uR <- dstate `*` dout (* product distribution *)\nproof dK_ll by apply dseed_ll.\n\nmodule IND_PRF = ____(MODULE_1)____.IND.\nmodule PRFc = PRFa.PRFr.\nmodule PRFi = PRFa.PRFi.\n\nclone PRG as PRGa\nwith\n  type output <- output,\n  op dout <- dout.\n\nmodule IND_PRG = PRGa.IND.\nmodule PRGi = PRGa.PRGi.\n\n(* Proof sketch *)\n\nmodule D_PRF(D: PRGa.Distinguisher, F: PRFa.PRFA) = {\n  var log: state list\n\n  module PRGp = {\n    proc init(): unit = {\n      SRG.st <$ dstate;\n      log <- [];\n    }\n\n    proc next(): output = {\n      var r;\n\n      log <- SRG.st::log;\n      (SRG.st, r) <@ F.f(SRG.st);\n      return r;\n    }\n  }\n\n  proc distinguish = IND_PRG(PRGp, D).main\n}.",
        "complete:": "require import Distr AllCore FSet SmtMap DProd List.\n\n(* A Stateful Random Generator *)\n\ntype seed.\n\nop dseed: seed distr.\naxiom dseed_ll: is_lossless dseed.\n\ntype state.\n\nop dstate: state distr.\naxiom dstate_uf: is_uniform dstate.\naxiom dstate_fu: is_full dstate.\n\ntype output.\n\nop dout: output distr.\naxiom dout_uf: is_uniform dout.\n\nop Fc : seed -> state -> state * output.\n\nmodule SRG = {\n  var s : seed\n  var st: state\n\n  proc init(): unit = {\n    s <$ dseed;\n    st <$ dstate;\n  }\n\n  proc next(): output = {\n    var r;\n    (st,r) <- Fc s st;\n    return r;\n  }\n}.\n\n(* A Pseudo-Random Generator *)\n\ntheory PRG.\n  type output.\n  op dout: output distr.\n\n  module type PRG = {\n    proc init(): unit\n    proc next(): output\n  }.\n\n  module type PRGA = {\n    proc next(): output\n  }.\n\n  module type Distinguisher(G: PRGA) = { proc distinguish(): bool }.\n\n  module IND(G: PRG, D: Distinguisher) = {\n    module D = D(G)\n\n    proc main(): bool = {\n      var b;\n\n      G.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\n  module PRGi: PRG, PRGA = {\n    proc init(): unit = {}\n    proc next(): output = { var r; r <$ PRG.dout; return r; }\n  }.\n\nend PRG.\n\n(* PRF *)\n\ntheory PRF.\n  type D.\n\n  type R.\n\n  type K.\n\n  op dK: K distr.\n  axiom dK_ll: is_lossless dK.\n\n  op F: K -> D -> R.\n\n  module PRFr = {\n    var k: K\n    proc init(): unit = { k <$ dK; }\n    proc f(x : D): R = { return F k x; }\n  }.\n\n  op uR: R distr.\n  axiom uR_uf: is_uniform uR.\n\n  module PRFi = {\n    var m : (D, R) fmap\n\n    proc init(): unit = {\n      m <- empty;\n    }\n\n    proc f (x : D) : R = {\n      var r: R;\n      if (! x \\in m) {\n        r <$ uR;\n        m.[x] <- r;\n      }\n      return (oget m.[x]);\n    }\n  }.\n\n  module type PRF = {\n    proc init() : unit\n    proc f(x : D) : R\n  }.\n\n  module type PRFA = {\n    proc f(x : D) : R\n  }.\n\n  module type Distinguisher (F: PRFA) = {\n    proc distinguish (): bool\n  }.\n\n  module IND(F: PRF, D: Distinguisher) = {\n    module D = D(F)\n\n    proc main(): bool = {\n      var b;\n\n      F.init();\n      b <@ D.distinguish();\n      return b;\n    }\n  }.\n\nend PRF.\n\nclone PRF as PRFa\nwith\n  type D <- state,\n  type R <- state * output,\n  type K <- seed,\n  op dK <- dseed,\n  op F <- Fc,\n  op uR <- dstate `*` dout (* product distribution *)\nproof dK_ll by apply dseed_ll.\n\nmodule IND_PRF = PRFa.IND.\nmodule PRFc = PRFa.PRFr.\nmodule PRFi = PRFa.PRFi.\n\nclone PRG as PRGa\nwith\n  type output <- output,\n  op dout <- dout.\n\nmodule IND_PRG = PRGa.IND.\nmodule PRGi = PRGa.PRGi.\n\n(* Proof sketch *)\n\nmodule D_PRF(D: PRGa.Distinguisher, F: PRFa.PRFA) = {\n  var log: state list\n\n  module PRGp = {\n    proc init(): unit = {\n      SRG.st <$ dstate;\n      log <- [];\n    }\n\n    proc next(): output = {\n      var r;\n\n      log <- SRG.st::log;\n      (SRG.st, r) <@ F.f(SRG.st);\n      return r;\n    }\n  }\n\n  proc distinguish = IND_PRG(PRGp, D).main\n}."
    },
    {
        "file": "EC-1/WF-examp.ec",
        "incomplete": "(* example use of well-founded recursion and induction\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* define well-founded relation on lists: lt_list_size xs ys <=>\n   size xs < size ys *)\n\nop lt_list_size : ____(OP_0)____ list rel = wf_pre size ____(OP_1)____.\n\nlemma wf_lt_list_size ['a] : ____(LEMMA_0)____ lt_list_size<:'a>.\nproof.\nrewrite wf_pre wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP (xs ys : 'a list) :\n  lt_list_size xs ys <=> size xs < size ys.\nproof.\nby rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* body of well-founded recursive definition that \"chunkifies\" an 'a\n   list into an 'a list list: the first n elements, then the next n\n   elements, etc., where if at the end there are < n elements left,\n   they are discarded *)\n\nop chunkify_wf_rec_def (n : int) : ('a list, 'a list list) wf_rec_def =\n  fun (xs : 'a list,                     (* input list *)\n       f : 'a list -> 'a list list) =>   (* for recursive calls on\n                                            strictly shorter lists *)\n  if n <= size xs\n  then take n xs :: f (drop n xs)\n  else [].\n\n(* the actual recursive definition: *)\n\nop chunkify (n : int) : 'a list -> 'a list list =\n  wf_recur\n  lt_list_size              (* well-founded relation being used *)\n  []                        (* element to be returned if recursive calls\n                               don't respect well-founded relation *)\n  (chunkify_wf_rec_def n).  (* body of recursive definition *)\n\nlemma chunkify_size (n : int, xs : 'a list) :\n  1 <= n => size (chunkify n xs) = size xs %/ n.\nproof.\nmove => ge1_n; move : xs.\napply (wf_ind lt_list_size).  (* use well-founded induction on lt_list_size *)\napply wf_lt_list_size.\nrewrite /chunkify => /= xs IH.\nrewrite wf_recur 1:wf_lt_list_size.\nrewrite {1}/chunkify_wf_rec_def.  (* only need to rewrite at top-level *)\ncase (n <= size xs) => [le_n_size_xs | not_le_n_size_xs].\n(* first case *)\nrewrite lt_list_sizeP.\nhave lt_size_drop : size (drop n xs) < size xs by rewrite size_drop /#.\nrewrite lt_size_drop /= IH 1:lt_list_sizeP //.\nrewrite size_drop 1:/# ler_maxr 1:/#.\nhave {2}-> : size xs = n + (size xs - n) by smt().\nrewrite (divzDl n) 1:dvdzz divzz /#.\n(* second case *)\nsmt(size_ge0 ltr_normr).\nqed.",
        "complete:": "(* example use of well-founded recursion and induction\n   (theories/structures/WF.ec) *)\n\nrequire import AllCore List IntDiv StdOrder.\nimport IntOrder.\n\nrequire import WF.\n\n(* define well-founded relation on lists: lt_list_size xs ys <=>\n   size xs < size ys *)\n\nop lt_list_size : 'a list rel = wf_pre size lt_nat.\n\nlemma wf_lt_list_size ['a] : wf lt_list_size<:'a>.\nproof.\nrewrite wf_pre wf_lt_nat.\nqed.\n\nlemma lt_list_sizeP (xs ys : 'a list) :\n  lt_list_size xs ys <=> size xs < size ys.\nproof.\nby rewrite /lt_list_size /wf_pre /lt_nat size_ge0.\nqed.\n\n(* body of well-founded recursive definition that \"chunkifies\" an 'a\n   list into an 'a list list: the first n elements, then the next n\n   elements, etc., where if at the end there are < n elements left,\n   they are discarded *)\n\nop chunkify_wf_rec_def (n : int) : ('a list, 'a list list) wf_rec_def =\n  fun (xs : 'a list,                     (* input list *)\n       f : 'a list -> 'a list list) =>   (* for recursive calls on\n                                            strictly shorter lists *)\n  if n <= size xs\n  then take n xs :: f (drop n xs)\n  else [].\n\n(* the actual recursive definition: *)\n\nop chunkify (n : int) : 'a list -> 'a list list =\n  wf_recur\n  lt_list_size              (* well-founded relation being used *)\n  []                        (* element to be returned if recursive calls\n                               don't respect well-founded relation *)\n  (chunkify_wf_rec_def n).  (* body of recursive definition *)\n\nlemma chunkify_size (n : int, xs : 'a list) :\n  1 <= n => size (chunkify n xs) = size xs %/ n.\nproof.\nmove => ge1_n; move : xs.\napply (wf_ind lt_list_size).  (* use well-founded induction on lt_list_size *)\napply wf_lt_list_size.\nrewrite /chunkify => /= xs IH.\nrewrite wf_recur 1:wf_lt_list_size.\nrewrite {1}/chunkify_wf_rec_def.  (* only need to rewrite at top-level *)\ncase (n <= size xs) => [le_n_size_xs | not_le_n_size_xs].\n(* first case *)\nrewrite lt_list_sizeP.\nhave lt_size_drop : size (drop n xs) < size xs by rewrite size_drop /#.\nrewrite lt_size_drop /= IH 1:lt_list_sizeP //.\nrewrite size_drop 1:/# ler_maxr 1:/#.\nhave {2}-> : size xs = n + (size xs - n) by smt().\nrewrite (divzDl n) 1:dvdzz divzz /#.\n(* second case *)\nsmt(size_ge0 ltr_normr).\nqed."
    },
    {
        "file": "EC-1/WhileSampling.ec",
        "incomplete": "require import Real Distr.\n\ntype ____(TYPE_0)____.\n\nop sample: ____(OP_0)____ distr.\naxiom sample_ll: is_lossless sample.\n\nop test: t -> bool.\naxiom pr_ntest: 0%r < mu sample (predC test).\n\nmodule Sample = {\n  proc sample () : t = {\n    var r : t;\n\n    r <$ sample;\n    while (test r) {\n      r <$ sample;\n    }\n    return r;\n  }\n}.\n\nlemma ____(LEMMA_0)____: islossless Sample.sample.\nproof.\nproc; seq  1: true=> //.\n+ by auto=> />; exact/sample_ll.\nwhile true (if test r then 1 else 0) 1 (mu sample (predC test))=> //.\n+ by move=> _ r; case: (test r).\n+ move=> ih; seq  1: true=> //.\n  by auto; rewrite sample_ll.\n+ by auto; rewrite sample_ll.\nrewrite pr_ntest=> /= z; conseq (: true ==> !test r).\n+ smt().\nby rnd; auto=> />.\nqed.",
        "complete:": "require import Real Distr.\n\ntype t.\n\nop sample: t distr.\naxiom sample_ll: is_lossless sample.\n\nop test: t -> bool.\naxiom pr_ntest: 0%r < mu sample (predC test).\n\nmodule Sample = {\n  proc sample () : t = {\n    var r : t;\n\n    r <$ sample;\n    while (test r) {\n      r <$ sample;\n    }\n    return r;\n  }\n}.\n\nlemma Sample_lossless: islossless Sample.sample.\nproof.\nproc; seq  1: true=> //.\n+ by auto=> />; exact/sample_ll.\nwhile true (if test r then 1 else 0) 1 (mu sample (predC test))=> //.\n+ by move=> _ r; case: (test r).\n+ move=> ih; seq  1: true=> //.\n  by auto; rewrite sample_ll.\n+ by auto; rewrite sample_ll.\nrewrite pr_ntest=> /= z; conseq (: true ==> !test r).\n+ smt().\nby rnd; auto=> />.\nqed."
    },
    {
        "file": "EC-1/W64_SchnorrProtocol.ec",
        "incomplete": "require import AllCore.\nrequire import JModel.\n\n\nrequire import W64_SchnorrExtract.\nrequire import BigNum_spec.\n\nmodule ____(MODULE_0)____ = M(Syscall).\nmodule JVerifier = M(Syscall).\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power:W64xN.R.t,\n                 challenge:W64xN.R.t) : W64xN.R.t \n  proc commitment () : W64xN.R.t * W64xN.R.t  \n}.\n\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t \n  proc response(challenge:W64xN.R.t) : W64xN.R.t \n}.\n\n\nmodule type ZKVerifierJ = {\n   proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) :\n    W64.t  \n  proc challenge() : W64xN.R.t \n}.\n\n\nmodule CompletenessJ(P:ZKProverJ,V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t, w:W64xN.R.t) = {\n    var z, c, r,t,v;\n    (z,r) <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(w,r,c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\n\n\n\nmodule SoundnessJ(P:ZKMaliciousProverJ, V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t) = {\n    var z, c,t,v;\n    z <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\n\n\ntype sbits.                     (* rewinding parameter type *)\n\n\nmodule type ZKRewindableMaliciousProverJ = {\n  proc response (challenge:W64xN.R.t) : W64xN.R.t\n  proc commitment () : W64xN.R.t \n  (* rewinding interface *)\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\n\nmodule type ExtractorJ(P: ZKRewindableMaliciousProverJ) = {\n  proc extract(statement: W64xN.R.t): W64xN.R.t\n}.\n\n\n\n\nmodule type MaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n}.\n\nmodule type ZKDistinguisherJ  = {\n  proc guess(statement : W64xN.R.t, witness : W64xN.R.t, summary : sbits) : bool \n}.\n\n\nmodule type RewMaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\n\nmodule type SimulatorJ(V0 : RewMaliciousVerifierJ)  = {\n  proc simulate(statement : W64xN.R.t) : sbits\n}.\n\n\nmodule ZKRealJ(P : ZKProverJ, V : MaliciousVerifierJ, D : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var commit, secret,  challenge, response, summary, guess;    \n    (commit, secret) <@ P.commitment();\n    challenge <@ V.challenge(statement, commit);\n    response <@ P.response(witness, secret, challenge);\n    summary <@ V.summitup(response);\n    guess <@ D.guess(statement, witness, summary);\n    return guess;\n  }\n}.\n\n\nmodule ZKIdealJ(S : SimulatorJ, V0 : RewMaliciousVerifierJ,\n               D0 : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var summary : sbits;\n    var guess : bool;\n    summary <@ S(V0).simulate(statement);\n    guess <@ D0.guess(statement, witness, summary);\n    return guess;\n  }\n}.",
        "complete:": "require import AllCore.\nrequire import JModel.\n\n\nrequire import W64_SchnorrExtract.\nrequire import BigNum_spec.\n\nmodule JProver = M(Syscall).\nmodule JVerifier = M(Syscall).\n\nmodule type ZKProverJ = {\n  proc response (witness0: W64xN.R.t, secret_power:W64xN.R.t,\n                 challenge:W64xN.R.t) : W64xN.R.t \n  proc commitment () : W64xN.R.t * W64xN.R.t  \n}.\n\n\nmodule type ZKMaliciousProverJ = {\n  proc commitment() : W64xN.R.t \n  proc response(challenge:W64xN.R.t) : W64xN.R.t \n}.\n\n\nmodule type ZKVerifierJ = {\n   proc verify(statement : W64xN.R.t, commitment : W64xN.R.t, challenge_0 : W64xN.R.t, response : W64xN.R.t) :\n    W64.t  \n  proc challenge() : W64xN.R.t \n}.\n\n\nmodule CompletenessJ(P:ZKProverJ,V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t, w:W64xN.R.t) = {\n    var z, c, r,t,v;\n    (z,r) <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(w,r,c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\n\n\n\nmodule SoundnessJ(P:ZKMaliciousProverJ, V:ZKVerifierJ) = {\n  proc main(s:W64xN.R.t) = {\n    var z, c,t,v;\n    z <@ P.commitment();\n    c <@ V.challenge();\n    t <@ P.response(c);\n    v <@ V.verify(s,z,c,t);\n    return (v <> W64.zero);\n  }\n}.\n\n\n\ntype sbits.                     (* rewinding parameter type *)\n\n\nmodule type ZKRewindableMaliciousProverJ = {\n  proc response (challenge:W64xN.R.t) : W64xN.R.t\n  proc commitment () : W64xN.R.t \n  (* rewinding interface *)\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\n\nmodule type ExtractorJ(P: ZKRewindableMaliciousProverJ) = {\n  proc extract(statement: W64xN.R.t): W64xN.R.t\n}.\n\n\n\n\nmodule type MaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n}.\n\nmodule type ZKDistinguisherJ  = {\n  proc guess(statement : W64xN.R.t, witness : W64xN.R.t, summary : sbits) : bool \n}.\n\n\nmodule type RewMaliciousVerifierJ = {\n  proc challenge(s : W64xN.R.t, z : W64xN.R.t) : W64xN.R.t\n  proc summitup(r : W64xN.R.t) : sbits\n  proc getState() : sbits \n  proc setState(b : sbits) : unit \n}.\n\n\nmodule type SimulatorJ(V0 : RewMaliciousVerifierJ)  = {\n  proc simulate(statement : W64xN.R.t) : sbits\n}.\n\n\nmodule ZKRealJ(P : ZKProverJ, V : MaliciousVerifierJ, D : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var commit, secret,  challenge, response, summary, guess;    \n    (commit, secret) <@ P.commitment();\n    challenge <@ V.challenge(statement, commit);\n    response <@ P.response(witness, secret, challenge);\n    summary <@ V.summitup(response);\n    guess <@ D.guess(statement, witness, summary);\n    return guess;\n  }\n}.\n\n\nmodule ZKIdealJ(S : SimulatorJ, V0 : RewMaliciousVerifierJ,\n               D0 : ZKDistinguisherJ) = {\n  proc run(statement : W64xN.R.t, witness : W64xN.R.t) : bool = {\n    var summary : sbits;\n    var guess : bool;\n    summary <@ S(V0).simulate(statement);\n    guess <@ D0.guess(statement, witness, summary);\n    return guess;\n  }\n}."
    },
    {
        "file": "EC-1/async-while.ec",
        "incomplete": "require import AllCore IntDiv Ring StdRing StdOrder.\n(*---*) import IntID IntOrder RealOrder.\n\ntype ____(TYPE_0)____.\n\nop n : { int | 0 <= n} as ____(OP_0)____.\nop k : { int | 0 <  k} as gt0_k.\n\nlemma ge0_k : ____(LEMMA_0)____ <= k.\nproof. by rewrite ltrW ?gt0_k. qed.\n\nmodule type I = {\n  proc step(i : int, x : value) : value\n}.\n\nmodule M(A : I) = {\n  proc f(x : value) = {\n    var i <- 0;\n\n    while (i < n * k) {\n      x <@ A.step(i, x);\n      i <- i + 1;\n    }\n\n    return x;\n  }\n\n  proc g(x : value) = {\n    var i <- 0;\n    var j;\n\n    while (i < n) {\n      j <- 0;\n      while (j < k) {\n        x <@ A.step(k * i + j, x);\n        j <- j + 1;\n      }\n      i <- i + 1;\n    }\n\n    return x;\n  }\n}.\n\nlemma M_equiv (A <: I) : islossless A.step =>\n  equiv[M(A).f ~ M(A).g : ={glob A, x} ==> ={res}].\nproof. move=> llA; proc.\nseq 1 1 : (i{1} = 0 /\\ ={glob A, x, i}) => //.\n+ by auto => &1 &2 />.\nasync while\n  [ (fun r => i%r < k%r * r), (i{2} + 1)%r ]\n  [ (fun r => i%r < r), (i{2} + 1)%r ]\n    (i{1} < n * k /\\ i{2} < n) (!(i{2} < n))\n  :\n    (={glob A, x} /\\ i{1} = k * i{2} /\\ (0 <= i{1})) => //=.\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ move=> v1 v2.\n  rcondt {2} 1; 1: by auto => /> /#.\n  rcondf{2} 4; 1: by auto; conseq (_: true);auto.\n  wp;while (   ={glob A, x} \n         /\\ i{1} = k * i{2} + j{2}\n         /\\ v1 = (i{2} + 1)%r\n         /\\ 0 <= i{2} <  n\n         /\\ 0 <= j{2} <= k) => /=; last by auto; smt(gt0_k ge0_n).\n  wp; call (_ : true); skip => &1 &2 /= />.\n  rewrite -fromintM !lt_fromint => *. \n  by have := StdOrder.IntOrder.ler_wpmul2l k{2} _ i{2} (n - 1); smt().\n+ by while true (n * k - i) => //; auto;1: call llA; auto => /#.\n+ while true (n - i);2: by auto=>/#.\n  move=> z;wp; while (true) (k - j);auto;1:call llA;auto => /#.\nqed.",
        "complete:": "require import AllCore IntDiv Ring StdRing StdOrder.\n(*---*) import IntID IntOrder RealOrder.\n\ntype value.\n\nop n : { int | 0 <= n} as ge0_n.\nop k : { int | 0 <  k} as gt0_k.\n\nlemma ge0_k : 0 <= k.\nproof. by rewrite ltrW ?gt0_k. qed.\n\nmodule type I = {\n  proc step(i : int, x : value) : value\n}.\n\nmodule M(A : I) = {\n  proc f(x : value) = {\n    var i <- 0;\n\n    while (i < n * k) {\n      x <@ A.step(i, x);\n      i <- i + 1;\n    }\n\n    return x;\n  }\n\n  proc g(x : value) = {\n    var i <- 0;\n    var j;\n\n    while (i < n) {\n      j <- 0;\n      while (j < k) {\n        x <@ A.step(k * i + j, x);\n        j <- j + 1;\n      }\n      i <- i + 1;\n    }\n\n    return x;\n  }\n}.\n\nlemma M_equiv (A <: I) : islossless A.step =>\n  equiv[M(A).f ~ M(A).g : ={glob A, x} ==> ={res}].\nproof. move=> llA; proc.\nseq 1 1 : (i{1} = 0 /\\ ={glob A, x, i}) => //.\n+ by auto => &1 &2 />.\nasync while\n  [ (fun r => i%r < k%r * r), (i{2} + 1)%r ]\n  [ (fun r => i%r < r), (i{2} + 1)%r ]\n    (i{1} < n * k /\\ i{2} < n) (!(i{2} < n))\n  :\n    (={glob A, x} /\\ i{1} = k * i{2} /\\ (0 <= i{1})) => //=.\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &1 &2 />; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ by move=> &2; exfalso=> &1; smt(gt0_k).\n+ move=> v1 v2.\n  rcondt {2} 1; 1: by auto => /> /#.\n  rcondf{2} 4; 1: by auto; conseq (_: true);auto.\n  wp;while (   ={glob A, x} \n         /\\ i{1} = k * i{2} + j{2}\n         /\\ v1 = (i{2} + 1)%r\n         /\\ 0 <= i{2} <  n\n         /\\ 0 <= j{2} <= k) => /=; last by auto; smt(gt0_k ge0_n).\n  wp; call (_ : true); skip => &1 &2 /= />.\n  rewrite -fromintM !lt_fromint => *. \n  by have := StdOrder.IntOrder.ler_wpmul2l k{2} _ i{2} (n - 1); smt().\n+ by while true (n * k - i) => //; auto;1: call llA; auto => /#.\n+ while true (n - i);2: by auto=>/#.\n  move=> z;wp; while (true) (k - j);auto;1:call llA;auto => /#.\nqed."
    },
    {
        "file": "EC-1/ambient-logic.ec",
        "incomplete": "(* \nAs we saw earlier in the abstract-ind-ror.ec file,\nwe use Emacs, and ProofGeneral to work with EasyCrypt.\nWe will need various commands/keybindings to work with Emacs.\nAll the keybindings begin either with the CONTROL key, denoted by \"C\",\nor the META or ALT key denoted by \"M\".\nSo if you see \"C-c C-n\" it simply means: CONTROL + c and then CONTROL + n.\nGo ahead, try it. This will evaluate the current comment, highlight it\nto indicate that it has been evaluated and will place a small black dot on the\nleft margin at the beginning of the next block to be evaluated.\n*)\n\n(*\nMost formal proofs are written interactively.\nThe proof-assistant, EC in our case, will keep track of the goals\n(context, and conclusions) for us.\nThe front-end, Proof-General + Emacs in our case, will show us the \ngoals and messages from the assistant, in the \"goals\" pane, and \"response\" pane \non the right.\nOur objective is to use different tactics to prove or \"discharge\" the goal.\nSince we only have comments so far there are no goals for EC to work with.\nWe will change that in a short while.\n*)\n \n(*\nHere is a short list of keystrokes that will come in handy for this file:\n1. C-c C-n :  Evaluate next line or block of code \n2. C-c C-u :  Go back one line or block of code\n3. C-c C-ENTER: Evaluate until the cursor position\n4. C-c C-l: To reset the Proof-General layout\n5. C-x C-s: Save file\n6. C-x C-c: Exit Emacs (read the prompt at the bottom of the screen)\n*)\n\n(*\nEC has a typed expression language, so everything we declare\nshould either explicitly have a type or it should be inferable\nfrom the operators that are used.\nTo begin with let us import the built-in Integer theory file.\n*)\n\nrequire import Int.\n\n(* The pragma line simply tells EC to print all goals *)\npragma Goals: printall.\n\n(*\nNow, let us start with something trivial to prove.\nLet us start with the reflexivity of integers.\nReflexivity is simply the property that an integer is equal to itself.\nMathematically, we would write it like so:\nFor every integer x, x=x.\n*)\n\n(*\nHere is how we declare something like that in EC.\nC-c C-n multiple times to get EC to evaluate the lemma.\nOr alternatively, move the cursor to the line with the lemma,\nand hit C-c C-ENTER.\n*)\n\nlemma int_refl: forall (x: int), x = x.\n(*\nNotice how EC populates the goals pane on the right\nwith the context and the conclusion.\nKeep stepping through the proof with C-c C-n.\n*)\nproof.\n    trivial.\nqed.\n\n(*\nWe begin a formal proof with the tactic called \"proof\",\nalthough it is optional to begin a proof with the \"proof\" keyword/tactic, \nit is considered good style to use it.\n\nThen we use a set of tactics which transform the goal into zero or more subgoals.\nIn this case, we used the tactic \"trivial\", to prove our int_refl lemma.\nOnce there are no more goals, we can end the proof with \"qed\",\nand EC saves the lemma for further use.\n*)\n\n(*\n\"trivial\" tries to solve the goal using a mixture of other tactics.\nSo it can be hard to understand when to apply it, but the good news\nis that trivial never fails. It either solves the goals or leaves the goal\nunchanged. So you can always try it without harm.\n*)\n\nprint int_refl.\n\n(*\nThe \"print\" command prints out the request in the response pane.\nWe can print types, modules, operations, lemmas etc using the print keyword.\nHere are some examples:\n*)\n\nprint op (+).\nprint op min.\nprint axiom Int.fold0.\n\n(* \nThe keywords simply act as qualifiers and filters. \nYou can print even without those. \nLike so:\n*)\nprint (+).\nprint min.\n\n(*\nNow EC knows the lemma int_refl, and allows us to use it to prove other lemmas.\nAlthough the next lemma is trivial, it illustrates the idea of this applying \nknown results.\n*)\n\nprint Int.\n\nlemma ____(LEMMA_10)____: 42 = 42.\nproof.\n   apply int_refl.\nqed.\n\n(*\n\"apply\" tries to match the conclusion of what we are applying (the proof term), \nwith the goal's conclusion. If there is a match, it replaces the goal\nwith the subgoals of the proof term.\nIn our case, EC matches int_refl to the goal's conclusion, sees that it\nmatches, and replaces the goal with what needs to be proven for int_relf which is\nnothing, and it concludes the proof.\n*)\n\n(* \nEC comes with a lot of predefined lemmas and axioms that we can use.\nLet us now look at axioms about commutativity and associativity for integers.\nThey are by the names addzC, and addzA. Print them out as an exercise.\n*)\n\n\n(* Simplifying goals *)\n\n(*\nIn the proofs, sometimes tactics yield us something that can be simplified\nWe use the tactic \"simplify\", in order to carry out the simplification.\n\nThe simplify tactic reduces the goal to a normal form using lambda calculus.\nWe don't need to worry about the specifics of how, but it is important to\nunderstand that EC can simplify the goals given it knows how to.\nIt will leave the goal unchanged if the goal is already in the normal form.\n\nFor instance, here is a contrived example that illustrates the idea.\nWe will get to more meaningful examples later, but going through these\nsimple examples will make writing complex proofs easier.\n*)\n\n(* Commutativity *)\nlemma x_plus_comm (x: int): x + 2*3 = 6 + x.\nproof.\n    simplify.\n    (* EC does the mathematical computation for us and simplifies the goal *)\n    simplify.\n    (* simplify doesn't fail, and leaves the goal unchanged *)\n    trivial.\n    (* trivial doesn't fail either, and leaves the goal unchanged *)\n    apply addzC.\nqed.\n\n(* ---- Exercise ---- *)\n(* \n\"admit\" is a tactic that closes the current goal by admitting it.\nReplace admit in the following lemma and prove it using the earlier tactics.\n*)\nlemma x_minus_equal (x: int): x - 10 = x - 9 - 1.\nproof.\nadmit.\nqed.\n\n(*\nThe goal list in EC is an ordered one, and you have to prove them\nin the same order as EC lists it. \"admit\" can be used to bypass a certain \ngoal and focus on something else in the goal list.\n*)\n\n(*\nUse the tactic \"split\" to split the disjunction into two\nand apply the previous axioms to discharge the goals.\nExperiment with admiting the first goal after splitting\n*)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\nadmit.\nqed.\n\n(*\nTo deal with disjunctions in EC, you can use the tactics \"left\" or \"right\"\nto step into a proof of the left proof term, or the right proof term respectively.\n*)\n\n(* Searching in EC *)\n\n(*\nSince, there is a lot that is already done in EC,\nwe need a way to look for things. \nWe do that using the \"search\" command. It prints out all axioms and lemmas \ninvolving the list of operators that give it.\n*)\n\nsearch [-].\n(* [] - Square braces for unary operators  *)\n\nsearch (+).\n\n(*\nAs you can see the list can be quite overwhelming and difficult to navigate.\nSo we can limit the results using a list of operators, or patterns.\n*)\n\nsearch ( * ).\n(*\n() - Parentheses for binary operators. \nNotice the extra space for the \"*\" operator.\nWe need that since (* *) also indicates comments.\n*)\n\nsearch (+) (=) (=>).\n(* List of operators \"=>\" is the implication symbol *)\n\nsearch min.\n(* By just the name of the operators. *)\n\n(*---- Exercises ----*)\n\n(* Distributivity *)\n(* Search for the appropriate axiom and apply it to discharge this goal. *)\nlemma int_distr (x y z: int): (x + y) * z = x * z + y * z.\nproof.\n    admit.\nqed.\n\n(*\nSo far, we saw lemmas without any assumptions \nexcept for that of the type of the variable in question.\nMore often than not we will have assumptions regarding variables.\nWe need to treat these assumptions as a given and introduce them into the context.\nThis is done by using \"move => ...\" followed by the name you want to give\nthe assumption.\n*)\n\nlemma x_pos (____(LEMMA_8)____: int): ____(LEMMA_9)____ < x => 0 < x+1.\nproof.\n    move => x_ge0.\n    simplify.\n    trivial.\n    (* Both of those tactics don't work. We need something else here *)\n    (* Let us see if EC has something that we can use. *)\n    search (<) (+) (0) (=>).\n    rewrite addz_gt0.\n    (*\n    \"rewrite\" simply rewrites the pattern provided, so in our case it\n    rewrites our goal here (0 < x + 1), with the pattern that we provided\n    which is addz_gt0, and then requires us to prove the assumptions of\n    the pattern which are 0 < x and 0 < 1.\n    *)\n        (* Goal 1: 0 < x *)\n\n        (*\n        When we have a goal matches an assumption, we \n        can use the tactic assumption to discharge it.\n        *)\n        assumption.\n\n        (* Goal 2: 0 < 1 *)\n        trivial.\nqed.\n\n(* Let us see some variations *)\n\nlemma int_assoc_rev (____(LEMMA_4)____ ____(LEMMA_5)____ z: ____(LEMMA_6)____): ____(LEMMA_7)____ + y + z = x + (y + z).\nproof.\n    print addzA.\n    (* \n    We might have a lemma or an axiom that we can apply to the goal,\n    but the LHS and RHS might be flipped, and EC will complain that\n    they don't match to apply them.\n    To rewrite a lemma or axiom in reverse, we simply add the \"-\" infront\n    of the lemma to switch the sides like so.\n    *)\n    rewrite -addzA.\n    trivial.\nqed.\n\n(*\nNote that here \"apply addzA.\" or \"apply -addzA\" do not work\nWe encourage you to try them.\n*)\n\n(*\nRecap:\nSo far we have seen the following tactics:\ntrivial, simplify, apply, rewrite,\nmove, split, left, right, admit, and assumption.\nWe also saw how to print and search for patterns.\nThese are at the foundation of how we work with EC.\n*)\n\n(*\nIntro to smt and external provers:\nAn important point to understand, however, is that EC\nwas built to work with cryptographic properties and more complex things.\nSo although other mathematical theorems and claims can be proven in EC,\nit will be quite painful to do so. We will employ powerful automated tools\nto take care of some of these low-level tactics and logic.\nEC offers this in the form of the \"smt\" tactic.\nWhen we run smt, EC sends the conclusion and the context to external smt solvers.\nIf they are able to solve the goal, then EC completes the proof.\nIf not smt fails and the burden of the proof is still on us.\n*)\n\nlemma x_pos_smt (x: int): 0 < x => 0 < x+1.\nproof.\nsmt.\nqed.\n\n(*\nAs you can see, smt can make our lives much easier.\nNow, here are some properties about logarithms that are mentioned in \nThe Joy of Cryptography. We leave them to be completed as exercises,\nwithout using the smt tactic. Most of them are straightforward and\nserve the purpose of exercising the use of basic tactics.\n*)\n\nrequire import AllCore.\n\n\n(* print AllCore to see what it includes *)\n\n(* Logs and exponents: *)\n\nlemma exp_product (x: real) (a b: int): x^(a*b) = x ^ a ^ b.\nproof.\n    search (^) (=).\n    by apply RField.exprM.\nqed.\n\nlemma exp_product2 (x: real) (a b: int): x <> 0%r => x^a * x^b = x^(a + b).\nproof.\n    move => x_pos.\n    search (^) (=).\n    print  RField.exprD.\n    rewrite -RField.exprD.\n    assumption.\n    trivial.\nqed.\n\n(* Logarithm exercises *)\nrequire import RealExp.\n\n(*\nPrint and search for \"ln\" to see how it is defined and\nthe results we have available already \n*)\nlemma ln_product (x y: real) : 0%r < x  => 0%r < y => ln (x*y) = ln x + ln y.\nproof.\n    search (ln) (+).\n    move => H1 H2.\n    by apply lnM.\nqed.\n\nprint log.\n(*\nNotice how log is defined. It is defined as an operator that expects two inputs\nSince most of ECs axioms are written for natural logs (ln), inorder to reason with\nlog and inorder to work with the next lemma, you will need to rewrite log.\nTo do so the syntax is\n\nrewrite /log.\n\nThe \"/\" will rewrite the pattern that follows.\n*)\n\n(*\nThis helper can come in handy in the next proof.\nSometimes it can be cumbersome to reason with a goal.\nIn cases like those, it is useful to reduce the complexity of the proof by using\nhelper lemmas like these.\n*)\n\nlemma helper (____(LEMMA_0)____ ____(LEMMA_1)____ ____(LEMMA_2)____: real): (x ____(LEMMA_3)____ y) / z = x/z + y/z.\nproof.\nsmt.\nqed.\n\nlemma log_product (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    move => H1 H2.\n    rewrite /log.\n    rewrite lnM.\n    assumption.\n    assumption.\n    by apply helper.\nqed.\n\n(* Or we can simply let smt do the heavy lifting for us *)\nlemma log_product_smt (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    smt.\nqed.\n\n(*\nModulo arithmatic exercises:\nThis is one of the properties that is mentioned in the\n *)\nrequire import IntDiv.\n\nlemma mod_add (x y z: int): (x %% z + y %% z) %% z = (x + y) %% z.\nproof.\n    by apply modzDm.\nqed.\n\n(* \nA couple of more keystrokes that might be useful.\n\n1. C-c C-r: Begin evaluating from the start\n2. C-c C-b: Evaluate until the end of the file.\n\nGo ahead and give these a try.\n*)",
        "complete:": "(* \nAs we saw earlier in the abstract-ind-ror.ec file,\nwe use Emacs, and ProofGeneral to work with EasyCrypt.\nWe will need various commands/keybindings to work with Emacs.\nAll the keybindings begin either with the CONTROL key, denoted by \"C\",\nor the META or ALT key denoted by \"M\".\nSo if you see \"C-c C-n\" it simply means: CONTROL + c and then CONTROL + n.\nGo ahead, try it. This will evaluate the current comment, highlight it\nto indicate that it has been evaluated and will place a small black dot on the\nleft margin at the beginning of the next block to be evaluated.\n*)\n\n(*\nMost formal proofs are written interactively.\nThe proof-assistant, EC in our case, will keep track of the goals\n(context, and conclusions) for us.\nThe front-end, Proof-General + Emacs in our case, will show us the \ngoals and messages from the assistant, in the \"goals\" pane, and \"response\" pane \non the right.\nOur objective is to use different tactics to prove or \"discharge\" the goal.\nSince we only have comments so far there are no goals for EC to work with.\nWe will change that in a short while.\n*)\n \n(*\nHere is a short list of keystrokes that will come in handy for this file:\n1. C-c C-n :  Evaluate next line or block of code \n2. C-c C-u :  Go back one line or block of code\n3. C-c C-ENTER: Evaluate until the cursor position\n4. C-c C-l: To reset the Proof-General layout\n5. C-x C-s: Save file\n6. C-x C-c: Exit Emacs (read the prompt at the bottom of the screen)\n*)\n\n(*\nEC has a typed expression language, so everything we declare\nshould either explicitly have a type or it should be inferable\nfrom the operators that are used.\nTo begin with let us import the built-in Integer theory file.\n*)\n\nrequire import Int.\n\n(* The pragma line simply tells EC to print all goals *)\npragma Goals: printall.\n\n(*\nNow, let us start with something trivial to prove.\nLet us start with the reflexivity of integers.\nReflexivity is simply the property that an integer is equal to itself.\nMathematically, we would write it like so:\nFor every integer x, x=x.\n*)\n\n(*\nHere is how we declare something like that in EC.\nC-c C-n multiple times to get EC to evaluate the lemma.\nOr alternatively, move the cursor to the line with the lemma,\nand hit C-c C-ENTER.\n*)\n\nlemma int_refl: forall (x: int), x = x.\n(*\nNotice how EC populates the goals pane on the right\nwith the context and the conclusion.\nKeep stepping through the proof with C-c C-n.\n*)\nproof.\n    trivial.\nqed.\n\n(*\nWe begin a formal proof with the tactic called \"proof\",\nalthough it is optional to begin a proof with the \"proof\" keyword/tactic, \nit is considered good style to use it.\n\nThen we use a set of tactics which transform the goal into zero or more subgoals.\nIn this case, we used the tactic \"trivial\", to prove our int_refl lemma.\nOnce there are no more goals, we can end the proof with \"qed\",\nand EC saves the lemma for further use.\n*)\n\n(*\n\"trivial\" tries to solve the goal using a mixture of other tactics.\nSo it can be hard to understand when to apply it, but the good news\nis that trivial never fails. It either solves the goals or leaves the goal\nunchanged. So you can always try it without harm.\n*)\n\nprint int_refl.\n\n(*\nThe \"print\" command prints out the request in the response pane.\nWe can print types, modules, operations, lemmas etc using the print keyword.\nHere are some examples:\n*)\n\nprint op (+).\nprint op min.\nprint axiom Int.fold0.\n\n(* \nThe keywords simply act as qualifiers and filters. \nYou can print even without those. \nLike so:\n*)\nprint (+).\nprint min.\n\n(*\nNow EC knows the lemma int_refl, and allows us to use it to prove other lemmas.\nAlthough the next lemma is trivial, it illustrates the idea of this applying \nknown results.\n*)\n\nprint Int.\n\nlemma forty_two_equal: 42 = 42.\nproof.\n   apply int_refl.\nqed.\n\n(*\n\"apply\" tries to match the conclusion of what we are applying (the proof term), \nwith the goal's conclusion. If there is a match, it replaces the goal\nwith the subgoals of the proof term.\nIn our case, EC matches int_refl to the goal's conclusion, sees that it\nmatches, and replaces the goal with what needs to be proven for int_relf which is\nnothing, and it concludes the proof.\n*)\n\n(* \nEC comes with a lot of predefined lemmas and axioms that we can use.\nLet us now look at axioms about commutativity and associativity for integers.\nThey are by the names addzC, and addzA. Print them out as an exercise.\n*)\n\n\n(* Simplifying goals *)\n\n(*\nIn the proofs, sometimes tactics yield us something that can be simplified\nWe use the tactic \"simplify\", in order to carry out the simplification.\n\nThe simplify tactic reduces the goal to a normal form using lambda calculus.\nWe don't need to worry about the specifics of how, but it is important to\nunderstand that EC can simplify the goals given it knows how to.\nIt will leave the goal unchanged if the goal is already in the normal form.\n\nFor instance, here is a contrived example that illustrates the idea.\nWe will get to more meaningful examples later, but going through these\nsimple examples will make writing complex proofs easier.\n*)\n\n(* Commutativity *)\nlemma x_plus_comm (x: int): x + 2*3 = 6 + x.\nproof.\n    simplify.\n    (* EC does the mathematical computation for us and simplifies the goal *)\n    simplify.\n    (* simplify doesn't fail, and leaves the goal unchanged *)\n    trivial.\n    (* trivial doesn't fail either, and leaves the goal unchanged *)\n    apply addzC.\nqed.\n\n(* ---- Exercise ---- *)\n(* \n\"admit\" is a tactic that closes the current goal by admitting it.\nReplace admit in the following lemma and prove it using the earlier tactics.\n*)\nlemma x_minus_equal (x: int): x - 10 = x - 9 - 1.\nproof.\nadmit.\nqed.\n\n(*\nThe goal list in EC is an ordered one, and you have to prove them\nin the same order as EC lists it. \"admit\" can be used to bypass a certain \ngoal and focus on something else in the goal list.\n*)\n\n(*\nUse the tactic \"split\" to split the disjunction into two\nand apply the previous axioms to discharge the goals.\nExperiment with admiting the first goal after splitting\n*)\nlemma int_assoc_comm (x y z: int): x + (y + z) = (x + y) + z /\\ x + y = y + x.\nproof.\nadmit.\nqed.\n\n(*\nTo deal with disjunctions in EC, you can use the tactics \"left\" or \"right\"\nto step into a proof of the left proof term, or the right proof term respectively.\n*)\n\n(* Searching in EC *)\n\n(*\nSince, there is a lot that is already done in EC,\nwe need a way to look for things. \nWe do that using the \"search\" command. It prints out all axioms and lemmas \ninvolving the list of operators that give it.\n*)\n\nsearch [-].\n(* [] - Square braces for unary operators  *)\n\nsearch (+).\n\n(*\nAs you can see the list can be quite overwhelming and difficult to navigate.\nSo we can limit the results using a list of operators, or patterns.\n*)\n\nsearch ( * ).\n(*\n() - Parentheses for binary operators. \nNotice the extra space for the \"*\" operator.\nWe need that since (* *) also indicates comments.\n*)\n\nsearch (+) (=) (=>).\n(* List of operators \"=>\" is the implication symbol *)\n\nsearch min.\n(* By just the name of the operators. *)\n\n(*---- Exercises ----*)\n\n(* Distributivity *)\n(* Search for the appropriate axiom and apply it to discharge this goal. *)\nlemma int_distr (x y z: int): (x + y) * z = x * z + y * z.\nproof.\n    admit.\nqed.\n\n(*\nSo far, we saw lemmas without any assumptions \nexcept for that of the type of the variable in question.\nMore often than not we will have assumptions regarding variables.\nWe need to treat these assumptions as a given and introduce them into the context.\nThis is done by using \"move => ...\" followed by the name you want to give\nthe assumption.\n*)\n\nlemma x_pos (x: int): 0 < x => 0 < x+1.\nproof.\n    move => x_ge0.\n    simplify.\n    trivial.\n    (* Both of those tactics don't work. We need something else here *)\n    (* Let us see if EC has something that we can use. *)\n    search (<) (+) (0) (=>).\n    rewrite addz_gt0.\n    (*\n    \"rewrite\" simply rewrites the pattern provided, so in our case it\n    rewrites our goal here (0 < x + 1), with the pattern that we provided\n    which is addz_gt0, and then requires us to prove the assumptions of\n    the pattern which are 0 < x and 0 < 1.\n    *)\n        (* Goal 1: 0 < x *)\n\n        (*\n        When we have a goal matches an assumption, we \n        can use the tactic assumption to discharge it.\n        *)\n        assumption.\n\n        (* Goal 2: 0 < 1 *)\n        trivial.\nqed.\n\n(* Let us see some variations *)\n\nlemma int_assoc_rev (x y z: int): x + y + z = x + (y + z).\nproof.\n    print addzA.\n    (* \n    We might have a lemma or an axiom that we can apply to the goal,\n    but the LHS and RHS might be flipped, and EC will complain that\n    they don't match to apply them.\n    To rewrite a lemma or axiom in reverse, we simply add the \"-\" infront\n    of the lemma to switch the sides like so.\n    *)\n    rewrite -addzA.\n    trivial.\nqed.\n\n(*\nNote that here \"apply addzA.\" or \"apply -addzA\" do not work\nWe encourage you to try them.\n*)\n\n(*\nRecap:\nSo far we have seen the following tactics:\ntrivial, simplify, apply, rewrite,\nmove, split, left, right, admit, and assumption.\nWe also saw how to print and search for patterns.\nThese are at the foundation of how we work with EC.\n*)\n\n(*\nIntro to smt and external provers:\nAn important point to understand, however, is that EC\nwas built to work with cryptographic properties and more complex things.\nSo although other mathematical theorems and claims can be proven in EC,\nit will be quite painful to do so. We will employ powerful automated tools\nto take care of some of these low-level tactics and logic.\nEC offers this in the form of the \"smt\" tactic.\nWhen we run smt, EC sends the conclusion and the context to external smt solvers.\nIf they are able to solve the goal, then EC completes the proof.\nIf not smt fails and the burden of the proof is still on us.\n*)\n\nlemma x_pos_smt (x: int): 0 < x => 0 < x+1.\nproof.\nsmt.\nqed.\n\n(*\nAs you can see, smt can make our lives much easier.\nNow, here are some properties about logarithms that are mentioned in \nThe Joy of Cryptography. We leave them to be completed as exercises,\nwithout using the smt tactic. Most of them are straightforward and\nserve the purpose of exercising the use of basic tactics.\n*)\n\nrequire import AllCore.\n\n\n(* print AllCore to see what it includes *)\n\n(* Logs and exponents: *)\n\nlemma exp_product (x: real) (a b: int): x^(a*b) = x ^ a ^ b.\nproof.\n    search (^) (=).\n    by apply RField.exprM.\nqed.\n\nlemma exp_product2 (x: real) (a b: int): x <> 0%r => x^a * x^b = x^(a + b).\nproof.\n    move => x_pos.\n    search (^) (=).\n    print  RField.exprD.\n    rewrite -RField.exprD.\n    assumption.\n    trivial.\nqed.\n\n(* Logarithm exercises *)\nrequire import RealExp.\n\n(*\nPrint and search for \"ln\" to see how it is defined and\nthe results we have available already \n*)\nlemma ln_product (x y: real) : 0%r < x  => 0%r < y => ln (x*y) = ln x + ln y.\nproof.\n    search (ln) (+).\n    move => H1 H2.\n    by apply lnM.\nqed.\n\nprint log.\n(*\nNotice how log is defined. It is defined as an operator that expects two inputs\nSince most of ECs axioms are written for natural logs (ln), inorder to reason with\nlog and inorder to work with the next lemma, you will need to rewrite log.\nTo do so the syntax is\n\nrewrite /log.\n\nThe \"/\" will rewrite the pattern that follows.\n*)\n\n(*\nThis helper can come in handy in the next proof.\nSometimes it can be cumbersome to reason with a goal.\nIn cases like those, it is useful to reduce the complexity of the proof by using\nhelper lemmas like these.\n*)\n\nlemma helper (x y z: real): (x + y) / z = x/z + y/z.\nproof.\nsmt.\nqed.\n\nlemma log_product (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    move => H1 H2.\n    rewrite /log.\n    rewrite lnM.\n    assumption.\n    assumption.\n    by apply helper.\nqed.\n\n(* Or we can simply let smt do the heavy lifting for us *)\nlemma log_product_smt (x y a : real):\n    0%r < x  => 0%r < y => log a (x*y) = log a x + log a y.\nproof.\n    smt.\nqed.\n\n(*\nModulo arithmatic exercises:\nThis is one of the properties that is mentioned in the\n *)\nrequire import IntDiv.\n\nlemma mod_add (x y z: int): (x %% z + y %% z) %% z = (x + y) %% z.\nproof.\n    by apply modzDm.\nqed.\n\n(* \nA couple of more keystrokes that might be useful.\n\n1. C-c C-r: Begin evaluating from the start\n2. C-c C-b: Evaluate until the end of the file.\n\nGo ahead and give these a try.\n*)"
    },
    {
        "file": "EC-1/asgncase.ec",
        "incomplete": "(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[____(LEMMA_0)____.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y = 1).\n- by auto.\n- by auto.\nqed.",
        "complete:": "(* -------------------------------------------------------------------- *)\nrequire import AllCore.\n\n(* -------------------------------------------------------------------- *)\nmodule M = {\n  proc f(x : int, y : int) = {\n    var x', y' : int;\n\n    (x', y') <- (x, y);\n\n    return (x', y');\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\nlemma L : hoare[M.f : arg = (0, 1) ==> res = (0, 1)].\nproof.\nproc.\ncase <- 1.\nseq 1 : (x' = 0 /\\ y = 1).\n- by auto.\n- by auto.\nqed."
    },
    {
        "file": "EC-1/adversary.ec",
        "incomplete": "require import AllCore List StdOrder Distr Real Int RealExp.\n(*---*) import RealOrder.\nrequire import Xreal RealSeries.\n(*---*) import StdBigop.Bigreal.\n\ntype ____(TYPE_0)____.\nop [lossless] dr : r distr.\n\nop ____(OP_0)____ : r -> bool.\n\nop p = mu dr test.\naxiom dr_mu_test : 0%r < p.\n\nop eps : real.\naxiom dr_mu1 : forall (x:r), mu1 dr x <= eps.\n\nlemma eps_ge0: ____(LEMMA_0)____ <= eps. by smt(dr_mu1 mu_bounded). qed.\n\nmodule type Oracle = { \n  proc o () : unit \n}.\n\nmodule type Adv (O:Oracle) = {\n  proc adv () : unit\n}.\n\nop Q : int.\naxiom Q_nneg : 0 <= Q.\n\nmodule O = {\n\n  var c : int \n  var log : r list\n  var bad : bool\n\n  proc extend_log () = {\n    var t, r;\n    t <- false;\n    while (!t) {\n      r <$ dr;\n      log <- r :: log;\n      t <- test r; \n    }\n  }\n\n  proc o () = {\n    var r;\n    c <- c + 1;\n    extend_log ();\n    if (c = Q) {\n      r <$ dr;\n      bad <- r \\in log;\n    }\n  }\n}.\n\nmodule Main(A:Adv) = {\n  proc main () = {\n    O.bad <- false;\n    O.c <- 0;\n    O.log <- [];\n    A(O).adv();\n  }\n}.\n\n(* extend-log increases log on average by 1/p *)\nehoare extend_log_size : O.extend_log : (inv p)%xr + (size O.log)%xr ==> (size O.log)%xr.\nproof.\n  proc.\n  while ((b2r (!t) / p)%xr + (size O.log)%xr).\n  + move => &hr; apply xle_cxr_r => |>.\n  + wp; skip; move => &hr; move: (t{hr}) (O.log{hr}) => {&hr} t log; apply xle_cxr_r => ntest.\n    rewrite ntest => /=.\n    rewrite (eq_Ep _ _\n       ((fun r => (inv p)%xr * (! test r)%xr) + (fun r => (1 + size log)%xr))).\n    + move => x xx /=. rewrite of_realM; 1,2:smt(of_realM invr_ge0 ge0_mu). smt().\n    rewrite EpD EpC EpZ /=; 1: smt(invr_gt0 dr_mu_test of_realdK).\n    rewrite Ep_mu mu_not dr_ll /= -/p.\n    rewrite !to_pos_pos; 1,2,3,4:smt(mu_bounded dr_mu_test size_ge0).\n  by auto.\nqed.\n\nehoare o_bad : O.o:\n    (O.bad => Q <= O.c) `|` if Q <= O.c then O.bad%xr else  (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr\n    ==> (O.bad => Q <= O.c)  `|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr.\nproof.\n  proc.\n  wp.\n  call /(fun x => (O.bad => Q <= O.c)\n          `|` if Q < O.c then O.bad%xr else x * eps%xr + (Q - O.c)%xr * (eps/p)%xr) extend_log_size.\n  + auto => &hr /=.\n    case: (O.c{hr} = Q) => [ -> /= | *].\n    + rewrite Ep_mu (:(fun (a : r) => a \\in O.log{hr}) = mem O.log{hr}); 1: by auto.\n      rewrite -of_realM /=; smt(mu_mem_le_mu1 size_ge0 eps_ge0 dr_mu1).\n    case: (Q < O.c{hr}); by smt().\n  auto => &hr /=; apply xle_cxr => *; split; 1:smt().\n  have -> /=: (Q < O.c{hr} + 1) = (Q <= O.c{hr}) by smt().\n  case (Q <= O.c{hr}); 1:smt().\n  by smt(of_realM of_realD dr_mu_test).\nqed.\n\nlemma pr_bad &m (A<:Adv{-O}) : Pr[Main(A).main() @ &m : O.bad] <= eps * Q%r * (inv p).\n  byehoare.\n  + proc.\n    call (: (O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr ==> O.bad%xr).\n    + proc ((O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr).\n      + move => &hr; apply xle_cxr => *; split; 1:smt(). by auto.\n      + move => &hr; apply xle_cxr_r => *.\n        by case: (O.bad{hr}) => [ /# |*]; smt(xle0x).\n      by apply o_bad.\n    by wp; auto; move => *; case (Q <= 0); smt(xle0x).\n  + auto.\n  auto.\nqed.",
        "complete:": "require import AllCore List StdOrder Distr Real Int RealExp.\n(*---*) import RealOrder.\nrequire import Xreal RealSeries.\n(*---*) import StdBigop.Bigreal.\n\ntype r.\nop [lossless] dr : r distr.\n\nop test : r -> bool.\n\nop p = mu dr test.\naxiom dr_mu_test : 0%r < p.\n\nop eps : real.\naxiom dr_mu1 : forall (x:r), mu1 dr x <= eps.\n\nlemma eps_ge0: 0%r <= eps. by smt(dr_mu1 mu_bounded). qed.\n\nmodule type Oracle = { \n  proc o () : unit \n}.\n\nmodule type Adv (O:Oracle) = {\n  proc adv () : unit\n}.\n\nop Q : int.\naxiom Q_nneg : 0 <= Q.\n\nmodule O = {\n\n  var c : int \n  var log : r list\n  var bad : bool\n\n  proc extend_log () = {\n    var t, r;\n    t <- false;\n    while (!t) {\n      r <$ dr;\n      log <- r :: log;\n      t <- test r; \n    }\n  }\n\n  proc o () = {\n    var r;\n    c <- c + 1;\n    extend_log ();\n    if (c = Q) {\n      r <$ dr;\n      bad <- r \\in log;\n    }\n  }\n}.\n\nmodule Main(A:Adv) = {\n  proc main () = {\n    O.bad <- false;\n    O.c <- 0;\n    O.log <- [];\n    A(O).adv();\n  }\n}.\n\n(* extend-log increases log on average by 1/p *)\nehoare extend_log_size : O.extend_log : (inv p)%xr + (size O.log)%xr ==> (size O.log)%xr.\nproof.\n  proc.\n  while ((b2r (!t) / p)%xr + (size O.log)%xr).\n  + move => &hr; apply xle_cxr_r => |>.\n  + wp; skip; move => &hr; move: (t{hr}) (O.log{hr}) => {&hr} t log; apply xle_cxr_r => ntest.\n    rewrite ntest => /=.\n    rewrite (eq_Ep _ _\n       ((fun r => (inv p)%xr * (! test r)%xr) + (fun r => (1 + size log)%xr))).\n    + move => x xx /=. rewrite of_realM; 1,2:smt(of_realM invr_ge0 ge0_mu). smt().\n    rewrite EpD EpC EpZ /=; 1: smt(invr_gt0 dr_mu_test of_realdK).\n    rewrite Ep_mu mu_not dr_ll /= -/p.\n    rewrite !to_pos_pos; 1,2,3,4:smt(mu_bounded dr_mu_test size_ge0).\n  by auto.\nqed.\n\nehoare o_bad : O.o:\n    (O.bad => Q <= O.c) `|` if Q <= O.c then O.bad%xr else  (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr\n    ==> (O.bad => Q <= O.c)  `|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr.\nproof.\n  proc.\n  wp.\n  call /(fun x => (O.bad => Q <= O.c)\n          `|` if Q < O.c then O.bad%xr else x * eps%xr + (Q - O.c)%xr * (eps/p)%xr) extend_log_size.\n  + auto => &hr /=.\n    case: (O.c{hr} = Q) => [ -> /= | *].\n    + rewrite Ep_mu (:(fun (a : r) => a \\in O.log{hr}) = mem O.log{hr}); 1: by auto.\n      rewrite -of_realM /=; smt(mu_mem_le_mu1 size_ge0 eps_ge0 dr_mu1).\n    case: (Q < O.c{hr}); by smt().\n  auto => &hr /=; apply xle_cxr => *; split; 1:smt().\n  have -> /=: (Q < O.c{hr} + 1) = (Q <= O.c{hr}) by smt().\n  case (Q <= O.c{hr}); 1:smt().\n  by smt(of_realM of_realD dr_mu_test).\nqed.\n\nlemma pr_bad &m (A<:Adv{-O}) : Pr[Main(A).main() @ &m : O.bad] <= eps * Q%r * (inv p).\n  byehoare.\n  + proc.\n    call (: (O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr ==> O.bad%xr).\n    + proc ((O.bad => Q <= O.c)`|` if Q <= O.c then O.bad%xr else (size O.log)%xr * eps%xr + (Q - O.c)%xr * (eps/p)%xr).\n      + move => &hr; apply xle_cxr => *; split; 1:smt(). by auto.\n      + move => &hr; apply xle_cxr_r => *.\n        by case: (O.bad{hr}) => [ /# |*]; smt(xle0x).\n      by apply o_bad.\n    by wp; auto; move => *; case (Q <= 0); smt(xle0x).\n  + auto.\n  auto.\nqed."
    },
    {
        "file": "EC-1/ArrayFiniteness.ec",
        "incomplete": "require import AllCore List.\n\n\nrequire import WArray256.\nrequire import JModel.\n\nop all_8lists = alltuples ____(OP_1)____ [true;false]. \n\nlemma all_8lists_full (l : bool list) : size l = 8\n => l \\in all_8lists. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 8 l [true;false]).\nsplit. auto. smt(@List).\nqed.\n\n\nlemma all_8lists_size  : \n size all_8lists = 2 ^ 8.\nrewrite /all_8lists. rewrite size_alltuples.\nsimplify. rewrite /max. simplify. auto.\nqed.\n\n\nlemma all_8lists_uniq  : \n uniq all_8lists.\nsmt(@List).\nqed.\n\nop all_8words = map W8.bits2w all_8lists.\n\nlemma all_8words_full (w : ____(LEMMA_2)____.t) : \n  w \\in all_8words.\nrewrite /all_8words.\nhave : (W8.w2bits w) \\in all_8lists. apply all_8lists_full.\nsmt(@W8).\nmove => h.\nhave : W8.bits2w (W8.w2bits w) \\in all_8words. rewrite /all_8words.\napply map_f. auto.\nrewrite /all_8words.\nsmt(@W8).\nqed.\n\nlemma all_8words_size : size all_8words = ____(LEMMA_3)____ ^ 8.\nrewrite /all_8words. rewrite - all_8lists_size.\nsmt(@List).\nqed.\n  \n\nlemma all_8words_uniq : uniq all_8words.\nrewrite /all_8words.\napply map_inj_in_uniq. \nprogress. \nhave  : w2bits(bits2w x)%W8 = w2bits(bits2w y)%W8. smt().\nrewrite  bits2wK. \nhave -: x \\in all_8lists.  auto. \nclear H. rewrite /all_8lists. smt(@List).\nrewrite  bits2wK. smt(@List).\nauto.\napply all_8lists_uniq.\nqed.\n\n\n\n\nop all_256lists = alltuples 256 all_8words. \n\nlemma all_256lists_full (l : W8.t list) : size l = 256\n => l \\in all_256lists. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 256 l all_8words).\nsplit. auto. \napply List.allP.\nsmt(all_8words_full).\nqed.\n\n\nlemma all_256lists_size  : \n size all_256lists = 256 ^ 256.\nrewrite /all_256lists. rewrite size_alltuples.\nsimplify. rewrite /max.\nrewrite all_8words_size. simplify.\nauto.\nqed.\n\nlemma all_256lists_uniq  : \n uniq all_256lists.\nsmt(@List all_8words_uniq).\nqed.\n\n\nop all_256words = map ____(OP_0)____.of_list all_256lists.\n\n\n\nlemma all_256words_uniq : uniq all_256words.\nrewrite /all_256words.\napply map_inj_in_uniq. \nprogress. \nhave  : to_list(of_list x)%WArray256 = to_list(of_list y)%WArray256. smt().\nrewrite of_listK.\nrewrite /all_256lists. smt(@List).\nrewrite  of_listK. smt(@List).\nrewrite /all_256lists. smt(@List).\napply all_256lists_uniq.\nqed.\n\nlemma all_256words_full (w : WArray256.t) : \n  w \\in all_256words.\nrewrite /all_256words.\nhave : (WArray256.to_list w) \\in all_256lists. apply all_256lists_full.\nsmt(@WArray256).\nmove => h.\nhave : WArray256.of_list (WArray256.to_list w) \\in all_256words. rewrite /all_256words.\napply map_f. auto.\nrewrite /all_256words.\nsmt(@WArray256).\nqed.\n\nlemma all_256words_size : size all_256words = 256 ^ 256.\nrewrite /all_256words. rewrite - all_256lists_size.\nsmt(@List).\nqed.\n\n\n    (* WArray1 *)\nrequire import WArray1.\n\nop all_256lists1 = alltuples 1 all_8words. \n\nlemma all_256lists1_full (l : W8.t list) : size l = 1\n => l \\in all_256lists1. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 1 l all_8words).\nsplit. auto. \napply List.allP.\nsmt(all_8words_full).\nqed.\n\n\nlemma all_256lists1_size  : \n size all_256lists1 = 256 ^ 1.\nrewrite /all_256lists1. rewrite size_alltuples.\nsimplify. rewrite /max.\nrewrite all_8words_size. simplify.\nauto.\nqed.\n\nlemma all_256lists1_uniq  : \n uniq all_256lists1.\nsmt(@List all_8words_uniq).\nqed.\n\nrequire import Array1.\n\nop all_256words1 = map (fun x => (Array1.init (fun i => x))) all_8words.\n\nlemma all_256words1_uniq : uniq all_256words1.\nrewrite /all_256words1.\napply map_inj_in_uniq. \nprogress.  smt(@Array1).\napply all_8words_uniq.\nqed.\n\n\nlemma all_256words1_full (w : W8.t Array1.t ) : \n  w \\in all_256words1.\nhave s : size (Array1.to_list w) = 1. smt(@Array1).\n\nhave q : (head witness (Array1.to_list w)) \\in all_8words. \napply all_8words_full.\n\nrewrite /all_256words1.\nhave <- : (fun (x : W8.t) => Array1.init (fun (_ : int) => x)) (head witness (to_list w)) = w.\nsmt(@Array1). \napply map_f. auto.\nqed.\n\nlemma all_256words1_size : size all_256words1 = 256 ^ 1.\nrewrite /all_256words1. rewrite - all_256lists1_size.\nsmt(@List).\nqed.\n\n\n\nrequire import BigNum_spec.\nrequire import AllCore List.\n\nimport W64xN.\nimport R.\nop all_w64xN : R.t list  = map R.bn_ofint (range 0 modulusR).\n\nlemma all_w64xN_uniq : uniq (all_w64xN).\napply map_inj_in_uniq. move => x y.\nmove => xi yi.\nhave f0 : 0 < modulusR. auto.\nhave f1 : 0 <= x < modulusR. split. smt(@List). move => _.\nsmt(@List).\nhave f2 : 0 <= y < modulusR. split. smt(@List). move => _.\nsmt(@List).\nclear xi yi. \nmove => ass.\nhave : valR (R.bn_ofint x) = valR (R.bn_ofint y).\nsmt().\nrewrite R.bn_ofintK.\nrewrite R.bn_ofintK. smt(@IntDiv).\nsmt(@List).\nqed.\n\nlemma modulusR_pos : 0 < ____(LEMMA_1)____. auto.\nqed.\n\n\nlemma ____(LEMMA_0)____ : size (all_w64xN) = modulusR.\nrewrite /all_w64xN.  smt(@List modulusR_pos).\nqed.\n\n\nlemma all_ints x : 0 <= x < modulusR => (R.bn_ofint x) \\in all_w64xN.\nprogress. rewrite /all_w64xN. smt(@List).\nqed.\n\n\nlemma all_w64xN_full x : x \\in all_w64xN.\n have f1 : R.bn_ofint (valR x) \\in all_w64xN.\n apply all_ints.  split. smt(@W64xN). move => _. \nhave f2 : 0 <= valR x < W64x2N.M ^ nlimbs.  rewrite /valR. apply R.bnk_cmp. smt().\nsmt (bnK).\nqed.",
        "complete:": "require import AllCore List.\n\n\nrequire import WArray256.\nrequire import JModel.\n\nop all_8lists = alltuples 8 [true;false]. \n\nlemma all_8lists_full (l : bool list) : size l = 8\n => l \\in all_8lists. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 8 l [true;false]).\nsplit. auto. smt(@List).\nqed.\n\n\nlemma all_8lists_size  : \n size all_8lists = 2 ^ 8.\nrewrite /all_8lists. rewrite size_alltuples.\nsimplify. rewrite /max. simplify. auto.\nqed.\n\n\nlemma all_8lists_uniq  : \n uniq all_8lists.\nsmt(@List).\nqed.\n\nop all_8words = map W8.bits2w all_8lists.\n\nlemma all_8words_full (w : W8.t) : \n  w \\in all_8words.\nrewrite /all_8words.\nhave : (W8.w2bits w) \\in all_8lists. apply all_8lists_full.\nsmt(@W8).\nmove => h.\nhave : W8.bits2w (W8.w2bits w) \\in all_8words. rewrite /all_8words.\napply map_f. auto.\nrewrite /all_8words.\nsmt(@W8).\nqed.\n\nlemma all_8words_size : size all_8words = 2 ^ 8.\nrewrite /all_8words. rewrite - all_8lists_size.\nsmt(@List).\nqed.\n  \n\nlemma all_8words_uniq : uniq all_8words.\nrewrite /all_8words.\napply map_inj_in_uniq. \nprogress. \nhave  : w2bits(bits2w x)%W8 = w2bits(bits2w y)%W8. smt().\nrewrite  bits2wK. \nhave -: x \\in all_8lists.  auto. \nclear H. rewrite /all_8lists. smt(@List).\nrewrite  bits2wK. smt(@List).\nauto.\napply all_8lists_uniq.\nqed.\n\n\n\n\nop all_256lists = alltuples 256 all_8words. \n\nlemma all_256lists_full (l : W8.t list) : size l = 256\n => l \\in all_256lists. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 256 l all_8words).\nsplit. auto. \napply List.allP.\nsmt(all_8words_full).\nqed.\n\n\nlemma all_256lists_size  : \n size all_256lists = 256 ^ 256.\nrewrite /all_256lists. rewrite size_alltuples.\nsimplify. rewrite /max.\nrewrite all_8words_size. simplify.\nauto.\nqed.\n\nlemma all_256lists_uniq  : \n uniq all_256lists.\nsmt(@List all_8words_uniq).\nqed.\n\n\nop all_256words = map WArray256.of_list all_256lists.\n\n\n\nlemma all_256words_uniq : uniq all_256words.\nrewrite /all_256words.\napply map_inj_in_uniq. \nprogress. \nhave  : to_list(of_list x)%WArray256 = to_list(of_list y)%WArray256. smt().\nrewrite of_listK.\nrewrite /all_256lists. smt(@List).\nrewrite  of_listK. smt(@List).\nrewrite /all_256lists. smt(@List).\napply all_256lists_uniq.\nqed.\n\nlemma all_256words_full (w : WArray256.t) : \n  w \\in all_256words.\nrewrite /all_256words.\nhave : (WArray256.to_list w) \\in all_256lists. apply all_256lists_full.\nsmt(@WArray256).\nmove => h.\nhave : WArray256.of_list (WArray256.to_list w) \\in all_256words. rewrite /all_256words.\napply map_f. auto.\nrewrite /all_256words.\nsmt(@WArray256).\nqed.\n\nlemma all_256words_size : size all_256words = 256 ^ 256.\nrewrite /all_256words. rewrite - all_256lists_size.\nsmt(@List).\nqed.\n\n\n    (* WArray1 *)\nrequire import WArray1.\n\nop all_256lists1 = alltuples 1 all_8words. \n\nlemma all_256lists1_full (l : W8.t list) : size l = 1\n => l \\in all_256lists1. \nrewrite /all_8lists.\nmove => q.\napply (alltuplesP 1 l all_8words).\nsplit. auto. \napply List.allP.\nsmt(all_8words_full).\nqed.\n\n\nlemma all_256lists1_size  : \n size all_256lists1 = 256 ^ 1.\nrewrite /all_256lists1. rewrite size_alltuples.\nsimplify. rewrite /max.\nrewrite all_8words_size. simplify.\nauto.\nqed.\n\nlemma all_256lists1_uniq  : \n uniq all_256lists1.\nsmt(@List all_8words_uniq).\nqed.\n\nrequire import Array1.\n\nop all_256words1 = map (fun x => (Array1.init (fun i => x))) all_8words.\n\nlemma all_256words1_uniq : uniq all_256words1.\nrewrite /all_256words1.\napply map_inj_in_uniq. \nprogress.  smt(@Array1).\napply all_8words_uniq.\nqed.\n\n\nlemma all_256words1_full (w : W8.t Array1.t ) : \n  w \\in all_256words1.\nhave s : size (Array1.to_list w) = 1. smt(@Array1).\n\nhave q : (head witness (Array1.to_list w)) \\in all_8words. \napply all_8words_full.\n\nrewrite /all_256words1.\nhave <- : (fun (x : W8.t) => Array1.init (fun (_ : int) => x)) (head witness (to_list w)) = w.\nsmt(@Array1). \napply map_f. auto.\nqed.\n\nlemma all_256words1_size : size all_256words1 = 256 ^ 1.\nrewrite /all_256words1. rewrite - all_256lists1_size.\nsmt(@List).\nqed.\n\n\n\nrequire import BigNum_spec.\nrequire import AllCore List.\n\nimport W64xN.\nimport R.\nop all_w64xN : R.t list  = map R.bn_ofint (range 0 modulusR).\n\nlemma all_w64xN_uniq : uniq (all_w64xN).\napply map_inj_in_uniq. move => x y.\nmove => xi yi.\nhave f0 : 0 < modulusR. auto.\nhave f1 : 0 <= x < modulusR. split. smt(@List). move => _.\nsmt(@List).\nhave f2 : 0 <= y < modulusR. split. smt(@List). move => _.\nsmt(@List).\nclear xi yi. \nmove => ass.\nhave : valR (R.bn_ofint x) = valR (R.bn_ofint y).\nsmt().\nrewrite R.bn_ofintK.\nrewrite R.bn_ofintK. smt(@IntDiv).\nsmt(@List).\nqed.\n\nlemma modulusR_pos : 0 < modulusR. auto.\nqed.\n\n\nlemma all_w64xN_size : size (all_w64xN) = modulusR.\nrewrite /all_w64xN.  smt(@List modulusR_pos).\nqed.\n\n\nlemma all_ints x : 0 <= x < modulusR => (R.bn_ofint x) \\in all_w64xN.\nprogress. rewrite /all_w64xN. smt(@List).\nqed.\n\n\nlemma all_w64xN_full x : x \\in all_w64xN.\n have f1 : R.bn_ofint (valR x) \\in all_w64xN.\n apply all_ints.  split. smt(@W64xN). move => _. \nhave f2 : 0 <= valR x < W64x2N.M ^ nlimbs.  rewrite /valR. apply R.bnk_cmp. smt().\nsmt (bnK).\nqed."
    },
    {
        "file": "EC-1/AuxLemmas.ec",
        "incomplete": "require import AllCore Distr Finite List.\n\n\nrequire import BitEncoding.\nimport BS2Int.\n\nrequire import JWord.\n\n\n\nmodule Skip = {\n  proc run() = {}\n}.\n\nlemma skip_run &m : Pr[____(LEMMA_0)____.run()@&m : true] = 1%r.\nbyphoare. proc. auto. auto. auto. qed.\n\n\n\nlemma kok (a b c : real) : 0%r <= a => 0%r < b => 1%r < c =>\n a <= b / c => a < b.\nsmt(@Real).\nqed.\n\n\nlemma w64oneP : forall x, 0 < x < 64 => W64.one.[x] = false. \nprogress. \nrewrite /W64.one.\nrewrite - of_intE.\nrewrite of_intwE.\nhave -> : (0 <= x && x < 64) = true. smt(). simplify.\nrewrite /int_bit.\nsmt(@IntDiv @W64).\nqed.\n\nop ____(OP_1)____ [____(OP_0)____] = choiceb (____(OP_2)____ (____(OP_3)____:'a->'a) => x = (fun x => x)) witness.\nlemma nasty_id ['a] (x:'a): nasty_id x = x.\n    have : (fun (x:'a->'a) => x = (fun x => x)) nasty_id.\n    rewrite /nasty_id. apply choicebP. smt().\n    smt().\nqed.\n\n\n\nlemma mkseqS' ['a]:\n  forall (f : int -> 'a) (n : int),\n    0 < n => mkseq f n = rcons (mkseq f (n - 1)) (f (n - 1)).\nsmt(mkseqS).\nqed.\n\n\nop LessThan (n x : int) = 0 <= x < n.\n\nlemma inveq a b : 1%r / a = 1%r / b => a = b.\nsmt(@Real).\nqed.\n\nlemma d_uni_sum (d : int distr) n : is_uniform d \n  => is_lossless d\n  => (forall x, LessThan n x => x \\in d)\n  => forall (i : int),\n   0 <= i => i < n =>\n  mu d (LessThan i) = i%r / (size (to_seq (support d)))%r.\nmove => isfu isll sup.\napply intind.\nsimplify. rewrite /LessThan. simplify. smt(@Distr).  \nprogress.\nhave -> : \n (i + 1)%r / (size (to_seq (support d)))%r\n = (i )%r / (size (to_seq (support d)))%r\n   + 1%r / (size (to_seq (support d)))%r.\nsmt(). \nhave ->: LessThan (i + 1) = (fun x => LessThan i x \\/ x = i).\napply fun_ext. move => x. simplify. rewrite /P. smt(). \nrewrite mu_or. simplify.\nrewrite H0. clear H0. smt(). \nrewrite /predI. rewrite /LessThan.\nhave -> : (fun (x : int) => (0 <= x && x < i) /\\ x = i)\n = (fun (x : int) => false). smt().\nhave ->: mu d (fun (_ : int) => false) = 0%r. smt(@Distr). simplify.\ncongr. \nrewrite mu1_uni_ll. smt(). \nauto. smt().\nqed.\n\n\nop inv ['a 'b] : 'a -> ('a -> 'b) -> 'b -> 'a\n = fun d f b => \n    choiceb (fun x => f x = b) \n            d.\n\nlemma invP ['a 'b] d (f : 'a -> 'b)  : \n    injective f \n    => forall x,  (inv d f)  (f x) = x. \nproof. move => ip x.\nrewrite /inv.\npose P := fun x' => (f x' = f x). \nhave : P (choiceb P d). \napply choicebP. exists x. auto.\nrewrite /P. apply ip.\nqed.\n\n\nlemma choiceb_dfl_cp ['a]:\n  forall (P : 'a -> bool) (x0 : 'a),\n choiceb P x0 <> x0\n  =>   (exists (x : 'a), P x).\nsmt (choiceb_dfl).\nqed.\n\nlemma choiceEx ['a 'b] d (f : 'a -> 'b) x y :  \n    (inv d f) x = y\n    => y <> d\n    => exists z, f z = x.\nproof. \nrewrite /inv.\npose P := fun x' => (f x' = x). \nmove => q. rewrite -q.\nmove => h.\napply (choiceb_dfl_cp  P d). auto.\nqed.",
        "complete:": "require import AllCore Distr Finite List.\n\n\nrequire import BitEncoding.\nimport BS2Int.\n\nrequire import JWord.\n\n\n\nmodule Skip = {\n  proc run() = {}\n}.\n\nlemma skip_run &m : Pr[Skip.run()@&m : true] = 1%r.\nbyphoare. proc. auto. auto. auto. qed.\n\n\n\nlemma kok (a b c : real) : 0%r <= a => 0%r < b => 1%r < c =>\n a <= b / c => a < b.\nsmt(@Real).\nqed.\n\n\nlemma w64oneP : forall x, 0 < x < 64 => W64.one.[x] = false. \nprogress. \nrewrite /W64.one.\nrewrite - of_intE.\nrewrite of_intwE.\nhave -> : (0 <= x && x < 64) = true. smt(). simplify.\nrewrite /int_bit.\nsmt(@IntDiv @W64).\nqed.\n\nop nasty_id ['a] = choiceb (fun (x:'a->'a) => x = (fun x => x)) witness.\nlemma nasty_id ['a] (x:'a): nasty_id x = x.\n    have : (fun (x:'a->'a) => x = (fun x => x)) nasty_id.\n    rewrite /nasty_id. apply choicebP. smt().\n    smt().\nqed.\n\n\n\nlemma mkseqS' ['a]:\n  forall (f : int -> 'a) (n : int),\n    0 < n => mkseq f n = rcons (mkseq f (n - 1)) (f (n - 1)).\nsmt(mkseqS).\nqed.\n\n\nop LessThan (n x : int) = 0 <= x < n.\n\nlemma inveq a b : 1%r / a = 1%r / b => a = b.\nsmt(@Real).\nqed.\n\nlemma d_uni_sum (d : int distr) n : is_uniform d \n  => is_lossless d\n  => (forall x, LessThan n x => x \\in d)\n  => forall (i : int),\n   0 <= i => i < n =>\n  mu d (LessThan i) = i%r / (size (to_seq (support d)))%r.\nmove => isfu isll sup.\napply intind.\nsimplify. rewrite /LessThan. simplify. smt(@Distr).  \nprogress.\nhave -> : \n (i + 1)%r / (size (to_seq (support d)))%r\n = (i )%r / (size (to_seq (support d)))%r\n   + 1%r / (size (to_seq (support d)))%r.\nsmt(). \nhave ->: LessThan (i + 1) = (fun x => LessThan i x \\/ x = i).\napply fun_ext. move => x. simplify. rewrite /P. smt(). \nrewrite mu_or. simplify.\nrewrite H0. clear H0. smt(). \nrewrite /predI. rewrite /LessThan.\nhave -> : (fun (x : int) => (0 <= x && x < i) /\\ x = i)\n = (fun (x : int) => false). smt().\nhave ->: mu d (fun (_ : int) => false) = 0%r. smt(@Distr). simplify.\ncongr. \nrewrite mu1_uni_ll. smt(). \nauto. smt().\nqed.\n\n\nop inv ['a 'b] : 'a -> ('a -> 'b) -> 'b -> 'a\n = fun d f b => \n    choiceb (fun x => f x = b) \n            d.\n\nlemma invP ['a 'b] d (f : 'a -> 'b)  : \n    injective f \n    => forall x,  (inv d f)  (f x) = x. \nproof. move => ip x.\nrewrite /inv.\npose P := fun x' => (f x' = f x). \nhave : P (choiceb P d). \napply choicebP. exists x. auto.\nrewrite /P. apply ip.\nqed.\n\n\nlemma choiceb_dfl_cp ['a]:\n  forall (P : 'a -> bool) (x0 : 'a),\n choiceb P x0 <> x0\n  =>   (exists (x : 'a), P x).\nsmt (choiceb_dfl).\nqed.\n\nlemma choiceEx ['a 'b] d (f : 'a -> 'b) x y :  \n    (inv d f) x = y\n    => y <> d\n    => exists z, f z = x.\nproof. \nrewrite /inv.\npose P := fun x' => (f x' = x). \nmove => q. rewrite -q.\nmove => h.\napply (choiceb_dfl_cp  P d). auto.\nqed."
    },
    {
        "file": "EC-1/AuxResults.ec",
        "incomplete": "require import DJoin.\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List RealExp.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n   \n\n\nlemma big_reindex f (c e : int) :  big predT f (range 0 e) \n = big predT (fun i => f (i - c)) (range c (e + c)) .\nrewrite (big_reindex predT f (fun x => x - c) (fun x => x + c) ).\nsmt().\nhave ->: (predT \\o transpose Int.(+) (-c)) = predT.\nsmt().\nhave ->: (f \\o transpose Int.(+) (-c)) = (fun (i : int) => f (i - c)).\nsmt().\nhave ->: (map (transpose Int.(+) c) (range 0 e)) = \n  range c (e + c).\nhave ->: (transpose Int.(+) c) = (+) c. smt().\nrewrite - (range_add 0 e c). auto.\nauto.\nqed.\n\n\nlemma big_formula_p p  : 0%r <= p <= 1%r => forall n, 0 <= n  =>\n bigi predT (fun (i : int) => p^i * (1%r-p) ) 0 n = 1%r - p^ n.\nmove => pa.  apply ge0ind. \nprogress. smt().\nprogress.\nhave ->: 1%r - p ^ 0 = 0%r. smt(@Real).\nsmt(@List).\nprogress.\nrewrite big_int_recr. auto. simplify.\nrewrite H0. auto.  smt(@Real).\nqed.\n\n\nlemma big_formula_1mp p  : 0%r <= p <= 1%r => forall n, 0 <= n  =>\n bigi predT (fun (i : int) => (1%r-p)^i * p) 0 n = 1%r - (1%r-p)^ n.\nsmt (big_formula_p).\nqed.\n\n\nlemma big_split_min ['a]:\n  forall (P0 : 'a -> bool) (F1 F2 : 'a -> real) (s : 'a list),\n    big P0 (fun (i : 'a) => F1 i - F2 i) s = big P0 F1 s - big P0 F2 s.\nproof.  progress.\nhave ->:  - big P0 F2 s\n =  (big P0 (fun x => - (F2 x) ) s).\napply (big_ind2 (fun (x : real) y => (- x) = y) ) .\nsmt(). smt().\nprogress.\napply big_split.\nqed.\n\n\nlemma multn p  : 0%r <= p <= 1%r => forall n, 0 <= n => 0%r <= p^n <= 1%r.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. smt(@Real).\nsmt(@Real).\nqed.\n\n\nlemma multn2 (p q : real)  :  0%r <= p <= q => forall n, 0 <= n => p^n <= q^n.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. \nhave ->: p ^ (n + 1) = p * p^n. smt(@Real).\nhave ->: q ^ (n + 1) = q * q^n. smt(@Real).\nsmt(@RealExp).\nqed.\n\n\nlemma big_geq0 p  : 0%r <= p <= 1%r => forall n, \n 0%r <= bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt (multn).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma big_leq1 p  : 0%r <= p <= 1%r => forall n, \n bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n <= 1%r.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt(@RealExp).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma djoinmap_weight (d : 'a -> 'b distr) :  forall l,\n  (forall x, is_lossless (d x)) =>\n    weight (djoinmap d l) = 1%r.\nelim. smt (weight_djoin_nil).\nsmt (weight_djoin_cons).\nqed.\n\n\nlemma sub_all ['a]:\n   forall (p1 p2 : 'a -> bool) (s : 'a list),\n     (forall (x : 'a), p1 x => p2 x) => all p1 s => all p2 s.\nmove => p1 p2.  elim. smt().\nsmt().\nqed.\n\n\nlemma take_zip ['a 'b] : \n   forall  (n :  int) (l1 : 'a list)(l2 : 'b list),\n   zip (take n l1) (take n l2) \n  = take n (zip l1 l2).\napply ge0ind. smt().\nsmt().\nprogress.\ncase (l1 = []).\nsmt().\nprogress.\nhave f1 : exists a1 l1', l1 = (a1 :: l1').\nclear H0 H.  \nexists (head witness l1) (behead l1).\nsmt().\nelim f1.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify.\ncase (l2 = []).\nsmt().\nprogress. \nhave f2 : exists a2 l2', l2 = (a2 :: l2').\nexists (head witness l2) (behead l2).\nsmt().\nelim f2.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify. smt().\nqed.\n\n\nlemma ler_trans1 (____(LEMMA_0)____ ____(LEMMA_1)____ c : real) : a <= b => b <= c => a <= c. by smt().\nqed.\n\n\nsection.\nlocal lemma oip1 (a b c eps : real) :  (0%r <= eps) =>\n  `|a / b - c| <= eps\n => exists (p : real), 0%r <= p <= eps  /\\ `|a / b - c| = p.\nsmt().\nqed.\n\n\nlocal lemma oip2 (a b c p : real) :  \n  (0%r < b) =>\n  `|a / b - c| = p =>\n      a = b * c - b * p \\/  a = b * c + b * p.\nsmt().\nqed.\n\n\nlocal lemma oip2b (a b c p : real) :  \n  (0%r < b) =>\n  (0%r <= p) =>\n      a = b * c - b * p \\/  a = b * c + b * p\n   =>   `|a / b - c| = p.\nsmt(@Real).\nqed.\n\n\nlocal lemma ots' (a c : real) : \n  (0%r <= a) =>\n  (0%r <= c <= 1%r) =>\n  a * c  <= a.\nproof. smt(). qed.\n\n\nlemma abs_val_ineq1 (a b c e : real) : \n  (0%r <= b <= 1%r) =>\n  (0%r <= c <= 1%r) =>\n  `|a - c * b| <= e\n    => `|a - b| <= e + (1%r-c).\nprogress.\nhave f : b = c * b + (1%r-c)*b. smt().\n    + case (a <= c * b). \n    move => H8.\n    have f2: c * b - a <= e. smt().\n    have f22 : c * b - a >= 0%r. smt().\n    have f3: c * b - a + (1%r - c)*b <= e + (1%r - c)*b.\n    smt().  \n    have f33 : c * b - a + (1%r - c)*b >= 0%r. smt().\n    have f4: b - a <= e + (1%r - c)*b.\n    smt().\n    have f5: b - a <= e + (1%r - c).\n    smt(@RealExp).\n    have f44: b - a >= 0%r.\n    smt().\n    smt().\n + move => H8.\nhave : c*b <= a. smt().\nclear H8. move => H8.\nhave f1 : a - c * b <= e. smt().\nhave f2: c * b - a + (1%r - c)*b <= e + (1%r - c)*b. smt().\nhave f3: b - a  <= e + (1%r - c)*b. smt().\nhave f4: b - a  <= e + (1%r - c). smt(ots').\nsmt().\nqed.\n\n\nlemma abs_val_ineq2 (a b c eps : real) :  (0%r < b) => (0%r <= eps) =>\n  `|a / b - c| <= eps => \n  exists (p : real),  0%r <= p <= eps  \n  /\\ `|a / b - c| = p \n  /\\ (a = b * (c - p) \\/  a = b * (c + p)).\nsmt (oip1 oip2).\nqed.\n\n\nlemma abs_val_ineq3 (a c p : real) :  \n  (0%r <= p) =>\n   a = c - p \\/  a = c + p\n   => `|a - c| = p.\nsmt().\nqed.\nend section.\n\nlemma aux_lem : forall l n,  \n  size l = n =>\n  nseq n true <> l  =>\n  false \\in l.\nelim. smt(@List). smt(@List).\nqed.\n\n\nsection.\nlocal lemma kiki2 ['a] : forall (l : 'a list), \n  unzip1 (map (fun (x : 'a) => (x, x)) l) = l.\nelim. smt(). smt().\nqed.\n\n\nlocal lemma kiki3 ['a] x :  forall (l : 'a list), uniq l => !(x \\in l) =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = [].\nelim. smt().\nprogress. \nsmt().\nqed.\n\n\nlocal lemma kiki4 ['a] x :  forall (l : 'a list), uniq l => x \\in l =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = (x, x) :: [].\nelim. smt().\nmove => y H2 H3 H4 H5. \ncase (x = y).\nmove => H6. rewrite H6. simplify.\n have f : !(x \\in H2). smt().\napply  (kiki3 y). smt(). smt().\nmove => q. rewrite q. simplify. apply H3. smt(). smt().\nqed.\n\n\nlocal lemma kiki0 ['a] : forall (l1 l2 : 'a list), size l1 <= size l2 => uniq l1 => uniq l2 => (forall x, x \\in l1 => x \\in l2) =>\n  (filter (fun x => fst x = snd x) (allpairs (fun (c1 c2 : 'a) => (c1, c2)) l1 l2)) = map (fun x => (x , x)) l1 .\nproof. elim. smt().\nprogress.\nrewrite allpairs_consl. simplify.\nrewrite filter_cat. \nrewrite  (kiki4 x). auto. smt(). simplify.\nsmt (filter_cat kiki4).\nqed.\n\n\nlemma cart2_diag_unzip1 ['a] (l : 'a list) : uniq l =>\n  unzip1 (filter (fun x => fst x = snd x) ((allpairs (fun x y => (x,y))) l l)) = l.\nmove => q.\nrewrite /cartprod2.  rewrite kiki0;auto.\nrewrite kiki2. auto. \nqed.\nend section.\n\n\n\n\ntheory Splitcases.\n\nrequire import Finite.\nrequire MeansWithParameter.\ntype ____(TYPE_0)____.\n\nsection.\nclone import MeansWithParameter with type argt <- argt,\n                                           type output <- bool,\n                                           type input <- bool,\n                                           op ____(OP_0)____ <- duniform [true; false].\n\n\nlemma splitcases:\n  forall (T <: Worker) &m (x : argt),\n    Pr[Rand(T).main(x) @ &m : res.`2] =\n    Pr[T.work(x,false) @ &m : res] / 2%r +\n    Pr[T.work(x,true) @ &m : res] / 2%r.\nprogress.\nrewrite (Mean_uni T &m (fun _ _ x => x) (1%r/2%r)). progress. \nrewrite duniform1E. smt().\nsmt(@Finite).\nprogress. simplify.\nhave ->: (support (duniform [true; false])) = (fun x => true). smt(@Distr).\npose lst := (to_seq (fun _ => true)).\nhave f1 :  false \\in lst. smt(@Finite @Distr).\nhave f2 :  true \\in lst . smt(@Finite @Distr).\nhave f3 : size lst = 2. rewrite /lst.\nrewrite -  Bool.BoolFin.count_mem.\napply uniq_to_seq.  rewrite /is_finite.\nexists [false; true]. progress. smt(). simplify. smt().\nauto.\nhave f4 : forall (l : bool list), false \\in l => true \\in l => size l = 2 => l = [false ; true] \\/ l = [true ; false]. \nelim. smt(). move => x0. elim.  progress. move => x1. elim. smt().\nprogress. smt(@List).\nhave f5 : lst = [false;  true] \\/ lst = [true ; false].  smt().\ncase (lst = [false; true]). move => z. rewrite z.\nsmt().\nprogress. have ->: lst = [true ; false]. smt().\nsmt().\nqed.\nend section.\nend Splitcases.",
        "complete:": "require import DJoin.\nrequire import AllCore Distr FSet StdRing StdOrder StdBigop List RealExp.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n   \n\n\nlemma big_reindex f (c e : int) :  big predT f (range 0 e) \n = big predT (fun i => f (i - c)) (range c (e + c)) .\nrewrite (big_reindex predT f (fun x => x - c) (fun x => x + c) ).\nsmt().\nhave ->: (predT \\o transpose Int.(+) (-c)) = predT.\nsmt().\nhave ->: (f \\o transpose Int.(+) (-c)) = (fun (i : int) => f (i - c)).\nsmt().\nhave ->: (map (transpose Int.(+) c) (range 0 e)) = \n  range c (e + c).\nhave ->: (transpose Int.(+) c) = (+) c. smt().\nrewrite - (range_add 0 e c). auto.\nauto.\nqed.\n\n\nlemma big_formula_p p  : 0%r <= p <= 1%r => forall n, 0 <= n  =>\n bigi predT (fun (i : int) => p^i * (1%r-p) ) 0 n = 1%r - p^ n.\nmove => pa.  apply ge0ind. \nprogress. smt().\nprogress.\nhave ->: 1%r - p ^ 0 = 0%r. smt(@Real).\nsmt(@List).\nprogress.\nrewrite big_int_recr. auto. simplify.\nrewrite H0. auto.  smt(@Real).\nqed.\n\n\nlemma big_formula_1mp p  : 0%r <= p <= 1%r => forall n, 0 <= n  =>\n bigi predT (fun (i : int) => (1%r-p)^i * p) 0 n = 1%r - (1%r-p)^ n.\nsmt (big_formula_p).\nqed.\n\n\nlemma big_split_min ['a]:\n  forall (P0 : 'a -> bool) (F1 F2 : 'a -> real) (s : 'a list),\n    big P0 (fun (i : 'a) => F1 i - F2 i) s = big P0 F1 s - big P0 F2 s.\nproof.  progress.\nhave ->:  - big P0 F2 s\n =  (big P0 (fun x => - (F2 x) ) s).\napply (big_ind2 (fun (x : real) y => (- x) = y) ) .\nsmt(). smt().\nprogress.\napply big_split.\nqed.\n\n\nlemma multn p  : 0%r <= p <= 1%r => forall n, 0 <= n => 0%r <= p^n <= 1%r.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. smt(@Real).\nsmt(@Real).\nqed.\n\n\nlemma multn2 (p q : real)  :  0%r <= p <= q => forall n, 0 <= n => p^n <= q^n.\nmove => cs.  apply ge0ind. smt().\nsmt(@Real).\nsimplify. progress. \nhave ->: p ^ (n + 1) = p * p^n. smt(@Real).\nhave ->: q ^ (n + 1) = q * q^n. smt(@Real).\nsmt(@RealExp).\nqed.\n\n\nlemma big_geq0 p  : 0%r <= p <= 1%r => forall n, \n 0%r <= bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt (multn).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma big_leq1 p  : 0%r <= p <= 1%r => forall n, \n bigi predT (fun (i : int) => (1%r-p) ^ i * p) 0 n <= 1%r.\nmove => cs n.\ncase (0 <= n). move=> ma.\nrewrite  big_formula_1mp.  auto. auto. smt(@RealExp).\nmove => q. \nhave : n < 0. smt().\nmove => qq.\nrewrite big_geq. smt(). auto.\nqed.\n\n\nlemma djoinmap_weight (d : 'a -> 'b distr) :  forall l,\n  (forall x, is_lossless (d x)) =>\n    weight (djoinmap d l) = 1%r.\nelim. smt (weight_djoin_nil).\nsmt (weight_djoin_cons).\nqed.\n\n\nlemma sub_all ['a]:\n   forall (p1 p2 : 'a -> bool) (s : 'a list),\n     (forall (x : 'a), p1 x => p2 x) => all p1 s => all p2 s.\nmove => p1 p2.  elim. smt().\nsmt().\nqed.\n\n\nlemma take_zip ['a 'b] : \n   forall  (n :  int) (l1 : 'a list)(l2 : 'b list),\n   zip (take n l1) (take n l2) \n  = take n (zip l1 l2).\napply ge0ind. smt().\nsmt().\nprogress.\ncase (l1 = []).\nsmt().\nprogress.\nhave f1 : exists a1 l1', l1 = (a1 :: l1').\nclear H0 H.  \nexists (head witness l1) (behead l1).\nsmt().\nelim f1.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify.\ncase (l2 = []).\nsmt().\nprogress. \nhave f2 : exists a2 l2', l2 = (a2 :: l2').\nexists (head witness l2) (behead l2).\nsmt().\nelim f2.\nprogress. \nhave -> : (n + 1 <= 0) = false.\nsmt(). simplify. smt().\nqed.\n\n\nlemma ler_trans1 (a b c : real) : a <= b => b <= c => a <= c. by smt().\nqed.\n\n\nsection.\nlocal lemma oip1 (a b c eps : real) :  (0%r <= eps) =>\n  `|a / b - c| <= eps\n => exists (p : real), 0%r <= p <= eps  /\\ `|a / b - c| = p.\nsmt().\nqed.\n\n\nlocal lemma oip2 (a b c p : real) :  \n  (0%r < b) =>\n  `|a / b - c| = p =>\n      a = b * c - b * p \\/  a = b * c + b * p.\nsmt().\nqed.\n\n\nlocal lemma oip2b (a b c p : real) :  \n  (0%r < b) =>\n  (0%r <= p) =>\n      a = b * c - b * p \\/  a = b * c + b * p\n   =>   `|a / b - c| = p.\nsmt(@Real).\nqed.\n\n\nlocal lemma ots' (a c : real) : \n  (0%r <= a) =>\n  (0%r <= c <= 1%r) =>\n  a * c  <= a.\nproof. smt(). qed.\n\n\nlemma abs_val_ineq1 (a b c e : real) : \n  (0%r <= b <= 1%r) =>\n  (0%r <= c <= 1%r) =>\n  `|a - c * b| <= e\n    => `|a - b| <= e + (1%r-c).\nprogress.\nhave f : b = c * b + (1%r-c)*b. smt().\n    + case (a <= c * b). \n    move => H8.\n    have f2: c * b - a <= e. smt().\n    have f22 : c * b - a >= 0%r. smt().\n    have f3: c * b - a + (1%r - c)*b <= e + (1%r - c)*b.\n    smt().  \n    have f33 : c * b - a + (1%r - c)*b >= 0%r. smt().\n    have f4: b - a <= e + (1%r - c)*b.\n    smt().\n    have f5: b - a <= e + (1%r - c).\n    smt(@RealExp).\n    have f44: b - a >= 0%r.\n    smt().\n    smt().\n + move => H8.\nhave : c*b <= a. smt().\nclear H8. move => H8.\nhave f1 : a - c * b <= e. smt().\nhave f2: c * b - a + (1%r - c)*b <= e + (1%r - c)*b. smt().\nhave f3: b - a  <= e + (1%r - c)*b. smt().\nhave f4: b - a  <= e + (1%r - c). smt(ots').\nsmt().\nqed.\n\n\nlemma abs_val_ineq2 (a b c eps : real) :  (0%r < b) => (0%r <= eps) =>\n  `|a / b - c| <= eps => \n  exists (p : real),  0%r <= p <= eps  \n  /\\ `|a / b - c| = p \n  /\\ (a = b * (c - p) \\/  a = b * (c + p)).\nsmt (oip1 oip2).\nqed.\n\n\nlemma abs_val_ineq3 (a c p : real) :  \n  (0%r <= p) =>\n   a = c - p \\/  a = c + p\n   => `|a - c| = p.\nsmt().\nqed.\nend section.\n\nlemma aux_lem : forall l n,  \n  size l = n =>\n  nseq n true <> l  =>\n  false \\in l.\nelim. smt(@List). smt(@List).\nqed.\n\n\nsection.\nlocal lemma kiki2 ['a] : forall (l : 'a list), \n  unzip1 (map (fun (x : 'a) => (x, x)) l) = l.\nelim. smt(). smt().\nqed.\n\n\nlocal lemma kiki3 ['a] x :  forall (l : 'a list), uniq l => !(x \\in l) =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = [].\nelim. smt().\nprogress. \nsmt().\nqed.\n\n\nlocal lemma kiki4 ['a] x :  forall (l : 'a list), uniq l => x \\in l =>\n filter (fun x => fst x = snd x)  (map ((fun (c1 c2 : 'a) => (c1, c2)) x) l)  = (x, x) :: [].\nelim. smt().\nmove => y H2 H3 H4 H5. \ncase (x = y).\nmove => H6. rewrite H6. simplify.\n have f : !(x \\in H2). smt().\napply  (kiki3 y). smt(). smt().\nmove => q. rewrite q. simplify. apply H3. smt(). smt().\nqed.\n\n\nlocal lemma kiki0 ['a] : forall (l1 l2 : 'a list), size l1 <= size l2 => uniq l1 => uniq l2 => (forall x, x \\in l1 => x \\in l2) =>\n  (filter (fun x => fst x = snd x) (allpairs (fun (c1 c2 : 'a) => (c1, c2)) l1 l2)) = map (fun x => (x , x)) l1 .\nproof. elim. smt().\nprogress.\nrewrite allpairs_consl. simplify.\nrewrite filter_cat. \nrewrite  (kiki4 x). auto. smt(). simplify.\nsmt (filter_cat kiki4).\nqed.\n\n\nlemma cart2_diag_unzip1 ['a] (l : 'a list) : uniq l =>\n  unzip1 (filter (fun x => fst x = snd x) ((allpairs (fun x y => (x,y))) l l)) = l.\nmove => q.\nrewrite /cartprod2.  rewrite kiki0;auto.\nrewrite kiki2. auto. \nqed.\nend section.\n\n\n\n\ntheory Splitcases.\n\nrequire import Finite.\nrequire MeansWithParameter.\ntype argt.\n\nsection.\nclone import MeansWithParameter with type argt <- argt,\n                                           type output <- bool,\n                                           type input <- bool,\n                                           op d <- duniform [true; false].\n\n\nlemma splitcases:\n  forall (T <: Worker) &m (x : argt),\n    Pr[Rand(T).main(x) @ &m : res.`2] =\n    Pr[T.work(x,false) @ &m : res] / 2%r +\n    Pr[T.work(x,true) @ &m : res] / 2%r.\nprogress.\nrewrite (Mean_uni T &m (fun _ _ x => x) (1%r/2%r)). progress. \nrewrite duniform1E. smt().\nsmt(@Finite).\nprogress. simplify.\nhave ->: (support (duniform [true; false])) = (fun x => true). smt(@Distr).\npose lst := (to_seq (fun _ => true)).\nhave f1 :  false \\in lst. smt(@Finite @Distr).\nhave f2 :  true \\in lst . smt(@Finite @Distr).\nhave f3 : size lst = 2. rewrite /lst.\nrewrite -  Bool.BoolFin.count_mem.\napply uniq_to_seq.  rewrite /is_finite.\nexists [false; true]. progress. smt(). simplify. smt().\nauto.\nhave f4 : forall (l : bool list), false \\in l => true \\in l => size l = 2 => l = [false ; true] \\/ l = [true ; false]. \nelim. smt(). move => x0. elim.  progress. move => x1. elim. smt().\nprogress. smt(@List).\nhave f5 : lst = [false;  true] \\/ lst = [true ; false].  smt().\ncase (lst = [false; true]). move => z. rewrite z.\nsmt().\nprogress. have ->: lst = [true ; false]. smt().\nsmt().\nqed.\nend section.\nend Splitcases."
    },
    {
        "file": "EC-1/BarrettRedInt.ec",
        "incomplete": "require import RealExp CoreReal Real StdOrder.\n\nimport RealOrder.\n\n\nop r(n k : real) : real = (floor (4%r^k  / n))%r .\nop t' (x n k : real) = (floor (x * r n k / 4%r^k))%r.\nop t (x n k : real)  : real = x - (t' x n k) * n.\n\n\n\nlemma r_pos n (k : real): \n   0%r <= n < 2%r^k =>\n  r n k >= 0%r. rewrite /r. move => Q. smt(@Real @RealExp).  qed.\n\n  \nlemma nn_bound n (k : real) : \n  0%r <= n < 2%r^k =>\n  n*n < 4%r^k. \n  have -> : 4%r = 2%r ^ 2%r. smt(@RealExp).\n  have -> : 2%r ^ 2%r ^ k = (2%r ^ k) * (2%r ^ k). smt(@RealExp).\n  smt().\nqed.  \n\n\nlemma st1 ____(LEMMA_1)____ (k : real) : (____(LEMMA_0)____ / ____(LEMMA_2)____ - 1%r) < r ____(LEMMA_3)____ k <= (4%r^k / n).\nsmt(floor_bound @RealExp).\nqed.\n\n\nlemma st2 x n (k : real) : x >= 0%r =>\n 0%r <= n < 2%r^k =>\n  x * (4%r^k / n - 1%r) <= x * r n k <= x* (4%r^k / n).\nmove => x_pos [n_bound1  n_bound2].\nrewrite /r.\nsplit.\ncase (x = 0%r). progress. \nmove => xnz.\napply ler_pmul2l. smt(). \nsmt(@Real @RealExp). \nmove => _.\ncase (x = 0%r). progress. \nmove => xnz.\napply ler_pmul2l. smt(). \nsmt(@Real). \nqed.\n\n\nlemma st3 x n (k : real) : x >= 0%r =>  0%r <= n < 2%r^k =>\n  (x / n) - (x / 4%r^k)\n    <= (x * r n k) / 4%r^k\n    <= x / n.\nmove => x_pos [n_bound1 n_bound2].\nhave ->: (x / n) - (x / 4%r^k) = (x * (4%r^k / n - 1%r)) / 4%r^k.\nsimplify.\n  pose a := 4%r ^ k. smt(@RealExp @Real).\nhave ->:  x / n = (x* (4%r^k / n)) / 4%r^k.\n  pose a := 4%r ^ k. smt(@RealExp @Real).\nsplit.\nprogress.\nsmt(ler_pmul2r st2  invr_gt0 rpow_gt0).\nmove => _. \napply ler_pmul2r. \nsmt(invr_gt0 rpow_gt0 ).\nsmt(st2).\nqed.\n\n\nlemma st4_1 x n (k : real) : \n   0%r <= n < 2%r^k =>\n   0%r <= x < n * n => \n   x / 4%r^k < 1%r. \nmove => [n_bound1 n_bound2] x_bound.\nhave : x < 4%r ^ k. smt(nn_bound).\nclear n_bound1 n_bound2.\nmove => p. smt().\nqed.\n\n \nlemma st4 x n (k : real) : \n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n  (x / n) - 1%r\n    <= (x * r n k) / 4%r^k\n       <= x / n.\nmove => n_bnds x_pos.\nsplit.\nhave x_lt1 : x / 4%r^k < 1%r. smt(st4_1).\nsmt(st3).\nmove => _. smt(st3).\nqed.\n\nrequire import FloorCeil.\nlemma st6 x n (k : real) : \n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n x - 2%r * n < t' x n k * n <= x.\nproof. move => x_bounds n_bounds.\n  have st5_1 : x / n - 2%r < (floor (x / n - 1%r)) %r.\n  smt(@Real).\n  have st5_2 : (floor (x / n - 1%r)) %r <= t' x n k.\n  rewrite /t'.\n  apply le_fromint. \n  apply floor_mono.  \n  smt(st4).\n  have st5_3: t' x n k <= x / n.\n  rewrite /t'.\n  smt (st4 floor_le).\nsplit.\n  have tr : x / n - 2%r  < t' x n k. smt(@Real). \n  have -> : (x - 2%r * n) = (x/n - 2%r)  * n. smt().\n  smt().\nmove => _.\nsmt(@RealOrder).\nqed.\n\n\nlemma st7 x n (k : real) : \n  0%r <= x < n *  n =>\n  0%r <= n < 2%r^k =>\n  -x  <= - t' x n k * n < 2%r*n - x.\nmove => x_bounds n_bounds.\nsplit.\napply ler_opp2. smt(st6).\nmove => _.\napply ltr_opp2. simplify.\nhave ->: - (2%r * n - x)\n  = (x - 2%r * n). smt().\nsmt(st6).\nqed.\n\n\nlemma barrett_bound x n (k : real) :\n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n  0%r  <= t x n k < 2%r*n .\nsmt(st7). qed.\n\n\n\nrequire import Int IntDiv.\nimport Ring.IntID.\n\nop ri(n k : int) : int = (4^k  %/ n).\nop ti' (____(OP_1)____ n k : ____(OP_0)____) : int = (x ____(OP_2)____ ri n k %/ 4^k).\nop ti (x n k : int)  : int = x - (ti' x n k) * n.\n\nlemma divz_eqP (m d n : int) :\n  0 < d => m %/ d = n <=> n * d <= m < (n + 1) * d.\nproof. smt(@IntDiv).\nqed.\n\nlemma floor_div1 a b : 0 < b => a %/ b = floor (a%r / b%r).\nmove => qp.\napply (divz_eqP     a b (floor (a%r / b%r)) qp).\nprogress. \nhave h1 : (floor (a%r / b%r))%r <= a%r / b%r.\nsmt (floor_bound).\nprogress. \nhave h2 : (a%r / b%r) * b%r <= a%r. smt().\nsmt(@Real).\nhave h1 : a%r < (floor (a%r / b%r) + 1)%r * b%r.\nsmt (floor_bound).\nprogress. \nhave h2 : a%r < ((a%r / b%r) + 1%r) * b%r. smt().\nsmt().\nqed.\n\n\nlemma mult_lemma1 a b : a%r * b%r = (a * b)%r.\nsmt(). qed.\n\nrequire import RealExp.\n\n\nlemma exp_lemma1 a :  0 < a => forall  b, 0 <= b  => a%r ^ b%r = (a ^ b)%r.\nmove => apos. apply intind.\nsimplify. smt(@RealExp @Ring).\nprogress. \nhave -> : (a ^ (i + 1)) = a * a ^ i. smt(@Ring).\nhave -> : (a * a ^ i)%r = a%r * (a^i) %r. \nsmt(@Ring).\nrewrite - H0. simplify. \nhave -> : (i + 1)%r = i%r + 1%r. smt().\nrewrite rpowD. smt(). smt(@Real @RealExp).\nqed.\n\n\nlemma same_ri (n k : int) : 0 < n => 0 <= k =>\n  r n%r k%r = (ri n k)%r.\nmove => npos kpos.\nrewrite /r /ri.\ncongr.\nrewrite floor_div1. auto.\ncongr. congr.\napply exp_lemma1. auto. auto.\nqed.\n\n\nlemma same_t' (x n k : int) : 0 < n => 0 <= k =>\n  t' x%r n%r k%r = (ti' x n k)%r.\nmove => npos kpos.\nrewrite /t' /ti'.\nrewrite same_ri. auto. auto.\ncongr.\nrewrite floor_div1. smt(@Ring @StdOrder).\ncongr. congr.\nsmt().\nrewrite exp_lemma1. auto. auto. auto.\nqed.\n\n\nlemma same_t (x n k : int) : 0 < n => 0 <= k =>\n  t x%r n%r k%r = (ti x n k)%r.\nprogress.\nrewrite /t /ti. rewrite same_t'. auto. auto.\nsmt().\nqed.\n\n\nop barrett_reduction (x n k : int) \n  = let r = ti x n k in (if r < n then r else r - n).\n\n  \nlemma barrett_reduction_correct (x n k : int) : \n   0 <= x < n*n\n   => 0 < n < 2^k\n   => 0 <= k\n   => barrett_reduction x n k = x %% n.\nrewrite /barrett_reduction.\nsimplify.\nhave timn :  ti x n k %% n = x %% n.\nrewrite /ti. \nrewrite - modzDm.\nhave ->: (- ti' x n k * n) %% n  = 0. \n  have -> : (- ti' x n k * n) = (- ti' x n k) * n.  smt().\nrewrite - modzMml. \nrewrite modzMl. auto.\nsimplify. apply modz_mod.\ncase (ti x n k < n).\nprogress. rewrite - timn.\nrewrite modz_small.\n progress.\n  have : 0%r <= (ti x n k)%r.\n  rewrite - same_t. smt(). smt(). \n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress.  smt(). smt(). split. smt(). move => q. smt(exp_lemma1).\n  elim kk. auto. smt().\n  have -> : `|n| = n. smt().\n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress.  smt(). smt(). smt(exp_lemma1).  smt(). auto.\nprogress.\nhave :  (ti x n k)%r < (2 * n)%r.\nrewrite - same_t. smt(). smt().\n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress. smt(). smt(). smt(exp_lemma1).  \n  smt(). smt(). \nqed.",
        "complete:": "require import RealExp CoreReal Real StdOrder.\n\nimport RealOrder.\n\n\nop r(n k : real) : real = (floor (4%r^k  / n))%r .\nop t' (x n k : real) = (floor (x * r n k / 4%r^k))%r.\nop t (x n k : real)  : real = x - (t' x n k) * n.\n\n\n\nlemma r_pos n (k : real): \n   0%r <= n < 2%r^k =>\n  r n k >= 0%r. rewrite /r. move => Q. smt(@Real @RealExp).  qed.\n\n  \nlemma nn_bound n (k : real) : \n  0%r <= n < 2%r^k =>\n  n*n < 4%r^k. \n  have -> : 4%r = 2%r ^ 2%r. smt(@RealExp).\n  have -> : 2%r ^ 2%r ^ k = (2%r ^ k) * (2%r ^ k). smt(@RealExp).\n  smt().\nqed.  \n\n\nlemma st1 n (k : real) : (4%r^k / n - 1%r) < r n k <= (4%r^k / n).\nsmt(floor_bound @RealExp).\nqed.\n\n\nlemma st2 x n (k : real) : x >= 0%r =>\n 0%r <= n < 2%r^k =>\n  x * (4%r^k / n - 1%r) <= x * r n k <= x* (4%r^k / n).\nmove => x_pos [n_bound1  n_bound2].\nrewrite /r.\nsplit.\ncase (x = 0%r). progress. \nmove => xnz.\napply ler_pmul2l. smt(). \nsmt(@Real @RealExp). \nmove => _.\ncase (x = 0%r). progress. \nmove => xnz.\napply ler_pmul2l. smt(). \nsmt(@Real). \nqed.\n\n\nlemma st3 x n (k : real) : x >= 0%r =>  0%r <= n < 2%r^k =>\n  (x / n) - (x / 4%r^k)\n    <= (x * r n k) / 4%r^k\n    <= x / n.\nmove => x_pos [n_bound1 n_bound2].\nhave ->: (x / n) - (x / 4%r^k) = (x * (4%r^k / n - 1%r)) / 4%r^k.\nsimplify.\n  pose a := 4%r ^ k. smt(@RealExp @Real).\nhave ->:  x / n = (x* (4%r^k / n)) / 4%r^k.\n  pose a := 4%r ^ k. smt(@RealExp @Real).\nsplit.\nprogress.\nsmt(ler_pmul2r st2  invr_gt0 rpow_gt0).\nmove => _. \napply ler_pmul2r. \nsmt(invr_gt0 rpow_gt0 ).\nsmt(st2).\nqed.\n\n\nlemma st4_1 x n (k : real) : \n   0%r <= n < 2%r^k =>\n   0%r <= x < n * n => \n   x / 4%r^k < 1%r. \nmove => [n_bound1 n_bound2] x_bound.\nhave : x < 4%r ^ k. smt(nn_bound).\nclear n_bound1 n_bound2.\nmove => p. smt().\nqed.\n\n \nlemma st4 x n (k : real) : \n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n  (x / n) - 1%r\n    <= (x * r n k) / 4%r^k\n       <= x / n.\nmove => n_bnds x_pos.\nsplit.\nhave x_lt1 : x / 4%r^k < 1%r. smt(st4_1).\nsmt(st3).\nmove => _. smt(st3).\nqed.\n\nrequire import FloorCeil.\nlemma st6 x n (k : real) : \n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n x - 2%r * n < t' x n k * n <= x.\nproof. move => x_bounds n_bounds.\n  have st5_1 : x / n - 2%r < (floor (x / n - 1%r)) %r.\n  smt(@Real).\n  have st5_2 : (floor (x / n - 1%r)) %r <= t' x n k.\n  rewrite /t'.\n  apply le_fromint. \n  apply floor_mono.  \n  smt(st4).\n  have st5_3: t' x n k <= x / n.\n  rewrite /t'.\n  smt (st4 floor_le).\nsplit.\n  have tr : x / n - 2%r  < t' x n k. smt(@Real). \n  have -> : (x - 2%r * n) = (x/n - 2%r)  * n. smt().\n  smt().\nmove => _.\nsmt(@RealOrder).\nqed.\n\n\nlemma st7 x n (k : real) : \n  0%r <= x < n *  n =>\n  0%r <= n < 2%r^k =>\n  -x  <= - t' x n k * n < 2%r*n - x.\nmove => x_bounds n_bounds.\nsplit.\napply ler_opp2. smt(st6).\nmove => _.\napply ltr_opp2. simplify.\nhave ->: - (2%r * n - x)\n  = (x - 2%r * n). smt().\nsmt(st6).\nqed.\n\n\nlemma barrett_bound x n (k : real) :\n  0%r <= x < n * n =>\n  0%r <= n < 2%r^k =>\n  0%r  <= t x n k < 2%r*n .\nsmt(st7). qed.\n\n\n\nrequire import Int IntDiv.\nimport Ring.IntID.\n\nop ri(n k : int) : int = (4^k  %/ n).\nop ti' (x n k : int) : int = (x * ri n k %/ 4^k).\nop ti (x n k : int)  : int = x - (ti' x n k) * n.\n\nlemma divz_eqP (m d n : int) :\n  0 < d => m %/ d = n <=> n * d <= m < (n + 1) * d.\nproof. smt(@IntDiv).\nqed.\n\nlemma floor_div1 a b : 0 < b => a %/ b = floor (a%r / b%r).\nmove => qp.\napply (divz_eqP     a b (floor (a%r / b%r)) qp).\nprogress. \nhave h1 : (floor (a%r / b%r))%r <= a%r / b%r.\nsmt (floor_bound).\nprogress. \nhave h2 : (a%r / b%r) * b%r <= a%r. smt().\nsmt(@Real).\nhave h1 : a%r < (floor (a%r / b%r) + 1)%r * b%r.\nsmt (floor_bound).\nprogress. \nhave h2 : a%r < ((a%r / b%r) + 1%r) * b%r. smt().\nsmt().\nqed.\n\n\nlemma mult_lemma1 a b : a%r * b%r = (a * b)%r.\nsmt(). qed.\n\nrequire import RealExp.\n\n\nlemma exp_lemma1 a :  0 < a => forall  b, 0 <= b  => a%r ^ b%r = (a ^ b)%r.\nmove => apos. apply intind.\nsimplify. smt(@RealExp @Ring).\nprogress. \nhave -> : (a ^ (i + 1)) = a * a ^ i. smt(@Ring).\nhave -> : (a * a ^ i)%r = a%r * (a^i) %r. \nsmt(@Ring).\nrewrite - H0. simplify. \nhave -> : (i + 1)%r = i%r + 1%r. smt().\nrewrite rpowD. smt(). smt(@Real @RealExp).\nqed.\n\n\nlemma same_ri (n k : int) : 0 < n => 0 <= k =>\n  r n%r k%r = (ri n k)%r.\nmove => npos kpos.\nrewrite /r /ri.\ncongr.\nrewrite floor_div1. auto.\ncongr. congr.\napply exp_lemma1. auto. auto.\nqed.\n\n\nlemma same_t' (x n k : int) : 0 < n => 0 <= k =>\n  t' x%r n%r k%r = (ti' x n k)%r.\nmove => npos kpos.\nrewrite /t' /ti'.\nrewrite same_ri. auto. auto.\ncongr.\nrewrite floor_div1. smt(@Ring @StdOrder).\ncongr. congr.\nsmt().\nrewrite exp_lemma1. auto. auto. auto.\nqed.\n\n\nlemma same_t (x n k : int) : 0 < n => 0 <= k =>\n  t x%r n%r k%r = (ti x n k)%r.\nprogress.\nrewrite /t /ti. rewrite same_t'. auto. auto.\nsmt().\nqed.\n\n\nop barrett_reduction (x n k : int) \n  = let r = ti x n k in (if r < n then r else r - n).\n\n  \nlemma barrett_reduction_correct (x n k : int) : \n   0 <= x < n*n\n   => 0 < n < 2^k\n   => 0 <= k\n   => barrett_reduction x n k = x %% n.\nrewrite /barrett_reduction.\nsimplify.\nhave timn :  ti x n k %% n = x %% n.\nrewrite /ti. \nrewrite - modzDm.\nhave ->: (- ti' x n k * n) %% n  = 0. \n  have -> : (- ti' x n k * n) = (- ti' x n k) * n.  smt().\nrewrite - modzMml. \nrewrite modzMl. auto.\nsimplify. apply modz_mod.\ncase (ti x n k < n).\nprogress. rewrite - timn.\nrewrite modz_small.\n progress.\n  have : 0%r <= (ti x n k)%r.\n  rewrite - same_t. smt(). smt(). \n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress.  smt(). smt(). split. smt(). move => q. smt(exp_lemma1).\n  elim kk. auto. smt().\n  have -> : `|n| = n. smt().\n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress.  smt(). smt(). smt(exp_lemma1).  smt(). auto.\nprogress.\nhave :  (ti x n k)%r < (2 * n)%r.\nrewrite - same_t. smt(). smt().\n  have kk : 0%r <= t x%r n%r k%r && t x%r n%r k%r < 2%r * n%r.\n  apply barrett_bound. progress. progress. smt(). smt(). smt(exp_lemma1).  \n  smt(). smt(). \nqed."
    },
    {
        "file": "EC-1/BarrettReduction_Abstract.ec",
        "incomplete": "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n\n(* equiv mulm_eq: *)\n(*  CSpecFp.mulm ~ ASpecFp.mulm:  *)\n(*   a{1} = Zp.asint a{2} /\\ b{1} = Zp.asint b{2} /\\ p{1} = Zp.p *)\n(*     ==> res{1} = Zp.asint res{2}. *)\n(* proof.  proc. inline*. wp.  skip. progress. *)\n(* smt(@Zp). *)\n(* qed. *)\n\n\n(* parameter for the Barrett reduction  *)\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm: ={a, p} /\\ r{2} = (4 ^ k{2} %/ p{2}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  /\\ 0 <= k{2} ==> ={res}.\nproc. inline*. wp. skip. progress.\nrewrite -  (barrett_reduction_correct a{2} p{2} k{2} ). auto. auto.  auto. \nrewrite /barrett_reduction. simplify. rewrite /ti. rewrite /ti'. rewrite /ri.\nhave ->: 2 ^ (2 * k{2}) = 4 ^ k{2}. smt(@Real).\nhave <-:  a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = (a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  %%  2 ^ k{2} * p{2}) %% W64x2N.modulusR.\nrewrite modz_small.\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \napply divz_ge0. \nsmt(exprn_ege1).\nrewrite /ri. \n  have : 0 <= (4 ^ k{2} %/ p{2}). apply divz_ge0.  smt(). smt(exprn_ege1). smt().\n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r. \n   apply st6. smt(). split. smt().  move => ?. rewrite  exp_lemma1. auto. auto. smt(@Real).\n  smt(). smt(). auto.\nhave -> : a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = ti a{2} p{2} k{2}. rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nsplit. \n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto.\n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split.  smt(). smt(). smt(exp_lemma1).\n  progress. smt(). \nmove => _.\nhave ->: `|W64xN.modulusR2| = W64xN.modulusR2. rewrite /W64xN.modulusR2. smt(@Ring).\n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto. \n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split. smt(). smt().\nsplit. smt(). move => ?. smt(exp_lemma1).\n  progress. \n   have : 2 * p{2} < W64xN.modulusR2. rewrite /W64xN.modulusR2. \n   have : W64x2N.M ^ (nlimbs) <= W64x2N.M ^ (2 * nlimbs).\n   apply ler_weexpn2l. smt(). smt().\n   have : p{2} <= W64x2N.M ^ nlimbs.\n    have ->: W64x2N.M ^ nlimbs = W64xN.modulusR. rewrite /W64xN.modulusR. auto. smt().\nsmt(). smt().\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \n  have : 0 <= ri p{2} k{2} %/ 4 ^ k{2}. apply divz_ge0. smt(exprn_ege1). rewrite /ri.\n  apply divz_ge0.  smt(). smt(exprn_ege1). smt(). \n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r.\n   apply st6. smt().  split. smt(). move => ?. smt(exp_lemma1).\n  smt().\n  smt(). auto.\nsmt().\nauto.\nqed.",
        "complete:": "require import Core Int Ring IntDiv StdOrder List Distr Real RealExp.\nimport Ring.IntID IntOrder.\n\nrequire import BarrettRedInt BigNum_spec.\n\n\n(* equiv mulm_eq: *)\n(*  CSpecFp.mulm ~ ASpecFp.mulm:  *)\n(*   a{1} = Zp.asint a{2} /\\ b{1} = Zp.asint b{2} /\\ p{1} = Zp.p *)\n(*     ==> res{1} = Zp.asint res{2}. *)\n(* proof.  proc. inline*. wp.  skip. progress. *)\n(* smt(@Zp). *)\n(* qed. *)\n\n\n(* parameter for the Barrett reduction  *)\nequiv redm_eq:\n ASpecFp.redm ~ CSpecFp.redm: ={a, p} /\\ r{2} = (4 ^ k{2} %/ p{2}) \n  /\\ 0 < p{2} < W64xN.modulusR\n  /\\ 0 <= a{2} < p{2} * p{2}\n  /\\ 0 < p{2} < 2 ^ k{2} \n  /\\ 0 <= k{2} ==> ={res}.\nproc. inline*. wp. skip. progress.\nrewrite -  (barrett_reduction_correct a{2} p{2} k{2} ). auto. auto.  auto. \nrewrite /barrett_reduction. simplify. rewrite /ti. rewrite /ti'. rewrite /ri.\nhave ->: 2 ^ (2 * k{2}) = 4 ^ k{2}. smt(@Real).\nhave <-:  a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = (a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  %%  2 ^ k{2} * p{2}) %% W64x2N.modulusR.\nrewrite modz_small.\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \napply divz_ge0. \nsmt(exprn_ege1).\nrewrite /ri. \n  have : 0 <= (4 ^ k{2} %/ p{2}). apply divz_ge0.  smt(). smt(exprn_ege1). smt().\n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r. \n   apply st6. smt(). split. smt().  move => ?. rewrite  exp_lemma1. auto. auto. smt(@Real).\n  smt(). smt(). auto.\nhave -> : a{2} - a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2} * p{2}\n = ti a{2} p{2} k{2}. rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nsplit. \n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto.\n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split.  smt(). smt(). smt(exp_lemma1).\n  progress. smt(). \nmove => _.\nhave ->: `|W64xN.modulusR2| = W64xN.modulusR2. rewrite /W64xN.modulusR2. smt(@Ring).\n   have : 0%r <= (ti a{2} p{2} k{2})%r < 2%r * p{2}%r.\n   rewrite - same_t. auto. auto. \n     apply (barrett_bound a{2}%r p{2}%r k{2}%r _ _). split. smt(). smt().\nsplit. smt(). move => ?. smt(exp_lemma1).\n  progress. \n   have : 2 * p{2} < W64xN.modulusR2. rewrite /W64xN.modulusR2. \n   have : W64x2N.M ^ (nlimbs) <= W64x2N.M ^ (2 * nlimbs).\n   apply ler_weexpn2l. smt(). smt().\n   have : p{2} <= W64x2N.M ^ nlimbs.\n    have ->: W64x2N.M ^ nlimbs = W64xN.modulusR. rewrite /W64xN.modulusR. auto. smt().\nsmt(). smt().\n have ->: a{2} * (4 ^ k{2} %/ p{2}) %/ 4 ^ k{2}  = ti' a{2} p{2} k{2}. \n  rewrite /ti. rewrite /ti'. rewrite /ri. auto.\nhave -> : ti' a{2} p{2} k{2} %% 2 ^ k{2} = ti' a{2} p{2} k{2}. \nrewrite modz_small. rewrite /ti'. split. \n  have : 0 <= ri p{2} k{2} %/ 4 ^ k{2}. apply divz_ge0. smt(exprn_ege1). rewrite /ri.\n  apply divz_ge0.  smt(). smt(exprn_ege1). smt(). \n  have ->: `|2 ^ k{2}| = 2 ^ k{2}. smt().\n  have : (ti' a{2} p{2} k{2})%r < (2 ^ k{2})%r.\n   rewrite - same_t'. auto. auto.\n  have qq :  a{2}%r - 2%r * p{2}%r < (t' a{2}%r p{2}%r k{2}%r) * p{2}%r <= a{2}%r.\n   apply st6. smt().  split. smt(). move => ?. smt(exp_lemma1).\n  smt().\n  smt(). auto.\nsmt().\nauto.\nqed."
    },
    {
        "file": "EC-1/basic-hash-unlink.ec",
        "incomplete": "(* Unlinkability of the Basic Hash protocol, multiple tags, one reader. *)\n\n(* Easycrypt: 1.0 (fa3853d3029d) *)\n(* Alt-Ergo version 2.3.3 *)\n(* Z3 4.8.4 *)\n(* CVC4 1.5 *)\n\nrequire import AllCore Int List FSet SmtMap IntDiv StdBigop Distr DBool Mu_mem.\nrequire import StdOrder.\n(*---*) import Bigint Bigreal BRA BIA IntOrder RealOrder RField.\nrequire (*---*) FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype ____(TYPE_0)____.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma ____(LEMMA_1)____ (i : int) : ____(LEMMA_0)____ dnonce by smt (dnonce_lluni).\n\nop max_n : ptxt.        (* arbitrary nonce in [dnonce] domain. *)\naxiom maxu_dnonce x: mu1 dnonce x <= mu1 dnonce max_n.\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ____(OP_1)____ -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Unforgeable multiple RF *)\n(* We assume that: \n   - i) the hash functions are indistinguishable from a lossless and uniform\n     distributions over ptxts (not full).\n   - ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is\n   large. *)\nop drf (i : int) : ptxt ____(OP_0)____.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\n(* The PRFs are all i.i.d. *)\naxiom drf_iid (i j : int) : forall (r : ptxt), mu1 (drf i) r = mu1 (drf j) r.\n\nlemma drf_sup (i j : int) : forall (r : ptxt), r \\in drf i <=> r \\in drf j \nby smt (drf_iid).\n\nhint exact random : drf_iid.\nhint ____(HINT_0)____ random : drf_sup.\nhint exact random : drf_ll.\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags (multiple sessions) and one reader. *)\n\nop n_tag : int.             (* number of tags *)\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\nop n_session : int.                 (* number of sessions per tag *)\naxiom n_session_p : 0 < n_session.  (* We have at least one session. *)\n\n(* Without initialization *)\nmodule Multiple0 (H : PRFs_Oracles) = {\n  var s_cpt : (int, int) fmap   (* Map a tag number to its session number. *)\n\n  (* Each tag runs at most n_session. *)\n  proc tag (i : int) : (ptxt * ptxt) option = {\n    var n, h, r, s_n;\n    i <- if (n_tag <= i) then 0 else i;\n    r <- None;\n\n    if (i \\in s_cpt) {\n      s_n <- oget s_cpt.[i];\n      if (s_n < n_session) {\n        n <$ dnonce;\n        h <@ H.f(i,n);\n        r <- Some (n, h);\n        s_cpt.[i] <- s_n + 1;\n      } \n    }\n    return r;\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule Multiple (H : PRFs) = {\n  module BH0 = Multiple0(H)\n  include BH0\n\n  proc init () : unit = { \n    var i;\n    H.init(n_tag); \n    \n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags (single session) and one reader. *)\n\n(* Without initialization *)\nmodule Single0 (H : PRFs_Oracles) = {\n\n  (* Each tag runs at most n_session. *)\n  proc tag (i : int) : (ptxt * ptxt) option = {\n    var n, h, r, s_n;\n    i <- if (n_tag <= i) then 0 else i;\n    r <- None;\n\n    if (i \\in Multiple0.s_cpt) {\n      s_n <- oget Multiple0.s_cpt.[i];\n      if (s_n < n_session) {\n        n <$ dnonce;\n        (* each hash function is used at most once *)\n        h <@ H.f(i * n_session + s_n,n); \n        r <- Some (n, h);\n        Multiple0.s_cpt.[i] <- s_n + 1;\n      } \n    }\n    return r;\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var r, b0, b, i, j;\n    b <- false;\n    i <- 0;\n    j <- 0;\n    b0 <- false;\n    while (i < n_tag) {\n      j <- 0;\n      b0 <- false;\n      while (j < n_session) {\n        r <- H.check(i * n_session + j, n, h);\n        b0 <- b0 || r;\n        j <- j + 1;\n      }\n      b <- b || b0;\n      i <- i + 1;\n    }\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule Single (H : PRFs) = {\n  module BH0 = Single0(H)\n  include BH0\n\n  proc init () : unit = { \n    var i;\n    H.init(n_tag * n_session); \n    \n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs, [n_tag] keys. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(* Indistinguishability game for unforgeable PRFs, [n_tag * n_session] keys. *)\nmodule EUF_PRF_INDb (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag * n_session);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : (ptxt * ptxt) option\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Adversary against the Basic Hash protocol unlinkability *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : bool\n}.\n\n\n(* Basic Hash protocol unlinkability game *)\nmodule Unlink (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    var b : bool;\n    BH.init ();\n    b <- Adv.a();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* The PRF/RF distinguisher. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    var i, b;\n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n\n    b <@ A.a();\n    return b; \n  } \n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Game-hope, PRF to RF for the multiple and single sessions protocols.  *)\n\nlemma eq_mult_RF &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, Multiple0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\nlemma eq_mult_PRF &m (A <: Adv {Multiple0, PRFs}) : \n    Pr[Unlink(A, Multiple, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with the single session protocol. *)\nlemma eq_single_RF &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim.\n\nlemma eq_single_PRF &m (A <: Adv {Multiple0, PRFs}) : \n    Pr[Unlink(A, Single, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_INDb(PRFs, D(A, Single0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim.\n\n\n(*-----------------------------------------------------------------------*)\n(* Second game-hope, where we bound the collision probability for all\n   the nonces sample by each tag.  *)\n\n(* The EUF_RF module, where we set a boolean bad to true if we hash\n   twice the same value. Since we only hash nonces, this is equivalent\n   to setting bad to true if a tag has a collision between two nonces\n   it samples.\n\n   In case of collisions, a message may have several hashes. We store\n   all possible hashes of a nonce, to be able to simulate the \"check\"\n   oracle procedure. *)\n\nmodule RF_bad = {\n  var bad : bool\n  var m : (int * ptxt, ptxt list) fmap\n\n  proc init(i : int) : unit = {\n    EUF_RF.init(i);\n    bad <- false;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (EUF_RF.n <= i) then 0 else i;\n\n    (* If we already hashed [x] under key [i], we set bad to true. *)\n    bad <- bad || (i,x) \\in m;\n\n    r <$ drf i;\n    m.[(i,x)] <- r :: odflt [] m.[(i,x)];\n    \n    return r;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (EUF_RF.n <= i) then 0 else i;\n    return ((i,x) \\in m && s \\in oget m.[(i,x)]);\n  }\n}.\n\n(* The winning probability against the unlinkability game (multiple\n   sessions) instanciated with Random Functions (EUF_RF) is equal to the\n   winning probability when instanciated with the Collision-Free Random\n   Functions (RF_bad), up-to-bad. *)\nlemma coll_multiple &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res] <=\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad].\nproof.\n  move => Hll; byequiv => //.\n  proc.\n  call(_: RF_bad.bad, \n    ={glob Single0, EUF_RF.n} /\\\n    (* (forall x i, (x,i) \\in EUF_RF.m{1} <=> (x,i) \\in RF_bad.m{2}) /\\ *)\n    (forall (x), omap (fun x => [x]) (EUF_RF.m.[(x)]{1}) = RF_bad.m.[(x)]{2})).\n  + proc; inline *; sp; if; 1,3 : by auto.\n    sp; if; 1, 3 : by auto. \n    seq 4 4 : (#pre /\\ ={n, i0, x}); 1 : by auto => /#.\n    wp; if {1}; 1 : by auto => />; smt(get_setE). \n    by auto; smt ().\n  + by move => &2 Hb; islossless.\n  + move => &2. proc; inline *; auto; sp; if; sp; auto. \n    by if; auto; smt (drf_ll dnonce_ll). \n  + proc; inline *. while (#pre /\\ ={b,i}); auto => />. \n    move => &1 &2 Hbad Hind Hle /> /#. \n  + move => &2 Hb; islossless. \n    while true (n_tag - i); auto; 2 : by smt ().\n    conseq (:true); 1 : by smt (). \n    by islossless. \n  + move => _; proc; conseq />.\n    while true (n_tag - i); auto; 2 : by smt ().\n    conseq (:true); 1 : by smt (). \n    by islossless. \n  + by inline *; sp => />; while (={i, Multiple0.s_cpt}); auto; smt (empty_valE).\nqed.\n\n(*-----------------------------------------------------------------------*)\n(* Same than the EUF_RF module, except that we set [bad] to true if we hash \n   the same value twice.  *)\nmodule EUF_RF2 = { \n  var bad : bool\n\n  proc init(i : int) : unit = {\n    EUF_RF.init(i);\n    bad <- false;\n  } \n\n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (EUF_RF.n <= i) then 0 else i;\n\n    (* If we already hashed [x] under key [i], we set bad to true. *)\n    bad <- bad || (i,x) \\in EUF_RF.m;\n\n    if ((i,x) \\notin EUF_RF.m) {\n      r <$ drf i;\n      EUF_RF.m.[(i,x)] <- r;\n    }\n    \n    return oget EUF_RF.m.[(i,x)];\n  }\n\n  proc check = EUF_RF.check\n}.\n\nlemma eq_single_RF2 &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[Unlink(A, Single, EUF_RF2).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem for the single session version of the unlinkability game. *)\nlemma coll_single &m (A <: Adv {EUF_RF, RF_bad, Multiple0, EUF_RF2}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    `| Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] -\n       Pr[Unlink(A, Single, RF_bad).main() @ &m : res] | <=\n       Pr[Unlink(A, Single, RF_bad).main() @ &m : RF_bad.bad].\nproof.  \n  move => Hll. \n  rewrite (eq_single_RF2 &m A).\n  byequiv (_ : ={glob A} ==> (EUF_RF2.bad{1} = RF_bad.bad{2}) /\\ \n                             (!RF_bad.bad{2} => ={res})) : EUF_RF2.bad => //;\n  2 : smt().\n  proc.\n  call(_: RF_bad.bad, \n    ={glob Single0, EUF_RF.n} /\\ (EUF_RF2.bad{1} = RF_bad.bad{2}) /\\\n    (* (forall x i, (x,i) \\in EUF_RF.m{1} <=> (x,i) \\in RF_bad.m{2}) /\\ *)\n    (forall (x), omap (fun x => [x]) (EUF_RF.m.[(x)]{1}) = RF_bad.m.[(x)]{2}),\n    (EUF_RF2.bad{1} = RF_bad.bad{2})).\n  + proc; inline *; sp; if; 1,3 : by auto. \n    sp; if; 1, 3 : by auto. \n    seq 4 4 : (#pre /\\ ={n, i0, x}); 1 : by auto => /> /#.\n    wp; sp. if {1}; 1 : by auto => />; smt(get_setE). \n    by auto; smt ().\n  + move => &2 Hb. \n    proc; inline *; auto; sp.\n    if; 2: by auto; smt().\n    sp; if; 2: by auto; smt().\n    seq 4 : (#pre) => //;\n    1,3 : by move => />; auto; smt(dnonce_ll). \n    seq 1 : (#post) =>//. \n    + by auto; smt(). \n    + by conseq />; islossless. \n    by hoare; auto; smt(). \n  + move => &2. proc; inline *; auto; sp; if; sp; auto. \n    by if; auto; smt (drf_ll dnonce_ll). \n  + proc; inline *; while (#pre /\\ ={b,b0,j,i}); auto => />. \n    while (#pre); auto => />. \n    by move => &1 &2 Hbad Hind Hle Hlt />; smt().\n  + move => &2 Hb. \n    proc; inline *; conseq />. \n    while true (n_tag - i); auto; 2 : by smt ().\n    while true (n_session - j); auto; 2 : by smt (). \n    by smt().\n  + move => &1. \n    proc; inline *; conseq />. \n    while true (n_tag - i); auto; 2 : by smt ().\n    while true (n_session - j); auto; 2 : by smt (). \n    by smt(). \n  + inline *; sp => />. \n    while (={i, Multiple0.s_cpt}); auto; smt (empty_valE).\nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* The probability of bad in the single sessions setting is 0,\n   since each tag hashes only one message. *)\n\n(* For the single session protocol, this should be 0. *)\nlemma coll_bound_single &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : RF_bad.bad] = 0%r.\nproof.\n  move => Hll.\n  byphoare => //; hoare.\n  proc. \n  call (_: EUF_RF.n = n_tag * n_session /\\\n     RF_bad.bad = false /\\\n     (forall (j : int), 0 <= j < n_tag <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j < n_tag => 0 <= oget Multiple0.s_cpt.[j]) /\\\n     (forall (j k : int) (x : ptxt), \n       Multiple0.s_cpt.[j] <> None => oget Multiple0.s_cpt.[j] <= k < n_session => \n         RF_bad.m.[(j * n_session + k,x)] = None)). \n  + proc; inline *; auto; sp.\n    if; 2 : by auto; smt ().\n    sp; if; 2 : by auto; smt ().\n    seq 1 :(#pre); 1 : by move => />; auto. \n    auto.\n    move => /> &hr i1. \n    pose i2 := (if n_tag <= i1 then 0 else i1).\n    move => *.\n    have -> /= : !(n_tag * n_session <= \n                   i2 * n_session + oget Multiple0.s_cpt{hr}.[i2]); \n    1 : smt (). \n    rewrite Tactics.eq_iff /dom => /=. \n    split; 1: by apply H1; smt().\n    rewrite /dom in H2; progress; 1,2,3,4 : smt (get_setE). \n    have := euclideU n_session i2 j (oget Multiple0.s_cpt{hr}.[i2]) k.\n    smt (get_setE). \n  + by conseq />; auto.\n  inline *; sp 6. \n  while (0 <= i <= n_tag /\\\n   (forall (j : int), 0 <= j && j < i <=> Multiple0.s_cpt.[j] <> None) /\\\n   (forall (j : int), 0 <= j && j < i => Multiple0.s_cpt.[j] = Some 0));\n  1 : by auto; move => /> *; smt (get_setE). \n  by auto => />; smt (empty_valE n_tag_p). \nqed.\n\nlemma coll_single_eq &m (A <: Adv {EUF_RF, RF_bad, Multiple0, EUF_RF2}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.  \n  move => Hll. \n  have H  := (coll_bound_single &m A Hll).\n  have H' := (coll_single &m A Hll).\n  smt().  \nqed.\n\n(*-----------------------------------------------------------------------*)\n(* We bound the probability of bad in the multiple sessions setting by:\n   \n       n_session^2 * n_tag * mu1 dnonce max_n\n\n   Since [dnonce] is uniform, [mu1 dnonce max_n] is 1/N, where [N] is\n   the size of the nonce space. \n   \n\n   Note that the bound could be improved to: \n\n       n_session * (n_session + 1) / 2 * n_tag * mu1 dnonce max_n\n\n   But the proof would be much more complicated: the current proof\n   using the failure event lemma, which makes us use the same counter\n   and bad event for all tags, which prevent from correctly tracking\n   the number of already hashed nonces for each tag. Currently, the\n   only way I see to circumvent this is to use the failure event lemma\n   together with a hybrid argument.  *)\n\nop pr_bad_step_r = n_session%r * mu1 dnonce max_n.\nop pr_bad_step (k : int) = pr_bad_step_r.\nop pr_bad = pr_bad_step_r * (n_session * n_tag)%r.\n\n(* Number of plain-texts hashed for tag [i]. *)\nop ptxt_hashed_l (i : int) (m : (int * ptxt, ptxt list) fmap) =\n  FSet.filter (fun x => fst x = i) (SmtMap.fdom m).\n\nop ptxt_hashed (i : int) (m : (int * ptxt, ptxt list) fmap)  =\n  FSet.card (ptxt_hashed_l i m).\n\nlemma ptxt_hashed_supp (i : int) (x : ptxt) (m : (int * ptxt, ptxt list) fmap) :\n    (i,x) \\in m <=> (i,x) \\in (ptxt_hashed_l i m)\nby rewrite /ptxt_hashed_l in_filter mem_fdom //.\n\nlemma ptxt_hashed_i (i j : int) (x : ptxt) (m : (int * ptxt, ptxt list) fmap) :\n    (j,x) \\in (ptxt_hashed_l i m) => i = j\nby rewrite /ptxt_hashed_l in_filter mem_fdom //.\n\nlemma ptxt_hashed_eq i m m' :\n    (forall x, (i,x) \\in (ptxt_hashed_l i m) <=>\n               (i,x) \\in (ptxt_hashed_l i m')) =>\n    (ptxt_hashed i m) = (ptxt_hashed i m').\nproof.\n move => H.\n rewrite /ptxt_hashed; congr.\n rewrite fsetP => -[j x].\n case (j = i) => [->|Hdeq]; smt(ptxt_hashed_i).\nqed.\n\nlemma big_if (i a b : int) : a <= i < b =>\n    bigi predT (fun (x : int) => if x = i then 1 else 0) a b = 1.\nproof.\n  move => H; rewrite (range_cat i); 1,2: smt (). \n  rewrite (range_cat (i + 1) i b); 1,2: smt (). \n  rewrite !big_cat !big_int.\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => i <= i0 && i0 < i + 1) \n       (fun (i0 : int) => i <= i0 && i0 < i + 1) \n       _ (fun x => 1) _) //; 1 : smt ().\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => a <= i0 && i0 < i)\n       (fun (i0 : int) => a <= i0 && i0 < i)\n       _ (fun x => 0) _) //; 1 : smt ().\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => i + 1 <= i0 && i0 < b)\n       (fun (i0 : int) => i + 1 <= i0 && i0 < b)\n       _ (fun x => 0) _) //; 1 : smt ().\n  by rewrite -!big_int !bigi_constz // /#. \nqed.\n\nlemma coll_bound_multiple &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad] <= pr_bad.\nproof.\n  move => Hll.\n  fel\n    1                        (* initialization phase  *)\n    (BIA.bigi \n      predT\n      (fun (k : int) => oget Multiple0.s_cpt.[k]) \n      0 n_tag)               (* counter *)\n    (fun k => pr_bad_step k) (* update to the upper-bound w.r.t. the counter *)\n    (n_tag * n_session)      (* upper-bound on the number of steps *)\n    (RF_bad.bad)             (* failure event *)\n\n                             (* pre-condition for the counter increase *)\n    [Multiple(RF_bad).tag : \n      (let j = if (n_tag <= i) then 0 else i in\n       j \\in Multiple0.s_cpt /\\ \n       oget Multiple0.s_cpt.[j] < n_session)]\n\n                             (* invariant *)\n    (EUF_RF.n = n_tag /\\\n     (forall (j : int), 0 <= j < n_tag <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j < n_tag => \n         0 <= oget Multiple0.s_cpt.[j] <= n_session) /\\\n     (forall (j : int), Multiple0.s_cpt.[j] <> None =>\n         ptxt_hashed j RF_bad.m <= oget Multiple0.s_cpt.[j])\n   ).  \n  + rewrite /pr_bad_step sumr_const count_predT size_range /=. \n    rewrite RField.intmulr /pr_bad /pr_bad_step_r.\n    smt (n_tag_p n_session_p).\n\n  + move => /> &hr H H0 H1 H2.\n    apply (IntOrder.ler_trans \n      (BIA.bigi predT (fun (k : int) => n_session) 0 n_tag)).\n   + rewrite !big_int.\n     by apply (Bigint.ler_sum _ _ (fun k => n_session) _); smt().\n   by rewrite sumr_const count_predT size_range intmulz; smt (n_tag_p).\n\n  + inline *; sp 6.\n    while (0 <= i <= n_tag /\\\n     (forall (j : int), 0 <= j && j < i <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j && j < i => Multiple0.s_cpt.[j] = Some 0));\n    1 : by auto; move => /> *; smt (get_setE).\n    auto => />; split; 1 : smt (empty_valE n_tag_p).\n    move => *; split. \n    + rewrite (eq_big_int 0 n_tag _ (fun k => 0)); \n      1 : by move => *; smt (get_setE).\n      by rewrite big1_eq.\n    move => *; split; 1 :  smt (empty_valE n_tag_p).\n    move => *; split; 1 :  smt (empty_valE n_session_p).   \n    by move => *; rewrite /ptxt_hashed /ptxt_hashed_l fdom0 filter0 fcards0 /#.  \n\n  + rewrite /pr_bad_step /=.\n    proc; inline *; \n    do 2! (sp; if; 2 : by hoare; auto). \n   seq 5 : (#post) (pr_bad_step_r) 1%r (1%r - pr_bad_step_r) 0%r => //;\n   2 : by hoare; conseq />.\n   wp; rnd; skip => /> &hr i1. \n   pose i2 := (if n_tag <= i1 then 0 else i1).\n   have -> /= : !(n_tag <= i2) by smt (n_tag_p).\n   move => H H1 H2 H3 H4 H5 H6 H7.\n   have -> : (fun (x : ptxt) => (i2, x) \\in RF_bad.m{hr}) = \n             (fun (x : ptxt) => (i2, x) \\in (ptxt_hashed_l i2 RF_bad.m{hr}))\n   by apply fun_ext => x; rewrite (ptxt_hashed_supp i2 _ RF_bad.m{hr}) //.   \n   have -> : (fun (x : ptxt) => (i2, x) \\in (ptxt_hashed_l i2 RF_bad.m{hr})) =\n     (fun (x : ptxt) => x \\in (image snd (ptxt_hashed_l i2 RF_bad.m{hr}))).\n   + apply fun_ext => x /=.\n     by rewrite imageP Tactics.eq_iff /=; split => [Hyp| [y Hyp]];\n     [1 : by exists (i2,x); smt() | 2 : smt (ptxt_hashed_i)].\n   have := Mu_mem.mu_mem_le_size \n     (map snd (elems (ptxt_hashed_l i2 RF_bad.m{hr}))) \n     dnonce (mu1 dnonce max_n) _;\n   1 : smt (maxu_dnonce).\n   move => /= Hmu.\n   rewrite /ptxt_hashed in H5. \n   rewrite size_map -cardE in Hmu => //. \n   rewrite /pr_bad_step_r. \n   apply (ler_trans \n       ((oget Multiple0.s_cpt{hr}.[i2])%r * mu1 dnonce max_n) _ _) \n   => //; 2: by apply ler_wpmul2r; smt (mu_bounded). \n   apply (ler_trans \n     ((card (ptxt_hashed_l i2 RF_bad.m{hr}))%r * mu1 dnonce max_n) _ _) \n   => //; 2: by apply ler_wpmul2r; smt (mu_bounded). \n   rewrite imageE. \n   have <- :(mem (unzip2 (elems (ptxt_hashed_l i2 RF_bad.m{hr}))) =\n            mem (oflist (unzip2 (elems (ptxt_hashed_l i2 RF_bad.m{hr})))))\n   by apply fun_ext => *; smt(mem_oflist). \n   smt().\n\n  (* if the precondition for [tag] holds:\n     - the counter increases\n     - the invariant is preserved. *)\n  + move => c. \n   proc; inline *; auto; sp. \n   if; 2 : by auto; smt ().\n   sp; if; 2 : by auto; smt ().\n   seq 1 :(#pre); 1 : by move => />; auto.   \n   auto => /> &hr i1. \n   pose i2 := (if n_tag <= i1 then 0 else i1). \n   have ->:  (if n_tag <= i2 then 0 else i2) = i2 by smt().\n   move => H H0 H1 H2 H3 r H4. \n   split.\n   + rewrite !big_int.\n     rewrite (eq_bigr _ \n     (fun (k : int) =>\n       oget Multiple0.s_cpt{hr}.[i2 <- oget Multiple0.s_cpt{hr}.[i2] + 1].[k])\n     (fun (k : int) =>\n       oget Multiple0.s_cpt{hr}.[k] + if k = i2 then 1 else 0)).\n     + by move => j H5 /=; smt (get_setE). \n     rewrite -sumrD -big_int -big_int big_if; 2 : smt(). \n     by rewrite /dom in H; smt(). \n   split; 1 : smt(get_setE).\n   split; 1 : smt(get_setE).\n   move => j. \n   case (i2 = j) => [->>|Hdeq]. \n   + rewrite !get_set_eqE // /=. \n     rewrite /ptxt_hashed /ptxt_hashed_l fdom_set filterU fcardU filter1 /=.\n     rewrite fcard1 fsetI1 /=. \n     rewrite /ptxt_hashed /ptxt_hashed_l in H3.\n     have H3i := (H3 j H). \n     smt(fcard1 fcards0).\n   rewrite !get_set_neqE //; 1 : smt(). \n   move => H5. \n   rewrite (ptxt_hashed_eq _ _ RF_bad.m{hr}); 2 : smt().\n   move => x.\n   rewrite !/ptxt_hashed_l !in_filter !mem_fdom // /=.\n   smt(get_setE).\n\n  (* if the precondition for [tag] does not hold:\n     - the counter does not increase\n     - the invariant is preserved\n     - bad is preserved. *)\n  + move => b c. \n   proc; inline *; auto; sp. \n   if; 2 : by auto; smt ().\n   sp; if; 2 : by auto; smt ().\n   seq 1 :(#pre); auto => /> /#. \nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* Assuming there are no collision, the single and multiple sessions\n   protocols coincide. *)\nlemma eq_single_mult &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) :\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] =\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.\n  byequiv => //; proc; inline *; sp 5 5. \n  seq 4 4 : (#pre /\\ ={Multiple0.s_cpt, i} /\\ \n             (forall j, (0 <= j < n_tag) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{2} = Some 0) /\\\n              forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n               exists j, 0 <= j < n_session /\\ \n                              r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}).\n  + sp; while (={Multiple0.s_cpt, i} /\\ 0 <= i{2} <= n_tag /\\\n         (forall j, (0 <= j < i{2}) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n         (forall j, (0 <= j < i{2}) => Multiple0.s_cpt.[j]{2} = Some 0) /\\\n          forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n           exists j, 0 <= j < n_session /\\ \n                          r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}); \n    1 : by auto; smt (get_setE).\n    by auto => />; smt (empty_valE n_tag_p). \n  call (_: ={glob Multiple0} /\\\n    EUF_RF.n{1} = n_tag /\\ EUF_RF.n{2} = n_tag * n_session /\\ \n    (forall j, (0 <= j < n_tag) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n    (forall j, (0 <= j < n_tag) => 0 <= oget Multiple0.s_cpt.[j]{1}) /\\\n    forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n      exists j, 0 <= j < n_session /\\ \n                     r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}). \n  (* tag *) \n  - move => />; 1 : by move => />; auto.\n    proc; inline *; sp; if => //.\n      (* 4 *)\n    + sp; if => //. \n        (* 5 *)\n      + seq 1 1 : (#pre /\\ ={n}); 1 : by auto => />.\n        wp; sp 3 3; seq 1 1 : (#pre); 1: by auto.\n        move => />; rnd (fun x => x); auto.\n        move => /> &1 &2 i_R; pose iR := (if n_tag <= i_R then 0 else i_R).\n        have -> /= : !(n_tag <= iR) by smt (n_tag_p).\n        move => *.\n        have -> /= : \n          !(n_tag * n_session <= \n            iR * n_session + oget Multiple0.s_cpt{2}.[iR]) \n        by smt (n_tag_p n_session_p).\n        split; 1 : by smt(drf_sup).        \n        move => /> *; smt(euclideU get_setE n_session_p n_tag_p). \n    auto => /> /#. \n  auto; move => /> /#. \n\n  (* reader *) \n  - proc; inline *; auto => />. \n    while (#pre /\\ 0 <= i{1} /\\ ={i,b}); \n    2: by conseq />; auto; smt (n_session_p n_tag_p). \n    conseq />; wp. \n    while {2} \n      (0 <= j{2} <= n_session /\\\n       (b0{2} <=> exists k, 0 <= k < j{2} /\\\n        let i2 = i{2} * n_session + k in\n        (h{2} \\in \n         odflt [] RF_bad.m{2}.[(if EUF_RF.n{2} <= i2 then 0 else i2, n{2})])))\n      (n_session - j{2});\n    1 : by auto => /> *; smt(get_setE). \n    auto => /> *; split; 1 : by smt (n_session_p).\n    move => *; split; 1 : smt (). \n    move => *; split; 1 : smt (). \n    congr.\n    have ->> : (j_R = n_session); 1 : smt (). \n    have He := (H1 n{2} i{2} h{2}).\n    have -> /= : !(n_tag <= i{2}) by smt (). \n    have <- /= : \n      (h{2} \\in odflt [] RF_bad.m{1}.[i{2}, n{2}]) = \n      (((i{2}, n{2}) \\in RF_bad.m{1}) && \n        (h{2} \\in oget RF_bad.m{1}.[i{2}, n{2}])). \n    + by rewrite /dom; case (RF_bad.m{1}.[i{2}, n{2}]); smt ().\n    rewrite He. \n    rewrite Tactics.eq_iff; progress. \n    + by exists j0; smt ().\n    exists k; smt ().\n\n  (* invariant implies the post *)\n  - auto => /#. \nqed.\n\n\n(*-----------------------------------------------------------------------*)\nlemma unlink_aux1 &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad}) :\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n  Pr[Unlink(A, Multiple, PRFs).main() @ &m : res] <=  \n  (  Pr[EUF_PRF_IND (PRFs,   D(A, Multiple0)).main() @ &m : res]\n   - Pr[EUF_PRF_IND (EUF_RF, D(A, Multiple0)).main() @ &m : res]) +\n  ( Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n    (n_session^2 * n_tag)%r * mu1 dnonce max_n).\nproof.\n  move => Hll.\n  rewrite (eq_mult_PRF &m A).\n  have {1}-> : (  Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res] =\n               (  Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res]\n                - Pr[EUF_PRF_IND(EUF_RF, D(A, Multiple0)).main() @ &m : res])\n               +  Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res]) \n  by have _ := eq_mult_RF &m A; smt().\n  apply ler_add2l. \n  apply (ler_trans (Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n                    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad]));\n  1 : by apply (coll_multiple &m A Hll).\n  apply ler_add2l. \n  have H := (coll_bound_multiple &m A Hll); rewrite /pr_bad /pr_bad_step_r in H. \n  rewrite expr2.\n  smt().\nqed.\n\nlemma unlink_aux2 &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad, EUF_RF2}) :\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n  Pr[Unlink(A, Single, PRFs).main() @ &m : res] =  \n  (  Pr[EUF_PRF_INDb(PRFs,   D(A, Single0)).main() @ &m : res]\n   - Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0)).main() @ &m : res]) +\n  Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.\n  move => Hll.\n  rewrite (eq_single_PRF &m A) -(eq_single_RF &m A).\n  rewrite (coll_single_eq &m A Hll). \n  smt().\nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* Final result. *)\nlemma unlinkability &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad, EUF_RF2}) :\n  (* We assume that the adversary is lossless (i.e. always terminates). *)\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n\n  (* Advantage of A against the unlinkability game. *)\n    Pr[Unlink(A, Multiple, PRFs).main() @ &m : res]\n  - Pr[Unlink(A, Single,   PRFs).main() @ &m : res] <=\n\n  (* Advantage of B=D(A, Multiple0) against PRF/EUF_RF \n     with [n_tag] keys. *)\n  (  Pr[EUF_PRF_IND (PRFs,   D(A, Multiple0)).main() @ &m : res]\n   - Pr[EUF_PRF_IND (EUF_RF, D(A, Multiple0)).main() @ &m : res]) +\n\n  (* Advantage of B=D(A, Single0) against PRF/EUF_RF \n     with [n_tag * n_session] keys. *)\n  (  Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0  )).main() @ &m : res]\n   - Pr[EUF_PRF_INDb(PRFs,   D(A, Single0  )).main() @ &m : res]) +\n\n  (* Collision probability between nonces hashed by each tag. *)\n  (n_session^2 * n_tag)%r * mu1 dnonce max_n.\nproof.\n  move => Hll.\n  have H1 := (unlink_aux1 &m A Hll).\n  have H2 := (unlink_aux2 &m A Hll).\n  rewrite (eq_single_mult &m A) in H1.  \n  rewrite (unlink_aux2 &m A Hll). \n  smt().\nqed.",
        "complete:": "(* Unlinkability of the Basic Hash protocol, multiple tags, one reader. *)\n\n(* Easycrypt: 1.0 (fa3853d3029d) *)\n(* Alt-Ergo version 2.3.3 *)\n(* Z3 4.8.4 *)\n(* CVC4 1.5 *)\n\nrequire import AllCore Int List FSet SmtMap IntDiv StdBigop Distr DBool Mu_mem.\nrequire import StdOrder.\n(*---*) import Bigint Bigreal BRA BIA IntOrder RealOrder RField.\nrequire (*---*) FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nop max_n : ptxt.        (* arbitrary nonce in [dnonce] domain. *)\naxiom maxu_dnonce x: mu1 dnonce x <= mu1 dnonce max_n.\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Unforgeable multiple RF *)\n(* We assume that: \n   - i) the hash functions are indistinguishable from a lossless and uniform\n     distributions over ptxts (not full).\n   - ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is\n   large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\n(* The PRFs are all i.i.d. *)\naxiom drf_iid (i j : int) : forall (r : ptxt), mu1 (drf i) r = mu1 (drf j) r.\n\nlemma drf_sup (i j : int) : forall (r : ptxt), r \\in drf i <=> r \\in drf j \nby smt (drf_iid).\n\nhint exact random : drf_iid.\nhint exact random : drf_sup.\nhint exact random : drf_ll.\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags (multiple sessions) and one reader. *)\n\nop n_tag : int.             (* number of tags *)\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\nop n_session : int.                 (* number of sessions per tag *)\naxiom n_session_p : 0 < n_session.  (* We have at least one session. *)\n\n(* Without initialization *)\nmodule Multiple0 (H : PRFs_Oracles) = {\n  var s_cpt : (int, int) fmap   (* Map a tag number to its session number. *)\n\n  (* Each tag runs at most n_session. *)\n  proc tag (i : int) : (ptxt * ptxt) option = {\n    var n, h, r, s_n;\n    i <- if (n_tag <= i) then 0 else i;\n    r <- None;\n\n    if (i \\in s_cpt) {\n      s_n <- oget s_cpt.[i];\n      if (s_n < n_session) {\n        n <$ dnonce;\n        h <@ H.f(i,n);\n        r <- Some (n, h);\n        s_cpt.[i] <- s_n + 1;\n      } \n    }\n    return r;\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule Multiple (H : PRFs) = {\n  module BH0 = Multiple0(H)\n  include BH0\n\n  proc init () : unit = { \n    var i;\n    H.init(n_tag); \n    \n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags (single session) and one reader. *)\n\n(* Without initialization *)\nmodule Single0 (H : PRFs_Oracles) = {\n\n  (* Each tag runs at most n_session. *)\n  proc tag (i : int) : (ptxt * ptxt) option = {\n    var n, h, r, s_n;\n    i <- if (n_tag <= i) then 0 else i;\n    r <- None;\n\n    if (i \\in Multiple0.s_cpt) {\n      s_n <- oget Multiple0.s_cpt.[i];\n      if (s_n < n_session) {\n        n <$ dnonce;\n        (* each hash function is used at most once *)\n        h <@ H.f(i * n_session + s_n,n); \n        r <- Some (n, h);\n        Multiple0.s_cpt.[i] <- s_n + 1;\n      } \n    }\n    return r;\n  }    \n  \n  proc reader (n h : ptxt) : bool = {    \n    var r, b0, b, i, j;\n    b <- false;\n    i <- 0;\n    j <- 0;\n    b0 <- false;\n    while (i < n_tag) {\n      j <- 0;\n      b0 <- false;\n      while (j < n_session) {\n        r <- H.check(i * n_session + j, n, h);\n        b0 <- b0 || r;\n        j <- j + 1;\n      }\n      b <- b || b0;\n      i <- i + 1;\n    }\n    return b;\n  } \n}.\n\n(* With initialization *)\nmodule Single (H : PRFs) = {\n  module BH0 = Single0(H)\n  include BH0\n\n  proc init () : unit = { \n    var i;\n    H.init(n_tag * n_session); \n    \n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs, [n_tag] keys. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(* Indistinguishability game for unforgeable PRFs, [n_tag * n_session] keys. *)\nmodule EUF_PRF_INDb (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag * n_session);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : (ptxt * ptxt) option\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Adversary against the Basic Hash protocol unlinkability *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : bool\n}.\n\n\n(* Basic Hash protocol unlinkability game *)\nmodule Unlink (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    var b : bool;\n    BH.init ();\n    b <- Adv.a();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* The PRF/RF distinguisher. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    var i, b;\n    Multiple0.s_cpt <- empty;\n    i <- 0;\n    while (i < n_tag) {\n      Multiple0.s_cpt.[i] <- 0;\n      i <- i + 1;\n    }\n\n    b <@ A.a();\n    return b; \n  } \n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Game-hope, PRF to RF for the multiple and single sessions protocols.  *)\n\nlemma eq_mult_RF &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, Multiple0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\nlemma eq_mult_PRF &m (A <: Adv {Multiple0, PRFs}) : \n    Pr[Unlink(A, Multiple, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with the single session protocol. *)\nlemma eq_single_RF &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim.\n\nlemma eq_single_PRF &m (A <: Adv {Multiple0, PRFs}) : \n    Pr[Unlink(A, Single, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_INDb(PRFs, D(A, Single0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim.\n\n\n(*-----------------------------------------------------------------------*)\n(* Second game-hope, where we bound the collision probability for all\n   the nonces sample by each tag.  *)\n\n(* The EUF_RF module, where we set a boolean bad to true if we hash\n   twice the same value. Since we only hash nonces, this is equivalent\n   to setting bad to true if a tag has a collision between two nonces\n   it samples.\n\n   In case of collisions, a message may have several hashes. We store\n   all possible hashes of a nonce, to be able to simulate the \"check\"\n   oracle procedure. *)\n\nmodule RF_bad = {\n  var bad : bool\n  var m : (int * ptxt, ptxt list) fmap\n\n  proc init(i : int) : unit = {\n    EUF_RF.init(i);\n    bad <- false;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (EUF_RF.n <= i) then 0 else i;\n\n    (* If we already hashed [x] under key [i], we set bad to true. *)\n    bad <- bad || (i,x) \\in m;\n\n    r <$ drf i;\n    m.[(i,x)] <- r :: odflt [] m.[(i,x)];\n    \n    return r;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (EUF_RF.n <= i) then 0 else i;\n    return ((i,x) \\in m && s \\in oget m.[(i,x)]);\n  }\n}.\n\n(* The winning probability against the unlinkability game (multiple\n   sessions) instanciated with Random Functions (EUF_RF) is equal to the\n   winning probability when instanciated with the Collision-Free Random\n   Functions (RF_bad), up-to-bad. *)\nlemma coll_multiple &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res] <=\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad].\nproof.\n  move => Hll; byequiv => //.\n  proc.\n  call(_: RF_bad.bad, \n    ={glob Single0, EUF_RF.n} /\\\n    (* (forall x i, (x,i) \\in EUF_RF.m{1} <=> (x,i) \\in RF_bad.m{2}) /\\ *)\n    (forall (x), omap (fun x => [x]) (EUF_RF.m.[(x)]{1}) = RF_bad.m.[(x)]{2})).\n  + proc; inline *; sp; if; 1,3 : by auto.\n    sp; if; 1, 3 : by auto. \n    seq 4 4 : (#pre /\\ ={n, i0, x}); 1 : by auto => /#.\n    wp; if {1}; 1 : by auto => />; smt(get_setE). \n    by auto; smt ().\n  + by move => &2 Hb; islossless.\n  + move => &2. proc; inline *; auto; sp; if; sp; auto. \n    by if; auto; smt (drf_ll dnonce_ll). \n  + proc; inline *. while (#pre /\\ ={b,i}); auto => />. \n    move => &1 &2 Hbad Hind Hle /> /#. \n  + move => &2 Hb; islossless. \n    while true (n_tag - i); auto; 2 : by smt ().\n    conseq (:true); 1 : by smt (). \n    by islossless. \n  + move => _; proc; conseq />.\n    while true (n_tag - i); auto; 2 : by smt ().\n    conseq (:true); 1 : by smt (). \n    by islossless. \n  + by inline *; sp => />; while (={i, Multiple0.s_cpt}); auto; smt (empty_valE).\nqed.\n\n(*-----------------------------------------------------------------------*)\n(* Same than the EUF_RF module, except that we set [bad] to true if we hash \n   the same value twice.  *)\nmodule EUF_RF2 = { \n  var bad : bool\n\n  proc init(i : int) : unit = {\n    EUF_RF.init(i);\n    bad <- false;\n  } \n\n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (EUF_RF.n <= i) then 0 else i;\n\n    (* If we already hashed [x] under key [i], we set bad to true. *)\n    bad <- bad || (i,x) \\in EUF_RF.m;\n\n    if ((i,x) \\notin EUF_RF.m) {\n      r <$ drf i;\n      EUF_RF.m.[(i,x)] <- r;\n    }\n    \n    return oget EUF_RF.m.[(i,x)];\n  }\n\n  proc check = EUF_RF.check\n}.\n\nlemma eq_single_RF2 &m (A <: Adv {Multiple0, EUF_RF}) : \n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[Unlink(A, Single, EUF_RF2).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem for the single session version of the unlinkability game. *)\nlemma coll_single &m (A <: Adv {EUF_RF, RF_bad, Multiple0, EUF_RF2}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    `| Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] -\n       Pr[Unlink(A, Single, RF_bad).main() @ &m : res] | <=\n       Pr[Unlink(A, Single, RF_bad).main() @ &m : RF_bad.bad].\nproof.  \n  move => Hll. \n  rewrite (eq_single_RF2 &m A).\n  byequiv (_ : ={glob A} ==> (EUF_RF2.bad{1} = RF_bad.bad{2}) /\\ \n                             (!RF_bad.bad{2} => ={res})) : EUF_RF2.bad => //;\n  2 : smt().\n  proc.\n  call(_: RF_bad.bad, \n    ={glob Single0, EUF_RF.n} /\\ (EUF_RF2.bad{1} = RF_bad.bad{2}) /\\\n    (* (forall x i, (x,i) \\in EUF_RF.m{1} <=> (x,i) \\in RF_bad.m{2}) /\\ *)\n    (forall (x), omap (fun x => [x]) (EUF_RF.m.[(x)]{1}) = RF_bad.m.[(x)]{2}),\n    (EUF_RF2.bad{1} = RF_bad.bad{2})).\n  + proc; inline *; sp; if; 1,3 : by auto. \n    sp; if; 1, 3 : by auto. \n    seq 4 4 : (#pre /\\ ={n, i0, x}); 1 : by auto => /> /#.\n    wp; sp. if {1}; 1 : by auto => />; smt(get_setE). \n    by auto; smt ().\n  + move => &2 Hb. \n    proc; inline *; auto; sp.\n    if; 2: by auto; smt().\n    sp; if; 2: by auto; smt().\n    seq 4 : (#pre) => //;\n    1,3 : by move => />; auto; smt(dnonce_ll). \n    seq 1 : (#post) =>//. \n    + by auto; smt(). \n    + by conseq />; islossless. \n    by hoare; auto; smt(). \n  + move => &2. proc; inline *; auto; sp; if; sp; auto. \n    by if; auto; smt (drf_ll dnonce_ll). \n  + proc; inline *; while (#pre /\\ ={b,b0,j,i}); auto => />. \n    while (#pre); auto => />. \n    by move => &1 &2 Hbad Hind Hle Hlt />; smt().\n  + move => &2 Hb. \n    proc; inline *; conseq />. \n    while true (n_tag - i); auto; 2 : by smt ().\n    while true (n_session - j); auto; 2 : by smt (). \n    by smt().\n  + move => &1. \n    proc; inline *; conseq />. \n    while true (n_tag - i); auto; 2 : by smt ().\n    while true (n_session - j); auto; 2 : by smt (). \n    by smt(). \n  + inline *; sp => />. \n    while (={i, Multiple0.s_cpt}); auto; smt (empty_valE).\nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* The probability of bad in the single sessions setting is 0,\n   since each tag hashes only one message. *)\n\n(* For the single session protocol, this should be 0. *)\nlemma coll_bound_single &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : RF_bad.bad] = 0%r.\nproof.\n  move => Hll.\n  byphoare => //; hoare.\n  proc. \n  call (_: EUF_RF.n = n_tag * n_session /\\\n     RF_bad.bad = false /\\\n     (forall (j : int), 0 <= j < n_tag <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j < n_tag => 0 <= oget Multiple0.s_cpt.[j]) /\\\n     (forall (j k : int) (x : ptxt), \n       Multiple0.s_cpt.[j] <> None => oget Multiple0.s_cpt.[j] <= k < n_session => \n         RF_bad.m.[(j * n_session + k,x)] = None)). \n  + proc; inline *; auto; sp.\n    if; 2 : by auto; smt ().\n    sp; if; 2 : by auto; smt ().\n    seq 1 :(#pre); 1 : by move => />; auto. \n    auto.\n    move => /> &hr i1. \n    pose i2 := (if n_tag <= i1 then 0 else i1).\n    move => *.\n    have -> /= : !(n_tag * n_session <= \n                   i2 * n_session + oget Multiple0.s_cpt{hr}.[i2]); \n    1 : smt (). \n    rewrite Tactics.eq_iff /dom => /=. \n    split; 1: by apply H1; smt().\n    rewrite /dom in H2; progress; 1,2,3,4 : smt (get_setE). \n    have := euclideU n_session i2 j (oget Multiple0.s_cpt{hr}.[i2]) k.\n    smt (get_setE). \n  + by conseq />; auto.\n  inline *; sp 6. \n  while (0 <= i <= n_tag /\\\n   (forall (j : int), 0 <= j && j < i <=> Multiple0.s_cpt.[j] <> None) /\\\n   (forall (j : int), 0 <= j && j < i => Multiple0.s_cpt.[j] = Some 0));\n  1 : by auto; move => /> *; smt (get_setE). \n  by auto => />; smt (empty_valE n_tag_p). \nqed.\n\nlemma coll_single_eq &m (A <: Adv {EUF_RF, RF_bad, Multiple0, EUF_RF2}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Single, EUF_RF).main() @ &m : res] =\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.  \n  move => Hll. \n  have H  := (coll_bound_single &m A Hll).\n  have H' := (coll_single &m A Hll).\n  smt().  \nqed.\n\n(*-----------------------------------------------------------------------*)\n(* We bound the probability of bad in the multiple sessions setting by:\n   \n       n_session^2 * n_tag * mu1 dnonce max_n\n\n   Since [dnonce] is uniform, [mu1 dnonce max_n] is 1/N, where [N] is\n   the size of the nonce space. \n   \n\n   Note that the bound could be improved to: \n\n       n_session * (n_session + 1) / 2 * n_tag * mu1 dnonce max_n\n\n   But the proof would be much more complicated: the current proof\n   using the failure event lemma, which makes us use the same counter\n   and bad event for all tags, which prevent from correctly tracking\n   the number of already hashed nonces for each tag. Currently, the\n   only way I see to circumvent this is to use the failure event lemma\n   together with a hybrid argument.  *)\n\nop pr_bad_step_r = n_session%r * mu1 dnonce max_n.\nop pr_bad_step (k : int) = pr_bad_step_r.\nop pr_bad = pr_bad_step_r * (n_session * n_tag)%r.\n\n(* Number of plain-texts hashed for tag [i]. *)\nop ptxt_hashed_l (i : int) (m : (int * ptxt, ptxt list) fmap) =\n  FSet.filter (fun x => fst x = i) (SmtMap.fdom m).\n\nop ptxt_hashed (i : int) (m : (int * ptxt, ptxt list) fmap)  =\n  FSet.card (ptxt_hashed_l i m).\n\nlemma ptxt_hashed_supp (i : int) (x : ptxt) (m : (int * ptxt, ptxt list) fmap) :\n    (i,x) \\in m <=> (i,x) \\in (ptxt_hashed_l i m)\nby rewrite /ptxt_hashed_l in_filter mem_fdom //.\n\nlemma ptxt_hashed_i (i j : int) (x : ptxt) (m : (int * ptxt, ptxt list) fmap) :\n    (j,x) \\in (ptxt_hashed_l i m) => i = j\nby rewrite /ptxt_hashed_l in_filter mem_fdom //.\n\nlemma ptxt_hashed_eq i m m' :\n    (forall x, (i,x) \\in (ptxt_hashed_l i m) <=>\n               (i,x) \\in (ptxt_hashed_l i m')) =>\n    (ptxt_hashed i m) = (ptxt_hashed i m').\nproof.\n move => H.\n rewrite /ptxt_hashed; congr.\n rewrite fsetP => -[j x].\n case (j = i) => [->|Hdeq]; smt(ptxt_hashed_i).\nqed.\n\nlemma big_if (i a b : int) : a <= i < b =>\n    bigi predT (fun (x : int) => if x = i then 1 else 0) a b = 1.\nproof.\n  move => H; rewrite (range_cat i); 1,2: smt (). \n  rewrite (range_cat (i + 1) i b); 1,2: smt (). \n  rewrite !big_cat !big_int.\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => i <= i0 && i0 < i + 1) \n       (fun (i0 : int) => i <= i0 && i0 < i + 1) \n       _ (fun x => 1) _) //; 1 : smt ().\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => a <= i0 && i0 < i)\n       (fun (i0 : int) => a <= i0 && i0 < i)\n       _ (fun x => 0) _) //; 1 : smt ().\n  rewrite (BIA.eq_big\n       (fun (i0 : int) => i + 1 <= i0 && i0 < b)\n       (fun (i0 : int) => i + 1 <= i0 && i0 < b)\n       _ (fun x => 0) _) //; 1 : smt ().\n  by rewrite -!big_int !bigi_constz // /#. \nqed.\n\nlemma coll_bound_multiple &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) : \n    (forall (BH <: BasicHashT0{A}),\n      islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad] <= pr_bad.\nproof.\n  move => Hll.\n  fel\n    1                        (* initialization phase  *)\n    (BIA.bigi \n      predT\n      (fun (k : int) => oget Multiple0.s_cpt.[k]) \n      0 n_tag)               (* counter *)\n    (fun k => pr_bad_step k) (* update to the upper-bound w.r.t. the counter *)\n    (n_tag * n_session)      (* upper-bound on the number of steps *)\n    (RF_bad.bad)             (* failure event *)\n\n                             (* pre-condition for the counter increase *)\n    [Multiple(RF_bad).tag : \n      (let j = if (n_tag <= i) then 0 else i in\n       j \\in Multiple0.s_cpt /\\ \n       oget Multiple0.s_cpt.[j] < n_session)]\n\n                             (* invariant *)\n    (EUF_RF.n = n_tag /\\\n     (forall (j : int), 0 <= j < n_tag <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j < n_tag => \n         0 <= oget Multiple0.s_cpt.[j] <= n_session) /\\\n     (forall (j : int), Multiple0.s_cpt.[j] <> None =>\n         ptxt_hashed j RF_bad.m <= oget Multiple0.s_cpt.[j])\n   ).  \n  + rewrite /pr_bad_step sumr_const count_predT size_range /=. \n    rewrite RField.intmulr /pr_bad /pr_bad_step_r.\n    smt (n_tag_p n_session_p).\n\n  + move => /> &hr H H0 H1 H2.\n    apply (IntOrder.ler_trans \n      (BIA.bigi predT (fun (k : int) => n_session) 0 n_tag)).\n   + rewrite !big_int.\n     by apply (Bigint.ler_sum _ _ (fun k => n_session) _); smt().\n   by rewrite sumr_const count_predT size_range intmulz; smt (n_tag_p).\n\n  + inline *; sp 6.\n    while (0 <= i <= n_tag /\\\n     (forall (j : int), 0 <= j && j < i <=> Multiple0.s_cpt.[j] <> None) /\\\n     (forall (j : int), 0 <= j && j < i => Multiple0.s_cpt.[j] = Some 0));\n    1 : by auto; move => /> *; smt (get_setE).\n    auto => />; split; 1 : smt (empty_valE n_tag_p).\n    move => *; split. \n    + rewrite (eq_big_int 0 n_tag _ (fun k => 0)); \n      1 : by move => *; smt (get_setE).\n      by rewrite big1_eq.\n    move => *; split; 1 :  smt (empty_valE n_tag_p).\n    move => *; split; 1 :  smt (empty_valE n_session_p).   \n    by move => *; rewrite /ptxt_hashed /ptxt_hashed_l fdom0 filter0 fcards0 /#.  \n\n  + rewrite /pr_bad_step /=.\n    proc; inline *; \n    do 2! (sp; if; 2 : by hoare; auto). \n   seq 5 : (#post) (pr_bad_step_r) 1%r (1%r - pr_bad_step_r) 0%r => //;\n   2 : by hoare; conseq />.\n   wp; rnd; skip => /> &hr i1. \n   pose i2 := (if n_tag <= i1 then 0 else i1).\n   have -> /= : !(n_tag <= i2) by smt (n_tag_p).\n   move => H H1 H2 H3 H4 H5 H6 H7.\n   have -> : (fun (x : ptxt) => (i2, x) \\in RF_bad.m{hr}) = \n             (fun (x : ptxt) => (i2, x) \\in (ptxt_hashed_l i2 RF_bad.m{hr}))\n   by apply fun_ext => x; rewrite (ptxt_hashed_supp i2 _ RF_bad.m{hr}) //.   \n   have -> : (fun (x : ptxt) => (i2, x) \\in (ptxt_hashed_l i2 RF_bad.m{hr})) =\n     (fun (x : ptxt) => x \\in (image snd (ptxt_hashed_l i2 RF_bad.m{hr}))).\n   + apply fun_ext => x /=.\n     by rewrite imageP Tactics.eq_iff /=; split => [Hyp| [y Hyp]];\n     [1 : by exists (i2,x); smt() | 2 : smt (ptxt_hashed_i)].\n   have := Mu_mem.mu_mem_le_size \n     (map snd (elems (ptxt_hashed_l i2 RF_bad.m{hr}))) \n     dnonce (mu1 dnonce max_n) _;\n   1 : smt (maxu_dnonce).\n   move => /= Hmu.\n   rewrite /ptxt_hashed in H5. \n   rewrite size_map -cardE in Hmu => //. \n   rewrite /pr_bad_step_r. \n   apply (ler_trans \n       ((oget Multiple0.s_cpt{hr}.[i2])%r * mu1 dnonce max_n) _ _) \n   => //; 2: by apply ler_wpmul2r; smt (mu_bounded). \n   apply (ler_trans \n     ((card (ptxt_hashed_l i2 RF_bad.m{hr}))%r * mu1 dnonce max_n) _ _) \n   => //; 2: by apply ler_wpmul2r; smt (mu_bounded). \n   rewrite imageE. \n   have <- :(mem (unzip2 (elems (ptxt_hashed_l i2 RF_bad.m{hr}))) =\n            mem (oflist (unzip2 (elems (ptxt_hashed_l i2 RF_bad.m{hr})))))\n   by apply fun_ext => *; smt(mem_oflist). \n   smt().\n\n  (* if the precondition for [tag] holds:\n     - the counter increases\n     - the invariant is preserved. *)\n  + move => c. \n   proc; inline *; auto; sp. \n   if; 2 : by auto; smt ().\n   sp; if; 2 : by auto; smt ().\n   seq 1 :(#pre); 1 : by move => />; auto.   \n   auto => /> &hr i1. \n   pose i2 := (if n_tag <= i1 then 0 else i1). \n   have ->:  (if n_tag <= i2 then 0 else i2) = i2 by smt().\n   move => H H0 H1 H2 H3 r H4. \n   split.\n   + rewrite !big_int.\n     rewrite (eq_bigr _ \n     (fun (k : int) =>\n       oget Multiple0.s_cpt{hr}.[i2 <- oget Multiple0.s_cpt{hr}.[i2] + 1].[k])\n     (fun (k : int) =>\n       oget Multiple0.s_cpt{hr}.[k] + if k = i2 then 1 else 0)).\n     + by move => j H5 /=; smt (get_setE). \n     rewrite -sumrD -big_int -big_int big_if; 2 : smt(). \n     by rewrite /dom in H; smt(). \n   split; 1 : smt(get_setE).\n   split; 1 : smt(get_setE).\n   move => j. \n   case (i2 = j) => [->>|Hdeq]. \n   + rewrite !get_set_eqE // /=. \n     rewrite /ptxt_hashed /ptxt_hashed_l fdom_set filterU fcardU filter1 /=.\n     rewrite fcard1 fsetI1 /=. \n     rewrite /ptxt_hashed /ptxt_hashed_l in H3.\n     have H3i := (H3 j H). \n     smt(fcard1 fcards0).\n   rewrite !get_set_neqE //; 1 : smt(). \n   move => H5. \n   rewrite (ptxt_hashed_eq _ _ RF_bad.m{hr}); 2 : smt().\n   move => x.\n   rewrite !/ptxt_hashed_l !in_filter !mem_fdom // /=.\n   smt(get_setE).\n\n  (* if the precondition for [tag] does not hold:\n     - the counter does not increase\n     - the invariant is preserved\n     - bad is preserved. *)\n  + move => b c. \n   proc; inline *; auto; sp. \n   if; 2 : by auto; smt ().\n   sp; if; 2 : by auto; smt ().\n   seq 1 :(#pre); auto => /> /#. \nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* Assuming there are no collision, the single and multiple sessions\n   protocols coincide. *)\nlemma eq_single_mult &m (A <: Adv {EUF_RF, RF_bad, Multiple0}) :\n    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] =\n    Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.\n  byequiv => //; proc; inline *; sp 5 5. \n  seq 4 4 : (#pre /\\ ={Multiple0.s_cpt, i} /\\ \n             (forall j, (0 <= j < n_tag) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n             (forall j, (0 <= j < n_tag) => Multiple0.s_cpt.[j]{2} = Some 0) /\\\n              forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n               exists j, 0 <= j < n_session /\\ \n                              r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}).\n  + sp; while (={Multiple0.s_cpt, i} /\\ 0 <= i{2} <= n_tag /\\\n         (forall j, (0 <= j < i{2}) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n         (forall j, (0 <= j < i{2}) => Multiple0.s_cpt.[j]{2} = Some 0) /\\\n          forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n           exists j, 0 <= j < n_session /\\ \n                          r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}); \n    1 : by auto; smt (get_setE).\n    by auto => />; smt (empty_valE n_tag_p). \n  call (_: ={glob Multiple0} /\\\n    EUF_RF.n{1} = n_tag /\\ EUF_RF.n{2} = n_tag * n_session /\\ \n    (forall j, (0 <= j < n_tag) <=> Multiple0.s_cpt.[j]{2} <> None) /\\\n    (forall j, (0 <= j < n_tag) => 0 <= oget Multiple0.s_cpt.[j]{1}) /\\\n    forall x i r, r \\in odflt [] RF_bad.m.[(i,x)]{1} <=> \n      exists j, 0 <= j < n_session /\\ \n                     r \\in odflt [] RF_bad.m.[(i * n_session + j, x)]{2}). \n  (* tag *) \n  - move => />; 1 : by move => />; auto.\n    proc; inline *; sp; if => //.\n      (* 4 *)\n    + sp; if => //. \n        (* 5 *)\n      + seq 1 1 : (#pre /\\ ={n}); 1 : by auto => />.\n        wp; sp 3 3; seq 1 1 : (#pre); 1: by auto.\n        move => />; rnd (fun x => x); auto.\n        move => /> &1 &2 i_R; pose iR := (if n_tag <= i_R then 0 else i_R).\n        have -> /= : !(n_tag <= iR) by smt (n_tag_p).\n        move => *.\n        have -> /= : \n          !(n_tag * n_session <= \n            iR * n_session + oget Multiple0.s_cpt{2}.[iR]) \n        by smt (n_tag_p n_session_p).\n        split; 1 : by smt(drf_sup).        \n        move => /> *; smt(euclideU get_setE n_session_p n_tag_p). \n    auto => /> /#. \n  auto; move => /> /#. \n\n  (* reader *) \n  - proc; inline *; auto => />. \n    while (#pre /\\ 0 <= i{1} /\\ ={i,b}); \n    2: by conseq />; auto; smt (n_session_p n_tag_p). \n    conseq />; wp. \n    while {2} \n      (0 <= j{2} <= n_session /\\\n       (b0{2} <=> exists k, 0 <= k < j{2} /\\\n        let i2 = i{2} * n_session + k in\n        (h{2} \\in \n         odflt [] RF_bad.m{2}.[(if EUF_RF.n{2} <= i2 then 0 else i2, n{2})])))\n      (n_session - j{2});\n    1 : by auto => /> *; smt(get_setE). \n    auto => /> *; split; 1 : by smt (n_session_p).\n    move => *; split; 1 : smt (). \n    move => *; split; 1 : smt (). \n    congr.\n    have ->> : (j_R = n_session); 1 : smt (). \n    have He := (H1 n{2} i{2} h{2}).\n    have -> /= : !(n_tag <= i{2}) by smt (). \n    have <- /= : \n      (h{2} \\in odflt [] RF_bad.m{1}.[i{2}, n{2}]) = \n      (((i{2}, n{2}) \\in RF_bad.m{1}) && \n        (h{2} \\in oget RF_bad.m{1}.[i{2}, n{2}])). \n    + by rewrite /dom; case (RF_bad.m{1}.[i{2}, n{2}]); smt ().\n    rewrite He. \n    rewrite Tactics.eq_iff; progress. \n    + by exists j0; smt ().\n    exists k; smt ().\n\n  (* invariant implies the post *)\n  - auto => /#. \nqed.\n\n\n(*-----------------------------------------------------------------------*)\nlemma unlink_aux1 &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad}) :\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n  Pr[Unlink(A, Multiple, PRFs).main() @ &m : res] <=  \n  (  Pr[EUF_PRF_IND (PRFs,   D(A, Multiple0)).main() @ &m : res]\n   - Pr[EUF_PRF_IND (EUF_RF, D(A, Multiple0)).main() @ &m : res]) +\n  ( Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n    (n_session^2 * n_tag)%r * mu1 dnonce max_n).\nproof.\n  move => Hll.\n  rewrite (eq_mult_PRF &m A).\n  have {1}-> : (  Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res] =\n               (  Pr[EUF_PRF_IND(PRFs, D(A, Multiple0)).main() @ &m : res]\n                - Pr[EUF_PRF_IND(EUF_RF, D(A, Multiple0)).main() @ &m : res])\n               +  Pr[Unlink(A, Multiple, EUF_RF).main() @ &m : res]) \n  by have _ := eq_mult_RF &m A; smt().\n  apply ler_add2l. \n  apply (ler_trans (Pr[Unlink(A, Multiple, RF_bad).main() @ &m : res] +\n                    Pr[Unlink(A, Multiple, RF_bad).main() @ &m : RF_bad.bad]));\n  1 : by apply (coll_multiple &m A Hll).\n  apply ler_add2l. \n  have H := (coll_bound_multiple &m A Hll); rewrite /pr_bad /pr_bad_step_r in H. \n  rewrite expr2.\n  smt().\nqed.\n\nlemma unlink_aux2 &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad, EUF_RF2}) :\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n  Pr[Unlink(A, Single, PRFs).main() @ &m : res] =  \n  (  Pr[EUF_PRF_INDb(PRFs,   D(A, Single0)).main() @ &m : res]\n   - Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0)).main() @ &m : res]) +\n  Pr[Unlink(A, Single, RF_bad).main() @ &m : res].\nproof.\n  move => Hll.\n  rewrite (eq_single_PRF &m A) -(eq_single_RF &m A).\n  rewrite (coll_single_eq &m A Hll). \n  smt().\nqed.\n\n\n(*-----------------------------------------------------------------------*)\n(* Final result. *)\nlemma unlinkability &m (A <: Adv {Multiple0, PRFs, EUF_RF, RF_bad, EUF_RF2}) :\n  (* We assume that the adversary is lossless (i.e. always terminates). *)\n  (forall (BH <: BasicHashT0{A}),\n    islossless BH.tag => islossless BH.reader => islossless A(BH).a) =>\n\n  (* Advantage of A against the unlinkability game. *)\n    Pr[Unlink(A, Multiple, PRFs).main() @ &m : res]\n  - Pr[Unlink(A, Single,   PRFs).main() @ &m : res] <=\n\n  (* Advantage of B=D(A, Multiple0) against PRF/EUF_RF \n     with [n_tag] keys. *)\n  (  Pr[EUF_PRF_IND (PRFs,   D(A, Multiple0)).main() @ &m : res]\n   - Pr[EUF_PRF_IND (EUF_RF, D(A, Multiple0)).main() @ &m : res]) +\n\n  (* Advantage of B=D(A, Single0) against PRF/EUF_RF \n     with [n_tag * n_session] keys. *)\n  (  Pr[EUF_PRF_INDb(EUF_RF, D(A, Single0  )).main() @ &m : res]\n   - Pr[EUF_PRF_INDb(PRFs,   D(A, Single0  )).main() @ &m : res]) +\n\n  (* Collision probability between nonces hashed by each tag. *)\n  (n_session^2 * n_tag)%r * mu1 dnonce max_n.\nproof.\n  move => Hll.\n  have H1 := (unlink_aux1 &m A Hll).\n  have H2 := (unlink_aux2 &m A Hll).\n  rewrite (eq_single_mult &m A) in H1.  \n  rewrite (unlink_aux2 &m A Hll). \n  smt().\nqed."
    }
]