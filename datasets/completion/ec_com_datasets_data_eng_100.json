[
    {
        "file": "EC-1/AAPI.ec",
        "incomplete": "(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type ____(TYPE_1)____.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type ____(TYPE_0)____.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : ____(OP_0)____ option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API.",
        "complete:": "(** Abstract class for API's *)\nrequire import AllCore List FSet.\n\n(**\n  An API is an entity that is capable of performing confidential\n  computations. It has the ability to manage both public and \n  secret data and some computations inside the API may disclose\n  side information.\n\n  An API may also maintain some internal memory storage, which it\n  may use to store the value of variables whose values are \n  intended to be secret.\n\n  API interactions are made via the construction of API calls and\n  the result of some API computation can be collected via API\n  responses. These interactions are made via an interaction buffer,\n  used both for calls and responses.\n\n  The API is also responsible to deal with input and output operations.\n*)\ntheory API.\n  \n  (** Public data type *)\n  type public_t.\n\n  type inputs_t.\n  type outputs_t.\n\n  (** Secret variables *)\n  type svar_t. \n\n  (** Secret operations *)\n  type sop_t.\n  (** Side information *)\n  type sideInfo_t.\n\n  (** API calls *)\n  type apiCall_data.\n\n  (** API responses *)\n  type apiRes_data.\n\n  (** Interaction buffer, both for API calls and responses *)\n  type apiCallRes.\n\n  (** Extracts some API call from the interaction buffer *)\n  op apiCall (x: apiCallRes) : apiCall_data option.\n\n  (** Extracts some API response from the interaction buffer *)\n  op apiRes (x: apiCallRes) : apiRes_data option.\n\n  (** Handle generator *)\n  (**\n    To generate handles, the API can query this entity\n    that, using the set of existing handles [hdls], \n    generates a new, fresh handle to store some secret\n    value.\n  *)\n  module type Handle = {\n    proc create_handle(hdls : svar_t fset) : svar_t\n  }.\n\n  (** API type *)\n  (**\n    An API discloses the following procedures:\n      - [api_init] - initialises the API engine\n      - [api_nparties] - gets the number of parties that are\n      interacting with the API\n      - [api_sop(sop, pargs, sargs)] - computes the secret\n      operation [sop] with public arguments [pargs] and \n      secret arguments [sargs]\n      - [api_declass(a)] - reveals the secret value of \n      variable [a], which becomes public.\n      - [api_in(xx)] - adds the input value [xx] to the internal\n      storage of the API\n      - [api_out(a)] - discloses the value of some variable [a]\n  *)\n  module type API_t = {\n   proc init(): unit\n   proc nparties(): int\n   proc declass(a: svar_t): (public_t * sideInfo_t) option\n   proc input(a: svar_t, inp: inputs_t): sideInfo_t option\n   proc output(a: svar_t): (outputs_t * sideInfo_t) option\n   proc sop(sop: sop_t, pargs: public_t list, sargs: svar_t list, result: svar_t) : sideInfo_t option\n  }.\n\nend API."
    },
    {
        "file": "EC-1/abstract-ind-ror.ec",
        "incomplete": "(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype ____(TYPE_0)____.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop ____(OP_0)____: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        (* Set m to be an authentic message. *)\n      } else {\n        (* Set m to be a random string. *)\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed.",
        "complete:": "(* \nWelcome to ProofGeneral, the front-end that we use to\nwork with EasyCrypt. ProofGeneral runs on top of Emacs,\nso most of keybindings of Emacs work as expected.\n\nIn this file, we go through an illustrative example of\nmodelling an IND-RoR game with EasyCrypt.\n\nTo interactively evaluate the script, you can either use the\ntoolbar at the top or use the following keybindings:\n1. ctrl + c and then ctrl + n to evaluate one line/block of code (Next)\n2. ctrl + c and then ctrl + u to undo evaluation of one line/block of code (Undo)\n3. ctrl + x ctrl + s to save the file\n4. ctrl + x ctrl + c to exit Emacs\n\nWe will look at more keybindings in the next file.\nEvaluting the first line will split the interface to show three panes.\n\n1. EasyCrypt script pane (left pane)\n2. Goals pane (top right)\n3. Response pane (bottom right)\n\nKeep evaluating until the end of the file\nand see how things change.\n*)\n\n(* We first import some core theory files *)\nrequire import Real Bool DBool.\n\n(* We define abstract data-types and operations *)\ntype msg.\ntype cip.\n\n(* Encrypt and decrypt operations. *)\nop enc: msg -> cip.\nop dec: cip -> msg.\n\n(* Compute operations for the adversary. *)\nop comp: cip -> bool.\n\n(*\nNext we define the module types.\nThese are blueprints for concrete types\nthat we instantiate right after we define them.\n*)\n\nmodule type Challenger = {\n  proc encrypt(m:msg): cip\n  proc decrypt(c:cip): msg\n}.\n\nmodule C:Challenger = {\n\n proc encrypt(m:msg): cip = {\n    return enc(m);\n }\n\n proc decrypt(c:cip): msg = {\n   return dec(c);\n }\n}.\n\n(* Similarly we define an adversary. *)\nmodule type Adversary = {\n  proc guess(c:cip): bool\n}.\n(* and an instance of the same. *)\nmodule Adv:Adversary = {\n\n  proc guess(c:cip): bool = {\n    return comp(c);\n  }\n}.\n\n(* The game module and the claims related to it. *)\nmodule Game(C:Challenger, Adv:Adversary) = {\n  \n  proc ind_ror(): bool = {\n      var m:msg;\n      var c:cip;\n      var b,b_adv:bool;\n      b <$ {0,1}; (* Pick b uniformly at random. *)\n      if(b=true){\n        (* Set m to be an authentic message. *)\n      } else {\n        (* Set m to be a random string. *)\n      }\n      c <@ C.encrypt(m);\n      b_adv <@ Adv.guess(c);\n      return (b_adv=b);\n  }\n}.\n\n(*\nAt this point EasyCrypt will throw a warning\ncomplaining about how there may be an uninitialized\nvariable. This happens because in our current\nprogram definition, we haven't initialized\n\"m\" to anything.\nWe skim past this warning, since this example\nis only to illustrate the structure of EasyCrypt scripts.\nGo ahead and keep evaluating the script.\nMake sure to undo some evaluations as well,\njust to get the keystrokes into your muscle memory.\n*)\n\naxiom ind_ror_pr_le1:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= 1%r.\n\nlemma ind_ror_secure:\nphoare [Game(C,Adv).ind_ror: true ==> res] <= (1%r/2%r).\n(* Notice the changes in the goals pane *)\nproof.\n  admit.\nqed."
    },
    {
        "file": "EC-1/AES.ec",
        "incomplete": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : ____(OP_5)____.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (____(OP_1)____:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (____(OP_0)____ : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (____(OP_3)____ : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : ____(LEMMA_2)____ (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: ____(OP_2)____.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state ____(OP_4)____: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ ____(LEMMA_0)____ k : ____(LEMMA_1)____ s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.",
        "complete:": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed."
    }
]