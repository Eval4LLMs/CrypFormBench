[
    {
        "file": "PV-1/AugmentedEKE2.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3\n   One does not know whether one decrypts { challengeA, challengeB }_K\n   and similar messages correctly. *)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree c: channel.\n\ntype ____(TYPE_1)____.\ntype passwd.\ntype nonce.\ntype G.\ntype ____(TYPE_0)____.\ntype key.\n\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\nfun G_to_key(G): key [data, typeConverter].\nfun G_to_bitstring(G):bitstring [____(FUN_1)____, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, ____(OP_14)____): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric cryptography\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(____(OP_3)____, key): bitstring.\nfun dec(bitstring, key): bitstring.\nequation forall x: bitstring, y: key; dec(enc(x,y),y) = x.\nequation ____(EQUATION_0)____ ____(EQUATION_2)____: bitstring, ____(EQUATION_1)____: key; enc(dec(x,y),y) = x.\n\n(* Hash function *)\n\nfun h(passwd):____(FUN_2)____.\n\n(* One-way function *)\n\nfun F(passwd, ____(FUN_0)____): bitstring.\n\n(* Predicate *)\n\nreduc ____(REDUC_3)____ ____(REDUC_1)____: ____(REDUC_2)____, ____(REDUC_0)____: key; T(h(____(OP_15)____), F(x,y), y) = true.\n\n(* Host names *)\n\nconst A, ____(CONST_0)____: host.\n\n\n\nfree PAB, ____(FREE_1)____, ____(FREE_0)____: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(____(OP_7)____: host, ____(OP_8)____: host, P: passwd) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(G_to_bitstring(exp(g, RA)), h(P))));\n\tin(____(OP_19)____, (m1: ____(OP_20)____, m2: bitstring));\n\tlet G_to_bitstring(____(OP_5)____) = dec(m1, h(P)) in\n\tlet ____(LET_0)____ = G_to_key(exp(gRB, RA)) in\n\tlet nonce_to_bitstring(challengeB) = dec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, enc((____(OP_1)____, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(____(IF_0)____) = dec(m3, K) then\n\tout(c, enc(F(P,K), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: ____(OP_9)____));\n\tlet G_to_bitstring(____(OP_11)____) = dec(____(OP_17)____, h(P)) in \n\tnew RB: ____(NEW_0)____;\n\tlet ____(LET_1)____ = G_to_key(exp(gRA, ____(OP_10)____)) in\n\tnew challengeB: nonce;\n\tout(c, (enc(G_to_bitstring(exp(g, RB)), h(____(OP_4)____)), enc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (challengeA: nonce, =challengeB) = dec(m4, K) in\n\tout(c, enc(nonce_to_bitstring(challengeA), K));\n\tin(c, ____(OP_12)____: bitstring);\n\tlet fr = dec(m5, K) in\n\tif T(h(P), fr, K) = true then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(____(OP_0)____, A, PAA)) |\n\t(!processB(____(OP_18)____, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(____(OP_13)____, A, PAB)) |\n\t(!processB(____(OP_16)____, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n1.575s (user 1.539s + system 0.036s), max rss 31472K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3\n   One does not know whether one decrypts { challengeA, challengeB }_K\n   and similar messages correctly. *)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree c: channel.\n\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\ntype key.\n\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\nfun G_to_key(G): key [data, typeConverter].\nfun G_to_bitstring(G):bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric cryptography\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(bitstring, key): bitstring.\nfun dec(bitstring, key): bitstring.\nequation forall x: bitstring, y: key; dec(enc(x,y),y) = x.\nequation forall x: bitstring, y: key; enc(dec(x,y),y) = x.\n\n(* Hash function *)\n\nfun h(passwd):key.\n\n(* One-way function *)\n\nfun F(passwd, key): bitstring.\n\n(* Predicate *)\n\nreduc forall x: passwd, y: key; T(h(x), F(x,y), y) = true.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(G_to_bitstring(exp(g, RA)), h(P))));\n\tin(c, (m1: bitstring, m2: bitstring));\n\tlet G_to_bitstring(gRB) = dec(m1, h(P)) in\n\tlet K = G_to_key(exp(gRB, RA)) in\n\tlet nonce_to_bitstring(challengeB) = dec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, enc((challengeA, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(challengeA) = dec(m3, K) then\n\tout(c, enc(F(P,K), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: bitstring));\n\tlet G_to_bitstring(gRA) = dec(m, h(P)) in \n\tnew RB: exponent;\n\tlet K = G_to_key(exp(gRA, RB)) in\n\tnew challengeB: nonce;\n\tout(c, (enc(G_to_bitstring(exp(g, RB)), h(P)), enc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (challengeA: nonce, =challengeB) = dec(m4, K) in\n\tout(c, enc(nonce_to_bitstring(challengeA), K));\n\tin(c, m5: bitstring);\n\tlet fr = dec(m5, K) in\n\tif T(h(P), fr, K) = true then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n1.575s (user 1.539s + system 0.036s), max rss 31472K\nEND *)"
    },
    {
        "file": "PV-1/basic1-1.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfun hash(____(FUN_0)____): bitstring.\n\nfree c: ____(FREE_0)____.\nfree x, n: bitstring [private].\n\nnoninterf x among (n, hash(n)).\n\nprocess\n\tout(____(OP_0)____, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\n0.011s (user 0.004s + system 0.007s), max rss 9820K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfun hash(bitstring): bitstring.\n\nfree c: channel.\nfree x, n: bitstring [private].\n\nnoninterf x among (n, hash(n)).\n\nprocess\n\tout(c, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\n0.011s (user 0.004s + system 0.007s), max rss 9820K\nEND *)"
    },
    {
        "file": "PV-1/basicweaksecret.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Basic weak secret example, from JLAP paper\n   Corrected version *)\n\ntype ____(TYPE_0)____.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun penc(____(FUN_0)____, ____(OP_1)____, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall ____(EQUATION_3)____: ____(EQUATION_0)____, ____(EQUATION_1)____: skey, ____(EQUATION_2)____: seed;  pdec(penc(x, pk(____(OP_0)____), z), y) = x.\n\n(* Hash function *)\n\nfun h(passwd): bitstring.\n\nfree c: ____(FREE_0)____.\nfree w: passwd [private].\n\nweaksecret w.\n\nprocess\n\tnew s: ____(NEW_0)____;\n\tnew a: seed;\n\tout(c, pk(s));\n\tout(c, penc(h(w), pk(s), a))\n\n(* EXPECTPV\nRESULT Weak secret w is true.\n0.016s (user 0.016s + system 0.000s), max rss 10280K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Basic weak secret example, from JLAP paper\n   Corrected version *)\n\ntype skey.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun penc(bitstring, pkey, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall x: bitstring, y: skey, z: seed;  pdec(penc(x, pk(y), z), y) = x.\n\n(* Hash function *)\n\nfun h(passwd): bitstring.\n\nfree c: channel.\nfree w: passwd [private].\n\nweaksecret w.\n\nprocess\n\tnew s: skey;\n\tnew a: seed;\n\tout(c, pk(s));\n\tout(c, penc(h(w), pk(s), a))\n\n(* EXPECTPV\nRESULT Weak secret w is true.\n0.016s (user 0.016s + system 0.000s), max rss 10280K\nEND *)"
    },
    {
        "file": "PV-1/bull_simplified.pv",
        "incomplete": "const ____(CONST_0)____ : bitstring.\n\nfree c : ____(FREE_1)____.\n\nfree ____(OP_2)____ : bitstring [ private ].\nfree Kbc : bitstring [ private ].\n\nfree ____(OP_3)____ : bitstring [ private ].\nfree Kbs : bitstring [ ____(FREE_2)____ ].\nfree Kcs : ____(FREE_0)____.\n\n(*fun key2bits(symkey)    : bitstring.\nreduc forall x:symkey; bits2key(key2bits(x)) = x.*)\n\nfun con3(____(OP_7)____, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring;\n  decon3(con3(x1, x2, x3)) = (x1, x2, x3).\nfun con4(bitstring, bitstring, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring, x4 : bitstring;\n  decon4(con4(x1, x2, x3, x4)) = (x1, x2, x3, x4).\nfun con5(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring, x4 : bitstring, x5 : bitstring;\n  decon5(con5(x1, x2, x3, x4, x5)) = (x1, x2, x3, x4, x5).\n\nfree idA : bitstring.\nfree idB : bitstring.\nfree idC : bitstring.\nfree ____(FREE_3)____ : bitstring.\n\n(* Symmetric key crpyotgraphy*)\nfun enc(____(FUN_1)____, bitstring): bitstring.\nfun dec(bitstring, bitstring) : bitstring.\nequation forall m: bitstring, k: bitstring;\n  dec(enc(m, ____(OP_8)____), k) = m.\n\nfun h(____(FUN_0)____, bitstring) : bitstring.\n\nfun xor(bitstring, bitstring) : bitstring.\n\n(*query attacker(Kas).*)\n(*query attacker(Kbs).*)\n(*query attacker(Kcs).*)\nquery attacker(____(QUERY_0)____).\n(*query attacker(Kbc).*)\n\nlet A =\n  new Na:bitstring;\n  let Xa = (\n    h(con3(idA, idB, Na), Kas), (* 1. calc hash A -> B *)\n    (idA, idB, Na)              (* 1. calc rest A -> B *)\n  ) in\n  out(c, Xa);                   (* 1. send A -> B *)\n  in(c, (idA1 : bitstring, idB1 : bitstring, xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring)); (* 6. recv B -> A *)\n  if idA1 = idA then (                                       (* 6. check B -> A *)\n  if idB1 = idB then (                                       (* 6. check B -> A *)\n  let Kab = xor(xor_Kab_h_Na_Kas, h(Na, Kas)) in   (* 6. new key Kab *)\n  let idA_idB_Na = dec(enc_idA_idB_Na_Kab, ____(LET_13)____) in\n  if idA_idB_Na = con3(idA, idB, Na) then (                  (* 6. check B -> A : verify key Kab *)\n    0                                                        (* completed *)\n  ))).\n\nlet B =\n  in(c, (hsh : bitstring, (idSrc  : bitstring,         (* 1. recv A -> B *)\n                           idDst  : bitstring,\n                           Nounce : bitstring)));\n\n  if idSrc = idA then (                                (* 1. check rest A -> B *)\n  if idDst = idB then (                                (* 1. check rest A -> B *)\n  if hsh   = h(con3(idSrc, idDst, Nounce), Kas) then ( (* 1. check hash A -> B *)\n    new Nb:bitstring;\n\n    let Na     = Nounce in                             (* 1. recon A -> B *)\n    let Xa     = (hsh, (idA, idB, Na)) in              (* 1. recon A -> B *)\n    let Xa_con = con4(hsh, idA, idB, Na) in\n    let Xb     = (\n      h(con4(idB, idC, Nb, Xa_con), Kbs),              (* 2. calc hash B -> C *)\n      (idB, idC, Nb, Xa)                               (* 2. calc rest B -> C *)\n    ) in\n    out(c, Xb);                                        (* 2. send B -> C *)\n    in(c, (idA1 : bitstring, idB1 : bitstring, xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring, (* 5. recv C -> B *)\n           idB2 : bitstring, idA2 : bitstring, xor_Kab_h_Nb_Kbs : bitstring, enc_idB_idA_Nb_Kab : bitstring,\n           idB3 : bitstring, idC1 : bitstring, xor_Kbc_h_Nb_Kbs : bitstring, enc_idB_idC_Nb_Kbc : bitstring));\n    if idA1 = idA then (                                       (* 5. check C -> B *)\n    if idA2 = idA then (                                       (* 5. check C -> B *)\n    if idB1 = idB then (                                       (* 5. check C -> B *)\n    if idB2 = idB then (                                       (* 5. check C -> B *)\n    if idB3 = idB then (                                       (* 5. check C -> B *)\n    if idC1 = idC then (                                       (* 5. check C -> B *)\n    let Kbc = xor(xor_Kbc_h_Nb_Kbs, h(Nb, Kbs)) in   (* 5. new key Kbc *)\n    let idB_idC_Nb = dec(enc_idB_idC_Nb_Kbc, ____(OP_12)____) in\n    if idB_idC_Nb  = con3(idB, idC, Nb) then (                 (* 5. check C -> B : verify key Kbc *)\n    let Kab = xor(xor_Kab_h_Nb_Kbs, h(Nb, Kbs)) in   (* 5. new key Kab *)\n    let idB_idA_Nb = dec(enc_idB_idA_Nb_Kab, Kab) in\n    if idB_idA_Nb  = con3(idB, idA, Nb) then (                 (* 5. check C -> B : verify key Kab *)\n      out(c, (idA, idB, xor_Kab_h_Na_Kas, enc_idA_idB_Na_Kab)); (* 6. send B -> A *)\n      0                                                         (* completed *)\n    ))))))))\n  ))).\n\nlet ____(LET_18)____ =\n  in(c, (hsh1st : bitstring, (idSrc1st  : bitstring,                      (* 2. recv B -> C *)\n                              idDst1st  : bitstring,\n                              Nounce1st : bitstring, (hsh2nd : bitstring, (idSrc2nd  : bitstring,\n                                                                           idDst2nd  : bitstring,\n                                                                           Nounce2nd : bitstring))\n                                                                           )));\n\n  if idSrc1st = idB then (                                          (* 3. check rest B -> C *)\n  if idDst1st = idC then (                                          (* 3. check rest B -> C *)\n  if idSrc2nd = idA then (                                          (* 3. check rest B -> C *)\n  if idDst2nd = idB then (                                          (* 3. check rest B -> C *)\n  if hsh1st   = h(con4(idSrc1st, idDst1st, Nounce1st,               (* 3. check hash B -> C *)\n                       con4(hsh2nd, idSrc2nd, idDst2nd, Nounce2nd)),\n                  Kbc) then (\n    new ____(NEW_0)____:bitstring;\n    out(c, Nc);                                               (* info leak due to compromise *)\n\n    let Na     = Nounce2nd in                                       (* recon A -> B in 1. *)\n    let Xa     = (hsh2nd, (idA, idB, Na)) in                        (* recon A -> B in 1. *)\n    let ____(LET_12)____ = con4(hsh2nd, idA, ____(LET_11)____, Na) in\n\n    let Nb     = Nounce1st in                                       (* recon B -> C in 2. *)\n    let Xb     = (hsh1st, (idB, idC, Nb, Xa)) in                    (* recon B -> C in 2. *)\n    let Xb_con = con5(hsh1st, idB, idC, Nb, Xa_con) in\n\n    let Xc = (\n      h(con4(idC, idS, Nc, Xb), Kcs),                               (* 3. calc hash C -> S *)\n      (idC, idS, Nc, Xb)                                            (* 3. calc rest C -> S *)\n    ) in\n    out(c, Xc);                                                     (* 3. send C -> S *)\n    in(c, (xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring, (* 4. recv S -> C *)\n           xor_Kab_h_Nb_Kbs : bitstring, enc_idB_idA_Nb_Kab : bitstring,\n           xor_Kbc_h_Nb_Kbs : bitstring, enc_idB_idC_Nb_Kbc : bitstring,\n           xor_Kbc_h_Nc_Kcs : bitstring, enc_idC_idB_Nc_Kbc : bitstring));   (* <= only entry that C can manipulate *)\n    let Kbc = xor(xor_Kbc_h_Nc_Kcs, h(Nc, Kcs)) in   (* 4. new key Kbc *)\n    out(c, Kbc);                                               (* info leak due to compromise *)\n    let idC_idB_Nc = dec(enc_idC_idB_Nc_Kbc, ____(LET_0)____) in\n    if idC_idB_Nc  = con3(idC, idB, Nc) then (                  (* 4. check S -> C : verify key Kbc *)\n      out(c, (idA, idB, xor_Kab_h_Na_Kas, enc_idA_idB_Na_Kab,   (* 5. send C -> B *)\n              idB, idA, xor_Kab_h_Nb_Kbs, ____(OP_17)____,\n              idB, idC, ____(OP_20)____, enc_idB_idC_Nb_Kbc));\n      0                                                         (* completed *)\n    )\n  ))))).\n\nlet S =\n  in(c, (hsh1st : bitstring, (idSrc1st  : bitstring,   (* 3. recv C -> S *)\n                              idDst1st  : bitstring,\n                              Nounce1st : bitstring, (hsh2nd : bitstring, (idSrc2nd  : bitstring,\n                                                                           idDst2nd  : bitstring,\n                                                                           Nounce2nd : bitstring, (hsh3rd : bitstring, (idSrc3rd  : bitstring,\n                                                                                                                        idDst3rd  : bitstring,\n                                                                                                                        Nounce3rd : bitstring))\n                                                                                                                        )))));\n  if idSrc1st = idC then (                                                 (* 3. check rest C -> S *)\n  if idDst1st = idS then (                                                 (* 3. check rest C -> S *)\n  if idSrc2nd = idB then (                                                 (* 3. check rest C -> S *)\n  if idDst2nd = idC then (                                                 (* 3. check rest C -> S *)\n  if idSrc3rd = idA then (                                                 (* 3. check rest C -> S *)\n  if idDst3rd = idB then (                                                 (* 3. check rest C -> S *)\n  if hsh1st   = h(con4(idSrc1st, idDst1st, Nounce1st,                      (* 3. check hash C -> S *)\n                       con5(hsh2nd, idSrc2nd, idDst2nd, Nounce2nd,\n                            con4(hsh3rd, idSrc3rd, idDst3rd, Nounce3rd))),\n                  Kcs) then (\n    let Na     = Nounce3rd in                                       (* recon A -> B in 1. *)\n    let Xa     = (hsh3rd, (idA, idB, Na)) in                        (* recon A -> B in 1. *)\n    let Xa_con = con4(____(LET_9)____, idA, idB, ____(LET_10)____) in\n\n    let Nb     = Nounce2nd in                                       (* recon B -> C in 2. *)\n    let Xb     = (hsh2nd, (idB, idC, Nb, Xa)) in                    (* recon B -> C in 2. *)\n    let Xb_con = con5(hsh2nd, idB, idC, Nb, Xa_con) in\n\n    let Nc     = Nounce1st in                                       (* recon C -> S in 3. *)\n    let Xc     = (hsh1st, (idC, idS, Nc, Xb)) in                    (* recon C -> S in 3. *)\n    let Xc_con = con5(hsh1st, idC, idS, Nc, Xb_con) in\n\n    out(c, (xor(Kab, h(Na, Kas)), enc(con3(idA, idB, Na), Kab),  (* 4. send S -> C *)\n            xor(____(OP_0)____, h(Nb, Kbs)), enc(con3(idB, idA, Nb), Kab),\n            xor(Kbc, h(Nb, ____(OP_11)____)), enc(con3(idB, idC, Nb), Kbc),\n            xor(Kbc, h(Nc, Kcs)), enc(con3(idC, idB, Nc), Kbc)))\n  ))))))).\n\nprocess\n  A|B|C|S",
        "complete:": "const ZERO : bitstring.\n\nfree c : channel.\n\nfree Kab : bitstring [ private ].\nfree Kbc : bitstring [ private ].\n\nfree Kas : bitstring [ private ].\nfree Kbs : bitstring [ private ].\nfree Kcs : bitstring.\n\n(*fun key2bits(symkey)    : bitstring.\nreduc forall x:symkey; bits2key(key2bits(x)) = x.*)\n\nfun con3(bitstring, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring;\n  decon3(con3(x1, x2, x3)) = (x1, x2, x3).\nfun con4(bitstring, bitstring, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring, x4 : bitstring;\n  decon4(con4(x1, x2, x3, x4)) = (x1, x2, x3, x4).\nfun con5(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\nreduc forall x1 : bitstring, x2 : bitstring, x3 : bitstring, x4 : bitstring, x5 : bitstring;\n  decon5(con5(x1, x2, x3, x4, x5)) = (x1, x2, x3, x4, x5).\n\nfree idA : bitstring.\nfree idB : bitstring.\nfree idC : bitstring.\nfree idS : bitstring.\n\n(* Symmetric key crpyotgraphy*)\nfun enc(bitstring, bitstring): bitstring.\nfun dec(bitstring, bitstring) : bitstring.\nequation forall m: bitstring, k: bitstring;\n  dec(enc(m, k), k) = m.\n\nfun h(bitstring, bitstring) : bitstring.\n\nfun xor(bitstring, bitstring) : bitstring.\n\n(*query attacker(Kas).*)\n(*query attacker(Kbs).*)\n(*query attacker(Kcs).*)\nquery attacker(Kab).\n(*query attacker(Kbc).*)\n\nlet A =\n  new Na:bitstring;\n  let Xa = (\n    h(con3(idA, idB, Na), Kas), (* 1. calc hash A -> B *)\n    (idA, idB, Na)              (* 1. calc rest A -> B *)\n  ) in\n  out(c, Xa);                   (* 1. send A -> B *)\n  in(c, (idA1 : bitstring, idB1 : bitstring, xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring)); (* 6. recv B -> A *)\n  if idA1 = idA then (                                       (* 6. check B -> A *)\n  if idB1 = idB then (                                       (* 6. check B -> A *)\n  let Kab = xor(xor_Kab_h_Na_Kas, h(Na, Kas)) in   (* 6. new key Kab *)\n  let idA_idB_Na = dec(enc_idA_idB_Na_Kab, Kab) in\n  if idA_idB_Na = con3(idA, idB, Na) then (                  (* 6. check B -> A : verify key Kab *)\n    0                                                        (* completed *)\n  ))).\n\nlet B =\n  in(c, (hsh : bitstring, (idSrc  : bitstring,         (* 1. recv A -> B *)\n                           idDst  : bitstring,\n                           Nounce : bitstring)));\n\n  if idSrc = idA then (                                (* 1. check rest A -> B *)\n  if idDst = idB then (                                (* 1. check rest A -> B *)\n  if hsh   = h(con3(idSrc, idDst, Nounce), Kas) then ( (* 1. check hash A -> B *)\n    new Nb:bitstring;\n\n    let Na     = Nounce in                             (* 1. recon A -> B *)\n    let Xa     = (hsh, (idA, idB, Na)) in              (* 1. recon A -> B *)\n    let Xa_con = con4(hsh, idA, idB, Na) in\n    let Xb     = (\n      h(con4(idB, idC, Nb, Xa_con), Kbs),              (* 2. calc hash B -> C *)\n      (idB, idC, Nb, Xa)                               (* 2. calc rest B -> C *)\n    ) in\n    out(c, Xb);                                        (* 2. send B -> C *)\n    in(c, (idA1 : bitstring, idB1 : bitstring, xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring, (* 5. recv C -> B *)\n           idB2 : bitstring, idA2 : bitstring, xor_Kab_h_Nb_Kbs : bitstring, enc_idB_idA_Nb_Kab : bitstring,\n           idB3 : bitstring, idC1 : bitstring, xor_Kbc_h_Nb_Kbs : bitstring, enc_idB_idC_Nb_Kbc : bitstring));\n    if idA1 = idA then (                                       (* 5. check C -> B *)\n    if idA2 = idA then (                                       (* 5. check C -> B *)\n    if idB1 = idB then (                                       (* 5. check C -> B *)\n    if idB2 = idB then (                                       (* 5. check C -> B *)\n    if idB3 = idB then (                                       (* 5. check C -> B *)\n    if idC1 = idC then (                                       (* 5. check C -> B *)\n    let Kbc = xor(xor_Kbc_h_Nb_Kbs, h(Nb, Kbs)) in   (* 5. new key Kbc *)\n    let idB_idC_Nb = dec(enc_idB_idC_Nb_Kbc, Kbc) in\n    if idB_idC_Nb  = con3(idB, idC, Nb) then (                 (* 5. check C -> B : verify key Kbc *)\n    let Kab = xor(xor_Kab_h_Nb_Kbs, h(Nb, Kbs)) in   (* 5. new key Kab *)\n    let idB_idA_Nb = dec(enc_idB_idA_Nb_Kab, Kab) in\n    if idB_idA_Nb  = con3(idB, idA, Nb) then (                 (* 5. check C -> B : verify key Kab *)\n      out(c, (idA, idB, xor_Kab_h_Na_Kas, enc_idA_idB_Na_Kab)); (* 6. send B -> A *)\n      0                                                         (* completed *)\n    ))))))))\n  ))).\n\nlet C =\n  in(c, (hsh1st : bitstring, (idSrc1st  : bitstring,                      (* 2. recv B -> C *)\n                              idDst1st  : bitstring,\n                              Nounce1st : bitstring, (hsh2nd : bitstring, (idSrc2nd  : bitstring,\n                                                                           idDst2nd  : bitstring,\n                                                                           Nounce2nd : bitstring))\n                                                                           )));\n\n  if idSrc1st = idB then (                                          (* 3. check rest B -> C *)\n  if idDst1st = idC then (                                          (* 3. check rest B -> C *)\n  if idSrc2nd = idA then (                                          (* 3. check rest B -> C *)\n  if idDst2nd = idB then (                                          (* 3. check rest B -> C *)\n  if hsh1st   = h(con4(idSrc1st, idDst1st, Nounce1st,               (* 3. check hash B -> C *)\n                       con4(hsh2nd, idSrc2nd, idDst2nd, Nounce2nd)),\n                  Kbc) then (\n    new Nc:bitstring;\n    out(c, Nc);                                               (* info leak due to compromise *)\n\n    let Na     = Nounce2nd in                                       (* recon A -> B in 1. *)\n    let Xa     = (hsh2nd, (idA, idB, Na)) in                        (* recon A -> B in 1. *)\n    let Xa_con = con4(hsh2nd, idA, idB, Na) in\n\n    let Nb     = Nounce1st in                                       (* recon B -> C in 2. *)\n    let Xb     = (hsh1st, (idB, idC, Nb, Xa)) in                    (* recon B -> C in 2. *)\n    let Xb_con = con5(hsh1st, idB, idC, Nb, Xa_con) in\n\n    let Xc = (\n      h(con4(idC, idS, Nc, Xb), Kcs),                               (* 3. calc hash C -> S *)\n      (idC, idS, Nc, Xb)                                            (* 3. calc rest C -> S *)\n    ) in\n    out(c, Xc);                                                     (* 3. send C -> S *)\n    in(c, (xor_Kab_h_Na_Kas : bitstring, enc_idA_idB_Na_Kab : bitstring, (* 4. recv S -> C *)\n           xor_Kab_h_Nb_Kbs : bitstring, enc_idB_idA_Nb_Kab : bitstring,\n           xor_Kbc_h_Nb_Kbs : bitstring, enc_idB_idC_Nb_Kbc : bitstring,\n           xor_Kbc_h_Nc_Kcs : bitstring, enc_idC_idB_Nc_Kbc : bitstring));   (* <= only entry that C can manipulate *)\n    let Kbc = xor(xor_Kbc_h_Nc_Kcs, h(Nc, Kcs)) in   (* 4. new key Kbc *)\n    out(c, Kbc);                                               (* info leak due to compromise *)\n    let idC_idB_Nc = dec(enc_idC_idB_Nc_Kbc, Kbc) in\n    if idC_idB_Nc  = con3(idC, idB, Nc) then (                  (* 4. check S -> C : verify key Kbc *)\n      out(c, (idA, idB, xor_Kab_h_Na_Kas, enc_idA_idB_Na_Kab,   (* 5. send C -> B *)\n              idB, idA, xor_Kab_h_Nb_Kbs, enc_idB_idA_Nb_Kab,\n              idB, idC, xor_Kbc_h_Nb_Kbs, enc_idB_idC_Nb_Kbc));\n      0                                                         (* completed *)\n    )\n  ))))).\n\nlet S =\n  in(c, (hsh1st : bitstring, (idSrc1st  : bitstring,   (* 3. recv C -> S *)\n                              idDst1st  : bitstring,\n                              Nounce1st : bitstring, (hsh2nd : bitstring, (idSrc2nd  : bitstring,\n                                                                           idDst2nd  : bitstring,\n                                                                           Nounce2nd : bitstring, (hsh3rd : bitstring, (idSrc3rd  : bitstring,\n                                                                                                                        idDst3rd  : bitstring,\n                                                                                                                        Nounce3rd : bitstring))\n                                                                                                                        )))));\n  if idSrc1st = idC then (                                                 (* 3. check rest C -> S *)\n  if idDst1st = idS then (                                                 (* 3. check rest C -> S *)\n  if idSrc2nd = idB then (                                                 (* 3. check rest C -> S *)\n  if idDst2nd = idC then (                                                 (* 3. check rest C -> S *)\n  if idSrc3rd = idA then (                                                 (* 3. check rest C -> S *)\n  if idDst3rd = idB then (                                                 (* 3. check rest C -> S *)\n  if hsh1st   = h(con4(idSrc1st, idDst1st, Nounce1st,                      (* 3. check hash C -> S *)\n                       con5(hsh2nd, idSrc2nd, idDst2nd, Nounce2nd,\n                            con4(hsh3rd, idSrc3rd, idDst3rd, Nounce3rd))),\n                  Kcs) then (\n    let Na     = Nounce3rd in                                       (* recon A -> B in 1. *)\n    let Xa     = (hsh3rd, (idA, idB, Na)) in                        (* recon A -> B in 1. *)\n    let Xa_con = con4(hsh3rd, idA, idB, Na) in\n\n    let Nb     = Nounce2nd in                                       (* recon B -> C in 2. *)\n    let Xb     = (hsh2nd, (idB, idC, Nb, Xa)) in                    (* recon B -> C in 2. *)\n    let Xb_con = con5(hsh2nd, idB, idC, Nb, Xa_con) in\n\n    let Nc     = Nounce1st in                                       (* recon C -> S in 3. *)\n    let Xc     = (hsh1st, (idC, idS, Nc, Xb)) in                    (* recon C -> S in 3. *)\n    let Xc_con = con5(hsh1st, idC, idS, Nc, Xb_con) in\n\n    out(c, (xor(Kab, h(Na, Kas)), enc(con3(idA, idB, Na), Kab),  (* 4. send S -> C *)\n            xor(Kab, h(Nb, Kbs)), enc(con3(idB, idA, Nb), Kab),\n            xor(Kbc, h(Nb, Kbs)), enc(con3(idB, idC, Nb), Kbc),\n            xor(Kbc, h(Nc, Kcs)), enc(con3(idC, idB, Nc), Kbc)))\n  ))))))).\n\nprocess\n  A|B|C|S"
    },
    {
        "file": "PV-1/cca2.pv",
        "incomplete": "(************************* Channel *************************)\nfree ch: channel. (* public channel *)\nfree ttp_ch: channel [private]. (* private channel between ttp and setup server *)\nfree ua_ch: channel [private]. (* private channel between UA and setup server *)\n\n(************************* Types *************************)\ntype ____(TYPE_4)____.\ntype spseq_skey [____(TYPE_2)____].\ntype spseq_signature.\ntype spseq_message.\ntype ____(TYPE_1)____.\n\ntype pke_pkey.\ntype pke_skey [private].\ntype ____(TYPE_0)____.\n\ntype point.\ntype nizk_proof.\n\ntype ds_pkey.\ntype ds_skey.\ntype ds_signature.\n\ntype ____(TYPE_3)____.\n\n(************************* Constructors *************************)\n(* sps-eq functions *)\nfun create_spseq_message(____(OP_21)____, point): spseq_message.\nfun spseq_verify(spseq_message, spseq_signature, ____(OP_38)____): spseq_message.\nfun spseq_sign(____(FUN_1)____, spseq_skey): spseq_signature.\nfun ChgRep_message(spseq_message, ____(FUN_2)____, gsk): spseq_message.\nfun ChgRep_signature(spseq_signature, ____(OP_10)____, ____(FUN_0)____): spseq_signature.\n\n(* pke functions *)\nfun pke_enc(point, ____(FUN_4)____, pke_parameter): bitstring.\nreduc forall pke_m:point, pke_pk:pke_pkey, pke_par:pke_parameter, pke_sk:pke_skey; pke_dec(pke_enc(____(OP_25)____, ____(OP_26)____, pke_par), pke_par, pke_sk) = pke_m.\n\n(* nizk function *)\nfun nizk_hash(____(FUN_10)____, ____(OP_15)____, point):bitstring.\nfun nizk_calc_r(____(FUN_3)____, bitstring, bitstring):bitstring.\nfun nizk_calc_Vp(bitstring, point): point.\nfun nizk_calc_Vv(bitstring, bitstring, point, point):point.\nfun nizk_cal_point(bitstring, point):point.\n\n(* ds functions *)\nfun ds_sign(bitstring, ____(OP_18)____): ____(FUN_7)____.\nreduc forall ____(REDUC_0)____:____(REDUC_1)____, ds_sk:ds_skey, ds_pk:ds_pkey; ds_verify(ds_sign(____(REDUC_2)____, ds_sk), ____(REDUC_3)____, ds_pk) = ds_m.\n\n(* other *)\nfun create_point_mul(bitstring, spseq_bg): point.\n\n(* Signing functions *)\nfun calc_C1(bitstring, spseq_signature):point.\nfun calc_C2(bitstring, bitstring, spseq_signature):____(FUN_5)____.\nfun calc_N(bitstring, spseq_bg):point.\nfun calc_M1(bitstring, spseq_signature):point.\nfun calc_M2(bitstring, bitstring, spseq_bg):point.\nfun sign_hash(point,point, point, spseq_signature, spseq_message): bitstring.\nfun calc_z1(____(FUN_6)____, bitstring, bitstring):bitstring.\nfun calc_z2(bitstring, bitstring, bitstring):bitstring.\n\n(* Verify functions *)\nfun calc_N_hat(bitstring, bitstring, spseq_bg, spseq_message):point.\nfun calc_M1_hat(bitstring, bitstring, ____(OP_45)____, point):point.\nfun calc_M2_hat(____(OP_24)____, bitstring, bitstring, ____(FUN_8)____, ____(FUN_9)____):point.\n\n(* Open fuctions *)\nfun pairing_lhs(spseq_bg, spseq_signature):point.\nfun pairing_rhs(point, spseq_signature):point.\n\n(************************* Events *************************)\nevent sig_verified(spseq_pkey).\nevent sig_open(spseq_pkey). \nevent send_message(spseq_pkey).\n\n(************************* Queries *************************)\n(* Authenticty query *)\n  (* sender authenticy *)\n  query spseq_pk:spseq_pkey; event(sig_verified(____(OP_13)____)) ==> event(send_message(____(OP_0)____)).\n  query spseq_pk:spseq_pkey; event(sig_open(spseq_pk)) ==> event(send_message(____(OP_31)____)).\n\n(* impersoniation resistance *)\n  (* the attacker is not in possession of the value *)\n  free ____(OP_8)____:gsk [private].\n  query attacker(secret_gsk).\n\n  (* strong secrecy/non-interference gsk --> attacker can not deduce any information about the value of gsk *)\n  noninterf secret_gsk.\n\n(************************* Processes UA *************************)\nlet UA =\n  (* SETUP PHASE *)\n    in(____(OP_22)____, (bg:spseq_bg, spseq_pk:____(OP_23)____));\n    in(ua_ch, (____(OP_41)____:pke_pkey, ____(OP_40)____:pke_parameter));\n    in(____(OP_19)____, ds_sk:ds_skey);\n\n  (* JOIN PHASE *)\n    new ____(NEW_3)____:bitstring;\n    new r:bitstring;\n    new Q:point;\n    new U:point;\n    let rP_hat = create_point_mul(r,bg) in\n    (* pke encrypt rP_hat *)\n    let C = pke_enc(rP_hat, pke_pk, pke_param) in\n\n    (* ds sign the encrypted rP_hat *)\n    let ds_sig = ds_sign(C, ds_sk) in\n\n    (* nizk gen p and v *)\n    let A = create_point_mul(____(LET_7)____, bg) in\n    new p1:bitstring;\n    new v1:bitstring;\n    let Vp1 = nizk_calc_Vp(v1, Q) in\n    let cp1 = nizk_hash(Q, Vp1, ____(LET_6)____) in\n    let rp1 = nizk_calc_r(v1, ____(OP_27)____, cp1) in\n    out(ch, (U, Q, C, ds_sig, cp1, rp1));\n\n    (* receive ttp response *)\n    in(ch, ____(OP_2)____:spseq_signature);\n  \n  (* SIGNING PHASE *)\n    (* randomize spseq sig *)\n    new inv_q:bitstring;\n    let mes = create_spseq_message(____(OP_36)____,____(LET_3)____) in\n    let rand_mes = ChgRep_message(____(LET_9)____, ____(OP_20)____, secret_gsk) in\n    let rand_sig = ChgRep_signature(spseq_sig, inv_q, secret_gsk) in\n    let ver_spseq = spseq_verify(mes, spseq_sig, spseq_pk) in\n    \n    (* signing *)\n    new u:bitstring;\n    new rho:bitstring;\n    new v:____(NEW_5)____;\n    new n:bitstring;\n    let mes_drone = ChgRep_message(____(OP_32)____, rho, secret_gsk) in\n    let sig_drone = ChgRep_signature(rand_sig, rho, secret_gsk) in\n\n    (* calculate hash components *)\n    let ____(LET_0)____ = calc_C1(u, sig_drone) in\n    let C2 = calc_C2(u, ____(LET_12)____, sig_drone) in\n    let N = calc_N(v, ____(OP_37)____) in\n    let M1 = calc_M1(n, sig_drone) in\n    let M2 = calc_M2(v, n, bg) in\n\n    (* hash c(N,M1,M2, sig, m) *)\n    let c = sign_hash(N, M1, M2, sig_drone, mes_drone) in\n    let z1 = calc_z1(____(LET_13)____, c, rho) in\n    let z2 = calc_z2(____(LET_10)____, c, u) in\n\n    (* send message *)\n    event send_message(spseq_pk);\n    out(ch, (mes_drone, ____(OP_29)____, ____(OP_28)____, C2, c, z1, ____(OP_30)____)).\n    \n(************************* Processes TTP *************************)\nlet observer =\n  (* SETUP PHASE *)\n  (* recieve public param *)\n  in(ch, (bg:____(OP_43)____, ____(OP_42)____:spseq_pkey));\n\n  (* OPEN PHASE *)\n  (* receive message *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, C1:point, C2:point, c:bitstring, z1:bitstring, z2:bitstring));\n  let ver_spseq = spseq_verify(mes, ____(OP_17)____, spseq_pk) in\n  let ____(LET_18)____ = calc_N_hat(____(OP_16)____, c, ____(LET_17)____, mes) in\n  let M1_hat = calc_M1_hat(____(OP_47)____, c, ____(LET_15)____, ____(LET_14)____) in\n  let M2_hat = calc_M2_hat(z1, z2, c, sig, C2) in\n  let c_check = sign_hash(____(LET_5)____, ____(LET_4)____, M2_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk).\n\n(************************* Processes TTP *************************)\nlet TTP =\n  (* SETUP PHASE *)\n  (* recieve setup info *)\n  in(ttp_ch, (bg:spseq_bg, spseq_sk:spseq_skey, spseq_pk:spseq_pkey));\n  in(ttp_ch, (____(OP_34)____:____(OP_33)____, pke_param:pke_parameter));\n  in(____(OP_9)____, ds_pk:ds_pkey);\n \n  (* JOIN PHASE *)\n  (* Receive join info *)\n  in(____(OP_5)____, (U:____(OP_4)____, Q:point, C:____(OP_3)____, ds_sig:____(OP_6)____, cp1:____(OP_7)____, rp1:bitstring));\n  (* create spseq sig *)\n  let spseq_mes = create_spseq_message(U,Q) in\n  let spseq_sig = spseq_sign(spseq_mes, ____(OP_39)____) in\n  (* verify nizk *)    \n  let A = create_point_mul(C, bg) in\n  let Vv1 = nizk_calc_Vv(cp1, rp1, A, Q) in\n  let cv1 = nizk_hash(____(LET_2)____, Vv1, A) in\n  (* verify ds *)\n  let C_sig = ds_verify(ds_sig, C, ____(LET_16)____) in\n  out(ch, spseq_sig);\n\n  (* VERIFY PHASE *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, C1:point, C2:point, c:bitstring, z1:bitstring, z2:bitstring));\n  let ____(LET_8)____ = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z1, c, bg, ____(OP_35)____) in\n  let M1_hat = calc_M1_hat(z2, c, sig, C1) in\n  let M2_hat = calc_M2_hat(z1, z2, c, sig, C2) in\n  let c_check = sign_hash(N_hat, M1_hat, M2_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk);\n\n  (* OPEN PHASE *)\n  let ____(LET_1)____ = pke_dec(C, pke_param, pke_sk) in \n  let lhs = pairing_lhs(bg, ____(LET_11)____) in\n  let rhs = pairing_rhs(____(OP_44)____, sig) in\n  if rhs = ____(IF_0)____ then event sig_open(spseq_pk). \n\n(************************* Processes setup_server *************************)\nlet setup_server =\n  (* setup spseq *)\n  new bg:____(NEW_1)____;\n  new spseq_sk:spseq_skey;\n  new spseq_pk:spseq_pkey;\n  out(ua_ch, (bg, spseq_pk));\n  out(ttp_ch, (bg, spseq_sk, spseq_pk));\n\n  (* setup pke *)\n  new pke_sk:____(NEW_6)____;\n  new ____(NEW_0)____:pke_pkey;\n  new pke_param:____(NEW_4)____;\n  out(ua_ch, (pke_pk, pke_param));\n  out(ttp_ch, (pke_sk, pke_param));\n\n  (* setup ds *)\n  new ____(NEW_2)____:ds_pkey;\n  new ds_sk:ds_skey;\n  out(ua_ch, ds_sk);\n  out(ttp_ch, ds_pk);\n\n  (* publish public info *)\n  out(ch, (____(OP_1)____, spseq_pk)).\n\nprocess\n  ( (setup_server) | (!TTP) | (!UA) | (!observer))",
        "complete:": "(************************* Channel *************************)\nfree ch: channel. (* public channel *)\nfree ttp_ch: channel [private]. (* private channel between ttp and setup server *)\nfree ua_ch: channel [private]. (* private channel between UA and setup server *)\n\n(************************* Types *************************)\ntype spseq_pkey.\ntype spseq_skey [private].\ntype spseq_signature.\ntype spseq_message.\ntype spseq_bg.\n\ntype pke_pkey.\ntype pke_skey [private].\ntype pke_parameter.\n\ntype point.\ntype nizk_proof.\n\ntype ds_pkey.\ntype ds_skey.\ntype ds_signature.\n\ntype gsk.\n\n(************************* Constructors *************************)\n(* sps-eq functions *)\nfun create_spseq_message(point, point): spseq_message.\nfun spseq_verify(spseq_message, spseq_signature, spseq_pkey): spseq_message.\nfun spseq_sign(spseq_message, spseq_skey): spseq_signature.\nfun ChgRep_message(spseq_message, bitstring, gsk): spseq_message.\nfun ChgRep_signature(spseq_signature, bitstring, gsk): spseq_signature.\n\n(* pke functions *)\nfun pke_enc(point, pke_pkey, pke_parameter): bitstring.\nreduc forall pke_m:point, pke_pk:pke_pkey, pke_par:pke_parameter, pke_sk:pke_skey; pke_dec(pke_enc(pke_m, pke_pk, pke_par), pke_par, pke_sk) = pke_m.\n\n(* nizk function *)\nfun nizk_hash(point, point, point):bitstring.\nfun nizk_calc_r(bitstring, bitstring, bitstring):bitstring.\nfun nizk_calc_Vp(bitstring, point): point.\nfun nizk_calc_Vv(bitstring, bitstring, point, point):point.\nfun nizk_cal_point(bitstring, point):point.\n\n(* ds functions *)\nfun ds_sign(bitstring, ds_skey): ds_signature.\nreduc forall ds_m:bitstring, ds_sk:ds_skey, ds_pk:ds_pkey; ds_verify(ds_sign(ds_m, ds_sk), ds_m, ds_pk) = ds_m.\n\n(* other *)\nfun create_point_mul(bitstring, spseq_bg): point.\n\n(* Signing functions *)\nfun calc_C1(bitstring, spseq_signature):point.\nfun calc_C2(bitstring, bitstring, spseq_signature):point.\nfun calc_N(bitstring, spseq_bg):point.\nfun calc_M1(bitstring, spseq_signature):point.\nfun calc_M2(bitstring, bitstring, spseq_bg):point.\nfun sign_hash(point,point, point, spseq_signature, spseq_message): bitstring.\nfun calc_z1(bitstring, bitstring, bitstring):bitstring.\nfun calc_z2(bitstring, bitstring, bitstring):bitstring.\n\n(* Verify functions *)\nfun calc_N_hat(bitstring, bitstring, spseq_bg, spseq_message):point.\nfun calc_M1_hat(bitstring, bitstring, spseq_signature, point):point.\nfun calc_M2_hat(bitstring, bitstring, bitstring, spseq_signature, point):point.\n\n(* Open fuctions *)\nfun pairing_lhs(spseq_bg, spseq_signature):point.\nfun pairing_rhs(point, spseq_signature):point.\n\n(************************* Events *************************)\nevent sig_verified(spseq_pkey).\nevent sig_open(spseq_pkey). \nevent send_message(spseq_pkey).\n\n(************************* Queries *************************)\n(* Authenticty query *)\n  (* sender authenticy *)\n  query spseq_pk:spseq_pkey; event(sig_verified(spseq_pk)) ==> event(send_message(spseq_pk)).\n  query spseq_pk:spseq_pkey; event(sig_open(spseq_pk)) ==> event(send_message(spseq_pk)).\n\n(* impersoniation resistance *)\n  (* the attacker is not in possession of the value *)\n  free secret_gsk:gsk [private].\n  query attacker(secret_gsk).\n\n  (* strong secrecy/non-interference gsk --> attacker can not deduce any information about the value of gsk *)\n  noninterf secret_gsk.\n\n(************************* Processes UA *************************)\nlet UA =\n  (* SETUP PHASE *)\n    in(ua_ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n    in(ua_ch, (pke_pk:pke_pkey, pke_param:pke_parameter));\n    in(ua_ch, ds_sk:ds_skey);\n\n  (* JOIN PHASE *)\n    new q:bitstring;\n    new r:bitstring;\n    new Q:point;\n    new U:point;\n    let rP_hat = create_point_mul(r,bg) in\n    (* pke encrypt rP_hat *)\n    let C = pke_enc(rP_hat, pke_pk, pke_param) in\n\n    (* ds sign the encrypted rP_hat *)\n    let ds_sig = ds_sign(C, ds_sk) in\n\n    (* nizk gen p and v *)\n    let A = create_point_mul(C, bg) in\n    new p1:bitstring;\n    new v1:bitstring;\n    let Vp1 = nizk_calc_Vp(v1, Q) in\n    let cp1 = nizk_hash(Q, Vp1, A) in\n    let rp1 = nizk_calc_r(v1, r, cp1) in\n    out(ch, (U, Q, C, ds_sig, cp1, rp1));\n\n    (* receive ttp response *)\n    in(ch, spseq_sig:spseq_signature);\n  \n  (* SIGNING PHASE *)\n    (* randomize spseq sig *)\n    new inv_q:bitstring;\n    let mes = create_spseq_message(U,Q) in\n    let rand_mes = ChgRep_message(mes, inv_q, secret_gsk) in\n    let rand_sig = ChgRep_signature(spseq_sig, inv_q, secret_gsk) in\n    let ver_spseq = spseq_verify(mes, spseq_sig, spseq_pk) in\n    \n    (* signing *)\n    new u:bitstring;\n    new rho:bitstring;\n    new v:bitstring;\n    new n:bitstring;\n    let mes_drone = ChgRep_message(rand_mes, rho, secret_gsk) in\n    let sig_drone = ChgRep_signature(rand_sig, rho, secret_gsk) in\n\n    (* calculate hash components *)\n    let C1 = calc_C1(u, sig_drone) in\n    let C2 = calc_C2(u, rho, sig_drone) in\n    let N = calc_N(v, bg) in\n    let M1 = calc_M1(n, sig_drone) in\n    let M2 = calc_M2(v, n, bg) in\n\n    (* hash c(N,M1,M2, sig, m) *)\n    let c = sign_hash(N, M1, M2, sig_drone, mes_drone) in\n    let z1 = calc_z1(v, c, rho) in\n    let z2 = calc_z2(n, c, u) in\n\n    (* send message *)\n    event send_message(spseq_pk);\n    out(ch, (mes_drone, sig_drone, C1, C2, c, z1, z2)).\n    \n(************************* Processes TTP *************************)\nlet observer =\n  (* SETUP PHASE *)\n  (* recieve public param *)\n  in(ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n\n  (* OPEN PHASE *)\n  (* receive message *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, C1:point, C2:point, c:bitstring, z1:bitstring, z2:bitstring));\n  let ver_spseq = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z1, c, bg, mes) in\n  let M1_hat = calc_M1_hat(z2, c, sig, C1) in\n  let M2_hat = calc_M2_hat(z1, z2, c, sig, C2) in\n  let c_check = sign_hash(N_hat, M1_hat, M2_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk).\n\n(************************* Processes TTP *************************)\nlet TTP =\n  (* SETUP PHASE *)\n  (* recieve setup info *)\n  in(ttp_ch, (bg:spseq_bg, spseq_sk:spseq_skey, spseq_pk:spseq_pkey));\n  in(ttp_ch, (pke_sk:pke_skey, pke_param:pke_parameter));\n  in(ttp_ch, ds_pk:ds_pkey);\n \n  (* JOIN PHASE *)\n  (* Receive join info *)\n  in(ch, (U:point, Q:point, C:bitstring, ds_sig:ds_signature, cp1:bitstring, rp1:bitstring));\n  (* create spseq sig *)\n  let spseq_mes = create_spseq_message(U,Q) in\n  let spseq_sig = spseq_sign(spseq_mes, spseq_sk) in\n  (* verify nizk *)    \n  let A = create_point_mul(C, bg) in\n  let Vv1 = nizk_calc_Vv(cp1, rp1, A, Q) in\n  let cv1 = nizk_hash(Q, Vv1, A) in\n  (* verify ds *)\n  let C_sig = ds_verify(ds_sig, C, ds_pk) in\n  out(ch, spseq_sig);\n\n  (* VERIFY PHASE *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, C1:point, C2:point, c:bitstring, z1:bitstring, z2:bitstring));\n  let ver_spseq = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z1, c, bg, mes) in\n  let M1_hat = calc_M1_hat(z2, c, sig, C1) in\n  let M2_hat = calc_M2_hat(z1, z2, c, sig, C2) in\n  let c_check = sign_hash(N_hat, M1_hat, M2_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk);\n\n  (* OPEN PHASE *)\n  let R_hat = pke_dec(C, pke_param, pke_sk) in \n  let lhs = pairing_lhs(bg, sig) in\n  let rhs = pairing_rhs(R_hat, sig) in\n  if rhs = lhs then event sig_open(spseq_pk). \n\n(************************* Processes setup_server *************************)\nlet setup_server =\n  (* setup spseq *)\n  new bg:spseq_bg;\n  new spseq_sk:spseq_skey;\n  new spseq_pk:spseq_pkey;\n  out(ua_ch, (bg, spseq_pk));\n  out(ttp_ch, (bg, spseq_sk, spseq_pk));\n\n  (* setup pke *)\n  new pke_sk:pke_skey;\n  new pke_pk:pke_pkey;\n  new pke_param:pke_parameter;\n  out(ua_ch, (pke_pk, pke_param));\n  out(ttp_ch, (pke_sk, pke_param));\n\n  (* setup ds *)\n  new ds_pk:ds_pkey;\n  new ds_sk:ds_skey;\n  out(ua_ch, ds_sk);\n  out(ttp_ch, ds_pk);\n\n  (* publish public info *)\n  out(ch, (bg, spseq_pk)).\n\nprocess\n  ( (setup_server) | (!TTP) | (!UA) | (!observer))"
    },
    {
        "file": "PV-1/cpa.pv",
        "incomplete": "(************************* Channel *************************)\nfree ch: channel. (* public channel *)\nfree ttp_ch: channel [private]. (* private channel between ttp and setup server *)\nfree ua_ch: channel [private]. (* private channel between UA and setup server *)\n\n(************************* Types *************************)\ntype spseq_pkey.\ntype spseq_skey [____(TYPE_3)____].\ntype spseq_signature.\ntype ____(TYPE_4)____.\ntype spseq_bg.\n\ntype pke_pkey.\ntype ____(TYPE_0)____ [private].\ntype ____(TYPE_1)____.\n\ntype point.\ntype nizk_proof.\n\ntype ds_pkey.\ntype ____(TYPE_2)____.\ntype ds_signature.\n\ntype gsk.\n\n(************************* Constructors *************************)\n(* sps-eq functions *)\nfun create_spseq_message(____(FUN_4)____, point): spseq_message.\nfun spseq_verify(____(FUN_2)____, spseq_signature, spseq_pkey): spseq_message.\nfun spseq_sign(____(OP_24)____, spseq_skey): spseq_signature.\nfun ChgRep_message(____(FUN_7)____, bitstring, gsk): spseq_message.\nfun ChgRep_signature(spseq_signature, bitstring, gsk): spseq_signature.\nfun pk(____(FUN_6)____): spseq_pkey.\n\n(* pke functions *)\nfun pke_enc(point, pke_pkey, ____(FUN_5)____): bitstring.\nreduc forall pke_m:point, pke_pk:pke_pkey, pke_par:pke_parameter, pke_sk:pke_skey; pke_dec(pke_enc(pke_m, pke_pk, ____(OP_30)____), pke_par, ____(OP_31)____) = pke_m.\n\n(* nizk function *)\nfun nizk_hash(____(OP_15)____, point, point):bitstring.\nfun nizk_calc_r(____(OP_20)____, bitstring, bitstring):bitstring.\nfun nizk_calc_Vp(____(FUN_8)____, ____(OP_23)____): point.\nfun nizk_calc_Vv(bitstring, bitstring, point, point):point.\nfun nizk_cal_point(bitstring, point):point.\n\n(* ds functions *)\nfun ds_sign(bitstring, ds_skey): ds_signature.\nreduc ____(REDUC_0)____ ds_m:____(REDUC_1)____, ____(REDUC_3)____:ds_skey, ____(REDUC_2)____:ds_pkey; ds_verify(ds_sign(ds_m, ds_sk), ds_m, ds_pk) = ds_m.\n\n(* other *)\nfun create_point_mul(____(OP_10)____, spseq_bg): point.\n\n(* Signing functions *)\nfun calc_N(bitstring, spseq_bg):point.\nfun sign_hash(point, ____(OP_26)____, ____(FUN_3)____): bitstring.\nfun calc_z(bitstring, bitstring, bitstring):bitstring.\n\n(* Verify functions *)\nfun calc_N_hat(bitstring, bitstring, spseq_bg, spseq_message):point.\nfun calc_M1_hat(____(FUN_1)____, bitstring, spseq_signature, ____(FUN_0)____):point.\nfun calc_M2_hat(bitstring, bitstring, bitstring, spseq_signature, point):point.\n\n(* Open fuctions *)\nfun pairing_lhs(spseq_bg, spseq_signature):point.\nfun pairing_rhs(point, spseq_signature):point.\n\n(************************* Events *************************)\nevent sig_verified(spseq_pkey).\nevent sig_open(spseq_pkey). \nevent send_message(spseq_pkey).\n\n(************************* Queries *************************)\n(* Authenticty query *)\n  (* sender authenticy *)\n  query spseq_pk:spseq_pkey; event(sig_verified(____(OP_16)____)) ==> event(send_message(____(OP_2)____)).\n  query ____(QUERY_0)____:____(QUERY_1)____; event(sig_open(____(OP_34)____)) ==> event(send_message(spseq_pk)).\n\n(* impersoniation resistance *)\n  (* the attacker is not in possession of the value *)\n  free secret_gsk:gsk [private].\n  query attacker(secret_gsk).\n\n  (* strong secrecy/non-interference gsk --> attacker can not deduce any information about the value of gsk *)\n  noninterf secret_gsk.\n\n(************************* Processes UA *************************)\nlet UA =\n  (* SETUP PHASE *)\n    in(ua_ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n    in(____(OP_6)____, (pke_pk:____(OP_7)____, pke_param:pke_parameter));\n    in(ua_ch, ds_sk:____(OP_9)____);\n\n  (* JOIN PHASE *)\n    new q:bitstring;\n    new r:____(NEW_2)____;\n    new Q:point;\n    new U:point;\n    let rP_hat = create_point_mul(____(OP_19)____,bg) in\n    (* pke encrypt rP_hat *)\n    let C = pke_enc(____(LET_5)____, ____(OP_28)____, pke_param) in\n\n    (* ds sign the encrypted rP_hat *)\n    let ds_sig = ds_sign(C, ds_sk) in\n\n    (* nizk gen p and v *)\n    let A = create_point_mul(____(OP_13)____, bg) in\n    new p1:bitstring;\n    new v1:bitstring;\n    let Vp1 = nizk_calc_Vp(____(LET_3)____, ____(OP_3)____) in\n    let cp1 = nizk_hash(Q, Vp1, A) in\n    let rp1 = nizk_calc_r(v1, r, ____(OP_27)____) in\n    out(ch, (U, Q, C, ds_sig, cp1, rp1));\n\n    (* receive ttp response *)\n    in(ch, spseq_sig:____(OP_4)____);\n  \n  (* SIGNING PHASE *)\n    (* randomize spseq sig *)\n    new inv_q:____(NEW_4)____;\n    let mes = create_spseq_message(____(OP_1)____,Q) in\n    let rand_mes = ChgRep_message(mes, ____(LET_1)____, secret_gsk) in\n    let rand_sig = ChgRep_signature(spseq_sig, inv_q, ____(OP_37)____) in\n    let ver_spseq = spseq_verify(mes, spseq_sig, ____(OP_35)____) in\n    \n    (* signing *)\n    new ____(NEW_1)____:bitstring;\n    new rho:bitstring;\n    new ____(NEW_6)____:bitstring;\n    new n:bitstring;\n    let mes_drone = ChgRep_message(rand_mes, rho, secret_gsk) in\n    let sig_drone = ChgRep_signature(____(LET_0)____, rho, secret_gsk) in\n\n    (* calculate hash components *)\n    let N = calc_N(v, ____(OP_21)____) in\n\n    (* hash c(N,M1,M2, sig, m) *)\n    let c = sign_hash(N, ____(LET_4)____, ____(OP_36)____) in\n    let z = calc_z(v, c, ____(OP_25)____) in\n\n    (* send message *)\n    event send_message(spseq_pk);\n    out(ch, (mes_drone, sig_drone, c, z)).\n    \n(************************* Processes TTP *************************)\nlet observer =\n  (* SETUP PHASE *)\n  (* recieve public param *)\n  in(ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n\n  (* OPEN PHASE *)\n  (* receive message *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, c:bitstring, z:bitstring));\n  let ver_spseq = spseq_verify(mes, ____(LET_2)____, spseq_pk) in\n  let N_hat = calc_N_hat(z, c, bg, ____(OP_12)____) in\n  let c_check = sign_hash(N_hat, sig, ____(OP_0)____) in\n  if c_check = c then event sig_verified(spseq_pk).\n\n(************************* Processes TTP *************************)\nlet TTP =\n  (* SETUP PHASE *)\n  (* recieve setup info *)\n  in(ttp_ch, (bg:spseq_bg, ____(OP_33)____:spseq_skey, spseq_pk:spseq_pkey));\n  in(____(OP_17)____, (____(OP_18)____:pke_skey, pke_param:pke_parameter));\n  in(ttp_ch, ____(OP_11)____:ds_pkey);\n \n  (* JOIN PHASE *)\n  (* Receive join info *)\n  in(ch, (U:point, Q:point, C:bitstring, ds_sig:ds_signature, cp1:bitstring, rp1:bitstring));\n  (* create spseq sig *)\n  let spseq_mes = create_spseq_message(U,Q) in\n  let spseq_sig = spseq_sign(spseq_mes, ____(OP_29)____) in\n  (* verify nizk *)    \n  let ____(LET_6)____ = create_point_mul(C, bg) in\n  let ____(LET_7)____ = nizk_calc_Vv(cp1, ____(OP_5)____, A, ____(LET_8)____) in\n  let cv1 = nizk_hash(Q, Vv1, A) in\n  (* verify ds *)\n  let C_sig = ds_verify(ds_sig, C, ds_pk) in\n  out(ch, spseq_sig);\n\n  (* VERIFY PHASE *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, c:bitstring, z:bitstring));\n  let ____(LET_9)____ = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z, c, bg, mes) in\n  let c_check = sign_hash(N_hat, ____(OP_22)____, mes) in\n  if c_check = c then event sig_verified(spseq_pk);\n\n  (* OPEN PHASE *)\n  let R_hat = pke_dec(____(OP_8)____, pke_param, pke_sk) in \n  let lhs = pairing_lhs(bg, sig) in\n  let rhs = pairing_rhs(R_hat, ____(OP_32)____) in\n  if ____(IF_0)____ = lhs then event sig_open(spseq_pk). \n\n(************************* Processes setup_server *************************)\nlet setup_server =\n  (* setup spseq *)\n  new bg:spseq_bg;\n  new spseq_sk:spseq_skey;\n  let spseq_pk = pk(spseq_sk) in\n  out(ua_ch, (bg, spseq_pk));\n  out(ttp_ch, (bg, spseq_sk, spseq_pk));\n\n  (* setup pke *)\n  new pke_sk:pke_skey;\n  new pke_pk:____(NEW_3)____;\n  new pke_param:pke_parameter;\n  out(ua_ch, (pke_pk, pke_param));\n  out(ttp_ch, (pke_sk, pke_param));\n\n  (* setup ds *)\n  new ds_pk:____(NEW_5)____;\n  new ds_sk:____(NEW_0)____;\n  out(ua_ch, ds_sk);\n  out(ttp_ch, ds_pk);\n\n  (* publish public info *)\n  out(ch, (bg, spseq_pk)).\n\nprocess\n  ( (setup_server) | (!TTP) | (!UA) | (!observer))",
        "complete:": "(************************* Channel *************************)\nfree ch: channel. (* public channel *)\nfree ttp_ch: channel [private]. (* private channel between ttp and setup server *)\nfree ua_ch: channel [private]. (* private channel between UA and setup server *)\n\n(************************* Types *************************)\ntype spseq_pkey.\ntype spseq_skey [private].\ntype spseq_signature.\ntype spseq_message.\ntype spseq_bg.\n\ntype pke_pkey.\ntype pke_skey [private].\ntype pke_parameter.\n\ntype point.\ntype nizk_proof.\n\ntype ds_pkey.\ntype ds_skey.\ntype ds_signature.\n\ntype gsk.\n\n(************************* Constructors *************************)\n(* sps-eq functions *)\nfun create_spseq_message(point, point): spseq_message.\nfun spseq_verify(spseq_message, spseq_signature, spseq_pkey): spseq_message.\nfun spseq_sign(spseq_message, spseq_skey): spseq_signature.\nfun ChgRep_message(spseq_message, bitstring, gsk): spseq_message.\nfun ChgRep_signature(spseq_signature, bitstring, gsk): spseq_signature.\nfun pk(spseq_skey): spseq_pkey.\n\n(* pke functions *)\nfun pke_enc(point, pke_pkey, pke_parameter): bitstring.\nreduc forall pke_m:point, pke_pk:pke_pkey, pke_par:pke_parameter, pke_sk:pke_skey; pke_dec(pke_enc(pke_m, pke_pk, pke_par), pke_par, pke_sk) = pke_m.\n\n(* nizk function *)\nfun nizk_hash(point, point, point):bitstring.\nfun nizk_calc_r(bitstring, bitstring, bitstring):bitstring.\nfun nizk_calc_Vp(bitstring, point): point.\nfun nizk_calc_Vv(bitstring, bitstring, point, point):point.\nfun nizk_cal_point(bitstring, point):point.\n\n(* ds functions *)\nfun ds_sign(bitstring, ds_skey): ds_signature.\nreduc forall ds_m:bitstring, ds_sk:ds_skey, ds_pk:ds_pkey; ds_verify(ds_sign(ds_m, ds_sk), ds_m, ds_pk) = ds_m.\n\n(* other *)\nfun create_point_mul(bitstring, spseq_bg): point.\n\n(* Signing functions *)\nfun calc_N(bitstring, spseq_bg):point.\nfun sign_hash(point, spseq_signature, spseq_message): bitstring.\nfun calc_z(bitstring, bitstring, bitstring):bitstring.\n\n(* Verify functions *)\nfun calc_N_hat(bitstring, bitstring, spseq_bg, spseq_message):point.\nfun calc_M1_hat(bitstring, bitstring, spseq_signature, point):point.\nfun calc_M2_hat(bitstring, bitstring, bitstring, spseq_signature, point):point.\n\n(* Open fuctions *)\nfun pairing_lhs(spseq_bg, spseq_signature):point.\nfun pairing_rhs(point, spseq_signature):point.\n\n(************************* Events *************************)\nevent sig_verified(spseq_pkey).\nevent sig_open(spseq_pkey). \nevent send_message(spseq_pkey).\n\n(************************* Queries *************************)\n(* Authenticty query *)\n  (* sender authenticy *)\n  query spseq_pk:spseq_pkey; event(sig_verified(spseq_pk)) ==> event(send_message(spseq_pk)).\n  query spseq_pk:spseq_pkey; event(sig_open(spseq_pk)) ==> event(send_message(spseq_pk)).\n\n(* impersoniation resistance *)\n  (* the attacker is not in possession of the value *)\n  free secret_gsk:gsk [private].\n  query attacker(secret_gsk).\n\n  (* strong secrecy/non-interference gsk --> attacker can not deduce any information about the value of gsk *)\n  noninterf secret_gsk.\n\n(************************* Processes UA *************************)\nlet UA =\n  (* SETUP PHASE *)\n    in(ua_ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n    in(ua_ch, (pke_pk:pke_pkey, pke_param:pke_parameter));\n    in(ua_ch, ds_sk:ds_skey);\n\n  (* JOIN PHASE *)\n    new q:bitstring;\n    new r:bitstring;\n    new Q:point;\n    new U:point;\n    let rP_hat = create_point_mul(r,bg) in\n    (* pke encrypt rP_hat *)\n    let C = pke_enc(rP_hat, pke_pk, pke_param) in\n\n    (* ds sign the encrypted rP_hat *)\n    let ds_sig = ds_sign(C, ds_sk) in\n\n    (* nizk gen p and v *)\n    let A = create_point_mul(C, bg) in\n    new p1:bitstring;\n    new v1:bitstring;\n    let Vp1 = nizk_calc_Vp(v1, Q) in\n    let cp1 = nizk_hash(Q, Vp1, A) in\n    let rp1 = nizk_calc_r(v1, r, cp1) in\n    out(ch, (U, Q, C, ds_sig, cp1, rp1));\n\n    (* receive ttp response *)\n    in(ch, spseq_sig:spseq_signature);\n  \n  (* SIGNING PHASE *)\n    (* randomize spseq sig *)\n    new inv_q:bitstring;\n    let mes = create_spseq_message(U,Q) in\n    let rand_mes = ChgRep_message(mes, inv_q, secret_gsk) in\n    let rand_sig = ChgRep_signature(spseq_sig, inv_q, secret_gsk) in\n    let ver_spseq = spseq_verify(mes, spseq_sig, spseq_pk) in\n    \n    (* signing *)\n    new u:bitstring;\n    new rho:bitstring;\n    new v:bitstring;\n    new n:bitstring;\n    let mes_drone = ChgRep_message(rand_mes, rho, secret_gsk) in\n    let sig_drone = ChgRep_signature(rand_sig, rho, secret_gsk) in\n\n    (* calculate hash components *)\n    let N = calc_N(v, bg) in\n\n    (* hash c(N,M1,M2, sig, m) *)\n    let c = sign_hash(N, sig_drone, mes_drone) in\n    let z = calc_z(v, c, rho) in\n\n    (* send message *)\n    event send_message(spseq_pk);\n    out(ch, (mes_drone, sig_drone, c, z)).\n    \n(************************* Processes TTP *************************)\nlet observer =\n  (* SETUP PHASE *)\n  (* recieve public param *)\n  in(ch, (bg:spseq_bg, spseq_pk:spseq_pkey));\n\n  (* OPEN PHASE *)\n  (* receive message *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, c:bitstring, z:bitstring));\n  let ver_spseq = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z, c, bg, mes) in\n  let c_check = sign_hash(N_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk).\n\n(************************* Processes TTP *************************)\nlet TTP =\n  (* SETUP PHASE *)\n  (* recieve setup info *)\n  in(ttp_ch, (bg:spseq_bg, spseq_sk:spseq_skey, spseq_pk:spseq_pkey));\n  in(ttp_ch, (pke_sk:pke_skey, pke_param:pke_parameter));\n  in(ttp_ch, ds_pk:ds_pkey);\n \n  (* JOIN PHASE *)\n  (* Receive join info *)\n  in(ch, (U:point, Q:point, C:bitstring, ds_sig:ds_signature, cp1:bitstring, rp1:bitstring));\n  (* create spseq sig *)\n  let spseq_mes = create_spseq_message(U,Q) in\n  let spseq_sig = spseq_sign(spseq_mes, spseq_sk) in\n  (* verify nizk *)    \n  let A = create_point_mul(C, bg) in\n  let Vv1 = nizk_calc_Vv(cp1, rp1, A, Q) in\n  let cv1 = nizk_hash(Q, Vv1, A) in\n  (* verify ds *)\n  let C_sig = ds_verify(ds_sig, C, ds_pk) in\n  out(ch, spseq_sig);\n\n  (* VERIFY PHASE *)\n  in(ch, (mes:spseq_message, sig:spseq_signature, c:bitstring, z:bitstring));\n  let ver_spseq = spseq_verify(mes, sig, spseq_pk) in\n  let N_hat = calc_N_hat(z, c, bg, mes) in\n  let c_check = sign_hash(N_hat, sig, mes) in\n  if c_check = c then event sig_verified(spseq_pk);\n\n  (* OPEN PHASE *)\n  let R_hat = pke_dec(C, pke_param, pke_sk) in \n  let lhs = pairing_lhs(bg, sig) in\n  let rhs = pairing_rhs(R_hat, sig) in\n  if rhs = lhs then event sig_open(spseq_pk). \n\n(************************* Processes setup_server *************************)\nlet setup_server =\n  (* setup spseq *)\n  new bg:spseq_bg;\n  new spseq_sk:spseq_skey;\n  let spseq_pk = pk(spseq_sk) in\n  out(ua_ch, (bg, spseq_pk));\n  out(ttp_ch, (bg, spseq_sk, spseq_pk));\n\n  (* setup pke *)\n  new pke_sk:pke_skey;\n  new pke_pk:pke_pkey;\n  new pke_param:pke_parameter;\n  out(ua_ch, (pke_pk, pke_param));\n  out(ttp_ch, (pke_sk, pke_param));\n\n  (* setup ds *)\n  new ds_pk:ds_pkey;\n  new ds_sk:ds_skey;\n  out(ua_ch, ds_sk);\n  out(ttp_ch, ds_pk);\n\n  (* publish public info *)\n  out(ch, (bg, spseq_pk)).\n\nprocess\n  ( (setup_server) | (!TTP) | (!UA) | (!observer))"
    },
    {
        "file": "PV-1/denning-sacco-orig.horn",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\npred ____(PRED_0)____/1 elimVar,decompData.\nnounif c:____(OP_4)____.\n\nfun pk/1.\nfun encrypt/2.\n\nfun sign/2.\n\nfun host/____(FUN_0)____.\n\nfun sencrypt/____(FUN_1)____.\n\nquery ____(QUERY_0)____:secret[].\n\nnot c:sA[].\nnot c:sB[].\nnot c:sS[].\n\nreduc\n(* Initialization *)\n\nc:c[];\nc:pk(sA[]);\nc:pk(sB[]);\nc:pk(sS[]);\n\n(* The attacker *)\n\n____(MESSAGE_3)____:x & ____(MESSAGE_4)____:encrypt(m,pk(x)) -> c:m;\nc:x -> c:pk(x);\nc:x & c:y -> c:encrypt(x,____(OP_2)____);\n____(MESSAGE_2)____:sign(____(OP_3)____,y) -> c:x;\nc:x & c:y -> c:sign(x,____(OP_5)____);\nc:host(x);\nc:x & c:y -> c:sencrypt(x,y);\nc:____(MESSAGE_1)____ & c:sencrypt(____(MESSAGE_0)____,x) -> c:m;\n\n(* The protocol *)\n(* A *)\n\nc:(sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[])) -> \nc:(sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]), encrypt(sign(k[pkx], sA[]), pkx));\n\n(* B *)\n\nc:(sign((host(sA[]), pk(s1)), sS[]), sign((host(____(OP_1)____[]), pk(sB[])), sS[]), encrypt(sign(k, s1), pk(sB[]))) -> c:sencrypt(secret[], k);\n\n(* server *)\n\nc:(host(s1), host(____(OP_6)____)) -> c:(sign((host(s1), pk(s1)), sS[]), sign((host(s2), pk(s2)), ____(OP_0)____[])).\n\n(* EXPECTPV\nRESULT goal reachable: c:secret[]\n0.004s (user 0.004s + system 0.000s), max rss 7508K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\npred c/1 elimVar,decompData.\nnounif c:x.\n\nfun pk/1.\nfun encrypt/2.\n\nfun sign/2.\n\nfun host/1.\n\nfun sencrypt/2.\n\nquery c:secret[].\n\nnot c:sA[].\nnot c:sB[].\nnot c:sS[].\n\nreduc\n(* Initialization *)\n\nc:c[];\nc:pk(sA[]);\nc:pk(sB[]);\nc:pk(sS[]);\n\n(* The attacker *)\n\nc:x & c:encrypt(m,pk(x)) -> c:m;\nc:x -> c:pk(x);\nc:x & c:y -> c:encrypt(x,y);\nc:sign(x,y) -> c:x;\nc:x & c:y -> c:sign(x,y);\nc:host(x);\nc:x & c:y -> c:sencrypt(x,y);\nc:x & c:sencrypt(m,x) -> c:m;\n\n(* The protocol *)\n(* A *)\n\nc:(sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[])) -> \nc:(sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]), encrypt(sign(k[pkx], sA[]), pkx));\n\n(* B *)\n\nc:(sign((host(sA[]), pk(s1)), sS[]), sign((host(sB[]), pk(sB[])), sS[]), encrypt(sign(k, s1), pk(sB[]))) -> c:sencrypt(secret[], k);\n\n(* server *)\n\nc:(host(s1), host(s2)) -> c:(sign((host(s1), pk(s1)), sS[]), sign((host(s2), pk(s2)), sS[])).\n\n(* EXPECTPV\nRESULT goal reachable: c:secret[]\n0.004s (user 0.004s + system 0.000s), max rss 7508K\nEND *)"
    },
    {
        "file": "PV-1/denning-sacco-orig.horntype",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* set ignoreTypes = true. *)\n\ntype ____(TYPE_0)____.\ntype pkey.\ntype host.\ntype key.\n\npred c(____(PRED_0)____) [elimVar,decompData].\n\nfun key_to_bitstring(key):bitstring [data,typeConverter].\n\nfun pk(____(OP_7)____):pkey.\nfun encrypt(____(FUN_1)____,pkey):bitstring.\n\nfun sign(bitstring,skey):bitstring.\n\nfun sencrypt(____(FUN_0)____,key):bitstring.\n\nfun host(skey):host.\n\nname secret:bitstring.\nname ____(NAME_0)____:skey.\nname sB:____(NAME_1)____.\nname sS:skey.\nname k:key.\n\nquery c(____(OP_10)____[]).\n\nnot c(sA[]).\nnot c(____(NOT_0)____[]).\nnot c(sS[]).\n\nclauses\n(* Initialization *)\n\nc(pk(sA[]));\nc(pk(sB[]));\nc(pk(sS[]));\n\n(* The attacker *)\n\nforall ____(OP_2)____:skey, m:bitstring; c(____(OP_8)____) & c(encrypt(m,pk(____(OP_11)____))) -> c(m);\nforall ____(OP_13)____:skey; c(x) -> c(pk(x));\nforall x:bitstring, ____(OP_14)____:pkey; c(x) & c(y) -> c(encrypt(____(OP_4)____,y));\nforall x:bitstring, y:skey; c(sign(____(OP_0)____,y)) -> c(x);\nforall x:bitstring, y:skey; c(x) & c(y) -> c(sign(____(OP_12)____,y));\nforall x:skey; c(host(x));\nforall x:bitstring, y:key; c(x) & c(y) -> c(sencrypt(____(OP_5)____,y));\nforall x:key, m:bitstring; c(x) & c(sencrypt(m,x)) -> c(m);\n\n(* The protocol *)\n(* A *)\n\nforall x:skey, pkx:pkey; c((sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]))) -> \nc((sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]), encrypt(sign(key_to_bitstring(____(OP_1)____[pkx]), sA[]), pkx)));\n\n(* B *)\n\nforall s1:skey, xk:key; c((sign((host(sA[]), pk(s1)), sS[]), sign((host(____(OP_9)____[]), pk(sB[])), sS[]), encrypt(sign(key_to_bitstring(xk), s1), pk(sB[])))) -> c(sencrypt(____(OP_6)____[], xk));\n\n(* server *)\n\nforall s1:skey, s2:skey; c((host(s1), host(s2))) -> c((sign((host(s1), pk(s1)), sS[]), sign((host(____(OP_3)____), pk(s2)), sS[]))).",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* set ignoreTypes = true. *)\n\ntype skey.\ntype pkey.\ntype host.\ntype key.\n\npred c(any_type) [elimVar,decompData].\n\nfun key_to_bitstring(key):bitstring [data,typeConverter].\n\nfun pk(skey):pkey.\nfun encrypt(bitstring,pkey):bitstring.\n\nfun sign(bitstring,skey):bitstring.\n\nfun sencrypt(bitstring,key):bitstring.\n\nfun host(skey):host.\n\nname secret:bitstring.\nname sA:skey.\nname sB:skey.\nname sS:skey.\nname k:key.\n\nquery c(secret[]).\n\nnot c(sA[]).\nnot c(sB[]).\nnot c(sS[]).\n\nclauses\n(* Initialization *)\n\nc(pk(sA[]));\nc(pk(sB[]));\nc(pk(sS[]));\n\n(* The attacker *)\n\nforall x:skey, m:bitstring; c(x) & c(encrypt(m,pk(x))) -> c(m);\nforall x:skey; c(x) -> c(pk(x));\nforall x:bitstring, y:pkey; c(x) & c(y) -> c(encrypt(x,y));\nforall x:bitstring, y:skey; c(sign(x,y)) -> c(x);\nforall x:bitstring, y:skey; c(x) & c(y) -> c(sign(x,y));\nforall x:skey; c(host(x));\nforall x:bitstring, y:key; c(x) & c(y) -> c(sencrypt(x,y));\nforall x:key, m:bitstring; c(x) & c(sencrypt(m,x)) -> c(m);\n\n(* The protocol *)\n(* A *)\n\nforall x:skey, pkx:pkey; c((sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]))) -> \nc((sign((host(sA[]), pk(sA[])), sS[]), sign((host(x), pkx), sS[]), encrypt(sign(key_to_bitstring(k[pkx]), sA[]), pkx)));\n\n(* B *)\n\nforall s1:skey, xk:key; c((sign((host(sA[]), pk(s1)), sS[]), sign((host(sB[]), pk(sB[])), sS[]), encrypt(sign(key_to_bitstring(xk), s1), pk(sB[])))) -> c(sencrypt(secret[], xk));\n\n(* server *)\n\nforall s1:skey, s2:skey; c((host(s1), host(s2))) -> c((sign((host(s1), pk(s1)), sS[]), sign((host(s2), pk(s2)), sS[])))."
    },
    {
        "file": "PV-1/DenningSacco3.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Denning-Sacco\n   In this model, I separate the keys for encryption and the\n   keys for signature, which complicates the model. *)\n\nfree c: channel.\n\ntype host.\ntype ____(TYPE_2)____.\ntype pkey.\ntype ____(OP_6)____.\ntype spkey.\ntype ____(TYPE_1)____.\n\n(* Probabilistic public key encryption *)\n\ntype seed.\nfun pk(skey): ____(FUN_1)____.\nfun internal_encrypt(bitstring, pkey, seed): bitstring.\nreduc forall x: bitstring, y: skey, r: seed; \n        decrypt(internal_encrypt(x,pk(y),r),y) = x.\nletfun encrypt(x: bitstring, y:pkey) = new r: seed; internal_encrypt(x,y,____(OP_12)____).\n\n(* Signatures *)\n\nfun spk(sskey): spkey.\nfun sign(____(OP_13)____, sskey): bitstring.\nreduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.\nreduc forall ____(REDUC_0)____: bitstring, ____(REDUC_1)____: ____(REDUC_2)____; checksign(sign(m,k), spk(k)) = m.\n\n(* Probabilistic shared key encryption *)\n\ntype ____(TYPE_0)____.\nfun internal_sencrypt(____(FUN_0)____,____(OP_7)____,sseed): bitstring.\nreduc forall x: bitstring, y: ____(OP_0)____, r: sseed; sdecrypt(internal_sencrypt(x,____(OP_1)____,r),y) = x.\nletfun sencrypt(x: bitstring, y: key) = new r: sseed; internal_sencrypt(x,y,r).\n\n(* Secrecy assumptions *)\n\nnot attacker(new ____(OP_3)____).\nnot attacker(new skB).\n\n(* Queries *)\n\nfree secretA, secretB: ____(FREE_0)____ [private].\nnoninterf secretA, secretB.\n\n(* Initiator *)\n\nlet processInitiator(skA: sskey, pkA: spkey, pkB: pkey) =\n        in(c, pk2: pkey);\n\tnew k: ____(NEW_0)____;\n\tout(c, encrypt(sign((____(OP_10)____, ____(OP_11)____, k), skA), pk2));\n\tif ____(IF_0)____ = pkB then\n\t(\n\tin(c, m: bitstring);\n\tlet s = sdecrypt(m,k)\n\t)\n\t|\n\tout(c, sencrypt(secretA, k)).\n\n(* Responder *)\n\nlet processResponder(skB: skey, pkB: pkey, pkA: spkey) =\n\tin(c, km: bitstring);\n\tlet ks = decrypt(km,skB) in\n\tlet (=pkA, =pkB, k:key) = checksign(ks, ____(OP_4)____) in\n\t(\n\tin(c, m: bitstring);\n\tlet s = sdecrypt(m,k)\n\t)\n\t|\n\tout(____(OP_5)____, sencrypt(secretB, k)).\n\n(* Main process *)\n\nprocess new skA: sskey; \n\tlet ____(LET_0)____ = spk(skA) in\n        out(c, ____(OP_2)____);\n        new skB: skey; \n\tlet pkB = pk(____(LET_1)____) in\n        out(____(OP_9)____, pkB);\n\t((!processInitiator(skA, pkA, pkB)) | \n\t (!processResponder(____(OP_8)____, pkB, pkA)))\n\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB is true.\n0.020s (user 0.016s + system 0.004s), max rss 10320K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Denning-Sacco\n   In this model, I separate the keys for encryption and the\n   keys for signature, which complicates the model. *)\n\nfree c: channel.\n\ntype host.\ntype key.\ntype pkey.\ntype skey.\ntype spkey.\ntype sskey.\n\n(* Probabilistic public key encryption *)\n\ntype seed.\nfun pk(skey): pkey.\nfun internal_encrypt(bitstring, pkey, seed): bitstring.\nreduc forall x: bitstring, y: skey, r: seed; \n        decrypt(internal_encrypt(x,pk(y),r),y) = x.\nletfun encrypt(x: bitstring, y:pkey) = new r: seed; internal_encrypt(x,y,r).\n\n(* Signatures *)\n\nfun spk(sskey): spkey.\nfun sign(bitstring, sskey): bitstring.\nreduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.\nreduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.\n\n(* Probabilistic shared key encryption *)\n\ntype sseed.\nfun internal_sencrypt(bitstring,key,sseed): bitstring.\nreduc forall x: bitstring, y: key, r: sseed; sdecrypt(internal_sencrypt(x,y,r),y) = x.\nletfun sencrypt(x: bitstring, y: key) = new r: sseed; internal_sencrypt(x,y,r).\n\n(* Secrecy assumptions *)\n\nnot attacker(new skA).\nnot attacker(new skB).\n\n(* Queries *)\n\nfree secretA, secretB: bitstring [private].\nnoninterf secretA, secretB.\n\n(* Initiator *)\n\nlet processInitiator(skA: sskey, pkA: spkey, pkB: pkey) =\n        in(c, pk2: pkey);\n\tnew k: key;\n\tout(c, encrypt(sign((pkA, pk2, k), skA), pk2));\n\tif pk2 = pkB then\n\t(\n\tin(c, m: bitstring);\n\tlet s = sdecrypt(m,k)\n\t)\n\t|\n\tout(c, sencrypt(secretA, k)).\n\n(* Responder *)\n\nlet processResponder(skB: skey, pkB: pkey, pkA: spkey) =\n\tin(c, km: bitstring);\n\tlet ks = decrypt(km,skB) in\n\tlet (=pkA, =pkB, k:key) = checksign(ks, pkA) in\n\t(\n\tin(c, m: bitstring);\n\tlet s = sdecrypt(m,k)\n\t)\n\t|\n\tout(c, sencrypt(secretB, k)).\n\n(* Main process *)\n\nprocess new skA: sskey; \n\tlet pkA = spk(skA) in\n        out(c, pkA);\n        new skB: skey; \n\tlet pkB = pk(skB) in\n        out(c, pkB);\n\t((!processInitiator(skA, pkA, pkB)) | \n\t (!processResponder(skB, pkB, pkA)))\n\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB is true.\n0.020s (user 0.016s + system 0.004s), max rss 10320K\nEND *)"
    },
    {
        "file": "PV-1/dh-fs.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\ntype G.\ntype ____(TYPE_0)____.\n\n(* Diffie-Hellman *)\n\nconst ____(CONST_0)____: G [data].\nfun exp(____(FUN_0)____, exponent): G.\n\nequation ____(EQUATION_1)____ ____(EQUATION_3)____: exponent, ____(EQUATION_0)____: exponent; exp(exp(g,x),____(EQUATION_2)____) = exp(exp(g,y),x).\n\nfree c: ____(FREE_0)____.\n\nprocess\n\tnew a1: ____(NEW_0)____; new a2: exponent; new a3: exponent;\n\tout(c, (exp(g,____(OP_1)____), exp(g,____(OP_0)____), choice[exp(exp(g,a1),a2), exp(g,a3)]))\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.026s (user 0.022s + system 0.004s), max rss 10268K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\ntype G.\ntype exponent.\n\n(* Diffie-Hellman *)\n\nconst g: G [data].\nfun exp(G, exponent): G.\n\nequation forall x: exponent, y: exponent; exp(exp(g,x),y) = exp(exp(g,y),x).\n\nfree c: channel.\n\nprocess\n\tnew a1: exponent; new a2: exponent; new a3: exponent;\n\tout(c, (exp(g,a1), exp(g,a2), choice[exp(exp(g,a1),a2), exp(g,a3)]))\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.026s (user 0.022s + system 0.004s), max rss 10268K\nEND *)"
    },
    {
        "file": "PV-1/E2IBS.pv",
        "incomplete": "(* Communication channels between PKG, BS and UE*)\nfree pkg_to_bs: channel [private].\nfree ____(FREE_0)____: channel.\n\n(*==============================================*)\n(*==============================================*)\n\n(*Data Types*)\ntype ____(OP_5)____.\ntype secret_key.\ntype ____(TYPE_0)____.\n\n(*==============================================*)\n(*==============================================*)\n\n(*Functions*)\n\n(* Get public key for a particular secret key *)\nfun get_public_key(secret_key): public_key.\n\n(* Generate secret key based on ID, parent secret key *)\n(* This function is abstracted for simplicity*)\nfun generate_secret_key(secret_key, ____(OP_10)____): secret_key.\n\n(* Get public key for base station *)\nfun generate_public_key(____(FUN_0)____): public_key.\n\n(* Sign a message using E2IBS scheme *)\nfun E2IBS_sign(____(OP_6)____, secret_key): bitstring.\n\n\n(*==============================================*)\n(*==============================================*)\n\n(* Destructors *)\n\n(* Verify the signature of a message*)\nreduc forall m: bitstring, k: secret_key;\n    checksign(E2IBS_sign(m, k), get_public_key(k)) = m.\n\n(* Verify the public key using parent public key*)\nreduc forall k: secret_key, xID: ID;\n    parentkey(generate_public_key(generate_secret_key(k, xID))) = k.\n\n(*==============================================*)\n(*==============================================*)\n\n(* Secrecy queries *)\n\n(*Attacker should not have access to the private keys*)\nfree secret_key_pkg, secret_key_bs: secret_key [private].\n\nquery attacker (secret_key_pkg);\n    attacker (secret_key_bs).\n\n(*==============================================*)\n(*==============================================*)\n\n(* Authentication queries *)\nevent authentication_successful(public_key).\nevent begin_signing(public_key).\n\n\nquery x: public_key; inj-event(authentication_successful(x))\n    ==> inj-event(begin_signing(x)).\n\n\n(*==============================================*)\n(*Core_PKG process*)\nlet Core_PKG(secret_key_pkg: ____(OP_8)____) =\n    (*Generate Keys for BS*)\n    in(pkg_to_bs, ID_BS: ____(OP_9)____);\n    let secret_key_bs = generate_secret_key(secret_key_pkg, ID_BS) in\n        out(pkg_to_bs, (generate_public_key(secret_key_bs), secret_key_bs)).\n\n\n(*==============================================*)\n\n(*Base-station process*)\nlet BS() =\n    (*Get new keys generated by PKG*)\n    new ID_BS: ID;\n    out(pkg_to_bs, ID_BS);\n    in(pkg_to_bs, (____(OP_1)____: public_key, secret_key_bs: secret_key));\n\n    (*Sign the SIB1 message*)\n    new SIB1: bitstring;\n    event begin_signing(public_key_bs);\n    let sig_SIB1 = E2IBS_sign(SIB1, ____(OP_4)____) in\n        out(bs_to_ue, (SIB1, sig_SIB1, ID_BS, public_key_bs)).\n\n(*==============================================*)\n\n(*UE process*)\nlet UE(public_key_pkg: ____(OP_7)____) =\n    (*Receive and verify signature*)\n    in(bs_to_ue, (SIB1: bitstring, sig_SIB1:bitstring, ID_BS: ID, public_key_bs: public_key));\n\n    (* Check whether signature is valid*)\n    let (= SIB1) = checksign(____(OP_3)____, public_key_bs) in\n    (* Verify BS\u2019s public-key*)\n    let(= public_key_pkg) = get_public_key(parentkey(____(OP_2)____)) in\n    event authentication_successful(public_key_bs).\n\n(*==============================================*)\n(*==============================================*)\n(* Main process*)\nprocess\n    (* Generate PKG\u2019s secret key*)\n    new ____(NEW_0)____: secret_key;\n\n    (* Start all individual processes in parallel*)\n    (Core_PKG(secret_key_pkg) | !BS() |!UE(get_public_key(____(OP_0)____)))",
        "complete:": "(* Communication channels between PKG, BS and UE*)\nfree pkg_to_bs: channel [private].\nfree bs_to_ue: channel.\n\n(*==============================================*)\n(*==============================================*)\n\n(*Data Types*)\ntype public_key.\ntype secret_key.\ntype ID.\n\n(*==============================================*)\n(*==============================================*)\n\n(*Functions*)\n\n(* Get public key for a particular secret key *)\nfun get_public_key(secret_key): public_key.\n\n(* Generate secret key based on ID, parent secret key *)\n(* This function is abstracted for simplicity*)\nfun generate_secret_key(secret_key, ID): secret_key.\n\n(* Get public key for base station *)\nfun generate_public_key(secret_key): public_key.\n\n(* Sign a message using E2IBS scheme *)\nfun E2IBS_sign(bitstring, secret_key): bitstring.\n\n\n(*==============================================*)\n(*==============================================*)\n\n(* Destructors *)\n\n(* Verify the signature of a message*)\nreduc forall m: bitstring, k: secret_key;\n    checksign(E2IBS_sign(m, k), get_public_key(k)) = m.\n\n(* Verify the public key using parent public key*)\nreduc forall k: secret_key, xID: ID;\n    parentkey(generate_public_key(generate_secret_key(k, xID))) = k.\n\n(*==============================================*)\n(*==============================================*)\n\n(* Secrecy queries *)\n\n(*Attacker should not have access to the private keys*)\nfree secret_key_pkg, secret_key_bs: secret_key [private].\n\nquery attacker (secret_key_pkg);\n    attacker (secret_key_bs).\n\n(*==============================================*)\n(*==============================================*)\n\n(* Authentication queries *)\nevent authentication_successful(public_key).\nevent begin_signing(public_key).\n\n\nquery x: public_key; inj-event(authentication_successful(x))\n    ==> inj-event(begin_signing(x)).\n\n\n(*==============================================*)\n(*Core_PKG process*)\nlet Core_PKG(secret_key_pkg: secret_key) =\n    (*Generate Keys for BS*)\n    in(pkg_to_bs, ID_BS: ID);\n    let secret_key_bs = generate_secret_key(secret_key_pkg, ID_BS) in\n        out(pkg_to_bs, (generate_public_key(secret_key_bs), secret_key_bs)).\n\n\n(*==============================================*)\n\n(*Base-station process*)\nlet BS() =\n    (*Get new keys generated by PKG*)\n    new ID_BS: ID;\n    out(pkg_to_bs, ID_BS);\n    in(pkg_to_bs, (public_key_bs: public_key, secret_key_bs: secret_key));\n\n    (*Sign the SIB1 message*)\n    new SIB1: bitstring;\n    event begin_signing(public_key_bs);\n    let sig_SIB1 = E2IBS_sign(SIB1, secret_key_bs) in\n        out(bs_to_ue, (SIB1, sig_SIB1, ID_BS, public_key_bs)).\n\n(*==============================================*)\n\n(*UE process*)\nlet UE(public_key_pkg: public_key) =\n    (*Receive and verify signature*)\n    in(bs_to_ue, (SIB1: bitstring, sig_SIB1:bitstring, ID_BS: ID, public_key_bs: public_key));\n\n    (* Check whether signature is valid*)\n    let (= SIB1) = checksign(sig_SIB1, public_key_bs) in\n    (* Verify BS\u2019s public-key*)\n    let(= public_key_pkg) = get_public_key(parentkey(public_key_bs)) in\n    event authentication_successful(public_key_bs).\n\n(*==============================================*)\n(*==============================================*)\n(* Main process*)\nprocess\n    (* Generate PKG\u2019s secret key*)\n    new secret_key_pkg: secret_key;\n\n    (* Start all individual processes in parallel*)\n    (Core_PKG(secret_key_pkg) | !BS() |!UE(get_public_key(secret_key_pkg)))"
    },
    {
        "file": "PV-1/eid_auth.pv",
        "incomplete": "(*\nProtocol parties:\n - User\n - Server\n - OCSP is melted into the Server\n - CA      -- certification authority\n - JS      -- JavaScript application running in the browser\n - EID     -- Web eID native application\n - SCard   -- eID smart card\n*)\n\n(* the attacker cannot match different data types *)\nset ignoreTypes = false.\n\ntype ____(OP_4)____.\ntype ____(TYPE_2)____.\ntype skey.\ntype pin.\ntype ____(TYPE_0)____.\ntype certSW.\ntype certSS.\ntype ____(OP_13)____.\ntype ____(TYPE_1)____.\n\n(* public channel *)\nfree net : channel.\n\n(* this special channel is only needed to model read-only TLS, and is not a real channel *)\nfree createTlsChannel : channel [private].\n\n(* TLS channel between two parties *)\n(* A TLS channel with server authentication *)\n(* Arguments: a nonce, and the public key of the server. *)\n(* The nonce is sent to the server encrypted with its public key *)\nfun tls(____(OP_3)____,pkey) : channel.\n\n\n(* private channel between user and \"JavaScript application\" *)\nfun channel_User_JS(____(OP_15)____) : channel [____(FUN_0)____].\n\n(* private channel between \"JavaScript application\" and \"Web eID native application\" *)\nfun channel_JS_EID(____(OP_80)____) : channel [____(FUN_4)____].\n\n(* private channel between user and \"Web eID native application\" *)\nfun channel_User_EID(party) : channel [____(FUN_1)____].\n\n(* private channel between \"Web eID native application\" and \"eID smart card\" *)\nfun channel_EID_SCard(party) : channel [private].\n\n\n(* certificate function, can only be issued by CA *)\nfun certUser(party,____(OP_26)____) : certU [private].\nreduc forall ____(OP_17)____ : party, PK : pkey; readcertU(certUser(____(OP_30)____,PK)) = (____(OP_41)____,PK).\n\nfun certServerWeak(____(OP_56)____,pkey) : certSW [private].\nreduc forall ____(OP_51)____ : ____(OP_48)____, PK : pkey; readcertSW(certServerWeak(____(OP_67)____,PK)) = (____(OP_71)____,PK).\n\nfun certServerStrong(party,____(OP_81)____) : ____(FUN_2)____ [private].\nreduc forall A : party, PK : pkey; readcertSS(certServerStrong(A,____(OP_61)____)) = (A,PK).\n\n(* we model a weaker attacker by assigning a write-only channel for IP that does not belong to the attacker *)\nfun dnsChannel(ip) : channel [private].\nreduc forall ____(REDUC_4)____ : ip; readDns(dnsChannel(____(REDUC_5)____)) = IP.\n\n(* some constant messages *)\nfree ____(FREE_1)____ : bitstring.\nfree consent : bitstring.\nfree needPIN : ____(FREE_2)____.\nfree ok : ____(FREE_0)____.\nfree authRequest : bitstring.\nfree challenge : bitstring.\n\n(* hash function *)\nfun hash(bitstring) : bitstring.\n\n(* Signatures *)\nfun pk(skey): pkey.\nfun sign(____(OP_5)____, ____(FUN_3)____): signature.\nreduc forall M: bitstring, ____(REDUC_0)____: ____(REDUC_1)____; verifySignature(pk(____(REDUC_2)____), sign(____(REDUC_3)____,M),M) = true.\nreduc forall M: bitstring, K: skey; extractMessage(sign(____(OP_27)____,M)) = M.\n\n(* Public key cryptography (used only to model TLS) *)\nfun encrypt(pkey, bitstring): bitstring.\nreduc forall M: bitstring, K: skey; decrypt(K, encrypt(pk(K),M)) = M.\n\n(* Table of smart cards *)\ntable smartCards(party,skey,certU,____(OP_77)____).\n(* Table of honest servers *)\ntable honestServers(party,skey,ip).\n(* DNS table *)\ntable dnsTable(____(OP_22)____,ip).\n(* Table of honest users *)\ntable honestUsers(party).\n(* Table of PINs for smart cards of honest users *)\ntable honestUsersPINs(party,pin).\n(* Table of valid user certificates that OCSP holds *)\ntable ocsp(certU).\n\n(* Declare events *)\nevent honest(party).\nevent honestPK(party,pkey).\n\nevent fakeServerCert(party).\nevent dnsPoisonedName(party).\n\nevent carelessUser(party).\n\nevent signedBySCard(party,bitstring).\n\nevent beginUser(____(OP_8)____,party).\nevent endUser(party,party).\n\nevent tlsJS(____(OP_74)____,party,bitstring).\nevent tlsServer(party,party,bitstring).\n\nevent endServer(party,party,bitstring).\nevent endJS(party,party,____(OP_55)____,pkey).\n\nevent test().\n(*query A : party, S : party, event(honest(S)) && event(endUser(A,S)).\nquery A : party, S : party, N : bitstring, PK : pkey; event(honest(A)) && event(honest(S)) && event(endJS(A,S,N,PK)).\nquery A : party, S : party, PK : pkey, N : bitstring; event(honest(A)) && event(endServer(A,S,N)).\nquery A : party, M : bitstring; event(honest(A)) && event(signedBySCard(A,M)).\n*)\n\n(* Impersonating User *)\n\n(* If a server approves an honest user's session, then indeed that user's smartcard was used to sign the hash of that session. *)\nquery A : party, S : party, N : bitstring, PKS : pkey; event(honest(A)) && inj-event(endServer(A,S,N)) ==> inj-event(signedBySCard(A,hash((N)))).\n\n(* If a server approves an honest user's session, then the user is aware of that. *)\n(* The query returns FALSE if we do not link the inserted PIN to a correct session. *)\n(* query A : party, S : party, N : bitstring; event(honest(A)) && event(endServer(A,S,N)) ==> event(beginUser(A,S)). *)\n\n(* The same query returns FALSE even if the PIN inserted by the user is linked to the server identity. *)\n(* query A : party, S : party, N : bitstring; event(honest(A)) && inj-event(endServer(A,S,N)) ==> inj-event(beginUser(A,S)) || event(carelessUser(A)). *)\n\n\n(* If the server authenticates A, then A is indeed on the other end of TLS pipe. *)\n(* The same query returns FALSE without additional assumptions or protection mechanisms *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)). *)\n\n(* The same query returns FALSE even if creating fake server certs is not possible. *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)) || event(fakeServerCert(S)). *)\n\n(* The same query returns FALSE even if DNS poisoning is not possible. *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)) || event(dnsPoisonedName(S)). *)\n\n\n(* Impersonating Server *)\n\n(* The following query returns FALSE, as indeed an attacker may claim to be an honest server *)\n(* query A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && event(endJS(A,S,N,PK)) ==> event(endServer(A,S,N)). *)\n\n(* Alternatively, if the browser is convinced that the pk used in generation of TLS was the honest server's one, then the authentication is indeed confirmed by the server. So even if the user does not know which session exactly was accepted, the browser does know it. *)\nquery ____(QUERY_2)____ : party, ____(QUERY_1)____ : party, ____(QUERY_5)____ : ____(QUERY_3)____, ____(QUERY_0)____ : bitstring; event(honestPK(____(QUERY_6)____,PK)) ____(QUERY_4)____ inj-event(endJS(A,S,N,PK)) ==> inj-event(endServer(A,S,N)).\n\n(* Alternatively, if the browser reads server's IP address from non-ponsoined DNS, then the authentication is indeed confirmed by the server. So even if the user does not know which session exactly was accepted, the browser does know it. *)\nquery A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && inj-event(endJS(A,S,N,PK)) ==> inj-event(endServer(A,S,N)) || event(dnsPoisonedName(S)).\n\n(* As far as certificate of S has not been falsified, if the user thinks that he has been authenticated, then ineed the server S has approved it as well. *)\nquery ____(QUERY_11)____ : ____(QUERY_10)____, ____(QUERY_9)____ : party, PK : pkey, N : bitstring; event(honest(S)) ____(QUERY_7)____ event(endUser(A,S)) ==> event(endServer(A,S,N)) ____(QUERY_8)____ event(fakeServerCert(____(OP_58)____)).\n\n(* This query returns FALSE, as the user can only be sure that the server S approved 'some' session. This is because we do not show the nonce to the user. This is not a problem, since it does not matter for the user which one of the sessions was accepted. *)\n(* query A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && inj-event(endUser(A,S)) ==> inj-event(endServer(A,S,N)) ||event(fakeServerCert(S)). *)\n\n(* Fake signatures *)\n\n(* if a smart card has signed something (in scope of our protocol), the user is aware of it, unless there is no visual check *)\nquery ____(QUERY_14)____ : ____(QUERY_12)____, ____(QUERY_16)____ : party, N : bitstring, ____(QUERY_13)____ : ____(QUERY_15)____; event(signedBySCard(____(OP_66)____,hash(N))) ==> event(beginUser(A,____(OP_64)____)) ____(QUERY_17)____ event(carelessUser(A)).\n\n(* The following query returns FALSE, as the user's PIN can be reused to create the same signature several times *)\n(* That is, after A interacted with an honest S using nonce N, the attacker may convince a smart card that the same session has been started again *)\n(* Although it would only enable to sign the same message multiple times, it might potentially make some signature forging attacks easier *)\n(* This seems more like ProVerif issue than a real attack, as the honest EID will prompt the PIN several times even if the message to be signed is the same *)\n(* query A : party, S : party, N : bitstring, PKS : pkey; event(honest(A)) && event(honest(S)) && inj-event(signedBySCard(A,hash(N))) ==> inj-event(beginUser(A,S)) || event(carelessUser(A)). *)\n\n(* All TLS channels are transparent *)\n(* A weaker attacker may only accept TLS requests sent to his physical address *)\nlet readTLS =\n    in(createTlsChannel, (____(OP_28)____ : ip, ____(OP_29)____ : bitstring, PKS : pkey));\n    out(dnsChannel(IP), encrypt(PKS, TlsNonce));\n    (!(in(tls(TlsNonce,____(OP_34)____), Msg : bitstring) ; out(____(OP_6)____, Msg))).\n\n(* we may have an unbounded number of honest users *)\n(* each honest user is issued exactly one personal smart card *)\nlet honestUserGenerator =\n    new A : party;\n    event honest(A);\n\n    new SKA : skey;\n    new ____(NEW_3)____ : pin;\n    let ____(OP_39)____ = certUser(A,pk(SKA)) in\n\n    insert ocsp(____(OP_40)____);\n    insert smartCards(A,SKA,Cert,____(OP_59)____);\n    insert honestUsers(A);\n    insert honestUsersPINs(A,PIN);\n\n    (* let everyone know all public keys *)\n    out(net,(A,pk(SKA)));\n    0.\n\n(* we may have an unbounded number of honest servers *)\n(* each honest server is issued a public key *)\n(* we assume that there is no trusted server certification, so malicious server generation is trivial *)\nlet honestServerGenerator =\n    new S : ____(NEW_2)____;\n    new ____(OP_10)____ : skey;\n    new ____(NEW_1)____ : ip;\n\n    (* in some cases, the user may be convinced in advance that the public key belongs to an honest server *)\n    insert honestServers(S,SKS,IP);\n    insert dnsTable(S,IP);\n\n    event honest(S);\n    event honestPK(S,pk(SKS));\n\n    (* let everyone know all public keys *)\n    out(net, (IP, certServerWeak(S,pk(SKS))));\n    0.\n\n(* attacker can use this to generate himself smart cards *)\n(* we allow it only for new names, so that no impersonation is possible *)\nlet maliciousUserGenerator =\n    new A : party;\n\n    (* the attacker may choose the secret key himself *)\n    (* we do not need to model a PIN, as it is used internally on user's side anyway *)\n    (* we only need that OCSP would accept the malicious user's identity *)\n    in(net, ____(OP_52)____ : skey);\n    let Cert = certUser(A,pk(SKA)) in\n\n    insert ocsp(Cert);\n\n    (* the attacker learns his new identity *)\n    out(net, A);\n    out(____(OP_38)____, channel_User_JS(A));\n    out(net, channel_JS_EID(A));\n    0.\n\n(* User  -- we do not model malicious user interacting with an honest web application *)\nlet processUser =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n\n    (* The attacker chooses the Server with whom User communicates *)\n    in(net, ____(OP_49)____ : party);\n\n    out(channel_User_JS(A), S);                                          (* send    (1) *)\n    in (channel_User_EID(A), (=needPIN, =S, N : bitstring));             (* receive (5) *)\n    get honestUsersPINs(=A,PIN : pin) in\n    event beginUser(A,S);\n\n    (* let us split the cases with and without visual check, to include both in the analysis *)\n    in(net, B : ____(OP_44)____);\n    if B then (\n        out(channel_User_EID(A), (PIN,S,N));                             (* send    (6) *)\n        in(channel_User_JS(A), (=____(OP_62)____,=ok));\n        event endUser(A,S)\n    ) else (\n        event carelessUser(A);\n        out(channel_User_EID(A), PIN);                                   (* send    (6) *)\n        in(channel_User_JS(A), (=S,=ok));\n        event endUser(A,S)\n    ).\n\n(* JS -- can be malicious. It is more like a proxy, and we avoid doing additional operations here, delegating them to EID *)\nlet processJS =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n\n    in (channel_User_JS(A), S : party);             (* receive (1) *)\n\n    (* TLS handshake *)\n    in(net, ServerWeakCert : ____(OP_20)____);\n    let (=S,PKS : pkey) = readcertSW(ServerWeakCert) in\n    get dnsTable(=S,IP : ip) in\n    new TlsNonce : bitstring;\n    event tlsJS(A,S,TlsNonce);\n    out(____(OP_24)____, (IP, TlsNonce, PKS));\n\n\n    out(tls(TlsNonce,PKS), authRequest);               (* send    (2) *)\n    in (tls(TlsNonce,PKS), (=challenge,N : bitstring));(* receive (3) *)\n\n    out(channel_JS_EID(A), (authRequest,S,IP,ServerWeakCert,N)); (* send    (4)  *)\n    in (channel_JS_EID(A), (UserCert : certU, Token : bitstring, Signature : signature));\n                                                             (* receive (12) *)\n    out(tls(TlsNonce,PKS), (UserCert, Token, Signature));    (* send    (13) *)\n\n    in (tls(TlsNonce, PKS), (=ok, =(A,N)));                  (* receive (17) *)\n    out(channel_User_JS(A), (____(OP_54)____,ok));\n    event endJS(A,S,N,PKS);\n    0.\n\n(* EID  -- always honest, as a malicious EID would learn user's PIN code *)\nlet processEID =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n    in (channel_JS_EID(A), (=authRequest,S : party, IP : ip, ServerWeakCert : certSW, N : bitstring)); (* receive ( 4) *)\n    out(channel_User_EID(A), (needPIN, S, N));                                                         (* send    ( 5) *)\n\n    (* let us split the cases with and without visual check, to include both in the analysis *)\n    in(net, B : ____(OP_68)____);\n    new SID : ____(NEW_4)____;\n    let Token = hash(N) in                             (*         ( 9) *)\n    if B then (\n        in (channel_User_EID(A), (PIN : pin,=S,=N));       (* receive ( 6) *)\n        out(channel_EID_SCard(A), getCertificate);         (* send    ( 7) *)\n        in (channel_EID_SCard(A), UserCert : certU);       (* receive ( 8) *)\n\n        out(channel_EID_SCard(A), (SID, Token, PIN));              (* send    (10) *)\n        in (channel_EID_SCard(A), (=SID, Signature : signature));  (* receive (11) *)\n        out(channel_JS_EID(A), (UserCert,Token,Signature))         (* send    (12) *)\n    ) else (\n        in (channel_User_EID(A), PIN : pin);               (* receive ( 6) *)\n        out(channel_EID_SCard(A), getCertificate);         (* send    ( 7) *)\n        in (channel_EID_SCard(A), UserCert : certU);       (* receive ( 8) *)\n\n        out(channel_EID_SCard(A), (SID, Token, PIN));              (* send    (10) *)\n        in (channel_EID_SCard(A), (=SID, Signature : signature));  (* receive (11) *)\n        out(channel_JS_EID(A), (UserCert,Token,Signature))         (* send    (12) *)\n    ).\n\n(* Smart Card  -- always honest, as there is no need to model a bad one *)\nlet processSCard =\n\n    (* The attacker decides who plays User role *)\n    (* SmartCard is a device that holds the secret key and the corresponding certificate of that user *)\n    get honestUsers(A : party) in\n    get smartCards(=A, SKA : skey, UserCert : certU, PIN : pin) in\n\n    (* in reality, certificate request and signing take place in parallel *)\n    (!(\n        in (channel_EID_SCard(A), =getCertificate);        (* receive ( 5) *)\n        out(channel_EID_SCard(A), UserCert)                (* send    ( 6) *)\n    )) | (!(\n        in (channel_EID_SCard(A), (SID : bitstring, M : bitstring, =PIN));  (* receive (14) *)\n        let Signature = sign(____(LET_2)____,M) in\n        event signedBySCard(A,____(OP_76)____);\n        out(channel_EID_SCard(A), (SID, Signature))                     (* send    (15) *)\n    )).\n\n(* Server *)\nlet processServer =\n\n    (* The attacker chooses Server's identity *)\n    get honestServers(S : party, SKS : ____(OP_0)____, ____(OP_1)____ : ip) in\n    let PKS = pk(SKS) in\n    let ServerWeakCert = certServerWeak(S,PKS) in\n\n    (* TLS handshake *)\n    in(dnsChannel(IP), EncTlsNonce : bitstring);\n    let TlsNonce = decrypt(SKS, ____(LET_4)____) in\n\n    in(tls(TlsNonce, PKS), =authRequest);                (* receive ( 2) *)\n    new N : ____(NEW_0)____;\n    out(tls(TlsNonce, PKS), (challenge,N));              (* send    ( 3) *)\n\n    in(tls(____(OP_35)____,PKS), (UserCert : certU, ____(OP_36)____ : ____(OP_37)____, Signature : signature));\n                                                         (* receive    (13) *)\n\n    let (A : party, PKA : pkey) = readcertU(UserCert) in (*            ( 9) *)\n    if verifySignature(PKA, Signature, ____(IF_0)____) then\n    let (=hash(N)) = Token in\n\n    (* is the cert valid? all valid certificates, for which a smart card was actually issued, are in the table ocsp *)\n    get ocsp(=UserCert) in                                           (* send    (15) *)\n                                                                     (* receive (16) *)\n\n    event endServer(A,S,N);\n    event tlsServer(A,S,TlsNonce);\n    out(tls(TlsNonce, PKS), (ok, (A,N)));                            (* send    (17) *)\n    0.\n\nlet ____(LET_3)____ =\n    in(net, S : party);\n    in(net, PKS : pkey);\n    event fakeServerCert(S);\n    out(net, certServerWeak(____(OP_33)____,PKS)).\n\n(* an honest DNS service *)\nlet honestDNS =\n    new S : party;\n    new IP : ip;\n    insert dnsTable(S,IP);\n    out(net, (S,____(OP_60)____,dnsChannel(IP))).\n\n(* an poisoned DNS service *)\nlet poisonedDNS =\n    in(net, S : party);\n    new IP : ip;\n    event dnsPoisonedName(S);\n    insert dnsTable(S,IP);\n    out(net, (S,IP,dnsChannel(IP))).\n\nlet writeToDnsChannel =\n    in(net, (IP : ip, M : bitstring));\n    out(dnsChannel(____(OP_43)____), M).\n\n(* the main process *)\nprocess\n        (* real party processes *)\n\t((!processUser) | (!processJS) | (!processEID) | (!processSCard) | (!processServer)\n        (* helpful functions for modeling TLS and DNS *)\n        | (!readTLS) | (!honestDNS)  | (!poisonedDNS) | (!writeToDnsChannel)\n        (* attacker may obtain server certificates from here *)\n        | (!corruptedCA)\n        (* generation of secret keys and certificates *)\n        | (!honestUserGenerator) | (!honestServerGenerator) | (!maliciousUserGenerator))",
        "complete:": "(*\nProtocol parties:\n - User\n - Server\n - OCSP is melted into the Server\n - CA      -- certification authority\n - JS      -- JavaScript application running in the browser\n - EID     -- Web eID native application\n - SCard   -- eID smart card\n*)\n\n(* the attacker cannot match different data types *)\nset ignoreTypes = false.\n\ntype party.\ntype pkey.\ntype skey.\ntype pin.\ntype certU.\ntype certSW.\ntype certSS.\ntype ip.\ntype signature.\n\n(* public channel *)\nfree net : channel.\n\n(* this special channel is only needed to model read-only TLS, and is not a real channel *)\nfree createTlsChannel : channel [private].\n\n(* TLS channel between two parties *)\n(* A TLS channel with server authentication *)\n(* Arguments: a nonce, and the public key of the server. *)\n(* The nonce is sent to the server encrypted with its public key *)\nfun tls(bitstring,pkey) : channel.\n\n\n(* private channel between user and \"JavaScript application\" *)\nfun channel_User_JS(party) : channel [private].\n\n(* private channel between \"JavaScript application\" and \"Web eID native application\" *)\nfun channel_JS_EID(party) : channel [private].\n\n(* private channel between user and \"Web eID native application\" *)\nfun channel_User_EID(party) : channel [private].\n\n(* private channel between \"Web eID native application\" and \"eID smart card\" *)\nfun channel_EID_SCard(party) : channel [private].\n\n\n(* certificate function, can only be issued by CA *)\nfun certUser(party,pkey) : certU [private].\nreduc forall A : party, PK : pkey; readcertU(certUser(A,PK)) = (A,PK).\n\nfun certServerWeak(party,pkey) : certSW [private].\nreduc forall A : party, PK : pkey; readcertSW(certServerWeak(A,PK)) = (A,PK).\n\nfun certServerStrong(party,pkey) : certSS [private].\nreduc forall A : party, PK : pkey; readcertSS(certServerStrong(A,PK)) = (A,PK).\n\n(* we model a weaker attacker by assigning a write-only channel for IP that does not belong to the attacker *)\nfun dnsChannel(ip) : channel [private].\nreduc forall IP : ip; readDns(dnsChannel(IP)) = IP.\n\n(* some constant messages *)\nfree getCertificate : bitstring.\nfree consent : bitstring.\nfree needPIN : bitstring.\nfree ok : bitstring.\nfree authRequest : bitstring.\nfree challenge : bitstring.\n\n(* hash function *)\nfun hash(bitstring) : bitstring.\n\n(* Signatures *)\nfun pk(skey): pkey.\nfun sign(skey, bitstring): signature.\nreduc forall M: bitstring, K: skey; verifySignature(pk(K), sign(K,M),M) = true.\nreduc forall M: bitstring, K: skey; extractMessage(sign(K,M)) = M.\n\n(* Public key cryptography (used only to model TLS) *)\nfun encrypt(pkey, bitstring): bitstring.\nreduc forall M: bitstring, K: skey; decrypt(K, encrypt(pk(K),M)) = M.\n\n(* Table of smart cards *)\ntable smartCards(party,skey,certU,pin).\n(* Table of honest servers *)\ntable honestServers(party,skey,ip).\n(* DNS table *)\ntable dnsTable(party,ip).\n(* Table of honest users *)\ntable honestUsers(party).\n(* Table of PINs for smart cards of honest users *)\ntable honestUsersPINs(party,pin).\n(* Table of valid user certificates that OCSP holds *)\ntable ocsp(certU).\n\n(* Declare events *)\nevent honest(party).\nevent honestPK(party,pkey).\n\nevent fakeServerCert(party).\nevent dnsPoisonedName(party).\n\nevent carelessUser(party).\n\nevent signedBySCard(party,bitstring).\n\nevent beginUser(party,party).\nevent endUser(party,party).\n\nevent tlsJS(party,party,bitstring).\nevent tlsServer(party,party,bitstring).\n\nevent endServer(party,party,bitstring).\nevent endJS(party,party,bitstring,pkey).\n\nevent test().\n(*query A : party, S : party, event(honest(S)) && event(endUser(A,S)).\nquery A : party, S : party, N : bitstring, PK : pkey; event(honest(A)) && event(honest(S)) && event(endJS(A,S,N,PK)).\nquery A : party, S : party, PK : pkey, N : bitstring; event(honest(A)) && event(endServer(A,S,N)).\nquery A : party, M : bitstring; event(honest(A)) && event(signedBySCard(A,M)).\n*)\n\n(* Impersonating User *)\n\n(* If a server approves an honest user's session, then indeed that user's smartcard was used to sign the hash of that session. *)\nquery A : party, S : party, N : bitstring, PKS : pkey; event(honest(A)) && inj-event(endServer(A,S,N)) ==> inj-event(signedBySCard(A,hash((N)))).\n\n(* If a server approves an honest user's session, then the user is aware of that. *)\n(* The query returns FALSE if we do not link the inserted PIN to a correct session. *)\n(* query A : party, S : party, N : bitstring; event(honest(A)) && event(endServer(A,S,N)) ==> event(beginUser(A,S)). *)\n\n(* The same query returns FALSE even if the PIN inserted by the user is linked to the server identity. *)\n(* query A : party, S : party, N : bitstring; event(honest(A)) && inj-event(endServer(A,S,N)) ==> inj-event(beginUser(A,S)) || event(carelessUser(A)). *)\n\n\n(* If the server authenticates A, then A is indeed on the other end of TLS pipe. *)\n(* The same query returns FALSE without additional assumptions or protection mechanisms *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)). *)\n\n(* The same query returns FALSE even if creating fake server certs is not possible. *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)) || event(fakeServerCert(S)). *)\n\n(* The same query returns FALSE even if DNS poisoning is not possible. *)\n(* query A : party, S : party, TlsNonce : bitstring; event(honest(A)) && event(tlsServer(A,S,TlsNonce)) ==> event(tlsJS(A,S,TlsNonce)) || event(dnsPoisonedName(S)). *)\n\n\n(* Impersonating Server *)\n\n(* The following query returns FALSE, as indeed an attacker may claim to be an honest server *)\n(* query A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && event(endJS(A,S,N,PK)) ==> event(endServer(A,S,N)). *)\n\n(* Alternatively, if the browser is convinced that the pk used in generation of TLS was the honest server's one, then the authentication is indeed confirmed by the server. So even if the user does not know which session exactly was accepted, the browser does know it. *)\nquery A : party, S : party, PK : pkey, N : bitstring; event(honestPK(S,PK)) && inj-event(endJS(A,S,N,PK)) ==> inj-event(endServer(A,S,N)).\n\n(* Alternatively, if the browser reads server's IP address from non-ponsoined DNS, then the authentication is indeed confirmed by the server. So even if the user does not know which session exactly was accepted, the browser does know it. *)\nquery A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && inj-event(endJS(A,S,N,PK)) ==> inj-event(endServer(A,S,N)) || event(dnsPoisonedName(S)).\n\n(* As far as certificate of S has not been falsified, if the user thinks that he has been authenticated, then ineed the server S has approved it as well. *)\nquery A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && event(endUser(A,S)) ==> event(endServer(A,S,N)) || event(fakeServerCert(S)).\n\n(* This query returns FALSE, as the user can only be sure that the server S approved 'some' session. This is because we do not show the nonce to the user. This is not a problem, since it does not matter for the user which one of the sessions was accepted. *)\n(* query A : party, S : party, PK : pkey, N : bitstring; event(honest(S)) && inj-event(endUser(A,S)) ==> inj-event(endServer(A,S,N)) ||event(fakeServerCert(S)). *)\n\n(* Fake signatures *)\n\n(* if a smart card has signed something (in scope of our protocol), the user is aware of it, unless there is no visual check *)\nquery A : party, S : party, N : bitstring, PKS : pkey; event(signedBySCard(A,hash(N))) ==> event(beginUser(A,S)) || event(carelessUser(A)).\n\n(* The following query returns FALSE, as the user's PIN can be reused to create the same signature several times *)\n(* That is, after A interacted with an honest S using nonce N, the attacker may convince a smart card that the same session has been started again *)\n(* Although it would only enable to sign the same message multiple times, it might potentially make some signature forging attacks easier *)\n(* This seems more like ProVerif issue than a real attack, as the honest EID will prompt the PIN several times even if the message to be signed is the same *)\n(* query A : party, S : party, N : bitstring, PKS : pkey; event(honest(A)) && event(honest(S)) && inj-event(signedBySCard(A,hash(N))) ==> inj-event(beginUser(A,S)) || event(carelessUser(A)). *)\n\n(* All TLS channels are transparent *)\n(* A weaker attacker may only accept TLS requests sent to his physical address *)\nlet readTLS =\n    in(createTlsChannel, (IP : ip, TlsNonce : bitstring, PKS : pkey));\n    out(dnsChannel(IP), encrypt(PKS, TlsNonce));\n    (!(in(tls(TlsNonce,PKS), Msg : bitstring) ; out(net, Msg))).\n\n(* we may have an unbounded number of honest users *)\n(* each honest user is issued exactly one personal smart card *)\nlet honestUserGenerator =\n    new A : party;\n    event honest(A);\n\n    new SKA : skey;\n    new PIN : pin;\n    let Cert = certUser(A,pk(SKA)) in\n\n    insert ocsp(Cert);\n    insert smartCards(A,SKA,Cert,PIN);\n    insert honestUsers(A);\n    insert honestUsersPINs(A,PIN);\n\n    (* let everyone know all public keys *)\n    out(net,(A,pk(SKA)));\n    0.\n\n(* we may have an unbounded number of honest servers *)\n(* each honest server is issued a public key *)\n(* we assume that there is no trusted server certification, so malicious server generation is trivial *)\nlet honestServerGenerator =\n    new S : party;\n    new SKS : skey;\n    new IP : ip;\n\n    (* in some cases, the user may be convinced in advance that the public key belongs to an honest server *)\n    insert honestServers(S,SKS,IP);\n    insert dnsTable(S,IP);\n\n    event honest(S);\n    event honestPK(S,pk(SKS));\n\n    (* let everyone know all public keys *)\n    out(net, (IP, certServerWeak(S,pk(SKS))));\n    0.\n\n(* attacker can use this to generate himself smart cards *)\n(* we allow it only for new names, so that no impersonation is possible *)\nlet maliciousUserGenerator =\n    new A : party;\n\n    (* the attacker may choose the secret key himself *)\n    (* we do not need to model a PIN, as it is used internally on user's side anyway *)\n    (* we only need that OCSP would accept the malicious user's identity *)\n    in(net, SKA : skey);\n    let Cert = certUser(A,pk(SKA)) in\n\n    insert ocsp(Cert);\n\n    (* the attacker learns his new identity *)\n    out(net, A);\n    out(net, channel_User_JS(A));\n    out(net, channel_JS_EID(A));\n    0.\n\n(* User  -- we do not model malicious user interacting with an honest web application *)\nlet processUser =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n\n    (* The attacker chooses the Server with whom User communicates *)\n    in(net, S : party);\n\n    out(channel_User_JS(A), S);                                          (* send    (1) *)\n    in (channel_User_EID(A), (=needPIN, =S, N : bitstring));             (* receive (5) *)\n    get honestUsersPINs(=A,PIN : pin) in\n    event beginUser(A,S);\n\n    (* let us split the cases with and without visual check, to include both in the analysis *)\n    in(net, B : bool);\n    if B then (\n        out(channel_User_EID(A), (PIN,S,N));                             (* send    (6) *)\n        in(channel_User_JS(A), (=S,=ok));\n        event endUser(A,S)\n    ) else (\n        event carelessUser(A);\n        out(channel_User_EID(A), PIN);                                   (* send    (6) *)\n        in(channel_User_JS(A), (=S,=ok));\n        event endUser(A,S)\n    ).\n\n(* JS -- can be malicious. It is more like a proxy, and we avoid doing additional operations here, delegating them to EID *)\nlet processJS =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n\n    in (channel_User_JS(A), S : party);             (* receive (1) *)\n\n    (* TLS handshake *)\n    in(net, ServerWeakCert : certSW);\n    let (=S,PKS : pkey) = readcertSW(ServerWeakCert) in\n    get dnsTable(=S,IP : ip) in\n    new TlsNonce : bitstring;\n    event tlsJS(A,S,TlsNonce);\n    out(createTlsChannel, (IP, TlsNonce, PKS));\n\n\n    out(tls(TlsNonce,PKS), authRequest);               (* send    (2) *)\n    in (tls(TlsNonce,PKS), (=challenge,N : bitstring));(* receive (3) *)\n\n    out(channel_JS_EID(A), (authRequest,S,IP,ServerWeakCert,N)); (* send    (4)  *)\n    in (channel_JS_EID(A), (UserCert : certU, Token : bitstring, Signature : signature));\n                                                             (* receive (12) *)\n    out(tls(TlsNonce,PKS), (UserCert, Token, Signature));    (* send    (13) *)\n\n    in (tls(TlsNonce, PKS), (=ok, =(A,N)));                  (* receive (17) *)\n    out(channel_User_JS(A), (S,ok));\n    event endJS(A,S,N,PKS);\n    0.\n\n(* EID  -- always honest, as a malicious EID would learn user's PIN code *)\nlet processEID =\n\n    (* The attacker decides who plays User role *)\n    get honestUsers(A : party) in\n    in (channel_JS_EID(A), (=authRequest,S : party, IP : ip, ServerWeakCert : certSW, N : bitstring)); (* receive ( 4) *)\n    out(channel_User_EID(A), (needPIN, S, N));                                                         (* send    ( 5) *)\n\n    (* let us split the cases with and without visual check, to include both in the analysis *)\n    in(net, B : bool);\n    new SID : bitstring;\n    let Token = hash(N) in                             (*         ( 9) *)\n    if B then (\n        in (channel_User_EID(A), (PIN : pin,=S,=N));       (* receive ( 6) *)\n        out(channel_EID_SCard(A), getCertificate);         (* send    ( 7) *)\n        in (channel_EID_SCard(A), UserCert : certU);       (* receive ( 8) *)\n\n        out(channel_EID_SCard(A), (SID, Token, PIN));              (* send    (10) *)\n        in (channel_EID_SCard(A), (=SID, Signature : signature));  (* receive (11) *)\n        out(channel_JS_EID(A), (UserCert,Token,Signature))         (* send    (12) *)\n    ) else (\n        in (channel_User_EID(A), PIN : pin);               (* receive ( 6) *)\n        out(channel_EID_SCard(A), getCertificate);         (* send    ( 7) *)\n        in (channel_EID_SCard(A), UserCert : certU);       (* receive ( 8) *)\n\n        out(channel_EID_SCard(A), (SID, Token, PIN));              (* send    (10) *)\n        in (channel_EID_SCard(A), (=SID, Signature : signature));  (* receive (11) *)\n        out(channel_JS_EID(A), (UserCert,Token,Signature))         (* send    (12) *)\n    ).\n\n(* Smart Card  -- always honest, as there is no need to model a bad one *)\nlet processSCard =\n\n    (* The attacker decides who plays User role *)\n    (* SmartCard is a device that holds the secret key and the corresponding certificate of that user *)\n    get honestUsers(A : party) in\n    get smartCards(=A, SKA : skey, UserCert : certU, PIN : pin) in\n\n    (* in reality, certificate request and signing take place in parallel *)\n    (!(\n        in (channel_EID_SCard(A), =getCertificate);        (* receive ( 5) *)\n        out(channel_EID_SCard(A), UserCert)                (* send    ( 6) *)\n    )) | (!(\n        in (channel_EID_SCard(A), (SID : bitstring, M : bitstring, =PIN));  (* receive (14) *)\n        let Signature = sign(SKA,M) in\n        event signedBySCard(A,M);\n        out(channel_EID_SCard(A), (SID, Signature))                     (* send    (15) *)\n    )).\n\n(* Server *)\nlet processServer =\n\n    (* The attacker chooses Server's identity *)\n    get honestServers(S : party, SKS : skey, IP : ip) in\n    let PKS = pk(SKS) in\n    let ServerWeakCert = certServerWeak(S,PKS) in\n\n    (* TLS handshake *)\n    in(dnsChannel(IP), EncTlsNonce : bitstring);\n    let TlsNonce = decrypt(SKS, EncTlsNonce) in\n\n    in(tls(TlsNonce, PKS), =authRequest);                (* receive ( 2) *)\n    new N : bitstring;\n    out(tls(TlsNonce, PKS), (challenge,N));              (* send    ( 3) *)\n\n    in(tls(TlsNonce,PKS), (UserCert : certU, Token : bitstring, Signature : signature));\n                                                         (* receive    (13) *)\n\n    let (A : party, PKA : pkey) = readcertU(UserCert) in (*            ( 9) *)\n    if verifySignature(PKA, Signature, Token) then\n    let (=hash(N)) = Token in\n\n    (* is the cert valid? all valid certificates, for which a smart card was actually issued, are in the table ocsp *)\n    get ocsp(=UserCert) in                                           (* send    (15) *)\n                                                                     (* receive (16) *)\n\n    event endServer(A,S,N);\n    event tlsServer(A,S,TlsNonce);\n    out(tls(TlsNonce, PKS), (ok, (A,N)));                            (* send    (17) *)\n    0.\n\nlet corruptedCA =\n    in(net, S : party);\n    in(net, PKS : pkey);\n    event fakeServerCert(S);\n    out(net, certServerWeak(S,PKS)).\n\n(* an honest DNS service *)\nlet honestDNS =\n    new S : party;\n    new IP : ip;\n    insert dnsTable(S,IP);\n    out(net, (S,IP,dnsChannel(IP))).\n\n(* an poisoned DNS service *)\nlet poisonedDNS =\n    in(net, S : party);\n    new IP : ip;\n    event dnsPoisonedName(S);\n    insert dnsTable(S,IP);\n    out(net, (S,IP,dnsChannel(IP))).\n\nlet writeToDnsChannel =\n    in(net, (IP : ip, M : bitstring));\n    out(dnsChannel(IP), M).\n\n(* the main process *)\nprocess\n        (* real party processes *)\n\t((!processUser) | (!processJS) | (!processEID) | (!processSCard) | (!processServer)\n        (* helpful functions for modeling TLS and DNS *)\n        | (!readTLS) | (!honestDNS)  | (!poisonedDNS) | (!writeToDnsChannel)\n        (* attacker may obtain server certificates from here *)\n        | (!corruptedCA)\n        (* generation of secret keys and certificates *)\n        | (!honestUserGenerator) | (!honestServerGenerator) | (!maliciousUserGenerator))"
    },
    {
        "file": "PV-1/EKE-DH.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Bellovin, Merritt, Oakland 92, section 3.1 *)\n\nfree c: channel.\n\ntype ____(TYPE_0)____.\ntype passwd.\ntype ____(TYPE_1)____.\ntype G.\ntype exponent.\n\nfun nonce_to_bitstring(____(OP_1)____): bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation ____(EQUATION_1)____ x: ____(EQUATION_0)____, ____(EQUATION_2)____: ____(EQUATION_3)____; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(____(FUN_0)____, passwd): G.\nfun dec(G, ____(FUN_1)____): G.\nequation forall x: G, y: passwd; dec(enc(____(OP_6)____,y),y) = x.\nequation forall x: G, y: passwd; enc(dec(x,____(OP_11)____),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(bitstring, G): bitstring.\nreduc forall ____(REDUC_0)____: bitstring, ____(REDUC_2)____: G; sdec(senc(____(REDUC_1)____,y),y) = x.\n\n(* Host names *)\n\nconst ____(CONST_0)____, B: host.\n\n\n\nfree ____(FREE_0)____, PAA, PBB: passwd [____(FREE_1)____].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) =\n\tnew RA: exponent;\n\tout(c, (hostA, enc(exp(____(OP_7)____,RA), P)));\n\tin(c,(m2: G,m3: bitstring));\n\tlet gRB = dec(____(LET_0)____,____(OP_8)____) in\n\tlet K = exp(gRB, RA) in\n\tlet nonce_to_bitstring(____(OP_0)____) = sdec(m3, K) in\n\tnew challengeA: nonce;\n\tout(c, senc((challengeA,challengeB), K));\n\tin(c, m4: bitstring);\n\tif nonce_to_bitstring(____(IF_0)____) = sdec(____(OP_2)____, K) then\n\t0.\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(____(OP_4)____, (=hostX, ____(OP_5)____: G));\n\tlet gRA = dec(m, P) in\n\tnew RB: exponent;\n\tlet ____(LET_1)____ = exp(gRA, ____(OP_3)____) in\n\tnew challengeB: ____(NEW_0)____;\n\tout(c, (enc(exp(g, RB), P), senc(nonce_to_bitstring(challengeB), ____(OP_10)____)));\n\tin(c,m3: bitstring);\n\tlet (challengeA: nonce,=challengeB) = sdec(m3, K) in\n\tout(____(OP_12)____, senc(nonce_to_bitstring(challengeA), K)).\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, ____(OP_14)____)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(____(OP_9)____, A, PAB)) |\n\t(!processB(B, ____(OP_13)____, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n0.470s (user 0.466s + system 0.004s), max rss 16660K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Bellovin, Merritt, Oakland 92, section 3.1 *)\n\nfree c: channel.\n\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(G, passwd): G.\nfun dec(G, passwd): G.\nequation forall x: G, y: passwd; dec(enc(x,y),y) = x.\nequation forall x: G, y: passwd; enc(dec(x,y),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; sdec(senc(x,y),y) = x.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) =\n\tnew RA: exponent;\n\tout(c, (hostA, enc(exp(g,RA), P)));\n\tin(c,(m2: G,m3: bitstring));\n\tlet gRB = dec(m2,P) in\n\tlet K = exp(gRB, RA) in\n\tlet nonce_to_bitstring(challengeB) = sdec(m3, K) in\n\tnew challengeA: nonce;\n\tout(c, senc((challengeA,challengeB), K));\n\tin(c, m4: bitstring);\n\tif nonce_to_bitstring(challengeA) = sdec(m4, K) then\n\t0.\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: G));\n\tlet gRA = dec(m, P) in\n\tnew RB: exponent;\n\tlet K = exp(gRA, RB) in\n\tnew challengeB: nonce;\n\tout(c, (enc(exp(g, RB), P), senc(nonce_to_bitstring(challengeB), K)));\n\tin(c,m3: bitstring);\n\tlet (challengeA: nonce,=challengeB) = sdec(m3, K) in\n\tout(c, senc(nonce_to_bitstring(challengeA), K)).\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n0.470s (user 0.466s + system 0.004s), max rss 16660K\nEND *)"
    },
    {
        "file": "PV-1/EKE.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Bellovin, Merritt, Oakland 92, section 2.1 *)\n\n\n(* There is an attack if one is able to distinguish a public\nkey from another bitstring. (The adversary decrypts the first \nmessage with the candidate password and tests whether the\nresult is a public key.) *)\n(*set ignoreTypes = true.*)\n\nfree c: channel.\n\ntype ____(TYPE_1)____.\ntype passwd.\ntype nonce.\ntype ____(TYPE_0)____.\ntype skey.\ntype key.\n\nfun nonce_to_bitstring(____(FUN_1)____): bitstring [data, typeConverter].\nfun pkey_to_bitstring(____(OP_11)____):bitstring [data, typeConverter].\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(bitstring, ____(OP_7)____): bitstring.\nfun dec(bitstring, ____(OP_13)____): bitstring.\nequation forall ____(EQUATION_2)____: ____(EQUATION_1)____, ____(EQUATION_0)____: passwd; dec(enc(x,y),y) = x.\nequation forall x: bitstring, y: passwd; enc(dec(x,y),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(____(FUN_0)____, key): bitstring.\nreduc ____(REDUC_0)____ ____(REDUC_1)____: bitstring, ____(REDUC_2)____: key; sdec(senc(x,y),y) = x.\n\n(* Public key encryption *)\n\nfun penc(key, ____(OP_4)____): bitstring.\nfun pk(skey): pkey.\nreduc forall x: key, y: skey; pdec(penc(x,pk(y)),y) = x.\n\n(* Host names *)\n\nconst ____(CONST_0)____, B: host.\n\n\n\nfree PAB, ____(FREE_1)____, ____(FREE_0)____: passwd [private].\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: ____(OP_5)____, hostX: host, P: ____(OP_6)____) =\n\tnew sEA: skey;\n\tlet ____(OP_12)____ = pk(sEA) in\n\tout(c, (hostA, enc(pkey_to_bitstring(EA), P)));\n\tin(c,m2: bitstring);\n\tlet R = pdec(dec(m2,P),sEA) in\n\tnew challengeA: nonce;\n\tout(c, senc(nonce_to_bitstring(____(OP_14)____), R));\n\tin(c, m4: ____(OP_16)____);\n\tlet (=challengeA, challengeB: nonce) = sdec(m4, R) in\n\tout(c, senc(nonce_to_bitstring(challengeB), ____(OP_10)____)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, ____(OP_1)____: host, ____(OP_2)____: passwd) =\n\tin(c, (=hostX, m: bitstring));\n\tlet pkey_to_bitstring(____(LET_0)____) = dec(m, P) in\n\tnew R: ____(NEW_1)____;\n\tout(c, enc(penc(R, EA), P));\n\tin(c,m3: bitstring);\n\tlet nonce_to_bitstring(challengeA) = sdec(m3, ____(LET_1)____) in\n\tnew challengeB: nonce;\n\tout(c, senc((challengeA, challengeB), R));\n\tin(c, m5: bitstring);\n\tif sdec(____(IF_0)____, R) = nonce_to_bitstring(challengeB) then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(____(OP_8)____, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(____(OP_3)____, B, PBB)) |\n\t(!processB(B, B, ____(OP_15)____)) |\n\t(!processA(A, B, ____(OP_9)____)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB)) |\n\t(* This is equivalent to the query \"weaksecret PAB\", but formulated with \"choice\" instead. *)\n\t(phase 1;\n\tnew w: ____(NEW_0)____;\n\tout(c, choice[____(OP_0)____, PAB]))\n\n\n\n\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.045s (user 0.033s + system 0.012s), max rss 11524K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Bellovin, Merritt, Oakland 92, section 2.1 *)\n\n\n(* There is an attack if one is able to distinguish a public\nkey from another bitstring. (The adversary decrypts the first \nmessage with the candidate password and tests whether the\nresult is a public key.) *)\n(*set ignoreTypes = true.*)\n\nfree c: channel.\n\ntype host.\ntype passwd.\ntype nonce.\ntype pkey.\ntype skey.\ntype key.\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\nfun pkey_to_bitstring(pkey):bitstring [data, typeConverter].\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(bitstring, passwd): bitstring.\nfun dec(bitstring, passwd): bitstring.\nequation forall x: bitstring, y: passwd; dec(enc(x,y),y) = x.\nequation forall x: bitstring, y: passwd; enc(dec(x,y),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(bitstring, key): bitstring.\nreduc forall x: bitstring, y: key; sdec(senc(x,y),y) = x.\n\n(* Public key encryption *)\n\nfun penc(key, pkey): bitstring.\nfun pk(skey): pkey.\nreduc forall x: key, y: skey; pdec(penc(x,pk(y)),y) = x.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) =\n\tnew sEA: skey;\n\tlet EA = pk(sEA) in\n\tout(c, (hostA, enc(pkey_to_bitstring(EA), P)));\n\tin(c,m2: bitstring);\n\tlet R = pdec(dec(m2,P),sEA) in\n\tnew challengeA: nonce;\n\tout(c, senc(nonce_to_bitstring(challengeA), R));\n\tin(c, m4: bitstring);\n\tlet (=challengeA, challengeB: nonce) = sdec(m4, R) in\n\tout(c, senc(nonce_to_bitstring(challengeB), R)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: bitstring));\n\tlet pkey_to_bitstring(EA) = dec(m, P) in\n\tnew R: key;\n\tout(c, enc(penc(R, EA), P));\n\tin(c,m3: bitstring);\n\tlet nonce_to_bitstring(challengeA) = sdec(m3, R) in\n\tnew challengeB: nonce;\n\tout(c, senc((challengeA, challengeB), R));\n\tin(c, m5: bitstring);\n\tif sdec(m5, R) = nonce_to_bitstring(challengeB) then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB)) |\n\t(* This is equivalent to the query \"weaksecret PAB\", but formulated with \"choice\" instead. *)\n\t(phase 1;\n\tnew w: passwd;\n\tout(c, choice[w, PAB]))\n\n\n\n\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.045s (user 0.033s + system 0.012s), max rss 11524K\nEND *)"
    },
    {
        "file": "PV-1/event.pv",
        "incomplete": "(* event.pv\n\nMessage 1: A -> B : RSA \\\n    if (message == Cocks) then\n        event RSA\n        event Cocks\n    else\n        event RSA\n\n*)\n\nchannel c. (* free c : channel. *)\nfree Cocks : bitstring[private].\nfree RSA : bitstring[____(FREE_0)____].\n\nevent evCocks.\nevent evRSA.\n\nquery event(evCocks) ==> event(evRSA).\nquery ____(QUERY_0)____ (evCocks).\n\nprocess\n    out(____(OP_0)____, RSA);\n    in(c, x:bitstring);\n    if x = Cocks then\n        event evCocks;\n        event evRSA\n    else\n        event evRSA",
        "complete:": "(* event.pv\n\nMessage 1: A -> B : RSA \\\n    if (message == Cocks) then\n        event RSA\n        event Cocks\n    else\n        event RSA\n\n*)\n\nchannel c. (* free c : channel. *)\nfree Cocks : bitstring[private].\nfree RSA : bitstring[private].\n\nevent evCocks.\nevent evRSA.\n\nquery event(evCocks) ==> event(evRSA).\nquery event (evCocks).\n\nprocess\n    out(c, RSA);\n    in(c, x:bitstring);\n    if x = Cocks then\n        event evCocks;\n        event evRSA\n    else\n        event evRSA"
    },
    {
        "file": "PV-1/handshake.pv",
        "incomplete": "(* Simple protocol from Proverif Manual *)\n\n(* Symmetric encryption functions *)\ntype key.\nfun senc(bitstring, key): bitstring.\nreduc forall ____(REDUC_2)____: bitstring, ____(REDUC_0)____: key; sdec(senc(m,____(REDUC_1)____),____(OP_9)____) = m.\n\n(* Asymmetric encryption functions *)\ntype skey. (* Private Key *)\ntype pkey. (* Public Key *)\nfun pk(skey): pkey. (* pk(skey) is the pkey bound to skey *)\nfun aenc(____(OP_12)____, pkey): bitstring.\nreduc forall m: bitstring, k: skey; adec(aenc(m, pk(____(OP_16)____)), k) = m.\n\n(* Digital Signature *)\ntype sskey. (* Private signing key *)\ntype spkey. (* Public signing key *)\nfun spk(sskey): ____(FUN_1)____.\nfun sign(____(FUN_0)____, sskey): bitstring.\nreduc forall m: bitstring, k: sskey; getmess(sign(m,____(OP_0)____)) = m.\nreduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.\n\nfree c:channel.\n\nfree ____(OP_17)____:bitstring [____(FREE_0)____].\nquery attacker(s).\n\nevent acceptsClient(key).\nevent acceptsServer(key, pkey).\nevent termClient(key, pkey).\nevent termServer(key).\n\n(* If A believes to have terminated a session, then the server has to have accepted*)\nquery x:key, y:pkey; event(termClient(x,y)) ==> event(acceptsServer(____(OP_13)____,y)).\nquery ____(QUERY_1)____:____(QUERY_0)____; inj-event(termServer(x)) ==> inj-event(acceptsClient(x)).\n\n(* A has a keypair and B's public key *)\nlet clientA(pkA:pkey, ____(OP_6)____:skey, pkB: spkey) =\n    (* A sends his public key *)\n    out(c,pkA);\n    (* A receives x = aenc(sign((pkB, k), skB), pkA) \n       which is the pair (B's public key, generate key k) signed\n       by B, and encrypted with A key\n       NOTE: Why include the public key in the pair? *)\n    in(c, x:bitstring);\n    (* Decrypts the message *)\n    let y = adec(x, skA) in\n    (* Checks the public key and the signature *)\n    let (=pkB, ____(LET_1)____:____(LET_2)____) = checksign(y,pkB) in\n    (* A believes that a session was started with key k *)\n    event acceptsClient(k);\n    (* Sends s encrypted by the key k *)\n    out (c, senc(s,____(OP_7)____));\n    (* A believes that she has terminated a session *)\n    event termClient(k, ____(OP_1)____).\n\nlet serverB(pkB:spkey, skB:sskey, ____(OP_4)____: ____(OP_3)____) =\n    (* The servers received the request with X public key *)\n    in(____(OP_8)____, pkX:pkey);\n    (* Generates a new key *)\n    new k:key;\n    (* Servers started a session with pkX *)\n    if pkX = ____(IF_0)____ then event acceptsServer(____(OP_10)____, pkX);\n    (* Sends the key signed and encrypted to X *)\n    out(c, aenc(sign((pkB,k),skB),pkX));\n    (* Receives the message, which is expected to be s encrypted by k *)\n    in (c,x:bitstring);\n    (* Decrypts *)\n    let z = sdec(____(OP_11)____,k) in\n    if pkX = pkA then event termServer(k).\n\nprocess\n    (* Creating A and B private keys *)\n    new skA: skey;\n    new ____(NEW_0)____: sskey;\n    (* Sending public keys in c, as they are public *)\n    let pkA = pk(skA) in out(c, pkA);\n    let ____(LET_0)____ = spk(skB) in out(c, pkB);\n    (* Starting the processes *)\n    ( (!clientA(pkA, skA, pkB)) | (!serverB(pkB, skB, pkA)) )",
        "complete:": "(* Simple protocol from Proverif Manual *)\n\n(* Symmetric encryption functions *)\ntype key.\nfun senc(bitstring, key): bitstring.\nreduc forall m: bitstring, k: key; sdec(senc(m,k),k) = m.\n\n(* Asymmetric encryption functions *)\ntype skey. (* Private Key *)\ntype pkey. (* Public Key *)\nfun pk(skey): pkey. (* pk(skey) is the pkey bound to skey *)\nfun aenc(bitstring, pkey): bitstring.\nreduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)), k) = m.\n\n(* Digital Signature *)\ntype sskey. (* Private signing key *)\ntype spkey. (* Public signing key *)\nfun spk(sskey): spkey.\nfun sign(bitstring, sskey): bitstring.\nreduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.\nreduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.\n\nfree c:channel.\n\nfree s:bitstring [private].\nquery attacker(s).\n\nevent acceptsClient(key).\nevent acceptsServer(key, pkey).\nevent termClient(key, pkey).\nevent termServer(key).\n\n(* If A believes to have terminated a session, then the server has to have accepted*)\nquery x:key, y:pkey; event(termClient(x,y)) ==> event(acceptsServer(x,y)).\nquery x:key; inj-event(termServer(x)) ==> inj-event(acceptsClient(x)).\n\n(* A has a keypair and B's public key *)\nlet clientA(pkA:pkey, skA:skey, pkB: spkey) =\n    (* A sends his public key *)\n    out(c,pkA);\n    (* A receives x = aenc(sign((pkB, k), skB), pkA) \n       which is the pair (B's public key, generate key k) signed\n       by B, and encrypted with A key\n       NOTE: Why include the public key in the pair? *)\n    in(c, x:bitstring);\n    (* Decrypts the message *)\n    let y = adec(x, skA) in\n    (* Checks the public key and the signature *)\n    let (=pkB, k:key) = checksign(y,pkB) in\n    (* A believes that a session was started with key k *)\n    event acceptsClient(k);\n    (* Sends s encrypted by the key k *)\n    out (c, senc(s,k));\n    (* A believes that she has terminated a session *)\n    event termClient(k, pkA).\n\nlet serverB(pkB:spkey, skB:sskey, pkA: pkey) =\n    (* The servers received the request with X public key *)\n    in(c, pkX:pkey);\n    (* Generates a new key *)\n    new k:key;\n    (* Servers started a session with pkX *)\n    if pkX = pkA then event acceptsServer(k, pkX);\n    (* Sends the key signed and encrypted to X *)\n    out(c, aenc(sign((pkB,k),skB),pkX));\n    (* Receives the message, which is expected to be s encrypted by k *)\n    in (c,x:bitstring);\n    (* Decrypts *)\n    let z = sdec(x,k) in\n    if pkX = pkA then event termServer(k).\n\nprocess\n    (* Creating A and B private keys *)\n    new skA: skey;\n    new skB: sskey;\n    (* Sending public keys in c, as they are public *)\n    let pkA = pk(skA) in out(c, pkA);\n    let pkB = spk(skB) in out(c, pkB);\n    (* Starting the processes *)\n    ( (!clientA(pkA, skA, pkB)) | (!serverB(pkB, skB, pkA)) )"
    },
    {
        "file": "PV-1/induction_nat.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Simple example that illustrates both the use of induction and the setting\n   nounigIgnoreAFewTimes. The query cannot be proved with one of them removed.\n*)\n\n\nfree d:channel[____(FREE_0)____].\n\nset nounifIgnoreAFewTimes = auto.\n\nquery x:nat,y:nat;\n  mess(d,x) ==> is_nat(x) [induction].\n\nprocess\n  out(d,____(OP_0)____) | ! in(d,x:nat); out(d,x+1)\n\n(* EXPECTPV\nRESULT mess(d[],x_1) ==> is_nat(x_1) is true.\n0.010s (user 0.005s + system 0.005s), max rss 8620K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Simple example that illustrates both the use of induction and the setting\n   nounigIgnoreAFewTimes. The query cannot be proved with one of them removed.\n*)\n\n\nfree d:channel[private].\n\nset nounifIgnoreAFewTimes = auto.\n\nquery x:nat,y:nat;\n  mess(d,x) ==> is_nat(x) [induction].\n\nprocess\n  out(d,0) | ! in(d,x:nat); out(d,x+1)\n\n(* EXPECTPV\nRESULT mess(d[],x_1) ==> is_nat(x_1) is true.\n0.010s (user 0.005s + system 0.005s), max rss 8620K\nEND *)"
    },
    {
        "file": "PV-1/JFKr-coresec.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* JFKr *)\n\ntype ____(TYPE_2)____.\ntype texponent.\ntype ____(TYPE_1)____.\ntype ____(TYPE_0)____.\ntype key.\ntype tag.\ntype nonce.\ntype grpinfo.\ntype sainfo.\n\nfun G_to_key(____(OP_11)____):key [data, typeConverter].\n\n(* Exponential and Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, ____(FUN_3)____): G.\nequation forall ____(EQUATION_2)____: ____(EQUATION_1)____, ____(EQUATION_3)____: texponent; exp(exp(____(EQUATION_0)____,y),z) = exp(exp(g,z),y).\n\n(* Signature *)\n\nfun S(____(OP_33)____, bitstring): bitstring.\nfun Pk(skey): pkey.\nreduc ____(REDUC_0)____ ____(OP_61)____: ____(REDUC_3)____, ____(REDUC_1)____: bitstring; V(S(k,____(OP_10)____), Pk(k),v) = ____(REDUC_2)____.\nreduc forall k: skey, v: bitstring; RecoverKey(S(k,v)) = Pk(k). (* For the attacker *)\nreduc forall k: skey, v: bitstring; RecoverText(S(k,v)) = v.    (* For the attacker *)\n\n(* Shared-key encryption *)\n\nfun E(key, bitstring): bitstring.\nreduc forall k: key, v: bitstring; D(k,E(k,____(OP_48)____)) = v.\n\n(* Keyed hash function *)\n\nfun H(____(FUN_4)____, bitstring): key.\n\n(* Tags *)\n\nconst tagE, tagA, tagV: tag [data].\n\n(* Constructors for JFK's formatted messages\n   Selectors are implicit when using \"data\" *)\n\nfun cons1(nonce, G): bitstring [data].\nfun cons2(nonce, nonce, G, grpinfo, ____(FUN_5)____): ____(FUN_7)____ [____(FUN_6)____] .\nfun cons3(____(FUN_0)____, nonce, G, G, key, ____(FUN_1)____, key): ____(FUN_2)____ [data].\nfun cons4(bitstring, key): bitstring [data].\n\n(* More constants *)\n\nconst constI, constR: tag [data].\nconst saR: ____(CONST_0)____ [data].\n\n(* Free names *)\n\nfree c: channel. (* Public channel *)\nfree d0: channel.\nfree pub, genprinc, getexponential, init0, getprinc0: channel.\n\n(* Secrecy assumptions *)\n\nnot attacker(new kAminus) phase 0.\nnot attacker(new ____(OP_41)____).\n\n(* Initiator\n   The process processI corresponds to I^A in the figure. *)\n\nlet processI(exponent: channel, init: channel, getI: channel, kAminus: skey) =\n  !\n  in(exponent, (dI: texponent, xI: G));\n  !\n  in(init, dummy: bitstring);    (* Init message *)\n  new NI: nonce;\n  out(c, cons1(NI, xI));\n  in(c, cons2(=____(OP_53)____, NR, ____(OP_52)____, grpinfoR, tR));\n  let h = G_to_key(exp(xR, ____(OP_56)____)) in\n  let Ka = H(____(LET_17)____, (NI, ____(OP_0)____, ____(LET_16)____)) in\n  let Ke = H(h, (NI, NR, ____(OP_55)____)) in\n  let ____(LET_14)____ = H(____(OP_54)____, (NI, NR, ____(LET_15)____)) in\n  let ____(LET_6)____ = S(kAminus, (NI, NR, ____(LET_7)____, ____(OP_3)____, ____(OP_2)____)) in\n  out(getI, (dummy, NI, NR, xI, xR, tR, Ka, Ke, Kv, sI)).\n\n(* Responder\n   The process processR corresponds to R^A in the figure. *)\n\nfree grpinfoR: grpinfo.\n\nlet processR(____(OP_7)____: ____(OP_8)____, ____(OP_9)____: channel, IDA: pkey, kAminus: skey) =\n  !\n  in(exponent, (dR: texponent, xR: G));\n  !\n  in(c, cons1(NI, xI));\n  new ____(NEW_0)____: nonce;\n  new tR: key;\n  out(c, cons2(____(OP_6)____, NR, ____(OP_5)____, grpinfoR, tR));\n  new l: channel;\n  (\n    (\n    !\n    in(c, cons3(=NI,=NR,xI,=xR,=tR,eI,hI));\n    out(l, (xI,eI,hI))\n    )\n  |\n    (\n    in(l, (xI: G,eI: bitstring,hI: key));\n      (\n        out(d0, (NR, ____(OP_44)____)) |\n\tlet ____(LET_5)____ = G_to_key(exp(xI,dR)) in\n  \tlet Ka = H(h, (NI, NR, tagA)) in\n  \tlet Ke = H(h, (NI, NR, tagE)) in\n  \tlet ____(LET_8)____ = H(h, (NI, ____(LET_9)____, tagV)) in\n  \tlet sR = S(kAminus, (NI, ____(LET_1)____, xI, ____(LET_2)____)) in\n  \tout(getR, (NI, ____(OP_15)____, ____(OP_17)____, xR, tR, ____(OP_14)____, hI, Ka, Ke, Kv, ____(OP_16)____))\n      )\n    )\n  ).\n\n(* Whole JFK system. *)\n\nprocess\n  new exponent: channel;\n  new ____(NEW_4)____: channel;\n  new ids: channel;\n  ( ! new d: texponent; let x = exp(g,d) in out(____(OP_45)____, x); ! out(exponent, (d,x)) )\n  |\n  (\n    !\n    new kAminus: ____(NEW_1)____;\n    let IDA = Pk(kAminus) in\n    new init: channel; new getI: channel; new getR: channel;\n    out(____(OP_25)____, (IDA, getI, getR, ____(OP_24)____));\n    ( processI(exponent, init, getI, kAminus) |\n      processR(exponent, ____(OP_46)____, IDA, kAminus) |\n      (!out(cp, IDA)) | (!out(ids, (kAminus, IDA))))\n  )\n  |\n  (\n    in(ids, (kAIminus: skey, IDAI: pkey));\n    in(ids, (kARminus: skey, IDAR: pkey));\n    in(exponent, (dI: texponent,xI: G));\n    in(exponent, (dR: texponent,xR: G)); (* with in(pub, (NR, xR)) instead, attack for xR = g, so h = exp(g, dI) = xI. *)\n    in(____(OP_59)____, (IDRp: pkey, saI: sainfo,=IDAI,=____(OP_60)____,=xI,=____(OP_58)____));\n    new NI: nonce;\n    new NR: nonce; (* we could use instead in(pub, NR); *)\n    new ____(NEW_5)____: key;\n    new NeI: ____(NEW_3)____; new NhI: key; new NeR: bitstring; new NhR: key; new NKv: key;\n    let h = G_to_key(exp(xR,dI)) in\n    let Ka = H(h, (NI, NR, tagA)) in\n    let Ke = H(h, (NI, NR, tagE)) in\n    let Kv = H(h, (NI, NR, tagV)) in\n    let ____(LET_4)____ = S(____(OP_23)____, (NI, ____(LET_3)____, xI, ____(OP_22)____)) in\n    let eR = E(____(LET_18)____, (____(OP_47)____, saR, ____(LET_19)____)) in\n    let hR = H(____(OP_1)____, (constR, eR)) in\n    let sI = S(kAIminus, (NI, NR, xI, xR, grpinfoR)) in\n    let eI = E(____(OP_13)____, (IDAI, IDRp, ____(OP_12)____, sI)) in\n    let hI = H(____(OP_62)____, (constI, eI)) in\n    out(pub, (____(OP_30)____, NR, ____(OP_27)____,\n\tchoice[eI, NeI],\n\tchoice[____(OP_29)____, ____(OP_26)____],\n\tchoice[eR, NeR],\n\tchoice[____(OP_28)____, NhR],\n\tchoice[Kv, NKv]))\n  )\n\n\n\n(*\n\nLet us name S' the above process.\nLet us define the context C as follows:\n\nnew getprinc0;\n(\n  []\n|\n  !\n  in(getprinc0, (IDA, getI, getR, init));\n  new connect; new accept; new channelSIA;\n  out(getprinc, (IDA, init, accept, connect, channelSIA));\n  in(channelSIA, SIA);\n  event princ(kAminus, IDA, init, accept, connect, SIA);\n  ( processI2 | processR2 )\n)\n\nlet processI2 =\n  !\n  in(getI, ((IDRp, saI), NI, NR, xI, xR, tR, Ka, Ke, Kv, sI));\n  let eI = E(Ke, (IDA, IDRp, saI, sI)) in\n  let hI = H(Ka, (constI, eI)) in\n  out(c, cons3(NI, NR, xI, xR, tR, eI, hI));\n  in(c, cons4(eR, hR));\n  if H(Ka, (constR, eR)) = hR then\n  let (IDRl, saR, sR) = D(Ke, eR) in\n  if V(sR, IDRl, (NI, NR, xI, xR)) = true then\n  out(connect, (IDRl, IDRp, saI, saR, Kv)).\n\nlet processR2 =\n  !\n  in(getR, (NI, NR, xI, xR, tR, eI, hI, Ka, Ke, Kv, sR));\n  if H(Ka, (constI, eI)) = hI then\n  let (IDIl, IDRp, saI, sI) = D(Ke,eI) in\n  if member:IDIl,SIA then\n  if V(sI, IDIl, (NI, NR, xI, xR, grpinfoR)) = true then\n  out(accept, (IDIl, IDRp, saI, saR, Kv));\n  let eR = E(Ke, (IDA, saR, sR)) in\n  let hR = H(Ka, (constR, eR)) in\n  out(c, cons4(eR, hR)).\n\nThe full JFKr script S (version without cache) is weakly observationally\nequivalent to C[S'] (more precisely, fst(S) is equivalent to\nfst(C[S']) and snd(S) is equivalent to snd(C[S'])). This is proved by\neliminating communications on the private channel getprinc and on each\ninstance of getI and getR.  ProVerif shows that S' satisfies\nequivalence, then so does C[S'] by the contextual property of\nequivalence, then fst(S) is weakly observationally equivalent to snd(S).\n\n*)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.701s (user 0.685s + system 0.016s), max rss 28572K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* JFKr *)\n\ntype G.\ntype texponent.\ntype skey.\ntype pkey.\ntype key.\ntype tag.\ntype nonce.\ntype grpinfo.\ntype sainfo.\n\nfun G_to_key(G):key [data, typeConverter].\n\n(* Exponential and Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, texponent): G.\nequation forall y: texponent, z: texponent; exp(exp(g,y),z) = exp(exp(g,z),y).\n\n(* Signature *)\n\nfun S(skey, bitstring): bitstring.\nfun Pk(skey): pkey.\nreduc forall k: skey, v: bitstring; V(S(k,v), Pk(k),v) = true.\nreduc forall k: skey, v: bitstring; RecoverKey(S(k,v)) = Pk(k). (* For the attacker *)\nreduc forall k: skey, v: bitstring; RecoverText(S(k,v)) = v.    (* For the attacker *)\n\n(* Shared-key encryption *)\n\nfun E(key, bitstring): bitstring.\nreduc forall k: key, v: bitstring; D(k,E(k,v)) = v.\n\n(* Keyed hash function *)\n\nfun H(key, bitstring): key.\n\n(* Tags *)\n\nconst tagE, tagA, tagV: tag [data].\n\n(* Constructors for JFK's formatted messages\n   Selectors are implicit when using \"data\" *)\n\nfun cons1(nonce, G): bitstring [data].\nfun cons2(nonce, nonce, G, grpinfo, key): bitstring [data] .\nfun cons3(nonce, nonce, G, G, key, bitstring, key): bitstring [data].\nfun cons4(bitstring, key): bitstring [data].\n\n(* More constants *)\n\nconst constI, constR: tag [data].\nconst saR: sainfo [data].\n\n(* Free names *)\n\nfree c: channel. (* Public channel *)\nfree d0: channel.\nfree pub, genprinc, getexponential, init0, getprinc0: channel.\n\n(* Secrecy assumptions *)\n\nnot attacker(new kAminus) phase 0.\nnot attacker(new d).\n\n(* Initiator\n   The process processI corresponds to I^A in the figure. *)\n\nlet processI(exponent: channel, init: channel, getI: channel, kAminus: skey) =\n  !\n  in(exponent, (dI: texponent, xI: G));\n  !\n  in(init, dummy: bitstring);    (* Init message *)\n  new NI: nonce;\n  out(c, cons1(NI, xI));\n  in(c, cons2(=NI, NR, xR, grpinfoR, tR));\n  let h = G_to_key(exp(xR, dI)) in\n  let Ka = H(h, (NI, NR, tagA)) in\n  let Ke = H(h, (NI, NR, tagE)) in\n  let Kv = H(h, (NI, NR, tagV)) in\n  let sI = S(kAminus, (NI, NR, xI, xR, grpinfoR)) in\n  out(getI, (dummy, NI, NR, xI, xR, tR, Ka, Ke, Kv, sI)).\n\n(* Responder\n   The process processR corresponds to R^A in the figure. *)\n\nfree grpinfoR: grpinfo.\n\nlet processR(exponent: channel, getR: channel, IDA: pkey, kAminus: skey) =\n  !\n  in(exponent, (dR: texponent, xR: G));\n  !\n  in(c, cons1(NI, xI));\n  new NR: nonce;\n  new tR: key;\n  out(c, cons2(NI, NR, xR, grpinfoR, tR));\n  new l: channel;\n  (\n    (\n    !\n    in(c, cons3(=NI,=NR,xI,=xR,=tR,eI,hI));\n    out(l, (xI,eI,hI))\n    )\n  |\n    (\n    in(l, (xI: G,eI: bitstring,hI: key));\n      (\n        out(d0, (NR, IDA)) |\n\tlet h = G_to_key(exp(xI,dR)) in\n  \tlet Ka = H(h, (NI, NR, tagA)) in\n  \tlet Ke = H(h, (NI, NR, tagE)) in\n  \tlet Kv = H(h, (NI, NR, tagV)) in\n  \tlet sR = S(kAminus, (NI, NR, xI, xR)) in\n  \tout(getR, (NI, NR, xI, xR, tR, eI, hI, Ka, Ke, Kv, sR))\n      )\n    )\n  ).\n\n(* Whole JFK system. *)\n\nprocess\n  new exponent: channel;\n  new cp: channel;\n  new ids: channel;\n  ( ! new d: texponent; let x = exp(g,d) in out(getexponential, x); ! out(exponent, (d,x)) )\n  |\n  (\n    !\n    new kAminus: skey;\n    let IDA = Pk(kAminus) in\n    new init: channel; new getI: channel; new getR: channel;\n    out(getprinc0, (IDA, getI, getR, init));\n    ( processI(exponent, init, getI, kAminus) |\n      processR(exponent, getR, IDA, kAminus) |\n      (!out(cp, IDA)) | (!out(ids, (kAminus, IDA))))\n  )\n  |\n  (\n    in(ids, (kAIminus: skey, IDAI: pkey));\n    in(ids, (kARminus: skey, IDAR: pkey));\n    in(exponent, (dI: texponent,xI: G));\n    in(exponent, (dR: texponent,xR: G)); (* with in(pub, (NR, xR)) instead, attack for xR = g, so h = exp(g, dI) = xI. *)\n    in(init0, (IDRp: pkey, saI: sainfo,=IDAI,=IDAR,=xI,=xR));\n    new NI: nonce;\n    new NR: nonce; (* we could use instead in(pub, NR); *)\n    new TR: key;\n    new NeI: bitstring; new NhI: key; new NeR: bitstring; new NhR: key; new NKv: key;\n    let h = G_to_key(exp(xR,dI)) in\n    let Ka = H(h, (NI, NR, tagA)) in\n    let Ke = H(h, (NI, NR, tagE)) in\n    let Kv = H(h, (NI, NR, tagV)) in\n    let sR = S(kARminus, (NI, NR, xI, xR)) in\n    let eR = E(Ke, (IDAR, saR, sR)) in\n    let hR = H(Ka, (constR, eR)) in\n    let sI = S(kAIminus, (NI, NR, xI, xR, grpinfoR)) in\n    let eI = E(Ke, (IDAI, IDRp, saI, sI)) in\n    let hI = H(Ka, (constI, eI)) in\n    out(pub, (NI, NR, TR,\n\tchoice[eI, NeI],\n\tchoice[hI, NhI],\n\tchoice[eR, NeR],\n\tchoice[hR, NhR],\n\tchoice[Kv, NKv]))\n  )\n\n\n\n(*\n\nLet us name S' the above process.\nLet us define the context C as follows:\n\nnew getprinc0;\n(\n  []\n|\n  !\n  in(getprinc0, (IDA, getI, getR, init));\n  new connect; new accept; new channelSIA;\n  out(getprinc, (IDA, init, accept, connect, channelSIA));\n  in(channelSIA, SIA);\n  event princ(kAminus, IDA, init, accept, connect, SIA);\n  ( processI2 | processR2 )\n)\n\nlet processI2 =\n  !\n  in(getI, ((IDRp, saI), NI, NR, xI, xR, tR, Ka, Ke, Kv, sI));\n  let eI = E(Ke, (IDA, IDRp, saI, sI)) in\n  let hI = H(Ka, (constI, eI)) in\n  out(c, cons3(NI, NR, xI, xR, tR, eI, hI));\n  in(c, cons4(eR, hR));\n  if H(Ka, (constR, eR)) = hR then\n  let (IDRl, saR, sR) = D(Ke, eR) in\n  if V(sR, IDRl, (NI, NR, xI, xR)) = true then\n  out(connect, (IDRl, IDRp, saI, saR, Kv)).\n\nlet processR2 =\n  !\n  in(getR, (NI, NR, xI, xR, tR, eI, hI, Ka, Ke, Kv, sR));\n  if H(Ka, (constI, eI)) = hI then\n  let (IDIl, IDRp, saI, sI) = D(Ke,eI) in\n  if member:IDIl,SIA then\n  if V(sI, IDIl, (NI, NR, xI, xR, grpinfoR)) = true then\n  out(accept, (IDIl, IDRp, saI, saR, Kv));\n  let eR = E(Ke, (IDA, saR, sR)) in\n  let hR = H(Ka, (constR, eR)) in\n  out(c, cons4(eR, hR)).\n\nThe full JFKr script S (version without cache) is weakly observationally\nequivalent to C[S'] (more precisely, fst(S) is equivalent to\nfst(C[S']) and snd(S) is equivalent to snd(C[S'])). This is proved by\neliminating communications on the private channel getprinc and on each\ninstance of getI and getR.  ProVerif shows that S' satisfies\nequivalence, then so does C[S'] by the contextual property of\nequivalence, then fst(S) is weakly observationally equivalent to snd(S).\n\n*)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.701s (user 0.685s + system 0.016s), max rss 28572K\nEND *)"
    },
    {
        "file": "PV-1/key-registration-locked.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Key Registration protocol.\n  Found in \"Set-Pi: Set Membership p-Calculus\", Computer Security Foundations Symposium (CSF), 2015 IEEE 28th.\n\n  Adapted from the output of GSVerif. On this protocol, we assume that the existence of a 'lock' represented by the\n  private channel 'd'. This lock is used to ensure that the attacker cannot mix the tests on the tables between\n  two sessions of the server.\n*)\n\nfree c:____(FREE_0)____.\ntype ____(TYPE_0)____.\n\n\nfun sign(____(OP_3)____,____(OP_9)____):bitstring.\nfun pk(____(FUN_0)____):bitstring.\n\nfun checksign(____(OP_26)____,bitstring):bitstring\nreduc forall ____(REDUC_1)____:____(REDUC_0)____, ____(REDUC_2)____:bitstring; checksign(sign(x,y),pk(y)) = x.\n\ntable db_server_valid(bitstring,____(OP_4)____,bitstring).\ntable db_server_revoked(bitstring,agent,bitstring).\n\nconst renew:bitstring.\nconst confirm:bitstring.\nconst ____(CONST_0)____:bitstring.\n\nevent Revoked(bitstring). (* Event pour la query *)\nevent Honest(bitstring).  (* Event pour la query *)\n\nevent InRevoked(nat,____(OP_6)____,agent,bitstring).\nevent InValid(nat,____(OP_20)____,agent,bitstring).\nevent TestValid(nat,bitstring).\nevent TestRevoked(nat,bitstring,bitstring).\nevent Received(bitstring).\n\nfree id1:bitstring.\nfree id2:bitstring.\n\nnounif i:nat; mess(____(OP_18)____ d,i) [inductionOn=i].\n\n(* Server *)\n\nlet Server(d:channel,____(OP_12)____:bitstring) =\n  in(c,(A:agent,pkA:bitstring));\n  in(c,sig:bitstring);\n  in(d,i:nat);\n  get db_server_valid(=skS,=A,=pkA) in (* The server checks that the key is valid. *)\n  let (=____(LET_0)____,=A,____(LET_1)____:bitstring) = checksign(sig,pkA) in\n  get db_server_valid(x,y,=new_pkA) in\n    out(c,error)\n  else\n    get db_server_revoked(x',y',=____(OP_1)____) in\n      out(c,error)\n    else\n      get db_server_revoked(x',y',=pkA) in\n        out(c,error)\n      else\n        event TestValid(____(OP_23)____,new_pkA);\n        event TestRevoked(i,id1,pkA);\n        event TestRevoked(____(OP_0)____,id2,new_pkA);\n        event InRevoked(i+1,skS,A,____(OP_22)____);\n        insert db_server_revoked(skS,A,pkA);\n\n        event InValid(i+1,skS,____(OP_7)____,new_pkA);\n        insert db_server_valid(____(OP_15)____,A,new_pkA);\n\n\n        event Honest(new_pkA);\n        event Revoked(pkA);\n\n        out(c,sign((confirm,____(OP_2)____),skS));\n        out(____(OP_17)____,i+1).\n\n(* Out of band registration *)\n\nlet Register(d:channel,A:agent,cellA:channel,skS:bitstring) =\n  new k:bitstring;\n  out(cellA,k); (* Initialisation of the agent's cell *)\n  in(d,i:nat);\n  event Honest(pk(____(OP_28)____));\n  event InValid(i+1,skS,A,pk(k));\n  insert db_server_valid(skS,A,pk(k));\n  out(d,i+1);\n  out(c,pk(____(OP_10)____)).\n\n(* Revocation from client *)\n\nlet Client(A:agent,cellA:channel,pkS:bitstring) =\n  new k':bitstring;\n  in(cellA,k:____(OP_14)____);\n  out(c,(A,pk(k)));\n  let sig:bitstring = sign((renew,A,pk(k')),k) in\n  out(c,sig);\n  in(c,sig':bitstring);\n  let (=confirm,=sig) = checksign(sig',pkS) in\n  out(c,k);\n  out(cellA,k').\n\n\naxiom sks:bitstring,sks':bitstring, id:bitstring, id':bitstring, i:nat, i':nat, j:nat, j':nat,A:agent, k:bitstring,A':agent, k':bitstring;\n  event(TestValid(i',____(OP_25)____)) && event(InValid(i,sks,A,k)) ==> i > i';\n  event(TestRevoked(____(OP_16)____,id,k)) && event(InRevoked(i,____(OP_24)____,A,k)) ==> i > i';\n  event(InValid(i,sks,A,k)) && event(InValid(i,sks',____(OP_13)____,k')) ==> (sks,A,k) = (sks',A',k');\n  event(InRevoked(i,sks,A,k)) && event(InRevoked(i,____(OP_21)____,A',k')) ==> (sks,A,k) = (sks',A',k') [fullSat].\n\nquery ky:bitstring;\n  attacker(ky) && event(Honest(pk(____(OP_11)____))) ==> event(Revoked(pk(____(OP_27)____)));\n  event(Honest(pk(____(OP_19)____))) ==> ky = new k || ky = new k'.\n\nprocess\n  new ____(NEW_0)____:channel; out(____(OP_8)____,0) | ! new skS:bitstring;  out(c,pk(skS));\n  (\n    (! Server(d,skS))\n  | ! new A:agent;\n    new cellA:channel;\n    (out(c,A) | Register(d,____(OP_5)____,cellA,skS) | ! Client(A,cellA,pk(skS)))\n  )\n\n(* EXPECTPV\nRESULT event(Honest(pk(ky))) && attacker(ky) ==> event(Revoked(pk(ky))) is true.\nRESULT event(Honest(pk(ky))) ==> ky = k[!2 = v,!1 = v_1] || ky = k'[!3 = v_2,!2 = v_3,!1 = v_4] is true.\n0.032s (user 0.032s + system 0.000s), max rss 10912K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Key Registration protocol.\n  Found in \"Set-Pi: Set Membership p-Calculus\", Computer Security Foundations Symposium (CSF), 2015 IEEE 28th.\n\n  Adapted from the output of GSVerif. On this protocol, we assume that the existence of a 'lock' represented by the\n  private channel 'd'. This lock is used to ensure that the attacker cannot mix the tests on the tables between\n  two sessions of the server.\n*)\n\nfree c:channel.\ntype agent.\n\n\nfun sign(bitstring,bitstring):bitstring.\nfun pk(bitstring):bitstring.\n\nfun checksign(bitstring,bitstring):bitstring\nreduc forall x:bitstring, y:bitstring; checksign(sign(x,y),pk(y)) = x.\n\ntable db_server_valid(bitstring,agent,bitstring).\ntable db_server_revoked(bitstring,agent,bitstring).\n\nconst renew:bitstring.\nconst confirm:bitstring.\nconst error:bitstring.\n\nevent Revoked(bitstring). (* Event pour la query *)\nevent Honest(bitstring).  (* Event pour la query *)\n\nevent InRevoked(nat,bitstring,agent,bitstring).\nevent InValid(nat,bitstring,agent,bitstring).\nevent TestValid(nat,bitstring).\nevent TestRevoked(nat,bitstring,bitstring).\nevent Received(bitstring).\n\nfree id1:bitstring.\nfree id2:bitstring.\n\nnounif i:nat; mess(new d,i) [inductionOn=i].\n\n(* Server *)\n\nlet Server(d:channel,skS:bitstring) =\n  in(c,(A:agent,pkA:bitstring));\n  in(c,sig:bitstring);\n  in(d,i:nat);\n  get db_server_valid(=skS,=A,=pkA) in (* The server checks that the key is valid. *)\n  let (=renew,=A,new_pkA:bitstring) = checksign(sig,pkA) in\n  get db_server_valid(x,y,=new_pkA) in\n    out(c,error)\n  else\n    get db_server_revoked(x',y',=new_pkA) in\n      out(c,error)\n    else\n      get db_server_revoked(x',y',=pkA) in\n        out(c,error)\n      else\n        event TestValid(i,new_pkA);\n        event TestRevoked(i,id1,pkA);\n        event TestRevoked(i,id2,new_pkA);\n        event InRevoked(i+1,skS,A,pkA);\n        insert db_server_revoked(skS,A,pkA);\n\n        event InValid(i+1,skS,A,new_pkA);\n        insert db_server_valid(skS,A,new_pkA);\n\n\n        event Honest(new_pkA);\n        event Revoked(pkA);\n\n        out(c,sign((confirm,sig),skS));\n        out(d,i+1).\n\n(* Out of band registration *)\n\nlet Register(d:channel,A:agent,cellA:channel,skS:bitstring) =\n  new k:bitstring;\n  out(cellA,k); (* Initialisation of the agent's cell *)\n  in(d,i:nat);\n  event Honest(pk(k));\n  event InValid(i+1,skS,A,pk(k));\n  insert db_server_valid(skS,A,pk(k));\n  out(d,i+1);\n  out(c,pk(k)).\n\n(* Revocation from client *)\n\nlet Client(A:agent,cellA:channel,pkS:bitstring) =\n  new k':bitstring;\n  in(cellA,k:bitstring);\n  out(c,(A,pk(k)));\n  let sig:bitstring = sign((renew,A,pk(k')),k) in\n  out(c,sig);\n  in(c,sig':bitstring);\n  let (=confirm,=sig) = checksign(sig',pkS) in\n  out(c,k);\n  out(cellA,k').\n\n\naxiom sks:bitstring,sks':bitstring, id:bitstring, id':bitstring, i:nat, i':nat, j:nat, j':nat,A:agent, k:bitstring,A':agent, k':bitstring;\n  event(TestValid(i',k)) && event(InValid(i,sks,A,k)) ==> i > i';\n  event(TestRevoked(i',id,k)) && event(InRevoked(i,sks,A,k)) ==> i > i';\n  event(InValid(i,sks,A,k)) && event(InValid(i,sks',A',k')) ==> (sks,A,k) = (sks',A',k');\n  event(InRevoked(i,sks,A,k)) && event(InRevoked(i,sks',A',k')) ==> (sks,A,k) = (sks',A',k') [fullSat].\n\nquery ky:bitstring;\n  attacker(ky) && event(Honest(pk(ky))) ==> event(Revoked(pk(ky)));\n  event(Honest(pk(ky))) ==> ky = new k || ky = new k'.\n\nprocess\n  new d:channel; out(d,0) | ! new skS:bitstring;  out(c,pk(skS));\n  (\n    (! Server(d,skS))\n  | ! new A:agent;\n    new cellA:channel;\n    (out(c,A) | Register(d,A,cellA,skS) | ! Client(A,cellA,pk(skS)))\n  )\n\n(* EXPECTPV\nRESULT event(Honest(pk(ky))) && attacker(ky) ==> event(Revoked(pk(ky))) is true.\nRESULT event(Honest(pk(ky))) ==> ky = k[!2 = v,!1 = v_1] || ky = k'[!3 = v_2,!2 = v_3,!1 = v_4] is true.\n0.032s (user 0.032s + system 0.000s), max rss 10912K\nEND *)"
    },
    {
        "file": "PV-1/macs.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Comparing an abstract MAC primitive to its implementation using\n   hashes of blocks, as explained in \"mobile values\", section 6. \n   This example amounts to a change of signature, with\n   the implementation signature having additional equations for the\n   benefit of the attacker. *)\n\ntype ____(TYPE_0)____.\ntype block.\n\nfun mac(key, bitstring): bitstring. (* MAC specification, with no equation. *)\nfun impl(key, bitstring): bitstring [private]. (* choice of a MAC implementation *)\n\nfun f(key, bitstring): bitstring. (* variable-length keyed hash *)\nfun h(bitstring, block): bitstring. (* keyed-hash for a single block *)\n\n(* \nThe first, broken implementation uses \nequation impl(k,x) = f(k,x).\n\nThe second, correct implementation uses \nequation impl(k,x) = f(k,f(k,x)).\n*)\n\nequation forall k: key, x: bitstring; impl(k,x) = f(k,f(k,x)).\n\nequation forall x: key, y: bitstring, z: block; h(f(x,y),____(OP_3)____) = f(x,(y,z)).  \n\nfree c, c1, c2: ____(FREE_0)____.\n\nprocess\n\tnew ____(NEW_0)____: key;\n\t(\n\t  ( !in(c1, x: bitstring); out(c,(____(OP_6)____,choice[mac(k,____(OP_7)____),impl(k,x)])))\n\t|       \n\t  ( in(c,(x: bitstring, m: bitstring)); \n\t    if choice[mac(____(IF_1)____,____(IF_0)____),impl(k,x)] = m then out(c2,x))\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.015s (user 0.011s + system 0.004s), max rss 10256K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Comparing an abstract MAC primitive to its implementation using\n   hashes of blocks, as explained in \"mobile values\", section 6. \n   This example amounts to a change of signature, with\n   the implementation signature having additional equations for the\n   benefit of the attacker. *)\n\ntype key.\ntype block.\n\nfun mac(key, bitstring): bitstring. (* MAC specification, with no equation. *)\nfun impl(key, bitstring): bitstring [private]. (* choice of a MAC implementation *)\n\nfun f(key, bitstring): bitstring. (* variable-length keyed hash *)\nfun h(bitstring, block): bitstring. (* keyed-hash for a single block *)\n\n(* \nThe first, broken implementation uses \nequation impl(k,x) = f(k,x).\n\nThe second, correct implementation uses \nequation impl(k,x) = f(k,f(k,x)).\n*)\n\nequation forall k: key, x: bitstring; impl(k,x) = f(k,f(k,x)).\n\nequation forall x: key, y: bitstring, z: block; h(f(x,y),z) = f(x,(y,z)).  \n\nfree c, c1, c2: channel.\n\nprocess\n\tnew k: key;\n\t(\n\t  ( !in(c1, x: bitstring); out(c,(x,choice[mac(k,x),impl(k,x)])))\n\t|       \n\t  ( in(c,(x: bitstring, m: bitstring)); \n\t    if choice[mac(k,x),impl(k,x)] = m then out(c2,x))\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.015s (user 0.011s + system 0.004s), max rss 10256K\nEND *)"
    },
    {
        "file": "PV-1/myProverif.pv",
        "incomplete": "(* proverif 2.04 *)\nfree DataA:bitstring [private].    (*r1 *)\nfree DataB:bitstring [private].    (*IDA*)\nfree DataC:bitstring [private].    (*X_GWN_A*)\n\nfree DataD:bitstring [private].    (*r2*)\nfree DataF:bitstring [private].\t   (*IDB*)\nfree DataE:bitstring [private].    (*X_GWN_B*)\nfree DataG:bitstring [private].    (*sk *)\n\n\n\n\n(*communication channel *)\nfree A2RC : channel [private].\nfree B2RC : channel [private].\nfree A2GWN_PRIVATE : ____(FREE_0)____ [private].\nfree B2GWN_PRIVATE : channel [____(FREE_2)____].\n\nfree A2GWN : channel.\nfree B2GWN : ____(FREE_1)____.\nconst G : bitstring. (* Public Terms *) \n\n(*Constructor*)\nfun XOR(bitstring, bitstring) : bitstring. (* Exclusive OR *) \nfun Concat(____(OP_38)____, bitstring) : bitstring. \nfun Hash1(____(FUN_5)____) : bitstring. \nfun Hash2(bitstring, bitstring) : bitstring. \nfun Hash3(____(OP_26)____, bitstring, bitstring) : bitstring. \nfun Hash4(bitstring, bitstring, bitstring, bitstring) : bitstring. \nfun Hash5(____(FUN_2)____, ____(FUN_3)____, bitstring, bitstring, bitstring) :bitstring. \nfun Response(bitstring) : bitstring.\n\nfun a_mul_G(bitstring, bitstring) : bitstring. (* a*P *) \nfun CH(bitstring, bitstring, bitstring): bitstring. \nfun get_kA_star(____(FUN_4)____, ____(OP_51)____, bitstring): bitstring.\nfun get_m1(bitstring, bitstring, bitstring): bitstring.\nfun get_new_CH(____(FUN_0)____, bitstring, bitstring): bitstring.\nfun aenc(____(OP_41)____,bitstring) : bitstring.\n\n(*Destructor function*)\nreduc ____(REDUC_5)____ m1 : ____(REDUC_3)____, m2 : ____(REDUC_4)____; Separate1(Concat(m1, ____(OP_27)____)) = m1. \nreduc forall m1 : bitstring, m2 : bitstring; Separate2(Concat(m1, m2)) = m2. \nreduc forall m1 : bitstring, m2 : bitstring; DXOR_getSecond(XOR(m1, m2), m1) = m2. \nreduc ____(REDUC_0)____ m1 : ____(REDUC_1)____, ____(REDUC_2)____ : bitstring; DXOR_getFirst(XOR(m1, m2), m2) = m1. \nreduc forall m0 : bitstring, r1 : bitstring,r0:bitstring,x:bitstring,G:bitstring; D_get_new_CH(get_new_CH(get_m1(get_kA_star(m0,____(OP_64)____,____(OP_63)____),____(OP_65)____,x), r1,a_mul_G(x,G))) = x. \n\n\n (*create Table*)\ntable NodeAsTable(____(OP_53)____,bitstring,bitstring,bitstring). \ntable DeviceTable(bitstring,bitstring,bitstring,bitstring).\n\n (*eight event*)\nevent GWN_Device_begin(bitstring).\nevent Device_GWN_end(bitstring).\nevent GWN_NodeA_begin(bitstring).\nevent NodeA_GWN_end(bitstring).\nevent Device_GWN_begin(bitstring).\nevent GWN_Device_end(bitstring).\nevent NodeA_GWN_begin(bitstring).\nevent GWN_NodeA_end(bitstring).\n\n(*query*)\nquery attacker(____(QUERY_3)____).\nquery attacker(DataG).\nquery attacker(____(QUERY_1)____).\nquery attacker(DataE).\nquery attacker(____(QUERY_2)____).\nquery attacker(DataF).\nquery attacker(DataG).\n\n(*correspondence assertions*)\nquery t:bitstring; inj-event(NodeA_GWN_end(____(OP_5)____)) ==> inj-event(NodeA_GWN_begin(____(OP_52)____)).\nquery ____(QUERY_0)____:bitstring; event(GWN_Device_end(t)) ==> event(GWN_Device_begin(____(OP_32)____)).\nquery t:bitstring; event(GWN_NodeA_end(t)) ==> event(GWN_NodeA_begin(____(OP_34)____)).\nquery t:bitstring; inj-event(Device_GWN_end(t)) ==> inj-event(Device_GWN_begin(t)).\n\n(*SDB*)\nlet processNodeB(DataD:bitstring,DataE:bitstring,DataF:bitstring,____(OP_2)____:bitstring,NodeB:bitstring,skB : bitstring,CB : bitstring) =\n\tlet RB = Response(CB) in\n\tnew r0 : ____(NEW_6)____;\n\tnew m0 : ____(NEW_3)____;\n\tnew a : ____(NEW_4)____;\n\tlet RB_1 = XOR(RB, a) in\n\tlet pkB = a_mul_G(skB, G) in\n\t\n\tout(B2RC,(pkB, ____(OP_0)____, m0, ____(OP_1)____)); \n\tin(B2RC,(MN2:bitstring,IDB:bitstring, TIDB:bitstring));\n\tlet kB_star = get_kA_star(m0,r0,skB) in\n\t\n\t\n\tin(B2GWN,(L2:____(OP_44)____, M2:bitstring, ____(OP_43)____:bitstring));\n\t\n\tlet X_GWN_B = DXOR_getSecond(MN2, RB_1) in \n\tlet IDA = Separate1(DXOR_getFirst(____(OP_36)____, Hash4(____(LET_11)____, ____(OP_35)____,____(LET_12)____,pkB))) in\n\tlet r1 = Separate2(DXOR_getFirst(L2, Hash4(X_GWN_B, T2,IDB,pkB))) in\n\tlet M2_1 = Hash5(r1, L2, ____(LET_24)____, T2, ____(LET_23)____) in\n\tif (____(IF_0)____ = M2_1) then\n\tnew r2 : bitstring;\n\tnew ____(NEW_0)____ : bitstring;\n\tlet r2_1 = Hash2(r2, ____(LET_21)____) in\n\tout(B2GWN, aenc(DataD,____(OP_57)____));\n\tlet TIDB_new = Hash3(r2_1,TIDB,IDA) in\n\tlet m2 = get_m1(____(LET_5)____,r2_1,skB) in\n\tout(B2GWN, aenc(DataF, IDB));\n\tlet ____(LET_3)____ = Hash4(____(LET_4)____, r2, IDA, IDB) in\n\tlet L3 = XOR(r2, Hash4(X_GWN_B, ____(OP_14)____,____(OP_13)____,pkB)) in\n\tlet DID2_1 = XOR(Hash3(r2_1,____(OP_4)____,T3), IDA) in\n\t out(B2GWN, aenc(DataE,X_GWN_B));\n\tevent GWN_Device_begin(____(OP_12)____);\n\tout(B2GWN, (L3,m2,DID2_1, T3, TIDB));\n\tevent Device_GWN_end(NodeB);\n\n\t0.\n\n(*SDA*)\nlet processNodeA(DataA:bitstring,DataB:bitstring,DataC:bitstring,DataG:bitstring,GWN:bitstring,____(OP_3)____:bitstring,skA : bitstring,CA : bitstring) =\n\tlet RA = Response(____(LET_25)____) in\n\tnew r0 : bitstring;\n\tnew m0 : bitstring;\n\tnew a : ____(NEW_5)____;\n\tlet RA_1 = XOR(RA, ____(OP_42)____) in\n\tlet pkA = a_mul_G(____(OP_30)____, G) in\n\t\n\tout(A2RC, (pkA, r0, m0, RA_1)); \n\tin(A2RC, (MN1:bitstring,IDA:bitstring,TIDA:bitstring,IDB:bitstring));   \n\t\n\tout(A2GWN_PRIVATE,(IDA));\n\tlet X_GWN_A = DXOR_getSecond(____(LET_14)____, RA_1) in \n\tlet kA_star = get_kA_star(____(OP_37)____,r0,____(LET_22)____) in\n\t\n\t\n\t\n\tevent GWN_NodeA_begin(GWN);\n\tnew r1 : bitstring;\n\tout(B2GWN, aenc(DataA,r1));\n\tnew T1 : bitstring;\n\tlet r1_1 = Hash2(r1, T1) in    \n\tlet m1 = get_m1(kA_star,r1_1,skA) in\n\tout(B2GWN, aenc(____(OP_15)____,IDA)); \n\tlet L1 = XOR(r1, Hash4(X_GWN_A, T1, ____(OP_60)____,____(OP_59)____)) in\n\tlet DID1_1 = XOR(Hash3(r1_1,m1,T1), IDB) in\n\tout(A2GWN,(L1, m1,DID1_1, T1, TIDA));\n\t\n\tout(A2GWN, aenc(DataC,X_GWN_A));   \n\t\n\tin(A2GWN,(L4:bitstring, M3:bitstring, T4:bitstring));\n\tif(____(OP_58)____ = r1) then\n\t\n\tlet IDB' = Separate1(DXOR_getFirst(____(LET_8)____, Hash4(X_GWN_A, T4,IDA,____(LET_7)____))) in\n\t\n\tlet r2 = Separate2(DXOR_getFirst(L4, Hash4(X_GWN_A, T4,IDA,pkA))) in\n\tlet TIDA_new = Hash3(____(LET_15)____,TIDA,IDB) in\n\tlet M3_1 = Hash5(r2, L4, X_GWN_A ,T4, IDB) in\n\t\n\tif M3 = M3_1 then\n\t\n\tlet SK = Hash4(r1, r2, IDA, IDB) in\n\tevent NodeA_GWN_end(____(OP_31)____);\n\tout(A2GWN, aenc(DataG,SK));\n\t0.\n\n(*RA Registration Center*)\nlet processThirdParty(____(OP_50)____:____(LET_26)____) =\t\n\tin(B2RC,(pkB:bitstring, r0_2:bitstring, m0_2:bitstring, RB_1:bitstring));\n\tnew B1 : bitstring;\n\tnew TIDB : ____(NEW_7)____;\n\tlet ____(LET_0)____ = CH(m0_2, ____(OP_61)____, pkB) in\n\tlet ____(LET_13)____ = Hash3(IDB, B1, pkB) in\n\t\n\tlet MN2 = XOR(RB_1, X_GWN_B) in\n\t\n\tinsert DeviceTable(IDB,X_GWN_B,____(OP_55)____,TIDB);\n\tout(B2RC,(____(OP_16)____,IDB, TIDB));  \n\t\n\tin(A2RC,(pkA:bitstring, r0:bitstring, m0:bitstring, RA_1:bitstring));\n\tlet IDA = CH(m0, r0, pkA) in\n\tnew ____(NEW_2)____ : bitstring;\n\tnew TIDA : bitstring;\n\tlet X_GWN_A = Hash3(IDA, B0, pkA) in\n\tlet MN1 = XOR(RA_1, X_GWN_A) in\n\t\n\tinsert NodeAsTable(IDA,X_GWN_A,pkA,TIDA);\n\tout(A2RC,(MN1,IDA,TIDA,IDB));\n\t0.\n\n(*Gateway*)\nlet process_GWN(NodeA:____(LET_6)____,GWN:bitstring, NodeB:bitstring)=\n\tin(____(OP_54)____,(IDA:bitstring));\n\t\n\tget NodeAsTable(=____(OP_19)____,X_GWN_A,pkA,____(OP_18)____) in \n\tin(A2GWN, (L1:bitstring ,m1:bitstring ,DID1_1:bitstring, T1:bitstring, TIDA':bitstring));\n\t    \n\tlet r1 = DXOR_getFirst(____(OP_29)____, Hash4(X_GWN_A, ____(LET_1)____, ____(OP_28)____,____(LET_2)____)) in\n\tlet r1_1 = Hash2(r1, T1) in\n\n\tlet pkA' = a_mul_G(D_get_new_CH(get_new_CH(m1,____(OP_49)____,pkA)),G) in\n\t\n\tif (pkA' = pkA) then\n\tlet IDB = DXOR_getSecond(DID1_1, Hash3(____(LET_19)____,m1,____(LET_18)____)) in\n\t\n\tevent Device_GWN_begin(NodeB);\t\n\tget DeviceTable(=IDB,X_GWN_B,pkB,TIDB) in  \n\tnew T2 : bitstring;\n\tlet L2 = XOR(Concat(IDA,r1), Hash4(X_GWN_B,T2 ,IDB, pkB)) in\n\tlet M2 = Hash5(r1, L2, X_GWN_B, T2, IDA) in\n\t\n\tout(B2GWN,(L2, M2, T2));\n\t\n\tin(B2GWN, (L3:bitstring,m2:bitstring,DID2_1:bitstring, T3:bitstring, TIDB':bitstring));\n\tlet r2 = DXOR_getFirst(L3, Hash4(X_GWN_B, T3, m2,pkB)) in\n\tlet r2_1 = Hash2(r2, T3) in\n\tlet ____(LET_16)____ = a_mul_G(D_get_new_CH(get_new_CH(____(LET_17)____,r2_1,pkB)),G) in     \n\t\n\t\n\tif (pkB' = pkB) then\n\t\n\tevent GWN_Device_end(GWN);\n\n\tevent NodeA_GWN_begin(NodeA);\n\t\n\tlet IDA = DXOR_getSecond(DID2_1,Hash3(r2_1,m2,T3)) in\n\t\n\tlet TIDA_new = Hash3(r1_1,____(LET_20)____,IDB) in\n\tlet TIDB_new = Hash3(r2_1,TIDB,IDA) in\n\t\n\tnew T4 : bitstring;\n\tlet ____(LET_10)____ = XOR(Concat(____(LET_9)____, r2), Hash4(X_GWN_A, T4, IDA, pkA)) in\n\tlet M3 = Hash5(r2, L4, X_GWN_A, T4, IDB) in \n\tlet SK = Hash4(r1, r2, IDA, IDB) in\n\t\n\t\n\tout(A2GWN,(L4, M3, T4)); \n\tevent GWN_NodeA_end(GWN); \n\t\n\t0.\n\n(*main*)\nprocess \n\tnew GWN:____(NEW_1)____; \n\tnew NodeB:bitstring; \n\tnew NodeA:bitstring;\n\tnew CA : bitstring;\n\tnew skA : bitstring;\n\t\n\tnew xp : ____(NEW_8)____;\n\t\n\tnew CB : bitstring;\n\tnew skB : bitstring;\n\t\n   ( !(processThirdParty(xp)) | (!processNodeB(DataD,DataE,DataF,____(OP_39)____,NodeB,skB,____(OP_40)____)) | (!processNodeA(DataA,____(OP_48)____,DataC,____(OP_47)____,GWN,____(OP_46)____,skA,CA)) |(!process_GWN(NodeA,GWN, NodeB)) )",
        "complete:": "(* proverif 2.04 *)\nfree DataA:bitstring [private].    (*r1 *)\nfree DataB:bitstring [private].    (*IDA*)\nfree DataC:bitstring [private].    (*X_GWN_A*)\n\nfree DataD:bitstring [private].    (*r2*)\nfree DataF:bitstring [private].\t   (*IDB*)\nfree DataE:bitstring [private].    (*X_GWN_B*)\nfree DataG:bitstring [private].    (*sk *)\n\n\n\n\n(*communication channel *)\nfree A2RC : channel [private].\nfree B2RC : channel [private].\nfree A2GWN_PRIVATE : channel [private].\nfree B2GWN_PRIVATE : channel [private].\n\nfree A2GWN : channel.\nfree B2GWN : channel.\nconst G : bitstring. (* Public Terms *) \n\n(*Constructor*)\nfun XOR(bitstring, bitstring) : bitstring. (* Exclusive OR *) \nfun Concat(bitstring, bitstring) : bitstring. \nfun Hash1(bitstring) : bitstring. \nfun Hash2(bitstring, bitstring) : bitstring. \nfun Hash3(bitstring, bitstring, bitstring) : bitstring. \nfun Hash4(bitstring, bitstring, bitstring, bitstring) : bitstring. \nfun Hash5(bitstring, bitstring, bitstring, bitstring, bitstring) :bitstring. \nfun Response(bitstring) : bitstring.\n\nfun a_mul_G(bitstring, bitstring) : bitstring. (* a*P *) \nfun CH(bitstring, bitstring, bitstring): bitstring. \nfun get_kA_star(bitstring, bitstring, bitstring): bitstring.\nfun get_m1(bitstring, bitstring, bitstring): bitstring.\nfun get_new_CH(bitstring, bitstring, bitstring): bitstring.\nfun aenc(bitstring,bitstring) : bitstring.\n\n(*Destructor function*)\nreduc forall m1 : bitstring, m2 : bitstring; Separate1(Concat(m1, m2)) = m1. \nreduc forall m1 : bitstring, m2 : bitstring; Separate2(Concat(m1, m2)) = m2. \nreduc forall m1 : bitstring, m2 : bitstring; DXOR_getSecond(XOR(m1, m2), m1) = m2. \nreduc forall m1 : bitstring, m2 : bitstring; DXOR_getFirst(XOR(m1, m2), m2) = m1. \nreduc forall m0 : bitstring, r1 : bitstring,r0:bitstring,x:bitstring,G:bitstring; D_get_new_CH(get_new_CH(get_m1(get_kA_star(m0,r0,x),r1,x), r1,a_mul_G(x,G))) = x. \n\n\n (*create Table*)\ntable NodeAsTable(bitstring,bitstring,bitstring,bitstring). \ntable DeviceTable(bitstring,bitstring,bitstring,bitstring).\n\n (*eight event*)\nevent GWN_Device_begin(bitstring).\nevent Device_GWN_end(bitstring).\nevent GWN_NodeA_begin(bitstring).\nevent NodeA_GWN_end(bitstring).\nevent Device_GWN_begin(bitstring).\nevent GWN_Device_end(bitstring).\nevent NodeA_GWN_begin(bitstring).\nevent GWN_NodeA_end(bitstring).\n\n(*query*)\nquery attacker(DataA).\nquery attacker(DataG).\nquery attacker(DataD).\nquery attacker(DataE).\nquery attacker(DataF).\nquery attacker(DataF).\nquery attacker(DataG).\n\n(*correspondence assertions*)\nquery t:bitstring; inj-event(NodeA_GWN_end(t)) ==> inj-event(NodeA_GWN_begin(t)).\nquery t:bitstring; event(GWN_Device_end(t)) ==> event(GWN_Device_begin(t)).\nquery t:bitstring; event(GWN_NodeA_end(t)) ==> event(GWN_NodeA_begin(t)).\nquery t:bitstring; inj-event(Device_GWN_end(t)) ==> inj-event(Device_GWN_begin(t)).\n\n(*SDB*)\nlet processNodeB(DataD:bitstring,DataE:bitstring,DataF:bitstring,GWN:bitstring,NodeB:bitstring,skB : bitstring,CB : bitstring) =\n\tlet RB = Response(CB) in\n\tnew r0 : bitstring;\n\tnew m0 : bitstring;\n\tnew a : bitstring;\n\tlet RB_1 = XOR(RB, a) in\n\tlet pkB = a_mul_G(skB, G) in\n\t\n\tout(B2RC,(pkB, r0, m0, RB_1)); \n\tin(B2RC,(MN2:bitstring,IDB:bitstring, TIDB:bitstring));\n\tlet kB_star = get_kA_star(m0,r0,skB) in\n\t\n\t\n\tin(B2GWN,(L2:bitstring, M2:bitstring, T2:bitstring));\n\t\n\tlet X_GWN_B = DXOR_getSecond(MN2, RB_1) in \n\tlet IDA = Separate1(DXOR_getFirst(L2, Hash4(X_GWN_B, T2,IDB,pkB))) in\n\tlet r1 = Separate2(DXOR_getFirst(L2, Hash4(X_GWN_B, T2,IDB,pkB))) in\n\tlet M2_1 = Hash5(r1, L2, X_GWN_B, T2, IDA) in\n\tif (M2 = M2_1) then\n\tnew r2 : bitstring;\n\tnew T3 : bitstring;\n\tlet r2_1 = Hash2(r2, T3) in\n\tout(B2GWN, aenc(DataD,r2));\n\tlet TIDB_new = Hash3(r2_1,TIDB,IDA) in\n\tlet m2 = get_m1(kB_star,r2_1,skB) in\n\tout(B2GWN, aenc(DataF, IDB));\n\tlet SK = Hash4(r1, r2, IDA, IDB) in\n\tlet L3 = XOR(r2, Hash4(X_GWN_B, T3,m2,pkB)) in\n\tlet DID2_1 = XOR(Hash3(r2_1,m2,T3), IDA) in\n\t out(B2GWN, aenc(DataE,X_GWN_B));\n\tevent GWN_Device_begin(GWN);\n\tout(B2GWN, (L3,m2,DID2_1, T3, TIDB));\n\tevent Device_GWN_end(NodeB);\n\n\t0.\n\n(*SDA*)\nlet processNodeA(DataA:bitstring,DataB:bitstring,DataC:bitstring,DataG:bitstring,GWN:bitstring,NodeA:bitstring,skA : bitstring,CA : bitstring) =\n\tlet RA = Response(CA) in\n\tnew r0 : bitstring;\n\tnew m0 : bitstring;\n\tnew a : bitstring;\n\tlet RA_1 = XOR(RA, a) in\n\tlet pkA = a_mul_G(skA, G) in\n\t\n\tout(A2RC, (pkA, r0, m0, RA_1)); \n\tin(A2RC, (MN1:bitstring,IDA:bitstring,TIDA:bitstring,IDB:bitstring));   \n\t\n\tout(A2GWN_PRIVATE,(IDA));\n\tlet X_GWN_A = DXOR_getSecond(MN1, RA_1) in \n\tlet kA_star = get_kA_star(m0,r0,skA) in\n\t\n\t\n\t\n\tevent GWN_NodeA_begin(GWN);\n\tnew r1 : bitstring;\n\tout(B2GWN, aenc(DataA,r1));\n\tnew T1 : bitstring;\n\tlet r1_1 = Hash2(r1, T1) in    \n\tlet m1 = get_m1(kA_star,r1_1,skA) in\n\tout(B2GWN, aenc(DataB,IDA)); \n\tlet L1 = XOR(r1, Hash4(X_GWN_A, T1, m1,pkA)) in\n\tlet DID1_1 = XOR(Hash3(r1_1,m1,T1), IDB) in\n\tout(A2GWN,(L1, m1,DID1_1, T1, TIDA));\n\t\n\tout(A2GWN, aenc(DataC,X_GWN_A));   \n\t\n\tin(A2GWN,(L4:bitstring, M3:bitstring, T4:bitstring));\n\tif(r1 = r1) then\n\t\n\tlet IDB' = Separate1(DXOR_getFirst(L4, Hash4(X_GWN_A, T4,IDA,pkA))) in\n\t\n\tlet r2 = Separate2(DXOR_getFirst(L4, Hash4(X_GWN_A, T4,IDA,pkA))) in\n\tlet TIDA_new = Hash3(r1_1,TIDA,IDB) in\n\tlet M3_1 = Hash5(r2, L4, X_GWN_A ,T4, IDB) in\n\t\n\tif M3 = M3_1 then\n\t\n\tlet SK = Hash4(r1, r2, IDA, IDB) in\n\tevent NodeA_GWN_end(NodeA);\n\tout(A2GWN, aenc(DataG,SK));\n\t0.\n\n(*RA Registration Center*)\nlet processThirdParty(xp:bitstring) =\t\n\tin(B2RC,(pkB:bitstring, r0_2:bitstring, m0_2:bitstring, RB_1:bitstring));\n\tnew B1 : bitstring;\n\tnew TIDB : bitstring;\n\tlet IDB = CH(m0_2, r0_2, pkB) in\n\tlet X_GWN_B = Hash3(IDB, B1, pkB) in\n\t\n\tlet MN2 = XOR(RB_1, X_GWN_B) in\n\t\n\tinsert DeviceTable(IDB,X_GWN_B,pkB,TIDB);\n\tout(B2RC,(MN2,IDB, TIDB));  \n\t\n\tin(A2RC,(pkA:bitstring, r0:bitstring, m0:bitstring, RA_1:bitstring));\n\tlet IDA = CH(m0, r0, pkA) in\n\tnew B0 : bitstring;\n\tnew TIDA : bitstring;\n\tlet X_GWN_A = Hash3(IDA, B0, pkA) in\n\tlet MN1 = XOR(RA_1, X_GWN_A) in\n\t\n\tinsert NodeAsTable(IDA,X_GWN_A,pkA,TIDA);\n\tout(A2RC,(MN1,IDA,TIDA,IDB));\n\t0.\n\n(*Gateway*)\nlet process_GWN(NodeA:bitstring,GWN:bitstring, NodeB:bitstring)=\n\tin(A2GWN_PRIVATE,(IDA:bitstring));\n\t\n\tget NodeAsTable(=IDA,X_GWN_A,pkA,TIDA) in \n\tin(A2GWN, (L1:bitstring ,m1:bitstring ,DID1_1:bitstring, T1:bitstring, TIDA':bitstring));\n\t    \n\tlet r1 = DXOR_getFirst(L1, Hash4(X_GWN_A, T1, m1,pkA)) in\n\tlet r1_1 = Hash2(r1, T1) in\n\n\tlet pkA' = a_mul_G(D_get_new_CH(get_new_CH(m1,r1_1,pkA)),G) in\n\t\n\tif (pkA' = pkA) then\n\tlet IDB = DXOR_getSecond(DID1_1, Hash3(r1_1,m1,T1)) in\n\t\n\tevent Device_GWN_begin(NodeB);\t\n\tget DeviceTable(=IDB,X_GWN_B,pkB,TIDB) in  \n\tnew T2 : bitstring;\n\tlet L2 = XOR(Concat(IDA,r1), Hash4(X_GWN_B,T2 ,IDB, pkB)) in\n\tlet M2 = Hash5(r1, L2, X_GWN_B, T2, IDA) in\n\t\n\tout(B2GWN,(L2, M2, T2));\n\t\n\tin(B2GWN, (L3:bitstring,m2:bitstring,DID2_1:bitstring, T3:bitstring, TIDB':bitstring));\n\tlet r2 = DXOR_getFirst(L3, Hash4(X_GWN_B, T3, m2,pkB)) in\n\tlet r2_1 = Hash2(r2, T3) in\n\tlet pkB' = a_mul_G(D_get_new_CH(get_new_CH(m2,r2_1,pkB)),G) in     \n\t\n\t\n\tif (pkB' = pkB) then\n\t\n\tevent GWN_Device_end(GWN);\n\n\tevent NodeA_GWN_begin(NodeA);\n\t\n\tlet IDA = DXOR_getSecond(DID2_1,Hash3(r2_1,m2,T3)) in\n\t\n\tlet TIDA_new = Hash3(r1_1,TIDA,IDB) in\n\tlet TIDB_new = Hash3(r2_1,TIDB,IDA) in\n\t\n\tnew T4 : bitstring;\n\tlet L4 = XOR(Concat(IDB, r2), Hash4(X_GWN_A, T4, IDA, pkA)) in\n\tlet M3 = Hash5(r2, L4, X_GWN_A, T4, IDB) in \n\tlet SK = Hash4(r1, r2, IDA, IDB) in\n\t\n\t\n\tout(A2GWN,(L4, M3, T4)); \n\tevent GWN_NodeA_end(GWN); \n\t\n\t0.\n\n(*main*)\nprocess \n\tnew GWN:bitstring; \n\tnew NodeB:bitstring; \n\tnew NodeA:bitstring;\n\tnew CA : bitstring;\n\tnew skA : bitstring;\n\t\n\tnew xp : bitstring;\n\t\n\tnew CB : bitstring;\n\tnew skB : bitstring;\n\t\n   ( !(processThirdParty(xp)) | (!processNodeB(DataD,DataE,DataF,GWN,NodeB,skB,CB)) | (!processNodeA(DataA,DataB,DataC,DataG,GWN,NodeA,skA,CA)) |(!process_GWN(NodeA,GWN, NodeB)) )"
    },
    {
        "file": "PV-1/nde-pk.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Non-deterministic public-key encryption *)\n\nfun pk/1.\nfun enc/____(FUN_0)____.\nfun dec/2.\nequation dec(enc(____(EQUATION_1)____, pk(y), ____(EQUATION_0)____), y) = x.\n\nfree c,____(FREE_0)____.\n\nprocess\n\tnew s;\n\t(\n\t  out(c, pk(s))\n\t|\n\t  !\n\t  in(____(OP_0)____, x);\n\t  new ____(NEW_0)____;\n\t  out(c, choice[enc(x, pk(s), a), a])\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.004s (user 0.004s + system 0.000s), max rss 8008K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Non-deterministic public-key encryption *)\n\nfun pk/1.\nfun enc/3.\nfun dec/2.\nequation dec(enc(x, pk(y), z), y) = x.\n\nfree c,c2.\n\nprocess\n\tnew s;\n\t(\n\t  out(c, pk(s))\n\t|\n\t  !\n\t  in(c2, x);\n\t  new a;\n\t  out(c, choice[enc(x, pk(s), a), a])\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.004s (user 0.004s + system 0.000s), max rss 8008K\nEND *)"
    },
    {
        "file": "PV-1/needham.horn",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\npred begin/1 block.\npred ____(PRED_0)____/1 elimVar, decompData.\nnounif c:x.\n\nfun ____(FUN_0)____/1.\nfun encrypt/2.\n\nquery end:x,____(QUERY_0)____.\n\nreduc\n\nc:encrypt(Nb[encrypt((v9,pk(____(OP_4)____[])),pk(____(OP_1)____[])),v10],pk(skB[])) & c:encrypt((v9,pk(skA[])),pk(skB[])) -> end:(v10),(v9,pk(skA[]),pk(skB[]),Nb[encrypt((v9,pk(skA[])),pk(skB[])),v10]);\nc:encrypt((v6,v7),pk(skB[])) -> c:encrypt((v6,Nb[encrypt((v6,v7),pk(skB[])),v8],pk(skB[])),v7);\n____(MESSAGE_5)____:(____(MESSAGE_10)____[____(MESSAGE_3)____,____(MESSAGE_7)____],pk(skA[]),____(MESSAGE_9)____,____(MESSAGE_4)____) & c:encrypt((Na[v3,v4],____(MESSAGE_6)____,v3),pk(skA[])) & c:v3 -> c:encrypt(____(MESSAGE_8)____,v3);\nc:v1 -> c:encrypt((____(OP_0)____[v1,v2],pk(skA[])),v1);\nc:pk(skB[]);\nc:pk(skA[]);\nc:c[];\n____(MESSAGE_1)____:encrypt(____(MESSAGE_0)____,pk(y)) & ____(MESSAGE_2)____:y -> c:x;\nc:____(OP_2)____ -> c:pk(any3);\nc:any2 & c:any1 -> c:encrypt(____(OP_3)____,any1).",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\npred begin/1 block.\npred c/1 elimVar, decompData.\nnounif c:x.\n\nfun pk/1.\nfun encrypt/2.\n\nquery end:x,y.\n\nreduc\n\nc:encrypt(Nb[encrypt((v9,pk(skA[])),pk(skB[])),v10],pk(skB[])) & c:encrypt((v9,pk(skA[])),pk(skB[])) -> end:(v10),(v9,pk(skA[]),pk(skB[]),Nb[encrypt((v9,pk(skA[])),pk(skB[])),v10]);\nc:encrypt((v6,v7),pk(skB[])) -> c:encrypt((v6,Nb[encrypt((v6,v7),pk(skB[])),v8],pk(skB[])),v7);\nbegin:(Na[v3,v4],pk(skA[]),v3,v5) & c:encrypt((Na[v3,v4],v5,v3),pk(skA[])) & c:v3 -> c:encrypt(v5,v3);\nc:v1 -> c:encrypt((Na[v1,v2],pk(skA[])),v1);\nc:pk(skB[]);\nc:pk(skA[]);\nc:c[];\nc:encrypt(x,pk(y)) & c:y -> c:x;\nc:any3 -> c:pk(any3);\nc:any2 & c:any1 -> c:encrypt(any2,any1)."
    },
    {
        "file": "PV-1/NeedhamSchroederSK.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Needham-Schroeder shared key *)\n\nfree c: ____(FREE_0)____.\n\ntype key.\ntype ____(TYPE_0)____.\ntype nonce.\ntype tag.\n\n(* Shared key encryption *)\n\nfun encrypt(____(FUN_0)____,____(OP_14)____): bitstring.\nreduc ____(REDUC_1)____ x: bitstring, ____(REDUC_0)____: key; decrypt(encrypt(x,____(REDUC_2)____),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new ____(OP_21)____).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nquery attacker(____(OP_11)____ secretA);\n      attacker(new secretB).\n\nevent endAparam(____(OP_6)____,host).\nevent endBparam(____(OP_12)____,host).\nevent beginAparam(host,host).\nevent beginBparam(host,host).\nevent endAkey(____(OP_1)____, host, key).\nevent beginAkey(host, host, ____(OP_10)____).\nevent endBkey(____(OP_17)____, host, key).\nevent beginBkey(host, host, key).\n\nquery x: host, y: host; inj-event(endAparam(____(OP_8)____,y)) ==> inj-event(beginAparam(x,y)).\nquery x: host, y: host, z: key; inj-event(endAkey(x,____(OP_19)____,z)) ==> inj-event(beginAkey(x,y,z)).\nquery x: host, y: host; inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)).\nquery ____(QUERY_1)____: ____(QUERY_0)____, y: ____(QUERY_3)____, ____(QUERY_4)____: key; inj-event(endBkey(____(QUERY_2)____,y,____(OP_15)____)) ==> inj-event(beginBkey(x,____(OP_20)____,z)).\n\n(* constants 0 and 1 *)\n\nconst c0: tag [data].\nconst c1: ____(CONST_0)____ [data].\n\n\n(* Role of the initiator with identity xA and key kas shared with S *)\n\nlet processInitiator =\n\t(* Session secret *)\n\tnew secretA: bitstring;\n        (* The attacker starts the initiator by choosing identity xA.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, (xA: host, h: host));\n\tif xA = A || xA = B then\n\tget keys(=xA, kas) in\n\t(* Real start of the role *)\n\tevent beginBparam(xA,____(OP_13)____);\n\tnew Na: ____(NEW_1)____;\n\tout(c,(____(OP_7)____, h, Na));\n\tin(c,m2: bitstring);\n\tlet (=Na, =h, k: key, m: bitstring) = decrypt(m2, kas) in\n\tevent beginBkey(xA, h, k);\n\tout(c,m);\n\tin(____(OP_4)____, m3: bitstring);\n\tlet (=c0, n: ____(LET_0)____) = decrypt(____(OP_0)____, k) in\n\tout(c, encrypt((c1, n), ____(OP_9)____));\n\tif ____(IF_1)____ = B ____(IF_0)____ h = A then\n\tevent endAparam(xA, h);\n\tevent endAkey(xA, h, k);\n\tout(c, encrypt(secretA, k)).\n\n(* Role of the responder with identity xB and key kbs shared with S *)\n                         \nlet processResponder =\n\t(* Session secret *)\n\tnew secretB: bitstring;\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kbs) in\n\t(* Real start of the role *)\n\tin(c,m4: bitstring);\n\tlet (k: key,h: host) = decrypt(m4,kbs) in\n\tevent beginAparam(h, xB);\n\tevent beginAkey(h, ____(OP_2)____, k);\n\tnew Nb: nonce;\n\tout(c, encrypt((c0, Nb), k));\n\tin(____(OP_22)____,m5: bitstring);\n\tlet (=c1, =Nb) = decrypt(____(OP_23)____,k) in\n\tif ____(IF_3)____ = ____(IF_2)____ || h = B then\n\tevent endBparam(h, xB);\n\tevent endBkey(h, xB, ____(OP_5)____);\n\tout(c, encrypt(secretB, k)).\n\n(* Server *)\n\nlet processS =\n\tin(c, (h1: host,h2: host,n: nonce));\n\tget keys(=h1, ks1) in\n\tget keys(=h2, ks2) in\n\tnew k: ____(NEW_0)____;\n\tout(c, encrypt((n, h2, k, encrypt((k,____(OP_16)____),ks2)), ks1)).\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(____(OP_18)____, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT not attacker(secretA[!1 = v]) is true.\nRESULT not attacker(secretB[!1 = v]) is true.\nRESULT inj-event(endAparam(x,y)) ==> inj-event(beginAparam(x,y)) is true.\nRESULT inj-event(endAkey(x,y,z)) ==> inj-event(beginAkey(x,y,z)) is true.\nRESULT inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)) is true.\nRESULT inj-event(endBkey(x,y,z)) ==> inj-event(beginBkey(x,y,z)) is true.\n0.105s (user 0.094s + system 0.012s), max rss 12748K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Needham-Schroeder shared key *)\n\nfree c: channel.\n\ntype key.\ntype host.\ntype nonce.\ntype tag.\n\n(* Shared key encryption *)\n\nfun encrypt(bitstring,key): bitstring.\nreduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new Kas).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nquery attacker(new secretA);\n      attacker(new secretB).\n\nevent endAparam(host,host).\nevent endBparam(host,host).\nevent beginAparam(host,host).\nevent beginBparam(host,host).\nevent endAkey(host, host, key).\nevent beginAkey(host, host, key).\nevent endBkey(host, host, key).\nevent beginBkey(host, host, key).\n\nquery x: host, y: host; inj-event(endAparam(x,y)) ==> inj-event(beginAparam(x,y)).\nquery x: host, y: host, z: key; inj-event(endAkey(x,y,z)) ==> inj-event(beginAkey(x,y,z)).\nquery x: host, y: host; inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)).\nquery x: host, y: host, z: key; inj-event(endBkey(x,y,z)) ==> inj-event(beginBkey(x,y,z)).\n\n(* constants 0 and 1 *)\n\nconst c0: tag [data].\nconst c1: tag [data].\n\n\n(* Role of the initiator with identity xA and key kas shared with S *)\n\nlet processInitiator =\n\t(* Session secret *)\n\tnew secretA: bitstring;\n        (* The attacker starts the initiator by choosing identity xA.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, (xA: host, h: host));\n\tif xA = A || xA = B then\n\tget keys(=xA, kas) in\n\t(* Real start of the role *)\n\tevent beginBparam(xA,h);\n\tnew Na: nonce;\n\tout(c,(xA, h, Na));\n\tin(c,m2: bitstring);\n\tlet (=Na, =h, k: key, m: bitstring) = decrypt(m2, kas) in\n\tevent beginBkey(xA, h, k);\n\tout(c,m);\n\tin(c, m3: bitstring);\n\tlet (=c0, n: nonce) = decrypt(m3, k) in\n\tout(c, encrypt((c1, n), k));\n\tif h = B || h = A then\n\tevent endAparam(xA, h);\n\tevent endAkey(xA, h, k);\n\tout(c, encrypt(secretA, k)).\n\n(* Role of the responder with identity xB and key kbs shared with S *)\n                         \nlet processResponder =\n\t(* Session secret *)\n\tnew secretB: bitstring;\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kbs) in\n\t(* Real start of the role *)\n\tin(c,m4: bitstring);\n\tlet (k: key,h: host) = decrypt(m4,kbs) in\n\tevent beginAparam(h, xB);\n\tevent beginAkey(h, xB, k);\n\tnew Nb: nonce;\n\tout(c, encrypt((c0, Nb), k));\n\tin(c,m5: bitstring);\n\tlet (=c1, =Nb) = decrypt(m5,k) in\n\tif h = A || h = B then\n\tevent endBparam(h, xB);\n\tevent endBkey(h, xB, k);\n\tout(c, encrypt(secretB, k)).\n\n(* Server *)\n\nlet processS =\n\tin(c, (h1: host,h2: host,n: nonce));\n\tget keys(=h1, ks1) in\n\tget keys(=h2, ks2) in\n\tnew k: key;\n\tout(c, encrypt((n, h2, k, encrypt((k,h1),ks2)), ks1)).\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT not attacker(secretA[!1 = v]) is true.\nRESULT not attacker(secretB[!1 = v]) is true.\nRESULT inj-event(endAparam(x,y)) ==> inj-event(beginAparam(x,y)) is true.\nRESULT inj-event(endAkey(x,y,z)) ==> inj-event(beginAkey(x,y,z)) is true.\nRESULT inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)) is true.\nRESULT inj-event(endBkey(x,y,z)) ==> inj-event(beginBkey(x,y,z)) is true.\n0.105s (user 0.094s + system 0.012s), max rss 12748K\nEND *)"
    },
    {
        "file": "PV-1/NS-CBC-secrecy.pv",
        "incomplete": "free c : channel.\n\nfree A : ____(OP_0)____.\nfree B : ____(OP_6)____.\nfree I : ____(FREE_0)____.\n\nfun succ(____(OP_8)____) : bitstring [data].\n\nfun cbc_enc_1(bitstring, bitstring) : bitstring.\nfun cbc_enc_2(bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_3(bitstring, bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_4(____(FUN_4)____, ____(FUN_5)____, bitstring, bitstring, bitstring) : bitstring.\n\nfun cbc_dec_1(bitstring, bitstring) : bitstring.\nfun cbc_dec_2(____(FUN_2)____, bitstring) : bitstring.\nfun cbc_dec_3(bitstring, bitstring) : bitstring.\nfun cbc_dec_4(____(FUN_0)____, bitstring) : bitstring.\n\nfun cbc_2_get_1_prefixes(____(FUN_1)____) : bitstring.\nfun cbc_3_get_1_prefixes(____(FUN_3)____) : bitstring.\nfun cbc_3_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_1_prefixes(____(FUN_6)____) : bitstring.\nfun cbc_4_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_3_prefixes(bitstring) : bitstring.\n\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_2_get_1_prefixes(cbc_enc_2(x0, x1, ____(OP_3)____)) = cbc_enc_1(x0, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_1_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_2_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_2(x0, x1, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_1_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_2_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_2(x0, x1, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_3_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_3(x0, x1, x2, k).\n\nequation forall x0:bitstring, k:bitstring;\n  cbc_dec_1(cbc_enc_1(x0, k), k) = x0.\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_dec_2(cbc_enc_2(x0, x1, k), k) = (x0, x1).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_dec_3(cbc_enc_3(x0, x1, x2, k), k) = (x0, x1, x2).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_dec_4(cbc_enc_4(x0, x1, x2, x3, k), k) = (x0, x1, x2, x3).\n\nquery attacker(____(QUERY_0)____ ____(OP_7)____).\n\nlet client_A(Kas : bitstring) =\n  new Na : bitstring;\n\n  out(c, (A, B, Na));                                     (* 1. *)\n  in(c, enc_Na_B_enc_Kab_A : bitstring);                  (* 2. *)\n  let (=Na, =B, Kab : bitstring, enc_Kab_A : bitstring) =\n    cbc_dec_4(enc_Na_B_enc_Kab_A, Kas) in\n  out(c, enc_Kab_A);                                      (* 3. *)\n  in(c, enc_Nb : bitstring);                              (* 4. *)\n  let Nb = cbc_dec_1(enc_Nb, ____(LET_0)____) in\n  out(c, cbc_enc_1(succ(Nb), Kab)).                       (* 5. *)\n\nlet client_B(Kbs : bitstring) =\n  new Nb : bitstring;\n  in(c, enc_Kab_A : bitstring);                            (* 3. *)\n  let (Kab : bitstring, =A) = cbc_dec_2(enc_Kab_A, Kbs) in\n  out(c, cbc_enc_1(Nb, Kab));                              (* 4. *)\n  in(c, enc_succ_Nb : bitstring);                          (* 5. *)\n  let (=succ(Nb)) = cbc_dec_1(enc_succ_Nb, Kab) in\n  0.\n\nlet server_S(Kas : bitstring, Kbs : bitstring) =\n  new ____(NEW_0)____ : bitstring;\n  in(c, (A : bitstring, B : bitstring, Na : bitstring));      (* 1. *)\n  out(c, cbc_enc_4(Na, B, Kab, cbc_enc_2(Kab, A, Kbs), Kas)). (* 2. *)\n\nprocess\n  new ____(NEW_1)____ : bitstring;\n  new Kbs : bitstring;\n\n    (! client_A(Kas))\n  | (! client_B(Kbs))\n  | (! server_S(____(OP_5)____, Kbs))",
        "complete:": "free c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun succ(bitstring) : bitstring [data].\n\nfun cbc_enc_1(bitstring, bitstring) : bitstring.\nfun cbc_enc_2(bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_3(bitstring, bitstring, bitstring, bitstring) : bitstring.\nfun cbc_enc_4(bitstring, bitstring, bitstring, bitstring, bitstring) : bitstring.\n\nfun cbc_dec_1(bitstring, bitstring) : bitstring.\nfun cbc_dec_2(bitstring, bitstring) : bitstring.\nfun cbc_dec_3(bitstring, bitstring) : bitstring.\nfun cbc_dec_4(bitstring, bitstring) : bitstring.\n\nfun cbc_2_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_1_prefixes(bitstring) : bitstring.\nfun cbc_3_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_1_prefixes(bitstring) : bitstring.\nfun cbc_4_get_2_prefixes(bitstring) : bitstring.\nfun cbc_4_get_3_prefixes(bitstring) : bitstring.\n\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_2_get_1_prefixes(cbc_enc_2(x0, x1, k)) = cbc_enc_1(x0, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_1_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_3_get_2_prefixes(cbc_enc_3(x0, x1, x2, k)) = cbc_enc_2(x0, x1, k).\n\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_1_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_1(x0, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_2_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_2(x0, x1, k).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_4_get_3_prefixes(cbc_enc_4(x0, x1, x2, x3, k)) = cbc_enc_3(x0, x1, x2, k).\n\nequation forall x0:bitstring, k:bitstring;\n  cbc_dec_1(cbc_enc_1(x0, k), k) = x0.\nequation forall x0:bitstring, x1:bitstring, k:bitstring;\n  cbc_dec_2(cbc_enc_2(x0, x1, k), k) = (x0, x1).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, k:bitstring;\n  cbc_dec_3(cbc_enc_3(x0, x1, x2, k), k) = (x0, x1, x2).\nequation forall x0:bitstring, x1:bitstring, x2:bitstring, x3:bitstring, k:bitstring;\n  cbc_dec_4(cbc_enc_4(x0, x1, x2, x3, k), k) = (x0, x1, x2, x3).\n\nquery attacker(new Kab).\n\nlet client_A(Kas : bitstring) =\n  new Na : bitstring;\n\n  out(c, (A, B, Na));                                     (* 1. *)\n  in(c, enc_Na_B_enc_Kab_A : bitstring);                  (* 2. *)\n  let (=Na, =B, Kab : bitstring, enc_Kab_A : bitstring) =\n    cbc_dec_4(enc_Na_B_enc_Kab_A, Kas) in\n  out(c, enc_Kab_A);                                      (* 3. *)\n  in(c, enc_Nb : bitstring);                              (* 4. *)\n  let Nb = cbc_dec_1(enc_Nb, Kab) in\n  out(c, cbc_enc_1(succ(Nb), Kab)).                       (* 5. *)\n\nlet client_B(Kbs : bitstring) =\n  new Nb : bitstring;\n  in(c, enc_Kab_A : bitstring);                            (* 3. *)\n  let (Kab : bitstring, =A) = cbc_dec_2(enc_Kab_A, Kbs) in\n  out(c, cbc_enc_1(Nb, Kab));                              (* 4. *)\n  in(c, enc_succ_Nb : bitstring);                          (* 5. *)\n  let (=succ(Nb)) = cbc_dec_1(enc_succ_Nb, Kab) in\n  0.\n\nlet server_S(Kas : bitstring, Kbs : bitstring) =\n  new Kab : bitstring;\n  in(c, (A : bitstring, B : bitstring, Na : bitstring));      (* 1. *)\n  out(c, cbc_enc_4(Na, B, Kab, cbc_enc_2(Kab, A, Kbs), Kas)). (* 2. *)\n\nprocess\n  new Kas : bitstring;\n  new Kbs : bitstring;\n\n    (! client_A(Kas))\n  | (! client_B(Kbs))\n  | (! server_S(Kas, Kbs))"
    },
    {
        "file": "PV-1/ns-example.pv",
        "incomplete": "free ____(FREE_0)____: channel.\n\n(* Public key encryption *)\ntype pkey.\ntype ____(TYPE_0)____.\n\nfun pk(skey): pkey.\nfun aenc(____(FUN_0)____, ____(OP_2)____): bitstring.\nreduc forall x: bitstring, y: skey; adec(aenc(x, pk(____(OP_6)____)), y) = x.\n\n(* Signatures *)\ntype spkey.\ntype sskey.\n\nfun spk(sskey): spkey.\nfun sign(____(OP_5)____, sskey): bitstring.\nreduc forall x: bitstring, y: sskey; getmess(sign(x, y)) = x.\nreduc forall x: bitstring, y: sskey; checksign(sign(x, y), spk(y)) = x.\n\n(* Shared key encryption *)\nfun senc(____(FUN_1)____, bitstring): bitstring.\nreduc forall ____(REDUC_0)____: bitstring, ____(REDUC_1)____: bitstring; sdec(senc(x, ____(REDUC_2)____), y) = x.\n\n(**\n * Process A of the Needham-Schroeder protocol\n *\n * @param pkB public key (identity) of the other honest party.\n * @param skA private key of the party running the process.\n *)\nlet processA(pkB: pkey, skA: skey) =\n  in(c, pkX: pkey);\n  new Na: bitstring;\n  out(c, aenc((Na, pk(skA)), pkX));\n  in(c, m: bitstring);\n  let (=Na, NX: bitstring) = adec(m, ____(OP_4)____) in\n  out(c, aenc(NX, pkX)).\n\nlet processB(pkA: pkey, ____(OP_0)____: skey) =\n  in(c, m: bitstring);\n  let (NY: bitstring, pkY: pkey) = adec(m, skB) in\n  new Nb: ____(NEW_0)____;\n  out(c, aenc((NY, Nb), pkY));\n  in(c, m3: bitstring);\n  if Nb = adec(m3, ____(OP_3)____) then 0.\n\nprocess\n  new skA: skey; let pkA = pk(skA) in out(c, ____(OP_7)____);\n  new skB: skey; let pkB = pk(skB) in out(c, ____(OP_1)____);\n  ( (!processA(pkB, skA)) | (!processB(pkA, skB)) )",
        "complete:": "free c: channel.\n\n(* Public key encryption *)\ntype pkey.\ntype skey.\n\nfun pk(skey): pkey.\nfun aenc(bitstring, pkey): bitstring.\nreduc forall x: bitstring, y: skey; adec(aenc(x, pk(y)), y) = x.\n\n(* Signatures *)\ntype spkey.\ntype sskey.\n\nfun spk(sskey): spkey.\nfun sign(bitstring, sskey): bitstring.\nreduc forall x: bitstring, y: sskey; getmess(sign(x, y)) = x.\nreduc forall x: bitstring, y: sskey; checksign(sign(x, y), spk(y)) = x.\n\n(* Shared key encryption *)\nfun senc(bitstring, bitstring): bitstring.\nreduc forall x: bitstring, y: bitstring; sdec(senc(x, y), y) = x.\n\n(**\n * Process A of the Needham-Schroeder protocol\n *\n * @param pkB public key (identity) of the other honest party.\n * @param skA private key of the party running the process.\n *)\nlet processA(pkB: pkey, skA: skey) =\n  in(c, pkX: pkey);\n  new Na: bitstring;\n  out(c, aenc((Na, pk(skA)), pkX));\n  in(c, m: bitstring);\n  let (=Na, NX: bitstring) = adec(m, skA) in\n  out(c, aenc(NX, pkX)).\n\nlet processB(pkA: pkey, skB: skey) =\n  in(c, m: bitstring);\n  let (NY: bitstring, pkY: pkey) = adec(m, skB) in\n  new Nb: bitstring;\n  out(c, aenc((NY, Nb), pkY));\n  in(c, m3: bitstring);\n  if Nb = adec(m3, skB) then 0.\n\nprocess\n  new skA: skey; let pkA = pk(skA) in out(c, pkA);\n  new skB: skey; let pkB = pk(skB) in out(c, pkB);\n  ( (!processA(pkB, skA)) | (!processB(pkA, skB)) )"
    },
    {
        "file": "PV-1/NSLPK-agree-A-to-B.pv",
        "incomplete": "(* The code modeling key server interaction is copied from ProVerif's Needham-Schroeder examples *)\nfree c : ____(FREE_0)____.\n\nfree A : bitstring.\nfree ____(FREE_1)____ : bitstring.\nfree I : bitstring.\n\nfun pkey(bitstring) : bitstring.\n\ntable keys(____(OP_2)____, bitstring).\n\n(* Crypto primitives for the trusted server *)\nfun sign(____(OP_9)____, bitstring) : bitstring.\nfun checksign(bitstring, bitstring) : bitstring.\nfun getmess(bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  checksign(sign(____(OP_6)____,k), pkey(k)) = m.\nequation forall m:bitstring, k:bitstring;\n  getmess(sign(m,k)) = m.\n\nfun dec(____(FUN_0)____, bitstring) : bitstring.\nfun enc(____(FUN_1)____, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  dec(enc(m, k), k) = m.\n\nfun aenc(____(FUN_2)____, bitstring) : bitstring.\nfun adec(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  adec(aenc(m, pkey(k)), k) = m.\n\nfree objective : bitstring [private].\n\nquery attacker(____(QUERY_0)____).\n\nlet client_A(____(OP_8)____ : bitstring, pkS : bitstring) =\n  new Na : bitstring;\n\n  (* get pub key of I *)\n  out(____(OP_15)____, (A, I));\n  in(c, ____(OP_18)____ : bitstring);\n  let (=I, pkI : bitstring) = checksign(sign_I_pkI, pkS) in\n\n  out(c, aenc((Na, A), pkI));                                (* 1. *)\n  in(c, aenc_Na_Ni_I : bitstring);                           (* 2. *)\n  let (=Na, Ni : bitstring, =I) = adec(aenc_Na_Ni_I, skA) in\n  out(c, aenc(Ni, pkI)).                                     (* 3. *)\n  \nlet client_B(____(OP_0)____ : bitstring, pkS : bitstring) =\n  new ____(NEW_1)____ : bitstring;\n\n  (* get pub key of A *)\n  out(c, (B, A));\n  in(c, sign_A_pkA : bitstring);\n  let (=A, pkA : ____(LET_1)____) = checksign(____(OP_5)____, pkS) in\n\n  in(c, aenc_Na_A : bitstring);                      (* 1. *)\n  let (____(LET_3)____ : ____(LET_2)____, =A) = adec(____(OP_3)____, skB) in\n  out(c, aenc((Na, Nb, B), pkA));                    (* 2. *)\n  in(c, aenc_Nb : bitstring);                        (* 3. *)\n  let (=Nb) = adec(aenc_Nb, ____(OP_1)____) in\n  out(c, ____(OP_7)____).\n\nlet key_retrieval_server(skS : bitstring) =\n  in(____(OP_17)____, (____(OP_16)____ : bitstring, dst : bitstring));\n  get keys(=____(OP_10)____, pkDst) in\n  out(c, sign((dst, pkDst), skS)).\n\nlet key_register_server =\n  in(c, (host : bitstring, pk : bitstring));\n  if ____(IF_1)____ <> ____(IF_0)____ && host <> B then (\n    insert keys(host, pk)\n  ).\n\nprocess\n  new skA : bitstring;\n  new skB : bitstring;\n  new skS : ____(NEW_0)____;\n\n  let pkA = pkey(skA) in\n  let pkB = pkey(skB) in\n  let pkS = pkey(skS) in\n\n  insert keys(A, pkA);\n  insert keys(B, pkB);\n\n  out(c, pkA);\n  out(c, pkB);\n  out(c, pkS);\n\n    (! client_A(____(OP_4)____, pkS))\n  | (! client_B(skB, ____(OP_11)____))\n  | (! key_retrieval_server(skS))\n  | (! key_register_server)",
        "complete:": "(* The code modeling key server interaction is copied from ProVerif's Needham-Schroeder examples *)\nfree c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun pkey(bitstring) : bitstring.\n\ntable keys(bitstring, bitstring).\n\n(* Crypto primitives for the trusted server *)\nfun sign(bitstring, bitstring) : bitstring.\nfun checksign(bitstring, bitstring) : bitstring.\nfun getmess(bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  checksign(sign(m,k), pkey(k)) = m.\nequation forall m:bitstring, k:bitstring;\n  getmess(sign(m,k)) = m.\n\nfun dec(bitstring, bitstring) : bitstring.\nfun enc(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  dec(enc(m, k), k) = m.\n\nfun aenc(bitstring, bitstring) : bitstring.\nfun adec(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  adec(aenc(m, pkey(k)), k) = m.\n\nfree objective : bitstring [private].\n\nquery attacker(objective).\n\nlet client_A(skA : bitstring, pkS : bitstring) =\n  new Na : bitstring;\n\n  (* get pub key of I *)\n  out(c, (A, I));\n  in(c, sign_I_pkI : bitstring);\n  let (=I, pkI : bitstring) = checksign(sign_I_pkI, pkS) in\n\n  out(c, aenc((Na, A), pkI));                                (* 1. *)\n  in(c, aenc_Na_Ni_I : bitstring);                           (* 2. *)\n  let (=Na, Ni : bitstring, =I) = adec(aenc_Na_Ni_I, skA) in\n  out(c, aenc(Ni, pkI)).                                     (* 3. *)\n  \nlet client_B(skB : bitstring, pkS : bitstring) =\n  new Nb : bitstring;\n\n  (* get pub key of A *)\n  out(c, (B, A));\n  in(c, sign_A_pkA : bitstring);\n  let (=A, pkA : bitstring) = checksign(sign_A_pkA, pkS) in\n\n  in(c, aenc_Na_A : bitstring);                      (* 1. *)\n  let (Na : bitstring, =A) = adec(aenc_Na_A, skB) in\n  out(c, aenc((Na, Nb, B), pkA));                    (* 2. *)\n  in(c, aenc_Nb : bitstring);                        (* 3. *)\n  let (=Nb) = adec(aenc_Nb, skB) in\n  out(c, objective).\n\nlet key_retrieval_server(skS : bitstring) =\n  in(c, (src : bitstring, dst : bitstring));\n  get keys(=dst, pkDst) in\n  out(c, sign((dst, pkDst), skS)).\n\nlet key_register_server =\n  in(c, (host : bitstring, pk : bitstring));\n  if host <> A && host <> B then (\n    insert keys(host, pk)\n  ).\n\nprocess\n  new skA : bitstring;\n  new skB : bitstring;\n  new skS : bitstring;\n\n  let pkA = pkey(skA) in\n  let pkB = pkey(skB) in\n  let pkS = pkey(skS) in\n\n  insert keys(A, pkA);\n  insert keys(B, pkB);\n\n  out(c, pkA);\n  out(c, pkB);\n  out(c, pkS);\n\n    (! client_A(skA, pkS))\n  | (! client_B(skB, pkS))\n  | (! key_retrieval_server(skS))\n  | (! key_register_server)"
    },
    {
        "file": "PV-1/NSLPK-secrecy.pv",
        "incomplete": "(* The code modeling key server interaction is copied from ProVerif's Needham-Schroeder examples *)\nfree c : channel.\n\nfree A : ____(OP_8)____.\nfree ____(FREE_0)____ : bitstring.\nfree I : bitstring.\n\nfun pkey(____(FUN_1)____) : bitstring.\n\ntable keys(____(OP_10)____, bitstring).\n\n(* Crypto primitives for the trusted server *)\nfun sign(____(OP_11)____, bitstring) : bitstring.\nfun checksign(bitstring, bitstring) : bitstring.\nfun getmess(bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  checksign(sign(____(OP_7)____,k), pkey(k)) = m.\nequation forall m:bitstring, k:bitstring;\n  getmess(sign(m,____(OP_13)____)) = m.\n\nfun dec(bitstring, bitstring) : bitstring.\nfun enc(____(FUN_0)____, ____(OP_17)____) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  dec(enc(____(OP_18)____, k), k) = m.\n\nfun aenc(bitstring, bitstring) : bitstring.\nfun adec(____(FUN_2)____, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  adec(aenc(m, pkey(k)), k) = m.\n\nquery attacker(new ____(QUERY_0)____).\n\nlet client_A(skA : bitstring, pkS : bitstring) =\n  new Na : ____(NEW_0)____;\n\n  (* get pub key of I *)\n  out(c, (A, I));\n  in(c, sign_I_pkI : bitstring);\n  let (=I, pkI : bitstring) = checksign(____(OP_19)____, pkS) in\n\n  out(c, aenc((Na, A), pkI));                                (* 1. *)\n  in(c, aenc_Na_Ni_I : bitstring);                           (* 2. *)\n  let (=Na, Ni : bitstring, =I) = adec(aenc_Na_Ni_I, skA) in\n  out(c, aenc(Ni, pkI)).                                     (* 3. *)\n  \nlet client_B(skB : bitstring, ____(OP_12)____ : bitstring) =\n  new Nb : ____(NEW_1)____;\n\n  (* get pub key of A *)\n  out(c, (B, A));\n  in(c, sign_A_pkA : bitstring);\n  let (=A, pkA : bitstring) = checksign(sign_A_pkA, ____(OP_20)____) in\n\n  in(c, aenc_Na_A : bitstring);                      (* 1. *)\n  let (Na : bitstring, =A) = adec(aenc_Na_A, ____(OP_9)____) in\n  out(c, aenc((Na, Nb, B), pkA));                    (* 2. *)\n  in(c, aenc_Nb : bitstring);                        (* 3. *)\n  let (=Nb) = adec(aenc_Nb, skB) in\n  0.\n\nlet key_retrieval_server(____(OP_1)____ : bitstring) =\n  in(c, (src : ____(OP_5)____, dst : ____(OP_6)____));\n  get keys(=dst, pkDst) in\n  out(c, sign((dst, ____(OP_3)____), skS)).\n\nlet ____(LET_1)____ =\n  in(____(OP_15)____, (____(OP_14)____ : bitstring, pk : bitstring));\n  if host <> ____(IF_0)____ && host <> B then (\n    insert keys(host, pk)\n  ).\n\nprocess\n  new skA : bitstring;\n  new skB : bitstring;\n  new skS : bitstring;\n\n  let pkA = pkey(skA) in\n  let pkB = pkey(____(LET_2)____) in\n  let pkS = pkey(skS) in\n\n  insert keys(A, pkA);\n  insert keys(B, pkB);\n\n  out(c, ____(OP_0)____);\n  out(c, pkB);\n  out(____(OP_2)____, pkS);\n\n    (! client_A(skA, pkS))\n  | (! client_B(skB, pkS))\n  | (! key_retrieval_server(skS))\n  | (! key_register_server)",
        "complete:": "(* The code modeling key server interaction is copied from ProVerif's Needham-Schroeder examples *)\nfree c : channel.\n\nfree A : bitstring.\nfree B : bitstring.\nfree I : bitstring.\n\nfun pkey(bitstring) : bitstring.\n\ntable keys(bitstring, bitstring).\n\n(* Crypto primitives for the trusted server *)\nfun sign(bitstring, bitstring) : bitstring.\nfun checksign(bitstring, bitstring) : bitstring.\nfun getmess(bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  checksign(sign(m,k), pkey(k)) = m.\nequation forall m:bitstring, k:bitstring;\n  getmess(sign(m,k)) = m.\n\nfun dec(bitstring, bitstring) : bitstring.\nfun enc(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  dec(enc(m, k), k) = m.\n\nfun aenc(bitstring, bitstring) : bitstring.\nfun adec(bitstring, bitstring) : bitstring.\nequation forall m:bitstring, k:bitstring;\n  adec(aenc(m, pkey(k)), k) = m.\n\nquery attacker(new Nb).\n\nlet client_A(skA : bitstring, pkS : bitstring) =\n  new Na : bitstring;\n\n  (* get pub key of I *)\n  out(c, (A, I));\n  in(c, sign_I_pkI : bitstring);\n  let (=I, pkI : bitstring) = checksign(sign_I_pkI, pkS) in\n\n  out(c, aenc((Na, A), pkI));                                (* 1. *)\n  in(c, aenc_Na_Ni_I : bitstring);                           (* 2. *)\n  let (=Na, Ni : bitstring, =I) = adec(aenc_Na_Ni_I, skA) in\n  out(c, aenc(Ni, pkI)).                                     (* 3. *)\n  \nlet client_B(skB : bitstring, pkS : bitstring) =\n  new Nb : bitstring;\n\n  (* get pub key of A *)\n  out(c, (B, A));\n  in(c, sign_A_pkA : bitstring);\n  let (=A, pkA : bitstring) = checksign(sign_A_pkA, pkS) in\n\n  in(c, aenc_Na_A : bitstring);                      (* 1. *)\n  let (Na : bitstring, =A) = adec(aenc_Na_A, skB) in\n  out(c, aenc((Na, Nb, B), pkA));                    (* 2. *)\n  in(c, aenc_Nb : bitstring);                        (* 3. *)\n  let (=Nb) = adec(aenc_Nb, skB) in\n  0.\n\nlet key_retrieval_server(skS : bitstring) =\n  in(c, (src : bitstring, dst : bitstring));\n  get keys(=dst, pkDst) in\n  out(c, sign((dst, pkDst), skS)).\n\nlet key_register_server =\n  in(c, (host : bitstring, pk : bitstring));\n  if host <> A && host <> B then (\n    insert keys(host, pk)\n  ).\n\nprocess\n  new skA : bitstring;\n  new skB : bitstring;\n  new skS : bitstring;\n\n  let pkA = pkey(skA) in\n  let pkB = pkey(skB) in\n  let pkS = pkey(skS) in\n\n  insert keys(A, pkA);\n  insert keys(B, pkB);\n\n  out(c, pkA);\n  out(c, pkB);\n  out(c, pkS);\n\n    (! client_A(skA, pkS))\n  | (! client_B(skB, pkS))\n  | (! key_retrieval_server(skS))\n  | (! key_register_server)"
    },
    {
        "file": "PV-1/otrv4_idake_deniable.pv",
        "incomplete": "(* Model of OTRv4\n * Sebastian R. Verschoor\n *\n * Here we prove offline deniability for OTRv4 when running in interactive\n * mode. That means that a communicating party is not able to provide\n * convincing evidence that a conversation took part. Whatever\n * transcript/evidence is given, the honest parties can always successful argue\n * that the entire transcript was simulated by a third party (with access to\n * only the public keys of the honest parties).\n *\n * In Proverif we model this by modelling the above simulator. We run the\n * interactive handshake for the honest parties and for the simulator. If the\n * adversary cannot distinguish between honest and simulated, then the protocol\n * is offline deniable.\n *\n * # Inaccuracies of the model\n *\n * Proverif is based on the pi-calculus and can only do so much to accurately\n * model the protocol and cryptographic primitives as specified (let alone\n * implemented). In particular, Proverif assumes perfect cryptographic\n * primitives and cannot handle associativity, but for a more complete\n * discussion of the matter see the [Proverif manual][Proverif]. This is\n * relevant for OTRv4 in at least the following ways:\n * - Diffie-Hellman is only defined relative to the base element.\n * - Hashes (also MAC and KDF) are essentialy random oracles.\n *\n * Besides the above unavoidable sources of incompleteness, there are also some\n * diversions from the protocol as [currently specified][OTRv4]:\n * - Each party is assumed to have just one signed prekey.\n * - protocol negotiation/modes: it is assumed that Alice and Bob have agreed\n *   on this beforehand. Downgrade attacks, for example, are not covered.\n * - nested KDF calls are avoided\n * - I modelled [this proposal](https://github.com/otrv4/otrv4/issues/205)\n *   (since I have only modelled the handshake, that means that I simply did\n *   not include additional ephemeral keys)\n *   FIXME: this should be done differently\n * - Fingerprint comparison must be modelled at a particular point in time,\n *   here done just after the regular protocol completes. In reality, it\n *   can be done at any time (preferably beforehand). The alternative (SMP) has\n *   not been modelled.\n *\n * Some things may look strange but they should not affect the results:\n * - public data (Client-/Prekey-Profiles) are outputted only once\n * - new values are generated as early as possible, this helps Proverif\n *   resolve the model quicker. In general the order of operations does not\n *   matter, only the order of sent/received messages.\n * - prekey management is more complicated then is modelled here. However, from\n *   the protocol perspective all the server is doing is caching the messages.\n * - signatures are implemented with message recovery directly from the signature.\n *   This should improve Proverif performance and does not affect the model since\n *   signatures are always computed over publicly known values.\n * - SSID values can be compared, but this is not required to be confidential,\n *   this is modelled by simply outputting the value (but actual comparison is\n *   considered out of scope).\n *\n * # References\n * \n * [DAKES]: https://www.petsymposium.org/2018/files/papers/issue1/paper12-2018-1-source.pdf\n * [Proverif]: http://prosecco.gforge.inria.fr/personal/bblanche/proverif/manual.pdf\n * [OTRv4]: https://github.com/otrv4/otrv4/blob/master/otrv4.md\n *)\n\n\n(* The specification makes sure types cannot be mixed *)\nset ignoreTypes = false.\n\n\n(* Public communication channel *)\nchannel c.\n\n\n(* ECDH: key exchange *)\n\ntype ec_point.\ntype ec_scalar.\n\nconst ec_base: ec_point [data].\nfun ec_point_as_bits(ec_point): bitstring [data, typeConverter].\n \nfun ec_mul(ec_scalar, ec_point): ec_point.\nequation forall x: ec_scalar, y: ec_scalar;\n    ec_mul(x, ec_mul(____(OP_1)____, ec_base)) = ec_mul(y, ec_mul(____(OP_6)____, ec_base)).\n\n(* EdDSA: digital signatures *)\ntype ____(OP_7)____.\ntype ____(TYPE_0)____.\n\nfun eddsa_scalar(eddsa_private_key): ____(FUN_0)____.\nletfun eddsa_public_key(____(OP_19)____: eddsa_private_key) = ec_mul(eddsa_scalar(____(OP_21)____), ec_base).\n\nfun eddsa_sign(eddsa_private_key, ____(OP_11)____): eddsa_signature.\nreduc forall k: eddsa_private_key, m: bitstring;\n    eddsa_get_msg(eddsa_sign(____(OP_8)____, m)) = m.\nreduc forall k: eddsa_private_key, m: bitstring;\n    eddsa_verify(eddsa_sign(k, m), ec_mul(eddsa_scalar(k), ec_base)) = m.\n\n(* Elliptic curve ring signatures (three public keys) *)\n\ntype ____(TYPE_1)____.\n\ntype coins.\nfun internal_ring_sign(ec_scalar, ec_point, ec_point, ____(OP_22)____, ____(OP_23)____): ring_signature.\n\nletfun ring_sign(k: ec_scalar, a: ec_point, b: ec_point, m: bitstring) =\n    new r: ____(NEW_0)____; internal_ring_sign(k, a, b, m, r).\n\nreduc forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n    ring_get_msg(internal_ring_sign(k, a, b, m, r)) = m.\nreduc\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(____(OP_3)____, a, ____(OP_4)____, ____(OP_2)____, r), ec_mul(k, ec_base), a, b) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), ec_mul(k, ec_base), b, a) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), a, ec_mul(k, ec_base), b) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), a, b, ec_mul(k, ec_base)) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), b, ec_mul(k, ec_base), a) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), b, a, ec_mul(k, ec_base)) = m.\n\n\n(* KDF *)\n\ntype ____(TYPE_2)____.\n\nfun kdf(tag, ____(FUN_1)____): bitstring.\n\n\n(* Domain seperating tags *)\n\n(* usageID variables, superfluous ones are commented out *)\nconst usageFingerprint: tag [data].\n(* const usageThirdBraceKey: tag [data]. *)\n(* const usageBraceKey: tag [data]. *)\nconst usageSharedSecret: tag [data].\nconst usageSSID: tag [data].\n(* const usageAuthRBobClientProfile: tag [data]. *)\n(* const usageAuthRAliceClientProfile: tag [data]. *)\n(* const usageAuthRPhi: tag [data]. *)\n(* const usageAuthIBobClientProfile: tag [data]. *)\n(* const usageAuthIAliceClientProfile: tag [data]. *)\n(* const usageAuthIPhi: tag [data]. *)\n(* const usageFirstRootKey: tag [data]. *)\nconst usageTmpKey: tag [data].\nconst usageAuthMACKey: ____(CONST_3)____ [data].\n(* const usageNonIntAuthBobClientProfile: tag [data]. *)\n(* const usageNonIntAuthAliceClientProfile: tag [data]. *)\n(* const usageNonIntAuthPhi: tag [data]. *)\nconst usageAuthMAC: tag [data].\n(* const usageECDHFirstEphemeral: tag [data]. *)\n(* const usageDHFirstEphemeral: tag [data]. *)\n(* const usageRootKey: tag [data]. *)\n(* const usageChainKey: tag [data]. *)\n(* const usageNextChainKey: tag [data]. *)\n(* const usageMessageKey: tag [data]. *)\nconst ____(CONST_4)____: tag [data].\n(* const usageExtraSymmKey: tag [data]. *)\n(* const usageDataMessageSections: tag [data]. *)\nconst usageAuthenticator: tag [data].\nconst usageSMPSecret: tag [data].\n(* const usageAuth: tag [data]. *)\n\n(* Other constants *)\nconst zero: tag [____(CONST_2)____].\nconst one: tag [data].\nconst ____(CONST_5)____: tag [data].\nconst fp_idake_bob: tag [____(CONST_1)____].\nconst fp_nidake_alice: ____(CONST_0)____ [data].\nconst fp_nidake_bob: tag [data].\n\n\n(* Identity of the honest parties (e.g. bare JID) *)\n\ntype identity.\nfree id1, id2: ____(FREE_0)____.\n\n\n(* Fingerprint calculation *)\nletfun fingerprint(client_profile: ____(OP_0)____) =\n    kdf(usageFingerprint, eddsa_get_msg(____(OP_16)____)).\n\n\n(* Generate a new Client Profile *)\nletfun generate_cp() =\n    new h: eddsa_private_key;\n    new f: ec_scalar;\n    let H = eddsa_public_key(h) in\n    let F = ec_mul(f, ec_base) in\n    let cp = eddsa_sign(h, (____(OP_10)____, F)) in\n    (cp, h, f).\n\n\n(* The main process. The idea is that we run an interactive handshake\n * between Alice and Bob, or a simulated conversation by a third party.\n * If the adversary cannot distinguish between them, then the handshake\n * is *offline deniable*.\n *)\n\nprocess\n    (* Generate the honest parties *)\n    new ____(OP_5)____: eddsa_private_key;\n    new ____(NEW_2)____: ec_scalar;\n    let H1 = eddsa_public_key(h1) in\n    let F1 = ec_mul(____(OP_20)____, ec_base) in\n    let cp1 = eddsa_sign(h1, (____(LET_8)____, F1)) in\n\n    new ____(OP_13)____: ____(NEW_3)____;\n    new f2: ec_scalar;\n    let ____(LET_3)____ = eddsa_public_key(____(OP_15)____) in\n    let F2 = ec_mul(____(OP_12)____, ec_base) in\n    let cp2 = eddsa_sign(h2, (H2, F2)) in\n\n    out(c, (cp1, cp2));\n\n    (\n        (!(\n            (* Bob *)\n            new y: ec_scalar;\n            let Y = ec_mul(____(LET_1)____, ec_base) in\n            out(c, Y);\n\n            (* Alice *)\n            new x: ec_scalar;\n            let X = ec_mul(____(LET_10)____, ec_base) in\n            let ta = (zero, ____(LET_5)____, cp1, ____(LET_4)____, X, ____(LET_6)____, id1) in\n            let ka = kdf(usageSharedSecret, ec_point_as_bits(ec_mul(____(OP_9)____, Y))) in\n            let ssid_a = kdf(usageSSID, ka) in out(____(OP_18)____, ssid_a);\n            let priv_a = choice[eddsa_scalar(h1), y] in\n            let pub_a = choice[____(LET_2)____, H1] in\n            let sigma_a = ring_sign(priv_a, F2, pub_a, ta) in\n            out(c, ____(OP_14)____);\n\n            (* Bob *)\n            let tb = (one, cp2, cp1, Y, X, id2, id1) in\n            let kb = kdf(usageSharedSecret, ec_point_as_bits(ec_mul(y, ____(LET_7)____))) in\n            let ssid_b = kdf(usageSSID, kb) in out(c, ssid_b);\n            let priv_b = choice[eddsa_scalar(h2), ____(LET_9)____] in\n            let pub_b = choice[X, H2] in\n            let sigma_b = ring_sign(priv_b, F1, pub_b, tb) in\n            new ____(NEW_1)____: ec_scalar;\n            let Z = ec_mul(____(OP_17)____, ec_base) in\n            let kmac = kdf(usageMACKey, kb) in\n            let ____(LET_0)____ = kdf(usageAuthenticator, (kmac, ec_point_as_bits(Z))) in\n            out(c, (sigma_b, Z, Z_mac));\n\n            (* Alice (has no further output) *)\n\n            (* Output the session key (as computed by both sides) *)\n            out(c, (ka, kb))\n        )) |\n\n        (* Reveal all secret values *)\n        (phase 1; out(c, (h1, f1, h2, f2)))\n\n    )",
        "complete:": "(* Model of OTRv4\n * Sebastian R. Verschoor\n *\n * Here we prove offline deniability for OTRv4 when running in interactive\n * mode. That means that a communicating party is not able to provide\n * convincing evidence that a conversation took part. Whatever\n * transcript/evidence is given, the honest parties can always successful argue\n * that the entire transcript was simulated by a third party (with access to\n * only the public keys of the honest parties).\n *\n * In Proverif we model this by modelling the above simulator. We run the\n * interactive handshake for the honest parties and for the simulator. If the\n * adversary cannot distinguish between honest and simulated, then the protocol\n * is offline deniable.\n *\n * # Inaccuracies of the model\n *\n * Proverif is based on the pi-calculus and can only do so much to accurately\n * model the protocol and cryptographic primitives as specified (let alone\n * implemented). In particular, Proverif assumes perfect cryptographic\n * primitives and cannot handle associativity, but for a more complete\n * discussion of the matter see the [Proverif manual][Proverif]. This is\n * relevant for OTRv4 in at least the following ways:\n * - Diffie-Hellman is only defined relative to the base element.\n * - Hashes (also MAC and KDF) are essentialy random oracles.\n *\n * Besides the above unavoidable sources of incompleteness, there are also some\n * diversions from the protocol as [currently specified][OTRv4]:\n * - Each party is assumed to have just one signed prekey.\n * - protocol negotiation/modes: it is assumed that Alice and Bob have agreed\n *   on this beforehand. Downgrade attacks, for example, are not covered.\n * - nested KDF calls are avoided\n * - I modelled [this proposal](https://github.com/otrv4/otrv4/issues/205)\n *   (since I have only modelled the handshake, that means that I simply did\n *   not include additional ephemeral keys)\n *   FIXME: this should be done differently\n * - Fingerprint comparison must be modelled at a particular point in time,\n *   here done just after the regular protocol completes. In reality, it\n *   can be done at any time (preferably beforehand). The alternative (SMP) has\n *   not been modelled.\n *\n * Some things may look strange but they should not affect the results:\n * - public data (Client-/Prekey-Profiles) are outputted only once\n * - new values are generated as early as possible, this helps Proverif\n *   resolve the model quicker. In general the order of operations does not\n *   matter, only the order of sent/received messages.\n * - prekey management is more complicated then is modelled here. However, from\n *   the protocol perspective all the server is doing is caching the messages.\n * - signatures are implemented with message recovery directly from the signature.\n *   This should improve Proverif performance and does not affect the model since\n *   signatures are always computed over publicly known values.\n * - SSID values can be compared, but this is not required to be confidential,\n *   this is modelled by simply outputting the value (but actual comparison is\n *   considered out of scope).\n *\n * # References\n * \n * [DAKES]: https://www.petsymposium.org/2018/files/papers/issue1/paper12-2018-1-source.pdf\n * [Proverif]: http://prosecco.gforge.inria.fr/personal/bblanche/proverif/manual.pdf\n * [OTRv4]: https://github.com/otrv4/otrv4/blob/master/otrv4.md\n *)\n\n\n(* The specification makes sure types cannot be mixed *)\nset ignoreTypes = false.\n\n\n(* Public communication channel *)\nchannel c.\n\n\n(* ECDH: key exchange *)\n\ntype ec_point.\ntype ec_scalar.\n\nconst ec_base: ec_point [data].\nfun ec_point_as_bits(ec_point): bitstring [data, typeConverter].\n \nfun ec_mul(ec_scalar, ec_point): ec_point.\nequation forall x: ec_scalar, y: ec_scalar;\n    ec_mul(x, ec_mul(y, ec_base)) = ec_mul(y, ec_mul(x, ec_base)).\n\n(* EdDSA: digital signatures *)\ntype eddsa_private_key.\ntype eddsa_signature.\n\nfun eddsa_scalar(eddsa_private_key): ec_scalar.\nletfun eddsa_public_key(x: eddsa_private_key) = ec_mul(eddsa_scalar(x), ec_base).\n\nfun eddsa_sign(eddsa_private_key, bitstring): eddsa_signature.\nreduc forall k: eddsa_private_key, m: bitstring;\n    eddsa_get_msg(eddsa_sign(k, m)) = m.\nreduc forall k: eddsa_private_key, m: bitstring;\n    eddsa_verify(eddsa_sign(k, m), ec_mul(eddsa_scalar(k), ec_base)) = m.\n\n(* Elliptic curve ring signatures (three public keys) *)\n\ntype ring_signature.\n\ntype coins.\nfun internal_ring_sign(ec_scalar, ec_point, ec_point, bitstring, coins): ring_signature.\n\nletfun ring_sign(k: ec_scalar, a: ec_point, b: ec_point, m: bitstring) =\n    new r: coins; internal_ring_sign(k, a, b, m, r).\n\nreduc forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n    ring_get_msg(internal_ring_sign(k, a, b, m, r)) = m.\nreduc\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), ec_mul(k, ec_base), a, b) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), ec_mul(k, ec_base), b, a) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), a, ec_mul(k, ec_base), b) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), a, b, ec_mul(k, ec_base)) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), b, ec_mul(k, ec_base), a) = m;\n    forall k: ec_scalar, a: ec_point, b: ec_point, m: bitstring, r: coins;\n        ring_verify(internal_ring_sign(k, a, b, m, r), b, a, ec_mul(k, ec_base)) = m.\n\n\n(* KDF *)\n\ntype tag.\n\nfun kdf(tag, bitstring): bitstring.\n\n\n(* Domain seperating tags *)\n\n(* usageID variables, superfluous ones are commented out *)\nconst usageFingerprint: tag [data].\n(* const usageThirdBraceKey: tag [data]. *)\n(* const usageBraceKey: tag [data]. *)\nconst usageSharedSecret: tag [data].\nconst usageSSID: tag [data].\n(* const usageAuthRBobClientProfile: tag [data]. *)\n(* const usageAuthRAliceClientProfile: tag [data]. *)\n(* const usageAuthRPhi: tag [data]. *)\n(* const usageAuthIBobClientProfile: tag [data]. *)\n(* const usageAuthIAliceClientProfile: tag [data]. *)\n(* const usageAuthIPhi: tag [data]. *)\n(* const usageFirstRootKey: tag [data]. *)\nconst usageTmpKey: tag [data].\nconst usageAuthMACKey: tag [data].\n(* const usageNonIntAuthBobClientProfile: tag [data]. *)\n(* const usageNonIntAuthAliceClientProfile: tag [data]. *)\n(* const usageNonIntAuthPhi: tag [data]. *)\nconst usageAuthMAC: tag [data].\n(* const usageECDHFirstEphemeral: tag [data]. *)\n(* const usageDHFirstEphemeral: tag [data]. *)\n(* const usageRootKey: tag [data]. *)\n(* const usageChainKey: tag [data]. *)\n(* const usageNextChainKey: tag [data]. *)\n(* const usageMessageKey: tag [data]. *)\nconst usageMACKey: tag [data].\n(* const usageExtraSymmKey: tag [data]. *)\n(* const usageDataMessageSections: tag [data]. *)\nconst usageAuthenticator: tag [data].\nconst usageSMPSecret: tag [data].\n(* const usageAuth: tag [data]. *)\n\n(* Other constants *)\nconst zero: tag [data].\nconst one: tag [data].\nconst fp_idake_alice: tag [data].\nconst fp_idake_bob: tag [data].\nconst fp_nidake_alice: tag [data].\nconst fp_nidake_bob: tag [data].\n\n\n(* Identity of the honest parties (e.g. bare JID) *)\n\ntype identity.\nfree id1, id2: identity.\n\n\n(* Fingerprint calculation *)\nletfun fingerprint(client_profile: eddsa_signature) =\n    kdf(usageFingerprint, eddsa_get_msg(client_profile)).\n\n\n(* Generate a new Client Profile *)\nletfun generate_cp() =\n    new h: eddsa_private_key;\n    new f: ec_scalar;\n    let H = eddsa_public_key(h) in\n    let F = ec_mul(f, ec_base) in\n    let cp = eddsa_sign(h, (H, F)) in\n    (cp, h, f).\n\n\n(* The main process. The idea is that we run an interactive handshake\n * between Alice and Bob, or a simulated conversation by a third party.\n * If the adversary cannot distinguish between them, then the handshake\n * is *offline deniable*.\n *)\n\nprocess\n    (* Generate the honest parties *)\n    new h1: eddsa_private_key;\n    new f1: ec_scalar;\n    let H1 = eddsa_public_key(h1) in\n    let F1 = ec_mul(f1, ec_base) in\n    let cp1 = eddsa_sign(h1, (H1, F1)) in\n\n    new h2: eddsa_private_key;\n    new f2: ec_scalar;\n    let H2 = eddsa_public_key(h2) in\n    let F2 = ec_mul(f2, ec_base) in\n    let cp2 = eddsa_sign(h2, (H2, F2)) in\n\n    out(c, (cp1, cp2));\n\n    (\n        (!(\n            (* Bob *)\n            new y: ec_scalar;\n            let Y = ec_mul(y, ec_base) in\n            out(c, Y);\n\n            (* Alice *)\n            new x: ec_scalar;\n            let X = ec_mul(x, ec_base) in\n            let ta = (zero, cp2, cp1, Y, X, id2, id1) in\n            let ka = kdf(usageSharedSecret, ec_point_as_bits(ec_mul(x, Y))) in\n            let ssid_a = kdf(usageSSID, ka) in out(c, ssid_a);\n            let priv_a = choice[eddsa_scalar(h1), y] in\n            let pub_a = choice[Y, H1] in\n            let sigma_a = ring_sign(priv_a, F2, pub_a, ta) in\n            out(c, sigma_a);\n\n            (* Bob *)\n            let tb = (one, cp2, cp1, Y, X, id2, id1) in\n            let kb = kdf(usageSharedSecret, ec_point_as_bits(ec_mul(y, X))) in\n            let ssid_b = kdf(usageSSID, kb) in out(c, ssid_b);\n            let priv_b = choice[eddsa_scalar(h2), x] in\n            let pub_b = choice[X, H2] in\n            let sigma_b = ring_sign(priv_b, F1, pub_b, tb) in\n            new z: ec_scalar;\n            let Z = ec_mul(z, ec_base) in\n            let kmac = kdf(usageMACKey, kb) in\n            let Z_mac = kdf(usageAuthenticator, (kmac, ec_point_as_bits(Z))) in\n            out(c, (sigma_b, Z, Z_mac));\n\n            (* Alice (has no further output) *)\n\n            (* Output the session key (as computed by both sides) *)\n            out(c, (ka, kb))\n        )) |\n\n        (* Reveal all secret values *)\n        (phase 1; out(c, (h1, f1, h2, f2)))\n\n    )"
    },
    {
        "file": "PV-1/OtwayRees-key.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Otway Rees protocol.\n   Version of Otway Rees, Operating Systems Review Vol 21 no 1, p 8-10, 1987 \n\nA -> B: (C, A, B, { Na, C, A, B }_kA)\nB -> S: (C, A, B, { Na, C, A, B }_kA, { Nb, C, A, B }_kB)\nS -> B: (C, { Na, k }_kA, { Nb, k }_kB)\nB -> A: (C, { Na, k }_kA)\n\n*)\n\nfree c: channel.\n\ntype key.\ntype ____(TYPE_0)____.\ntype nonce.\n\n(* Shared key encryption *)\n\nfun encrypt(____(FUN_0)____,key): bitstring.\nreduc forall ____(REDUC_0)____: bitstring, ____(REDUC_1)____: ____(REDUC_2)____; decrypt(encrypt(x,____(OP_5)____),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new ____(OP_8)____).\nnot attacker(new ____(OP_11)____).\n\n(* 2 honest host names A and B *)\n\nfree A, ____(FREE_0)____: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nfree secretkey: key [private].\nnoninterf secretkey.\n\n(* Role of the initiator with identity xA and key kA shared with S *)\n\nlet processInitiator =\n        (* The attacker starts the initiator by choosing identity xA,\n\t   and its interlocutor xB0.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, (xA: host, xB0: host));\n\tif ____(IF_0)____ = A ____(IF_1)____ xA = B then\n\tget keys(=xA, kA) in\n\t(* Real start of the role *)\n\tnew C: nonce; \n\tnew ____(NEW_1)____: nonce;\n        out(c, (C, xA, xB0, encrypt((Na, C, xA, ____(OP_9)____), ____(OP_10)____)));\n\tin(c, (=C, m2: bitstring));\n\tlet (=Na, k: key) = decrypt(m2, kA).\n\n(* Role of the responder with identity xB and key kB shared with S *)\n\nlet processResponder =\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(____(OP_6)____, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kB) in\n\t(* Real start of the role *)\n\tin(____(OP_1)____, (C1: nonce, xA1: ____(OP_3)____, =xB, ____(OP_2)____: bitstring));\n\tnew Nb: nonce;\n\tout(c, (C1, xA1, xB, m2, encrypt((Nb, C1, xA1, xB), kB)));\n\tin(c, (=____(OP_7)____, m3: bitstring, m4: bitstring));\n\tlet (=Nb, k: key) = decrypt(m4, kB) in\n\tout(c, (C1, m3)).\n\n(* Server *)\n\nlet processS = \n        in(____(OP_15)____, (____(OP_16)____: nonce, xA1: host, xB1: host, ____(OP_14)____: ____(OP_13)____, m3: bitstring));\n    \tget keys(=xA1, kA1) in\n\tget keys(=xB1, kB1) in\n\tlet (____(LET_1)____: nonce, =C1, =____(LET_2)____, =xB1) = decrypt(m2, kA1) in\n\tlet (Nb1: nonce, =C1, =xA1, =xB1) = decrypt(m3, kB1) in\n\tif (xA1, xB1) = (A, B) then\n\t(\n\tlet k = ____(LET_0)____ in\n        out(c, (C1, encrypt((Na1, k), kA1), \n                    encrypt((Nb1, ____(OP_4)____), kB1)))\n        )\n        else\n        (\n\tnew k: ____(NEW_0)____;\n        out(c, (C1, encrypt((Na1, k), kA1), \n                    encrypt((Nb1, k), ____(OP_12)____)))\n        ).\n\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,____(OP_0)____).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT Non-interference secretkey is true.\n0.045s (user 0.041s + system 0.004s), max rss 11256K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Otway Rees protocol.\n   Version of Otway Rees, Operating Systems Review Vol 21 no 1, p 8-10, 1987 \n\nA -> B: (C, A, B, { Na, C, A, B }_kA)\nB -> S: (C, A, B, { Na, C, A, B }_kA, { Nb, C, A, B }_kB)\nS -> B: (C, { Na, k }_kA, { Nb, k }_kB)\nB -> A: (C, { Na, k }_kA)\n\n*)\n\nfree c: channel.\n\ntype key.\ntype host.\ntype nonce.\n\n(* Shared key encryption *)\n\nfun encrypt(bitstring,key): bitstring.\nreduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new Kas).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nfree secretkey: key [private].\nnoninterf secretkey.\n\n(* Role of the initiator with identity xA and key kA shared with S *)\n\nlet processInitiator =\n        (* The attacker starts the initiator by choosing identity xA,\n\t   and its interlocutor xB0.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, (xA: host, xB0: host));\n\tif xA = A || xA = B then\n\tget keys(=xA, kA) in\n\t(* Real start of the role *)\n\tnew C: nonce; \n\tnew Na: nonce;\n        out(c, (C, xA, xB0, encrypt((Na, C, xA, xB0), kA)));\n\tin(c, (=C, m2: bitstring));\n\tlet (=Na, k: key) = decrypt(m2, kA).\n\n(* Role of the responder with identity xB and key kB shared with S *)\n\nlet processResponder =\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kB) in\n\t(* Real start of the role *)\n\tin(c, (C1: nonce, xA1: host, =xB, m2: bitstring));\n\tnew Nb: nonce;\n\tout(c, (C1, xA1, xB, m2, encrypt((Nb, C1, xA1, xB), kB)));\n\tin(c, (=C1, m3: bitstring, m4: bitstring));\n\tlet (=Nb, k: key) = decrypt(m4, kB) in\n\tout(c, (C1, m3)).\n\n(* Server *)\n\nlet processS = \n        in(c, (C1: nonce, xA1: host, xB1: host, m2: bitstring, m3: bitstring));\n    \tget keys(=xA1, kA1) in\n\tget keys(=xB1, kB1) in\n\tlet (Na1: nonce, =C1, =xA1, =xB1) = decrypt(m2, kA1) in\n\tlet (Nb1: nonce, =C1, =xA1, =xB1) = decrypt(m3, kB1) in\n\tif (xA1, xB1) = (A, B) then\n\t(\n\tlet k = secretkey in\n        out(c, (C1, encrypt((Na1, k), kA1), \n                    encrypt((Nb1, k), kB1)))\n        )\n        else\n        (\n\tnew k: key;\n        out(c, (C1, encrypt((Na1, k), kA1), \n                    encrypt((Nb1, k), kB1)))\n        ).\n\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT Non-interference secretkey is true.\n0.045s (user 0.041s + system 0.004s), max rss 11256K\nEND *)"
    },
    {
        "file": "PV-1/pidenning-sacco3.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Denning-Sacco *)\n\nfree ____(FREE_0)____.\n\n(* Probabilistic public key cryptography *)\n\nfun pk/____(FUN_0)____.\nfun encrypt/3.\nreduc decrypt(encrypt(x,pk(y),r),y) = x.\n\n(* Signatures *)\n\nfun sign/2.\nreduc getmess(sign(m,k)) = m.\nreduc checksign(sign(____(REDUC_0)____,k), pk(k)) = m.\n\n(* Probabilistic Shared-key cryptography *)\n\nfun sencrypt/3.\nreduc sdecrypt(sencrypt(x,y,r),y) = x.\n\n(* Secrecy assumptions *)\n\nnot ____(OP_4)____.\nnot skB.\n\nprivate free secretA, secretB.\nnoninterf secretA, secretB.\n\nlet processA =\n\tin(c, ____(OP_1)____);\n\tnew k; new ____(NEW_0)____;\n\tout(c, (encrypt(sign((pkA, pk2, k), skA), pk2, r)));\n\tif pk2 = ____(IF_0)____ then\n\t(\n\tin(c, ____(OP_0)____);\n        let s = sdecrypt(____(LET_0)____,k) in 0\n\t)\n\t|\n \tnew r;\n\tout(c, sencrypt(secretA, k, r)).\n\nlet ____(LET_2)____ =\n\tin(c, km);\n\tlet ks = decrypt(____(OP_5)____,skB) in\n\tlet (=pkA, =pkB, k) = checksign(ks, pkA) in\n\t(\n\tin(c, m);\n        let s = sdecrypt(m,k) in 0\n\t)\n\t|\n\tnew r;\n\tout(c, sencrypt(____(OP_3)____, k, r)).\n\nprocess new skA; \n\tlet pkA = pk(skA) in\n        out(____(OP_2)____, pkA);\n        new skB; \n\tlet pkB = pk(____(LET_1)____) in\n        out(____(OP_6)____, pkB);\n\t((!processA) | (!processB))\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB is true.\n0.016s (user 0.012s + system 0.004s), max rss 8668K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Denning-Sacco *)\n\nfree c.\n\n(* Probabilistic public key cryptography *)\n\nfun pk/1.\nfun encrypt/3.\nreduc decrypt(encrypt(x,pk(y),r),y) = x.\n\n(* Signatures *)\n\nfun sign/2.\nreduc getmess(sign(m,k)) = m.\nreduc checksign(sign(m,k), pk(k)) = m.\n\n(* Probabilistic Shared-key cryptography *)\n\nfun sencrypt/3.\nreduc sdecrypt(sencrypt(x,y,r),y) = x.\n\n(* Secrecy assumptions *)\n\nnot skA.\nnot skB.\n\nprivate free secretA, secretB.\nnoninterf secretA, secretB.\n\nlet processA =\n\tin(c, pk2);\n\tnew k; new r;\n\tout(c, (encrypt(sign((pkA, pk2, k), skA), pk2, r)));\n\tif pk2 = pkB then\n\t(\n\tin(c, m);\n        let s = sdecrypt(m,k) in 0\n\t)\n\t|\n \tnew r;\n\tout(c, sencrypt(secretA, k, r)).\n\nlet processB =\n\tin(c, km);\n\tlet ks = decrypt(km,skB) in\n\tlet (=pkA, =pkB, k) = checksign(ks, pkA) in\n\t(\n\tin(c, m);\n        let s = sdecrypt(m,k) in 0\n\t)\n\t|\n\tnew r;\n\tout(c, sencrypt(secretB, k, r)).\n\nprocess new skA; \n\tlet pkA = pk(skA) in\n        out(c, pkA);\n        new skB; \n\tlet pkB = pk(skB) in\n        out(c, pkB);\n\t((!processA) | (!processB))\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB is true.\n0.016s (user 0.012s + system 0.004s), max rss 8668K\nEND *)"
    },
    {
        "file": "PV-1/pineedham-shr-orig4.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Needham-Schroeder shared key *)\n\nfree ____(FREE_0)____.\n\n(* Shared-key cryptography *)\n\nfun encrypt/____(FUN_0)____.\nreduc decrypt(encrypt(____(REDUC_0)____,k),k) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(____(OP_9)____)) = x.\n\n(* constants 0 and 1 *)\n\ndata c0/0.\ndata c1/0.\n\n(* Secrecy assumptions *)\n\nnot Kas.\nnot ____(OP_2)____.\n\nquery attacker:secretA[];\n      attacker:secretB[].\nquery evinj:endAparam(____(OP_1)____,____(QUERY_0)____) ==> evinj:beginAparam(____(QUERY_1)____,____(OP_5)____).\nquery evinj:endAkey(x,____(OP_0)____,z) ==> evinj:beginAkey(x,____(OP_6)____,z).\nquery evinj:endBparam(____(OP_16)____,y) ==> evinj:beginBparam(x,y).\nquery evinj:endBkey(x,y,____(OP_8)____) ==> evinj:beginBkey(x,y,z).\n\n\nlet processA =\n\tnew secretA;\n\tin(c, ____(OP_18)____);\n\tevent beginBparam(A,h);\n\tnew ____(NEW_0)____;\n\tout(c,(A, h, Na));\n\tin(c,m2);\n\tlet (=Na, =h, k, m) = decrypt(m2, Kas) in\n\tevent beginBkey(A, ____(OP_17)____, k);\n\tout(c,m);\n\tin(____(OP_14)____, m3);\n\tlet (=c0, n) = decrypt(m3, k) in\n\tout(c, encrypt((c1, n), k));\n\tif h = ____(IF_0)____ then\n\tevent endAparam(A, h);\n\tevent endAkey(A, h, k);\n\tout(c, encrypt(secretA, k)).\n\nlet processB =\n\tnew secretB;\n\tin(____(OP_10)____,m4);\n\tlet (k,h) = decrypt(____(OP_13)____,Kbs) in\n\tevent beginAparam(____(OP_7)____, B);\n\tevent beginAkey(h, B, ____(OP_15)____);\n\tnew Nb;\n\tout(c, encrypt((c0, ____(OP_3)____), k));\n\tin(c,m5);\n\tlet (=c1, =Nb) = decrypt(____(OP_11)____,k) in\n\tif h = A then\n\tevent endBparam(h, B);\n\tevent endBkey(h, B, k);\n\tout(c, encrypt(secretB, k)).\n\nlet ____(LET_0)____ =\n\tin(c, (____(OP_4)____,h2,n));\n\tlet ks1 = getkey(____(LET_2)____) in\n\tlet ____(LET_1)____ = getkey(h2) in\n\tnew k;\n\tout(c, encrypt((n, h2, k, encrypt((k,h1),____(OP_12)____)), ks1)).\n\nprocess\n\tnew Kas;\n\tnew ____(NEW_1)____;\n\tlet A = host(Kas) in\n\tlet B = host(Kbs) in\n\tout(c, A);\n\tout(c, B);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT not attacker:secretA[!1 = v] is true.\nRESULT not attacker:secretB[!1 = v] is true.\nRESULT evinj:endAparam(x,y) ==> evinj:beginAparam(x,y) is true.\nRESULT evinj:endAkey(x,y,z) ==> evinj:beginAkey(x,y,z) is true.\nRESULT evinj:endBparam(x,y) ==> evinj:beginBparam(x,y) is true.\nRESULT evinj:endBkey(x,y,z) ==> evinj:beginBkey(x,y,z) is true.\n0.036s (user 0.036s + system 0.000s), max rss 10324K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Needham-Schroeder shared key *)\n\nfree c.\n\n(* Shared-key cryptography *)\n\nfun encrypt/2.\nreduc decrypt(encrypt(m,k),k) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\n(* constants 0 and 1 *)\n\ndata c0/0.\ndata c1/0.\n\n(* Secrecy assumptions *)\n\nnot Kas.\nnot Kbs.\n\nquery attacker:secretA[];\n      attacker:secretB[].\nquery evinj:endAparam(x,y) ==> evinj:beginAparam(x,y).\nquery evinj:endAkey(x,y,z) ==> evinj:beginAkey(x,y,z).\nquery evinj:endBparam(x,y) ==> evinj:beginBparam(x,y).\nquery evinj:endBkey(x,y,z) ==> evinj:beginBkey(x,y,z).\n\n\nlet processA =\n\tnew secretA;\n\tin(c, h);\n\tevent beginBparam(A,h);\n\tnew Na;\n\tout(c,(A, h, Na));\n\tin(c,m2);\n\tlet (=Na, =h, k, m) = decrypt(m2, Kas) in\n\tevent beginBkey(A, h, k);\n\tout(c,m);\n\tin(c, m3);\n\tlet (=c0, n) = decrypt(m3, k) in\n\tout(c, encrypt((c1, n), k));\n\tif h = B then\n\tevent endAparam(A, h);\n\tevent endAkey(A, h, k);\n\tout(c, encrypt(secretA, k)).\n\nlet processB =\n\tnew secretB;\n\tin(c,m4);\n\tlet (k,h) = decrypt(m4,Kbs) in\n\tevent beginAparam(h, B);\n\tevent beginAkey(h, B, k);\n\tnew Nb;\n\tout(c, encrypt((c0, Nb), k));\n\tin(c,m5);\n\tlet (=c1, =Nb) = decrypt(m5,k) in\n\tif h = A then\n\tevent endBparam(h, B);\n\tevent endBkey(h, B, k);\n\tout(c, encrypt(secretB, k)).\n\nlet processS =\n\tin(c, (h1,h2,n));\n\tlet ks1 = getkey(h1) in\n\tlet ks2 = getkey(h2) in\n\tnew k;\n\tout(c, encrypt((n, h2, k, encrypt((k,h1),ks2)), ks1)).\n\nprocess\n\tnew Kas;\n\tnew Kbs;\n\tlet A = host(Kas) in\n\tlet B = host(Kbs) in\n\tout(c, A);\n\tout(c, B);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT not attacker:secretA[!1 = v] is true.\nRESULT not attacker:secretB[!1 = v] is true.\nRESULT evinj:endAparam(x,y) ==> evinj:beginAparam(x,y) is true.\nRESULT evinj:endAkey(x,y,z) ==> evinj:beginAkey(x,y,z) is true.\nRESULT evinj:endBparam(x,y) ==> evinj:beginBparam(x,y) is true.\nRESULT evinj:endBkey(x,y,z) ==> evinj:beginBkey(x,y,z) is true.\n0.036s (user 0.036s + system 0.000s), max rss 10324K\nEND *)"
    },
    {
        "file": "PV-1/piotwayrees-key.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Otway Rees protocol.\n   Version of Otway Rees, Operating Systems Review Vol 21 no 1, p 8-10, 1987 \n\nA -> B: (C, A, B, { Na, C, A, B }_kA)\nB -> S: (C, A, B, { Na, C, A, B }_kA, { Nb, C, A, B }_kB)\nS -> B: (C, { Na, k }_kA, { Nb, k }_kB)\nB -> A: (C, { Na, k }_kA)\n\nCorrect\n*)\n\n(* Shared-key cryptography *)\n\nfun encrypt/____(FUN_0)____.\nreduc decrypt(encrypt(____(REDUC_0)____,k),k) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\nfree ____(FREE_0)____.\n\nprivate free secretkey.\nnoninterf secretkey.\n\nlet processA = in(c, hostB0);\n\t       new C; new Na;\n               out(c, (C, hostA, hostB0, encrypt((Na, C, hostA, hostB0), kA)));\n\t       in(c, (=____(OP_2)____, m2));\n\tlet (=____(LET_2)____, k) = decrypt(____(LET_1)____, kA) in 0.\n\n\nlet ____(LET_3)____ = \n\tin(____(OP_8)____, (C1, hostA1, =hostB, ____(OP_7)____));\n\tnew ____(NEW_0)____;\n\tout(c, (C1, hostA1, hostB, m2, encrypt((Nb, C1, hostA1, hostB), kB)));\n\tin(c, (=C1, m3, m4));\n\tlet (=Nb, k) = decrypt(____(OP_5)____, kB) in\n\tout(c, (C1, m3)).\n\n\nlet processS = in(c, (C1, hostA1, hostB1, m2, m3));\n\t       let (Na1, =C1, =hostA1, =hostB1) = decrypt(m2, getkey(hostA1)) in\n\t       let (Nb1, =C1, =hostA1, =hostB1) = decrypt(____(OP_6)____, getkey(hostB1)) in\n\t       if (hostA1,____(IF_0)____) = (hostA,hostB) then\n\t\t(let k2 = secretkey in\n                out(c, (C1, encrypt((____(OP_1)____, k2), getkey(hostA1)), \n                            encrypt((Nb1, ____(OP_3)____), getkey(hostB1)))))\n               else\n\t\tnew k;\n                out(c, (C1, encrypt((Na1, k), getkey(hostA1)), \n                            encrypt((Nb1, k), getkey(hostB1)))).\n\nprocess new kA; new kB;\n\tlet ____(LET_0)____ = host(kA) in \n\tlet hostB = host(kB) in\n\tout(____(OP_0)____, hostA); out(____(OP_4)____, hostB);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT Non-interference secretkey is true.\n0.048s (user 0.048s + system 0.000s), max rss 9640K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Otway Rees protocol.\n   Version of Otway Rees, Operating Systems Review Vol 21 no 1, p 8-10, 1987 \n\nA -> B: (C, A, B, { Na, C, A, B }_kA)\nB -> S: (C, A, B, { Na, C, A, B }_kA, { Nb, C, A, B }_kB)\nS -> B: (C, { Na, k }_kA, { Nb, k }_kB)\nB -> A: (C, { Na, k }_kA)\n\nCorrect\n*)\n\n(* Shared-key cryptography *)\n\nfun encrypt/2.\nreduc decrypt(encrypt(m,k),k) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\nfree c.\n\nprivate free secretkey.\nnoninterf secretkey.\n\nlet processA = in(c, hostB0);\n\t       new C; new Na;\n               out(c, (C, hostA, hostB0, encrypt((Na, C, hostA, hostB0), kA)));\n\t       in(c, (=C, m2));\n\tlet (=Na, k) = decrypt(m2, kA) in 0.\n\n\nlet processB = \n\tin(c, (C1, hostA1, =hostB, m2));\n\tnew Nb;\n\tout(c, (C1, hostA1, hostB, m2, encrypt((Nb, C1, hostA1, hostB), kB)));\n\tin(c, (=C1, m3, m4));\n\tlet (=Nb, k) = decrypt(m4, kB) in\n\tout(c, (C1, m3)).\n\n\nlet processS = in(c, (C1, hostA1, hostB1, m2, m3));\n\t       let (Na1, =C1, =hostA1, =hostB1) = decrypt(m2, getkey(hostA1)) in\n\t       let (Nb1, =C1, =hostA1, =hostB1) = decrypt(m3, getkey(hostB1)) in\n\t       if (hostA1,hostB1) = (hostA,hostB) then\n\t\t(let k2 = secretkey in\n                out(c, (C1, encrypt((Na1, k2), getkey(hostA1)), \n                            encrypt((Nb1, k2), getkey(hostB1)))))\n               else\n\t\tnew k;\n                out(c, (C1, encrypt((Na1, k), getkey(hostA1)), \n                            encrypt((Nb1, k), getkey(hostB1)))).\n\nprocess new kA; new kB;\n\tlet hostA = host(kA) in \n\tlet hostB = host(kB) in\n\tout(c, hostA); out(c, hostB);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT Non-interference secretkey is true.\n0.048s (user 0.048s + system 0.000s), max rss 9640K\nEND *)"
    },
    {
        "file": "PV-1/piterm.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Handshake protocol.\n   Simplified from Delaune, Jacquemard, LSV-04-1 \n\nTermination problem:\n\nRule 12: attacker_guess:encrypt(x_42,y_43),v_44 & attacker_guess:y_43,v_45 -> attacker_guess:x_42,decrypt(v_44,v_45)\n\nv_93 <> encrypt(v_90,v_92) & attacker_guess:v_89,v_90 & attacker_guess:v_91,v_92 & attacker_guess:encrypt(v_89,v_91),v_93 -> bad:\n\nv_167 <> encrypt(encrypt(v_163,v_165),v_168) & attacker_guess:v_162,v_163 & attacker_guess:v_164,v_165 & attacker_guess:encrypt(encrypt(v_162,v_164),y_166),v_167 & attacker_guess:y_166,v_168 -> bad:\n\netc leads to a loop...\n\nOr with another selection function\n\nattacker_guess:x_115,v_116 & attacker_guess:y_117,v_118 & attacker_guess:y_117,v_119 -> attacker_guess:x_115,decrypt(encrypt(v_116,v_118),v_119)\na\n\nleads to a similar loop...\n\n*)\n\n(* shared-key encryption as equation *)\n\nfun encrypt/2.\nfun ____(FUN_0)____/2.\nequation decrypt(encrypt(____(EQUATION_0)____,____(OP_2)____),y) = x.\n\nfree ____(FREE_0)____.\nprivate free pw.\nweaksecret pw.\n\nprocess\n\tnew pw;\n\tnew ____(NEW_0)____;\n\tout(c, encrypt(N, pw))\n\n(* EXPECTPV\nRESULT Weak secret pw_1 is true.\n0.004s (user 0.004s + system 0.000s), max rss 7776K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Handshake protocol.\n   Simplified from Delaune, Jacquemard, LSV-04-1 \n\nTermination problem:\n\nRule 12: attacker_guess:encrypt(x_42,y_43),v_44 & attacker_guess:y_43,v_45 -> attacker_guess:x_42,decrypt(v_44,v_45)\n\nv_93 <> encrypt(v_90,v_92) & attacker_guess:v_89,v_90 & attacker_guess:v_91,v_92 & attacker_guess:encrypt(v_89,v_91),v_93 -> bad:\n\nv_167 <> encrypt(encrypt(v_163,v_165),v_168) & attacker_guess:v_162,v_163 & attacker_guess:v_164,v_165 & attacker_guess:encrypt(encrypt(v_162,v_164),y_166),v_167 & attacker_guess:y_166,v_168 -> bad:\n\netc leads to a loop...\n\nOr with another selection function\n\nattacker_guess:x_115,v_116 & attacker_guess:y_117,v_118 & attacker_guess:y_117,v_119 -> attacker_guess:x_115,decrypt(encrypt(v_116,v_118),v_119)\na\n\nleads to a similar loop...\n\n*)\n\n(* shared-key encryption as equation *)\n\nfun encrypt/2.\nfun decrypt/2.\nequation decrypt(encrypt(x,y),y) = x.\n\nfree c.\nprivate free pw.\nweaksecret pw.\n\nprocess\n\tnew pw;\n\tnew N;\n\tout(c, encrypt(N, pw))\n\n(* EXPECTPV\nRESULT Weak secret pw_1 is true.\n0.004s (user 0.004s + system 0.000s), max rss 7776K\nEND *)"
    },
    {
        "file": "PV-1/piwoolampk.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfree ____(FREE_0)____.\n(*\n\nWoo and Lam public-key auth protocol (1997)\n\nA -> B: A\nB -> A: N\nA -> B: { A, B, N }_skA\nB -> S: A\nS -> B: A, { A, pkA }_skS\n\nCorrect\n\n*)\n\n(* Signatures *)\n\nfun pk/1.\nfun ____(FUN_0)____/2.\nreduc getmess(sign(m,k)) = m.\nreduc checksign(sign(m,____(REDUC_0)____), pk(k)) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(____(OP_3)____)) = ____(OP_8)____.\n\n(* Secrecy assumptions *)\n\nnot skA.\nnot ____(OP_11)____.\nnot skS.\n\nquery evinj:endBparam(x) ==> evinj:beginBparam(x).\nquery evinj:endBfull(____(OP_2)____,y,____(QUERY_0)____) ==> evinj:beginBfull(____(OP_7)____,y,____(QUERY_1)____).\n\nlet processA = in(c, hostB0); (* Choose B *)\n               event beginBparam(hostB0);\n               out(c, hostA);\n               in(c,____(OP_13)____);\n\t       event beginBfull(____(OP_14)____, n, hostB0);\n\t       out(c,sign((hostA, hostB0, n),skA)).\n\nlet processB = in(c, ____(OP_5)____);\n               new ____(NEW_0)____; out(c,n);\n               in(____(OP_10)____,m); \n               out(c, hostA0);\n               in(c, (=hostA0, m4)); \n                  let (=____(LET_1)____, pkA2) = checksign(____(OP_6)____, pkS) in\n                     let (=hostA0, =____(OP_12)____, =n) = checksign(m,____(OP_0)____) in\n\t\t\t(* OK *)\n                        if hostA0 = ____(IF_0)____ then\n\t\t\t  event endBparam(hostB);\n\t\t\t  event endBfull(hostA0, n, ____(OP_1)____).\n\nlet processS = in(c, hostA);\n\t       out(c, (hostA, sign((hostA, getkey(hostA)), skS))).\n\nprocess new skA; new skB; new skS;\n        let pkA = pk(skA) in\n        let pkB = pk(skB) in\n        let pkS = pk(skS) in\n\tlet hostA = host(pkA) in\n\tlet hostB = host(____(LET_0)____) in\n\tout(c, ____(OP_9)____); out(c, pkB); out(c, pkS);\n\tout(c, hostA); out(c, hostB);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is true.\nRESULT evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z) is true.\n0.012s (user 0.004s + system 0.008s), max rss 8628K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfree c.\n(*\n\nWoo and Lam public-key auth protocol (1997)\n\nA -> B: A\nB -> A: N\nA -> B: { A, B, N }_skA\nB -> S: A\nS -> B: A, { A, pkA }_skS\n\nCorrect\n\n*)\n\n(* Signatures *)\n\nfun pk/1.\nfun sign/2.\nreduc getmess(sign(m,k)) = m.\nreduc checksign(sign(m,k), pk(k)) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\n(* Secrecy assumptions *)\n\nnot skA.\nnot skB.\nnot skS.\n\nquery evinj:endBparam(x) ==> evinj:beginBparam(x).\nquery evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z).\n\nlet processA = in(c, hostB0); (* Choose B *)\n               event beginBparam(hostB0);\n               out(c, hostA);\n               in(c,n);\n\t       event beginBfull(hostA, n, hostB0);\n\t       out(c,sign((hostA, hostB0, n),skA)).\n\nlet processB = in(c, hostA0);\n               new n; out(c,n);\n               in(c,m); \n               out(c, hostA0);\n               in(c, (=hostA0, m4)); \n                  let (=hostA0, pkA2) = checksign(m4, pkS) in\n                     let (=hostA0, =hostB, =n) = checksign(m,pkA2) in\n\t\t\t(* OK *)\n                        if hostA0 = hostA then\n\t\t\t  event endBparam(hostB);\n\t\t\t  event endBfull(hostA0, n, hostB).\n\nlet processS = in(c, hostA);\n\t       out(c, (hostA, sign((hostA, getkey(hostA)), skS))).\n\nprocess new skA; new skB; new skS;\n        let pkA = pk(skA) in\n        let pkB = pk(skB) in\n        let pkS = pk(skS) in\n\tlet hostA = host(pkA) in\n\tlet hostB = host(pkB) in\n\tout(c, pkA); out(c, pkB); out(c, pkS);\n\tout(c, hostA); out(c, hostB);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is true.\nRESULT evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z) is true.\n0.012s (user 0.004s + system 0.008s), max rss 8628K\nEND *)"
    },
    {
        "file": "PV-1/piyahalom.pi",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfree ____(FREE_0)____.\n(* \n\nA -> B : A, N_A\nB -> S : B, N_B, { A, N_A }_Kbs\nS -> A : N_B, { B, K_ab, N_A }_Kas, { A, K_ab, N_B }_Kbs\nA -> B : { A, K_ab, N_B }_Kbs, { N_B }_Kab\n\nNo agreement on N_A, but agreement on N_B and on the session key K_ab.\n\n*)\n\n(* Table of host names/keys shared with the server \n   The constructor host maps keys to host names.\n   The private destructor getkey maps host names to keys. *)\n\nfun host/1.\nprivate reduc getkey(host(____(OP_2)____)) = ____(OP_4)____.\n\n(* Shared key cryptography *)\n\nfun ____(FUN_0)____/2.\nreduc decrypt(encrypt(____(OP_11)____,____(REDUC_0)____),y) = ____(OP_15)____.\n\n(* Secrecy assumptions *)\n\nnot kas.\nnot ____(OP_0)____.\n\nprivate free secretA, secretB.\nquery attacker:secretA;\n      attacker:secretB.\nquery ____(QUERY_0)____:endAparam(____(QUERY_1)____) ==> evinj:beginAparam(x).\nquery evinj:endBparam(x) ==> evinj:beginBparam(x).\nquery evinj:endBkey(x,____(OP_1)____,z,t) ==> evinj:beginBkey(____(OP_12)____,y,z,t).\n\nlet processA = \n\tnew Na; \n\tout(c, (host(kas), Na)); \n\tin(c, (nb, m1, m2));\n        let (____(OP_3)____, kab, na2) = decrypt(m1, ____(OP_8)____) in\n\tevent beginBparam(b);\n        if na2 = ____(IF_0)____ then \n \tevent beginBkey(b, host(kas), nb, kab);\n        out(____(OP_14)____, (m2, encrypt(nb, kab)));\n\t(* OK *) \n        if b = host(kbs) then\n\tevent endAparam(host(kas));\n\tout(c, encrypt(secretA, kab)).\n                         \nlet processB = \n\tin(c, (____(OP_7)____, na)); \n\tevent beginAparam(a);\n\tnew ____(NEW_0)____; \n\tout(c, (host(kbs), Nb, encrypt((____(OP_5)____,na), kbs)));\n\tin(c, (m3, m4));\n        let (=a, kab, =Nb) = decrypt(m3, kbs) in\n        if Nb = decrypt(m4, kab) then\n\t(* OK *)\n        if a = host(kas) then\n\tevent endBparam(host(kbs));\n\tevent endBkey(host(kbs), a, Nb, kab);\n\tout(c, encrypt(secretB, kab)).\n\nlet ____(LET_1)____ = \n\tin(c, (b, nb, ____(OP_9)____));\n\tlet kbs2 = getkey(b) in\n        let (a, na) = decrypt(____(LET_0)____,kbs2) in\n        let kas2 = getkey(a) in\n        new kab;\n\tout(c, (nb, encrypt((b, ____(OP_6)____, na), kas2), encrypt((a, kab, nb), kbs2))).\n\n\nprocess new kas; new kbs; \n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT not attacker:secretA[] is true.\nRESULT not attacker:secretB[] is true.\nRESULT evinj:endAparam(x) ==> evinj:beginAparam(x) is true.\nRESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is true.\nRESULT evinj:endBkey(x,y,z,t) ==> evinj:beginBkey(x,y,z,t) is true.\n0.040s (user 0.028s + system 0.012s), max rss 9552K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfree c.\n(* \n\nA -> B : A, N_A\nB -> S : B, N_B, { A, N_A }_Kbs\nS -> A : N_B, { B, K_ab, N_A }_Kas, { A, K_ab, N_B }_Kbs\nA -> B : { A, K_ab, N_B }_Kbs, { N_B }_Kab\n\nNo agreement on N_A, but agreement on N_B and on the session key K_ab.\n\n*)\n\n(* Table of host names/keys shared with the server \n   The constructor host maps keys to host names.\n   The private destructor getkey maps host names to keys. *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\n(* Shared key cryptography *)\n\nfun encrypt/2.\nreduc decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot kas.\nnot kbs.\n\nprivate free secretA, secretB.\nquery attacker:secretA;\n      attacker:secretB.\nquery evinj:endAparam(x) ==> evinj:beginAparam(x).\nquery evinj:endBparam(x) ==> evinj:beginBparam(x).\nquery evinj:endBkey(x,y,z,t) ==> evinj:beginBkey(x,y,z,t).\n\nlet processA = \n\tnew Na; \n\tout(c, (host(kas), Na)); \n\tin(c, (nb, m1, m2));\n        let (b, kab, na2) = decrypt(m1, kas) in\n\tevent beginBparam(b);\n        if na2 = Na then \n \tevent beginBkey(b, host(kas), nb, kab);\n        out(c, (m2, encrypt(nb, kab)));\n\t(* OK *) \n        if b = host(kbs) then\n\tevent endAparam(host(kas));\n\tout(c, encrypt(secretA, kab)).\n                         \nlet processB = \n\tin(c, (a, na)); \n\tevent beginAparam(a);\n\tnew Nb; \n\tout(c, (host(kbs), Nb, encrypt((a,na), kbs)));\n\tin(c, (m3, m4));\n        let (=a, kab, =Nb) = decrypt(m3, kbs) in\n        if Nb = decrypt(m4, kab) then\n\t(* OK *)\n        if a = host(kas) then\n\tevent endBparam(host(kbs));\n\tevent endBkey(host(kbs), a, Nb, kab);\n\tout(c, encrypt(secretB, kab)).\n\nlet processS = \n\tin(c, (b, nb, m5));\n\tlet kbs2 = getkey(b) in\n        let (a, na) = decrypt(m5,kbs2) in\n        let kas2 = getkey(a) in\n        new kab;\n\tout(c, (nb, encrypt((b, kab, na), kas2), encrypt((a, kab, nb), kbs2))).\n\n\nprocess new kas; new kbs; \n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT not attacker:secretA[] is true.\nRESULT not attacker:secretB[] is true.\nRESULT evinj:endAparam(x) ==> evinj:beginAparam(x) is true.\nRESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is true.\nRESULT evinj:endBkey(x,y,z,t) ==> evinj:beginBkey(x,y,z,t) is true.\n0.040s (user 0.028s + system 0.012s), max rss 9552K\nEND *)"
    },
    {
        "file": "PV-1/pptm.pv",
        "incomplete": "(*Dolev-Yao model Open Channel*)\n(*Channel between UAV A and UAV B*)\nfree ____(FREE_0)____:channel.\n\n\n(* RSA modulus *)\ntype N.\n\n(* The attacker should not have knowledge of the actual identifier of the capsule mapped from  f (see paper Sec.4.3 step (4)) (secret).\nAlthough, we define the secret as \"weak\" to check if offline brute-force or dictionary attacks are feasible. *)\n\nfree dA_i: ____(OP_11)____ [private].\nweaksecret dA_i.\nfree ____(OP_10)____: bitstring [private].\nweaksecret dB_i_k.\n\n\n(* Types, Constants and Variables *)\ntype radius.\ntype length.\ntype ____(TYPE_2)____.\ntype ____(TYPE_0)____.\ntype nonce.\ntype ____(OP_1)____.\ntype ____(TYPE_1)____.\n\n\n\n\n(* A formal query, specifying the attacker can't ever be leaked the\nactual capsule identifiers during the protocol. *)\nquery attacker(dA_i).\nquery attacker(____(QUERY_0)____).\n\n(*Verify the non interference property for the capsule identifiers A and B, which means that \nthe different secrets are indistingishuable for the adversary strong secrecy.*)\nnoninterf dB_i_k.\nnoninterf dA_i.\n\n(*Auxiliary Functions*)\nfun hash(bitstring):bitstring.\nfun map(bitstring):bitstring.(*secure function of 2H(x)+1*)\nfun append(____(FUN_1)____,____(OP_14)____):bitstring.\nfun mod(bitstring,N):bitstring.\nfun exp_mod(bitstring,bitstring,N):bitstring.\nfun inv_mod(bitstring,____(FUN_2)____):bitstring.\nfun extract_elem(vector,index):bitstring.\nfun add_elem(vector,bitstring,index):vector.\nfun map_trajectory(origin,____(OP_2)____,radius,length):vector.\n(* Type converter *)\nfun nonce_to_bitstring(nonce): ____(FUN_3)____ [data,typeConverter].\n(*Events*)\nevent end_UAV_A(vector).\nevent end_UAV_B(bitstring).\n\n\n\n(* The process for UAV A*)\nlet uavA(____(OP_3)____:N) =\n    (* Step (3) of Sec.4.3 in our paper*)\n    new ____(NEW_1)____:origin;\n    new T_i:angle;\n    new r_i:radius;\n    new h_i:length;\n    new xi_i:nonce;\n\n    (* Step (6) of Sec.4.3, Eq.9*)\n    let cA_i = exp_mod(nonce_to_bitstring(xi_i), dA_i, ____(OP_12)____) in\n    (* Step (7) of Sec.4.3*)\n    out (c,(cA_i,____(OP_13)____,T_i,r_i,h_i));\n    (* Step (11) of Sec.4.3*)\n    in (c, cB_i:vector);\n    new k:____(NEW_0)____;\n    let cB_i_k = extract_elem(cB_i,____(OP_9)____) in\n    (* Step (12) of Sec.4.3, Eq. 12*)\n    let wA_i_k = hash(mod(nonce_to_bitstring(xi_i),nB)) in \n    (* Step (15) of Sec.4.3*)\n    if wA_i_k = ____(IF_0)____ then ( \n        (* Step (13) of Sec.4.3, Eq. 14*)\n        let ____(OP_0)____ = hash(mod(append(nonce_to_bitstring(xi_i),dA_i),nB)) in\n        (* Step (16) of Sec.4.3 ==> paper*)\n        out(____(OP_8)____,wA_i);\n    \n        event end_UAV_A(cB_i)).\n\n\n\n\n\n\n\n\n(* The process for UAV B*)\nlet uavB(nB:N) =\n    (* Step (8) of Sec.4.3*)\n    in(____(OP_6)____, (____(OP_7)____:____(OP_5)____,O_i:____(OP_4)____,T_i:angle,r_i:radius,h_i:length));\n    let GB_i = map_trajectory(____(LET_1)____,____(LET_2)____,r_i,h_i) in\n    new k:index;\n    (* Step (9) of Sec.4.3*)\n    let eB_i_k = inv_mod(dB_i_k,nB) in\n    (* Step (10) of Sec.4.3, Eq. 10*)\n    let x_i_k = exp_mod(cA_i,eB_i_k,nB) in\n    (* Step (10) of Sec.4.3, Eq. 11*)\n    let cB_i_k = hash(x_i_k) in\n    new ____(NEW_2)____:vector;\n    let cB_i = add_elem(cB_i,____(LET_0)____,k) in\n    (* Step (11) of Sec.4.3*)\n    out (c, cB_i);\n    (* Step (16) of Sec.4.3*)\n    in (c, wA_i:bitstring);\n    (* Step (17) of Sec.4.3, Eq. 15*)\n    if wA_i = hash(mod(append(x_i_k,dB_i_k),nB)) then (\n        event end_UAV_B(wA_i)).\n\nprocess\n    new nB: N;\n    ((!uavA(nB)) | (!uavB(nB)))",
        "complete:": "(*Dolev-Yao model Open Channel*)\n(*Channel between UAV A and UAV B*)\nfree c:channel.\n\n\n(* RSA modulus *)\ntype N.\n\n(* The attacker should not have knowledge of the actual identifier of the capsule mapped from  f (see paper Sec.4.3 step (4)) (secret).\nAlthough, we define the secret as \"weak\" to check if offline brute-force or dictionary attacks are feasible. *)\n\nfree dA_i: bitstring [private].\nweaksecret dA_i.\nfree dB_i_k: bitstring [private].\nweaksecret dB_i_k.\n\n\n(* Types, Constants and Variables *)\ntype radius.\ntype length.\ntype angle.\ntype origin.\ntype nonce.\ntype vector.\ntype index.\n\n\n\n\n(* A formal query, specifying the attacker can't ever be leaked the\nactual capsule identifiers during the protocol. *)\nquery attacker(dA_i).\nquery attacker(dB_i_k).\n\n(*Verify the non interference property for the capsule identifiers A and B, which means that \nthe different secrets are indistingishuable for the adversary strong secrecy.*)\nnoninterf dB_i_k.\nnoninterf dA_i.\n\n(*Auxiliary Functions*)\nfun hash(bitstring):bitstring.\nfun map(bitstring):bitstring.(*secure function of 2H(x)+1*)\nfun append(bitstring,bitstring):bitstring.\nfun mod(bitstring,N):bitstring.\nfun exp_mod(bitstring,bitstring,N):bitstring.\nfun inv_mod(bitstring,N):bitstring.\nfun extract_elem(vector,index):bitstring.\nfun add_elem(vector,bitstring,index):vector.\nfun map_trajectory(origin,angle,radius,length):vector.\n(* Type converter *)\nfun nonce_to_bitstring(nonce): bitstring [data,typeConverter].\n(*Events*)\nevent end_UAV_A(vector).\nevent end_UAV_B(bitstring).\n\n\n\n(* The process for UAV A*)\nlet uavA(nB:N) =\n    (* Step (3) of Sec.4.3 in our paper*)\n    new O_i:origin;\n    new T_i:angle;\n    new r_i:radius;\n    new h_i:length;\n    new xi_i:nonce;\n\n    (* Step (6) of Sec.4.3, Eq.9*)\n    let cA_i = exp_mod(nonce_to_bitstring(xi_i), dA_i, nB) in\n    (* Step (7) of Sec.4.3*)\n    out (c,(cA_i,O_i,T_i,r_i,h_i));\n    (* Step (11) of Sec.4.3*)\n    in (c, cB_i:vector);\n    new k:index;\n    let cB_i_k = extract_elem(cB_i,k) in\n    (* Step (12) of Sec.4.3, Eq. 12*)\n    let wA_i_k = hash(mod(nonce_to_bitstring(xi_i),nB)) in \n    (* Step (15) of Sec.4.3*)\n    if wA_i_k = cB_i_k then ( \n        (* Step (13) of Sec.4.3, Eq. 14*)\n        let wA_i = hash(mod(append(nonce_to_bitstring(xi_i),dA_i),nB)) in\n        (* Step (16) of Sec.4.3 ==> paper*)\n        out(c,wA_i);\n    \n        event end_UAV_A(cB_i)).\n\n\n\n\n\n\n\n\n(* The process for UAV B*)\nlet uavB(nB:N) =\n    (* Step (8) of Sec.4.3*)\n    in(c, (cA_i:bitstring,O_i:origin,T_i:angle,r_i:radius,h_i:length));\n    let GB_i = map_trajectory(O_i,T_i,r_i,h_i) in\n    new k:index;\n    (* Step (9) of Sec.4.3*)\n    let eB_i_k = inv_mod(dB_i_k,nB) in\n    (* Step (10) of Sec.4.3, Eq. 10*)\n    let x_i_k = exp_mod(cA_i,eB_i_k,nB) in\n    (* Step (10) of Sec.4.3, Eq. 11*)\n    let cB_i_k = hash(x_i_k) in\n    new cB_i:vector;\n    let cB_i = add_elem(cB_i,cB_i_k,k) in\n    (* Step (11) of Sec.4.3*)\n    out (c, cB_i);\n    (* Step (16) of Sec.4.3*)\n    in (c, wA_i:bitstring);\n    (* Step (17) of Sec.4.3, Eq. 15*)\n    if wA_i = hash(mod(append(x_i_k,dB_i_k),nB)) then (\n        event end_UAV_B(wA_i)).\n\nprocess\n    new nB: N;\n    ((!uavA(nB)) | (!uavB(nB)))"
    },
    {
        "file": "PV-1/private_authentication_bounded_processes.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Private Authentication\n   Taken from Delaune, Jacquemard, CSFW'04 *)\n\n(*set simplifyProcess = interactive.*)\n\n(* shared-key encryption as equation *)\n\nfun aenc(bitstring, bitstring): bitstring.\nfun pk(____(FUN_0)____): bitstring.\n\nreduc forall ____(REDUC_1)____: bitstring, ____(REDUC_0)____: bitstring; adec(aenc(____(REDUC_2)____,pk(y)),y) = x.\n\n(* declaration of public name*)\n\nfree ____(FREE_0)____: channel.\n\n(* declaration of biprocess *)\n\nlet processA(sk_a:bitstring,____(OP_2)____:bitstring) =\n\tnew n_a: bitstring;\n\tout(c, aenc((n_a,pk(____(OP_5)____)),pk(sk_b)));\n\tin(____(OP_6)____, x:bitstring);\n\t0.\n\nlet processB(sk_b:bitstring,____(OP_3)____:bitstring) =\n\tin(c, ____(OP_7)____:bitstring);\n\tnew n_b:bitstring;\n\n\tlet (n_a:____(LET_0)____,pub_a:bitstring) = adec(x, ____(LET_1)____) in\n\t  if pub_a = pk(____(IF_0)____)\n\t  then\n\t    out(c,aenc((n_a,n_b,pk(sk_b)),pk(____(OP_0)____)))\n\t  else\n\t    out(c,aenc(n_b,pk(sk_b)))\n\telse\n\t  out(c,aenc(n_b,pk(sk_b))).\n\t  \nlet system(sk_a:bitstring,sk_b:bitstring) = !processA(sk_a,sk_b) | !processB(sk_b,sk_a).\n\n\nequivalence\n\tnew ____(NEW_0)____:bitstring; new sk_b:bitstring; new sk_c:bitstring;\n\t  out(c,pk(sk_a));out(c,pk(____(OP_1)____));out(c,pk(____(OP_4)____)); system(sk_a,sk_b)\n\t  \n\tnew sk_a:bitstring; new sk_b:bitstring; new sk_c:bitstring;\n\t  out(c,pk(sk_a));out(c,pk(sk_b));out(c,pk(sk_c)); system(sk_c,sk_b)\n\t  \n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.031s (user 0.023s + system 0.008s), max rss 10704K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Private Authentication\n   Taken from Delaune, Jacquemard, CSFW'04 *)\n\n(*set simplifyProcess = interactive.*)\n\n(* shared-key encryption as equation *)\n\nfun aenc(bitstring, bitstring): bitstring.\nfun pk(bitstring): bitstring.\n\nreduc forall x: bitstring, y: bitstring; adec(aenc(x,pk(y)),y) = x.\n\n(* declaration of public name*)\n\nfree c: channel.\n\n(* declaration of biprocess *)\n\nlet processA(sk_a:bitstring,sk_b:bitstring) =\n\tnew n_a: bitstring;\n\tout(c, aenc((n_a,pk(sk_a)),pk(sk_b)));\n\tin(c, x:bitstring);\n\t0.\n\nlet processB(sk_b:bitstring,sk_a:bitstring) =\n\tin(c, x:bitstring);\n\tnew n_b:bitstring;\n\n\tlet (n_a:bitstring,pub_a:bitstring) = adec(x, sk_b) in\n\t  if pub_a = pk(sk_a)\n\t  then\n\t    out(c,aenc((n_a,n_b,pk(sk_b)),pk(sk_a)))\n\t  else\n\t    out(c,aenc(n_b,pk(sk_b)))\n\telse\n\t  out(c,aenc(n_b,pk(sk_b))).\n\t  \nlet system(sk_a:bitstring,sk_b:bitstring) = !processA(sk_a,sk_b) | !processB(sk_b,sk_a).\n\n\nequivalence\n\tnew sk_a:bitstring; new sk_b:bitstring; new sk_c:bitstring;\n\t  out(c,pk(sk_a));out(c,pk(sk_b));out(c,pk(sk_c)); system(sk_a,sk_b)\n\t  \n\tnew sk_a:bitstring; new sk_b:bitstring; new sk_c:bitstring;\n\t  out(c,pk(sk_a));out(c,pk(sk_b));out(c,pk(sk_c)); system(sk_c,sk_b)\n\t  \n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.031s (user 0.023s + system 0.008s), max rss 10704K\nEND *)"
    },
    {
        "file": "PV-1/private_messaging.pv",
        "incomplete": "(*----------------------------------*)\n(*Types\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\ntype G.\ntype exponent.\ntype hmac_key.\ntype sym_key.\ntype ____(TYPE_1)____.\ntype ____(OP_9)____.\ntype ____(TYPE_0)____.\n\n\n(*----------------------------------*)\n(*Constants\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nfree c: channel.\nfree ____(OP_16)____: sk [private].\nfree skB: sk [private].\nfree ____(OP_20)____: sk [____(FREE_1)____].\nfree m1: ____(OP_37)____ [private].\nfree ____(OP_10)____: bitstring [____(FREE_0)____].\nfree m3: bitstring [private].\nconst failmsg: bitstring [data].\nconst zero:sym_key [data].\nconst nonce0: nonce [____(CONST_0)____].\nconst recipients: bitstring [data].\n\nevent Sentmessage(pk, pk, bitstring).\nevent Receivedmessage(pk, pk, bitstring).\n\n(*----------------------------------*)\n(*Primitives\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n\n\n(*Type conversions*)\nfun pk2bit(pk): ____(FUN_1)____ [typeConverter].\nfun bit2pk(bitstring):pk     [____(FUN_0)____].\nfun symkey2bit(sym_key): bitstring [typeConverter].\nfun pk2symkey(pk): sym_key [typeConverter].\n\n\nfun get_pk(sk): pk.\nfun valid(____(FUN_4)____):sk.\nfun weak(sk):sk.\n\n(*DH*)\nfun exp(pk, ____(OP_21)____): sym_key.\nequation forall ____(EQUATION_0)____:____(EQUATION_1)____, y:sk; exp(get_pk(____(EQUATION_2)____), y) = exp(get_pk(y), ____(OP_13)____).\n\n\nfun dhexp(pk, sk): sym_key\nreduc forall b:sk, a:sk; dhexp(get_pk(weak(a)), b) = zero\notherwise forall b:sk, a:sk; dhexp(get_pk(a), weak(____(OP_14)____)) = zero\notherwise forall b:sk, a:sk; dhexp(get_pk(____(OP_2)____), b) = exp(get_pk(a), b).\n\n\n(*Symmetric Encryption*)\nfun enc(bitstring, sym_key): bitstring.\nreduc forall m: bitstring, k: sym_key; dec(enc(m, k), k) = m.\n\n(*HMAC*)\nfun hmac(bitstring, hmac_key): bitstring.\nreduc forall ____(REDUC_0)____: ____(REDUC_2)____, k: ____(REDUC_1)____; checkhmac(hmac(____(REDUC_3)____, k), m, k) = true.\n\n(*Hash*)\nfun hash(bitstring): bitstring.\n\n(*Hash to a symetric key*)\nfun hash_to_key(bitstring): sym_key.\n\n(*signatures*)\nfun sign(bitstring, ____(FUN_2)____): bitstring.\nfun checksign(bitstring, pk, bitstring): bool\nreduc forall m: bitstring, k: sk; checksign(sign(m,k), get_pk(k), m) = true\notherwise forall m1: bitstring, m2:bitstring, k: sk; checksign(sign(m1, weak(k)), get_pk(weak(k)), m2) = true\notherwise forall str1:bitstring, pkey: pk, str2: bitstring; checksign(____(OP_17)____, pkey, str2) = false.\nreduc forall m: bitstring, k1: sk, k2: sk; resign(sign(m,k1), k2) = sign(m,k2).\n\n(*secret box*)\nfun incnonce(____(FUN_3)____):nonce.\nreduc forall n:nonce; decnonce(incnonce(n)) = n.\n\nfun aeadenc(sym_key, ____(FUN_5)____, ____(OP_18)____): bitstring.\nfun aeaddec(sym_key, nonce, bitstring): bitstring\nreduc forall k:sym_key, n:nonce, m:bitstring;\n  \taeaddec(k, ____(OP_39)____, aeadenc( k, n, ____(OP_38)____)) = (true, m)\notherwise forall k:sym_key, n: nonce, str: bitstring;\n    aeaddec(k, n, str) = (false, failmsg).\n\n\n\n(*----------------------------------*)\n(*Queries\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nquery attacker(m1) phase 0.\nquery attacker(m2) phase ____(QUERY_0)____.\nquery attacker(m3) phase 0.\nquery pkSender: pk, ____(QUERY_4)____:pk, ____(QUERY_2)____: bitstring; ____(QUERY_1)____ (Receivedmessage(pkSender, ____(OP_36)____, ____(QUERY_3)____)) ==> event (Sentmessage(pkSender, pkReceiver, mes)).\n(*query event (Sentmessage(exp(g, skA), exp(g, skC), m1)).*)\n(*query event (Receivedmessage(get_pk(skA), get_pk(skC), m1)).*)\nquery event (Receivedmessage(get_pk(____(OP_3)____), get_pk(skB), m3)).\n\n\n(*----------------------------------*)\n(*Principals\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nlet EncryptM42(____(OP_6)____:sk, pkReceiver1:pk, pkReceiver2:pk, m_out: bitstring) =\n  let pkMe = get_pk(____(LET_11)____) in\n  new ____(OP_1)____: ____(NEW_1)____;\n  new y: ____(NEW_0)____;\n  new nonce: nonce;\n  let pkh = get_pk(h) in\n  let key1 = dhexp(____(LET_0)____, h) in\n  let key2 = dhexp(____(OP_29)____, h) in\n  let header = (y, ____(LET_1)____) in\n  let enc1 = aeadenc(key1, nonce, ____(OP_12)____) in\n  let enc2 = aeadenc(key2, nonce, header) in\n  let encM = aeadenc(y, nonce, m_out) in\n  let sig = sign((nonce, pkh, ____(OP_7)____, enc2, ____(OP_8)____), skMe) in\n  event Sentmessage(pkMe, pkReceiver1, m_out);\n  event Sentmessage(pkMe, pkReceiver2, m_out);\n  out(____(OP_31)____, nonce);\n  out(____(OP_30)____, pkh);\n  out(____(OP_5)____, enc1);\n  out(c, enc2);\n  out(c, ____(OP_4)____);\n  out(c, sig).\n\nlet DecryptM42(skMe:sk, pkSender:pk) =\n  let pkMe = get_pk(skMe) ____(LET_10)____\n  in(c, ____(OP_15)____: nonce);\n  in(c, ____(OP_33)____: pk);\n  in(c, ____(OP_0)____: bitstring);\n  in(c, enc2: bitstring);\n  in(c, ____(OP_19)____: bitstring);\n  in(c, sig: bitstring);\n  let ____(LET_8)____ = dhexp(____(OP_27)____, skMe) in\n  let (=true) = checksign(sig, pkSender, (____(OP_35)____, pkh, enc1, enc2, ____(OP_34)____)) in\n  let (=true, header: bitstring) = aeaddec(key, nonce, enc1) in\n  (\n  let (y: ____(LET_7)____, foo: bitstring)  = ____(LET_6)____ in\n  let (b:bool, m_in: bitstring) = aeaddec(y, ____(OP_24)____, encM) in\n  event Receivedmessage(____(OP_11)____, pkMe, m_in)\n  )\n  else\n  let (=true, header: bitstring) = aeaddec(key, nonce, ____(OP_26)____) in\n  let (y: sym_key, foo: bitstring) = header in\n  let (b:bool, m_in: bitstring) = aeaddec( y, nonce, encM) in\n  event Receivedmessage(pkSender, pkMe, m_in).\n\n\nlet EncryptM41(skMe:sk, pkReceiver:pk, mes: bitstring) =\n  let pkMe = get_pk(skMe) in\n  new h: sk;\n  new y: sym_key;\n  new nonce: nonce;\n  let pkh = get_pk(h) in\n  let key1 = dhexp(pkReceiver, h) in\n  let header = (y, recipients) in\n  let enc1 = aeadenc(key1, ____(OP_25)____, ____(LET_9)____) in\n  let encM = aeadenc(y, nonce, mes) in\n  event Sentmessage(pkMe, pkReceiver, mes);\n  let ____(LET_3)____ = sign((nonce, pkh, enc1, ____(LET_4)____), skMe) in\n  out(c, nonce);\n  out(c, pkh);\n  out(c, enc1);\n  out(c, encM);\n  out(c, sig).\n\nlet DecryptM41(skMe:sk, pkSender:pk) =\n  let pkMe = get_pk(skMe) in\n  in(c, nonce: nonce);\n  in(c, pkh: pk);\n  in(c, enc1: ____(OP_32)____);\n  in(c, encM: bitstring);\n  in(c, sig:bitstring);\n  let key = dhexp(____(LET_5)____, skMe) in\n  if checksign(sig, pkSender, (____(IF_0)____, pkh, ____(IF_1)____, encM)) then\n  let (=true, header: bitstring) = aeaddec(key, nonce, enc1) in\n  let (y: sym_key, foo: bitstring)  = header in\n  let (=true, m1: bitstring) = aeaddec(y, ____(LET_2)____, encM) in\n  event Receivedmessage(pkSender, pkMe, m1).\n\n(*----------------------------------*)\n(*Main process\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nprocess\n\t!(\n    !(\n      !EncryptM42(____(OP_40)____, get_pk(skB), get_pk(skC), m1) | !DecryptM42(skB, get_pk(skA)) | !DecryptM42(skC, get_pk(skA))\n    ) |\n    !(\n      !EncryptM42(skB, get_pk(skA), get_pk(skC), m2) | !DecryptM42(skA, get_pk(skB)) | !DecryptM42(skC, get_pk(skB))\n    ) |\n    !(\n      !EncryptM41(skC, get_pk(skA), m3) | !DecryptM41(skB, get_pk(skC)) | !DecryptM41(skA, get_pk(skC))\n    ) |\n    (phase 1; out(____(OP_41)____,skB); out(c, skC); out(c, ____(OP_42)____))\n  )",
        "complete:": "(*----------------------------------*)\n(*Types\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\ntype G.\ntype exponent.\ntype hmac_key.\ntype sym_key.\ntype nonce.\ntype sk.\ntype pk.\n\n\n(*----------------------------------*)\n(*Constants\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nfree c: channel.\nfree skA: sk [private].\nfree skB: sk [private].\nfree skC: sk [private].\nfree m1: bitstring [private].\nfree m2: bitstring [private].\nfree m3: bitstring [private].\nconst failmsg: bitstring [data].\nconst zero:sym_key [data].\nconst nonce0: nonce [data].\nconst recipients: bitstring [data].\n\nevent Sentmessage(pk, pk, bitstring).\nevent Receivedmessage(pk, pk, bitstring).\n\n(*----------------------------------*)\n(*Primitives\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n\n\n(*Type conversions*)\nfun pk2bit(pk): bitstring [typeConverter].\nfun bit2pk(bitstring):pk     [typeConverter].\nfun symkey2bit(sym_key): bitstring [typeConverter].\nfun pk2symkey(pk): sym_key [typeConverter].\n\n\nfun get_pk(sk): pk.\nfun valid(sk):sk.\nfun weak(sk):sk.\n\n(*DH*)\nfun exp(pk, sk): sym_key.\nequation forall x:sk, y:sk; exp(get_pk(x), y) = exp(get_pk(y), x).\n\n\nfun dhexp(pk, sk): sym_key\nreduc forall b:sk, a:sk; dhexp(get_pk(weak(a)), b) = zero\notherwise forall b:sk, a:sk; dhexp(get_pk(a), weak(b)) = zero\notherwise forall b:sk, a:sk; dhexp(get_pk(a), b) = exp(get_pk(a), b).\n\n\n(*Symmetric Encryption*)\nfun enc(bitstring, sym_key): bitstring.\nreduc forall m: bitstring, k: sym_key; dec(enc(m, k), k) = m.\n\n(*HMAC*)\nfun hmac(bitstring, hmac_key): bitstring.\nreduc forall m: bitstring, k: hmac_key; checkhmac(hmac(m, k), m, k) = true.\n\n(*Hash*)\nfun hash(bitstring): bitstring.\n\n(*Hash to a symetric key*)\nfun hash_to_key(bitstring): sym_key.\n\n(*signatures*)\nfun sign(bitstring, sk): bitstring.\nfun checksign(bitstring, pk, bitstring): bool\nreduc forall m: bitstring, k: sk; checksign(sign(m,k), get_pk(k), m) = true\notherwise forall m1: bitstring, m2:bitstring, k: sk; checksign(sign(m1, weak(k)), get_pk(weak(k)), m2) = true\notherwise forall str1:bitstring, pkey: pk, str2: bitstring; checksign(str1, pkey, str2) = false.\nreduc forall m: bitstring, k1: sk, k2: sk; resign(sign(m,k1), k2) = sign(m,k2).\n\n(*secret box*)\nfun incnonce(nonce):nonce.\nreduc forall n:nonce; decnonce(incnonce(n)) = n.\n\nfun aeadenc(sym_key, nonce, bitstring): bitstring.\nfun aeaddec(sym_key, nonce, bitstring): bitstring\nreduc forall k:sym_key, n:nonce, m:bitstring;\n  \taeaddec(k, n, aeadenc( k, n, m)) = (true, m)\notherwise forall k:sym_key, n: nonce, str: bitstring;\n    aeaddec(k, n, str) = (false, failmsg).\n\n\n\n(*----------------------------------*)\n(*Queries\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nquery attacker(m1) phase 0.\nquery attacker(m2) phase 0.\nquery attacker(m3) phase 0.\nquery pkSender: pk, pkReceiver:pk, mes: bitstring; event (Receivedmessage(pkSender, pkReceiver, mes)) ==> event (Sentmessage(pkSender, pkReceiver, mes)).\n(*query event (Sentmessage(exp(g, skA), exp(g, skC), m1)).*)\n(*query event (Receivedmessage(get_pk(skA), get_pk(skC), m1)).*)\nquery event (Receivedmessage(get_pk(skC), get_pk(skB), m3)).\n\n\n(*----------------------------------*)\n(*Principals\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nlet EncryptM42(skMe:sk, pkReceiver1:pk, pkReceiver2:pk, m_out: bitstring) =\n  let pkMe = get_pk(skMe) in\n  new h: sk;\n  new y: sym_key;\n  new nonce: nonce;\n  let pkh = get_pk(h) in\n  let key1 = dhexp(pkReceiver1, h) in\n  let key2 = dhexp(pkReceiver2, h) in\n  let header = (y, recipients) in\n  let enc1 = aeadenc(key1, nonce, header) in\n  let enc2 = aeadenc(key2, nonce, header) in\n  let encM = aeadenc(y, nonce, m_out) in\n  let sig = sign((nonce, pkh, enc1, enc2, encM), skMe) in\n  event Sentmessage(pkMe, pkReceiver1, m_out);\n  event Sentmessage(pkMe, pkReceiver2, m_out);\n  out(c, nonce);\n  out(c, pkh);\n  out(c, enc1);\n  out(c, enc2);\n  out(c, encM);\n  out(c, sig).\n\nlet DecryptM42(skMe:sk, pkSender:pk) =\n  let pkMe = get_pk(skMe) in\n  in(c, nonce: nonce);\n  in(c, pkh: pk);\n  in(c, enc1: bitstring);\n  in(c, enc2: bitstring);\n  in(c, encM: bitstring);\n  in(c, sig: bitstring);\n  let key = dhexp(pkh, skMe) in\n  let (=true) = checksign(sig, pkSender, (nonce, pkh, enc1, enc2, encM)) in\n  let (=true, header: bitstring) = aeaddec(key, nonce, enc1) in\n  (\n  let (y: sym_key, foo: bitstring)  = header in\n  let (b:bool, m_in: bitstring) = aeaddec(y, nonce, encM) in\n  event Receivedmessage(pkSender, pkMe, m_in)\n  )\n  else\n  let (=true, header: bitstring) = aeaddec(key, nonce, enc2) in\n  let (y: sym_key, foo: bitstring) = header in\n  let (b:bool, m_in: bitstring) = aeaddec( y, nonce, encM) in\n  event Receivedmessage(pkSender, pkMe, m_in).\n\n\nlet EncryptM41(skMe:sk, pkReceiver:pk, mes: bitstring) =\n  let pkMe = get_pk(skMe) in\n  new h: sk;\n  new y: sym_key;\n  new nonce: nonce;\n  let pkh = get_pk(h) in\n  let key1 = dhexp(pkReceiver, h) in\n  let header = (y, recipients) in\n  let enc1 = aeadenc(key1, nonce, header) in\n  let encM = aeadenc(y, nonce, mes) in\n  event Sentmessage(pkMe, pkReceiver, mes);\n  let sig = sign((nonce, pkh, enc1, encM), skMe) in\n  out(c, nonce);\n  out(c, pkh);\n  out(c, enc1);\n  out(c, encM);\n  out(c, sig).\n\nlet DecryptM41(skMe:sk, pkSender:pk) =\n  let pkMe = get_pk(skMe) in\n  in(c, nonce: nonce);\n  in(c, pkh: pk);\n  in(c, enc1: bitstring);\n  in(c, encM: bitstring);\n  in(c, sig:bitstring);\n  let key = dhexp(pkh, skMe) in\n  if checksign(sig, pkSender, (nonce, pkh, enc1, encM)) then\n  let (=true, header: bitstring) = aeaddec(key, nonce, enc1) in\n  let (y: sym_key, foo: bitstring)  = header in\n  let (=true, m1: bitstring) = aeaddec(y, nonce, encM) in\n  event Receivedmessage(pkSender, pkMe, m1).\n\n(*----------------------------------*)\n(*Main process\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nprocess\n\t!(\n    !(\n      !EncryptM42(skA, get_pk(skB), get_pk(skC), m1) | !DecryptM42(skB, get_pk(skA)) | !DecryptM42(skC, get_pk(skA))\n    ) |\n    !(\n      !EncryptM42(skB, get_pk(skA), get_pk(skC), m2) | !DecryptM42(skA, get_pk(skB)) | !DecryptM42(skC, get_pk(skB))\n    ) |\n    !(\n      !EncryptM41(skC, get_pk(skA), m3) | !DecryptM41(skB, get_pk(skC)) | !DecryptM41(skA, get_pk(skC))\n    ) |\n    (phase 1; out(c,skB); out(c, skC); out(c, skA))\n  )"
    },
    {
        "file": "PV-1/proba-pk.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\ntype skey.\ntype ____(TYPE_0)____.\ntype ____(TYPE_1)____.\ntype block.\ntype encblock.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun enc(block, ____(FUN_0)____, seed): encblock.\nfun dec(encblock, ____(OP_1)____): block.\nequation forall ____(EQUATION_1)____: block, ____(EQUATION_0)____: skey, ____(EQUATION_2)____: seed;  dec(enc(____(EQUATION_3)____, pk(____(OP_0)____), z), y) = x.\n\n\nfree c,____(FREE_0)____: channel.\n\nprocess\n\tnew s: ____(NEW_0)____;\n\t(\n\t  out(c, pk(s))\n\t|\n\t  !\n\t  in(c2, x: block);\n\t  new a: seed;\n\t  new r: encblock;\n\t  out(c, choice[enc(x, pk(s), a), r])\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.011s (user 0.011s + system 0.000s), max rss 10136K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\ntype skey.\ntype pkey.\ntype seed.\ntype block.\ntype encblock.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun enc(block, pkey, seed): encblock.\nfun dec(encblock, skey): block.\nequation forall x: block, y: skey, z: seed;  dec(enc(x, pk(y), z), y) = x.\n\n\nfree c,c2: channel.\n\nprocess\n\tnew s: skey;\n\t(\n\t  out(c, pk(s))\n\t|\n\t  !\n\t  in(c2, x: block);\n\t  new a: seed;\n\t  new r: encblock;\n\t  out(c, choice[enc(x, pk(s), a), r])\n\t)\n\n(* EXPECTPV\nRESULT Observational equivalence is true.\n0.011s (user 0.011s + system 0.000s), max rss 10136K\nEND *)"
    },
    {
        "file": "PV-1/ProVerif-Code.pv",
        "incomplete": "type pubKey.\ntype ____(TYPE_0)____.\nfree sch: channel[private].\nfree usch: ____(FREE_1)____.\nfree k: ____(OP_0)____ [private].\nfree skHN: ____(FREE_0)____ [private].\nfree pkHN: pubKey.\n\nfree SUPI: ____(OP_3)____ [private].\nfree ____(OP_6)____: ____(OP_7)____.\n\nfun f(pubKey,____(FUN_3)____):____(OP_8)____.\nfun f1(____(OP_22)____):____(OP_43)____.\nfun f2(____(FUN_5)____):____(OP_44)____.\nfun f3(____(FUN_1)____):bitstring.\nfun f4(bitstring):bitstring.\nfun f5(bitstring):bitstring.\nfun SHA(bitstring):bitstring.\nfun pk(____(FUN_2)____):pubKey.\nfun getkey(bitstring):bitstring.\n\nfun senc(____(OP_42)____,bitstring):bitstring.\nreduc forall m:bitstring,n:bitstring; \nsdec(senc(____(OP_1)____,n),n)=m.\nfun keyseed(bitstring):bitstring.\n\n(* XOR *)\nfun xor(____(FUN_0)____,bitstring): bitstring.\nequation forall m:bitstring,n: bitstring;\n xor(xor(m,n),n)=m.\n    \n     \n\n(* Key Encapsulation Mechanism*)\nfun Encaps(____(OP_35)____,bitstring):bitstring.\n    (* Encaps takes the pk and a freshly generated random number. \n     Note that by definition Encaps is a probabilistic algorithm *)\n     \nfun KEMkey(bitstring):bitstring.\n     (* takes Encaps as input and outputs the shared KEM key*)\n\nfun KEMCipher(bitstring):bitstring.\n     (* takes Encaps as input and outputs the KEM ciphertext*)\nfun DecapsKey(secKey,____(FUN_4)____):bitstring.\n     (* takes the KEM secret key and ciphertext and outputs the KEM shared key*)\n\n(* The KEM is given by the following equations *)\nequation forall sk:secKey, r:bitstring;\nDecapsKey(sk,KEMCipher(Encaps(pk(____(OP_5)____),r)))=KEMkey(Encaps(pk(sk),____(OP_21)____)).\n\n\n\n\n\nevent UESendConSN(bitstring).\nevent UERecResSN(bitstring).\n\nevent SNRecReqUE(bitstring).\nevent UESendReqSN(bitstring). \n\nevent SNSendReqHN(bitstring).\nevent SNSendConHN(bitstring).\nevent SNRecConUE(bitstring).\nevent SNSendResUE(bitstring).\nevent SNRecResHN(bitstring).\n\nevent HNRecConSN(bitstring).\nevent HNSendResSN(bitstring).\nevent HNRecReqSN(bitstring).\n\n(* The process at the UE *)\n\nlet UE(____(OP_25)____:bitstring,____(OP_27)____:bitstring,pkHN:____(OP_24)____,k:bitstring,____(OP_26)____:bitstring)=\n(* Key Encapsulation *)\n    new rUE:____(NEW_0)____;     \n    let Ks1=KEMkey(Encaps(____(OP_17)____,rUE)) in\n    let c1=KEMCipher(Encaps(____(OP_18)____,rUE)) in\n        \n    (* generate a pair of KEM pk/sk *)\n    new skUE: ____(NEW_2)____; \n    let ____(LET_0)____ = pk(skUE) in \n    let USUCI = senc((SUPI, pkUE,SNname),Ks1)in\n        \n    let K'= f(pkUE,k) in    \n    let ____(OP_4)____ = f1((USUCI,Ks1,____(LET_13)____)) in\n    event UESendReqSN(MAC1);\n    out(usch,(____(OP_45)____, ____(OP_46)____,MAC1,idHN));\n\n(* End of Identification request material *)\n\n    in(usch, (uc2: bitstring,UCONC:bitstring,uMAC2:bitstring));\n    (* Decapsulation at UE *)\n    let UKs2=DecapsKey(____(OP_38)____, uc2) in\n        \n        \n    let urSN = xor(UCONC,f5((k,____(OP_19)____))) in\n    if uMAC2=f1((k,UKs2,urSN))  then \n    event UERecResSN(uMAC2);\n    let URES=f2((k,UKs2)) in\n    let UCK=f3((k,____(LET_8)____)) in\n    let UIK=f4((k,UKs2)) in \n                   \n                   \n    let URESstar= keyseed((UCK,UIK,UKs2,URES,SNname)) in\n    let HXRES=SHA((URESstar,urSN)) in\n    let UkAUSF = keyseed((UCK,UIK,UKs2,UCONC,SNname)) in\n    let UkSEAF = keyseed((UkAUSF,SNname)) in\n\n    event UESendConSN(URESstar);\n    out(____(OP_9)____,URESstar).\n                   \n                   \n                   \n\n\n(* The process at the SN *)\n\nlet SN(SNname:bitstring)=\n    in (usch,(sUSUCI:bitstring,____(OP_23)____:bitstring,sidHN:bitstring));\n    event SNRecReqUE(sMAC1);\n    new rSN:bitstring;\n    event SNSendReqHN(sMAC1);\n    out(sch,(sUSUCI,____(OP_32)____,____(OP_33)____,rSN));\n\n(* End of the first phase *)\n\n    in(sch,(sc2:bitstring,sHXRES:bitstring,sM:bitstring,sCONC:bitstring,sMAC2:bitstring));\n    event SNRecResHN(sMAC2);\n\n    event SNSendResUE(sMAC2);\n    out(usch,(sc2,sCONC,sMAC2));\n\n(* SN sent AUTN to UE *)\n\n    in(usch,URESstar:bitstring);\n    let sXRES = f1((URESstar,____(LET_4)____)) in\n    if ____(IF_0)____ = sHXRES then \n    event SNRecConUE(sHXRES);\n    let sK3=xor(sXRES,f5((URESstar,____(LET_9)____))) in\n    let (skSEAF:bitstring,sSUPI:bitstring)=sdec(sM, sK3) in\n    new conf:bitstring;\n    event SNSendConHN(conf);\n    out(____(OP_11)____,(conf)).\n\n(* The process at the HN *)\n        (* Identification phase *)\n\nlet HN(skHN:secKey,____(OP_40)____:bitstring)=\n    in(sch,(hc1:____(OP_29)____, hUSUCI:____(OP_31)____,____(OP_28)____:bitstring,\n    hSNname':bitstring,____(OP_30)____:bitstring));\n(* Decapsulation *)\n    let hKs1=DecapsKey(____(OP_10)____, ____(LET_1)____) in\n    let (____(OP_15)____:bitstring,hpkUE:pubKey,hSNname:bitstring)=\n    sdec(hUSUCI,hKs1) in\n    if hSNname=hSNname' then\n    let hk = getkey(hSUPI) in\n    let hK'=f(____(OP_41)____,hKs1) in  \n    if ____(OP_36)____= f1((hUSUCI,hKs1,hK')) then\n    event HNRecReqSN(hMAC1);\n\n(* Encapsulation at the HN*)\n    new rHN:bitstring;   \n    let ____(LET_7)____=KEMkey(Encaps(hpkUE,rHN)) in\n    let c2=KEMCipher(Encaps(hpkUE,rHN)) in\n\n(* Authentication vector at HN *)\n\n    let ____(OP_16)____=f1((hk,____(LET_6)____,hrSN)) in\n    let XRES=f2((hk,____(LET_5)____)) in\n    let CONC=xor(hrSN,f5((____(OP_12)____,Ks2))) in\n    let CK=f3((____(LET_12)____,Ks2)) in\n    let IK=f4((hk,Ks2)) in\n    let XRESstar= keyseed((CK,____(LET_11)____,____(LET_10)____,XRES,hSNname)) in\n    let HXRES=SHA((____(OP_2)____,hrSN)) in\n    let kAUSF = keyseed((CK,IK,Ks2,CONC,hSNname)) in\n            \n    let kSEAF = keyseed((kAUSF,hSNname)) in\n\n    let K3=xor(XRES,f5((hk,____(LET_2)____))) in\n    let M=senc((kSEAF,hSUPI), K3) in\n\n\n    event HNSendResSN(MAC2);\n    out(sch,(c2,HXRES,M,CONC,MAC2));\n(* End of Authentication material generation *)\n\nin(sch,____(OP_37)____:bitstring);\nevent HNRecConSN(hconf).\n    \n   \n\n\n\nquery attacker(skHN).\nquery attacker(k).\nquery ____(QUERY_0)____ (SUPI).\n\n\nquery a:bitstring,b:bitstring;\nevent(HNRecReqSN(____(OP_34)____))\n==> event(SNSendReqHN(b)).\nquery a:bitstring,b:bitstring;\nevent(SNRecResHN(a))\n==> event(HNSendResSN(b)).   \nquery a:bitstring,b:bitstring;\nevent(UERecResSN(____(OP_39)____))\n==> event(SNSendResUE(b)).\nquery a:bitstring,b:bitstring;\nevent(SNRecConUE(a))\n==> event(UESendConSN(____(OP_20)____)).\nquery a:bitstring,b:bitstring;\nevent(HNRecConSN(a))\n==> event(SNSendConHN(b)).\nprocess\nnew ____(NEW_1)____ :secKey;\nnew idHN :bitstring;\nnew SNname :bitstring;\nlet pkHN = pk(____(LET_3)____) in\nout(usch, pkHN);\n(!UE(SUPI,idHN,____(OP_14)____,k,____(OP_13)____)|!SN(SNname)|!HN(skHN,idHN))",
        "complete:": "type pubKey.\ntype secKey.\nfree sch: channel[private].\nfree usch: channel.\nfree k: bitstring [private].\nfree skHN: secKey [private].\nfree pkHN: pubKey.\n\nfree SUPI: bitstring [private].\nfree SNname: bitstring.\n\nfun f(pubKey,bitstring):bitstring.\nfun f1(bitstring):bitstring.\nfun f2(bitstring):bitstring.\nfun f3(bitstring):bitstring.\nfun f4(bitstring):bitstring.\nfun f5(bitstring):bitstring.\nfun SHA(bitstring):bitstring.\nfun pk(secKey):pubKey.\nfun getkey(bitstring):bitstring.\n\nfun senc(bitstring,bitstring):bitstring.\nreduc forall m:bitstring,n:bitstring; \nsdec(senc(m,n),n)=m.\nfun keyseed(bitstring):bitstring.\n\n(* XOR *)\nfun xor(bitstring,bitstring): bitstring.\nequation forall m:bitstring,n: bitstring;\n xor(xor(m,n),n)=m.\n    \n     \n\n(* Key Encapsulation Mechanism*)\nfun Encaps(pubKey,bitstring):bitstring.\n    (* Encaps takes the pk and a freshly generated random number. \n     Note that by definition Encaps is a probabilistic algorithm *)\n     \nfun KEMkey(bitstring):bitstring.\n     (* takes Encaps as input and outputs the shared KEM key*)\n\nfun KEMCipher(bitstring):bitstring.\n     (* takes Encaps as input and outputs the KEM ciphertext*)\nfun DecapsKey(secKey,bitstring):bitstring.\n     (* takes the KEM secret key and ciphertext and outputs the KEM shared key*)\n\n(* The KEM is given by the following equations *)\nequation forall sk:secKey, r:bitstring;\nDecapsKey(sk,KEMCipher(Encaps(pk(sk),r)))=KEMkey(Encaps(pk(sk),r)).\n\n\n\n\n\nevent UESendConSN(bitstring).\nevent UERecResSN(bitstring).\n\nevent SNRecReqUE(bitstring).\nevent UESendReqSN(bitstring). \n\nevent SNSendReqHN(bitstring).\nevent SNSendConHN(bitstring).\nevent SNRecConUE(bitstring).\nevent SNSendResUE(bitstring).\nevent SNRecResHN(bitstring).\n\nevent HNRecConSN(bitstring).\nevent HNSendResSN(bitstring).\nevent HNRecReqSN(bitstring).\n\n(* The process at the UE *)\n\nlet UE(SUPI:bitstring,idHN:bitstring,pkHN:pubKey,k:bitstring,SNname:bitstring)=\n(* Key Encapsulation *)\n    new rUE:bitstring;     \n    let Ks1=KEMkey(Encaps(pkHN,rUE)) in\n    let c1=KEMCipher(Encaps(pkHN,rUE)) in\n        \n    (* generate a pair of KEM pk/sk *)\n    new skUE: secKey; \n    let pkUE = pk(skUE) in \n    let USUCI = senc((SUPI, pkUE,SNname),Ks1)in\n        \n    let K'= f(pkUE,k) in    \n    let MAC1 = f1((USUCI,Ks1,K')) in\n    event UESendReqSN(MAC1);\n    out(usch,(c1, USUCI,MAC1,idHN));\n\n(* End of Identification request material *)\n\n    in(usch, (uc2: bitstring,UCONC:bitstring,uMAC2:bitstring));\n    (* Decapsulation at UE *)\n    let UKs2=DecapsKey(skUE, uc2) in\n        \n        \n    let urSN = xor(UCONC,f5((k,UKs2))) in\n    if uMAC2=f1((k,UKs2,urSN))  then \n    event UERecResSN(uMAC2);\n    let URES=f2((k,UKs2)) in\n    let UCK=f3((k,UKs2)) in\n    let UIK=f4((k,UKs2)) in \n                   \n                   \n    let URESstar= keyseed((UCK,UIK,UKs2,URES,SNname)) in\n    let HXRES=SHA((URESstar,urSN)) in\n    let UkAUSF = keyseed((UCK,UIK,UKs2,UCONC,SNname)) in\n    let UkSEAF = keyseed((UkAUSF,SNname)) in\n\n    event UESendConSN(URESstar);\n    out(usch,URESstar).\n                   \n                   \n                   \n\n\n(* The process at the SN *)\n\nlet SN(SNname:bitstring)=\n    in (usch,(sUSUCI:bitstring,sMAC1:bitstring,sidHN:bitstring));\n    event SNRecReqUE(sMAC1);\n    new rSN:bitstring;\n    event SNSendReqHN(sMAC1);\n    out(sch,(sUSUCI,sMAC1,SNname,rSN));\n\n(* End of the first phase *)\n\n    in(sch,(sc2:bitstring,sHXRES:bitstring,sM:bitstring,sCONC:bitstring,sMAC2:bitstring));\n    event SNRecResHN(sMAC2);\n\n    event SNSendResUE(sMAC2);\n    out(usch,(sc2,sCONC,sMAC2));\n\n(* SN sent AUTN to UE *)\n\n    in(usch,URESstar:bitstring);\n    let sXRES = f1((URESstar,rSN)) in\n    if sXRES = sHXRES then \n    event SNRecConUE(sHXRES);\n    let sK3=xor(sXRES,f5((URESstar,rSN))) in\n    let (skSEAF:bitstring,sSUPI:bitstring)=sdec(sM, sK3) in\n    new conf:bitstring;\n    event SNSendConHN(conf);\n    out(sch,(conf)).\n\n(* The process at the HN *)\n        (* Identification phase *)\n\nlet HN(skHN:secKey,idHN:bitstring)=\n    in(sch,(hc1:bitstring, hUSUCI:bitstring,hMAC1:bitstring,\n    hSNname':bitstring,hrSN:bitstring));\n(* Decapsulation *)\n    let hKs1=DecapsKey(skHN, hc1) in\n    let (hSUPI:bitstring,hpkUE:pubKey,hSNname:bitstring)=\n    sdec(hUSUCI,hKs1) in\n    if hSNname=hSNname' then\n    let hk = getkey(hSUPI) in\n    let hK'=f(hpkUE,hKs1) in  \n    if hMAC1= f1((hUSUCI,hKs1,hK')) then\n    event HNRecReqSN(hMAC1);\n\n(* Encapsulation at the HN*)\n    new rHN:bitstring;   \n    let Ks2=KEMkey(Encaps(hpkUE,rHN)) in\n    let c2=KEMCipher(Encaps(hpkUE,rHN)) in\n\n(* Authentication vector at HN *)\n\n    let MAC2=f1((hk,Ks2,hrSN)) in\n    let XRES=f2((hk,Ks2)) in\n    let CONC=xor(hrSN,f5((hk,Ks2))) in\n    let CK=f3((hk,Ks2)) in\n    let IK=f4((hk,Ks2)) in\n    let XRESstar= keyseed((CK,IK,Ks2,XRES,hSNname)) in\n    let HXRES=SHA((XRESstar,hrSN)) in\n    let kAUSF = keyseed((CK,IK,Ks2,CONC,hSNname)) in\n            \n    let kSEAF = keyseed((kAUSF,hSNname)) in\n\n    let K3=xor(XRES,f5((hk,Ks2))) in\n    let M=senc((kSEAF,hSUPI), K3) in\n\n\n    event HNSendResSN(MAC2);\n    out(sch,(c2,HXRES,M,CONC,MAC2));\n(* End of Authentication material generation *)\n\nin(sch,hconf:bitstring);\nevent HNRecConSN(hconf).\n    \n   \n\n\n\nquery attacker(skHN).\nquery attacker(k).\nquery attacker (SUPI).\n\n\nquery a:bitstring,b:bitstring;\nevent(HNRecReqSN(a))\n==> event(SNSendReqHN(b)).\nquery a:bitstring,b:bitstring;\nevent(SNRecResHN(a))\n==> event(HNSendResSN(b)).   \nquery a:bitstring,b:bitstring;\nevent(UERecResSN(a))\n==> event(SNSendResUE(b)).\nquery a:bitstring,b:bitstring;\nevent(SNRecConUE(a))\n==> event(UESendConSN(b)).\nquery a:bitstring,b:bitstring;\nevent(HNRecConSN(a))\n==> event(SNSendConHN(b)).\nprocess\nnew skHN :secKey;\nnew idHN :bitstring;\nnew SNname :bitstring;\nlet pkHN = pk(skHN) in\nout(usch, pkHN);\n(!UE(SUPI,idHN,pkHN,k,SNname)|!SN(SNname)|!HN(skHN,idHN))"
    },
    {
        "file": "PV-1/racd.pv",
        "incomplete": "(*Dolev-Yao model Open Channel*)\nfree c:channel.\ntype ____(OP_1)____.\ntype tuple.\ntype ____(TYPE_2)____.\ntype nonce.\ntype ____(TYPE_0)____.\ntype pkey.\ntype result.\ntype ____(TYPE_1)____.\nfree x_i: bitstring [private].\nweaksecret x_i.\n\n(* Randomness generated by Prover *)\nfree r_i: bitstring [private].\nfree v_i: bitstring [____(FREE_0)____].\n\n\n\n\n(*noninterf r_i;\nnoninterf v_i;*)\n(* Elliptic Curve *)\ntype ____(TYPE_3)____.\ntype L.\n\n\n(*free nB: N [data].*)\n(* Auxiliary Functions *)\nfun templatehash(bitstring):bitstring.\nfun mod(bitstring,____(OP_10)____):bitstring.\nfun mul(____(OP_17)____,bitstring):bitstring.\nfun point_mul(____(FUN_3)____,G):G.\nfun hash(G,G,G):____(FUN_0)____.\nfun map(bitstring):bitstring.(*secure function of 2H(x)+1*)\nfun append(G,G,G):____(FUN_4)____.\nfun exp(G,____(FUN_1)____):G.\nfun sub(bitstring,bitstring):bitstring.\nfun tpm_pcr_extend(bitstring,G):none.\nfun ima_pp(bitstring,G,bitstring,bitstring):none.\nfun ima_pp_event():G.\nfun ima_pp_s():____(FUN_5)____.\nfun ima_pp_c():bitstring.\nfun requestTPMQuote():bitstring.\nfun hash_chain(G):bitstring.\nfun retrieve_all():bitstring.\nfun collect_results(G,bool):list.\nfun retrieve_results(list):bitstring.\nfun retrieve_event(list):G.\n(* Public key Cryptography *)\nfun pk(skey): ____(FUN_2)____.\n\n(* Signatures *)\nfun ok () : result .\nfun sign ( bitstring , skey ) : bitstring .\nreduc forall ____(REDUC_1)____ : bitstring , sk : skey ; ____(REDUC_0)____ ( sign (____(REDUC_2)____ , sk ) ) = ____(REDUC_3)____ .\nreduc forall m : bitstring , sk : skey ; checksign ( sign (m , sk ) , pk(sk) ) = ok () .   \n\n\n(*Events*)\nevent secureboot().\nevent requestAttestation(nonce).\nevent acceptAttestationRequest(nonce).(*attester*)\nevent sendAttestationResult(bitstring,list).(*attester*)\nevent requestpartialVerification(nonce,G,bitstring,bitstring,bitstring).(*attester*)\nevent verifiedAttestationResult(bitstring,G,bool).(*partialverifer*)\n(*event failedAttestationResult(pkey,bitstring,bool).*)\nevent trustable().(*Verifier*)\n\n(* A formal query, specifying the attacker can't ever be leaked the\nactual binary and the randomness during the protocol. *)\nquery attacker(x_i).\nquery attacker(____(QUERY_0)____).\nquery attacker(v_i).\n\n\nquery pk:pkey, n:nonce, event_hash:G, c_i:bitstring,c_i':bitstring, ____(OP_15)____:bitstring, result:bool, ____(OP_13)____:list;\nevent(trustable())==>(event(sendAttestationResult(tpmQuote_signed,____(OP_16)____))==>event(verifiedAttestationResult(tpmQuote_signed,event_hash,____(OP_2)____))).\n\n\nnoninterf x_i among (r_i,v_i,   ima_pp_c(), ima_pp_s()).\n\nlet verifier(pk:pkey) =\n    new n:nonce;\n    (*event requestAttestation(n);*)\n    out(____(OP_9)____,n);\n\n    in (c,(tpmQuote_signed:bitstring, partialAttestationresults:list));\n    let result' = retrieve_results(partialAttestationresults) in\n    let event_hash = retrieve_event(partialAttestationresults) in\n    let hash_chained = hash_chain(event_hash) in\n    new valid:bitstring;\n    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in\n    if checksign(tpmQuote_signed,____(OP_8)____) = ok() then\n        if ____(IF_2)____' =n ____(IF_1)____ hash_chained' = hash_chained && ____(IF_0)____ = valid then (\n            event trustable()).\n\n\nlet attester(index:____(OP_25)____, pk:____(OP_26)____, sk:____(OP_24)____, g:____(OP_23)____,odr:L) =\n    let event_hash = exp(g,mod(mul(r_i,mod(templatehash(x_i),odr)),odr)) in\n    let g_i = exp(____(OP_12)____, mod(templatehash(x_i),odr)) in\n    let t_i = exp(g_i,v_i) in\n    let c_i = hash(____(LET_6)____,t_i,event_hash) in\n    let s_i = mod(sub(____(LET_0)____,mod(mul(r_i,mod(____(LET_1)____,odr)),odr)),odr) in\n    (*event secureboot();*)\n    let pcr = tpm_pcr_extend(index,event_hash)in\n    let ima = ima_pp(index,____(LET_4)____,____(OP_11)____,____(LET_3)____)in\n    \n    \n    in(c,____(OP_6)____:nonce);\n    (*event acceptAttestationRequest(n);*)\n    let tpmQuote = requestTPMQuote() in\n    let tpmQuote_signed = sign(tpmQuote,sk) in\n    let event_hash_ima = ima_pp_event() in\n    let s_i_ima = ima_pp_s() in\n    let c_i_ima= ima_pp_c() in\n    (*event requestpartialVerification(n,event_hash_ima,c_i_ima,s_i_ima,tpmQuote_signed);*)\n    out (c,(event_hash_ima,c_i_ima,s_i_ima,n,tpmQuote_signed));\n    \n    in (c,(tpmQuote_signed':bitstring,event_hash':G,attresult:bool));\n    let ____(LET_8)____ = collect_results(____(OP_7)____,attresult) in\n    event sendAttestationResult(tpmQuote_signed', ____(OP_22)____);\n    out(c,(____(OP_14)____,partialAttestationresults)).\n   \n  \n\nlet partialVerifier(pk:pkey, ____(OP_19)____:G, odr:____(OP_20)____)=\n    in(c, (event_hash_ima:G,c_i_ima:bitstring,s_i_ima:bitstring,n:nonce, tpmQuote_signed:bitstring));\n    let g_i = exp(g, mod(templatehash(x_i),____(LET_2)____)) in\n    let g_i_s = exp(g_i,s_i_ima) in\n    let event_hash_c = exp(event_hash_ima,mod(c_i_ima,odr)) in\n    let ____(LET_7)____ = point_mul(g_i_s,event_hash_c) in\n    let c_i' = hash(g_i,____(OP_21)____,event_hash_ima) in \n    let hash_chained = hash_chain(event_hash_ima) in\n    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in\n    if checksign(tpmQuote_signed,____(OP_18)____) = ok() then\n        if c_i' = c_i_ima && n' = n && hash_chained' = hash_chained then (\n            event verifiedAttestationResult(tpmQuote_signed,event_hash_ima,____(OP_30)____);\n            out(c,(____(OP_0)____,event_hash_ima,true))).\n\n\n\nprocess\n    new sk:____(NEW_1)____;\n    let ____(LET_5)____ = pk(sk) in\n    new index:bitstring;\n    new g: G;\n    new odr:____(NEW_0)____;\n    ((!verifier(pkey)) |  (!attester(index,pkey,sk,g,odr)) | (!partialVerifier(pkey,g,odr))  )",
        "complete:": "(*Dolev-Yao model Open Channel*)\nfree c:channel.\ntype list.\ntype tuple.\ntype none.\ntype nonce.\ntype skey.\ntype pkey.\ntype result.\ntype key.\nfree x_i: bitstring [private].\nweaksecret x_i.\n\n(* Randomness generated by Prover *)\nfree r_i: bitstring [private].\nfree v_i: bitstring [private].\n\n\n\n\n(*noninterf r_i;\nnoninterf v_i;*)\n(* Elliptic Curve *)\ntype G.\ntype L.\n\n\n(*free nB: N [data].*)\n(* Auxiliary Functions *)\nfun templatehash(bitstring):bitstring.\nfun mod(bitstring,L):bitstring.\nfun mul(bitstring,bitstring):bitstring.\nfun point_mul(G,G):G.\nfun hash(G,G,G):bitstring.\nfun map(bitstring):bitstring.(*secure function of 2H(x)+1*)\nfun append(G,G,G):bitstring.\nfun exp(G,bitstring):G.\nfun sub(bitstring,bitstring):bitstring.\nfun tpm_pcr_extend(bitstring,G):none.\nfun ima_pp(bitstring,G,bitstring,bitstring):none.\nfun ima_pp_event():G.\nfun ima_pp_s():bitstring.\nfun ima_pp_c():bitstring.\nfun requestTPMQuote():bitstring.\nfun hash_chain(G):bitstring.\nfun retrieve_all():bitstring.\nfun collect_results(G,bool):list.\nfun retrieve_results(list):bitstring.\nfun retrieve_event(list):G.\n(* Public key Cryptography *)\nfun pk(skey): pkey.\n\n(* Signatures *)\nfun ok () : result .\nfun sign ( bitstring , skey ) : bitstring .\nreduc forall m : bitstring , sk : skey ; getmess ( sign (m , sk ) ) = m .\nreduc forall m : bitstring , sk : skey ; checksign ( sign (m , sk ) , pk(sk) ) = ok () .   \n\n\n(*Events*)\nevent secureboot().\nevent requestAttestation(nonce).\nevent acceptAttestationRequest(nonce).(*attester*)\nevent sendAttestationResult(bitstring,list).(*attester*)\nevent requestpartialVerification(nonce,G,bitstring,bitstring,bitstring).(*attester*)\nevent verifiedAttestationResult(bitstring,G,bool).(*partialverifer*)\n(*event failedAttestationResult(pkey,bitstring,bool).*)\nevent trustable().(*Verifier*)\n\n(* A formal query, specifying the attacker can't ever be leaked the\nactual binary and the randomness during the protocol. *)\nquery attacker(x_i).\nquery attacker(r_i).\nquery attacker(v_i).\n\n\nquery pk:pkey, n:nonce, event_hash:G, c_i:bitstring,c_i':bitstring, tpmQuote_signed:bitstring, result:bool, partialAttestationresults:list;\nevent(trustable())==>(event(sendAttestationResult(tpmQuote_signed,partialAttestationresults))==>event(verifiedAttestationResult(tpmQuote_signed,event_hash,result))).\n\n\nnoninterf x_i among (r_i,v_i,   ima_pp_c(), ima_pp_s()).\n\nlet verifier(pk:pkey) =\n    new n:nonce;\n    (*event requestAttestation(n);*)\n    out(c,n);\n\n    in (c,(tpmQuote_signed:bitstring, partialAttestationresults:list));\n    let result' = retrieve_results(partialAttestationresults) in\n    let event_hash = retrieve_event(partialAttestationresults) in\n    let hash_chained = hash_chain(event_hash) in\n    new valid:bitstring;\n    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in\n    if checksign(tpmQuote_signed,pk) = ok() then\n        if n' =n && hash_chained' = hash_chained && result' = valid then (\n            event trustable()).\n\n\nlet attester(index:bitstring, pk:pkey, sk:skey, g:G,odr:L) =\n    let event_hash = exp(g,mod(mul(r_i,mod(templatehash(x_i),odr)),odr)) in\n    let g_i = exp(g, mod(templatehash(x_i),odr)) in\n    let t_i = exp(g_i,v_i) in\n    let c_i = hash(g_i,t_i,event_hash) in\n    let s_i = mod(sub(v_i,mod(mul(r_i,mod(c_i,odr)),odr)),odr) in\n    (*event secureboot();*)\n    let pcr = tpm_pcr_extend(index,event_hash)in\n    let ima = ima_pp(index,event_hash,c_i,s_i)in\n    \n    \n    in(c,n:nonce);\n    (*event acceptAttestationRequest(n);*)\n    let tpmQuote = requestTPMQuote() in\n    let tpmQuote_signed = sign(tpmQuote,sk) in\n    let event_hash_ima = ima_pp_event() in\n    let s_i_ima = ima_pp_s() in\n    let c_i_ima= ima_pp_c() in\n    (*event requestpartialVerification(n,event_hash_ima,c_i_ima,s_i_ima,tpmQuote_signed);*)\n    out (c,(event_hash_ima,c_i_ima,s_i_ima,n,tpmQuote_signed));\n    \n    in (c,(tpmQuote_signed':bitstring,event_hash':G,attresult:bool));\n    let partialAttestationresults = collect_results(event_hash',attresult) in\n    event sendAttestationResult(tpmQuote_signed', partialAttestationresults);\n    out(c,(tpmQuote_signed',partialAttestationresults)).\n   \n  \n\nlet partialVerifier(pk:pkey, g:G, odr:L)=\n    in(c, (event_hash_ima:G,c_i_ima:bitstring,s_i_ima:bitstring,n:nonce, tpmQuote_signed:bitstring));\n    let g_i = exp(g, mod(templatehash(x_i),odr)) in\n    let g_i_s = exp(g_i,s_i_ima) in\n    let event_hash_c = exp(event_hash_ima,mod(c_i_ima,odr)) in\n    let t_i' = point_mul(g_i_s,event_hash_c) in\n    let c_i' = hash(g_i,t_i',event_hash_ima) in \n    let hash_chained = hash_chain(event_hash_ima) in\n    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in\n    if checksign(tpmQuote_signed,pk) = ok() then\n        if c_i' = c_i_ima && n' = n && hash_chained' = hash_chained then (\n            event verifiedAttestationResult(tpmQuote_signed,event_hash_ima,true);\n            out(c,(tpmQuote_signed,event_hash_ima,true))).\n\n\n\nprocess\n    new sk:skey;\n    let pkey = pk(sk) in\n    new index:bitstring;\n    new g: G;\n    new odr:L;\n    ((!verifier(pkey)) |  (!attester(index,pkey,sk,g,odr)) | (!partialVerifier(pkey,g,odr))  )"
    },
    {
        "file": "PV-1/rdp.pv",
        "incomplete": "(*assumes private as protected by Solid-OIDC*)\nfree cout:channel [private] . (* out client, in RDP  *)\nfree cin:channel [private] . (* in client, out RDP  *)\nfree orgin:channel [private] .  (* out proxy, in org  *)\nfree orgout:channel [private] .  (* in  proxy, out org  *)\nfree affin:channel [private] .  (* out proxy, in affiliate  *)\nfree affout:channel [private] .  (* in proxy, out affiliate  *)\nfree pub:channel .  (* public channel  *)\n\ntype ____(TYPE_0)____.\n\nfree OK:bitstring.\nfree notOK:bitstring.\nfree nN:Name . (* to indicate no policy for Name found *)\nfree nO:bitstring . (* to indicate no policy for operation found *)\nfree validName:Name [private] . (* a client Name which is authorized to perform operations *)\nfree invalidName:Name [private] . (* a client Name which is NOT authorized to perform any operation *)\n\nevent clientSendName(bitstring) . (* event emitted if client sends Name and op *)\nevent clientReceiveResponse(bitstring) . (* event emitted after client receives a response  *)\n(* event clientCompletes .  event emitted after client receives a response  *)\n\nevent orgOK(bitstring) . (* event emitted when org receives a message to return policy  *)\n\nevent affReceivesMsg(bitstring) . (* event emitted if affiliate accepts a message *)\n\nevent rdpWasSuccessful(bitstring) . (* event emitted if rdp receives an answer for orgOK request from affiliate *)\n\n\n(* Goal 1: The affiliate will never get to known a client's Name from the RDP regardless of whether the Name is valid or invalid *)\nquery attacker(validName) .\nquery attacker(invalidName) .\n\n(* Goal 2: When client sends a message to affiliate via the proxy, the org has to have seen the message before forwarding *)\nquery ____(OP_6)____:bitstring; event(clientReceiveResponse(____(OP_0)____)) ==> inj-event(orgOK(____(OP_1)____)).\n\n(* fullchain *)\nquery ____(OP_9)____:bitstring; \n  event(clientReceiveResponse(____(OP_14)____))\n  ==> \n  inj-event(rdpWasSuccessful(nonce))\n  && \n  inj-event(orgOK(nonce))\n  && \n  inj-event(affReceivesMsg(____(OP_7)____)).\n\n(* Goal 3: Whenever client sends a request, it will receive a response *)\nquery nonce:bitstring; event(clientReceiveResponse(nonce)) ==> inj-event(clientSendName(nonce)) . \n\n\n(*===Client that wants to perform an operation op===*)\nlet client(clientname:Name, op:bitstring) = \n  new nonce:bitstring; (*session id*)\n  (*  *)\n  let m0 = (clientname, op, nonce) in\n  event clientSendName(nonce) ;\n  out(____(OP_8)____, m0);\n  (*  *)\n  in(cin, m4:bitstring) ;\n  let (____(LET_5)____:____(LET_6)____,nonce2:bitstring) = m4 in\n  if nonce = nonce2 then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  (* if you did not check the nonces, ProVerif is not able to prove correspondence correctly *)\n  event clientReceiveResponse(nonce)  . \n\n(*===RDP who checks and forwards operation op===*)\nlet rdp(____(OP_13)____:____(OP_2)____) =\n  in(cout, m0:bitstring) ;\n  let (xname:Name , xop:bitstring, nonce:bitstring) = m0 in\n  let m1 = (xname, ____(LET_4)____) in\n  out(orgin, m1) ; (* send Name to org to get answer with policy details *)\n  (*  *)\n  in(orgout, ____(OP_15)____:bitstring) ;\n  let (polName:Name, polOp:bitstring, nonce2:bitstring) = m2 in\n  if (xname, xop, nonce) = (polName, polOp, nonce2) then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  let m3 = (orgName, xop, nonce) in\n  out(____(OP_3)____, m3 ); \n  (*  *)\n  in(affout, m4:bitstring); (* proxy response*)\n  let (resp:____(LET_2)____,____(LET_3)____:bitstring) = m4 in\n  if nonce = nonce3 then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  event rdpWasSuccessful(nonce);\n  out(cin, m4) .\n\n(*===Organization to return policy===*)\nlet organization(okName:Name, okOp:____(OP_10)____) =\n  in(orgin, m1:bitstring ) ;\n  let (yname:____(LET_1)____, nonce:bitstring) = ____(LET_0)____ in\n  if yname = okName then \n  event orgOK(nonce) ;\n  let m2 = (okName, okOp, nonce) in \n  out(orgout, m2) .\n\n(*===Affiliate to whom the operation is fowarded to===*)\nlet affiliate(____(OP_12)____:Name, op:bitstring)  =\n  in(affin, m3:bitstring) ;\n  let (zname:Name, zop:bitstring, nonce:bitstring) = m3 in\n  if (zname, zop) = (orgName, ____(IF_1)____) then\n  event affReceivesMsg(nonce) ;   \n  let m4 = (OK,nonce) in \n  out(affout,m4) ;\n  out(pub,zname) . (* publish received Name to check if affiliate ever received secret client Name*)\n\nprocess\n  new op:bitstring; (*the operation to be applied to the affiliate*)\n  new orgName:Name; (* the organization's Name and the Name the RDP uses*)\n  (* one client is initalized with a valid Name and the operation, one client with an invalid Name, RDP knows the organization Name, organization knows which client is allowed to perform what operation, the affiliation knows the organization  *)\n  (\n      !client(invalidName, ____(OP_4)____) \n    | !client(validName, op) \n    | !rdp(orgName) \n    | !organization(validName , op) \n    | !affiliate(orgName, op)\n  )",
        "complete:": "(*assumes private as protected by Solid-OIDC*)\nfree cout:channel [private] . (* out client, in RDP  *)\nfree cin:channel [private] . (* in client, out RDP  *)\nfree orgin:channel [private] .  (* out proxy, in org  *)\nfree orgout:channel [private] .  (* in  proxy, out org  *)\nfree affin:channel [private] .  (* out proxy, in affiliate  *)\nfree affout:channel [private] .  (* in proxy, out affiliate  *)\nfree pub:channel .  (* public channel  *)\n\ntype Name.\n\nfree OK:bitstring.\nfree notOK:bitstring.\nfree nN:Name . (* to indicate no policy for Name found *)\nfree nO:bitstring . (* to indicate no policy for operation found *)\nfree validName:Name [private] . (* a client Name which is authorized to perform operations *)\nfree invalidName:Name [private] . (* a client Name which is NOT authorized to perform any operation *)\n\nevent clientSendName(bitstring) . (* event emitted if client sends Name and op *)\nevent clientReceiveResponse(bitstring) . (* event emitted after client receives a response  *)\n(* event clientCompletes .  event emitted after client receives a response  *)\n\nevent orgOK(bitstring) . (* event emitted when org receives a message to return policy  *)\n\nevent affReceivesMsg(bitstring) . (* event emitted if affiliate accepts a message *)\n\nevent rdpWasSuccessful(bitstring) . (* event emitted if rdp receives an answer for orgOK request from affiliate *)\n\n\n(* Goal 1: The affiliate will never get to known a client's Name from the RDP regardless of whether the Name is valid or invalid *)\nquery attacker(validName) .\nquery attacker(invalidName) .\n\n(* Goal 2: When client sends a message to affiliate via the proxy, the org has to have seen the message before forwarding *)\nquery nonce:bitstring; event(clientReceiveResponse(nonce)) ==> inj-event(orgOK(nonce)).\n\n(* fullchain *)\nquery nonce:bitstring; \n  event(clientReceiveResponse(nonce))\n  ==> \n  inj-event(rdpWasSuccessful(nonce))\n  && \n  inj-event(orgOK(nonce))\n  && \n  inj-event(affReceivesMsg(nonce)).\n\n(* Goal 3: Whenever client sends a request, it will receive a response *)\nquery nonce:bitstring; event(clientReceiveResponse(nonce)) ==> inj-event(clientSendName(nonce)) . \n\n\n(*===Client that wants to perform an operation op===*)\nlet client(clientname:Name, op:bitstring) = \n  new nonce:bitstring; (*session id*)\n  (*  *)\n  let m0 = (clientname, op, nonce) in\n  event clientSendName(nonce) ;\n  out(cout, m0);\n  (*  *)\n  in(cin, m4:bitstring) ;\n  let (resp:bitstring,nonce2:bitstring) = m4 in\n  if nonce = nonce2 then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  (* if you did not check the nonces, ProVerif is not able to prove correspondence correctly *)\n  event clientReceiveResponse(nonce)  . \n\n(*===RDP who checks and forwards operation op===*)\nlet rdp(orgName:Name) =\n  in(cout, m0:bitstring) ;\n  let (xname:Name , xop:bitstring, nonce:bitstring) = m0 in\n  let m1 = (xname, nonce) in\n  out(orgin, m1) ; (* send Name to org to get answer with policy details *)\n  (*  *)\n  in(orgout, m2:bitstring) ;\n  let (polName:Name, polOp:bitstring, nonce2:bitstring) = m2 in\n  if (xname, xop, nonce) = (polName, polOp, nonce2) then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  let m3 = (orgName, xop, nonce) in\n  out(affin, m3 ); \n  (*  *)\n  in(affout, m4:bitstring); (* proxy response*)\n  let (resp:bitstring,nonce3:bitstring) = m4 in\n  if nonce = nonce3 then (*! these nonce checks are required in order to be able to prove inj-event query ! *)\n  event rdpWasSuccessful(nonce);\n  out(cin, m4) .\n\n(*===Organization to return policy===*)\nlet organization(okName:Name, okOp:bitstring) =\n  in(orgin, m1:bitstring ) ;\n  let (yname:Name, nonce:bitstring) = m1 in\n  if yname = okName then \n  event orgOK(nonce) ;\n  let m2 = (okName, okOp, nonce) in \n  out(orgout, m2) .\n\n(*===Affiliate to whom the operation is fowarded to===*)\nlet affiliate(orgName:Name, op:bitstring)  =\n  in(affin, m3:bitstring) ;\n  let (zname:Name, zop:bitstring, nonce:bitstring) = m3 in\n  if (zname, zop) = (orgName, op) then\n  event affReceivesMsg(nonce) ;   \n  let m4 = (OK,nonce) in \n  out(affout,m4) ;\n  out(pub,zname) . (* publish received Name to check if affiliate ever received secret client Name*)\n\nprocess\n  new op:bitstring; (*the operation to be applied to the affiliate*)\n  new orgName:Name; (* the organization's Name and the Name the RDP uses*)\n  (* one client is initalized with a valid Name and the operation, one client with an invalid Name, RDP knows the organization Name, organization knows which client is allowed to perform what operation, the affiliation knows the organization  *)\n  (\n      !client(invalidName, op) \n    | !client(validName, op) \n    | !rdp(orgName) \n    | !organization(validName , op) \n    | !affiliate(orgName, op)\n  )"
    },
    {
        "file": "PV-1/secure-device.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Secure Device.\n\n  This example was originally generated by GSVerif from the following processes:\n\n      let Conf(cell:channel) =\n        ! in(c,x:bitstring);\n          in(cell,y:bitstring);\n          let test:bool = (y = init && (x = left || x = right)) in\n          if test\n          then out(cell,x)\n          else out(cell,y).\n\n      let Decrypt(cell:channel,k:bitstring) =\n        ! in(c,x:bitstring);\n          let (xl:bitstring,xr:bitstring) = adec(x,k) in\n          in(cell,y:bitstring);\n          if y = left then out(c,xl); out(cell,y)\n          else if y = right then out(c,xr); out(cell,y)\n          else out(cell,y).\n\n      let Device =\n        new cell:channel [precise];\n        new k:bitstring;\n          out(c,pk(k))\n        | out(cell,init)\n        | Conf(cell) | Decrypt(cell,k)\n        | (! in(cell,x:bitstring); out(cell,x))\n        | (\n          !\n          new sl:bitstring;\n          new sr:bitstring;\n          out(c,aenc((sl,sr),pk(k))) | in(c,(=sl,=sr)); event Attack\n          ).\n\n      process ! Device\n\n  GSVerif modifies a query F => \\phi with F => \\phi || \\phi' where \\phi' is a property\n  that is always false. Instead of using this transformed query, we can declare the\n  negation of \\phi' as an axiom. See the paper on GSVerif (CSF'18) for more details\n  on these properties.\n*)\n\nfree c:channel.\n\nfun pk(bitstring):bitstring.\nfun aenc(____(FUN_0)____,bitstring):bitstring.\n\nfun adec(bitstring,bitstring):bitstring\nreduc forall ____(REDUC_1)____:____(REDUC_0)____,____(REDUC_2)____:bitstring; adec(aenc(x,pk(y)),y) = x.\n\nconst init:bitstring.\nconst ____(CONST_0)____:bitstring.\nconst right:bitstring.\n\nevent Attack.\n\ntype ____(TYPE_0)____.\n\nfree ____(FREE_0)____:stamp [private].\n\nevent Counter(channel,stamp,stamp,nat).\nevent VCell_bitstring(____(OP_19)____,bitstring).\n\naxiom i:nat,i1:nat,st:stamp,st1:stamp,st2:stamp,x:bitstring,x1:bitstring,d:channel;\n  event(VCell_bitstring(____(OP_15)____,(i,x1))) && event(VCell_bitstring(d,(i,x))) ==> x1 = x;\n  event(Counter(d,st2,st,____(OP_3)____)) && event(Counter(d,st2,st,i)) ==> i1 = i;\n  event(Counter(d,st2,st,i1)) && event(Counter(d,st2,st1,i1)) ==> st = st1.\n\nquery event(____(QUERY_0)____).\n\nprocess\n  !\n  new cell:channel; (* Application of the process Device *)\n  new k:bitstring;\n  (\n      out(c,pk(k))\n    | out(cell,(0,init))\n    | (\n      !  (* Application of the process Conf *)\n      in(____(OP_21)____,x:bitstring);\n      in(cell,(i:nat,y:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(____(OP_24)____,(i,y));\n      let test:bool = (y = init && (x = left || x = right)) in\n      if test\n      then\n        new st[]:stamp;\n        event Counter(cell,id,st,i);\n        event VCell_bitstring(cell,(i ____(OP_2)____ ____(OP_1)____,x));\n        out(cell,(____(OP_13)____ + 1,____(OP_14)____))\n      else out(cell,(i,y))\n    ) | (\n      !  (* Application of the process Decrypt *)\n      in(c,x:bitstring);\n      let (xl:bitstring,xr:bitstring) = adec(x,k) in\n      in(cell,(i:nat,y:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(cell,(i,y));\n      if y = left\n      then\n        out(c,xl);\n        out(cell,(i,y))\n      else\n        if y = right\n        then\n          out(____(OP_12)____,xr);\n          out(cell,(i,y))\n        else out(cell,(i,y))\n    ) | (\n      !\n      in(cell,(i:nat,x:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(cell,(____(OP_0)____,x));\n      out(cell,(i,x))\n    ) | (\n      !\n      new ____(NEW_2)____:bitstring;\n      new sr:bitstring;\n      ( out(c,aenc((sl,sr),pk(k))) | in(c,(= sl,= sr)); event Attack())\n    )\n  )\n\n(* EXPECTPV\nRESULT not event(Attack) is true.\n0.013s (user 0.004s + system 0.009s), max rss 9860K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Secure Device.\n\n  This example was originally generated by GSVerif from the following processes:\n\n      let Conf(cell:channel) =\n        ! in(c,x:bitstring);\n          in(cell,y:bitstring);\n          let test:bool = (y = init && (x = left || x = right)) in\n          if test\n          then out(cell,x)\n          else out(cell,y).\n\n      let Decrypt(cell:channel,k:bitstring) =\n        ! in(c,x:bitstring);\n          let (xl:bitstring,xr:bitstring) = adec(x,k) in\n          in(cell,y:bitstring);\n          if y = left then out(c,xl); out(cell,y)\n          else if y = right then out(c,xr); out(cell,y)\n          else out(cell,y).\n\n      let Device =\n        new cell:channel [precise];\n        new k:bitstring;\n          out(c,pk(k))\n        | out(cell,init)\n        | Conf(cell) | Decrypt(cell,k)\n        | (! in(cell,x:bitstring); out(cell,x))\n        | (\n          !\n          new sl:bitstring;\n          new sr:bitstring;\n          out(c,aenc((sl,sr),pk(k))) | in(c,(=sl,=sr)); event Attack\n          ).\n\n      process ! Device\n\n  GSVerif modifies a query F => \\phi with F => \\phi || \\phi' where \\phi' is a property\n  that is always false. Instead of using this transformed query, we can declare the\n  negation of \\phi' as an axiom. See the paper on GSVerif (CSF'18) for more details\n  on these properties.\n*)\n\nfree c:channel.\n\nfun pk(bitstring):bitstring.\nfun aenc(bitstring,bitstring):bitstring.\n\nfun adec(bitstring,bitstring):bitstring\nreduc forall x:bitstring,y:bitstring; adec(aenc(x,pk(y)),y) = x.\n\nconst init:bitstring.\nconst left:bitstring.\nconst right:bitstring.\n\nevent Attack.\n\ntype stamp.\n\nfree id:stamp [private].\n\nevent Counter(channel,stamp,stamp,nat).\nevent VCell_bitstring(channel,bitstring).\n\naxiom i:nat,i1:nat,st:stamp,st1:stamp,st2:stamp,x:bitstring,x1:bitstring,d:channel;\n  event(VCell_bitstring(d,(i,x1))) && event(VCell_bitstring(d,(i,x))) ==> x1 = x;\n  event(Counter(d,st2,st,i1)) && event(Counter(d,st2,st,i)) ==> i1 = i;\n  event(Counter(d,st2,st,i1)) && event(Counter(d,st2,st1,i1)) ==> st = st1.\n\nquery event(Attack).\n\nprocess\n  !\n  new cell:channel; (* Application of the process Device *)\n  new k:bitstring;\n  (\n      out(c,pk(k))\n    | out(cell,(0,init))\n    | (\n      !  (* Application of the process Conf *)\n      in(c,x:bitstring);\n      in(cell,(i:nat,y:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(cell,(i,y));\n      let test:bool = (y = init && (x = left || x = right)) in\n      if test\n      then\n        new st[]:stamp;\n        event Counter(cell,id,st,i);\n        event VCell_bitstring(cell,(i + 1,x));\n        out(cell,(i + 1,x))\n      else out(cell,(i,y))\n    ) | (\n      !  (* Application of the process Decrypt *)\n      in(c,x:bitstring);\n      let (xl:bitstring,xr:bitstring) = adec(x,k) in\n      in(cell,(i:nat,y:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(cell,(i,y));\n      if y = left\n      then\n        out(c,xl);\n        out(cell,(i,y))\n      else\n        if y = right\n        then\n          out(c,xr);\n          out(cell,(i,y))\n        else out(cell,(i,y))\n    ) | (\n      !\n      in(cell,(i:nat,x:bitstring)); (* The first nat variable has been added due to the cell parameter *)\n      event VCell_bitstring(cell,(i,x));\n      out(cell,(i,x))\n    ) | (\n      !\n      new sl:bitstring;\n      new sr:bitstring;\n      ( out(c,aenc((sl,sr),pk(k))) | in(c,(= sl,= sr)); event Attack())\n    )\n  )\n\n(* EXPECTPV\nRESULT not event(Attack) is true.\n0.013s (user 0.004s + system 0.009s), max rss 9860K\nEND *)"
    },
    {
        "file": "PV-1/SignedAugmentedEKE1.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3 \n\nNote that this protocol uses the same key for shared-key encryption\nand for signatures...\n*)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree ____(FREE_0)____: channel.\n\ntype host.\ntype ____(OP_10)____.\ntype ____(TYPE_0)____.\ntype G.\ntype exponent.\ntype ____(TYPE_1)____.\n\nfun nonce_to_bitstring(____(OP_0)____): bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst ____(CONST_0)____: G.\nfun exp(G, exponent): G.\nequation forall ____(EQUATION_1)____: ____(EQUATION_3)____, ____(EQUATION_2)____: exponent; exp(exp(____(EQUATION_0)____, x), y) = exp(exp(____(OP_12)____, y), x).\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(____(OP_5)____, key): G.\nfun dec(G, key): G.\nequation forall x: G, y: key; dec(enc(x,____(OP_1)____),y) = x.\nequation forall x: G, y: key; enc(dec(x,____(OP_15)____),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(____(FUN_0)____, G): bitstring.\nreduc forall ____(REDUC_1)____: ____(REDUC_2)____, ____(REDUC_0)____: G; sdec(senc(x,____(OP_2)____),y) = x.\n\n(* Signature *)\n\nfun pk(passwd):key.\nfun sign(G, passwd): ____(FUN_1)____.\nreduc forall x: G, y: passwd; verif(sign(x,____(OP_16)____), pk(y),x) = true.\nreduc forall x: G, y: passwd; getmess(sign(x,y)) = x.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, ____(OP_8)____: host, P: ____(OP_7)____) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(exp(g,RA), pk(P))));\n\tin(____(OP_3)____, (m1: ____(OP_4)____, m2: bitstring));\n\tlet gRB = dec(m1, pk(P)) in\n\tlet ____(LET_0)____ = exp(gRB, RA) in\n\tlet nonce_to_bitstring(____(OP_13)____) = sdec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, senc((challengeA, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(challengeA) = sdec(m3, K) then\n\tout(c, senc(sign(K,P), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: G)); \n\tlet gRA = dec(m, pk(P)) in\n\tnew RB: exponent;\n\tlet ____(LET_1)____ = exp(gRA, ____(OP_17)____) in\n\tnew ____(NEW_0)____: nonce;\n\tout(c, (enc(exp(____(OP_11)____, RB), pk(P)), senc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (____(LET_2)____: nonce, =challengeB) = sdec(m4, ____(LET_3)____) in\n\tout(c, senc(nonce_to_bitstring(challengeA), K));\n\tin(c, ____(OP_6)____: bitstring);\n\tlet fr = sdec(m5, K) in\n\tif verif(fr,pk(P),K) = ____(IF_0)____ then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(____(OP_9)____, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, ____(OP_18)____)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, ____(OP_14)____)) |\n\t(!processB(B, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n0.698s (user 0.686s + system 0.012s), max rss 18488K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3 \n\nNote that this protocol uses the same key for shared-key encryption\nand for signatures...\n*)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree c: channel.\n\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\ntype key.\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric encryption\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(G, key): G.\nfun dec(G, key): G.\nequation forall x: G, y: key; dec(enc(x,y),y) = x.\nequation forall x: G, y: key; enc(dec(x,y),y) = x.\n\n(* Symmetric encryption\n   One knows whether decryption succeeds or not *)\n\nfun senc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; sdec(senc(x,y),y) = x.\n\n(* Signature *)\n\nfun pk(passwd):key.\nfun sign(G, passwd): bitstring.\nreduc forall x: G, y: passwd; verif(sign(x,y), pk(y),x) = true.\nreduc forall x: G, y: passwd; getmess(sign(x,y)) = x.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(exp(g,RA), pk(P))));\n\tin(c, (m1: G, m2: bitstring));\n\tlet gRB = dec(m1, pk(P)) in\n\tlet K = exp(gRB, RA) in\n\tlet nonce_to_bitstring(challengeB) = sdec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, senc((challengeA, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(challengeA) = sdec(m3, K) then\n\tout(c, senc(sign(K,P), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: G)); \n\tlet gRA = dec(m, pk(P)) in\n\tnew RB: exponent;\n\tlet K = exp(gRA, RB) in\n\tnew challengeB: nonce;\n\tout(c, (enc(exp(g, RB), pk(P)), senc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (challengeA: nonce, =challengeB) = sdec(m4, K) in\n\tout(c, senc(nonce_to_bitstring(challengeA), K));\n\tin(c, m5: bitstring);\n\tlet fr = sdec(m5, K) in\n\tif verif(fr,pk(P),K) = true then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n0.698s (user 0.686s + system 0.012s), max rss 18488K\nEND *)"
    },
    {
        "file": "PV-1/signedDH.pv",
        "incomplete": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree ____(FREE_0)____: channel.\n\ntype pkey.\ntype ____(TYPE_0)____.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(____(FUN_0)____):pkey.\nreduc ____(REDUC_1)____ m: ____(REDUC_0)____, k: ____(REDUC_2)____; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, ____(OP_3)____): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,____(OP_7)____),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: ____(CONST_0)____.\nfun exp(G, ____(OP_1)____): G.\nequation forall x: ____(EQUATION_1)____, ____(EQUATION_3)____: ____(EQUATION_2)____; exp(exp(____(EQUATION_0)____, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(____(QUERY_0)____).\n\n(* The process *)\n\nlet p0(____(LET_1)____: skey, pkA: pkey, ____(LET_0)____: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(____(OP_0)____, n0), skA), pkA));\n\t in(c,m1: ____(OP_8)____); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = ____(IF_0)____ then\n\t out(c, enc(s,k)).\n\nlet p1(skB: ____(LET_2)____, pkB: ____(LET_3)____, pkA: pkey) = \n         in(____(OP_4)____, (____(OP_5)____: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, ____(OP_6)____) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(____(LET_4)____,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew ____(NEW_0)____: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)",
        "complete:": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree c: channel.\n\ntype pkey.\ntype skey.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(skey):pkey.\nreduc forall m: G, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(s).\n\n(* The process *)\n\nlet p0(skA: skey, pkA: pkey, pkB: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(g, n0), skA), pkA));\n\t in(c,m1: bitstring); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = pkB then\n\t out(c, enc(s,k)).\n\nlet p1(skB: skey, pkB: pkey, pkA: pkey) = \n         in(c, (m0: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, n1) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(m,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew skB: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)"
    },
    {
        "file": "PV-1/simpleryahalom-auth.horn",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Simpler Yahalom protocol\nVersion of Burrows, Abadi, Needham, SRC039\n\nMessage 1 A -> B: A; Na \nMessage 2 B -> S: B; Nb; {A; Na}Kbs \nMessage 3 S -> A: Nb; {B; Kab; Na}Kas ; {A; Kab; Nb}Kbs \nMessage 4 A -> B: {A; Kab; Nb}Kbs ; {Nb}Kab\n\nAttack of Syverson, A taxonomy of replay attacks\n\n*)\n\npred c/1 elimVar, ____(PRED_0)____.\nnounif c:x.\n\nfun encrypt/2.\nfun ____(FUN_0)____/1.\n\nquery A:x,____(QUERY_0)____.\n\n(* param maxDepth = 6. *)\n\nnot c:Kas[].\nnot c:Kbs[].\n\nreduc\n\n(* attacker *)\n\nc:c[];\nc:____(OP_1)____ -> c:host(k);\nc:k & c:m -> c:encrypt(m,k);\nc:k & c:encrypt(m,k) -> c:m;\nc:host(Kas[]);\nc:host(Kbs[]);\n\n(* A *)\n\nc:(host(Kas[]), Na[i]);\nc:(nb, encrypt((b, k, Na[i]), Kas[]), mb) -> c:(mb, encrypt(nb, k));\nc:(____(MESSAGE_4)____, encrypt((host(____(MESSAGE_6)____[]), ____(MESSAGE_5)____, Na[____(MESSAGE_8)____]), Kas[]), mb) -> A:____(MESSAGE_7)____, encrypt((host(Kbs[]), k, ____(OP_2)____[i]), Kas[]);\n\n(* B *)\n\n____(MESSAGE_1)____:(____(MESSAGE_0)____, na) -> ____(MESSAGE_3)____:(host(Kbs[]), Nb[a, na, ____(MESSAGE_2)____], encrypt((____(OP_0)____, na), Kbs[]));\n\n(* S *)\n\nc:(host(kbs), nb, encrypt((host(kas), na), kbs)) -> c:(nb, encrypt((host(____(OP_5)____), k[____(OP_3)____, kbs, na, nb], na), ____(OP_4)____), encrypt((host(kas),  k[kas, kbs, na, nb], nb), kbs)).",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Simpler Yahalom protocol\nVersion of Burrows, Abadi, Needham, SRC039\n\nMessage 1 A -> B: A; Na \nMessage 2 B -> S: B; Nb; {A; Na}Kbs \nMessage 3 S -> A: Nb; {B; Kab; Na}Kas ; {A; Kab; Nb}Kbs \nMessage 4 A -> B: {A; Kab; Nb}Kbs ; {Nb}Kab\n\nAttack of Syverson, A taxonomy of replay attacks\n\n*)\n\npred c/1 elimVar, decompData.\nnounif c:x.\n\nfun encrypt/2.\nfun host/1.\n\nquery A:x,y.\n\n(* param maxDepth = 6. *)\n\nnot c:Kas[].\nnot c:Kbs[].\n\nreduc\n\n(* attacker *)\n\nc:c[];\nc:k -> c:host(k);\nc:k & c:m -> c:encrypt(m,k);\nc:k & c:encrypt(m,k) -> c:m;\nc:host(Kas[]);\nc:host(Kbs[]);\n\n(* A *)\n\nc:(host(Kas[]), Na[i]);\nc:(nb, encrypt((b, k, Na[i]), Kas[]), mb) -> c:(mb, encrypt(nb, k));\nc:(nb, encrypt((host(Kbs[]), k, Na[i]), Kas[]), mb) -> A:nb, encrypt((host(Kbs[]), k, Na[i]), Kas[]);\n\n(* B *)\n\nc:(a, na) -> c:(host(Kbs[]), Nb[a, na, j], encrypt((a, na), Kbs[]));\n\n(* S *)\n\nc:(host(kbs), nb, encrypt((host(kas), na), kbs)) -> c:(nb, encrypt((host(kbs), k[kas, kbs, na, nb], na), kas), encrypt((host(kas),  k[kas, kbs, na, nb], nb), kbs))."
    },
    {
        "file": "PV-1/sissi_unforgeable_VC.pv",
        "incomplete": "(* This is a ProVerif description of the Protocol Flow from the SISSI architecture. *)\n\n(* START keys *)\ntype ____(TYPE_0)____.\ntype PublicKey.\nfun pk(SecretKey):PublicKey.\n(* END keys *)\n\n(* START asymmetric encryption *)\nfun aenc(bitstring(*the message*), PublicKey):bitstring (*asymmetric encrypt input msg*).\nreduc forall msg:bitstring,sk:SecretKey; adec(aenc(msg,pk(sk)),sk)=msg (*asymmetric decrypt*).\n(* END Asymmetric encryption *)\n\n(* START digital signature *)\nfun sig(bitstring(*the message*), SecretKey):bitstring(*the signature value*).\nreduc forall msg:bitstring,sk:SecretKey; check(msg,sig(msg,sk),pk(sk))=true (*check(msg,sigVal,pk)*).\n(* END digital signature *)\n\n(* START DID *)\ntype DID.\nfun genDID(PublicKey,SecretKey(*such that DID can not be inferred by others*)):DID.\nreduc forall sk:SecretKey; getPubKey(genDID(pk(sk),sk)) = pk(sk). (* as of page 129 of manual *)\n(* this implies that a DID may only be associated to only one pubKey, which is not true => model as table*)\n(* but tables do not seem to be publically available? as of page 41 of manual *)\n(* END DID *)\n\n(* START credential *)\n(*\nVC = (claims, sig(claims, sk) )\n*)\n(* END credential *)\n\n(* START access control rule (ACR) *)\n(*\nACR = (attr, DID_I)\n*)\n(* END access control rule *)\n\n(*DEFS*)\nfree ____(FREE_9)____:channel.\nconst ____(CONST_0)____:bitstring.\nconst uri:bitstring.\n\nfun ch(____(FUN_0)____): channel.\n\nfree m'_0_fromHolder: bitstring [private].\nfree m'_2_fromHolder: bitstring [private].\nfree cred_fromHolder: bitstring [private].\n\nfree m'_1_fromIssuer: bitstring [private].\nfree m'_3_fromIssuer: bitstring [private]. \nfree ____(FREE_1)____: bitstring [private].\n\nfree m'_4_fromProver: bitstring [private].\nfree m'_6_fromProver: bitstring [private].\nfree rule_fromProver: ____(FREE_8)____ [private].\nfree m'_8_fromProver: bitstring [private].\nfree cred_fromProver: bitstring [private].\nfree access_token_fromProver: bitstring [____(FREE_2)____].\n\nfree m'_5_fromVerifier: bitstring [private].\nfree rule_fromVerifier: ____(FREE_0)____ [private].\nfree m'_7_fromVerifier: bitstring [private].\nfree vp_fromVerifier: bitstring [private].\nfree cred_fromVerifier: bitstring [____(FREE_7)____].\nfree m'_9_fromVerifier: bitstring [____(FREE_6)____].\nfree access_token_fromVerifier: bitstring [private].\n\nfree Issuer_Completes:bitstring [private].\nfree ____(OP_77)____:bitstring [private].\nfree ____(OP_24)____:____(FREE_4)____ [private].\nfree ____(FREE_5)____:bitstring [private].\n\n\n(* Authentication *)\nevent auth_VerifierSendsLastMessageToProver(____(OP_72)____,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverCompletesProtocol(bitstring,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverSendsLastMessageToVerifier(bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_VerifierCompletesProtocol(bitstring).\n\nevent auth_IssuerSendsLastMessageToHolder(bitstring).\nevent auth_HolderCompletesProtocol(bitstring,bitstring,bitstring,bitstring).\nevent auth_HolderSendsLastMessageToIssuer(bitstring,bitstring,bitstring).\nevent auth_IssuerCompletesProtocol(bitstring,bitstring,bitstring).\n\nevent auth_ProverSendsLastMessageToVerifierInProtocolFull(____(OP_25)____,____(OP_26)____,____(OP_27)____,bitstring,bitstring, bitstring, bitstring,bitstring,bitstring).\n\n(* START process macros ~ agent *)\n\n(** START Prover **)\nlet prover(DID_P:DID, sk_P:SecretKey, VC:bitstring, DID_V:DID, pk_V:PublicKey, talksOnlyToHonest:bool, m_0:bitstring,m_1:bitstring,m_2:bitstring,m_3:bitstring) (* input ~ what the agent starts with in private*) =\n    new ____(OP_6)____:____(NEW_0)____;                          \n    new n_p:____(NEW_2)____;\n    let m'_4 = (n_p,pk(ssk_P)) in\n    let m_4 = aenc( ( m'_4, sig(m'_4,____(OP_2)____) ) ,pk_V) in\n    out(____(OP_71)____, m_4);\n    (**)\n    (**)\n    (* receive let m_5 = aenc( (m'_5,sig(m'_5,sk_V)),spk_P) in *)\n    in(h,____(OP_51)____:bitstring);\n    let ((n'_p:bitstring,n_v:bitstring,spk_V:PublicKey),sigVal_5:bitstring) = adec(m_5,ssk_P) in\n    if check((____(IF_8)____,n_v,____(IF_7)____),sigVal_5,pk_V) then\n    if ____(IF_3)____ = n_p then\n    let m'_6 = (n_v,uri) in\n    let m_6 = aenc( ( ____(OP_8)____, sig(m'_6,____(OP_9)____) ) ,spk_V) in\n    out(h, m_6);\n    (**)\n    (**)\n    (* receive let m_7 = aenc( (m'_7,sig(m'_7,ssk_V)),spk_P) in *)\n    in(h,____(OP_49)____:bitstring);\n    let ((n_c:____(LET_36)____,____(LET_37)____:bitstring),____(LET_38)____:bitstring) = adec(m_7,____(OP_43)____) in\n    if check((n_c,rule),sigVal_7,spk_V) then\n    let (____(LET_35)____:bitstring,sigVal_VC:bitstring)=____(LET_34)____ in\n    if claims = rule then\n    let m''_8 = (n_c,DID_V,VC) in\n    let m'_8 = (____(LET_20)____, sig(m''_8,____(OP_74)____) ) in\n    let m_8 = aenc( ( m'_8, sig(m'_8,ssk_P) ) ,spk_V) in\n    (* event_just_before_the_last_send_message_of_S  *)\n    event auth_ProverSendsLastMessageToVerifier(m_4,m_5,m_6,m_7,m_8);\n    event auth_ProverSendsLastMessageToVerifierInProtocolFull(m_0,m_1,m_2,m_3, m_4,m_5,m_6,m_7,m_8);\n    out(h, ____(OP_3)____);\n    (**)\n    (**)\n    in(h,m_9:bitstring);\n    let ((____(LET_53)____:____(LET_55)____,sigVal_tkn:bitstring),sigVal_9:bitstring) = adec(m_9,____(LET_54)____) in\n    if check((____(OP_30)____,sigVal_tkn),sigVal_9,____(IF_0)____) then\n    if check(____(OP_15)____,sigVal_tkn,pk_V) then\n    (* Prover about to complete protocol! *)\n    out(h, Prover_Completes);\n    (* phase 1 ; *)\n    if ____(IF_15)____ then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_ProverCompletesProtocol(m_4,____(OP_19)____,____(OP_18)____,m_7,m_8,m_9) |\n    out(ch(( m'_4, sig(m'_4,ssk_P) )),m'_4_fromProver) |\n    out(ch(( m'_6, sig(m'_6,ssk_P) )),m'_6_fromProver) |\n    out(ch(( m'_8, sig(m'_8,ssk_P) )), m'_8_fromProver) | (*VP*)\n    out(ch(VC),cred_fromProver) |\n    out(ch(tkn_access),access_token_fromProver);\n    0.\n(** END Prover **)\n\n(** START Verifier **)\nlet verifier(DID_V:DID, sk_V:SecretKey, rule:bitstring, pk_P:PublicKey, pk_I:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    let ( DID_P:____(LET_41)____, attr:bitstring, DID_I:DID ) = ____(LET_40)____ in\n    (* receive  m_4 = aenc( ( m'_4, sig(m'_4,ssk_p) ) ,pk_V) in *)\n    in(h,m_4:bitstring);\n    let ((____(LET_18)____:____(LET_19)____,spk_P:____(LET_17)____),sigVal_4:bitstring) = adec(____(OP_7)____,sk_V) in\n    if check((n_p,spk_P),sigVal_4,spk_P) then  \n    new ssk_V:SecretKey;                          \n    new n_v:bitstring;\n    let m'_5 = (n_p,n_v,pk(ssk_V)) in\n    let m_5 = aenc( (m'_5,sig(m'_5,____(OP_44)____)),spk_P) in\n    out(h,m_5); \n    (**)\n    (**)\n    (* receive let m_6 = aenc( (m'_6,sig(m'_6,ssk_P)),spk_V) in *)\n    in(h,m_6:bitstring);\n    let ((n'_v:____(LET_21)____,uri':____(LET_23)____),____(LET_22)____:bitstring) = adec(m_6,____(OP_20)____) in\n    if check((n'_v,uri'),sigVal_6,spk_P) then\n    if (n'_v, uri') = (____(IF_5)____, uri) then\n    new n_c:bitstring;\n    let m'_7 = (n_c,rule) in\n    let m_7 = aenc( ( m'_7, sig(m'_7,ssk_V) ) ,spk_P) in\n    out(h, m_7);\n    (**)\n    (**)\n    (* receive let m_8 = aenc( (m'_8,sig(m'_8,ssk_P)),spk_V) in *)\n    in(h,m_8:bitstring);\n    let (((____(LET_51)____:____(LET_50)____,____(LET_52)____'_V:DID,((____(LET_49)____:DID,attr':bitstring,____(LET_46)____:DID), ____(LET_48)____:bitstring)), sigVal_P:bitstring), sigVal_8:bitstring) = adec(____(LET_47)____,ssk_V) in\n    if check(((____(IF_11)____,____(IF_10)____,((____(IF_9)____,____(IF_12)____,DID'_I), sigVal_I)), sigVal_P ),sigVal_8,spk_P) then\n    if check((n'_c,DID'_V,((DID'_P,attr',DID'_I), sigVal_I)), sigVal_P ,pk_P) then\n    if check((DID'_P,attr',____(IF_13)____), sigVal_I,____(IF_14)____) then\n    if (n'_c,DID'_V,(DID'_P,attr',DID'_I)) = (n_c,DID_V,(DID_P,attr,DID_I)) then\n    new tkn_access:bitstring;\n    let m'_9 = (tkn_access, sig(tkn_access,sk_V)) in\n    let m_9 = aenc( (____(LET_1)____,sig(m'_9,____(LET_0)____)),spk_P) in\n    (* event_just_before_the_last_send_message_of_S  *)\n    event auth_VerifierSendsLastMessageToProver(m_4,m_5,____(OP_52)____,m_7,____(OP_53)____,m_9);\n    out(h, m_9);\n    (* Verifier about to complete the protocol *)\n    out(h, Verifier_Completes);\n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_VerifierCompletesProtocol(sigVal_I) |\n    out(ch((m'_5,sig(m'_5,sk_V))),m'_5_fromVerifier) |\n    out(ch(rule), ____(OP_66)____) |\n    out(ch( ( m'_7, sig(m'_7,ssk_V) )), m'_7_fromVerifier) |\n    out(ch((n'_c,DID'_V,(DID'_P,attr',DID'_I, sigVal_I), sigVal_P)),vp_fromVerifier) |\n    out(ch((DID'_P,attr',____(OP_23)____, ____(OP_22)____)),cred_fromVerifier) |\n    out(ch( ( ____(OP_45)____, sig(m'_9,ssk_V) )), m'_9_fromVerifier) |\n    out(ch(tkn_access),access_token_fromVerifier);\n    0.\n(** END Verifier **)\n\n(** START Holder/Prover **)\nlet holder(DID_P:DID, sk_P:SecretKey, DID_I:DID, pk_I:PublicKey, DID_V:DID, pk_V:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    new ssk_P:SecretKey;                          \n    new n_p:____(NEW_4)____;\n    let m'_0 = (n_p,pk(ssk_P)) in\n    let m_0 = aenc( ( m'_0, sig(m'_0,____(OP_68)____) ) ,pk_I) in\n    out(____(OP_50)____, m_0);\n    (**)\n    (**)\n    (* receive let m_1 = aenc( (m'_1,sig(m'_1,sk_I)),spk_P) in *)\n    in(h,____(OP_4)____:bitstring);\n    let ((n'_p:bitstring,n_i:bitstring,spk_I:PublicKey),sigVal_1:bitstring) = adec(m_1,____(OP_76)____) in\n    if check((n'_p,n_i,____(IF_1)____),sigVal_1,____(IF_2)____) then\n    if n'_p = n_p then\n    new n_h:bitstring;\n    let m''_2 = (n_i,____(LET_16)____,____(LET_15)____,n_h) in\n    let m'_2 = (m''_2, sig(m''_2,sk_P)) in\n    let m_2 = aenc( ( ____(OP_1)____, sig(m'_2,ssk_P) ) ,spk_I) in\n    (* event_just_before_the_last_send_message_of_S  *) \n    event auth_HolderSendsLastMessageToIssuer(m_0,m_1,m_2);\n    out(____(OP_75)____, m_2);\n    (**)\n    (**)\n    (* receive let m_3 = aenc( (m'_3,sig(m'_3,ssk_I)),spk_P) in *)\n    in(h,m_3:bitstring);\n    let (((((DID'_P:DID,attr':bitstring,DID'_I:DID), sigVal_I:bitstring),DID''_P:DID,n'_h:bitstring),sigVal'_I:bitstring), sigVal_3:bitstring)  = adec(m_3,____(OP_70)____) in\n    if check(((((DID'_P,attr',DID'_I), sigVal_I), DID''_P, n'_h),sigVal'_I),sigVal_3,spk_I) then\n    if check((((DID'_P,attr',DID'_I), sigVal_I), DID''_P,n'_h),sigVal'_I, pk_I) then\n    if (DID''_P,n'_h) = (____(IF_6)____,n_h) then\n    if check((DID'_P,____(OP_10)____,DID'_I), sigVal_I, ____(OP_11)____) then\n    if (DID'_P, DID'_I)= (DID_P, DID_I) then\n    (* Holder about to complete the Protocol *)\n    out(h, Holder_Completes);\n\n    !prover(____(OP_40)____, sk_P, ((DID'_P,attr',DID'_I), ____(OP_38)____), ____(OP_37)____, pk_V, talksOnlyToHonest, ____(OP_39)____,m_1,m_2,____(OP_36)____) |\n   \n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    event auth_HolderCompletesProtocol(m_0,m_1,m_2,m_3) | \n    out(ch(( m'_0, sig(m'_0,ssk_P) )),m'_0_fromHolder) |\n    out(ch(( m'_2, sig(m'_2,ssk_P) )),m'_2_fromHolder) |\n    out(ch(((DID'_P,attr,DID'_I), sigVal_I)),cred_fromHolder); (*currently public anyway...?*)\n    0.\n(** END Holder/Prover **)\n\n(** START Issuer **)\nlet issuer(DID_I:DID, sk_I:SecretKey, attr:bitstring, DID_P:DID, pk_P:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    (* receive  m_0 = aenc( ( m'_0, sig(m'_0,ssk_p) ) ,pk_I) in *)\n    in(h,m_0:bitstring);\n    let ((n_p:bitstring,spk_P:PublicKey),sigVal_0:bitstring) = adec(m_0,sk_I) in\n    if check((____(IF_4)____,____(OP_65)____),sigVal_0,spk_P) then  \n    new ____(NEW_3)____:SecretKey;                          \n    new ____(NEW_1)____:bitstring;\n    let m'_1 = (n_p,n_i,pk(ssk_I)) in\n    let m_1 = aenc( (____(LET_39)____,sig(m'_1,sk_I)),spk_P) in\n    out(h,m_1); \n    (**)\n    (**)\n    (* receive let m_2 = aenc( ( m'_2, sig(m'_2,ssk_P) ) ,spk_I) in *)\n    in(h,m_2:bitstring);\n    let (((n'_i:____(LET_13)____,____(LET_11)____:____(LET_14)____,DID'_I:DID,n_h:bitstring),____(LET_12)____:bitstring),sigVal_2:bitstring) = adec(____(OP_46)____,ssk_I) in\n    if check(((n'_i,____(IF_16)____,DID'_I,____(IF_17)____),sigVal_P),____(OP_16)____,____(OP_17)____) then\n    if check((n'_i,DID'_P,DID'_I,n_h),sigVal_P,pk_P) then\n    if (n'_i,DID'_P,DID'_I) = (n_i,DID_P,DID_I) then \n    let claims = (DID_P,____(LET_2)____,DID_I) in\n    let VC = (claims, sig(claims, ____(OP_5)____) ) in\n    let ____(LET_45)____ = ((____(LET_43)____,____(LET_44)____,n_h), sig((VC,DID_P,n_h),sk_I)) in\n    let m_3 = aenc( (____(OP_41)____,sig(____(OP_42)____,ssk_I)),spk_P) in\n    (* event_just_before_the_last_send_message_of_S *)\n    event auth_IssuerSendsLastMessageToHolder(sig(____(OP_47)____, sk_I));\n    out(h, m_3);\n    (* Issuer about to complete the protocol *)\n    out(h, ____(OP_64)____);\n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    event auth_IssuerCompletesProtocol(m_0,m_1,m_2) | \n    out(ch((m'_1,sig(m'_1,sk_I))),m'_1_fromIssuer) |\n    out(ch(VC),cred_fromIssuer) | (* currently public anyway ...? *)\n    out(ch((m'_3,sig(m'_3,ssk_I))),m'_3_fromIssuer);\n    0.\n(** END Issuer **)\n\n(* END process macros *)\n\n(*\nquery attacker(Issuer_Completes).\nquery attacker(Holder_Completes).\nquery attacker(Prover_Completes).\nquery attacker(Verifier_Completes).\n*)\n\n\n(* AUTHETNICATION *)\n\n(* credentials are not forgeable, even if prover/holder is fully compromised *)\nquery  VC:bitstring; \n    event(auth_VerifierCompletesProtocol(____(OP_35)____))\n    ==>\n    event(auth_IssuerSendsLastMessageToHolder(VC)) \n    .\n\n(* MAIN *)\n\n\n\nfree sk_E:SecretKey. (*other agent may or may not be honest, but we don't know*)\nprocess (*use root process for setup *)\n    (*declare secret keys*)\n    new sk_I:SecretKey;\n    new sk_V:SecretKey;\n    (*advertise public keys*)\n    out(h,pk(sk_I));\n    out(____(OP_67)____,pk(sk_V));\n    (*advertise DIDs*)\n    let DID_I = genDID(pk(____(OP_73)____),sk_I) in\n    let DID_V = genDID(pk(sk_V),sk_V) in\n    let ____(LET_42)____ = genDID(pk(____(OP_29)____),____(OP_55)____) in\n    out(____(OP_69)____,DID_I);\n    out(h,DID_V);\n    out(h,DID_E);\n    \n    let ____(LET_24)____ = ( DID_E, attr, ____(LET_25)____ ) in \n    let rule_EE = ( DID_E, attr, DID_E ) in\n\n    (*let agents dance*)\n    ( (\n         !issuer   (DID_I, sk_I, attr, DID_E, pk(sk_E), false)  \n       | !verifier (DID_V, sk_V, rule_EI, pk(sk_E), pk(sk_I), true)    \n       | !verifier (DID_V, sk_V, rule_EE, pk(sk_E), pk(sk_E), false) \n    ) )",
        "complete:": "(* This is a ProVerif description of the Protocol Flow from the SISSI architecture. *)\n\n(* START keys *)\ntype SecretKey.\ntype PublicKey.\nfun pk(SecretKey):PublicKey.\n(* END keys *)\n\n(* START asymmetric encryption *)\nfun aenc(bitstring(*the message*), PublicKey):bitstring (*asymmetric encrypt input msg*).\nreduc forall msg:bitstring,sk:SecretKey; adec(aenc(msg,pk(sk)),sk)=msg (*asymmetric decrypt*).\n(* END Asymmetric encryption *)\n\n(* START digital signature *)\nfun sig(bitstring(*the message*), SecretKey):bitstring(*the signature value*).\nreduc forall msg:bitstring,sk:SecretKey; check(msg,sig(msg,sk),pk(sk))=true (*check(msg,sigVal,pk)*).\n(* END digital signature *)\n\n(* START DID *)\ntype DID.\nfun genDID(PublicKey,SecretKey(*such that DID can not be inferred by others*)):DID.\nreduc forall sk:SecretKey; getPubKey(genDID(pk(sk),sk)) = pk(sk). (* as of page 129 of manual *)\n(* this implies that a DID may only be associated to only one pubKey, which is not true => model as table*)\n(* but tables do not seem to be publically available? as of page 41 of manual *)\n(* END DID *)\n\n(* START credential *)\n(*\nVC = (claims, sig(claims, sk) )\n*)\n(* END credential *)\n\n(* START access control rule (ACR) *)\n(*\nACR = (attr, DID_I)\n*)\n(* END access control rule *)\n\n(*DEFS*)\nfree h:channel.\nconst attr:bitstring.\nconst uri:bitstring.\n\nfun ch(bitstring): channel.\n\nfree m'_0_fromHolder: bitstring [private].\nfree m'_2_fromHolder: bitstring [private].\nfree cred_fromHolder: bitstring [private].\n\nfree m'_1_fromIssuer: bitstring [private].\nfree m'_3_fromIssuer: bitstring [private]. \nfree cred_fromIssuer: bitstring [private].\n\nfree m'_4_fromProver: bitstring [private].\nfree m'_6_fromProver: bitstring [private].\nfree rule_fromProver: bitstring [private].\nfree m'_8_fromProver: bitstring [private].\nfree cred_fromProver: bitstring [private].\nfree access_token_fromProver: bitstring [private].\n\nfree m'_5_fromVerifier: bitstring [private].\nfree rule_fromVerifier: bitstring [private].\nfree m'_7_fromVerifier: bitstring [private].\nfree vp_fromVerifier: bitstring [private].\nfree cred_fromVerifier: bitstring [private].\nfree m'_9_fromVerifier: bitstring [private].\nfree access_token_fromVerifier: bitstring [private].\n\nfree Issuer_Completes:bitstring [private].\nfree Holder_Completes:bitstring [private].\nfree Prover_Completes:bitstring [private].\nfree Verifier_Completes:bitstring [private].\n\n\n(* Authentication *)\nevent auth_VerifierSendsLastMessageToProver(bitstring,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverCompletesProtocol(bitstring,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverSendsLastMessageToVerifier(bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_VerifierCompletesProtocol(bitstring).\n\nevent auth_IssuerSendsLastMessageToHolder(bitstring).\nevent auth_HolderCompletesProtocol(bitstring,bitstring,bitstring,bitstring).\nevent auth_HolderSendsLastMessageToIssuer(bitstring,bitstring,bitstring).\nevent auth_IssuerCompletesProtocol(bitstring,bitstring,bitstring).\n\nevent auth_ProverSendsLastMessageToVerifierInProtocolFull(bitstring,bitstring,bitstring,bitstring,bitstring, bitstring, bitstring,bitstring,bitstring).\n\n(* START process macros ~ agent *)\n\n(** START Prover **)\nlet prover(DID_P:DID, sk_P:SecretKey, VC:bitstring, DID_V:DID, pk_V:PublicKey, talksOnlyToHonest:bool, m_0:bitstring,m_1:bitstring,m_2:bitstring,m_3:bitstring) (* input ~ what the agent starts with in private*) =\n    new ssk_P:SecretKey;                          \n    new n_p:bitstring;\n    let m'_4 = (n_p,pk(ssk_P)) in\n    let m_4 = aenc( ( m'_4, sig(m'_4,ssk_P) ) ,pk_V) in\n    out(h, m_4);\n    (**)\n    (**)\n    (* receive let m_5 = aenc( (m'_5,sig(m'_5,sk_V)),spk_P) in *)\n    in(h,m_5:bitstring);\n    let ((n'_p:bitstring,n_v:bitstring,spk_V:PublicKey),sigVal_5:bitstring) = adec(m_5,ssk_P) in\n    if check((n'_p,n_v,spk_V),sigVal_5,pk_V) then\n    if n'_p = n_p then\n    let m'_6 = (n_v,uri) in\n    let m_6 = aenc( ( m'_6, sig(m'_6,ssk_P) ) ,spk_V) in\n    out(h, m_6);\n    (**)\n    (**)\n    (* receive let m_7 = aenc( (m'_7,sig(m'_7,ssk_V)),spk_P) in *)\n    in(h,m_7:bitstring);\n    let ((n_c:bitstring,rule:bitstring),sigVal_7:bitstring) = adec(m_7,ssk_P) in\n    if check((n_c,rule),sigVal_7,spk_V) then\n    let (claims:bitstring,sigVal_VC:bitstring)=VC in\n    if claims = rule then\n    let m''_8 = (n_c,DID_V,VC) in\n    let m'_8 = (m''_8, sig(m''_8,sk_P) ) in\n    let m_8 = aenc( ( m'_8, sig(m'_8,ssk_P) ) ,spk_V) in\n    (* event_just_before_the_last_send_message_of_S  *)\n    event auth_ProverSendsLastMessageToVerifier(m_4,m_5,m_6,m_7,m_8);\n    event auth_ProverSendsLastMessageToVerifierInProtocolFull(m_0,m_1,m_2,m_3, m_4,m_5,m_6,m_7,m_8);\n    out(h, m_8);\n    (**)\n    (**)\n    in(h,m_9:bitstring);\n    let ((tkn_access:bitstring,sigVal_tkn:bitstring),sigVal_9:bitstring) = adec(m_9,ssk_P) in\n    if check((tkn_access,sigVal_tkn),sigVal_9,spk_V) then\n    if check(tkn_access,sigVal_tkn,pk_V) then\n    (* Prover about to complete protocol! *)\n    out(h, Prover_Completes);\n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_ProverCompletesProtocol(m_4,m_5,m_6,m_7,m_8,m_9) |\n    out(ch(( m'_4, sig(m'_4,ssk_P) )),m'_4_fromProver) |\n    out(ch(( m'_6, sig(m'_6,ssk_P) )),m'_6_fromProver) |\n    out(ch(( m'_8, sig(m'_8,ssk_P) )), m'_8_fromProver) | (*VP*)\n    out(ch(VC),cred_fromProver) |\n    out(ch(tkn_access),access_token_fromProver);\n    0.\n(** END Prover **)\n\n(** START Verifier **)\nlet verifier(DID_V:DID, sk_V:SecretKey, rule:bitstring, pk_P:PublicKey, pk_I:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    let ( DID_P:DID, attr:bitstring, DID_I:DID ) = rule in\n    (* receive  m_4 = aenc( ( m'_4, sig(m'_4,ssk_p) ) ,pk_V) in *)\n    in(h,m_4:bitstring);\n    let ((n_p:bitstring,spk_P:PublicKey),sigVal_4:bitstring) = adec(m_4,sk_V) in\n    if check((n_p,spk_P),sigVal_4,spk_P) then  \n    new ssk_V:SecretKey;                          \n    new n_v:bitstring;\n    let m'_5 = (n_p,n_v,pk(ssk_V)) in\n    let m_5 = aenc( (m'_5,sig(m'_5,sk_V)),spk_P) in\n    out(h,m_5); \n    (**)\n    (**)\n    (* receive let m_6 = aenc( (m'_6,sig(m'_6,ssk_P)),spk_V) in *)\n    in(h,m_6:bitstring);\n    let ((n'_v:bitstring,uri':bitstring),sigVal_6:bitstring) = adec(m_6,ssk_V) in\n    if check((n'_v,uri'),sigVal_6,spk_P) then\n    if (n'_v, uri') = (n_v, uri) then\n    new n_c:bitstring;\n    let m'_7 = (n_c,rule) in\n    let m_7 = aenc( ( m'_7, sig(m'_7,ssk_V) ) ,spk_P) in\n    out(h, m_7);\n    (**)\n    (**)\n    (* receive let m_8 = aenc( (m'_8,sig(m'_8,ssk_P)),spk_V) in *)\n    in(h,m_8:bitstring);\n    let (((n'_c:bitstring,DID'_V:DID,((DID'_P:DID,attr':bitstring,DID'_I:DID), sigVal_I:bitstring)), sigVal_P:bitstring), sigVal_8:bitstring) = adec(m_8,ssk_V) in\n    if check(((n'_c,DID'_V,((DID'_P,attr',DID'_I), sigVal_I)), sigVal_P ),sigVal_8,spk_P) then\n    if check((n'_c,DID'_V,((DID'_P,attr',DID'_I), sigVal_I)), sigVal_P ,pk_P) then\n    if check((DID'_P,attr',DID'_I), sigVal_I,pk_I) then\n    if (n'_c,DID'_V,(DID'_P,attr',DID'_I)) = (n_c,DID_V,(DID_P,attr,DID_I)) then\n    new tkn_access:bitstring;\n    let m'_9 = (tkn_access, sig(tkn_access,sk_V)) in\n    let m_9 = aenc( (m'_9,sig(m'_9,ssk_V)),spk_P) in\n    (* event_just_before_the_last_send_message_of_S  *)\n    event auth_VerifierSendsLastMessageToProver(m_4,m_5,m_6,m_7,m_8,m_9);\n    out(h, m_9);\n    (* Verifier about to complete the protocol *)\n    out(h, Verifier_Completes);\n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_VerifierCompletesProtocol(sigVal_I) |\n    out(ch((m'_5,sig(m'_5,sk_V))),m'_5_fromVerifier) |\n    out(ch(rule), rule_fromVerifier) |\n    out(ch( ( m'_7, sig(m'_7,ssk_V) )), m'_7_fromVerifier) |\n    out(ch((n'_c,DID'_V,(DID'_P,attr',DID'_I, sigVal_I), sigVal_P)),vp_fromVerifier) |\n    out(ch((DID'_P,attr',DID'_I, sigVal_I)),cred_fromVerifier) |\n    out(ch( ( m'_9, sig(m'_9,ssk_V) )), m'_9_fromVerifier) |\n    out(ch(tkn_access),access_token_fromVerifier);\n    0.\n(** END Verifier **)\n\n(** START Holder/Prover **)\nlet holder(DID_P:DID, sk_P:SecretKey, DID_I:DID, pk_I:PublicKey, DID_V:DID, pk_V:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    new ssk_P:SecretKey;                          \n    new n_p:bitstring;\n    let m'_0 = (n_p,pk(ssk_P)) in\n    let m_0 = aenc( ( m'_0, sig(m'_0,ssk_P) ) ,pk_I) in\n    out(h, m_0);\n    (**)\n    (**)\n    (* receive let m_1 = aenc( (m'_1,sig(m'_1,sk_I)),spk_P) in *)\n    in(h,m_1:bitstring);\n    let ((n'_p:bitstring,n_i:bitstring,spk_I:PublicKey),sigVal_1:bitstring) = adec(m_1,ssk_P) in\n    if check((n'_p,n_i,spk_I),sigVal_1,pk_I) then\n    if n'_p = n_p then\n    new n_h:bitstring;\n    let m''_2 = (n_i,DID_P,DID_I,n_h) in\n    let m'_2 = (m''_2, sig(m''_2,sk_P)) in\n    let m_2 = aenc( ( m'_2, sig(m'_2,ssk_P) ) ,spk_I) in\n    (* event_just_before_the_last_send_message_of_S  *) \n    event auth_HolderSendsLastMessageToIssuer(m_0,m_1,m_2);\n    out(h, m_2);\n    (**)\n    (**)\n    (* receive let m_3 = aenc( (m'_3,sig(m'_3,ssk_I)),spk_P) in *)\n    in(h,m_3:bitstring);\n    let (((((DID'_P:DID,attr':bitstring,DID'_I:DID), sigVal_I:bitstring),DID''_P:DID,n'_h:bitstring),sigVal'_I:bitstring), sigVal_3:bitstring)  = adec(m_3,ssk_P) in\n    if check(((((DID'_P,attr',DID'_I), sigVal_I), DID''_P, n'_h),sigVal'_I),sigVal_3,spk_I) then\n    if check((((DID'_P,attr',DID'_I), sigVal_I), DID''_P,n'_h),sigVal'_I, pk_I) then\n    if (DID''_P,n'_h) = (DID_P,n_h) then\n    if check((DID'_P,attr',DID'_I), sigVal_I, pk_I) then\n    if (DID'_P, DID'_I)= (DID_P, DID_I) then\n    (* Holder about to complete the Protocol *)\n    out(h, Holder_Completes);\n\n    !prover(DID_P, sk_P, ((DID'_P,attr',DID'_I), sigVal_I), DID_V, pk_V, talksOnlyToHonest, m_0,m_1,m_2,m_3) |\n   \n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    event auth_HolderCompletesProtocol(m_0,m_1,m_2,m_3) | \n    out(ch(( m'_0, sig(m'_0,ssk_P) )),m'_0_fromHolder) |\n    out(ch(( m'_2, sig(m'_2,ssk_P) )),m'_2_fromHolder) |\n    out(ch(((DID'_P,attr,DID'_I), sigVal_I)),cred_fromHolder); (*currently public anyway...?*)\n    0.\n(** END Holder/Prover **)\n\n(** START Issuer **)\nlet issuer(DID_I:DID, sk_I:SecretKey, attr:bitstring, DID_P:DID, pk_P:PublicKey, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    (* receive  m_0 = aenc( ( m'_0, sig(m'_0,ssk_p) ) ,pk_I) in *)\n    in(h,m_0:bitstring);\n    let ((n_p:bitstring,spk_P:PublicKey),sigVal_0:bitstring) = adec(m_0,sk_I) in\n    if check((n_p,spk_P),sigVal_0,spk_P) then  \n    new ssk_I:SecretKey;                          \n    new n_i:bitstring;\n    let m'_1 = (n_p,n_i,pk(ssk_I)) in\n    let m_1 = aenc( (m'_1,sig(m'_1,sk_I)),spk_P) in\n    out(h,m_1); \n    (**)\n    (**)\n    (* receive let m_2 = aenc( ( m'_2, sig(m'_2,ssk_P) ) ,spk_I) in *)\n    in(h,m_2:bitstring);\n    let (((n'_i:bitstring,DID'_P:DID,DID'_I:DID,n_h:bitstring),sigVal_P:bitstring),sigVal_2:bitstring) = adec(m_2,ssk_I) in\n    if check(((n'_i,DID'_P,DID'_I,n_h),sigVal_P),sigVal_2,spk_P) then\n    if check((n'_i,DID'_P,DID'_I,n_h),sigVal_P,pk_P) then\n    if (n'_i,DID'_P,DID'_I) = (n_i,DID_P,DID_I) then \n    let claims = (DID_P,attr,DID_I) in\n    let VC = (claims, sig(claims, sk_I) ) in\n    let m'_3 = ((VC,DID_P,n_h), sig((VC,DID_P,n_h),sk_I)) in\n    let m_3 = aenc( (m'_3,sig(m'_3,ssk_I)),spk_P) in\n    (* event_just_before_the_last_send_message_of_S *)\n    event auth_IssuerSendsLastMessageToHolder(sig(claims, sk_I));\n    out(h, m_3);\n    (* Issuer about to complete the protocol *)\n    out(h, Issuer_Completes);\n    (* phase 1 ; *)\n    if talksOnlyToHonest then\n    event auth_IssuerCompletesProtocol(m_0,m_1,m_2) | \n    out(ch((m'_1,sig(m'_1,sk_I))),m'_1_fromIssuer) |\n    out(ch(VC),cred_fromIssuer) | (* currently public anyway ...? *)\n    out(ch((m'_3,sig(m'_3,ssk_I))),m'_3_fromIssuer);\n    0.\n(** END Issuer **)\n\n(* END process macros *)\n\n(*\nquery attacker(Issuer_Completes).\nquery attacker(Holder_Completes).\nquery attacker(Prover_Completes).\nquery attacker(Verifier_Completes).\n*)\n\n\n(* AUTHETNICATION *)\n\n(* credentials are not forgeable, even if prover/holder is fully compromised *)\nquery  VC:bitstring; \n    event(auth_VerifierCompletesProtocol(VC))\n    ==>\n    event(auth_IssuerSendsLastMessageToHolder(VC)) \n    .\n\n(* MAIN *)\n\n\n\nfree sk_E:SecretKey. (*other agent may or may not be honest, but we don't know*)\nprocess (*use root process for setup *)\n    (*declare secret keys*)\n    new sk_I:SecretKey;\n    new sk_V:SecretKey;\n    (*advertise public keys*)\n    out(h,pk(sk_I));\n    out(h,pk(sk_V));\n    (*advertise DIDs*)\n    let DID_I = genDID(pk(sk_I),sk_I) in\n    let DID_V = genDID(pk(sk_V),sk_V) in\n    let DID_E = genDID(pk(sk_E),sk_E) in\n    out(h,DID_I);\n    out(h,DID_V);\n    out(h,DID_E);\n    \n    let rule_EI = ( DID_E, attr, DID_I ) in \n    let rule_EE = ( DID_E, attr, DID_E ) in\n\n    (*let agents dance*)\n    ( (\n         !issuer   (DID_I, sk_I, attr, DID_E, pk(sk_E), false)  \n       | !verifier (DID_V, sk_V, rule_EI, pk(sk_E), pk(sk_I), true)    \n       | !verifier (DID_V, sk_V, rule_EE, pk(sk_E), pk(sk_E), false) \n    ) )"
    },
    {
        "file": "PV-1/sissy_multiparty_agreement_dh.pv",
        "incomplete": "(* This is a ProVerif description of the Protocol Flow from the SISSI architecture. *)\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* Start Definitions *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n(* START keys *)\ntype ____(TYPE_2)____.\ntype ____(OP_22)____.\ntype ____(TYPE_0)____.\nfun pk(SecretKey):PublicKey.\n\nfun pk_b(____(FUN_0)____):____(OP_46)____.\nfun b_pk(bitstring):PublicKey.\n(* END keys *)\n\n(* START group *)\ntype G.\ntype ____(TYPE_1)____.\n\nfun exp(G, exponent): G.\nfun g(exponent): G.\nequation forall ____(EQUATION_0)____: ____(EQUATION_2)____, ____(EQUATION_1)____: exponent; exp(g(____(OP_60)____),____(OP_9)____) = exp(g(____(OP_57)____),x).\n\nfun GtoSymK(G): SymmetricKey.\n(* END group *)\n\n(* START symmetric encryption *)\nfun enc(bitstring(*the message*), SymmetricKey):bitstring (*symmetric encrypt input msg*).\nreduc forall msg:bitstring,symk:SymmetricKey; dec(enc(msg,symk),symk)=msg (*symmetric decrypt*).\n(* END symmetric encryption *)\n\n(* START asymmetric encryption *)\nfun aenc(bitstring(*the message*), PublicKey):bitstring (*asymmetric encrypt input msg*).\nreduc forall msg:bitstring,sk:SecretKey; adec(aenc(msg,pk(sk)),sk)=msg (*asymmetric decrypt*).\n(* END Asymmetric encryption *)\n\n(* START digital signature *)\nfun sign(bitstring(*the message*), SecretKey):bitstring (*sign the input msg*).\nreduc forall msg:bitstring,sk:SecretKey; auth(sign(msg,sk),pk(sk))=msg (*check signature, and get msg*).\nreduc forall msg:bitstring,sk:SecretKey; getMsg(sign(msg,sk))=msg (*just get msg*).\n(* END digital signature *)\n\n(* ALTERNATIVE model authcrypt directly as a set of corresponding funcs and reducs...*)\nletfun authcrypt(msg:____(OP_74)____,sk:SecretKey,____(OP_73)____:PublicKey) = aenc(sign(msg,____(OP_32)____),pk).\nletfun authdecrypt(cipher:bitstring,sk:SecretKey,pk:PublicKey) = auth(adec(cipher,sk),pk).\n(* ALTERNATIVE model authcrypt directly as a set of corresponding funcs and reducs...*)\n\n(* START DID *)\ntype DID.\nfun genDID(PublicKey,SecretKey(*such that DID can not be inferred by others*)):DID.\nreduc forall sk:SecretKey; getPubKey(genDID(pk(sk),sk)) = pk(sk). (* as of page 129 of manual *)\n(* this implies that a DID may only be associated to only one pubKey, which is not true => model as table*)\n(* but tables do not seem to be publically available? as of page 41 of manual *)\nfun b_DID(____(FUN_6)____):DID.\nfun DID_b(DID):bitstring.\n(* END DID *)\n\n(* START credential *)\ntype ____(OP_42)____.\nfun issueVC(DID(*the subject*),bitstring(*the attribute*),SecretKey(*for issuer DID and signing*)):VC.\nreduc forall ____(REDUC_6)____:DID,____(REDUC_5)____:____(REDUC_4)____,____(REDUC_7)____:SecretKey; verify(issueVC(____(REDUC_8)____,attr,____(REDUC_9)____),pk(issuerSk))=(subject,attr,genDID(pk(____(OP_87)____),issuerSk)).\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getIssuerFromVC(issueVC(subject,attr,issuerSk))=genDID(pk(issuerSk),issuerSk).\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getAttrFromVC(issueVC(subject,attr,issuerSk))=attr.\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getSubjectFromVC(issueVC(subject,attr,issuerSk))=subject.\nreduc ____(REDUC_18)____ ____(REDUC_16)____:DID,attr:bitstring,____(REDUC_14)____:____(REDUC_17)____; getVcAsTuple(issueVC(____(OP_19)____,attr,____(REDUC_15)____))= (subject,attr,genDID(pk(issuerSk),issuerSk)).\n(* do table for (attr,issuerDID) lookup*)\n(* for now use if then *)\n(* END credential *)\n\n(* START access control rule (ACR) *)\ntype ACR. (*access control rule*)\nfun makeRule(DID(*the subject*),bitstring(*the attribute*),DID(*the issuer*)):ACR. (* technically, the subject is dynamically injected or when unknown an implicit placeholder in the rule; but for the sake of simplicity we omit that technical detail.*)\nreduc forall ____(REDUC_10)____:____(REDUC_12)____,attr:bitstring,____(REDUC_13)____:DID; getIssuerFromRule(makeRule(____(REDUC_11)____,attr,issuer))=issuer.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getAttrFromRule(makeRule(subject,____(OP_36)____,issuer))=attr.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getSubjectFromRule(makeRule(subject,attr,issuer))=subject.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getRuleAsTuple(makeRule(subject,attr,issuer))=(subject,attr,issuer).\n(* END access control rule *)\n\n(*DEFS*)\nfree h:channel.\nconst attr:bitstring.\nconst ____(CONST_0)____:bitstring.\n\nfun ch(bitstring): channel.\nfun chC(VC): channel.\nfun chR(ACR): channel.\nfun chS(SymmetricKey):channel.\n\nfree n_p_fromHolder: bitstring [private].\nfree n_i_fromHolder: bitstring [private].\nfree ____(FREE_7)____: bitstring [private]. \nfree cred_fromHolder: bitstring [private].\n\nfree n_p_fromIssuer: bitstring [____(FREE_2)____].\nfree credIssuing_fromIssuer_notMeaningful: bitstring [private]. \nfree cred_fromIssuer: bitstring [____(FREE_8)____].\n\nfree n_p_fromProver: bitstring [private].\nfree rule_fromProver: bitstring [private].\nfree ____(OP_35)____: bitstring [____(FREE_4)____].\nfree vp_fromProver: bitstring [private].\nfree ____(OP_13)____: bitstring [private].\nfree ____(OP_75)____: bitstring [private].\nfree K_private_fromProver:bitstring [private].\n\nfree n_p_fromVerifier: bitstring [private].\nfree ____(OP_72)____: bitstring [private].\nfree credRequest_fromVerifier: bitstring [____(FREE_3)____].\nfree ____(OP_20)____: bitstring [private].\nfree vp_fromVerifier: bitstring [____(FREE_5)____].\nfree cred_fromVerifier: bitstring [private].\nfree access_token_fromVerifier: bitstring [____(FREE_1)____].\nfree K_private_fromVerifier:____(FREE_6)____ [private].\n\n\n(* Authentication *)\nevent auth_VerifierSendsLastMessageToProver(____(OP_58)____,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverCompletesProtocol(G,____(OP_59)____,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverSendsLastMessageToVerifier(G,____(OP_85)____,bitstring,bitstring, bitstring).\nevent auth_VerifierCompletesProtocol(G,bitstring,bitstring,bitstring, bitstring).\n\nevent auth_IssuerSendsLastMessageToHolder(G,bitstring,bitstring,bitstring).\nevent auth_HolderCompletesProtocol(G,bitstring,bitstring,bitstring).\nevent auth_HolderSendsLastMessageToIssuer(G,bitstring,bitstring).\nevent auth_IssuerCompletesProtocol(G,bitstring,bitstring).\n\nevent auth_ProverSendsLastMessageToVerifierInProtocolFull(G,____(OP_5)____,____(OP_6)____,____(OP_7)____,G, bitstring, bitstring,bitstring,bitstring).\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Definitions *)\n(* Start Agents *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n\n\n  (**)\n  (**)\n  (**)\n  (**)\n  (* Part 2 - Prover - Verifier *)\n  (**)\n  (**)\n  (**)\n  (**)\n\n\n\n(** START Prover **)\nlet prover(sk:SecretKey, cred:VC, verifierDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    \n    (* Treatment *)\n    new x:____(NEW_1)____;\n    let ____(LET_2)____ = g(x) in\n    let msg_handshakeReq = ____(LET_28)____ in\n\n    (* === Message 1 [->] *)\n    out(h,____(OP_15)____);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 2 [<-] *)\n    in(____(OP_89)____,(gy:____(OP_88)____,m:bitstring));\n\n    (* Treatment *)\n    let ____(LET_0)____ = (gy,m) in\n    let K = GtoSymK(exp(____(LET_3)____,x)) in\n    let pk_v = getPubKey(verifierDID) in\n    if (dec(auth(m,pk_v),K)) = (gy,gx) then\n    let msg_uri = (enc(sign((gx,gy),sk),K),enc(pk_b(pk(____(OP_1)____)),K)) in\n\n    (* === Message 3 [->] *)\n    out(h,____(OP_50)____);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 4 [<-] *)\n    in(h,x:bitstring); (* receive msg *)\n\n    (* Treatment *)\n    let msg_rule = x in\n    let msg = dec(x,K) in (* authdecrypt msg *)\n    let (n_c:bitstring,rule:ACR) = msg in (* deconstruct msg=(n_c,r) *)\n    if getVcAsTuple(cred) = getRuleAsTuple(rule) then (* TODO lookup *) (* lookup credential *)\n    let vp = sign((n_c,verifierDID,cred),sk) in (* create Verifiable Presentation *)\n    let msg_vp = enc(vp,K) in (* send authcrypt msg /w VP *)\n    event auth_ProverSendsLastMessageToVerifier(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp); (* event_just_before_the_last_send_message_of_S  *)\n\n    (* === Message 5 [->] *) \n    out(h, ____(OP_76)____);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 6 [<-] *)\n    in(____(OP_79)____,x:bitstring);\n\n    (* Treatment *)\n    let ____(LET_29)____ = x in\n    let (access_token:bitstring, recipientDID:DID) = dec(____(OP_44)____,K) in \n    if recipientDID = genDID(pk(____(OP_41)____),sk) then\n    \n    (* event received_access_token; and I am the recipient, Prover about to complete protocol! *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if ____(IF_3)____ then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_ProverCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp, msg_accessToken) |\n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    out(chR(rule),rule_fromProver) |\n    out(ch((n_c,verifierDID,cred)), unsigned_vp_fromProver) |\n    out(ch(vp), vp_fromProver) |\n    out(chC(cred),cred_fromProver) |\n    out(ch(access_token),____(OP_77)____);\n    out(chS(K),K_private_fromProver);\n    0.\n(** END Prover **)\n\n\n(** START Verifier **)\nlet verifier(sk:SecretKey, rule:ACR, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (**)\n    (**)\n    (**)\n    (* === Message 1 [<-] *)\n    in(h,____(OP_90)____:G);\n\n    (* Treatment *)\n    let msg_handshakeReq = gx in\n    new y:exponent;\n    let gy = g(____(LET_25)____) in\n    let K = GtoSymK(exp(____(OP_49)____,y)) in\n    let msg_handshakeResp = (gy,enc(sign((gy,gx),sk),K)) in\n\n    (* === Message 2 [->] *)\n    out(____(OP_83)____,msg_handshakeResp);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 3 [<-] *)\n    in(h,(m:bitstring,e_pk:bitstring));\n\n    (* Treatment *)\n    let msg_uri = (m,e_pk) in\n    let pk_p = b_pk(dec(____(OP_14)____,K)) in\n    if (dec(auth(m,pk_p),K)) = (gx,gy) then\n    new n_c:bitstring;\n    let msg = (n_c,rule) in\n    let msg_rule = enc(msg,____(OP_31)____) in\n\n    (* === Message 4 [->] *)\n    out(h, msg_rule);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 5 [<-] *)\n    in(____(OP_86)____,x:bitstring);\n\n    (* Treatment *)\n    let ____(LET_27)____ = x in\n    let ____(OP_37)____ = dec(x,____(OP_55)____) in \n    let (unauth_n'_c:bitstring,unauth_recipient:DID,unauth_cred:VC) = getMsg(unauth_vp) in (* deconstruct vp=(n_c,cred) *)\n    let cred_subject = getSubjectFromVC(unauth_cred) in (*get subject *)\n    if cred_subject = getSubjectFromRule(rule) then (* check if subject match from cred and rule *) (* delete if you do not want the specificy*) (* where prover p is the expected type of agent, i.e. honest*)\n    let pk_subject = getPubKey(cred_subject) in (* get subject pubkey *)\n    let (n'_c:bitstring,recipientDID:DID,cred:VC) = auth(unauth_vp,pk_subject) in (* authenticate VP *)\n    if recipientDID = genDID(pk(sk),sk) then (* check if verifier is actual recipient*)\n    if n'_c = n_c then (* check nonce *)\n    if getIssuerFromVC(cred) = getIssuerFromRule(rule) then (* check if issuers match from cred and rule *)\n    let (subjectDID:DID,asserted_attr:bitstring,issuerDID:DID) = verify(cred,getPubKey(getIssuerFromVC(cred))) in (* check cred integrity *)\n    if asserted_attr = getAttrFromRule(rule) then (* check if attribute match from cred and rule *)\n    new access_token:bitstring; (* mint new access token *)\n    let msg = (access_token,subjectDID) in\n    let msg_accessToken = enc(____(OP_66)____,____(LET_32)____) in\n    event auth_VerifierSendsLastMessageToProver(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp, msg_accessToken); (* event_just_before_the_last_send_message_of_S  *)\n\n    (* === Message 6 [->] *)\n    out(h, msg_accessToken);\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_VerifierCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp) |\n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    out(chR(rule), ____(OP_4)____) |\n    out(ch((n_c,rule)), credRequest_fromVerifier) |\n    out(ch(unauth_vp),unauth_vp_fromVerifier) |\n    out(ch((n'_c,recipientDID,cred)),vp_fromVerifier) |\n    out(chC(cred),cred_fromVerifier) |\n    out(ch(access_token),access_token_fromVerifier);\n    out(chS(K),K_private_fromVerifier);\n    0.\n(** END Verifier **)\n\n\n  (**)\n  (**)\n  (**)\n  (**)\n  (* Part 1 - Issuer - Holder (i.e. Prover in part 2) *)\n  (**)\n  (**)\n  (**)\n  (**)\n\n\n(** START Holder/Prover **)\nlet holder(sk:SecretKey, issuerDID:DID, verifierDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (* Treatment *)\n    new x:exponent;\n    let gx = g(x) in\n    let msg_handshakeReq = gx in\n\n    (* === Message 1 [->] *)\n    out(h,____(OP_18)____);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 2 [<-] *)\n    in(h,(gy:G,m:bitstring));\n\n    (* Treatment *)\n    let msg_handshakeResp = (gy,m) in\n    let K = GtoSymK(exp(gy,____(LET_19)____)) in\n    let pk_i = getPubKey(issuerDID) in\n    if (dec(auth(____(OP_17)____,pk_i),K)) = (gy,gx) then\n    let msg_did = (enc(sign((gx,gy),sk),K),enc(DID_b(genDID(pk(____(OP_78)____),sk)),K),enc(DID_b(issuerDID),K)) in \n\n    (* === Message 3 [->] *)\n    out(h,msg_did);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 4 [<-] *)\n\n    (* receive msg *)\n    in(h,x:bitstring);\n    (* authdecrypt msg *)\n    let msg_credential = x in\n    (* let (credential:VC, recipientDID:DID, n_strongSecrecy:bitstring) = authdecrypt(x,ssk,spk_i) in  *)\n    let (credential:VC, ____(LET_31)____:DID) = dec(____(LET_30)____,K) in \n    if recipientDID = genDID(pk(____(IF_1)____),sk) then\n    if getIssuerFromVC(credential) = issuerDID then\n    (* TODO validate credential *)\n    (* event received_access_token; and I am the recipient *)\n    (* Prover about to complete protocol! *)\n\n    (* !prover(sk, credential, verifierDID, talksOnlyToHonest, msg_handshakeReq,msg_handshakeResp,msg_did,msg_credential) | *)\n   \n    (* phase 1 ; *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* ( event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks ) *)\n    event auth_HolderCompletesProtocol(____(OP_63)____,msg_handshakeResp,msg_did,msg_credential) | \n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    (* out(ch(n_p),n_p_fromHolder) | *)\n    (* out(ch(n_i),n_i_fromHolder) | *)\n    (* out(ch((n_i,genDID(pk(sk),sk),issuerDID)), providingDID_fromHolder) |  *)\n    (* DID alone is public knowledge *)\n    out(chC(credential),cred_fromHolder); (*currently public anyway...?*)\n    0.\n\n    \n(** END Holder/Prover **)\n\n(** START Issuer **)\nlet issuer(sk:SecretKey, attr:bitstring, expectedDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (**)\n    (**)\n    (**)\n    (* === Message 1 [<-] *)\n    in(h,gx:G);\n\n    (* Treatment *)\n    let msg_handshakeReq = gx in\n    new y:exponent;\n    let gy = g(y) in\n    let K = GtoSymK(exp(gx,y)) in\n    let msg_handshakeResp = (gy,enc(sign((gy,gx),sk),K)) in\n\n    (* === Message 2 [->] *)\n    out(h,msg_handshakeResp);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 3 [<-] *)\n    in(h,(m:bitstring,proverDID:DID,recipientDID:DID));\n\n    (* Treatment *)\n    let msg_did = (m,proverDID,____(LET_26)____) in\n    let pk_h = getPubKey(proverDID) in\n    if (dec(auth(____(OP_25)____,____(IF_2)____),K)) = (gx,gy) then\n\n    if proverDID = expectedDID then(*this is just for proverif, to model it s.t. secrecy check is only executed when proverDID is expceted. nobody cares if attacker knows some message that was explicitly and knowingly send to the attacker.*)\n    (* check if issuer is actual recipient*)\n    if recipientDID = genDID(pk(sk),sk) then\n\n    (* issue new credential *)\n    let cred = issueVC(____(LET_1)____, attr, sk) in\n    (* new n_strongSecrecy:bitstring; *)\n    (* let msg = (cred,proverDID,n_strongSecrecy) in *)\n    let msg = (cred,proverDID) in\n    let msg_cred = enc(msg,K) in\n    (* event_just_before_the_last_send_message_of_S *)\n    event auth_IssuerSendsLastMessageToHolder(msg_handshakeReq,msg_handshakeResp,msg_did,msg_cred);\n\n    (* === Message 4 [->] *)\n    out(h, msg_cred);\n\n    (* phase 1 ; *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_IssuerCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_did) | \n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    (* out(ch(n_p),n_p_fromIssuer) | *)\n    out(chC(cred),cred_fromIssuer) | (* currently public anyway ...? *)\n    (* out(ch((cred,proverDID,n_strongSecrecy)),credIssuing_fromIssuer_notMeaningful); *)\n    out(ch((cred,proverDID)),____(OP_16)____);\n    0.\n(** END Issuer **)\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Agents *)\n(* Start Assumptions *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n(* SECRECY *)\n\n\nquery attacker(____(QUERY_6)____).\nquery attacker(n_i_fromHolder).\nquery attacker(providingDID_fromHolder). (* should be private, it is a message that includes prover did*)\n(*query attacker(cred_fromHolder). *) (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n\nquery attacker(n_p_fromIssuer).\nquery attacker(credIssuing_fromIssuer_notMeaningful). (* should be private, it is a message that includes credential*)\n(* using the n_strongSecrecy is actually a privacy thing, we modified the protocol by introducing it, which is not the way to go. *)\n(*query attacker(cred_fromIssuer).*)  (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n\nquery attacker(n_p_fromProver).\nquery attacker(unsigned_vp_fromProver). (* should be private, it is a message that includes credential, redundant i think*)\nquery attacker(vp_fromProver).    (* should be private, it is a message that includes credential*)\nquery attacker(cred_fromProver).  (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n(*I have no idea, why this cred_fromProver is not triggered but the other cred_x are...*)\nquery attacker(access_token_fromProver). (* should be private, even with the credential leaked (this is the actual token, not the message containing it) *)\nquery attacker(K_private_fromProver).\n\nquery attacker(____(QUERY_2)____). \nquery attacker(rule_fromVerifier). (* basically public, as it is discoverable by an attacker by simply asking the verifier*)\nquery attacker(credRequest_fromVerifier). (* should be private, it is a message includes rule*)\nquery attacker(unauth_vp_fromVerifier). (* should be private, it is a message that includes credential, redundant i think*)\nquery attacker(vp_fromVerifier). (* should be private, it is a message that includes credential*)\nquery attacker(cred_fromVerifier). (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\nquery attacker(access_token_fromVerifier). (* should be private, even with the credential leaked (this is the actual token, not the message containing it) *)\nquery attacker(____(QUERY_1)____).\n\n(* AUTHETNICATION *)\n\n(* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks\n==> \nevent_just_before_the_last_send_message_of_S *)\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_accessToken:bitstring; \n    inj-event(auth_ProverCompletesProtocol(____(OP_12)____, m_handshakeResp, m_uri, m_rule, m_vp, ____(OP_11)____))\n    ==>\n    inj-event(auth_VerifierSendsLastMessageToProver(____(OP_93)____, m_handshakeResp, ____(OP_94)____, m_rule, m_vp, m_accessToken)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring; \n    inj-event(auth_VerifierCompletesProtocol(m_handshakeReq, ____(OP_53)____, m_uri, ____(OP_54)____, m_vp))\n    ==>\n    inj-event(auth_ProverSendsLastMessageToVerifier(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_did:bitstring, m_cred:bitstring; \n    inj-event(auth_HolderCompletesProtocol(m_handshakeReq, m_handshakeResp, m_did, m_cred))\n    ==>\n    inj-event(auth_IssuerSendsLastMessageToHolder(m_handshakeReq, ____(OP_43)____, m_did, m_cred)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_did:bitstring; \n    inj-event(auth_IssuerCompletesProtocol(____(OP_29)____, m_handshakeResp,  m_did))\n    ==>\n    inj-event(auth_HolderSendsLastMessageToIssuer(m_handshakeReq, ____(OP_0)____, m_did)) .\n\n(* inj-agreement will not work, expected, since re-use of credentials issued once for multiple provings *)\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_handshakeReq_2:G, m_handshakeResp_2:bitstring, m_did:bitstring, m_cred:bitstring; \n    inj-event(\n        auth_VerifierCompletesProtocol(\n                m_handshakeReq, \n                m_handshakeResp, \n                m_uri, \n                m_rule, \n                ____(OP_84)____))\n    ==>\n    inj-event(\n        auth_ProverSendsLastMessageToVerifier(\n                m_handshakeReq, \n                m_handshakeResp, \n                m_uri, \n                m_rule, \n                m_vp)) \n    &&\n    inj-event(\n        auth_IssuerSendsLastMessageToHolder(\n                m_handshakeReq_2, \n                m_handshakeResp_2, \n                m_did, \n                m_cred)) \n    &&\n    inj-event(\n        auth_HolderCompletesProtocol(\n                m_handshakeReq_2, \n                m_handshakeResp_2, \n                m_did, \n                m_cred))\n    .\n\n(* this should hold, \"for every proving, there must be an issuing\" *)\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_handshakeReq_2:G, m_handshakeResp_2:bitstring, m_did:bitstring, m_cred:bitstring; \n    event(auth_VerifierCompletesProtocol(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp))\n    ==>\n    event(auth_IssuerSendsLastMessageToHolder(m_handshakeReq_2, m_handshakeResp_2, ____(OP_45)____, m_cred)) \n    &&\n    event(auth_ProverSendsLastMessageToVerifierInProtocolFull(m_handshakeReq_2, m_handshakeResp_2, m_did, m_cred, m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp))\n    .\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Assumptions *)\n(* Start Main *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\nfree sk_otherAgent:SecretKey. (*other agent may or may not be honest, but we don't know*)\nprocess (*use root process for setup *)\n    (*declare secret keys*)\n    new sk_prover:SecretKey;\n    new ____(NEW_2)____:SecretKey;\n    new ____(NEW_0)____:SecretKey;\n    (*advertise public keys*)\n    out(h,pk(____(OP_70)____));\n    out(h,pk(____(OP_23)____));\n    out(____(OP_40)____,pk(sk_prover));\n    (*advertise DIDs*)\n    out(h,genDID(pk(sk_prover),sk_prover));\n    out(h,genDID(pk(____(OP_38)____),sk_verifier));\n    out(h,genDID(pk(sk_issuer),sk_issuer));\n    \n    (*assume issuer verified prover for attribute*)\n    (* credential = ( (DID_prover, attriubte, DID_issuer), signature_issuer ) *)\n    (* let cred = issueVC(  genDID(pk(sk_prover),sk_prover),   attr,    sk_issuer   ) \n    let cred_otherAgent = issueVC(  genDID(pk(sk_otherAgent),sk_otherAgent),   attr,    sk_issuer   ) in \n    out(h,cred_otherAgent); *)\n\n    (*assume verifier trusts issuer for asserting attribute*)\n    (* rule = (DID_prover , attribute , DID_issuer) *)\n    let acr = makeRule(  genDID(pk(sk_prover),sk_prover),   attr,   genDID(pk(sk_issuer),sk_issuer)  ) in (* where prover p is honest agent*)\n    let acr_otherAgent = makeRule(  genDID(pk(sk_otherAgent),sk_otherAgent),   attr,   genDID(pk(sk_issuer),sk_issuer)  ) in (* where other agent may or may not be dishonest*)\n    let acr_compromisedIssuer = makeRule(  genDID(pk(____(LET_35)____),sk_prover),   ____(LET_34)____,   genDID(pk(sk_otherAgent),sk_otherAgent)  ) in\n    let acr_compromised = makeRule(  genDID(pk(____(LET_5)____),____(LET_6)____),   attr,   genDID(pk(sk_otherAgent),sk_otherAgent)  ) in\n\n    (*let agents dance*)\n    (\n    (\n        !issuer(sk_issuer, attr, genDID(pk(sk_prover),sk_prover), true)\n    |   \n        !issuer(sk_issuer, attr, genDID(pk(sk_otherAgent),sk_otherAgent), false)\n    |\n        !holder(sk_prover,  genDID(pk(sk_issuer),sk_issuer), genDID(pk(sk_verifier),sk_verifier), true)\n    |\n        !holder(sk_prover,  genDID(pk(sk_issuer),sk_issuer), genDID(pk(sk_otherAgent),sk_otherAgent), false) \n    |\n        !holder(____(OP_92)____,  genDID(pk(sk_otherAgent),sk_otherAgent), genDID(pk(____(OP_91)____),sk_verifier), false) \n    |\n        !holder(sk_prover,  genDID(pk(sk_otherAgent),sk_otherAgent), genDID(pk(sk_otherAgent),sk_otherAgent), false) \n    |\n        !verifier(sk_verifier, acr, true) \n    | \n        !verifier(sk_verifier, acr_otherAgent, false)\n    | \n        !verifier(sk_verifier, acr_compromisedIssuer, false) \n    | \n        !verifier(sk_verifier, acr_compromised, ____(OP_82)____) \n    ) \n  \n    \n    )\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Main *)\n(* --------------------------------------------------------------------------------------------------------- *)",
        "complete:": "(* This is a ProVerif description of the Protocol Flow from the SISSI architecture. *)\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* Start Definitions *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n(* START keys *)\ntype SymmetricKey.\ntype SecretKey.\ntype PublicKey.\nfun pk(SecretKey):PublicKey.\n\nfun pk_b(PublicKey):bitstring.\nfun b_pk(bitstring):PublicKey.\n(* END keys *)\n\n(* START group *)\ntype G.\ntype exponent.\n\nfun exp(G, exponent): G.\nfun g(exponent): G.\nequation forall x: exponent, y: exponent; exp(g(x),y) = exp(g(y),x).\n\nfun GtoSymK(G): SymmetricKey.\n(* END group *)\n\n(* START symmetric encryption *)\nfun enc(bitstring(*the message*), SymmetricKey):bitstring (*symmetric encrypt input msg*).\nreduc forall msg:bitstring,symk:SymmetricKey; dec(enc(msg,symk),symk)=msg (*symmetric decrypt*).\n(* END symmetric encryption *)\n\n(* START asymmetric encryption *)\nfun aenc(bitstring(*the message*), PublicKey):bitstring (*asymmetric encrypt input msg*).\nreduc forall msg:bitstring,sk:SecretKey; adec(aenc(msg,pk(sk)),sk)=msg (*asymmetric decrypt*).\n(* END Asymmetric encryption *)\n\n(* START digital signature *)\nfun sign(bitstring(*the message*), SecretKey):bitstring (*sign the input msg*).\nreduc forall msg:bitstring,sk:SecretKey; auth(sign(msg,sk),pk(sk))=msg (*check signature, and get msg*).\nreduc forall msg:bitstring,sk:SecretKey; getMsg(sign(msg,sk))=msg (*just get msg*).\n(* END digital signature *)\n\n(* ALTERNATIVE model authcrypt directly as a set of corresponding funcs and reducs...*)\nletfun authcrypt(msg:bitstring,sk:SecretKey,pk:PublicKey) = aenc(sign(msg,sk),pk).\nletfun authdecrypt(cipher:bitstring,sk:SecretKey,pk:PublicKey) = auth(adec(cipher,sk),pk).\n(* ALTERNATIVE model authcrypt directly as a set of corresponding funcs and reducs...*)\n\n(* START DID *)\ntype DID.\nfun genDID(PublicKey,SecretKey(*such that DID can not be inferred by others*)):DID.\nreduc forall sk:SecretKey; getPubKey(genDID(pk(sk),sk)) = pk(sk). (* as of page 129 of manual *)\n(* this implies that a DID may only be associated to only one pubKey, which is not true => model as table*)\n(* but tables do not seem to be publically available? as of page 41 of manual *)\nfun b_DID(bitstring):DID.\nfun DID_b(DID):bitstring.\n(* END DID *)\n\n(* START credential *)\ntype VC.\nfun issueVC(DID(*the subject*),bitstring(*the attribute*),SecretKey(*for issuer DID and signing*)):VC.\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; verify(issueVC(subject,attr,issuerSk),pk(issuerSk))=(subject,attr,genDID(pk(issuerSk),issuerSk)).\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getIssuerFromVC(issueVC(subject,attr,issuerSk))=genDID(pk(issuerSk),issuerSk).\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getAttrFromVC(issueVC(subject,attr,issuerSk))=attr.\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getSubjectFromVC(issueVC(subject,attr,issuerSk))=subject.\nreduc forall subject:DID,attr:bitstring,issuerSk:SecretKey; getVcAsTuple(issueVC(subject,attr,issuerSk))= (subject,attr,genDID(pk(issuerSk),issuerSk)).\n(* do table for (attr,issuerDID) lookup*)\n(* for now use if then *)\n(* END credential *)\n\n(* START access control rule (ACR) *)\ntype ACR. (*access control rule*)\nfun makeRule(DID(*the subject*),bitstring(*the attribute*),DID(*the issuer*)):ACR. (* technically, the subject is dynamically injected or when unknown an implicit placeholder in the rule; but for the sake of simplicity we omit that technical detail.*)\nreduc forall subject:DID,attr:bitstring,issuer:DID; getIssuerFromRule(makeRule(subject,attr,issuer))=issuer.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getAttrFromRule(makeRule(subject,attr,issuer))=attr.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getSubjectFromRule(makeRule(subject,attr,issuer))=subject.\nreduc forall subject:DID,attr:bitstring,issuer:DID; getRuleAsTuple(makeRule(subject,attr,issuer))=(subject,attr,issuer).\n(* END access control rule *)\n\n(*DEFS*)\nfree h:channel.\nconst attr:bitstring.\nconst uri:bitstring.\n\nfun ch(bitstring): channel.\nfun chC(VC): channel.\nfun chR(ACR): channel.\nfun chS(SymmetricKey):channel.\n\nfree n_p_fromHolder: bitstring [private].\nfree n_i_fromHolder: bitstring [private].\nfree providingDID_fromHolder: bitstring [private]. \nfree cred_fromHolder: bitstring [private].\n\nfree n_p_fromIssuer: bitstring [private].\nfree credIssuing_fromIssuer_notMeaningful: bitstring [private]. \nfree cred_fromIssuer: bitstring [private].\n\nfree n_p_fromProver: bitstring [private].\nfree rule_fromProver: bitstring [private].\nfree unsigned_vp_fromProver: bitstring [private].\nfree vp_fromProver: bitstring [private].\nfree cred_fromProver: bitstring [private].\nfree access_token_fromProver: bitstring [private].\nfree K_private_fromProver:bitstring [private].\n\nfree n_p_fromVerifier: bitstring [private].\nfree rule_fromVerifier: bitstring [private].\nfree credRequest_fromVerifier: bitstring [private].\nfree unauth_vp_fromVerifier: bitstring [private].\nfree vp_fromVerifier: bitstring [private].\nfree cred_fromVerifier: bitstring [private].\nfree access_token_fromVerifier: bitstring [private].\nfree K_private_fromVerifier:bitstring [private].\n\n\n(* Authentication *)\nevent auth_VerifierSendsLastMessageToProver(G,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverCompletesProtocol(G,bitstring,bitstring,bitstring,bitstring, bitstring).\nevent auth_ProverSendsLastMessageToVerifier(G,bitstring,bitstring,bitstring, bitstring).\nevent auth_VerifierCompletesProtocol(G,bitstring,bitstring,bitstring, bitstring).\n\nevent auth_IssuerSendsLastMessageToHolder(G,bitstring,bitstring,bitstring).\nevent auth_HolderCompletesProtocol(G,bitstring,bitstring,bitstring).\nevent auth_HolderSendsLastMessageToIssuer(G,bitstring,bitstring).\nevent auth_IssuerCompletesProtocol(G,bitstring,bitstring).\n\nevent auth_ProverSendsLastMessageToVerifierInProtocolFull(G,bitstring,bitstring,bitstring,G, bitstring, bitstring,bitstring,bitstring).\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Definitions *)\n(* Start Agents *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n\n\n  (**)\n  (**)\n  (**)\n  (**)\n  (* Part 2 - Prover - Verifier *)\n  (**)\n  (**)\n  (**)\n  (**)\n\n\n\n(** START Prover **)\nlet prover(sk:SecretKey, cred:VC, verifierDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n    \n    (* Treatment *)\n    new x:exponent;\n    let gx = g(x) in\n    let msg_handshakeReq = gx in\n\n    (* === Message 1 [->] *)\n    out(h,msg_handshakeReq);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 2 [<-] *)\n    in(h,(gy:G,m:bitstring));\n\n    (* Treatment *)\n    let msg_handshakeResp = (gy,m) in\n    let K = GtoSymK(exp(gy,x)) in\n    let pk_v = getPubKey(verifierDID) in\n    if (dec(auth(m,pk_v),K)) = (gy,gx) then\n    let msg_uri = (enc(sign((gx,gy),sk),K),enc(pk_b(pk(sk)),K)) in\n\n    (* === Message 3 [->] *)\n    out(h,msg_uri);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 4 [<-] *)\n    in(h,x:bitstring); (* receive msg *)\n\n    (* Treatment *)\n    let msg_rule = x in\n    let msg = dec(x,K) in (* authdecrypt msg *)\n    let (n_c:bitstring,rule:ACR) = msg in (* deconstruct msg=(n_c,r) *)\n    if getVcAsTuple(cred) = getRuleAsTuple(rule) then (* TODO lookup *) (* lookup credential *)\n    let vp = sign((n_c,verifierDID,cred),sk) in (* create Verifiable Presentation *)\n    let msg_vp = enc(vp,K) in (* send authcrypt msg /w VP *)\n    event auth_ProverSendsLastMessageToVerifier(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp); (* event_just_before_the_last_send_message_of_S  *)\n\n    (* === Message 5 [->] *) \n    out(h, msg_vp);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 6 [<-] *)\n    in(h,x:bitstring);\n\n    (* Treatment *)\n    let msg_accessToken = x in\n    let (access_token:bitstring, recipientDID:DID) = dec(x,K) in \n    if recipientDID = genDID(pk(sk),sk) then\n    \n    (* event received_access_token; and I am the recipient, Prover about to complete protocol! *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_ProverCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp, msg_accessToken) |\n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    out(chR(rule),rule_fromProver) |\n    out(ch((n_c,verifierDID,cred)), unsigned_vp_fromProver) |\n    out(ch(vp), vp_fromProver) |\n    out(chC(cred),cred_fromProver) |\n    out(ch(access_token),access_token_fromProver);\n    out(chS(K),K_private_fromProver);\n    0.\n(** END Prover **)\n\n\n(** START Verifier **)\nlet verifier(sk:SecretKey, rule:ACR, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (**)\n    (**)\n    (**)\n    (* === Message 1 [<-] *)\n    in(h,gx:G);\n\n    (* Treatment *)\n    let msg_handshakeReq = gx in\n    new y:exponent;\n    let gy = g(y) in\n    let K = GtoSymK(exp(gx,y)) in\n    let msg_handshakeResp = (gy,enc(sign((gy,gx),sk),K)) in\n\n    (* === Message 2 [->] *)\n    out(h,msg_handshakeResp);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 3 [<-] *)\n    in(h,(m:bitstring,e_pk:bitstring));\n\n    (* Treatment *)\n    let msg_uri = (m,e_pk) in\n    let pk_p = b_pk(dec(e_pk,K)) in\n    if (dec(auth(m,pk_p),K)) = (gx,gy) then\n    new n_c:bitstring;\n    let msg = (n_c,rule) in\n    let msg_rule = enc(msg,K) in\n\n    (* === Message 4 [->] *)\n    out(h, msg_rule);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 5 [<-] *)\n    in(h,x:bitstring);\n\n    (* Treatment *)\n    let msg_vp = x in\n    let unauth_vp = dec(x,K) in \n    let (unauth_n'_c:bitstring,unauth_recipient:DID,unauth_cred:VC) = getMsg(unauth_vp) in (* deconstruct vp=(n_c,cred) *)\n    let cred_subject = getSubjectFromVC(unauth_cred) in (*get subject *)\n    if cred_subject = getSubjectFromRule(rule) then (* check if subject match from cred and rule *) (* delete if you do not want the specificy*) (* where prover p is the expected type of agent, i.e. honest*)\n    let pk_subject = getPubKey(cred_subject) in (* get subject pubkey *)\n    let (n'_c:bitstring,recipientDID:DID,cred:VC) = auth(unauth_vp,pk_subject) in (* authenticate VP *)\n    if recipientDID = genDID(pk(sk),sk) then (* check if verifier is actual recipient*)\n    if n'_c = n_c then (* check nonce *)\n    if getIssuerFromVC(cred) = getIssuerFromRule(rule) then (* check if issuers match from cred and rule *)\n    let (subjectDID:DID,asserted_attr:bitstring,issuerDID:DID) = verify(cred,getPubKey(getIssuerFromVC(cred))) in (* check cred integrity *)\n    if asserted_attr = getAttrFromRule(rule) then (* check if attribute match from cred and rule *)\n    new access_token:bitstring; (* mint new access token *)\n    let msg = (access_token,subjectDID) in\n    let msg_accessToken = enc(msg,K) in\n    event auth_VerifierSendsLastMessageToProver(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp, msg_accessToken); (* event_just_before_the_last_send_message_of_S  *)\n\n    (* === Message 6 [->] *)\n    out(h, msg_accessToken);\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_VerifierCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_uri,msg_rule,msg_vp) |\n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    out(chR(rule), rule_fromVerifier) |\n    out(ch((n_c,rule)), credRequest_fromVerifier) |\n    out(ch(unauth_vp),unauth_vp_fromVerifier) |\n    out(ch((n'_c,recipientDID,cred)),vp_fromVerifier) |\n    out(chC(cred),cred_fromVerifier) |\n    out(ch(access_token),access_token_fromVerifier);\n    out(chS(K),K_private_fromVerifier);\n    0.\n(** END Verifier **)\n\n\n  (**)\n  (**)\n  (**)\n  (**)\n  (* Part 1 - Issuer - Holder (i.e. Prover in part 2) *)\n  (**)\n  (**)\n  (**)\n  (**)\n\n\n(** START Holder/Prover **)\nlet holder(sk:SecretKey, issuerDID:DID, verifierDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (* Treatment *)\n    new x:exponent;\n    let gx = g(x) in\n    let msg_handshakeReq = gx in\n\n    (* === Message 1 [->] *)\n    out(h,msg_handshakeReq);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 2 [<-] *)\n    in(h,(gy:G,m:bitstring));\n\n    (* Treatment *)\n    let msg_handshakeResp = (gy,m) in\n    let K = GtoSymK(exp(gy,x)) in\n    let pk_i = getPubKey(issuerDID) in\n    if (dec(auth(m,pk_i),K)) = (gy,gx) then\n    let msg_did = (enc(sign((gx,gy),sk),K),enc(DID_b(genDID(pk(sk),sk)),K),enc(DID_b(issuerDID),K)) in \n\n    (* === Message 3 [->] *)\n    out(h,msg_did);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 4 [<-] *)\n\n    (* receive msg *)\n    in(h,x:bitstring);\n    (* authdecrypt msg *)\n    let msg_credential = x in\n    (* let (credential:VC, recipientDID:DID, n_strongSecrecy:bitstring) = authdecrypt(x,ssk,spk_i) in  *)\n    let (credential:VC, recipientDID:DID) = dec(x,K) in \n    if recipientDID = genDID(pk(sk),sk) then\n    if getIssuerFromVC(credential) = issuerDID then\n    (* TODO validate credential *)\n    (* event received_access_token; and I am the recipient *)\n    (* Prover about to complete protocol! *)\n\n    (* !prover(sk, credential, verifierDID, talksOnlyToHonest, msg_handshakeReq,msg_handshakeResp,msg_did,msg_credential) | *)\n   \n    (* phase 1 ; *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* ( event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks ) *)\n    event auth_HolderCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_did,msg_credential) | \n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    (* out(ch(n_p),n_p_fromHolder) | *)\n    (* out(ch(n_i),n_i_fromHolder) | *)\n    (* out(ch((n_i,genDID(pk(sk),sk),issuerDID)), providingDID_fromHolder) |  *)\n    (* DID alone is public knowledge *)\n    out(chC(credential),cred_fromHolder); (*currently public anyway...?*)\n    0.\n\n    \n(** END Holder/Prover **)\n\n(** START Issuer **)\nlet issuer(sk:SecretKey, attr:bitstring, expectedDID:DID, talksOnlyToHonest:bool) (* input ~ what the agent starts with in private*) =\n\n    (**)\n    (**)\n    (**)\n    (* === Message 1 [<-] *)\n    in(h,gx:G);\n\n    (* Treatment *)\n    let msg_handshakeReq = gx in\n    new y:exponent;\n    let gy = g(y) in\n    let K = GtoSymK(exp(gx,y)) in\n    let msg_handshakeResp = (gy,enc(sign((gy,gx),sk),K)) in\n\n    (* === Message 2 [->] *)\n    out(h,msg_handshakeResp);\n\n    (**)\n    (**)\n    (**)\n    (* === Message 3 [<-] *)\n    in(h,(m:bitstring,proverDID:DID,recipientDID:DID));\n\n    (* Treatment *)\n    let msg_did = (m,proverDID,recipientDID) in\n    let pk_h = getPubKey(proverDID) in\n    if (dec(auth(m,pk_h),K)) = (gx,gy) then\n\n    if proverDID = expectedDID then(*this is just for proverif, to model it s.t. secrecy check is only executed when proverDID is expceted. nobody cares if attacker knows some message that was explicitly and knowingly send to the attacker.*)\n    (* check if issuer is actual recipient*)\n    if recipientDID = genDID(pk(sk),sk) then\n\n    (* issue new credential *)\n    let cred = issueVC(proverDID, attr, sk) in\n    (* new n_strongSecrecy:bitstring; *)\n    (* let msg = (cred,proverDID,n_strongSecrecy) in *)\n    let msg = (cred,proverDID) in\n    let msg_cred = enc(msg,K) in\n    (* event_just_before_the_last_send_message_of_S *)\n    event auth_IssuerSendsLastMessageToHolder(msg_handshakeReq,msg_handshakeResp,msg_did,msg_cred);\n\n    (* === Message 4 [->] *)\n    out(h, msg_cred);\n\n    (* phase 1 ; *)\n\n    (* --------------------------------------------------------------------------------------- *)\n    (* Dishonest Agent *)\n\n    if talksOnlyToHonest then\n    (* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks *)\n    event auth_IssuerCompletesProtocol(msg_handshakeReq,msg_handshakeResp,msg_did) | \n    (* checks if m is secret where the second argument is the dummy the query looks for*)\n    (* out(ch(n_p),n_p_fromIssuer) | *)\n    out(chC(cred),cred_fromIssuer) | (* currently public anyway ...? *)\n    (* out(ch((cred,proverDID,n_strongSecrecy)),credIssuing_fromIssuer_notMeaningful); *)\n    out(ch((cred,proverDID)),credIssuing_fromIssuer_notMeaningful);\n    0.\n(** END Issuer **)\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Agents *)\n(* Start Assumptions *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\n(* SECRECY *)\n\n\nquery attacker(n_p_fromHolder).\nquery attacker(n_i_fromHolder).\nquery attacker(providingDID_fromHolder). (* should be private, it is a message that includes prover did*)\n(*query attacker(cred_fromHolder). *) (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n\nquery attacker(n_p_fromIssuer).\nquery attacker(credIssuing_fromIssuer_notMeaningful). (* should be private, it is a message that includes credential*)\n(* using the n_strongSecrecy is actually a privacy thing, we modified the protocol by introducing it, which is not the way to go. *)\n(*query attacker(cred_fromIssuer).*)  (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n\nquery attacker(n_p_fromProver).\nquery attacker(unsigned_vp_fromProver). (* should be private, it is a message that includes credential, redundant i think*)\nquery attacker(vp_fromProver).    (* should be private, it is a message that includes credential*)\nquery attacker(cred_fromProver).  (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\n(*I have no idea, why this cred_fromProver is not triggered but the other cred_x are...*)\nquery attacker(access_token_fromProver). (* should be private, even with the credential leaked (this is the actual token, not the message containing it) *)\nquery attacker(K_private_fromProver).\n\nquery attacker(n_p_fromVerifier). \nquery attacker(rule_fromVerifier). (* basically public, as it is discoverable by an attacker by simply asking the verifier*)\nquery attacker(credRequest_fromVerifier). (* should be private, it is a message includes rule*)\nquery attacker(unauth_vp_fromVerifier). (* should be private, it is a message that includes credential, redundant i think*)\nquery attacker(vp_fromVerifier). (* should be private, it is a message that includes credential*)\nquery attacker(cred_fromVerifier). (* can be leaked in our model, as the prover explicitly/knowlingly talks to otherAgent (attacker) trying to authenticate with them (dishonest verifier) *)\nquery attacker(access_token_fromVerifier). (* should be private, even with the credential leaked (this is the actual token, not the message containing it) *)\nquery attacker(K_private_fromVerifier).\n\n(* AUTHETNICATION *)\n\n(* event_at_the_very_end_of_role_R_in_parallel_with_secrecy_checks\n==> \nevent_just_before_the_last_send_message_of_S *)\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_accessToken:bitstring; \n    inj-event(auth_ProverCompletesProtocol(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp, m_accessToken))\n    ==>\n    inj-event(auth_VerifierSendsLastMessageToProver(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp, m_accessToken)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring; \n    inj-event(auth_VerifierCompletesProtocol(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp))\n    ==>\n    inj-event(auth_ProverSendsLastMessageToVerifier(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_did:bitstring, m_cred:bitstring; \n    inj-event(auth_HolderCompletesProtocol(m_handshakeReq, m_handshakeResp, m_did, m_cred))\n    ==>\n    inj-event(auth_IssuerSendsLastMessageToHolder(m_handshakeReq, m_handshakeResp, m_did, m_cred)) .\n\n\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_did:bitstring; \n    inj-event(auth_IssuerCompletesProtocol(m_handshakeReq, m_handshakeResp,  m_did))\n    ==>\n    inj-event(auth_HolderSendsLastMessageToIssuer(m_handshakeReq, m_handshakeResp, m_did)) .\n\n(* inj-agreement will not work, expected, since re-use of credentials issued once for multiple provings *)\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_handshakeReq_2:G, m_handshakeResp_2:bitstring, m_did:bitstring, m_cred:bitstring; \n    inj-event(\n        auth_VerifierCompletesProtocol(\n                m_handshakeReq, \n                m_handshakeResp, \n                m_uri, \n                m_rule, \n                m_vp))\n    ==>\n    inj-event(\n        auth_ProverSendsLastMessageToVerifier(\n                m_handshakeReq, \n                m_handshakeResp, \n                m_uri, \n                m_rule, \n                m_vp)) \n    &&\n    inj-event(\n        auth_IssuerSendsLastMessageToHolder(\n                m_handshakeReq_2, \n                m_handshakeResp_2, \n                m_did, \n                m_cred)) \n    &&\n    inj-event(\n        auth_HolderCompletesProtocol(\n                m_handshakeReq_2, \n                m_handshakeResp_2, \n                m_did, \n                m_cred))\n    .\n\n(* this should hold, \"for every proving, there must be an issuing\" *)\nquery  m_handshakeReq:G, m_handshakeResp:bitstring, m_uri:bitstring, m_rule:bitstring, m_vp:bitstring, m_handshakeReq_2:G, m_handshakeResp_2:bitstring, m_did:bitstring, m_cred:bitstring; \n    event(auth_VerifierCompletesProtocol(m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp))\n    ==>\n    event(auth_IssuerSendsLastMessageToHolder(m_handshakeReq_2, m_handshakeResp_2, m_did, m_cred)) \n    &&\n    event(auth_ProverSendsLastMessageToVerifierInProtocolFull(m_handshakeReq_2, m_handshakeResp_2, m_did, m_cred, m_handshakeReq, m_handshakeResp, m_uri, m_rule, m_vp))\n    .\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Assumptions *)\n(* Start Main *)\n(* --------------------------------------------------------------------------------------------------------- *)\n\nfree sk_otherAgent:SecretKey. (*other agent may or may not be honest, but we don't know*)\nprocess (*use root process for setup *)\n    (*declare secret keys*)\n    new sk_prover:SecretKey;\n    new sk_verifier:SecretKey;\n    new sk_issuer:SecretKey;\n    (*advertise public keys*)\n    out(h,pk(sk_issuer));\n    out(h,pk(sk_verifier));\n    out(h,pk(sk_prover));\n    (*advertise DIDs*)\n    out(h,genDID(pk(sk_prover),sk_prover));\n    out(h,genDID(pk(sk_verifier),sk_verifier));\n    out(h,genDID(pk(sk_issuer),sk_issuer));\n    \n    (*assume issuer verified prover for attribute*)\n    (* credential = ( (DID_prover, attriubte, DID_issuer), signature_issuer ) *)\n    (* let cred = issueVC(  genDID(pk(sk_prover),sk_prover),   attr,    sk_issuer   ) \n    let cred_otherAgent = issueVC(  genDID(pk(sk_otherAgent),sk_otherAgent),   attr,    sk_issuer   ) in \n    out(h,cred_otherAgent); *)\n\n    (*assume verifier trusts issuer for asserting attribute*)\n    (* rule = (DID_prover , attribute , DID_issuer) *)\n    let acr = makeRule(  genDID(pk(sk_prover),sk_prover),   attr,   genDID(pk(sk_issuer),sk_issuer)  ) in (* where prover p is honest agent*)\n    let acr_otherAgent = makeRule(  genDID(pk(sk_otherAgent),sk_otherAgent),   attr,   genDID(pk(sk_issuer),sk_issuer)  ) in (* where other agent may or may not be dishonest*)\n    let acr_compromisedIssuer = makeRule(  genDID(pk(sk_prover),sk_prover),   attr,   genDID(pk(sk_otherAgent),sk_otherAgent)  ) in\n    let acr_compromised = makeRule(  genDID(pk(sk_otherAgent),sk_otherAgent),   attr,   genDID(pk(sk_otherAgent),sk_otherAgent)  ) in\n\n    (*let agents dance*)\n    (\n    (\n        !issuer(sk_issuer, attr, genDID(pk(sk_prover),sk_prover), true)\n    |   \n        !issuer(sk_issuer, attr, genDID(pk(sk_otherAgent),sk_otherAgent), false)\n    |\n        !holder(sk_prover,  genDID(pk(sk_issuer),sk_issuer), genDID(pk(sk_verifier),sk_verifier), true)\n    |\n        !holder(sk_prover,  genDID(pk(sk_issuer),sk_issuer), genDID(pk(sk_otherAgent),sk_otherAgent), false) \n    |\n        !holder(sk_prover,  genDID(pk(sk_otherAgent),sk_otherAgent), genDID(pk(sk_verifier),sk_verifier), false) \n    |\n        !holder(sk_prover,  genDID(pk(sk_otherAgent),sk_otherAgent), genDID(pk(sk_otherAgent),sk_otherAgent), false) \n    |\n        !verifier(sk_verifier, acr, true) \n    | \n        !verifier(sk_verifier, acr_otherAgent, false)\n    | \n        !verifier(sk_verifier, acr_compromisedIssuer, false) \n    | \n        !verifier(sk_verifier, acr_compromised, false) \n    ) \n  \n    \n    )\n\n(* --------------------------------------------------------------------------------------------------------- *)\n(* End Main *)\n(* --------------------------------------------------------------------------------------------------------- *)"
    }
]