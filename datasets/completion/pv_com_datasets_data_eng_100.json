[
    {
        "file": "PV-1/AugmentedEKE2.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3\n   One does not know whether one decrypts { challengeA, challengeB }_K\n   and similar messages correctly. *)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree c: channel.\n\ntype ____(TYPE_1)____.\ntype passwd.\ntype nonce.\ntype G.\ntype ____(TYPE_0)____.\ntype key.\n\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\nfun G_to_key(G): key [data, typeConverter].\nfun G_to_bitstring(G):bitstring [____(FUN_1)____, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, ____(OP_14)____): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric cryptography\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(____(OP_3)____, key): bitstring.\nfun dec(bitstring, key): bitstring.\nequation forall x: bitstring, y: key; dec(enc(x,y),y) = x.\nequation ____(EQUATION_0)____ ____(EQUATION_2)____: bitstring, ____(EQUATION_1)____: key; enc(dec(x,y),y) = x.\n\n(* Hash function *)\n\nfun h(passwd):____(FUN_2)____.\n\n(* One-way function *)\n\nfun F(passwd, ____(FUN_0)____): bitstring.\n\n(* Predicate *)\n\nreduc ____(REDUC_3)____ ____(REDUC_1)____: ____(REDUC_2)____, ____(REDUC_0)____: key; T(h(____(OP_15)____), F(x,y), y) = true.\n\n(* Host names *)\n\nconst A, ____(CONST_0)____: host.\n\n\n\nfree PAB, ____(FREE_1)____, ____(FREE_0)____: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(____(OP_7)____: host, ____(OP_8)____: host, P: passwd) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(G_to_bitstring(exp(g, RA)), h(P))));\n\tin(____(OP_19)____, (m1: ____(OP_20)____, m2: bitstring));\n\tlet G_to_bitstring(____(OP_5)____) = dec(m1, h(P)) in\n\tlet ____(LET_0)____ = G_to_key(exp(gRB, RA)) in\n\tlet nonce_to_bitstring(challengeB) = dec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, enc((____(OP_1)____, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(____(IF_0)____) = dec(m3, K) then\n\tout(c, enc(F(P,K), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: ____(OP_9)____));\n\tlet G_to_bitstring(____(OP_11)____) = dec(____(OP_17)____, h(P)) in \n\tnew RB: ____(NEW_0)____;\n\tlet ____(LET_1)____ = G_to_key(exp(gRA, ____(OP_10)____)) in\n\tnew challengeB: nonce;\n\tout(c, (enc(G_to_bitstring(exp(g, RB)), h(____(OP_4)____)), enc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (challengeA: nonce, =challengeB) = dec(m4, K) in\n\tout(c, enc(nonce_to_bitstring(challengeA), K));\n\tin(c, ____(OP_12)____: bitstring);\n\tlet fr = dec(m5, K) in\n\tif T(h(P), fr, K) = true then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(____(OP_0)____, A, PAA)) |\n\t(!processB(____(OP_18)____, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(____(OP_13)____, A, PAB)) |\n\t(!processB(____(OP_16)____, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n1.575s (user 1.539s + system 0.036s), max rss 31472K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Augmented EKE, Bellovin, Merritt,\n   Section 3\n   One does not know whether one decrypts { challengeA, challengeB }_K\n   and similar messages correctly. *)\n\n(* There is an attack if the adversary can distinguish a group element\nin G from a random bitstring. (The adversary decrypts the first message\nwith h(P') for the guessed password P' and concludes that the guess is\ngood if the result is an element of G.) *)\n(* set ignoreTypes = true. *)\n\nfree c: channel.\n\ntype host.\ntype passwd.\ntype nonce.\ntype G.\ntype exponent.\ntype key.\n\n\nfun nonce_to_bitstring(nonce): bitstring [data, typeConverter].\nfun G_to_key(G): key [data, typeConverter].\nfun G_to_bitstring(G):bitstring [data, typeConverter].\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Symmetric cryptography\n   One does not know whether decryption succeeds or not\n   For use with weak secrets *)\n\nfun enc(bitstring, key): bitstring.\nfun dec(bitstring, key): bitstring.\nequation forall x: bitstring, y: key; dec(enc(x,y),y) = x.\nequation forall x: bitstring, y: key; enc(dec(x,y),y) = x.\n\n(* Hash function *)\n\nfun h(passwd):key.\n\n(* One-way function *)\n\nfun F(passwd, key): bitstring.\n\n(* Predicate *)\n\nreduc forall x: passwd, y: key; T(h(x), F(x,y), y) = true.\n\n(* Host names *)\n\nconst A, B: host.\n\n\n\nfree PAB, PAA, PBB: passwd [private].\nweaksecret PAB.\nweaksecret PAA.\nweaksecret PBB.\n\n(* Initiator with identity hostA talking to responder with identity hostX *)\n\nlet processA(hostA: host, hostX: host, P: passwd) = \n\tnew RA: exponent;\n\tout(c, (hostA, enc(G_to_bitstring(exp(g, RA)), h(P))));\n\tin(c, (m1: bitstring, m2: bitstring));\n\tlet G_to_bitstring(gRB) = dec(m1, h(P)) in\n\tlet K = G_to_key(exp(gRB, RA)) in\n\tlet nonce_to_bitstring(challengeB) = dec(m2, K) in\n\tnew challengeA: nonce;\n\tout(c, enc((challengeA, challengeB), K));\n\tin(c, m3: bitstring);\n\tif nonce_to_bitstring(challengeA) = dec(m3, K) then\n\tout(c, enc(F(P,K), K)).\n\n(* Responder with identity hostB talking to initiator with identity hostX *)\n\nlet processB(hostB: host, hostX: host, P: passwd) =\n\tin(c, (=hostX, m: bitstring));\n\tlet G_to_bitstring(gRA) = dec(m, h(P)) in \n\tnew RB: exponent;\n\tlet K = G_to_key(exp(gRA, RB)) in\n\tnew challengeB: nonce;\n\tout(c, (enc(G_to_bitstring(exp(g, RB)), h(P)), enc(nonce_to_bitstring(challengeB), K)));\n\tin(c, m4: bitstring);\n\tlet (challengeA: nonce, =challengeB) = dec(m4, K) in\n\tout(c, enc(nonce_to_bitstring(challengeA), K));\n\tin(c, m5: bitstring);\n\tlet fr = dec(m5, K) in\n\tif T(h(P), fr, K) = true then\n\t0.\n\n(* The code for A or B talking to other participants can be considered\nas part of the adversary, since it does not share secrets with the\ncode for A or B talking to A or B. (The only secret is the password.)\n\nThe code for A talking to A (and for B talking to B) could also be\nseparated from the rest, since it does not share secrets with the code\nfor A talking to B and for B talking to A.\n\nHere, I made the choice that A and B use the same password when A\ntalks to B and when B talks to A. It would be easy to write the other\noption in which they use a different password in each direction. *)\n\nprocess \n\t(!processA(A, A, PAA)) |\n\t(!processB(A, A, PAA)) |\n\t(!processA(B, B, PBB)) |\n\t(!processB(B, B, PBB)) |\n\t(!processA(A, B, PAB)) |\n\t(!processB(A, B, PAB)) |\n\t(!processA(B, A, PAB)) |\n\t(!processB(B, A, PAB))\n\n\n(* EXPECTPV\nRESULT Weak secret PAB is true.\nRESULT Weak secret PAA is true.\nRESULT Weak secret PBB is true.\n1.575s (user 1.539s + system 0.036s), max rss 31472K\nEND *)"
    },
    {
        "file": "PV-1/basic1-1.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfun hash(____(FUN_0)____): bitstring.\n\nfree c: ____(FREE_0)____.\nfree x, n: bitstring [private].\n\nnoninterf x among (n, hash(n)).\n\nprocess\n\tout(____(OP_0)____, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\n0.011s (user 0.004s + system 0.007s), max rss 9820K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfun hash(bitstring): bitstring.\n\nfree c: channel.\nfree x, n: bitstring [private].\n\nnoninterf x among (n, hash(n)).\n\nprocess\n\tout(c, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\n0.011s (user 0.004s + system 0.007s), max rss 9820K\nEND *)"
    },
    {
        "file": "PV-1/basicweaksecret.pv",
        "incomplete": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Basic weak secret example, from JLAP paper\n   Corrected version *)\n\ntype ____(TYPE_0)____.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun penc(____(FUN_0)____, ____(OP_1)____, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall ____(EQUATION_3)____: ____(EQUATION_0)____, ____(EQUATION_1)____: skey, ____(EQUATION_2)____: seed;  pdec(penc(x, pk(____(OP_0)____), z), y) = x.\n\n(* Hash function *)\n\nfun h(passwd): bitstring.\n\nfree c: ____(FREE_0)____.\nfree w: passwd [private].\n\nweaksecret w.\n\nprocess\n\tnew s: ____(NEW_0)____;\n\tnew a: seed;\n\tout(c, pk(s));\n\tout(c, penc(h(w), pk(s), a))\n\n(* EXPECTPV\nRESULT Weak secret w is true.\n0.016s (user 0.016s + system 0.000s), max rss 10280K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Basic weak secret example, from JLAP paper\n   Corrected version *)\n\ntype skey.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun penc(bitstring, pkey, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall x: bitstring, y: skey, z: seed;  pdec(penc(x, pk(y), z), y) = x.\n\n(* Hash function *)\n\nfun h(passwd): bitstring.\n\nfree c: channel.\nfree w: passwd [private].\n\nweaksecret w.\n\nprocess\n\tnew s: skey;\n\tnew a: seed;\n\tout(c, pk(s));\n\tout(c, penc(h(w), pk(s), a))\n\n(* EXPECTPV\nRESULT Weak secret w is true.\n0.016s (user 0.016s + system 0.000s), max rss 10280K\nEND *)"
    }
]