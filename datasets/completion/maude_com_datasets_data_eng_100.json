[
    {
        "file": "MAUDE-1/Denning-Sacco.maude",
        "incomplete": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort ____(SUBSORT_0)____ Nonce  Key < Msg .\n  subsort Masterkey  ____(SUBSORT_1)____ < Key .\n  subsort ____(SUBSORT_2)____ UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> ____(OP_1)____ [____(OP_0)____] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : ____(OP_5)____ Name -> ____(OP_4)____ [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> ____(OP_7)____ [____(OP_6)____] .\n\n  ---encrypt\n  op e : Key ____(OP_8)____ -> Msg [____(OP_9)____] .\n  op d : ____(OP_10)____ Msg -> Msg  [____(OP_11)____] .\n\n  --- Concatenation\n  op ____(OP_13)____ : Msg Msg -> Msg [frozen ____(OP_14)____ (e ____(OP_12)____)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(____(EQ_4)____, e(____(EQ_8)____:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(____(EQ_5)____, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars ____(VAR_0)____ M2 ____(VAR_1)____ ____(EQ_0)____ : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,____(EQ_13)____)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,____(EQ_1)____)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; ____(EQ_7)____) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(____(EQ_14)____,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; ____(EQ_3)____),\n            -(e(mkey(____(EQ_11)____,____(EQ_12)____), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(____(EQ_6)____,B,n(s,r)) \n                         ; t(s,____(EQ_2)____) \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(____(EQ_10)____) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(____(EQ_9)____,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "complete:": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm"
    },
    {
        "file": "MAUDE-1/maa-crc.maude",
        "incomplete": "fmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [____(OP_0)____] .\n  op Xtrue : -> ____(OP_1)____ [ctor] .\n  op x0 : -> Bit [____(OP_2)____] .\n  op x1 : -> ____(OP_3)____ [ctor] .\n  op ____(OP_7)____ : ____(OP_4)____ ____(OP_5)____ Bit Bit Bit Bit Bit Bit -> Octet [____(OP_6)____] .\n  op buildOctetSum : Bit Octet -> ____(OP_9)____ [____(OP_8)____] .\n  op ____(OP_11)____ : Octet Octet -> Half [____(OP_10)____] .\n  op ____(OP_12)____ : ____(OP_13)____ Half -> HalfSum [ctor] .\n  op ____(OP_15)____ : Octet Octet Octet Octet -> ____(OP_14)____ [ctor] .\n  op buildBlockSum : Bit Block -> ____(OP_17)____ [____(OP_16)____] .\n  op buildPair : ____(OP_19)____ Block -> ____(OP_18)____ [ctor] .\n  op ____(OP_20)____ : -> Nat [ctor] .\n  op succ : Nat -> Nat [____(OP_21)____] .\n  op ____(OP_22)____ : ____(OP_23)____ Block -> Key [ctor] .\n  op unitMessage : ____(OP_24)____ -> Message [ctor] .\n  op consMessage : ____(OP_26)____ ____(OP_25)____ -> Message [ctor] .\n  op ____(OP_27)____ : Message -> SegmentedMessage [ctor] .\n  op ____(OP_28)____ : Message SegmentedMessage -> SegmentedMessage [____(OP_29)____] .\n  op notBool : ____(OP_30)____ -> Xbool .\n  op andBool : ____(OP_31)____ Xbool -> Xbool .\n  op ____(OP_32)____ : Xbool Xbool -> Xbool .\n  op xorBool : ____(OP_33)____ Xbool -> Xbool .\n  op notBit : ____(OP_34)____ -> Bit .\n  op andBit : ____(OP_35)____ Bit -> Bit .\n  op ____(OP_36)____ : Bit Bit -> Bit .\n  op xorBit : ____(OP_37)____ Bit -> Bit .\n  op x00 : -> Octet .\n  op x01 : -> Octet .\n  op x0000 : -> Half .\n  op HalfU : ____(OP_38)____ -> Half .\n  op HalfL : Block -> ____(OP_39)____ .\n  op ____(OP_40)____ : Bit Bit -> Xbool .\n  op eqOctet : ____(OP_41)____ Octet -> Xbool .\n  op eqOctetSum : ____(OP_42)____ OctetSum -> Xbool .\n  op eqHalf : ____(OP_43)____ Half -> Xbool .\n  op eqHalfSum : ____(OP_44)____ HalfSum -> Xbool .\n  op eqBlock : ____(OP_45)____ Block -> Xbool .\n  op ____(OP_46)____ : BlockSum BlockSum -> Xbool .\n  op ____(OP_47)____ : Pair Pair -> Xbool .\n  op addBit : ____(OP_48)____ ____(OP_49)____ Bit -> Bit .\n  op carBit : ____(OP_50)____ ____(OP_51)____ Bit -> Bit .\n  op addOctetSum : ____(OP_52)____ Octet Bit -> ____(OP_53)____ .\n  op addOctet8 : ____(OP_54)____ ____(OP_55)____ ____(OP_56)____ ____(OP_57)____ ____(OP_58)____ ____(OP_59)____ ____(OP_60)____ Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op ____(OP_65)____ : ____(OP_61)____ ____(OP_62)____ ____(OP_63)____ ____(OP_64)____ ____(OP_66)____ ____(OP_67)____ Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet6 : ____(OP_68)____ ____(OP_69)____ ____(OP_70)____ ____(OP_71)____ ____(OP_73)____ Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> ____(OP_72)____ .\n  op addOctet5 : ____(OP_74)____ ____(OP_75)____ ____(OP_76)____ ____(OP_77)____ ____(OP_79)____ Bit Bit Bit Bit Bit Bit Bit Bit Bit -> ____(OP_78)____ .\n  op addOctet4 : ____(OP_80)____ ____(OP_81)____ ____(OP_82)____ ____(OP_83)____ ____(OP_84)____ ____(OP_85)____ Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet3 : ____(OP_86)____ ____(OP_87)____ ____(OP_88)____ ____(OP_89)____ ____(OP_90)____ Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet2 : ____(OP_91)____ ____(OP_92)____ ____(OP_93)____ ____(OP_94)____ ____(OP_95)____ Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet1 : ____(OP_96)____ ____(OP_97)____ ____(OP_98)____ ____(OP_99)____ Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op ____(OP_103)____ : ____(OP_100)____ ____(OP_101)____ ____(OP_102)____ Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op dropCarryOctetSum : ____(OP_104)____ -> Octet .\n  op addOctet : ____(OP_105)____ Octet -> Octet .\n  op addHalfSum : ____(OP_106)____ Half -> HalfSum .\n  op addHalf2 : ____(OP_107)____ Octet Octet Octet -> ____(OP_108)____ .\n  op addHalf1 : ____(OP_109)____ Octet OctetSum -> ____(OP_110)____ .\n  op addHalf0 : OctetSum ____(OP_111)____ -> HalfSum .\n  op dropCarryHalfSum : ____(OP_112)____ -> Half .\n  op addHalf : ____(OP_113)____ Half -> Half .\n  op addHalfOctet : ____(OP_114)____ Half -> Half .\n  op addHalfOctets : ____(OP_115)____ Octet -> Half .\n  op addBlockSum : ____(OP_116)____ Block -> BlockSum .\n  op addBlock4 : ____(OP_117)____ ____(OP_118)____ ____(OP_119)____ Octet Octet Octet Octet Octet -> ____(OP_120)____ .\n  op ____(OP_123)____ : ____(OP_121)____ ____(OP_122)____ Octet Octet Octet Octet OctetSum -> BlockSum .\n  op ____(OP_126)____ : ____(OP_124)____ ____(OP_125)____ Octet Octet OctetSum Octet -> BlockSum .\n  op ____(OP_127)____ : ____(OP_128)____ Octet OctetSum Octet Octet -> BlockSum .\n  op ____(OP_130)____ : OctetSum ____(OP_129)____ Octet Octet -> BlockSum .\n  op dropCarryBlockSum : BlockSum -> ____(OP_131)____ .\n  op addBlock : ____(OP_132)____ Block -> Block .\n  op addBlockHalf : Half ____(OP_133)____ -> Block .\n  op addBlockHalves : ____(OP_134)____ Half -> Block .\n  op ____(OP_135)____ : Octet -> Octet .\n  op leftOctet2 : ____(OP_136)____ -> Octet .\n  op leftOctet3 : ____(OP_137)____ -> Octet .\n  op leftOctet4 : ____(OP_138)____ -> Octet .\n  op leftOctet5 : ____(OP_139)____ -> Octet .\n  op ____(OP_140)____ : Octet -> Octet .\n  op ____(OP_141)____ : Octet -> Octet .\n  op ____(OP_142)____ : Octet -> Octet .\n  op rightOctet2 : ____(OP_143)____ -> Octet .\n  op ____(OP_144)____ : Octet -> Octet .\n  op ____(OP_145)____ : Octet -> Octet .\n  op rightOctet5 : ____(OP_146)____ -> Octet .\n  op ____(OP_147)____ : Octet -> Octet .\n  op rightOctet7 : ____(OP_148)____ -> Octet .\n  op mulOctet : ____(OP_149)____ Octet -> Half .\n  op mulOctet1 : ____(OP_150)____ ____(OP_153)____ Bit Bit Bit Bit Bit Bit Octet ____(OP_151)____ -> ____(OP_152)____ .\n  op mulOctet2 : ____(OP_154)____ ____(OP_155)____ ____(OP_156)____ Bit Bit Bit Bit Octet ____(OP_157)____ -> Half .\n  op ____(OP_161)____ : ____(OP_159)____ ____(OP_160)____ Bit Bit Bit Bit Octet ____(OP_158)____ -> Half .\n  op mulOctet4 : ____(OP_164)____ Bit Bit Bit Bit ____(OP_163)____ ____(OP_162)____ -> Half .\n  op ____(OP_167)____ : ____(OP_165)____ Bit Bit Bit Octet ____(OP_166)____ -> Half .\n  op ____(OP_168)____ : ____(OP_169)____ Bit Bit Octet Half -> Half .\n  op ____(OP_171)____ : ____(OP_170)____ Bit Octet Half -> Half .\n  op ____(OP_172)____ : Bit ____(OP_173)____ Half -> Half .\n  op mulOctetA : ____(OP_174)____ ____(OP_175)____ Octet -> Half .\n  op mulOctetB : Octet ____(OP_176)____ -> Half .\n  op mulHalf : Half Half -> ____(OP_177)____ .\n  op ____(OP_178)____ : Half Half Half Half -> ____(OP_179)____ .\n  op ____(OP_181)____ : ____(OP_180)____ ____(OP_182)____ ____(OP_183)____ Octet Octet Octet Octet Octet -> Block .\n  op mulHalf3 : ____(OP_184)____ ____(OP_186)____ Octet Octet Half Octet -> ____(OP_185)____ .\n  op mulHalf2 : ____(OP_187)____ Half Octet Octet -> ____(OP_188)____ .\n  op mulHalf1 : Half ____(OP_189)____ ____(OP_190)____ Octet -> Block .\n  op mulBlock : Block Block -> ____(OP_191)____ .\n  op mulBlockA : ____(OP_192)____ ____(OP_193)____ Block Block -> Pair .\n  op ____(OP_195)____ : ____(OP_194)____ ____(OP_197)____ Half Half Half Half Half Half -> ____(OP_196)____ .\n  op mulBlock3 : ____(OP_198)____ ____(OP_199)____ ____(OP_200)____ Half Block Half -> Pair .\n  op mulBlock2 : Half ____(OP_202)____ Half Half -> ____(OP_201)____ .\n  op ____(OP_203)____ : Block ____(OP_204)____ Half Half -> Pair .\n  op ____(OP_205)____ : ____(OP_206)____ Half Half Half -> Pair .\n  op addNat : ____(OP_207)____ Nat -> Nat .\n  op multNat : ____(OP_208)____ Nat -> Nat .\n  op ____(OP_209)____ : Nat Nat -> Xbool .\n  op ltNat : Nat Nat -> ____(OP_210)____ .\n  op n1 : -> Nat .\n  op n2 : -> Nat .\n  op n3 : -> Nat .\n  op n4 : -> Nat .\n  op n5 : -> Nat .\n  op n6 : -> Nat .\n  op n7 : -> Nat .\n  op n8 : -> Nat .\n  op n9 : -> Nat .\n  op n10 : -> Nat .\n  op n11 : -> Nat .\n  op n12 : -> Nat .\n  op n13 : -> Nat .\n  op n14 : -> Nat .\n  op n15 : -> Nat .\n  op n16 : -> Nat .\n  op n17 : -> Nat .\n  op n18 : -> Nat .\n  op n19 : -> Nat .\n  op n20 : -> Nat .\n  op n21 : -> Nat .\n  op n22 : -> Nat .\n  op n254 : -> Nat .\n  op n256 : -> Nat .\n  op n4100 : -> Nat .\n  op andOctet : ____(OP_211)____ Octet -> Octet .\n  op ____(OP_212)____ : Octet Octet -> Octet .\n  op xorOctet : ____(OP_213)____ Octet -> Octet .\n  op x02 : -> Octet .\n  op x03 : -> Octet .\n  op x04 : -> Octet .\n  op x05 : -> Octet .\n  op x06 : -> Octet .\n  op x07 : -> Octet .\n  op x08 : -> Octet .\n  op x09 : -> Octet .\n  op x0A : -> Octet .\n  op x0B : -> Octet .\n  op x0C : -> Octet .\n  op x0D : -> Octet .\n  op x0E : -> Octet .\n  op x0F : -> Octet .\n  op x10 : -> Octet .\n  op x11 : -> Octet .\n  op x12 : -> Octet .\n  op x13 : -> Octet .\n  op x14 : -> Octet .\n  op x15 : -> Octet .\n  op x16 : -> Octet .\n  op x17 : -> Octet .\n  op x18 : -> Octet .\n  op x1A : -> Octet .\n  op x1B : -> Octet .\n  op x1C : -> Octet .\n  op x1D : -> Octet .\n  op x1E : -> Octet .\n  op x1F : -> Octet .\n  op x20 : -> Octet .\n  op x21 : -> Octet .\n  op x23 : -> Octet .\n  op x24 : -> Octet .\n  op x25 : -> Octet .\n  op x26 : -> Octet .\n  op x27 : -> Octet .\n  op x28 : -> Octet .\n  op x29 : -> Octet .\n  op x2A : -> Octet .\n  op x2B : -> Octet .\n  op x2D : -> Octet .\n  op x2E : -> Octet .\n  op x2F : -> Octet .\n  op x30 : -> Octet .\n  op x31 : -> Octet .\n  op x32 : -> Octet .\n  op x33 : -> Octet .\n  op x34 : -> Octet .\n  op x35 : -> Octet .\n  op x36 : -> Octet .\n  op x37 : -> Octet .\n  op x38 : -> Octet .\n  op x39 : -> Octet .\n  op x3A : -> Octet .\n  op x3B : -> Octet .\n  op x3C : -> Octet .\n  op x3D : -> Octet .\n  op x3F : -> Octet .\n  op x40 : -> Octet .\n  op x46 : -> Octet .\n  op x48 : -> Octet .\n  op x49 : -> Octet .\n  op x4A : -> Octet .\n  op x4B : -> Octet .\n  op x4C : -> Octet .\n  op x4D : -> Octet .\n  op x4E : -> Octet .\n  op x4F : -> Octet .\n  op x50 : -> Octet .\n  op x51 : -> Octet .\n  op x53 : -> Octet .\n  op x54 : -> Octet .\n  op x55 : -> Octet .\n  op x58 : -> Octet .\n  op x5A : -> Octet .\n  op x5B : -> Octet .\n  op x5C : -> Octet .\n  op x5D : -> Octet .\n  op x5E : -> Octet .\n  op x5F : -> Octet .\n  op x60 : -> Octet .\n  op x61 : -> Octet .\n  op x62 : -> Octet .\n  op x63 : -> Octet .\n  op x64 : -> Octet .\n  op x65 : -> Octet .\n  op x66 : -> Octet .\n  op x67 : -> Octet .\n  op x69 : -> Octet .\n  op x6A : -> Octet .\n  op x6B : -> Octet .\n  op x6C : -> Octet .\n  op x6D : -> Octet .\n  op x6E : -> Octet .\n  op x6F : -> Octet .\n  op x70 : -> Octet .\n  op x71 : -> Octet .\n  op x72 : -> Octet .\n  op x73 : -> Octet .\n  op x74 : -> Octet .\n  op x75 : -> Octet .\n  op x76 : -> Octet .\n  op x77 : -> Octet .\n  op x78 : -> Octet .\n  op x79 : -> Octet .\n  op x7A : -> Octet .\n  op x7B : -> Octet .\n  op x7C : -> Octet .\n  op x7D : -> Octet .\n  op x7E : -> Octet .\n  op x7F : -> Octet .\n  op x80 : -> Octet .\n  op x81 : -> Octet .\n  op x83 : -> Octet .\n  op x84 : -> Octet .\n  op x85 : -> Octet .\n  op x86 : -> Octet .\n  op x88 : -> Octet .\n  op x89 : -> Octet .\n  op x8A : -> Octet .\n  op x8C : -> Octet .\n  op x8D : -> Octet .\n  op x8E : -> Octet .\n  op x8F : -> Octet .\n  op x90 : -> Octet .\n  op x91 : -> Octet .\n  op x92 : -> Octet .\n  op x93 : -> Octet .\n  op x95 : -> Octet .\n  op x96 : -> Octet .\n  op x97 : -> Octet .\n  op x98 : -> Octet .\n  op x99 : -> Octet .\n  op x9A : -> Octet .\n  op x9B : -> Octet .\n  op x9C : -> Octet .\n  op x9D : -> Octet .\n  op x9E : -> Octet .\n  op x9F : -> Octet .\n  op xA0 : -> Octet .\n  op xA1 : -> Octet .\n  op xA2 : -> Octet .\n  op xA3 : -> Octet .\n  op xA4 : -> Octet .\n  op xA5 : -> Octet .\n  op xA6 : -> Octet .\n  op xA7 : -> Octet .\n  op xA8 : -> Octet .\n  op xA9 : -> Octet .\n  op xAA : -> Octet .\n  op xAB : -> Octet .\n  op xAC : -> Octet .\n  op xAE : -> Octet .\n  op xAF : -> Octet .\n  op xB0 : -> Octet .\n  op xB1 : -> Octet .\n  op xB2 : -> Octet .\n  op xB3 : -> Octet .\n  op xB5 : -> Octet .\n  op xB6 : -> Octet .\n  op xB8 : -> Octet .\n  op xB9 : -> Octet .\n  op xBA : -> Octet .\n  op xBB : -> Octet .\n  op xBC : -> Octet .\n  op xBE : -> Octet .\n  op xBF : -> Octet .\n  op xC0 : -> Octet .\n  op xC1 : -> Octet .\n  op xC2 : -> Octet .\n  op xC4 : -> Octet .\n  op xC5 : -> Octet .\n  op xC6 : -> Octet .\n  op xC7 : -> Octet .\n  op xC8 : -> Octet .\n  op xC9 : -> Octet .\n  op xCA : -> Octet .\n  op xCB : -> Octet .\n  op xCC : -> Octet .\n  op xCD : -> Octet .\n  op xCE : -> Octet .\n  op xD0 : -> Octet .\n  op xD1 : -> Octet .\n  op xD2 : -> Octet .\n  op xD3 : -> Octet .\n  op xD4 : -> Octet .\n  op xD5 : -> Octet .\n  op xD6 : -> Octet .\n  op xD7 : -> Octet .\n  op xD8 : -> Octet .\n  op xD9 : -> Octet .\n  op xDB : -> Octet .\n  op xDC : -> Octet .\n  op xDD : -> Octet .\n  op xDE : -> Octet .\n  op xDF : -> Octet .\n  op xE0 : -> Octet .\n  op xE1 : -> Octet .\n  op xE3 : -> Octet .\n  op xE6 : -> Octet .\n  op xE8 : -> Octet .\n  op xE9 : -> Octet .\n  op xEA : -> Octet .\n  op xEB : -> Octet .\n  op xEC : -> Octet .\n  op xED : -> Octet .\n  op xEE : -> Octet .\n  op xEF : -> Octet .\n  op xF0 : -> Octet .\n  op xF1 : -> Octet .\n  op xF2 : -> Octet .\n  op xF3 : -> Octet .\n  op xF4 : -> Octet .\n  op xF5 : -> Octet .\n  op xF6 : -> Octet .\n  op xF7 : -> Octet .\n  op xF8 : -> Octet .\n  op xF9 : -> Octet .\n  op xFA : -> Octet .\n  op xFB : -> Octet .\n  op xFC : -> Octet .\n  op xFD : -> Octet .\n  op xFE : -> Octet .\n  op xFF : -> Octet .\n  op andBlock : ____(OP_214)____ Block -> Block .\n  op orBlock : ____(OP_215)____ Block -> Block .\n  op xorBlock : ____(OP_216)____ Block -> Block .\n  op x0001 : -> Half .\n  op x00000000 : -> Block .\n  op x00000001 : -> Block .\n  op x00000002 : -> Block .\n  op x00000003 : -> Block .\n  op x00000004 : -> Block .\n  op x00000005 : -> Block .\n  op x00000006 : -> Block .\n  op x00000007 : -> Block .\n  op x00000008 : -> Block .\n  op x00000009 : -> Block .\n  op x0000000A : -> Block .\n  op x0000000B : -> Block .\n  op x0000000C : -> Block .\n  op x0000000D : -> Block .\n  op x0000000E : -> Block .\n  op x0000000F : -> Block .\n  op x00000010 : -> Block .\n  op x00000012 : -> Block .\n  op x00000014 : -> Block .\n  op x00000016 : -> Block .\n  op x00000018 : -> Block .\n  op x0000001B : -> Block .\n  op x0000001D : -> Block .\n  op x0000001E : -> Block .\n  op x0000001F : -> Block .\n  op x00000031 : -> Block .\n  op x00000036 : -> Block .\n  op x00000060 : -> Block .\n  op x00000080 : -> Block .\n  op x000000A5 : -> Block .\n  op x000000B6 : -> Block .\n  op x000000C4 : -> Block .\n  op x000000D2 : -> Block .\n  op x00000100 : -> Block .\n  op x00000129 : -> Block .\n  op x0000018C : -> Block .\n  op x00004000 : -> Block .\n  op x00010000 : -> Block .\n  op x00020000 : -> Block .\n  op x00030000 : -> Block .\n  op x00040000 : -> Block .\n  op x00060000 : -> Block .\n  op x00804021 : -> Block .\n  op x00FF00FF : -> Block .\n  op x0103050B : -> Block .\n  op x01030703 : -> Block .\n  op x01030705 : -> Block .\n  op x0103070F : -> Block .\n  op x02040801 : -> Block .\n  op x0297AF6F : -> Block .\n  op x07050301 : -> Block .\n  op x077788A2 : -> Block .\n  op x07C72EAA : -> Block .\n  op x0A202020 : -> Block .\n  op x0AD67E20 : -> Block .\n  op x10000000 : -> Block .\n  op x11A9D254 : -> Block .\n  op x11AC46B8 : -> Block .\n  op x1277A6D4 : -> Block .\n  op x13647149 : -> Block .\n  op x160EE9B5 : -> Block .\n  op x17065DBB : -> Block .\n  op x17A808FD : -> Block .\n  op x1D10D8D3 : -> Block .\n  op x1D3B7760 : -> Block .\n  op x1D9C9655 : -> Block .\n  op x1F3F7FFF : -> Block .\n  op x204E80A7 : -> Block .\n  op x21D869BA : -> Block .\n  op x24B66FB5 : -> Block .\n  op x270EEDAF : -> Block .\n  op x277B4B25 : -> Block .\n  op x2829040B : -> Block .\n  op x288FC786 : -> Block .\n  op x28EAD8B3 : -> Block .\n  op x29907CD8 : -> Block .\n  op x29C1485F : -> Block .\n  op x29EEE96B : -> Block .\n  op x2A6091AE : -> Block .\n  op x2BF8499A : -> Block .\n  op x2E80AC30 : -> Block .\n  op x2FD76FFB : -> Block .\n  op x30261492 : -> Block .\n  op x303FF4AA : -> Block .\n  op x33D5A466 : -> Block .\n  op x344925FC : -> Block .\n  op x34ACF886 : -> Block .\n  op x3CD54DEB : -> Block .\n  op x3CF3A7D2 : -> Block .\n  op x3DD81AC6 : -> Block .\n  op x3F6F7248 : -> Block .\n  op x48B204D6 : -> Block .\n  op x4A645A01 : -> Block .\n  op x4C49AAE0 : -> Block .\n  op x4CE933E1 : -> Block .\n  op x4D53901A : -> Block .\n  op x4DA124A1 : -> Block .\n  op x4F998E01 : -> Block .\n  op x4FB1138A : -> Block .\n  op x50DEC930 : -> Block .\n  op x51AF3C1D : -> Block .\n  op x51EDE9C7 : -> Block .\n  op x550D91CE : -> Block .\n  op x55555555 : -> Block .\n  op x55DD063F : -> Block .\n  op x5834A585 : -> Block .\n  op x5A35D667 : -> Block .\n  op x5BC02502 : -> Block .\n  op x5CCA3239 : -> Block .\n  op x5EBA06C2 : -> Block .\n  op x5F38EEF1 : -> Block .\n  op x613F8E2A : -> Block .\n  op x63C70DBA : -> Block .\n  op x6AD6E8A4 : -> Block .\n  op x6AEBACF8 : -> Block .\n  op x6D67E884 : -> Block .\n  op x7050EC5E : -> Block .\n  op x717153D5 : -> Block .\n  op x7201F4DC : -> Block .\n  op x7397C9AE : -> Block .\n  op x74B39176 : -> Block .\n  op x76232E5F : -> Block .\n  op x7783C51D : -> Block .\n  op x7792F9D4 : -> Block .\n  op x7BC180AB : -> Block .\n  op x7DB2D9F4 : -> Block .\n  op x7DFEFBFF : -> Block .\n  op x7F76A3B0 : -> Block .\n  op x7F839576 : -> Block .\n  op x7FFFFFF0 : -> Block .\n  op x7FFFFFF1 : -> Block .\n  op x7FFFFFFC : -> Block .\n  op x7FFFFFFD : -> Block .\n  op x80000000 : -> Block .\n  op x80000002 : -> Block .\n  op x800000C2 : -> Block .\n  op x80018000 : -> Block .\n  op x80018001 : -> Block .\n  op x80397302 : -> Block .\n  op x81D10CA3 : -> Block .\n  op x89D635D7 : -> Block .\n  op x8CE37709 : -> Block .\n  op x8DC8BBDE : -> Block .\n  op x9115A558 : -> Block .\n  op x91896CFA : -> Block .\n  op x9372CDC6 : -> Block .\n  op x98D1CC75 : -> Block .\n  op x9D15C437 : -> Block .\n  op x9DB15CF6 : -> Block .\n  op x9E2E7B36 : -> Block .\n  op xA018C83B : -> Block .\n  op xA0B87B77 : -> Block .\n  op xA44AAAC0 : -> Block .\n  op xA511987A : -> Block .\n  op xA70FC148 : -> Block .\n  op xA93BD410 : -> Block .\n  op xAAAAAAAA : -> Block .\n  op xAB00FFCD : -> Block .\n  op xAB01FCCD : -> Block .\n  op xAB6EED4A : -> Block .\n  op xABEEED6B : -> Block .\n  op xACBC13DD : -> Block .\n  op xB1CC1CC5 : -> Block .\n  op xB8142629 : -> Block .\n  op xB99A62DE : -> Block .\n  op xBA92DB12 : -> Block .\n  op xBBA57835 : -> Block .\n  op xBE9F0917 : -> Block .\n  op xBF2D7D85 : -> Block .\n  op xBFEF7FDF : -> Block .\n  op xC1ED90DD : -> Block .\n  op xC21A1846 : -> Block .\n  op xC4EB1AEB : -> Block .\n  op xC6B1317E : -> Block .\n  op xCBC865BA : -> Block .\n  op xCD959B46 : -> Block .\n  op xD0482465 : -> Block .\n  op xD636250D : -> Block .\n  op xD7843FDC : -> Block .\n  op xD78634BC : -> Block .\n  op xD8804CA5 : -> Block .\n  op xDB79FBDC : -> Block .\n  op xDB9102B0 : -> Block .\n  op xE0C08000 : -> Block .\n  op xE6A12F07 : -> Block .\n  op xEB35B97F : -> Block .\n  op xF0239DD5 : -> Block .\n  op xF14D6E28 : -> Block .\n  op xF2EF3501 : -> Block .\n  op xF6A09667 : -> Block .\n  op xFD297DA4 : -> Block .\n  op xFDC1A8BA : -> Block .\n  op xFE4E5BDD : -> Block .\n  op xFEA1D334 : -> Block .\n  op xFECCAA6E : -> Block .\n  op xFEFC07F0 : -> Block .\n  op xFF2D7DA5 : -> Block .\n  op xFFEF0001 : -> Block .\n  op xFFFF00FF : -> Block .\n  op xFFFFFF2D : -> Block .\n  op xFFFFFF3A : -> Block .\n  op xFFFFFFF0 : -> Block .\n  op xFFFFFFF1 : -> Block .\n  op xFFFFFFF4 : -> Block .\n  op xFFFFFFF5 : -> Block .\n  op xFFFFFFF7 : -> Block .\n  op xFFFFFFF9 : -> Block .\n  op xFFFFFFFA : -> Block .\n  op xFFFFFFFB : -> Block .\n  op xFFFFFFFC : -> Block .\n  op xFFFFFFFD : -> Block .\n  op xFFFFFFFE : -> Block .\n  op xFFFFFFFF : -> Block .\n  op appendMessage : ____(OP_217)____ Block -> Message .\n  op ____(OP_218)____ : Message -> Message .\n  op makeMessage : Nat ____(OP_219)____ ____(OP_220)____ -> Message .\n  op ____(OP_221)____ : Message -> SegmentedMessage .\n  op cutSegment : ____(OP_222)____ Message Nat -> ____(OP_223)____ .\n  op ADD : ____(OP_224)____ Block -> Block .\n  op ____(OP_225)____ : Block Block -> Block .\n  op MUL : ____(OP_226)____ Block -> Pair .\n  op OR : ____(OP_227)____ Block -> Block .\n  op ____(OP_228)____ : Block Block -> Block .\n  op XOR-prime : ____(OP_229)____ -> Block .\n  op CYC : ____(OP_230)____ -> Block .\n  op ____(OP_231)____ : Nat Block -> Block .\n  op FIX1 : ____(OP_232)____ -> Block .\n  op FIX2 : ____(OP_233)____ -> Block .\n  op ____(OP_234)____ : Octet -> Xbool .\n  op ____(OP_235)____ : Octet -> Bit .\n  op adjust : ____(OP_236)____ Octet -> Octet .\n  op PAT : ____(OP_237)____ Block -> Octet .\n  op BYT : ____(OP_238)____ Block -> Pair .\n  op BYT-prime : ____(OP_239)____ ____(OP_240)____ ____(OP_241)____ ____(OP_242)____ Octet Octet Octet Octet Octet -> Pair .\n  op ADDC : ____(OP_243)____ Block -> Pair .\n  op ADDC-prime : ____(OP_244)____ -> Pair .\n  op MUL1 : ____(OP_245)____ Block -> Block .\n  op MUL1XY : ____(OP_246)____ -> Block .\n  op MUL1UL : ____(OP_247)____ Block -> Block .\n  op ____(OP_248)____ : Pair -> Block .\n  op ____(OP_249)____ : Block Block -> Block .\n  op ____(OP_250)____ : Pair -> Block .\n  op MUL2UL : ____(OP_251)____ Block -> Block .\n  op MUL2DEL : Pair ____(OP_252)____ -> Block .\n  op MUL2FL : ____(OP_253)____ Block -> Block .\n  op MUL2SC : Pair -> ____(OP_254)____ .\n  op MUL2A : ____(OP_255)____ Block -> Block .\n  op ____(OP_256)____ : Pair -> Block .\n  op MUL2AUL : ____(OP_257)____ Block -> Block .\n  op MUL2ADL : ____(OP_258)____ Block -> Block .\n  op MUL2ASC : ____(OP_259)____ -> Block .\n  op squareHalf : Half -> ____(OP_260)____ .\n  op Q : ____(OP_261)____ -> Block .\n  op H4 : ____(OP_262)____ -> Block .\n  op H6 : ____(OP_263)____ -> Block .\n  op H8 : ____(OP_264)____ -> Block .\n  op ____(OP_265)____ : Block -> Block .\n  op ____(OP_266)____ : Block Octet -> Block .\n  op ____(OP_267)____ : Block -> Block .\n  op ____(OP_268)____ : Block -> Block .\n  op J1-2 : ____(OP_269)____ -> Block .\n  op J1-4 : ____(OP_270)____ -> Block .\n  op J1-6 : ____(OP_271)____ -> Block .\n  op ____(OP_272)____ : Block -> Block .\n  op J2-2 : ____(OP_273)____ -> Block .\n  op J2-4 : ____(OP_274)____ -> Block .\n  op J2-6 : ____(OP_275)____ -> Block .\n  op J2-8 : ____(OP_276)____ -> Block .\n  op K1-2 : ____(OP_277)____ -> Block .\n  op K1-4 : ____(OP_278)____ -> Block .\n  op K1-5 : ____(OP_279)____ -> Block .\n  op K1-7 : ____(OP_280)____ -> Block .\n  op K1-9 : ____(OP_281)____ -> Block .\n  op K2-2 : ____(OP_282)____ -> Block .\n  op K2-4 : ____(OP_283)____ -> Block .\n  op ____(OP_284)____ : Block -> Block .\n  op K2-7 : ____(OP_285)____ -> Block .\n  op K2-9 : ____(OP_286)____ -> Block .\n  op preludeXY : Block Block -> ____(OP_287)____ .\n  op preludeVW : ____(OP_288)____ Block -> Pair .\n  op preludeST : Block Block -> ____(OP_289)____ .\n  op ____(OP_290)____ : Pair Octet -> Pair .\n  op preludeVW-prime : ____(OP_291)____ -> Pair .\n  op ____(OP_292)____ : Pair -> Pair .\n  op computeXY : ____(OP_293)____ ____(OP_294)____ Block -> Pair .\n  op computeXY-prime : ____(OP_295)____ ____(OP_296)____ Block -> Pair .\n  op computeVW : ____(OP_297)____ -> Pair .\n  op loop1 : ____(OP_298)____ ____(OP_299)____ Message -> Pair .\n  op ____(OP_300)____ : Pair Pair ____(OP_301)____ -> Pair .\n  op coda : ____(OP_302)____ Pair Pair -> ____(OP_303)____ .\n  op ____(OP_304)____ : Key Message -> Block .\n  op MAA-prime : ____(OP_305)____ Pair Pair Message -> ____(OP_306)____ .\n  op MAC : Key ____(OP_307)____ -> Block .\n  op ____(OP_308)____ : Key SegmentedMessage -> Block .\n  op MACnext : Key ____(OP_309)____ SegmentedMessage -> ____(OP_310)____ .\n  eq [001]: notBool (Xfalse) = Xtrue .\n  eq [002]: notBool (Xtrue) = Xfalse .\n  eq [003]: andBool (Xfalse, L:Xbool) = Xfalse .\n  eq [004]: andBool (Xtrue, L:Xbool) = L:Xbool .\n  eq [005]: orBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [006]: orBool (Xtrue, L:Xbool) = Xtrue .\n  eq [007]: xorBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [008]: xorBool (Xtrue, L:Xbool) = notBool (L:Xbool) .\n  eq [009]: notBit (x0) = x1 .\n  eq [010]: notBit (x1) = x0 .\n  eq [011]: andBit (B:Bit, x0) = x0 .\n  eq [012]: andBit (B:Bit, x1) = B:Bit .\n  eq [013]: orBit (B:Bit, x0) = B:Bit .\n  eq [014]: orBit (B:Bit, x1) = x1 .\n  eq [015]: xorBit (B:Bit, x0) = B:Bit .\n  eq [016]: xorBit (B:Bit, x1) = notBit (B:Bit) .\n  eq [017]: x00 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x0) .\n  eq [018]: x01 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x1) .\n  eq [019]: x0000 = buildHalf (x00, x00) .\n  eq [020]: HalfU (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [021]: HalfL (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O3:Octet, O4:Octet) .\n  eq [022]: eqBit (x0, x0) = Xtrue .\n  eq [023]: eqBit (x0, x1) = Xfalse .\n  eq [024]: eqBit (x1, x0) = Xfalse .\n  eq [025]: eqBit (x1, x1) = Xtrue .\n  eq [026]: eqOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = andBool (eqBit (B1:Bit, B-prime1:Bit), andBool (eqBit (B2:Bit, B-prime2:Bit), andBool (eqBit (B3:Bit, B-prime3:Bit), andBool (eqBit (B4:Bit, B-prime4:Bit), andBool (eqBit (B5:Bit, B-prime5:Bit), andBool (eqBit (B6:Bit, B-prime6:Bit), andBool (eqBit (B7:Bit, B-prime7:Bit), eqBit (B8:Bit, B-prime8:Bit)))))))) .\n  eq [027]: eqOctetSum (buildOctetSum (B:Bit, O:Octet), buildOctetSum (B-prime:Bit, O-prime:Octet)) = andBool (eqBit (B:Bit, B-prime:Bit), eqOctet (O:Octet, O-prime:Octet)) .\n  eq [028]: eqHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)) .\n  eq [029]: eqHalfSum (buildHalfSum (B:Bit, H:Half), buildHalfSum (B-prime:Bit, H-prime:Half)) = andBool (eqBit (B:Bit, B-prime:Bit), eqHalf (H:Half, H-prime:Half)) .\n  eq [030]: eqBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = andBool (andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)), andBool (eqOctet (O3:Octet, O-prime3:Octet), eqOctet (O4:Octet, O-prime4:Octet))) .\n  eq [031]: eqBlockSum (buildBlockSum (B:Bit, W:Block), buildBlockSum (B-prime:Bit, W-prime:Block)) = andBool (eqBit (B:Bit, B-prime:Bit), eqBlock (W:Block, W-prime:Block)) .\n  eq [032]: eqPair (buildPair (W1:Block, W2:Block), buildPair (W-prime1:Block, W-prime2:Block)) = andBool (eqBlock (W1:Block, W-prime1:Block), eqBlock (W2:Block, W-prime2:Block)) .\n  eq [033]: addBit (B:Bit, B-prime:Bit, Bcarry:Bit) = xorBit (xorBit (B:Bit, B-prime:Bit), Bcarry:Bit) .\n  eq [034]: carBit (B:Bit, B-prime:Bit, Bcarry:Bit) = orBit (andBit (andBit (B:Bit, B-prime:Bit), notBit (Bcarry:Bit)), andBit (orBit (B:Bit, B-prime:Bit), Bcarry:Bit)) .\n  eq [035]: addOctetSum (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit), Bcarry:Bit) = addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) .\n  eq [036]: addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) = addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, carBit (B8:Bit, B-prime8:Bit, Bcarry:Bit), addBit (B8:Bit, B-prime8:Bit, Bcarry:Bit)) .\n  eq [037]: addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, Bcarry:Bit, B-second8:Bit) = addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, carBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), addBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), B-second8:Bit) .\n  eq [038]: addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, Bcarry:Bit, B-second7:Bit, B-second8:Bit) = addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, carBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), addBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), B-second7:Bit, B-second8:Bit) .\n  eq [039]: addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, Bcarry:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, carBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), addBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [040]: addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, Bcarry:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, carBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), addBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [041]: addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, Bcarry:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, carBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), addBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [042]: addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, Bcarry:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet1 (B1:Bit, B-prime1:Bit, carBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), addBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [043]: addOctet1 (B1:Bit, B-prime1:Bit, Bcarry:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet0 (carBit (B1:Bit, B-prime1:Bit, Bcarry:Bit), addBit (B1:Bit, B-prime1:Bit, Bcarry:Bit), B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [044]: addOctet0 (Bcarry:Bit, B-second1:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = buildOctetSum (Bcarry:Bit, buildOctet (B-second1:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit)) .\n  eq [045]: dropCarryOctetSum (buildOctetSum (Bcarry:Bit, O:Octet)) = O:Octet .\n  eq [046]: addOctet (O:Octet, O-prime:Octet) = dropCarryOctetSum (addOctetSum (O:Octet, O-prime:Octet, x0)) .\n  eq [047]: addHalfSum (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = addHalf2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet) .\n  eq [048]: addHalf2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet) = addHalf1 (O1:Octet, O-prime1:Octet, addOctetSum (O2:Octet, O-prime2:Octet, x0)) .\n  eq [049]: addHalf1 (O1:Octet, O-prime1:Octet, buildOctetSum (B:Bit, O-second2:Octet)) = addHalf0 (addOctetSum (O1:Octet, O-prime1:Octet, B:Bit), O-second2:Octet) .\n  eq [050]: addHalf0 (buildOctetSum (B:Bit, O-second1:Octet), O-second2:Octet) = buildHalfSum (B:Bit, buildHalf (O-second1:Octet, O-second2:Octet)) .\n  eq [051]: dropCarryHalfSum (buildHalfSum (B:Bit, H:Half)) = H:Half .\n  eq [052]: addHalf (H:Half, H-prime:Half) = dropCarryHalfSum (addHalfSum (H:Half, H-prime:Half)) .\n  eq [053]: addHalfOctet (O:Octet, H:Half) = addHalf (buildHalf (x00, O:Octet), H:Half) .\n  eq [054]: addHalfOctets (O:Octet, O-prime:Octet) = addHalf (buildHalf (x00, O:Octet), buildHalf (x00, O-prime:Octet)) .\n  eq [055]: addBlockSum (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = addBlock4 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, O4:Octet, O-prime4:Octet) .\n  eq [056]: addBlock4 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, O4:Octet, O-prime4:Octet) = addBlock3 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, addOctetSum (O4:Octet, O-prime4:Octet, x0)) .\n  eq [057]: addBlock3 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, buildOctetSum (Bcarry:Bit, O-second4:Octet)) = addBlock2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, addOctetSum (O3:Octet, O-prime3:Octet, Bcarry:Bit), O-second4:Octet) .\n  eq [058]: addBlock2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, buildOctetSum (Bcarry:Bit, O-second3:Octet), O-second4:Octet) = addBlock1 (O1:Octet, O-prime1:Octet, addOctetSum (O2:Octet, O-prime2:Octet, Bcarry:Bit), O-second3:Octet, O-second4:Octet) .\n  eq [059]: addBlock1 (O1:Octet, O-prime1:Octet, buildOctetSum (Bcarry:Bit, O-second2:Octet), O-second3:Octet, O-second4:Octet) = addBlock0 (addOctetSum (O1:Octet, O-prime1:Octet, Bcarry:Bit), O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [060]: addBlock0 (buildOctetSum (Bcarry:Bit, O-second1:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) = buildBlockSum (Bcarry:Bit, buildBlock (O-second1:Octet, O-second2:Octet, O-second3:Octet, O-second4:Octet)) .\n  eq [061]: dropCarryBlockSum (buildBlockSum (Bcarry:Bit, W:Block)) = W:Block .\n  eq [062]: addBlock (W:Block, W-prime:Block) = dropCarryBlockSum (addBlockSum (W:Block, W-prime:Block)) .\n  eq [063]: addBlockHalf (buildHalf (O1:Octet, O2:Octet), W:Block) = addBlock (buildBlock (x00, x00, O1:Octet, O2:Octet), W:Block) .\n  eq [064]: addBlockHalves (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = addBlock (buildBlock (x00, x00, O1:Octet, O2:Octet), buildBlock (x00, x00, O-prime1:Octet, O-prime2:Octet)) .\n  eq [065]: leftOctet1 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0) .\n  eq [066]: leftOctet2 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0) .\n  eq [067]: leftOctet3 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0, x0) .\n  eq [068]: leftOctet4 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0, x0, x0) .\n  eq [069]: leftOctet5 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B6:Bit, B7:Bit, B8:Bit, x0, x0, x0, x0, x0) .\n  eq [070]: leftOctet6 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B7:Bit, B8:Bit, x0, x0, x0, x0, x0, x0) .\n  eq [071]: leftOctet7 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B8:Bit, x0, x0, x0, x0, x0, x0, x0) .\n  eq [072]: rightOctet1 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit) .\n  eq [073]: rightOctet2 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit) .\n  eq [074]: rightOctet3 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit) .\n  eq [075]: rightOctet4 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit) .\n  eq [076]: rightOctet5 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, B1:Bit, B2:Bit, B3:Bit) .\n  eq [077]: rightOctet6 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, x0, B1:Bit, B2:Bit) .\n  eq [078]: rightOctet7 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, x0, x0, B1:Bit) .\n  eq [079]: mulOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), O-prime:Octet) = mulOctet1 (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, x0000) .\n  eq [080]: mulOctet1 (x0, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet2 (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [081]: mulOctet1 (x1, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet2 (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet1 (O-prime:Octet), leftOctet7 (O-prime:Octet))) .\n  eq [082]: mulOctet2 (x0, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet3 (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [083]: mulOctet2 (x1, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet3 (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet2 (O-prime:Octet), leftOctet6 (O-prime:Octet))) .\n  eq [084]: mulOctet3 (x0, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet4 (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [085]: mulOctet3 (x1, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet4 (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet3 (O-prime:Octet), leftOctet5 (O-prime:Octet))) .\n  eq [086]: mulOctet4 (x0, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet5 (B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [087]: mulOctet4 (x1, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet5 (B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet4 (O-prime:Octet), leftOctet4 (O-prime:Octet))) .\n  eq [088]: mulOctet5 (x0, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet6 (B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [089]: mulOctet5 (x1, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet6 (B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet5 (O-prime:Octet), leftOctet3 (O-prime:Octet))) .\n  eq [090]: mulOctet6 (x0, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet7 (B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [091]: mulOctet6 (x1, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet7 (B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet6 (O-prime:Octet), leftOctet2 (O-prime:Octet))) .\n  eq [092]: mulOctet7 (x0, B8:Bit, O-prime:Octet, H:Half) = mulOctet8 (B8:Bit, O-prime:Octet, H:Half) .\n  eq [093]: mulOctet7 (x1, B8:Bit, O-prime:Octet, H:Half) = mulOctet8 (B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet7 (O-prime:Octet), leftOctet1 (O-prime:Octet))) .\n  eq [094]: mulOctet8 (x0, O-prime:Octet, H:Half) = H:Half .\n  eq [095]: mulOctet8 (x1, O-prime:Octet, H:Half) = mulOctetA (H:Half, x00, O-prime:Octet) .\n  eq [096]: mulOctetA (buildHalf (O1:Octet, O2:Octet), O-prime1:Octet, O-prime2:Octet) = mulOctetB (addOctet (O1:Octet, O-prime1:Octet), addOctetSum (O2:Octet, O-prime2:Octet, x0)) .\n  eq [097]: mulOctetB (O1:Octet, buildOctetSum (x0, O2:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [098]: mulOctetB (O1:Octet, buildOctetSum (x1, O2:Octet)) = buildHalf (addOctet (O1:Octet, x01), O2:Octet) .\n  eq [099]: mulHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = mulHalfA (mulOctet (O1:Octet, O-prime1:Octet), mulOctet (O1:Octet, O-prime2:Octet), mulOctet (O2:Octet, O-prime1:Octet), mulOctet (O2:Octet, O-prime2:Octet)) .\n  eq [100]: mulHalfA (buildHalf (O11U:Octet, O11L:Octet), buildHalf (O12U:Octet, O12L:Octet), buildHalf (O21U:Octet, O21L:Octet), buildHalf (O22U:Octet, O22L:Octet)) = mulHalf4 (O11U:Octet, O11L:Octet, O12U:Octet, O12L:Octet, O21U:Octet, O21L:Octet, O22U:Octet, O22L:Octet) .\n  eq [101]: mulHalf4 (O11U:Octet, O11L:Octet, O12U:Octet, O12L:Octet, O21U:Octet, O21L:Octet, O22U:Octet, O-second4:Octet) = mulHalf3 (O11U:Octet, O11L:Octet, O12U:Octet, O21U:Octet, addHalfOctet (O12L:Octet, addHalfOctets (O21L:Octet, O22U:Octet)), O-second4:Octet) .\n  eq [102]: mulHalf3 (O11U:Octet, O11L:Octet, O12U:Octet, O21U:Octet, buildHalf (Ocarry:Octet, O-second3:Octet), O-second4:Octet) = mulHalf2 (O11U:Octet, addHalfOctet (Ocarry:Octet, addHalfOctet (O11L:Octet, addHalfOctets (O12U:Octet, O21U:Octet))), O-second3:Octet, O-second4:Octet) .\n  eq [103]: mulHalf2 (O11U:Octet, buildHalf (Ocarry:Octet, O-second2:Octet), O-second3:Octet, O-second4:Octet) = mulHalf1 (addHalfOctets (Ocarry:Octet, O11U:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [104]: mulHalf1 (buildHalf (Ocarry:Octet, O-second1:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) = buildBlock (O-second1:Octet, O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [105]: mulBlock (W1:Block, W2:Block) = mulBlockA (mulHalf (HalfU (W1:Block), HalfU (W2:Block)), mulHalf (HalfU (W1:Block), HalfL (W2:Block)), mulHalf (HalfL (W1:Block), HalfU (W2:Block)), mulHalf (HalfL (W1:Block), HalfL (W2:Block))) .\n  eq [106]: mulBlockA (W11:Block, W12:Block, W21:Block, W22:Block) = mulBlock4 (HalfU (W11:Block), HalfL (W11:Block), HalfU (W12:Block), HalfL (W12:Block), HalfU (W21:Block), HalfL (W21:Block), HalfU (W22:Block), HalfL (W22:Block)) .\n  eq [107]: mulBlock4 (H11U:Half, H11L:Half, H12U:Half, H12L:Half, H21U:Half, H21L:Half, H22U:Half, H-second4:Half) = mulBlock3 (H11U:Half, H11L:Half, H12U:Half, H21U:Half, addBlockHalf (H12L:Half, addBlockHalves (H21L:Half, H22U:Half)), H-second4:Half) .\n  eq [108]: mulBlock3 (H11U:Half, H11L:Half, H12U:Half, H21U:Half, W:Block, H-second4:Half) = mulBlock2 (H11U:Half, addBlockHalf (HalfU (W:Block), addBlockHalf (H11L:Half, addBlockHalves (H12U:Half, H21U:Half))), HalfL (W:Block), H-second4:Half) .\n  eq [109]: mulBlock2 (H11U:Half, W:Block, H-second3:Half, H-second4:Half) = mulBlock1 (addBlockHalves (HalfU (W:Block), H11U:Half), HalfL (W:Block), H-second3:Half, H-second4:Half) .\n  eq [110]: mulBlock1 (W:Block, H-second2:Half, H-second3:Half, H-second4:Half) = mulBlockB (HalfL (W:Block), H-second2:Half, H-second3:Half, H-second4:Half) .\n  eq [111]: mulBlockB (buildHalf (O1U:Octet, O1L:Octet), buildHalf (O2U:Octet, O2L:Octet), buildHalf (O3U:Octet, O3L:Octet), buildHalf (O4U:Octet, O4L:Octet)) = buildPair (buildBlock (O1U:Octet, O1L:Octet, O2U:Octet, O2L:Octet), buildBlock (O3U:Octet, O3L:Octet, O4U:Octet, O4L:Octet)) .\n  eq [112]: addNat (N:Nat, zero) = N:Nat .\n  eq [113]: addNat (N:Nat, succ (N-prime:Nat)) = addNat (succ (N:Nat), N-prime:Nat) .\n  eq [114]: multNat (N:Nat, zero) = zero .\n  eq [115]: multNat (N:Nat, succ (N-prime:Nat)) = addNat (N:Nat, multNat (N:Nat, N-prime:Nat)) .\n  eq [116]: eqNat (zero, zero) = Xtrue .\n  eq [117]: eqNat (zero, succ (N-prime:Nat)) = Xfalse .\n  eq [118]: eqNat (succ (N:Nat), zero) = Xfalse .\n  eq [119]: eqNat (succ (N:Nat), succ (N-prime:Nat)) = eqNat (N:Nat, N-prime:Nat) .\n  eq [120]: ltNat (zero, zero) = Xfalse .\n  eq [121]: ltNat (zero, succ (N-prime:Nat)) = Xtrue .\n  eq [122]: ltNat (succ (N-prime:Nat), zero) = Xfalse .\n  eq [123]: ltNat (succ (N:Nat), succ (N-prime:Nat)) = ltNat (N:Nat, N-prime:Nat) .\n  eq [124]: n1 = succ (zero) .\n  eq [125]: n2 = succ (n1) .\n  eq [126]: n3 = succ (n2) .\n  eq [127]: n4 = succ (n3) .\n  eq [128]: n5 = succ (n4) .\n  eq [129]: n6 = succ (n5) .\n  eq [130]: n7 = succ (n6) .\n  eq [131]: n8 = succ (n7) .\n  eq [132]: n9 = succ (n8) .\n  eq [133]: n10 = succ (n9) .\n  eq [134]: n11 = succ (n10) .\n  eq [135]: n12 = succ (n11) .\n  eq [136]: n13 = succ (n12) .\n  eq [137]: n14 = succ (n13) .\n  eq [138]: n15 = succ (n14) .\n  eq [139]: n16 = succ (n15) .\n  eq [140]: n17 = succ (n16) .\n  eq [141]: n18 = succ (n17) .\n  eq [142]: n19 = succ (n18) .\n  eq [143]: n20 = succ (n19) .\n  eq [144]: n21 = succ (n20) .\n  eq [145]: n22 = succ (n21) .\n  eq [146]: n254 = addNat (n12, multNat (n11, n22)) .\n  eq [147]: n256 = multNat (n16, n16) .\n  eq [148]: n4100 = addNat (n4, multNat (n16, n256)) .\n  eq [149]: andOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (andBit (B1:Bit, B-prime1:Bit), andBit (B2:Bit, B-prime2:Bit), andBit (B3:Bit, B-prime3:Bit), andBit (B4:Bit, B-prime4:Bit), andBit (B5:Bit, B-prime5:Bit), andBit (B6:Bit, B-prime6:Bit), andBit (B7:Bit, B-prime7:Bit), andBit (B8:Bit, B-prime8:Bit)) .\n  eq [150]: orOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (orBit (B1:Bit, B-prime1:Bit), orBit (B2:Bit, B-prime2:Bit), orBit (B3:Bit, B-prime3:Bit), orBit (B4:Bit, B-prime4:Bit), orBit (B5:Bit, B-prime5:Bit), orBit (B6:Bit, B-prime6:Bit), orBit (B7:Bit, B-prime7:Bit), orBit (B8:Bit, B-prime8:Bit)) .\n  eq [151]: xorOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (xorBit (B1:Bit, B-prime1:Bit), xorBit (B2:Bit, B-prime2:Bit), xorBit (B3:Bit, B-prime3:Bit), xorBit (B4:Bit, B-prime4:Bit), xorBit (B5:Bit, B-prime5:Bit), xorBit (B6:Bit, B-prime6:Bit), xorBit (B7:Bit, B-prime7:Bit), xorBit (B8:Bit, B-prime8:Bit)) .\n  eq [152]: x02 = buildOctet (x0, x0, x0, x0, x0, x0, x1, x0) .\n  eq [153]: x03 = buildOctet (x0, x0, x0, x0, x0, x0, x1, x1) .\n  eq [154]: x04 = buildOctet (x0, x0, x0, x0, x0, x1, x0, x0) .\n  eq [155]: x05 = buildOctet (x0, x0, x0, x0, x0, x1, x0, x1) .\n  eq [156]: x06 = buildOctet (x0, x0, x0, x0, x0, x1, x1, x0) .\n  eq [157]: x07 = buildOctet (x0, x0, x0, x0, x0, x1, x1, x1) .\n  eq [158]: x08 = buildOctet (x0, x0, x0, x0, x1, x0, x0, x0) .\n  eq [159]: x09 = buildOctet (x0, x0, x0, x0, x1, x0, x0, x1) .\n  eq [160]: x0A = buildOctet (x0, x0, x0, x0, x1, x0, x1, x0) .\n  eq [161]: x0B = buildOctet (x0, x0, x0, x0, x1, x0, x1, x1) .\n  eq [162]: x0C = buildOctet (x0, x0, x0, x0, x1, x1, x0, x0) .\n  eq [163]: x0D = buildOctet (x0, x0, x0, x0, x1, x1, x0, x1) .\n  eq [164]: x0E = buildOctet (x0, x0, x0, x0, x1, x1, x1, x0) .\n  eq [165]: x0F = buildOctet (x0, x0, x0, x0, x1, x1, x1, x1) .\n  eq [166]: x10 = buildOctet (x0, x0, x0, x1, x0, x0, x0, x0) .\n  eq [167]: x11 = buildOctet (x0, x0, x0, x1, x0, x0, x0, x1) .\n  eq [168]: x12 = buildOctet (x0, x0, x0, x1, x0, x0, x1, x0) .\n  eq [169]: x13 = buildOctet (x0, x0, x0, x1, x0, x0, x1, x1) .\n  eq [170]: x14 = buildOctet (x0, x0, x0, x1, x0, x1, x0, x0) .\n  eq [171]: x15 = buildOctet (x0, x0, x0, x1, x0, x1, x0, x1) .\n  eq [172]: x16 = buildOctet (x0, x0, x0, x1, x0, x1, x1, x0) .\n  eq [173]: x17 = buildOctet (x0, x0, x0, x1, x0, x1, x1, x1) .\n  eq [174]: x18 = buildOctet (x0, x0, x0, x1, x1, x0, x0, x0) .\n  eq [175]: x1A = buildOctet (x0, x0, x0, x1, x1, x0, x1, x0) .\n  eq [176]: x1B = buildOctet (x0, x0, x0, x1, x1, x0, x1, x1) .\n  eq [177]: x1C = buildOctet (x0, x0, x0, x1, x1, x1, x0, x0) .\n  eq [178]: x1D = buildOctet (x0, x0, x0, x1, x1, x1, x0, x1) .\n  eq [179]: x1E = buildOctet (x0, x0, x0, x1, x1, x1, x1, x0) .\n  eq [180]: x1F = buildOctet (x0, x0, x0, x1, x1, x1, x1, x1) .\n  eq [181]: x20 = buildOctet (x0, x0, x1, x0, x0, x0, x0, x0) .\n  eq [182]: x21 = buildOctet (x0, x0, x1, x0, x0, x0, x0, x1) .\n  eq [183]: x23 = buildOctet (x0, x0, x1, x0, x0, x0, x1, x1) .\n  eq [184]: x24 = buildOctet (x0, x0, x1, x0, x0, x1, x0, x0) .\n  eq [185]: x25 = buildOctet (x0, x0, x1, x0, x0, x1, x0, x1) .\n  eq [186]: x26 = buildOctet (x0, x0, x1, x0, x0, x1, x1, x0) .\n  eq [187]: x27 = buildOctet (x0, x0, x1, x0, x0, x1, x1, x1) .\n  eq [188]: x28 = buildOctet (x0, x0, x1, x0, x1, x0, x0, x0) .\n  eq [189]: x29 = buildOctet (x0, x0, x1, x0, x1, x0, x0, x1) .\n  eq [190]: x2A = buildOctet (x0, x0, x1, x0, x1, x0, x1, x0) .\n  eq [191]: x2B = buildOctet (x0, x0, x1, x0, x1, x0, x1, x1) .\n  eq [192]: x2D = buildOctet (x0, x0, x1, x0, x1, x1, x0, x1) .\n  eq [193]: x2E = buildOctet (x0, x0, x1, x0, x1, x1, x1, x0) .\n  eq [194]: x2F = buildOctet (x0, x0, x1, x0, x1, x1, x1, x1) .\n  eq [195]: x30 = buildOctet (x0, x0, x1, x1, x0, x0, x0, x0) .\n  eq [196]: x31 = buildOctet (x0, x0, x1, x1, x0, x0, x0, x1) .\n  eq [197]: x32 = buildOctet (x0, x0, x1, x1, x0, x0, x1, x0) .\n  eq [198]: x33 = buildOctet (x0, x0, x1, x1, x0, x0, x1, x1) .\n  eq [199]: x34 = buildOctet (x0, x0, x1, x1, x0, x1, x0, x0) .\n  eq [200]: x35 = buildOctet (x0, x0, x1, x1, x0, x1, x0, x1) .\n  eq [201]: x36 = buildOctet (x0, x0, x1, x1, x0, x1, x1, x0) .\n  eq [202]: x37 = buildOctet (x0, x0, x1, x1, x0, x1, x1, x1) .\n  eq [203]: x38 = buildOctet (x0, x0, x1, x1, x1, x0, x0, x0) .\n  eq [204]: x39 = buildOctet (x0, x0, x1, x1, x1, x0, x0, x1) .\n  eq [205]: x3A = buildOctet (x0, x0, x1, x1, x1, x0, x1, x0) .\n  eq [206]: x3B = buildOctet (x0, x0, x1, x1, x1, x0, x1, x1) .\n  eq [207]: x3D = buildOctet (x0, x0, x1, x1, x1, x1, x0, x1) .\n  eq [208]: x3C = buildOctet (x0, x0, x1, x1, x1, x1, x0, x0) .\n  eq [209]: x3F = buildOctet (x0, x0, x1, x1, x1, x1, x1, x1) .\n  eq [210]: x40 = buildOctet (x0, x1, x0, x0, x0, x0, x0, x0) .\n  eq [211]: x46 = buildOctet (x0, x1, x0, x0, x0, x1, x1, x0) .\n  eq [212]: x48 = buildOctet (x0, x1, x0, x0, x1, x0, x0, x0) .\n  eq [213]: x49 = buildOctet (x0, x1, x0, x0, x1, x0, x0, x1) .\n  eq [214]: x4A = buildOctet (x0, x1, x0, x0, x1, x0, x1, x0) .\n  eq [215]: x4B = buildOctet (x0, x1, x0, x0, x1, x0, x1, x1) .\n  eq [216]: x4C = buildOctet (x0, x1, x0, x0, x1, x1, x0, x0) .\n  eq [217]: x4D = buildOctet (x0, x1, x0, x0, x1, x1, x0, x1) .\n  eq [218]: x4E = buildOctet (x0, x1, x0, x0, x1, x1, x1, x0) .\n  eq [219]: x4F = buildOctet (x0, x1, x0, x0, x1, x1, x1, x1) .\n  eq [220]: x50 = buildOctet (x0, x1, x0, x1, x0, x0, x0, x0) .\n  eq [221]: x51 = buildOctet (x0, x1, x0, x1, x0, x0, x0, x1) .\n  eq [222]: x53 = buildOctet (x0, x1, x0, x1, x0, x0, x1, x1) .\n  eq [223]: x54 = buildOctet (x0, x1, x0, x1, x0, x1, x0, x0) .\n  eq [224]: x55 = buildOctet (x0, x1, x0, x1, x0, x1, x0, x1) .\n  eq [225]: x58 = buildOctet (x0, x1, x0, x1, x1, x0, x0, x0) .\n  eq [226]: x5A = buildOctet (x0, x1, x0, x1, x1, x0, x1, x0) .\n  eq [227]: x5B = buildOctet (x0, x1, x0, x1, x1, x0, x1, x1) .\n  eq [228]: x5C = buildOctet (x0, x1, x0, x1, x1, x1, x0, x0) .\n  eq [229]: x5D = buildOctet (x0, x1, x0, x1, x1, x1, x0, x1) .\n  eq [230]: x5E = buildOctet (x0, x1, x0, x1, x1, x1, x1, x0) .\n  eq [231]: x5F = buildOctet (x0, x1, x0, x1, x1, x1, x1, x1) .\n  eq [232]: x60 = buildOctet (x0, x1, x1, x0, x0, x0, x0, x0) .\n  eq [233]: x61 = buildOctet (x0, x1, x1, x0, x0, x0, x0, x1) .\n  eq [234]: x62 = buildOctet (x0, x1, x1, x0, x0, x0, x1, x0) .\n  eq [235]: x63 = buildOctet (x0, x1, x1, x0, x0, x0, x1, x1) .\n  eq [236]: x64 = buildOctet (x0, x1, x1, x0, x0, x1, x0, x0) .\n  eq [237]: x65 = buildOctet (x0, x1, x1, x0, x0, x1, x0, x1) .\n  eq [238]: x66 = buildOctet (x0, x1, x1, x0, x0, x1, x1, x0) .\n  eq [239]: x67 = buildOctet (x0, x1, x1, x0, x0, x1, x1, x1) .\n  eq [240]: x69 = buildOctet (x0, x1, x1, x0, x1, x0, x0, x1) .\n  eq [241]: x6A = buildOctet (x0, x1, x1, x0, x1, x0, x1, x0) .\n  eq [242]: x6B = buildOctet (x0, x1, x1, x0, x1, x0, x1, x1) .\n  eq [243]: x6C = buildOctet (x0, x1, x1, x0, x1, x1, x0, x0) .\n  eq [244]: x6D = buildOctet (x0, x1, x1, x0, x1, x1, x0, x1) .\n  eq [245]: x6E = buildOctet (x0, x1, x1, x0, x1, x1, x1, x0) .\n  eq [246]: x6F = buildOctet (x0, x1, x1, x0, x1, x1, x1, x1) .\n  eq [247]: x70 = buildOctet (x0, x1, x1, x1, x0, x0, x0, x0) .\n  eq [248]: x71 = buildOctet (x0, x1, x1, x1, x0, x0, x0, x1) .\n  eq [249]: x72 = buildOctet (x0, x1, x1, x1, x0, x0, x1, x0) .\n  eq [250]: x73 = buildOctet (x0, x1, x1, x1, x0, x0, x1, x1) .\n  eq [251]: x74 = buildOctet (x0, x1, x1, x1, x0, x1, x0, x0) .\n  eq [252]: x75 = buildOctet (x0, x1, x1, x1, x0, x1, x0, x1) .\n  eq [253]: x76 = buildOctet (x0, x1, x1, x1, x0, x1, x1, x0) .\n  eq [254]: x77 = buildOctet (x0, x1, x1, x1, x0, x1, x1, x1) .\n  eq [255]: x78 = buildOctet (x0, x1, x1, x1, x1, x0, x0, x0) .\n  eq [256]: x79 = buildOctet (x0, x1, x1, x1, x1, x0, x0, x1) .\n  eq [257]: x7A = buildOctet (x0, x1, x1, x1, x1, x0, x1, x0) .\n  eq [258]: x7B = buildOctet (x0, x1, x1, x1, x1, x0, x1, x1) .\n  eq [259]: x7C = buildOctet (x0, x1, x1, x1, x1, x1, x0, x0) .\n  eq [260]: x7D = buildOctet (x0, x1, x1, x1, x1, x1, x0, x1) .\n  eq [261]: x7E = buildOctet (x0, x1, x1, x1, x1, x1, x1, x0) .\n  eq [262]: x7F = buildOctet (x0, x1, x1, x1, x1, x1, x1, x1) .\n  eq [263]: x80 = buildOctet (x1, x0, x0, x0, x0, x0, x0, x0) .\n  eq [264]: x81 = buildOctet (x1, x0, x0, x0, x0, x0, x0, x1) .\n  eq [265]: x83 = buildOctet (x1, x0, x0, x0, x0, x0, x1, x1) .\n  eq [266]: x84 = buildOctet (x1, x0, x0, x0, x0, x1, x0, x0) .\n  eq [267]: x85 = buildOctet (x1, x0, x0, x0, x0, x1, x0, x1) .\n  eq [268]: x86 = buildOctet (x1, x0, x0, x0, x0, x1, x1, x0) .\n  eq [269]: x88 = buildOctet (x1, x0, x0, x0, x1, x0, x0, x0) .\n  eq [270]: x89 = buildOctet (x1, x0, x0, x0, x1, x0, x0, x1) .\n  eq [271]: x8A = buildOctet (x1, x0, x0, x0, x1, x0, x1, x0) .\n  eq [272]: x8C = buildOctet (x1, x0, x0, x0, x1, x1, x0, x0) .\n  eq [273]: x8D = buildOctet (x1, x0, x0, x0, x1, x1, x0, x1) .\n  eq [274]: x8E = buildOctet (x1, x0, x0, x0, x1, x1, x1, x0) .\n  eq [275]: x8F = buildOctet (x1, x0, x0, x0, x1, x1, x1, x1) .\n  eq [276]: x90 = buildOctet (x1, x0, x0, x1, x0, x0, x0, x0) .\n  eq [277]: x91 = buildOctet (x1, x0, x0, x1, x0, x0, x0, x1) .\n  eq [278]: x92 = buildOctet (x1, x0, x0, x1, x0, x0, x1, x0) .\n  eq [279]: x93 = buildOctet (x1, x0, x0, x1, x0, x0, x1, x1) .\n  eq [280]: x95 = buildOctet (x1, x0, x0, x1, x0, x1, x0, x1) .\n  eq [281]: x96 = buildOctet (x1, x0, x0, x1, x0, x1, x1, x0) .\n  eq [282]: x97 = buildOctet (x1, x0, x0, x1, x0, x1, x1, x1) .\n  eq [283]: x98 = buildOctet (x1, x0, x0, x1, x1, x0, x0, x0) .\n  eq [284]: x99 = buildOctet (x1, x0, x0, x1, x1, x0, x0, x1) .\n  eq [285]: x9A = buildOctet (x1, x0, x0, x1, x1, x0, x1, x0) .\n  eq [286]: x9B = buildOctet (x1, x0, x0, x1, x1, x0, x1, x1) .\n  eq [287]: x9C = buildOctet (x1, x0, x0, x1, x1, x1, x0, x0) .\n  eq [288]: x9D = buildOctet (x1, x0, x0, x1, x1, x1, x0, x1) .\n  eq [289]: x9E = buildOctet (x1, x0, x0, x1, x1, x1, x1, x0) .\n  eq [290]: x9F = buildOctet (x1, x0, x0, x1, x1, x1, x1, x1) .\n  eq [291]: xA1 = buildOctet (x1, x0, x1, x0, x0, x0, x0, x1) .\n  eq [292]: xA0 = buildOctet (x1, x0, x1, x0, x0, x0, x0, x0) .\n  eq [293]: xA2 = buildOctet (x1, x0, x1, x0, x0, x0, x1, x0) .\n  eq [294]: xA3 = buildOctet (x1, x0, x1, x0, x0, x0, x1, x1) .\n  eq [295]: xA4 = buildOctet (x1, x0, x1, x0, x0, x1, x0, x0) .\n  eq [296]: xA5 = buildOctet (x1, x0, x1, x0, x0, x1, x0, x1) .\n  eq [297]: xA6 = buildOctet (x1, x0, x1, x0, x0, x1, x1, x0) .\n  eq [298]: xA7 = buildOctet (x1, x0, x1, x0, x0, x1, x1, x1) .\n  eq [299]: xA8 = buildOctet (x1, x0, x1, x0, x1, x0, x0, x0) .\n  eq [300]: xA9 = buildOctet (x1, x0, x1, x0, x1, x0, x0, x1) .\n  eq [301]: xAA = buildOctet (x1, x0, x1, x0, x1, x0, x1, x0) .\n  eq [302]: xAB = buildOctet (x1, x0, x1, x0, x1, x0, x1, x1) .\n  eq [303]: xAC = buildOctet (x1, x0, x1, x0, x1, x1, x0, x0) .\n  eq [304]: xAE = buildOctet (x1, x0, x1, x0, x1, x1, x1, x0) .\n  eq [305]: xAF = buildOctet (x1, x0, x1, x0, x1, x1, x1, x1) .\n  eq [306]: xB0 = buildOctet (x1, x0, x1, x1, x0, x0, x0, x0) .\n  eq [307]: xB1 = buildOctet (x1, x0, x1, x1, x0, x0, x0, x1) .\n  eq [308]: xB2 = buildOctet (x1, x0, x1, x1, x0, x0, x1, x0) .\n  eq [309]: xB3 = buildOctet (x1, x0, x1, x1, x0, x0, x1, x1) .\n  eq [310]: xB5 = buildOctet (x1, x0, x1, x1, x0, x1, x0, x1) .\n  eq [311]: xB6 = buildOctet (x1, x0, x1, x1, x0, x1, x1, x0) .\n  eq [312]: xB8 = buildOctet (x1, x0, x1, x1, x1, x0, x0, x0) .\n  eq [313]: xB9 = buildOctet (x1, x0, x1, x1, x1, x0, x0, x1) .\n  eq [314]: xBA = buildOctet (x1, x0, x1, x1, x1, x0, x1, x0) .\n  eq [315]: xBB = buildOctet (x1, x0, x1, x1, x1, x0, x1, x1) .\n  eq [316]: xBC = buildOctet (x1, x0, x1, x1, x1, x1, x0, x0) .\n  eq [317]: xBE = buildOctet (x1, x0, x1, x1, x1, x1, x1, x0) .\n  eq [318]: xBF = buildOctet (x1, x0, x1, x1, x1, x1, x1, x1) .\n  eq [319]: xC0 = buildOctet (x1, x1, x0, x0, x0, x0, x0, x0) .\n  eq [320]: xC1 = buildOctet (x1, x1, x0, x0, x0, x0, x0, x1) .\n  eq [321]: xC2 = buildOctet (x1, x1, x0, x0, x0, x0, x1, x0) .\n  eq [322]: xC4 = buildOctet (x1, x1, x0, x0, x0, x1, x0, x0) .\n  eq [323]: xC5 = buildOctet (x1, x1, x0, x0, x0, x1, x0, x1) .\n  eq [324]: xC6 = buildOctet (x1, x1, x0, x0, x0, x1, x1, x0) .\n  eq [325]: xC7 = buildOctet (x1, x1, x0, x0, x0, x1, x1, x1) .\n  eq [326]: xC8 = buildOctet (x1, x1, x0, x0, x1, x0, x0, x0) .\n  eq [327]: xC9 = buildOctet (x1, x1, x0, x0, x1, x0, x0, x1) .\n  eq [328]: xCA = buildOctet (x1, x1, x0, x0, x1, x0, x1, x0) .\n  eq [329]: xCB = buildOctet (x1, x1, x0, x0, x1, x0, x1, x1) .\n  eq [330]: xCC = buildOctet (x1, x1, x0, x0, x1, x1, x0, x0) .\n  eq [331]: xCD = buildOctet (x1, x1, x0, x0, x1, x1, x0, x1) .\n  eq [332]: xCE = buildOctet (x1, x1, x0, x0, x1, x1, x1, x0) .\n  eq [333]: xD0 = buildOctet (x1, x1, x0, x1, x0, x0, x0, x0) .\n  eq [334]: xD1 = buildOctet (x1, x1, x0, x1, x0, x0, x0, x1) .\n  eq [335]: xD2 = buildOctet (x1, x1, x0, x1, x0, x0, x1, x0) .\n  eq [336]: xD3 = buildOctet (x1, x1, x0, x1, x0, x0, x1, x1) .\n  eq [337]: xD4 = buildOctet (x1, x1, x0, x1, x0, x1, x0, x0) .\n  eq [338]: xD5 = buildOctet (x1, x1, x0, x1, x0, x1, x0, x1) .\n  eq [339]: xD6 = buildOctet (x1, x1, x0, x1, x0, x1, x1, x0) .\n  eq [340]: xD7 = buildOctet (x1, x1, x0, x1, x0, x1, x1, x1) .\n  eq [341]: xD8 = buildOctet (x1, x1, x0, x1, x1, x0, x0, x0) .\n  eq [342]: xD9 = buildOctet (x1, x1, x0, x1, x1, x0, x0, x1) .\n  eq [343]: xDB = buildOctet (x1, x1, x0, x1, x1, x0, x1, x1) .\n  eq [344]: xDC = buildOctet (x1, x1, x0, x1, x1, x1, x0, x0) .\n  eq [345]: xDD = buildOctet (x1, x1, x0, x1, x1, x1, x0, x1) .\n  eq [346]: xDE = buildOctet (x1, x1, x0, x1, x1, x1, x1, x0) .\n  eq [347]: xDF = buildOctet (x1, x1, x0, x1, x1, x1, x1, x1) .\n  eq [348]: xE0 = buildOctet (x1, x1, x1, x0, x0, x0, x0, x0) .\n  eq [349]: xE1 = buildOctet (x1, x1, x1, x0, x0, x0, x0, x1) .\n  eq [350]: xE3 = buildOctet (x1, x1, x1, x0, x0, x0, x1, x1) .\n  eq [351]: xE6 = buildOctet (x1, x1, x1, x0, x0, x1, x1, x0) .\n  eq [352]: xE8 = buildOctet (x1, x1, x1, x0, x1, x0, x0, x0) .\n  eq [353]: xE9 = buildOctet (x1, x1, x1, x0, x1, x0, x0, x1) .\n  eq [354]: xEA = buildOctet (x1, x1, x1, x0, x1, x0, x1, x0) .\n  eq [355]: xEB = buildOctet (x1, x1, x1, x0, x1, x0, x1, x1) .\n  eq [356]: xEC = buildOctet (x1, x1, x1, x0, x1, x1, x0, x0) .\n  eq [357]: xED = buildOctet (x1, x1, x1, x0, x1, x1, x0, x1) .\n  eq [358]: xEE = buildOctet (x1, x1, x1, x0, x1, x1, x1, x0) .\n  eq [359]: xEF = buildOctet (x1, x1, x1, x0, x1, x1, x1, x1) .\n  eq [360]: xF0 = buildOctet (x1, x1, x1, x1, x0, x0, x0, x0) .\n  eq [361]: xF1 = buildOctet (x1, x1, x1, x1, x0, x0, x0, x1) .\n  eq [362]: xF2 = buildOctet (x1, x1, x1, x1, x0, x0, x1, x0) .\n  eq [363]: xF3 = buildOctet (x1, x1, x1, x1, x0, x0, x1, x1) .\n  eq [364]: xF4 = buildOctet (x1, x1, x1, x1, x0, x1, x0, x0) .\n  eq [365]: xF5 = buildOctet (x1, x1, x1, x1, x0, x1, x0, x1) .\n  eq [366]: xF6 = buildOctet (x1, x1, x1, x1, x0, x1, x1, x0) .\n  eq [367]: xF7 = buildOctet (x1, x1, x1, x1, x0, x1, x1, x1) .\n  eq [368]: xF8 = buildOctet (x1, x1, x1, x1, x1, x0, x0, x0) .\n  eq [369]: xF9 = buildOctet (x1, x1, x1, x1, x1, x0, x0, x1) .\n  eq [370]: xFA = buildOctet (x1, x1, x1, x1, x1, x0, x1, x0) .\n  eq [371]: xFB = buildOctet (x1, x1, x1, x1, x1, x0, x1, x1) .\n  eq [372]: xFC = buildOctet (x1, x1, x1, x1, x1, x1, x0, x0) .\n  eq [373]: xFD = buildOctet (x1, x1, x1, x1, x1, x1, x0, x1) .\n  eq [374]: xFE = buildOctet (x1, x1, x1, x1, x1, x1, x1, x0) .\n  eq [375]: xFF = buildOctet (x1, x1, x1, x1, x1, x1, x1, x1) .\n  eq [376]: andBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (andOctet (O1:Octet, O-prime1:Octet), andOctet (O2:Octet, O-prime2:Octet), andOctet (O3:Octet, O-prime3:Octet), andOctet (O4:Octet, O-prime4:Octet)) .\n  eq [377]: orBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (orOctet (O1:Octet, O-prime1:Octet), orOctet (O2:Octet, O-prime2:Octet), orOctet (O3:Octet, O-prime3:Octet), orOctet (O4:Octet, O-prime4:Octet)) .\n  eq [378]: xorBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (xorOctet (O1:Octet, O-prime1:Octet), xorOctet (O2:Octet, O-prime2:Octet), xorOctet (O3:Octet, O-prime3:Octet), xorOctet (O4:Octet, O-prime4:Octet)) .\n  eq [379]: x0001 = buildHalf (x00, x01) .\n  eq [380]: x00000000 = buildBlock (x00, x00, x00, x00) .\n  eq [381]: x00000001 = buildBlock (x00, x00, x00, x01) .\n  eq [382]: x00000002 = buildBlock (x00, x00, x00, x02) .\n  eq [383]: x00000003 = buildBlock (x00, x00, x00, x03) .\n  eq [384]: x00000004 = buildBlock (x00, x00, x00, x04) .\n  eq [385]: x00000005 = buildBlock (x00, x00, x00, x05) .\n  eq [386]: x00000006 = buildBlock (x00, x00, x00, x06) .\n  eq [387]: x00000007 = buildBlock (x00, x00, x00, x07) .\n  eq [388]: x00000008 = buildBlock (x00, x00, x00, x08) .\n  eq [389]: x00000009 = buildBlock (x00, x00, x00, x09) .\n  eq [390]: x0000000A = buildBlock (x00, x00, x00, x0A) .\n  eq [391]: x0000000B = buildBlock (x00, x00, x00, x0B) .\n  eq [392]: x0000000C = buildBlock (x00, x00, x00, x0C) .\n  eq [393]: x0000000D = buildBlock (x00, x00, x00, x0D) .\n  eq [394]: x0000000E = buildBlock (x00, x00, x00, x0E) .\n  eq [395]: x0000000F = buildBlock (x00, x00, x00, x0F) .\n  eq [396]: x00000010 = buildBlock (x00, x00, x00, x10) .\n  eq [397]: x00000012 = buildBlock (x00, x00, x00, x12) .\n  eq [398]: x00000014 = buildBlock (x00, x00, x00, x14) .\n  eq [399]: x00000016 = buildBlock (x00, x00, x00, x16) .\n  eq [401]: x00000018 = buildBlock (x00, x00, x00, x18) .\n  eq [402]: x0000001B = buildBlock (x00, x00, x00, x1B) .\n  eq [403]: x0000001D = buildBlock (x00, x00, x00, x1D) .\n  eq [404]: x0000001E = buildBlock (x00, x00, x00, x1E) .\n  eq [405]: x0000001F = buildBlock (x00, x00, x00, x1F) .\n  eq [406]: x00000031 = buildBlock (x00, x00, x00, x31) .\n  eq [407]: x00000036 = buildBlock (x00, x00, x00, x36) .\n  eq [408]: x00000060 = buildBlock (x00, x00, x00, x60) .\n  eq [409]: x00000080 = buildBlock (x00, x00, x00, x80) .\n  eq [410]: x000000A5 = buildBlock (x00, x00, x00, xA5) .\n  eq [411]: x000000B6 = buildBlock (x00, x00, x00, xB6) .\n  eq [412]: x000000C4 = buildBlock (x00, x00, x00, xC4) .\n  eq [413]: x000000D2 = buildBlock (x00, x00, x00, xD2) .\n  eq [414]: x00000100 = buildBlock (x00, x00, x01, x00) .\n  eq [415]: x00000129 = buildBlock (x00, x00, x01, x29) .\n  eq [416]: x0000018C = buildBlock (x00, x00, x01, x8C) .\n  eq [417]: x00004000 = buildBlock (x00, x00, x40, x00) .\n  eq [418]: x00010000 = buildBlock (x00, x01, x00, x00) .\n  eq [419]: x00020000 = buildBlock (x00, x02, x00, x00) .\n  eq [420]: x00030000 = buildBlock (x00, x03, x00, x00) .\n  eq [421]: x00040000 = buildBlock (x00, x04, x00, x00) .\n  eq [422]: x00060000 = buildBlock (x00, x06, x00, x00) .\n  eq [423]: x00804021 = buildBlock (x00, x80, x40, x21) .\n  eq [424]: x00FF00FF = buildBlock (x00, xFF, x00, xFF) .\n  eq [425]: x0103050B = buildBlock (x01, x03, x05, x0B) .\n  eq [426]: x01030703 = buildBlock (x01, x03, x07, x03) .\n  eq [427]: x01030705 = buildBlock (x01, x03, x07, x05) .\n  eq [428]: x0103070F = buildBlock (x01, x03, x07, x0F) .\n  eq [429]: x02040801 = buildBlock (x02, x04, x08, x01) .\n  eq [430]: x0297AF6F = buildBlock (x02, x97, xAF, x6F) .\n  eq [431]: x07050301 = buildBlock (x07, x05, x03, x01) .\n  eq [432]: x077788A2 = buildBlock (x07, x77, x88, xA2) .\n  eq [433]: x07C72EAA = buildBlock (x07, xC7, x2E, xAA) .\n  eq [434]: x0A202020 = buildBlock (x0A, x20, x20, x20) .\n  eq [435]: x0AD67E20 = buildBlock (x0A, xD6, x7E, x20) .\n  eq [436]: x10000000 = buildBlock (x10, x00, x00, x00) .\n  eq [437]: x11A9D254 = buildBlock (x11, xA9, xD2, x54) .\n  eq [438]: x11AC46B8 = buildBlock (x11, xAC, x46, xB8) .\n  eq [439]: x1277A6D4 = buildBlock (x12, x77, xA6, xD4) .\n  eq [440]: x13647149 = buildBlock (x13, x64, x71, x49) .\n  eq [441]: x160EE9B5 = buildBlock (x16, x0E, xE9, xB5) .\n  eq [442]: x17065DBB = buildBlock (x17, x06, x5D, xBB) .\n  eq [443]: x17A808FD = buildBlock (x17, xA8, x08, xFD) .\n  eq [444]: x1D10D8D3 = buildBlock (x1D, x10, xD8, xD3) .\n  eq [445]: x1D3B7760 = buildBlock (x1D, x3B, x77, x60) .\n  eq [446]: x1D9C9655 = buildBlock (x1D, x9C, x96, x55) .\n  eq [447]: x1F3F7FFF = buildBlock (x1F, x3F, x7F, xFF) .\n  eq [448]: x204E80A7 = buildBlock (x20, x4E, x80, xA7) .\n  eq [449]: x21D869BA = buildBlock (x21, xD8, x69, xBA) .\n  eq [450]: x24B66FB5 = buildBlock (x24, xB6, x6F, xB5) .\n  eq [451]: x270EEDAF = buildBlock (x27, x0E, xED, xAF) .\n  eq [452]: x277B4B25 = buildBlock (x27, x7B, x4B, x25) .\n  eq [453]: x2829040B = buildBlock (x28, x29, x04, x0B) .\n  eq [454]: x288FC786 = buildBlock (x28, x8F, xC7, x86) .\n  eq [455]: x28EAD8B3 = buildBlock (x28, xEA, xD8, xB3) .\n  eq [456]: x29907CD8 = buildBlock (x29, x90, x7C, xD8) .\n  eq [457]: x29C1485F = buildBlock (x29, xC1, x48, x5F) .\n  eq [458]: x29EEE96B = buildBlock (x29, xEE, xE9, x6B) .\n  eq [459]: x2A6091AE = buildBlock (x2A, x60, x91, xAE) .\n  eq [460]: x2BF8499A = buildBlock (x2B, xF8, x49, x9A) .\n  eq [461]: x2E80AC30 = buildBlock (x2E, x80, xAC, x30) .\n  eq [462]: x2FD76FFB = buildBlock (x2F, xD7, x6F, xFB) .\n  eq [463]: x30261492 = buildBlock (x30, x26, x14, x92) .\n  eq [464]: x303FF4AA = buildBlock (x30, x3F, xF4, xAA) .\n  eq [465]: x33D5A466 = buildBlock (x33, xD5, xA4, x66) .\n  eq [466]: x344925FC = buildBlock (x34, x49, x25, xFC) .\n  eq [467]: x34ACF886 = buildBlock (x34, xAC, xF8, x86) .\n  eq [468]: x3CD54DEB = buildBlock (x3C, xD5, x4D, xEB) .\n  eq [469]: x3CF3A7D2 = buildBlock (x3C, xF3, xA7, xD2) .\n  eq [470]: x3DD81AC6 = buildBlock (x3D, xD8, x1A, xC6) .\n  eq [471]: x3F6F7248 = buildBlock (x3F, x6F, x72, x48) .\n  eq [472]: x48B204D6 = buildBlock (x48, xB2, x04, xD6) .\n  eq [473]: x4A645A01 = buildBlock (x4A, x64, x5A, x01) .\n  eq [474]: x4C49AAE0 = buildBlock (x4C, x49, xAA, xE0) .\n  eq [475]: x4CE933E1 = buildBlock (x4C, xE9, x33, xE1) .\n  eq [476]: x4D53901A = buildBlock (x4D, x53, x90, x1A) .\n  eq [477]: x4DA124A1 = buildBlock (x4D, xA1, x24, xA1) .\n  eq [478]: x4F998E01 = buildBlock (x4F, x99, x8E, x01) .\n  eq [479]: x4FB1138A = buildBlock (x4F, xB1, x13, x8A) .\n  eq [480]: x50DEC930 = buildBlock (x50, xDE, xC9, x30) .\n  eq [481]: x51AF3C1D = buildBlock (x51, xAF, x3C, x1D) .\n  eq [482]: x51EDE9C7 = buildBlock (x51, xED, xE9, xC7) .\n  eq [483]: x550D91CE = buildBlock (x55, x0D, x91, xCE) .\n  eq [484]: x55555555 = buildBlock (x55, x55, x55, x55) .\n  eq [485]: x55DD063F = buildBlock (x55, xDD, x06, x3F) .\n  eq [486]: x5834A585 = buildBlock (x58, x34, xA5, x85) .\n  eq [487]: x5A35D667 = buildBlock (x5A, x35, xD6, x67) .\n  eq [488]: x5BC02502 = buildBlock (x5B, xC0, x25, x02) .\n  eq [489]: x5CCA3239 = buildBlock (x5C, xCA, x32, x39) .\n  eq [490]: x5EBA06C2 = buildBlock (x5E, xBA, x06, xC2) .\n  eq [491]: x5F38EEF1 = buildBlock (x5F, x38, xEE, xF1) .\n  eq [492]: x613F8E2A = buildBlock (x61, x3F, x8E, x2A) .\n  eq [493]: x63C70DBA = buildBlock (x63, xC7, x0D, xBA) .\n  eq [494]: x6AD6E8A4 = buildBlock (x6A, xD6, xE8, xA4) .\n  eq [495]: x6AEBACF8 = buildBlock (x6A, xEB, xAC, xF8) .\n  eq [496]: x6D67E884 = buildBlock (x6D, x67, xE8, x84) .\n  eq [497]: x7050EC5E = buildBlock (x70, x50, xEC, x5E) .\n  eq [498]: x717153D5 = buildBlock (x71, x71, x53, xD5) .\n  eq [499]: x7201F4DC = buildBlock (x72, x01, xF4, xDC) .\n  eq [500]: x7397C9AE = buildBlock (x73, x97, xC9, xAE) .\n  eq [501]: x74B39176 = buildBlock (x74, xB3, x91, x76) .\n  eq [502]: x76232E5F = buildBlock (x76, x23, x2E, x5F) .\n  eq [503]: x7783C51D = buildBlock (x77, x83, xC5, x1D) .\n  eq [504]: x7792F9D4 = buildBlock (x77, x92, xF9, xD4) .\n  eq [505]: x7BC180AB = buildBlock (x7B, xC1, x80, xAB) .\n  eq [506]: x7DB2D9F4 = buildBlock (x7D, xB2, xD9, xF4) .\n  eq [507]: x7DFEFBFF = buildBlock (x7D, xFE, xFB, xFF) .\n  eq [508]: x7F76A3B0 = buildBlock (x7F, x76, xA3, xB0) .\n  eq [509]: x7F839576 = buildBlock (x7F, x83, x95, x76) .\n  eq [510]: x7FFFFFF0 = buildBlock (x7F, xFF, xFF, xF0) .\n  eq [511]: x7FFFFFF1 = buildBlock (x7F, xFF, xFF, xF1) .\n  eq [512]: x7FFFFFFC = buildBlock (x7F, xFF, xFF, xFC) .\n  eq [513]: x7FFFFFFD = buildBlock (x7F, xFF, xFF, xFD) .\n  eq [514]: x80000000 = buildBlock (x80, x00, x00, x00) .\n  eq [515]: x80000002 = buildBlock (x80, x00, x00, x02) .\n  eq [516]: x800000C2 = buildBlock (x80, x00, x00, xC2) .\n  eq [517]: x80018000 = buildBlock (x80, x01, x80, x00) .\n  eq [518]: x80018001 = buildBlock (x80, x01, x80, x01) .\n  eq [519]: x80397302 = buildBlock (x80, x39, x73, x02) .\n  eq [520]: x81D10CA3 = buildBlock (x81, xD1, x0C, xA3) .\n  eq [521]: x89D635D7 = buildBlock (x89, xD6, x35, xD7) .\n  eq [522]: x8CE37709 = buildBlock (x8C, xE3, x77, x09) .\n  eq [523]: x8DC8BBDE = buildBlock (x8D, xC8, xBB, xDE) .\n  eq [524]: x9115A558 = buildBlock (x91, x15, xA5, x58) .\n  eq [525]: x91896CFA = buildBlock (x91, x89, x6C, xFA) .\n  eq [526]: x9372CDC6 = buildBlock (x93, x72, xCD, xC6) .\n  eq [527]: x98D1CC75 = buildBlock (x98, xD1, xCC, x75) .\n  eq [528]: x9D15C437 = buildBlock (x9D, x15, xC4, x37) .\n  eq [529]: x9DB15CF6 = buildBlock (x9D, xB1, x5C, xF6) .\n  eq [530]: x9E2E7B36 = buildBlock (x9E, x2E, x7B, x36) .\n  eq [531]: xA018C83B = buildBlock (xA0, x18, xC8, x3B) .\n  eq [532]: xA0B87B77 = buildBlock (xA0, xB8, x7B, x77) .\n  eq [533]: xA44AAAC0 = buildBlock (xA4, x4A, xAA, xC0) .\n  eq [534]: xA511987A = buildBlock (xA5, x11, x98, x7A) .\n  eq [535]: xA70FC148 = buildBlock (xA7, x0F, xC1, x48) .\n  eq [536]: xA93BD410 = buildBlock (xA9, x3B, xD4, x10) .\n  eq [537]: xAAAAAAAA = buildBlock (xAA, xAA, xAA, xAA) .\n  eq [538]: xAB00FFCD = buildBlock (xAB, x00, xFF, xCD) .\n  eq [539]: xAB01FCCD = buildBlock (xAB, x01, xFC, xCD) .\n  eq [540]: xAB6EED4A = buildBlock (xAB, x6E, xED, x4A) .\n  eq [541]: xABEEED6B = buildBlock (xAB, xEE, xED, x6B) .\n  eq [542]: xACBC13DD = buildBlock (xAC, xBC, x13, xDD) .\n  eq [543]: xB1CC1CC5 = buildBlock (xB1, xCC, x1C, xC5) .\n  eq [544]: xB8142629 = buildBlock (xB8, x14, x26, x29) .\n  eq [545]: xB99A62DE = buildBlock (xB9, x9A, x62, xDE) .\n  eq [546]: xBA92DB12 = buildBlock (xBA, x92, xDB, x12) .\n  eq [547]: xBBA57835 = buildBlock (xBB, xA5, x78, x35) .\n  eq [548]: xBE9F0917 = buildBlock (xBE, x9F, x09, x17) .\n  eq [549]: xBF2D7D85 = buildBlock (xBF, x2D, x7D, x85) .\n  eq [550]:  xBFEF7FDF = buildBlock (xBF, xEF, x7F, xDF) .\n  eq [551]: xC1ED90DD = buildBlock (xC1, xED, x90, xDD) .\n  eq [552]: xC21A1846 = buildBlock (xC2, x1A, x18, x46) .\n  eq [553]: xC4EB1AEB = buildBlock (xC4, xEB, x1A, xEB) .\n  eq [554]: xC6B1317E = buildBlock (xC6, xB1, x31, x7E) .\n  eq [555]: xCBC865BA = buildBlock (xCB, xC8, x65, xBA) .\n  eq [556]: xCD959B46 = buildBlock (xCD, x95, x9B, x46) .\n  eq [557]: xD0482465 = buildBlock (xD0, x48, x24, x65) .\n  eq [558]: xD636250D = buildBlock (xD6, x36, x25, x0D) .\n  eq [559]: xD7843FDC = buildBlock (xD7, x84, x3F, xDC) .\n  eq [560]: xD78634BC = buildBlock (xD7, x86, x34, xBC) .\n  eq [561]: xD8804CA5 = buildBlock (xD8, x80, x4C, xA5) .\n  eq [562]: xDB79FBDC = buildBlock (xDB, x79, xFB, xDC) .\n  eq [563]: xDB9102B0 = buildBlock (xDB, x91, x02, xB0) .\n  eq [564]: xE0C08000 = buildBlock (xE0, xC0, x80, x00) .\n  eq [565]: xE6A12F07 = buildBlock (xE6, xA1, x2F, x07) .\n  eq [566]: xEB35B97F = buildBlock (xEB, x35, xB9, x7F) .\n  eq [567]: xF0239DD5 = buildBlock (xF0, x23, x9D, xD5) .\n  eq [568]: xF14D6E28 = buildBlock (xF1, x4D, x6E, x28) .\n  eq [569]: xF2EF3501 = buildBlock (xF2, xEF, x35, x01) .\n  eq [570]: xF6A09667 = buildBlock (xF6, xA0, x96, x67) .\n  eq [571]: xFD297DA4 = buildBlock (xFD, x29, x7D, xA4) .\n  eq [572]: xFDC1A8BA = buildBlock (xFD, xC1, xA8, xBA) .\n  eq [573]: xFE4E5BDD = buildBlock (xFE, x4E, x5B, xDD) .\n  eq [574]: xFEA1D334 = buildBlock (xFE, xA1, xD3, x34) .\n  eq [575]: xFECCAA6E = buildBlock (xFE, xCC, xAA, x6E) .\n  eq [576]: xFEFC07F0 = buildBlock (xFE, xFC, x07, xF0) .\n  eq [577]: xFF2D7DA5 = buildBlock (xFF, x2D, x7D, xA5) .\n  eq [578]: xFFEF0001 = buildBlock (xFF, xEF, x00, x01) .\n  eq [579]: xFFFF00FF = buildBlock (xFF, xFF, x00, xFF) .\n  eq [580]: xFFFFFF2D = buildBlock (xFF, xFF, xFF, x2D) .\n  eq [581]: xFFFFFF3A = buildBlock (xFF, xFF, xFF, x3A) .\n  eq [582]: xFFFFFFF0 = buildBlock (xFF, xFF, xFF, xF0) .\n  eq [583]: xFFFFFFF1 = buildBlock (xFF, xFF, xFF, xF1) .\n  eq [584]: xFFFFFFF4 = buildBlock (xFF, xFF, xFF, xF4) .\n  eq [585]: xFFFFFFF5 = buildBlock (xFF, xFF, xFF, xF5) .\n  eq [586]: xFFFFFFF7 = buildBlock (xFF, xFF, xFF, xF7) .\n  eq [587]: xFFFFFFF9 = buildBlock (xFF, xFF, xFF, xF9) .\n  eq [588]: xFFFFFFFA = buildBlock (xFF, xFF, xFF, xFA) .\n  eq [589]: xFFFFFFFB = buildBlock (xFF, xFF, xFF, xFB) .\n  eq [590]: xFFFFFFFC = buildBlock (xFF, xFF, xFF, xFC) .\n  eq [591]: xFFFFFFFD = buildBlock (xFF, xFF, xFF, xFD) .\n  eq [592]: xFFFFFFFE = buildBlock (xFF, xFF, xFF, xFE) .\n  eq [593]: xFFFFFFFF = buildBlock (xFF, xFF, xFF, xFF) .\n  eq [594]: appendMessage (unitMessage (W:Block), W-prime:Block) = consMessage (W:Block, unitMessage (W-prime:Block)) .\n  eq [595]: appendMessage (consMessage (W:Block, M:Message), W-prime:Block) = consMessage (W:Block, appendMessage (M:Message, W-prime:Block)) .\n  eq [596]: reverseMessage (unitMessage (W:Block)) = unitMessage (W:Block) .\n  eq [597]: reverseMessage (consMessage (W:Block, M:Message)) = appendMessage (reverseMessage (M:Message), W:Block) .\n ceq [598]: makeMessage (succ (N:Nat), W:Block, W-prime:Block) = unitMessage (W:Block) if eqNat (N:Nat, zero) = Xtrue .\n ceq [599]: makeMessage (succ (N:Nat), W:Block, W-prime:Block) = consMessage (W:Block, makeMessage (N:Nat, ADD (W:Block, W-prime:Block), W-prime:Block)) if eqNat (N:Nat, zero) = Xfalse .\n  eq [600]: ADD (W:Block, W-prime:Block) = addBlock (W:Block, W-prime:Block) .\n  eq [601]: AND (W:Block, W-prime:Block) = andBlock (W:Block, W-prime:Block) .\n  eq [602]: MUL (W:Block, W-prime:Block) = mulBlock (W:Block, W-prime:Block) .\n  eq [603]: OR (W:Block, W-prime:Block) = orBlock (W:Block, W-prime:Block) .\n  eq [604]: XOR (W:Block, W-prime:Block) = xorBlock (W:Block, W-prime:Block) .\n  eq [605]: XOR-prime (buildPair (W:Block, W-prime:Block)) = XOR (W:Block, W-prime:Block) .\n  eq [606]: CYC (buildBlock (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B9:Bit, B10:Bit, B11:Bit, B12:Bit, B13:Bit, B14:Bit, B15:Bit, B16:Bit), buildOctet (B17:Bit, B18:Bit, B19:Bit, B20:Bit, B21:Bit, B22:Bit, B23:Bit, B24:Bit), buildOctet (B25:Bit, B26:Bit, B27:Bit, B28:Bit, B29:Bit, B30:Bit, B31:Bit, B32:Bit))) = buildBlock (buildOctet (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, B9:Bit), buildOctet (B10:Bit, B11:Bit, B12:Bit, B13:Bit, B14:Bit, B15:Bit, B16:Bit, B17:Bit), buildOctet (B18:Bit, B19:Bit, B20:Bit, B21:Bit, B22:Bit, B23:Bit, B24:Bit, B25:Bit), buildOctet (B26:Bit, B27:Bit, B28:Bit, B29:Bit, B30:Bit, B31:Bit, B32:Bit, B1:Bit)) .\n  eq [607]: nCYC (zero, W:Block) = W:Block .\n  eq [608]: nCYC (succ (N:Nat), W:Block) = CYC (nCYC (N:Nat, W:Block)) .\n  eq [609]: FIX1 (W:Block) = AND (OR (W:Block, x02040801), xBFEF7FDF) .\n  eq [610]: FIX2 (W:Block) = AND (OR (W:Block, x00804021), x7DFEFBFF) .\n  eq [611]: needAdjust (O:Octet) = orBool (eqOctet (O:Octet, x00), eqOctet (O:Octet, xFF)) .\n ceq [612]: adjustCode (O:Octet) = x1 if needAdjust (O:Octet) = Xtrue .\n ceq [613]: adjustCode (O:Octet) = x0 if needAdjust (O:Octet) = Xfalse .\n ceq [614]: adjust (O:Octet, O-prime:Octet) = xorOctet (O:Octet, O-prime:Octet) if needAdjust (O:Octet) = Xtrue .\n ceq [615]: adjust (O:Octet, O-prime:Octet) = O:Octet if needAdjust (O:Octet) = Xfalse .\n  eq [616]: PAT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildOctet (adjustCode (O1:Octet), adjustCode (O2:Octet), adjustCode (O3:Octet), adjustCode (O4:Octet), adjustCode (O-prime1:Octet), adjustCode (O-prime2:Octet), adjustCode (O-prime3:Octet), adjustCode (O-prime4:Octet)) .\n  eq [617]: BYT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = BYT-prime (O1:Octet, O2:Octet, O3:Octet, O4:Octet, O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet, PAT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet))) .\n  eq [618]: BYT-prime (O1:Octet, O2:Octet, O3:Octet, O4:Octet, O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet, Opat:Octet) = buildPair (buildBlock (adjust (O1:Octet, rightOctet7 (Opat:Octet)), adjust (O2:Octet, rightOctet6 (Opat:Octet)), adjust (O3:Octet, rightOctet5 (Opat:Octet)), adjust (O4:Octet, rightOctet4 (Opat:Octet))), buildBlock (adjust (O-prime1:Octet, rightOctet3 (Opat:Octet)), adjust (O-prime2:Octet, rightOctet2 (Opat:Octet)), adjust (O-prime3:Octet, rightOctet1 (Opat:Octet)), adjust (O-prime4:Octet, Opat:Octet))) .\n  eq [619]: ADDC (W:Block, W-prime:Block) = ADDC-prime (addBlockSum (W:Block, W-prime:Block)) .\n  eq [620]: ADDC-prime (buildBlockSum (x0, W:Block)) = buildPair (x00000000, W:Block) .\n  eq [621]: ADDC-prime (buildBlockSum (x1, W:Block)) = buildPair (x00000001, W:Block) .\n  eq [622]: MUL1 (W:Block, W-prime:Block) = MUL1XY (MUL (W:Block, W-prime:Block)) .\n  eq [623]: MUL1XY (buildPair (W:Block, W-prime:Block)) = MUL1UL (W:Block, W-prime:Block) .\n  eq [624]: MUL1UL (W:Block, W-prime:Block) = MUL1SC (ADDC (W:Block, W-prime:Block)) .\n  eq [625]: MUL1SC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, Wcarry:Block) .\n  eq [626]: MUL2 (W:Block, W-prime:Block) = MUL2XY (MUL (W:Block, W-prime:Block)) .\n  eq [627]: MUL2XY (buildPair (W:Block, W-prime:Block)) = MUL2UL (W:Block, W-prime:Block) .\n  eq [628]: MUL2UL (W:Block, W-prime:Block) = MUL2DEL (ADDC (W:Block, W:Block), W-prime:Block) .\n  eq [629]: MUL2DEL (buildPair (Wcarry:Block, W:Block), W-prime:Block) = MUL2FL (ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)), W-prime:Block) .\n  eq [630]: MUL2FL (W:Block, W-prime:Block) = MUL2SC (ADDC (W:Block, W-prime:Block)) .\n  eq [631]: MUL2SC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)) .\n  eq [632]: MUL2A (W:Block, W-prime:Block) = MUL2AXY (MUL (W:Block, W-prime:Block)) .\n  eq [633]: MUL2AXY (buildPair (W:Block, W-prime:Block)) = MUL2AUL (W:Block, W-prime:Block) .\n  eq [634]: MUL2AUL (W:Block, W-prime:Block) = MUL2ADL (ADD (W:Block, W:Block), W-prime:Block) .\n  eq [635]: MUL2ADL (W:Block, W-prime:Block) = MUL2ASC (ADDC (W:Block, W-prime:Block)) .\n  eq [636]: MUL2ASC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)) .\n  eq [637]: squareHalf (H:Half) = mulHalf (H:Half, H:Half) .\n  eq [638]: Q (O:Octet) = squareHalf (addHalf (buildHalf (x00, O:Octet), x0001)) .\n  eq [639]: J1-2 (W:Block) = MUL1 (W:Block, W:Block) .\n  eq [640]: J1-4 (W:Block) = MUL1 (J1-2 (W:Block), J1-2 (W:Block)) .\n  eq [641]: J1-6 (W:Block) = MUL1 (J1-2 (W:Block), J1-4 (W:Block)) .\n  eq [642]: J1-8 (W:Block) = MUL1 (J1-2 (W:Block), J1-6 (W:Block)) .\n  eq [643]: J2-2 (W:Block) = MUL2 (W:Block, W:Block) .\n  eq [644]: J2-4 (W:Block) = MUL2 (J2-2 (W:Block), J2-2 (W:Block)) .\n  eq [645]: J2-6 (W:Block) = MUL2 (J2-2 (W:Block), J2-4 (W:Block)) .\n  eq [646]: J2-8 (W:Block) = MUL2 (J2-2 (W:Block), J2-6 (W:Block)) .\n  eq [647]: K1-2 (W:Block) = MUL1 (W:Block, W:Block) .\n  eq [648]: K1-4 (W:Block) = MUL1 (K1-2 (W:Block), K1-2 (W:Block)) .\n  eq [649]: K1-5 (W:Block) = MUL1 (W:Block, K1-4 (W:Block)) .\n  eq [650]: K1-7 (W:Block) = MUL1 (K1-2 (W:Block), K1-5 (W:Block)) .\n  eq [651]: K1-9 (W:Block) = MUL1 (K1-2 (W:Block), K1-7 (W:Block)) .\n  eq [652]: K2-2 (W:Block) = MUL2 (W:Block, W:Block) .\n  eq [653]: K2-4 (W:Block) = MUL2 (K2-2 (W:Block), K2-2 (W:Block)) .\n  eq [654]: K2-5 (W:Block) = MUL2 (W:Block, K2-4 (W:Block)) .\n  eq [655]: K2-7 (W:Block) = MUL2 (K2-2 (W:Block), K2-5 (W:Block)) .\n  eq [656]: K2-9 (W:Block) = MUL2 (K2-2 (W:Block), K2-7 (W:Block)) .\n  eq [657]: H4 (W:Block) = XOR (J1-4 (W:Block), J2-4 (W:Block)) .\n  eq [658]: H6 (W:Block) = XOR (J1-6 (W:Block), J2-6 (W:Block)) .\n  eq [659]: H8 (W:Block) = XOR (J1-8 (W:Block), J2-8 (W:Block)) .\n  eq [660]: H0 (W:Block) = XOR (K1-5 (W:Block), K2-5 (W:Block)) .\n  eq [661]: H5 (W:Block, O:Octet) = MUL2 (H0 (W:Block), Q (O:Octet)) .\n  eq [662]: H7 (W:Block) = XOR (K1-7 (W:Block), K2-7 (W:Block)) .\n  eq [663]: H9 (W:Block) = XOR (K1-9 (W:Block), K2-9 (W:Block)) .\n  eq [664]: splitSegment (unitMessage (W:Block)) = unitSegment (unitMessage (W:Block)) .\n  eq [665]: splitSegment (consMessage (W:Block, M:Message)) = cutSegment (M:Message, unitMessage (W:Block), n254) .\n  eq [666]: cutSegment (unitMessage (W:Block), M-prime:Message, N:Nat) = unitSegment (reverseMessage (consMessage (W:Block, M-prime:Message))) .\n  eq [667]: cutSegment (consMessage (W:Block, M:Message), M-prime:Message, zero) = consSegment (reverseMessage (consMessage (W:Block, M-prime:Message)), splitSegment (M:Message)) .\n  eq [668]: cutSegment (consMessage (W:Block, M:Message), M-prime:Message, succ (N:Nat)) = cutSegment (M:Message, consMessage (W:Block, M-prime:Message), N:Nat) .\n  eq [669]: preludeXY (W1:Block, W2:Block) = preludeXY-prime (BYT (W1:Block, W2:Block), PAT (W1:Block, W2:Block)) .\n  eq [670]: preludeVW (W1:Block, W2:Block) = preludeVW-prime (BYT (W1:Block, W2:Block)) .\n  eq [671]: preludeST (W1:Block, W2:Block) = preludeST-prime (BYT (W1:Block, W2:Block)) .\n  eq [672]: preludeXY-prime (buildPair (W:Block, W-prime:Block), O:Octet) = BYT (H4 (W:Block), H5 (W-prime:Block, O:Octet)) .\n  eq [673]: preludeVW-prime (buildPair (W:Block, W-prime:Block)) = BYT (H6 (W:Block), H7 (W-prime:Block)) .\n  eq [674]: preludeST-prime (buildPair (W:Block, W-prime:Block)) = BYT (H8 (W:Block), H9 (W-prime:Block)) .\n  eq [675]: computeXY (P:Pair, P-prime:Pair, W:Block) = computeXY-prime (P:Pair, W:Block, XOR-prime (computeVW (P-prime:Pair))) .\n  eq [676]: computeXY-prime (buildPair (W1:Block, W2:Block), W:Block, W-prime:Block) = buildPair (MUL1 (XOR (W1:Block, W:Block), FIX1 (ADD (XOR (W2:Block, W:Block), W-prime:Block))), MUL2A (XOR (W2:Block, W:Block), FIX2 (ADD (XOR (W1:Block, W:Block), W-prime:Block)))) .\n  eq [677]: computeVW (buildPair (W1:Block, W2:Block)) = buildPair (CYC (W1:Block), W2:Block) .\n  eq [678]: loop1 (P:Pair, P-prime:Pair, unitMessage (W:Block)) = computeXY (P:Pair, P-prime:Pair, W:Block) .\n  eq [679]: loop1 (P:Pair, P-prime:Pair, consMessage (W:Block, M:Message)) = loop1 (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), M:Message) .\n  eq [680]: loop2 (P:Pair, P-prime:Pair, unitMessage (W:Block)) = computeVW (P-prime:Pair) .\n  eq [681]: loop2 (P:Pair, P-prime:Pair, consMessage (W:Block, M:Message)) = loop2 (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), M:Message) .\n  eq [682]: coda (P:Pair, P-prime:Pair, buildPair (W:Block, W-prime:Block)) = XOR-prime (computeXY (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), W-prime:Block)) .\n  eq [683]: MAA (buildKey (W1:Block, W2:Block), M:Message) = MAA-prime (preludeXY (W1:Block, W2:Block), preludeVW (W1:Block, W2:Block), preludeST (W1:Block, W2:Block), M:Message) .\n  eq [684]: MAA-prime (P1:Pair, P2:Pair, P3:Pair, M:Message) = coda (loop1 (P1:Pair, P2:Pair, M:Message), loop2 (P1:Pair, P2:Pair, M:Message), P3:Pair) .\n  eq [685]: MAC (K:Key, M:Message) = MACfirst (K:Key, splitSegment (M:Message)) .\n  eq [686]: MACfirst (K:Key, unitSegment (M:Message)) = MAA (K:Key, M:Message) .\n  eq [687]: MACfirst (K:Key, consSegment (M:Message, S:SegmentedMessage)) = MACnext (K:Key, MAA (K:Key, M:Message), S:SegmentedMessage) .\n  eq [688]: MACnext (K:Key, W:Block, unitSegment (M:Message)) = MAA (K:Key, consMessage (W:Block, M:Message)) .\n  eq [689]: MACnext (K:Key, W:Block, consSegment (M:Message, S:SegmentedMessage)) = MACnext (K:Key, MAA (K:Key, consMessage (W:Block, M:Message)), S:SegmentedMessage) .\nendfm\neof\nreduce eqBlock (MUL1 (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL1 (xFFFFFFF0, x0000000E), xFFFFFF2D) .\nreduce eqBlock (MUL1 (xFFFFFFF0, xFFFFFFF1), x000000D2) .\nreduce eqBlock (MUL2 (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL2 (xFFFFFFF0, x0000000E), xFFFFFF3A) .\nreduce eqBlock (MUL2 (xFFFFFFF0, xFFFFFFF1), x000000B6) .\nreduce eqBlock (MUL2A (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL2A (xFFFFFFF0, x0000000E), xFFFFFF3A) .\nreduce eqBlock (MUL2A (x7FFFFFF0, xFFFFFFF1), x800000C2) .\nreduce eqBlock (MUL2A (xFFFFFFF0, x7FFFFFF1), x000000C4) .\nreduce eqPair (BYT (x00000000, x00000000), buildPair (x0103070F, x1F3F7FFF)) .\nreduce eqPair (BYT (xFFFF00FF, xFFFFFFFF), buildPair (xFEFC07F0, xE0C08000)) .\nreduce eqPair (BYT (xAB00FFCD, xFFEF0001), buildPair (xAB01FCCD, xF2EF3501)) .\nreduce eqOctet (PAT (x00000000, x00000000), xFF) .\nreduce eqOctet (PAT (xFFFF00FF, xFFFFFFFF), xFF) .\nreduce eqOctet (PAT (xAB00FFCD, xFFEF0001), x6A) .\nreduce eqBlock (J1-2 (x00000100), x00010000) .\nreduce eqBlock (J1-4 (x00000100), x00000001) .\nreduce eqBlock (J1-6 (x00000100), x00010000) .\nreduce eqBlock (J1-8 (x00000100), x00000001) .\nreduce eqBlock (J2-2 (x00000100), x00010000) .\nreduce eqBlock (J2-4 (x00000100), x00000002) .\nreduce eqBlock (J2-6 (x00000100), x00020000) .\nreduce eqBlock (J2-8 (x00000100), x00000004) .\nreduce eqBlock (H4 (x00000100), x00000003) .\nreduce eqBlock (H6 (x00000100), x00030000) .\nreduce eqBlock (H8 (x00000100), x00000005) .\nreduce eqBlock (K1-2 (x00000080), x00004000) .\nreduce eqBlock (K1-4 (x00000080), x10000000) .\nreduce eqBlock (K1-5 (x00000080), x00000008) .\nreduce eqBlock (K1-7 (x00000080), x00020000) .\nreduce eqBlock (K1-9 (x00000080), x80000000) .\nreduce eqBlock (K2-2 (x00000080), x00004000) .\nreduce eqBlock (K2-4 (x00000080), x10000000) .\nreduce eqBlock (K2-5 (x00000080), x00000010) .\nreduce eqBlock (K2-7 (x00000080), x00040000) .\nreduce eqBlock (K2-9 (x00000080), x00000002) .\nreduce eqBlock (H0 (x00000080), x00000018) .\nreduce eqBlock (Q (x01), x00000004) .\nreduce eqBlock (H5 (x00000080, x01), x00000060) .\nreduce eqBlock (H7 (x00000080), x00060000) .\nreduce eqBlock (H9 (x00000080), x80000002) .\nreduce eqOctet (PAT (x00000003, x00000060), xEE) .\nreduce eqOctet (PAT (x00030000, x00060000), xBB) .\nreduce eqOctet (PAT (x00000005, x80000002), xE6) .\nreduce eqPair (BYT (x00000003, x00000060), buildPair (x01030703, x1D3B7760)) .\nreduce eqPair (BYT (x00030000, x00060000), buildPair (x0103050B, x17065DBB)) .\nreduce eqPair (BYT (x00000005, x80000002), buildPair (x01030705, x80397302)) .\nreduce eqBlock (CYC (x00000003), x00000006) .\nreduce eqBlock (XOR (x00000006, x00000003), x00000005) .\nreduce eqBlock (XOR (x00000002, x00000005), x00000007) .\nreduce eqBlock (XOR (x00000003, x00000005), x00000006) .\nreduce eqBlock (ADD (x00000005, x00000006), x0000000B) .\nreduce eqBlock (ADD (x00000005, x00000007), x0000000C) .\nreduce eqBlock (OR (x0000000B, x00000004), x0000000F) .\nreduce eqBlock (OR (x0000000C, x00000001), x0000000D) .\nreduce eqBlock (AND (x0000000F, xFFFFFFF7), x00000007) .\nreduce eqBlock (AND (x0000000D, xFFFFFFFB), x00000009) .\nreduce eqBlock (MUL1 (x00000007, x00000007), x00000031) .\nreduce eqBlock (MUL2A (x00000006, x00000009), x00000036) .\nreduce eqBlock (XOR (x00000031, x00000036), x00000007) .\nreduce eqBlock (CYC (x00000003), x00000006) .\nreduce eqBlock (XOR (x00000006, x00000003), x00000005) .\nreduce eqBlock (XOR (xFFFFFFFD, x00000001), xFFFFFFFC) .\nreduce eqBlock (XOR (xFFFFFFFC, x00000001), xFFFFFFFD) .\nreduce eqBlock (ADD (x00000005, xFFFFFFFD), x00000002) .\nreduce eqBlock (ADD (x00000005, xFFFFFFFC), x00000001) .\nreduce eqBlock (OR (x00000002, x00000001), x00000003) .\nreduce eqBlock (OR (x00000001, x00000004), x00000005) .\nreduce eqBlock (AND (x00000003, xFFFFFFF9), x00000001) .\nreduce eqBlock (AND (x00000005, xFFFFFFFC), x00000004) .\nreduce eqBlock (MUL1 (xFFFFFFFC, x00000001), xFFFFFFFC) .\nreduce eqBlock (MUL2A (xFFFFFFFD, x00000004), xFFFFFFFA) .\nreduce eqBlock (XOR (xFFFFFFFC, xFFFFFFFA), x00000006) .\nreduce eqBlock (CYC (x00000007), x0000000E) .\nreduce eqBlock (XOR (x0000000E, x00000007), x00000009) .\nreduce eqBlock (XOR (xFFFFFFFD, x00000008), xFFFFFFF5) .\nreduce eqBlock (XOR (xFFFFFFFC, x00000008), xFFFFFFF4) .\nreduce eqBlock (ADD (x00000009, xFFFFFFF4), xFFFFFFFD) .\nreduce eqBlock (ADD (x00000009, xFFFFFFF5), xFFFFFFFE) .\nreduce eqBlock (OR (xFFFFFFFD, x00000001), xFFFFFFFD) .\nreduce eqBlock (OR (xFFFFFFFE, x00000002), xFFFFFFFE) .\nreduce eqBlock (AND (xFFFFFFFD, xFFFFFFFE), xFFFFFFFC) .\nreduce eqBlock (AND (xFFFFFFFE, x7FFFFFFD), x7FFFFFFC) .\nreduce eqBlock (MUL1 (xFFFFFFF5, xFFFFFFFC), x0000001E) .\nreduce eqBlock (MUL2A (xFFFFFFF4, x7FFFFFFC), x0000001E) .\nreduce eqBlock (XOR (x0000001E, x0000001E), x00000000) .\nreduce eqBlock (CYC (x00000001), x00000002) .\nreduce eqBlock (XOR (x00000002, x00000001), x00000003) .\nreduce eqBlock (XOR (x00000001, x00000000), x00000001) .\nreduce eqBlock (XOR (x00000002, x00000000), x00000002) .\nreduce eqBlock (ADD (x00000003, x00000002), x00000005) .\nreduce eqBlock (ADD (x00000003, x00000001), x00000004) .\nreduce eqBlock (OR (x00000005, x00000002), x00000007) .\nreduce eqBlock (OR (x00000004, x00000001), x00000005) .\nreduce eqBlock (AND (x00000007, xFFFFFFFB), x00000003) .\nreduce eqBlock (AND (x00000005, xFFFFFFFB), x00000001) .\nreduce eqBlock (MUL1 (x00000001, x00000003), x00000003) .\nreduce eqBlock (MUL2A (x00000002, x00000001), x00000002) .\nreduce eqBlock (XOR (x00000003, x00000002), x00000001) .\nreduce eqBlock (CYC (x00000002), x00000004) .\nreduce eqBlock (XOR (x00000004, x00000001), x00000005) .\nreduce eqBlock (XOR (x00000003, x00000001), x00000002) .\nreduce eqBlock (XOR (x00000002, x00000001), x00000003) .\nreduce eqBlock (ADD (x00000005, x00000003), x00000008) .\nreduce eqBlock (ADD (x00000005, x00000002), x00000007) .\nreduce eqBlock (OR (x00000008, x00000002), x0000000A) .\nreduce eqBlock (OR (x00000007, x00000001), x00000007) .\nreduce eqBlock (AND (x0000000A, xFFFFFFFB), x0000000A) .\nreduce eqBlock (AND (x00000007, xFFFFFFFB), x00000003) .\nreduce eqBlock (MUL1 (x00000002, x0000000A), x00000014) .\nreduce eqBlock (MUL2A (x00000003, x00000003), x00000009) .\nreduce eqBlock (XOR (x00000014, x00000009), x0000001D) .\nreduce eqBlock (CYC (x00000004), x00000008) .\nreduce eqBlock (XOR (x00000008, x00000001), x00000009) .\nreduce eqBlock (XOR (x00000014, x00000002), x00000016) .\nreduce eqBlock (XOR (x00000009, x00000002), x0000000B) .\nreduce eqBlock (ADD (x00000009, x0000000B), x00000014) .\nreduce eqBlock (ADD (x00000009, x00000016), x0000001F) .\nreduce eqBlock (OR (x00000014, x00000002), x00000016) .\nreduce eqBlock (OR (x0000001F, x00000001), x0000001F) .\nreduce eqBlock (AND (x00000016, xFFFFFFFB), x00000012) .\nreduce eqBlock (AND (x0000001F, xFFFFFFFB), x0000001B) .\nreduce eqBlock (MUL1 (x00000016, x00000012), x0000018C) .\nreduce eqBlock (MUL2A (x0000000B, x0000001B), x00000129) .\nreduce eqBlock (XOR (x0000018C, x00000129), x000000A5) .\nreduce eqBlock (CYC (xC4EB1AEB), x89D635D7) .\nreduce eqBlock (XOR (x89D635D7, xF6A09667), x7F76A3B0) .\nreduce eqBlock (XOR (x21D869BA, x0A202020), x2BF8499A) .\nreduce eqBlock (XOR (x7792F9D4, x0A202020), x7DB2D9F4) .\nreduce eqBlock (ADD (x7F76A3B0, x7DB2D9F4), xFD297DA4) .\nreduce eqBlock (ADD (x7F76A3B0, x2BF8499A), xAB6EED4A) .\nreduce eqBlock (OR (xFD297DA4, x02040801), xFF2D7DA5) .\nreduce eqBlock (OR (xAB6EED4A, x00804021), xABEEED6B) .\nreduce eqBlock (AND (xFF2D7DA5, xBFEF7FDF), xBF2D7D85) .\nreduce eqBlock (AND (xABEEED6B, x7DFEFBFF), x29EEE96B) .\nreduce eqBlock (MUL1 (x2BF8499A, xBF2D7D85), x0AD67E20) .\nreduce eqBlock (MUL2A (x7DB2D9F4, x29EEE96B), x30261492) .\nreduce eqOctet (PAT (x00FF00FF, x00000000), xFF) .\nreduce eqPair (preludeXY (x00FF00FF, x00000000), buildPair (x4A645A01, x50DEC930)) .\nreduce eqPair (preludeVW (x00FF00FF, x00000000), buildPair (x5CCA3239, xFECCAA6E)) .\nreduce eqPair (preludeST (x00FF00FF, x00000000), buildPair (x51EDE9C7, x24B66FB5)) .\nreduce eqPair (computeXY-prime (buildPair (x4A645A01, x50DEC930), x55555555, XOR (nCYC (n1, x5CCA3239), xFECCAA6E)), buildPair (x48B204D6, x5834A585)) .\nreduce eqPair (computeXY-prime (buildPair (x48B204D6, x5834A585), xAAAAAAAA, XOR (nCYC (n2, x5CCA3239), xFECCAA6E)), buildPair (x4F998E01, xBE9F0917)) .\nreduce eqPair (computeXY-prime (buildPair (x4F998E01, xBE9F0917), x51EDE9C7, XOR (nCYC (n3, x5CCA3239), xFECCAA6E)), buildPair (x344925FC, xDB9102B0)) .\nreduce eqPair (computeXY-prime (buildPair (x344925FC, xDB9102B0), x24B66FB5, XOR (nCYC (n4, x5CCA3239), xFECCAA6E)), buildPair (x277B4B25, xD636250D)) .\nreduce eqBlock (XOR (x277B4B25, xD636250D), xF14D6E28) .\nreduce eqOctet (PAT (x00FF00FF, x00000000), xFF) .\nreduce eqPair (preludeXY (x00FF00FF, x00000000), buildPair (x4A645A01, x50DEC930)) .\nreduce eqPair (preludeVW (x00FF00FF, x00000000), buildPair (x5CCA3239, xFECCAA6E)) .\nreduce eqPair (preludeST (x00FF00FF, x00000000), buildPair (x51EDE9C7, x24B66FB5)) .\nreduce eqPair (computeXY-prime (buildPair (x4A645A01, x50DEC930), xAAAAAAAA, XOR (nCYC (n1, x5CCA3239), xFECCAA6E)), buildPair (x6AEBACF8, x9DB15CF6)) .\nreduce eqPair (computeXY-prime (buildPair (x6AEBACF8, x9DB15CF6), x55555555, XOR (nCYC (n2, x5CCA3239), xFECCAA6E)), buildPair (x270EEDAF, xB8142629)) .\nreduce eqPair (computeXY-prime (buildPair (x270EEDAF, xB8142629), x51EDE9C7, XOR (nCYC (n3, x5CCA3239), xFECCAA6E)), buildPair (x29907CD8, xBA92DB12)) .\nreduce eqPair (computeXY-prime (buildPair (x29907CD8, xBA92DB12), x24B66FB5, XOR (nCYC (n4, x5CCA3239), xFECCAA6E)), buildPair (x28EAD8B3, x81D10CA3)) .\nreduce eqBlock (XOR (x28EAD8B3, x81D10CA3), xA93BD410) .\nreduce eqOctet (PAT (x55555555, x5A35D667), x00) .\nreduce eqPair (preludeXY (x55555555, x5A35D667), buildPair (x34ACF886, x7397C9AE)) .\nreduce eqPair (preludeVW (x55555555, x5A35D667), buildPair (x7201F4DC, x2829040B)) .\nreduce eqPair (preludeST (x55555555, x5A35D667), buildPair (x9E2E7B36, x13647149)) .\nreduce eqPair (computeXY-prime (buildPair (x34ACF886, x7397C9AE), x00000000, XOR (nCYC (n1, x7201F4DC), x2829040B)), buildPair (x2FD76FFB, x550D91CE)) .\nreduce eqPair (computeXY-prime (buildPair (x2FD76FFB, x550D91CE), xFFFFFFFF, XOR (nCYC (n2, x7201F4DC), x2829040B)), buildPair (xA70FC148, x1D10D8D3)) .\nreduce eqPair (computeXY-prime (buildPair (xA70FC148, x1D10D8D3), x9E2E7B36, XOR (nCYC (n3, x7201F4DC), x2829040B)), buildPair (xB1CC1CC5, x29C1485F)) .\nreduce eqPair (computeXY-prime (buildPair (xB1CC1CC5, x29C1485F), x13647149, XOR (nCYC (n4, x7201F4DC), x2829040B)), buildPair (x288FC786, x9115A558)) .\nreduce eqBlock (XOR (x288FC786, x9115A558), xB99A62DE) .\nreduce eqOctet (PAT (x55555555, x5A35D667), x00) .\nreduce eqPair (preludeXY (x55555555, x5A35D667), buildPair (x34ACF886, x7397C9AE)) .\nreduce eqPair (preludeVW (x55555555, x5A35D667), buildPair (x7201F4DC, x2829040B)) .\nreduce eqPair (preludeST (x55555555, x5A35D667), buildPair (x9E2E7B36, x13647149)) .\nreduce eqPair (computeXY-prime (buildPair (x34ACF886, x7397C9AE), xFFFFFFFF, XOR (nCYC (n1, x7201F4DC), x2829040B)), buildPair (x8DC8BBDE, xFE4E5BDD)) .\nreduce eqPair (computeXY-prime (buildPair (x8DC8BBDE, xFE4E5BDD), x00000000, XOR (nCYC (n2, x7201F4DC), x2829040B)), buildPair (xCBC865BA, x0297AF6F)) .\nreduce eqPair (computeXY-prime (buildPair (xCBC865BA, x0297AF6F), x9E2E7B36, XOR (nCYC (n3, x7201F4DC), x2829040B)), buildPair (x3CF3A7D2, x160EE9B5)) .\nreduce eqPair (computeXY-prime (buildPair (x3CF3A7D2, x160EE9B5), x13647149, XOR (nCYC (n4, x7201F4DC), x2829040B)), buildPair (xD0482465, x7050EC5E)) .\nreduce eqBlock (XOR (xD0482465, x7050EC5E), xA018C83B) .\nreduce eqPair (preludeXY (xE6A12F07, x9D15C437), buildPair (x21D869BA, x7792F9D4)) .\nreduce eqPair (preludeVW (xE6A12F07, x9D15C437), buildPair (xC4EB1AEB, xF6A09667)) .\nreduce eqPair (preludeST (xE6A12F07, x9D15C437), buildPair (x6D67E884, xA511987A)) .\nreduce eqPair (computeXY-prime (buildPair (x204E80A7, x077788A2), x00000000, XOR (nCYC (n1, x17A808FD), xFEA1D334)), buildPair (x303FF4AA, x1277A6D4)) .\nreduce eqPair (computeXY-prime (buildPair (x303FF4AA, x1277A6D4), x00000000, XOR (nCYC (n2, x17A808FD), xFEA1D334)), buildPair (x55DD063F, x4C49AAE0)) .\nreduce eqPair (computeXY-prime (buildPair (x55DD063F, x4C49AAE0), x00000000, XOR (nCYC (n3, x17A808FD), xFEA1D334)), buildPair (x51AF3C1D, x5BC02502)) .\nreduce eqPair (computeXY-prime (buildPair (x51AF3C1D, x5BC02502), x00000000, XOR (nCYC (n4, x17A808FD), xFEA1D334)), buildPair (xA44AAAC0, x63C70DBA)) .\nreduce eqPair (computeXY-prime (buildPair (xA44AAAC0, x63C70DBA), x00000000, XOR (nCYC (n5, x17A808FD), xFEA1D334)), buildPair (x4D53901A, x2E80AC30)) .\nreduce eqPair (computeXY-prime (buildPair (x4D53901A, x2E80AC30), x00000000, XOR (nCYC (n6, x17A808FD), xFEA1D334)), buildPair (x5F38EEF1, x2A6091AE)) .\nreduce eqPair (computeXY-prime (buildPair (x5F38EEF1, x2A6091AE), x00000000, XOR (nCYC (n7, x17A808FD), xFEA1D334)), buildPair (xF0239DD5, x3DD81AC6)) .\nreduce eqPair (computeXY-prime (buildPair (xF0239DD5, x3DD81AC6), x00000000, XOR (nCYC (n8, x17A808FD), xFEA1D334)), buildPair (xEB35B97F, x9372CDC6)) .\nreduce eqPair (computeXY-prime (buildPair (xEB35B97F, x9372CDC6), x00000000, XOR (nCYC (n9, x17A808FD), xFEA1D334)), buildPair (x4DA124A1, xC6B1317E)) .\nreduce eqPair (computeXY-prime (buildPair (x4DA124A1, xC6B1317E), x00000000, XOR (nCYC (n10, x17A808FD), xFEA1D334)), buildPair (x7F839576, x74B39176)) .\nreduce eqPair (computeXY-prime (buildPair (x7F839576, x74B39176), x00000000, XOR (nCYC (n11, x17A808FD), xFEA1D334)), buildPair (x11A9D254, xD78634BC)) .\nreduce eqPair (computeXY-prime (buildPair (x11A9D254, xD78634BC), x00000000, XOR (nCYC (n12, x17A808FD), xFEA1D334)), buildPair (xD8804CA5, xFDC1A8BA)) .\nreduce eqPair (computeXY-prime (buildPair (xD8804CA5, xFDC1A8BA), x00000000, XOR (nCYC (n13, x17A808FD), xFEA1D334)), buildPair (x3F6F7248, x11AC46B8)) .\nreduce eqPair (computeXY-prime (buildPair (x3F6F7248, x11AC46B8), x00000000, XOR (nCYC (n14, x17A808FD), xFEA1D334)), buildPair (xACBC13DD, x33D5A466)) .\nreduce eqPair (computeXY-prime (buildPair (xACBC13DD, x33D5A466), x00000000, XOR (nCYC (n15, x17A808FD), xFEA1D334)), buildPair (x4CE933E1, xC21A1846)) .\nreduce eqPair (computeXY-prime (buildPair (x4CE933E1, xC21A1846), x00000000, XOR (nCYC (n16, x17A808FD), xFEA1D334)), buildPair (xC1ED90DD, xCD959B46)) .\nreduce eqPair (computeXY-prime (buildPair (xC1ED90DD, xCD959B46), x00000000, XOR (nCYC (n17, x17A808FD), xFEA1D334)), buildPair (x3CD54DEB, x613F8E2A)) .\nreduce eqPair (computeXY-prime (buildPair (x3CD54DEB, x613F8E2A), x00000000, XOR (nCYC (n18, x17A808FD), xFEA1D334)), buildPair (xBBA57835, x07C72EAA)) .\nreduce eqPair (computeXY-prime (buildPair (xBBA57835, x07C72EAA), x00000000, XOR (nCYC (n19, x17A808FD), xFEA1D334)), buildPair (xD7843FDC, x6AD6E8A4)) .\nreduce eqPair (computeXY-prime (buildPair (xD7843FDC, x6AD6E8A4), x00000000, XOR (nCYC (n20, x17A808FD), xFEA1D334)), buildPair (x5EBA06C2, x91896CFA)) .\nreduce eqPair (computeXY-prime (buildPair (x5EBA06C2, x91896CFA), x76232E5F, XOR (nCYC (n21, x17A808FD), xFEA1D334)), buildPair (x1D9C9655, x98D1CC75)) .\nreduce eqPair (computeXY-prime (buildPair (x1D9C9655, x98D1CC75), x4FB1138A, XOR (nCYC (n22, x17A808FD), xFEA1D334)), buildPair (x7BC180AB, xA0B87B77)) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n20, x00000000, x00000000)), xDB79FBDC) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n16, x00000000, x07050301)), x8CE37709) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n256, x00000000, x07050301)), x717153D5) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n4100, x00000000, x07050301)), x7783C51D) .\nquit",
        "complete:": "fmod MAA is\n  sorts Xbool Nat Bit Octet OctetSum Half HalfSum Block BlockSum Pair Key Message SegmentedMessage .\n  op Xfalse : -> Xbool [ctor] .\n  op Xtrue : -> Xbool [ctor] .\n  op x0 : -> Bit [ctor] .\n  op x1 : -> Bit [ctor] .\n  op buildOctet : Bit Bit Bit Bit Bit Bit Bit Bit -> Octet [ctor] .\n  op buildOctetSum : Bit Octet -> OctetSum [ctor] .\n  op buildHalf : Octet Octet -> Half [ctor] .\n  op buildHalfSum : Bit Half -> HalfSum [ctor] .\n  op buildBlock : Octet Octet Octet Octet -> Block [ctor] .\n  op buildBlockSum : Bit Block -> BlockSum [ctor] .\n  op buildPair : Block Block -> Pair [ctor] .\n  op zero : -> Nat [ctor] .\n  op succ : Nat -> Nat [ctor] .\n  op buildKey : Block Block -> Key [ctor] .\n  op unitMessage : Block -> Message [ctor] .\n  op consMessage : Block Message -> Message [ctor] .\n  op unitSegment : Message -> SegmentedMessage [ctor] .\n  op consSegment : Message SegmentedMessage -> SegmentedMessage [ctor] .\n  op notBool : Xbool -> Xbool .\n  op andBool : Xbool Xbool -> Xbool .\n  op orBool : Xbool Xbool -> Xbool .\n  op xorBool : Xbool Xbool -> Xbool .\n  op notBit : Bit -> Bit .\n  op andBit : Bit Bit -> Bit .\n  op orBit : Bit Bit -> Bit .\n  op xorBit : Bit Bit -> Bit .\n  op x00 : -> Octet .\n  op x01 : -> Octet .\n  op x0000 : -> Half .\n  op HalfU : Block -> Half .\n  op HalfL : Block -> Half .\n  op eqBit : Bit Bit -> Xbool .\n  op eqOctet : Octet Octet -> Xbool .\n  op eqOctetSum : OctetSum OctetSum -> Xbool .\n  op eqHalf : Half Half -> Xbool .\n  op eqHalfSum : HalfSum HalfSum -> Xbool .\n  op eqBlock : Block Block -> Xbool .\n  op eqBlockSum : BlockSum BlockSum -> Xbool .\n  op eqPair : Pair Pair -> Xbool .\n  op addBit : Bit Bit Bit -> Bit .\n  op carBit : Bit Bit Bit -> Bit .\n  op addOctetSum : Octet Octet Bit -> OctetSum .\n  op addOctet8 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet7 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet6 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet5 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet4 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet3 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet2 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op addOctet0 : Bit Bit Bit Bit Bit Bit Bit Bit Bit -> OctetSum .\n  op dropCarryOctetSum : OctetSum -> Octet .\n  op addOctet : Octet Octet -> Octet .\n  op addHalfSum : Half Half -> HalfSum .\n  op addHalf2 : Octet Octet Octet Octet -> HalfSum .\n  op addHalf1 : Octet Octet OctetSum -> HalfSum .\n  op addHalf0 : OctetSum Octet -> HalfSum .\n  op dropCarryHalfSum : HalfSum -> Half .\n  op addHalf : Half Half -> Half .\n  op addHalfOctet : Octet Half -> Half .\n  op addHalfOctets : Octet Octet -> Half .\n  op addBlockSum : Block Block -> BlockSum .\n  op addBlock4 : Octet Octet Octet Octet Octet Octet Octet Octet -> BlockSum .\n  op addBlock3 : Octet Octet Octet Octet Octet Octet OctetSum -> BlockSum .\n  op addBlock2 : Octet Octet Octet Octet OctetSum Octet -> BlockSum .\n  op addBlock1 : Octet Octet OctetSum Octet Octet -> BlockSum .\n  op addBlock0 : OctetSum Octet Octet Octet -> BlockSum .\n  op dropCarryBlockSum : BlockSum -> Block .\n  op addBlock : Block Block -> Block .\n  op addBlockHalf : Half Block -> Block .\n  op addBlockHalves : Half Half -> Block .\n  op leftOctet1 : Octet -> Octet .\n  op leftOctet2 : Octet -> Octet .\n  op leftOctet3 : Octet -> Octet .\n  op leftOctet4 : Octet -> Octet .\n  op leftOctet5 : Octet -> Octet .\n  op leftOctet6 : Octet -> Octet .\n  op leftOctet7 : Octet -> Octet .\n  op rightOctet1 : Octet -> Octet .\n  op rightOctet2 : Octet -> Octet .\n  op rightOctet3 : Octet -> Octet .\n  op rightOctet4 : Octet -> Octet .\n  op rightOctet5 : Octet -> Octet .\n  op rightOctet6 : Octet -> Octet .\n  op rightOctet7 : Octet -> Octet .\n  op mulOctet : Octet Octet -> Half .\n  op mulOctet1 : Bit Bit Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet2 : Bit Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet3 : Bit Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet4 : Bit Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet5 : Bit Bit Bit Bit Octet Half -> Half .\n  op mulOctet6 : Bit Bit Bit Octet Half -> Half .\n  op mulOctet7 : Bit Bit Octet Half -> Half .\n  op mulOctet8 : Bit Octet Half -> Half .\n  op mulOctetA : Half Octet Octet -> Half .\n  op mulOctetB : Octet OctetSum -> Half .\n  op mulHalf : Half Half -> Block .\n  op mulHalfA : Half Half Half Half -> Block .\n  op mulHalf4 : Octet Octet Octet Octet Octet Octet Octet Octet -> Block .\n  op mulHalf3 : Octet Octet Octet Octet Half Octet -> Block .\n  op mulHalf2 : Octet Half Octet Octet -> Block .\n  op mulHalf1 : Half Octet Octet Octet -> Block .\n  op mulBlock : Block Block -> Pair .\n  op mulBlockA : Block Block Block Block -> Pair .\n  op mulBlock4 : Half Half Half Half Half Half Half Half -> Pair .\n  op mulBlock3 : Half Half Half Half Block Half -> Pair .\n  op mulBlock2 : Half Block Half Half -> Pair .\n  op mulBlock1 : Block Half Half Half -> Pair .\n  op mulBlockB : Half Half Half Half -> Pair .\n  op addNat : Nat Nat -> Nat .\n  op multNat : Nat Nat -> Nat .\n  op eqNat : Nat Nat -> Xbool .\n  op ltNat : Nat Nat -> Xbool .\n  op n1 : -> Nat .\n  op n2 : -> Nat .\n  op n3 : -> Nat .\n  op n4 : -> Nat .\n  op n5 : -> Nat .\n  op n6 : -> Nat .\n  op n7 : -> Nat .\n  op n8 : -> Nat .\n  op n9 : -> Nat .\n  op n10 : -> Nat .\n  op n11 : -> Nat .\n  op n12 : -> Nat .\n  op n13 : -> Nat .\n  op n14 : -> Nat .\n  op n15 : -> Nat .\n  op n16 : -> Nat .\n  op n17 : -> Nat .\n  op n18 : -> Nat .\n  op n19 : -> Nat .\n  op n20 : -> Nat .\n  op n21 : -> Nat .\n  op n22 : -> Nat .\n  op n254 : -> Nat .\n  op n256 : -> Nat .\n  op n4100 : -> Nat .\n  op andOctet : Octet Octet -> Octet .\n  op orOctet : Octet Octet -> Octet .\n  op xorOctet : Octet Octet -> Octet .\n  op x02 : -> Octet .\n  op x03 : -> Octet .\n  op x04 : -> Octet .\n  op x05 : -> Octet .\n  op x06 : -> Octet .\n  op x07 : -> Octet .\n  op x08 : -> Octet .\n  op x09 : -> Octet .\n  op x0A : -> Octet .\n  op x0B : -> Octet .\n  op x0C : -> Octet .\n  op x0D : -> Octet .\n  op x0E : -> Octet .\n  op x0F : -> Octet .\n  op x10 : -> Octet .\n  op x11 : -> Octet .\n  op x12 : -> Octet .\n  op x13 : -> Octet .\n  op x14 : -> Octet .\n  op x15 : -> Octet .\n  op x16 : -> Octet .\n  op x17 : -> Octet .\n  op x18 : -> Octet .\n  op x1A : -> Octet .\n  op x1B : -> Octet .\n  op x1C : -> Octet .\n  op x1D : -> Octet .\n  op x1E : -> Octet .\n  op x1F : -> Octet .\n  op x20 : -> Octet .\n  op x21 : -> Octet .\n  op x23 : -> Octet .\n  op x24 : -> Octet .\n  op x25 : -> Octet .\n  op x26 : -> Octet .\n  op x27 : -> Octet .\n  op x28 : -> Octet .\n  op x29 : -> Octet .\n  op x2A : -> Octet .\n  op x2B : -> Octet .\n  op x2D : -> Octet .\n  op x2E : -> Octet .\n  op x2F : -> Octet .\n  op x30 : -> Octet .\n  op x31 : -> Octet .\n  op x32 : -> Octet .\n  op x33 : -> Octet .\n  op x34 : -> Octet .\n  op x35 : -> Octet .\n  op x36 : -> Octet .\n  op x37 : -> Octet .\n  op x38 : -> Octet .\n  op x39 : -> Octet .\n  op x3A : -> Octet .\n  op x3B : -> Octet .\n  op x3C : -> Octet .\n  op x3D : -> Octet .\n  op x3F : -> Octet .\n  op x40 : -> Octet .\n  op x46 : -> Octet .\n  op x48 : -> Octet .\n  op x49 : -> Octet .\n  op x4A : -> Octet .\n  op x4B : -> Octet .\n  op x4C : -> Octet .\n  op x4D : -> Octet .\n  op x4E : -> Octet .\n  op x4F : -> Octet .\n  op x50 : -> Octet .\n  op x51 : -> Octet .\n  op x53 : -> Octet .\n  op x54 : -> Octet .\n  op x55 : -> Octet .\n  op x58 : -> Octet .\n  op x5A : -> Octet .\n  op x5B : -> Octet .\n  op x5C : -> Octet .\n  op x5D : -> Octet .\n  op x5E : -> Octet .\n  op x5F : -> Octet .\n  op x60 : -> Octet .\n  op x61 : -> Octet .\n  op x62 : -> Octet .\n  op x63 : -> Octet .\n  op x64 : -> Octet .\n  op x65 : -> Octet .\n  op x66 : -> Octet .\n  op x67 : -> Octet .\n  op x69 : -> Octet .\n  op x6A : -> Octet .\n  op x6B : -> Octet .\n  op x6C : -> Octet .\n  op x6D : -> Octet .\n  op x6E : -> Octet .\n  op x6F : -> Octet .\n  op x70 : -> Octet .\n  op x71 : -> Octet .\n  op x72 : -> Octet .\n  op x73 : -> Octet .\n  op x74 : -> Octet .\n  op x75 : -> Octet .\n  op x76 : -> Octet .\n  op x77 : -> Octet .\n  op x78 : -> Octet .\n  op x79 : -> Octet .\n  op x7A : -> Octet .\n  op x7B : -> Octet .\n  op x7C : -> Octet .\n  op x7D : -> Octet .\n  op x7E : -> Octet .\n  op x7F : -> Octet .\n  op x80 : -> Octet .\n  op x81 : -> Octet .\n  op x83 : -> Octet .\n  op x84 : -> Octet .\n  op x85 : -> Octet .\n  op x86 : -> Octet .\n  op x88 : -> Octet .\n  op x89 : -> Octet .\n  op x8A : -> Octet .\n  op x8C : -> Octet .\n  op x8D : -> Octet .\n  op x8E : -> Octet .\n  op x8F : -> Octet .\n  op x90 : -> Octet .\n  op x91 : -> Octet .\n  op x92 : -> Octet .\n  op x93 : -> Octet .\n  op x95 : -> Octet .\n  op x96 : -> Octet .\n  op x97 : -> Octet .\n  op x98 : -> Octet .\n  op x99 : -> Octet .\n  op x9A : -> Octet .\n  op x9B : -> Octet .\n  op x9C : -> Octet .\n  op x9D : -> Octet .\n  op x9E : -> Octet .\n  op x9F : -> Octet .\n  op xA0 : -> Octet .\n  op xA1 : -> Octet .\n  op xA2 : -> Octet .\n  op xA3 : -> Octet .\n  op xA4 : -> Octet .\n  op xA5 : -> Octet .\n  op xA6 : -> Octet .\n  op xA7 : -> Octet .\n  op xA8 : -> Octet .\n  op xA9 : -> Octet .\n  op xAA : -> Octet .\n  op xAB : -> Octet .\n  op xAC : -> Octet .\n  op xAE : -> Octet .\n  op xAF : -> Octet .\n  op xB0 : -> Octet .\n  op xB1 : -> Octet .\n  op xB2 : -> Octet .\n  op xB3 : -> Octet .\n  op xB5 : -> Octet .\n  op xB6 : -> Octet .\n  op xB8 : -> Octet .\n  op xB9 : -> Octet .\n  op xBA : -> Octet .\n  op xBB : -> Octet .\n  op xBC : -> Octet .\n  op xBE : -> Octet .\n  op xBF : -> Octet .\n  op xC0 : -> Octet .\n  op xC1 : -> Octet .\n  op xC2 : -> Octet .\n  op xC4 : -> Octet .\n  op xC5 : -> Octet .\n  op xC6 : -> Octet .\n  op xC7 : -> Octet .\n  op xC8 : -> Octet .\n  op xC9 : -> Octet .\n  op xCA : -> Octet .\n  op xCB : -> Octet .\n  op xCC : -> Octet .\n  op xCD : -> Octet .\n  op xCE : -> Octet .\n  op xD0 : -> Octet .\n  op xD1 : -> Octet .\n  op xD2 : -> Octet .\n  op xD3 : -> Octet .\n  op xD4 : -> Octet .\n  op xD5 : -> Octet .\n  op xD6 : -> Octet .\n  op xD7 : -> Octet .\n  op xD8 : -> Octet .\n  op xD9 : -> Octet .\n  op xDB : -> Octet .\n  op xDC : -> Octet .\n  op xDD : -> Octet .\n  op xDE : -> Octet .\n  op xDF : -> Octet .\n  op xE0 : -> Octet .\n  op xE1 : -> Octet .\n  op xE3 : -> Octet .\n  op xE6 : -> Octet .\n  op xE8 : -> Octet .\n  op xE9 : -> Octet .\n  op xEA : -> Octet .\n  op xEB : -> Octet .\n  op xEC : -> Octet .\n  op xED : -> Octet .\n  op xEE : -> Octet .\n  op xEF : -> Octet .\n  op xF0 : -> Octet .\n  op xF1 : -> Octet .\n  op xF2 : -> Octet .\n  op xF3 : -> Octet .\n  op xF4 : -> Octet .\n  op xF5 : -> Octet .\n  op xF6 : -> Octet .\n  op xF7 : -> Octet .\n  op xF8 : -> Octet .\n  op xF9 : -> Octet .\n  op xFA : -> Octet .\n  op xFB : -> Octet .\n  op xFC : -> Octet .\n  op xFD : -> Octet .\n  op xFE : -> Octet .\n  op xFF : -> Octet .\n  op andBlock : Block Block -> Block .\n  op orBlock : Block Block -> Block .\n  op xorBlock : Block Block -> Block .\n  op x0001 : -> Half .\n  op x00000000 : -> Block .\n  op x00000001 : -> Block .\n  op x00000002 : -> Block .\n  op x00000003 : -> Block .\n  op x00000004 : -> Block .\n  op x00000005 : -> Block .\n  op x00000006 : -> Block .\n  op x00000007 : -> Block .\n  op x00000008 : -> Block .\n  op x00000009 : -> Block .\n  op x0000000A : -> Block .\n  op x0000000B : -> Block .\n  op x0000000C : -> Block .\n  op x0000000D : -> Block .\n  op x0000000E : -> Block .\n  op x0000000F : -> Block .\n  op x00000010 : -> Block .\n  op x00000012 : -> Block .\n  op x00000014 : -> Block .\n  op x00000016 : -> Block .\n  op x00000018 : -> Block .\n  op x0000001B : -> Block .\n  op x0000001D : -> Block .\n  op x0000001E : -> Block .\n  op x0000001F : -> Block .\n  op x00000031 : -> Block .\n  op x00000036 : -> Block .\n  op x00000060 : -> Block .\n  op x00000080 : -> Block .\n  op x000000A5 : -> Block .\n  op x000000B6 : -> Block .\n  op x000000C4 : -> Block .\n  op x000000D2 : -> Block .\n  op x00000100 : -> Block .\n  op x00000129 : -> Block .\n  op x0000018C : -> Block .\n  op x00004000 : -> Block .\n  op x00010000 : -> Block .\n  op x00020000 : -> Block .\n  op x00030000 : -> Block .\n  op x00040000 : -> Block .\n  op x00060000 : -> Block .\n  op x00804021 : -> Block .\n  op x00FF00FF : -> Block .\n  op x0103050B : -> Block .\n  op x01030703 : -> Block .\n  op x01030705 : -> Block .\n  op x0103070F : -> Block .\n  op x02040801 : -> Block .\n  op x0297AF6F : -> Block .\n  op x07050301 : -> Block .\n  op x077788A2 : -> Block .\n  op x07C72EAA : -> Block .\n  op x0A202020 : -> Block .\n  op x0AD67E20 : -> Block .\n  op x10000000 : -> Block .\n  op x11A9D254 : -> Block .\n  op x11AC46B8 : -> Block .\n  op x1277A6D4 : -> Block .\n  op x13647149 : -> Block .\n  op x160EE9B5 : -> Block .\n  op x17065DBB : -> Block .\n  op x17A808FD : -> Block .\n  op x1D10D8D3 : -> Block .\n  op x1D3B7760 : -> Block .\n  op x1D9C9655 : -> Block .\n  op x1F3F7FFF : -> Block .\n  op x204E80A7 : -> Block .\n  op x21D869BA : -> Block .\n  op x24B66FB5 : -> Block .\n  op x270EEDAF : -> Block .\n  op x277B4B25 : -> Block .\n  op x2829040B : -> Block .\n  op x288FC786 : -> Block .\n  op x28EAD8B3 : -> Block .\n  op x29907CD8 : -> Block .\n  op x29C1485F : -> Block .\n  op x29EEE96B : -> Block .\n  op x2A6091AE : -> Block .\n  op x2BF8499A : -> Block .\n  op x2E80AC30 : -> Block .\n  op x2FD76FFB : -> Block .\n  op x30261492 : -> Block .\n  op x303FF4AA : -> Block .\n  op x33D5A466 : -> Block .\n  op x344925FC : -> Block .\n  op x34ACF886 : -> Block .\n  op x3CD54DEB : -> Block .\n  op x3CF3A7D2 : -> Block .\n  op x3DD81AC6 : -> Block .\n  op x3F6F7248 : -> Block .\n  op x48B204D6 : -> Block .\n  op x4A645A01 : -> Block .\n  op x4C49AAE0 : -> Block .\n  op x4CE933E1 : -> Block .\n  op x4D53901A : -> Block .\n  op x4DA124A1 : -> Block .\n  op x4F998E01 : -> Block .\n  op x4FB1138A : -> Block .\n  op x50DEC930 : -> Block .\n  op x51AF3C1D : -> Block .\n  op x51EDE9C7 : -> Block .\n  op x550D91CE : -> Block .\n  op x55555555 : -> Block .\n  op x55DD063F : -> Block .\n  op x5834A585 : -> Block .\n  op x5A35D667 : -> Block .\n  op x5BC02502 : -> Block .\n  op x5CCA3239 : -> Block .\n  op x5EBA06C2 : -> Block .\n  op x5F38EEF1 : -> Block .\n  op x613F8E2A : -> Block .\n  op x63C70DBA : -> Block .\n  op x6AD6E8A4 : -> Block .\n  op x6AEBACF8 : -> Block .\n  op x6D67E884 : -> Block .\n  op x7050EC5E : -> Block .\n  op x717153D5 : -> Block .\n  op x7201F4DC : -> Block .\n  op x7397C9AE : -> Block .\n  op x74B39176 : -> Block .\n  op x76232E5F : -> Block .\n  op x7783C51D : -> Block .\n  op x7792F9D4 : -> Block .\n  op x7BC180AB : -> Block .\n  op x7DB2D9F4 : -> Block .\n  op x7DFEFBFF : -> Block .\n  op x7F76A3B0 : -> Block .\n  op x7F839576 : -> Block .\n  op x7FFFFFF0 : -> Block .\n  op x7FFFFFF1 : -> Block .\n  op x7FFFFFFC : -> Block .\n  op x7FFFFFFD : -> Block .\n  op x80000000 : -> Block .\n  op x80000002 : -> Block .\n  op x800000C2 : -> Block .\n  op x80018000 : -> Block .\n  op x80018001 : -> Block .\n  op x80397302 : -> Block .\n  op x81D10CA3 : -> Block .\n  op x89D635D7 : -> Block .\n  op x8CE37709 : -> Block .\n  op x8DC8BBDE : -> Block .\n  op x9115A558 : -> Block .\n  op x91896CFA : -> Block .\n  op x9372CDC6 : -> Block .\n  op x98D1CC75 : -> Block .\n  op x9D15C437 : -> Block .\n  op x9DB15CF6 : -> Block .\n  op x9E2E7B36 : -> Block .\n  op xA018C83B : -> Block .\n  op xA0B87B77 : -> Block .\n  op xA44AAAC0 : -> Block .\n  op xA511987A : -> Block .\n  op xA70FC148 : -> Block .\n  op xA93BD410 : -> Block .\n  op xAAAAAAAA : -> Block .\n  op xAB00FFCD : -> Block .\n  op xAB01FCCD : -> Block .\n  op xAB6EED4A : -> Block .\n  op xABEEED6B : -> Block .\n  op xACBC13DD : -> Block .\n  op xB1CC1CC5 : -> Block .\n  op xB8142629 : -> Block .\n  op xB99A62DE : -> Block .\n  op xBA92DB12 : -> Block .\n  op xBBA57835 : -> Block .\n  op xBE9F0917 : -> Block .\n  op xBF2D7D85 : -> Block .\n  op xBFEF7FDF : -> Block .\n  op xC1ED90DD : -> Block .\n  op xC21A1846 : -> Block .\n  op xC4EB1AEB : -> Block .\n  op xC6B1317E : -> Block .\n  op xCBC865BA : -> Block .\n  op xCD959B46 : -> Block .\n  op xD0482465 : -> Block .\n  op xD636250D : -> Block .\n  op xD7843FDC : -> Block .\n  op xD78634BC : -> Block .\n  op xD8804CA5 : -> Block .\n  op xDB79FBDC : -> Block .\n  op xDB9102B0 : -> Block .\n  op xE0C08000 : -> Block .\n  op xE6A12F07 : -> Block .\n  op xEB35B97F : -> Block .\n  op xF0239DD5 : -> Block .\n  op xF14D6E28 : -> Block .\n  op xF2EF3501 : -> Block .\n  op xF6A09667 : -> Block .\n  op xFD297DA4 : -> Block .\n  op xFDC1A8BA : -> Block .\n  op xFE4E5BDD : -> Block .\n  op xFEA1D334 : -> Block .\n  op xFECCAA6E : -> Block .\n  op xFEFC07F0 : -> Block .\n  op xFF2D7DA5 : -> Block .\n  op xFFEF0001 : -> Block .\n  op xFFFF00FF : -> Block .\n  op xFFFFFF2D : -> Block .\n  op xFFFFFF3A : -> Block .\n  op xFFFFFFF0 : -> Block .\n  op xFFFFFFF1 : -> Block .\n  op xFFFFFFF4 : -> Block .\n  op xFFFFFFF5 : -> Block .\n  op xFFFFFFF7 : -> Block .\n  op xFFFFFFF9 : -> Block .\n  op xFFFFFFFA : -> Block .\n  op xFFFFFFFB : -> Block .\n  op xFFFFFFFC : -> Block .\n  op xFFFFFFFD : -> Block .\n  op xFFFFFFFE : -> Block .\n  op xFFFFFFFF : -> Block .\n  op appendMessage : Message Block -> Message .\n  op reverseMessage : Message -> Message .\n  op makeMessage : Nat Block Block -> Message .\n  op splitSegment : Message -> SegmentedMessage .\n  op cutSegment : Message Message Nat -> SegmentedMessage .\n  op ADD : Block Block -> Block .\n  op AND : Block Block -> Block .\n  op MUL : Block Block -> Pair .\n  op OR : Block Block -> Block .\n  op XOR : Block Block -> Block .\n  op XOR-prime : Pair -> Block .\n  op CYC : Block -> Block .\n  op nCYC : Nat Block -> Block .\n  op FIX1 : Block -> Block .\n  op FIX2 : Block -> Block .\n  op needAdjust : Octet -> Xbool .\n  op adjustCode : Octet -> Bit .\n  op adjust : Octet Octet -> Octet .\n  op PAT : Block Block -> Octet .\n  op BYT : Block Block -> Pair .\n  op BYT-prime : Octet Octet Octet Octet Octet Octet Octet Octet Octet -> Pair .\n  op ADDC : Block Block -> Pair .\n  op ADDC-prime : BlockSum -> Pair .\n  op MUL1 : Block Block -> Block .\n  op MUL1XY : Pair -> Block .\n  op MUL1UL : Block Block -> Block .\n  op MUL1SC : Pair -> Block .\n  op MUL2 : Block Block -> Block .\n  op MUL2XY : Pair -> Block .\n  op MUL2UL : Block Block -> Block .\n  op MUL2DEL : Pair Block -> Block .\n  op MUL2FL : Block Block -> Block .\n  op MUL2SC : Pair -> Block .\n  op MUL2A : Block Block -> Block .\n  op MUL2AXY : Pair -> Block .\n  op MUL2AUL : Block Block -> Block .\n  op MUL2ADL : Block Block -> Block .\n  op MUL2ASC : Pair -> Block .\n  op squareHalf : Half -> Block .\n  op Q : Octet -> Block .\n  op H4 : Block -> Block .\n  op H6 : Block -> Block .\n  op H8 : Block -> Block .\n  op H0 : Block -> Block .\n  op H5 : Block Octet -> Block .\n  op H7 : Block -> Block .\n  op H9 : Block -> Block .\n  op J1-2 : Block -> Block .\n  op J1-4 : Block -> Block .\n  op J1-6 : Block -> Block .\n  op J1-8 : Block -> Block .\n  op J2-2 : Block -> Block .\n  op J2-4 : Block -> Block .\n  op J2-6 : Block -> Block .\n  op J2-8 : Block -> Block .\n  op K1-2 : Block -> Block .\n  op K1-4 : Block -> Block .\n  op K1-5 : Block -> Block .\n  op K1-7 : Block -> Block .\n  op K1-9 : Block -> Block .\n  op K2-2 : Block -> Block .\n  op K2-4 : Block -> Block .\n  op K2-5 : Block -> Block .\n  op K2-7 : Block -> Block .\n  op K2-9 : Block -> Block .\n  op preludeXY : Block Block -> Pair .\n  op preludeVW : Block Block -> Pair .\n  op preludeST : Block Block -> Pair .\n  op preludeXY-prime : Pair Octet -> Pair .\n  op preludeVW-prime : Pair -> Pair .\n  op preludeST-prime : Pair -> Pair .\n  op computeXY : Pair Pair Block -> Pair .\n  op computeXY-prime : Pair Block Block -> Pair .\n  op computeVW : Pair -> Pair .\n  op loop1 : Pair Pair Message -> Pair .\n  op loop2 : Pair Pair Message -> Pair .\n  op coda : Pair Pair Pair -> Block .\n  op MAA : Key Message -> Block .\n  op MAA-prime : Pair Pair Pair Message -> Block .\n  op MAC : Key Message -> Block .\n  op MACfirst : Key SegmentedMessage -> Block .\n  op MACnext : Key Block SegmentedMessage -> Block .\n  eq [001]: notBool (Xfalse) = Xtrue .\n  eq [002]: notBool (Xtrue) = Xfalse .\n  eq [003]: andBool (Xfalse, L:Xbool) = Xfalse .\n  eq [004]: andBool (Xtrue, L:Xbool) = L:Xbool .\n  eq [005]: orBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [006]: orBool (Xtrue, L:Xbool) = Xtrue .\n  eq [007]: xorBool (Xfalse, L:Xbool) = L:Xbool .\n  eq [008]: xorBool (Xtrue, L:Xbool) = notBool (L:Xbool) .\n  eq [009]: notBit (x0) = x1 .\n  eq [010]: notBit (x1) = x0 .\n  eq [011]: andBit (B:Bit, x0) = x0 .\n  eq [012]: andBit (B:Bit, x1) = B:Bit .\n  eq [013]: orBit (B:Bit, x0) = B:Bit .\n  eq [014]: orBit (B:Bit, x1) = x1 .\n  eq [015]: xorBit (B:Bit, x0) = B:Bit .\n  eq [016]: xorBit (B:Bit, x1) = notBit (B:Bit) .\n  eq [017]: x00 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x0) .\n  eq [018]: x01 = buildOctet (x0, x0, x0, x0, x0, x0, x0, x1) .\n  eq [019]: x0000 = buildHalf (x00, x00) .\n  eq [020]: HalfU (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [021]: HalfL (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet)) = buildHalf (O3:Octet, O4:Octet) .\n  eq [022]: eqBit (x0, x0) = Xtrue .\n  eq [023]: eqBit (x0, x1) = Xfalse .\n  eq [024]: eqBit (x1, x0) = Xfalse .\n  eq [025]: eqBit (x1, x1) = Xtrue .\n  eq [026]: eqOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = andBool (eqBit (B1:Bit, B-prime1:Bit), andBool (eqBit (B2:Bit, B-prime2:Bit), andBool (eqBit (B3:Bit, B-prime3:Bit), andBool (eqBit (B4:Bit, B-prime4:Bit), andBool (eqBit (B5:Bit, B-prime5:Bit), andBool (eqBit (B6:Bit, B-prime6:Bit), andBool (eqBit (B7:Bit, B-prime7:Bit), eqBit (B8:Bit, B-prime8:Bit)))))))) .\n  eq [027]: eqOctetSum (buildOctetSum (B:Bit, O:Octet), buildOctetSum (B-prime:Bit, O-prime:Octet)) = andBool (eqBit (B:Bit, B-prime:Bit), eqOctet (O:Octet, O-prime:Octet)) .\n  eq [028]: eqHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)) .\n  eq [029]: eqHalfSum (buildHalfSum (B:Bit, H:Half), buildHalfSum (B-prime:Bit, H-prime:Half)) = andBool (eqBit (B:Bit, B-prime:Bit), eqHalf (H:Half, H-prime:Half)) .\n  eq [030]: eqBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = andBool (andBool (eqOctet (O1:Octet, O-prime1:Octet), eqOctet (O2:Octet, O-prime2:Octet)), andBool (eqOctet (O3:Octet, O-prime3:Octet), eqOctet (O4:Octet, O-prime4:Octet))) .\n  eq [031]: eqBlockSum (buildBlockSum (B:Bit, W:Block), buildBlockSum (B-prime:Bit, W-prime:Block)) = andBool (eqBit (B:Bit, B-prime:Bit), eqBlock (W:Block, W-prime:Block)) .\n  eq [032]: eqPair (buildPair (W1:Block, W2:Block), buildPair (W-prime1:Block, W-prime2:Block)) = andBool (eqBlock (W1:Block, W-prime1:Block), eqBlock (W2:Block, W-prime2:Block)) .\n  eq [033]: addBit (B:Bit, B-prime:Bit, Bcarry:Bit) = xorBit (xorBit (B:Bit, B-prime:Bit), Bcarry:Bit) .\n  eq [034]: carBit (B:Bit, B-prime:Bit, Bcarry:Bit) = orBit (andBit (andBit (B:Bit, B-prime:Bit), notBit (Bcarry:Bit)), andBit (orBit (B:Bit, B-prime:Bit), Bcarry:Bit)) .\n  eq [035]: addOctetSum (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit), Bcarry:Bit) = addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) .\n  eq [036]: addOctet8 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, B8:Bit, B-prime8:Bit, Bcarry:Bit) = addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, carBit (B8:Bit, B-prime8:Bit, Bcarry:Bit), addBit (B8:Bit, B-prime8:Bit, Bcarry:Bit)) .\n  eq [037]: addOctet7 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, B7:Bit, B-prime7:Bit, Bcarry:Bit, B-second8:Bit) = addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, carBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), addBit (B7:Bit, B-prime7:Bit, Bcarry:Bit), B-second8:Bit) .\n  eq [038]: addOctet6 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, B6:Bit, B-prime6:Bit, Bcarry:Bit, B-second7:Bit, B-second8:Bit) = addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, carBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), addBit (B6:Bit, B-prime6:Bit, Bcarry:Bit), B-second7:Bit, B-second8:Bit) .\n  eq [039]: addOctet5 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, B5:Bit, B-prime5:Bit, Bcarry:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, carBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), addBit (B5:Bit, B-prime5:Bit, Bcarry:Bit), B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [040]: addOctet4 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, B4:Bit, B-prime4:Bit, Bcarry:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, carBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), addBit (B4:Bit, B-prime4:Bit, Bcarry:Bit), B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [041]: addOctet3 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, B3:Bit, B-prime3:Bit, Bcarry:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, carBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), addBit (B3:Bit, B-prime3:Bit, Bcarry:Bit), B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [042]: addOctet2 (B1:Bit, B-prime1:Bit, B2:Bit, B-prime2:Bit, Bcarry:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet1 (B1:Bit, B-prime1:Bit, carBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), addBit (B2:Bit, B-prime2:Bit, Bcarry:Bit), B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [043]: addOctet1 (B1:Bit, B-prime1:Bit, Bcarry:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = addOctet0 (carBit (B1:Bit, B-prime1:Bit, Bcarry:Bit), addBit (B1:Bit, B-prime1:Bit, Bcarry:Bit), B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) .\n  eq [044]: addOctet0 (Bcarry:Bit, B-second1:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit) = buildOctetSum (Bcarry:Bit, buildOctet (B-second1:Bit, B-second2:Bit, B-second3:Bit, B-second4:Bit, B-second5:Bit, B-second6:Bit, B-second7:Bit, B-second8:Bit)) .\n  eq [045]: dropCarryOctetSum (buildOctetSum (Bcarry:Bit, O:Octet)) = O:Octet .\n  eq [046]: addOctet (O:Octet, O-prime:Octet) = dropCarryOctetSum (addOctetSum (O:Octet, O-prime:Octet, x0)) .\n  eq [047]: addHalfSum (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = addHalf2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet) .\n  eq [048]: addHalf2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet) = addHalf1 (O1:Octet, O-prime1:Octet, addOctetSum (O2:Octet, O-prime2:Octet, x0)) .\n  eq [049]: addHalf1 (O1:Octet, O-prime1:Octet, buildOctetSum (B:Bit, O-second2:Octet)) = addHalf0 (addOctetSum (O1:Octet, O-prime1:Octet, B:Bit), O-second2:Octet) .\n  eq [050]: addHalf0 (buildOctetSum (B:Bit, O-second1:Octet), O-second2:Octet) = buildHalfSum (B:Bit, buildHalf (O-second1:Octet, O-second2:Octet)) .\n  eq [051]: dropCarryHalfSum (buildHalfSum (B:Bit, H:Half)) = H:Half .\n  eq [052]: addHalf (H:Half, H-prime:Half) = dropCarryHalfSum (addHalfSum (H:Half, H-prime:Half)) .\n  eq [053]: addHalfOctet (O:Octet, H:Half) = addHalf (buildHalf (x00, O:Octet), H:Half) .\n  eq [054]: addHalfOctets (O:Octet, O-prime:Octet) = addHalf (buildHalf (x00, O:Octet), buildHalf (x00, O-prime:Octet)) .\n  eq [055]: addBlockSum (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = addBlock4 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, O4:Octet, O-prime4:Octet) .\n  eq [056]: addBlock4 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, O4:Octet, O-prime4:Octet) = addBlock3 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, addOctetSum (O4:Octet, O-prime4:Octet, x0)) .\n  eq [057]: addBlock3 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, O3:Octet, O-prime3:Octet, buildOctetSum (Bcarry:Bit, O-second4:Octet)) = addBlock2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, addOctetSum (O3:Octet, O-prime3:Octet, Bcarry:Bit), O-second4:Octet) .\n  eq [058]: addBlock2 (O1:Octet, O-prime1:Octet, O2:Octet, O-prime2:Octet, buildOctetSum (Bcarry:Bit, O-second3:Octet), O-second4:Octet) = addBlock1 (O1:Octet, O-prime1:Octet, addOctetSum (O2:Octet, O-prime2:Octet, Bcarry:Bit), O-second3:Octet, O-second4:Octet) .\n  eq [059]: addBlock1 (O1:Octet, O-prime1:Octet, buildOctetSum (Bcarry:Bit, O-second2:Octet), O-second3:Octet, O-second4:Octet) = addBlock0 (addOctetSum (O1:Octet, O-prime1:Octet, Bcarry:Bit), O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [060]: addBlock0 (buildOctetSum (Bcarry:Bit, O-second1:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) = buildBlockSum (Bcarry:Bit, buildBlock (O-second1:Octet, O-second2:Octet, O-second3:Octet, O-second4:Octet)) .\n  eq [061]: dropCarryBlockSum (buildBlockSum (Bcarry:Bit, W:Block)) = W:Block .\n  eq [062]: addBlock (W:Block, W-prime:Block) = dropCarryBlockSum (addBlockSum (W:Block, W-prime:Block)) .\n  eq [063]: addBlockHalf (buildHalf (O1:Octet, O2:Octet), W:Block) = addBlock (buildBlock (x00, x00, O1:Octet, O2:Octet), W:Block) .\n  eq [064]: addBlockHalves (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = addBlock (buildBlock (x00, x00, O1:Octet, O2:Octet), buildBlock (x00, x00, O-prime1:Octet, O-prime2:Octet)) .\n  eq [065]: leftOctet1 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0) .\n  eq [066]: leftOctet2 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0) .\n  eq [067]: leftOctet3 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0, x0) .\n  eq [068]: leftOctet4 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B5:Bit, B6:Bit, B7:Bit, B8:Bit, x0, x0, x0, x0) .\n  eq [069]: leftOctet5 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B6:Bit, B7:Bit, B8:Bit, x0, x0, x0, x0, x0) .\n  eq [070]: leftOctet6 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B7:Bit, B8:Bit, x0, x0, x0, x0, x0, x0) .\n  eq [071]: leftOctet7 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (B8:Bit, x0, x0, x0, x0, x0, x0, x0) .\n  eq [072]: rightOctet1 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit) .\n  eq [073]: rightOctet2 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit) .\n  eq [074]: rightOctet3 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit) .\n  eq [075]: rightOctet4 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, B1:Bit, B2:Bit, B3:Bit, B4:Bit) .\n  eq [076]: rightOctet5 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, B1:Bit, B2:Bit, B3:Bit) .\n  eq [077]: rightOctet6 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, x0, B1:Bit, B2:Bit) .\n  eq [078]: rightOctet7 (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit)) = buildOctet (x0, x0, x0, x0, x0, x0, x0, B1:Bit) .\n  eq [079]: mulOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), O-prime:Octet) = mulOctet1 (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, x0000) .\n  eq [080]: mulOctet1 (x0, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet2 (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [081]: mulOctet1 (x1, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet2 (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet1 (O-prime:Octet), leftOctet7 (O-prime:Octet))) .\n  eq [082]: mulOctet2 (x0, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet3 (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [083]: mulOctet2 (x1, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet3 (B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet2 (O-prime:Octet), leftOctet6 (O-prime:Octet))) .\n  eq [084]: mulOctet3 (x0, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet4 (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [085]: mulOctet3 (x1, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet4 (B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet3 (O-prime:Octet), leftOctet5 (O-prime:Octet))) .\n  eq [086]: mulOctet4 (x0, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet5 (B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [087]: mulOctet4 (x1, B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet5 (B5:Bit, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet4 (O-prime:Octet), leftOctet4 (O-prime:Octet))) .\n  eq [088]: mulOctet5 (x0, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet6 (B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [089]: mulOctet5 (x1, B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet6 (B6:Bit, B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet5 (O-prime:Octet), leftOctet3 (O-prime:Octet))) .\n  eq [090]: mulOctet6 (x0, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet7 (B7:Bit, B8:Bit, O-prime:Octet, H:Half) .\n  eq [091]: mulOctet6 (x1, B7:Bit, B8:Bit, O-prime:Octet, H:Half) = mulOctet7 (B7:Bit, B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet6 (O-prime:Octet), leftOctet2 (O-prime:Octet))) .\n  eq [092]: mulOctet7 (x0, B8:Bit, O-prime:Octet, H:Half) = mulOctet8 (B8:Bit, O-prime:Octet, H:Half) .\n  eq [093]: mulOctet7 (x1, B8:Bit, O-prime:Octet, H:Half) = mulOctet8 (B8:Bit, O-prime:Octet, mulOctetA (H:Half, rightOctet7 (O-prime:Octet), leftOctet1 (O-prime:Octet))) .\n  eq [094]: mulOctet8 (x0, O-prime:Octet, H:Half) = H:Half .\n  eq [095]: mulOctet8 (x1, O-prime:Octet, H:Half) = mulOctetA (H:Half, x00, O-prime:Octet) .\n  eq [096]: mulOctetA (buildHalf (O1:Octet, O2:Octet), O-prime1:Octet, O-prime2:Octet) = mulOctetB (addOctet (O1:Octet, O-prime1:Octet), addOctetSum (O2:Octet, O-prime2:Octet, x0)) .\n  eq [097]: mulOctetB (O1:Octet, buildOctetSum (x0, O2:Octet)) = buildHalf (O1:Octet, O2:Octet) .\n  eq [098]: mulOctetB (O1:Octet, buildOctetSum (x1, O2:Octet)) = buildHalf (addOctet (O1:Octet, x01), O2:Octet) .\n  eq [099]: mulHalf (buildHalf (O1:Octet, O2:Octet), buildHalf (O-prime1:Octet, O-prime2:Octet)) = mulHalfA (mulOctet (O1:Octet, O-prime1:Octet), mulOctet (O1:Octet, O-prime2:Octet), mulOctet (O2:Octet, O-prime1:Octet), mulOctet (O2:Octet, O-prime2:Octet)) .\n  eq [100]: mulHalfA (buildHalf (O11U:Octet, O11L:Octet), buildHalf (O12U:Octet, O12L:Octet), buildHalf (O21U:Octet, O21L:Octet), buildHalf (O22U:Octet, O22L:Octet)) = mulHalf4 (O11U:Octet, O11L:Octet, O12U:Octet, O12L:Octet, O21U:Octet, O21L:Octet, O22U:Octet, O22L:Octet) .\n  eq [101]: mulHalf4 (O11U:Octet, O11L:Octet, O12U:Octet, O12L:Octet, O21U:Octet, O21L:Octet, O22U:Octet, O-second4:Octet) = mulHalf3 (O11U:Octet, O11L:Octet, O12U:Octet, O21U:Octet, addHalfOctet (O12L:Octet, addHalfOctets (O21L:Octet, O22U:Octet)), O-second4:Octet) .\n  eq [102]: mulHalf3 (O11U:Octet, O11L:Octet, O12U:Octet, O21U:Octet, buildHalf (Ocarry:Octet, O-second3:Octet), O-second4:Octet) = mulHalf2 (O11U:Octet, addHalfOctet (Ocarry:Octet, addHalfOctet (O11L:Octet, addHalfOctets (O12U:Octet, O21U:Octet))), O-second3:Octet, O-second4:Octet) .\n  eq [103]: mulHalf2 (O11U:Octet, buildHalf (Ocarry:Octet, O-second2:Octet), O-second3:Octet, O-second4:Octet) = mulHalf1 (addHalfOctets (Ocarry:Octet, O11U:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [104]: mulHalf1 (buildHalf (Ocarry:Octet, O-second1:Octet), O-second2:Octet, O-second3:Octet, O-second4:Octet) = buildBlock (O-second1:Octet, O-second2:Octet, O-second3:Octet, O-second4:Octet) .\n  eq [105]: mulBlock (W1:Block, W2:Block) = mulBlockA (mulHalf (HalfU (W1:Block), HalfU (W2:Block)), mulHalf (HalfU (W1:Block), HalfL (W2:Block)), mulHalf (HalfL (W1:Block), HalfU (W2:Block)), mulHalf (HalfL (W1:Block), HalfL (W2:Block))) .\n  eq [106]: mulBlockA (W11:Block, W12:Block, W21:Block, W22:Block) = mulBlock4 (HalfU (W11:Block), HalfL (W11:Block), HalfU (W12:Block), HalfL (W12:Block), HalfU (W21:Block), HalfL (W21:Block), HalfU (W22:Block), HalfL (W22:Block)) .\n  eq [107]: mulBlock4 (H11U:Half, H11L:Half, H12U:Half, H12L:Half, H21U:Half, H21L:Half, H22U:Half, H-second4:Half) = mulBlock3 (H11U:Half, H11L:Half, H12U:Half, H21U:Half, addBlockHalf (H12L:Half, addBlockHalves (H21L:Half, H22U:Half)), H-second4:Half) .\n  eq [108]: mulBlock3 (H11U:Half, H11L:Half, H12U:Half, H21U:Half, W:Block, H-second4:Half) = mulBlock2 (H11U:Half, addBlockHalf (HalfU (W:Block), addBlockHalf (H11L:Half, addBlockHalves (H12U:Half, H21U:Half))), HalfL (W:Block), H-second4:Half) .\n  eq [109]: mulBlock2 (H11U:Half, W:Block, H-second3:Half, H-second4:Half) = mulBlock1 (addBlockHalves (HalfU (W:Block), H11U:Half), HalfL (W:Block), H-second3:Half, H-second4:Half) .\n  eq [110]: mulBlock1 (W:Block, H-second2:Half, H-second3:Half, H-second4:Half) = mulBlockB (HalfL (W:Block), H-second2:Half, H-second3:Half, H-second4:Half) .\n  eq [111]: mulBlockB (buildHalf (O1U:Octet, O1L:Octet), buildHalf (O2U:Octet, O2L:Octet), buildHalf (O3U:Octet, O3L:Octet), buildHalf (O4U:Octet, O4L:Octet)) = buildPair (buildBlock (O1U:Octet, O1L:Octet, O2U:Octet, O2L:Octet), buildBlock (O3U:Octet, O3L:Octet, O4U:Octet, O4L:Octet)) .\n  eq [112]: addNat (N:Nat, zero) = N:Nat .\n  eq [113]: addNat (N:Nat, succ (N-prime:Nat)) = addNat (succ (N:Nat), N-prime:Nat) .\n  eq [114]: multNat (N:Nat, zero) = zero .\n  eq [115]: multNat (N:Nat, succ (N-prime:Nat)) = addNat (N:Nat, multNat (N:Nat, N-prime:Nat)) .\n  eq [116]: eqNat (zero, zero) = Xtrue .\n  eq [117]: eqNat (zero, succ (N-prime:Nat)) = Xfalse .\n  eq [118]: eqNat (succ (N:Nat), zero) = Xfalse .\n  eq [119]: eqNat (succ (N:Nat), succ (N-prime:Nat)) = eqNat (N:Nat, N-prime:Nat) .\n  eq [120]: ltNat (zero, zero) = Xfalse .\n  eq [121]: ltNat (zero, succ (N-prime:Nat)) = Xtrue .\n  eq [122]: ltNat (succ (N-prime:Nat), zero) = Xfalse .\n  eq [123]: ltNat (succ (N:Nat), succ (N-prime:Nat)) = ltNat (N:Nat, N-prime:Nat) .\n  eq [124]: n1 = succ (zero) .\n  eq [125]: n2 = succ (n1) .\n  eq [126]: n3 = succ (n2) .\n  eq [127]: n4 = succ (n3) .\n  eq [128]: n5 = succ (n4) .\n  eq [129]: n6 = succ (n5) .\n  eq [130]: n7 = succ (n6) .\n  eq [131]: n8 = succ (n7) .\n  eq [132]: n9 = succ (n8) .\n  eq [133]: n10 = succ (n9) .\n  eq [134]: n11 = succ (n10) .\n  eq [135]: n12 = succ (n11) .\n  eq [136]: n13 = succ (n12) .\n  eq [137]: n14 = succ (n13) .\n  eq [138]: n15 = succ (n14) .\n  eq [139]: n16 = succ (n15) .\n  eq [140]: n17 = succ (n16) .\n  eq [141]: n18 = succ (n17) .\n  eq [142]: n19 = succ (n18) .\n  eq [143]: n20 = succ (n19) .\n  eq [144]: n21 = succ (n20) .\n  eq [145]: n22 = succ (n21) .\n  eq [146]: n254 = addNat (n12, multNat (n11, n22)) .\n  eq [147]: n256 = multNat (n16, n16) .\n  eq [148]: n4100 = addNat (n4, multNat (n16, n256)) .\n  eq [149]: andOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (andBit (B1:Bit, B-prime1:Bit), andBit (B2:Bit, B-prime2:Bit), andBit (B3:Bit, B-prime3:Bit), andBit (B4:Bit, B-prime4:Bit), andBit (B5:Bit, B-prime5:Bit), andBit (B6:Bit, B-prime6:Bit), andBit (B7:Bit, B-prime7:Bit), andBit (B8:Bit, B-prime8:Bit)) .\n  eq [150]: orOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (orBit (B1:Bit, B-prime1:Bit), orBit (B2:Bit, B-prime2:Bit), orBit (B3:Bit, B-prime3:Bit), orBit (B4:Bit, B-prime4:Bit), orBit (B5:Bit, B-prime5:Bit), orBit (B6:Bit, B-prime6:Bit), orBit (B7:Bit, B-prime7:Bit), orBit (B8:Bit, B-prime8:Bit)) .\n  eq [151]: xorOctet (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B-prime1:Bit, B-prime2:Bit, B-prime3:Bit, B-prime4:Bit, B-prime5:Bit, B-prime6:Bit, B-prime7:Bit, B-prime8:Bit)) = buildOctet (xorBit (B1:Bit, B-prime1:Bit), xorBit (B2:Bit, B-prime2:Bit), xorBit (B3:Bit, B-prime3:Bit), xorBit (B4:Bit, B-prime4:Bit), xorBit (B5:Bit, B-prime5:Bit), xorBit (B6:Bit, B-prime6:Bit), xorBit (B7:Bit, B-prime7:Bit), xorBit (B8:Bit, B-prime8:Bit)) .\n  eq [152]: x02 = buildOctet (x0, x0, x0, x0, x0, x0, x1, x0) .\n  eq [153]: x03 = buildOctet (x0, x0, x0, x0, x0, x0, x1, x1) .\n  eq [154]: x04 = buildOctet (x0, x0, x0, x0, x0, x1, x0, x0) .\n  eq [155]: x05 = buildOctet (x0, x0, x0, x0, x0, x1, x0, x1) .\n  eq [156]: x06 = buildOctet (x0, x0, x0, x0, x0, x1, x1, x0) .\n  eq [157]: x07 = buildOctet (x0, x0, x0, x0, x0, x1, x1, x1) .\n  eq [158]: x08 = buildOctet (x0, x0, x0, x0, x1, x0, x0, x0) .\n  eq [159]: x09 = buildOctet (x0, x0, x0, x0, x1, x0, x0, x1) .\n  eq [160]: x0A = buildOctet (x0, x0, x0, x0, x1, x0, x1, x0) .\n  eq [161]: x0B = buildOctet (x0, x0, x0, x0, x1, x0, x1, x1) .\n  eq [162]: x0C = buildOctet (x0, x0, x0, x0, x1, x1, x0, x0) .\n  eq [163]: x0D = buildOctet (x0, x0, x0, x0, x1, x1, x0, x1) .\n  eq [164]: x0E = buildOctet (x0, x0, x0, x0, x1, x1, x1, x0) .\n  eq [165]: x0F = buildOctet (x0, x0, x0, x0, x1, x1, x1, x1) .\n  eq [166]: x10 = buildOctet (x0, x0, x0, x1, x0, x0, x0, x0) .\n  eq [167]: x11 = buildOctet (x0, x0, x0, x1, x0, x0, x0, x1) .\n  eq [168]: x12 = buildOctet (x0, x0, x0, x1, x0, x0, x1, x0) .\n  eq [169]: x13 = buildOctet (x0, x0, x0, x1, x0, x0, x1, x1) .\n  eq [170]: x14 = buildOctet (x0, x0, x0, x1, x0, x1, x0, x0) .\n  eq [171]: x15 = buildOctet (x0, x0, x0, x1, x0, x1, x0, x1) .\n  eq [172]: x16 = buildOctet (x0, x0, x0, x1, x0, x1, x1, x0) .\n  eq [173]: x17 = buildOctet (x0, x0, x0, x1, x0, x1, x1, x1) .\n  eq [174]: x18 = buildOctet (x0, x0, x0, x1, x1, x0, x0, x0) .\n  eq [175]: x1A = buildOctet (x0, x0, x0, x1, x1, x0, x1, x0) .\n  eq [176]: x1B = buildOctet (x0, x0, x0, x1, x1, x0, x1, x1) .\n  eq [177]: x1C = buildOctet (x0, x0, x0, x1, x1, x1, x0, x0) .\n  eq [178]: x1D = buildOctet (x0, x0, x0, x1, x1, x1, x0, x1) .\n  eq [179]: x1E = buildOctet (x0, x0, x0, x1, x1, x1, x1, x0) .\n  eq [180]: x1F = buildOctet (x0, x0, x0, x1, x1, x1, x1, x1) .\n  eq [181]: x20 = buildOctet (x0, x0, x1, x0, x0, x0, x0, x0) .\n  eq [182]: x21 = buildOctet (x0, x0, x1, x0, x0, x0, x0, x1) .\n  eq [183]: x23 = buildOctet (x0, x0, x1, x0, x0, x0, x1, x1) .\n  eq [184]: x24 = buildOctet (x0, x0, x1, x0, x0, x1, x0, x0) .\n  eq [185]: x25 = buildOctet (x0, x0, x1, x0, x0, x1, x0, x1) .\n  eq [186]: x26 = buildOctet (x0, x0, x1, x0, x0, x1, x1, x0) .\n  eq [187]: x27 = buildOctet (x0, x0, x1, x0, x0, x1, x1, x1) .\n  eq [188]: x28 = buildOctet (x0, x0, x1, x0, x1, x0, x0, x0) .\n  eq [189]: x29 = buildOctet (x0, x0, x1, x0, x1, x0, x0, x1) .\n  eq [190]: x2A = buildOctet (x0, x0, x1, x0, x1, x0, x1, x0) .\n  eq [191]: x2B = buildOctet (x0, x0, x1, x0, x1, x0, x1, x1) .\n  eq [192]: x2D = buildOctet (x0, x0, x1, x0, x1, x1, x0, x1) .\n  eq [193]: x2E = buildOctet (x0, x0, x1, x0, x1, x1, x1, x0) .\n  eq [194]: x2F = buildOctet (x0, x0, x1, x0, x1, x1, x1, x1) .\n  eq [195]: x30 = buildOctet (x0, x0, x1, x1, x0, x0, x0, x0) .\n  eq [196]: x31 = buildOctet (x0, x0, x1, x1, x0, x0, x0, x1) .\n  eq [197]: x32 = buildOctet (x0, x0, x1, x1, x0, x0, x1, x0) .\n  eq [198]: x33 = buildOctet (x0, x0, x1, x1, x0, x0, x1, x1) .\n  eq [199]: x34 = buildOctet (x0, x0, x1, x1, x0, x1, x0, x0) .\n  eq [200]: x35 = buildOctet (x0, x0, x1, x1, x0, x1, x0, x1) .\n  eq [201]: x36 = buildOctet (x0, x0, x1, x1, x0, x1, x1, x0) .\n  eq [202]: x37 = buildOctet (x0, x0, x1, x1, x0, x1, x1, x1) .\n  eq [203]: x38 = buildOctet (x0, x0, x1, x1, x1, x0, x0, x0) .\n  eq [204]: x39 = buildOctet (x0, x0, x1, x1, x1, x0, x0, x1) .\n  eq [205]: x3A = buildOctet (x0, x0, x1, x1, x1, x0, x1, x0) .\n  eq [206]: x3B = buildOctet (x0, x0, x1, x1, x1, x0, x1, x1) .\n  eq [207]: x3D = buildOctet (x0, x0, x1, x1, x1, x1, x0, x1) .\n  eq [208]: x3C = buildOctet (x0, x0, x1, x1, x1, x1, x0, x0) .\n  eq [209]: x3F = buildOctet (x0, x0, x1, x1, x1, x1, x1, x1) .\n  eq [210]: x40 = buildOctet (x0, x1, x0, x0, x0, x0, x0, x0) .\n  eq [211]: x46 = buildOctet (x0, x1, x0, x0, x0, x1, x1, x0) .\n  eq [212]: x48 = buildOctet (x0, x1, x0, x0, x1, x0, x0, x0) .\n  eq [213]: x49 = buildOctet (x0, x1, x0, x0, x1, x0, x0, x1) .\n  eq [214]: x4A = buildOctet (x0, x1, x0, x0, x1, x0, x1, x0) .\n  eq [215]: x4B = buildOctet (x0, x1, x0, x0, x1, x0, x1, x1) .\n  eq [216]: x4C = buildOctet (x0, x1, x0, x0, x1, x1, x0, x0) .\n  eq [217]: x4D = buildOctet (x0, x1, x0, x0, x1, x1, x0, x1) .\n  eq [218]: x4E = buildOctet (x0, x1, x0, x0, x1, x1, x1, x0) .\n  eq [219]: x4F = buildOctet (x0, x1, x0, x0, x1, x1, x1, x1) .\n  eq [220]: x50 = buildOctet (x0, x1, x0, x1, x0, x0, x0, x0) .\n  eq [221]: x51 = buildOctet (x0, x1, x0, x1, x0, x0, x0, x1) .\n  eq [222]: x53 = buildOctet (x0, x1, x0, x1, x0, x0, x1, x1) .\n  eq [223]: x54 = buildOctet (x0, x1, x0, x1, x0, x1, x0, x0) .\n  eq [224]: x55 = buildOctet (x0, x1, x0, x1, x0, x1, x0, x1) .\n  eq [225]: x58 = buildOctet (x0, x1, x0, x1, x1, x0, x0, x0) .\n  eq [226]: x5A = buildOctet (x0, x1, x0, x1, x1, x0, x1, x0) .\n  eq [227]: x5B = buildOctet (x0, x1, x0, x1, x1, x0, x1, x1) .\n  eq [228]: x5C = buildOctet (x0, x1, x0, x1, x1, x1, x0, x0) .\n  eq [229]: x5D = buildOctet (x0, x1, x0, x1, x1, x1, x0, x1) .\n  eq [230]: x5E = buildOctet (x0, x1, x0, x1, x1, x1, x1, x0) .\n  eq [231]: x5F = buildOctet (x0, x1, x0, x1, x1, x1, x1, x1) .\n  eq [232]: x60 = buildOctet (x0, x1, x1, x0, x0, x0, x0, x0) .\n  eq [233]: x61 = buildOctet (x0, x1, x1, x0, x0, x0, x0, x1) .\n  eq [234]: x62 = buildOctet (x0, x1, x1, x0, x0, x0, x1, x0) .\n  eq [235]: x63 = buildOctet (x0, x1, x1, x0, x0, x0, x1, x1) .\n  eq [236]: x64 = buildOctet (x0, x1, x1, x0, x0, x1, x0, x0) .\n  eq [237]: x65 = buildOctet (x0, x1, x1, x0, x0, x1, x0, x1) .\n  eq [238]: x66 = buildOctet (x0, x1, x1, x0, x0, x1, x1, x0) .\n  eq [239]: x67 = buildOctet (x0, x1, x1, x0, x0, x1, x1, x1) .\n  eq [240]: x69 = buildOctet (x0, x1, x1, x0, x1, x0, x0, x1) .\n  eq [241]: x6A = buildOctet (x0, x1, x1, x0, x1, x0, x1, x0) .\n  eq [242]: x6B = buildOctet (x0, x1, x1, x0, x1, x0, x1, x1) .\n  eq [243]: x6C = buildOctet (x0, x1, x1, x0, x1, x1, x0, x0) .\n  eq [244]: x6D = buildOctet (x0, x1, x1, x0, x1, x1, x0, x1) .\n  eq [245]: x6E = buildOctet (x0, x1, x1, x0, x1, x1, x1, x0) .\n  eq [246]: x6F = buildOctet (x0, x1, x1, x0, x1, x1, x1, x1) .\n  eq [247]: x70 = buildOctet (x0, x1, x1, x1, x0, x0, x0, x0) .\n  eq [248]: x71 = buildOctet (x0, x1, x1, x1, x0, x0, x0, x1) .\n  eq [249]: x72 = buildOctet (x0, x1, x1, x1, x0, x0, x1, x0) .\n  eq [250]: x73 = buildOctet (x0, x1, x1, x1, x0, x0, x1, x1) .\n  eq [251]: x74 = buildOctet (x0, x1, x1, x1, x0, x1, x0, x0) .\n  eq [252]: x75 = buildOctet (x0, x1, x1, x1, x0, x1, x0, x1) .\n  eq [253]: x76 = buildOctet (x0, x1, x1, x1, x0, x1, x1, x0) .\n  eq [254]: x77 = buildOctet (x0, x1, x1, x1, x0, x1, x1, x1) .\n  eq [255]: x78 = buildOctet (x0, x1, x1, x1, x1, x0, x0, x0) .\n  eq [256]: x79 = buildOctet (x0, x1, x1, x1, x1, x0, x0, x1) .\n  eq [257]: x7A = buildOctet (x0, x1, x1, x1, x1, x0, x1, x0) .\n  eq [258]: x7B = buildOctet (x0, x1, x1, x1, x1, x0, x1, x1) .\n  eq [259]: x7C = buildOctet (x0, x1, x1, x1, x1, x1, x0, x0) .\n  eq [260]: x7D = buildOctet (x0, x1, x1, x1, x1, x1, x0, x1) .\n  eq [261]: x7E = buildOctet (x0, x1, x1, x1, x1, x1, x1, x0) .\n  eq [262]: x7F = buildOctet (x0, x1, x1, x1, x1, x1, x1, x1) .\n  eq [263]: x80 = buildOctet (x1, x0, x0, x0, x0, x0, x0, x0) .\n  eq [264]: x81 = buildOctet (x1, x0, x0, x0, x0, x0, x0, x1) .\n  eq [265]: x83 = buildOctet (x1, x0, x0, x0, x0, x0, x1, x1) .\n  eq [266]: x84 = buildOctet (x1, x0, x0, x0, x0, x1, x0, x0) .\n  eq [267]: x85 = buildOctet (x1, x0, x0, x0, x0, x1, x0, x1) .\n  eq [268]: x86 = buildOctet (x1, x0, x0, x0, x0, x1, x1, x0) .\n  eq [269]: x88 = buildOctet (x1, x0, x0, x0, x1, x0, x0, x0) .\n  eq [270]: x89 = buildOctet (x1, x0, x0, x0, x1, x0, x0, x1) .\n  eq [271]: x8A = buildOctet (x1, x0, x0, x0, x1, x0, x1, x0) .\n  eq [272]: x8C = buildOctet (x1, x0, x0, x0, x1, x1, x0, x0) .\n  eq [273]: x8D = buildOctet (x1, x0, x0, x0, x1, x1, x0, x1) .\n  eq [274]: x8E = buildOctet (x1, x0, x0, x0, x1, x1, x1, x0) .\n  eq [275]: x8F = buildOctet (x1, x0, x0, x0, x1, x1, x1, x1) .\n  eq [276]: x90 = buildOctet (x1, x0, x0, x1, x0, x0, x0, x0) .\n  eq [277]: x91 = buildOctet (x1, x0, x0, x1, x0, x0, x0, x1) .\n  eq [278]: x92 = buildOctet (x1, x0, x0, x1, x0, x0, x1, x0) .\n  eq [279]: x93 = buildOctet (x1, x0, x0, x1, x0, x0, x1, x1) .\n  eq [280]: x95 = buildOctet (x1, x0, x0, x1, x0, x1, x0, x1) .\n  eq [281]: x96 = buildOctet (x1, x0, x0, x1, x0, x1, x1, x0) .\n  eq [282]: x97 = buildOctet (x1, x0, x0, x1, x0, x1, x1, x1) .\n  eq [283]: x98 = buildOctet (x1, x0, x0, x1, x1, x0, x0, x0) .\n  eq [284]: x99 = buildOctet (x1, x0, x0, x1, x1, x0, x0, x1) .\n  eq [285]: x9A = buildOctet (x1, x0, x0, x1, x1, x0, x1, x0) .\n  eq [286]: x9B = buildOctet (x1, x0, x0, x1, x1, x0, x1, x1) .\n  eq [287]: x9C = buildOctet (x1, x0, x0, x1, x1, x1, x0, x0) .\n  eq [288]: x9D = buildOctet (x1, x0, x0, x1, x1, x1, x0, x1) .\n  eq [289]: x9E = buildOctet (x1, x0, x0, x1, x1, x1, x1, x0) .\n  eq [290]: x9F = buildOctet (x1, x0, x0, x1, x1, x1, x1, x1) .\n  eq [291]: xA1 = buildOctet (x1, x0, x1, x0, x0, x0, x0, x1) .\n  eq [292]: xA0 = buildOctet (x1, x0, x1, x0, x0, x0, x0, x0) .\n  eq [293]: xA2 = buildOctet (x1, x0, x1, x0, x0, x0, x1, x0) .\n  eq [294]: xA3 = buildOctet (x1, x0, x1, x0, x0, x0, x1, x1) .\n  eq [295]: xA4 = buildOctet (x1, x0, x1, x0, x0, x1, x0, x0) .\n  eq [296]: xA5 = buildOctet (x1, x0, x1, x0, x0, x1, x0, x1) .\n  eq [297]: xA6 = buildOctet (x1, x0, x1, x0, x0, x1, x1, x0) .\n  eq [298]: xA7 = buildOctet (x1, x0, x1, x0, x0, x1, x1, x1) .\n  eq [299]: xA8 = buildOctet (x1, x0, x1, x0, x1, x0, x0, x0) .\n  eq [300]: xA9 = buildOctet (x1, x0, x1, x0, x1, x0, x0, x1) .\n  eq [301]: xAA = buildOctet (x1, x0, x1, x0, x1, x0, x1, x0) .\n  eq [302]: xAB = buildOctet (x1, x0, x1, x0, x1, x0, x1, x1) .\n  eq [303]: xAC = buildOctet (x1, x0, x1, x0, x1, x1, x0, x0) .\n  eq [304]: xAE = buildOctet (x1, x0, x1, x0, x1, x1, x1, x0) .\n  eq [305]: xAF = buildOctet (x1, x0, x1, x0, x1, x1, x1, x1) .\n  eq [306]: xB0 = buildOctet (x1, x0, x1, x1, x0, x0, x0, x0) .\n  eq [307]: xB1 = buildOctet (x1, x0, x1, x1, x0, x0, x0, x1) .\n  eq [308]: xB2 = buildOctet (x1, x0, x1, x1, x0, x0, x1, x0) .\n  eq [309]: xB3 = buildOctet (x1, x0, x1, x1, x0, x0, x1, x1) .\n  eq [310]: xB5 = buildOctet (x1, x0, x1, x1, x0, x1, x0, x1) .\n  eq [311]: xB6 = buildOctet (x1, x0, x1, x1, x0, x1, x1, x0) .\n  eq [312]: xB8 = buildOctet (x1, x0, x1, x1, x1, x0, x0, x0) .\n  eq [313]: xB9 = buildOctet (x1, x0, x1, x1, x1, x0, x0, x1) .\n  eq [314]: xBA = buildOctet (x1, x0, x1, x1, x1, x0, x1, x0) .\n  eq [315]: xBB = buildOctet (x1, x0, x1, x1, x1, x0, x1, x1) .\n  eq [316]: xBC = buildOctet (x1, x0, x1, x1, x1, x1, x0, x0) .\n  eq [317]: xBE = buildOctet (x1, x0, x1, x1, x1, x1, x1, x0) .\n  eq [318]: xBF = buildOctet (x1, x0, x1, x1, x1, x1, x1, x1) .\n  eq [319]: xC0 = buildOctet (x1, x1, x0, x0, x0, x0, x0, x0) .\n  eq [320]: xC1 = buildOctet (x1, x1, x0, x0, x0, x0, x0, x1) .\n  eq [321]: xC2 = buildOctet (x1, x1, x0, x0, x0, x0, x1, x0) .\n  eq [322]: xC4 = buildOctet (x1, x1, x0, x0, x0, x1, x0, x0) .\n  eq [323]: xC5 = buildOctet (x1, x1, x0, x0, x0, x1, x0, x1) .\n  eq [324]: xC6 = buildOctet (x1, x1, x0, x0, x0, x1, x1, x0) .\n  eq [325]: xC7 = buildOctet (x1, x1, x0, x0, x0, x1, x1, x1) .\n  eq [326]: xC8 = buildOctet (x1, x1, x0, x0, x1, x0, x0, x0) .\n  eq [327]: xC9 = buildOctet (x1, x1, x0, x0, x1, x0, x0, x1) .\n  eq [328]: xCA = buildOctet (x1, x1, x0, x0, x1, x0, x1, x0) .\n  eq [329]: xCB = buildOctet (x1, x1, x0, x0, x1, x0, x1, x1) .\n  eq [330]: xCC = buildOctet (x1, x1, x0, x0, x1, x1, x0, x0) .\n  eq [331]: xCD = buildOctet (x1, x1, x0, x0, x1, x1, x0, x1) .\n  eq [332]: xCE = buildOctet (x1, x1, x0, x0, x1, x1, x1, x0) .\n  eq [333]: xD0 = buildOctet (x1, x1, x0, x1, x0, x0, x0, x0) .\n  eq [334]: xD1 = buildOctet (x1, x1, x0, x1, x0, x0, x0, x1) .\n  eq [335]: xD2 = buildOctet (x1, x1, x0, x1, x0, x0, x1, x0) .\n  eq [336]: xD3 = buildOctet (x1, x1, x0, x1, x0, x0, x1, x1) .\n  eq [337]: xD4 = buildOctet (x1, x1, x0, x1, x0, x1, x0, x0) .\n  eq [338]: xD5 = buildOctet (x1, x1, x0, x1, x0, x1, x0, x1) .\n  eq [339]: xD6 = buildOctet (x1, x1, x0, x1, x0, x1, x1, x0) .\n  eq [340]: xD7 = buildOctet (x1, x1, x0, x1, x0, x1, x1, x1) .\n  eq [341]: xD8 = buildOctet (x1, x1, x0, x1, x1, x0, x0, x0) .\n  eq [342]: xD9 = buildOctet (x1, x1, x0, x1, x1, x0, x0, x1) .\n  eq [343]: xDB = buildOctet (x1, x1, x0, x1, x1, x0, x1, x1) .\n  eq [344]: xDC = buildOctet (x1, x1, x0, x1, x1, x1, x0, x0) .\n  eq [345]: xDD = buildOctet (x1, x1, x0, x1, x1, x1, x0, x1) .\n  eq [346]: xDE = buildOctet (x1, x1, x0, x1, x1, x1, x1, x0) .\n  eq [347]: xDF = buildOctet (x1, x1, x0, x1, x1, x1, x1, x1) .\n  eq [348]: xE0 = buildOctet (x1, x1, x1, x0, x0, x0, x0, x0) .\n  eq [349]: xE1 = buildOctet (x1, x1, x1, x0, x0, x0, x0, x1) .\n  eq [350]: xE3 = buildOctet (x1, x1, x1, x0, x0, x0, x1, x1) .\n  eq [351]: xE6 = buildOctet (x1, x1, x1, x0, x0, x1, x1, x0) .\n  eq [352]: xE8 = buildOctet (x1, x1, x1, x0, x1, x0, x0, x0) .\n  eq [353]: xE9 = buildOctet (x1, x1, x1, x0, x1, x0, x0, x1) .\n  eq [354]: xEA = buildOctet (x1, x1, x1, x0, x1, x0, x1, x0) .\n  eq [355]: xEB = buildOctet (x1, x1, x1, x0, x1, x0, x1, x1) .\n  eq [356]: xEC = buildOctet (x1, x1, x1, x0, x1, x1, x0, x0) .\n  eq [357]: xED = buildOctet (x1, x1, x1, x0, x1, x1, x0, x1) .\n  eq [358]: xEE = buildOctet (x1, x1, x1, x0, x1, x1, x1, x0) .\n  eq [359]: xEF = buildOctet (x1, x1, x1, x0, x1, x1, x1, x1) .\n  eq [360]: xF0 = buildOctet (x1, x1, x1, x1, x0, x0, x0, x0) .\n  eq [361]: xF1 = buildOctet (x1, x1, x1, x1, x0, x0, x0, x1) .\n  eq [362]: xF2 = buildOctet (x1, x1, x1, x1, x0, x0, x1, x0) .\n  eq [363]: xF3 = buildOctet (x1, x1, x1, x1, x0, x0, x1, x1) .\n  eq [364]: xF4 = buildOctet (x1, x1, x1, x1, x0, x1, x0, x0) .\n  eq [365]: xF5 = buildOctet (x1, x1, x1, x1, x0, x1, x0, x1) .\n  eq [366]: xF6 = buildOctet (x1, x1, x1, x1, x0, x1, x1, x0) .\n  eq [367]: xF7 = buildOctet (x1, x1, x1, x1, x0, x1, x1, x1) .\n  eq [368]: xF8 = buildOctet (x1, x1, x1, x1, x1, x0, x0, x0) .\n  eq [369]: xF9 = buildOctet (x1, x1, x1, x1, x1, x0, x0, x1) .\n  eq [370]: xFA = buildOctet (x1, x1, x1, x1, x1, x0, x1, x0) .\n  eq [371]: xFB = buildOctet (x1, x1, x1, x1, x1, x0, x1, x1) .\n  eq [372]: xFC = buildOctet (x1, x1, x1, x1, x1, x1, x0, x0) .\n  eq [373]: xFD = buildOctet (x1, x1, x1, x1, x1, x1, x0, x1) .\n  eq [374]: xFE = buildOctet (x1, x1, x1, x1, x1, x1, x1, x0) .\n  eq [375]: xFF = buildOctet (x1, x1, x1, x1, x1, x1, x1, x1) .\n  eq [376]: andBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (andOctet (O1:Octet, O-prime1:Octet), andOctet (O2:Octet, O-prime2:Octet), andOctet (O3:Octet, O-prime3:Octet), andOctet (O4:Octet, O-prime4:Octet)) .\n  eq [377]: orBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (orOctet (O1:Octet, O-prime1:Octet), orOctet (O2:Octet, O-prime2:Octet), orOctet (O3:Octet, O-prime3:Octet), orOctet (O4:Octet, O-prime4:Octet)) .\n  eq [378]: xorBlock (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildBlock (xorOctet (O1:Octet, O-prime1:Octet), xorOctet (O2:Octet, O-prime2:Octet), xorOctet (O3:Octet, O-prime3:Octet), xorOctet (O4:Octet, O-prime4:Octet)) .\n  eq [379]: x0001 = buildHalf (x00, x01) .\n  eq [380]: x00000000 = buildBlock (x00, x00, x00, x00) .\n  eq [381]: x00000001 = buildBlock (x00, x00, x00, x01) .\n  eq [382]: x00000002 = buildBlock (x00, x00, x00, x02) .\n  eq [383]: x00000003 = buildBlock (x00, x00, x00, x03) .\n  eq [384]: x00000004 = buildBlock (x00, x00, x00, x04) .\n  eq [385]: x00000005 = buildBlock (x00, x00, x00, x05) .\n  eq [386]: x00000006 = buildBlock (x00, x00, x00, x06) .\n  eq [387]: x00000007 = buildBlock (x00, x00, x00, x07) .\n  eq [388]: x00000008 = buildBlock (x00, x00, x00, x08) .\n  eq [389]: x00000009 = buildBlock (x00, x00, x00, x09) .\n  eq [390]: x0000000A = buildBlock (x00, x00, x00, x0A) .\n  eq [391]: x0000000B = buildBlock (x00, x00, x00, x0B) .\n  eq [392]: x0000000C = buildBlock (x00, x00, x00, x0C) .\n  eq [393]: x0000000D = buildBlock (x00, x00, x00, x0D) .\n  eq [394]: x0000000E = buildBlock (x00, x00, x00, x0E) .\n  eq [395]: x0000000F = buildBlock (x00, x00, x00, x0F) .\n  eq [396]: x00000010 = buildBlock (x00, x00, x00, x10) .\n  eq [397]: x00000012 = buildBlock (x00, x00, x00, x12) .\n  eq [398]: x00000014 = buildBlock (x00, x00, x00, x14) .\n  eq [399]: x00000016 = buildBlock (x00, x00, x00, x16) .\n  eq [401]: x00000018 = buildBlock (x00, x00, x00, x18) .\n  eq [402]: x0000001B = buildBlock (x00, x00, x00, x1B) .\n  eq [403]: x0000001D = buildBlock (x00, x00, x00, x1D) .\n  eq [404]: x0000001E = buildBlock (x00, x00, x00, x1E) .\n  eq [405]: x0000001F = buildBlock (x00, x00, x00, x1F) .\n  eq [406]: x00000031 = buildBlock (x00, x00, x00, x31) .\n  eq [407]: x00000036 = buildBlock (x00, x00, x00, x36) .\n  eq [408]: x00000060 = buildBlock (x00, x00, x00, x60) .\n  eq [409]: x00000080 = buildBlock (x00, x00, x00, x80) .\n  eq [410]: x000000A5 = buildBlock (x00, x00, x00, xA5) .\n  eq [411]: x000000B6 = buildBlock (x00, x00, x00, xB6) .\n  eq [412]: x000000C4 = buildBlock (x00, x00, x00, xC4) .\n  eq [413]: x000000D2 = buildBlock (x00, x00, x00, xD2) .\n  eq [414]: x00000100 = buildBlock (x00, x00, x01, x00) .\n  eq [415]: x00000129 = buildBlock (x00, x00, x01, x29) .\n  eq [416]: x0000018C = buildBlock (x00, x00, x01, x8C) .\n  eq [417]: x00004000 = buildBlock (x00, x00, x40, x00) .\n  eq [418]: x00010000 = buildBlock (x00, x01, x00, x00) .\n  eq [419]: x00020000 = buildBlock (x00, x02, x00, x00) .\n  eq [420]: x00030000 = buildBlock (x00, x03, x00, x00) .\n  eq [421]: x00040000 = buildBlock (x00, x04, x00, x00) .\n  eq [422]: x00060000 = buildBlock (x00, x06, x00, x00) .\n  eq [423]: x00804021 = buildBlock (x00, x80, x40, x21) .\n  eq [424]: x00FF00FF = buildBlock (x00, xFF, x00, xFF) .\n  eq [425]: x0103050B = buildBlock (x01, x03, x05, x0B) .\n  eq [426]: x01030703 = buildBlock (x01, x03, x07, x03) .\n  eq [427]: x01030705 = buildBlock (x01, x03, x07, x05) .\n  eq [428]: x0103070F = buildBlock (x01, x03, x07, x0F) .\n  eq [429]: x02040801 = buildBlock (x02, x04, x08, x01) .\n  eq [430]: x0297AF6F = buildBlock (x02, x97, xAF, x6F) .\n  eq [431]: x07050301 = buildBlock (x07, x05, x03, x01) .\n  eq [432]: x077788A2 = buildBlock (x07, x77, x88, xA2) .\n  eq [433]: x07C72EAA = buildBlock (x07, xC7, x2E, xAA) .\n  eq [434]: x0A202020 = buildBlock (x0A, x20, x20, x20) .\n  eq [435]: x0AD67E20 = buildBlock (x0A, xD6, x7E, x20) .\n  eq [436]: x10000000 = buildBlock (x10, x00, x00, x00) .\n  eq [437]: x11A9D254 = buildBlock (x11, xA9, xD2, x54) .\n  eq [438]: x11AC46B8 = buildBlock (x11, xAC, x46, xB8) .\n  eq [439]: x1277A6D4 = buildBlock (x12, x77, xA6, xD4) .\n  eq [440]: x13647149 = buildBlock (x13, x64, x71, x49) .\n  eq [441]: x160EE9B5 = buildBlock (x16, x0E, xE9, xB5) .\n  eq [442]: x17065DBB = buildBlock (x17, x06, x5D, xBB) .\n  eq [443]: x17A808FD = buildBlock (x17, xA8, x08, xFD) .\n  eq [444]: x1D10D8D3 = buildBlock (x1D, x10, xD8, xD3) .\n  eq [445]: x1D3B7760 = buildBlock (x1D, x3B, x77, x60) .\n  eq [446]: x1D9C9655 = buildBlock (x1D, x9C, x96, x55) .\n  eq [447]: x1F3F7FFF = buildBlock (x1F, x3F, x7F, xFF) .\n  eq [448]: x204E80A7 = buildBlock (x20, x4E, x80, xA7) .\n  eq [449]: x21D869BA = buildBlock (x21, xD8, x69, xBA) .\n  eq [450]: x24B66FB5 = buildBlock (x24, xB6, x6F, xB5) .\n  eq [451]: x270EEDAF = buildBlock (x27, x0E, xED, xAF) .\n  eq [452]: x277B4B25 = buildBlock (x27, x7B, x4B, x25) .\n  eq [453]: x2829040B = buildBlock (x28, x29, x04, x0B) .\n  eq [454]: x288FC786 = buildBlock (x28, x8F, xC7, x86) .\n  eq [455]: x28EAD8B3 = buildBlock (x28, xEA, xD8, xB3) .\n  eq [456]: x29907CD8 = buildBlock (x29, x90, x7C, xD8) .\n  eq [457]: x29C1485F = buildBlock (x29, xC1, x48, x5F) .\n  eq [458]: x29EEE96B = buildBlock (x29, xEE, xE9, x6B) .\n  eq [459]: x2A6091AE = buildBlock (x2A, x60, x91, xAE) .\n  eq [460]: x2BF8499A = buildBlock (x2B, xF8, x49, x9A) .\n  eq [461]: x2E80AC30 = buildBlock (x2E, x80, xAC, x30) .\n  eq [462]: x2FD76FFB = buildBlock (x2F, xD7, x6F, xFB) .\n  eq [463]: x30261492 = buildBlock (x30, x26, x14, x92) .\n  eq [464]: x303FF4AA = buildBlock (x30, x3F, xF4, xAA) .\n  eq [465]: x33D5A466 = buildBlock (x33, xD5, xA4, x66) .\n  eq [466]: x344925FC = buildBlock (x34, x49, x25, xFC) .\n  eq [467]: x34ACF886 = buildBlock (x34, xAC, xF8, x86) .\n  eq [468]: x3CD54DEB = buildBlock (x3C, xD5, x4D, xEB) .\n  eq [469]: x3CF3A7D2 = buildBlock (x3C, xF3, xA7, xD2) .\n  eq [470]: x3DD81AC6 = buildBlock (x3D, xD8, x1A, xC6) .\n  eq [471]: x3F6F7248 = buildBlock (x3F, x6F, x72, x48) .\n  eq [472]: x48B204D6 = buildBlock (x48, xB2, x04, xD6) .\n  eq [473]: x4A645A01 = buildBlock (x4A, x64, x5A, x01) .\n  eq [474]: x4C49AAE0 = buildBlock (x4C, x49, xAA, xE0) .\n  eq [475]: x4CE933E1 = buildBlock (x4C, xE9, x33, xE1) .\n  eq [476]: x4D53901A = buildBlock (x4D, x53, x90, x1A) .\n  eq [477]: x4DA124A1 = buildBlock (x4D, xA1, x24, xA1) .\n  eq [478]: x4F998E01 = buildBlock (x4F, x99, x8E, x01) .\n  eq [479]: x4FB1138A = buildBlock (x4F, xB1, x13, x8A) .\n  eq [480]: x50DEC930 = buildBlock (x50, xDE, xC9, x30) .\n  eq [481]: x51AF3C1D = buildBlock (x51, xAF, x3C, x1D) .\n  eq [482]: x51EDE9C7 = buildBlock (x51, xED, xE9, xC7) .\n  eq [483]: x550D91CE = buildBlock (x55, x0D, x91, xCE) .\n  eq [484]: x55555555 = buildBlock (x55, x55, x55, x55) .\n  eq [485]: x55DD063F = buildBlock (x55, xDD, x06, x3F) .\n  eq [486]: x5834A585 = buildBlock (x58, x34, xA5, x85) .\n  eq [487]: x5A35D667 = buildBlock (x5A, x35, xD6, x67) .\n  eq [488]: x5BC02502 = buildBlock (x5B, xC0, x25, x02) .\n  eq [489]: x5CCA3239 = buildBlock (x5C, xCA, x32, x39) .\n  eq [490]: x5EBA06C2 = buildBlock (x5E, xBA, x06, xC2) .\n  eq [491]: x5F38EEF1 = buildBlock (x5F, x38, xEE, xF1) .\n  eq [492]: x613F8E2A = buildBlock (x61, x3F, x8E, x2A) .\n  eq [493]: x63C70DBA = buildBlock (x63, xC7, x0D, xBA) .\n  eq [494]: x6AD6E8A4 = buildBlock (x6A, xD6, xE8, xA4) .\n  eq [495]: x6AEBACF8 = buildBlock (x6A, xEB, xAC, xF8) .\n  eq [496]: x6D67E884 = buildBlock (x6D, x67, xE8, x84) .\n  eq [497]: x7050EC5E = buildBlock (x70, x50, xEC, x5E) .\n  eq [498]: x717153D5 = buildBlock (x71, x71, x53, xD5) .\n  eq [499]: x7201F4DC = buildBlock (x72, x01, xF4, xDC) .\n  eq [500]: x7397C9AE = buildBlock (x73, x97, xC9, xAE) .\n  eq [501]: x74B39176 = buildBlock (x74, xB3, x91, x76) .\n  eq [502]: x76232E5F = buildBlock (x76, x23, x2E, x5F) .\n  eq [503]: x7783C51D = buildBlock (x77, x83, xC5, x1D) .\n  eq [504]: x7792F9D4 = buildBlock (x77, x92, xF9, xD4) .\n  eq [505]: x7BC180AB = buildBlock (x7B, xC1, x80, xAB) .\n  eq [506]: x7DB2D9F4 = buildBlock (x7D, xB2, xD9, xF4) .\n  eq [507]: x7DFEFBFF = buildBlock (x7D, xFE, xFB, xFF) .\n  eq [508]: x7F76A3B0 = buildBlock (x7F, x76, xA3, xB0) .\n  eq [509]: x7F839576 = buildBlock (x7F, x83, x95, x76) .\n  eq [510]: x7FFFFFF0 = buildBlock (x7F, xFF, xFF, xF0) .\n  eq [511]: x7FFFFFF1 = buildBlock (x7F, xFF, xFF, xF1) .\n  eq [512]: x7FFFFFFC = buildBlock (x7F, xFF, xFF, xFC) .\n  eq [513]: x7FFFFFFD = buildBlock (x7F, xFF, xFF, xFD) .\n  eq [514]: x80000000 = buildBlock (x80, x00, x00, x00) .\n  eq [515]: x80000002 = buildBlock (x80, x00, x00, x02) .\n  eq [516]: x800000C2 = buildBlock (x80, x00, x00, xC2) .\n  eq [517]: x80018000 = buildBlock (x80, x01, x80, x00) .\n  eq [518]: x80018001 = buildBlock (x80, x01, x80, x01) .\n  eq [519]: x80397302 = buildBlock (x80, x39, x73, x02) .\n  eq [520]: x81D10CA3 = buildBlock (x81, xD1, x0C, xA3) .\n  eq [521]: x89D635D7 = buildBlock (x89, xD6, x35, xD7) .\n  eq [522]: x8CE37709 = buildBlock (x8C, xE3, x77, x09) .\n  eq [523]: x8DC8BBDE = buildBlock (x8D, xC8, xBB, xDE) .\n  eq [524]: x9115A558 = buildBlock (x91, x15, xA5, x58) .\n  eq [525]: x91896CFA = buildBlock (x91, x89, x6C, xFA) .\n  eq [526]: x9372CDC6 = buildBlock (x93, x72, xCD, xC6) .\n  eq [527]: x98D1CC75 = buildBlock (x98, xD1, xCC, x75) .\n  eq [528]: x9D15C437 = buildBlock (x9D, x15, xC4, x37) .\n  eq [529]: x9DB15CF6 = buildBlock (x9D, xB1, x5C, xF6) .\n  eq [530]: x9E2E7B36 = buildBlock (x9E, x2E, x7B, x36) .\n  eq [531]: xA018C83B = buildBlock (xA0, x18, xC8, x3B) .\n  eq [532]: xA0B87B77 = buildBlock (xA0, xB8, x7B, x77) .\n  eq [533]: xA44AAAC0 = buildBlock (xA4, x4A, xAA, xC0) .\n  eq [534]: xA511987A = buildBlock (xA5, x11, x98, x7A) .\n  eq [535]: xA70FC148 = buildBlock (xA7, x0F, xC1, x48) .\n  eq [536]: xA93BD410 = buildBlock (xA9, x3B, xD4, x10) .\n  eq [537]: xAAAAAAAA = buildBlock (xAA, xAA, xAA, xAA) .\n  eq [538]: xAB00FFCD = buildBlock (xAB, x00, xFF, xCD) .\n  eq [539]: xAB01FCCD = buildBlock (xAB, x01, xFC, xCD) .\n  eq [540]: xAB6EED4A = buildBlock (xAB, x6E, xED, x4A) .\n  eq [541]: xABEEED6B = buildBlock (xAB, xEE, xED, x6B) .\n  eq [542]: xACBC13DD = buildBlock (xAC, xBC, x13, xDD) .\n  eq [543]: xB1CC1CC5 = buildBlock (xB1, xCC, x1C, xC5) .\n  eq [544]: xB8142629 = buildBlock (xB8, x14, x26, x29) .\n  eq [545]: xB99A62DE = buildBlock (xB9, x9A, x62, xDE) .\n  eq [546]: xBA92DB12 = buildBlock (xBA, x92, xDB, x12) .\n  eq [547]: xBBA57835 = buildBlock (xBB, xA5, x78, x35) .\n  eq [548]: xBE9F0917 = buildBlock (xBE, x9F, x09, x17) .\n  eq [549]: xBF2D7D85 = buildBlock (xBF, x2D, x7D, x85) .\n  eq [550]:  xBFEF7FDF = buildBlock (xBF, xEF, x7F, xDF) .\n  eq [551]: xC1ED90DD = buildBlock (xC1, xED, x90, xDD) .\n  eq [552]: xC21A1846 = buildBlock (xC2, x1A, x18, x46) .\n  eq [553]: xC4EB1AEB = buildBlock (xC4, xEB, x1A, xEB) .\n  eq [554]: xC6B1317E = buildBlock (xC6, xB1, x31, x7E) .\n  eq [555]: xCBC865BA = buildBlock (xCB, xC8, x65, xBA) .\n  eq [556]: xCD959B46 = buildBlock (xCD, x95, x9B, x46) .\n  eq [557]: xD0482465 = buildBlock (xD0, x48, x24, x65) .\n  eq [558]: xD636250D = buildBlock (xD6, x36, x25, x0D) .\n  eq [559]: xD7843FDC = buildBlock (xD7, x84, x3F, xDC) .\n  eq [560]: xD78634BC = buildBlock (xD7, x86, x34, xBC) .\n  eq [561]: xD8804CA5 = buildBlock (xD8, x80, x4C, xA5) .\n  eq [562]: xDB79FBDC = buildBlock (xDB, x79, xFB, xDC) .\n  eq [563]: xDB9102B0 = buildBlock (xDB, x91, x02, xB0) .\n  eq [564]: xE0C08000 = buildBlock (xE0, xC0, x80, x00) .\n  eq [565]: xE6A12F07 = buildBlock (xE6, xA1, x2F, x07) .\n  eq [566]: xEB35B97F = buildBlock (xEB, x35, xB9, x7F) .\n  eq [567]: xF0239DD5 = buildBlock (xF0, x23, x9D, xD5) .\n  eq [568]: xF14D6E28 = buildBlock (xF1, x4D, x6E, x28) .\n  eq [569]: xF2EF3501 = buildBlock (xF2, xEF, x35, x01) .\n  eq [570]: xF6A09667 = buildBlock (xF6, xA0, x96, x67) .\n  eq [571]: xFD297DA4 = buildBlock (xFD, x29, x7D, xA4) .\n  eq [572]: xFDC1A8BA = buildBlock (xFD, xC1, xA8, xBA) .\n  eq [573]: xFE4E5BDD = buildBlock (xFE, x4E, x5B, xDD) .\n  eq [574]: xFEA1D334 = buildBlock (xFE, xA1, xD3, x34) .\n  eq [575]: xFECCAA6E = buildBlock (xFE, xCC, xAA, x6E) .\n  eq [576]: xFEFC07F0 = buildBlock (xFE, xFC, x07, xF0) .\n  eq [577]: xFF2D7DA5 = buildBlock (xFF, x2D, x7D, xA5) .\n  eq [578]: xFFEF0001 = buildBlock (xFF, xEF, x00, x01) .\n  eq [579]: xFFFF00FF = buildBlock (xFF, xFF, x00, xFF) .\n  eq [580]: xFFFFFF2D = buildBlock (xFF, xFF, xFF, x2D) .\n  eq [581]: xFFFFFF3A = buildBlock (xFF, xFF, xFF, x3A) .\n  eq [582]: xFFFFFFF0 = buildBlock (xFF, xFF, xFF, xF0) .\n  eq [583]: xFFFFFFF1 = buildBlock (xFF, xFF, xFF, xF1) .\n  eq [584]: xFFFFFFF4 = buildBlock (xFF, xFF, xFF, xF4) .\n  eq [585]: xFFFFFFF5 = buildBlock (xFF, xFF, xFF, xF5) .\n  eq [586]: xFFFFFFF7 = buildBlock (xFF, xFF, xFF, xF7) .\n  eq [587]: xFFFFFFF9 = buildBlock (xFF, xFF, xFF, xF9) .\n  eq [588]: xFFFFFFFA = buildBlock (xFF, xFF, xFF, xFA) .\n  eq [589]: xFFFFFFFB = buildBlock (xFF, xFF, xFF, xFB) .\n  eq [590]: xFFFFFFFC = buildBlock (xFF, xFF, xFF, xFC) .\n  eq [591]: xFFFFFFFD = buildBlock (xFF, xFF, xFF, xFD) .\n  eq [592]: xFFFFFFFE = buildBlock (xFF, xFF, xFF, xFE) .\n  eq [593]: xFFFFFFFF = buildBlock (xFF, xFF, xFF, xFF) .\n  eq [594]: appendMessage (unitMessage (W:Block), W-prime:Block) = consMessage (W:Block, unitMessage (W-prime:Block)) .\n  eq [595]: appendMessage (consMessage (W:Block, M:Message), W-prime:Block) = consMessage (W:Block, appendMessage (M:Message, W-prime:Block)) .\n  eq [596]: reverseMessage (unitMessage (W:Block)) = unitMessage (W:Block) .\n  eq [597]: reverseMessage (consMessage (W:Block, M:Message)) = appendMessage (reverseMessage (M:Message), W:Block) .\n ceq [598]: makeMessage (succ (N:Nat), W:Block, W-prime:Block) = unitMessage (W:Block) if eqNat (N:Nat, zero) = Xtrue .\n ceq [599]: makeMessage (succ (N:Nat), W:Block, W-prime:Block) = consMessage (W:Block, makeMessage (N:Nat, ADD (W:Block, W-prime:Block), W-prime:Block)) if eqNat (N:Nat, zero) = Xfalse .\n  eq [600]: ADD (W:Block, W-prime:Block) = addBlock (W:Block, W-prime:Block) .\n  eq [601]: AND (W:Block, W-prime:Block) = andBlock (W:Block, W-prime:Block) .\n  eq [602]: MUL (W:Block, W-prime:Block) = mulBlock (W:Block, W-prime:Block) .\n  eq [603]: OR (W:Block, W-prime:Block) = orBlock (W:Block, W-prime:Block) .\n  eq [604]: XOR (W:Block, W-prime:Block) = xorBlock (W:Block, W-prime:Block) .\n  eq [605]: XOR-prime (buildPair (W:Block, W-prime:Block)) = XOR (W:Block, W-prime:Block) .\n  eq [606]: CYC (buildBlock (buildOctet (B1:Bit, B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit), buildOctet (B9:Bit, B10:Bit, B11:Bit, B12:Bit, B13:Bit, B14:Bit, B15:Bit, B16:Bit), buildOctet (B17:Bit, B18:Bit, B19:Bit, B20:Bit, B21:Bit, B22:Bit, B23:Bit, B24:Bit), buildOctet (B25:Bit, B26:Bit, B27:Bit, B28:Bit, B29:Bit, B30:Bit, B31:Bit, B32:Bit))) = buildBlock (buildOctet (B2:Bit, B3:Bit, B4:Bit, B5:Bit, B6:Bit, B7:Bit, B8:Bit, B9:Bit), buildOctet (B10:Bit, B11:Bit, B12:Bit, B13:Bit, B14:Bit, B15:Bit, B16:Bit, B17:Bit), buildOctet (B18:Bit, B19:Bit, B20:Bit, B21:Bit, B22:Bit, B23:Bit, B24:Bit, B25:Bit), buildOctet (B26:Bit, B27:Bit, B28:Bit, B29:Bit, B30:Bit, B31:Bit, B32:Bit, B1:Bit)) .\n  eq [607]: nCYC (zero, W:Block) = W:Block .\n  eq [608]: nCYC (succ (N:Nat), W:Block) = CYC (nCYC (N:Nat, W:Block)) .\n  eq [609]: FIX1 (W:Block) = AND (OR (W:Block, x02040801), xBFEF7FDF) .\n  eq [610]: FIX2 (W:Block) = AND (OR (W:Block, x00804021), x7DFEFBFF) .\n  eq [611]: needAdjust (O:Octet) = orBool (eqOctet (O:Octet, x00), eqOctet (O:Octet, xFF)) .\n ceq [612]: adjustCode (O:Octet) = x1 if needAdjust (O:Octet) = Xtrue .\n ceq [613]: adjustCode (O:Octet) = x0 if needAdjust (O:Octet) = Xfalse .\n ceq [614]: adjust (O:Octet, O-prime:Octet) = xorOctet (O:Octet, O-prime:Octet) if needAdjust (O:Octet) = Xtrue .\n ceq [615]: adjust (O:Octet, O-prime:Octet) = O:Octet if needAdjust (O:Octet) = Xfalse .\n  eq [616]: PAT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = buildOctet (adjustCode (O1:Octet), adjustCode (O2:Octet), adjustCode (O3:Octet), adjustCode (O4:Octet), adjustCode (O-prime1:Octet), adjustCode (O-prime2:Octet), adjustCode (O-prime3:Octet), adjustCode (O-prime4:Octet)) .\n  eq [617]: BYT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet)) = BYT-prime (O1:Octet, O2:Octet, O3:Octet, O4:Octet, O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet, PAT (buildBlock (O1:Octet, O2:Octet, O3:Octet, O4:Octet), buildBlock (O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet))) .\n  eq [618]: BYT-prime (O1:Octet, O2:Octet, O3:Octet, O4:Octet, O-prime1:Octet, O-prime2:Octet, O-prime3:Octet, O-prime4:Octet, Opat:Octet) = buildPair (buildBlock (adjust (O1:Octet, rightOctet7 (Opat:Octet)), adjust (O2:Octet, rightOctet6 (Opat:Octet)), adjust (O3:Octet, rightOctet5 (Opat:Octet)), adjust (O4:Octet, rightOctet4 (Opat:Octet))), buildBlock (adjust (O-prime1:Octet, rightOctet3 (Opat:Octet)), adjust (O-prime2:Octet, rightOctet2 (Opat:Octet)), adjust (O-prime3:Octet, rightOctet1 (Opat:Octet)), adjust (O-prime4:Octet, Opat:Octet))) .\n  eq [619]: ADDC (W:Block, W-prime:Block) = ADDC-prime (addBlockSum (W:Block, W-prime:Block)) .\n  eq [620]: ADDC-prime (buildBlockSum (x0, W:Block)) = buildPair (x00000000, W:Block) .\n  eq [621]: ADDC-prime (buildBlockSum (x1, W:Block)) = buildPair (x00000001, W:Block) .\n  eq [622]: MUL1 (W:Block, W-prime:Block) = MUL1XY (MUL (W:Block, W-prime:Block)) .\n  eq [623]: MUL1XY (buildPair (W:Block, W-prime:Block)) = MUL1UL (W:Block, W-prime:Block) .\n  eq [624]: MUL1UL (W:Block, W-prime:Block) = MUL1SC (ADDC (W:Block, W-prime:Block)) .\n  eq [625]: MUL1SC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, Wcarry:Block) .\n  eq [626]: MUL2 (W:Block, W-prime:Block) = MUL2XY (MUL (W:Block, W-prime:Block)) .\n  eq [627]: MUL2XY (buildPair (W:Block, W-prime:Block)) = MUL2UL (W:Block, W-prime:Block) .\n  eq [628]: MUL2UL (W:Block, W-prime:Block) = MUL2DEL (ADDC (W:Block, W:Block), W-prime:Block) .\n  eq [629]: MUL2DEL (buildPair (Wcarry:Block, W:Block), W-prime:Block) = MUL2FL (ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)), W-prime:Block) .\n  eq [630]: MUL2FL (W:Block, W-prime:Block) = MUL2SC (ADDC (W:Block, W-prime:Block)) .\n  eq [631]: MUL2SC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)) .\n  eq [632]: MUL2A (W:Block, W-prime:Block) = MUL2AXY (MUL (W:Block, W-prime:Block)) .\n  eq [633]: MUL2AXY (buildPair (W:Block, W-prime:Block)) = MUL2AUL (W:Block, W-prime:Block) .\n  eq [634]: MUL2AUL (W:Block, W-prime:Block) = MUL2ADL (ADD (W:Block, W:Block), W-prime:Block) .\n  eq [635]: MUL2ADL (W:Block, W-prime:Block) = MUL2ASC (ADDC (W:Block, W-prime:Block)) .\n  eq [636]: MUL2ASC (buildPair (Wcarry:Block, W:Block)) = ADD (W:Block, ADD (Wcarry:Block, Wcarry:Block)) .\n  eq [637]: squareHalf (H:Half) = mulHalf (H:Half, H:Half) .\n  eq [638]: Q (O:Octet) = squareHalf (addHalf (buildHalf (x00, O:Octet), x0001)) .\n  eq [639]: J1-2 (W:Block) = MUL1 (W:Block, W:Block) .\n  eq [640]: J1-4 (W:Block) = MUL1 (J1-2 (W:Block), J1-2 (W:Block)) .\n  eq [641]: J1-6 (W:Block) = MUL1 (J1-2 (W:Block), J1-4 (W:Block)) .\n  eq [642]: J1-8 (W:Block) = MUL1 (J1-2 (W:Block), J1-6 (W:Block)) .\n  eq [643]: J2-2 (W:Block) = MUL2 (W:Block, W:Block) .\n  eq [644]: J2-4 (W:Block) = MUL2 (J2-2 (W:Block), J2-2 (W:Block)) .\n  eq [645]: J2-6 (W:Block) = MUL2 (J2-2 (W:Block), J2-4 (W:Block)) .\n  eq [646]: J2-8 (W:Block) = MUL2 (J2-2 (W:Block), J2-6 (W:Block)) .\n  eq [647]: K1-2 (W:Block) = MUL1 (W:Block, W:Block) .\n  eq [648]: K1-4 (W:Block) = MUL1 (K1-2 (W:Block), K1-2 (W:Block)) .\n  eq [649]: K1-5 (W:Block) = MUL1 (W:Block, K1-4 (W:Block)) .\n  eq [650]: K1-7 (W:Block) = MUL1 (K1-2 (W:Block), K1-5 (W:Block)) .\n  eq [651]: K1-9 (W:Block) = MUL1 (K1-2 (W:Block), K1-7 (W:Block)) .\n  eq [652]: K2-2 (W:Block) = MUL2 (W:Block, W:Block) .\n  eq [653]: K2-4 (W:Block) = MUL2 (K2-2 (W:Block), K2-2 (W:Block)) .\n  eq [654]: K2-5 (W:Block) = MUL2 (W:Block, K2-4 (W:Block)) .\n  eq [655]: K2-7 (W:Block) = MUL2 (K2-2 (W:Block), K2-5 (W:Block)) .\n  eq [656]: K2-9 (W:Block) = MUL2 (K2-2 (W:Block), K2-7 (W:Block)) .\n  eq [657]: H4 (W:Block) = XOR (J1-4 (W:Block), J2-4 (W:Block)) .\n  eq [658]: H6 (W:Block) = XOR (J1-6 (W:Block), J2-6 (W:Block)) .\n  eq [659]: H8 (W:Block) = XOR (J1-8 (W:Block), J2-8 (W:Block)) .\n  eq [660]: H0 (W:Block) = XOR (K1-5 (W:Block), K2-5 (W:Block)) .\n  eq [661]: H5 (W:Block, O:Octet) = MUL2 (H0 (W:Block), Q (O:Octet)) .\n  eq [662]: H7 (W:Block) = XOR (K1-7 (W:Block), K2-7 (W:Block)) .\n  eq [663]: H9 (W:Block) = XOR (K1-9 (W:Block), K2-9 (W:Block)) .\n  eq [664]: splitSegment (unitMessage (W:Block)) = unitSegment (unitMessage (W:Block)) .\n  eq [665]: splitSegment (consMessage (W:Block, M:Message)) = cutSegment (M:Message, unitMessage (W:Block), n254) .\n  eq [666]: cutSegment (unitMessage (W:Block), M-prime:Message, N:Nat) = unitSegment (reverseMessage (consMessage (W:Block, M-prime:Message))) .\n  eq [667]: cutSegment (consMessage (W:Block, M:Message), M-prime:Message, zero) = consSegment (reverseMessage (consMessage (W:Block, M-prime:Message)), splitSegment (M:Message)) .\n  eq [668]: cutSegment (consMessage (W:Block, M:Message), M-prime:Message, succ (N:Nat)) = cutSegment (M:Message, consMessage (W:Block, M-prime:Message), N:Nat) .\n  eq [669]: preludeXY (W1:Block, W2:Block) = preludeXY-prime (BYT (W1:Block, W2:Block), PAT (W1:Block, W2:Block)) .\n  eq [670]: preludeVW (W1:Block, W2:Block) = preludeVW-prime (BYT (W1:Block, W2:Block)) .\n  eq [671]: preludeST (W1:Block, W2:Block) = preludeST-prime (BYT (W1:Block, W2:Block)) .\n  eq [672]: preludeXY-prime (buildPair (W:Block, W-prime:Block), O:Octet) = BYT (H4 (W:Block), H5 (W-prime:Block, O:Octet)) .\n  eq [673]: preludeVW-prime (buildPair (W:Block, W-prime:Block)) = BYT (H6 (W:Block), H7 (W-prime:Block)) .\n  eq [674]: preludeST-prime (buildPair (W:Block, W-prime:Block)) = BYT (H8 (W:Block), H9 (W-prime:Block)) .\n  eq [675]: computeXY (P:Pair, P-prime:Pair, W:Block) = computeXY-prime (P:Pair, W:Block, XOR-prime (computeVW (P-prime:Pair))) .\n  eq [676]: computeXY-prime (buildPair (W1:Block, W2:Block), W:Block, W-prime:Block) = buildPair (MUL1 (XOR (W1:Block, W:Block), FIX1 (ADD (XOR (W2:Block, W:Block), W-prime:Block))), MUL2A (XOR (W2:Block, W:Block), FIX2 (ADD (XOR (W1:Block, W:Block), W-prime:Block)))) .\n  eq [677]: computeVW (buildPair (W1:Block, W2:Block)) = buildPair (CYC (W1:Block), W2:Block) .\n  eq [678]: loop1 (P:Pair, P-prime:Pair, unitMessage (W:Block)) = computeXY (P:Pair, P-prime:Pair, W:Block) .\n  eq [679]: loop1 (P:Pair, P-prime:Pair, consMessage (W:Block, M:Message)) = loop1 (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), M:Message) .\n  eq [680]: loop2 (P:Pair, P-prime:Pair, unitMessage (W:Block)) = computeVW (P-prime:Pair) .\n  eq [681]: loop2 (P:Pair, P-prime:Pair, consMessage (W:Block, M:Message)) = loop2 (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), M:Message) .\n  eq [682]: coda (P:Pair, P-prime:Pair, buildPair (W:Block, W-prime:Block)) = XOR-prime (computeXY (computeXY (P:Pair, P-prime:Pair, W:Block), computeVW (P-prime:Pair), W-prime:Block)) .\n  eq [683]: MAA (buildKey (W1:Block, W2:Block), M:Message) = MAA-prime (preludeXY (W1:Block, W2:Block), preludeVW (W1:Block, W2:Block), preludeST (W1:Block, W2:Block), M:Message) .\n  eq [684]: MAA-prime (P1:Pair, P2:Pair, P3:Pair, M:Message) = coda (loop1 (P1:Pair, P2:Pair, M:Message), loop2 (P1:Pair, P2:Pair, M:Message), P3:Pair) .\n  eq [685]: MAC (K:Key, M:Message) = MACfirst (K:Key, splitSegment (M:Message)) .\n  eq [686]: MACfirst (K:Key, unitSegment (M:Message)) = MAA (K:Key, M:Message) .\n  eq [687]: MACfirst (K:Key, consSegment (M:Message, S:SegmentedMessage)) = MACnext (K:Key, MAA (K:Key, M:Message), S:SegmentedMessage) .\n  eq [688]: MACnext (K:Key, W:Block, unitSegment (M:Message)) = MAA (K:Key, consMessage (W:Block, M:Message)) .\n  eq [689]: MACnext (K:Key, W:Block, consSegment (M:Message, S:SegmentedMessage)) = MACnext (K:Key, MAA (K:Key, consMessage (W:Block, M:Message)), S:SegmentedMessage) .\nendfm\neof\nreduce eqBlock (MUL1 (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL1 (xFFFFFFF0, x0000000E), xFFFFFF2D) .\nreduce eqBlock (MUL1 (xFFFFFFF0, xFFFFFFF1), x000000D2) .\nreduce eqBlock (MUL2 (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL2 (xFFFFFFF0, x0000000E), xFFFFFF3A) .\nreduce eqBlock (MUL2 (xFFFFFFF0, xFFFFFFF1), x000000B6) .\nreduce eqBlock (MUL2A (x0000000F, x0000000E), x000000D2) .\nreduce eqBlock (MUL2A (xFFFFFFF0, x0000000E), xFFFFFF3A) .\nreduce eqBlock (MUL2A (x7FFFFFF0, xFFFFFFF1), x800000C2) .\nreduce eqBlock (MUL2A (xFFFFFFF0, x7FFFFFF1), x000000C4) .\nreduce eqPair (BYT (x00000000, x00000000), buildPair (x0103070F, x1F3F7FFF)) .\nreduce eqPair (BYT (xFFFF00FF, xFFFFFFFF), buildPair (xFEFC07F0, xE0C08000)) .\nreduce eqPair (BYT (xAB00FFCD, xFFEF0001), buildPair (xAB01FCCD, xF2EF3501)) .\nreduce eqOctet (PAT (x00000000, x00000000), xFF) .\nreduce eqOctet (PAT (xFFFF00FF, xFFFFFFFF), xFF) .\nreduce eqOctet (PAT (xAB00FFCD, xFFEF0001), x6A) .\nreduce eqBlock (J1-2 (x00000100), x00010000) .\nreduce eqBlock (J1-4 (x00000100), x00000001) .\nreduce eqBlock (J1-6 (x00000100), x00010000) .\nreduce eqBlock (J1-8 (x00000100), x00000001) .\nreduce eqBlock (J2-2 (x00000100), x00010000) .\nreduce eqBlock (J2-4 (x00000100), x00000002) .\nreduce eqBlock (J2-6 (x00000100), x00020000) .\nreduce eqBlock (J2-8 (x00000100), x00000004) .\nreduce eqBlock (H4 (x00000100), x00000003) .\nreduce eqBlock (H6 (x00000100), x00030000) .\nreduce eqBlock (H8 (x00000100), x00000005) .\nreduce eqBlock (K1-2 (x00000080), x00004000) .\nreduce eqBlock (K1-4 (x00000080), x10000000) .\nreduce eqBlock (K1-5 (x00000080), x00000008) .\nreduce eqBlock (K1-7 (x00000080), x00020000) .\nreduce eqBlock (K1-9 (x00000080), x80000000) .\nreduce eqBlock (K2-2 (x00000080), x00004000) .\nreduce eqBlock (K2-4 (x00000080), x10000000) .\nreduce eqBlock (K2-5 (x00000080), x00000010) .\nreduce eqBlock (K2-7 (x00000080), x00040000) .\nreduce eqBlock (K2-9 (x00000080), x00000002) .\nreduce eqBlock (H0 (x00000080), x00000018) .\nreduce eqBlock (Q (x01), x00000004) .\nreduce eqBlock (H5 (x00000080, x01), x00000060) .\nreduce eqBlock (H7 (x00000080), x00060000) .\nreduce eqBlock (H9 (x00000080), x80000002) .\nreduce eqOctet (PAT (x00000003, x00000060), xEE) .\nreduce eqOctet (PAT (x00030000, x00060000), xBB) .\nreduce eqOctet (PAT (x00000005, x80000002), xE6) .\nreduce eqPair (BYT (x00000003, x00000060), buildPair (x01030703, x1D3B7760)) .\nreduce eqPair (BYT (x00030000, x00060000), buildPair (x0103050B, x17065DBB)) .\nreduce eqPair (BYT (x00000005, x80000002), buildPair (x01030705, x80397302)) .\nreduce eqBlock (CYC (x00000003), x00000006) .\nreduce eqBlock (XOR (x00000006, x00000003), x00000005) .\nreduce eqBlock (XOR (x00000002, x00000005), x00000007) .\nreduce eqBlock (XOR (x00000003, x00000005), x00000006) .\nreduce eqBlock (ADD (x00000005, x00000006), x0000000B) .\nreduce eqBlock (ADD (x00000005, x00000007), x0000000C) .\nreduce eqBlock (OR (x0000000B, x00000004), x0000000F) .\nreduce eqBlock (OR (x0000000C, x00000001), x0000000D) .\nreduce eqBlock (AND (x0000000F, xFFFFFFF7), x00000007) .\nreduce eqBlock (AND (x0000000D, xFFFFFFFB), x00000009) .\nreduce eqBlock (MUL1 (x00000007, x00000007), x00000031) .\nreduce eqBlock (MUL2A (x00000006, x00000009), x00000036) .\nreduce eqBlock (XOR (x00000031, x00000036), x00000007) .\nreduce eqBlock (CYC (x00000003), x00000006) .\nreduce eqBlock (XOR (x00000006, x00000003), x00000005) .\nreduce eqBlock (XOR (xFFFFFFFD, x00000001), xFFFFFFFC) .\nreduce eqBlock (XOR (xFFFFFFFC, x00000001), xFFFFFFFD) .\nreduce eqBlock (ADD (x00000005, xFFFFFFFD), x00000002) .\nreduce eqBlock (ADD (x00000005, xFFFFFFFC), x00000001) .\nreduce eqBlock (OR (x00000002, x00000001), x00000003) .\nreduce eqBlock (OR (x00000001, x00000004), x00000005) .\nreduce eqBlock (AND (x00000003, xFFFFFFF9), x00000001) .\nreduce eqBlock (AND (x00000005, xFFFFFFFC), x00000004) .\nreduce eqBlock (MUL1 (xFFFFFFFC, x00000001), xFFFFFFFC) .\nreduce eqBlock (MUL2A (xFFFFFFFD, x00000004), xFFFFFFFA) .\nreduce eqBlock (XOR (xFFFFFFFC, xFFFFFFFA), x00000006) .\nreduce eqBlock (CYC (x00000007), x0000000E) .\nreduce eqBlock (XOR (x0000000E, x00000007), x00000009) .\nreduce eqBlock (XOR (xFFFFFFFD, x00000008), xFFFFFFF5) .\nreduce eqBlock (XOR (xFFFFFFFC, x00000008), xFFFFFFF4) .\nreduce eqBlock (ADD (x00000009, xFFFFFFF4), xFFFFFFFD) .\nreduce eqBlock (ADD (x00000009, xFFFFFFF5), xFFFFFFFE) .\nreduce eqBlock (OR (xFFFFFFFD, x00000001), xFFFFFFFD) .\nreduce eqBlock (OR (xFFFFFFFE, x00000002), xFFFFFFFE) .\nreduce eqBlock (AND (xFFFFFFFD, xFFFFFFFE), xFFFFFFFC) .\nreduce eqBlock (AND (xFFFFFFFE, x7FFFFFFD), x7FFFFFFC) .\nreduce eqBlock (MUL1 (xFFFFFFF5, xFFFFFFFC), x0000001E) .\nreduce eqBlock (MUL2A (xFFFFFFF4, x7FFFFFFC), x0000001E) .\nreduce eqBlock (XOR (x0000001E, x0000001E), x00000000) .\nreduce eqBlock (CYC (x00000001), x00000002) .\nreduce eqBlock (XOR (x00000002, x00000001), x00000003) .\nreduce eqBlock (XOR (x00000001, x00000000), x00000001) .\nreduce eqBlock (XOR (x00000002, x00000000), x00000002) .\nreduce eqBlock (ADD (x00000003, x00000002), x00000005) .\nreduce eqBlock (ADD (x00000003, x00000001), x00000004) .\nreduce eqBlock (OR (x00000005, x00000002), x00000007) .\nreduce eqBlock (OR (x00000004, x00000001), x00000005) .\nreduce eqBlock (AND (x00000007, xFFFFFFFB), x00000003) .\nreduce eqBlock (AND (x00000005, xFFFFFFFB), x00000001) .\nreduce eqBlock (MUL1 (x00000001, x00000003), x00000003) .\nreduce eqBlock (MUL2A (x00000002, x00000001), x00000002) .\nreduce eqBlock (XOR (x00000003, x00000002), x00000001) .\nreduce eqBlock (CYC (x00000002), x00000004) .\nreduce eqBlock (XOR (x00000004, x00000001), x00000005) .\nreduce eqBlock (XOR (x00000003, x00000001), x00000002) .\nreduce eqBlock (XOR (x00000002, x00000001), x00000003) .\nreduce eqBlock (ADD (x00000005, x00000003), x00000008) .\nreduce eqBlock (ADD (x00000005, x00000002), x00000007) .\nreduce eqBlock (OR (x00000008, x00000002), x0000000A) .\nreduce eqBlock (OR (x00000007, x00000001), x00000007) .\nreduce eqBlock (AND (x0000000A, xFFFFFFFB), x0000000A) .\nreduce eqBlock (AND (x00000007, xFFFFFFFB), x00000003) .\nreduce eqBlock (MUL1 (x00000002, x0000000A), x00000014) .\nreduce eqBlock (MUL2A (x00000003, x00000003), x00000009) .\nreduce eqBlock (XOR (x00000014, x00000009), x0000001D) .\nreduce eqBlock (CYC (x00000004), x00000008) .\nreduce eqBlock (XOR (x00000008, x00000001), x00000009) .\nreduce eqBlock (XOR (x00000014, x00000002), x00000016) .\nreduce eqBlock (XOR (x00000009, x00000002), x0000000B) .\nreduce eqBlock (ADD (x00000009, x0000000B), x00000014) .\nreduce eqBlock (ADD (x00000009, x00000016), x0000001F) .\nreduce eqBlock (OR (x00000014, x00000002), x00000016) .\nreduce eqBlock (OR (x0000001F, x00000001), x0000001F) .\nreduce eqBlock (AND (x00000016, xFFFFFFFB), x00000012) .\nreduce eqBlock (AND (x0000001F, xFFFFFFFB), x0000001B) .\nreduce eqBlock (MUL1 (x00000016, x00000012), x0000018C) .\nreduce eqBlock (MUL2A (x0000000B, x0000001B), x00000129) .\nreduce eqBlock (XOR (x0000018C, x00000129), x000000A5) .\nreduce eqBlock (CYC (xC4EB1AEB), x89D635D7) .\nreduce eqBlock (XOR (x89D635D7, xF6A09667), x7F76A3B0) .\nreduce eqBlock (XOR (x21D869BA, x0A202020), x2BF8499A) .\nreduce eqBlock (XOR (x7792F9D4, x0A202020), x7DB2D9F4) .\nreduce eqBlock (ADD (x7F76A3B0, x7DB2D9F4), xFD297DA4) .\nreduce eqBlock (ADD (x7F76A3B0, x2BF8499A), xAB6EED4A) .\nreduce eqBlock (OR (xFD297DA4, x02040801), xFF2D7DA5) .\nreduce eqBlock (OR (xAB6EED4A, x00804021), xABEEED6B) .\nreduce eqBlock (AND (xFF2D7DA5, xBFEF7FDF), xBF2D7D85) .\nreduce eqBlock (AND (xABEEED6B, x7DFEFBFF), x29EEE96B) .\nreduce eqBlock (MUL1 (x2BF8499A, xBF2D7D85), x0AD67E20) .\nreduce eqBlock (MUL2A (x7DB2D9F4, x29EEE96B), x30261492) .\nreduce eqOctet (PAT (x00FF00FF, x00000000), xFF) .\nreduce eqPair (preludeXY (x00FF00FF, x00000000), buildPair (x4A645A01, x50DEC930)) .\nreduce eqPair (preludeVW (x00FF00FF, x00000000), buildPair (x5CCA3239, xFECCAA6E)) .\nreduce eqPair (preludeST (x00FF00FF, x00000000), buildPair (x51EDE9C7, x24B66FB5)) .\nreduce eqPair (computeXY-prime (buildPair (x4A645A01, x50DEC930), x55555555, XOR (nCYC (n1, x5CCA3239), xFECCAA6E)), buildPair (x48B204D6, x5834A585)) .\nreduce eqPair (computeXY-prime (buildPair (x48B204D6, x5834A585), xAAAAAAAA, XOR (nCYC (n2, x5CCA3239), xFECCAA6E)), buildPair (x4F998E01, xBE9F0917)) .\nreduce eqPair (computeXY-prime (buildPair (x4F998E01, xBE9F0917), x51EDE9C7, XOR (nCYC (n3, x5CCA3239), xFECCAA6E)), buildPair (x344925FC, xDB9102B0)) .\nreduce eqPair (computeXY-prime (buildPair (x344925FC, xDB9102B0), x24B66FB5, XOR (nCYC (n4, x5CCA3239), xFECCAA6E)), buildPair (x277B4B25, xD636250D)) .\nreduce eqBlock (XOR (x277B4B25, xD636250D), xF14D6E28) .\nreduce eqOctet (PAT (x00FF00FF, x00000000), xFF) .\nreduce eqPair (preludeXY (x00FF00FF, x00000000), buildPair (x4A645A01, x50DEC930)) .\nreduce eqPair (preludeVW (x00FF00FF, x00000000), buildPair (x5CCA3239, xFECCAA6E)) .\nreduce eqPair (preludeST (x00FF00FF, x00000000), buildPair (x51EDE9C7, x24B66FB5)) .\nreduce eqPair (computeXY-prime (buildPair (x4A645A01, x50DEC930), xAAAAAAAA, XOR (nCYC (n1, x5CCA3239), xFECCAA6E)), buildPair (x6AEBACF8, x9DB15CF6)) .\nreduce eqPair (computeXY-prime (buildPair (x6AEBACF8, x9DB15CF6), x55555555, XOR (nCYC (n2, x5CCA3239), xFECCAA6E)), buildPair (x270EEDAF, xB8142629)) .\nreduce eqPair (computeXY-prime (buildPair (x270EEDAF, xB8142629), x51EDE9C7, XOR (nCYC (n3, x5CCA3239), xFECCAA6E)), buildPair (x29907CD8, xBA92DB12)) .\nreduce eqPair (computeXY-prime (buildPair (x29907CD8, xBA92DB12), x24B66FB5, XOR (nCYC (n4, x5CCA3239), xFECCAA6E)), buildPair (x28EAD8B3, x81D10CA3)) .\nreduce eqBlock (XOR (x28EAD8B3, x81D10CA3), xA93BD410) .\nreduce eqOctet (PAT (x55555555, x5A35D667), x00) .\nreduce eqPair (preludeXY (x55555555, x5A35D667), buildPair (x34ACF886, x7397C9AE)) .\nreduce eqPair (preludeVW (x55555555, x5A35D667), buildPair (x7201F4DC, x2829040B)) .\nreduce eqPair (preludeST (x55555555, x5A35D667), buildPair (x9E2E7B36, x13647149)) .\nreduce eqPair (computeXY-prime (buildPair (x34ACF886, x7397C9AE), x00000000, XOR (nCYC (n1, x7201F4DC), x2829040B)), buildPair (x2FD76FFB, x550D91CE)) .\nreduce eqPair (computeXY-prime (buildPair (x2FD76FFB, x550D91CE), xFFFFFFFF, XOR (nCYC (n2, x7201F4DC), x2829040B)), buildPair (xA70FC148, x1D10D8D3)) .\nreduce eqPair (computeXY-prime (buildPair (xA70FC148, x1D10D8D3), x9E2E7B36, XOR (nCYC (n3, x7201F4DC), x2829040B)), buildPair (xB1CC1CC5, x29C1485F)) .\nreduce eqPair (computeXY-prime (buildPair (xB1CC1CC5, x29C1485F), x13647149, XOR (nCYC (n4, x7201F4DC), x2829040B)), buildPair (x288FC786, x9115A558)) .\nreduce eqBlock (XOR (x288FC786, x9115A558), xB99A62DE) .\nreduce eqOctet (PAT (x55555555, x5A35D667), x00) .\nreduce eqPair (preludeXY (x55555555, x5A35D667), buildPair (x34ACF886, x7397C9AE)) .\nreduce eqPair (preludeVW (x55555555, x5A35D667), buildPair (x7201F4DC, x2829040B)) .\nreduce eqPair (preludeST (x55555555, x5A35D667), buildPair (x9E2E7B36, x13647149)) .\nreduce eqPair (computeXY-prime (buildPair (x34ACF886, x7397C9AE), xFFFFFFFF, XOR (nCYC (n1, x7201F4DC), x2829040B)), buildPair (x8DC8BBDE, xFE4E5BDD)) .\nreduce eqPair (computeXY-prime (buildPair (x8DC8BBDE, xFE4E5BDD), x00000000, XOR (nCYC (n2, x7201F4DC), x2829040B)), buildPair (xCBC865BA, x0297AF6F)) .\nreduce eqPair (computeXY-prime (buildPair (xCBC865BA, x0297AF6F), x9E2E7B36, XOR (nCYC (n3, x7201F4DC), x2829040B)), buildPair (x3CF3A7D2, x160EE9B5)) .\nreduce eqPair (computeXY-prime (buildPair (x3CF3A7D2, x160EE9B5), x13647149, XOR (nCYC (n4, x7201F4DC), x2829040B)), buildPair (xD0482465, x7050EC5E)) .\nreduce eqBlock (XOR (xD0482465, x7050EC5E), xA018C83B) .\nreduce eqPair (preludeXY (xE6A12F07, x9D15C437), buildPair (x21D869BA, x7792F9D4)) .\nreduce eqPair (preludeVW (xE6A12F07, x9D15C437), buildPair (xC4EB1AEB, xF6A09667)) .\nreduce eqPair (preludeST (xE6A12F07, x9D15C437), buildPair (x6D67E884, xA511987A)) .\nreduce eqPair (computeXY-prime (buildPair (x204E80A7, x077788A2), x00000000, XOR (nCYC (n1, x17A808FD), xFEA1D334)), buildPair (x303FF4AA, x1277A6D4)) .\nreduce eqPair (computeXY-prime (buildPair (x303FF4AA, x1277A6D4), x00000000, XOR (nCYC (n2, x17A808FD), xFEA1D334)), buildPair (x55DD063F, x4C49AAE0)) .\nreduce eqPair (computeXY-prime (buildPair (x55DD063F, x4C49AAE0), x00000000, XOR (nCYC (n3, x17A808FD), xFEA1D334)), buildPair (x51AF3C1D, x5BC02502)) .\nreduce eqPair (computeXY-prime (buildPair (x51AF3C1D, x5BC02502), x00000000, XOR (nCYC (n4, x17A808FD), xFEA1D334)), buildPair (xA44AAAC0, x63C70DBA)) .\nreduce eqPair (computeXY-prime (buildPair (xA44AAAC0, x63C70DBA), x00000000, XOR (nCYC (n5, x17A808FD), xFEA1D334)), buildPair (x4D53901A, x2E80AC30)) .\nreduce eqPair (computeXY-prime (buildPair (x4D53901A, x2E80AC30), x00000000, XOR (nCYC (n6, x17A808FD), xFEA1D334)), buildPair (x5F38EEF1, x2A6091AE)) .\nreduce eqPair (computeXY-prime (buildPair (x5F38EEF1, x2A6091AE), x00000000, XOR (nCYC (n7, x17A808FD), xFEA1D334)), buildPair (xF0239DD5, x3DD81AC6)) .\nreduce eqPair (computeXY-prime (buildPair (xF0239DD5, x3DD81AC6), x00000000, XOR (nCYC (n8, x17A808FD), xFEA1D334)), buildPair (xEB35B97F, x9372CDC6)) .\nreduce eqPair (computeXY-prime (buildPair (xEB35B97F, x9372CDC6), x00000000, XOR (nCYC (n9, x17A808FD), xFEA1D334)), buildPair (x4DA124A1, xC6B1317E)) .\nreduce eqPair (computeXY-prime (buildPair (x4DA124A1, xC6B1317E), x00000000, XOR (nCYC (n10, x17A808FD), xFEA1D334)), buildPair (x7F839576, x74B39176)) .\nreduce eqPair (computeXY-prime (buildPair (x7F839576, x74B39176), x00000000, XOR (nCYC (n11, x17A808FD), xFEA1D334)), buildPair (x11A9D254, xD78634BC)) .\nreduce eqPair (computeXY-prime (buildPair (x11A9D254, xD78634BC), x00000000, XOR (nCYC (n12, x17A808FD), xFEA1D334)), buildPair (xD8804CA5, xFDC1A8BA)) .\nreduce eqPair (computeXY-prime (buildPair (xD8804CA5, xFDC1A8BA), x00000000, XOR (nCYC (n13, x17A808FD), xFEA1D334)), buildPair (x3F6F7248, x11AC46B8)) .\nreduce eqPair (computeXY-prime (buildPair (x3F6F7248, x11AC46B8), x00000000, XOR (nCYC (n14, x17A808FD), xFEA1D334)), buildPair (xACBC13DD, x33D5A466)) .\nreduce eqPair (computeXY-prime (buildPair (xACBC13DD, x33D5A466), x00000000, XOR (nCYC (n15, x17A808FD), xFEA1D334)), buildPair (x4CE933E1, xC21A1846)) .\nreduce eqPair (computeXY-prime (buildPair (x4CE933E1, xC21A1846), x00000000, XOR (nCYC (n16, x17A808FD), xFEA1D334)), buildPair (xC1ED90DD, xCD959B46)) .\nreduce eqPair (computeXY-prime (buildPair (xC1ED90DD, xCD959B46), x00000000, XOR (nCYC (n17, x17A808FD), xFEA1D334)), buildPair (x3CD54DEB, x613F8E2A)) .\nreduce eqPair (computeXY-prime (buildPair (x3CD54DEB, x613F8E2A), x00000000, XOR (nCYC (n18, x17A808FD), xFEA1D334)), buildPair (xBBA57835, x07C72EAA)) .\nreduce eqPair (computeXY-prime (buildPair (xBBA57835, x07C72EAA), x00000000, XOR (nCYC (n19, x17A808FD), xFEA1D334)), buildPair (xD7843FDC, x6AD6E8A4)) .\nreduce eqPair (computeXY-prime (buildPair (xD7843FDC, x6AD6E8A4), x00000000, XOR (nCYC (n20, x17A808FD), xFEA1D334)), buildPair (x5EBA06C2, x91896CFA)) .\nreduce eqPair (computeXY-prime (buildPair (x5EBA06C2, x91896CFA), x76232E5F, XOR (nCYC (n21, x17A808FD), xFEA1D334)), buildPair (x1D9C9655, x98D1CC75)) .\nreduce eqPair (computeXY-prime (buildPair (x1D9C9655, x98D1CC75), x4FB1138A, XOR (nCYC (n22, x17A808FD), xFEA1D334)), buildPair (x7BC180AB, xA0B87B77)) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n20, x00000000, x00000000)), xDB79FBDC) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n16, x00000000, x07050301)), x8CE37709) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n256, x00000000, x07050301)), x717153D5) .\nreduce eqBlock (MAC (buildKey (x80018001, x80018000), makeMessage (n4100, x00000000, x07050301)), x7783C51D) .\nquit"
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "incomplete": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name ____(SUBSORT_0)____ Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : ____(OP_0)____ Msg -> Msg [____(OP_1)____] .\n  op sk : Key ____(OP_2)____ -> Msg [____(OP_3)____] .\n\n  --- Nonce operator\n  op ____(OP_4)____ : Name ____(OP_5)____ -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op ____(OP_7)____ : Msg  Msg  -> Msg [____(OP_8)____ (e E) ____(OP_6)____] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars ____(EQ_7)____ ____(EQ_3)____ Z : ____(VAR_0)____ .\n  vars r ____(VAR_1)____ : Fresh .\n  vars ____(VAR_2)____ B : Name .\n  vars ____(VAR_3)____ N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(____(EQ_6)____), +(____(EQ_2)____ ; Y), nil ] &\n     :: nil :: [ nil | -(X ; ____(EQ_8)____), +(X), nil ] &\n     :: nil :: [ nil | -(X ; ____(EQ_9)____), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(____(EQ_11)____,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; ____(EQ_4)____ ; B)), +(pk(____(EQ_10)____, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,____(EQ_5)____ ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(____(EQ_1)____,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "complete:": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude",
        "incomplete": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < ____(SUBSORT_0)____ .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key ____(OP_0)____ -> Msg [____(OP_1)____] .\n  op sk : ____(OP_3)____ ____(OP_2)____ -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name ____(OP_5)____ -> ____(OP_4)____ [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : ____(OP_6)____  ____(OP_7)____  -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(____(EQ_4)____,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars ____(EQ_10)____ ____(VAR_0)____ Z : Msg .\n  vars r r' : ____(VAR_1)____ .\n  vars A B : ____(VAR_2)____ .\n  vars ____(VAR_3)____ NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(____(EQ_5)____), +(____(EQ_0)____ ; ____(EQ_8)____), nil ] &\n     :: nil :: [ nil | -(____(EQ_3)____ ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(____(EQ_1)____,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(____(EQ_6)____, NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(____(EQ_7)____, NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,____(EQ_9)____ ; NA)), +(pk(a, NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "complete:": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [assoc frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars NA NB : Msg .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; NB ; B)), +(pk(B, NB)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; NA)), +(pk(A, NA ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; NA)), +(pk(a, NA ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/nsl-db-dc.maude",
        "incomplete": "--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < ____(SUBSORT_0)____ .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op ____(OP_0)____ : Name ____(OP_1)____ -> Msg [frozen] .  \n  op sk : Name ____(OP_2)____ -> Msg [____(OP_3)____] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op ____(OP_4)____ : Name Fresh -> ____(OP_5)____ [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : ____(OP_6)____  ____(OP_8)____  -> Msg [gather (e E) ____(OP_7)____] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op ____(EQ_10)____ : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars ____(VAR_0)____ ____(EQ_15)____ Z : Msg .\n  vars ____(VAR_1)____ B : Name .\n  vars ____(VAR_2)____ YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r ____(VAR_4)____ r'' ____(VAR_3)____ : Fresh .\n  vars ____(VAR_5)____ B C : Name .\n  vars ____(VAR_6)____ ____(VAR_7)____ ____(EQ_11)____ N' NC : Nonce .\n  vars ____(EQ_8)____ ____(VAR_8)____ : NonceSet .\n  vars ____(VAR_10)____ Y ____(VAR_9)____ H : Msg .\n  vars P Q : ____(VAR_11)____ .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(____(EQ_1)____), -(Y), +(____(EQ_12)____ ; Y), nil ] &\n     :: nil :: [ nil | -(____(EQ_14)____ ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(____(EQ_13)____,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,____(EQ_19)____)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,____(EQ_3)____)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,____(EQ_0)____) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; ____(EQ_16)____-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(____(EQ_7)____,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,____(EQ_5)____))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(____(EQ_4)____,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,____(EQ_9)____) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(____(EQ_17)____, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,____(EQ_2)____)),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(____(EQ_18)____,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "complete:": "--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < Msg .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Y Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r'' r# : Fresh .\n  vars A B C : Name .\n  vars NA NB N N' NC : Nonce .\n  vars NS NS' : NonceSet .\n  vars X Y Z H : Msg .\n  vars P Q : Name .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; 1-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(B,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(B,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/signed_dh.maude",
        "incomplete": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen ____(SUBSORT_0)____ < GenvExp .\n  subsort Name NeNonceSet ____(SUBSORT_2)____ ____(SUBSORT_1)____ Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op ____(OP_1)____ : Name Fresh -> ____(OP_0)____ [frozen] .\n\n  --- Nonce operator\n  op n : ____(OP_2)____ Fresh -> Nonce [____(OP_3)____] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op ____(OP_4)____ : ____(OP_5)____ Msg -> Msg [frozen] .\n  op d : Key ____(OP_6)____ -> ____(OP_7)____ [frozen] .\n\n  --- Signing\n  op ____(OP_9)____ : Name ____(OP_8)____ -> Msg [frozen] .\n\n  --- Exp\n  op exp : ____(OP_10)____ NeNonceSet -> ____(OP_11)____ [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [____(OP_13)____ assoc ____(OP_12)____] .\n\n  --- Concatenation\n  op _;_ : ____(OP_15)____ Msg -> Msg [frozen ____(OP_14)____ (____(OP_16)____ E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(____(EQ_9)____,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,____(EQ_7)____)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 ____(VAR_0)____ ____(VAR_1)____ : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : ____(VAR_2)____ .\n  vars ____(VAR_4)____ ____(VAR_3)____ r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : ____(VAR_5)____ .\n  vars M M1 ____(VAR_6)____ : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; ____(EQ_18)____), +(M1), nil ] &\n     :: nil :: [ nil | -(____(EQ_28)____ ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(____(EQ_30)____,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,____(EQ_21)____)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(____(EQ_14)____), nil ] &\n     :: nil :: [ nil | -(GE), -(____(EQ_26)____), +(exp(GE,____(EQ_11)____)), nil ] &\n     :: r ::   [ nil | +(n(____(EQ_2)____,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(____(EQ_8)____,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(____(EQ_25)____, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(____(EQ_17)____,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(____(EQ_20)____,r)); sign(a, b ; exp(____(EQ_10)____,n(a,r)))),\n            -(a ; ____(EQ_27)____ ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(____(EQ_22)____,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(____(EQ_16)____,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(____(EQ_24)____,r)),sec(a,____(EQ_23)____))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(____(EQ_19)____,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(____(EQ_5)____, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, ____(EQ_3)____), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "complete:": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/abstract-bakeryAC-checks.maude",
        "incomplete": "*** version of Nov. 10 2017 of abstract-bakery\n\nset include BOOL off .\n\nfmod NAT> is\n  sorts Zero NzNat Nat Bool .\n  subsorts Zero NzNat < Nat .\n  op tt : -> Bool [ctor] .  *** true\n  op ff : -> Bool [ctor] .  *** false\n  op 0 : -> ____(OP_2)____ [ctor] .\n  op 1 : -> ____(OP_3)____ [ctor] .\n  op _+_ : ____(OP_5)____ ____(OP_6)____ -> Nat [ctor assoc comm id: ____(OP_4)____] .\n  op _+_ : ____(OP_7)____ Nat -> NzNat [ctor ____(OP_9)____ comm ____(OP_8)____ 0] .\n  op ____(OP_11)____ : Nat ____(OP_10)____ -> NzNat [____(OP_12)____ assoc comm id: 0] .\n  op _+_ : ____(OP_14)____ NzNat -> NzNat [ctor ____(OP_15)____ ____(OP_13)____ id: 0] .  \n  op _>_ : ____(OP_16)____ Nat -> Bool .\n\n  vars ____(VAR_0)____ m : Nat ____(VAR_1)____  vars n' ____(VAR_2)____ : NzNat .\n\n  eq n + n' > n = tt .\n  eq n > n + m = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n\n  sorts Mode BState .\n\n  ops sleep wait crit : -> Mode [ctor] .\n  op <____(OP_17)____> : ____(OP_18)____ Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n\n  vars ____(VAR_3)____ Q : Mode .\n  vars ____(VAR_4)____ Y : Nat .\n\n  eq initial = < sleep, 0, sleep, 0 > .\n  \n  rl [p1_sleep] : < sleep, X, Q, Y > => < wait, Y + 1, Q, Y > .\n  rl [p1_wait] : < wait, X, Q, 0 > => < crit, X, Q, 0 > .\n  crl [p1_wait] : < wait, X, Q, Y > => < crit, X, Q, Y > if  X > Y = ff .\n  rl [p1_crit] : < crit, X, Q, Y > => < sleep, 0, Q, Y > .\n  \n  rl [p2_sleep] : < P, X, sleep, Y > => < P, X, wait, X + 1  > .\n  rl [p2_wait] : < P, 0, wait, Y > => < P, 0, crit, Y > .\n  crl [p2_wait] : < P, X, wait, Y > => < P, X, crit, Y > if X > Y = tt .\n  rl [p2_crit] : < P, X, crit, Y > => < P, X, sleep, 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n\n  op ____(OP_19)____ : State ____(OP_20)____ -> Bool [frozen] .\n \n  vars P Q : ____(VAR_5)____ .\n  vars X Y : ____(VAR_6)____ .\n\n  eq < wait, X, Q, Y > |= 1wait = tt .\n  eq < sleep, X, Q, Y > |= 1wait = ff .\n  eq < crit, X, Q, Y > |= 1wait = ff .\n  eq < P , X, wait, Y > |= 2wait = tt .\n  eq < P , X, sleep, Y > |= 2wait = ff .\n  eq < P , X, crit, Y > |= 2wait = ff .\n  eq < crit , X, Q, Y > |= 1crit = tt .\n  eq < sleep, X, Q, Y > |= 1crit = ff .\n  eq < wait, X, Q, Y > |= 1crit = ff .\n  eq < P , X, crit, Y > |= 2crit = tt .\n  eq < P , X, sleep, Y > |= 2crit = ff .\n  eq < P , X, wait, Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n\n  ____(VAR_9)____ ____(VAR_8)____ Q ____(VAR_12)____ Mode ____(VAR_7)____  vars X ____(VAR_10)____ : Nat ____(VAR_11)____  vars X' Y' : NzNat .\n\n  eq < P, 0, Q, 1 + Y' > = < P, 0, Q, 1 >  .\n  eq < P, 1 + X', Q, 0 > = < P, 1 , Q, 0 >  .\n  eq < P, 1, Q, 1 + Y' + X' > = < P, 1, Q, 1 + 1 >  .  \n  eq < P, 1 + X' + Y', Q, 1 > = < P, 1 + 1, Q, 1 >  .  \n  eq < P, X' + 1, Q, Y' + X' + 1 > = < P, 1, Q, 1 + 1 > .\n  eq < P, X' + Y' + 1, Q, Y' + 1 > = < P, 1 + 1, Q, 1 >  .\n  eq < P, X' + Y' + 1, Q, X' + Y' + 1 > = < P, 1 + 1, Q, 1 + 1 > .\nendm\n\nload mfe.maude\n(select tool CRC .)\n(ccr ABSTRACT-BAKERY .)\n(select tool ChC .)\n(cch ABSTRACT-BAKERY .)\n(show all critical pairs .)\n\n\n---(                  \\||||||||||||||||||/\n                   --- Welcome to Maude ---\n                     /||||||||||||||||||\\\n            Maude 2.7++ built: Sep  9 2014 14:55:11\n            With additional hooks\n            Copyright 1997-2014 SRI International\n                   Fri Nov 10 16:06:00 2017\n\nload mfe.maude .\n\n            Full Maude 2.7 March 10th 2015\n\nThe Maude Formal Environment 1.0b\n    Inductive Theorem Prover - July 20th 2010\n    Sufficient Completeness Checker 2a - August 2010\n    Church-Rosser Checker 3n - December 17th 2012\n    Coherence Checker 3n - December 17th 2012\n    Maude Termination Tool 1.5j - August 11th 2014\n    Equality Enrichments 0.999 - July 2nd 2012\n    Equational Resolution Theorem Prover 0 - July 7th 2012\n    General Logics - based Operational Termination 0.0 - July 8th 2014\n\n(select tool CRC .)\nrewrites: 80 in 0ms cpu (10ms real) (~ rewrites/second)\nThe CRC has been set as current tool.\n\n(ccr ABSTRACT-BAKERY .)\nrewrites: 2260851 in 0ms cpu (1613ms real) (~ rewrites/second)\nChurch-Rosser check for ABSTRACT-BAKERY\n        All critical pairs have been joined.\n        The specification is locally-confluent.\n        The module is sort-decreasing.\n\n(select tool ChC .)\nrewrites: 76 in 0ms cpu (4ms real) (~ rewrites/second)\nThe ChC has been set as current tool.\n\n(cch ABSTRACT-BAKERY .)\nrewrites: 919547 in 0ms cpu (675ms real) (~ rewrites/second)\nCoherence checking of ABSTRACT-BAKERY\n        All critical pairs have been rewritten and no rewrite with rules can happen at non-overlapping positions of equations left-hand sides.\n        The sufficient-completeness, termination and Church-Rosser properties must still be checked.\n\n(show all critical pairs .)\nrewrites: 602 in 0ms cpu (11ms real) (~ rewrites/second)\nThe following critical pairs cannot be joined:\n  cp ABSTRACT-BAKERY0\n joined\n    < P:Mode,0,sleep,Y:Nat >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY0\n joined\n    < P:Mode,0,wait,1 >\n    => < P:Mode,0,crit,1 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < sleep,X:Nat,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,0,crit,1 >\n    => < P:Mode,0,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1,crit,0 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1,crit,1 + 1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1 + 1,crit,1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1 + 1,crit,1 + 1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,0,sleep,Y:Nat >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < sleep,X:Nat,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,0,sleep,1 >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1,sleep,0 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1,sleep,1 + 1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1 + 1,sleep,1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1 + 1,sleep,1 + 1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,0,Q:Mode,1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1,Q:Mode,0 >\n    => < sleep,0,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1,Q:Mode,1 + 1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1 + 1,Q:Mode,1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1 + 1,Q:Mode,1 + 1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,0,Q:Mode,1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1,Q:Mode,1 + 1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1 + 1,Q:Mode,1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1 + 1,Q:Mode,1 + 1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY5\n joined\n    < wait,1,Q:Mode,0 >\n    => < crit,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY5\n joined\n    < P:Mode,1 + 1,wait,1 >\n    => < P:Mode,1 + 1,crit,1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,0,Q:Mode,1 >\n    => < crit,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,1,Q:Mode,1 + 1 >\n    => < crit,1,Q:Mode,1 + 1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,1 + 1,Q:Mode,1 + 1 >\n    => < crit,1 + 1,Q:Mode,1 + 1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < P:Mode,1,wait,0 >\n    => < P:Mode,1,crit,0 > .\n---)",
        "complete:": "*** version of Nov. 10 2017 of abstract-bakery\n\nset include BOOL off .\n\nfmod NAT> is\n  sorts Zero NzNat Nat Bool .\n  subsorts Zero NzNat < Nat .\n  op tt : -> Bool [ctor] .  *** true\n  op ff : -> Bool [ctor] .  *** false\n  op 0 : -> Zero [ctor] .\n  op 1 : -> NzNat [ctor] .\n  op _+_ : Nat Nat -> Nat [ctor assoc comm id: 0] .\n  op _+_ : NzNat Nat -> NzNat [ctor assoc comm id: 0] .\n  op _+_ : Nat NzNat -> NzNat [ctor assoc comm id: 0] .\n  op _+_ : NzNat NzNat -> NzNat [ctor assoc comm id: 0] .  \n  op _>_ : Nat Nat -> Bool .\n\n  vars n m : Nat .  vars n' m' : NzNat .\n\n  eq n + n' > n = tt .\n  eq n > n + m = ff .\nendfm\n\nmod BAKERY is\n  protecting NAT> .\n\n  sorts Mode BState .\n\n  ops sleep wait crit : -> Mode [ctor] .\n  op <_,_,_,_> : Mode Nat Mode Nat -> BState [ctor] .\n  op initial : -> BState .\n\n  vars P Q : Mode .\n  vars X Y : Nat .\n\n  eq initial = < sleep, 0, sleep, 0 > .\n  \n  rl [p1_sleep] : < sleep, X, Q, Y > => < wait, Y + 1, Q, Y > .\n  rl [p1_wait] : < wait, X, Q, 0 > => < crit, X, Q, 0 > .\n  crl [p1_wait] : < wait, X, Q, Y > => < crit, X, Q, Y > if  X > Y = ff .\n  rl [p1_crit] : < crit, X, Q, Y > => < sleep, 0, Q, Y > .\n  \n  rl [p2_sleep] : < P, X, sleep, Y > => < P, X, wait, X + 1  > .\n  rl [p2_wait] : < P, 0, wait, Y > => < P, 0, crit, Y > .\n  crl [p2_wait] : < P, X, wait, Y > => < P, X, crit, Y > if X > Y = tt .\n  rl [p2_crit] : < P, X, crit, Y > => < P, X, sleep, 0 > .\nendm\n\nmod BAKERY-PREDS is\n  protecting BAKERY .\n  sort State Prop .\n  subsort BState < State .\n  ops 1wait 2wait 1crit 2crit : -> Prop [ctor] .\n\n  op _|=_ : State Prop -> Bool [frozen] .\n \n  vars P Q : Mode .\n  vars X Y : Nat .\n\n  eq < wait, X, Q, Y > |= 1wait = tt .\n  eq < sleep, X, Q, Y > |= 1wait = ff .\n  eq < crit, X, Q, Y > |= 1wait = ff .\n  eq < P , X, wait, Y > |= 2wait = tt .\n  eq < P , X, sleep, Y > |= 2wait = ff .\n  eq < P , X, crit, Y > |= 2wait = ff .\n  eq < crit , X, Q, Y > |= 1crit = tt .\n  eq < sleep, X, Q, Y > |= 1crit = ff .\n  eq < wait, X, Q, Y > |= 1crit = ff .\n  eq < P , X, crit, Y > |= 2crit = tt .\n  eq < P , X, sleep, Y > |= 2crit = ff .\n  eq < P , X, wait, Y > |= 2crit = ff .\nendm\n\nmod ABSTRACT-BAKERY is\n  including BAKERY-PREDS .\n\n  vars P Q : Mode .  vars X Y : Nat .  vars X' Y' : NzNat .\n\n  eq < P, 0, Q, 1 + Y' > = < P, 0, Q, 1 >  .\n  eq < P, 1 + X', Q, 0 > = < P, 1 , Q, 0 >  .\n  eq < P, 1, Q, 1 + Y' + X' > = < P, 1, Q, 1 + 1 >  .  \n  eq < P, 1 + X' + Y', Q, 1 > = < P, 1 + 1, Q, 1 >  .  \n  eq < P, X' + 1, Q, Y' + X' + 1 > = < P, 1, Q, 1 + 1 > .\n  eq < P, X' + Y' + 1, Q, Y' + 1 > = < P, 1 + 1, Q, 1 >  .\n  eq < P, X' + Y' + 1, Q, X' + Y' + 1 > = < P, 1 + 1, Q, 1 + 1 > .\nendm\n\nload mfe.maude\n(select tool CRC .)\n(ccr ABSTRACT-BAKERY .)\n(select tool ChC .)\n(cch ABSTRACT-BAKERY .)\n(show all critical pairs .)\n\n\n---(                  \\||||||||||||||||||/\n                   --- Welcome to Maude ---\n                     /||||||||||||||||||\\\n            Maude 2.7++ built: Sep  9 2014 14:55:11\n            With additional hooks\n            Copyright 1997-2014 SRI International\n                   Fri Nov 10 16:06:00 2017\n\nload mfe.maude .\n\n            Full Maude 2.7 March 10th 2015\n\nThe Maude Formal Environment 1.0b\n    Inductive Theorem Prover - July 20th 2010\n    Sufficient Completeness Checker 2a - August 2010\n    Church-Rosser Checker 3n - December 17th 2012\n    Coherence Checker 3n - December 17th 2012\n    Maude Termination Tool 1.5j - August 11th 2014\n    Equality Enrichments 0.999 - July 2nd 2012\n    Equational Resolution Theorem Prover 0 - July 7th 2012\n    General Logics - based Operational Termination 0.0 - July 8th 2014\n\n(select tool CRC .)\nrewrites: 80 in 0ms cpu (10ms real) (~ rewrites/second)\nThe CRC has been set as current tool.\n\n(ccr ABSTRACT-BAKERY .)\nrewrites: 2260851 in 0ms cpu (1613ms real) (~ rewrites/second)\nChurch-Rosser check for ABSTRACT-BAKERY\n        All critical pairs have been joined.\n        The specification is locally-confluent.\n        The module is sort-decreasing.\n\n(select tool ChC .)\nrewrites: 76 in 0ms cpu (4ms real) (~ rewrites/second)\nThe ChC has been set as current tool.\n\n(cch ABSTRACT-BAKERY .)\nrewrites: 919547 in 0ms cpu (675ms real) (~ rewrites/second)\nCoherence checking of ABSTRACT-BAKERY\n        All critical pairs have been rewritten and no rewrite with rules can happen at non-overlapping positions of equations left-hand sides.\n        The sufficient-completeness, termination and Church-Rosser properties must still be checked.\n\n(show all critical pairs .)\nrewrites: 602 in 0ms cpu (11ms real) (~ rewrites/second)\nThe following critical pairs cannot be joined:\n  cp ABSTRACT-BAKERY0\n joined\n    < P:Mode,0,sleep,Y:Nat >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY0\n joined\n    < P:Mode,0,wait,1 >\n    => < P:Mode,0,crit,1 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < sleep,X:Nat,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,0,crit,1 >\n    => < P:Mode,0,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1,crit,0 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1,crit,1 + 1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1 + 1,crit,1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,1 + 1,crit,1 + 1 >\n    => < P:Mode,1,sleep,0 > .\n  cp ABSTRACT-BAKERY1\n joined\n    < P:Mode,0,sleep,Y:Nat >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < sleep,X:Nat,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,0,sleep,1 >\n    => < P:Mode,0,wait,1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1,sleep,0 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1,sleep,1 + 1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1 + 1,sleep,1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY2\n joined\n    < P:Mode,1 + 1,sleep,1 + 1 >\n    => < P:Mode,1,wait,1 + 1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,0,Q:Mode,1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1,Q:Mode,0 >\n    => < sleep,0,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1,Q:Mode,1 + 1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1 + 1,Q:Mode,1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY3\n joined\n    < crit,1 + 1,Q:Mode,1 + 1 >\n    => < sleep,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,0,Q:Mode,1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1,Q:Mode,0 >\n    => < wait,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1,Q:Mode,1 + 1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1 + 1,Q:Mode,1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY4\n joined\n    < sleep,1 + 1,Q:Mode,1 + 1 >\n    => < wait,1 + 1,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY5\n joined\n    < wait,1,Q:Mode,0 >\n    => < crit,1,Q:Mode,0 > .\n  cp ABSTRACT-BAKERY5\n joined\n    < P:Mode,1 + 1,wait,1 >\n    => < P:Mode,1 + 1,crit,1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,0,Q:Mode,1 >\n    => < crit,0,Q:Mode,1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,1,Q:Mode,1 + 1 >\n    => < crit,1,Q:Mode,1 + 1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < wait,1 + 1,Q:Mode,1 + 1 >\n    => < crit,1 + 1,Q:Mode,1 + 1 > .\n  cp ABSTRACT-BAKERY6\n joined\n    < P:Mode,1,wait,0 >\n    => < P:Mode,1,crit,0 > .\n---)"
    },
    {
        "file": "MAUDE-1/ACU_MissingUnifiersMay2020.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op ____(OP_1)____ : Nat ____(OP_0)____ -> NzNat [assoc comm ____(OP_2)____ 0] .\n  op _+_ : ____(OP_4)____ Nat -> Nat [____(OP_3)____] .\n  op 0 : -> Zero .\n  op ____(OP_5)____ : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where we were losing ACU unifiers because\n***\tthey were subsumed by an mgu that failed to sort and code\n***\tintended to detect this situation failed because of a mis-set\n***\tflag.\n***\n\nfmod FOO is\n  sorts Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op _+_ : Nat NzNat -> NzNat [assoc comm id: 0] .\n  op _+_ : Nat Nat -> Nat [ditto] .\n  op 0 : -> Zero .\n  op g : Zero -> Nat .\nendfm\n\nunify N:Nat =? g(M:Nat + Z:Zero) ."
    },
    {
        "file": "MAUDE-1/ACU_TreeVariableSubproblem.maude",
        "incomplete": "set show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : ____(OP_0)____ Set -> Set [assoc ____(OP_1)____] .\n  op g : ____(OP_2)____ -> Set .\n  eq g(____(EQ_2)____) = ____(EQ_4)____ .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op ____(OP_3)____ : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(____(EQ_1)____), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op ____(OP_5)____ : ____(OP_4)____ Set -> Set [assoc comm] .\n  op ____(OP_6)____ : Nat -> Set .\n  eq g(____(EQ_6)____) = ____(EQ_12)____ .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : ____(OP_7)____ Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(____(EQ_3)____), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : ____(OP_9)____ Set -> Set [assoc ____(OP_8)____] .\n  op g : Nat -> ____(OP_10)____ .\n  eq g(____(EQ_17)____) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : ____(OP_11)____ Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N = 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(____(EQ_9)____), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op ____(OP_12)____ : ____(OP_13)____ Set -> Set [assoc comm] .\n  op g : Nat -> ____(OP_14)____ .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : ____(OP_15)____ Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(____(EQ_15)____), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : ____(OP_17)____ Set -> Set [____(OP_16)____ comm] .\n  op ____(OP_18)____ : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : ____(OP_19)____ Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : ____(OP_20)____ ____(OP_21)____ -> Set [assoc comm] .\n  op ____(OP_22)____ : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op ____(OP_23)____ : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N = 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op ____(OP_25)____ : Set Set -> Set [____(OP_24)____ comm] .\n  op ____(OP_26)____ : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op ____(OP_27)____ : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : ____(OP_29)____ Set -> Set [____(OP_28)____ comm] .\n  op g : ____(OP_30)____ -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op ____(OP_31)____ : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : ____(OP_32)____ Set -> Set [____(OP_33)____ comm] .\n  op ____(OP_34)____ : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op ____(OP_35)____ : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N = 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1",
        "complete:": "set show timing off .\n\n***\n***\tCheck corner cases for class ACU_TreeVariableSubproblem.\n***\n***\tThis kind of matching subproblem is generated when we have unbound stripper and collector\n***\tvariables, the subject is in red-black tree form, and we need to generate all solutions.\n***\tCorner cases arise when the stripper and/or collector variable is bound by an earlier\n*** \tACU_TreeVariableSubproblem and we need to deal with the bound variables correctly.\n***\n\n*** bound collector case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N > 10 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N < 2 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N M : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(M, S)) = M if N = 5 .  *** N, M are strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n\n*** bound stripper case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N > 10 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N < 2 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, T)) = T if N = 5 .  *** N is a strippers, S, T are collectors\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\n*** both bound case\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S T : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N > 10 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N < 2 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1\n\n\nfmod FOO is\n  pr NAT .\n  sort  Set .\n  subsort Nat < Set .\nvar N : Nat .\n  op f : Set Set -> Set [assoc comm] .\n  op g : Nat -> Set .\n  eq g(0) = 0 .\n  eq g(s N) = f(g(N), s N) .  *** make a red-black tree of arguments\n\nvar S : Set .\n  op h : Set Set -> Set .\n  ceq h(f(N, S), f(N, S)) = S if N = 5 .  *** N is a strippers, S is a collector\nendfm\n\nred h(g(11), g(11)) .\nred h(f(g(11), g(9)), f(g(11), g(9))) .  *** multiplicities > 1"
    },
    {
        "file": "MAUDE-1/ascentFunctionsJanuary2020.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule(____(EQ_1)____, ____(EQ_0)____) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts(____(EQ_2)____, false) .\nred in META-LEVEL : upSubsortDecls(____(EQ_3)____, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that contects of bad module cannot be pulled up\n***\tto the metalevel.\n***\n\n\nsmod BAD is\n  pr NON-EXISTENT .\nendsm\n\nred in META-LEVEL : upModule('BAD, false) .\nred in META-LEVEL : upImports('BAD) .\nred in META-LEVEL : upSorts('BAD, false) .\nred in META-LEVEL : upSubsortDecls('BAD, false) .\nred in META-LEVEL : upOpDecls('BAD, false) .\nred in META-LEVEL : upMbs('BAD, false) .\nred in META-LEVEL : upEqs('BAD, false) .\nred in META-LEVEL : upRls('BAD, false) .\nred in META-LEVEL : upStratDecls('BAD, false) .\nred in META-LEVEL : upSds('BAD, false) ."
    },
    {
        "file": "MAUDE-1/AU_and_A_UnificationEdgeCases.maude",
        "incomplete": "***\n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\nunify T X =? A B C Y .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a .",
        "complete:": "***\n***\tTests for edge cases of associative-identity and\n***\tassociative unification algorithms.\n***\n\nset show timing off .\n\n***(\n1/26/21\nThis example shows that replacing a constrained variable\nP with unconstrained variables A B leads to unnecessary\nincompleteness in versions before Alpha133.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair List .\n  subsort Elt Pair < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\nendfm\n\nunify P =? A B /\\ X P =? P Y .\n\n\n***(\n1/27/21\nThis example show that the imperfect splitting of upperbound on\nT to give upperbounds of 2, 1, 1 on A, B, C is then tightened\nto 1, 1, 1 in the post hoc PigPug::tightenConstraints() pass.\nA corner case that shows that constraint tightening is possible\nand might be useful in a system of equations.\n\n5/26/21\nWe now rely on WordLevel::checkAssignmentNormalCase() in the\nnext WordLevel to do the same tightening on variables that\nhaven't been eliminated.\n)\n\nfmod ASSOC-LIST is\n  sorts Elt Pair Triple List .\n  subsort Elt < Pair < Triple < List .\n  op __ : List List -> List [assoc] .\n  op __ : Elt Elt -> Pair [assoc] .\n  op __ : Elt Pair -> Triple [assoc] .\n  op __ : Pair Elt -> Triple [assoc] .\n\n  op rev : List -> List .\n  vars A B C X Y Z : List .\n  vars P Q R : Pair .\n  vars E F G : Elt .\n  vars S T U V : Triple .\nendfm\n\nunify T X =? A B C Y .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids identity assignments,\nand two cases where a sort-decreasing identity axiom foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Lo .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\nvars W X Y Z : Lo .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\nfmod FOO3 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op __ : Hi Hi -> Hi [assoc id: 1] .\n  op __ : Lo Lo -> Lo [ditto] .\nvars W X : Lo .\nvars Y Z : Hi .\nendfm\n\nunify W =? Y Z .\nirred unify W =? Y Z .\n\n\n***(\n2/18/21\nDemonstrate Alpha133 optimization that avoids equality steps in PigPug\nand a case where a following equation foils the optimization.\n)\n\nfmod FOO is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\nvars W X Y Z : Foo .\nendfm\n\nunify W X =? Y Z .\nirred unify W =? Y Z .\n\nunify W X =? Y Z /\\ W X =? a a .\nirred unify W X =? Y Z /\\ W X =? a a ."
    },
    {
        "file": "MAUDE-1/AU_IrredUnification.maude",
        "incomplete": "***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op ____(OP_1)____ : ____(OP_0)____ Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\nvars A B C ____(EQ_0)____ ____(VAR_1)____ ____(VAR_0)____ : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : ____(OP_3)____ List -> List [assoc id: ____(OP_2)____] .\nvars L M ____(VAR_2)____ : List .\nvars E F G : ____(VAR_3)____ .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort ____(SUBSORT_0)____ NzNat < Nat .\n  op 0 : -> Zero .\n  op ____(OP_4)____ : Nat -> NzNat [iter] .\n  op _*_ : ____(OP_6)____ NzNat -> NzNat [assoc ____(OP_7)____ s(____(OP_5)____) prec 31] .\n  op _*_ : ____(OP_8)____ ____(OP_9)____ -> Nat [ditto] .\n\n  vars W ____(VAR_6)____ Y Z ____(VAR_5)____ ____(VAR_4)____ C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : ____(OP_11)____ Foo -> Foo [____(OP_10)____ id: c(a, ____(OP_12)____)] .\n  op c : ____(OP_13)____ ____(OP_14)____ -> Foo [comm] .\n  vars W X Y Z ____(VAR_7)____ ____(VAR_9)____ C ____(VAR_8)____ : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(____(EQ_3)____, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : ____(OP_15)____ Foo -> Foo [assoc id: g(____(OP_16)____ ____(OP_17)____)] .\n  op ____(OP_19)____ : ____(OP_20)____ Foo -> Foo [assoc id: f(____(____(EQ_1)____)____ b)] .\n\n  vars X Y : ____(VAR_10)____ .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(____(EQ_2)____, a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : ____(OP_21)____ -> Foo .\n  op f : ____(OP_23)____ Foo -> Foo [assoc ____(OP_24)____ h(f(____(OP_22)____ b))] .\n\n  vars ____(VAR_11)____ Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : ____(OP_26)____ Foo -> Foo [assoc id: ____(OP_25)____] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op ____(OP_27)____ : ____(OP_28)____ Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, ____(EQ_4)____) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : ____(OP_29)____ ____(OP_30)____ -> Hi [assoc id: 1] .\n  op f : ____(OP_31)____ Lo -> Lo [assoc ____(OP_32)____ 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) .",
        "complete:": "***\n***\tTests for associative-identity unification.\n***\tThis version only looks at irredundant unifiers\n***\tbecause the number of irredundant unifiers shouldn't\n***\tchange as we optimize AU unification to avoid generating\n***\tredundant unifiers.\n***\n\nset show timing off .\n\nfmod AU-TEST is\n  sort Foo .\n  op 1 : -> Foo .\n  op __ : Foo Foo -> Foo [assoc id: 1] .\n  ops a b c : -> Foo .\nvars A B C X Y Z : Foo .\nendfm\n\n*** one side goes to one variable\nirred unify X =? Y X /\\ Z Y  =? A B .\n\n*** one side goes to empty\nirred unify X =? Y X /\\  Z C =? C  /\\ Z Y =? A B .\n\n*** both sides go to one variable\nirred unify X =? Y X /\\ A C =? C  /\\ Z Y =? A B .\n\n*** both side to to empty\nirred unify X =? Y X /\\ Y =? A B Z  /\\ Z Y =? A B .\n\n*** AU problem completely nulls out\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\nirred unify X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n\n*** null equation\nirred unify X =? Y X /\\ 1 =? A B Z  /\\ Z Y =? A B .\nirred unify X =? Y X /\\ C =? 1 /\\ C =? A B Z  /\\ Z Y =? A B .\n\n*** collapse\nirred unify A B C =? a .\nirred unify Y =? 1 /\\ X =? Y Z .\n\n*** linear\nirred unify A B =? X Y .\nirred unify A B =? X Y Z .\nirred unify A B C =? X Y Z .\n\n\n*** order-sorted unification\n\nfmod LIST is\n  sorts Elt List .\n  subsort Elt < List .\n  op nil : -> List .\n  op __ : List List -> List [assoc id: nil] .\nvars L M N : List .\nvars E F G : Elt .\nendfm\n\nirred unify E =? L M N .\nirred unify E L E M =? E N F N .\n\n*** cycle breaking\n\nfmod NAT' is\n  protecting BOOL .\n  sorts Zero NzNat Nat .\n  subsort Zero NzNat < Nat .\n  op 0 : -> Zero .\n  op s_ : Nat -> NzNat [iter] .\n  op _*_ : NzNat NzNat -> NzNat [assoc id: s(0) prec 31] .\n  op _*_ : Nat Nat -> Nat [ditto] .\n\n  vars W X Y Z A B C D : Nat .\nendfm\n\n*** cycle breaking through S theory\nirred unify X =? s (X * Y) .\nirred unify X =? s X * Y .\n\n*** theory conflict\nirred unify s X =? s X * Y .\nirred unify s X =? X * Y .\n\nfmod COMM is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: c(a, b)] .\n  op c : Foo Foo -> Foo [comm] .\n  vars W X Y Z A B C D : Foo .\nendfm\n\n*** cycle breaking through comm theory\nirred unify X =? c(f(X, Y), Z) .\n\nfmod FOO2 is\n  sort Foo .\n  ops a b c d : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: g(c, d)] .\n  op g : Foo Foo -> Foo [assoc id: f(a, b)] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identities\nirred unify X =? f(Y, a, b) /\\ Y =? g(X, c, d) .\n\nfmod FOO3 is\n  sort Foo .\n  ops a b : -> Foo .\n  op h : Foo -> Foo .\n  op f : Foo Foo -> Foo [assoc id: h(f(a, b))] .\n\n  vars X Y : Foo .\nendfm\n\n*** cycle breaking with non-disjoint identity\nirred unify X =? f(Y, a, b) /\\ Y =? h(X) .\n\n*** order-sorted mgus need not be unsorted mgus\n\nfmod AU-UNSORTED is\n  sort Foo .\n  op 1 : -> Foo .\n  op f : Foo Foo -> Foo [assoc id: 1] .\nendfm\n\n*** 1 mgu\nirred unify X:Foo =? f(Y:Foo, Z:Foo) .\n\nfmod AU-SORTED1 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\nendfm\n\n*** unsorted mgu can't be sorted so collapse solutions becomes mgus\nirred unify X:Lo =? f(Y:Hi, Z:Hi) .\n\nfmod AU-SORTED2 is\n  sorts Lo Hi .\n  subsort Lo < Hi .\n  op 1 : -> Hi .\n  op f : Hi Hi -> Hi [assoc id: 1] .\n  op f : Lo Lo -> Lo [assoc id: 1] .\nendfm\n\n*** collapse solutions not subsumed by non-collapse solution after sorting \nirred unify X:Lo =? f(Y:Hi, Z:Hi) ."
    },
    {
        "file": "MAUDE-1/bank.maude",
        "incomplete": "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : ____(OP_1)____ Int ____(OP_0)____ -> Account [ctor] .\n\n    op active : -> Status [____(OP_2)____] .\n    op ____(OP_3)____ : -> Status [ctor] .\n\n    op Alice : -> ____(OP_4)____ [ctor] .         \n    op Bob : -> ____(OP_5)____ [ctor] .\n    op Charlie : -> ____(OP_6)____ [ctor] .       \n    op ____(OP_7)____ : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op ____(OP_8)____ : Account -> Account .\n    ceq updateStatus(< ____(EQ_8)____ >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : ____(VAR_0)____ .\n    vars ____(VAR_1)____ BAL1 BAL2 M : ____(VAR_2)____ .\n    \n    op empty-state : -> State [____(OP_9)____] .\n    op ____(OP_12)____ : State State -> State [ctor assoc ____(OP_11)____ ____(OP_10)____ empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  ____(OP_13)____ : ____(OP_14)____ Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(____(EQ_9)____, M) ; < ID | BAL | active > => \n                  updateStatus(< ____(EQ_12)____ >) .\n\n    rl [debit] : debit(ID, ____(EQ_18)____) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ____(EQ_17)____ >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, ____(EQ_10)____) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(____(EQ_15)____, 45) ; transfer(Alice, Charlie, 15) ; transfer(____(EQ_3)____, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, ____(EQ_4)____, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(____(EQ_2)____, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, ____(EQ_13)____) ; debit(Alice, ____(EQ_7)____) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, ____(EQ_11)____) ; transfer(Bob, Alice, 60) ; credit(____(EQ_1)____, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, ____(EQ_6)____, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(____(EQ_16)____, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ____(VAR_3)____ ____(EQ_0)____' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op ____(OP_15)____ : State -> Nat .\n    eq numberOfAccounts(____(EQ_5)____ ; A ; ____(EQ_14)____') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm",
        "complete:": "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | active >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 30) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Bob, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 130) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Alice, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm"
    },
    {
        "file": "MAUDE-1/bike.maude",
        "incomplete": "*** Specification of BIKE\n*** Author: V\u00edctor Garc\u00eda Valero <vicgarval@upv.es>\n\n*** Module specifying basic datatypes and its operations used in BIKE\nfmod DATA-TYPES is\n    protecting NAT .\n\n    *** Supersort of all data\n    sort Data . \n    *** Definition of type polynomial for our data\n    *** Definition of type polynomial without identity element to avoid collision problem\n    sorts Polynomial .\n\n    *** Specify that polynomials are data\n    subsorts Polynomial < Data .\n\n    subsort Nat < Polynomial .\n\n    vars P0 P1 P2 : ____(VAR_0)____ .\n    \n    *** Operator addition of polynomials\n    op ____(OP_1)____ : ____(OP_2)____ Polynomial -> Polynomial [assoc comm ____(OP_0)____ 33] .\n    *** Identity axiom as an equation to avoid colapsing\n    eq 0 p+ P0 = P0 .\n\n    *** Operator multiplication of polynomials\n    op _p*____(EQ_40)____ : Polynomial Polynomial -> Polynomial [____(OP_5)____ ____(OP_3)____ ____(OP_4)____ 31] .\n    *** Identity axiom as an equation to avoid colapsing\n    eq 1 p* P0 = P0 .\n\n    *** Distributive property of polynomial product over polynomial addition\n    eq (P0 p+ P1) p* P2 = (P0 p* P2) p+ (P1 p* P2) .\n\n    *** Pair\n    sort Pair .\n\n    *** A Pair can be seen as a Polynomial divided in two parts\n    subsort Pair < Polynomial .\n\n    op [____(OP_6)____] : Data Data -> Pair [____(OP_7)____] .\n\n    vars D1 D2 : ____(VAR_1)____ .\n\n    *** First element of Pair\n    op first : ____(OP_8)____ -> Data .\n    eq first([D1,D2]) = D1 .\n    *** Second element of Pair\n    op second : ____(OP_9)____ -> Data .\n    eq second([D1,D2]) = D2 .\n\n    *** Inverse operation over polynomials\n    op inv : ____(OP_10)____ -> Polynomial .\n\n    eq P0 p* inv(P0) = 1 .\nendfm\n\n*** Module to specify all the hash functions that are used in the steps of BIKE KEM\nfmod BIKE-HASH-OPERATIONS is\n    protecting DATA-TYPES .\n\n    *** H recieves a random polynomial and returns a hash of it (which is a pair of polynomials)\n    op H : ____(OP_11)____ -> Pair [ctor] .\n    op K : ____(OP_13)____ Pair -> Polynomial [____(OP_12)____] .\n    op L : Polynomial -> Polynomial [____(OP_14)____] .\n\n    vars P0 ____(VAR_2)____ : Polynomial .\n\n    *** Possible relation on how the concatenation for the computation of L is done\n    *** This possibility considers the case when the concatenation is doen throug addition\n    eq L([P0,____(EQ_21)____]) = L(P0 p+ P1) .\nendfm\n\n*** Module to represent the data and operations handled during KEYGEN\nfmod BIKE-KEYGEN is\n    protecting DATA-TYPES .\n\n    *** Constant value representing the h_i sampled from the private key space H_w\n    ops h0 h1 h0' h1' : -> Polynomial .\n\n    *** Constant value representing the sigma obtained in step 3\n    ops sigma sigma' : -> Polynomial .\nendfm\n\n*** Module to represent the operations and data handled during ENC\nfmod BIKE-ENC is\n    protecting DATA-TYPES .\n    protecting BIKE-HASH-OPERATIONS .\n\n    *** Messages randomply generated by a principal\n    ops ____(EQ_16)____ : -> Polynomial .\n\n    *** Errors generated from H(M1)\n    ops e0 e1 : -> Polynomial .\n    eq H(____(EQ_34)____) = [e0,e1] .\n\n    *** Errors generated from H(M2)\n    ops e0' e1' : -> Polynomial .\n    eq H(m2) = [e0',e1'] .\n\n    *** Operator to represent the shared key\n    ops k k' : -> Polynomial .\n    var C : Pair .\n    *** Key generated from K(m1,c)\n    eq K(____(EQ_15)____,C) = k .\n    *** Key generated from K(m2,c)\n    eq K(m2,C) = k' .\nendfm\n\n*** Module to represent the operations and data handled during DEC\n*** Its main purpouse is to demonstrate that the computed key is\n*** the one that was computed in the other side using PK and C\nfmod BIKE-DEC is\n    protecting DATA-TYPES .\n    protecting NAT .\n\n    *** Operator to represent the decoder used (Black-Gray-Flip)\n    op ____(OP_15)____ : ____(OP_16)____ Polynomial Polynomial -> Pair .\n    \n    vars P0 P1 ____(VAR_3)____ P3 : ____(VAR_4)____ .\n\n    *** We only consider the perfect case where the obtained errors are the originals\n    eq decoder((P0 p* P1) p+ (P2 p* P3), P1, P3) = [P0,P2] .\n\n    subsort Nat < Data .\n\n    var D : Data .\n\n    *** XOR\n    op _xorD_ : ____(OP_17)____ ____(OP_18)____ -> Data [assoc comm] .\n    eq D xorD 0 = D .\n    eq D xorD D = 0 .\nendfm\n\n*** Specification of the system upon BIKE will work\nfmod MODEL-CONFIGURATION is\n    protecting DATA-TYPES .\n\n    ***\n    *** SORTS\n    ***\n\n    sorts Identifier Content Participant Participants . \n    sorts MsgState Msg Msgs .\n    subsort Msg < Msgs .\n    subsort Participant < Participants .\n\n    sorts Key Keys .\n    subsort Key < Keys .\n\n    *** We distinguish between public and secret keys, both being keys in the end\n    sorts PKey SKey .\n\n    ***We define keys as a type of content\n    subsorts Polynomial < PKey SKey < Key < Content .\n\n    *** We also declare that a pair is content\n    subsort Pair < Content .\n\n    *** Sort for the State of our system\n    sort GlobalState .\n    \n    ***\n    *** OPERATORS\n    ***\n\n    *** Empty group of keys\n    op emptyK : -> Keys .\n    *** Group of keys\n    op _;_ : ____(OP_20)____ Keys -> Keys [assoc ____(OP_21)____ id: ____(OP_19)____] .\n\n    var K : Key .\n    vars KS1 ____(VAR_5)____ : Keys .\n\n    *** Operation to check the precence of a key in a participant\n    op _in_ : Key Keys -> ____(OP_22)____ .\n    eq K in (KS1 ; K ; KS2) = true .\n    eq K in (KS1) = false [owise] .\n\n    *** Operator to represent the relation of a public key and a principal\n    op publicKey : ____(OP_23)____ Key -> PKey .\n\n    *** Operator to represent the relation of a secret key and a principal\n    op secretKey : Identifier Key -> ____(OP_24)____ .\n\n    *** Operator to represent the shared key with a participant\n    op ____(OP_26)____ : ____(OP_25)____ Key -> SKey [format (g! o)] .\n\n    *** Posible states for a message delivering PK\n    ops sentPK receivedPK : -> MsgState .\n    *** Posible states for a message delivering C\n    ops sentC receivedC : -> MsgState .\n\n    *** Empty content\n    op emptyC : -> Content .\n    *** Group of contents\n    op ____(OP_27)____ : ____(OP_29)____ Content -> Content [assoc comm ____(OP_28)____ emptyC] .\n\n    vars C ____(VAR_6)____ ____(EQ_5)____ : Content .\n\n    *** Operation to check the contents of a participant\n    op ____(OP_30)____ : Content Content -> Bool .\n    eq C in (CONT1 C CONT2) = true .\n    eq C in (CONT1) = false [owise] .\n\n    *** Structure of a message\n    *** Sender, Receiver, State, Content\n    op msg{(____(OP_32)____)[_]_} : Identifier Identifier MsgState ____(OP_31)____ -> Msg .\n\n    *** Group of messsages\n    op ____(EQ_38)____ : -> Msgs .\n    op __ : ____(OP_36)____ Msgs -> Msgs [assoc id: ____(OP_34)____ ____(OP_33)____ (____(OP_35)____ nt d)] .\n\n    var M : Msg .\n    vars ____(VAR_7)____ MS2 : Msgs .\n    \n    *** Operation to check the network\n    op _in_ : ____(OP_37)____ Msgs -> Bool .\n\n    eq M in (MS1 M MS2) = true .\n    eq M in (MS1) = false [owise] .\n\n    *** Defintion of our three main participants followiing the literature\n    ops Alice Eve Bob : ->  Identifier [ctor] .\n\n    *** Definition of the default participant\n    op ____(EQ_9)____ : -> Identifier [____(OP_38)____] .\n\n    *** Operator to assign a Ciphered text to a participant\n    op cI : ____(OP_39)____ Pair -> Content .\n\n    *** Operator to mark the current participant to whom the key exchange is happening\n    op peer : Identifier -> ____(OP_40)____ .\n\n    *** Definition of the components of a Participant\n    *** (idenifier [keys] content)\n    op _[_]_ : ____(OP_42)____ Keys Content -> Participant [____(OP_41)____] .\n\n    *** Group of participants\n    op __ : ____(OP_46)____ Participant -> ____(OP_43)____ [assoc ____(OP_44)____ format (____(OP_45)____ n d)] .\n\n    *** Global state composed by Samples, Participants and a Network with messages\n    op {_}<_>net(_) : ____(OP_50)____ Participants Msgs -> GlobalState [ctor ____(OP_49)____ (____(OP_47)____ ____(OP_48)____ ____(OP_51)____ ____(OP_52)____ n n d d d d)] .\nendfm\n\n*** Protocol/mechanism samples and behaviour\nmod BIKE is\n    ***\n    *** IMPORTS\n    ***\n\n    protecting DATA-TYPES .\n    protecting BIKE-HASH-OPERATIONS .\n    protecting BIKE-KEYGEN .\n    protecting BIKE-ENC .\n    protecting BIKE-DEC .\n    protecting MODEL-CONFIGURATION .\n\n    *** Group of polynomials sigma that can be sampled\n    op ____(OP_53)____ : Content -> Content .\n\n    *** Group of messages m that can be sampled\n    op ms : ____(OP_54)____ -> Content .\n\n    *** Group of polynomials h that can be sampled; They come in pairs\n    op hs : ____(OP_55)____ -> Content .\n\n    *** Operator to assign a polynomial 'sigma' to a participant\n    op sigmaI : Identifier Polynomial -> ____(OP_56)____ .\n\n    *** Operator to assign a message to a participant\n    op mI : Identifier Polynomial -> ____(OP_57)____ .\n\n    *** Operator to assign a random pair of hs to a participant\n    op ____(OP_58)____ : Identifier Pair -> Content .\n\n    ***\n    *** INITIAL STATES\n    ***\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([____(EQ_28)____,h1])} < (Alice[emptyK]peer(____(EQ_20)____)) (Eve[emptyK]peer(____(EQ_42)____)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [____(EQ_27)____,h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    ***\n    *** RULES\n    ***\n\n    vars ____(EQ_14)____ ____(EQ_30)____ ID3 : ____(VAR_8)____ .\n    var PS : Participants .\n    vars ____(EQ_2)____ ____(EQ_10)____' : ____(VAR_9)____ .\n    vars SK ____(VAR_10)____ : SKey .\n    vars PK PK' : ____(VAR_11)____ .\n    vars ____(VAR_12)____ Cs' ____(VAR_13)____ ____(EQ_32)____ : Pair .\n    vars ____(VAR_14)____ C1 : Polynomial .\n    vars E0 E1 : ____(VAR_15)____ .\n    var M : Polynomial .\n    vars ____(VAR_16)____ KS2 KS3 : Keys .\n    vars ____(VAR_17)____ SAM2 : Data .\n    vars CONT1 CONT2 ____(VAR_18)____ : Content .\n\n    ***\n    *** HONEST PARTICIPANT BEHAVIOUR\n    ***\n\n    *** For now the protocol only starts when the participant can sample necesary values for keygen\n\n    crl [KeyGen] :  {sigmas(____(EQ_1)____ CONT1) hs(____(EQ_3)____) CONT3} < (____(EQ_37)____[emptyK]peer(none)) PS >net(____(EQ_29)____) \n                    => \n                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, ____(EQ_24)____)]peer(none) sigmaI(ID1,SAM1) hI(____(EQ_22)____, SAM2)) PS >net(____(EQ_33)____) \n                    if PK := (second(SAM2) p* inv(first(SAM2))) .\n\n    --- The public key is sent\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (____(EQ_44)____[KS2]peer(none) CONT2) PS >net(____(EQ_46)____)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(____(EQ_12)____, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(____(EQ_18)____, ID2)[receivedPK](PK)} MSGS') .\n    \n    *** The public key is consumed to generate a shared key\n    crl [Enc] : {ms(____(EQ_8)____) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(____(EQ_43)____, SK) ; KS2]peer(ID1) mI(____(EQ_23)____, SAM1) cI(ID1, ____(EQ_11)____) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(SAM1) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    Cs := [(E0 p+ (E1 p* (PK))), (SAM1 xorD L(Es))] /\\\n                    SK := K(SAM1, Cs) .\n\n    *** The ciphered text is sent\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](____(EQ_17)____)}) \n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\ \n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n    \n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](____(EQ_26)____)} MSGS') \n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    *** The ciphered text is consumed to generate the shared key\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, ____(EQ_35)____) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) \n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := second(Cs) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    ***\n    *** INTRUDER BEHAVIOUR\n    ***\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, ____(EQ_25)____) ; KS1]peer(none) CONT1) PS >net(MSGS msg{(____(EQ_36)____,ID2)[sentPK](PK)}) \n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,____(EQ_0)____) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(____(EQ_19)____,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,____(EQ_6)____) peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](____(EQ_31)____)}) \n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,____(EQ_41)____) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(____(EQ_4)____,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,____(EQ_13)____) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](____(EQ_39)____)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, SK) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)}) \n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm",
        "complete:": "*** Specification of BIKE\n*** Author: V\u00edctor Garc\u00eda Valero <vicgarval@upv.es>\n\n*** Module specifying basic datatypes and its operations used in BIKE\nfmod DATA-TYPES is\n    protecting NAT .\n\n    *** Supersort of all data\n    sort Data . \n    *** Definition of type polynomial for our data\n    *** Definition of type polynomial without identity element to avoid collision problem\n    sorts Polynomial .\n\n    *** Specify that polynomials are data\n    subsorts Polynomial < Data .\n\n    subsort Nat < Polynomial .\n\n    vars P0 P1 P2 : Polynomial .\n    \n    *** Operator addition of polynomials\n    op _p+_ : Polynomial Polynomial -> Polynomial [assoc comm prec 33] .\n    *** Identity axiom as an equation to avoid colapsing\n    eq 0 p+ P0 = P0 .\n\n    *** Operator multiplication of polynomials\n    op _p*_ : Polynomial Polynomial -> Polynomial [assoc comm prec 31] .\n    *** Identity axiom as an equation to avoid colapsing\n    eq 1 p* P0 = P0 .\n\n    *** Distributive property of polynomial product over polynomial addition\n    eq (P0 p+ P1) p* P2 = (P0 p* P2) p+ (P1 p* P2) .\n\n    *** Pair\n    sort Pair .\n\n    *** A Pair can be seen as a Polynomial divided in two parts\n    subsort Pair < Polynomial .\n\n    op [_,_] : Data Data -> Pair [ctor] .\n\n    vars D1 D2 : Data .\n\n    *** First element of Pair\n    op first : Pair -> Data .\n    eq first([D1,D2]) = D1 .\n    *** Second element of Pair\n    op second : Pair -> Data .\n    eq second([D1,D2]) = D2 .\n\n    *** Inverse operation over polynomials\n    op inv : Polynomial -> Polynomial .\n\n    eq P0 p* inv(P0) = 1 .\nendfm\n\n*** Module to specify all the hash functions that are used in the steps of BIKE KEM\nfmod BIKE-HASH-OPERATIONS is\n    protecting DATA-TYPES .\n\n    *** H recieves a random polynomial and returns a hash of it (which is a pair of polynomials)\n    op H : Polynomial -> Pair [ctor] .\n    op K : Polynomial Pair -> Polynomial [ctor] .\n    op L : Polynomial -> Polynomial [ctor] .\n\n    vars P0 P1 : Polynomial .\n\n    *** Possible relation on how the concatenation for the computation of L is done\n    *** This possibility considers the case when the concatenation is doen throug addition\n    eq L([P0,P1]) = L(P0 p+ P1) .\nendfm\n\n*** Module to represent the data and operations handled during KEYGEN\nfmod BIKE-KEYGEN is\n    protecting DATA-TYPES .\n\n    *** Constant value representing the h_i sampled from the private key space H_w\n    ops h0 h1 h0' h1' : -> Polynomial .\n\n    *** Constant value representing the sigma obtained in step 3\n    ops sigma sigma' : -> Polynomial .\nendfm\n\n*** Module to represent the operations and data handled during ENC\nfmod BIKE-ENC is\n    protecting DATA-TYPES .\n    protecting BIKE-HASH-OPERATIONS .\n\n    *** Messages randomply generated by a principal\n    ops m1 m2 : -> Polynomial .\n\n    *** Errors generated from H(M1)\n    ops e0 e1 : -> Polynomial .\n    eq H(m1) = [e0,e1] .\n\n    *** Errors generated from H(M2)\n    ops e0' e1' : -> Polynomial .\n    eq H(m2) = [e0',e1'] .\n\n    *** Operator to represent the shared key\n    ops k k' : -> Polynomial .\n    var C : Pair .\n    *** Key generated from K(m1,c)\n    eq K(m1,C) = k .\n    *** Key generated from K(m2,c)\n    eq K(m2,C) = k' .\nendfm\n\n*** Module to represent the operations and data handled during DEC\n*** Its main purpouse is to demonstrate that the computed key is\n*** the one that was computed in the other side using PK and C\nfmod BIKE-DEC is\n    protecting DATA-TYPES .\n    protecting NAT .\n\n    *** Operator to represent the decoder used (Black-Gray-Flip)\n    op decoder : Polynomial Polynomial Polynomial -> Pair .\n    \n    vars P0 P1 P2 P3 : Polynomial .\n\n    *** We only consider the perfect case where the obtained errors are the originals\n    eq decoder((P0 p* P1) p+ (P2 p* P3), P1, P3) = [P0,P2] .\n\n    subsort Nat < Data .\n\n    var D : Data .\n\n    *** XOR\n    op _xorD_ : Data Data -> Data [assoc comm] .\n    eq D xorD 0 = D .\n    eq D xorD D = 0 .\nendfm\n\n*** Specification of the system upon BIKE will work\nfmod MODEL-CONFIGURATION is\n    protecting DATA-TYPES .\n\n    ***\n    *** SORTS\n    ***\n\n    sorts Identifier Content Participant Participants . \n    sorts MsgState Msg Msgs .\n    subsort Msg < Msgs .\n    subsort Participant < Participants .\n\n    sorts Key Keys .\n    subsort Key < Keys .\n\n    *** We distinguish between public and secret keys, both being keys in the end\n    sorts PKey SKey .\n\n    ***We define keys as a type of content\n    subsorts Polynomial < PKey SKey < Key < Content .\n\n    *** We also declare that a pair is content\n    subsort Pair < Content .\n\n    *** Sort for the State of our system\n    sort GlobalState .\n    \n    ***\n    *** OPERATORS\n    ***\n\n    *** Empty group of keys\n    op emptyK : -> Keys .\n    *** Group of keys\n    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .\n\n    var K : Key .\n    vars KS1 KS2 : Keys .\n\n    *** Operation to check the precence of a key in a participant\n    op _in_ : Key Keys -> Bool .\n    eq K in (KS1 ; K ; KS2) = true .\n    eq K in (KS1) = false [owise] .\n\n    *** Operator to represent the relation of a public key and a principal\n    op publicKey : Identifier Key -> PKey .\n\n    *** Operator to represent the relation of a secret key and a principal\n    op secretKey : Identifier Key -> SKey .\n\n    *** Operator to represent the shared key with a participant\n    op sharedKey : Identifier Key -> SKey [format (g! o)] .\n\n    *** Posible states for a message delivering PK\n    ops sentPK receivedPK : -> MsgState .\n    *** Posible states for a message delivering C\n    ops sentC receivedC : -> MsgState .\n\n    *** Empty content\n    op emptyC : -> Content .\n    *** Group of contents\n    op __ : Content Content -> Content [assoc comm id: emptyC] .\n\n    vars C CONT1 CONT2 : Content .\n\n    *** Operation to check the contents of a participant\n    op _in_ : Content Content -> Bool .\n    eq C in (CONT1 C CONT2) = true .\n    eq C in (CONT1) = false [owise] .\n\n    *** Structure of a message\n    *** Sender, Receiver, State, Content\n    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .\n\n    *** Group of messsages\n    op emptyM : -> Msgs .\n    op __ : Msgs Msgs -> Msgs [assoc id: emptyM format (d nt d)] .\n\n    var M : Msg .\n    vars MS1 MS2 : Msgs .\n    \n    *** Operation to check the network\n    op _in_ : Msg Msgs -> Bool .\n\n    eq M in (MS1 M MS2) = true .\n    eq M in (MS1) = false [owise] .\n\n    *** Defintion of our three main participants followiing the literature\n    ops Alice Eve Bob : ->  Identifier [ctor] .\n\n    *** Definition of the default participant\n    op none : -> Identifier [ctor] .\n\n    *** Operator to assign a Ciphered text to a participant\n    op cI : Identifier Pair -> Content .\n\n    *** Operator to mark the current participant to whom the key exchange is happening\n    op peer : Identifier -> Content .\n\n    *** Definition of the components of a Participant\n    *** (idenifier [keys] content)\n    op _[_]_ : Identifier Keys Content -> Participant [ctor] .\n\n    *** Group of participants\n    op __ : Participant Participant -> Participants [assoc comm format (d n d)] .\n\n    *** Global state composed by Samples, Participants and a Network with messages\n    op {_}<_>net(_) : Content Participants Msgs -> GlobalState [ctor format (n d d n n n d d d d)] .\nendfm\n\n*** Protocol/mechanism samples and behaviour\nmod BIKE is\n    ***\n    *** IMPORTS\n    ***\n\n    protecting DATA-TYPES .\n    protecting BIKE-HASH-OPERATIONS .\n    protecting BIKE-KEYGEN .\n    protecting BIKE-ENC .\n    protecting BIKE-DEC .\n    protecting MODEL-CONFIGURATION .\n\n    *** Group of polynomials sigma that can be sampled\n    op sigmas : Content -> Content .\n\n    *** Group of messages m that can be sampled\n    op ms : Content -> Content .\n\n    *** Group of polynomials h that can be sampled; They come in pairs\n    op hs : Content -> Content .\n\n    *** Operator to assign a polynomial 'sigma' to a participant\n    op sigmaI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a message to a participant\n    op mI : Identifier Polynomial -> Content .\n\n    *** Operator to assign a random pair of hs to a participant\n    op hI : Identifier Pair -> Content .\n\n    ***\n    *** INITIAL STATES\n    ***\n    ops init1 init2 : -> GlobalState .\n    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .\n\n    ***\n    *** RULES\n    ***\n\n    vars ID1 ID2 ID3 : Identifier .\n    var PS : Participants .\n    vars MSGS MSGS' : Msgs .\n    vars SK SK' : SKey .\n    vars PK PK' : PKey .\n    vars Cs Cs' Hs Es : Pair .\n    vars C0 C1 : Polynomial .\n    vars E0 E1 : Polynomial .\n    var M : Polynomial .\n    vars KS1 KS2 KS3 : Keys .\n    vars SAM1 SAM2 : Data .\n    vars CONT1 CONT2 CONT3 : Content .\n\n    ***\n    *** HONEST PARTICIPANT BEHAVIOUR\n    ***\n\n    *** For now the protocol only starts when the participant can sample necesary values for keygen\n\n    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]peer(none)) PS >net(MSGS) \n                    => \n                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]peer(none) sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(MSGS) \n                    if PK := (second(SAM2) p* inv(first(SAM2))) .\n\n    --- The public key is sent\n    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)\n                    =>\n                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})\n                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\\\n                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .\n\n    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')\n                        =>\n                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .\n    \n    *** The public key is consumed to generate a shared key\n    crl [Enc] : {ms(SAM1 CONT1) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)\n                =>\n                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, SK) ; KS2]peer(ID1) mI(ID2, SAM1) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                if  ID1 =/= ID2 /\\\n                    Es := H(SAM1) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    Cs := [(E0 p+ (E1 p* (PK))), (SAM1 xorD L(Es))] /\\\n                    SK := K(SAM1, Cs) .\n\n    *** The ciphered text is sent\n    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)\n                        =>\n                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)}) \n                        if  ID1 =/= ID2 /\\\n                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\\ \n                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .\n    \n    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS') \n                        =>\n                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .\n\n    *** The ciphered text is consumed to generate the shared key\n    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)\n                =>\n                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) \n                if  ID1 =/= ID2 /\\\n                    ID2 =/= none /\\\n                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\\\n                    E0 := first(Es) /\\\n                    E1 := second(Es) /\\\n                    M := second(Cs) xorD L(Es) /\\\n                    SK := K(M, Cs) .\n\n    ***\n    *** INTRUDER BEHAVIOUR\n    ***\n\n    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK') ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)}) \n                        =>\n                        {CONT3}< (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            PK =/= PK' /\\\n                            (publicKey(ID1,PK)) in KS1 == false .\n\n    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs') peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs)}) \n                        =>\n                        {CONT3}< (Eve[KS1]cI(Eve,Cs) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) \n                        if  ID1 =/= Eve /\\\n                            ID2 =/= Eve /\\\n                            ID1 =/= ID2 /\\\n                            Cs =/= Cs' /\\\n                            (cI(ID1,Cs)) in CONT1 == false .\n\n    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})\n                                    =>\n                                    {CONT3}< (Eve[publicKey(Alice,PK) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})\n                                    if PK =/= 1 .\n\n    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})\n                                    =>\n                                    {CONT3}< (Eve[sharedKey(Bob, SK) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)}) \n                                    if  M := (second(Cs)) xorD L(first(Cs)) /\\\n                                        SK := K(M,Cs) .\nendm"
    },
    {
        "file": "MAUDE-1/closeSocketFeb2020.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that closing a server TCP socket that is waiting\n***\tto accept connections doesn't cause Maude to spin its wheels\n***\twaiting for events on the closed socket.\n***\nload socket\n\nmod SERVER-SHUTDOWN is\n        protecting SOCKET .\n        op Server : -> Cid [____(OP_0)____] .\n        op server : -> ____(OP_1)____ [ctor] .\n        op state:_ : ____(OP_2)____ -> Attribute [ctor] .\n\n        sort ServerState .\n        ops init closing : -> ServerState [ctor] .\n        op  accepting    : ____(OP_3)____ -> ServerState [ctor] .\n\n    var ____(EQ_0)____   : Oid .\n    var Reason : String .\n        rl [createdSocket] :\n                < server : Server | state: init >\n                createdSocket(server, socketManager, SSkt)\n        =>\n                < server : Server | state: accepting(SSkt) >\n                acceptClient(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: accepting(SSkt) >\n        =>\n                < server : Server | state: closing >\n                closeSocket(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: closing >\n                closedSocket(____(EQ_1)____, SSkt, Reason)\n        =>\n                none\n        .\n        op initial : -> Configuration .\n        eq initial = <> < server : Server | state: init >\n                     createServerTcpSocket(socketManager, server, 1234, 5) .\nendm\n\nerew initial .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck that closing a server TCP socket that is waiting\n***\tto accept connections doesn't cause Maude to spin its wheels\n***\twaiting for events on the closed socket.\n***\nload socket\n\nmod SERVER-SHUTDOWN is\n        protecting SOCKET .\n        op Server : -> Cid [ctor] .\n        op server : -> Oid [ctor] .\n        op state:_ : ServerState -> Attribute [ctor] .\n\n        sort ServerState .\n        ops init closing : -> ServerState [ctor] .\n        op  accepting    : Oid -> ServerState [ctor] .\n\n    var SSkt   : Oid .\n    var Reason : String .\n        rl [createdSocket] :\n                < server : Server | state: init >\n                createdSocket(server, socketManager, SSkt)\n        =>\n                < server : Server | state: accepting(SSkt) >\n                acceptClient(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: accepting(SSkt) >\n        =>\n                < server : Server | state: closing >\n                closeSocket(SSkt, server)\n        .\n        rl [close] :\n                < server : Server | state: closing >\n                closedSocket(server, SSkt, Reason)\n        =>\n                none\n        .\n        op initial : -> Configuration .\n        eq initial = <> < server : Server | state: init >\n                     createServerTcpSocket(socketManager, server, 1234, 5) .\nendm\n\nerew initial ."
    },
    {
        "file": "MAUDE-1/complexParserSyncApril2020.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, ____(EQ_1)____), none, '0, ____(EQ_0)____) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tCheck bug where cached simple parser was getting used\n***\twith complex parser auxiliary information leading to crash.\n***\n\nselect META-LEVEL .\n\nred metaParse(upModule('NAT, false), none, '0, 'Nat) .\nred metaParseStrategy(upModule('NAT, false), none, 'idle) .\nred metaParse(upModule('NAT, false), none, '0, 'Nat) ."
    },
    {
        "file": "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> ____(OP_0)____ [ctor] .\n  vars F ____(VAR_0)____ : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug found by Paco where the condition evaluation set unrewritable/unstackable flags\n***\tthat were respect when rewriting with ab, even though it allows rewriting with nonexec rules.\n***\n\nmod NONEXEC is\n  sorts Foo Bar .\n  ops a b : -> Foo [ctor] .\n  op <_> : Foo -> Bar [ctor] .\n  vars F G : Foo .\n  crl < F > => < G > if F => G /\\ F =/= G .\n  rl [ab] : a => b [nonexec] .\nendm\n\nsrew < a > using try(all) ; ab ."
    },
    {
        "file": "MAUDE-1/CUIbug12-22-09.maude",
        "incomplete": "***(\nBug discovered 12/22/09.\n\nCUI_DagNode::stackArguments() checks the wrong UNSTACKABLE flag for the\nsecond argument resulting in a missed rewrite.\n\nResolved in alpha92b.\n)\nset show timing off .\n\nmod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl c => d .\nendm\n\nrew f(a, g(b)) .\n\n***(\nfirst pass:\nf does not rewrite - marked unrewritable\nf stacks a and g(b)\na does not rewrite - marked unrewritable\ng(b) does not rewrite - marked unrewritable\na does not stack anything and is unrewritable - marked unstackable\ng stacks b\nb rewrites to c and we rebuild f(a, g(c)) with only the a node shared\nwith the previous dag\n\nsecond pass:\nf is unrewritable\nf cannot stack a because it is unstackable\nf cannot stack g(c) because we check the wrong unstackable flag\n\nthus we miss c => d\n)\n\nmod CUI-BUG2 is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl g(c) => d .\nendm\n\nrew f(a, g(b)) .",
        "complete:": "***(\nBug discovered 12/22/09.\n\nCUI_DagNode::stackArguments() checks the wrong UNSTACKABLE flag for the\nsecond argument resulting in a missed rewrite.\n\nResolved in alpha92b.\n)\nset show timing off .\n\nmod CUI-BUG is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl c => d .\nendm\n\nrew f(a, g(b)) .\n\n***(\nfirst pass:\nf does not rewrite - marked unrewritable\nf stacks a and g(b)\na does not rewrite - marked unrewritable\ng(b) does not rewrite - marked unrewritable\na does not stack anything and is unrewritable - marked unstackable\ng stacks b\nb rewrites to c and we rebuild f(a, g(c)) with only the a node shared\nwith the previous dag\n\nsecond pass:\nf is unrewritable\nf cannot stack a because it is unstackable\nf cannot stack g(c) because we check the wrong unstackable flag\n\nthus we miss c => d\n)\n\nmod CUI-BUG2 is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl g(c) => d .\nendm\n\nrew f(a, g(b)) ."
    },
    {
        "file": "MAUDE-1/CUI_OccursCheckSeptember2020.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for nontermination in U and CU unification due to\n***\tnot doing an indirect occurs check. We use irred because\n***\twe might reduce the number of redundant unifiers in the\n***\tfuture.\n***\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op ____(OP_1)____ : ____(OP_0)____ Foo -> Foo [id: 1] .\nvars A B ____(VAR_0)____ X Y ____(VAR_1)____ : Foo .\nendfm\n\nirred unify X =? f(Z, ____(EQ_3)____) /\\ Z =? f(____(EQ_0)____, Y) /\\ f(X, ____(EQ_1)____) =? f(____(EQ_7)____, B) .\nirred unify f(____(EQ_2)____, Y) =? a /\\ Z =? f(X, ____(EQ_6)____) /\\ X =? f(____(EQ_4)____, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(____(EQ_5)____, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op ____(OP_3)____ : Foo Foo -> Foo [comm ____(OP_2)____ 1] .\nvars A ____(VAR_2)____ C X Y ____(VAR_3)____ : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for nontermination in U and CU unification due to\n***\tnot doing an indirect occurs check. We use irred because\n***\twe might reduce the number of redundant unifiers in the\n***\tfuture.\n***\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [comm id: 1] .\nvars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y)  .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) ."
    },
    {
        "file": "MAUDE-1/CU_Unification.maude",
        "incomplete": "set show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : ____(OP_0)____ Foo -> Foo [left ____(OP_1)____ 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X ____(VAR_1)____ ____(VAR_0)____ : Foo .\nendfm\n\nunify f(____(EQ_0)____, Y) =? f(U, ____(EQ_4)____) .\nvariant unify f(X, ____(EQ_1)____) =? f(U, ____(EQ_6)____) .\n\nunify f(____(EQ_2)____, Y) =? X .\nvariant unify f(X, ____(EQ_3)____) =? X .\n\nunify f(X, ____(EQ_5)____) =? Y .\nvariant unify f(____(EQ_7)____, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : ____(OP_2)____ Foo -> Foo [right ____(OP_3)____ 1f] .\n  op 1f : -> Foo .\n\n  vars U ____(VAR_2)____ W X ____(VAR_3)____ Z : Foo .\nendfm\n\nunify f(X, ____(EQ_10)____) =? f(____(EQ_8)____, V) .\nvariant unify f(X, ____(EQ_11)____) =? f(U, ____(EQ_9)____) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op ____(OP_4)____ : Foo Foo -> Foo [____(OP_5)____ 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y ____(VAR_4)____ : ____(VAR_5)____ .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm ____(OP_7)____ ____(OP_6)____] .\n  op 1f : -> Foo .\n\n  vars U V ____(VAR_7)____ X Y Z : ____(VAR_6)____ .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .",
        "complete:": "set show timing off .\n\n*** Ul theory\n\nfmod FOO is\n  sort Foo .\n  op f : Foo Foo -> Foo [left id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** Ur theory\n\nfmod FOO2 is\n  sort Foo .\n  op f : Foo Foo -> Foo [right id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** U theory\n\nfmod FOO3 is\n  sort Foo .\n  op f : Foo Foo -> Foo [id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n\n*** CU theory\n\nfmod FOO4 is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\nendfm\n\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y ."
    },
    {
        "file": "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug in tuple creation for unifier filtering if the unifiers\n***\tare degenerate.\n***\n\nfiltered variant unify in NAT : 1 =? 1 ."
    },
    {
        "file": "MAUDE-1/dekker.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> Program .\n  op if_then_fi : Test Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n  inc TESTS .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***(\nDekker's algorithm is generally defined with two processes on a shared\nmemory machine specified in an imperative language. Rather than give a\ntranslation of Dekker's algorithm into rewriting logic we give a deep\nembedding of a toy language just powerful enough to express Dekker's\nalgorithm.\n)\n\nload model-checker\n\n***(\nNaive model of memory with locations named by Qids and holding\nInts.\n)\n\nfmod MEMORY is\n  inc INT .\n  inc QID .\n\n  sorts Memory .\n  op none : -> Memory .\t\n  op __ : Memory Memory -> Memory [assoc comm id: none] .\n  op [_,_] : Qid Int -> Memory .\nendfm\n\n***(\nEquality test comparing the contents of a named memory location to a\ngiven machine integer.\n)\n\nfmod TESTS is\n  inc MEMORY .\n\n  sort Test .\n  op _=_ : Qid Int -> Test .\n  op eval : Test Memory -> Bool .\n\n  var Q : Qid .\n  var M : Memory .\n  vars N N' : Int .\n\n  eq eval(Q = N, [Q, N'] M) = N == N' .\nendfm\n\n***(\nSyntax for a trival sequential programming langauge.\n)\n\nfmod SEQUENTIAL is\n  inc TESTS .\n\n  sorts UserStatement Program .\n  subsort UserStatement < Program .\n  op skip : -> Program .\n  op _;_ : Program Program -> Program [prec 61 assoc id: skip] .\n  op _:=_ : Qid Int -> Program .\n  op if_then_fi : Test Program -> Program .\n  op while_do_od : Test Program -> Program .\n  op repeat_forever : Program -> Program .\nendfm\n\n***(\nProcesses have a process identifier and a program.\nThe machine state is a soup of processes, a shared memory and a\nprocess identifier. The latter records the id of the last process\nto execute and is needed to talk about fairness. The operational\nsemantics of the programming language running on this machine is given\nby just 5 rules.\n)\n\nmod PARALLEL is\n  inc SEQUENTIAL .\n  inc TESTS .\n\n  sorts Pid Process Soup MachineState .\n  subsort Process < Soup .\n  op [_,_] : Pid Program -> Process .\n  op empty : -> Soup .\n  op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .\n  op {_,_,_} : Soup Memory Pid -> MachineState .\n\n  vars P R : Program .\n  var S : Soup .\n  var U : UserStatement .\n  vars I J : Pid .\n  var M : Memory .\n  var Q : Qid .\n  vars N X : Int .\n  var T : Test .\n\n  rl {[I, U ; R] | S, M, J} => {[I, R] | S, M, I} .\n\n  rl {[I, (Q := N) ; R] | S, [Q, X] M, J} =>\n\t{[I, R] | S, [Q, N] M, I} .\n\n  rl {[I, if T then P fi ; R] | S, M, J} =>\n\t{[I, if eval(T, M) then P else skip fi ; R] | S, M, I} .\n\n  rl {[I, while T do P od ; R] | S, M, J} =>\n        {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R]\n         | S, M, I} .\n\n  rl {[I, repeat P forever ; R] | S, M, J} =>\n\t{[I, P ; repeat P forever ; R] | S, M, I} .\nendm\n\n***(\nThe classical Dekker's algorithm for mutual exclusion between two\nprocesses using 3 variables, 'c1, 'c2 and 'turn, in shared memory.\ncrit is used to represent the critical section and rem is used to\nrepresent the remainder (non-critical) part of each program.\n)\n\nmod DEKKER is\n  inc PARALLEL .\n  subsort Int < Pid .\n  ops crit rem : -> UserStatement .\n  ops p1 p2 : -> Program .\n  op initialMem : -> Memory .\n  op initial : -> MachineState .\n\n  eq p1 =\n\trepeat\n\t  'c1 := 0 ;\n\t  while 'c2 = 0 do\n\t    if 'turn = 2 then \n\t      'c1 := 1 ;\n\t      while 'turn = 2 do skip od ;\n\t      'c1 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 2 ;\n\t  'c1 := 1 ;\n\t  rem\n\tforever .\n\n  eq p2 =\n\trepeat\n\t  'c2 := 0 ;\n\t  while 'c1 = 0 do\n\t    if 'turn = 1 then \n\t      'c2 := 1 ;\n\t      while 'turn = 1 do skip od ;\n\t      'c2 := 0\n\t    fi\n\t  od ;\n\t  crit ;\n\t  'turn := 1 ;\n\t  'c2 := 1 ;\n\t  rem\n\tforever .\n\n  eq initialMem = ['c1, 1] ['c2, 1] ['turn, 1] .\n  eq initial = { [1, p1] | [2, p2], initialMem, 0 } .\nendm\n\n***(\nThe model check. Note how the operation enterCrit is used to represent\ntwo propositions: enterCrit(1) means process 1 is about to enter it's\ncritical section and enterCrit(2) means process 2 is about to enter\nit's critical section. Similarly exec(1) means process 1 just executed\nand exec(2) means process 2 just executed.\n)\n\nmod CHECK is\n  inc DEKKER .\n  inc MODEL-CHECKER .\n  subsort MachineState < State .\n  ops enterCrit exec : Pid -> Prop .\n\n  var M : Memory .\n  vars R : Program .\n  var S : Soup .\n  vars I J : Pid .\n\n  eq {[I, crit ; R] | S, M, J} |= enterCrit(I) = true .\n  eq {S, M, J} |= exec(J) = true .\nendm\n\n***(\nSafety: we check that always we are not in a state where p1 is about\nto enter it's critical section and p2 is about to enter it's critical\nsection.\n)\n\nred modelCheck(initial, [] ~ (enterCrit(1) /\\ enterCrit(2))) .\n\n***(\n\"Strong\" liveness: if p1 gets to execute infinitely often then it\nenters it's critical section infinitely often. This is not true\nwith Dekker's algorithm.\n)\n\nred modelCheck(initial, []<> exec(1) -> []<> enterCrit(1)) .\n*** Counterexample has a 9 state lead in to a 2 state cycle.\n\n***(\n\"Weaker\" liveness: if p1 and p2 both get to execute infinitely often\nthen p1 and p2 both enter their critical sections infinitely often.\n)\n\nred modelCheck(initial, ([]<> exec(1) /\\ []<> exec(2)) ->\n    ([]<> enterCrit(1) /\\ []<> enterCrit(2))) ."
    },
    {
        "file": "MAUDE-1/deleteTimerMarch2021.maude",
        "incomplete": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where deleteTimer() left the interpreter in an\n***\tinconsistent state and caused a crash on the next rewrite\n***\tcommand.\n***\n\nload time\n\nmod TEST is\n  inc TIME .\n  op myClass : -> Cid .\n  ops me : -> Oid .\n\nvars ____(VAR_0)____ O2 O3 : Oid .\n  rl < O : myClass | none > createdTimer(O, O2, O3) =>\n     < O : myClass | none > deleteTimer(O3, me) .\nendm\n\nerew <> < me : myClass | none > createTimer(timeManager, ____(EQ_0)____) .\nred 0 .",
        "complete:": "set show timing off .\nset show advisories off .\n\n***\n***\tTest for bug where deleteTimer() left the interpreter in an\n***\tinconsistent state and caused a crash on the next rewrite\n***\tcommand.\n***\n\nload time\n\nmod TEST is\n  inc TIME .\n  op myClass : -> Cid .\n  ops me : -> Oid .\n\nvars O O2 O3 : Oid .\n  rl < O : myClass | none > createdTimer(O, O2, O3) =>\n     < O : myClass | none > deleteTimer(O3, me) .\nendm\n\nerew <> < me : myClass | none > createTimer(timeManager, me) .\nred 0 ."
    },
    {
        "file": "MAUDE-1/dining-philosophers5.maude",
        "incomplete": "set show timing off .\nset show advisories off .\nset verbose on .\n\n---- 5 DINING PHILOSOPHERS\n***(\n    Real-Time Maude 2.4 interpreter extension of Full Maude 2.4.\n\n    Real-Time Maude built by Peter Olveczky on top of\n    Full Maude built by Francisco Duran.\n\n    Copyright 1997-2007 SRI International, Menlo Park, CA 94025, USA.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n)***\n\nfmod TIME is\n   sorts Time NzTime .\n   subsort NzTime < Time .\n\n   op zero : -> Time .\n   op _plus_ : ____(OP_1)____ Time -> Time [assoc comm ____(OP_0)____ 33 ____(OP_3)____ (E ____(OP_2)____)] .\n   op _monus_ : ____(OP_4)____ ____(OP_5)____ -> Time [____(OP_6)____ 33 gather (E e)] .\n   op _le_ : ____(OP_8)____ Time -> Bool [____(OP_7)____ 37] .\n   op _lt_ : Time Time -> ____(OP_10)____ [____(OP_9)____ 37] .\n   op _ge_ : ____(OP_11)____ ____(OP_12)____ -> Bool [prec 37] .\n   op _gt_ : ____(OP_14)____ Time -> Bool [____(OP_13)____ 37] .\n\n   eq zero plus R:Time = R:Time .\n   eq R:Time le R':Time = (R:Time lt R':Time) or (R:Time == R':Time) .\n   eq R:Time ge R':Time = R':Time le R:Time .\n   eq R:Time gt R':Time = R':Time lt R:Time .\nendfm\n\nview Time from TRIV to TIME is\n  sort Elt to Time .\nendv\n\n*** Module TIME-INF:\nfmod TIME-INF is\n  including TIME .\n  sort TimeInf .\n  subsort Time < TimeInf .\n\n  op INF : -> TimeInf .\n  op _plus_ : ____(OP_16)____ TimeInf -> TimeInf [____(OP_15)____] .\n  op ____(OP_18)____ : TimeInf ____(OP_17)____ -> TimeInf [ditto] .\n  op _le_ : ____(OP_19)____ TimeInf -> Bool [prec ____(OP_20)____] .\n  op _lt_ : TimeInf TimeInf -> Bool [____(OP_21)____ ____(OP_22)____] .\n  op ____(OP_24)____ : ____(OP_23)____ TimeInf -> Bool [prec 37] .\n  op ____(OP_26)____ : TimeInf TimeInf -> ____(OP_25)____ [prec 37] .\n\n  var TI TI' : TimeInf .\n  var R : Time .\n\n  eq INF plus TI = INF .\n  eq INF monus R = INF .\n  eq TI le INF = true .\n  eq INF le R = false .\n  eq INF lt TI = false .\n  eq R lt INF = true .\n  eq TI gt TI' = TI' lt TI .\n  eq TI ge TI' = TI' le TI .\nendfm\n\n*** Now for linear time ...\n\nfmod LTIME is\n  including TIME .\n\n  ops minimum maximum : Time Time -> Time [assoc comm] .\n\n  vars ____(VAR_0)____ R' : Time .\n  ceq maximum(____(EQ_9)____, R') = R if R' le R .\n  ceq minimum(R, R') = R' if R' le R .\nendfm\n\n\n\n*** Linear time with infinity value:\n\nfmod LTIME-INF is\n  including LTIME .\n  including TIME-INF .\n\n  ops minimum maximum : TimeInf TimeInf -> TimeInf [ditto] .\n\n  eq maximum(INF, ____(EQ_4)____) = INF .\n  eq minimum(INF, ____(EQ_7)____) = TI:TimeInf .\nendfm\n\n\n\n*** Discrete time domain, the natural numbers ...\n\nfmod NAT-TIME-DOMAIN is\n  inc LTIME .\n  protecting NAT .\n\n  subsort Nat < Time .\n  subsort NzNat < NzTime .\n\n  vars N N' : ____(VAR_1)____ .\n\n  eq zero = 0 .\n  eq N plus N' = N + N' .\n  eq N monus N' = if N > N' then sd(N, N') else 0 fi .\n  eq N lt N' = N < N' .\nendfm\n\n\n\nfmod NAT-TIME-DOMAIN-WITH-INF is\n  protecting NAT-TIME-DOMAIN .\n  including LTIME-INF .\n\n  --- should for simplicity extend <, >=, etc to infinity:\n\n  op _<_ : TimeInf TimeInf -> ____(OP_28)____ [____(OP_27)____] .\n  op _<____(OP_29)____ : ____(OP_30)____ TimeInf -> Bool [ditto] .\n  op ____(OP_32)____>_ : TimeInf TimeInf -> ____(OP_31)____ [ditto] .\n  op _>=_ : ____(OP_33)____ TimeInf -> Bool [____(OP_34)____] .\n\n  op _+_ : ____(OP_36)____ TimeInf -> TimeInf [____(OP_35)____] .\n\n  var N : Nat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq N < INF = true .\n  eq TI <= INF = true .\n  eq INF <= N = false .\n  eq INF >= TI = true .\n  eq N >= INF = false .\n  eq TI > INF = false .\n  eq INF > N = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\nendfm\n\n\n--- changed!\n*** --------------------------\nfmod POSITIVE-RAT is\n  protecting RAT .\n\n  sort NNegRat .                 --- non-negative rationals!\n  subsorts Zero PosRat Nat < NNegRat < Rat .\nendfm\n\n\n\nfmod POSRAT-TIME-DOMAIN is\n  inc LTIME .\n  protecting POSITIVE-RAT .\n\n  subsort NNegRat < Time .\n  subsort PosRat < NzTime .\n\n  vars R R' : ____(VAR_2)____ .\n\n  eq zero = 0 .\n  eq R plus R' = R + R' .\n  eq R monus R' = if R > R' then R - R' else 0 fi .\n  eq R lt R' = R < R' .\nendfm\n\n\n\nfmod POSRAT-TIME-DOMAIN-WITH-INF is\n  protecting POSRAT-TIME-DOMAIN .\n  including LTIME-INF .\n\n  --- again, we should extend the comparison operators to infinity:\n  op ____(OP_38)____<_ : TimeInf TimeInf -> Bool [____(OP_37)____] .\n  op _<=_ : TimeInf TimeInf -> ____(OP_40)____ [____(OP_39)____] .\n  op _>_ : ____(OP_41)____ TimeInf -> Bool [____(OP_42)____] .\n  op _>=_ : ____(OP_43)____ TimeInf -> ____(OP_44)____ [ditto] .\n\n  op _+_ : ____(OP_45)____ ____(OP_46)____ -> TimeInf [ditto] .\n  op _+_ : ____(OP_47)____ NNegRat -> NNegRat [____(OP_48)____] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : ____(OP_49)____ ____(OP_50)____ -> Zero [ditto] .\n  op max : Zero ____(OP_51)____ -> NzNat [____(OP_52)____] .\n  op max : Rat ____(OP_53)____ -> TimeInf [____(OP_54)____] .\n  op max : Rat ____(OP_55)____ -> ____(OP_56)____ [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : ____(OP_57)____ Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    ----sort Philosopher .\n    ----subsort Philosopher < Cid .\n    ----op Philosopher : -> Philosopher [ctor] .\n    ----op status :_ : Status -> Attribute [ctor gather (&)] .\n    ----op chopsticks :_ : Nat -> Attribute [ctor gather (&)] .\n    ----op timer :_ : Time -> Attribute [ctor gather (&)] .\n\n    class Chopstick .\n    ---- sort Chopstick .\n    ---- subsort Chopstick < Cid .\n    ---- op Chopstick : -> Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I ____(VAR_4)____ N M K : ____(VAR_3)____ .\n    vars ____(VAR_5)____ Atts1 Atts2 : AttributeSet .\n    vars T T' : ____(VAR_6)____ .\n    var ____(EQ_3)____ : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : P:Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : P:Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op ____(OP_65)____ : Configuration -> Time .\n    eq mte(< ____(EQ_2)____, Atts1 > Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration ____(OP_66)____ -> Configuration .\n    eq delta(< ____(EQ_0)____ > ____(EQ_1)____, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : ____(OP_67)____ -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat ____(OP_68)____ -> Prop .\n    op phil-sticks : Nat Nat -> ____(OP_69)____ .\n    \n    vars P N : ____(VAR_7)____ .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, ____(EQ_5)____) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(____(EQ_6)____, 1) /\\ phil-sticks(4, 1))) .",
        "complete:": "set show timing off .\nset show advisories off .\nset verbose on .\n\n---- 5 DINING PHILOSOPHERS\n***(\n    Real-Time Maude 2.4 interpreter extension of Full Maude 2.4.\n\n    Real-Time Maude built by Peter Olveczky on top of\n    Full Maude built by Francisco Duran.\n\n    Copyright 1997-2007 SRI International, Menlo Park, CA 94025, USA.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n)***\n\nfmod TIME is\n   sorts Time NzTime .\n   subsort NzTime < Time .\n\n   op zero : -> Time .\n   op _plus_ : Time Time -> Time [assoc comm prec 33 gather (E e)] .\n   op _monus_ : Time Time -> Time [prec 33 gather (E e)] .\n   op _le_ : Time Time -> Bool [prec 37] .\n   op _lt_ : Time Time -> Bool [prec 37] .\n   op _ge_ : Time Time -> Bool [prec 37] .\n   op _gt_ : Time Time -> Bool [prec 37] .\n\n   eq zero plus R:Time = R:Time .\n   eq R:Time le R':Time = (R:Time lt R':Time) or (R:Time == R':Time) .\n   eq R:Time ge R':Time = R':Time le R:Time .\n   eq R:Time gt R':Time = R':Time lt R:Time .\nendfm\n\nview Time from TRIV to TIME is\n  sort Elt to Time .\nendv\n\n*** Module TIME-INF:\nfmod TIME-INF is\n  including TIME .\n  sort TimeInf .\n  subsort Time < TimeInf .\n\n  op INF : -> TimeInf .\n  op _plus_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _monus_ : TimeInf Time -> TimeInf [ditto] .\n  op _le_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _lt_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _ge_ : TimeInf TimeInf -> Bool [prec 37] .\n  op _gt_ : TimeInf TimeInf -> Bool [prec 37] .\n\n  var TI TI' : TimeInf .\n  var R : Time .\n\n  eq INF plus TI = INF .\n  eq INF monus R = INF .\n  eq TI le INF = true .\n  eq INF le R = false .\n  eq INF lt TI = false .\n  eq R lt INF = true .\n  eq TI gt TI' = TI' lt TI .\n  eq TI ge TI' = TI' le TI .\nendfm\n\n*** Now for linear time ...\n\nfmod LTIME is\n  including TIME .\n\n  ops minimum maximum : Time Time -> Time [assoc comm] .\n\n  vars R R' : Time .\n  ceq maximum(R, R') = R if R' le R .\n  ceq minimum(R, R') = R' if R' le R .\nendfm\n\n\n\n*** Linear time with infinity value:\n\nfmod LTIME-INF is\n  including LTIME .\n  including TIME-INF .\n\n  ops minimum maximum : TimeInf TimeInf -> TimeInf [ditto] .\n\n  eq maximum(INF, TI:TimeInf) = INF .\n  eq minimum(INF, TI:TimeInf) = TI:TimeInf .\nendfm\n\n\n\n*** Discrete time domain, the natural numbers ...\n\nfmod NAT-TIME-DOMAIN is\n  inc LTIME .\n  protecting NAT .\n\n  subsort Nat < Time .\n  subsort NzNat < NzTime .\n\n  vars N N' : Nat .\n\n  eq zero = 0 .\n  eq N plus N' = N + N' .\n  eq N monus N' = if N > N' then sd(N, N') else 0 fi .\n  eq N lt N' = N < N' .\nendfm\n\n\n\nfmod NAT-TIME-DOMAIN-WITH-INF is\n  protecting NAT-TIME-DOMAIN .\n  including LTIME-INF .\n\n  --- should for simplicity extend <, >=, etc to infinity:\n\n  op _<_ : TimeInf TimeInf -> Bool [ditto] .\n  op _<=_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n\n  var N : Nat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq N < INF = true .\n  eq TI <= INF = true .\n  eq INF <= N = false .\n  eq INF >= TI = true .\n  eq N >= INF = false .\n  eq TI > INF = false .\n  eq INF > N = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\nendfm\n\n\n--- changed!\n*** --------------------------\nfmod POSITIVE-RAT is\n  protecting RAT .\n\n  sort NNegRat .                 --- non-negative rationals!\n  subsorts Zero PosRat Nat < NNegRat < Rat .\nendfm\n\n\n\nfmod POSRAT-TIME-DOMAIN is\n  inc LTIME .\n  protecting POSITIVE-RAT .\n\n  subsort NNegRat < Time .\n  subsort PosRat < NzTime .\n\n  vars R R' : NNegRat .\n\n  eq zero = 0 .\n  eq R plus R' = R + R' .\n  eq R monus R' = if R > R' then R - R' else 0 fi .\n  eq R lt R' = R < R' .\nendfm\n\n\n\nfmod POSRAT-TIME-DOMAIN-WITH-INF is\n  protecting POSRAT-TIME-DOMAIN .\n  including LTIME-INF .\n\n  --- again, we should extend the comparison operators to infinity:\n  op _<_ : TimeInf TimeInf -> Bool [ditto] .\n  op _<=_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>_ : TimeInf TimeInf -> Bool [ditto] .\n  op _>=_ : TimeInf TimeInf -> Bool [ditto] .\n\n  op _+_ : TimeInf TimeInf -> TimeInf [ditto] .\n  op _+_ : NNegRat NNegRat -> NNegRat [ditto] .\n\n  var R : NNegRat .  var TI : TimeInf .\n\n  eq INF < TI = false .\n  eq R < INF = true .\n  eq TI <= INF = true .\n  eq INF <= R = false .\n  eq INF >= TI = true .\n  eq R >= INF = false .\n  eq TI > INF = false .\n  eq INF > R = true .\n\n  eq INF + TI = INF .\n\n  --- NEW: must also extend the built-in 'min' and'max' to TimeInf:\n  ops min max : TimeInf TimeInf -> TimeInf [ditto] .\n  eq max(INF, TI:TimeInf) = INF .\n  eq min(INF, TI:TimeInf) = TI:TimeInf .\n\n  --- Some additional declarations for preregularity:\n  ops min max : NNegRat NNegRat -> NNegRat [ditto] .\n  ops min max : Zero Zero -> Zero [ditto] .\n  op min : Zero NzNat -> Zero [ditto] .\n  op max : Zero NzNat -> NzNat [ditto] .\n  op max : Rat TimeInf -> TimeInf [ditto] .\n  op max : Rat NNegRat -> NNegRat [ditto] .\nendfm\n\nomod DINING-PHILOSOPHERS is\n    protecting POSRAT-TIME-DOMAIN-WITH-INF .\n    including CONFIGURATION .\n\n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    ----sort Philosopher .\n    ----subsort Philosopher < Cid .\n    ----op Philosopher : -> Philosopher [ctor] .\n    ----op status :_ : Status -> Attribute [ctor gather (&)] .\n    ----op chopsticks :_ : Nat -> Attribute [ctor gather (&)] .\n    ----op timer :_ : Time -> Attribute [ctor gather (&)] .\n\n    class Chopstick .\n    ---- sort Chopstick .\n    ---- subsort Chopstick < Cid .\n    ---- op Chopstick : -> Chopstick .\n\n    subsort Nat < Oid .\n\n    vars I J N M K : Nat .\n    vars Atts Atts1 Atts2 : AttributeSet .\n    vars T T' : Time .\n    var Conf : Configuration .\n    \n    rl [get-hungry] :\n         < I : Philosopher | status : thinking, timer : 0 > \n      => < I : Philosopher | status : hungry > .\n    crl [grab-stick] :\n         < I : Philosopher | status : hungry, chopsticks : N >\n         < J : Chopstick | >\n      => < I : Philosopher | chopsticks : s N >\n      if I == J or (s I == J or (I == 4 and J == 0)) .\n    rl [eat] :\n         < I : Philosopher | status : hungry, chopsticks : 2 >\n      => < I : Philosopher | status : eating, timer : EATING-TIME > .\n    rl [stop-eating] :\n         < I : P:Philosopher | status : eating, chopsticks : 0, timer : 0, Atts1 >\n      => < I : P:Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME, Atts1 >\n         < I : Chopstick | none >\n         < if I == 4 then 0 else s I fi : Chopstick | none > \n         [dnt] .\n\n    op mte : Configuration -> Time .\n    eq mte(< I : Philosopher | timer : T, Atts1 > Conf) \n      = minimum(T, mte(Conf)) .\n    eq mte(Conf) = 0 [owise] .\n\n    op delta : Configuration Time -> Configuration .\n    eq delta(< I : Philosopher | timer : T > Conf, T') \n      = < I : Philosopher | timer : T - T' > delta(Conf, T') .\n\n    crl [tick] : { Conf, T } => { delta(Conf, T'), T + T' }\n      if T' := mte(Conf) \n      /\\ T' > 0 \n      /\\ T < 1000 .\n \n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n      = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\nendom\n\nred initState .\nsearch [1] initState =>! S:System .\n\nload model-checker.maude\n\nomod DINING-PHILOSOPHERS-PREDS is\n    protecting DINING-PHILOSOPHERS .\n    including SATISFACTION .\n    subsort System < State .\n   \n    op phil-status : Nat Status -> Prop .\n    op phil-sticks : Nat Nat -> Prop .\n    \n    vars P N : Nat .\n    var  Conf : Configuration .\n    var  St : Status .\n    var  Atts : AttributeSet .\n    var  T : Time . \n   \n    eq { < P : Philosopher | status : St > Conf, T } |= phil-status(P, St) = true .\n    eq { < P : Philosopher | chopsticks : N > Conf, T } |= phil-sticks(P, N) = true .\n  endom\n\n  omod DINING-PHILOSOPHERS-5-CHECK is\n    protecting DINING-PHILOSOPHERS-PREDS .\n    including MODEL-CHECKER .\n    including LTL-SIMPLIFIER .\n  endom\n\nred modelCheck(initState, [] ~ (phil-sticks(0, 1) /\\ phil-sticks(1, 1) /\\ phil-sticks(2, 1) /\\ phil-sticks(3, 1) /\\ phil-sticks(4, 1))) ."
    },
    {
        "file": "MAUDE-1/diophantine.maude",
        "incomplete": "set show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector, \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1),\n\"gcd\"\n) .",
        "complete:": "set show timing off .\n\nload linear\n\n*** 10 solution system from Domenjoud LNCS 520\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n(1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n),\nzeroVector, \"cd\"\n) .\n\n*** sailors and monkey from Contejean and Devie 1994\n\nred natSystemSolve(\n(\n(0,0) |-> 1 ; (0,1) |-> -5 ;\n(1,1) |-> 4 ; (1,2) |-> -5 ;\n(2,2) |-> 4 ; (2,3) |-> -5 ;\n(3,3) |-> 4 ; (3,4) |-> -5 ;\n(4,4) |-> 4 ; (4,5) |-> -5 ;\n(5,5) |-> 4 ; (5,6) |-> -5\n),\n(0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4 |-> 1 ; 5 |-> 1),\n\"gcd\"\n) ."
    },
    {
        "file": "MAUDE-1/doubleAttributeFebruary2023.maude",
        "incomplete": "***\n***\tTest for warning with double iter attribute.\n***\n\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [____(OP_0)____ ____(OP_1)____] .\nendfm",
        "complete:": "***\n***\tTest for warning with double iter attribute.\n***\n\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm"
    },
    {
        "file": "MAUDE-1/Example1.maude",
        "incomplete": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .",
        "complete:": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! ."
    },
    {
        "file": "MAUDE-1/Example3.maude",
        "incomplete": "***(\n3. Assume that N is as before\nNode N {\n StartCondition: LookUpOnChange(X,5) >= 9\n x := LookUpNow(X)\n}\n\nand that Sigma(I,X) = 8, Gamma(i-1,X) = 11. The execution of N ends with x\nhaving a value of 11 (independently of the fact that the \"real\" value of X,\ni.e., Sigma(i,X) = 1,  isn't >= 9).\n\nExplanation:\nSince there is a monitor on the variable X and that monitor doesn't hold at\ncurrent time, Gamma(i,X) gets the value Gamma(i-1,X), i.e., 11. By\ndefinition, both LookUpOnChange(X,5) and LookUpNow(X) evaluate to Gamma(i,X)\n= 11. \n***)\n\nmod EXAMPLE3 is\n protecting PLEXILITE-PREDS .\n\n op Example3 : -> Plexil .\n eq Example3 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   lookupOnChange('X,v(5)) >= const(v(9))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example3Env : -> ContextList .\n eq Example3Env = ('X : v(3)) # ('X : v(7)) # ('X : v(11)) .\n\nendm\n\neof\n\nsrew compile(Example3Env,Example3) using micro ! .\nsrew compile(Example3Env,Example3) using micro ! ; macro ; micro ! .",
        "complete:": "***(\n3. Assume that N is as before\nNode N {\n StartCondition: LookUpOnChange(X,5) >= 9\n x := LookUpNow(X)\n}\n\nand that Sigma(I,X) = 8, Gamma(i-1,X) = 11. The execution of N ends with x\nhaving a value of 11 (independently of the fact that the \"real\" value of X,\ni.e., Sigma(i,X) = 1,  isn't >= 9).\n\nExplanation:\nSince there is a monitor on the variable X and that monitor doesn't hold at\ncurrent time, Gamma(i,X) gets the value Gamma(i-1,X), i.e., 11. By\ndefinition, both LookUpOnChange(X,5) and LookUpNow(X) evaluate to Gamma(i,X)\n= 11. \n***)\n\nmod EXAMPLE3 is\n protecting PLEXILITE-PREDS .\n\n op Example3 : -> Plexil .\n eq Example3 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   lookupOnChange('X,v(5)) >= const(v(9))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example3Env : -> ContextList .\n eq Example3Env = ('X : v(3)) # ('X : v(7)) # ('X : v(11)) .\n\nendm\n\neof\n\nsrew compile(Example3Env,Example3) using micro ! .\nsrew compile(Example3Env,Example3) using micro ! ; macro ; micro ! ."
    },
    {
        "file": "MAUDE-1/fakeParameterConstant.maude",
        "incomplete": "***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op ____(OP_0)____ : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> ____(OP_1)____ [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .",
        "complete:": "***\n***\tTest that fake parameter constant isn't treated like one.\n***\n\nfth T is\n  sort Elt .\n  op c : -> Elt [pconst] .\nendfth\n\nfmod FOO{X :: T} is\n  op X$d : -> X$Elt [pconst] .\n  eq X$c = X$d .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all ."
    },
    {
        "file": "MAUDE-1/fakeParameterSort.maude",
        "incomplete": "***\n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < X$Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all .",
        "complete:": "***\n***\tTest that fake parameter sort isn't treated like one.\n***\n\nfth T is\n  sort Elt .\nendfth\n\nfmod FOO{X :: T} is\n  sort X$Foo .\n  subsort X$Foo < X$Elt .\nendfm\n\nfmod BAR{Y :: T} is\n  inc FOO{Y} .\nendfm\n\nshow all ."
    },
    {
        "file": "MAUDE-1/filteredVariantUnifyJune2023.maude",
        "incomplete": "set show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op ____(OP_0)____ : -> Nat [ctor] .\n  op s : ____(OP_1)____ -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : ____(OP_2)____ -> Stk [ctor] .\n  op ____(OP_5)____ : Stk Stk -> Stk [____(OP_4)____ assoc ____(OP_3)____ emp] .\n  op ____(OP_6)____ : ____(OP_7)____ Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : [Stk] .\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches",
        "complete:": "set show timing off .\n\n***\n***\tBug reported by UberPyro on github:\n***\t https://github.com/SRI-CSL/Maude/issues/11\n***\tCode used with permission.\n***\n\nfmod SUB-STACK is\n  sorts Nat Stk .\n  op 0 : -> Nat [ctor] .\n  op s : Nat -> Nat [ctor] .\n\n  subsort Nat < Stk .\n  op emp : -> Stk .\n  op mk : Nat -> Stk [ctor] .\n  op _*_ : Stk Stk -> Stk [ctor assoc id: emp] .\n  op _+_ : Stk Stk -> Stk [ctor assoc comm] .\n\n  vars X Y : [Stk] .\n  eq [sub] : (X * Y) + X = X [variant] .\n\nendfm\n\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** OK\n\nfiltered variant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk .\n*** failed to terminate because we weren't tracking the accumulated substitution\n*** when computing variant subsumption - reducibility considerations are critical\n*** for pruning branches"
    },
    {
        "file": "MAUDE-1/generatedByFebruary2023.maude",
        "incomplete": "***\n***\tTest that generated-by is recognized as ending the previous mixfix statement.\n***\n\nfmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared .",
        "complete:": "***\n***\tTest that generated-by is recognized as ending the previous mixfix statement.\n***\n\nfmod FOO is\n  eq 5 = 1 .\n  generated-by NAT .\nendfm\n\nshow desugared ."
    },
    {
        "file": "MAUDE-1/hf-sets.maude",
        "incomplete": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : ____(OP_0)____ Magma -> Magma [ctor assoc ____(OP_1)____] .\n    op {____(OP_2)____} : Magma -> Set [ctor] .\n    op {} : -> Set [____(OP_3)____] .\n\n    vars M M' : ____(VAR_0)____ ____(VAR_1)____              vars ____(VAR_2)____ ____(VAR_3)____ T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {____(EQ_40)____}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({____(EQ_23)____}), S) .\n\n    op ____(OP_10)____ : Set Set -> Set .\n    eq [61]: augment({}, ____(EQ_33)____) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, ____(EQ_32)____) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({____(EQ_1)____},@6:Set)U augment({____(EQ_5)____},@6:Set)U augment({____(EQ_4)____},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({____(EQ_15)____},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({____(EQ_17)____})U augment(P({____(EQ_13)____}),@1:Set)U augment(P({____(EQ_37)____})U augment(P({@3:Magma}),____(EQ_26)____),\n    @2:Set)\n    = P({@3:Magma})U augment(P({____(EQ_11)____}),@2:Set)U augment(P({____(EQ_30)____})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({____(EQ_18)____})U augment(P({____(EQ_19)____}),@2:Set)\n    = P({____(EQ_27)____})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    ____(EQ_22)____),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({____(EQ_12)____},@2:Set)\n    = augment({@1:Magma},____(EQ_39)____)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({____(EQ_2)____},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({____(EQ_10)____},@4:Set)U augment({____(EQ_0)____},@4:Set)U augment({@3:Magma},____(EQ_21)____)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},____(EQ_20)____).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},____(EQ_24)____)U augment({____(EQ_34)____},@5:Set)U augment({@3:Magma},____(EQ_9)____)U augment({\n    ____(EQ_7)____},@5:Set)\n    = augment({____(EQ_25)____},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({____(EQ_38)____}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : ____(VAR_4)____ .\n  eq [64]: augment(S U S', ____(EQ_8)____) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({____(EQ_16)____}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),____(EQ_3)____)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),____(EQ_28)____),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : ____(VAR_5)____ .\n  eq [65]: augment(augment(S, ____(EQ_36)____), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    ____(EQ_14)____}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)",
        "complete:": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)"
    }
]