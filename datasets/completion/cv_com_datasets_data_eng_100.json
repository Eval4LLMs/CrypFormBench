[
    {
        "file": "CV-1/Aizatulin-RPC.parse.cv",
        "incomplete": "param ____(PARAM_0)____.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\n(* unforgeable MACs *)\n\ntype mkeyseed [fixed, large].\ntype mkey [bounded].\ntype ____(TYPE_0)____.\n(* type macres. *)\n\nproba ____(PROBA_0)____.\n\nexpand UF_CMA_mac(mkeyseed, mkey, ____(OP_1)____, bitstring, mkgen, mac, check, Pmac).\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\nfun parse2(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\n\nforall x:bitstring, y:bitstring;\n  parse1(concat1(x, y)) = x.\n\nforall x:bitstring, y:bitstring;\n  parse2(concat1(x, y)) = y.\n\nevent client_begin(bitstring).\nevent server_accept(bitstring).\n\nquery x: bitstring, y:bitstring;\n  event server_accept(____(EVENT_0)____) ==> client_begin(x).\n\nlet A =\n  in(c1, ____(OP_0)____: bitstring);\n  event client_begin(payload);\n  out(c2, concat1(payload, mac(payload, kAB))).\n\nlet B = \n  in(c4, m: bitstring);\n  let payload = parse1(m) in\n  let h = parse2(m) in\n  if check(payload, kAB, h) then\n  event server_accept(payload);\n  yield.\n\n(* can we insert a bang at the front? *)\nprocess\n  in(start, ());\n  new keyseed: mkeyseed;\n  let kAB = mkgen(keyseed) in\n  out(____(OP_4)____, ());\n  ((! N A) | (! N B))\n\n   \n(* EXPECTED\nAll queries proved.\n0.032s (user 0.028s + system 0.004s), max rss 36912K\nEND *)",
        "complete:": "param N.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\n(* unforgeable MACs *)\n\ntype mkeyseed [fixed, large].\ntype mkey [bounded].\ntype macinput.\n(* type macres. *)\n\nproba Pmac.\n\nexpand UF_CMA_mac(mkeyseed, mkey, bitstring, bitstring, mkgen, mac, check, Pmac).\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\nfun parse2(bitstring): bitstring. (* The indication [decompos] makes the proof fail... *)\n\nforall x:bitstring, y:bitstring;\n  parse1(concat1(x, y)) = x.\n\nforall x:bitstring, y:bitstring;\n  parse2(concat1(x, y)) = y.\n\nevent client_begin(bitstring).\nevent server_accept(bitstring).\n\nquery x: bitstring, y:bitstring;\n  event server_accept(x) ==> client_begin(x).\n\nlet A =\n  in(c1, payload: bitstring);\n  event client_begin(payload);\n  out(c2, concat1(payload, mac(payload, kAB))).\n\nlet B = \n  in(c4, m: bitstring);\n  let payload = parse1(m) in\n  let h = parse2(m) in\n  if check(payload, kAB, h) then\n  event server_accept(payload);\n  yield.\n\n(* can we insert a bang at the front? *)\nprocess\n  in(start, ());\n  new keyseed: mkeyseed;\n  let kAB = mkgen(keyseed) in\n  out(finish, ());\n  ((! N A) | (! N B))\n\n   \n(* EXPECTED\nAll queries proved.\n0.032s (user 0.028s + system 0.004s), max rss 36912K\nEND *)"
    },
    {
        "file": "CV-1/auto_sa_rename_after_simplify.cv",
        "incomplete": "param ____(PARAM_0)____.\nchannel ____(CHANNEL_0)____.\n\nprocess\n\t(\n\tin(c, (____(OP_1)____:bitstring, y:bitstring, ____(OP_0)____:bitstring));\n\tif x = y || x = z then\n\tfind i <= N suchthat defined(a[i]) && let y' = a[i] in x = y' then\n\t     out(c, true)\n\telse\t\n\t     out(c, false)\n\t)\t     \n|\n\t(\n\t!N\n\tin(c, a:bitstring)\n\t)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15440K\nEND *)",
        "complete:": "param N.\nchannel c.\n\nprocess\n\t(\n\tin(c, (x:bitstring, y:bitstring, z:bitstring));\n\tif x = y || x = z then\n\tfind i <= N suchthat defined(a[i]) && let y' = a[i] in x = y' then\n\t     out(c, true)\n\telse\t\n\t     out(c, false)\n\t)\t     \n|\n\t(\n\t!N\n\tin(c, a:bitstring)\n\t)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15440K\nEND *)"
    },
    {
        "file": "CV-1/Avik-cc-sym-enc-prf-mac.cv",
        "incomplete": "(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, ____(PARAM_0)____, q, qE, qD.\n\ntype S [large,fixed].\ntype ____(OP_3)____ [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba ____(PROBA_0)____.\nproba pXOR.\n\nfun f(____(OP_6)____,N): ____(FUN_0)____.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:N) m -> f(____(OP_8)____,x)\n<=(pPRF(time,n,____(OP_7)____))=>\n    !n \n      (x:N) m -> find u <= m \n\t            suchthat defined(x[u],____(OP_10)____[u])\n                          && x = x[u]\n\t            then r[u]\n                    else new r:L; r.\n\nfun h(____(OP_11)____,N,L): W.\n\n(* h(K) is a message authentication code (an unpredictable function family) *)\n\nfun h'(K,N,L): W.\n\nequiv \n    !n new k:K; (\n         (y:N,z:L) m -> h(k,y,z),\n\t (y':N,z':L,t:W) p -> t = h(k,y',z')  \n    ) \n<=(pUF(time,n,m,p))=>\n    !n new k:K; (\n         (y:N,z:L) m -> h'(k,y,z),\n\t (y':N,z':L,t:W) p -> find u <= m suchthat \n\t     defined(y[u],z[u]) && y' = y[u] && z' = z[u] \n                          then t = h'(k,y',z') else false \n    ).\n\nfun xor(L,L): L.\n\n(* the theory of xor implies several propositions *)\n\nforall x:L, y:L; xor(x, xor(x,y)) = y.\n\nequiv \n    (y:L) n -> new x:L; xor(x,y)\n<=(pXOR(time,n))=>\n    (y:L) n -> new x:L; x.\n\nfun choose(bool,L,L): L.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:L, z:L;\n  (x && choose(____(OP_2)____,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\nconst reject:L.\n\n(* query *)\nquery secret ____(QUERY_0)____.\n\nchannel dummy, ____(CHANNEL_0)____, cEret, cD, cDret, start.\n\nlet processE = !qE\n    in(cE, (m0:L, m1:L));\n    new x':N;\n    let tempE = f(s,x') in\n    let m' = choose(b,m1,m0) in\n    let c':L = xor(tempE, m') in\n    let t':W = h(k,x',c') in\n    out(cEret, (x',c',t')).\n\nlet processD = !qD\n    in(cD, (x:____(OP_0)____, ____(OP_1)____:L, t:W));\n    if t = h(k,x,c) \n      then \n        (find u <= qE suchthat \n                defined(x'[____(OP_4)____],c'[____(OP_5)____],t'[u])\n             && x = x'[u]\n             && c = c'[u]\n\t     && t = t'[u] (* BB: added *)\n           then out(cDret, reject)  \n           else \n             let tempD = f(s,x) in \n             let m = xor(tempD, c) in \n             out(cDret, ____(OP_9)____) ) \n      else out(cDret, reject).\n\nlet processI = !q\n  in(dummy, ());\n  new k:K;\n  new s:S;\n  new b:bool;\n  out(dummy, ()); \n  (processE | processD).\n\nprocess\n  in(start, ());\n  out(dummy, ());\n  processI\n\n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18976K\nEND *)",
        "complete:": "(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, p, q, qE, qD.\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba pUF.\nproba pXOR.\n\nfun f(S,N): L.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:N) m -> f(s,x)\n<=(pPRF(time,n,m))=>\n    !n \n      (x:N) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then r[u]\n                    else new r:L; r.\n\nfun h(K,N,L): W.\n\n(* h(K) is a message authentication code (an unpredictable function family) *)\n\nfun h'(K,N,L): W.\n\nequiv \n    !n new k:K; (\n         (y:N,z:L) m -> h(k,y,z),\n\t (y':N,z':L,t:W) p -> t = h(k,y',z')  \n    ) \n<=(pUF(time,n,m,p))=>\n    !n new k:K; (\n         (y:N,z:L) m -> h'(k,y,z),\n\t (y':N,z':L,t:W) p -> find u <= m suchthat \n\t     defined(y[u],z[u]) && y' = y[u] && z' = z[u] \n                          then t = h'(k,y',z') else false \n    ).\n\nfun xor(L,L): L.\n\n(* the theory of xor implies several propositions *)\n\nforall x:L, y:L; xor(x, xor(x,y)) = y.\n\nequiv \n    (y:L) n -> new x:L; xor(x,y)\n<=(pXOR(time,n))=>\n    (y:L) n -> new x:L; x.\n\nfun choose(bool,L,L): L.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:L, z:L;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\nconst reject:L.\n\n(* query *)\nquery secret b.\n\nchannel dummy, cE, cEret, cD, cDret, start.\n\nlet processE = !qE\n    in(cE, (m0:L, m1:L));\n    new x':N;\n    let tempE = f(s,x') in\n    let m' = choose(b,m1,m0) in\n    let c':L = xor(tempE, m') in\n    let t':W = h(k,x',c') in\n    out(cEret, (x',c',t')).\n\nlet processD = !qD\n    in(cD, (x:N, c:L, t:W));\n    if t = h(k,x,c) \n      then \n        (find u <= qE suchthat \n                defined(x'[u],c'[u],t'[u])\n             && x = x'[u]\n             && c = c'[u]\n\t     && t = t'[u] (* BB: added *)\n           then out(cDret, reject)  \n           else \n             let tempD = f(s,x) in \n             let m = xor(tempD, c) in \n             out(cDret, m) ) \n      else out(cDret, reject).\n\nlet processI = !q\n  in(dummy, ());\n  new k:K;\n  new s:S;\n  new b:bool;\n  out(dummy, ()); \n  (processE | processD).\n\nprocess\n  in(start, ());\n  out(dummy, ());\n  processI\n\n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18976K\nEND *)"
    },
    {
        "file": "CV-1/Avik-elgamal.cv",
        "incomplete": "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam ____(PARAM_0)____, q.\n\ntype Z [fixed].\n\ntype G [fixed].\n\nproba ____(PROBA_0)____.\n\nfun exp(____(FUN_0)____,Z): G.\nconst gamma:G.\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new ____(OP_3)____:Z; exp(gamma,____(OP_4)____) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(____(OP_5)____,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun dot(G,G): G.\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\nfun invdot(G,G): G.\n\n(* invdot is the left-inverse of dot *)\n\nforall a:G, b:G;\n  invdot(a, dot(a,b)) = b.\n\n(* the DDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(____(OP_6)____,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, mult(x,y)) ) (* BB: removed [all] *)\n<=(pDDH(time) * n)=>  (* BB: Was pDDH(time,n) *)\n    !n new x:Z; new y:Z; new z:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, z) ).\n\nfun choose(bool,G,G): G.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:G, z:G;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret ____(QUERY_0)____.\n\nchannel cPK, ____(CHANNEL_0)____, cEret, start.\n\nlet processE = \n    in(cE, (m0:____(OP_2)____, m1:G));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let zeta = dot(____(OP_0)____, m) in\n    out(cEret, (beta,zeta)).\n\nprocess\n  !q  (* BB: Replication not present in Shoup's paper, but ok *)\n  in(start, ());\n  new x:Z;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  processE\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)",
        "complete:": "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q.\n\ntype Z [fixed].\n\ntype G [fixed].\n\nproba pDDH.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new x:Z; exp(gamma,x) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun dot(G,G): G.\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\nfun invdot(G,G): G.\n\n(* invdot is the left-inverse of dot *)\n\nforall a:G, b:G;\n  invdot(a, dot(a,b)) = b.\n\n(* the DDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, mult(x,y)) ) (* BB: removed [all] *)\n<=(pDDH(time) * n)=>  (* BB: Was pDDH(time,n) *)\n    !n new x:Z; new y:Z; new z:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, z) ).\n\nfun choose(bool,G,G): G.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:G, z:G;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret b.\n\nchannel cPK, cE, cEret, start.\n\nlet processE = \n    in(cE, (m0:G, m1:G));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let zeta = dot(delta, m) in\n    out(cEret, (beta,zeta)).\n\nprocess\n  !q  (* BB: Replication not present in Shoup's paper, but ok *)\n  in(start, ());\n  new x:Z;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  processE\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)"
    },
    {
        "file": "CV-1/Avik-hash-elgamal-CDH.cv",
        "incomplete": "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q, nH, ____(PARAM_0)____, nCDH'.\n\ntype Z [fixed].\ntype G.\ntype K [large,fixed].\ntype D [____(TYPE_0)____].\n\nproba ____(PROBA_0)____.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun xor(D,D): D.\n\n(* xor self-cancels *)\n\nforall x:D, y:D;\n  xor(x, xor(x,____(OP_3)____)) = y.\n\n(* xor(.,y) is a one-time pad *)\n\nequiv \n    (y:D) n -> new x:D; xor(x,y) [all]\n<=(0)=>   (* BB: The difference of probability is 0 *)\n    (y:D) n -> new x:D; x.\n\n(* the CDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> z = exp(gamma, mult(x,y))\n )\n<=(pCDH(____(OP_4)____,n,nCDH))=>\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> false ).\n\nfun h(K,G): D.\n\n(* h in the random oracle model *)\n\nequiv !n new k:K; (x:G) nH -> h(k,____(OP_1)____)\n      <=(0)=>\n      !n new k:K; (x:G) nH -> find j <= nH suchthat defined(x[j],r[j]) && otheruses(r[j]) && x= x[j] then r[j] else\n\t\t\t new r:D; r.\n\n    \nfun choose(bool,____(FUN_0)____,D): D.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:D, z:D;\n  (x && choose(x,____(OP_8)____,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret ____(QUERY_0)____.\n\nchannel ____(CHANNEL_1)____, cPK, cE, ____(CHANNEL_0)____, cH, cHret, start.\n\nlet processE = \n    in(cE, (m0:D, m1:D));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let hash = h(k,____(OP_6)____) in\n    let v = xor(hash, ____(OP_7)____) in\n    out(cEret, (beta,____(OP_0)____)).\n\nlet processH =\n  !nH\n  in(cH, xH:G);\n  out(cHret, h(____(OP_5)____,xH)).\n\nprocess\n  !q   (* BB: Replication not present in Shoup's paper, but ok *)\n  in(dummy, ());\n  new x:Z;\n  new k:K;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  (processE | processH)\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19040K\nEND *)",
        "complete:": "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q, nH, nCDH, nCDH'.\n\ntype Z [fixed].\ntype G.\ntype K [large,fixed].\ntype D [fixed].\n\nproba pCDH.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun xor(D,D): D.\n\n(* xor self-cancels *)\n\nforall x:D, y:D;\n  xor(x, xor(x,y)) = y.\n\n(* xor(.,y) is a one-time pad *)\n\nequiv \n    (y:D) n -> new x:D; xor(x,y) [all]\n<=(0)=>   (* BB: The difference of probability is 0 *)\n    (y:D) n -> new x:D; x.\n\n(* the CDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> z = exp(gamma, mult(x,y))\n )\n<=(pCDH(time,n,nCDH))=>\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> false ).\n\nfun h(K,G): D.\n\n(* h in the random oracle model *)\n\nequiv !n new k:K; (x:G) nH -> h(k,x)\n      <=(0)=>\n      !n new k:K; (x:G) nH -> find j <= nH suchthat defined(x[j],r[j]) && otheruses(r[j]) && x= x[j] then r[j] else\n\t\t\t new r:D; r.\n\n    \nfun choose(bool,D,D): D.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:D, z:D;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret b.\n\nchannel dummy, cPK, cE, cEret, cH, cHret, start.\n\nlet processE = \n    in(cE, (m0:D, m1:D));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let hash = h(k,delta) in\n    let v = xor(hash, m) in\n    out(cEret, (beta,v)).\n\nlet processH =\n  !nH\n  in(cH, xH:G);\n  out(cHret, h(k,xH)).\n\nprocess\n  !q   (* BB: Replication not present in Shoup's paper, but ok *)\n  in(dummy, ());\n  new x:Z;\n  new k:K;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  (processE | processH)\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19040K\nEND *)"
    },
    {
        "file": "CV-1/Avik-luby-rackoff.cv",
        "incomplete": "(** The Luby-Rackoff construction **)\n\n(** A construction \n    using a pseudo-random family of functions over a large domain\n    and an almost-XOR-universal-hash function family\n    is shown to be pseudo-random.\n    See Section 6, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, ____(PARAM_0)____, q.\n\ntype ____(OP_1)____ [large,fixed].\ntype K [large,fixed].\n\ntype D [large,fixed].\ntype DD [fixed].\n\nproba pPRF.\nproba ____(PROBA_0)____.\n\nfun f(____(FUN_0)____,D): D.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRF(____(OP_2)____,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat defined(____(OP_3)____[u],r[u]) \n                          && x = x[u]\n\t            then r[u]\n                    else new r:D; r.\n\n(* the theory of xor implies several propositions... *)\n\nexpand Xor(D, xor, zero).\n\n(* ...and h(K) is an almost-XOR-universal-hash function family *)\n\nfun h(K,D): D.\n\ncollision new k:K; forall x:D, x':D, y:D;\n  xor(h(k,x),h(k,x')) = y <=(pAXUH(time))=> (x = x' && y = zero).\n\nfun pairsep(D,D): DD [compos].\nfun extract1(DD): D.\nfun extract2(DD): D.\n\n(* extracts are inverses of pair *)\n\ncollision forall p:DD, p':DD;\n    (extract1(p) = extract1(p')) && (extract2(p) = extract2(p')) \n<=(0)=> \n    (p = p').\n\nfun concat(D,D): DD.\n\n(* concat preserves independent-randomness *)\n\nequiv \n    () n -> new x:D; new y:D; concat(x,y)\n<=(0)=>\n    () n -> new z: DD; z.\n\n(* query *)\nquery ____(QUERY_0)____ test.\n\nchannel dummy, ____(CHANNEL_0)____.\n\nlet processC = !q\n    in(dummy, ());\n    new du:D;\n    new dv:D;\n    let p = pairsep(du,____(OP_0)____) in\n    let u = extract1(p) in\n    let v = extract2(p) in\n    let temp1 = h(k,v) in\n    let w = xor(u,temp1) in\n    let temp2 = f(____(OP_4)____,w) in \n    let x = xor(v,temp2) in\n    let temp3 = f(s2,x) in\n    let y = xor(____(OP_5)____,temp3) in\n    let test:DD = concat(x,y) in\n    yield.\n\nprocess\n  in(start, ());\n  new k:K;\n  new s1:S;\n  new s2:S;\n  out(dummy, ());\n  processC\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18864K\nEND *)",
        "complete:": "(** The Luby-Rackoff construction **)\n\n(** A construction \n    using a pseudo-random family of functions over a large domain\n    and an almost-XOR-universal-hash function family\n    is shown to be pseudo-random.\n    See Section 6, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, q.\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype D [large,fixed].\ntype DD [fixed].\n\nproba pPRF.\nproba pAXUH.\n\nfun f(S,D): D.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRF(time,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat defined(x[u],r[u]) \n                          && x = x[u]\n\t            then r[u]\n                    else new r:D; r.\n\n(* the theory of xor implies several propositions... *)\n\nexpand Xor(D, xor, zero).\n\n(* ...and h(K) is an almost-XOR-universal-hash function family *)\n\nfun h(K,D): D.\n\ncollision new k:K; forall x:D, x':D, y:D;\n  xor(h(k,x),h(k,x')) = y <=(pAXUH(time))=> (x = x' && y = zero).\n\nfun pairsep(D,D): DD [compos].\nfun extract1(DD): D.\nfun extract2(DD): D.\n\n(* extracts are inverses of pair *)\n\ncollision forall p:DD, p':DD;\n    (extract1(p) = extract1(p')) && (extract2(p) = extract2(p')) \n<=(0)=> \n    (p = p').\n\nfun concat(D,D): DD.\n\n(* concat preserves independent-randomness *)\n\nequiv \n    () n -> new x:D; new y:D; concat(x,y)\n<=(0)=>\n    () n -> new z: DD; z.\n\n(* query *)\nquery secret test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, ());\n    new du:D;\n    new dv:D;\n    let p = pairsep(du,dv) in\n    let u = extract1(p) in\n    let v = extract2(p) in\n    let temp1 = h(k,v) in\n    let w = xor(u,temp1) in\n    let temp2 = f(s1,w) in \n    let x = xor(v,temp2) in\n    let temp3 = f(s2,x) in\n    let y = xor(w,temp3) in\n    let test:DD = concat(x,y) in\n    yield.\n\nprocess\n  in(start, ());\n  new k:K;\n  new s1:S;\n  new s2:S;\n  out(dummy, ());\n  processC\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18864K\nEND *)"
    },
    {
        "file": "CV-1/Avik-prf.cv",
        "incomplete": "(** Pseudo-random functions **)\n\n(** Extending the input length of a pseudo-random function family\n    with a universal hash function\n    is shown to preserve pseudo-randomness.\n    See Section 4, \"Sequences of Games\", Victor Shoup. **)\n\nparam ____(PARAM_0)____, m, q.\n\nproof {\n      auto;\n      merge_branches;\n      success\n      }\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype D1 [____(TYPE_0)____].\ntype D2 [fixed].\ntype D [fixed].\ntype G [large,fixed].\n\nproba pPRF.\nproba ____(PROBA_0)____.\n\nfun f(S,____(FUN_0)____): D2.\nfun h(K,D): D1.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D1) m -> f(s,____(OP_4)____) [all] \n<=(pPRF(time,n,m))=>\t\t(* BB: Could be n * pPRF(time) *)\n    !n \n      (x:D1) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then r[u]\n                    else new r:D2; r.\n\n(* h(K) is a universal-hash function family *)\n\ncollision new k:K; forall w:D, w':D; \n  h(____(OP_0)____,w) = h(k,w') <=(pUH(time))=> w = w'.\n\n\n(* query *)\n(* BB: Does not seem to correctly model the problem \n\nfun sep(G): D [compos].\n\nquery secret test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, ());\n    new g:G;\n    let w = sep(g) in\n    let x:D1 = h(k,w) in\n    let test:D2 = f(s,x) in\n    yield.\n\nprocess\n  in(start, ());\n  new k:K;\n  new s:S;\n  out(dummy, ());\n  processC\n\n\nBB: Another coding, but would require the system to be able to simplify\nif b then P else P' into P when P and P' are equal up to renaming.\nFor now, can be checked by manual inspection...\nAugust 5, 2015: This merging of branches now works.\n*)\n\nquery secret b.\n\nchannel start, dummy, c0, c1.\n\nlet processC = !q\n    in(c0, w:D);\n    if b then\n        (* output the image of w by the constructed pseudo-random function *)\n        out(c1, f(____(OP_1)____,h(k,w)))\n    else\n        (* output the image of w by a random function *)\n\tfind u <= q suchthat defined(w[u],r[u]) && w[u] = w \n\tthen out(c1,____(OP_6)____[u])\n\telse new r:D2; out(c1,r).\n\n\nprocess\n  in(start, ());\n  new k:K;\n  new s:S;\n  new b:bool;\n  out(dummy, ());\n  processC\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 16688K\nEND *)",
        "complete:": "(** Pseudo-random functions **)\n\n(** Extending the input length of a pseudo-random function family\n    with a universal hash function\n    is shown to preserve pseudo-randomness.\n    See Section 4, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, q.\n\nproof {\n      auto;\n      merge_branches;\n      success\n      }\n\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype D1 [fixed].\ntype D2 [fixed].\ntype D [fixed].\ntype G [large,fixed].\n\nproba pPRF.\nproba pUH.\n\nfun f(S,D1): D2.\nfun h(K,D): D1.\n\n(* f(S) is a pseudo-random function family *) \n\nequiv\n    !n new s:S;\n      (x:D1) m -> f(s,x) [all] \n<=(pPRF(time,n,m))=>\t\t(* BB: Could be n * pPRF(time) *)\n    !n \n      (x:D1) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then r[u]\n                    else new r:D2; r.\n\n(* h(K) is a universal-hash function family *)\n\ncollision new k:K; forall w:D, w':D; \n  h(k,w) = h(k,w') <=(pUH(time))=> w = w'.\n\n\n(* query *)\n(* BB: Does not seem to correctly model the problem \n\nfun sep(G): D [compos].\n\nquery secret test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, ());\n    new g:G;\n    let w = sep(g) in\n    let x:D1 = h(k,w) in\n    let test:D2 = f(s,x) in\n    yield.\n\nprocess\n  in(start, ());\n  new k:K;\n  new s:S;\n  out(dummy, ());\n  processC\n\n\nBB: Another coding, but would require the system to be able to simplify\nif b then P else P' into P when P and P' are equal up to renaming.\nFor now, can be checked by manual inspection...\nAugust 5, 2015: This merging of branches now works.\n*)\n\nquery secret b.\n\nchannel start, dummy, c0, c1.\n\nlet processC = !q\n    in(c0, w:D);\n    if b then\n        (* output the image of w by the constructed pseudo-random function *)\n        out(c1, f(s,h(k,w)))\n    else\n        (* output the image of w by a random function *)\n\tfind u <= q suchthat defined(w[u],r[u]) && w[u] = w \n\tthen out(c1,r[u])\n\telse new r:D2; out(c1,r).\n\n\nprocess\n  in(start, ());\n  new k:K;\n  new s:S;\n  new b:bool;\n  out(dummy, ());\n  processC\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 16688K\nEND *)"
    },
    {
        "file": "CV-1/Avik-prp.cv",
        "incomplete": "(** Pseudo-random permutations **)\n\n(** A pseudo-random permutation family with large domain\n    is shown to be pseudo-random.\n    See Section 5, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, ____(PARAM_0)____, q.\n\ntype ____(OP_1)____ [large,fixed].\n\ntype D [____(TYPE_0)____,fixed].\n\nproba ____(PROBA_0)____.\n\nfun f(S,D): D.\n\n(* f(S) is a pseudo-random permutation family... *) \n\nfun sep1(____(FUN_0)____): D [compos].\n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRP(time,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then sep1(r[u])\n                    else new r:D; sep1(r).\n\t\t\t(* BB: f(S) is a pseudo-random function, not a pseudo\n\t\t\t   random permutation. *)\n\n\n(* ...where sep1 is a permutation *)\n\nequiv\n    () n -> new x:D; sep1(x) \n<=(0)=>\n    () n -> new x:D; x.\n\nfun sep2(D): D [compos].\n\n(* BB: Does not seem to be related to the problem we want to handle... *)\n\n(* query *)\nquery secret ____(QUERY_0)____.\n\nchannel ____(CHANNEL_0)____, start.\n\nlet processC = !q\n    in(____(OP_0)____, ());\n    new d:D;\n    let x = sep2(d) in\n    let test:D = f(s,x) in\n    yield.\n\nprocess\n  in(start, ());\n  new s:S;\n  out(dummy, ());\n  processC\n\n\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16352K\nEND *)",
        "complete:": "(** Pseudo-random permutations **)\n\n(** A pseudo-random permutation family with large domain\n    is shown to be pseudo-random.\n    See Section 5, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, q.\n\ntype S [large,fixed].\n\ntype D [large,fixed].\n\nproba pPRP.\n\nfun f(S,D): D.\n\n(* f(S) is a pseudo-random permutation family... *) \n\nfun sep1(D): D [compos].\n\nequiv\n    !n new s:S;\n      (x:D) m -> f(s,x) [all] \n<=(pPRP(time,n,m))=>\n    !n \n      (x:D) m -> find u <= m \n\t            suchthat defined(x[u],r[u])\n                          && x = x[u]\n\t            then sep1(r[u])\n                    else new r:D; sep1(r).\n\t\t\t(* BB: f(S) is a pseudo-random function, not a pseudo\n\t\t\t   random permutation. *)\n\n\n(* ...where sep1 is a permutation *)\n\nequiv\n    () n -> new x:D; sep1(x) \n<=(0)=>\n    () n -> new x:D; x.\n\nfun sep2(D): D [compos].\n\n(* BB: Does not seem to be related to the problem we want to handle... *)\n\n(* query *)\nquery secret test.\n\nchannel dummy, start.\n\nlet processC = !q\n    in(dummy, ());\n    new d:D;\n    let x = sep2(d) in\n    let test:D = f(s,x) in\n    yield.\n\nprocess\n  in(start, ());\n  new s:S;\n  out(dummy, ());\n  processC\n\n\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16352K\nEND *)"
    },
    {
        "file": "CV-1/bug-args-at-creation.cv",
        "incomplete": "(* Version in which the participants only talk to A and B \n   Using two series of function symbols to prevent repeated applications\n   of the same cryptographic rule.\n\n*)\n\nparam ____(PARAM_0)____.\nparam N2.\nparam N3.\n\ntype nonce [____(TYPE_0)____,fixed].\ntype host [bounded].\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [____(TYPE_1)____].\ntype maxenc [bounded].\ntype maxmac [bounded].\n\nfun concat1(nonce, nonce, host, host):maxenc [compos].\nfun concat2(____(FUN_0)____, key):maxenc [compos].\n\nforall y:nonce,z:nonce,t:host,u:host, y2:nonce,z2:key; concat1(y,z,t,u) <> concat2(y2,z2).\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba ____(PROBA_0)____.\n\nexpand IND_CPA_sym_enc(keyseed, key, maxenc, maxmac, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zconcat1:maxenc.\nconst Zconcat2:maxenc.\nforall y:nonce,z:nonce,t:host,u:host; \n\tZ(concat1(y,z,t,u)) = Zconcat1.\nforall y:nonce,z:key; \n\tZ(concat2(y,z)) = Zconcat2.\n\n(* Mac *)\n\nproba Pmac.\n\nexpand UF_CMA_mac(mkeyseed, mkey, maxmac, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery secret1 ____(QUERY_0)____.\nquery secret keyA.\n\nchannel c1, c2, ____(CHANNEL_2)____, c4, ____(CHANNEL_0)____, c6, ____(CHANNEL_1)____, c8, c9, start, finish.\nconst A : host.\nconst B : host.\n\nevent endA(host, host, ____(OP_3)____, key).\nevent endB(host, host, nonce, ____(EVENT_0)____).\nevent beginA(host, host, nonce).\nevent beginB(host, host, nonce).\n\nlet processA = \n\tin(start, ());\n\tnew M : nonce;\n\tnew Na : nonce;\n\tnew s1 : seed;\n\tlet ea1:maxmac = enc(concat1(Na, M, A, B), Kas, s1) in\n\tevent beginA(A, ____(OP_1)____, M);\n\tout(c1, (M, ____(OP_5)____, ____(OP_4)____, ea1, mac(ea1, mKas)));\n\tin(c2, (=M, ea2: maxmac, ma2: macs));\n\tif check(ea2, mKas, ma2) then\n\tlet injbot(concat2(=Na, k)) = dec(ea2, Kas) in\n\tevent endA(A, ____(OP_7)____, M, k);\n\tlet keyA:key = k.\n\nlet processS =\n\tin(c7, (M: nonce));\n\tfind i <= N, j <= N suchthat defined(ea1[j]) && let injbot(concat1(____(OP_6)____,b,c,d)) = dec(ea1[j], ____(OP_2)____) in (i = j) && b = M else false then\n\tout(c8, M).\n\t\nprocess \n\tin(start, ());\n\tnew rKas: keyseed;\n\tlet Kas = kgen(rKas) in\n\tnew ____(OP_0)____: mkeyseed;\n\tlet mKas = mkgen(rmKas) in\n\tnew rKbs: keyseed;\n\tlet Kbs = kgen(rKbs) in\n\tnew ____(OP_8)____: mkeyseed;\n\tlet mKbs = mkgen(rmKbs) in\n\tout(c9, ());\n\t((! N processA) |\n\t (! N processS))\n\n(* EXPECTED\nAll queries proved.\n0.160s (user 0.160s + system 0.000s), max rss 32160K\nEND *)",
        "complete:": "(* Version in which the participants only talk to A and B \n   Using two series of function symbols to prevent repeated applications\n   of the same cryptographic rule.\n\n*)\n\nparam N.\nparam N2.\nparam N3.\n\ntype nonce [large,fixed].\ntype host [bounded].\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [fixed].\ntype maxenc [bounded].\ntype maxmac [bounded].\n\nfun concat1(nonce, nonce, host, host):maxenc [compos].\nfun concat2(nonce, key):maxenc [compos].\n\nforall y:nonce,z:nonce,t:host,u:host, y2:nonce,z2:key; concat1(y,z,t,u) <> concat2(y2,z2).\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(keyseed, key, maxenc, maxmac, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nconst Zconcat1:maxenc.\nconst Zconcat2:maxenc.\nforall y:nonce,z:nonce,t:host,u:host; \n\tZ(concat1(y,z,t,u)) = Zconcat1.\nforall y:nonce,z:key; \n\tZ(concat2(y,z)) = Zconcat2.\n\n(* Mac *)\n\nproba Pmac.\n\nexpand UF_CMA_mac(mkeyseed, mkey, maxmac, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery secret1 keyA.\nquery secret keyA.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, start, finish.\nconst A : host.\nconst B : host.\n\nevent endA(host, host, nonce, key).\nevent endB(host, host, nonce, key).\nevent beginA(host, host, nonce).\nevent beginB(host, host, nonce).\n\nlet processA = \n\tin(start, ());\n\tnew M : nonce;\n\tnew Na : nonce;\n\tnew s1 : seed;\n\tlet ea1:maxmac = enc(concat1(Na, M, A, B), Kas, s1) in\n\tevent beginA(A, B, M);\n\tout(c1, (M, A, B, ea1, mac(ea1, mKas)));\n\tin(c2, (=M, ea2: maxmac, ma2: macs));\n\tif check(ea2, mKas, ma2) then\n\tlet injbot(concat2(=Na, k)) = dec(ea2, Kas) in\n\tevent endA(A, B, M, k);\n\tlet keyA:key = k.\n\nlet processS =\n\tin(c7, (M: nonce));\n\tfind i <= N, j <= N suchthat defined(ea1[j]) && let injbot(concat1(a,b,c,d)) = dec(ea1[j], Kas) in (i = j) && b = M else false then\n\tout(c8, M).\n\t\nprocess \n\tin(start, ());\n\tnew rKas: keyseed;\n\tlet Kas = kgen(rKas) in\n\tnew rmKas: mkeyseed;\n\tlet mKas = mkgen(rmKas) in\n\tnew rKbs: keyseed;\n\tlet Kbs = kgen(rKbs) in\n\tnew rmKbs: mkeyseed;\n\tlet mKbs = mkgen(rmKbs) in\n\tout(c9, ());\n\t((! N processA) |\n\t (! N processS))\n\n(* EXPECTED\nAll queries proved.\n0.160s (user 0.160s + system 0.000s), max rss 32160K\nEND *)"
    },
    {
        "file": "CV-1/bug-cryptotransf-find-in-find-cond.cv",
        "incomplete": "(* FDH signature scheme *)\n\nparam ____(PARAM_0)____.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [____(TYPE_0)____].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel ____(CHANNEL_0)____, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery ____(QUERY_0)____ bad ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! qS\n\tin(c1, ____(OP_2)____:bitstring);\n\tout(c2, invf(sk, hash(hk,m))).\n\nlet processT = \n\tin(c3, (m':bitstring, s:D));\n\tif f(pk, ____(OP_0)____) = hash(hk,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\tin(____(OP_3)____, ());\n\tnew hk: hashkey;\n\tnew r:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(____(OP_1)____, pk);\n\t(processS | processT | hashoracle | \n\t(in (c1, x:bitstring); \n\tfind j<=qS suchthat defined(m[j]) && \n\t  (find j'<=qS suchthat defined(m[j']) then m[j] = m[j'] else false) \n\tthen out(c2, x) \n\telse out(c3, x))  )\n\n\n(* EXPECTED\nAll queries proved.\n0.040s (user 0.030s + system 0.010s), max rss 20000K\nEND *)",
        "complete:": "(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent bad.\nquery event bad ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! qS\n\tin(c1, m:bitstring);\n\tout(c2, invf(sk, hash(hk,m))).\n\nlet processT = \n\tin(c3, (m':bitstring, s:D));\n\tif f(pk, s) = hash(hk,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\tin(start, ());\n\tnew hk: hashkey;\n\tnew r:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(processS | processT | hashoracle | \n\t(in (c1, x:bitstring); \n\tfind j<=qS suchthat defined(m[j]) && \n\t  (find j'<=qS suchthat defined(m[j']) then m[j] = m[j'] else false) \n\tthen out(c2, x) \n\telse out(c3, x))  )\n\n\n(* EXPECTED\nAll queries proved.\n0.040s (user 0.030s + system 0.010s), max rss 20000K\nEND *)"
    },
    {
        "file": "CV-1/bugsimplif.cv",
        "incomplete": "(* The \"find j <= N suchthat defined(j) then\" at some point lead to \n   a wrong simplification in which CryptoVerif considered that j must be defined\n   before executing the find, instead of just after.\n\n   Version in which the participants only talk to A and B \n   Using two series of function symbols to prevent repeated applications\n   of the same cryptographic rule.\n\n   The result obtained by CryptoVerif changed with the new semantics\n   of find: \n      find j <= N suchthat defined(j) then\n   is now interpreted as \n      find j = j' <= N suchthat defined(j) then \n   which always fails (j is not defined yet when defined(j) is tested).\n*)\n\nparam ____(PARAM_0)____.\nparam N2.\nparam N3.\n\ntype tag [bounded].\ntype ____(TYPE_0)____ [large,fixed].\ntype host [bounded].\ntype ____(TYPE_2)____ [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [fixed].\ntype ____(OP_19)____ [bounded].\ntype maxmac [bounded].\ntype ____(TYPE_1)____ [bounded].\n\nconst tag1: tag.\nconst tag2: tag.\nconst tag3: tag.\nconst tag4: tag.\n\nfun concat1(nonce, nonce, host, host):maxencnotag [compos].\nfun concat2(nonce, key):____(FUN_0)____ [compos].\nfun tagf(tag, maxencnotag):maxenc [compos].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba ____(PROBA_0)____.\n\nfun enc(maxenc, key, ____(OP_5)____): maxmac.\nfun kgen(keyseed):key.\nfun dec(maxmac, key): bitstringbot.\n\nfun enc2(maxenc, key, seed): maxmac.\nfun kgen2(keyseed):key.\n\nfun injbot(maxenc):bitstringbot [compos].\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nfun Z(maxenc):maxenc.\nconst Z1:maxenc.\nconst Z2:maxenc.\n\nforall m:maxenc, r:keyseed, r2:seed; \n\tdec(enc(m, kgen(____(OP_9)____), r2), kgen(r)) = injbot(m).\nforall u:tag, x:nonce, y:nonce, z:host, t:host; Z(tagf(u,concat1(____(OP_10)____,y,z,t))) = Z1.\nforall u:tag, x:nonce, y:key; Z(tagf(u,concat2(x,y))) = Z2.\n\n\nequiv  ! N2 new r: keyseed; ((x:maxenc) N -> new r2: seed; enc(x, kgen(r), r2)) \n     <=(N2 * Penc(____(OP_2)____, N))=> \n       ! N2 new r: keyseed; ((x:maxenc) N -> new r2: seed; enc2(Z(x), kgen2(r), r2)).\n\n(* Mac *)\n\nproba Pmac.\n\nfun mac(maxmac, ____(OP_16)____):____(FUN_3)____.\nfun check(maxmac, ____(FUN_1)____, macs): bool.\nfun mkgen(mkeyseed):____(FUN_2)____.\n\nfun mac2(maxmac, mkey):macs.\nfun check2(maxmac, mkey, macs): bool.\nfun mkgen2(mkeyseed):mkey.\n\nforall m:maxmac, r:mkeyseed;\n\tcheck(m, mkgen(r), mac(m, mkgen(r))).\nforall m:maxmac, r:mkeyseed;\n\tcheck2(m, mkgen2(r), mac2(m, mkgen2(r))).\n\nequiv ! N3 new r: mkeyseed;(\n\t (x: maxmac) N -> mac(x, mkgen(r)),\n\t (m: maxmac, ma: macs) N2 -> check(m, mkgen(r), ma))\n     <=(N3 * Pmac(time, N, N2))=>\n      ! N3 new r: mkeyseed;(\n\t (x: maxmac) N -> mac2(x, mkgen2(r)),\n\t (m: maxmac, ma: macs) N2 -> \n\t    find j <= N suchthat defined(x[j]) && (m = x[j]) && check2(x[j], mkgen2(r), ma) then true else false).\n\n\n(* Queries *)\n\nquery secret1 keyA.\nquery secret1 keyB.\n\nquery secret keyA.\nquery ____(QUERY_0)____ keyB.\n\nchannel c1, c2, ____(CHANNEL_2)____, ____(CHANNEL_1)____, c5, c6, c7, c8, c9, start, ____(CHANNEL_0)____.\nconst A : host.\nconst B : host.\n\nevent endA(____(OP_6)____, host, nonce, key).\nevent endB(host, host, ____(OP_20)____, key).\nevent beginA(host, host, nonce).\nevent beginB(host, host, nonce).\n\nquery x:host, y:host, n:nonce, k:key; \n\tevent endA(____(OP_3)____,y,n,k) ==> beginB(____(OP_24)____,y,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent endB(____(EVENT_3)____,y,____(EVENT_2)____,k) ==> beginA(x,____(OP_25)____,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent inj:endA(x,y,n,k) ==> inj:beginB(x,y,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent inj:endB(____(EVENT_0)____,y,____(EVENT_1)____,k) ==> inj:beginA(x,y,n).\n\n\nlet processA = \n\tin(____(OP_13)____, ());\n\tnew M : nonce;\n\tnew Na : nonce;\n\tnew s1 : seed;\n\tlet ea1 = enc(tagf(tag1, concat1(Na, M, A, B)), Kas, s1) in\n\tevent beginA(A, B, M);\n\tout(c1, (M, A, ____(OP_17)____, ____(OP_18)____, mac(ea1, mKas)));\n\tin(c2, (=M, ea2: maxmac, ma2: macs));\n\tif check(ea2, mKas, ma2) then\n\tlet injbot(tagf(=tag3, concat2(=Na, k))) = dec(ea2, Kas) in\n\tevent endA(A, ____(OP_7)____, M, k);\n\tlet keyA:key = k.\n\nlet processB =\n\tin(c3, (M: nonce, =A, =B, ____(OP_11)____:maxmac, ____(OP_12)____:macs));\n\tnew Nb : nonce;\n\tnew s2 : seed;\n\tlet e2 = enc(tagf(tag2, concat1(Nb, M, A, B)), Kbs, s2) in\n\tevent beginB(A, B, M);\n\tout(c4, (M, ____(OP_0)____, ____(OP_1)____, ea, ma, e2, mac(e2, mKbs)));\n\tin(____(OP_21)____, (=____(OP_23)____, ea2: maxmac, ma2: macs, ____(OP_22)____: maxmac, mb2: macs));\n\tif check(eb2, mKbs, mb2) then\n\tlet injbot(tagf(=tag4, concat2(=Nb, k))) = dec(eb2, Kbs) in\n\tout(c6, (M, ____(OP_14)____, ma2));\n\tin(finish, ());\n\tevent endB(A, B, M, k);\n\tlet keyB:key = k.\n\nlet processS =\n\tin(c7, (M: nonce, =A, =B, ea1: maxmac, ma1: macs, eb1: maxmac, mb1: macs));\n\tif check(ea1, mKas, ma1) then\n\tlet injbot(tagf(=____(OP_8)____, concat1(Na, =M, =A, =B))) = dec(ea1, ____(OP_4)____) in\n\tif check(eb1, mKbs, mb1) then\n\tlet injbot(tagf(=tag2, concat1(Nb, =M, =A, =B))) = dec(eb1, Kbs) in\n\tnew k: key;\n\tnew s3: seed;\n\tnew s4: seed;\n\tlet e1 = enc(tagf(tag3, concat2(Na, k)), Kas, s3) in\n\tlet e2 = enc(tagf(tag4, concat2(Nb, k)), Kbs, s4) in\n\tout(c8, (M, e1, mac(e1, mKas), e2, mac(e2, mKbs))).\n\t\nprocess \n\tin(start, ());\n\tnew rKas: keyseed;\n\tlet Kas = kgen(rKas) in\n\tnew rmKas: mkeyseed;\n\tlet mKas = mkgen(rmKas) in\n\tnew rKbs: keyseed;\n\tlet Kbs = kgen(rKbs) in\n\tnew rmKbs: mkeyseed;\n\tlet mKbs = mkgen(rmKbs) in\n\tfind j <= N suchthat defined(j) then\n\tout(c9, ());\n\t((! N processA) |\n\t (! N processB) | \n\t (! N processS))\n\n(* EXPECTED\nAll queries proved.\n0.140s (user 0.140s + system 0.000s), max rss 32160K\nEND *)",
        "complete:": "(* The \"find j <= N suchthat defined(j) then\" at some point lead to \n   a wrong simplification in which CryptoVerif considered that j must be defined\n   before executing the find, instead of just after.\n\n   Version in which the participants only talk to A and B \n   Using two series of function symbols to prevent repeated applications\n   of the same cryptographic rule.\n\n   The result obtained by CryptoVerif changed with the new semantics\n   of find: \n      find j <= N suchthat defined(j) then\n   is now interpreted as \n      find j = j' <= N suchthat defined(j) then \n   which always fails (j is not defined yet when defined(j) is tested).\n*)\n\nparam N.\nparam N2.\nparam N3.\n\ntype tag [bounded].\ntype nonce [large,fixed].\ntype host [bounded].\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [fixed].\ntype maxenc [bounded].\ntype maxmac [bounded].\ntype maxencnotag [bounded].\n\nconst tag1: tag.\nconst tag2: tag.\nconst tag3: tag.\nconst tag4: tag.\n\nfun concat1(nonce, nonce, host, host):maxencnotag [compos].\nfun concat2(nonce, key):maxencnotag [compos].\nfun tagf(tag, maxencnotag):maxenc [compos].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nfun enc(maxenc, key, seed): maxmac.\nfun kgen(keyseed):key.\nfun dec(maxmac, key): bitstringbot.\n\nfun enc2(maxenc, key, seed): maxmac.\nfun kgen2(keyseed):key.\n\nfun injbot(maxenc):bitstringbot [compos].\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nfun Z(maxenc):maxenc.\nconst Z1:maxenc.\nconst Z2:maxenc.\n\nforall m:maxenc, r:keyseed, r2:seed; \n\tdec(enc(m, kgen(r), r2), kgen(r)) = injbot(m).\nforall u:tag, x:nonce, y:nonce, z:host, t:host; Z(tagf(u,concat1(x,y,z,t))) = Z1.\nforall u:tag, x:nonce, y:key; Z(tagf(u,concat2(x,y))) = Z2.\n\n\nequiv  ! N2 new r: keyseed; ((x:maxenc) N -> new r2: seed; enc(x, kgen(r), r2)) \n     <=(N2 * Penc(time, N))=> \n       ! N2 new r: keyseed; ((x:maxenc) N -> new r2: seed; enc2(Z(x), kgen2(r), r2)).\n\n(* Mac *)\n\nproba Pmac.\n\nfun mac(maxmac, mkey):macs.\nfun check(maxmac, mkey, macs): bool.\nfun mkgen(mkeyseed):mkey.\n\nfun mac2(maxmac, mkey):macs.\nfun check2(maxmac, mkey, macs): bool.\nfun mkgen2(mkeyseed):mkey.\n\nforall m:maxmac, r:mkeyseed;\n\tcheck(m, mkgen(r), mac(m, mkgen(r))).\nforall m:maxmac, r:mkeyseed;\n\tcheck2(m, mkgen2(r), mac2(m, mkgen2(r))).\n\nequiv ! N3 new r: mkeyseed;(\n\t (x: maxmac) N -> mac(x, mkgen(r)),\n\t (m: maxmac, ma: macs) N2 -> check(m, mkgen(r), ma))\n     <=(N3 * Pmac(time, N, N2))=>\n      ! N3 new r: mkeyseed;(\n\t (x: maxmac) N -> mac2(x, mkgen2(r)),\n\t (m: maxmac, ma: macs) N2 -> \n\t    find j <= N suchthat defined(x[j]) && (m = x[j]) && check2(x[j], mkgen2(r), ma) then true else false).\n\n\n(* Queries *)\n\nquery secret1 keyA.\nquery secret1 keyB.\n\nquery secret keyA.\nquery secret keyB.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, start, finish.\nconst A : host.\nconst B : host.\n\nevent endA(host, host, nonce, key).\nevent endB(host, host, nonce, key).\nevent beginA(host, host, nonce).\nevent beginB(host, host, nonce).\n\nquery x:host, y:host, n:nonce, k:key; \n\tevent endA(x,y,n,k) ==> beginB(x,y,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent endB(x,y,n,k) ==> beginA(x,y,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent inj:endA(x,y,n,k) ==> inj:beginB(x,y,n).\nquery x:host, y:host, n:nonce, k:key; \n\tevent inj:endB(x,y,n,k) ==> inj:beginA(x,y,n).\n\n\nlet processA = \n\tin(start, ());\n\tnew M : nonce;\n\tnew Na : nonce;\n\tnew s1 : seed;\n\tlet ea1 = enc(tagf(tag1, concat1(Na, M, A, B)), Kas, s1) in\n\tevent beginA(A, B, M);\n\tout(c1, (M, A, B, ea1, mac(ea1, mKas)));\n\tin(c2, (=M, ea2: maxmac, ma2: macs));\n\tif check(ea2, mKas, ma2) then\n\tlet injbot(tagf(=tag3, concat2(=Na, k))) = dec(ea2, Kas) in\n\tevent endA(A, B, M, k);\n\tlet keyA:key = k.\n\nlet processB =\n\tin(c3, (M: nonce, =A, =B, ea:maxmac, ma:macs));\n\tnew Nb : nonce;\n\tnew s2 : seed;\n\tlet e2 = enc(tagf(tag2, concat1(Nb, M, A, B)), Kbs, s2) in\n\tevent beginB(A, B, M);\n\tout(c4, (M, A, B, ea, ma, e2, mac(e2, mKbs)));\n\tin(c5, (=M, ea2: maxmac, ma2: macs, eb2: maxmac, mb2: macs));\n\tif check(eb2, mKbs, mb2) then\n\tlet injbot(tagf(=tag4, concat2(=Nb, k))) = dec(eb2, Kbs) in\n\tout(c6, (M, ea2, ma2));\n\tin(finish, ());\n\tevent endB(A, B, M, k);\n\tlet keyB:key = k.\n\nlet processS =\n\tin(c7, (M: nonce, =A, =B, ea1: maxmac, ma1: macs, eb1: maxmac, mb1: macs));\n\tif check(ea1, mKas, ma1) then\n\tlet injbot(tagf(=tag1, concat1(Na, =M, =A, =B))) = dec(ea1, Kas) in\n\tif check(eb1, mKbs, mb1) then\n\tlet injbot(tagf(=tag2, concat1(Nb, =M, =A, =B))) = dec(eb1, Kbs) in\n\tnew k: key;\n\tnew s3: seed;\n\tnew s4: seed;\n\tlet e1 = enc(tagf(tag3, concat2(Na, k)), Kas, s3) in\n\tlet e2 = enc(tagf(tag4, concat2(Nb, k)), Kbs, s4) in\n\tout(c8, (M, e1, mac(e1, mKas), e2, mac(e2, mKbs))).\n\t\nprocess \n\tin(start, ());\n\tnew rKas: keyseed;\n\tlet Kas = kgen(rKas) in\n\tnew rmKas: mkeyseed;\n\tlet mKas = mkgen(rmKas) in\n\tnew rKbs: keyseed;\n\tlet Kbs = kgen(rKbs) in\n\tnew rmKbs: mkeyseed;\n\tlet mKbs = mkgen(rmKbs) in\n\tfind j <= N suchthat defined(j) then\n\tout(c9, ());\n\t((! N processA) |\n\t (! N processB) | \n\t (! N processS))\n\n(* EXPECTED\nAll queries proved.\n0.140s (user 0.140s + system 0.000s), max rss 32160K\nEND *)"
    },
    {
        "file": "CV-1/CDH_RSR.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n\ntype Z [large,bounded,nonuniform].\ntype G [large,bounded,____(TYPE_0)____].\n\nfun exp(G,Z): G.\nfun exp'(G,Z): G.\nconst g:G.\n\nfun mult(____(FUN_0)____,____(OP_0)____): Z. \nequation builtin commut(mult).\n\n(* CDH assumption *)\nproba ____(PROBA_0)____.\nproba pDistRerandom.\nexpand CDH_RSR(G, Z, g, exp, exp', mult, pCDH, pDistRerandom).\n\nprocess 0",
        "complete:": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n\ntype Z [large,bounded,nonuniform].\ntype G [large,bounded,nonuniform].\n\nfun exp(G,Z): G.\nfun exp'(G,Z): G.\nconst g:G.\n\nfun mult(Z,Z): Z. \nequation builtin commut(mult).\n\n(* CDH assumption *)\nproba pCDH.\nproba pDistRerandom.\nexpand CDH_RSR(G, Z, g, exp, exp', mult, pCDH, pDistRerandom).\n\nprocess 0"
    },
    {
        "file": "CV-1/Chaudhuri-Blanchet-elgamal.cv",
        "incomplete": "(** ElGamal encryption scheme \n    Modeling by Bruno Blanchet and Avik Chaudhuri **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\n(* Replicated the encryption oracle, so that several encryptions can\nbe performed, in order to show that El Gamal is IND-CPA. This goes \nslightly beyond the proof in Shoup's paper (it is however an easy\nconsequence of Shoup's proof). *) \n\nparam n, ____(PARAM_0)____.\n\ntype Z [____(TYPE_0)____].\ntype G [fixed].\n\n(* Decisional Diffie-Hellman assumption *)\n\nproba ____(PROBA_0)____.\n\nexpand DDH(G,Z,gamma,exp,mult,pDDH).\n\n(* Product in the group G *)\n\nfun dot(____(FUN_0)____,G): G.\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\n(* query *)\nquery ____(QUERY_0)____ b.\n\nchannel ____(CHANNEL_0)____, cE, cEret, start.\n\nlet processE = \n    !qE\n    in(cE, (m0:G, m1:G));\n    let m = if b then m1 else m0 in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let zeta = dot(delta, ____(OP_1)____) in\n    out(cEret, (____(OP_2)____,zeta)).\n\nprocess\n  in(start, ());\n  new b:bool;\n  new x:Z;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  processE\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)",
        "complete:": "(** ElGamal encryption scheme \n    Modeling by Bruno Blanchet and Avik Chaudhuri **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\n(* Replicated the encryption oracle, so that several encryptions can\nbe performed, in order to show that El Gamal is IND-CPA. This goes \nslightly beyond the proof in Shoup's paper (it is however an easy\nconsequence of Shoup's proof). *) \n\nparam n, qE.\n\ntype Z [fixed].\ntype G [fixed].\n\n(* Decisional Diffie-Hellman assumption *)\n\nproba pDDH.\n\nexpand DDH(G,Z,gamma,exp,mult,pDDH).\n\n(* Product in the group G *)\n\nfun dot(G,G): G.\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\n(* query *)\nquery secret b.\n\nchannel cPK, cE, cEret, start.\n\nlet processE = \n    !qE\n    in(cE, (m0:G, m1:G));\n    let m = if b then m1 else m0 in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let zeta = dot(delta, m) in\n    out(cEret, (beta,zeta)).\n\nprocess\n  in(start, ());\n  new b:bool;\n  new x:Z;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  processE\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)"
    },
    {
        "file": "CV-1/Dreier-sako-ov-sound-simplified.cv",
        "incomplete": "(* \nsimplif_add (dec(c1, keyone) <> bidToBit(bidval)) knowing\nSubstitutions:\n(dec(c1, sk) = bidToBit(bidval))\n(sk = keyone)\n(m1 = bidToBit(bidval))\nFacts:\nElsefind:\n\nAdding (dec(c1, keyone) <> bidToBit(bidval))\n\nTrying to apply the rewrite rule \"x <> x -> false\"\nin Terms.apply_eq_reds leads to testing\n\"Terms.simp_equal_terms try_no_var dec(c1, keyone) bidToBit(bidval)\"\nwhere try_no_var = Facts.try_no_var (substitutions above).\nHowever, Terms.simp_equal_terms and Facts.try_no_var \napply substitutions only to variables, so not to dec(c1, keyone)\nor bidToBit(bidval).\nHence the matching fails and the simplification is not\ndetected.\n\nSOLVED 26/5/2015\n*)\n\nparam ____(PARAM_0)____.\n\ntype ____(TYPE_0)____ [bounded].\ntype skey [bounded].\ntype seed [fixed].\ntype blocksize [fixed].\ntype bid [bounded].\n\nconst bidval:bid.\n\nfun bidToBit(bid):blocksize [compos].\n\n(* Public-key encryption *)\n\nfun pkgen(skey):pkey.\nfun dec(bitstring, skey): ____(FUN_0)____.\n\n(* Queries *)\n\nchannel ____(CHANNEL_0)____, chPKI, chW.\n\nevent bad().\n\nquery ____(QUERY_0)____ bad ==> false.\n\nprocess\n in(start, ());\n new keyone:skey;\n out(chPKI, (keyone, pkgen(keyone)));\n  in(chW, (c1:bitstring, m1:blocksize, sk:skey));\n  if sk = keyone && m1=dec(c1,sk) then\n    if m1=bidToBit(bidval) then\n      if dec(c1, keyone) <> bidToBit(bidval) then\n        event bad()\n \n(* EXPECTED\nAll queries proved.\n0.016s (user 0.016s + system 0.000s), max rss 22752K\nEND *)",
        "complete:": "(* \nsimplif_add (dec(c1, keyone) <> bidToBit(bidval)) knowing\nSubstitutions:\n(dec(c1, sk) = bidToBit(bidval))\n(sk = keyone)\n(m1 = bidToBit(bidval))\nFacts:\nElsefind:\n\nAdding (dec(c1, keyone) <> bidToBit(bidval))\n\nTrying to apply the rewrite rule \"x <> x -> false\"\nin Terms.apply_eq_reds leads to testing\n\"Terms.simp_equal_terms try_no_var dec(c1, keyone) bidToBit(bidval)\"\nwhere try_no_var = Facts.try_no_var (substitutions above).\nHowever, Terms.simp_equal_terms and Facts.try_no_var \napply substitutions only to variables, so not to dec(c1, keyone)\nor bidToBit(bidval).\nHence the matching fails and the simplification is not\ndetected.\n\nSOLVED 26/5/2015\n*)\n\nparam N.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [fixed].\ntype blocksize [fixed].\ntype bid [bounded].\n\nconst bidval:bid.\n\nfun bidToBit(bid):blocksize [compos].\n\n(* Public-key encryption *)\n\nfun pkgen(skey):pkey.\nfun dec(bitstring, skey): blocksize.\n\n(* Queries *)\n\nchannel start, chPKI, chW.\n\nevent bad().\n\nquery event bad ==> false.\n\nprocess\n in(start, ());\n new keyone:skey;\n out(chPKI, (keyone, pkgen(keyone)));\n  in(chW, (c1:bitstring, m1:blocksize, sk:skey));\n  if sk = keyone && m1=dec(c1,sk) then\n    if m1=bidToBit(bidval) then\n      if dec(c1, keyone) <> bidToBit(bidval) then\n        event bad()\n \n(* EXPECTED\nAll queries proved.\n0.016s (user 0.016s + system 0.000s), max rss 22752K\nEND *)"
    },
    {
        "file": "CV-1/enc-then-MAC-IND-CPA.ocv",
        "incomplete": "(* Encrypt-then-MAC is IND-CPA *)\n\nparam ____(PARAM_0)____.\n\ntype mkey [fixed].\ntype key [____(TYPE_0)____].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba ____(PROBA_0)____.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nquery ____(QUERY_0)____ b.\n\nfun concat(bitstring, macs): bitstring [____(FUN_0)____].\n\nletfun full_enc(m: bitstring, k: ____(OP_0)____, mk: mkey) =\n  c1 <- enc(m,k);\n  concat(c1,mac(c1,mk)).\n\nlet QencLR(b0: bool, k: key, mk: mkey) = \n    \tforeach i <= qEnc do\n\tOenc (____(OP_1)____: bitstring, m2: bitstring) :=\n\tif Z(m1) = Z(m2) then (* m1 and m2 have the same length *)\n\tm0 <- if b0 then m1 else m2;\n\treturn(full_enc(m0,k,mk)).\n\nprocess \n\tOstart() :=\n\tb <-R bool;\n\tk <-R key;\n\tmk <-R mkey;\n\treturn;\n\trun QencLR(b, k,mk)",
        "complete:": "(* Encrypt-then-MAC is IND-CPA *)\n\nparam qEnc.\n\ntype mkey [fixed].\ntype key [fixed].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nquery secret b.\n\nfun concat(bitstring, macs): bitstring [data].\n\nletfun full_enc(m: bitstring, k: key, mk: mkey) =\n  c1 <- enc(m,k);\n  concat(c1,mac(c1,mk)).\n\nlet QencLR(b0: bool, k: key, mk: mkey) = \n    \tforeach i <= qEnc do\n\tOenc (m1: bitstring, m2: bitstring) :=\n\tif Z(m1) = Z(m2) then (* m1 and m2 have the same length *)\n\tm0 <- if b0 then m1 else m2;\n\treturn(full_enc(m0,k,mk)).\n\nprocess \n\tOstart() :=\n\tb <-R bool;\n\tk <-R key;\n\tmk <-R mkey;\n\treturn;\n\trun QencLR(b, k,mk)"
    },
    {
        "file": "CV-1/enc-then-MAC-INT_CTXT.ocv",
        "incomplete": "(* Encrypt-then-MAC is INT-CTXT *)\n\nparam qEnc, ____(PARAM_0)____.\n\ntype ____(TYPE_0)____ [fixed].\ntype key [fixed].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba ____(PROBA_0)____.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery event(____(QUERY_0)____) ==> false.\n\nfun concat(____(FUN_0)____, macs): bitstring [data].\n\nletfun full_enc(m: bitstring, k: key, mk: ____(OP_1)____) =\n  c1 <- enc(m,____(OP_6)____);\n  concat(c1,mac(c1,____(OP_4)____)).\n\nletfun full_dec(____(OP_0)____: bitstring, k: key, mk: mkey) =\n  let concat(c1, mac1) = c in\n  (\n     if verify(c1, ____(OP_7)____, mac1) then\n        dec(c1, k)\n     else\n        bottom\n  )\n  else\n     bottom.\n\ntable ciphertexts(bitstring).\n \nlet Qenc(k: key, mk: mkey) = \n        foreach ienc <= qEnc do\n\tOEnc(m0: ____(OP_2)____) :=\n\tc0 <- full_enc(m0,k,____(OP_3)____);\n\tinsert ciphertexts(c0);\n\treturn(c0).\n\nlet QdecTest(k: key, mk: mkey) =\n        foreach idec <= qDec do\n        ODec(c: bitstring) :=\n\tget ciphertexts(=c) in return(true) else\n\tif full_dec(c, k, mk) <> bottom\n\tthen event bad; return(true)\n\telse return(false).\n\nprocess \n\tOstart() :=\n\tk <-R key;\n\tmk <-R mkey;\n\treturn;\n\t(run Qenc(____(OP_5)____,mk) | run QdecTest(k,mk))",
        "complete:": "(* Encrypt-then-MAC is INT-CTXT *)\n\nparam qEnc, qDec.\n\ntype mkey [fixed].\ntype key [fixed].\ntype macs [fixed].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(key, bitstring, bitstring, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_det_mac(mkey, bitstring, macs, mac, verify, Pmac).\n\n(* Queries *)\n\nevent bad.\nquery event(bad) ==> false.\n\nfun concat(bitstring, macs): bitstring [data].\n\nletfun full_enc(m: bitstring, k: key, mk: mkey) =\n  c1 <- enc(m,k);\n  concat(c1,mac(c1,mk)).\n\nletfun full_dec(c: bitstring, k: key, mk: mkey) =\n  let concat(c1, mac1) = c in\n  (\n     if verify(c1, mk, mac1) then\n        dec(c1, k)\n     else\n        bottom\n  )\n  else\n     bottom.\n\ntable ciphertexts(bitstring).\n \nlet Qenc(k: key, mk: mkey) = \n        foreach ienc <= qEnc do\n\tOEnc(m0: bitstring) :=\n\tc0 <- full_enc(m0,k,mk);\n\tinsert ciphertexts(c0);\n\treturn(c0).\n\nlet QdecTest(k: key, mk: mkey) =\n        foreach idec <= qDec do\n        ODec(c: bitstring) :=\n\tget ciphertexts(=c) in return(true) else\n\tif full_dec(c, k, mk) <> bottom\n\tthen event bad; return(true)\n\telse return(false).\n\nprocess \n\tOstart() :=\n\tk <-R key;\n\tmk <-R mkey;\n\treturn;\n\t(run Qenc(k,mk) | run QdecTest(k,mk))"
    },
    {
        "file": "CV-1/encrypt-then-MAC.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* Show that, if encryption is IND-CPA and MAC is SUF-CMA, then\n   encrypt-then-MAC is IND-CCA2 *)\n\nparam ____(PARAM_0)____.\nparam N2.\nparam N3.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype ____(TYPE_0)____ [fixed].\ntype macs [bounded].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba ____(PROBA_0)____.\n\nexpand SUF_CMA_mac(mkeyseed, mkey, bitstring, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery ____(QUERY_0)____ b.\n\nchannel ____(CHANNEL_0)____, cdec, start, c.\n\nlet LRencOracle = \n\tin(cenc, (____(OP_2)____: bitstring, m2: bitstring));\n\tif Z(m1) = Z(m2) then\n\tlet m = if b then m1 else m2 in\n\tnew s1 : seed;\n\tlet ea1: bitstring = enc(m, Kab, s1) in\n\tlet ma1: macs = mac(____(OP_3)____, mKab) in\n\tout(cenc, (ea1, ma1)).\n\nlet decOracle =\n\tin(cdec, (ea:bitstring, ma:macs));\n\tfind u <= N suchthat defined(ea1[____(OP_0)____],ma1[u]) && (ea = ea1[u]) && \n\t  (ma = ma1[u]) then yield else\n\tif check(ea, mKab, ma) then\n\t(\n           let injbot(____(OP_1)____) = dec(ea, Kab) in\n\t   out(cdec, injbot(cleartext))\n\t)\n        else\n        (\n\t   out(cdec, bottom)\n        ).\n\nprocess \n\tin(start, ());\n\tnew b: bool;\n\tnew ____(OP_4)____: keyseed;\n\tlet Kab = kgen(rKab) in\n\tnew rmKab: mkeyseed;\n\tlet mKab = mkgen(rmKab) in\n\tout(c, ());\n\t((! N LRencOracle) |\n\t (! N decOracle))",
        "complete:": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* Show that, if encryption is IND-CPA and MAC is SUF-CMA, then\n   encrypt-then-MAC is IND-CCA2 *)\n\nparam N.\nparam N2.\nparam N3.\n\ntype mkey [bounded].\ntype mkeyseed [fixed].\ntype key [fixed].\ntype keyseed [fixed].\ntype seed [fixed].\ntype macs [bounded].\n\n(* Shared-key encryption (CPA Stream cipher) *)\n\nproba Penc.\n\nexpand IND_CPA_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc).\n\n(* Mac *)\n\nproba Pmac.\n\nexpand SUF_CMA_mac(mkeyseed, mkey, bitstring, macs, mkgen, mac, check, Pmac).\n\n(* Queries *)\n\nquery secret1 b.\n\nchannel cenc, cdec, start, c.\n\nlet LRencOracle = \n\tin(cenc, (m1: bitstring, m2: bitstring));\n\tif Z(m1) = Z(m2) then\n\tlet m = if b then m1 else m2 in\n\tnew s1 : seed;\n\tlet ea1: bitstring = enc(m, Kab, s1) in\n\tlet ma1: macs = mac(ea1, mKab) in\n\tout(cenc, (ea1, ma1)).\n\nlet decOracle =\n\tin(cdec, (ea:bitstring, ma:macs));\n\tfind u <= N suchthat defined(ea1[u],ma1[u]) && (ea = ea1[u]) && \n\t  (ma = ma1[u]) then yield else\n\tif check(ea, mKab, ma) then\n\t(\n           let injbot(cleartext) = dec(ea, Kab) in\n\t   out(cdec, injbot(cleartext))\n\t)\n        else\n        (\n\t   out(cdec, bottom)\n        ).\n\nprocess \n\tin(start, ());\n\tnew b: bool;\n\tnew rKab: keyseed;\n\tlet Kab = kgen(rKab) in\n\tnew rmKab: mkeyseed;\n\tlet mKab = mkgen(rmKab) in\n\tout(c, ());\n\t((! N LRencOracle) |\n\t (! N decOracle))"
    },
    {
        "file": "CV-1/encryptBR93-1.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* encryption scheme by Bellare and Rogaway, Random Oracles are\nPractical: a Paradigm for Designing Efficient Protocols, CCS'93, \nsection 3.1: E(x) = f(r) || H(r) xor x (CPA) *)\n\n(* In order to determine the proof, use interactive mode: \n   set interactiveMode = true.\nThe proof is as follows: *)\n\nproof {\ncrypto rom(hash);\nremove_assign binder pk;\ncrypto ow(f) r;\ncrypto remove_xor(xor) *;\nsimplify;\nsuccess\n}\n\nparam nx.\n\ntype ____(TYPE_0)____ [bounded].\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm(keyseed, key, key, seed, pkgen, skgen, f, mf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, seed, hasht, hash).\n\nparam qH [____(PARAM_0)____].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: seed); out(hc2, hash(hk,x)).\n\n(* Xor *)\n\nexpand Xor(hasht, xor, zero).\n\n(* Queries *)\n\nquery secret1 ____(QUERY_0)____.\n\nchannel c1, c2, ____(CHANNEL_0)____, ____(CHANNEL_1)____, c5, hstart, hret, start.\n\nlet processT = \n\tin(c3, (____(OP_4)____:hasht, m2:hasht));\n\tnew b1:bool;\n\tlet menc = if b1 then m1 else m2 in\n\tnew x:seed;\n\tlet a = f(____(OP_3)____,x) in\n\tlet b = xor(hash(hk, x), menc) in\n\tout(c4, (a,b)).\n\nprocess \n\tin(____(OP_2)____, ());\n\tnew hk: hashkey;\n\tout(____(OP_5)____, ());\n\t(hashoracle |\n\t(in(start, ());\n\tnew r:keyseed; \n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(____(OP_1)____, pk);\n\tprocessT))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18752K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* encryption scheme by Bellare and Rogaway, Random Oracles are\nPractical: a Paradigm for Designing Efficient Protocols, CCS'93, \nsection 3.1: E(x) = f(r) || H(r) xor x (CPA) *)\n\n(* In order to determine the proof, use interactive mode: \n   set interactiveMode = true.\nThe proof is as follows: *)\n\nproof {\ncrypto rom(hash);\nremove_assign binder pk;\ncrypto ow(f) r;\ncrypto remove_xor(xor) *;\nsimplify;\nsuccess\n}\n\nparam nx.\n\ntype key [bounded].\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm(keyseed, key, key, seed, pkgen, skgen, f, mf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, seed, hasht, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: seed); out(hc2, hash(hk,x)).\n\n(* Xor *)\n\nexpand Xor(hasht, xor, zero).\n\n(* Queries *)\n\nquery secret1 b1.\n\nchannel c1, c2, c3, c4, c5, hstart, hret, start.\n\nlet processT = \n\tin(c3, (m1:hasht, m2:hasht));\n\tnew b1:bool;\n\tlet menc = if b1 then m1 else m2 in\n\tnew x:seed;\n\tlet a = f(pk,x) in\n\tlet b = xor(hash(hk, x), menc) in\n\tout(c4, (a,b)).\n\nprocess \n\tin(hstart, ());\n\tnew hk: hashkey;\n\tout(hret, ());\n\t(hashoracle |\n\t(in(start, ());\n\tnew r:keyseed; \n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c5, pk);\n\tprocessT))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18752K\nEND *)"
    },
    {
        "file": "CV-1/encryptBR93-1.ocv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* encryption scheme by Bellare and Rogaway, Random Oracles are\nPractical: a Paradigm for Designing Efficient Protocols, CCS'93, \nsection 3.1: E(x) = f(r) || H(r) xor x (CPA) *)\n\n(* In order to determine the proof, use interactive mode: \n   set interactiveMode = true.\nThe proof is as follows: \n\nproof {\ncrypto rom(hash);\nremove_assign binder pk;\ncrypto ow(f) r;\ncrypto remove_xor(xor) *;\nsuccess\n}\nIt works automatically with priority 2 for pkgen(r) in ow(f).\n*)\nparam ____(PARAM_0)____.\n\ntype key [bounded].\ntype keyseed [large,fixed].\ntype hasht [____(TYPE_0)____,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm(keyseed, key, key, seed, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_large(hashkey, seed, hasht, hash, hashoracle, qH).\n\n(* Xor *)\n\nexpand Xor(hasht, xor, zero).\n\n(* Queries *)\n\nquery secret b1 [____(QUERY_0)____].\n\nlet processT(____(OP_3)____: hashkey, pk0: key) = \n\tOT(____(OP_1)____:hasht, m2:hasht) :=\n\tb1 <-R bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tmenc <- if_fun(b1, m1, m2);\n\tx <-R seed;\n\ta <- f(____(OP_5)____,x);\n\tb <- xor(hash(hk,x), menc);\n\treturn(a,b).\n\nprocess \n\tOhkgen() :=\n\thk <-R hashkey;\n\treturn;\n\t(run hashoracle(hk) |\n\tOgen() :=\n\tr <-R keyseed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\trun processT(____(OP_0)____, pk))\n\n\n(* EXPECTED\nAll queries proved.\n0.049s (user 0.042s + system 0.008s), max rss 20188K\nEND *)",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* encryption scheme by Bellare and Rogaway, Random Oracles are\nPractical: a Paradigm for Designing Efficient Protocols, CCS'93, \nsection 3.1: E(x) = f(r) || H(r) xor x (CPA) *)\n\n(* In order to determine the proof, use interactive mode: \n   set interactiveMode = true.\nThe proof is as follows: \n\nproof {\ncrypto rom(hash);\nremove_assign binder pk;\ncrypto ow(f) r;\ncrypto remove_xor(xor) *;\nsuccess\n}\nIt works automatically with priority 2 for pkgen(r) in ow(f).\n*)\nparam nx.\n\ntype key [bounded].\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm(keyseed, key, key, seed, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_large(hashkey, seed, hasht, hash, hashoracle, qH).\n\n(* Xor *)\n\nexpand Xor(hasht, xor, zero).\n\n(* Queries *)\n\nquery secret b1 [cv_bit].\n\nlet processT(hk: hashkey, pk0: key) = \n\tOT(m1:hasht, m2:hasht) :=\n\tb1 <-R bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tmenc <- if_fun(b1, m1, m2);\n\tx <-R seed;\n\ta <- f(pk0,x);\n\tb <- xor(hash(hk,x), menc);\n\treturn(a,b).\n\nprocess \n\tOhkgen() :=\n\thk <-R hashkey;\n\treturn;\n\t(run hashoracle(hk) |\n\tOgen() :=\n\tr <-R keyseed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\trun processT(hk, pk))\n\n\n(* EXPECTED\nAll queries proved.\n0.049s (user 0.042s + system 0.008s), max rss 20188K\nEND *)"
    },
    {
        "file": "CV-1/encryptfdhWithEncryptionOracle.cv",
        "incomplete": "(* FDH encryption scheme (CPA) *)\n\nproof {\ncrypto hash;\nremove_assign binder pk;\ncrypto f r;\nshow_game;\ncrypto ____(OP_6)____ r_78;\nsuccess\n}\n\n\nparam N.\nparam N2.\nparam ____(PARAM_1)____.\nparam N4.\nparam ____(PARAM_0)____.\nparam N6.\nparam N7.\n\ntype ____(TYPE_0)____.\ntype skey.\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype ____(OP_8)____ [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nconst mark:bitstring.\nfun pkgen(____(FUN_1)____):pkey.\nfun pkgen2(keyseed):pkey.\nfun skgen(keyseed):skey.\nfun f(pkey, seed):seed.\nfun f2(____(FUN_0)____, seed):seed.\nfun mf(____(OP_11)____, seed):seed.\n\nforall r:keyseed, x:seed; mf(skgen(r), f(pkgen(r), ____(OP_3)____)) = x.\n\nforall k:pkey, x:seed, x2:seed; (f(k,x) = f(k,x2)) = (x = x2).\n\n(*\nequiv !N new y:seed; (k:pkey) -> y\n<=(0)=> \n      !N new y:seed; (k:pkey) -> f(k,y).\n\nThe equivalence above is ok, but for manual proofs only. (It can be applied\neverywhere.) The one below can be used in automatic proofs.\n*)\n\nequiv !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y:seed; (() N4 -> mf(skgen(r),y), () N5 -> y))\n<=(0)=>\n      !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y:seed; (() N4 -> y, () N5 -> f(pkgen(r), ____(OP_2)____))).\n\n\nequiv !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y: seed; (() N4 -> f(pkgen(r), y),\n\t\t           (x:seed) N5 -> x = y,\n\t\t           () N6 -> y))\n<=(N * N3 * POW(time))=>\n      !N new r: keyseed; (\n\t!N2 () -> pkgen2(r),\n\t!N3 new y: seed; (() N4 -> f2(pkgen2(r), y),\n\t\t           (x:seed) N5 -> find j <= N6 suchthat defined(____(OP_0)____[j]) && true then x = y else false,\n\t\t           () N6 -> let k:bitstring = mark in y)).\n\n(* Hash function, random oracle model *)\n\nfun hash(seed):hasht.\n\nequiv (x:seed) N -> hash(x) [all]\n      <=(0)=>\n      (x:seed) N -> find j <= N suchthat defined(x[j],r[j]) && x= x[j] then r[j] else\n\t\t    new r:hasht; r.\n\n(* Xor *)\n\nfun xor(hasht,hasht):hasht.\nequation commut(xor).\n\nequiv !N new a:hasht; (x:hasht) -> xor(a,x)\n      <=(0)=>\n      !N new a:hasht; (x:hasht) -> a.\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, hasht, hasht):hasht.\nforall x:hasht,y:hasht; test(true,x,____(OP_7)____) = x.\nforall x:hasht,y:hasht; test(____(OP_9)____,x,y) = y.\n\n(* Queries *)\n\nquery ____(QUERY_0)____ b1.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15,\n\tstart, finish.\n\nlet processH =\n\t! N\n\tin(c1, x:seed);\n\tout(c2, hash(x)).\n\nlet processE =\n\t! N2\n\tin(____(OP_5)____, m:hasht);\n\tnew x:seed;\n\tlet a = f(____(OP_1)____,x) in\n\tlet b = xor(hash(x), m) in\n\tout(c4, (a,b)).\n\nlet processT = \n\tin(c7, (m1:hasht, m2:hasht));\n\tnew b1:bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(b1, m1, m2) in\n\tnew x:seed;\n\tlet a = f(____(OP_4)____,x) in\n\tlet b = xor(hash(x), menc) in\n\tout(____(OP_10)____, (a,b)).\n\nprocess \n\tin(start, =());\n\tnew r:keyseed; \n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c9, pk);\n\t(processH | processE | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19296K\nEND *)",
        "complete:": "(* FDH encryption scheme (CPA) *)\n\nproof {\ncrypto hash;\nremove_assign binder pk;\ncrypto f r;\nshow_game;\ncrypto xor r_78;\nsuccess\n}\n\n\nparam N.\nparam N2.\nparam N3.\nparam N4.\nparam N5.\nparam N6.\nparam N7.\n\ntype pkey.\ntype skey.\ntype keyseed [large,fixed].\ntype hasht [large,fixed].\ntype seed [large,fixed]. \n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nconst mark:bitstring.\nfun pkgen(keyseed):pkey.\nfun pkgen2(keyseed):pkey.\nfun skgen(keyseed):skey.\nfun f(pkey, seed):seed.\nfun f2(pkey, seed):seed.\nfun mf(skey, seed):seed.\n\nforall r:keyseed, x:seed; mf(skgen(r), f(pkgen(r), x)) = x.\n\nforall k:pkey, x:seed, x2:seed; (f(k,x) = f(k,x2)) = (x = x2).\n\n(*\nequiv !N new y:seed; (k:pkey) -> y\n<=(0)=> \n      !N new y:seed; (k:pkey) -> f(k,y).\n\nThe equivalence above is ok, but for manual proofs only. (It can be applied\neverywhere.) The one below can be used in automatic proofs.\n*)\n\nequiv !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y:seed; (() N4 -> mf(skgen(r),y), () N5 -> y))\n<=(0)=>\n      !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y:seed; (() N4 -> y, () N5 -> f(pkgen(r), y))).\n\n\nequiv !N new r: keyseed; (\n\t!N2 () -> pkgen(r),\n\t!N3 new y: seed; (() N4 -> f(pkgen(r), y),\n\t\t           (x:seed) N5 -> x = y,\n\t\t           () N6 -> y))\n<=(N * N3 * POW(time))=>\n      !N new r: keyseed; (\n\t!N2 () -> pkgen2(r),\n\t!N3 new y: seed; (() N4 -> f2(pkgen2(r), y),\n\t\t           (x:seed) N5 -> find j <= N6 suchthat defined(k[j]) && true then x = y else false,\n\t\t           () N6 -> let k:bitstring = mark in y)).\n\n(* Hash function, random oracle model *)\n\nfun hash(seed):hasht.\n\nequiv (x:seed) N -> hash(x) [all]\n      <=(0)=>\n      (x:seed) N -> find j <= N suchthat defined(x[j],r[j]) && x= x[j] then r[j] else\n\t\t    new r:hasht; r.\n\n(* Xor *)\n\nfun xor(hasht,hasht):hasht.\nequation commut(xor).\n\nequiv !N new a:hasht; (x:hasht) -> xor(a,x)\n      <=(0)=>\n      !N new a:hasht; (x:hasht) -> a.\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, hasht, hasht):hasht.\nforall x:hasht,y:hasht; test(true,x,y) = x.\nforall x:hasht,y:hasht; test(false,x,y) = y.\n\n(* Queries *)\n\nquery secret b1.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15,\n\tstart, finish.\n\nlet processH =\n\t! N\n\tin(c1, x:seed);\n\tout(c2, hash(x)).\n\nlet processE =\n\t! N2\n\tin(c3, m:hasht);\n\tnew x:seed;\n\tlet a = f(pk,x) in\n\tlet b = xor(hash(x), m) in\n\tout(c4, (a,b)).\n\nlet processT = \n\tin(c7, (m1:hasht, m2:hasht));\n\tnew b1:bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(b1, m1, m2) in\n\tnew x:seed;\n\tlet a = f(pk,x) in\n\tlet b = xor(hash(x), menc) in\n\tout(c8, (a,b)).\n\nprocess \n\tin(start, =());\n\tnew r:keyseed; \n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c9, pk);\n\t(processH | processE | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19296K\nEND *)"
    },
    {
        "file": "CV-1/equivromhash1.ocv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file justifies the version of the ROM with OH and Oeq\nfrom a version with only oracle OH.\nHowever, the probability found by CryptoVerif is twice larger than optimal. *)\n\ndef ROM_hash_0(____(OP_3)____, hashinput, hashoutput, hash, hashoracle, qH) {\n\nparam Nh, N, Neq.\n\nfun hash(key, hashinput):____(FUN_0)____.\n\nequiv(rom(____(OP_7)____))\n      foreach ih <= Nh do k <-R key;\n        (foreach i <= N do OH(____(OP_1)____:hashinput) := return(hash(k,x)))\n       <=(0)=> \n      foreach ih <= Nh do \n        (foreach i <= N do OH(x:hashinput) := \n\t   find[unique] u <= N suchthat defined(____(OP_4)____[u],____(OP_6)____[u]) && x= x[u] then return(r[u]) else r <-R hashoutput; return(r)).\n\t   \nparam qH [____(PARAM_0)____].\n\nlet hashoracle(k: key) = \n        foreach iH <= qH do\n\tOH(x:hashinput) :=\n\treturn(hash(k,x)).\n\n}\n\ntype ____(TYPE_0)____ [large, fixed].\ntype input.\ntype output [large, fixed].\n\nexpand ROM_hash_0(hashkey, input, output, ____(OP_2)____, hashoracle, qH).\n\nparam Nh, N, Neq.\n\nproof {\n      crypto rom(H);\n      show_game;\n      move array r_2;\n      show_game occ;\n      insert 78 \"r_3 <- cst_output\";\n      merge_branches;\n      remove_assign useless;\n      success\n}\n\nequivalence\n    foreach ih <= Nh do\n    Ostart() :=\n    hk <-R hashkey;\n    return();\n    ((foreach ih <= N do OH(x: input) := return(H(hk, ____(OP_0)____))) |\n     (foreach ieq <= Neq do Oeq(x': input, r': output) := return(r' = H(hk, x'))))\n\n    foreach ih <= Nh do\n    Ostart() :=\n    return();\n    ((foreach ih <= N do OH(x: input) := \n\t   find[unique] u <= N suchthat defined(x[u],r[u]) && x= x[u] then return(r[u]) else r <-R output; return(r)) |\n     (foreach ieq <= Neq do Oeq(x': input, r': output) := \n           find[unique] u <= N suchthat defined(x[u],r[u]) && x' = x[u] then return(r' = r[u]) else\n\t   return(____(OP_5)____)))",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file justifies the version of the ROM with OH and Oeq\nfrom a version with only oracle OH.\nHowever, the probability found by CryptoVerif is twice larger than optimal. *)\n\ndef ROM_hash_0(key, hashinput, hashoutput, hash, hashoracle, qH) {\n\nparam Nh, N, Neq.\n\nfun hash(key, hashinput):hashoutput.\n\nequiv(rom(hash))\n      foreach ih <= Nh do k <-R key;\n        (foreach i <= N do OH(x:hashinput) := return(hash(k,x)))\n       <=(0)=> \n      foreach ih <= Nh do \n        (foreach i <= N do OH(x:hashinput) := \n\t   find[unique] u <= N suchthat defined(x[u],r[u]) && x= x[u] then return(r[u]) else r <-R hashoutput; return(r)).\n\t   \nparam qH [noninteractive].\n\nlet hashoracle(k: key) = \n        foreach iH <= qH do\n\tOH(x:hashinput) :=\n\treturn(hash(k,x)).\n\n}\n\ntype hashkey [large, fixed].\ntype input.\ntype output [large, fixed].\n\nexpand ROM_hash_0(hashkey, input, output, H, hashoracle, qH).\n\nparam Nh, N, Neq.\n\nproof {\n      crypto rom(H);\n      show_game;\n      move array r_2;\n      show_game occ;\n      insert 78 \"r_3 <- cst_output\";\n      merge_branches;\n      remove_assign useless;\n      success\n}\n\nequivalence\n    foreach ih <= Nh do\n    Ostart() :=\n    hk <-R hashkey;\n    return();\n    ((foreach ih <= N do OH(x: input) := return(H(hk, x))) |\n     (foreach ieq <= Neq do Oeq(x': input, r': output) := return(r' = H(hk, x'))))\n\n    foreach ih <= Nh do\n    Ostart() :=\n    return();\n    ((foreach ih <= N do OH(x: input) := \n\t   find[unique] u <= N suchthat defined(x[u],r[u]) && x= x[u] then return(r[u]) else r <-R output; return(r)) |\n     (foreach ieq <= Neq do Oeq(x': input, r': output) := \n           find[unique] u <= N suchthat defined(x[u],r[u]) && x' = x[u] then return(r' = r[u]) else\n\t   return(false)))"
    },
    {
        "file": "CV-1/fdh-1.ocv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype ____(TYPE_0)____ [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(____(OP_0)____, bitstring, D, hash).\n\nparam ____(PARAM_0)____ [noninteractive].\nlet hashoracle = foreach iH <= qH do OH(x:bitstring) := return(hash(hk,x)).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery event ____(QUERY_0)____ ==> false.\n\nlet processS =\n\tforeach iS <= qS do\n\tOS(m:bitstring) :=\n\treturn(invf(sk, hash(hk, m))).\n\nlet processT = \n\tOT(m':bitstring, s:____(OP_2)____) :=\n\tif f(pk, s) = hash(hk, ____(OP_1)____) then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then end else\n\tevent forge.\n\nprocess \n\tOgen() :=\n\thk <-R hashkey;\n\t____(OP_3)____ <-R seed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\t(hashoracle | processS | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nlet hashoracle = foreach iH <= qH do OH(x:bitstring) := return(hash(hk,x)).\n\n(* Queries *)\n\nevent forge.\nquery event forge ==> false.\n\nlet processS =\n\tforeach iS <= qS do\n\tOS(m:bitstring) :=\n\treturn(invf(sk, hash(hk, m))).\n\nlet processT = \n\tOT(m':bitstring, s:D) :=\n\tif f(pk, s) = hash(hk, m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then end else\n\tevent forge.\n\nprocess \n\tOgen() :=\n\thk <-R hashkey;\n\tr <-R seed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\t(hashoracle | processS | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)"
    },
    {
        "file": "CV-1/fdh-JSC.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme\n   Result of Jean-Sebastien Coron, using the Random Self-Reducibility of RSA *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype ____(TYPE_0)____ [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation, with Random-Self-Reducibility *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm_RSR(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [____(PARAM_0)____].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: ____(OP_2)____); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery ____(QUERY_0)____ bad ==> false.\n\nchannel c0, c1, ____(CHANNEL_0)____, c3, c4, c5, ____(CHANNEL_1)____.\n\nlet processS =\n\t! qS\n\tin(c1, m:bitstring);\n\tout(c2, invf(sk, hash(hk,m))).\n\nlet processT = \n\tin(____(OP_0)____, (m':bitstring, s:D));\n\tif f(pk, s) = hash(____(OP_3)____,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew ____(OP_1)____:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(processS | processT | hashoracle))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.020s + system 0.010s), max rss 20000K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme\n   Result of Jean-Sebastien Coron, using the Random Self-Reducibility of RSA *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation, with Random-Self-Reducibility *)\n\nproba POW.\n\nexpand OW_trapdoor_perm_RSR(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent bad.\nquery event bad ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! qS\n\tin(c1, m:bitstring);\n\tout(c2, invf(sk, hash(hk,m))).\n\nlet processT = \n\tin(c3, (m':bitstring, s:D));\n\tif f(pk, s) = hash(hk,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew r:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(processS | processT | hashoracle))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.020s + system 0.010s), max rss 20000K\nEND *)"
    },
    {
        "file": "CV-1/fdh-JSC.ocv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme\n   Result of Jean-Sebastien Coron, using the Random Self-Reducibility of RSA *)\n\nparam ____(PARAM_0)____.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm_RSR(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery event(____(QUERY_0)____) ==> false.\n\nlet processS(hk: hashkey, sk: skey) =\n\tforeach iS <= qS do\n\tOS(m:bitstring) :=\n\treturn(invf(sk, hash(____(OP_4)____,m))).\n\nlet processT(hk: hashkey, ____(OP_3)____: pkey) = \n\tOT(m':bitstring, s:D) :=\n\tif f(____(OP_2)____, s) = hash(____(OP_1)____,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent forge.\n\nprocess \n\tOgen() :=\n\thk <-R hashkey;\n\tr <-R seed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\t(run hashoracle(hk) | run processS(hk, sk) | run processT(____(OP_0)____, pk))\n\n\n(* EXPECTED\nAll queries proved.\n0.057s (user 0.045s + system 0.012s), max rss 20452K\nEND *)",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme\n   Result of Jean-Sebastien Coron, using the Random Self-Reducibility of RSA *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm_RSR(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Queries *)\n\nevent forge.\nquery event(forge) ==> false.\n\nlet processS(hk: hashkey, sk: skey) =\n\tforeach iS <= qS do\n\tOS(m:bitstring) :=\n\treturn(invf(sk, hash(hk,m))).\n\nlet processT(hk: hashkey, pk: pkey) = \n\tOT(m':bitstring, s:D) :=\n\tif f(pk, s) = hash(hk,m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent forge.\n\nprocess \n\tOgen() :=\n\thk <-R hashkey;\n\tr <-R seed; \n\tpk <- pkgen(r);\n\tsk <- skgen(r);\n\treturn(pk);\n\t(run hashoracle(hk) | run processS(hk, sk) | run processT(hk, pk))\n\n\n(* EXPECTED\nAll queries proved.\n0.057s (user 0.045s + system 0.012s), max rss 20452K\nEND *)"
    },
    {
        "file": "CV-1/fdh.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [____(TYPE_0)____].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, ____(OP_1)____).\n\nparam qH [noninteractive].\nchannel ____(CHANNEL_0)____, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent ____(EVENT_0)____.\nquery event ____(QUERY_0)____ ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! qS\n\tin(c1, m:bitstring);\n\tout(c2, invf(sk, hash(hk, ____(OP_3)____))).\n\nlet processT = \n\tin(c3, (m':bitstring, s:D));\n\tif f(pk, s) = hash(hk, ____(OP_2)____) then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew ____(OP_0)____:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(processS | processT | hashoracle))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19968K\nEND *)",
        "complete:": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* FDH signature scheme *)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed].\n\n(* One-way trapdoor permutation *)\n\nproba POW.\n\nexpand OW_trapdoor_perm(seed, pkey, skey, D, pkgen, skgen, f, invf, POW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, bitstring, D, hash).\n\nparam qH [noninteractive].\nchannel hc1, hc2.\nlet hashoracle = ! qH in(hc1, x: bitstring); out(hc2, hash(hk,x)).\n\n(* Queries *)\n\nevent bad.\nquery event bad ==> false.\n\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS =\n\t! qS\n\tin(c1, m:bitstring);\n\tout(c2, invf(sk, hash(hk, m))).\n\nlet processT = \n\tin(c3, (m':bitstring, s:D));\n\tif f(pk, s) = hash(hk, m') then\n\tfind u <= qS suchthat defined(m[u]) && (m' = m[u]) then yield else\n\tevent bad.\n\nprocess \n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew r:seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(processS | processT | hashoracle))\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19968K\nEND *)"
    },
    {
        "file": "CV-1/for_bruno2.ocv",
        "incomplete": "param N, N'.\nparam N1.\nparam ____(PARAM_0)____.\n\n\n\ntype block [fixed, ____(TYPE_0)____].\n\n(* define xor to exist over blocks *)\nexpand Xor(block, xor, zeroblock).\n\n(*\nequiv obvious\n      foreach i <= N do r <-R block; O() := return(r = zeroblock) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O() := return(false).\n\nequiv obvious2\n      foreach i <= N do r <-R block; O(x:block) := return(r = x) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O(x:block) := return(false).\n*)\n\nequiv jons_remove_xor\n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:____(OP_4)____, b2:block) := return(xor(b1, r) = b2) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:block, b2:block) := return(false).\n\n\n\n\nquery secret ____(QUERY_0)____.\n\n\n\nlet left_oracle =\n    Oleft(b1: block, b2: block) :=\n    \tif secret_bit then\n\t        return( xor(____(OP_3)____, r) = b2)   \n\telse\n\t\treturn(false).\n\nlet right_oracle =\n    Oright(b1: block, b2: block) :=\n    \tif secret_bit then\n\t        return( false )\n\telse\n\t\treturn( xor(b1, r) = b2).   \n\n\n\nprocess \n\tOstart() :=\n\tr <-R block;\n        secret_bit <-R bool;\n\treturn;\n\n\t(foreach i <= N1 do left_oracle) | (foreach i <= N2 do right_oracle)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)",
        "complete:": "param N, N'.\nparam N1.\nparam N2.\n\n\n\ntype block [fixed, large].\n\n(* define xor to exist over blocks *)\nexpand Xor(block, xor, zeroblock).\n\n(*\nequiv obvious\n      foreach i <= N do r <-R block; O() := return(r = zeroblock) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O() := return(false).\n\nequiv obvious2\n      foreach i <= N do r <-R block; O(x:block) := return(r = x) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; O(x:block) := return(false).\n*)\n\nequiv jons_remove_xor\n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:block, b2:block) := return(xor(b1, r) = b2) \n      <=( N / |block| )=> \n      foreach i <= N do r <-R block; foreach i <= N' do O(b1:block, b2:block) := return(false).\n\n\n\n\nquery secret secret_bit.\n\n\n\nlet left_oracle =\n    Oleft(b1: block, b2: block) :=\n    \tif secret_bit then\n\t        return( xor(b1, r) = b2)   \n\telse\n\t\treturn(false).\n\nlet right_oracle =\n    Oright(b1: block, b2: block) :=\n    \tif secret_bit then\n\t        return( false )\n\telse\n\t\treturn( xor(b1, r) = b2).   \n\n\n\nprocess \n\tOstart() :=\n\tr <-R block;\n        secret_bit <-R bool;\n\treturn;\n\n\t(foreach i <= N1 do left_oracle) | (foreach i <= N2 do right_oracle)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)"
    },
    {
        "file": "CV-1/GDH_RSR.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n\ntype Z [large,bounded,nonuniform].\ntype G [____(TYPE_0)____,bounded,nonuniform].\n\nfun exp(G,Z): G.\nfun exp'(G,Z): G.\nconst g:G.\n\nfun mult(____(FUN_0)____,Z): Z. \nequation builtin commut(mult).\n\n(* GDH assumption *)\nproba ____(PROBA_0)____.\nproba pDistRerandom.\nexpand GDH_RSR(G, Z, ____(OP_0)____, exp, exp', mult, ____(OP_1)____, pDistRerandom).\n\nprocess 0",
        "complete:": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n\ntype Z [large,bounded,nonuniform].\ntype G [large,bounded,nonuniform].\n\nfun exp(G,Z): G.\nfun exp'(G,Z): G.\nconst g:G.\n\nfun mult(Z,Z): Z. \nequation builtin commut(mult).\n\n(* GDH assumption *)\nproba pGDH.\nproba pDistRerandom.\nexpand GDH_RSR(G, Z, g, exp, exp', mult, pGDH, pDistRerandom).\n\nprocess 0"
    },
    {
        "file": "CV-1/HKDFexpand.ocv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves that, when l_1, l_2, l_3 are pairwise distinct\nlabels and s is a fresh random value, HKDF-expand-label(s, l_i, \"\") for \ni = 1,2,3 are indistinguishable from independent fresh random values. *)\n\ntype key [large, fixed].\ntype ____(TYPE_0)____.\n\n(* HMAC is a PRF *)\n\nproba ____(PROBA_0)____.\nexpand PRF(key, bitstring, key, HMAC, Pprf).\n\n(* HKDF_expand_label_empty_bytes(Secret, Label) = \n   HKDF_expand_label(Secret, Label, \"\", Length) =\n   HKDF_expand(Secret, [Length, tls13_string + Label, \"\"], Length) =\n   Truncate(HMAC(Secret, [Length, tls13_string + Label, \"\", 0x00]), Length)\n\ntls13_string is \"TLS 1.3, \" in draft 18 and \"tls13 \" in the RFC.\nThe Length is supposed to be fixed from the Label (true for a given configuration).\nLength <= Hash.length\nWe ignore the final truncation; we assume that the caller will use only\nthe first Length bits.\nWe define build_arg(Label) = [Length, tls13_string + Label, \"\", 0x00].\n*)\n\nfun build_arg(label): ____(FUN_0)____ [data].\n\nletfun HKDF_expand_label_empty_bytes(Secret: key, Label: label) =\n       HMAC(Secret, build_arg(Label)).\n\n(* Three different constant labels\n   Typical labels: \"finished\", \"key\", \"iv\" for the handshake_traffic_secret\n   or \"application traffic secret\" in draft 18 resp. \"traffic upd\" in the RFC,\n   \"key\", \"iv\" for the traffic_secret_N *)\n\nconst l1: label.\nconst l2: label.\nconst l3: label.\n\nletfun HKDF_expand_l1(Secret: key) =\n       HKDF_expand_label_empty_bytes(____(OP_2)____, l1).\nletfun HKDF_expand_l2(Secret: key) =\n       HKDF_expand_label_empty_bytes(Secret, ____(OP_3)____).\nletfun HKDF_expand_l3(Secret: key) =\n       HKDF_expand_label_empty_bytes(Secret, ____(OP_0)____).\n\n\n(* Prove equivalence between processLeft and processRight *)\n\nparam ____(PARAM_0)____.\n\nlet processLeft =\n    !N Ok() := new k: key; return;\n    ((O1() := return(HKDF_expand_l1(k))) |\n     (O2() := return(HKDF_expand_l2(k))) |\n     (O3() := return(HKDF_expand_l3(k)))).\n\nlet processRight =\n    !N Ok() := return;\n    ((O1() := new r1: key; return(r1)) |\n     (O2() := new ____(OP_1)____: key; return(r2)) |\n     (O3() := new r3: key; return(r3))).\n    \nequivalence\n\trun processLeft\n\trun processRight\n\n(* EXPECTED\nAll queries proved.\n0.047s (user 0.039s + system 0.008s), max rss 20156K\nEND *)",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves that, when l_1, l_2, l_3 are pairwise distinct\nlabels and s is a fresh random value, HKDF-expand-label(s, l_i, \"\") for \ni = 1,2,3 are indistinguishable from independent fresh random values. *)\n\ntype key [large, fixed].\ntype label.\n\n(* HMAC is a PRF *)\n\nproba Pprf.\nexpand PRF(key, bitstring, key, HMAC, Pprf).\n\n(* HKDF_expand_label_empty_bytes(Secret, Label) = \n   HKDF_expand_label(Secret, Label, \"\", Length) =\n   HKDF_expand(Secret, [Length, tls13_string + Label, \"\"], Length) =\n   Truncate(HMAC(Secret, [Length, tls13_string + Label, \"\", 0x00]), Length)\n\ntls13_string is \"TLS 1.3, \" in draft 18 and \"tls13 \" in the RFC.\nThe Length is supposed to be fixed from the Label (true for a given configuration).\nLength <= Hash.length\nWe ignore the final truncation; we assume that the caller will use only\nthe first Length bits.\nWe define build_arg(Label) = [Length, tls13_string + Label, \"\", 0x00].\n*)\n\nfun build_arg(label): bitstring [data].\n\nletfun HKDF_expand_label_empty_bytes(Secret: key, Label: label) =\n       HMAC(Secret, build_arg(Label)).\n\n(* Three different constant labels\n   Typical labels: \"finished\", \"key\", \"iv\" for the handshake_traffic_secret\n   or \"application traffic secret\" in draft 18 resp. \"traffic upd\" in the RFC,\n   \"key\", \"iv\" for the traffic_secret_N *)\n\nconst l1: label.\nconst l2: label.\nconst l3: label.\n\nletfun HKDF_expand_l1(Secret: key) =\n       HKDF_expand_label_empty_bytes(Secret, l1).\nletfun HKDF_expand_l2(Secret: key) =\n       HKDF_expand_label_empty_bytes(Secret, l2).\nletfun HKDF_expand_l3(Secret: key) =\n       HKDF_expand_label_empty_bytes(Secret, l3).\n\n\n(* Prove equivalence between processLeft and processRight *)\n\nparam N.\n\nlet processLeft =\n    !N Ok() := new k: key; return;\n    ((O1() := return(HKDF_expand_l1(k))) |\n     (O2() := return(HKDF_expand_l2(k))) |\n     (O3() := return(HKDF_expand_l3(k)))).\n\nlet processRight =\n    !N Ok() := return;\n    ((O1() := new r1: key; return(r1)) |\n     (O2() := new r2: key; return(r2)) |\n     (O3() := new r3: key; return(r3))).\n    \nequivalence\n\trun processLeft\n\trun processRight\n\n(* EXPECTED\nAll queries proved.\n0.047s (user 0.039s + system 0.008s), max rss 20156K\nEND *)"
    },
    {
        "file": "CV-1/ind_cca2.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype pkey [bounded].\ntype skey [____(TYPE_0)____].\ntype keyseed [fixed].\ntype ____(OP_6)____.\ntype ciphertext.\ntype enc_seed [bounded].\n\nparam ____(PARAM_0)____, N2.\n\nproba ____(PROBA_0)____.\n\nfun Z(cleartext):cleartext.\nfun enc(cleartext, pkey, enc_seed): ciphertext.\nfun skgen(____(FUN_0)____):skey.\nfun pkgen(keyseed):pkey.\n\n(* part displayed in the paper starts here *)\nfun dec(ciphertext, skey): bitstringbot.\nfun injbot(cleartext):bitstringbot [data].\n\nequation forall ____(OP_0)____:cleartext, k:keyseed, r:enc_seed; \n  dec(enc(m, pkgen(____(OP_4)____), r), skgen(k)) = injbot(m).\n\ntable cipher(cleartext, ciphertext).\n\nequiv(ind_cca2(____(OP_2)____))\n  k <-R keyseed; (\n    Opk() := return(pkgen(k)) |\n    foreach i2 <= N2 do Odec(c:ciphertext) :=\n      return(dec(c, skgen(k))) |\n    foreach i <= N do r <-R enc_seed;\n      Oenc(m:cleartext) := return(enc(m, pkgen(k),r)))\n<=(N * Penc(time + (N-1) * time(enc, maxlength(m)), N2))=>\n  k <-R keyseed; (\n   Opk() := return(pkgen(k)) |\n   foreach i2 <= N2 do Odec(c:ciphertext) :=\n     get cipher(m1, =c) in return(injbot(____(OP_3)____))\n     else return(dec(c, skgen(k))) |\n   foreach i <= N do r <-R enc_seed;\n     Oenc(m:cleartext) :=\n       ____(OP_1)____ <- enc(Z(m), pkgen(k), ____(OP_5)____);\n       insert cipher(m, c1); return(c1)).\n\nprocess 0",
        "complete:": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [fixed].\ntype cleartext.\ntype ciphertext.\ntype enc_seed [bounded].\n\nparam N, N2.\n\nproba Penc.\n\nfun Z(cleartext):cleartext.\nfun enc(cleartext, pkey, enc_seed): ciphertext.\nfun skgen(keyseed):skey.\nfun pkgen(keyseed):pkey.\n\n(* part displayed in the paper starts here *)\nfun dec(ciphertext, skey): bitstringbot.\nfun injbot(cleartext):bitstringbot [data].\n\nequation forall m:cleartext, k:keyseed, r:enc_seed; \n  dec(enc(m, pkgen(k), r), skgen(k)) = injbot(m).\n\ntable cipher(cleartext, ciphertext).\n\nequiv(ind_cca2(enc))\n  k <-R keyseed; (\n    Opk() := return(pkgen(k)) |\n    foreach i2 <= N2 do Odec(c:ciphertext) :=\n      return(dec(c, skgen(k))) |\n    foreach i <= N do r <-R enc_seed;\n      Oenc(m:cleartext) := return(enc(m, pkgen(k),r)))\n<=(N * Penc(time + (N-1) * time(enc, maxlength(m)), N2))=>\n  k <-R keyseed; (\n   Opk() := return(pkgen(k)) |\n   foreach i2 <= N2 do Odec(c:ciphertext) :=\n     get cipher(m1, =c) in return(injbot(m1))\n     else return(dec(c, skgen(k))) |\n   foreach i <= N do r <-R enc_seed;\n     Oenc(m:cleartext) :=\n       c1 <- enc(Z(m), pkgen(k), r);\n       insert cipher(m, c1); return(c1)).\n\nprocess 0"
    },
    {
        "file": "CV-1/ind_cpa.cv",
        "incomplete": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype cleartext.\ntype ciphertext.\ntype key [____(TYPE_0)____].\ntype enc_seed [bounded].\n\nfun enc(cleartext, key, enc_seed): ciphertext.\nfun Z(____(FUN_0)____):cleartext.\n\nparam ____(PARAM_0)____.\nproba ____(PROBA_0)____.\n\nequiv(ind_cpa(____(OP_1)____))\n  k <-R key; \n  foreach i <= N do \n    r <-R enc_seed; \n    Oenc(x:____(OP_0)____) :=  return(enc(x, k, r)) \n<=(Penc(time, N, maxlength(x)))=> \n  k <-R key;\n  foreach i <= N do \n  r <-R enc_seed; \n  Oenc(x:cleartext) := return(enc(Z(x), k, r)).\n\nprocess 0",
        "complete:": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype cleartext.\ntype ciphertext.\ntype key [bounded].\ntype enc_seed [bounded].\n\nfun enc(cleartext, key, enc_seed): ciphertext.\nfun Z(cleartext):cleartext.\n\nparam N.\nproba Penc.\n\nequiv(ind_cpa(enc))\n  k <-R key; \n  foreach i <= N do \n    r <-R enc_seed; \n    Oenc(x:cleartext) :=  return(enc(x, k, r)) \n<=(Penc(time, N, maxlength(x)))=> \n  k <-R key;\n  foreach i <= N do \n  r <-R enc_seed; \n  Oenc(x:cleartext) := return(enc(Z(x), k, r)).\n\nprocess 0"
    },
    {
        "file": "CV-1/intctxt-corrupt-comput.ocv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves a version of INT-CTXT that allows corruption of keys\n   from a version that does not. Both the assumption and the conclusion\n   are indistinguishability properties with the [computational] \n   annotation. The proof is simple because CryptoVerif automatically\n   translates the result to prove with the [computational] annotation\n   to showing that event [distinguish], raised when the 2 sides yield\n   different results, is executed with negligible probability. *)\n\ndef INT_CTXT_sym_enc_no_corrupt(key, ____(OP_9)____, ciphertext, enc_seed, enc, enc_r, enc_r', dec, injbot, Z, Advintctxt) { \n\nparam ____(PARAM_0)____, N'.\n\nfun enc_r(____(OP_4)____, key, enc_seed): ciphertext.\nfun dec(ciphertext, key): bitstringbot.\n\nfun enc_r'(cleartext, key, enc_seed): ciphertext.\n\nfun injbot(cleartext):bitstringbot [data].\nequation forall ____(OP_10)____:____(OP_3)____; injbot(x) <> bottom.\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nfun Z(____(FUN_0)____):cleartext.\n\n(* The encryption function is probabilistic *)\nletfun enc(m: cleartext, k: ____(OP_1)____) =\n       r <-R enc_seed; enc_r(m, k, r).\n\nequation forall m:cleartext, k:key, r:enc_seed; \n\tdec(enc_r(m, k, r), k) = injbot(m).\n\n\t(* INT-CTXT *)\n\nequiv(int_ctxt(____(OP_6)____))\n      k <-R key; (\n      \t      foreach i <= N do r <-R enc_seed; Oenc(x:cleartext) := return(enc_r(x, ____(OP_7)____, r)) |\n\t      foreach i' <= N' do Odec(____(OP_0)____:ciphertext) [useful_change] := return(dec(y,k)))\n     <=(Advintctxt(time, N, N', maxlength(x), maxlength(y)))=> [computational] \n      k <-R key [unchanged]; (\n      \t      foreach i <= N do r <-R enc_seed [unchanged]; Oenc(x:cleartext) := z:ciphertext <- enc_r(x, k, r); return(z) |\n\t      foreach i' <= N' do Odec(____(OP_5)____:ciphertext) := find j <= N suchthat defined(x[____(OP_8)____],z[j]) && z[j] = y then return(injbot(x[j])) else return(bottom)).\n\n}\n\ntype key [bounded].\ntype cleartext.\ntype ciphertext.\ntype enc_seed [____(TYPE_0)____].\nproba ____(PROBA_0)____.\n\nexpand INT_CTXT_sym_enc_no_corrupt(key, cleartext, ciphertext, enc_seed, enc, enc_r, enc_r', dec, injbot, Z, Advintctxt).\n\nproof {\n  success simplify;\n  auto\n}\n\nparam N, N'. \n\nquery_equiv(int_ctxt_corrupt(enc))\n      k <-R key; (\n      \t      foreach i <= N do r <-R enc_seed; Oenc(x:cleartext) := return(enc_r(x, k, r)) |\n\t      foreach i' <= N' do Odec(y:ciphertext) [useful_change] := return(dec(y,k)) |\n\t      Ocorrupt() [10] := return(k))\n     <=(?)=> [manual,computational] \n      k <-R key [unchanged]; (\n      \t      foreach i <= N do r <-R enc_seed [unchanged]; Oenc(x:cleartext) := z:ciphertext <- enc_r(x, k, r); return(z) |\n\t      foreach i' <= N' do Odec(y:ciphertext) :=\n\t      \t      if defined(____(OP_2)____) then return(dec(y,k)) else\n\t\t      find j <= N suchthat defined(x[j],z[j]) && z[j] = y then return(injbot(x[j])) else return(bottom) |\n\t      Ocorrupt() := let corrupt: bool = true in return(k))\n\n(* EXPECTED\nAll queries proved.\n0.049s (user 0.038s + system 0.011s), max rss 20004K\nEND *)",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves a version of INT-CTXT that allows corruption of keys\n   from a version that does not. Both the assumption and the conclusion\n   are indistinguishability properties with the [computational] \n   annotation. The proof is simple because CryptoVerif automatically\n   translates the result to prove with the [computational] annotation\n   to showing that event [distinguish], raised when the 2 sides yield\n   different results, is executed with negligible probability. *)\n\ndef INT_CTXT_sym_enc_no_corrupt(key, cleartext, ciphertext, enc_seed, enc, enc_r, enc_r', dec, injbot, Z, Advintctxt) { \n\nparam N, N'.\n\nfun enc_r(cleartext, key, enc_seed): ciphertext.\nfun dec(ciphertext, key): bitstringbot.\n\nfun enc_r'(cleartext, key, enc_seed): ciphertext.\n\nfun injbot(cleartext):bitstringbot [data].\nequation forall x:cleartext; injbot(x) <> bottom.\n\n(* The function Z returns for each bitstring, a bitstring\n   of the same length, consisting only of zeroes. *)\nfun Z(cleartext):cleartext.\n\n(* The encryption function is probabilistic *)\nletfun enc(m: cleartext, k: key) =\n       r <-R enc_seed; enc_r(m, k, r).\n\nequation forall m:cleartext, k:key, r:enc_seed; \n\tdec(enc_r(m, k, r), k) = injbot(m).\n\n\t(* INT-CTXT *)\n\nequiv(int_ctxt(enc))\n      k <-R key; (\n      \t      foreach i <= N do r <-R enc_seed; Oenc(x:cleartext) := return(enc_r(x, k, r)) |\n\t      foreach i' <= N' do Odec(y:ciphertext) [useful_change] := return(dec(y,k)))\n     <=(Advintctxt(time, N, N', maxlength(x), maxlength(y)))=> [computational] \n      k <-R key [unchanged]; (\n      \t      foreach i <= N do r <-R enc_seed [unchanged]; Oenc(x:cleartext) := z:ciphertext <- enc_r(x, k, r); return(z) |\n\t      foreach i' <= N' do Odec(y:ciphertext) := find j <= N suchthat defined(x[j],z[j]) && z[j] = y then return(injbot(x[j])) else return(bottom)).\n\n}\n\ntype key [bounded].\ntype cleartext.\ntype ciphertext.\ntype enc_seed [bounded].\nproba Advintctxt.\n\nexpand INT_CTXT_sym_enc_no_corrupt(key, cleartext, ciphertext, enc_seed, enc, enc_r, enc_r', dec, injbot, Z, Advintctxt).\n\nproof {\n  success simplify;\n  auto\n}\n\nparam N, N'. \n\nquery_equiv(int_ctxt_corrupt(enc))\n      k <-R key; (\n      \t      foreach i <= N do r <-R enc_seed; Oenc(x:cleartext) := return(enc_r(x, k, r)) |\n\t      foreach i' <= N' do Odec(y:ciphertext) [useful_change] := return(dec(y,k)) |\n\t      Ocorrupt() [10] := return(k))\n     <=(?)=> [manual,computational] \n      k <-R key [unchanged]; (\n      \t      foreach i <= N do r <-R enc_seed [unchanged]; Oenc(x:cleartext) := z:ciphertext <- enc_r(x, k, r); return(z) |\n\t      foreach i' <= N' do Odec(y:ciphertext) :=\n\t      \t      if defined(corrupt) then return(dec(y,k)) else\n\t\t      find j <= N suchthat defined(x[j],z[j]) && z[j] = y then return(injbot(x[j])) else return(bottom) |\n\t      Ocorrupt() := let corrupt: bool = true in return(k))\n\n(* EXPECTED\nAll queries proved.\n0.049s (user 0.038s + system 0.011s), max rss 20004K\nEND *)"
    },
    {
        "file": "CV-1/invites.cv",
        "incomplete": "(*----------------------------------*)\n(*Types\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\ntype hmac_key [large, fixed].\ntype hash_key [nonuniform, fixed].\ntype sym_key [large, fixed].\ntype nonce [bounded].\ntype Z [large, bounded].\ntype ____(OP_5)____ [large, bounded].\ntype subG [large, bounded].\ntype D [____(TYPE_2)____].\ntype prfout [bounded].\ntype message [____(TYPE_1)____].\ntype ____(TYPE_0)____ [large, fixed].\ntype skey [bounded].\ntype pkey [bounded].\n\n(*----------------------------------*)\n(*Constants\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nparam ____(PARAM_0)____, N2.\n\nchannel c1, c2, ____(CHANNEL_0)____, c4, c5, c6, c7, c8, c9, ____(CHANNEL_2)____, ____(CHANNEL_1)____, finish.\nconst failmsg: bitstring.\nconst zero:sym_key.\nconst nonce0: nonce.\nconst empty_addata: bitstring.\nconst hkey: hash_key.\n\nevent ClientAccept(____(OP_17)____).\nevent ServerAccept(G).\nevent ClientEndSession(G,hmac_key).\nevent ServerEndSession(G,hmac_key).\nevent ClientConfirmNetwork(hmac_key).\nevent ServerConfirmNetwork(hmac_key).\nevent Sentmessage(G, bitstring).\nevent Receivedmessage(G, ____(EVENT_1)____).\n\n(*----------------------------------*)\n(*Primitives\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n(*Type conversions*)\nfun G2bit(G): bitstring [typeConverter].\nfun bit2G(bitstring):G     [typeConverter].\nfun symkey2bit(sym_key): bitstring [____(FUN_0)____].\nfun G2symkey(G): sym_key [typeConverter].\n\n\n(*DH*)\nexpand DH_X25519(G, Z, g, exp, mult, subG, g_k, exp_div_k, exp_div_k', pow_k, subG2G, G_zero, sub_zero).\n\n(*HMAC*)(*hmac function is modeled as a PRF *)\nproba Pprf.\nexpand PRF(____(OP_13)____, bitstring, prfout, hmac, Pprf).\n\n(*We assume in this model that SHA256 is collision resistant and preimage resistant*)\nproba Phash.\nexpand CollisionResistant_hash(hash_key, bitstring, bitstring, hash, ____(OP_9)____, Phash).\n\n(*We assume in this model that SHA256 is collision resistant and preimage resistant*)\nproba Phash2key.\nexpand CollisionResistant_hash(hash_key, ____(OP_8)____, sym_key, hash2key, hash2keyoracle, Phash2key).\n\n(*signatures*)\n(*UF-CMA malleable probabilistic signature*)\nproba ____(PROBA_1)____.\nproba Psigncoll.\nexpand UF_CMA_proba_signature(seed, pkey, skey, bitstring, bitstring, skgen, pkgen, sign, check, Psign, Psigncoll).\n\n(*secret box*)\nproba Penc.\nproba ____(PROBA_0)____.\nexpand AEAD_nonce(sym_key, bitstring, bitstring, bitstring, nonce, secret_box, secret_box_open, injbot, zeroer, Penc, Pencctxt).\n\n\n\n\n(*----------------------------------*)\n(*Queries\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n\nquery ____(QUERY_1)____:G, y:hmac_key; ____(QUERY_0)____ (ServerEndSession(x, y)) ==> event(ClientConfirmNetwork(y)).\nquery x: G, y: hmac_key ; event(ClientEndSession(x, y)) ==> event(ServerAccept(____(OP_10)____)) && event(ServerConfirmNetwork(y)).\n\n\n(*----------------------------------*)\n(*Principals\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nlet Alice(skA:Z, signA: seed, signBpk: pkey, pkB:G, skInv: Z, ____(OP_7)____: hmac_key) =\n  in(c9, m: bitstring);\n  let pkA = exp(g, ____(OP_3)____) in\n  let pkInv = exp(g, ____(OP_2)____) in\n  let signAsk = skgen(signA) in\n  let signApk = pkgen(signA) in\n\tnew ephemeral_skA: Z;\n\tlet ephemeral_pkA = exp(g, ephemeral_skA) in\n\tlet m1 = (ephemeral_pkA, hmac(N, G2bit(ephemeral_pkA))) in\n\tout(____(OP_19)____, m1);\n\tin(c2, (ephemeral_pkX:G, hmacX: prfout));\n\tif hmacX = hmac(N, G2bit(ephemeral_pkX)) then\n  let key1 = exp(____(OP_12)____, ephemeral_skA) in\n  let key2 = exp(____(OP_0)____, ephemeral_skA) in\n  let secret1 = hash2key(hkey, (N, key1, key2)) in\n  let sign_Inv = sign((N, pkB, hash(____(OP_16)____, G2bit(key1))), signAsk) in\n  let m3 = secret_box((sign_Inv, pkInv, signApk), empty_addata, secret1, nonce0) in\n\tout(c3, m3);\n\tin (c4, m4: bitstring);\n\tlet key3 = exp(ephemeral_pkX, skInv) in\n\tlet secret2 = hash2key(hkey, (N, key1, key2, key3)) in\n\tlet injbot(____(OP_20)____: bitstring) = secret_box_open(____(OP_15)____, empty_addata, secret2, nonce0) in\n  if check((N, sign_Inv, pkInv, hash(hkey ,G2bit(key1))), signBpk, sign_B) then\n\tevent ClientEndSession(pkInv, ____(EVENT_0)____).\n\nlet Bob(skB:Z, signB: ____(OP_6)____, N: hmac_key) =\n\tin(c5, (ephemeral_pkY:G, ____(OP_1)____: prfout));\n  let pkB = exp(g, skB) in\n  let signBsk = skgen(signB) in\n\tif hmacY = hmac(____(OP_11)____, G2bit(ephemeral_pkY)) then\n\tevent ServerConfirmNetwork(N);\n\tnew ephemeral_skB: Z;\n\tlet ephemeral_pkB = exp(g, ephemeral_skB) in\n\tlet m2 = (ephemeral_pkB, hmac(N, G2bit(ephemeral_pkB))) in\n\tout(c6, m2);\n\tin(c7, ____(OP_4)____: bitstring);\n\tlet key1 = exp(ephemeral_pkY, ephemeral_skB) in\n\tlet key2 = exp(ephemeral_pkY, skB) in\n\tlet secret1 = hash2key(hkey, (N, key1, key2)) in\n\tlet injbot(tuple) = secret_box_open( m3, empty_addata, ____(OP_18)____, nonce0) in\n  let (sign_Y: bitstring, ____(OP_14)____: G, signYpk: pkey) = tuple in\n\tif check((N, pkB, hash(hkey, G2bit(key1))), signYpk, sign_Y) then\n\tlet key3 = exp(pkY, ephemeral_skB) in\n\tlet secret2 = hash2key(hkey, (N, key1, key2, key3)) in\n\tlet m4:bitstring = secret_box(sign((N, sign_Y, pkY, hash(hkey, G2bit(key1))), signBsk), empty_addata, secret2, nonce0) in\n\tevent ServerAccept(pkY);\n\tout(c8, m4).\n\n(*----------------------------------*)\n(*Main process\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nprocess\n\tin(start, ());\n  new initN: hmac_key;\n  new signA: seed;\n  new signB: seed;\n  new skA: Z;\n  new skB: Z;\n  new skInv: Z;\n  new mssg: message;\n  out(begin, mssg);\n\t(! i <= N1 Alice(skA, signA, pkgen(signB), exp(g, skB), skInv, initN) |\n\t (! i <= N2 Bob(skB, signB, initN) ))",
        "complete:": "(*----------------------------------*)\n(*Types\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\ntype hmac_key [large, fixed].\ntype hash_key [nonuniform, fixed].\ntype sym_key [large, fixed].\ntype nonce [bounded].\ntype Z [large, bounded].\ntype G [large, bounded].\ntype subG [large, bounded].\ntype D [fixed].\ntype prfout [bounded].\ntype message [bounded].\ntype seed [large, fixed].\ntype skey [bounded].\ntype pkey [bounded].\n\n(*----------------------------------*)\n(*Constants\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nparam N1, N2.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, start, begin, finish.\nconst failmsg: bitstring.\nconst zero:sym_key.\nconst nonce0: nonce.\nconst empty_addata: bitstring.\nconst hkey: hash_key.\n\nevent ClientAccept(G).\nevent ServerAccept(G).\nevent ClientEndSession(G,hmac_key).\nevent ServerEndSession(G,hmac_key).\nevent ClientConfirmNetwork(hmac_key).\nevent ServerConfirmNetwork(hmac_key).\nevent Sentmessage(G, bitstring).\nevent Receivedmessage(G, bitstring).\n\n(*----------------------------------*)\n(*Primitives\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n(*Type conversions*)\nfun G2bit(G): bitstring [typeConverter].\nfun bit2G(bitstring):G     [typeConverter].\nfun symkey2bit(sym_key): bitstring [typeConverter].\nfun G2symkey(G): sym_key [typeConverter].\n\n\n(*DH*)\nexpand DH_X25519(G, Z, g, exp, mult, subG, g_k, exp_div_k, exp_div_k', pow_k, subG2G, G_zero, sub_zero).\n\n(*HMAC*)(*hmac function is modeled as a PRF *)\nproba Pprf.\nexpand PRF(hmac_key, bitstring, prfout, hmac, Pprf).\n\n(*We assume in this model that SHA256 is collision resistant and preimage resistant*)\nproba Phash.\nexpand CollisionResistant_hash(hash_key, bitstring, bitstring, hash, hashoracle, Phash).\n\n(*We assume in this model that SHA256 is collision resistant and preimage resistant*)\nproba Phash2key.\nexpand CollisionResistant_hash(hash_key, bitstring, sym_key, hash2key, hash2keyoracle, Phash2key).\n\n(*signatures*)\n(*UF-CMA malleable probabilistic signature*)\nproba Psign.\nproba Psigncoll.\nexpand UF_CMA_proba_signature(seed, pkey, skey, bitstring, bitstring, skgen, pkgen, sign, check, Psign, Psigncoll).\n\n(*secret box*)\nproba Penc.\nproba Pencctxt.\nexpand AEAD_nonce(sym_key, bitstring, bitstring, bitstring, nonce, secret_box, secret_box_open, injbot, zeroer, Penc, Pencctxt).\n\n\n\n\n(*----------------------------------*)\n(*Queries\t\t\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\n\nquery x:G, y:hmac_key; event (ServerEndSession(x, y)) ==> event(ClientConfirmNetwork(y)).\nquery x: G, y: hmac_key ; event(ClientEndSession(x, y)) ==> event(ServerAccept(x)) && event(ServerConfirmNetwork(y)).\n\n\n(*----------------------------------*)\n(*Principals\t\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nlet Alice(skA:Z, signA: seed, signBpk: pkey, pkB:G, skInv: Z, N: hmac_key) =\n  in(c9, m: bitstring);\n  let pkA = exp(g, skA) in\n  let pkInv = exp(g, skInv) in\n  let signAsk = skgen(signA) in\n  let signApk = pkgen(signA) in\n\tnew ephemeral_skA: Z;\n\tlet ephemeral_pkA = exp(g, ephemeral_skA) in\n\tlet m1 = (ephemeral_pkA, hmac(N, G2bit(ephemeral_pkA))) in\n\tout(c1, m1);\n\tin(c2, (ephemeral_pkX:G, hmacX: prfout));\n\tif hmacX = hmac(N, G2bit(ephemeral_pkX)) then\n  let key1 = exp(ephemeral_pkX, ephemeral_skA) in\n  let key2 = exp(pkB, ephemeral_skA) in\n  let secret1 = hash2key(hkey, (N, key1, key2)) in\n  let sign_Inv = sign((N, pkB, hash(hkey, G2bit(key1))), signAsk) in\n  let m3 = secret_box((sign_Inv, pkInv, signApk), empty_addata, secret1, nonce0) in\n\tout(c3, m3);\n\tin (c4, m4: bitstring);\n\tlet key3 = exp(ephemeral_pkX, skInv) in\n\tlet secret2 = hash2key(hkey, (N, key1, key2, key3)) in\n\tlet injbot(sign_B: bitstring) = secret_box_open(m4, empty_addata, secret2, nonce0) in\n  if check((N, sign_Inv, pkInv, hash(hkey ,G2bit(key1))), signBpk, sign_B) then\n\tevent ClientEndSession(pkInv, N).\n\nlet Bob(skB:Z, signB: seed, N: hmac_key) =\n\tin(c5, (ephemeral_pkY:G, hmacY: prfout));\n  let pkB = exp(g, skB) in\n  let signBsk = skgen(signB) in\n\tif hmacY = hmac(N, G2bit(ephemeral_pkY)) then\n\tevent ServerConfirmNetwork(N);\n\tnew ephemeral_skB: Z;\n\tlet ephemeral_pkB = exp(g, ephemeral_skB) in\n\tlet m2 = (ephemeral_pkB, hmac(N, G2bit(ephemeral_pkB))) in\n\tout(c6, m2);\n\tin(c7, m3: bitstring);\n\tlet key1 = exp(ephemeral_pkY, ephemeral_skB) in\n\tlet key2 = exp(ephemeral_pkY, skB) in\n\tlet secret1 = hash2key(hkey, (N, key1, key2)) in\n\tlet injbot(tuple) = secret_box_open( m3, empty_addata, secret1, nonce0) in\n  let (sign_Y: bitstring, pkY: G, signYpk: pkey) = tuple in\n\tif check((N, pkB, hash(hkey, G2bit(key1))), signYpk, sign_Y) then\n\tlet key3 = exp(pkY, ephemeral_skB) in\n\tlet secret2 = hash2key(hkey, (N, key1, key2, key3)) in\n\tlet m4:bitstring = secret_box(sign((N, sign_Y, pkY, hash(hkey, G2bit(key1))), signBsk), empty_addata, secret2, nonce0) in\n\tevent ServerAccept(pkY);\n\tout(c8, m4).\n\n(*----------------------------------*)\n(*Main process\t\t\t\t\t\t\t\t\t\t\t*)\n(*----------------------------------*)\n\nprocess\n\tin(start, ());\n  new initN: hmac_key;\n  new signA: seed;\n  new signB: seed;\n  new skA: Z;\n  new skB: Z;\n  new skInv: Z;\n  new mssg: message;\n  out(begin, mssg);\n\t(! i <= N1 Alice(skA, signA, pkgen(signB), exp(g, skB), skInv, initN) |\n\t (! i <= N2 Bob(skB, signB, initN) ))"
    },
    {
        "file": "CV-1/kerberos-conclude-simplified.cv",
        "incomplete": "(*\n  CryptoVerif tries to apply the rewrite rule test(b,x,x) -> x to\n  test(b,Z(m1),Z(m2)). Trying to match the term test(b,Z(m1),Z(m2))\n  with the pattern test(b,x,x) in Facts.match_term calls\n  \"Terms.simp_equal_terms try_no_var Z(m1) Z(m2)\" where\n  try_no_var = Facts.try_no_var (Z(m1) -> Z(m2)).\n  However, Terms.simp_equal_terms and Facts.try_no_var \n  apply substitutions only to variables, so not to Z(m1).\n  Hence the matching fails and the simplification is not\n  detected.\n*)\n\n\nparam ____(PARAM_0)____.\ntype ____(TYPE_0)____ [bounded].\nfun Z(____(OP_2)____):maxenc.\n\nchannel c1, ____(CHANNEL_0)____, c3, start.\n\n\nquery secret1 ____(QUERY_0)____.\n\n\n(* Key Usability : we want to check if the encryption scheme is still CCA2 secure when using the key SK *)\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, ____(FUN_0)____, ____(OP_3)____):maxenc.\n\nforall b:bool, x:maxenc, y:maxenc; Z(test(b,x,y)) = test(b,Z(x),Z(y)).\nforall b:bool, x:maxenc; test(b,x,x) = x.\n\n(* Encryption Oracle *)\n\nlet processOE =\n\tin(c2,(m1:maxenc, m2:maxenc));\n\tif Z(m1) = Z(m2) then\n    \tlet menc = test(b1,Z(m1),Z(m2)) in\n    \tout(c3, menc).\n\nprocess \n\tin(start, ());\n\t  new b1:bool;\t\t\t\t\t(* let b1 in {0,1} *)\n     \t  out(c1, ());\t\t\t\t\t\t\n      \t  ( ! qE processOE ) \n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.008s + system 0.012s), max rss 22736K\nEND *)",
        "complete:": "(*\n  CryptoVerif tries to apply the rewrite rule test(b,x,x) -> x to\n  test(b,Z(m1),Z(m2)). Trying to match the term test(b,Z(m1),Z(m2))\n  with the pattern test(b,x,x) in Facts.match_term calls\n  \"Terms.simp_equal_terms try_no_var Z(m1) Z(m2)\" where\n  try_no_var = Facts.try_no_var (Z(m1) -> Z(m2)).\n  However, Terms.simp_equal_terms and Facts.try_no_var \n  apply substitutions only to variables, so not to Z(m1).\n  Hence the matching fails and the simplification is not\n  detected.\n*)\n\n\nparam qE.\ntype maxenc [bounded].\nfun Z(maxenc):maxenc.\n\nchannel c1, c2, c3, start.\n\n\nquery secret1 b1.\n\n\n(* Key Usability : we want to check if the encryption scheme is still CCA2 secure when using the key SK *)\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, maxenc, maxenc):maxenc.\n\nforall b:bool, x:maxenc, y:maxenc; Z(test(b,x,y)) = test(b,Z(x),Z(y)).\nforall b:bool, x:maxenc; test(b,x,x) = x.\n\n(* Encryption Oracle *)\n\nlet processOE =\n\tin(c2,(m1:maxenc, m2:maxenc));\n\tif Z(m1) = Z(m2) then\n    \tlet menc = test(b1,Z(m1),Z(m2)) in\n    \tout(c3, menc).\n\nprocess \n\tin(start, ());\n\t  new b1:bool;\t\t\t\t\t(* let b1 in {0,1} *)\n     \t  out(c1, ());\t\t\t\t\t\t\n      \t  ( ! qE processOE ) \n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.008s + system 0.012s), max rss 22736K\nEND *)"
    },
    {
        "file": "CV-1/Kyber.ocv",
        "incomplete": "proof {\nsimplify coll_elim(variables:z_1);\ninsert before \"if secb\" \"if pk_6 = pk' then\";\ninsert before_nth 1 \"if secb\" \"if ct_3 = c_1 then\";\n\nall_simplify;\nall_simplify;\nsuccess\n}\n\n\n(* Types for abstract CPA KEM *)\n\n \ntype ____(OP_5)____ [bounded].\ntype cpa_sk [bounded].\ntype ____(OP_4)____ [bounded].\ntype cpa_key_seed [large,fixed].\ntype cpa_enc_seed [large,fixed].\n\n\n\n\n(* Types for final CCA  KEM *)\n\ntype kemskey [bounded].\n\ntype ____(TYPE_2)____.\ntype kem_seed [large,fixed].\ntype kem_enc_seed [large,fixed].\n\n\ntype kemsec [large,fixed].\n\ntype kem_keypair.\nfun KEM_KeyPair(cpa_pk, kemskey) : kem_keypair [data].\n\n\n\n(* Hash functions *)\n\ntype hashes [bounded]. (* H output *)\n\ntype B [____(TYPE_1)____,fixed].\ntype hashkey [____(TYPE_3)____,fixed]. \nproba ____(PROBA_0)____.\nexpand CollisionResistant_hash_2(hashkey, B,hashes, kemsec, KDF, hashoracleKDF, qH2).\n\ntype hashkey2 [large,____(TYPE_0)____].\n\nproba qH3.\nexpand CollisionResistant_hash_1(hashkey2, B, hashes, H, hashoracleH, qH3).\n\nfun cpa_pk_to_B(cpa_pk) :B [data].\n\nfun cpa_ct_to_B(cpa_ciphertext) :B [data].\n\nletfun H1(____(OP_2)____:hashkey2,pk: cpa_pk) =\n       H(hk2, cpa_pk_to_B(pk)).\n\nletfun H2(hk2:hashkey2,b: B) =\n       H(hk2, b).\n\nletfun H3(hk2:hashkey2,ct:cpa_ciphertext) =\n       H(hk2, cpa_ct_to_B(ct) ).\n\n\nproba qH4.\ntype hashkey3 [large,fixed].\nexpand CollisionResistant_hash_2(hashkey3, hashes, hashes, B, G1, hashoracleG1, qH4).\n\n\n\nfun G2(hashes,hashes) : cpa_enc_seed.\n\n\n\n\n\nfun cpa_pkgen(cpa_key_seed):cpa_pk.\nfun cpa_skgen(cpa_key_seed):cpa_sk.\n\nfun cpa_enc(cpa_pk,____(FUN_0)____, cpa_enc_seed) : cpa_ciphertext.\nfun cpa_dec(cpa_sk,cpa_ciphertext) : hashes.\n\n\n\n\nequation forall m:hashes, s:cpa_key_seed, r:cpa_enc_seed;\n\t cpa_dec( cpa_skgen(s), cpa_enc( cpa_pkgen(s), m, r)) =m.\n\n\n(* type kempkey [bounded]. *) (* this is already cpa_pk *)\n\n\nfun kem_to_cpa_seed(kem_seed) : cpa_key_seed.\n\n\n\n\n\nfun concat4(cpa_sk,____(FUN_2)____,hashes,____(FUN_1)____) : kemskey [data].\n\nletfun cca_gen(hk2: hashkey2, ____(OP_11)____ : ____(OP_0)____)  =\n       z <-R B;\n       ____(OP_8)____ <-  kem_to_cpa_seed(k);\n       pk <- cpa_pkgen(cpas);\n       sk' <- cpa_skgen(cpas);\n       sk <- concat4(sk',pk,H1(hk2,pk),z);\n       KEM_KeyPair(pk, sk).\n     \n\n\n\n\ntype encapspair.\nfun KEMEncaps(cpa_ciphertext,kemsec) : encapspair [data].\n\n\nfun kseedToB(kem_enc_seed) : B.\nletfun cca_encaps(hk:____(OP_12)____, hk2: hashkey2, ____(OP_14)____: hashkey3, pk : ____(OP_13)____, k : kem_enc_seed) =\n       m' <- kseedToB(k);\n       m <- H2(hk2,m');\n       Kt <- G1(hk3,m,H1(hk2,pk));\n       r <- G2(m,H1(hk2,pk));\n       c <- cpa_enc(pk,m,r);\n       KEMEncaps(c,KDF(hk,Kt, H3(hk2,c))).\n\n\nconst nullsec : kemsec.\n\nletfun cca_decap(hk:hashkey, hk2: hashkey2, hk3: hashkey3, c : cpa_ciphertext, sk : kemskey) =\n       let concat4(sk',pk,h,z) = sk in\n       m' <- cpa_dec(____(OP_10)____,c);\n       Kt' <- G1(hk3, m',H1(hk2,pk));\n       r' <- G2(m',H1(hk2, pk));\n       c' <- cpa_enc(pk,m',____(OP_6)____);\n       (if c = c' then\n              KDF(hk,Kt', H3(hk2,c'))\n\t      else\n\t     KDF(hk,z, H3(hk2,c)))\n\t else\n\t  nullsec (*cannot occur *)\n.       \n\n\n(* We prove the equivalent of \n\nfun decap(ciphertext, kemskey): kemsec.\n\nfun kem_secret(kempkey, kem_enc_seed) : kemsec.\nfun kem_encap(kempkey, kem_enc_seed): ciphertext.\n\ncollision r <-R kem_seed; k <-R kem_enc_seed;  forall ct: ciphertext, pk:kempkey;\n\t  return(decap(ct,kemskgen(r))= kem_secret(pk,k))\n\t  <=(KEMcollNew)=> return(ct=kem_encap(pk,k) && pk = kempkgen(r)).\n*)\n\n\nquery ____(QUERY_0)____ secb [cv_bit].\n\nset autoMergeBranches = true.\nset autoSARename = true.\n\nprocess\n    Start() :=\n    \t    hk <-R hashkey;\n    \t    hk2 <-R hashkey2;\n    \t    hk3 <-R hashkey3;\t    \n    \t    secb <-R bool;\n    \t    r <-R kem_seed;\n\t    k <-R kem_enc_seed;\n\t    let  KEM_KeyPair(pk, sk) = cca_gen(hk2,r) in\n\t    return(r,____(OP_7)____);\n\n\t    run hashoracleKDF(hk) |\n\t    run hashoracleH(hk2) |\n\t    run hashoracleG1(hk3) |\t  \t    \n\t    OChall(ct: cpa_ciphertext, pk':____(OP_9)____) :=\n    \t    let KEMEncaps(____(OP_3)____,K) = cca_encaps(hk,hk2,hk3,pk',k) in\n\t    (\n\t    \t   if secb then \n\t\t      \t    return(cca_decap(hk,hk2,hk3,ct, sk) = K)\n\t\t    else\n\t\t\treturn( (ct = c) && (pk' = pk))\n\t\t\t\t    )",
        "complete:": "proof {\nsimplify coll_elim(variables:z_1);\ninsert before \"if secb\" \"if pk_6 = pk' then\";\ninsert before_nth 1 \"if secb\" \"if ct_3 = c_1 then\";\n\nall_simplify;\nall_simplify;\nsuccess\n}\n\n\n(* Types for abstract CPA KEM *)\n\n \ntype cpa_pk [bounded].\ntype cpa_sk [bounded].\ntype cpa_ciphertext [bounded].\ntype cpa_key_seed [large,fixed].\ntype cpa_enc_seed [large,fixed].\n\n\n\n\n(* Types for final CCA  KEM *)\n\ntype kemskey [bounded].\n\ntype ciphertext.\ntype kem_seed [large,fixed].\ntype kem_enc_seed [large,fixed].\n\n\ntype kemsec [large,fixed].\n\ntype kem_keypair.\nfun KEM_KeyPair(cpa_pk, kemskey) : kem_keypair [data].\n\n\n\n(* Hash functions *)\n\ntype hashes [bounded]. (* H output *)\n\ntype B [large,fixed].\ntype hashkey [large,fixed]. \nproba qH2.\nexpand CollisionResistant_hash_2(hashkey, B,hashes, kemsec, KDF, hashoracleKDF, qH2).\n\ntype hashkey2 [large,fixed].\n\nproba qH3.\nexpand CollisionResistant_hash_1(hashkey2, B, hashes, H, hashoracleH, qH3).\n\nfun cpa_pk_to_B(cpa_pk) :B [data].\n\nfun cpa_ct_to_B(cpa_ciphertext) :B [data].\n\nletfun H1(hk2:hashkey2,pk: cpa_pk) =\n       H(hk2, cpa_pk_to_B(pk)).\n\nletfun H2(hk2:hashkey2,b: B) =\n       H(hk2, b).\n\nletfun H3(hk2:hashkey2,ct:cpa_ciphertext) =\n       H(hk2, cpa_ct_to_B(ct) ).\n\n\nproba qH4.\ntype hashkey3 [large,fixed].\nexpand CollisionResistant_hash_2(hashkey3, hashes, hashes, B, G1, hashoracleG1, qH4).\n\n\n\nfun G2(hashes,hashes) : cpa_enc_seed.\n\n\n\n\n\nfun cpa_pkgen(cpa_key_seed):cpa_pk.\nfun cpa_skgen(cpa_key_seed):cpa_sk.\n\nfun cpa_enc(cpa_pk,hashes, cpa_enc_seed) : cpa_ciphertext.\nfun cpa_dec(cpa_sk,cpa_ciphertext) : hashes.\n\n\n\n\nequation forall m:hashes, s:cpa_key_seed, r:cpa_enc_seed;\n\t cpa_dec( cpa_skgen(s), cpa_enc( cpa_pkgen(s), m, r)) =m.\n\n\n(* type kempkey [bounded]. *) (* this is already cpa_pk *)\n\n\nfun kem_to_cpa_seed(kem_seed) : cpa_key_seed.\n\n\n\n\n\nfun concat4(cpa_sk,cpa_pk,hashes,B) : kemskey [data].\n\nletfun cca_gen(hk2: hashkey2, k : kem_seed)  =\n       z <-R B;\n       cpas <-  kem_to_cpa_seed(k);\n       pk <- cpa_pkgen(cpas);\n       sk' <- cpa_skgen(cpas);\n       sk <- concat4(sk',pk,H1(hk2,pk),z);\n       KEM_KeyPair(pk, sk).\n     \n\n\n\n\ntype encapspair.\nfun KEMEncaps(cpa_ciphertext,kemsec) : encapspair [data].\n\n\nfun kseedToB(kem_enc_seed) : B.\nletfun cca_encaps(hk:hashkey, hk2: hashkey2, hk3: hashkey3, pk : cpa_pk, k : kem_enc_seed) =\n       m' <- kseedToB(k);\n       m <- H2(hk2,m');\n       Kt <- G1(hk3,m,H1(hk2,pk));\n       r <- G2(m,H1(hk2,pk));\n       c <- cpa_enc(pk,m,r);\n       KEMEncaps(c,KDF(hk,Kt, H3(hk2,c))).\n\n\nconst nullsec : kemsec.\n\nletfun cca_decap(hk:hashkey, hk2: hashkey2, hk3: hashkey3, c : cpa_ciphertext, sk : kemskey) =\n       let concat4(sk',pk,h,z) = sk in\n       m' <- cpa_dec(sk',c);\n       Kt' <- G1(hk3, m',H1(hk2,pk));\n       r' <- G2(m',H1(hk2, pk));\n       c' <- cpa_enc(pk,m',r');\n       (if c = c' then\n              KDF(hk,Kt', H3(hk2,c'))\n\t      else\n\t     KDF(hk,z, H3(hk2,c)))\n\t else\n\t  nullsec (*cannot occur *)\n.       \n\n\n(* We prove the equivalent of \n\nfun decap(ciphertext, kemskey): kemsec.\n\nfun kem_secret(kempkey, kem_enc_seed) : kemsec.\nfun kem_encap(kempkey, kem_enc_seed): ciphertext.\n\ncollision r <-R kem_seed; k <-R kem_enc_seed;  forall ct: ciphertext, pk:kempkey;\n\t  return(decap(ct,kemskgen(r))= kem_secret(pk,k))\n\t  <=(KEMcollNew)=> return(ct=kem_encap(pk,k) && pk = kempkgen(r)).\n*)\n\n\nquery secret secb [cv_bit].\n\nset autoMergeBranches = true.\nset autoSARename = true.\n\nprocess\n    Start() :=\n    \t    hk <-R hashkey;\n    \t    hk2 <-R hashkey2;\n    \t    hk3 <-R hashkey3;\t    \n    \t    secb <-R bool;\n    \t    r <-R kem_seed;\n\t    k <-R kem_enc_seed;\n\t    let  KEM_KeyPair(pk, sk) = cca_gen(hk2,r) in\n\t    return(r,k);\n\n\t    run hashoracleKDF(hk) |\n\t    run hashoracleH(hk2) |\n\t    run hashoracleG1(hk3) |\t  \t    \n\t    OChall(ct: cpa_ciphertext, pk':cpa_pk) :=\n    \t    let KEMEncaps(c,K) = cca_encaps(hk,hk2,hk3,pk',k) in\n\t    (\n\t    \t   if secb then \n\t\t      \t    return(cca_decap(hk,hk2,hk3,ct, sk) = K)\n\t\t    else\n\t\t\treturn( (ct = c) && (pk' = pk))\n\t\t\t\t    )"
    },
    {
        "file": "CV-1/lemmaMAC_collision_resistant_Nkeys.ocv",
        "incomplete": "(* The files lemmaMAC_collision_resistant.ocv and lemmaMAC_collision_resistant2.ocv \n   show that, assuming HMAC-SHA256, KDF256, and KDF128 are\n   independent pseudo-random functions (using the same key), HMAC-SHA256\n   is collision-resistant. (The MAC key remains secret, but the adversary\n   is allowed to make MAC queries.)\n\nMore precisely, we prove equivalence:\n\n\t!N new k: mac_key;\n\t(! qMAC O_mac(m: bitstring) := MAC2(k, m),\n\t ! qColl O_coll(m1: bitstring, m2: bitstring) [useful_change] := (MAC2(k, m1) = MAC2(k, m2)))\n<=(N * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| +\n        2 * PPRF(time + (N-1) * (qMAC + 2 * qColl) * time(MAC, max(maxlength(m), maxlength(m2), maxlength(m1))), \n                 qMAC + 2 * qColl, max(maxlength(m), maxlength(m2), maxlength(m1)), 0, 0)))=>\n\t!N new k: mac_key;\n\t(! qMAC O_mac(m: bitstring) := MAC2(k, m),\n\t ! qColl O_coll(m1: bitstring, m2: bitstring) := (m1 = m2)).\n\nWe prove the secrecy of bit b in the game below, \nwhich implies this indistinguishability.\n\nProved secrecy of b up to probability (12. * N * qColl + 4. * qColl * qColl * N * N + 4. * qColl * N * N * qMAC + qMAC * qMAC * N * N) / |t_SHA256_out| + 2. * N * PPRF(time(context for game 8) + time + (-1. * qMAC + N * qMAC + -2. * qColl + 2. * N * qColl) * time(MAC, max(maxlength(game 8: m), maxlength(game 8: m2), maxlength(game 8: m1))), qMAC + 2. * qColl, max(maxlength(game 8: m), maxlength(game 8: m2), maxlength(game 8: m1)), 0, 0)\ntime(context for game 8) = qColl * N * time(= bitstring, maxlength(game 8: m1), maxlength(game 8: m2))\n\nIgnoring the time of equality checks, we get\n\nProved secrecy of b up to probability \nN * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| +\n     2 * PPRF(time + (N-1) * (qMAC + 2 * qColl) * time(MAC, max(maxlength(m), maxlength(m2), maxlength(m1))), \n              qMAC + 2 * qColl, max(maxlength(m), maxlength(m2), maxlength(m1)), 0, 0))\nThe factors N inside (...)/|t_SHA256_out| could actually be removed,\nas obtained by considering one key, and then inferring for N keys. \n*)\n\n(* Do not assume by default that all constants are \n   different. We shall say it explicitly when they are different *)\n\nset diffConstants = false.\n\n(**** Manual indications for the proof ****)\n\nproof {\n      show_game occ;\n      insert 29 \"if m1 = m2 then\";\n      show_game occ;\n      insert 65 \"if MAC(k,____(OP_0)____) = MAC(k,m2) then\";\n      simplify;\n      merge_branches;\n      auto\n}\n\n(**** Declarations of types, constants, and functions\n      with the associated assumptions ****)\n\ntype mac_key [large, fixed]. (* 256 bits HMAC-SHA256 key *)\ntype enc_key [large, fixed]. (* 128 bits AES key *)\ntype t_SHA256_out [fixed, large]. (* 256 bits bitstrings *)\ntype ____(TYPE_0)____ [fixed].\n\nfun MAC(mac_key, ____(FUN_0)____): t_SHA256_out.\nfun KDF256(mac_key, t_SHA256_out, t_id, t_id): mac_key.\nfun KDF128(mac_key, t_SHA256_out, t_id, t_id): enc_key.\n\nparam N, ____(PARAM_0)____, qMAC, qColl, qKDF256, qKDF128.\n\n(* Assumption:  HMAC-SHA256, KDF256, and KDF128 are\nindependent pseudo-random functions (using the same key) *)\n\nproba ____(PROBA_0)____.\n      (* PPRF(t, qMAC, l, qKDF256, qKDF128) is the probability of \n         distinguishing MAC, KDF256, and KDF128 from independent pseudo-random\n\t functions in time t, with qMAC, qKDF256, qKDF128 queries to\n\t MAC, KDF256, and KDF128 respectively, with MAC queries of length\n\t at most l. *)\n\nequiv\n\tforeach i <= q do\n\tk <-R mac_key;\n\t(foreach i <= qMAC do O_MAC(m: bitstring) := return(MAC(k, m)) |\n\t foreach i <= qKDF256 do O_KDF256(X: t_SHA256_out, U: t_id, V: t_id) :=\n\t \t      \t      \t return(KDF256(____(OP_7)____, X, U, V)) |\n\t foreach i <= qKDF128 do O_KDF128(X: t_SHA256_out, U: t_id, V: t_id) :=\n\t \t      \t      \t return(KDF128(k, X, ____(OP_2)____, V)))\n<=(q * PPRF(time + (q-1)*(qMAC * time(MAC, maxlength(m)) + qKDF256 * time(KDF256) + qKDF128 * time(KDF128)), qMAC, maxlength(m), qKDF256, qKDF128))=>\n\tforeach i <= q do\n\t(foreach i <= qMAC do O_MAC(m: bitstring) := \n\t    find[unique] j1 <= qMAC suchthat defined(m[j1],r1[j1]) && m = m[j1] then\n\t\treturn(r1[j1])\n\t    else \n\t\tr1 <-R t_SHA256_out;\n\t\treturn(r1)\n\t |\n\t foreach i <= qKDF256 do O_KDF256(X2: t_SHA256_out, U2: t_id, V2: t_id) :=\n\t    find[unique] j2 <= qKDF256 suchthat defined(X2[j2],U2[j2],V2[j2],____(OP_6)____[j2]) && \n\t    \t X2 = X2[j2] && U2 = U2[j2] && V2 = V2[j2] then\n\t\treturn(r2[j2])\n\t    else \n\t\tr2 <-R mac_key;\n\t\treturn(r2)\n\t |\n\t foreach i <= qKDF128 do O_KDF128(X3: t_SHA256_out, U3: t_id, V3: t_id) :=\n\t    find[unique] j3 <= qKDF128 suchthat defined(X3[j3],U3[j3],V3[j3],____(OP_1)____[j3]) && \n\t    \t X3 = X3[j3] && U3 = U3[j3] && V3 = V3[j3] then\n\t\treturn(r3[j3])\n\t    else \n\t\tr3 <-R enc_key;\n\t\treturn(r3)\n\t ).\n\t\n(* Security property to prove: secrecy of bit b *)\n\nquery secret ____(QUERY_0)____.\n\n(**** Initial game ****)\n\n(* HMAC-SHA256 oracle *)\n\nlet PMAC =\n    foreach i <= qMAC do\n    O_MAC(m: bitstring) :=\n    return(MAC(k, m)).\n\n(* HMAC-SHA256 collision oracle *)\n\nlet PColl =\n    foreach i <= qColl do\n    O_Coll(m1: bitstring, m2: bitstring) :=\n    if b then\n       return(m1 = m2)\n    else\n       return(MAC(k, m1) = MAC(k, m2)).\n\nprocess\n\tOstart() :=\n\tb <-R bool;\n\treturn();\n\tforeach ik <= N do\n\tOgen() :=\n\tk <-R mac_key;\n\treturn();\n\t(PMAC | PColl)\n\n(* EXPECTED\nAll queries proved.\n0.052s (user 0.040s + system 0.012s), max rss 30960K\nEND *)",
        "complete:": "(* The files lemmaMAC_collision_resistant.ocv and lemmaMAC_collision_resistant2.ocv \n   show that, assuming HMAC-SHA256, KDF256, and KDF128 are\n   independent pseudo-random functions (using the same key), HMAC-SHA256\n   is collision-resistant. (The MAC key remains secret, but the adversary\n   is allowed to make MAC queries.)\n\nMore precisely, we prove equivalence:\n\n\t!N new k: mac_key;\n\t(! qMAC O_mac(m: bitstring) := MAC2(k, m),\n\t ! qColl O_coll(m1: bitstring, m2: bitstring) [useful_change] := (MAC2(k, m1) = MAC2(k, m2)))\n<=(N * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| +\n        2 * PPRF(time + (N-1) * (qMAC + 2 * qColl) * time(MAC, max(maxlength(m), maxlength(m2), maxlength(m1))), \n                 qMAC + 2 * qColl, max(maxlength(m), maxlength(m2), maxlength(m1)), 0, 0)))=>\n\t!N new k: mac_key;\n\t(! qMAC O_mac(m: bitstring) := MAC2(k, m),\n\t ! qColl O_coll(m1: bitstring, m2: bitstring) := (m1 = m2)).\n\nWe prove the secrecy of bit b in the game below, \nwhich implies this indistinguishability.\n\nProved secrecy of b up to probability (12. * N * qColl + 4. * qColl * qColl * N * N + 4. * qColl * N * N * qMAC + qMAC * qMAC * N * N) / |t_SHA256_out| + 2. * N * PPRF(time(context for game 8) + time + (-1. * qMAC + N * qMAC + -2. * qColl + 2. * N * qColl) * time(MAC, max(maxlength(game 8: m), maxlength(game 8: m2), maxlength(game 8: m1))), qMAC + 2. * qColl, max(maxlength(game 8: m), maxlength(game 8: m2), maxlength(game 8: m1)), 0, 0)\ntime(context for game 8) = qColl * N * time(= bitstring, maxlength(game 8: m1), maxlength(game 8: m2))\n\nIgnoring the time of equality checks, we get\n\nProved secrecy of b up to probability \nN * ((12 * qColl + 4 * qColl * qColl * N + 4 * qColl * N * qMAC + qMAC * qMAC * N) / |t_SHA256_out| +\n     2 * PPRF(time + (N-1) * (qMAC + 2 * qColl) * time(MAC, max(maxlength(m), maxlength(m2), maxlength(m1))), \n              qMAC + 2 * qColl, max(maxlength(m), maxlength(m2), maxlength(m1)), 0, 0))\nThe factors N inside (...)/|t_SHA256_out| could actually be removed,\nas obtained by considering one key, and then inferring for N keys. \n*)\n\n(* Do not assume by default that all constants are \n   different. We shall say it explicitly when they are different *)\n\nset diffConstants = false.\n\n(**** Manual indications for the proof ****)\n\nproof {\n      show_game occ;\n      insert 29 \"if m1 = m2 then\";\n      show_game occ;\n      insert 65 \"if MAC(k,m1) = MAC(k,m2) then\";\n      simplify;\n      merge_branches;\n      auto\n}\n\n(**** Declarations of types, constants, and functions\n      with the associated assumptions ****)\n\ntype mac_key [large, fixed]. (* 256 bits HMAC-SHA256 key *)\ntype enc_key [large, fixed]. (* 128 bits AES key *)\ntype t_SHA256_out [fixed, large]. (* 256 bits bitstrings *)\ntype t_id [fixed].\n\nfun MAC(mac_key, bitstring): t_SHA256_out.\nfun KDF256(mac_key, t_SHA256_out, t_id, t_id): mac_key.\nfun KDF128(mac_key, t_SHA256_out, t_id, t_id): enc_key.\n\nparam N, q, qMAC, qColl, qKDF256, qKDF128.\n\n(* Assumption:  HMAC-SHA256, KDF256, and KDF128 are\nindependent pseudo-random functions (using the same key) *)\n\nproba PPRF.\n      (* PPRF(t, qMAC, l, qKDF256, qKDF128) is the probability of \n         distinguishing MAC, KDF256, and KDF128 from independent pseudo-random\n\t functions in time t, with qMAC, qKDF256, qKDF128 queries to\n\t MAC, KDF256, and KDF128 respectively, with MAC queries of length\n\t at most l. *)\n\nequiv\n\tforeach i <= q do\n\tk <-R mac_key;\n\t(foreach i <= qMAC do O_MAC(m: bitstring) := return(MAC(k, m)) |\n\t foreach i <= qKDF256 do O_KDF256(X: t_SHA256_out, U: t_id, V: t_id) :=\n\t \t      \t      \t return(KDF256(k, X, U, V)) |\n\t foreach i <= qKDF128 do O_KDF128(X: t_SHA256_out, U: t_id, V: t_id) :=\n\t \t      \t      \t return(KDF128(k, X, U, V)))\n<=(q * PPRF(time + (q-1)*(qMAC * time(MAC, maxlength(m)) + qKDF256 * time(KDF256) + qKDF128 * time(KDF128)), qMAC, maxlength(m), qKDF256, qKDF128))=>\n\tforeach i <= q do\n\t(foreach i <= qMAC do O_MAC(m: bitstring) := \n\t    find[unique] j1 <= qMAC suchthat defined(m[j1],r1[j1]) && m = m[j1] then\n\t\treturn(r1[j1])\n\t    else \n\t\tr1 <-R t_SHA256_out;\n\t\treturn(r1)\n\t |\n\t foreach i <= qKDF256 do O_KDF256(X2: t_SHA256_out, U2: t_id, V2: t_id) :=\n\t    find[unique] j2 <= qKDF256 suchthat defined(X2[j2],U2[j2],V2[j2],r2[j2]) && \n\t    \t X2 = X2[j2] && U2 = U2[j2] && V2 = V2[j2] then\n\t\treturn(r2[j2])\n\t    else \n\t\tr2 <-R mac_key;\n\t\treturn(r2)\n\t |\n\t foreach i <= qKDF128 do O_KDF128(X3: t_SHA256_out, U3: t_id, V3: t_id) :=\n\t    find[unique] j3 <= qKDF128 suchthat defined(X3[j3],U3[j3],V3[j3],r3[j3]) && \n\t    \t X3 = X3[j3] && U3 = U3[j3] && V3 = V3[j3] then\n\t\treturn(r3[j3])\n\t    else \n\t\tr3 <-R enc_key;\n\t\treturn(r3)\n\t ).\n\t\n(* Security property to prove: secrecy of bit b *)\n\nquery secret b.\n\n(**** Initial game ****)\n\n(* HMAC-SHA256 oracle *)\n\nlet PMAC =\n    foreach i <= qMAC do\n    O_MAC(m: bitstring) :=\n    return(MAC(k, m)).\n\n(* HMAC-SHA256 collision oracle *)\n\nlet PColl =\n    foreach i <= qColl do\n    O_Coll(m1: bitstring, m2: bitstring) :=\n    if b then\n       return(m1 = m2)\n    else\n       return(MAC(k, m1) = MAC(k, m2)).\n\nprocess\n\tOstart() :=\n\tb <-R bool;\n\treturn();\n\tforeach ik <= N do\n\tOgen() :=\n\tk <-R mac_key;\n\treturn();\n\t(PMAC | PColl)\n\n(* EXPECTED\nAll queries proved.\n0.052s (user 0.040s + system 0.012s), max rss 30960K\nEND *)"
    },
    {
        "file": "CV-1/lemmaMAC_KDF_are_indep_PRFs_from_compression_ROM.ocv",
        "incomplete": "(* This file shows that HMAC-SHA256, KDF256, and KDF128 are independent\npseudo-random functions even when they use the same key, assuming that\nthe compression function of SHA256 is a random oracle.\n\nKDF256(k, (X,U,V)) = KDF(k; 256; SharedInfoMAC(X,U,V))\nKDF128(k, (X,U,V)) = KDF(k; 128; SharedInfoENC(X,U,V))\n\nWe rely on the result shown in \nlemmaMAC_KDF_are_indep_PRFs_from_compression_PRF.ocv\nA random oracle is a fortiori a PRF. So we just have to show the\nfollowing joint assumption:\n\nproba P_SHA256_joint.\n\nequiv SHA256_joint\n       foreach i3 <= N2 do k <-R mac_key;\n       \t       (O1() := return(SHA256_comp(SHA256_init, xor(padkey(k), opad))) |\n\t        O2() := return(SHA256_comp(SHA256_init, xor(padkey(k), ipad))) |\n\t\tforeach i<= N do O3(x: mac_key) := return(SHA256_comp(SHA256_init, concatSHA256(k, x))))\n     <=(P_SHA256_joint(time + (N2-1)*((2+N)*time(SHA256_comp) + 2*time(xor) + 2*time(padkey)), N2, N))=>\n       foreach i3 <= N2 do \n       \t       (O1() := r1 <-R t_SHA256_out; return(r1) |\n\t        O2() := r2 <-R t_SHA256_out; return(r2) |\n\t\tforeach i<= N do O3(x: mac_key) := \n\t\t\tfind[unique] j <= N suchthat defined(x[j],r3[j]) && x = x[j] then\n\t\t\t     return(r3[j])\n\t\t\telse\n\t\t\t     r3 <-R t_SHA256_out;\n\t\t\t     return(r3)).\n\nWe prove the result and obtain\nP_SHA256_joint(t, N2, N) = (2 N N2^2 + 2 N1 N2 + N1 N2 N + 4 N2^2) / |mac_key|\nwhere N1 is the number of SHA256_comp queries from the adversary.\n*)\n\n(* Do not assume by default that all constants are \n   different. We shall say it explicitly when they are different *)\n\nset diffConstants = false.\n\n(**** Declarations of types, constants, and functions\n      with the associated assumptions ****)\n\ntype mac_key [large, fixed]. (* 256 bits HMAC-SHA256 key *)\n\n(* Hash function SHA256 *)\n\ntype hashkey1 [fixed, large]. (* Models the choice of the compression function of SHA256 *)\ntype t_SHA256_out [fixed, large]. (* 256 bits bitstrings *)\ntype t_SHA256_block [large, fixed]. (* 512 bits SHA256 block *)\n\nconst SHA256_init: t_SHA256_out.\nfun concatSHA256(____(FUN_0)____, mac_key): t_SHA256_block [compos].\n\n(* SHA256 compression function = Random oracle *)\nexpand ROM_hash_pair(hashkey1, t_SHA256_out, t_SHA256_block, t_SHA256_out, SHA256_comp).\n\n(* HMAC helper functions *)\n\nconst opad, ipad: t_SHA256_block.\n\nfun padkey(mac_key): t_SHA256_block [compos].\n\nexpand Xor(t_SHA256_block, xor, zero).\n\nforall; opad <> ipad.\nforall k: mac_key, x: mac_key; xor(padkey(k), opad) <> concatSHA256(k, x).\nforall k: mac_key, x: mac_key; xor(padkey(k), ipad) <> concatSHA256(k, x).\n\n(**** Initial game ****)\n\nparam N, N1, ____(PARAM_0)____.\n\nprocess\n\tOstart() :=\n\thk1 <-R hashkey1;\n\treturn;\n\t(foreach i2 <= N2 do \n\t    Ogen() := k <-R mac_key; return;\n\t    ((O1() := return(SHA256_comp(____(OP_1)____, SHA256_init, xor(padkey(k), opad)))) |\n             (O2() := return(SHA256_comp(hk1, SHA256_init, xor(padkey(k), ____(OP_3)____)))) |\n             foreach i <= N do \n                O3(x: mac_key) := return(SHA256_comp(hk1, SHA256_init, concatSHA256(k, ____(OP_0)____))))) |\n\t(* oracle for SHA256_comp *)\n        (foreach i1 <= N1 do \n            OH(x1: t_SHA256_out, x2: t_SHA256_block) :=\n\t\t return(SHA256_comp(hk1, x1, x2)))",
        "complete:": "(* This file shows that HMAC-SHA256, KDF256, and KDF128 are independent\npseudo-random functions even when they use the same key, assuming that\nthe compression function of SHA256 is a random oracle.\n\nKDF256(k, (X,U,V)) = KDF(k; 256; SharedInfoMAC(X,U,V))\nKDF128(k, (X,U,V)) = KDF(k; 128; SharedInfoENC(X,U,V))\n\nWe rely on the result shown in \nlemmaMAC_KDF_are_indep_PRFs_from_compression_PRF.ocv\nA random oracle is a fortiori a PRF. So we just have to show the\nfollowing joint assumption:\n\nproba P_SHA256_joint.\n\nequiv SHA256_joint\n       foreach i3 <= N2 do k <-R mac_key;\n       \t       (O1() := return(SHA256_comp(SHA256_init, xor(padkey(k), opad))) |\n\t        O2() := return(SHA256_comp(SHA256_init, xor(padkey(k), ipad))) |\n\t\tforeach i<= N do O3(x: mac_key) := return(SHA256_comp(SHA256_init, concatSHA256(k, x))))\n     <=(P_SHA256_joint(time + (N2-1)*((2+N)*time(SHA256_comp) + 2*time(xor) + 2*time(padkey)), N2, N))=>\n       foreach i3 <= N2 do \n       \t       (O1() := r1 <-R t_SHA256_out; return(r1) |\n\t        O2() := r2 <-R t_SHA256_out; return(r2) |\n\t\tforeach i<= N do O3(x: mac_key) := \n\t\t\tfind[unique] j <= N suchthat defined(x[j],r3[j]) && x = x[j] then\n\t\t\t     return(r3[j])\n\t\t\telse\n\t\t\t     r3 <-R t_SHA256_out;\n\t\t\t     return(r3)).\n\nWe prove the result and obtain\nP_SHA256_joint(t, N2, N) = (2 N N2^2 + 2 N1 N2 + N1 N2 N + 4 N2^2) / |mac_key|\nwhere N1 is the number of SHA256_comp queries from the adversary.\n*)\n\n(* Do not assume by default that all constants are \n   different. We shall say it explicitly when they are different *)\n\nset diffConstants = false.\n\n(**** Declarations of types, constants, and functions\n      with the associated assumptions ****)\n\ntype mac_key [large, fixed]. (* 256 bits HMAC-SHA256 key *)\n\n(* Hash function SHA256 *)\n\ntype hashkey1 [fixed, large]. (* Models the choice of the compression function of SHA256 *)\ntype t_SHA256_out [fixed, large]. (* 256 bits bitstrings *)\ntype t_SHA256_block [large, fixed]. (* 512 bits SHA256 block *)\n\nconst SHA256_init: t_SHA256_out.\nfun concatSHA256(mac_key, mac_key): t_SHA256_block [compos].\n\n(* SHA256 compression function = Random oracle *)\nexpand ROM_hash_pair(hashkey1, t_SHA256_out, t_SHA256_block, t_SHA256_out, SHA256_comp).\n\n(* HMAC helper functions *)\n\nconst opad, ipad: t_SHA256_block.\n\nfun padkey(mac_key): t_SHA256_block [compos].\n\nexpand Xor(t_SHA256_block, xor, zero).\n\nforall; opad <> ipad.\nforall k: mac_key, x: mac_key; xor(padkey(k), opad) <> concatSHA256(k, x).\nforall k: mac_key, x: mac_key; xor(padkey(k), ipad) <> concatSHA256(k, x).\n\n(**** Initial game ****)\n\nparam N, N1, N2.\n\nprocess\n\tOstart() :=\n\thk1 <-R hashkey1;\n\treturn;\n\t(foreach i2 <= N2 do \n\t    Ogen() := k <-R mac_key; return;\n\t    ((O1() := return(SHA256_comp(hk1, SHA256_init, xor(padkey(k), opad)))) |\n             (O2() := return(SHA256_comp(hk1, SHA256_init, xor(padkey(k), ipad)))) |\n             foreach i <= N do \n                O3(x: mac_key) := return(SHA256_comp(hk1, SHA256_init, concatSHA256(k, x))))) |\n\t(* oracle for SHA256_comp *)\n        (foreach i1 <= N1 do \n            OH(x1: t_SHA256_out, x2: t_SHA256_block) :=\n\t\t return(SHA256_comp(hk1, x1, x2)))"
    },
    {
        "file": "CV-1/live-demo-3.ocv",
        "incomplete": "(* This file uses the builtin ind-cpa assumption to prove a variant of the ind-cpa assumption. *)\n(* CryptoVerif should succeed. *)\n\ntype key [fixed].  \n\ntype enc_seed [bounded].\n\nproba ____(PROBA_0)____.\n\nexpand IND_CPA_sym_enc_all_args(key,\nbitstring,\nbitstring,\nenc_seed,\nenc,\nenc_r,\nenc_r',\ndec,\ninjbot,\nZ,\nPenc).\n\nquery secret ____(QUERY_0)____.\n\nlet QencLR(b0: bool, k: key, r: enc_seed) = \n\tOenc (m1: bitstring, ____(OP_0)____: bitstring) :=\n\tif Z(m1) = Z(m2) then (* m1 and m2 have the same length *)\n\tif b0 then \n\t\treturn(enc_r(m1,k,____(OP_1)____))\n\telse\n\t\treturn(enc_r(m2,k,r)).\n\nprocess Ostart () :=\n        b <-R bool;\n\tk <-R key;\n\tr <-R enc_seed;\n\treturn;\n \trun QencLR(b, k, r)",
        "complete:": "(* This file uses the builtin ind-cpa assumption to prove a variant of the ind-cpa assumption. *)\n(* CryptoVerif should succeed. *)\n\ntype key [fixed].  \n\ntype enc_seed [bounded].\n\nproba Penc.\n\nexpand IND_CPA_sym_enc_all_args(key,\nbitstring,\nbitstring,\nenc_seed,\nenc,\nenc_r,\nenc_r',\ndec,\ninjbot,\nZ,\nPenc).\n\nquery secret b.\n\nlet QencLR(b0: bool, k: key, r: enc_seed) = \n\tOenc (m1: bitstring, m2: bitstring) :=\n\tif Z(m1) = Z(m2) then (* m1 and m2 have the same length *)\n\tif b0 then \n\t\treturn(enc_r(m1,k,r))\n\telse\n\t\treturn(enc_r(m2,k,r)).\n\nprocess Ostart () :=\n        b <-R bool;\n\tk <-R key;\n\tr <-R enc_seed;\n\treturn;\n \trun QencLR(b, k, r)"
    },
    {
        "file": "CV-1/mergeif.cv",
        "incomplete": "(* Public-key Kerberos 5, all three rounds, with PKINIT in public key mode (RFC 4556), consider key usability of AK after client completes session, client and TGS are restricted not to take outputs by the encryption oracle, authentication will partly fail as expected  *)\n\nproof {\nmerge_branches;\nsuccess\n}\n\nparam ____(PARAM_1)____.\nparam N2.\nparam N3.\nparam N4.\nparam N5.\nparam qE.\nparam ____(PARAM_0)____.\n\ntype nonce [fixed,large].\ntype client [____(TYPE_4)____].\ntype kas [bounded].\ntype tgs [bounded].\ntype server [bounded].\n\n(* types for public-key cryptography *)\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype spkey [____(TYPE_0)____].\ntype sskey [bounded].\ntype skeyseed [large,fixed].\ntype sseed [fixed].  \ntype signature [____(TYPE_2)____].\ntype blocksize [fixed].\ntype blocksizebot [bounded].\ntype sblocksize [bounded].\n\n(* types for symmetric encryption *)\n\ntype symkeyseed [____(TYPE_5)____].\ntype key [fixed].\ntype protkey [fixed].\ntype ____(TYPE_1)____ [fixed].\ntype macs [fixed].\ntype mkeyseed [fixed].\ntype mkey [fixed].\ntype symseed [fixed].\ntype maxmac [bounded].\ntype ____(TYPE_3)____ [bounded].\ntype timest [fixed].\n\n(* message construction functions *)\n\nfun concat1(client, pkey, spkey):sblocksize [compos].\t\t\t\t\nfun concat3(protkey, macs):sblocksize [compos]. \t     \t       \t  \t\nfun concat7(kas, pkey, spkey):sblocksize [compos].    \t\t\t\t\nfun padno(timest,nonce):sblocksize [compos]. \t    \t   \t      \t      \t\nfun concat2(kas, pkey, spkey, ____(FUN_4)____, protkey, ____(FUN_5)____, signature):____(FUN_3)____ [compos]. \t\nfun concat4(key, ____(FUN_1)____, timest, tgs):maxenc [____(FUN_0)____]. \t\t\t\t\nfun concat5(key, timest, client):maxenc [compos]. \t\t\t\t\nfun concat8(key, nonce, ____(FUN_7)____, server):____(FUN_6)____ [compos]. \t\t       \t\nfun pad(____(OP_16)____, timest):maxenc [compos].\t\t\t\t\t\nfun padts(timest):maxenc [compos].\t\t\t\t\t\t\nfun concat6(client, pkey, spkey, signature, timest, nonce, signature, client, tgs, nonce):maxmac [compos].   \n\nforall y:key, x:timest, z:client, ____(OP_8)____:key, y2:nonce, x2:timest, z2:tgs;        \t  concat5(y,x,z) <> concat4(t2,y2,x2,z2).\nforall t:key, y: nonce, x:timest, z:server, t2:key, y2:nonce, x2:timest, z2:tgs;  concat8(t,y,x,z) <> concat4(t2,y2,x2,z2).\nforall z:client, t:timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t \t  pad(z,t) <> concat4(t2,y2,x2,z2).\nforall t: timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t\t\t  padts(t) <> concat4(t2,y2,x2,z2).\nforall y:key, x:timest, z:client, t2: key, y2:nonce, x2:timest, z2:server;   \t  concat5(y,x,z) <> concat8(t2,y2,x2,z2).\nforall y:key, x:timest, z:client, t2: timest, z2:client;    \t\t\t  concat5(y,x,z) <> pad(____(OP_3)____,t2). \nforall y:key, x:timest, z:client, t2: timest;    \t\t\t\t  concat5(y,x,z) <> padts(t2). \nforall t:key, y:nonce, x:timest, z:server, t2:timest, z2:client;  \t\t  concat8(t,y,x,z) <> pad(z2,t2).\nforall t:key, y:nonce, x:timest, z:server, t2:timest;  \t\t\t\t  concat8(t,y,x,z) <> padts(t2).\nforall t: timest, z: client, t2: timest;   \t\t\t\t\t  pad(z,t)<> padts(t2).\n\nforall k1:protkey, y:macs, z2:client, y2:pkey, x2:spkey; \t\t  \t  concat3(k1,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2: nonce, t2:timest; \t\t\t  \t  concat3(k1,y) <> padno(t2,z2).\nforall t:timest, y:nonce, z2:client, y2:pkey, x2:spkey;\t\t\t\t  padno(t,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2:kas, y2:pkey, x2:spkey;\t\t  \t\t  concat3(k1,y) <> concat7(z2,y2,x2).\nforall t:timest, y:nonce, z2:kas, y2:pkey, x2:spkey; \t     \t\t\t  padno(t,y) <> concat7(z2,y2,x2).\nforall z2:client, y2:pkey, x2:spkey, z:kas, y:pkey, x:spkey;\t\t  \t  concat1(z2,y2,x2) <> concat7(z,y,x).\n\n\n(* Public-key encryption (IND-CCA2): *)\n\nproba Ppenc.\nproba Ppenccoll.\n\nexpand IND_CCA2_public_key_enc(keyseed, pkey, skey, blocksize, bitstring, seed, skgen, pkgen, penc, pdec, injbot1, Z, Ppenc, Ppenccoll).\n\n(* Signatures (UF-CMA): *)\n\nproba ____(PROBA_1)____.\nproba Psigncoll.\n\nexpand UF_CMA_signature(skeyseed, spkey, sskey, sblocksize, signature, sseed, sskgen, spkgen, sign, check, Psign, Psigncoll).\n\n(* Shared-key encryption (IND-CPA and INT-CTXT Stream cipher): *)\n\nproba Penc.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTXT_sym_enc(symkeyseed, key, maxenc, maxmac, symseed, kgen, enc, dec, injbot2, Z2, Penc, Pencctxt).\n\n(* The function Z2 returns for each bitstring, a bitstring of the same length, consisting only of zeroes. *)\nconst Zconcat4:maxenc.\nconst Zconcat5:maxenc.\nconst Zconcat8:maxenc.\nconst     Zpad:maxenc.\nconst   Zpadts:maxenc. \nforall m:key, y:nonce, x:timest, z:tgs; \n    Z2(concat4(m,y,x,z)) = Zconcat4.\nforall y:key, x:timest, z:client; \n    Z2(concat5(y,x,z)) = Zconcat5.\nforall t:key, y:nonce, x:timest, z:server;\n    Z2(concat8(t, y, x, z)) = Zconcat8.\nforall z:client, t:timest;\n        Z2(pad(z,t)) = Zpad.\nforall t: timest;\n        Z2(padts(t)) = Zpadts.\n\n(* Collision-resistance for hmac: *)\n(* HMAC:\n\nHMAC(m,k) = H(k xor opad ++ H((k xor ipad) ++ m))\nwhere ++ is concatenation.\n\nConsider collision resistance for H:\nLet k' be a key corresponding to the choice of H (chosen once\nat the beginning of the protocol and published). We add k' as \nargument to H, so also to HMAC...\n\nHMAC(m,k,k') = H(k xor opad ++ H((k xor ipad) ++ m, k'), k')\n\nCollision resistance for H means:\nH(m1,k') = H(m2,k') <==> m1 = m2 up to negligible probability.\n\nHence\nHMAC(m1,k,k') = HMAC(m2,k,k') ==> \nk xor opad ++ H((k xor ipad) ++ m1, k') = k xor opad ++ H((k xor ipad) ++ m2, k') ==>\nH((k xor ipad) ++ m1, k') = H((k xor ipad) ++ m2, k') ==>\n(k xor ipad) ++ m1 = (k xor ipad) ++ m2 ==>\nm1 = m2\n\n(k, ipad, opad have the same, known length, so the concatenation uniquely\ndetermines its elements)\n\nIf needed, we could even have the stronger property:\nHMAC(m1,k1,k') = HMAC(m2,k2,k') ==> m1 = m2 && k1 = k2\n\nHere, we give the definition of HMAC and assume the collision resistance\nof the underlying hash function. CryptoVerif proves the collision\nresistance for HMAC.\n*)\n\nproba ____(PROBA_0)____.\ntype collisionkey [fixed].\nexpand CollisionResistant_hash(collisionkey, bitstring, macs, h, Phash).\n\nfun mkgen(symkeyseed):key.\nfun concath1(key,macs):bitstring [compos].\nfun concath2(key, maxmac):bitstring [compos].\nfun xor(____(OP_5)____,key):key.\nconst opad:key.\nconst ipad:key.\n\nfun hmac(maxmac, key, collisionkey):macs.\n\nforall m:maxmac, k:key, collkey:collisionkey; hmac(m,k,collkey) = h(collkey, concath1(xor(k, ____(OP_9)____), h(collkey, concath2(xor(k, ipad), m)))).\n\n(* Pseudorandom function (PRF) for key derivation\n   The definition included in the CryptoVerif library uses a key generation function for the PRF.\n   Here, we don't, so we adapt that definition instead of reusing the macro directly *)\n\nproba pPRF.\n\nfun keyderivation(protkey, usenum):symkeyseed.\n\nequiv !N2 new z:protkey;\n         (x:usenum) N -> keyderivation(____(OP_13)____,x)\n      <=(N2 * pPRF(time, ____(OP_18)____))=>\n      !N2 (x:usenum) N -> find u <= N suchthat defined(x[u],s[u]) && x = x[u]\n                 then s[u]\n                 else new s:symkeyseed; s.\n\n(* Key Usage Numbers for key derivation *)\nconst un1: usenum.\nconst un2: usenum.\n\n\n(* Channel declarations *)\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33,\n\t start, finish, cC, cK.\n\n(* Host names for honest hosts *)\n\nconst C :client.\nconst K :kas.\nconst T :tgs.\nconst S :server.\n\n(* Final accept messages *)\n\nfun acceptC1(kas, ____(FUN_2)____):bitstring.\nfun acceptC2(tgs, server):bitstring.\nfun acceptC3(server):bitstring.\nfun acceptK(client):bitstring.\nfun acceptT(client, server):bitstring.\nfun acceptS(client): bitstring.\n\n(* Authentication Queries *)\n\nevent fullKC(client, tgs, nonce, bitstring, ____(OP_2)____, maxmac).\nevent fullCK(kas, tgs, nonce, bitstring, ____(EVENT_0)____, ____(OP_1)____).       \nevent partCT(tgs, maxmac, maxmac).          \nevent fullCT(kas, tgs, server, nonce, maxmac, maxmac, maxmac).  \nevent partTC(____(OP_7)____, ____(EVENT_2)____, maxmac).           \nevent fullTC(____(OP_11)____, server, nonce, ____(OP_12)____, maxmac, maxmac, maxmac).\n\nevent partCS(server, tgs, maxmac, maxmac).\nevent fullCS(server, tgs, kas, maxmac, maxmac, maxmac).\nevent partSC(____(OP_10)____, maxmac, maxmac).\nevent fullSC(____(EVENT_1)____, maxmac, maxmac, maxmac).           \n      \t\t\n\n(* Theorem 9, client completes sesssion\n   Secrecy of the coin b1 *)\nquery secret1 ____(QUERY_0)____.\n\n(* Encryption Oracle *)\n\nlet processOE =\n\tin(c27,(____(OP_4)____:maxenc, m2:maxenc));\n\tif Z2(m1) = Z2(m2) then\n\tif b1 then\n\t  (\n          new r1: symseed;\n          let z1 = enc(Z2(m1),k1,____(OP_17)____) in\n    \t  out(c22, z1)\n          )\n        else\n          (\n          new r2: symseed;\n          let z2 = enc(Z2(____(OP_0)____),k1,r2) in\n    \t  out(c22, ____(OP_14)____)\n\t  ).\n\n\n(* Main process, which generates long-term keys and runs the various processes *)\n\nprocess \n\tin(start, ());\n\t  new b1:bool;\t\t\t\t\t(* let b1 in {0,1} *)\n\t  new s:symkeyseed;\n\t  let k1 = kgen(s) in\n     \t  out(c25, ());\t\t\t\t\t\t\n      \t  ( ! qE processOE )\n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18240K\nEND *)",
        "complete:": "(* Public-key Kerberos 5, all three rounds, with PKINIT in public key mode (RFC 4556), consider key usability of AK after client completes session, client and TGS are restricted not to take outputs by the encryption oracle, authentication will partly fail as expected  *)\n\nproof {\nmerge_branches;\nsuccess\n}\n\nparam N.\nparam N2.\nparam N3.\nparam N4.\nparam N5.\nparam qE.\nparam qD.\n\ntype nonce [fixed,large].\ntype client [bounded].\ntype kas [bounded].\ntype tgs [bounded].\ntype server [bounded].\n\n(* types for public-key cryptography *)\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype spkey [bounded].\ntype sskey [bounded].\ntype skeyseed [large,fixed].\ntype sseed [fixed].  \ntype signature [bounded].\ntype blocksize [fixed].\ntype blocksizebot [bounded].\ntype sblocksize [bounded].\n\n(* types for symmetric encryption *)\n\ntype symkeyseed [fixed].\ntype key [fixed].\ntype protkey [fixed].\ntype usenum [fixed].\ntype macs [fixed].\ntype mkeyseed [fixed].\ntype mkey [fixed].\ntype symseed [fixed].\ntype maxmac [bounded].\ntype maxenc [bounded].\ntype timest [fixed].\n\n(* message construction functions *)\n\nfun concat1(client, pkey, spkey):sblocksize [compos].\t\t\t\t\nfun concat3(protkey, macs):sblocksize [compos]. \t     \t       \t  \t\nfun concat7(kas, pkey, spkey):sblocksize [compos].    \t\t\t\t\nfun padno(timest,nonce):sblocksize [compos]. \t    \t   \t      \t      \t\nfun concat2(kas, pkey, spkey, signature, protkey, macs, signature):blocksize [compos]. \t\nfun concat4(key, nonce, timest, tgs):maxenc [compos]. \t\t\t\t\nfun concat5(key, timest, client):maxenc [compos]. \t\t\t\t\nfun concat8(key, nonce, timest, server):maxenc [compos]. \t\t       \t\nfun pad(client, timest):maxenc [compos].\t\t\t\t\t\nfun padts(timest):maxenc [compos].\t\t\t\t\t\t\nfun concat6(client, pkey, spkey, signature, timest, nonce, signature, client, tgs, nonce):maxmac [compos].   \n\nforall y:key, x:timest, z:client, t2:key, y2:nonce, x2:timest, z2:tgs;        \t  concat5(y,x,z) <> concat4(t2,y2,x2,z2).\nforall t:key, y: nonce, x:timest, z:server, t2:key, y2:nonce, x2:timest, z2:tgs;  concat8(t,y,x,z) <> concat4(t2,y2,x2,z2).\nforall z:client, t:timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t \t  pad(z,t) <> concat4(t2,y2,x2,z2).\nforall t: timest, t2:key, y2:nonce, x2:timest, z2:tgs;  \t\t\t  padts(t) <> concat4(t2,y2,x2,z2).\nforall y:key, x:timest, z:client, t2: key, y2:nonce, x2:timest, z2:server;   \t  concat5(y,x,z) <> concat8(t2,y2,x2,z2).\nforall y:key, x:timest, z:client, t2: timest, z2:client;    \t\t\t  concat5(y,x,z) <> pad(z2,t2). \nforall y:key, x:timest, z:client, t2: timest;    \t\t\t\t  concat5(y,x,z) <> padts(t2). \nforall t:key, y:nonce, x:timest, z:server, t2:timest, z2:client;  \t\t  concat8(t,y,x,z) <> pad(z2,t2).\nforall t:key, y:nonce, x:timest, z:server, t2:timest;  \t\t\t\t  concat8(t,y,x,z) <> padts(t2).\nforall t: timest, z: client, t2: timest;   \t\t\t\t\t  pad(z,t)<> padts(t2).\n\nforall k1:protkey, y:macs, z2:client, y2:pkey, x2:spkey; \t\t  \t  concat3(k1,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2: nonce, t2:timest; \t\t\t  \t  concat3(k1,y) <> padno(t2,z2).\nforall t:timest, y:nonce, z2:client, y2:pkey, x2:spkey;\t\t\t\t  padno(t,y) <> concat1(z2,y2,x2).\nforall k1:protkey, y:macs, z2:kas, y2:pkey, x2:spkey;\t\t  \t\t  concat3(k1,y) <> concat7(z2,y2,x2).\nforall t:timest, y:nonce, z2:kas, y2:pkey, x2:spkey; \t     \t\t\t  padno(t,y) <> concat7(z2,y2,x2).\nforall z2:client, y2:pkey, x2:spkey, z:kas, y:pkey, x:spkey;\t\t  \t  concat1(z2,y2,x2) <> concat7(z,y,x).\n\n\n(* Public-key encryption (IND-CCA2): *)\n\nproba Ppenc.\nproba Ppenccoll.\n\nexpand IND_CCA2_public_key_enc(keyseed, pkey, skey, blocksize, bitstring, seed, skgen, pkgen, penc, pdec, injbot1, Z, Ppenc, Ppenccoll).\n\n(* Signatures (UF-CMA): *)\n\nproba Psign.\nproba Psigncoll.\n\nexpand UF_CMA_signature(skeyseed, spkey, sskey, sblocksize, signature, sseed, sskgen, spkgen, sign, check, Psign, Psigncoll).\n\n(* Shared-key encryption (IND-CPA and INT-CTXT Stream cipher): *)\n\nproba Penc.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTXT_sym_enc(symkeyseed, key, maxenc, maxmac, symseed, kgen, enc, dec, injbot2, Z2, Penc, Pencctxt).\n\n(* The function Z2 returns for each bitstring, a bitstring of the same length, consisting only of zeroes. *)\nconst Zconcat4:maxenc.\nconst Zconcat5:maxenc.\nconst Zconcat8:maxenc.\nconst     Zpad:maxenc.\nconst   Zpadts:maxenc. \nforall m:key, y:nonce, x:timest, z:tgs; \n    Z2(concat4(m,y,x,z)) = Zconcat4.\nforall y:key, x:timest, z:client; \n    Z2(concat5(y,x,z)) = Zconcat5.\nforall t:key, y:nonce, x:timest, z:server;\n    Z2(concat8(t, y, x, z)) = Zconcat8.\nforall z:client, t:timest;\n        Z2(pad(z,t)) = Zpad.\nforall t: timest;\n        Z2(padts(t)) = Zpadts.\n\n(* Collision-resistance for hmac: *)\n(* HMAC:\n\nHMAC(m,k) = H(k xor opad ++ H((k xor ipad) ++ m))\nwhere ++ is concatenation.\n\nConsider collision resistance for H:\nLet k' be a key corresponding to the choice of H (chosen once\nat the beginning of the protocol and published). We add k' as \nargument to H, so also to HMAC...\n\nHMAC(m,k,k') = H(k xor opad ++ H((k xor ipad) ++ m, k'), k')\n\nCollision resistance for H means:\nH(m1,k') = H(m2,k') <==> m1 = m2 up to negligible probability.\n\nHence\nHMAC(m1,k,k') = HMAC(m2,k,k') ==> \nk xor opad ++ H((k xor ipad) ++ m1, k') = k xor opad ++ H((k xor ipad) ++ m2, k') ==>\nH((k xor ipad) ++ m1, k') = H((k xor ipad) ++ m2, k') ==>\n(k xor ipad) ++ m1 = (k xor ipad) ++ m2 ==>\nm1 = m2\n\n(k, ipad, opad have the same, known length, so the concatenation uniquely\ndetermines its elements)\n\nIf needed, we could even have the stronger property:\nHMAC(m1,k1,k') = HMAC(m2,k2,k') ==> m1 = m2 && k1 = k2\n\nHere, we give the definition of HMAC and assume the collision resistance\nof the underlying hash function. CryptoVerif proves the collision\nresistance for HMAC.\n*)\n\nproba Phash.\ntype collisionkey [fixed].\nexpand CollisionResistant_hash(collisionkey, bitstring, macs, h, Phash).\n\nfun mkgen(symkeyseed):key.\nfun concath1(key,macs):bitstring [compos].\nfun concath2(key, maxmac):bitstring [compos].\nfun xor(key,key):key.\nconst opad:key.\nconst ipad:key.\n\nfun hmac(maxmac, key, collisionkey):macs.\n\nforall m:maxmac, k:key, collkey:collisionkey; hmac(m,k,collkey) = h(collkey, concath1(xor(k, opad), h(collkey, concath2(xor(k, ipad), m)))).\n\n(* Pseudorandom function (PRF) for key derivation\n   The definition included in the CryptoVerif library uses a key generation function for the PRF.\n   Here, we don't, so we adapt that definition instead of reusing the macro directly *)\n\nproba pPRF.\n\nfun keyderivation(protkey, usenum):symkeyseed.\n\nequiv !N2 new z:protkey;\n         (x:usenum) N -> keyderivation(z,x)\n      <=(N2 * pPRF(time, N))=>\n      !N2 (x:usenum) N -> find u <= N suchthat defined(x[u],s[u]) && x = x[u]\n                 then s[u]\n                 else new s:symkeyseed; s.\n\n(* Key Usage Numbers for key derivation *)\nconst un1: usenum.\nconst un2: usenum.\n\n\n(* Channel declarations *)\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33,\n\t start, finish, cC, cK.\n\n(* Host names for honest hosts *)\n\nconst C :client.\nconst K :kas.\nconst T :tgs.\nconst S :server.\n\n(* Final accept messages *)\n\nfun acceptC1(kas, tgs):bitstring.\nfun acceptC2(tgs, server):bitstring.\nfun acceptC3(server):bitstring.\nfun acceptK(client):bitstring.\nfun acceptT(client, server):bitstring.\nfun acceptS(client): bitstring.\n\n(* Authentication Queries *)\n\nevent fullKC(client, tgs, nonce, bitstring, maxmac, maxmac).\nevent fullCK(kas, tgs, nonce, bitstring, maxmac, maxmac).       \nevent partCT(tgs, maxmac, maxmac).          \nevent fullCT(kas, tgs, server, nonce, maxmac, maxmac, maxmac).  \nevent partTC(client, maxmac, maxmac).           \nevent fullTC(client, server, nonce, maxmac, maxmac, maxmac, maxmac).\n\nevent partCS(server, tgs, maxmac, maxmac).\nevent fullCS(server, tgs, kas, maxmac, maxmac, maxmac).\nevent partSC(client, maxmac, maxmac).\nevent fullSC(client, maxmac, maxmac, maxmac).           \n      \t\t\n\n(* Theorem 9, client completes sesssion\n   Secrecy of the coin b1 *)\nquery secret1 b1.\n\n(* Encryption Oracle *)\n\nlet processOE =\n\tin(c27,(m1:maxenc, m2:maxenc));\n\tif Z2(m1) = Z2(m2) then\n\tif b1 then\n\t  (\n          new r1: symseed;\n          let z1 = enc(Z2(m1),k1,r1) in\n    \t  out(c22, z1)\n          )\n        else\n          (\n          new r2: symseed;\n          let z2 = enc(Z2(m2),k1,r2) in\n    \t  out(c22, z2)\n\t  ).\n\n\n(* Main process, which generates long-term keys and runs the various processes *)\n\nprocess \n\tin(start, ());\n\t  new b1:bool;\t\t\t\t\t(* let b1 in {0,1} *)\n\t  new s:symkeyseed;\n\t  let k1 = kgen(s) in\n     \t  out(c25, ());\t\t\t\t\t\t\n      \t  ( ! qE processOE )\n\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 18240K\nEND *)"
    },
    {
        "file": "CV-1/Misha-injectivity_and_equality.cv",
        "incomplete": "proof {\n      show_game occ;\n      replace 18 ____(OP_9)____;\n      auto\n}\n\nchannel ____(CHANNEL_0)____.\n\ntype ____(OP_8)____ [fixed].\n\nfun f(____(FUN_0)____): bitstring [compos].\nforall ____(OP_10)____: nonce, ____(OP_1)____: nonce;\n  (f(x) = f(____(OP_2)____)) = (x = ____(OP_7)____).\n\nfun g(nonce): nonce.\n\nevent start(____(EVENT_0)____).\nevent finish(nonce).\n\nquery x: nonce;\n  event finish(x) ==> start(x).\n\nprocess\n  in(____(OP_3)____, ());\n  new x: nonce;\n\n  event start(x);\n  \n  out(c, x);\n  in(____(OP_0)____, x':nonce);\n  \n  if f(x) = f(g(____(OP_5)____)) then\n  \n  event finish(g(x'));\n  yield\n\n(*\n     in(c, ());\n     new x: nonce;\n     event start(x);\n     out(c, x);\n     in(c, x': nonce);\n     if (x = g(x')) then\n     event finish(g(x'))\n\nIn order to prove the correspondence finish(y) ==> start(y),\nit sees that when finish(y) is executed, we have\ny = g(x'), x = g(x') and start(x). In order to prove start(y)\nknowing start(x), it assumes x <> y and tries to prove a contradiction\nfrom: y = g(x'), x = g(x'), x <> y.\nThen the problem appears: substituting x with y their values,\nit should obviously obtain g(x') <> g(x') which yields a contradiction.\nHowever, while it correctly orients the equality y = g(x') into\ny -> g(x'), it fails to orient x = g(x') because of a heuristic that\nprevents creating x -> ... when x is created by a \"new\".\nSo x is not replaced with g(x') and the proof fails.\nThe obvious solution would be to disable this heuristic; however,\nthis heuristic is very useful in many other examples...\n*)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 17024K\nEND *)",
        "complete:": "proof {\n      show_game occ;\n      replace 18 x;\n      auto\n}\n\nchannel c.\n\ntype nonce [fixed].\n\nfun f(nonce): bitstring [compos].\nforall x: nonce, x': nonce;\n  (f(x) = f(x')) = (x = x').\n\nfun g(nonce): nonce.\n\nevent start(nonce).\nevent finish(nonce).\n\nquery x: nonce;\n  event finish(x) ==> start(x).\n\nprocess\n  in(c, ());\n  new x: nonce;\n\n  event start(x);\n  \n  out(c, x);\n  in(c, x':nonce);\n  \n  if f(x) = f(g(x')) then\n  \n  event finish(g(x'));\n  yield\n\n(*\n     in(c, ());\n     new x: nonce;\n     event start(x);\n     out(c, x);\n     in(c, x': nonce);\n     if (x = g(x')) then\n     event finish(g(x'))\n\nIn order to prove the correspondence finish(y) ==> start(y),\nit sees that when finish(y) is executed, we have\ny = g(x'), x = g(x') and start(x). In order to prove start(y)\nknowing start(x), it assumes x <> y and tries to prove a contradiction\nfrom: y = g(x'), x = g(x'), x <> y.\nThen the problem appears: substituting x with y their values,\nit should obviously obtain g(x') <> g(x') which yields a contradiction.\nHowever, while it correctly orients the equality y = g(x') into\ny -> g(x'), it fails to orient x = g(x') because of a heuristic that\nprevents creating x -> ... when x is created by a \"new\".\nSo x is not replaced with g(x') and the proof fails.\nThe obvious solution would be to disable this heuristic; however,\nthis heuristic is very useful in many other examples...\n*)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 17024K\nEND *)"
    },
    {
        "file": "CV-1/Misha-pk-shared-no-cast.cv",
        "incomplete": "channel ____(CHANNEL_0)____, c_out.\ntype mstring.\n\nparam ____(PARAM_0)____.\n\ntype nonce [fixed, large].\n\n(************************\n  Public-key encryption\n*************************)\n\n(* IND-CCA2 probabilistic public-key encryption \n   keyseed: type of key seeds, must be \"fixed\" (to be able to generate random numbers from it), typically large.\n   pkey: type of public keys, must be \"bounded\"\n   skey: type of secret keys, must be \"bounded\"\n   cleartext: type of cleartexts, must be \"bounded\" or \"fixed\" (the encryptions of *all* cleartexts of any length\n              are assumed to be indistinguishable from each other).\n   ciphertext: type of ciphertexts\n   seed: type of random seeds for encryption, must be \"fixed\"\n\n   dk: public-key generation function \n   sk: secret-key generation function\n   E: encryption function\n   D: decryption function\n   injbot: natural injection from cleartext to bitstringbot\n   Z: a constant cleartext\n\n   Penc(t, N): probability of breaking the IND-CCA2 property\n   in time t for one key and N decryption queries.\n   Penccoll: probability of collision between independently generated keys\n*)\n\ntype keyseed_T [fixed, large].\ntype pkey [bounded].\ntype cleartext [____(TYPE_0)____].\ntype seed_T [fixed].\n\nproba ____(PROBA_0)____.\nproba Penccoll.\n\nexpand IND_CCA2_public_key_enc(keyseed_T, pkey, pkey, cleartext, mstring, seed_T, dk, ek, E, D, injbot, Z, Penc, Penccoll).\n\n(*************************** \n  Concatenation and Parsing \n***************************)\n\nfun pad(____(FUN_0)____): cleartext [compos].\n\n(******************** \n  Query\n********************)\n \nevent beginA().\nevent endB().\n\nquery;\n  event endB() ==> beginA().\n\n(******************** \n  Process\n********************)\n\nlet pA = \n  in(____(OP_2)____, ());\n  \n  event beginA();\n\n  new nonce3: seed_T;\n  let msg1 = E(pad(sN), pkB, nonce3) in\n  out(c_out, msg1); 0 .\n\nlet pB = \n  in(c_in, msg1: mstring);\n  let injbot(msg1_c) = D(____(OP_1)____, skB) in\n  \n  (* This doesn't work: *)\n  (* if pad(sN) = msg1_c then *)\n  \n  (* This does: *)\n  let pad(=sN) = msg1_c in\n\n  event endB();\n  yield .\n\nprocess\n(\n  in(c_in, ());\n  new B_seed: keyseed_T;\n  let pkB = ek(B_seed) in\n  let skB = dk(B_seed) in\n  \n  new sN: nonce;\n  \n  out(c_out, (pkB));\n  ((! N pA) | (! N pB))\n)\n\n(* EXPECTED\nAll queries proved.\n0.024s (user 0.016s + system 0.008s), max rss 41456K\nEND *)",
        "complete:": "channel c_in, c_out.\ntype mstring.\n\nparam N.\n\ntype nonce [fixed, large].\n\n(************************\n  Public-key encryption\n*************************)\n\n(* IND-CCA2 probabilistic public-key encryption \n   keyseed: type of key seeds, must be \"fixed\" (to be able to generate random numbers from it), typically large.\n   pkey: type of public keys, must be \"bounded\"\n   skey: type of secret keys, must be \"bounded\"\n   cleartext: type of cleartexts, must be \"bounded\" or \"fixed\" (the encryptions of *all* cleartexts of any length\n              are assumed to be indistinguishable from each other).\n   ciphertext: type of ciphertexts\n   seed: type of random seeds for encryption, must be \"fixed\"\n\n   dk: public-key generation function \n   sk: secret-key generation function\n   E: encryption function\n   D: decryption function\n   injbot: natural injection from cleartext to bitstringbot\n   Z: a constant cleartext\n\n   Penc(t, N): probability of breaking the IND-CCA2 property\n   in time t for one key and N decryption queries.\n   Penccoll: probability of collision between independently generated keys\n*)\n\ntype keyseed_T [fixed, large].\ntype pkey [bounded].\ntype cleartext [bounded].\ntype seed_T [fixed].\n\nproba Penc.\nproba Penccoll.\n\nexpand IND_CCA2_public_key_enc(keyseed_T, pkey, pkey, cleartext, mstring, seed_T, dk, ek, E, D, injbot, Z, Penc, Penccoll).\n\n(*************************** \n  Concatenation and Parsing \n***************************)\n\nfun pad(nonce): cleartext [compos].\n\n(******************** \n  Query\n********************)\n \nevent beginA().\nevent endB().\n\nquery;\n  event endB() ==> beginA().\n\n(******************** \n  Process\n********************)\n\nlet pA = \n  in(c_in, ());\n  \n  event beginA();\n\n  new nonce3: seed_T;\n  let msg1 = E(pad(sN), pkB, nonce3) in\n  out(c_out, msg1); 0 .\n\nlet pB = \n  in(c_in, msg1: mstring);\n  let injbot(msg1_c) = D(msg1, skB) in\n  \n  (* This doesn't work: *)\n  (* if pad(sN) = msg1_c then *)\n  \n  (* This does: *)\n  let pad(=sN) = msg1_c in\n\n  event endB();\n  yield .\n\nprocess\n(\n  in(c_in, ());\n  new B_seed: keyseed_T;\n  let pkB = ek(B_seed) in\n  let skB = dk(B_seed) in\n  \n  new sN: nonce;\n  \n  out(c_out, (pkB));\n  ((! N pA) | (! N pB))\n)\n\n(* EXPECTED\nAll queries proved.\n0.024s (user 0.016s + system 0.008s), max rss 41456K\nEND *)"
    },
    {
        "file": "CV-1/Misha-RPC-enc-fixed.cv",
        "incomplete": "param ____(PARAM_0)____.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\ntype payload [fixed].\nfun payload2bs(payload) : ____(OP_8)____ [compos].\n\n(* IND-CPA INT-CTXT encryption *)\n\ntype keyseed [____(TYPE_0)____, large].\ntype key [bounded].\ntype seed [fixed, large].\n\nproba ____(PROBA_0)____.\nproba Pencptxt.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTXT_sym_enc(keyseed, key, ____(OP_4)____, bitstring, seed, kgen, enc, dec, injbot, Z, Penc, Pencctxt). \n\nfun key2bs(key): bitstring [compos].\nfun bs2key(____(FUN_0)____): key.\nforall k: key;\n  bs2key(key2bs(k)) = k.\n\n(* Concatenation and parsing *)\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): bitstring.\nfun parse2(bitstring): bitstring.\n\nforall ____(OP_1)____:bitstring, y:bitstring;\n  parse1(concat1(x, ____(OP_9)____)) = x.\n\nforall x:bitstring, y:bitstring;\n  parse2(concat1(____(OP_10)____, y)) = y.\n\n(* Assumes concat1 is really just the concatenation.\n   If concat1 adds a non-zero tag, the equation below is wrong,\n   but can be adapted. *)\nforall x:bitstring, y:bitstring;\n       Z(concat1(x, y)) = concat1(Z(x), Z(y)).\n\n(* All keys have the same length *)\nconst Zkey: bitstring.\nforall y:key;\n       Z(key2bs(____(OP_5)____)) = Zkey.\n\n(* Events and queries *)\n\nevent client_begin(bitstring).\nevent client_accept(bitstring, bitstring).\nevent server_reply(bitstring, bitstring).\n\nquery x: bitstring, y:bitstring;\n  event client_accept(x, y) ==> server_reply(x, y).\n\nquery x: bitstring, y:bitstring;\n  event server_reply(____(EVENT_0)____, y) ==> client_begin(x).\n\n(*\nquery x: bitstring, y:bitstring;\n  event client_accept(x, y).\n*)\n\n(* The process *)\n\nlet A = \n  in(start, ());\n  new request_: payload;\n  let request = payload2bs(request_) in\n  event client_begin(request);\n  new kS_seed: keyseed;\n  let kS = kgen(kS_seed) in\n  new r: seed;\n  let var1 = enc(concat1(request, key2bs(kS)), kAB, r) in\n  out(c1, var1);\n  in(c2, var2: bitstring);\n  let injbot(response) = dec(var2, kS) in\n  event client_accept(request, ____(OP_3)____); \n  yield.\n\nlet B = \n  in(____(OP_0)____, var12: bitstring);\n  new ____(OP_6)____: payload;\n  let response = payload2bs(response_) in\n  let injbot(msg) = dec(var12, kAB) in\n  let request = parse1(msg) in\n  event server_reply(____(OP_7)____, response);\n  let key2bs(kS) = parse2(msg) in\n  new r: seed;  \n  let var13 = enc(response, kS, r) in\n  out(c4, var13).\n\nprocess\n  in(start, ());\n  new ____(OP_2)____: keyseed;\n  let kAB = kgen(kAB_seed) in\n  out(finish, ());\n  ((! N A) | (! N B))\n\n\n(* EXPECTED\nAll queries proved.\n0.048s (user 0.044s + system 0.004s), max rss 36016K\nEND *)",
        "complete:": "param N.\n\nchannel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n  start, finish.\n\ntype payload [fixed].\nfun payload2bs(payload) : bitstring [compos].\n\n(* IND-CPA INT-CTXT encryption *)\n\ntype keyseed [fixed, large].\ntype key [bounded].\ntype seed [fixed, large].\n\nproba Penc.\nproba Pencptxt.\nproba Pencctxt.\n\nexpand IND_CPA_INT_CTXT_sym_enc(keyseed, key, bitstring, bitstring, seed, kgen, enc, dec, injbot, Z, Penc, Pencctxt). \n\nfun key2bs(key): bitstring [compos].\nfun bs2key(bitstring): key.\nforall k: key;\n  bs2key(key2bs(k)) = k.\n\n(* Concatenation and parsing *)\n\nfun concat1(bitstring, bitstring): bitstring [compos].\nfun parse1(bitstring): bitstring.\nfun parse2(bitstring): bitstring.\n\nforall x:bitstring, y:bitstring;\n  parse1(concat1(x, y)) = x.\n\nforall x:bitstring, y:bitstring;\n  parse2(concat1(x, y)) = y.\n\n(* Assumes concat1 is really just the concatenation.\n   If concat1 adds a non-zero tag, the equation below is wrong,\n   but can be adapted. *)\nforall x:bitstring, y:bitstring;\n       Z(concat1(x, y)) = concat1(Z(x), Z(y)).\n\n(* All keys have the same length *)\nconst Zkey: bitstring.\nforall y:key;\n       Z(key2bs(y)) = Zkey.\n\n(* Events and queries *)\n\nevent client_begin(bitstring).\nevent client_accept(bitstring, bitstring).\nevent server_reply(bitstring, bitstring).\n\nquery x: bitstring, y:bitstring;\n  event client_accept(x, y) ==> server_reply(x, y).\n\nquery x: bitstring, y:bitstring;\n  event server_reply(x, y) ==> client_begin(x).\n\n(*\nquery x: bitstring, y:bitstring;\n  event client_accept(x, y).\n*)\n\n(* The process *)\n\nlet A = \n  in(start, ());\n  new request_: payload;\n  let request = payload2bs(request_) in\n  event client_begin(request);\n  new kS_seed: keyseed;\n  let kS = kgen(kS_seed) in\n  new r: seed;\n  let var1 = enc(concat1(request, key2bs(kS)), kAB, r) in\n  out(c1, var1);\n  in(c2, var2: bitstring);\n  let injbot(response) = dec(var2, kS) in\n  event client_accept(request, response); \n  yield.\n\nlet B = \n  in(c3, var12: bitstring);\n  new response_: payload;\n  let response = payload2bs(response_) in\n  let injbot(msg) = dec(var12, kAB) in\n  let request = parse1(msg) in\n  event server_reply(request, response);\n  let key2bs(kS) = parse2(msg) in\n  new r: seed;  \n  let var13 = enc(response, kS, r) in\n  out(c4, var13).\n\nprocess\n  in(start, ());\n  new kAB_seed: keyseed;\n  let kAB = kgen(kAB_seed) in\n  out(finish, ());\n  ((! N A) | (! N B))\n\n\n(* EXPECTED\nAll queries proved.\n0.048s (user 0.044s + system 0.004s), max rss 36016K\nEND *)"
    },
    {
        "file": "CV-1/OAEP-CPA.cv",
        "incomplete": "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);\n      crypto rom(____(OP_9)____);\n      show_game occ;\n      insert_event bad1 31;\n      show_game occ;\n      insert_event bad2 59;\n      crypto remove_xor(xorDr) \"@10_r_129\";\n      crypto remove_xor(xorDow) \"@9_r_137\";      \n      remove_assign binder pk;\n      crypto pd_ow(f) \"r_107\" \"@9_r_146\" \"@10_r_144\";\n      success\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype ____(TYPE_0)____ [fixed,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba ____(PROBA_0)____.\n\nexpand set_PD_OW_trapdoor_perm(seed, pkey, skey, D, Dow, Dr, ____(OP_7)____, ____(OP_8)____, ____(OP_6)____, invf, concat, P_PD_OW).\n\n(* Hash functions, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, Dr, Dow, G).\nparam qG [noninteractive].\nchannel ch1, ch2.\nlet hashoracleG = !qG in(ch1, x:Dr); out(ch2, G(hkg,____(OP_4)____)).\n\nexpand ROM_hash(hashkey, Dow, Dr, H).\nparam qH [noninteractive].\nchannel ____(CHANNEL_0)____, ch4.\nlet hashoracleH = !qH in(ch3, x:Dow); out(ch4, H(hkh,x)).\n\n(* concatenation *)\ntype Dm.\ntype Dz [large].\n\nfun concatm(____(OP_3)____,Dz):Dow [compos].\nconst zero: Dz.\n\n(* Xor *)\n\nexpand Xor(Dow, ____(OP_5)____, zeroDow).\nexpand Xor(Dr, xorDr, zeroDr).\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, ____(OP_2)____, Dm):Dm.\nforall x:Dm,y:Dm; test(true,x,y) = x.\nforall x:Dm,y:Dm; test(false,x,y) = y.\n\n(* Queries *)\n\nquery ____(QUERY_0)____ b1.\n\nchannel c0, c1, c2.\n\nlet processT = \n\tin(c1, (m1: Dm, m2: Dm));\n\tnew b1: bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(____(OP_0)____, m1, m2) in\n\tnew r: Dr;\n\tlet s = xorDow(concatm(menc, zero), G(hkg,r)) in\n\tlet t = xorDr(____(OP_1)____, H(hkh,s)) in\n\tout(c2, f(pk, concat(s,t))).\n\nprocess \n\tin(c0, ());\n\tnew hkh: hashkey;\n\tnew hkg: hashkey;\n\tnew r: seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(hashoracleG | hashoracleH | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)",
        "complete:": "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);\n      crypto rom(G);\n      show_game occ;\n      insert_event bad1 31;\n      show_game occ;\n      insert_event bad2 59;\n      crypto remove_xor(xorDr) \"@10_r_129\";\n      crypto remove_xor(xorDow) \"@9_r_137\";      \n      remove_assign binder pk;\n      crypto pd_ow(f) \"r_107\" \"@9_r_146\" \"@10_r_144\";\n      success\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba P_PD_OW.\n\nexpand set_PD_OW_trapdoor_perm(seed, pkey, skey, D, Dow, Dr, pkgen, skgen, f, invf, concat, P_PD_OW).\n\n(* Hash functions, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, Dr, Dow, G).\nparam qG [noninteractive].\nchannel ch1, ch2.\nlet hashoracleG = !qG in(ch1, x:Dr); out(ch2, G(hkg,x)).\n\nexpand ROM_hash(hashkey, Dow, Dr, H).\nparam qH [noninteractive].\nchannel ch3, ch4.\nlet hashoracleH = !qH in(ch3, x:Dow); out(ch4, H(hkh,x)).\n\n(* concatenation *)\ntype Dm.\ntype Dz [large].\n\nfun concatm(Dm,Dz):Dow [compos].\nconst zero: Dz.\n\n(* Xor *)\n\nexpand Xor(Dow, xorDow, zeroDow).\nexpand Xor(Dr, xorDr, zeroDr).\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, Dm, Dm):Dm.\nforall x:Dm,y:Dm; test(true,x,y) = x.\nforall x:Dm,y:Dm; test(false,x,y) = y.\n\n(* Queries *)\n\nquery secret1 b1.\n\nchannel c0, c1, c2.\n\nlet processT = \n\tin(c1, (m1: Dm, m2: Dm));\n\tnew b1: bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(b1, m1, m2) in\n\tnew r: Dr;\n\tlet s = xorDow(concatm(menc, zero), G(hkg,r)) in\n\tlet t = xorDr(r, H(hkh,s)) in\n\tout(c2, f(pk, concat(s,t))).\n\nprocess \n\tin(c0, ());\n\tnew hkh: hashkey;\n\tnew hkg: hashkey;\n\tnew r: seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(hashoracleG | hashoracleH | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)"
    },
    {
        "file": "CV-1/obizarre.ocv",
        "incomplete": "param ____(PARAM_0)____.\n\ntype ____(TYPE_0)____ [fixed, large].\n\nquery secret1 k.\nquery secret ____(QUERY_0)____.\n\nprocess\n        Oa () :=\n           k <-R key;\n           return ();\n        foreach i <= N do \n(*\n           Ob () := \n              s <-R key ;\n*)\n           Ob (s:key) :=\n              if k=s then return(s) else return(s)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15248K\nEND *)",
        "complete:": "param N.\n\ntype key [fixed, large].\n\nquery secret1 k.\nquery secret k.\n\nprocess\n        Oa () :=\n           k <-R key;\n           return ();\n        foreach i <= N do \n(*\n           Ob () := \n              s <-R key ;\n*)\n           Ob (s:key) :=\n              if k=s then return(s) else return(s)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 15248K\nEND *)"
    },
    {
        "file": "CV-1/otestPRF.ocv",
        "incomplete": "(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam ____(PARAM_0)____, m, p, q, qE, qD.\n\ntype seed [large,fixed].\ntype S [____(TYPE_0)____,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba pUF.\nproba ____(PROBA_0)____.\n\n(* f(S) is a pseudo-random function family *) \n\nexpand PRF(seed, S, N, L, kgen, f, pPRF).\n\n(* h(K) is a message authentication code (an unpredictable function family) *)\n\nfun h(K,N,____(OP_4)____): W.\nfun h'(K,N,L): W.\n\nequiv \n    foreach i <= n do k <-R K; (\n         foreach im <= m do Omac(y:N,z:____(OP_1)____) := return(h(k,y,z)) |\n\t foreach ip <= p do Ocheck(y':____(OP_8)____,z':L,t:W) := return(____(OP_11)____ = h(k,y',z'))\n    ) \n<=(pUF(time,n,m,p))=>\n    foreach i <= n do k <-R K; (\n         foreach im <= m do Omac(____(OP_9)____:N,z:L) := return(h'(k,y,z)) |\n\t foreach ip <= p do Ocheck(y':N,z':L,t:W) := find u <= m suchthat \n\t     defined(____(OP_6)____[u],z[u]) && y' = y[u] && z' = z[u] \n                          then return(t = h'(k,y',z')) else return(false)\n    ).\n\nfun xor(____(FUN_0)____,L): L.\n\n(* the theory of xor implies several propositions *)\n\nforall ____(OP_3)____:L, y:L; xor(x, xor(x,y)) = y.\n\nequiv \n    foreach i <= n do x <-R L; OX(y:L) := return(xor(x,y))\n<=(0)=>\n    foreach i <= n do x <-R L; OX(y:L) := return(x).\n\nfun choose(bool,L,L): L.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:L, z:L;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\nconst reject:L.\n\n(* query *)\nquery secret ____(QUERY_0)____.\n\nlet processE = \n    foreach iE <= qE do\n    OE(m0:L, m1:L) :=\n    x' <-R N;\n    let tempE = f(____(OP_0)____,x') in\n    let m' = choose(b,m1,m0) in\n    let c':L = xor(tempE, ____(OP_10)____) in\n    let t':W = h(k,x',c') in\n    return(x',c',____(OP_5)____).\n\nlet processD = \n    foreach iD <= qD do\n    OD(x:N, c:L, t:W) :=\n    if t = h(k,x,c) \n      then \n        (find u <= qE suchthat \n                defined(x'[u],c'[u],t'[u])\n             && x = x'[u]\n             && c = c'[u]\n\t     && t = t'[u] (* BB: added *)\n           then return(reject)  \n           else \n             let tempD = f(s,x) in \n             let m = xor(tempD, c) in \n             return(m) ) \n      else return(reject).\n\nprocess\n  foreach i <= q do\n  Ostart() :=\n  k <-R K;\n  ____(OP_7)____ <-R seed;\n  let s = kgen(sseed) in\n  b <-R bool;\n  return(); \n  (processE | processD)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19552K\nEND *)",
        "complete:": "(** Chosen ciphertext secure symmetric encryption **)\n\n(** The construction of an encryption scheme \n    using a pseudo-random function family\n    and an unpredictable function family\n    is shown to be IND-CCA2.\n    See Section 7, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, m, p, q, qE, qD.\n\ntype seed [large,fixed].\ntype S [large,fixed].\ntype K [large,fixed].\n\ntype N [large,fixed].\ntype L [fixed].\ntype W [fixed].\n\nproba pPRF.\nproba pUF.\nproba pXOR.\n\n(* f(S) is a pseudo-random function family *) \n\nexpand PRF(seed, S, N, L, kgen, f, pPRF).\n\n(* h(K) is a message authentication code (an unpredictable function family) *)\n\nfun h(K,N,L): W.\nfun h'(K,N,L): W.\n\nequiv \n    foreach i <= n do k <-R K; (\n         foreach im <= m do Omac(y:N,z:L) := return(h(k,y,z)) |\n\t foreach ip <= p do Ocheck(y':N,z':L,t:W) := return(t = h(k,y',z'))\n    ) \n<=(pUF(time,n,m,p))=>\n    foreach i <= n do k <-R K; (\n         foreach im <= m do Omac(y:N,z:L) := return(h'(k,y,z)) |\n\t foreach ip <= p do Ocheck(y':N,z':L,t:W) := find u <= m suchthat \n\t     defined(y[u],z[u]) && y' = y[u] && z' = z[u] \n                          then return(t = h'(k,y',z')) else return(false)\n    ).\n\nfun xor(L,L): L.\n\n(* the theory of xor implies several propositions *)\n\nforall x:L, y:L; xor(x, xor(x,y)) = y.\n\nequiv \n    foreach i <= n do x <-R L; OX(y:L) := return(xor(x,y))\n<=(0)=>\n    foreach i <= n do x <-R L; OX(y:L) := return(x).\n\nfun choose(bool,L,L): L.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:L, z:L;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\nconst reject:L.\n\n(* query *)\nquery secret b.\n\nlet processE = \n    foreach iE <= qE do\n    OE(m0:L, m1:L) :=\n    x' <-R N;\n    let tempE = f(s,x') in\n    let m' = choose(b,m1,m0) in\n    let c':L = xor(tempE, m') in\n    let t':W = h(k,x',c') in\n    return(x',c',t').\n\nlet processD = \n    foreach iD <= qD do\n    OD(x:N, c:L, t:W) :=\n    if t = h(k,x,c) \n      then \n        (find u <= qE suchthat \n                defined(x'[u],c'[u],t'[u])\n             && x = x'[u]\n             && c = c'[u]\n\t     && t = t'[u] (* BB: added *)\n           then return(reject)  \n           else \n             let tempD = f(s,x) in \n             let m = xor(tempD, c) in \n             return(m) ) \n      else return(reject).\n\nprocess\n  foreach i <= q do\n  Ostart() :=\n  k <-R K;\n  sseed <-R seed;\n  let s = kgen(sseed) in\n  b <-R bool;\n  return(); \n  (processE | processD)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19552K\nEND *)"
    },
    {
        "file": "CV-1/pfdh.cv",
        "incomplete": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* PFDH signature scheme\n   The prover finds the same probability as for FDH, not the better\n   reduction by J.S.Coron. This is ok, because we do not give the\n   hypothesis of random self-reducibility.\n *)\n\n(* Example updated from CV 1.28 by Benjamin Beurdouche *)\n\n(*\nset interactiveMode = true.\n\nProof:\n\ncrypto hash\ncrypto mf r r_35 r_38\ncrypto f r\nsuccess\n\nThe prover finds the proof automatically, like for fdh, but is unable to find\nthe better reduction which exists for this scheme...\n*)\n\nparam ____(PARAM_0)____.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [(*large,*)fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation *)\nproba ____(PROBA_0)____.\nexpand OW_trapdoor_perm(keyseed, pkey, skey, D, pkgen, skgen, f, mf, pOW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [____(TYPE_0)____].\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Queries *)\nevent ____(EVENT_0)____.\nquery event(____(QUERY_0)____) ==> false.\n\n(* Channels and Processes *)\nchannel c0, ____(CHANNEL_0)____, ____(CHANNEL_1)____, c3, c4, c5, start.\n\nlet processS(hk:hashkey, sk:____(OP_2)____) =\n\t! qS\n\tin(c1, m:bitstring);\n\tnew sr:seed;\n\tout(c2, (sr,mf(sk, hash(hk, (m,sr))))).\n\nlet processT(hk:hashkey, ____(OP_1)____:pkey) =\n\tin(c3, (m2:bitstring, sr:seed, s:D));\n\tif f(pk, s) = hash(hk, (m2,sr)) then\n\tfind j <= qS suchthat defined(m[j]) && (m2 = m[j]) then yield else\n\tevent bad.\n\nprocess\n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew r:keyseed;\n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c0, pk);\n\t(hashoracle(hk) | processS(hk,sk) | processT(hk,pk)))\n\n(* EXPECTED\nAll queries proved.\n0.061s (user 0.057s + system 0.004s), max rss 21056K\nEND *)",
        "complete:": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* PFDH signature scheme\n   The prover finds the same probability as for FDH, not the better\n   reduction by J.S.Coron. This is ok, because we do not give the\n   hypothesis of random self-reducibility.\n *)\n\n(* Example updated from CV 1.28 by Benjamin Beurdouche *)\n\n(*\nset interactiveMode = true.\n\nProof:\n\ncrypto hash\ncrypto mf r r_35 r_38\ncrypto f r\nsuccess\n\nThe prover finds the proof automatically, like for fdh, but is unable to find\nthe better reduction which exists for this scheme...\n*)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [(*large,*)fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation *)\nproba pOW.\nexpand OW_trapdoor_perm(keyseed, pkey, skey, D, pkgen, skgen, f, mf, pOW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Queries *)\nevent bad.\nquery event(bad) ==> false.\n\n(* Channels and Processes *)\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS(hk:hashkey, sk:skey) =\n\t! qS\n\tin(c1, m:bitstring);\n\tnew sr:seed;\n\tout(c2, (sr,mf(sk, hash(hk, (m,sr))))).\n\nlet processT(hk:hashkey, pk:pkey) =\n\tin(c3, (m2:bitstring, sr:seed, s:D));\n\tif f(pk, s) = hash(hk, (m2,sr)) then\n\tfind j <= qS suchthat defined(m[j]) && (m2 = m[j]) then yield else\n\tevent bad.\n\nprocess\n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew r:keyseed;\n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c0, pk);\n\t(hashoracle(hk) | processS(hk,sk) | processT(hk,pk)))\n\n(* EXPECTED\nAll queries proved.\n0.061s (user 0.057s + system 0.004s), max rss 21056K\nEND *)"
    }
]