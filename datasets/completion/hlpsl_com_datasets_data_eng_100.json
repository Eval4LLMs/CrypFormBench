[
    {
        "file": "HLPSL-1/20172001_Assign_3.hlpsl",
        "incomplete": "____(ROLE_0)____ ____(ROLE_2)____ (Ui, ____(PARAM_2)____, GWN, SDj: ____(PARAM_3)____, ____(PARAM_1)____ : hash_func,\n____(PARAM_0)____ : symmetric_key, Snd, ____(PARAM_4)____: channel(____(PARAM_5)____))\nplayed_by Ui\ndef=\nlocal State: ____(VARIABLE_0)____, ____(VARIABLE_2)____, IDsdj, IDgwn, PWi, ____(VARIABLE_4)____, ____(VARIABLE_3)____, A: ____(VARIABLE_1)____,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, T1, Sigmai: text, Gen, Rep : hash_func\nconst ____(VARIABLE_6)____, ui_gwn_rui, gwn_ui_t4, ____(VARIABLE_5)____,____(VARIABLE_7)____: protocol_id\ninit State := 0\ntransition\n1. State = ____(STATE_0)____ /\\ ____(MESSAGE_41)____(start) =|>\n% Registration phase\nState' := 1 /\\ A' := new() /\\ R' := new()\n/\\ secret({PWi, BIOi, ____(EVENT_1)____, ____(EVENT_2)____}, sr1, ____(EVENT_0)____)\n/\\ Sigmai' := Gen(BIOi) /\\ RPWi' := xor(H(PWi.Sigmai'.A'), R')\n% Send registration request securely to RA\n/\\ Snd({____(MESSAGE_42)____}_SKuira)\n\n% Receive information securely from RA for SPi\n2. State = ____(STATE_1)____/\\Rcv({xor(H(____(MESSAGE_43)____),xor(H(PWi.Sigmai'.A'),R')).TIDi'}_SKuira)=|>\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') /\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ ____(MESSAGE_44)____(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,____(EVENT_3)____, ____(EVENT_4)____)\n/\\ ____(EVENT_5)____(Ui,GWN,ui_gwn_rui,____(EVENT_6)____)\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3/\\____(EVENT_7)____(GWN,Ui,gwn_ui_t4,____(EVENT_8)____)/\\request(GWN,Ui,____(EVENT_9)____,____(EVENT_10)____)\nend ____(ROLE_1)____\n \n\nrole registrationauthority (Ui, RA, ____(PARAM_8)____, SDj: agent, H : ____(PARAM_7)____,\nSKuira : ____(PARAM_9)____, ____(PARAM_6)____, ____(PARAM_11)____: channel(____(PARAM_10)____))\nplayed_by RA\ndef=\nlocal ____(VARIABLE_8)____: nat, IDi, ____(VARIABLE_9)____, ____(VARIABLE_11)____, ____(VARIABLE_12)____, ____(VARIABLE_10)____, RPWi, ____(VARIABLE_13)____, Ai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ____(VARIABLE_14)____,sr3: protocol_id\ninit State := 0\ntransition\n1. State = ____(STATE_2)____ /\\ Rcv({____(MESSAGE_45)____}_SKuira) =|>\nState' := 1 /\\ Kgwnui' := new()\n/\\ ____(EVENT_12)____(____(EVENT_13)____, ____(EVENT_11)____, {RA,GWN,Ui})\n/\\ ____(EVENT_16)____(____(EVENT_14)____, sr3, {RA,GWN,____(EVENT_15)____})\n/\\ Ai' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ ____(MESSAGE_46)____({Ai'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (____(PARAM_14)____, RA, ____(PARAM_17)____, ____(PARAM_15)____: agent, ____(PARAM_12)____ : ____(PARAM_13)____,\nSKuira : symmetric_key, Snd, ____(PARAM_16)____: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, ____(VARIABLE_18)____, ____(VARIABLE_16)____, RPWi, ____(VARIABLE_15)____: ____(VARIABLE_17)____,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst ____(VARIABLE_21)____, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, ____(VARIABLE_22)____, ui_gwn_rui, ____(VARIABLE_19)____, ____(VARIABLE_20)____: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ ____(MESSAGE_47)____(TIDi'.xor(H(IDi.Kgwnui), Rui').H(xor(H(IDi.Kgwnui), Rui').T1'.IDi'.TIDi'.Rui').T1') =|>\nState' := 1 /\\ M4' := H(IDi.Kgwnui)\n/\\ ____(EVENT_17)____(____(EVENT_18)____,GWN,ui_gwn_t1, T1')\n/\\ ____(EVENT_20)____(Ui,____(EVENT_19)____,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ ____(MESSAGE_48)____(M7'.M8'.T2')\n/\\ witness(____(EVENT_22)____,SDj,____(EVENT_21)____, T2')\n/\\ ____(EVENT_23)____(____(EVENT_24)____,SDj,gwn_sdj_rgwn, Rgwn')\n\n2. State = 1 /\\ Rcv(____(MESSAGE_49)____) =|>\nState' := 2 /\\ TIDi' := new() /\\ Rgwn' := new() /\\ Rui' := new() /\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ ____(EVENT_26)____(SDj,GWN,____(EVENT_25)____, T3')\n/\\ ____(EVENT_28)____(____(EVENT_27)____,GWN,sdj_gwn_rsdj, Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ ____(EVENT_30)____(____(EVENT_29)____,Ui,gwn_ui_t4, T4')\n/\\ witness(GWN,Ui,____(EVENT_32)____, ____(EVENT_31)____)\nend role\n\n\n\nrole smartdevice (____(PARAM_21)____, RA, GWN, ____(PARAM_18)____: agent, ____(PARAM_20)____ : ____(PARAM_23)____,\nSKuira : symmetric_key, ____(PARAM_19)____, Rcv: channel(____(PARAM_22)____))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, ____(VARIABLE_23)____, IDgwn, PWi, BIOi, ____(VARIABLE_25)____, ____(VARIABLE_24)____: ____(VARIABLE_26)____,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, ____(VARIABLE_28)____, ____(VARIABLE_27)____: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(____(MESSAGE_50)____)}_M6'.M8'.T2') =|>\nState' := 1 /\\ Kgwnsdj' := new()\n/\\ request(GWN,____(EVENT_33)____,gwn_sdj_t2, ____(EVENT_34)____)\n/\\ request(____(EVENT_35)____,SDj,gwn_sdj_rgwn, ____(EVENT_36)____)\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ ____(MESSAGE_51)____(M10'.M11'.M12'.T3')\n/\\ ____(EVENT_37)____(SDj,GWN,____(EVENT_38)____, T3')\n/\\ ____(EVENT_40)____(SDj,GWN,____(EVENT_39)____, Rsdj')\n\nend role\n\nrole session (____(PARAM_24)____, ____(PARAM_25)____, ____(PARAM_27)____, SDj: agent, H: hash_func, SKuira: ____(PARAM_26)____)\ndef=\nlocal S1, R1, S2, R2, S3, ____(VARIABLE_29)____, ____(VARIABLE_31)____, ____(VARIABLE_32)____: channel (____(VARIABLE_30)____)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S2, R2)\nend role\n\nrole environment()\ndef=\nconst ui, ____(VARIABLE_33)____, ____(VARIABLE_35)____, ____(VARIABLE_34)____: agent, ____(VARIABLE_36)____: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\n____(GOAL_53)____ ____(GOAL_52)____, sr2, sr3\nauthentication_on ____(GOAL_54)____, ____(GOAL_55)____, gwn_sdj_t2\nauthentication_on ____(GOAL_56)____, sdj_gwn_t3, ____(GOAL_57)____\nauthentication_on ____(GOAL_58)____, gwn_ui_tidinew\nend goal\nenvironment()",
        "complete:": "role user (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by Ui\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, RPWi, A: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, T1, Sigmai: text, Gen, Rep : hash_func\nconst ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew,sr1: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(start) =|>\n% Registration phase\nState' := 1 /\\ A' := new() /\\ R' := new()\n/\\ secret({PWi, BIOi, A', R'}, sr1, Ui)\n/\\ Sigmai' := Gen(BIOi) /\\ RPWi' := xor(H(PWi.Sigmai'.A'), R')\n% Send registration request securely to RA\n/\\ Snd({IDi.RPWi'}_SKuira)\n\n% Receive information securely from RA for SPi\n2. State = 1/\\Rcv({xor(H(IDi'.Kgwnui),xor(H(PWi.Sigmai'.A'),R')).TIDi'}_SKuira)=|>\n% Login phase\nState' := 2\n% Send login request to GWN via public channel\n/\\ Rui' := new() /\\ T1' := new()/\\ M1' := H(IDi.Kgwnui)\n/\\ M2' := xor(M1', Rui') /\\ M3' := H(M2'.T1'.IDi'.TIDi'.Rui')\n/\\ Snd(TIDi'.M2'.M3'.T1')\n% Ui has freshly generated the values T1 and Rui for GWN\n/\\ witness(Ui,GWN,ui_gwn_t1, T1')\n/\\ witness(Ui,GWN,ui_gwn_rui,Rui')\n% Authentication and key agreement phase\n\n% Receive authentication reply from GWN via public channel\n3. State = 2 /\\ Rcv({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')=|>\n% Ui's acceptance of T4 and TIDinew generated for Ui by GWN\nState' := 3/\\request(GWN,Ui,gwn_ui_t4,T4')/\\request(GWN,Ui,gwn_ui_tidinew,TIDinew')\nend role\n \n\nrole registrationauthority (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by RA\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, RPWi, A, Ai: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, M1, Rui, TIDi,TIDinew: text,\nM2, M3, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst sr2,sr3: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.RPWi'}_SKuira) =|>\nState' := 1 /\\ Kgwnui' := new()\n/\\ secret(Kgwnui, sr2, {RA,GWN,Ui})\n/\\ secret(Kgwnsdj, sr3, {RA,GWN,SDj})\n/\\ Ai' := xor(H(IDi.Kgwnui'), RPWi')\n/\\ TIDi' := new()\n/\\ Snd({Ai'.TIDi'}_SKuira)\n\nend role\n\n\nrole gatewaynode (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by GWN\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, RPWi, A: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T1, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj, ui_gwn_t1, ui_gwn_rui, gwn_ui_t4, gwn_ui_tidinew: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv(TIDi'.xor(H(IDi.Kgwnui), Rui').H(xor(H(IDi.Kgwnui), Rui').T1'.IDi'.TIDi'.Rui').T1') =|>\nState' := 1 /\\ M4' := H(IDi.Kgwnui)\n/\\ request(Ui,GWN,ui_gwn_t1, T1')\n/\\ request(Ui,GWN,ui_gwn_rui,Rui')\n/\\ M2' := new()\n/\\ Ruistar' := xor(M2', M4')\n/\\ Rgwn' := new()\n/\\ T2' := new()\n/\\ M6' := H(IDsdj.Kgwnsdj)\n/\\ M7' := {IDi.IDgwn.Ruistar'.Rgwn.H(M4')}_M6'\n/\\ M8' := H(M6'.T2'.IDi.IDsdj.IDgwn.Rgwn')\n/\\ Snd(M7'.M8'.T2')\n/\\ witness(GWN,SDj,gwn_sdj_t2, T2')\n/\\ witness(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n\n2. State = 1 /\\ Rcv(M10'.M11'.M12'.T3') =|>\nState' := 2 /\\ TIDi' := new() /\\ Rgwn' := new() /\\ Rui' := new() /\\ Rsdj' := new()\t\t\t\t\t\t\t\n/\\ request(SDj,GWN,sdj_gwn_t3, T3')\n/\\ request(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n/\\ T4' := new()\n/\\ TIDinew' := new()\n/\\ Snd({Rui'.Rgwn'.Rsdj'.IDi.IDsdj.IDgwn.\nH(H(IDsdj.Kgwnsdj))}_H(IDi.Kgwnui).\nxor(TIDinew', H(TIDi'.H(IDi.Kgwnui).T3'.T4')).\nH(H(H(IDi.IDsdj.IDgwn.Rui'.Rgwn'.Rsdj'.\nH(H(IDi.Kgwnui)).H(H(IDsdj.Kgwnsdj))).T3').T4'.Rui').T3'.T4')\n/\\ witness(GWN,Ui,gwn_ui_t4, T4')\n/\\ witness(GWN,Ui,gwn_ui_tidinew, TIDinew')\nend role\n\n\n\nrole smartdevice (Ui, RA, GWN, SDj: agent, H : hash_func,\nSKuira : symmetric_key, Snd, Rcv: channel(dy))\nplayed_by SDj\ndef=\nlocal State: nat, IDi, IDsdj, IDgwn, PWi, BIOi, RPWi, A: text,\nR, Kgwnui, Kgwnsdj, Rgwn, Rsdj, T2, M1, Rui, TIDi,TIDinew, Ruistar: text,\nM2, M3, M4, M6, M7, M8, M10, M11, M12, T3, T4, Sigmai: text, Gen, Rep : hash_func\nconst gwn_sdj_t2, gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj: protocol_id\ninit State := 0\ntransition\n1. State = 0 /\\ Rcv({IDi.IDgwn.Ruistar'.Rgwn'.H(M4')}_M6'.M8'.T2') =|>\nState' := 1 /\\ Kgwnsdj' := new()\n/\\ request(GWN,SDj,gwn_sdj_t2, T2')\n/\\ request(GWN,SDj,gwn_sdj_rgwn, Rgwn')\n/\\ Rsdj' := new()\n/\\ T3' := new()\n/\\ M10' := xor(H(H(IDsdj.Kgwnsdj').T3'), Rsdj')\n/\\ M11' := H(H(IDi.IDsdj.IDgwn.Ruistar'.Rgwn'.Rsdj'.H(M4').H(H(IDsdj.Kgwnsdj)).T3'))\n/\\ M12' := H(Rsdj'.Rgwn'.IDsdj.IDgwn.T3')\n/\\ Snd(M10'.M11'.M12'.T3')\n/\\ witness(SDj,GWN,sdj_gwn_t3, T3')\n/\\ witness(SDj,GWN,sdj_gwn_rsdj, Rsdj')\n\nend role\n\nrole session (Ui, RA, GWN, SDj: agent, H: hash_func, SKuira: symmetric_key)\ndef=\nlocal S1, R1, S2, R2, S3, R3, S4, R4: channel (dy)\ncomposition\nuser (Ui, RA, GWN, SDj, H, SKuira, S1, R1)\n/\\ registrationauthority(Ui, RA, GWN, SDj, H, SKuira, S2, R2)\n/\\ gatewaynode (Ui, RA, GWN, SDj, H, SKuira, S3, R3)\n/\\ smartdevice (Ui, RA, GWN, SDj, H, SKuira, S2, R2)\nend role\n\nrole environment()\ndef=\nconst ui, ra, gwn, sdj: agent, h: hash_func, skuira: symmetric_key,\nkgwnui, kgwnsdj, idi, idsnj, idgwn, t1, t2, t3, t4, tidi, tidinew: text,\ngen, rep: hash_func, ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2, gwn_sdj_rgwn,\nsdj_gwn_t3, sdj_gwn_rsdj, sr1, sr2, sr3: protocol_id\nintruder_knowledge ={t1, t2, t3, t4, h, gen, rep}\ncomposition\nsession(ui, ra, gwn, sdj, h, skuira) /\\ session(i, ra, gwn, sdj, h, skuira)\n/\\ session(ui, i, gwn, sdj, h, skuira) /\\ session(ui, ra, i, sdj, h, skuira)\n/\\ session(ui, ra, gwn, i, h, skuira)\nend role\ngoal\nsecrecy_of sr1, sr2, sr3\nauthentication_on ui_gwn_t1, ui_gwn_rui, gwn_sdj_t2\nauthentication_on gwn_sdj_rgwn, sdj_gwn_t3, sdj_gwn_rsdj\nauthentication_on gwn_ui_t4, gwn_ui_tidinew\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/2019202008.hlpsl",
        "incomplete": "%%A temporal-credential-based mutual authentication and key agreement scheme for wireless sensor networks\n%% Roles\n%%\t-user (AGENT : User)\n%%  -generate password (AGENT : Gen)\n%%  -gateway node (AGENT: Gwn)\n%%  -smart device (AGENT :Sensor)\n%%  -session\n%%  -environment\n%%  -goal\n\n____(ROLE_0)____ generate(\n\t____(PARAM_0)____, User, ____(PARAM_2)____, ____(PARAM_3)____: agent,\n\tSND, ____(PARAM_1)____: channel(dy),\n    H: hash_func)\n\nplayed_by Gen\ndef=\nlocal \n\t  ____(VARIABLE_0)____: nat,\n      SKgenu, SKgeng: symmetric_key,\n      PWD: text\n    const sp1, sp2: ____(VARIABLE_1)____\n\ninit  State := 0\ntransition\n\n1. State = 0 /\\ RCV(start) =|> \n State' := 1 /\\ PWD' := new()\n %%Send Password to user through a secure channel\n             /\\ SND({PWD'}_SKgenu)\n %%Send Password to gateway node through a secure channel\n             /\\ SND({PWD'}_SKgeng)\nend ____(ROLE_2)____\n\n%%Role user\nrole user(\n\t____(PARAM_7)____,User,____(PARAM_5)____,____(PARAM_6)____\t: ____(PARAM_4)____,\n\tSND,RCV : channel(dy),\n\tH\t: hash_func\n\t)\n\nplayed_by User def=\n\t\n\tlocal\n\t\tState : ____(VARIABLE_2)____,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTi,Tdel \t: nat,\n\t\tSId,PWS,UID,PWD,TS1,TS4,TS6,TE,Kgwnu,PWD1,VI,PTC,TC,DID,C,K,PKS,P,C1,PKS1,Kj,KEYij,H1,H2 \t\t: text\n\n\tconst\n\t\tsp2,u_g_ts1,____(VARIABLE_4)____,____(VARIABLE_3)____,____(VARIABLE_6)____,s_u_ts6,s_u_kj:____(VARIABLE_5)____\t\n\n\tinit\n\t\tState:=0\n\n\ttransition\n\n\t%%User Registration\n\n\t\t1. State  = ____(STATE_1)____ /\\ RCV({PWD'}_SKgenu) =|>\n\t\t   State':=1  /\\ UID' := new() /\\ TS1' := new()\n\t\t\t\t\t  /\\ PWD1' := H(PWD')\n\t\t\t\t\t  /\\ VI' := H(TS1'.PWD1')\n\t\t\t\t\t  /\\ SND(TS1'.UID'.VI')\n\t\t\t\t\t  /\\ ____(EVENT_0)____(____(EVENT_1)____,Gwn,u_g_ts1,TS1')\n\n\t\t2. State  = ____(STATE_2)____ /\\ RCV({UID'.H(H(PWD1')).TE'.PTC'}_SKgwnu) =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ ____(EVENT_3)____({____(EVENT_2)____},sp2, {Gwn})\n\t\t   \t\t\t  /\\ request(____(EVENT_4)____,User,g_u_te,____(EVENT_5)____)\n\t\t   \t\t\t  /\\ H1' := H(H(PWD1'))\n\t\t   \t\t\t  /\\ H2' := H(H(PWD'))\n\t%%Login and authentication phase\n\t\t   \t\t\t  /\\ TC' := xor(PTC',H(PWD))\n\t\t   \t\t\t  /\\ TS4' := new()\n\t\t   \t\t\t  /\\ DID' := xor(UID', H(TC'.TS4'))\n\t\t   \t\t\t  /\\ C' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := new()\n\t\t   \t\t\t  /\\ PKS' := xor(K',H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ SND(DID'.C'.PKS'.TS4'.TE'.P')\n\t\t   \t\t\t  /\\ ____(EVENT_6)____(User,Gwn,____(EVENT_7)____,TS4')\n\t\t   \t\t\t  /\\ ____(EVENT_8)____(User,Gwn,____(EVENT_9)____, K')\n\n\t\t3. State  = ____(STATE_4)____ /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 3 /\\ Kj' := new() /\\ ____(EVENT_11)____(____(EVENT_10)____,User,s_u_ts6,TS6')\n\t\t   \t\t\t  /\\ request(____(EVENT_13)____,User,s_u_kj, ____(EVENT_12)____)\t\n\n\t%%Receive Session key \t   \t\t\t  \n\t\t4. State  = ____(STATE_0)____ /\\ RCV(H(xor(K', Kj'))) =|>\n\t\t   State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n\tGen,User,____(PARAM_8)____,Sensor\t: ____(PARAM_10)____,\n\t____(PARAM_11)____,____(PARAM_9)____ : channel(dy),\n\tH \t: hash_func\n%\tKgwnu, Kgwns\t: public_key,\n\t)\n\nplayed_by Gwn def=\n\n\tlocal\n\t\t____(VARIABLE_13)____ : nat,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTdel,Tchckgwn,Ti,Tgwn\t: nat,\n\t\tPWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij\t: text\n\n\n\tconst\n\t\t____(VARIABLE_10)____,____(VARIABLE_12)____,____(VARIABLE_11)____,g_u_te,u_g_ts1,____(VARIABLE_7)____,s_g_ts2,____(VARIABLE_9)____,u_g_ts4,u_g_k,s_g_ts6,s_g_kj:____(VARIABLE_8)____\n\n\tinit\n\t\tState := 0\n\n\ttransition\n\n\t%% REceive request for registration from user\n\n\t\t1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n\t\t   State':= 1 /\\ TE' := new()\n\n\t\t2. State  = ____(STATE_3)____ /\\ RCV(TS1'.UID'.VI') =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n\t\t   \t\t\t  /\\ TE' := new()\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.P'.TE')\n\t\t   \t\t\t  /\\ PTC' := xor(TC', H(PWD'))\n\t\t   \t\t\t  /\\ ____(EVENT_15)____({____(EVENT_14)____}, sp2, {Gwn})\n\t\t   \t\t\t  /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n\t\t   \t\t\t  /\\ ____(EVENT_16)____(Gwn,User,____(EVENT_17)____,TE') \n\t\t   \t\t\t  /\\ request(____(EVENT_19)____,____(EVENT_18)____,u_g_ts1,TS1')\n\n    %%Receive request for registration from Sensor\n\t\t3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n\t\t   State':= 3 /\\ PWS' := new() /\\ secret({____(EVENT_20)____}, ____(EVENT_21)____, {Sensor, Gwn})\n\t\t   \t \t\t  /\\ VI3' := H(TS2'.H(PWS'))\n\t\t   \t \t\t  /\\ TC1' := H(Kgwns.SId')\n\t\t   \t \t\t  /\\ TS3' := new()\n\t\t   \t \t\t  /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n\t\t   \t \t\t  /\\ SND(TS3'.REG')\n\t\t   \t \t\t  /\\ ____(EVENT_23)____({Kgwns}, ____(EVENT_22)____, {Gwn})\n\t\t   \t \t\t  /\\ ____(EVENT_24)____(____(EVENT_25)____,Sensor,g_s_ts3,TS3')\n\t\t   \t \t\t  /\\ request(____(EVENT_27)____,Gwn,s_g_ts2,____(EVENT_26)____)\n    %%Login and authentication phase\n\t\t4. State  = ____(STATE_5)____ /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n\t\t   State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.UID')\n\t\t   \t\t\t  /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := xor(PKS', H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ TC1' := H(Kgwns.SId') \n\t\t   \t\t\t  /\\ TS5' := new()\n\t\t   \t\t\t  /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn' := H(UID'.TC1'.TS5')\n\t\t   \t\t\t  /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n\t\t   \t\t\t  /\\ ____(EVENT_29)____(____(EVENT_28)____,Sensor,g_s_ts5,TS5')\n\t\t   \t\t\t  /\\ request(____(EVENT_31)____,Gwn,____(EVENT_30)____,TS4')\n\t\t   \t\t\t  /\\ ____(EVENT_33)____(User,Gwn,u_g_k, ____(EVENT_32)____)\n\n    %% send session key via public channel to user and sensor\n\t\t5. State  = ____(STATE_6)____ /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n\t\t   \t\t\t  /\\ KEYij' := H(xor(K',Kj'))\n\t\t   \t\t\t  /\\ SND(KEYij)\n\t\t   \t\t\t  /\\ request(Sensor,____(EVENT_34)____,s_g_ts6, ____(EVENT_35)____)\n\t\t   \t\t\t  /\\ ____(EVENT_36)____(Sensor,Gwn,____(EVENT_37)____, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n\tGen,____(PARAM_13)____,Gwn,____(PARAM_15)____\t: agent,\n\t____(PARAM_12)____,____(PARAM_14)____ : channel(dy),\n\tH \t: hash_func\n\t)\n\nplayed_by Sensor def=\n\n\tlocal\n\t\tState : nat,\n\t\tTgwn,Tdel,Tchckj: nat,\n\t\tPWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij \t: text\n\n\tconst\n\t\tsp3,sp4,s_g_ts2,____(VARIABLE_17)____,____(VARIABLE_14)____,s_u_kj,____(VARIABLE_16)____:____(VARIABLE_15)____\n\n\tinit\n\t\tState := 2\n\n\ttransition\n\n\t%%Sensor Node registration\n\t\t\n\t\t1. State  = 2 /\\ RCV(start) =|> \n\t\t   State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n\t\t   \t\t\t  /\\ VI' := H(TS2'.H(PWS'))\n\t\t   \t\t\t  /\\ SND(SId'.TS2'.VI')\n\t\t   \t\t\t  /\\ secret({____(EVENT_38)____}, sp3, {____(EVENT_39)____, Gwn})\n\t\t   \t\t\t  /\\ witness(____(EVENT_40)____,Gwn,____(EVENT_41)____,TS2')\n\n\t\t2. State  = 3 /\\ RCV(TS3'.REG') =|>\n\t\t   State':= 4 /\\ PWS' := new() /\\ secret({____(EVENT_43)____}, sp4, {____(EVENT_42)____})\n\t\t   \t\t\t  /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n\t\t   \t\t\t  /\\ ____(EVENT_44)____(Gwn,____(EVENT_45)____,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n\t\t3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n\t\t   State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n\t\t   \t\t\t  /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ TS6' := new()\n\t\t   \t\t\t  /\\ Kj' := new()\n\t\t   \t\t\t  /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n\t\t   \t\t\t  /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n\t\t   \t\t\t  /\\ SND(SId'.TS6'.C1'.PKS1')\n\t\t   \t\t\t  /\\ witness(____(EVENT_46)____,User,s_u_ts6,____(EVENT_47)____)\n\t\t   \t\t\t  /\\ ____(EVENT_48)____(____(EVENT_49)____,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n\t\t4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n\t\t   State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n\t\t              /\\ witness(Sensor,____(EVENT_51)____,s_g_ts6, ____(EVENT_50)____)\n\t\t              /\\ witness(____(EVENT_53)____,Gwn,____(EVENT_52)____, Kj')\nend role\n\n%%Sensor role\nrole session(\n\t____(PARAM_17)____,____(PARAM_18)____,Gwn,Sensor : ____(PARAM_16)____,\n\tH:hash_func)\n\n\tdef=\n\t\t\n\t\tlocal \n\t\t\t____(VARIABLE_18)____,RCVU,SNDG,RCVG,SNDS,____(VARIABLE_19)____: channel (____(VARIABLE_20)____)\n\n\t\tcomposition\n\t\t\tuser(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n  \t\t\t/\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n  \t\t\t/\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n\t\n\tdef=\n\n\t\tconst \n\t\t\ta,____(VARIABLE_22)____,____(VARIABLE_21)____,d: agent,\n\t\t\tu_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n\t\t\th:hash_func,\n\t\t\tt1,t2,t3:text\n\t\t\t%Kgwnu,Kgwns:public_key\n\n\n\tintruder_knowledge = {a,b,c,t1,t2,t3}\n\n\tcomposition\n\t\t   session(a,b,c,d,h)\n\t\t/\\ session(a,i,c,d,h) \n\t\t/\\ session(a,b,i,d,h)\n\t\t/\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n\t____(GOAL_55)____ sp2, ____(GOAL_54)____, sp4\n\n\tauthentication_on ____(GOAL_57)____, ____(GOAL_56)____, u_g_k\n\t____(GOAL_59)____ g_u_te, ____(GOAL_58)____, g_s_ts5\n\tauthentication_on s_g_ts2, ____(GOAL_61)____, ____(GOAL_60)____, ____(GOAL_62)____, s_g_kj\nend goal\n\nenvironment()",
        "complete:": "%%A temporal-credential-based mutual authentication and key agreement scheme for wireless sensor networks\n%% Roles\n%%\t-user (AGENT : User)\n%%  -generate password (AGENT : Gen)\n%%  -gateway node (AGENT: Gwn)\n%%  -smart device (AGENT :Sensor)\n%%  -session\n%%  -environment\n%%  -goal\n\nrole generate(\n\tGen, User, Gwn, Sensor: agent,\n\tSND, RCV: channel(dy),\n    H: hash_func)\n\nplayed_by Gen\ndef=\nlocal \n\t  State: nat,\n      SKgenu, SKgeng: symmetric_key,\n      PWD: text\n    const sp1, sp2: protocol_id\n\ninit  State := 0\ntransition\n\n1. State = 0 /\\ RCV(start) =|> \n State' := 1 /\\ PWD' := new()\n %%Send Password to user through a secure channel\n             /\\ SND({PWD'}_SKgenu)\n %%Send Password to gateway node through a secure channel\n             /\\ SND({PWD'}_SKgeng)\nend role\n\n%%Role user\nrole user(\n\tGen,User,Gwn,Sensor\t: agent,\n\tSND,RCV : channel(dy),\n\tH\t: hash_func\n\t)\n\nplayed_by User def=\n\t\n\tlocal\n\t\tState : nat,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTi,Tdel \t: nat,\n\t\tSId,PWS,UID,PWD,TS1,TS4,TS6,TE,Kgwnu,PWD1,VI,PTC,TC,DID,C,K,PKS,P,C1,PKS1,Kj,KEYij,H1,H2 \t\t: text\n\n\tconst\n\t\tsp2,u_g_ts1,g_u_te,u_g_ts4,u_g_k,s_u_ts6,s_u_kj:protocol_id\t\n\n\tinit\n\t\tState:=0\n\n\ttransition\n\n\t%%User Registration\n\n\t\t1. State  = 0 /\\ RCV({PWD'}_SKgenu) =|>\n\t\t   State':=1  /\\ UID' := new() /\\ TS1' := new()\n\t\t\t\t\t  /\\ PWD1' := H(PWD')\n\t\t\t\t\t  /\\ VI' := H(TS1'.PWD1')\n\t\t\t\t\t  /\\ SND(TS1'.UID'.VI')\n\t\t\t\t\t  /\\ witness(User,Gwn,u_g_ts1,TS1')\n\n\t\t2. State  = 1 /\\ RCV({UID'.H(H(PWD1')).TE'.PTC'}_SKgwnu) =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ secret({Kgwnu},sp2, {Gwn})\n\t\t   \t\t\t  /\\ request(Gwn,User,g_u_te,TE')\n\t\t   \t\t\t  /\\ H1' := H(H(PWD1'))\n\t\t   \t\t\t  /\\ H2' := H(H(PWD'))\n\t%%Login and authentication phase\n\t\t   \t\t\t  /\\ TC' := xor(PTC',H(PWD))\n\t\t   \t\t\t  /\\ TS4' := new()\n\t\t   \t\t\t  /\\ DID' := xor(UID', H(TC'.TS4'))\n\t\t   \t\t\t  /\\ C' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := new()\n\t\t   \t\t\t  /\\ PKS' := xor(K',H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ SND(DID'.C'.PKS'.TS4'.TE'.P')\n\t\t   \t\t\t  /\\ witness(User,Gwn,u_g_ts4,TS4')\n\t\t   \t\t\t  /\\ witness(User,Gwn,u_g_k, K')\n\n\t\t3. State  = 2 /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 3 /\\ Kj' := new() /\\ request(Sensor,User,s_u_ts6,TS6')\n\t\t   \t\t\t  /\\ request(Sensor,User,s_u_kj, Kj')\t\n\n\t%%Receive Session key \t   \t\t\t  \n\t\t4. State  = 3 /\\ RCV(H(xor(K', Kj'))) =|>\n\t\t   State':= 4 /\\ KEYij' := H(xor(K',Kj'))\n\nend role\n\n%%Role gateway node\nrole gateway(\n\tGen,User,Gwn,Sensor\t: agent,\n\tSND,RCV : channel(dy),\n\tH \t: hash_func\n%\tKgwnu, Kgwns\t: public_key,\n\t)\n\nplayed_by Gwn def=\n\n\tlocal\n\t\tState : nat,\n\t\tSKgwnu,SKgenu,SKgeng : symmetric_key,\n\t\tTdel,Tchckgwn,Ti,Tgwn\t: nat,\n\t\tPWS,SId,UID,PWD,TS4,TS6,TS5,TS3,TS2,TE,TS1,Kgwns,Kgwnu,VI,VI1,P,TC,PTC,VI2,VI3,TC1,REG,P1,DID,C,PKS,C1,K,DIDgwn,Cgwn,PKSgwn,C1j,PKS1,Kj,KEYij\t: text\n\n\n\tconst\n\t\tsp2,sp3,sp4,g_u_te,u_g_ts1,g_s_ts3,s_g_ts2,g_s_ts5,u_g_ts4,u_g_k,s_g_ts6,s_g_kj:protocol_id\n\n\tinit\n\t\tState := 0\n\n\ttransition\n\n\t%% REceive request for registration from user\n\n\t\t1. State  = 0 /\\  RCV({PWD'}_SKgeng) =|>\n\t\t   State':= 1 /\\ TE' := new()\n\n\t\t2. State  = 1 /\\ RCV(TS1'.UID'.VI') =|>\n\t\t   State':= 2 /\\ PWD' := new() /\\ VI1' := H(TS1'.H(PWD'))\n\t\t   \t\t\t  /\\ TE' := new()\n\t\t   \t\t\t  /\\ P' := H(UID'.TE')\n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.P'.TE')\n\t\t   \t\t\t  /\\ PTC' := xor(TC', H(PWD'))\n\t\t   \t\t\t  /\\ secret({Kgwnu}, sp2, {Gwn})\n\t\t   \t\t\t  /\\ SND({UID'.H(H(PWD')).TE'.PTC'}_SKgwnu)\n\t\t   \t\t\t  /\\ witness(Gwn,User,g_u_te,TE') \n\t\t   \t\t\t  /\\ request(User,Gwn,u_g_ts1,TS1')\n\n    %%Receive request for registration from Sensor\n\t\t3. State  = 2 /\\ RCV(SId'.TS2'.VI2') =|>\n\t\t   State':= 3 /\\ PWS' := new() /\\ secret({PWS}, sp3, {Sensor, Gwn})\n\t\t   \t \t\t  /\\ VI3' := H(TS2'.H(PWS'))\n\t\t   \t \t\t  /\\ TC1' := H(Kgwns.SId')\n\t\t   \t \t\t  /\\ TS3' := new()\n\t\t   \t \t\t  /\\ REG' := xor(H(H(PWS').TS3'),TC1')\n\t\t   \t \t\t  /\\ SND(TS3'.REG')\n\t\t   \t \t\t  /\\ secret({Kgwns}, sp4, {Gwn})\n\t\t   \t \t\t  /\\ witness(Gwn,Sensor,g_s_ts3,TS3')\n\t\t   \t \t\t  /\\ request(Sensor,Gwn,s_g_ts2,TS2')\n    %%Login and authentication phase\n\t\t4. State  = 3 /\\ RCV(DID'.C'.PKS'.TS4'.TE'.P') =|>\n\t\t   State':= 4 /\\ SId' := new() /\\ UID' := xor(DID',H(H(inv(Kgwnu).P'.TE').TS4')) \n\t\t   \t\t\t  /\\ TC' := H(Kgwnu.UID')\n\t\t   \t\t\t  /\\ C1' := H(xor(H(UID'.TS4'),TC'))\n\t\t   \t\t\t  /\\ K' := xor(PKS', H(TC'.TS4'.0))\n\t\t   \t\t\t  /\\ TC1' := H(Kgwns.SId') \n\t\t   \t\t\t  /\\ TS5' := new()\n\t\t   \t\t\t  /\\ DIDgwn' := xor(UID',H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn' := H(UID'.TC1'.TS5')\n\t\t   \t\t\t  /\\ PKSgwn' := xor(K',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ SND(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn')\n\t\t   \t\t\t  /\\ witness(Gwn,Sensor,g_s_ts5,TS5')\n\t\t   \t\t\t  /\\ request(User,Gwn,u_g_ts4,TS4')\n\t\t   \t\t\t  /\\ request(User,Gwn,u_g_k, K')\n\n    %% send session key via public channel to user and sensor\n\t\t5. State  = 4 /\\ RCV(SId'.TS6'.C1'.PKS1') =|>\n\t\t   State':= 5 /\\ K' := new() /\\ Kj' := xor(PKS1', H(K'.TS6'))\n\t\t   \t\t\t  /\\ KEYij' := H(xor(K',Kj'))\n\t\t   \t\t\t  /\\ SND(KEYij)\n\t\t   \t\t\t  /\\ request(Sensor,Gwn,s_g_ts6, TS6')\n\t\t   \t\t\t  /\\ request(Sensor,Gwn,s_g_kj, Kj')\n\nend role\n\n%%Sensor role\n\nrole sensor(\n\tGen,User,Gwn,Sensor\t: agent,\n\tSND,RCV : channel(dy),\n\tH \t: hash_func\n\t)\n\nplayed_by Sensor def=\n\n\tlocal\n\t\tState : nat,\n\t\tTgwn,Tdel,Tchckj: nat,\n\t\tPWS,SId,Kgwns,TS6,TS5,TS3,TS2,TE,VI,TC1,DID,DIDgwn,Cgwn,PKSgwn,IDi,Cgwn1,Ki,Kj,C1,PKS1,REG,IDj,TCj,KEYij \t: text\n\n\tconst\n\t\tsp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id\n\n\tinit\n\t\tState := 2\n\n\ttransition\n\n\t%%Sensor Node registration\n\t\t\n\t\t1. State  = 2 /\\ RCV(start) =|> \n\t\t   State':= 3 /\\ TS2' := new() /\\ SId' := new() /\\ PWS' := new() \n\t\t   \t\t\t  /\\ VI' := H(TS2'.H(PWS'))\n\t\t   \t\t\t  /\\ SND(SId'.TS2'.VI')\n\t\t   \t\t\t  /\\ secret({PWS}, sp3, {Sensor, Gwn})\n\t\t   \t\t\t  /\\ witness(Sensor,Gwn,s_g_ts2,TS2')\n\n\t\t2. State  = 3 /\\ RCV(TS3'.REG') =|>\n\t\t   State':= 4 /\\ PWS' := new() /\\ secret({Kgwns}, sp4, {Gwn})\n\t\t   \t\t\t  /\\ TC1' := xor(REG', H(H(PWS').TS3')) \n\t\t   \t\t\t  /\\ request(Gwn,Sensor,g_s_ts3,TS3')\n\n    %%Authentication between gateway and sensor\n\t\t3. State  = 4 /\\ RCV(TS5'.DID'.DIDgwn'.Cgwn'.PKSgwn') =|>\n\t\t   State':= 5 /\\ SId' := new() /\\ TCj' := new() /\\ IDj' := new() /\\ TC1' := new() /\\ IDi' := xor(DIDgwn', H(DID'.TC1'.TS5'))\n\t\t   \t\t\t  /\\ Cgwn1' := H(IDj'.TCj'.TS5')\n\t\t   \t\t\t  /\\ Ki' := xor(PKSgwn',H(TC1'.TS5'))\n\t\t   \t\t\t  /\\ TS6' := new()\n\t\t   \t\t\t  /\\ Kj' := new()\n\t\t   \t\t\t  /\\ C1' := H(Kj'.IDi'.SId'.TS6')\n\t\t   \t\t\t  /\\ PKS1' := xor(Kj',H(Ki'.TS6'))\n\t\t   \t\t\t  /\\ SND(SId'.TS6'.C1'.PKS1')\n\t\t   \t\t\t  /\\ witness(Sensor,User,s_u_ts6,TS6')\n\t\t   \t\t\t  /\\ witness(Sensor,User,s_u_kj,Kj')\n\n    %%Receive session key from gateway through public channel\n\t\t4. State  = 5 /\\ RCV(H(xor(Ki', Kj'))) =|>\n\t\t   State' := 6 /\\ TS6' := new() /\\ KEYij' := H(xor(Ki', Kj'))\n\t\t              /\\ witness(Sensor,Gwn,s_g_ts6, TS6')\n\t\t              /\\ witness(Sensor,Gwn,s_g_kj, Kj')\nend role\n\n%%Sensor role\nrole session(\n\tGen,User,Gwn,Sensor : agent,\n\tH:hash_func)\n\n\tdef=\n\t\t\n\t\tlocal \n\t\t\tSNDU,RCVU,SNDG,RCVG,SNDS,RCVS: channel (dy)\n\n\t\tcomposition\n\t\t\tuser(Gen,User,Gwn,Sensor,SNDU,RCVU,H)\n  \t\t\t/\\ gateway(Gen,User,Gwn,Sensor,SNDG,RCVG,H)\n  \t\t\t/\\ sensor(Gen,User,Gwn,Sensor,SNDS,RCVS,H)\nend role\n\n%%Role for environment\nrole environment()\n\t\n\tdef=\n\n\t\tconst \n\t\t\ta,b,c,d: agent,\n\t\t\tu_g_ts4,u_g_k,sp2,g_u_te,u_g_ts1,g_s_ts5,s_g_ts6,sp3,sp4,s_g_ts2,g_s_ts3,s_u_ts6,s_u_kj,s_g_kj:protocol_id,\n\t\t\th:hash_func,\n\t\t\tt1,t2,t3:text\n\t\t\t%Kgwnu,Kgwns:public_key\n\n\n\tintruder_knowledge = {a,b,c,t1,t2,t3}\n\n\tcomposition\n\t\t   session(a,b,c,d,h)\n\t\t/\\ session(a,i,c,d,h) \n\t\t/\\ session(a,b,i,d,h)\n\t\t/\\ session(a,b,c,i,h)\n\nend role\n\ngoal\n\tsecrecy_of sp2, sp3, sp4\n\n\tauthentication_on u_g_ts4, u_g_ts1, u_g_k\n\tauthentication_on g_u_te, g_s_ts3, g_s_ts5\n\tauthentication_on s_g_ts2, s_u_kj, s_u_ts6, s_g_ts6, s_g_kj\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/AAAMobileIP.hlpsl",
        "incomplete": "%% PROTOCOL: AAA Mobile IP\n%%\n%% PURPOSE:\n%%   This document specifies a Diameter application that allows a Diameter\n%%   server to authenticate, authorise and collect accounting information\n%%   for Mobile IPv4 services rendered to a mobile node.\n%%\n%% REFERENCE:\n%%   \\begin{itemize}\n%%   \\item \\cite{mip4-rfc3012bis,aaa-diameter-mobileip}\n%%   \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Paul Hankes Drielsma, Information Security Group,  ETH Z\\\"{u}rich, December 2003\n%%   \\item Sebastian M\\\"odersheim, Information Security Group, ETH Z\\\"{u}rich, January 2004\n%%   \\item Luca Compagna, AI-Lab DIST, University of Genova, December 2004\n%%   \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. FA   -> MN:   FA,N_FA\n%% 2. MN   -> FA:   N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH\n%% 3. FA   -> AAAL: N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH\n%% 4. AAAL -> AAAH: N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH      \n%% 5. AAAH -> HA:   MN,\n%%                  {K_MnHa,K_FaHa}_KAAAHHa,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {MN,\n%%                   {K_MnHa,K_FaHa}_KAAAHHa,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH\n%%                  }_K_AAAHHa\n%% 6. HA   -> AAAH: {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_AAAHHa\n%% 7. AAAH -> AAAL: N_FA,\n%%                  {K_MnFa,K_FaHa}_K_AAAHAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {N_FA,\n%%                   {K_MnFa,K_FaHa}_K_AAAHAAAL,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_AAAHAAAL\n%% 8. AAAL -> FA:   N_FA,\n%%                  {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {N_FA,\n%%                   {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_FaAAAL\n%% 9. FA   -> MN:   {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%% \\end{verbatim}\n%% PROBLEMS: 7\n%% CLASSIFICATION: G1, G7, G10, G12\n%% ATTACKS:\n%% \\begin{verbatim}\n%% i      -> (mn,3): fa,fa\n%% (mn,3) -> i:      fa,mn,aaah,{fa,mn,aaah}k_mn_aaah\n%% i      -> (mn,3): {fa,mn,aaah}k_mn_aaah,{{fa,mn,aaah}k_mn_aaah}(mn,aaah)\n%% \\end{verbatim}\n%% In this type-flaw attack, the intruder replays the message \n%% \\verb+{fa,mn,aaah}k_mn_aaah+  to the mobile node, which expects to receive\n%% a message of the form \\verb+{fa,NewKey}k_mn_aaah+ where NewKey is the\n%% new key, which is thus matched with the pair of agent names \\verb+mn,aah+. \n%% Since the intruder knows these two agent names, he can also produce a \n%% message encrypted with this new key as required.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\n\nrole aaa_MIP_MN (MN, AAAH, FA : ____(PARAM_2)____,\n                 ____(PARAM_0)____, ____(PARAM_1)____     : channel(dy),\n                 K_MnAAAH     : symmetric_key)\nplayed_by MN\ndef=\n\n  local  State         : ____(VARIABLE_0)____,\n\t K_MnFa,K_MnHa : symmetric_key\n\n  init   State := 0\n\n  transition\n\n   1. State = ____(STATE_0)____\n      /\\ ____(MESSAGE_18)____(FA.FA)\n      =|> \n      State' := 1\n      /\\  Snd(____(MESSAGE_19)____.{FA.MN.AAAH}_K_MnAAAH) \n\n   2. State = ____(STATE_2)____\n      /\\ Rcv( {K_MnFa'.K_MnHa'}_K_MnAAAH.\n             {{K_MnFa'.K_MnHa'}_K_MnAAAH}_K_MnHa') \n      =|>  \n      State' := 2 \n      /\\ wrequest(MN,AAAH,k_mnha2,K_MnHa')\n      /\\ wrequest(MN,AAAH,k_mnfa2,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_FA (____(PARAM_5)____,AAAL,____(PARAM_3)____,____(PARAM_6)____: agent,\n                 ____(PARAM_4)____, Rcv: channel(dy),\n                 K_FaAAAL: symmetric_key)\nplayed_by FA\ndef=\n\n  local\n    State              : nat,\n    K_MnFa, K_FaHa     : symmetric_key,\n    SignedRegReq       : {agent.(agent.agent)}_symmetric_key,\n    KeyMnHaKeyMnFa     : {symmetric_key.symmetric_key}_symmetric_key,\n    SignKeyMnHaKeyMnFa : \n         {{symmetric_key.symmetric_key}_symmetric_key}_symmetric_key\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ ____(MESSAGE_20)____(start)\n      =|> \n      State' := 1\n      /\\ Snd(____(MESSAGE_21)____) \n\n   2. State = ____(STATE_3)____\n      /\\ ____(MESSAGE_22)____(FA.MN.AAAH.SignedRegReq')\n      =|> \n      State' := 2\n      /\\ Snd(____(MESSAGE_23)____) \n\t\n   3. State = ____(STATE_1)____\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n              KeyMnHaKeyMnFa'.SignKeyMnHaKeyMnFa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n               KeyMnHaKeyMnFa'.SignKeyMnHaKeyMnFa'}_K_FaAAAL)\n      =|>\n      State' := 3\n      /\\ Snd(____(MESSAGE_24)____) \n      /\\ wrequest(FA,AAAH,k_faha1,K_FaHa')\n      /\\ wrequest(FA,AAAH,k_mnfa1,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_3)____ (AAAL,____(PARAM_10)____,____(PARAM_7)____,MN: agent,\n                  ____(PARAM_8)____, Rcv: channel(____(PARAM_9)____),\n                  K_FaAAAL,K_AAAHAAAL: symmetric_key)\nplayed_by AAAL\ndef=\n\n  local\n    State                : nat,\n    K_MnFa,K_FaHa        : symmetric_key,\n    SignedRegReq         : {agent.(agent.agent)}_symmetric_key,\n    KeyMnFaKeyMnHa       : {symmetric_key.symmetric_key}_symmetric_key,\n    SignedKeyMnFaKeyMnHa : \n           {{symmetric_key.symmetric_key}_symmetric_key}_symmetric_key\n\n  init State := 0\n  \n  transition\n\n   1. State = 0\n      /\\ Rcv(____(MESSAGE_25)____)\n      =|> \n      State' := 1 \n      /\\ Snd(____(MESSAGE_26)____) \n\n   2. State = ____(STATE_4)____\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n              KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n               KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_AAAHAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAH (AAAH,____(PARAM_12)____,____(PARAM_11)____,____(PARAM_14)____,____(PARAM_13)____ : agent,\n           Snd, Rcv : channel(dy),\n           K_MnAAAH,\n           K_AAAHAAAL,\n           KAAAHHa : symmetric_key)\nplayed_by AAAH\ndef=\n\n  local  ____(VARIABLE_1)____                : nat,\n\t K_FaHa,K_MnHa,K_MnFa : symmetric_key\n\n  const  secFAHA, ____(VARIABLE_3)____, ____(VARIABLE_2)____   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State   = 0\n      /\\ ____(MESSAGE_27)____(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH)\n      =|> \n      State' := 1\n      /\\ K_MnHa' := new()\n      /\\ K_MnFa' := new()\n      /\\ K_FaHa' := new()\n      /\\ Snd( MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                 {K_MnFa'.K_MnHa'}_K_MnAAAH.\n                 {MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                     {K_MnFa'.K_MnHa'}_K_MnAAAH}_KAAAHHa)\n      /\\ ____(EVENT_1)____(AAAH,____(EVENT_0)____,k_faha1,K_FaHa')\n      /\\ witness(AAAH,____(EVENT_3)____,____(EVENT_2)____,K_FaHa')\n      /\\ witness(AAAH,____(EVENT_5)____,k_mnfa1,____(EVENT_4)____)\n      /\\ witness(AAAH,MN,____(EVENT_6)____,____(EVENT_7)____)\n      /\\ ____(EVENT_9)____(____(EVENT_8)____,MN,k_mnha2,K_MnHa')\n      /\\ ____(EVENT_10)____(AAAH,____(EVENT_11)____,k_mnha1,K_MnHa')\n\n   2. State = 1\n      /\\ Rcv( {K_MnFa.K_MnHa}_K_MnAAAH.\n              {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n               {{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_KAAAHHa)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n\t     {FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_K_AAAHAAAL)\t\n      /\\ secret(K_FaHa,____(EVENT_13)____,{FA,____(EVENT_12)____}) \n      /\\ ____(EVENT_15)____(K_MnFa,____(EVENT_14)____,{FA,MN})\n      /\\ secret(K_MnHa,____(EVENT_17)____,{____(EVENT_16)____,HA})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_HA (HA,AAAH,____(PARAM_17)____: ____(PARAM_16)____,\n                 Snd,____(PARAM_15)____: channel(dy),\n                 K_AAAHHa: symmetric_key)\nplayed_by HA\ndef=\n\n  local\n    State                 : nat,\n    K_MnFa,K_FaHa, K_MnHa : symmetric_key,\n    KeyMnFaKeyMnHa        : {symmetric_key.symmetric_key}_symmetric_key\n\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv( MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'.\n             {MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'}_K_AAAHHa) \n      =|> \n      State' := 1\n      /\\ Snd( KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'.\n             {KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'}_K_AAAHHa)\n      /\\ wrequest(HA,AAAH,k_faha2,K_FaHa')\n      /\\ wrequest(HA,AAAH,k_mnha1,K_MnHa')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_2)____(MN,FA,AAAL,AAAH,HA: ____(PARAM_21)____,\n\t     Kmn3ah,____(PARAM_18)____,____(PARAM_20)____,____(PARAM_19)____: ____(PARAM_22)____) def=\n\n   local     MNs,____(VARIABLE_4)____,\n\t     FAs,FAr,\n\t     Ls, Lr,\n\t     Hs, Hr,\n\t     HAs, HAr: channel(dy)\n\n   composition\n\n           aaa_MIP_MN(MN,AAAH,FA,MNs,MNr,Kmn3ah)\n\n        /\\ aaa_MIP_FA(FA,AAAL,AAAH,MN,FAs,FAr,Kfa3al)\n  \n        /\\ aaa_MIP_AAAL(AAAL,AAAH,FA,MN,Ls,Lr,Kfa3al,K3ah3al)\n\n        /\\ aaa_MIP_AAAH(AAAH,AAAL,HA,FA,MN,Hs,Hr,Kmn3ah,K3ah3al,Kha3ah)\n         \n        /\\ aaa_MIP_HA(HA,AAAH,MN,HAs,HAr,Kha3ah)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____() def=\n\n  const k_mnha1, ____(VARIABLE_6)____, k_faha1                    : ____(VARIABLE_5)____,\n        k_mnha2, k_mnfa2, k_faha2                    : protocol_id,\n        mn, fa, aaal, aaah, ha                       : agent,\n        k_mn_aaah, k_fa_aaal, k_aaah_aaal, k_ha_aaah : symmetric_key\n\n  intruder_knowledge = {mn,fa,aaal,aaah,ha}\n\n  composition\n\n\tsession(mn,fa,aaal,aaah,ha,\t                    %%% Agents\n\t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%\t/\\ session(i,mn,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_i_aaah,k_mn_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%     intruder_knowledge += {k_i_aaah}\n%%%\t/\\ session(mn,i,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_mn_aaah,k_i_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,i,aaah,ha,\t              %%% Agents\n%%% % \t\tk_mn_aaah,k_fa_i,k_aaah_i,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,aaal,i,ha,\t           %%% Agents\n%%% % \t\tk_mn_i,k_fa_aaal,k_i_aaal,k_ha_i)  %%% Shared Keys\n%%%\t/\\ session(mn,fa,aaal,aaah,i,\t                   %%% Agents\n%%% \t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_i_aaah)  %%% Shared Keys\n\nend role\n\n____(ROLE_0)____\n\n  %secrecy_of K_MnFa, K_FaHa, K_MnFa\n  secrecy_of secFAHA, secFAMN, secMNHA % addresses G12\n\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_faha1\n  weak_authentication_on k_faha1 % addresses G1,G7,G10\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_mnfa1\n  weak_authentication_on k_mnfa1 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_faha2\n  weak_authentication_on k_faha2 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_mnha1\n  weak_authentication_on k_mnha1 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnha2\n  weak_authentication_on k_mnha2 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnfa2\n  weak_authentication_on k_mnfa2 % addresses G1,G7,G10\n\nend goal\n\nenvironment()",
        "complete:": "%% PROTOCOL: AAA Mobile IP\n%%\n%% PURPOSE:\n%%   This document specifies a Diameter application that allows a Diameter\n%%   server to authenticate, authorise and collect accounting information\n%%   for Mobile IPv4 services rendered to a mobile node.\n%%\n%% REFERENCE:\n%%   \\begin{itemize}\n%%   \\item \\cite{mip4-rfc3012bis,aaa-diameter-mobileip}\n%%   \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Paul Hankes Drielsma, Information Security Group,  ETH Z\\\"{u}rich, December 2003\n%%   \\item Sebastian M\\\"odersheim, Information Security Group, ETH Z\\\"{u}rich, January 2004\n%%   \\item Luca Compagna, AI-Lab DIST, University of Genova, December 2004\n%%   \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. FA   -> MN:   FA,N_FA\n%% 2. MN   -> FA:   N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH\n%% 3. FA   -> AAAL: N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH\n%% 4. AAAL -> AAAH: N_FA,MN,AAAH,\n%%                  {N_FA,MN,AAAH}_K_MnAAAH      \n%% 5. AAAH -> HA:   MN,\n%%                  {K_MnHa,K_FaHa}_KAAAHHa,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {MN,\n%%                   {K_MnHa,K_FaHa}_KAAAHHa,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH\n%%                  }_K_AAAHHa\n%% 6. HA   -> AAAH: {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_AAAHHa\n%% 7. AAAH -> AAAL: N_FA,\n%%                  {K_MnFa,K_FaHa}_K_AAAHAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {N_FA,\n%%                   {K_MnFa,K_FaHa}_K_AAAHAAAL,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_AAAHAAAL\n%% 8. AAAL -> FA:   N_FA,\n%%                  {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa,\n%%                  {N_FA,\n%%                   {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                   {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                   {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%%                  }_K_FaAAAL\n%% 9. FA   -> MN:   {K_MnFa,K_FaHa}_K_FaAAAL,\n%%                  {K_MnFa,K_MnHa}_K_MnAAAH,\n%%                  {{K_MnFa,K_MnHa}_K_MnAAAH}_K_MnHa\n%% \\end{verbatim}\n%% PROBLEMS: 7\n%% CLASSIFICATION: G1, G7, G10, G12\n%% ATTACKS:\n%% \\begin{verbatim}\n%% i      -> (mn,3): fa,fa\n%% (mn,3) -> i:      fa,mn,aaah,{fa,mn,aaah}k_mn_aaah\n%% i      -> (mn,3): {fa,mn,aaah}k_mn_aaah,{{fa,mn,aaah}k_mn_aaah}(mn,aaah)\n%% \\end{verbatim}\n%% In this type-flaw attack, the intruder replays the message \n%% \\verb+{fa,mn,aaah}k_mn_aaah+  to the mobile node, which expects to receive\n%% a message of the form \\verb+{fa,NewKey}k_mn_aaah+ where NewKey is the\n%% new key, which is thus matched with the pair of agent names \\verb+mn,aah+. \n%% Since the intruder knows these two agent names, he can also produce a \n%% message encrypted with this new key as required.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%  HLPSL:\n\nrole aaa_MIP_MN (MN, AAAH, FA : agent,\n                 Snd, Rcv     : channel(dy),\n                 K_MnAAAH     : symmetric_key)\nplayed_by MN\ndef=\n\n  local  State         : nat,\n\t K_MnFa,K_MnHa : symmetric_key\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(FA.FA)\n      =|> \n      State' := 1\n      /\\  Snd(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH) \n\n   2. State = 1\n      /\\ Rcv( {K_MnFa'.K_MnHa'}_K_MnAAAH.\n             {{K_MnFa'.K_MnHa'}_K_MnAAAH}_K_MnHa') \n      =|>  \n      State' := 2 \n      /\\ wrequest(MN,AAAH,k_mnha2,K_MnHa')\n      /\\ wrequest(MN,AAAH,k_mnfa2,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_FA (FA,AAAL,AAAH,MN: agent,\n                 Snd, Rcv: channel(dy),\n                 K_FaAAAL: symmetric_key)\nplayed_by FA\ndef=\n\n  local\n    State              : nat,\n    K_MnFa, K_FaHa     : symmetric_key,\n    SignedRegReq       : {agent.(agent.agent)}_symmetric_key,\n    KeyMnHaKeyMnFa     : {symmetric_key.symmetric_key}_symmetric_key,\n    SignKeyMnHaKeyMnFa : \n         {{symmetric_key.symmetric_key}_symmetric_key}_symmetric_key\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Snd(FA.FA) \n\n   2. State = 1\n      /\\ Rcv(FA.MN.AAAH.SignedRegReq')\n      =|> \n      State' := 2\n      /\\ Snd(FA.MN.AAAH.SignedRegReq') \n\t\n   3. State = 2\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n              KeyMnHaKeyMnFa'.SignKeyMnHaKeyMnFa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n               KeyMnHaKeyMnFa'.SignKeyMnHaKeyMnFa'}_K_FaAAAL)\n      =|>\n      State' := 3\n      /\\ Snd(KeyMnHaKeyMnFa'.SignKeyMnHaKeyMnFa') \n      /\\ wrequest(FA,AAAH,k_faha1,K_FaHa')\n      /\\ wrequest(FA,AAAH,k_mnfa1,K_MnFa')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAL (AAAL,AAAH,FA,MN: agent,\n                  Snd, Rcv: channel(dy),\n                  K_FaAAAL,K_AAAHAAAL: symmetric_key)\nplayed_by AAAL\ndef=\n\n  local\n    State                : nat,\n    K_MnFa,K_FaHa        : symmetric_key,\n    SignedRegReq         : {agent.(agent.agent)}_symmetric_key,\n    KeyMnFaKeyMnHa       : {symmetric_key.symmetric_key}_symmetric_key,\n    SignedKeyMnFaKeyMnHa : \n           {{symmetric_key.symmetric_key}_symmetric_key}_symmetric_key\n\n  init State := 0\n  \n  transition\n\n   1. State = 0\n      /\\ Rcv(FA.MN.AAAH.SignedRegReq')\n      =|> \n      State' := 1 \n      /\\ Snd(FA.MN.AAAH. SignedRegReq') \n\n   2. State = 1\n      /\\ Rcv( FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n              KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n              {FA.{K_MnFa'.K_FaHa'}_K_AAAHAAAL.\n               KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_AAAHAAAL)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'.\n             {FA.{K_MnFa'.K_FaHa'}_K_FaAAAL.\n                 KeyMnFaKeyMnHa'.SignedKeyMnFaKeyMnHa'}_K_FaAAAL)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_AAAH (AAAH,AAAL,HA,FA,MN : agent,\n           Snd, Rcv : channel(dy),\n           K_MnAAAH,\n           K_AAAHAAAL,\n           KAAAHHa : symmetric_key)\nplayed_by AAAH\ndef=\n\n  local  State                : nat,\n\t K_FaHa,K_MnHa,K_MnFa : symmetric_key\n\n  const  secFAHA, secFAMN, secMNHA   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State   = 0\n      /\\ Rcv(FA.MN.AAAH.{FA.MN.AAAH}_K_MnAAAH)\n      =|> \n      State' := 1\n      /\\ K_MnHa' := new()\n      /\\ K_MnFa' := new()\n      /\\ K_FaHa' := new()\n      /\\ Snd( MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                 {K_MnFa'.K_MnHa'}_K_MnAAAH.\n                 {MN.{K_MnHa'.K_FaHa'}_KAAAHHa.\n                     {K_MnFa'.K_MnHa'}_K_MnAAAH}_KAAAHHa)\n      /\\ witness(AAAH,FA,k_faha1,K_FaHa')\n      /\\ witness(AAAH,HA,k_faha2,K_FaHa')\n      /\\ witness(AAAH,FA,k_mnfa1,K_MnFa')\n      /\\ witness(AAAH,MN,k_mnfa2,K_MnFa')\n      /\\ witness(AAAH,MN,k_mnha2,K_MnHa')\n      /\\ witness(AAAH,HA,k_mnha1,K_MnHa')\n\n   2. State = 1\n      /\\ Rcv( {K_MnFa.K_MnHa}_K_MnAAAH.\n              {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n               {{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_KAAAHHa)\n      =|>\n      State' := 2\n      /\\ Snd( FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa.\n\t     {FA.{K_MnFa.K_FaHa}_K_AAAHAAAL.{K_MnFa.K_MnHa}_K_MnAAAH.\n                {{K_MnFa.K_MnHa}_K_MnAAAH}_K_MnHa}_K_AAAHAAAL)\t\n      /\\ secret(K_FaHa,secFAHA,{FA,HA}) \n      /\\ secret(K_MnFa,secFAMN,{FA,MN})\n      /\\ secret(K_MnHa,secMNHA,{MN,HA})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_MIP_HA (HA,AAAH,MN: agent,\n                 Snd,Rcv: channel(dy),\n                 K_AAAHHa: symmetric_key)\nplayed_by HA\ndef=\n\n  local\n    State                 : nat,\n    K_MnFa,K_FaHa, K_MnHa : symmetric_key,\n    KeyMnFaKeyMnHa        : {symmetric_key.symmetric_key}_symmetric_key\n\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv( MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'.\n             {MN.{K_MnHa'.K_FaHa'}_K_AAAHHa.KeyMnFaKeyMnHa'}_K_AAAHHa) \n      =|> \n      State' := 1\n      /\\ Snd( KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'.\n             {KeyMnFaKeyMnHa'.{KeyMnFaKeyMnHa'}_K_MnHa'}_K_AAAHHa)\n      /\\ wrequest(HA,AAAH,k_faha2,K_FaHa')\n      /\\ wrequest(HA,AAAH,k_mnha1,K_MnHa')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(MN,FA,AAAL,AAAH,HA: agent,\n\t     Kmn3ah,Kfa3al,K3ah3al,Kha3ah: symmetric_key) def=\n\n   local     MNs,MNr,\n\t     FAs,FAr,\n\t     Ls, Lr,\n\t     Hs, Hr,\n\t     HAs, HAr: channel(dy)\n\n   composition\n\n           aaa_MIP_MN(MN,AAAH,FA,MNs,MNr,Kmn3ah)\n\n        /\\ aaa_MIP_FA(FA,AAAL,AAAH,MN,FAs,FAr,Kfa3al)\n  \n        /\\ aaa_MIP_AAAL(AAAL,AAAH,FA,MN,Ls,Lr,Kfa3al,K3ah3al)\n\n        /\\ aaa_MIP_AAAH(AAAH,AAAL,HA,FA,MN,Hs,Hr,Kmn3ah,K3ah3al,Kha3ah)\n         \n        /\\ aaa_MIP_HA(HA,AAAH,MN,HAs,HAr,Kha3ah)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const k_mnha1, k_mnfa1, k_faha1                    : protocol_id,\n        k_mnha2, k_mnfa2, k_faha2                    : protocol_id,\n        mn, fa, aaal, aaah, ha                       : agent,\n        k_mn_aaah, k_fa_aaal, k_aaah_aaal, k_ha_aaah : symmetric_key\n\n  intruder_knowledge = {mn,fa,aaal,aaah,ha}\n\n  composition\n\n\tsession(mn,fa,aaal,aaah,ha,\t                    %%% Agents\n\t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%\t/\\ session(i,mn,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_i_aaah,k_mn_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%%     intruder_knowledge += {k_i_aaah}\n%%%\t/\\ session(mn,i,aaal,aaah,ha,\t%%% Agents\n%%%\t\tk_mn_aaah,k_i_aaal,k_aaah_aaal,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,i,aaah,ha,\t              %%% Agents\n%%% % \t\tk_mn_aaah,k_fa_i,k_aaah_i,k_ha_aaah)  %%% Shared Keys\n%%% % necessarily flawed:\n%%% %\t/\\ session(mn,fa,aaal,i,ha,\t           %%% Agents\n%%% % \t\tk_mn_i,k_fa_aaal,k_i_aaal,k_ha_i)  %%% Shared Keys\n%%%\t/\\ session(mn,fa,aaal,aaah,i,\t                   %%% Agents\n%%% \t\tk_mn_aaah,k_fa_aaal,k_aaah_aaal,k_i_aaah)  %%% Shared Keys\n\nend role\n\ngoal\n\n  %secrecy_of K_MnFa, K_FaHa, K_MnFa\n  secrecy_of secFAHA, secFAMN, secMNHA % addresses G12\n\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_faha1\n  weak_authentication_on k_faha1 % addresses G1,G7,G10\n  %AAA_MIP_FA weakly authenticates AAA_MIP_AAAH on k_mnfa1\n  weak_authentication_on k_mnfa1 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_faha2\n  weak_authentication_on k_faha2 % addresses G1,G7,G10\n  %AAA_MIP_HA weakly authenticates AAA_MIP_AAAH on k_mnha1\n  weak_authentication_on k_mnha1 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnha2\n  weak_authentication_on k_mnha2 % addresses G1,G7,G10\n  %AAA_MIP_MN weakly authenticates AAA_MIP_AAAH on k_mnfa2\n  weak_authentication_on k_mnfa2 % addresses G1,G7,G10\n\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/AKS.hlpsl",
        "incomplete": "____(ROLE_0)____ ____(ROLE_1)____(\n  OBU1,____(PARAM_2)____,____(PARAM_3)____                   : ____(PARAM_5)____,\n  ____(PARAM_1)____,PID2,P                      : text,\n  ____(PARAM_6)____,PUF1                : ____(PARAM_0)____,\n  SND,RCV                  : channel(____(PARAM_4)____))\nplayed_by OBU1 def=\n  \n  local\n    State        :____(VARIABLE_0)____,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ ____(EVENT_1)____(OBU1,SN,____(EVENT_0)____,MAC')\n  2. State = ____(STATE_1)____ /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ ____(EVENT_3)____(OBU1,____(EVENT_2)____,o1_o2_h12,H12') /\\ request(____(EVENT_4)____,____(EVENT_5)____,o2_o1_h21,H21') /\\ secret(A1,____(EVENT_7)____,{____(EVENT_6)____,____(EVENT_8)____,SN}) /\\ secret(____(EVENT_9)____,r1,{____(EVENT_10)____,OBU2,____(EVENT_11)____})\n\nend ____(ROLE_2)____\n\nrole role_OBU2(\n  OBU1,____(PARAM_7)____,SN                   : ____(PARAM_8)____,\n  ____(PARAM_11)____,P                      : text,\n  H,____(PARAM_10)____                : ____(PARAM_9)____,\n  SND,RCV                  : channel(____(PARAM_12)____))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(____(EVENT_12)____,OBU2,____(EVENT_13)____,H21')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ ____(EVENT_16)____(R1,r1,{____(EVENT_15)____,OBU2,____(EVENT_14)____}) /\\ secret(____(EVENT_19)____,r2,{OBU1,____(EVENT_17)____,____(EVENT_18)____}) /\\____(EVENT_21)____(____(EVENT_22)____,____(EVENT_20)____,{OBU1,OBU2,SN}) /\\ request(____(EVENT_24)____,SN,s_o2_hs2,____(EVENT_23)____) /\\ ____(EVENT_26)____(OBU2,____(EVENT_25)____,o1_o2_h12,H12')\n\nend role\n\n\n\nrole role_SN(\n  ____(PARAM_17)____,OBU2,____(PARAM_19)____                   : agent,\n  PID1,____(PARAM_13)____,C1,C2,____(PARAM_20)____                   : text,\n  H,PUF1,____(PARAM_16)____                : hash_func,\n  ____(PARAM_15)____,____(PARAM_14)____                  : channel(____(PARAM_18)____))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = ____(STATE_0)____ /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,____(EVENT_27)____,____(EVENT_28)____,Hs2') /\\ request(____(EVENT_29)____,OBU1,____(EVENT_30)____,MAC') /\\ ____(EVENT_33)____(R1,____(EVENT_32)____,{OBU1,____(EVENT_31)____,SN}) /\\ ____(EVENT_34)____(____(EVENT_35)____,r2,{OBU1,____(EVENT_36)____,SN})\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : ____(PARAM_22)____,\n  ____(PARAM_21)____,PID2,C1,____(PARAM_26)____,____(PARAM_24)____          : ____(PARAM_27)____,\n  H,____(PARAM_23)____,____(PARAM_25)____                : hash_func)\ndef=\n  local ____(VARIABLE_2)____,SS,RO,RS : channel(____(VARIABLE_1)____)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    ____(VARIABLE_5)____,____(VARIABLE_3)____,____(VARIABLE_6)____,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,____(VARIABLE_4)____  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of ____(GOAL_37)____\n  ____(GOAL_38)____ r2\n  ____(GOAL_39)____ a1\n  ____(GOAL_40)____ a2\n  authentication_on ____(GOAL_41)____\n  ____(GOAL_42)____ s_o2_hs2\nend goal\n\nenvironment()",
        "complete:": "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1',r1,{OBU1,OBU2,SN})\n\nend role\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,OBU2,o2_o1_h21,H21')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(OBU2,SN,s_o2_hs2,Hs2) /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2,P                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,SS,RO,RS : channel(dy)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,a1,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of a1\n  secrecy_of a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl",
        "incomplete": "____(ROLE_0)____ user (U, ____(PARAM_0)____, F: ____(PARAM_2)____, Kus, ____(PARAM_4)____, Kas: ____(PARAM_3)____, Ks: public_key, H, ____(PARAM_7)____: ____(PARAM_1)____, ____(PARAM_5)____, ____(PARAM_6)____: channel (dy))\nplayed_by U def=\n\n  local ____(VARIABLE_0)____: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = ____(STATE_0)____ /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{____(EVENT_0)____,____(EVENT_1)____})\n\t\t   /\\ ____(EVENT_2)____(SAim',g2,{U,____(EVENT_3)____})\n\t\t   /\\ ____(EVENT_4)____(SPWim',g3,{____(EVENT_5)____})\n\n\t2.  State = ____(STATE_1)____ /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = ____(STATE_3)____ /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ ____(EVENT_7)____(U,____(EVENT_6)____,u_s_tim,Tim')\n\n\t4.  State = ____(STATE_2)____ /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ ____(EVENT_8)____(S,____(EVENT_9)____,s_u_b1mi,B1mi')\n\nend ____(ROLE_2)____\n\nrole server (U, ____(PARAM_13)____, ____(PARAM_11)____: agent, ____(PARAM_8)____, Rus, Kas: symmetric_key, ____(PARAM_10)____: ____(PARAM_14)____, ____(PARAM_15)____, Mul: hash_func, ____(PARAM_12)____, RCV: channel (____(PARAM_9)____))\nplayed_by S def=\n\n  local ____(VARIABLE_1)____: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{____(EVENT_10)____,____(EVENT_11)____})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,____(EVENT_13)____,____(EVENT_12)____)\n\t\t   /\\ ____(EVENT_14)____(S,U,____(EVENT_15)____,B1mi')\n\nend role\n\nrole foreign (U, S, ____(PARAM_18)____: ____(PARAM_17)____, ____(PARAM_19)____, Rus, ____(PARAM_20)____: ____(PARAM_23)____, Ks: ____(PARAM_21)____, ____(PARAM_22)____, Mul: hash_func, ____(PARAM_16)____, RCV: channel (dy))\nplayed_by F def=\n\n  local ____(VARIABLE_2)____: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ ____(EVENT_16)____(Nfp',____(EVENT_17)____,{U,____(EVENT_18)____,F})\n\t\t   /\\ ____(EVENT_20)____(Nfp1',____(EVENT_21)____,{U,____(EVENT_19)____,F})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (____(PARAM_25)____, S, F: agent, ____(PARAM_28)____, ____(PARAM_29)____, ____(PARAM_27)____: ____(PARAM_26)____, Ks: public_key, H, ____(PARAM_24)____: hash_func) def=\n\n  local ____(VARIABLE_3)____, RU, SS, RS, ____(VARIABLE_5)____, ____(VARIABLE_4)____: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const ____(VARIABLE_7)____, s, f: ____(VARIABLE_6)____,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\n____(ROLE_1)____\n\n  ____(GOAL_24)____ g1, g2, ____(GOAL_22)____, ____(GOAL_23)____, g5, g6\n  authentication_on ____(GOAL_25)____, s_u_b1mi\n\nend goal\n\nenvironment()",
        "complete:": "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ secret(SAim',g2,{U,S})\n\t\t   /\\ secret(SPWim',g3,{U})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ witness(U,S,u_s_tim,Tim')\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ secret(Nfp',g5,{U,S,F})\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/An_Anonymous_Key_Distribution_Scheme_for_Group_Healthcare_Services_in_5G-Enabled_Multi-Server_Environments.hlpsl",
        "incomplete": "____(ROLE_0)____ ____(ROLE_1)____ (____(PARAM_2)____, S: ____(PARAM_5)____, Kus, SKij: ____(PARAM_8)____, ____(PARAM_7)____: ____(PARAM_0)____, ____(PARAM_1)____, H4, H5, Sub, Add, ____(PARAM_6)____: hash_func, ____(PARAM_3)____, ____(PARAM_4)____: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1.  State = ____(STATE_2)____ /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new() /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(____(EVENT_0)____,____(EVENT_1)____,{U}) /\\ ____(EVENT_2)____(IDi,g2,{____(EVENT_3)____,S}) /\\ secret(____(EVENT_5)____,g3,{____(EVENT_4)____}) /\\ ____(EVENT_6)____(Bi,____(EVENT_7)____,{U})\n2.  State = ____(STATE_0)____ /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi & Bi in the smart card %/\\ Store Ej', IDj, & Nj in the USB\n% Login and authentication phase\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card %/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose bij = 3\n/\\ N' := H(H(H(V'))) /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) /\\ Yij' := xor(E,Ej) /\\ Tu' := new() /\\ A' := xor(xor(BBi',W'),Tu') /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,____(EVENT_8)____,____(EVENT_9)____) /\\ ____(EVENT_10)____(U,____(EVENT_11)____,u_s_tu,Tu')\n/\\ ____(EVENT_12)____(IDi,g2,{U,____(EVENT_13)____}) /\\ ____(EVENT_15)____(PWi,g3,{____(EVENT_14)____}) /\\ ____(EVENT_17)____(Bi,____(EVENT_16)____,{U})\n4.  State = ____(STATE_1)____ /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts' %/\\ Confirm B %/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts') /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ request(____(EVENT_18)____,U,____(EVENT_19)____,Ts')\nend role\nrole server (____(PARAM_12)____, ____(PARAM_16)____: agent, ____(PARAM_13)____, ____(PARAM_9)____: symmetric_key, Ks: public_key, ____(PARAM_11)____, H4, ____(PARAM_15)____, Sub, Add, ____(PARAM_14)____: ____(PARAM_10)____, SND, ____(PARAM_17)____: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, X, Y, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({IDi.Nj.Yij'}_Kus)\n/\\ secret(____(EVENT_20)____,g5,{____(EVENT_21)____})\n% Login and authentication phase\n2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu' %/\\ Use Xj to decrypt Yij %/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi.W).Tu')\n%/\\ Confirm A\n/\\ Ts' := new() /\\ B' := xor(H(H(H(H(V')))),Ts') /\\ IDinew' := H(Yij.IDi.H(Xj)) /\\ SKij' := H(xor(H(H(H(V'))),Yij)) /\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion. The server calculates ck0 and hide it into the following multiple equations, in which C1, C2 and C3 are predetermined, and Hj is equal to H4(skij||T2).\n/\\ C1' := new() /\\ C2' := new() /\\ C3' := new() /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3'))) /\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ witness(S,U,____(EVENT_22)____,____(EVENT_23)____)\n/\\ request(U,S,____(EVENT_24)____,____(EVENT_25)____) /\\ request(____(EVENT_26)____,____(EVENT_27)____,u_s_tu,Tu')\nend role\nrole session (U, S: ____(PARAM_24)____, ____(PARAM_21)____, SKij: ____(PARAM_22)____, ____(PARAM_18)____: ____(PARAM_19)____, H, H4, H5, Sub, ____(PARAM_20)____, Mul: ____(PARAM_23)____) def=\nlocal SU, ____(VARIABLE_0)____, ____(VARIABLE_1)____, RS: channel (dy)\ncomposition\nuser (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SU,RU) /\\ server (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SS,RS)\nend role\nrole environment() def=\nconst ____(VARIABLE_2)____, ____(VARIABLE_3)____: agent,\nkus, skij, kui: symmetric_key,\nks, ki: public_key,\nh, h4, h5, sub, add, mul: hash_func,\nu_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5: protocol_id\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\ncomposition\nsession(u,s,kus,skij,ks,h,h4,h5,sub,add,mul) /\\ session(u,i,kui,kui,ks,h,h4,h5,sub,add,mul) /\\ session(i,s,kui,kui,ks,h,h4,h5,sub,add,mul)\nend role\ngoal\nsecrecy_of g1, ____(GOAL_28)____, ____(GOAL_30)____, g4, ____(GOAL_29)____\n____(GOAL_32)____ u_s_v, ____(GOAL_31)____, s_u_ts\nend goal\nenvironment()",
        "complete:": "role user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new() /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(E',g1,{U}) /\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi & Bi in the smart card %/\\ Store Ej', IDj, & Nj in the USB\n% Login and authentication phase\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card %/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose bij = 3\n/\\ N' := H(H(H(V'))) /\\ BBi' := H(PWi.Bi) /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) /\\ Yij' := xor(E,Ej) /\\ Tu' := new() /\\ A' := xor(xor(BBi',W'),Tu') /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_v,V') /\\ witness(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts' %/\\ Confirm B %/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts') /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n/\\ request(S,U,s_u_ts,Ts')\nend role\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Ck0, E, Ej, X, Y, Xj, V, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, C1, C2, C3: message\ninit State := 0\ntransition\n% Registration phase\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({IDi.Nj.Yij'}_Kus)\n/\\ secret(Xj,g5,{S})\n% Login and authentication phase\n2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu' %/\\ Use Xj to decrypt Yij %/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi.W).Tu')\n%/\\ Confirm A\n/\\ Ts' := new() /\\ B' := xor(H(H(H(H(V')))),Ts') /\\ IDinew' := H(Yij.IDi.H(Xj)) /\\ SKij' := H(xor(H(H(H(V'))),Yij)) /\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion. The server calculates ck0 and hide it into the following multiple equations, in which C1, C2 and C3 are predetermined, and Hj is equal to H4(skij||T2).\n/\\ C1' := new() /\\ C2' := new() /\\ C3' := new() /\\ Ck0' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3'))) /\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_v,V') /\\ request(U,S,u_s_tu,Tu')\nend role\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H4, H5, Sub, Add, Mul: hash_func) def=\nlocal SU, RU, SS, RS: channel (dy)\ncomposition\nuser (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SU,RU) /\\ server (U,S,Kus,SKij,Ks,H,H4,H5,Sub,Add,Mul,SS,RS)\nend role\nrole environment() def=\nconst u, s: agent,\nkus, skij, kui: symmetric_key,\nks, ki: public_key,\nh, h4, h5, sub, add, mul: hash_func,\nu_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5: protocol_id\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\ncomposition\nsession(u,s,kus,skij,ks,h,h4,h5,sub,add,mul) /\\ session(u,i,kui,kui,ks,h,h4,h5,sub,add,mul) /\\ session(i,s,kui,kui,ks,h,h4,h5,sub,add,mul)\nend role\ngoal\nsecrecy_of g1, g2, g3, g4, g5\nauthentication_on u_s_v, u_s_tu, s_u_ts\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/An_Autonomous_Log_Storage_Management_Protocol_with_Blockchain_Mechanism_and_Access_Control_for_the_Internet_of_Things.hlpsl",
        "incomplete": "____(ROLE_2)____ ____(ROLE_0)____ (____(PARAM_1)____, ____(PARAM_7)____, ____(PARAM_2)____: ____(PARAM_6)____, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: ____(PARAM_3)____, ____(PARAM_0)____, ____(PARAM_4)____: channel (____(PARAM_5)____))\nplayed_by U def=\nlocal State: ____(VARIABLE_0)____,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1.  State = ____(STATE_0)____ /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new() /\\ SND({IDi'}_Kau) /\\ secret(____(EVENT_0)____,____(EVENT_1)____,{A,U})\n2.  State = ____(STATE_1)____ /\\ RCV({exp(G,Add(Alpha'.TIDi'))}_Kau) =|>\nState':= 2\n%/\\ Store SK % Log verification phase\n3.  State = 0 /\\ RCV(exp(G,Ss').Mul(M.exp(Y,Ss')).({X'.IP.T}_inv(ECDSA))) =|>\nState':= 1\n%/\\ Use ECDSA to verify ECDSA signature %/\\ Use Y and C = Mul(M.exp(Y,S)) to verify log signature\n/\\ ____(EVENT_2)____(S,U,ss,____(EVENT_3)____)\n% Log unsigncryption phase\n/\\ Ys' := Pair(SK.exp(G,Ss'))\n%/\\ Use Ys to decytp C and obtain view the log data M\nend role\n\nrole authority (____(PARAM_11)____, S, U: ____(PARAM_12)____, ____(PARAM_14)____: symmetric_key, ECDSA: ____(PARAM_8)____, ____(PARAM_15)____, Add, ____(PARAM_13)____, Pair: ____(PARAM_10)____, SND, RCV: channel (____(PARAM_9)____))\nplayed_by A def=\nlocal ____(VARIABLE_1)____: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1. State = 0 /\\ RCV({IDi'}_Kau) =|>\nState':= 1\n%/\\ Verify IDi\n/\\ Alpha' := new() /\\ TIDi' := new() /\\ SK' := exp(G,Add(Alpha'.TIDi'))\n%/\\ The value SK' is computed for three attributes A, B, C\n/\\ SND({SK'}_Kau)\n/\\ ____(EVENT_5)____(SK',____(EVENT_4)____,{U,A}) /\\ ____(EVENT_6)____(Alpha',alpha,{____(EVENT_7)____})\nend role\n\nrole sensor (A, ____(PARAM_20)____, U: agent, Kau: ____(PARAM_23)____, ____(PARAM_21)____: ____(PARAM_19)____, ____(PARAM_18)____, ____(PARAM_22)____, ____(PARAM_17)____, Pair: ____(PARAM_16)____, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: ____(VARIABLE_2)____,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% Log signcryption phase\n1. State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ Ss' := new() %/\\ Choose Ss for computation of three attributes A, B, C; M is the log data\n/\\ Ce' := exp(G,Ss') /\\ C' := Mul(M.exp(Y,Ss')) /\\ Hs' := H(C') /\\ X' := exp(Hs',Mul(Y.Ss')) %/\\ X: log signature\n/\\ Sig' := {X'.IP.T}_inv(ECDSA) %/\\ IP: IP adrress of the Sensor; T: timestamp\n/\\ SND(Ce'.C'.Sig')\n/\\ ____(EVENT_8)____(Ss',____(EVENT_9)____,{S})\n/\\ witness(S,U,____(EVENT_10)____,____(EVENT_11)____)\nend role\n\nrole session (____(PARAM_27)____, ____(PARAM_26)____, U: agent, Kau: symmetric_key, ____(PARAM_28)____: public_key, ____(PARAM_24)____, Add, ____(PARAM_29)____, Pair: ____(PARAM_25)____) def=\nlocal ____(VARIABLE_4)____, RA, SS, ____(VARIABLE_3)____, SU, ____(VARIABLE_5)____: channel (dy)\ncomposition\nauthority (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SA,RA) /\\ sensor (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SS,RS)\n/\\ user (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SU,RU)\nend role\n\nrole environment() def=\nconst ____(VARIABLE_6)____, ____(VARIABLE_8)____, ____(VARIABLE_7)____, i: agent,\nkau, kui: symmetric_key,\necdsa, ki: public_key,\nh, add, mul, pair: hash_func,\nidi, sk, alpha, ss: protocol_id\nintruder_knowledge = {a,s,u,ki,inv(ki)}\ncomposition\nsession(a,s,u,kau,ecdsa,h,add,mul,pair) /\\ session(i,s,u,kui,ecdsa,h,add,mul,pair)\n/\\ session(a,i,u,kui,ecdsa,h,add,mul,pair) /\\ session(a,s,i,kui,ecdsa,h,add,mul,pair)\nend role\n____(ROLE_1)____\n____(GOAL_13)____ idi, ____(GOAL_12)____, alpha, ss\nauthentication_on ____(GOAL_14)____\nend goal\nenvironment()",
        "complete:": "role user (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new() /\\ SND({IDi'}_Kau) /\\ secret(IDi',idi,{A,U})\n2.  State = 1 /\\ RCV({exp(G,Add(Alpha'.TIDi'))}_Kau) =|>\nState':= 2\n%/\\ Store SK % Log verification phase\n3.  State = 0 /\\ RCV(exp(G,Ss').Mul(M.exp(Y,Ss')).({X'.IP.T}_inv(ECDSA))) =|>\nState':= 1\n%/\\ Use ECDSA to verify ECDSA signature %/\\ Use Y and C = Mul(M.exp(Y,S)) to verify log signature\n/\\ request(S,U,ss,Ss')\n% Log unsigncryption phase\n/\\ Ys' := Pair(SK.exp(G,Ss'))\n%/\\ Use Ys to decytp C and obtain view the log data M\nend role\n\nrole authority (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by A def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% User registration phase\n1. State = 0 /\\ RCV({IDi'}_Kau) =|>\nState':= 1\n%/\\ Verify IDi\n/\\ Alpha' := new() /\\ TIDi' := new() /\\ SK' := exp(G,Add(Alpha'.TIDi'))\n%/\\ The value SK' is computed for three attributes A, B, C\n/\\ SND({SK'}_Kau)\n/\\ secret(SK',sk,{U,A}) /\\ secret(Alpha',alpha,{A})\nend role\n\nrole sensor (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\nlocal State: nat,\nIDi, TIDi, Ys, Alpha, SK, Ss, Ce, C, Hs, Sig, G, M, Y, X, IP, T: text\ninit State := 0\ntransition\n% Log signcryption phase\n1. State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ Ss' := new() %/\\ Choose Ss for computation of three attributes A, B, C; M is the log data\n/\\ Ce' := exp(G,Ss') /\\ C' := Mul(M.exp(Y,Ss')) /\\ Hs' := H(C') /\\ X' := exp(Hs',Mul(Y.Ss')) %/\\ X: log signature\n/\\ Sig' := {X'.IP.T}_inv(ECDSA) %/\\ IP: IP adrress of the Sensor; T: timestamp\n/\\ SND(Ce'.C'.Sig')\n/\\ secret(Ss',ss,{S})\n/\\ witness(S,U,ss,Ss')\nend role\n\nrole session (A, S, U: agent, Kau: symmetric_key, ECDSA: public_key, H, Add, Mul, Pair: hash_func) def=\nlocal SA, RA, SS, RS, SU, RU: channel (dy)\ncomposition\nauthority (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SA,RA) /\\ sensor (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SS,RS)\n/\\ user (A,S,U,Kau,ECDSA,H,Add,Mul,Pair,SU,RU)\nend role\n\nrole environment() def=\nconst a, s, u, i: agent,\nkau, kui: symmetric_key,\necdsa, ki: public_key,\nh, add, mul, pair: hash_func,\nidi, sk, alpha, ss: protocol_id\nintruder_knowledge = {a,s,u,ki,inv(ki)}\ncomposition\nsession(a,s,u,kau,ecdsa,h,add,mul,pair) /\\ session(i,s,u,kui,ecdsa,h,add,mul,pair)\n/\\ session(a,i,u,kui,ecdsa,h,add,mul,pair) /\\ session(a,s,i,kui,ecdsa,h,add,mul,pair)\nend role\ngoal\nsecrecy_of idi, sk, alpha, ss\nauthentication_on ss\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/Auth-protocol.hlpsl",
        "incomplete": "%%% Start of protocol\nrole ____(ROLE_1)____ (____(PARAM_2)____, ____(PARAM_1)____: agent, ____(PARAM_3)____: symmetric_key, ____(PARAM_0)____,RCV: channel(dy))  \nplayed_by ED\ndef=\n\tlocal\n\t\t____(VARIABLE_0)____:nat,\n\t\tIDu, PWu, Bu, Aa, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,____(VARIABLE_1)____, sp3, a, ____(VARIABLE_2)____, bprime, ____(VARIABLE_3)____, ____(VARIABLE_4)____\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n\t1. State = ____(STATE_1)____  /\\  RCV(start) =|> \n        State' := 1  /\\  M' := H(IDu.Bu) \n\t/\\ Aa' := new()\n\t/\\ TW' := H(xor(Aa,H(Bu.PWu)))\n%%%% Identity is Shared BETWEEN ED and NAD\n\t/\\  ____(EVENT_1)____({____(EVENT_0)____}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  ____(EVENT_3)____({PWu,Bu}, sp2, {____(EVENT_2)____})\n%%%%Send Registration Request to NAD\n\t/\\  SND({IDu.M'.TW'}_SKus)\n%%%% Receive Registration Reply to NAD\n\t2. State=1 /\\ RCV({PIDr'.Du.Yu.Fu.Zu}_SKus) =|>  \n%%%% Master key s is only known to NAD\n\tState' := 3 /\\  ____(EVENT_4)____({____(EVENT_5)____}, sp3, {NAD})\n%%%% Authentication and Key Exchange Phase (Public Channel)\n\t/\\ Fu' := H(IDu.TW)\n\t/\\ Cu' :=  new() \n%%%% Here we assume that H(IDu.Ss)= AB'\n\t/\\  AB' := xor(Du, H(IDu.TW))\n\t/\\ Buj'  := xor(xor(xor(Zu,H(IDj.Cu')),TW),H(PIDr'.H(IDu.Ss)))\n\t/\\ Xu' := xor(Yu, H(M.TW))\n\t/\\ DIDu' := H(PIDr'.Xu.Cu')\n%%% Send login request message M1 to NAD \n\t/\\ SND(PIDr'.DIDu'.Buj'.Cu')\n%%% U has freshly generated random number\n\t/\\ ____(EVENT_7)____(ED, NAD, cu, ____(EVENT_6)____)\n%%% Receive Authentication message from NAD\n\t3. State=3 /\\ RCV(Quj. Tu. Dj\t) =|> \n\tState' := 5 /\\  Dj' := new() /\\ PIDr' := new() \n\t/\\ Quj' := H(H(IDu.Ss).Tu.Cu.Dj.Xu.IDj)\n\t/\\ SKuj' := H(H(IDu.Ss). Cu. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\n\t/\\ PIDrprime' := xor(Tu, H(PIDr'.H(IDu.Ss).Xu))\n%%%Send authentication Reply to NAD\n\t/\\ SND(Qujprime')\n%%% ED's acceptance of values b' and Dj for ED by NAD\n\t/\\ ____(EVENT_8)____(ED, NAD, dj, ____(EVENT_9)____)\n\t/\\ request(ED, ____(EVENT_11)____, bprime, ____(EVENT_10)____)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n%%NAD ROLE\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole networkdevice (____(PARAM_4)____, NAD: agent, ____(PARAM_6)____: ____(PARAM_7)____, SND,____(PARAM_5)____: channel(dy))  \nplayed_by NAD\ndef=\n\tlocal\n\t\t____(VARIABLE_5)____:nat,\n\t\tIDu, PWu, Bu, Aa, Bb, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,____(VARIABLE_8)____, ____(VARIABLE_6)____, a, b,  ____(VARIABLE_7)____, dj, cu\t: ____(VARIABLE_9)____\n\tinit\n\t\tState := 0\n\ttransition\n%%%User Registration Phase\n \n\t1. State =  ____(STATE_2)____ /\\ RCV({IDu.M.TW}_SKus) =|>\n%%%% Identity IDu is shared between ED and NAD\n\tState' := 2 /\\  secret({____(EVENT_12)____}, ____(EVENT_13)____, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({____(EVENT_15)____,____(EVENT_14)____}, sp2, {ED})\n\n%%%%% Computation\n\t/\\ Lu' := H(M.Ss)\n\t/\\ Bb' := new()\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\t\t\t\t\t\t\t\t\t\t\n\t/\\ Yu' := xor(Xu', H(M.TW))\n\t/\\ Zu' := xor(xor(Lu',H(Ss\t. Bb)),TW)\t\n\t/\\ Fu' := H(H(IDu.TW))\t\n\t/\\ PIDr' :={IDu.Ss.Bb}_SKus\n\t/\\ Du' := xor(H(IDu.Ss), H(IDu.TW))\n\t/\\ SND(PIDr'. Du'. Yu'.Fu'.Zu')\n%%%%%%%%%% Mutual Authentication\n%%% Receive login request Message M1 from ED\n\n\t2. State = ____(STATE_0)____ /\\ RCV(PIDr. DIDu. Buj.Cu') =|>\n%%%% We decrytp PIDr by using master key of CCS\n\tState' := 4 /\\   PIDr':= IDu.Ss.Bb\n\t/\\ Lu' := xor(xor(xor(Buj,H(H(IDj.Cu'))),H(PIDr.H(IDu.Ss))),H(Ss.Bb))\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n\t/\\ Bbprime' := new()\n\t/\\ Dj' := new()\n\t/\\ PIDrprime' := xor(H(IDu.Ss), H(Ss.Bbprime'))\n\t/\\ Tu' := xor(PIDrprime',H(PIDr'.H(IDu.Ss).Xu'))\n\t/\\ Quj' :=H(H(IDu.Ss).Tu'.Cu'.Dj'.Xu'.IDj)\n%%% Send request message M2 to ED publicly\n\t/\\ SND(Quj'.Tu'.Dj') \n%%% Freshly generated Random number b' and Dj\n\t/\\ witness(ED, ____(EVENT_17)____, ____(EVENT_16)____, Dj')\n\t/\\ witness(ED, ____(EVENT_18)____, ____(EVENT_19)____, Bbprime')\n%%% Receive request message M3 to ED publicly\n\t3. State = 4 /\\ RCV(Qujprime') =|>\t\n%%% NAD acceptance of value Cu generated by ED for NAD\n\t  State' := 6  /\\ Cu' := new()\t  /\\ ____(EVENT_21)____(____(EVENT_20)____, NAD, cu, Cu')\n\t/\\ SKuj' := H(H(IDu.Ss). Cu'. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\nend role \n\nrole session (ED,NAD: agent, ____(PARAM_8)____: ____(PARAM_9)____)\ndef=\n\tlocal\n\t\tSND1,____(VARIABLE_10)____,RCV1,____(VARIABLE_11)____: channel(dy)\n\tcomposition\n\t\tedge (ED, NAD, SKus, SND1, RCV1)\n\t\t/\\  networkdevice (ED, NAD, SKus, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst ____(VARIABLE_13)____, nad: ____(VARIABLE_12)____, skus: symmetric_key,\n        h: hash_func, sp1,sp2, sp3, a, b, bprime, dj, cu: protocol_id\n\tintruder_knowledge = {ed, nad, h}\n\tcomposition\n\t session(ed, nad, skus) \n\t/\\ session(i, nad, skus)\n\t/\\ session(ed, i, skus)\nend role\n____(ROLE_0)____\n        secrecy_of ____(GOAL_22)____, sp2, ____(GOAL_23)____\n        authentication_on a,____(GOAL_24)____\n        authentication_on b, ____(GOAL_25)____,____(GOAL_26)____\nend goal\nenvironment()",
        "complete:": "%%% Start of protocol\nrole edge (ED, NAD: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by ED\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b, bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n\t1. State = 0  /\\  RCV(start) =|> \n        State' := 1  /\\  M' := H(IDu.Bu) \n\t/\\ Aa' := new()\n\t/\\ TW' := H(xor(Aa,H(Bu.PWu)))\n%%%% Identity is Shared BETWEEN ED and NAD\n\t/\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n%%%%Send Registration Request to NAD\n\t/\\  SND({IDu.M'.TW'}_SKus)\n%%%% Receive Registration Reply to NAD\n\t2. State=1 /\\ RCV({PIDr'.Du.Yu.Fu.Zu}_SKus) =|>  \n%%%% Master key s is only known to NAD\n\tState' := 3 /\\  secret({Ss}, sp3, {NAD})\n%%%% Authentication and Key Exchange Phase (Public Channel)\n\t/\\ Fu' := H(IDu.TW)\n\t/\\ Cu' :=  new() \n%%%% Here we assume that H(IDu.Ss)= AB'\n\t/\\  AB' := xor(Du, H(IDu.TW))\n\t/\\ Buj'  := xor(xor(xor(Zu,H(IDj.Cu')),TW),H(PIDr'.H(IDu.Ss)))\n\t/\\ Xu' := xor(Yu, H(M.TW))\n\t/\\ DIDu' := H(PIDr'.Xu.Cu')\n%%% Send login request message M1 to NAD \n\t/\\ SND(PIDr'.DIDu'.Buj'.Cu')\n%%% U has freshly generated random number\n\t/\\ witness(ED, NAD, cu, Cu')\n%%% Receive Authentication message from NAD\n\t3. State=3 /\\ RCV(Quj. Tu. Dj\t) =|> \n\tState' := 5 /\\  Dj' := new() /\\ PIDr' := new() \n\t/\\ Quj' := H(H(IDu.Ss).Tu.Cu.Dj.Xu.IDj)\n\t/\\ SKuj' := H(H(IDu.Ss). Cu. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\n\t/\\ PIDrprime' := xor(Tu, H(PIDr'.H(IDu.Ss).Xu))\n%%%Send authentication Reply to NAD\n\t/\\ SND(Qujprime')\n%%% ED's acceptance of values b' and Dj for ED by NAD\n\t/\\ request(ED, NAD, dj, Dj')\n\t/\\ request(ED, NAD, bprime, Bbprime)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n%%NAD ROLE\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole networkdevice (ED, NAD: agent, SKus: symmetric_key, SND,RCV: channel(dy))  \nplayed_by NAD\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu, PWu, Bu, Aa, Bb, Cu, M,AB, TW: text,\n\t\tLu, Xu, Yu, Fu, Zu, PIDr, Bbprime, Du: text,\n\t\tBuj, IDj, Quj, PIDrprime, Qujprime, Dj, Tu, SKuj,Ss, DIDu: text,\n\t\tH: hash_func\n\tconst\n\t\tsp1,sp2, sp3, a, b,  bprime, dj, cu\t: protocol_id\n\tinit\n\t\tState := 0\n\ttransition\n%%%User Registration Phase\n \n\t1. State =  0 /\\ RCV({IDu.M.TW}_SKus) =|>\n%%%% Identity IDu is shared between ED and NAD\n\tState' := 2 /\\  secret({IDu}, sp1, {ED,NAD})\n%%%%Password and Biometric  are only know to ED\n\t/\\  secret({PWu,Bu}, sp2, {ED})\n\n%%%%% Computation\n\t/\\ Lu' := H(M.Ss)\n\t/\\ Bb' := new()\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\t\t\t\t\t\t\t\t\t\t\n\t/\\ Yu' := xor(Xu', H(M.TW))\n\t/\\ Zu' := xor(xor(Lu',H(Ss\t. Bb)),TW)\t\n\t/\\ Fu' := H(H(IDu.TW))\t\n\t/\\ PIDr' :={IDu.Ss.Bb}_SKus\n\t/\\ Du' := xor(H(IDu.Ss), H(IDu.TW))\n\t/\\ SND(PIDr'. Du'. Yu'.Fu'.Zu')\n%%%%%%%%%% Mutual Authentication\n%%% Receive login request Message M1 from ED\n\n\t2. State = 2 /\\ RCV(PIDr. DIDu. Buj.Cu') =|>\n%%%% We decrytp PIDr by using master key of CCS\n\tState' := 4 /\\   PIDr':= IDu.Ss.Bb\n\t/\\ Lu' := xor(xor(xor(Buj,H(H(IDj.Cu'))),H(PIDr.H(IDu.Ss))),H(Ss.Bb))\n\t/\\ Xu' := H(Lu'.H(Ss.Bb))\n\t/\\ DIDu' := H(PIDr'.Xu'.Cu')\n\t/\\ Bbprime' := new()\n\t/\\ Dj' := new()\n\t/\\ PIDrprime' := xor(H(IDu.Ss), H(Ss.Bbprime'))\n\t/\\ Tu' := xor(PIDrprime',H(PIDr'.H(IDu.Ss).Xu'))\n\t/\\ Quj' :=H(H(IDu.Ss).Tu'.Cu'.Dj'.Xu'.IDj)\n%%% Send request message M2 to ED publicly\n\t/\\ SND(Quj'.Tu'.Dj') \n%%% Freshly generated Random number b' and Dj\n\t/\\ witness(ED, NAD, dj, Dj')\n\t/\\ witness(ED, NAD, bprime, Bbprime')\n%%% Receive request message M3 to ED publicly\n\t3. State = 4 /\\ RCV(Qujprime') =|>\t\n%%% NAD acceptance of value Cu generated by ED for NAD\n\t  State' := 6  /\\ Cu' := new()\t  /\\ request(ED, NAD, cu, Cu')\n\t/\\ SKuj' := H(H(IDu.Ss). Cu'. Dj. Xu. IDj)\n        /\\ Qujprime' := H(SKuj.H(IDu.Ss).Dj.Xu.IDj)\nend role \n\nrole session (ED,NAD: agent, SKus: symmetric_key)\ndef=\n\tlocal\n\t\tSND1,SND2,RCV1,RCV2: channel(dy)\n\tcomposition\n\t\tedge (ED, NAD, SKus, SND1, RCV1)\n\t\t/\\  networkdevice (ED, NAD, SKus, SND2, RCV2)\nend role\n\nrole environment()\ndef=\n\tconst ed, nad: agent, skus: symmetric_key,\n        h: hash_func, sp1,sp2, sp3, a, b, bprime, dj, cu: protocol_id\n\tintruder_knowledge = {ed, nad, h}\n\tcomposition\n\t session(ed, nad, skus) \n\t/\\ session(i, nad, skus)\n\t/\\ session(ed, i, skus)\nend role\ngoal\n        secrecy_of sp1, sp2, sp3\n        authentication_on a,cu\n        authentication_on b, bprime,dj\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/authenticationWPA.hlpsl",
        "incomplete": "%% PROTOCOL: WPA2 Wifi security protocol authentication request response and 4 way handshake.\n%% PURPOSE:\n%% We want to model the security capabilities of the WPA2 model for which \n%% we need to use a relevant analysis software. Here, the protocol is \n%% modelled on AVISPA Tool. On performing the analysis, we see that\n%% there is no attack possible and the protocol is safe.\n%% However, we know now that there is a KRACK Attack possible against the protocol.\n%% THe purpose of this project is to come up with a patch to the protocol and hence\n%% the AVISPA tool is not sufficient to model such behaviour according to our findings.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\n\nrole authenticator(____(PARAM_1)____,____(PARAM_2)____:____(PARAM_3)____,\n\t   ____(PARAM_0)____: text,\t\n\t   KDF: hash_func,\n\t   ____(PARAM_4)____,Rcv:channel(dy)) \nplayed_by A\ndef=\n\n  local State : ____(VARIABLE_0)____,\n  \tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, ANonce, SNonce,PTK,GTK : text\n\t\n  const ____(VARIABLE_1)____,sec_gtk : protocol_id\n\n  init State:=1\n\n  transition\n  \t1. State=____(STATE_0)____ /\\ Rcv(____(MESSAGE_6)____) =|>\n  \t   State':=3 /\\ AuthResp' := new() /\\ ____(MESSAGE_7)____(AuthResp')\n\t1. State=3 /\\ Rcv(____(MESSAGE_8)____) =|>\n\t   State' := 5 /\\ ReAuthResp' :=new() /\\ ReplayCounter' := new() /\\ ANonce' := new() /\\ Snd(____(MESSAGE_9)____)\n\t2. State=5 /\\ Rcv(____(MESSAGE_10)____) =|> \n\t   State':= 7 /\\ PTK':= KDF(PMK.ANonce.SNonce') /\\ ReplayCounterplus1' := new() /\\ GTK':= new() /\\ ____(MESSAGE_11)____(ReplayCounterplus1'.{GTK'}_PTK') /\\\n\t   ____(EVENT_1)____(GTK',sec_gtk,{A,____(EVENT_0)____}) /\\\n\t   witness(A,____(EVENT_2)____,authenticator_supplicant_gtk,____(EVENT_3)____)\n\t   \n\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole ____(ROLE_1)____(____(PARAM_6)____,____(PARAM_8)____:agent, \n\t ____(PARAM_5)____: ____(PARAM_7)____,\n         KDF: hash_func,\n         ____(PARAM_9)____,Rcv:channel(dy)) \nplayed_by S\ndef=\n\n  local State : ____(VARIABLE_2)____, \n\tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, SNonce, ANonce ,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,____(VARIABLE_3)____ : protocol_id\n\t\n  init State:=0\n  \n  transition\n  \t1. State=____(STATE_1)____ /\\ Rcv(____(MESSAGE_12)____) =|>\n  \t   State':=2 /\\ AuthReq' := new() /\\ Snd(____(MESSAGE_13)____)\n  \t2. State=____(STATE_2)____ /\\ Rcv(____(MESSAGE_14)____) =|>\n  \t   State':=4 /\\ ReAuthReq' := new() /\\ Snd(____(MESSAGE_15)____)\n\t1. State=4 /\\ Rcv(____(MESSAGE_16)____) =|>\n   \t   State':= 6 /\\ SNonce':=new() /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ ____(MESSAGE_17)____(ReplayCounter'.SNonce') \n   \t2. State= 6 /\\ ____(MESSAGE_18)____(ReplayCounterplus1'.{GTK'}_PTK') =|>\n   \t   State':= 7 /\\ request(S,____(EVENT_4)____,____(EVENT_5)____,GTK')\n\nend role\n\t\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n\nrole session(A,S:____(PARAM_10)____,\n\t      KDF: ____(PARAM_11)____, \n\t      ____(PARAM_12)____:text) \ndef=\n\n  local SND_A,____(VARIABLE_4)____,SND_B,RCV_B:channel(____(VARIABLE_5)____) \n  \n  composition\n\tauthenticator(A,S,PMK,KDF,SND_A,RCV_A) \n     /\\ supplicant(S,A,PMK,KDF,SND_B,RCV_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole ____(ROLE_0)____() \ndef=\n\n  const authenticator_supplicant_gtk,____(VARIABLE_7)____ : ____(VARIABLE_6)____,\n  \ta,s : agent, \n\tpmk : text,\n\tgtk : protocol_id,\n\tkdf : hash_func\n\t\n  intruder_knowledge = {a,s,pmk}\n  \n  composition\n     session(a,s,kdf,pmk)\n \n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  \n  authentication_on ____(GOAL_19)____\n  ____(GOAL_20)____ sec_gtk\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: WPA2 Wifi security protocol authentication request response and 4 way handshake.\n%% PURPOSE:\n%% We want to model the security capabilities of the WPA2 model for which \n%% we need to use a relevant analysis software. Here, the protocol is \n%% modelled on AVISPA Tool. On performing the analysis, we see that\n%% there is no attack possible and the protocol is safe.\n%% However, we know now that there is a KRACK Attack possible against the protocol.\n%% THe purpose of this project is to come up with a patch to the protocol and hence\n%% the AVISPA tool is not sufficient to model such behaviour according to our findings.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\n\nrole authenticator(A,S:agent,\n\t   PMK: text,\t\n\t   KDF: hash_func,\n\t   Snd,Rcv:channel(dy)) \nplayed_by A\ndef=\n\n  local State : nat,\n  \tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, ANonce, SNonce,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\n  init State:=1\n\n  transition\n  \t1. State=1 /\\ Rcv(AuthReq') =|>\n  \t   State':=3 /\\ AuthResp' := new() /\\ Snd(AuthResp')\n\t1. State=3 /\\ Rcv(ReAuthReq') =|>\n\t   State' := 5 /\\ ReAuthResp' :=new() /\\ ReplayCounter' := new() /\\ ANonce' := new() /\\ Snd(ReAuthResp'.ReplayCounter'.ANonce')\n\t2. State=5 /\\ Rcv(ReplayCounter'.SNonce') =|> \n\t   State':= 7 /\\ PTK':= KDF(PMK.ANonce.SNonce') /\\ ReplayCounterplus1' := new() /\\ GTK':= new() /\\ Snd(ReplayCounterplus1'.{GTK'}_PTK') /\\\n\t   secret(GTK',sec_gtk,{A,S}) /\\\n\t   witness(A,S,authenticator_supplicant_gtk,GTK')\n\t   \n\t\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole supplicant(S,A:agent, \n\t PMK: text,\n         KDF: hash_func,\n         Snd,Rcv:channel(dy)) \nplayed_by S\ndef=\n\n  local State : nat, \n\tAuthReq, AuthResp, ReAuthReq, ReAuthResp, ReplayCounter, ReplayCounterplus1, SNonce, ANonce ,PTK,GTK : text\n\t\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id\n\t\n  init State:=0\n  \n  transition\n  \t1. State=0 /\\ Rcv(start) =|>\n  \t   State':=2 /\\ AuthReq' := new() /\\ Snd(AuthReq')\n  \t2. State=2 /\\ Rcv(AuthResp') =|>\n  \t   State':=4 /\\ ReAuthReq' := new() /\\ Snd(ReAuthReq')\n\t1. State=4 /\\ Rcv(ReAuthResp'.ReplayCounter'.ANonce') =|>\n   \t   State':= 6 /\\ SNonce':=new() /\\ PTK':= KDF(PMK.ANonce'.SNonce') /\\ Snd(ReplayCounter'.SNonce') \n   \t2. State= 6 /\\ Rcv(ReplayCounterplus1'.{GTK'}_PTK') =|>\n   \t   State':= 7 /\\ request(S,A,authenticator_supplicant_gtk,GTK')\n\nend role\n\t\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\t\n\nrole session(A,S:agent,\n\t      KDF: hash_func, \n\t      PMK:text) \ndef=\n\n  local SND_A,RCV_A,SND_B,RCV_B:channel(dy) \n  \n  composition\n\tauthenticator(A,S,PMK,KDF,SND_A,RCV_A) \n     /\\ supplicant(S,A,PMK,KDF,SND_B,RCV_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t\nrole environment() \ndef=\n\n  const authenticator_supplicant_gtk,sec_gtk : protocol_id,\n  \ta,s : agent, \n\tpmk : text,\n\tgtk : protocol_id,\n\tkdf : hash_func\n\t\n  intruder_knowledge = {a,s,pmk}\n  \n  composition\n     session(a,s,kdf,pmk)\n \n  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  \n  authentication_on authenticator_supplicant_gtk\n  secrecy_of sec_gtk\n \nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/AVISPAProject.hlpsl",
        "incomplete": "% A -> S: ({A.B.Na}_Ka)  % Ka is a key shared by A and S\n% A <- S: ({K.Na}_Ka.  % S generates new key K \n%                      % {K.Na}_Ka does not need Na, but it helps A identify the session for the key K\n%          {K.Na.A}_Kb)  % A cannot decrypt the contents of {K.Na.Ns}_Kb, but is able to forward it to B\n%                        % if A is not encrypted with Kb, the attacker will be able to pretend to be A when contacting B\n% A -> B: ({K.Na.A}_Kb)  % The last part is a key confirmation\n% A <- B: ({Na.Nb}_K)  % A tests if B knows K during this session, by using Na\n% A -> B: ({Nb.Na}_K)  % B tests if A knows K during this session, by using Nb\n%                      % Na is not necessary, but it helps B identify the session when receiving Nb\n\n____(ROLE_0)____ ____(ROLE_2)____ (A, ____(PARAM_1)____, ____(PARAM_2)____ : ____(PARAM_0)____,\n\t    Ka      : symmetric_key,\n\t    SND_SA, RCV_SA, SND_BA, ____(PARAM_3)____ : channel(____(PARAM_4)____))\n\nplayed_by A def=\n    local ____(VARIABLE_0)____ : nat,\n          Na,Nb : text,\n          K     : symmetric_key,\n          X     : {symmetric_key.text.agent}_symmetric_key\n    init State := 0\n\n    transition\n    1. State  = 0 /\\ RCV_BA(start) =|>\n       State':= 2 /\\ Na' := new()\n                  /\\ SND_SA({A.B.Na'}_Ka)\n\n    2. State  = 2 /\\ RCV_SA({K'.Na}_Ka.X') =|>\n       State':= 4 /\\ SND_BA(X')\n\n    3. State  = ____(STATE_2)____ /\\ RCV_BA({Na.Nb'}_K) =|>\n       State':= 6 /\\ SND_BA({Nb'.Na}_K)\n                  /\\ request(A,B,alice_bob_na,Na) % A verifies that B knows K (B can decrpyt and encrypt again Na)\n                  /\\ witness(____(EVENT_2)____,B,bob_alice_nb,____(EVENT_3)____) \nend ____(ROLE_1)____\n\n\nrole server (____(PARAM_5)____, ____(PARAM_8)____, B  : agent,\n             ____(PARAM_7)____, Kb   : ____(PARAM_6)____,\n             ____(PARAM_9)____, RCV_AS : channel(dy))\n\nplayed_by S def=\n    local State : nat,\n          Na    : text,\n          K     : symmetric_key\n    init  State := 1\n\n    transition\n    1. State  = ____(STATE_1)____ /\\ RCV_AS({A.B.Na'}_Ka) =|>\n       State':= 3 /\\ K' := new()\n                  /\\ SND_AS({K'.Na'}_Ka.{K'.Na'.A}_Kb)\n                  /\\ secret(____(EVENT_6)____,k,{____(EVENT_4)____,B,____(EVENT_5)____})\nend role\n\n\nrole bob (____(PARAM_10)____, ____(PARAM_13)____, B : agent,\n          ____(PARAM_11)____      : symmetric_key,\n          SND_AB, RCV_AB : channel(____(PARAM_12)____))\n\nplayed_by B def=\n     local State  : nat,\n           Na,Nb  : text,\n           K      : symmetric_key\n     init  State := 5\n\n     transition\n     1. State  = 5 /\\ RCV_AB({K'.Na'.A}_Kb) =|>\n        State':= 7 /\\ Nb' := new()\n                   /\\ SND_AB({Na'.Nb'}_K')\n                   /\\ ____(EVENT_7)____(B,A,alice_bob_na,____(EVENT_8)____)\n                   \n     2. State  = ____(STATE_0)____ /\\ RCV_AB({Nb.Na}_K) =|>\n        State':= 9 /\\ request(B,A,bob_alice_nb,Nb) % B verifies that A knows K (A can decrpyt and encrypt again Nb)\n                   \nend role\n\n\nrole session(A, ____(PARAM_14)____, ____(PARAM_15)____ : agent,\n             Ka, ____(PARAM_16)____  : symmetric_key)\ndef=\n     local\n        SSA, ____(VARIABLE_1)____,\n        SBA, RBA,\n        SAS, RAS,\n        SAB, RAB : channel (dy)\n\n     composition\n              alice (A, S, B, Ka, SSA, RSA, SBA, RBA)\n          /\\  server(A, S, B, Ka, Kb, SAS, RAS)\n          /\\  bob   (A, S, B, Kb, SAB, RAB)\nend role\n\n\nrole environment()\ndef=\n      const a, b, ____(VARIABLE_3)____         : ____(VARIABLE_2)____,\n            ka, kb, ki      : symmetric_key,\n            alice_bob_na, bob_alice_nb, k : protocol_id\n\n      intruder_knowledge = {a, b, s, ki}\n\n      composition         \n              session(a,s,b,ka,kb)\n           /\\ session(a,s,i,ka,ki)\n           /\\ session(i,s,b,ki,kb)\n           /\\ session(i,s,a,ki,ka)\nend role\n\n\ngoal\n    ____(GOAL_11)____ k\n    authentication_on ____(GOAL_12)____\n    ____(GOAL_13)____ bob_alice_nb\nend goal\n\nenvironment()",
        "complete:": "% A -> S: ({A.B.Na}_Ka)  % Ka is a key shared by A and S\n% A <- S: ({K.Na}_Ka.  % S generates new key K \n%                      % {K.Na}_Ka does not need Na, but it helps A identify the session for the key K\n%          {K.Na.A}_Kb)  % A cannot decrypt the contents of {K.Na.Ns}_Kb, but is able to forward it to B\n%                        % if A is not encrypted with Kb, the attacker will be able to pretend to be A when contacting B\n% A -> B: ({K.Na.A}_Kb)  % The last part is a key confirmation\n% A <- B: ({Na.Nb}_K)  % A tests if B knows K during this session, by using Na\n% A -> B: ({Nb.Na}_K)  % B tests if A knows K during this session, by using Nb\n%                      % Na is not necessary, but it helps B identify the session when receiving Nb\n\nrole alice (A, S, B : agent,\n\t    Ka      : symmetric_key,\n\t    SND_SA, RCV_SA, SND_BA, RCV_BA : channel(dy))\n\nplayed_by A def=\n    local State : nat,\n          Na,Nb : text,\n          K     : symmetric_key,\n          X     : {symmetric_key.text.agent}_symmetric_key\n    init State := 0\n\n    transition\n    1. State  = 0 /\\ RCV_BA(start) =|>\n       State':= 2 /\\ Na' := new()\n                  /\\ SND_SA({A.B.Na'}_Ka)\n\n    2. State  = 2 /\\ RCV_SA({K'.Na}_Ka.X') =|>\n       State':= 4 /\\ SND_BA(X')\n\n    3. State  = 4 /\\ RCV_BA({Na.Nb'}_K) =|>\n       State':= 6 /\\ SND_BA({Nb'.Na}_K)\n                  /\\ request(A,B,alice_bob_na,Na) % A verifies that B knows K (B can decrpyt and encrypt again Na)\n                  /\\ witness(A,B,bob_alice_nb,Nb') \nend role\n\n\nrole server (A, S, B  : agent,\n             Ka, Kb   : symmetric_key,\n             SND_AS, RCV_AS : channel(dy))\n\nplayed_by S def=\n    local State : nat,\n          Na    : text,\n          K     : symmetric_key\n    init  State := 1\n\n    transition\n    1. State  = 1 /\\ RCV_AS({A.B.Na'}_Ka) =|>\n       State':= 3 /\\ K' := new()\n                  /\\ SND_AS({K'.Na'}_Ka.{K'.Na'.A}_Kb)\n                  /\\ secret(K',k,{A,B,S})\nend role\n\n\nrole bob (A, S, B : agent,\n          Kb      : symmetric_key,\n          SND_AB, RCV_AB : channel(dy))\n\nplayed_by B def=\n     local State  : nat,\n           Na,Nb  : text,\n           K      : symmetric_key\n     init  State := 5\n\n     transition\n     1. State  = 5 /\\ RCV_AB({K'.Na'.A}_Kb) =|>\n        State':= 7 /\\ Nb' := new()\n                   /\\ SND_AB({Na'.Nb'}_K')\n                   /\\ witness(B,A,alice_bob_na,Na')\n                   \n     2. State  = 7 /\\ RCV_AB({Nb.Na}_K) =|>\n        State':= 9 /\\ request(B,A,bob_alice_nb,Nb) % B verifies that A knows K (A can decrpyt and encrypt again Nb)\n                   \nend role\n\n\nrole session(A, S, B : agent,\n             Ka, Kb  : symmetric_key)\ndef=\n     local\n        SSA, RSA,\n        SBA, RBA,\n        SAS, RAS,\n        SAB, RAB : channel (dy)\n\n     composition\n              alice (A, S, B, Ka, SSA, RSA, SBA, RBA)\n          /\\  server(A, S, B, Ka, Kb, SAS, RAS)\n          /\\  bob   (A, S, B, Kb, SAB, RAB)\nend role\n\n\nrole environment()\ndef=\n      const a, b, s         : agent,\n            ka, kb, ki      : symmetric_key,\n            alice_bob_na, bob_alice_nb, k : protocol_id\n\n      intruder_knowledge = {a, b, s, ki}\n\n      composition         \n              session(a,s,b,ka,kb)\n           /\\ session(a,s,i,ka,ki)\n           /\\ session(i,s,b,ki,kb)\n           /\\ session(i,s,a,ki,ka)\nend role\n\n\ngoal\n    secrecy_of k\n    authentication_on alice_bob_na\n    authentication_on bob_alice_nb\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/A_Secure_and_Efficient_Smart_Card-based_UCSSO_Scheme_Using_Extended_Chebyshev_Chaotic_Maps_for_Telemedicine_Systems.hlpsl",
        "incomplete": "____(ROLE_1)____ user (____(PARAM_3)____, S: ____(PARAM_4)____, Kus: symmetric_key, T, ____(PARAM_1)____: ____(PARAM_0)____, SND, RCV: channel (____(PARAM_2)____))\nplayed_by U def=\n\nlocal State: ____(VARIABLE_0)____,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(____(EVENT_0)____,g1,{U,____(EVENT_1)____}) /\\ secret(Ai',____(EVENT_3)____,{____(EVENT_2)____,S}) /\\ ____(EVENT_4)____(PWi',____(EVENT_5)____,{U})\n2.  State = ____(STATE_1)____ /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,____(EVENT_6)____,u_s_pi,____(EVENT_7)____)\n3.  State = ____(STATE_0)____ /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ ____(EVENT_8)____(____(EVENT_9)____,U,s_u_sj,Sj')\n\nend role\n\n\nrole server (____(PARAM_9)____, S: agent, ____(PARAM_5)____: ____(PARAM_6)____, T, ____(PARAM_7)____: hash_func, ____(PARAM_8)____, RCV: channel (dy))\nplayed_by S def=\n\nlocal ____(VARIABLE_1)____: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',____(EVENT_11)____,{____(EVENT_10)____,S}) /\\ ____(EVENT_12)____(Bjj',g5,{____(EVENT_13)____,S}) /\\ secret(____(EVENT_14)____,g6,{____(EVENT_15)____})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(____(EVENT_16)____,U,____(EVENT_17)____,Sj')\n/\\ ____(EVENT_18)____(U,S,____(EVENT_19)____,Pi')\n3. State = ____(STATE_2)____ /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (____(PARAM_11)____, ____(PARAM_10)____: ____(PARAM_13)____, Kus: symmetric_key, ____(PARAM_12)____, H: hash_func) def=\n\nlocal ____(VARIABLE_3)____, RU, ____(VARIABLE_2)____, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: ____(VARIABLE_4)____,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\n____(ROLE_0)____\n\n____(GOAL_20)____ ____(GOAL_22)____, ____(GOAL_23)____, g3, g4, ____(GOAL_21)____, g6 authentication_on u_s_pi, s_u_sj\n\nend goal\n\n\nenvironment()",
        "complete:": "role user (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(IDi',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ secret(PWi',g3,{U})\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,S,u_s_pi,Pi')\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ request(S,U,s_u_sj,Sj')\n\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',g4,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Xsj,g6,{S})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(S,U,s_u_sj,Sj')\n/\\ request(U,S,u_s_pi,Pi')\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (U, S: agent, Kus: symmetric_key, T, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6 authentication_on u_s_pi, s_u_sj\n\nend goal\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/BRSKI.hlpsl",
        "incomplete": "%% PROTOCOL*: Bootstrapping RemoteSecure Key Infrastructures (BRSKI)\n%% PURPOSE: (BRSKI) protocol provides a solution for a resource-constrained \n%\t     new device to automatically onboard the correct network in a secure manner.\n%\t     BRSKI specification refers the new device as 'pledge'. \n%\t     Protocol aims to establish a trusted relationship between pledge and the \n%\t     network operator/owner referred as 'registrar' in such a way so that \n%\t     they can assure and authenticate each other's identity. This is done using\n%\t     a singed 802.1AR iDevID cert which is installed into the device \n%\t     by the manufacturer during the manufacturing process. The iDevID cert indicates \n%\t     the manufacturer of the device, serial number of the device and type of the device.\n%\t     Manufacturer also installs a trust anchor of manufacturer's authorized signing authority\n%\t     (known as MASA) at compile time using which it can trust and verify the 'MASA'.\n\n\n%%\n%% REFERENCE: https://tools.ietf.org/pdf/draft-ietf-anima-bootstrapping-keyinfra-41.pdf\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Author1\n%% \\item Author2\n%% \\item Author3\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% Let P,R,M respectively represnts the pledge, registrar and MASA.\n%% Kp,Kr,Km represents their public key and kca denotes the public key of certificate authority.\n\n%%\n%% P --> R : P.Na.Sid.Pa\t\t[Pledge_hello (Part of TLS handshake)]\n%% R --> P : Nb.Sid.Pa.{R.Kr}_inv(Kca)\t[Registrar_hello (Part of TLS handshake)]\n%% P --> R : {Pms}_Kr.{Sn.Issuer.Sln.Aki.Kp}_inv(Km).{Finishedp}_ClientKp\t[Pledge_key_exchange (Part of TLS handshake)]\n%%\t  Mp : PRF(Pms.Na.Nb)\n%%\t  Finishedp : PRF(Mp.P.R.Na.Pa.Sid)\n%%\t  ClientKp  : KeyGen(P.Na.Nb.Mp)\n%%\t  ServerKp  : KeyGen(R.Na.Nb.Mp)\n%% R --> P : {Finishedp}_ServerKp\t[Registrar_key_exchange (Part of TLS handshake)]\n%% P --> R : {signed Pledge_voucher_request}_ClientKp\n%%\t  Pledge_voucher_rquest : {Assr'.Np'.Sn.Crdate'.{R.Kr}_inv(Kca)}_(inv(Kp))\n%% R --> M : R.Nc.Sidm.Pam\t\t[Registrar_hello (Part of TLS handshake)]\n%% M --> R : Nd.Sidm.Pam.{M.Km}_inv(Kca)\t[MASA_hello (Part of TLS handshake)]\n%%\t  Masa certificate ={M.Km}_inv(Kca)\n%% R --> M : {Pmsm}_Kr.{R.Kr}_inv(Kca).{Finishedm}_ClientKm [Registrar_key_exchange (Part of TLS handshake)]\n%%\t  Mm : PRF(Pmsm.Nc.Nd)\n%%\t  Finishedm : PRF(Mm.R.M.Nc.Pam.Sidm)\n%%\t  ClientKm  : KeyGen(R.Nc.Nd.Mm)\n%%\t  ServerKm  : KeyGen(M.Nc.Nd.Mm)\n%% M --> R : {Finishedm}_Serverm\t\t[MASA_key_exchange (Part of TLS handshake)]\n%% R --> M : {signed registrar_voucher_request}_ClientKm\n%%\t  registrar_voucher_request = {Assr.Np.Sn.Rcrdate'.Issuer.Prior-signed pledge_voucher_request}\n%% M --> R : {signed Voucher}_ServerKm\n%%\t  voucher = {Assr.Np.Sn.{R.Kr}_inv(Kca)}\n%% R --> P : {signed voucher}_ServerKp\n%% \\end{verbatim}\n%% LIMITATIONS:\n%%\\begin{itemize}\n%% \\item This formalisation is based on the abstracted version of BRSKI \n%% presented by in https://tools.ietf.org/pdf/draft-ietf-anima-bootstrapping-keyinfra-41.pdf. \n%% \\item We do consider nonceless voucher request in this modelling.\n%%\\end{itemize}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% NOTES:\n%% To initiate the bootstarping process, the pledge sends the iDevID as part of TLS session \n%% and establish a provisional TLS connection through a joint proxy. Once the provisional \n%% TLS connection is established pledge sends a signed voucher-request to the registrar \n%% which includes the information about the pledge such as assertion(Assr), nonce(Np),\n%% serial-number(Sn), created-on(Crdate), proximity-registrar-cert.\n%% While receiving the pledge voucher-request registrar determines if it is \n%% expecting such device if yes then it locates the device's MASA and sends MASA \n%% a signed registrar voucher-request that contains the entire pledge voucher-request.\n%% The registrar's voucher-request includes following information: assertion(Assr), nonce(Np),\n%% serial-number(Sn), created-on(Crdate) from the pledge voucher-request, idevid-issuer(Issuer)\n%% from the iDevID certificate and entire pledge voucher-request in prior-signed-voucher-request field.\n%% Then MASA checks its record with respect to the provided device serial number in the voucher-request.\n%% if the voucher-request is accepted, a voucher is issued. Voucher contains assertion(Assr), \n%% nonce(Np), serial-number(Sn) and pinned-domain-cert. Registrar redeems the voucher by passing \n%% it to the pledge. Pledge validates the signed voucher using the pre-installed \\textit{MASA}'s trust anchor.\n%% The pledge also verifies the registrar using the pinned-domain cert and completes the authentication of \n%% provisional TLS connection. The pledge returns a voucher telemetry status indicating voucher acceptance status.\n\n%% HLPSL:\n\n____(ROLE_0)____ pledge (____(PARAM_5)____, R, ____(PARAM_9)____        : agent,\n\t     ____(PARAM_7)____, ____(PARAM_1)____, ____(PARAM_2)____    : ____(PARAM_4)____,\n\t     KeyGen, PRF    : ____(PARAM_0)____,\n\t     Sn      \t    : text, %devID serial Number \n             Issuer    \t    : text, %devID issuer\n             Aki\t    : text, %devID authorityKeyIdentifier\n             Sln\t    : text, %devID subjectAltName\t\n             SND_R, RCV_R, SND_M, ____(PARAM_8)____   : channel (dy))\nplayed_by P def=\n\nlocal\tNp, ____(VARIABLE_1)____, ____(VARIABLE_0)____, Assr, Pms, ____(VARIABLE_2)____, ____(VARIABLE_3)____ : text,\n\tCrdate                         : text,\n\tState                          : nat,\n\tKp                             : public_key,\n\tFinishedp\t    : hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKp, ServerKp  : hash(agent.text.text.hash(text.text.text)),\n        Mp\t\t    : hash(text.text.text)\n\nconst sec_np_pr, auth_np, auth_sn, auth_na_nb, auth_reg_cert, auth_na_nb2, auth_idev, auth_reg_certchain, tls_pledgek, tls_registrark : protocol_id%,\n\n  init State := 0\n\n  transition\n\n 0. State  = ____(STATE_2)____ /\\ RCV_R(start) =|>\n    State':= 2 \n\t/\\ Na' := new()\n\t/\\ Pa' := new()\n\t/\\ Sid' := new()\n\t/\\ SND_R(P.Na'.Sid'.Pa')\n\n\n 2. State  = 2 /\\ RCV_R(Nb'.Sid.Pa.{R.Kr'}_inv(Kca)) =|>\n    State':= 4 /\\ Pms' := new()\n\t/\\ Mp' := PRF(Pms'.Na.Nb')\n        /\\ Finishedp' := PRF(Mp'.P.R.Na.Pa.Sid)\n        /\\ ClientKp' := KeyGen(P.Na.Nb'.Mp')\n        /\\ ServerKp' := KeyGen(R.Na.Nb'.Mp')\n        /\\ SND_R({Pms'}_(Kr).{Sn.Issuer.Sln.Aki.Kp}_inv(Km).{Finishedp'}_ClientKp') \n\t/\\ ____(EVENT_1)____(ClientKp,tls_pledgek,{P,____(EVENT_0)____})\n        /\\ secret(ServerKp,tls_registrark,{____(EVENT_2)____,____(EVENT_3)____})\n\t\n\t/\\ witness(P,R,auth_na_nb,Na.Nb')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ witness(P,M,auth_idev,Sn) %Masa can authenticate pledge on serialNumber\n\n\n  4. State  = ____(STATE_5)____ /\\ RCV_R( {PRF(PRF(Pms.Na.Nb).P.R.Na.Pa.Sid)}_KeyGen(R.Na.Nb'.PRF(Pms.Na.Nb))) =|>\n     State':= 6 /\\ Np'   := new()\n\t/\\ Assr' := new()\n\t/\\ Crdate' := new()\n\t/\\ SND_R({{Assr'.Np'.Sn.Crdate'.{R.Kr}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms.Na.Nb')) ) \n\t/\\ ____(EVENT_9)____(Np,sec_np_pr,{____(EVENT_8)____,R})\n\t/\\ ____(EVENT_11)____(P,____(EVENT_10)____,auth_na_nb2,Na.Nb)\n\t/\\ witness(P,R,auth_reg_cert,{R.Kr}_inv(Kca))%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\n  6. State  = ____(STATE_0)____ /\\ RCV_R({{Assr'.Np.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms'.Na.Nb'))) =|> \n     State':= 8 /\\ ____(EVENT_14)____(P,R,____(EVENT_15)____,{R.Kr'}_inv(Kca))\n\t/\\ request(____(EVENT_16)____,M,____(EVENT_17)____,Np)\n\t/\\ ____(EVENT_18)____(P,____(EVENT_19)____,auth_sn,Sn)\n\nend role\n\nrole registrar (____(PARAM_13)____, R, ____(PARAM_10)____     : ____(PARAM_17)____,\n\t\tKr, ____(PARAM_12)____, Kca     : public_key,\n   \t     \tKeyGen, ____(PARAM_16)____    : hash_func,\n\t     \t____(PARAM_15)____, ____(PARAM_14)____, ____(PARAM_11)____, RCV_M  : channel (dy))\nplayed_by R def=\n\n  local ____(VARIABLE_14)____, Np, Na, ____(VARIABLE_10)____, ____(VARIABLE_11)____, Nd,  ____(VARIABLE_15)____, ____(VARIABLE_9)____, Sid, ____(VARIABLE_12)____, Sidm, ____(VARIABLE_13)____  : text,\n\tSn, Crdate, Rcrdate     : text,\n\tState\t: nat,\n\tKp\t: public_key,\n\tIssuer\t: text,\n\tAki\t: text,  %authorityKeyIdentifier\n\tSln\t: text,  %subjectAltName\n\tFinishedp, Finishedm\t: hash(hash(text.text.text).agent.agent.text.text.text),\n\tClientKp, ServerKp, ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text)),\n\tMm\t: hash(text.text.text)\n\n\n  const sec_np_rm, auth_na_nb, auth_na_nb2, auth_reg_cert, auth_np, auth_np1, auth_nc_nd, auth_reg_certchain, auth_nc_nd2, tls_registrarrmk, tls_masarmk: protocol_id%,\n \n  init State := 1\n\n  transition\n\n  1. State  = ____(STATE_1)____ /\\ RCV_P(P.Na'.Sid'.Pa') =|>\n     State':= 3 /\\ Nb' := new() \n\t/\\ SND_P(Nb'.Sid'.Pa'.{R.Kr}_inv(Kca))\n\t/\\ witness(R,P,____(EVENT_20)____,____(EVENT_21)____)\n    \n  3. State  = 3 \n\t/\\ RCV_P({Pms'}_Kr.{Sn'.Issuer'.Sln'.Aki'.Kp'}_(inv(Km)).{Finishedp'}_ClientKp') \t\n\t/\\ Finishedp = PRF(PRF(Pms'.Na.Nb').P.R.Na.Pa.Sid)\n\t/\\ ClientKp = KeyGen(P.Na.Nb'.PRF(Pms'.Na.Nb'))=|>\n\n     State':= 9 \n\t/\\ ServerKp' := KeyGen(R.Na.Nb'.PRF(Pms'.Na.Nb'))\n\t/\\ SND_P( {PRF(PRF(Pms'.Na.Nb').P.R.Na.Pa.Sid)}_KeyGen(R.Na.Nb'.PRF(Pms'.Na.Nb')) )\n        /\\ request(R,P,auth_na_nb,Na.Nb) %%%%check registrar cert to authenticate pledge\n \n 9. State  = 9 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = ____(STATE_4)____ \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ ____(EVENT_27)____(ClientKm,tls_registrarrmk,{____(EVENT_26)____,M})\n\t/\\ secret(ServerKm,____(EVENT_29)____,{R,____(EVENT_28)____})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(____(EVENT_31)____,sec_np_rm,{R,____(EVENT_30)____})\n\t/\\ ____(EVENT_33)____(M,____(EVENT_32)____,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(____(EVENT_36)____,____(EVENT_37)____,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, ____(PARAM_19)____, ____(PARAM_26)____  : ____(PARAM_24)____,\n\t   Km, ____(PARAM_20)____, ____(PARAM_28)____  : public_key,\n   \t   KeyGen, PRF    : ____(PARAM_25)____,\n\t   Sn      \t: text, %serial Number \n           Issuer    \t: ____(PARAM_22)____,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t: text,  %subjectAltName\t\n\t   SND_R, RCV_R, ____(PARAM_18)____, RCV_P   : channel (____(PARAM_27)____))\nplayed_by M def=\n\n  local SeID, Assr , ____(VARIABLE_22)____, Nc, Nd, Pmsm, ____(VARIABLE_25)____, ____(VARIABLE_23)____ : ____(VARIABLE_24)____,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,____(EVENT_39)____,____(EVENT_38)____,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = ____(STATE_3)____ \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ ____(EVENT_43)____(M,P,____(EVENT_42)____,Np')\n\t/\\ ____(EVENT_44)____(____(EVENT_45)____,P,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n\t \n \nend role\n\n\nrole session(____(PARAM_35)____, ____(PARAM_30)____, ____(PARAM_29)____        : agent,\n             ____(PARAM_34)____, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: ____(PARAM_38)____,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: ____(PARAM_37)____,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local ____(VARIABLE_31)____, SR, SM, ____(VARIABLE_32)____, ____(VARIABLE_30)____, RM  : channel (dy)\n\n  composition\n\tpledge(P,S,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,S,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,S,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,____(VARIABLE_33)____,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\n____(ROLE_2)____\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm %confidentiality of Np\t\n\t____(GOAL_50)____ ____(GOAL_49)____,tls_registrark,tls_registrarrmk,tls_masarmk\n\tauthentication_on ____(GOAL_51)____\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\t____(GOAL_53)____ auth_na_nb2        \n\tauthentication_on ____(GOAL_54)____\n\tauthentication_on ____(GOAL_55)____\t\n\tauthentication_on ____(GOAL_56)____\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n\tauthentication_on auth_reg_certchain %% MASA can check registrar on RegistrarChain\n\tauthentication_on auth_np  %Registrar authenticates voucher by checking nonce Np.\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()",
        "complete:": "%% PROTOCOL*: Bootstrapping RemoteSecure Key Infrastructures (BRSKI)\n%% PURPOSE: (BRSKI) protocol provides a solution for a resource-constrained \n%\t     new device to automatically onboard the correct network in a secure manner.\n%\t     BRSKI specification refers the new device as 'pledge'. \n%\t     Protocol aims to establish a trusted relationship between pledge and the \n%\t     network operator/owner referred as 'registrar' in such a way so that \n%\t     they can assure and authenticate each other's identity. This is done using\n%\t     a singed 802.1AR iDevID cert which is installed into the device \n%\t     by the manufacturer during the manufacturing process. The iDevID cert indicates \n%\t     the manufacturer of the device, serial number of the device and type of the device.\n%\t     Manufacturer also installs a trust anchor of manufacturer's authorized signing authority\n%\t     (known as MASA) at compile time using which it can trust and verify the 'MASA'.\n\n\n%%\n%% REFERENCE: https://tools.ietf.org/pdf/draft-ietf-anima-bootstrapping-keyinfra-41.pdf\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Author1\n%% \\item Author2\n%% \\item Author3\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% Let P,R,M respectively represnts the pledge, registrar and MASA.\n%% Kp,Kr,Km represents their public key and kca denotes the public key of certificate authority.\n\n%%\n%% P --> R : P.Na.Sid.Pa\t\t[Pledge_hello (Part of TLS handshake)]\n%% R --> P : Nb.Sid.Pa.{R.Kr}_inv(Kca)\t[Registrar_hello (Part of TLS handshake)]\n%% P --> R : {Pms}_Kr.{Sn.Issuer.Sln.Aki.Kp}_inv(Km).{Finishedp}_ClientKp\t[Pledge_key_exchange (Part of TLS handshake)]\n%%\t  Mp : PRF(Pms.Na.Nb)\n%%\t  Finishedp : PRF(Mp.P.R.Na.Pa.Sid)\n%%\t  ClientKp  : KeyGen(P.Na.Nb.Mp)\n%%\t  ServerKp  : KeyGen(R.Na.Nb.Mp)\n%% R --> P : {Finishedp}_ServerKp\t[Registrar_key_exchange (Part of TLS handshake)]\n%% P --> R : {signed Pledge_voucher_request}_ClientKp\n%%\t  Pledge_voucher_rquest : {Assr'.Np'.Sn.Crdate'.{R.Kr}_inv(Kca)}_(inv(Kp))\n%% R --> M : R.Nc.Sidm.Pam\t\t[Registrar_hello (Part of TLS handshake)]\n%% M --> R : Nd.Sidm.Pam.{M.Km}_inv(Kca)\t[MASA_hello (Part of TLS handshake)]\n%%\t  Masa certificate ={M.Km}_inv(Kca)\n%% R --> M : {Pmsm}_Kr.{R.Kr}_inv(Kca).{Finishedm}_ClientKm [Registrar_key_exchange (Part of TLS handshake)]\n%%\t  Mm : PRF(Pmsm.Nc.Nd)\n%%\t  Finishedm : PRF(Mm.R.M.Nc.Pam.Sidm)\n%%\t  ClientKm  : KeyGen(R.Nc.Nd.Mm)\n%%\t  ServerKm  : KeyGen(M.Nc.Nd.Mm)\n%% M --> R : {Finishedm}_Serverm\t\t[MASA_key_exchange (Part of TLS handshake)]\n%% R --> M : {signed registrar_voucher_request}_ClientKm\n%%\t  registrar_voucher_request = {Assr.Np.Sn.Rcrdate'.Issuer.Prior-signed pledge_voucher_request}\n%% M --> R : {signed Voucher}_ServerKm\n%%\t  voucher = {Assr.Np.Sn.{R.Kr}_inv(Kca)}\n%% R --> P : {signed voucher}_ServerKp\n%% \\end{verbatim}\n%% LIMITATIONS:\n%%\\begin{itemize}\n%% \\item This formalisation is based on the abstracted version of BRSKI \n%% presented by in https://tools.ietf.org/pdf/draft-ietf-anima-bootstrapping-keyinfra-41.pdf. \n%% \\item We do consider nonceless voucher request in this modelling.\n%%\\end{itemize}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% NOTES:\n%% To initiate the bootstarping process, the pledge sends the iDevID as part of TLS session \n%% and establish a provisional TLS connection through a joint proxy. Once the provisional \n%% TLS connection is established pledge sends a signed voucher-request to the registrar \n%% which includes the information about the pledge such as assertion(Assr), nonce(Np),\n%% serial-number(Sn), created-on(Crdate), proximity-registrar-cert.\n%% While receiving the pledge voucher-request registrar determines if it is \n%% expecting such device if yes then it locates the device's MASA and sends MASA \n%% a signed registrar voucher-request that contains the entire pledge voucher-request.\n%% The registrar's voucher-request includes following information: assertion(Assr), nonce(Np),\n%% serial-number(Sn), created-on(Crdate) from the pledge voucher-request, idevid-issuer(Issuer)\n%% from the iDevID certificate and entire pledge voucher-request in prior-signed-voucher-request field.\n%% Then MASA checks its record with respect to the provided device serial number in the voucher-request.\n%% if the voucher-request is accepted, a voucher is issued. Voucher contains assertion(Assr), \n%% nonce(Np), serial-number(Sn) and pinned-domain-cert. Registrar redeems the voucher by passing \n%% it to the pledge. Pledge validates the signed voucher using the pre-installed \\textit{MASA}'s trust anchor.\n%% The pledge also verifies the registrar using the pinned-domain cert and completes the authentication of \n%% provisional TLS connection. The pledge returns a voucher telemetry status indicating voucher acceptance status.\n\n%% HLPSL:\n\nrole pledge (P, R, M        : agent,\n\t     Kr, Km, Kca    : public_key,\n\t     KeyGen, PRF    : hash_func,\n\t     Sn      \t    : text, %devID serial Number \n             Issuer    \t    : text, %devID issuer\n             Aki\t    : text, %devID authorityKeyIdentifier\n             Sln\t    : text, %devID subjectAltName\t\n             SND_R, RCV_R, SND_M, RCV_M   : channel (dy))\nplayed_by P def=\n\nlocal\tNp, Na, Nb, Assr, Pms, Sid, Pa : text,\n\tCrdate                         : text,\n\tState                          : nat,\n\tKp                             : public_key,\n\tFinishedp\t    : hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKp, ServerKp  : hash(agent.text.text.hash(text.text.text)),\n        Mp\t\t    : hash(text.text.text)\n\nconst sec_np_pr, auth_np, auth_sn, auth_na_nb, auth_reg_cert, auth_na_nb2, auth_idev, auth_reg_certchain, tls_pledgek, tls_registrark : protocol_id%,\n\n  init State := 0\n\n  transition\n\n 0. State  = 0 /\\ RCV_R(start) =|>\n    State':= 2 \n\t/\\ Na' := new()\n\t/\\ Pa' := new()\n\t/\\ Sid' := new()\n\t/\\ SND_R(P.Na'.Sid'.Pa')\n\n\n 2. State  = 2 /\\ RCV_R(Nb'.Sid.Pa.{R.Kr'}_inv(Kca)) =|>\n    State':= 4 /\\ Pms' := new()\n\t/\\ Mp' := PRF(Pms'.Na.Nb')\n        /\\ Finishedp' := PRF(Mp'.P.R.Na.Pa.Sid)\n        /\\ ClientKp' := KeyGen(P.Na.Nb'.Mp')\n        /\\ ServerKp' := KeyGen(R.Na.Nb'.Mp')\n        /\\ SND_R({Pms'}_(Kr).{Sn.Issuer.Sln.Aki.Kp}_inv(Km).{Finishedp'}_ClientKp') \n\t/\\ secret(ClientKp,tls_pledgek,{P,R})\n        /\\ secret(ServerKp,tls_registrark,{P,R})\n\t\n\t/\\ witness(P,R,auth_na_nb,Na.Nb')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ witness(P,M,auth_idev,Sn) %Masa can authenticate pledge on serialNumber\n\n\n  4. State  = 4 /\\ RCV_R( {PRF(PRF(Pms.Na.Nb).P.R.Na.Pa.Sid)}_KeyGen(R.Na.Nb'.PRF(Pms.Na.Nb))) =|>\n     State':= 6 /\\ Np'   := new()\n\t/\\ Assr' := new()\n\t/\\ Crdate' := new()\n\t/\\ SND_R({{Assr'.Np'.Sn.Crdate'.{R.Kr}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms.Na.Nb')) ) \n\t/\\ secret(Np,sec_np_pr,{P,R})\n\t/\\ request(P,R,auth_na_nb2,Na.Nb)\n\t/\\ witness(P,R,auth_reg_cert,{R.Kr}_inv(Kca))%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\n  6. State  = 6 /\\ RCV_R({{Assr'.Np.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms'.Na.Nb'))) =|> \n     State':= 8 /\\ request(P,R,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\t/\\ request(P,M,auth_np,Np)\n\t/\\ request(P,M,auth_sn,Sn)\n\nend role\n\nrole registrar (P, R, M     : agent,\n\t\tKr, Km, Kca     : public_key,\n   \t     \tKeyGen, PRF    : hash_func,\n\t     \tSND_P, RCV_P, SND_M, RCV_M  : channel (dy))\nplayed_by R def=\n\n  local Assr, Np, Na, Nb, Nc, Nd,  Pms, Pmsm, Sid, Pa, Sidm, Pam  : text,\n\tSn, Crdate, Rcrdate     : text,\n\tState\t: nat,\n\tKp\t: public_key,\n\tIssuer\t: text,\n\tAki\t: text,  %authorityKeyIdentifier\n\tSln\t: text,  %subjectAltName\n\tFinishedp, Finishedm\t: hash(hash(text.text.text).agent.agent.text.text.text),\n\tClientKp, ServerKp, ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text)),\n\tMm\t: hash(text.text.text)\n\n\n  const sec_np_rm, auth_na_nb, auth_na_nb2, auth_reg_cert, auth_np, auth_np1, auth_nc_nd, auth_reg_certchain, auth_nc_nd2, tls_registrarrmk, tls_masarmk: protocol_id%,\n \n  init State := 1\n\n  transition\n\n  1. State  = 1 /\\ RCV_P(P.Na'.Sid'.Pa') =|>\n     State':= 3 /\\ Nb' := new() \n\t/\\ SND_P(Nb'.Sid'.Pa'.{R.Kr}_inv(Kca))\n\t/\\ witness(R,P,auth_na_nb2,Na'.Nb')\n    \n  3. State  = 3 \n\t/\\ RCV_P({Pms'}_Kr.{Sn'.Issuer'.Sln'.Aki'.Kp'}_(inv(Km)).{Finishedp'}_ClientKp') \t\n\t/\\ Finishedp = PRF(PRF(Pms'.Na.Nb').P.R.Na.Pa.Sid)\n\t/\\ ClientKp = KeyGen(P.Na.Nb'.PRF(Pms'.Na.Nb'))=|>\n\n     State':= 9 \n\t/\\ ServerKp' := KeyGen(R.Na.Nb'.PRF(Pms'.Na.Nb'))\n\t/\\ SND_P( {PRF(PRF(Pms'.Na.Nb').P.R.Na.Pa.Sid)}_KeyGen(R.Na.Nb'.PRF(Pms'.Na.Nb')) )\n        /\\ request(R,P,auth_na_nb,Na.Nb) %%%%check registrar cert to authenticate pledge\n \n 9. State  = 9 \n     /\\ RCV_P({{Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp))}_(KeyGen(P.Pms'.Na.Nb'))) =|>\n     State':= 11 \n\t/\\ Nc' := new() \n\t/\\ Pam' := new()\n\t/\\ Sidm' := new()\n\t/\\ SND_M(R.Nc'.Sidm'.Pam')\n     \n 11. State  = 11 \n     /\\ RCV_M(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)) =|> %Nd'.Sidm'.Pam'.{M.Km}_inv(Kca)\n     State':= 13 \n\t/\\ Pmsm' := new()\n\t/\\ Mm' := PRF(Pmsm'.Nc.Nd')\n\t/\\ Finishedm' := PRF(Mm'.R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm' := KeyGen(R.Nc.Nd'.Mm')\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.Mm')\n\n\t/\\ SND_M({Pmsm'}_(Km).{R.Kr}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ witness(R,M,auth_nc_nd2,Nc.Nd')%% so that registrar can authenticate pledge on {R.Kr'}_inv(Kca)\n\t/\\ secret(ClientKm,tls_registrarrmk,{R,M})\n\t/\\ secret(ServerKm,tls_masarmk,{R,M})\n\n\n 13. State  = 13 \n      /\\ RCV_M({PRF(PRF(Pmsm'.Nc'.Nd').R.M.Nc'.Pam.Sidm)}_KeyGen(M.Nc'.Nd'.PRF(Pmsm'.Nc'.Nd'))) =|>\n     State':= 15 \n\t/\\ Rcrdate':= new() \n\t/\\ SND_M({{Assr.Np.Sn.Rcrdate'.Issuer.({Assr.Np.Sn.Crdate.{R.Kr}_inv(Kca)}_(inv(Kp)))}_(inv(Kr)).{R.Kr}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd'))     \n\t/\\ secret(Np,sec_np_rm,{R,M})\n\t/\\ request(M,R,auth_nc_nd,Nc.Nd)\n\t/\\ request(R,P,auth_reg_cert,{R.Kr}_inv(Kca)) %%%%check registrar cert to authenticate pledge\n\t\n\t\n 15. State  = 15 \n     /\\ RCV_M({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd')) =|>\n     State':= 17 /\\ SND_P({{Assr'.Np'.Sn'.{R.Kr'}_inv(Kca)}_(inv(Km))}_(KeyGen(R.Pms.Na.Nb)))\n\t/\\ witness(R,P,auth_reg_certchain,{R.Kr'}_inv(Kca))\n\nend role\n\nrole masa (P, R, M  : agent,\n\t   Km, Kp, Kca  : public_key,\n   \t   KeyGen, PRF    : hash_func,\n\t   Sn      \t: text, %serial Number \n           Issuer    \t: text,\n           Aki\t        : text,  %authorityKeyIdentifier\n           Sln\t    \t: text,  %subjectAltName\t\n\t   SND_R, RCV_R, SND_P, RCV_P   : channel (dy))\nplayed_by M def=\n\n  local SeID, Assr , Np, Nc, Nd, Pmsm, Sidm, Pam : text,\n        Crdate, Rcrdate     : text,\n\tState               : nat,\n\tKr \t            : public_key,\n\tFinishedm: hash(hash(text.text.text).agent.agent.text.text.text),\n        ClientKm, ServerKm: hash(agent.text.text.hash(text.text.text))        \n\n  const auth_sn, auth_np, auth_np1, auth_idev, auth_reg_certchain, auth_reg_cert1,auth_nc_nd, auth_nc_nd2  : protocol_id%,\n       \n  init State := 5\n\n  transition\n\n1. State  = 5 \n\t/\\ RCV_R(R.Nc'.Sidm'.Pam') =|>     \n\tState':= 7\n     \t/\\ Nd' := new() \n\t/\\ SND_R(Nd'.Sidm'.Pam'.{M.Km}_inv(Kca))\n     \t/\\ witness(M,R,auth_nc_nd,Nc'.Nd')\n\n2. State  = 7 \n\t/\\ RCV_R({Pmsm'}_(Km').{R.Kr'}_inv(Kca).{Finishedm'}_ClientKm') \n\t/\\ Finishedm = PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)\n\t/\\ ClientKm = KeyGen(R.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))=|>\n     State':= 19\n\t/\\ ServerKm' := KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd'))\n        /\\ SND_R( {PRF(PRF(Pmsm'.Nc.Nd').R.M.Nc.Pam.Sidm)}_KeyGen(M.Nc.Nd'.PRF(Pmsm'.Nc.Nd')) )\n\t/\\ request(M,R,auth_nc_nd2,Nc.Nd) %%%%check registrar cert to authenticate pledge\n     \n3. State  = 19 \n\t/\\ RCV_R({{Assr'.Np'.Sn.Rcrdate'.Issuer'.({Assr'.Np'.Sn.Crdate'.{R.Kr'}_inv(Kca)}_(inv(Kp')))}_(inv(Kr')).{R.Kr'}_inv(Kca)}_KeyGen(R.Pmsm'.Nc.Nd')) =|>     \n\tState':= 21\n\t/\\ SND_R({{Assr'.Np'.Sn.{R.Kr'}_inv(Kca)}_(inv(Km))}_KeyGen(M.Pmsm'.Nc.Nd'))\n\t/\\ witness(M,P,auth_np,Np')\n\t/\\ witness(M,P,auth_sn,Sn)\n\t/\\ request(M,P,auth_idev,Sn) %Authenticating plegde on serialnumber\n\t \n \nend role\n\n\nrole session(P, S, M        : agent,\n             Kp, Kr, Km, Kca\t: public_key,\n\t     KeyGen, PRF    \t: hash_func,\n\t     Sn      \t\t: text, %serial Number \n             Issuer    \t\t: text,\n             Aki\t\t: text,  %authorityKeyIdentifier\n             Sln\t\t: text  %subjectAltName\t\n\t     )\ndef=\n\n  local SP, SR, SM, RP, RR, RM  : channel (dy)\n\n  composition\n\tpledge(P,S,M,Kp,Km,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SP,RP,SM,RM)\n\t/\\ registrar(P,S,M,Kr,Km,Kca,KeyGen,PRF,SR,RR,SM,RM)\n\t/\\ masa(P,S,M,Km,Kp,Kca,KeyGen,PRF,Sn,Issuer,Aki,Sln,SM,RM,SP,RP)\n\nend role\n\nrole environment()\ndef=\n\n   const p,r,m\t\t\t: agent,\n         kp, kr, km, kca, ki    : public_key,\n         keygen, prf\t\t: hash_func,\n\t sn      \t\t: text, %serial Number \n         issuer    \t\t: text,\n         aki\t\t\t: text,  %authorityKeyIdentifier\n         sln\t\t\t: text   %subjectAltName\t\n\n   intruder_knowledge = {p,r,m,kp,kr,m,kca,ki,inv(ki)\n                        ,{i.ki}_inv(kca)     %%% 2nd session\n%                       ,{i.ki}_inv(kca)     %%% 3rd session\n                        }\n\n   composition\n \tsession(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\  session(p,r,m,kp,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,i,m,kp,ki,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(i,r,m,ki,kr,km,kca,keygen,prf,sn,issuer,aki,sln)\n%   /\\\tsession(p,r,i,kp,kr,ki,kca,keygen,prf,sn,issuer,aki,sln)\n\n\nend role\n\n\ngoal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tsecrecy_of sec_np_pr,sec_np_rm %confidentiality of Np\t\n\tsecrecy_of tls_pledgek,tls_registrark,tls_registrarrmk,tls_masarmk\n\tauthentication_on auth_sn\n\tauthentication_on auth_na_nb %Registrar can authenticate pledge on its TLS certificate\n\tauthentication_on auth_na_nb2        \n\tauthentication_on auth_reg_cert\n\tauthentication_on auth_nc_nd\t\n\tauthentication_on auth_nc_nd2\n\tauthentication_on auth_idev  %Masa can authenticate pledge on serialNumber and subjectkeyidentifier\n\tauthentication_on auth_reg_certchain %% MASA can check registrar on RegistrarChain\n\tauthentication_on auth_np  %Registrar authenticates voucher by checking nonce Np.\n        authentication_on auth_np1 %Plegde authenticates voucher by checking nonce Np.\n\nend goal\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/calp-v3.hlpsl",
        "incomplete": "%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), un lecteur de badge (LB)\n%% Deux cas de figures :  - une demande d'acc\u00e8s normal (1)\n%%\t\t\t  - une demande d'acc\u00e8s exceptionnel (2)\n%% B_S:\n%% Badgeuse -> Serveur : {IdBageuse, IdEmploye}_PKs\n%%Serveur -> Badgeuse : { ClefSession}_PKb\n%%Badgeuse -> Serveur: { Msg}_ClefSession\n%%Serveur -> Badgeuse: { ok.H(Msg)}_ClefSession\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le badgeuse, initiant le protocole\nrole badgeuse (____(PARAM_1)____, ____(PARAM_7)____: agent,\n\t    ____(PARAM_0)____, ____(PARAM_6)____,____(PARAM_3)____ : protocol_id,\n            TypeAction : protocol_id,            \n            ____(PARAM_5)____, ____(PARAM_4)____: public_key,\n\t    H: ____(PARAM_2)____,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local ____(VARIABLE_0)____: nat,\n  Action: text,\n  ClefSession : symmetric_key\n  init State:=0\n  \n  transition  \n   \n    0.  State=____(STATE_1)____ /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ ____(EVENT_0)____(____(EVENT_1)____,idemploye,{B,S}) /\\ witness(____(EVENT_2)____,____(EVENT_3)____,badgeuse_serveur,IdEmploye.IdBadgeuse)\n    2.  State=1 /\\ RCV({ClefSession'.IdServeur}_PKb) =|> \n\tState':=2 /\\ SND({TypeAction}_ClefSession) \n    3.  State=____(STATE_0)____ /\\ RCV({TypeAction.Action'}_ClefSession) =|>\n        State':=3 /\\ SND({ok.H(Action')}_ClefSession) /\\ request(B,S,____(EVENT_5)____, ____(EVENT_4)____)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, ____(PARAM_9)____: ____(PARAM_15)____,\n            IdEmploye, ____(PARAM_16)____,____(PARAM_11)____,____(PARAM_12)____ : protocol_id,\n\t    ____(PARAM_13)____: text,\n\t    ____(PARAM_8)____,PKs: ____(PARAM_10)____,\n\t    H: hash_func,\n\t    SND,RCV: channel(____(PARAM_14)____))\nplayed_by S def=\n\n  local ____(VARIABLE_1)____: nat,\n  ClefSession: symmetric_key\n  init State:=0\n\n  transition\n    \n    1.  State=____(STATE_2)____ /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ ClefSession':=new() /\\ secret(____(EVENT_7)____, sessionkey,{____(EVENT_6)____,S}) /\\ SND({ClefSession.IdServeur}_PKb) /\\secret(____(EVENT_9)____,____(EVENT_8)____,{B,S}) /\\ ____(EVENT_10)____(S,____(EVENT_11)____,serveur_badgeuse,IdEmploye.IdBadgeuse)\n\n    2.  State=1 /\\ RCV({TypeAction}_ClefSession) =|>\n        State':=2 /\\ SND({TypeAction.Action}_ClefSession) /\\ secret(____(EVENT_12)____, act,{____(EVENT_13)____,S})\n\n    3.  State=2 /\\ RCV({ok.H(Action)}_ClefSession) =|>\n        State':=3 /\\ ____(EVENT_14)____(____(EVENT_15)____,B,serveur_badgeuse, IdEmploye.IdBadgeuse)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(____(PARAM_20)____, S: ____(PARAM_21)____, ____(PARAM_23)____, PKb: ____(PARAM_22)____, IdEmploye,IdBadgeuse,IdServeur,____(PARAM_17)____ : protocol_id,H:____(PARAM_18)____,Action:____(PARAM_19)____) def=\n\n  local SB, RB, ____(VARIABLE_3)____, ____(VARIABLE_2)____: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,PKb,PKs,H,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,Action,PKs,PKb,H,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const ____(VARIABLE_4)____,____(VARIABLE_5)____ : agent,\n\t  pks, pkb, pki: public_key,\n          h:hash_func,\n          idemploye, idbadgeuse, badgeuse_serveur,typeaction, serveur_badgeuse,act,sessionkey,idserveur: protocol_id,\n          idemployei:protocol_id,\n          action :text,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki),h,typeaction,idemployei}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemploye,idserveur, idbadgeuse,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemployei,idserveur, idbadgeuse,typeaction,h,action)\n\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of ____(GOAL_16)____,act\t\n\t____(GOAL_17)____ idemploye,idserveur\n\tauthentication_on ____(GOAL_18)____\n\tauthentication_on ____(GOAL_19)____\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()",
        "complete:": "%% PROTOCOL: CALP:Control Access Loria Protocol\n%% PURPOSE: Un serveur(S), un lecteur de badge (LB)\n%% Deux cas de figures :  - une demande d'acc\u00e8s normal (1)\n%%\t\t\t  - une demande d'acc\u00e8s exceptionnel (2)\n%% B_S:\n%% Badgeuse -> Serveur : {IdBageuse, IdEmploye}_PKs\n%%Serveur -> Badgeuse : { ClefSession}_PKb\n%%Badgeuse -> Serveur: { Msg}_ClefSession\n%%Serveur -> Badgeuse: { ok.H(Msg)}_ClefSession\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le badgeuse, initiant le protocole\nrole badgeuse (B, S: agent,\n\t    IdEmploye, IdBadgeuse,IdServeur : protocol_id,\n            TypeAction : protocol_id,            \n            PKb, PKs: public_key,\n\t    H: hash_func,      \n            SND, RCV: channel(dy)) \n\nplayed_by B def=\n\n  local State: nat,\n  Action: text,\n  ClefSession : symmetric_key\n  init State:=0\n  \n  transition  \n   \n    0.  State=0 /\\ RCV(start) =|> \n\tState':=1 /\\ SND({IdEmploye.IdBadgeuse}_PKs) /\\ secret(IdEmploye,idemploye,{B,S}) /\\ witness(B,S,badgeuse_serveur,IdEmploye.IdBadgeuse)\n    2.  State=1 /\\ RCV({ClefSession'.IdServeur}_PKb) =|> \n\tState':=2 /\\ SND({TypeAction}_ClefSession) \n    3.  State=2 /\\ RCV({TypeAction.Action'}_ClefSession) =|>\n        State':=3 /\\ SND({ok.H(Action')}_ClefSession) /\\ request(B,S,serveur_badgeuse, IdEmploye.IdBadgeuse)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% role serveur\nrole serveur (B, S: agent,\n            IdEmploye, IdBadgeuse,IdServeur,TypeAction : protocol_id,\n\t    Action: text,\n\t    PKb,PKs: public_key,\n\t    H: hash_func,\n\t    SND,RCV: channel(dy))\nplayed_by S def=\n\n  local State: nat,\n  ClefSession: symmetric_key\n  init State:=0\n\n  transition\n    \n    1.  State=0 /\\ RCV({IdEmploye.IdBadgeuse}_PKs) =|>\n        State':=1 /\\ ClefSession':=new() /\\ secret(ClefSession', sessionkey,{B,S}) /\\ SND({ClefSession.IdServeur}_PKb) /\\secret(IdServeur,idserveur,{B,S}) /\\ witness(S,B,serveur_badgeuse,IdEmploye.IdBadgeuse)\n\n    2.  State=1 /\\ RCV({TypeAction}_ClefSession) =|>\n        State':=2 /\\ SND({TypeAction.Action}_ClefSession) /\\ secret(Action, act,{B,S})\n\n    3.  State=2 /\\ RCV({ok.H(Action)}_ClefSession) =|>\n        State':=3 /\\ request(S,B,serveur_badgeuse, IdEmploye.IdBadgeuse)\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant une session\nrole session(B, S: agent, PKs, PKb: public_key, IdEmploye,IdBadgeuse,IdServeur,TypeAction : protocol_id,H:hash_func,Action:text) def=\n\n  local SB, RB, SS, RS: channel(dy)\n\n  composition \n\n\tbadgeuse(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,PKb,PKs,H,SB,RB)\n     /\\ serveur(B,S,IdEmploye,IdBadgeuse,IdServeur,TypeAction,Action,PKs,PKb,H,SS,RS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% d\u00e9finition du r\u00f4le caract\u00e9risant le scenario \u00e0 ex\u00e9cuter\nrole environment() def=\n\n    const b,s : agent,\n\t  pks, pkb, pki: public_key,\n          h:hash_func,\n          idemploye, idbadgeuse, badgeuse_serveur,typeaction, serveur_badgeuse,act,sessionkey,idserveur: protocol_id,\n          idemployei:protocol_id,\n          action :text,\n\t  ok : nat\n    intruder_knowledge = {b, s, pkb, pks, pki, inv(pki),h,typeaction,idemployei}\n\n    composition\n\n\tsession(b,s,pks,pkb,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(b,i,pkb,pki,idemploye, idbadgeuse,idserveur,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemploye,idserveur, idbadgeuse,typeaction,h,action)/\\\n\tsession(i,s,pki,pks,idemployei,idserveur, idbadgeuse,typeaction,h,action)\n\n\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\tsecrecy_of sessionkey,act\t\n\tsecrecy_of idemploye,idserveur\n\tauthentication_on badgeuse_serveur\n\tauthentication_on serveur_badgeuse\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% lancement du r\u00f4le principal\nenvironment()"
    },
    {
        "file": "HLPSL-1/CHAPv2.hlpsl",
        "incomplete": "%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole ____(ROLE_1)____ (____(PARAM_1)____,B   : agent,\n           \tKab   : ____(PARAM_2)____,\n\t   \t____(PARAM_4)____     : ____(PARAM_3)____,\n           \tSnd, ____(PARAM_0)____: channel(dy))\nplayed_by A\ndef=\n           \n  local ____(VARIABLE_0)____  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : ____(VARIABLE_1)____\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(____(MESSAGE_12)____) =|>\n      State' := 1 /\\ ____(MESSAGE_13)____(A)\n\n   2. State   = ____(STATE_0)____ /\\ ____(MESSAGE_14)____(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(____(MESSAGE_15)____))\n\t          /\\ witness(A,____(EVENT_1)____,____(EVENT_0)____,Na') \n\t\t  /\\ ____(EVENT_2)____(Kab,sec_kab1,{____(EVENT_3)____,B})\n\n   3. State   = 2 /\\ Rcv(H(____(MESSAGE_16)____)) =|> \n      State' := 3 /\\ ____(EVENT_4)____(____(EVENT_5)____,B,nb,Nb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                ____(PARAM_9)____ : ____(PARAM_7)____,\n\t\t____(PARAM_8)____: ____(PARAM_5)____,\n                Snd, ____(PARAM_6)____: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : ____(VARIABLE_2)____,\n        Na, Nb : text\n\n  const ____(VARIABLE_3)____ : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ ____(MESSAGE_17)____(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(____(MESSAGE_18)____)\n\t          /\\ witness(____(EVENT_6)____,A,nb,____(EVENT_7)____)\n\n   2. State   = ____(STATE_1)____ /\\ ____(MESSAGE_19)____(Na'.H(Kab.Na'.Nb.A)) =|>\n      State' := 2 /\\ Snd(H(____(MESSAGE_20)____))\n\t          /\\ request(B,____(EVENT_8)____,____(EVENT_9)____,Na') \n\t\t  /\\ ____(EVENT_11)____(Kab,sec_kab2,{A,____(EVENT_10)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole ____(ROLE_0)____(A,____(PARAM_12)____: ____(PARAM_10)____,\n\t     Kab: ____(PARAM_11)____,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, ____(VARIABLE_5)____, ____(VARIABLE_4)____: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : ____(VARIABLE_6)____,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(b,i,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole chap_Init (A,B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, Rcv: channel(dy))\nplayed_by A\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)\n\n   2. State   = 1 /\\ Rcv(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.Na'.Nb'.A))\n\t          /\\ witness(A,B,na,Na') \n\t\t  /\\ secret(Kab,sec_kab1,{A,B})\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na)) =|> \n      State' := 3 /\\ request(A,B,nb,Nb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH: hash_func,\n                Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab2 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')\n\t          /\\ witness(B,A,nb,Nb')\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.Na'.Nb.A)) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))\n\t          /\\ request(B,A,na,Na') \n\t\t  /\\ secret(Kab,sec_kab2,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(b,i,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/chebyshev_final.hlpsl",
        "incomplete": "____(ROLE_1)____ user(\n\t____(PARAM_2)____, ____(PARAM_1)____, RC : ____(PARAM_0)____,\n\tRPkeyi : symmetric_key, % used for registration phase(secure channel)\n\t% Discrete Chaotic Map (SIDj, xj, Tsj(xj)(mod p))\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Ui def=\n\n\tlocal\n\tState : ____(VARIABLE_0)____,\n\tPubj : (agent.text.message) set,\t\n\tCi, EHIDi : message,\n\tVi : hash(text.text.hash(text).text),\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTsj, Tri : message,\n\tIDi, PWi, Bi, Ri, RNi, RN1: text,\n\tXj, Trisj, TRN1, RN2: text,\n\tRN3: text.text, \t\n\t\n\tBhi : hash(text)\n\n\tinit\n\tState := 0\n\t/\\ Pubj := {}\n\n\ttransition\n\t% Registration phase\n\t0. State = ____(STATE_2)____ /\\ ____(MESSAGE_21)____(Sj.Xj'.Tsj')\n\t=|> State' := 2 /\\ Pubj' := cons(Sj.Xj'.Tsj', Pubj)\n\t/\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new()\n\t/\\ secret(____(EVENT_0)____, idi, ____(EVENT_1)____) /\\ ____(EVENT_3)____(PWi', ____(EVENT_2)____, Ui)\n\t/\\ secret(Bi', bi, Ui) % secrecy test\n\t/\\ Bhi' := BH(Bi') /\\ Ri' := new()\n\t/\\ Ci' := xor(Ri', Hash(IDi'.PWi'.Bhi'))\n\t/\\ Vi' := Hash(IDi'.PWi'.Bhi'.Ri')\n\t/\\ HIDi' := Hash(IDi'.Bhi')\n\t% check identity traceability\t\n\t/\\ ____(EVENT_7)____(HIDi, ____(EVENT_6)____, {____(EVENT_8)____, RC, Sj})\t\n\t/\\ ____(MESSAGE_22)____({HIDi'.Ci'.Vi'}_RPkeyi)\n\t\n\t2. State = ____(STATE_1)____ /\\ Rcv({____(MESSAGE_23)____}_RPkeyi) /\\ in(Sj.Xj'.Tsj', Pubj)\n\t=|> State' := 4\n\t% login phase\n\t/\\ RNi' := new() /\\ RN1' := new()\n\t/\\ Tri' := exp(Xj, RNi')\n\t% encryption instead of multiplication\t\n\t/\\ EHIDi' := {HIDi}_exp(Tsj',RNi') \n\t% symmetric encryption instead of chebyshev polynomial\n\t/\\ TRN1' := {RN1'}_UIDi %T_{RN1'}(UIDi)\n\t%/\\ Snd(Sj.Tri'.EHIDi'.TRN1')\n\t/\\ Snd(____(MESSAGE_25)____)\n\t/\\ ____(MESSAGE_26)____(Sj.EHIDi')\n\t/\\ Snd(____(MESSAGE_27)____)\n\t% authentication property\n\t/\\ witness(____(EVENT_9)____, ____(EVENT_10)____, rn1, RN1')\n\t/\\ RN3' := HIDi.RN1\n\t% authentication phase\n\n\t4. State = 4 /\\ ____(MESSAGE_28)____({RN2'}_RN3)\n\t=|> State' := 6\n\t/\\ request(Ui, ____(EVENT_12)____, ____(EVENT_11)____, RN2')\n\nend ____(ROLE_2)____\n\nrole server(\n\t____(PARAM_3)____, ____(PARAM_5)____, RC: agent,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Sj def=\n\n\tlocal\n\t____(VARIABLE_1)____ : nat,\n\tRN1, RN2 : text,\t\n\tRN3 : text.text,\t\n\tKeyRing: (hash(hash(text.hash(text)).text).hash(hash(text.hash(text)).text)) set,\n\tPKeyj : text, %public key(x_j) of discrete chebyshev\n\tTPKeyj : message, %public key (T_{x_j}(x_j)) of discrete chebyshev\n\tSKeyj : text, %secret key\n\tHIDi : hash(text.hash(text)),\n\tUIDi, XIDi: hash(hash(text.hash(text)).text),\n\tTri, Ex1 : message\n\n\tinit\n\tState := 0\n\t/\\ KeyRing := {}\n\n\ttransition\n\t% Server Registration phase\n\t0. State = ____(STATE_3)____ /\\ ____(MESSAGE_29)____(start)\n\t=|> State' := 1 /\\ Snd({____(MESSAGE_30)____}_RPKeyj)\n\t\n\t1. State = ____(STATE_0)____ /\\ ____(MESSAGE_31)____({PKeyj'.TPKeyj'.SKeyj'}_RPKeyj)\n\t=|> State' := 2\n\t/\\ Snd(Sj.PKeyj'.TPKeyj')\t% release public key\n\n\t% Registration phase\n\t2. State = ____(STATE_4)____ /\\ ____(MESSAGE_33)____({HIDi'.UIDi'}_RPKeyj) /\\ not(in(XIDi'.UIDi', KeyRing))\n\t=|> State' := 3\n\t/\\ XIDi' := Hash(HIDi'.SKeyj)\n\t/\\ KeyRing' := cons(XIDi'.UIDi', KeyRing)\n\n\t% Login phase\n\t%3. State = 3 /\\ Rcv(Sj.Tri'.{HIDi'}_Ex1'.{RN1'}_UIDi')  /\\ Ex1' = exp(Tri',SKeyj) /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)\n\t3. State = 3 /\\ Rcv(____(MESSAGE_35)____)  /\\ Ex1' = exp(Tri',SKeyj) /\\ ____(MESSAGE_36)____(Sj.{HIDi'}_Ex1') /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)/\\ Rcv(Sj.{____(MESSAGE_37)____}_UIDi')\n\t=|> State' := 5\n\t/\\ RN2' := new()\n\t/\\ RN3' := HIDi.RN1\n\t/\\ Snd({____(MESSAGE_38)____}_RN3')\n\t/\\ request(Sj, ____(EVENT_13)____, rn1, ____(EVENT_14)____)\n\t/\\ witness(____(EVENT_15)____, ____(EVENT_16)____, rn2, RN2)\t\n\t%/\\ request(Sj, Ui, rn2, RN2)\n\t\n\t\nend role\n\n% Registration Server\nrole regserver(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key, % secure channel w/ Ui\n\tRPKeyj : symmetric_key, % secure channel w/ Sj\n\tHash : ____(PARAM_10)____,\n\tBH : hash_func, % biohash function\n\tSndi, ____(PARAM_6)____, ____(PARAM_11)____ : channel(dy))\nplayed_by RC def=\n\n\tlocal\n\t____(VARIABLE_2)____ : nat,\n\tUri  : text,\n\tCi : message,\n\tVi : hash(text.text.hash(text).text),\n\tXj, SKj : text,\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTXj : message\n\n\tinit\n\tState := 0\n\t\n\ttransition\n\t% Server Registration\n\t0. State = 0 /\\ ____(MESSAGE_39)____({Sj}_RPKeyj)\n\t=|> State' := 1\n\t/\\ Xj' := new()\n\t/\\ SKj' := new()\n\t/\\ TXj' := exp(Xj', SKj')\n\t%/\\ Sndi(Sj.Xj'.TXj')\n\t/\\ Sndj({Xj'.TXj'.SKj'}_RPKeyj)\n\t/\\ secret(____(EVENT_20)____, ____(EVENT_19)____, {Sj, RC}) \n\t\n\t% User Registration\t\n\t1. State = 1 /\\ Rcv({____(MESSAGE_40)____}_RPKeyi)\n\t=|> State' := 1\n\t/\\ Uri' := new()\n\t/\\ UIDi' := Hash(HIDi'.Uri')\n\t/\\ Sndi({UIDi'.Ci'.Vi'}_RPKeyi)\n\t/\\ Sndj({HIDi'.UIDi'}_RPKeyj)\nend role\n\nrole session(\n\tUi, Sj, RC : ____(PARAM_15)____,\n\tRPKeyi : ____(PARAM_12)____,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\t%Pubj : (agent.message.message) set,\n\t%PKeyj : text,\n\t%SKeyj : message, % secret key of server\n\tHash : hash_func,\n\tBH : hash_func)\ndef=\n\tlocal SI, SJ, ____(VARIABLE_6)____, ____(VARIABLE_4)____, RR, ____(VARIABLE_5)____, ____(VARIABLE_3)____ : channel(dy)\n\n\tcomposition\n\tuser(Ui, Sj, RC, RPKeyi, Hash, BH, SI, SJ)\n\t/\\ server(Ui, Sj, RC, RPKeyj, Hash, BH, RI, RJ)\n\t/\\ regserver(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH, SRI, SRJ, RR)\nend role\n\nrole environment()\ndef=\n\tconst\n\t____(VARIABLE_7)____, ____(VARIABLE_9)____, bi, hidi, rn1, ____(VARIABLE_8)____, skj : protocol_id,\n\ta1, a2, b, r : agent,\n\tkar1, kar2, kir, kbr : symmetric_key,\n\tskeyj : text,\n\tpkeyj : text,\n\th : hash_func,\n\tbh : hash_func\n\n\tintruder_knowledge = {a1, a2, b, r, kir, h, bh}\n\t\n\tcomposition\n\tsession(a1, b, r, kar1, kbr, h, bh)\n\t%/\\ session(a2, b, r, kar2, kbr, h, bh)\n\t%/\\ session(i, b, r, kir, kbr, h, bh)\nend role\n\n____(ROLE_0)____\n\t____(GOAL_43)____ ____(GOAL_41)____, pwi, ____(GOAL_42)____, hidi, skj\n\tauthentication_on rn1, ____(GOAL_44)____\nend goal\n\nenvironment()",
        "complete:": "role user(\n\tUi, Sj, RC : agent,\n\tRPkeyi : symmetric_key, % used for registration phase(secure channel)\n\t% Discrete Chaotic Map (SIDj, xj, Tsj(xj)(mod p))\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Ui def=\n\n\tlocal\n\tState : nat,\n\tPubj : (agent.text.message) set,\t\n\tCi, EHIDi : message,\n\tVi : hash(text.text.hash(text).text),\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTsj, Tri : message,\n\tIDi, PWi, Bi, Ri, RNi, RN1: text,\n\tXj, Trisj, TRN1, RN2: text,\n\tRN3: text.text, \t\n\t\n\tBhi : hash(text)\n\n\tinit\n\tState := 0\n\t/\\ Pubj := {}\n\n\ttransition\n\t% Registration phase\n\t0. State = 0 /\\ Rcv(Sj.Xj'.Tsj')\n\t=|> State' := 2 /\\ Pubj' := cons(Sj.Xj'.Tsj', Pubj)\n\t/\\ IDi' := new() /\\ PWi' := new() /\\ Bi' := new()\n\t/\\ secret(IDi', idi, Ui) /\\ secret(PWi', pwi, Ui)\n\t/\\ secret(Bi', bi, Ui) % secrecy test\n\t/\\ Bhi' := BH(Bi') /\\ Ri' := new()\n\t/\\ Ci' := xor(Ri', Hash(IDi'.PWi'.Bhi'))\n\t/\\ Vi' := Hash(IDi'.PWi'.Bhi'.Ri')\n\t/\\ HIDi' := Hash(IDi'.Bhi')\n\t% check identity traceability\t\n\t/\\ secret(HIDi, hidi, {Ui, RC, Sj})\t\n\t/\\ Snd({HIDi'.Ci'.Vi'}_RPkeyi)\n\t\n\t2. State = 2 /\\ Rcv({UIDi'.Ci.Vi}_RPkeyi) /\\ in(Sj.Xj'.Tsj', Pubj)\n\t=|> State' := 4\n\t% login phase\n\t/\\ RNi' := new() /\\ RN1' := new()\n\t/\\ Tri' := exp(Xj, RNi')\n\t% encryption instead of multiplication\t\n\t/\\ EHIDi' := {HIDi}_exp(Tsj',RNi') \n\t% symmetric encryption instead of chebyshev polynomial\n\t/\\ TRN1' := {RN1'}_UIDi %T_{RN1'}(UIDi)\n\t%/\\ Snd(Sj.Tri'.EHIDi'.TRN1')\n\t/\\ Snd(Sj.Tri')\n\t/\\ Snd(Sj.EHIDi')\n\t/\\ Snd(Sj.TRN1')\n\t% authentication property\n\t/\\ witness(Ui, Sj, rn1, RN1')\n\t/\\ RN3' := HIDi.RN1\n\t% authentication phase\n\n\t4. State = 4 /\\ Rcv({RN2'}_RN3)\n\t=|> State' := 6\n\t/\\ request(Ui, Sj, rn2, RN2')\n\nend role\n\nrole server(\n\tUi, Sj, RC: agent,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\tHash : hash_func, % cyptographic hash function\n\tBH : hash_func, % biohash function\n\tSnd, Rcv : channel(dy))\nplayed_by Sj def=\n\n\tlocal\n\tState : nat,\n\tRN1, RN2 : text,\t\n\tRN3 : text.text,\t\n\tKeyRing: (hash(hash(text.hash(text)).text).hash(hash(text.hash(text)).text)) set,\n\tPKeyj : text, %public key(x_j) of discrete chebyshev\n\tTPKeyj : message, %public key (T_{x_j}(x_j)) of discrete chebyshev\n\tSKeyj : text, %secret key\n\tHIDi : hash(text.hash(text)),\n\tUIDi, XIDi: hash(hash(text.hash(text)).text),\n\tTri, Ex1 : message\n\n\tinit\n\tState := 0\n\t/\\ KeyRing := {}\n\n\ttransition\n\t% Server Registration phase\n\t0. State = 0 /\\ Rcv(start)\n\t=|> State' := 1 /\\ Snd({Sj}_RPKeyj)\n\t\n\t1. State = 1 /\\ Rcv({PKeyj'.TPKeyj'.SKeyj'}_RPKeyj)\n\t=|> State' := 2\n\t/\\ Snd(Sj.PKeyj'.TPKeyj')\t% release public key\n\n\t% Registration phase\n\t2. State = 2 /\\ Rcv({HIDi'.UIDi'}_RPKeyj) /\\ not(in(XIDi'.UIDi', KeyRing))\n\t=|> State' := 3\n\t/\\ XIDi' := Hash(HIDi'.SKeyj)\n\t/\\ KeyRing' := cons(XIDi'.UIDi', KeyRing)\n\n\t% Login phase\n\t%3. State = 3 /\\ Rcv(Sj.Tri'.{HIDi'}_Ex1'.{RN1'}_UIDi')  /\\ Ex1' = exp(Tri',SKeyj) /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)\n\t3. State = 3 /\\ Rcv(Sj.Tri')  /\\ Ex1' = exp(Tri',SKeyj) /\\ Rcv(Sj.{HIDi'}_Ex1') /\\ in(Hash(HIDi'.SKeyj).UIDi', KeyRing)/\\ Rcv(Sj.{RN1'}_UIDi')\n\t=|> State' := 5\n\t/\\ RN2' := new()\n\t/\\ RN3' := HIDi.RN1\n\t/\\ Snd({RN2'}_RN3')\n\t/\\ request(Sj, Ui, rn1, RN1)\n\t/\\ witness(Sj, Ui, rn2, RN2)\t\n\t%/\\ request(Sj, Ui, rn2, RN2)\n\t\n\t\nend role\n\n% Registration Server\nrole regserver(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key, % secure channel w/ Ui\n\tRPKeyj : symmetric_key, % secure channel w/ Sj\n\tHash : hash_func,\n\tBH : hash_func, % biohash function\n\tSndi, Sndj, Rcv : channel(dy))\nplayed_by RC def=\n\n\tlocal\n\tState : nat,\n\tUri  : text,\n\tCi : message,\n\tVi : hash(text.text.hash(text).text),\n\tXj, SKj : text,\n\tHIDi : hash(text.hash(text)),\n\tUIDi : hash(hash(text.hash(text)).text),\n\tTXj : message\n\n\tinit\n\tState := 0\n\t\n\ttransition\n\t% Server Registration\n\t0. State = 0 /\\ Rcv({Sj}_RPKeyj)\n\t=|> State' := 1\n\t/\\ Xj' := new()\n\t/\\ SKj' := new()\n\t/\\ TXj' := exp(Xj', SKj')\n\t%/\\ Sndi(Sj.Xj'.TXj')\n\t/\\ Sndj({Xj'.TXj'.SKj'}_RPKeyj)\n\t/\\ secret(SKj', skj, {Sj, RC}) \n\t\n\t% User Registration\t\n\t1. State = 1 /\\ Rcv({HIDi'.Ci'.Vi'}_RPKeyi)\n\t=|> State' := 1\n\t/\\ Uri' := new()\n\t/\\ UIDi' := Hash(HIDi'.Uri')\n\t/\\ Sndi({UIDi'.Ci'.Vi'}_RPKeyi)\n\t/\\ Sndj({HIDi'.UIDi'}_RPKeyj)\nend role\n\nrole session(\n\tUi, Sj, RC : agent,\n\tRPKeyi : symmetric_key,\n\tRPKeyj : symmetric_key, % used for registration phase(secure channel)\n\t%Pubj : (agent.message.message) set,\n\t%PKeyj : text,\n\t%SKeyj : message, % secret key of server\n\tHash : hash_func,\n\tBH : hash_func)\ndef=\n\tlocal SI, SJ, RI, RJ, RR, SRI, SRJ : channel(dy)\n\n\tcomposition\n\tuser(Ui, Sj, RC, RPKeyi, Hash, BH, SI, SJ)\n\t/\\ server(Ui, Sj, RC, RPKeyj, Hash, BH, RI, RJ)\n\t/\\ regserver(Ui, Sj, RC, RPKeyi, RPKeyj, Hash, BH, SRI, SRJ, RR)\nend role\n\nrole environment()\ndef=\n\tconst\n\tidi, pwi, bi, hidi, rn1, rn2, skj : protocol_id,\n\ta1, a2, b, r : agent,\n\tkar1, kar2, kir, kbr : symmetric_key,\n\tskeyj : text,\n\tpkeyj : text,\n\th : hash_func,\n\tbh : hash_func\n\n\tintruder_knowledge = {a1, a2, b, r, kir, h, bh}\n\t\n\tcomposition\n\tsession(a1, b, r, kar1, kbr, h, bh)\n\t%/\\ session(a2, b, r, kar2, kbr, h, bh)\n\t%/\\ session(i, b, r, kir, kbr, h, bh)\nend role\n\ngoal\n\tsecrecy_of idi, pwi, bi, hidi, skj\n\tauthentication_on rn1, rn2\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/CRAM-MD5.hlpsl",
        "incomplete": "%% PROTOCOL: CRAM-MD5 Challenge-Response Authentication Mechanism\n%% PURPOSE:\n%% CRAM-MD5 is intended to provide an authentication extension to\n%% IMAP4 that neither transfers passwords in cleartext nor requires\n%% significant security infrastructure in order to function.  To this end,\n%% the protocol assumes a shared password (which we model, without loss of\n%% generality, as a shared cryptographic key) between the IMAP4 server\n%% (called S in our model) and each client A.  Only a hash value of\n%% the shared password is ever sent over the network, thus precluding\n%% plaintext transmission.\n%% \n%% REFERENCE:\n%% RFC 2195~\\cite{RFC2195}\n%% MODELER:\n%% Paul Hankes Drielsma, ETH Z\\\"urich, July 2004\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% Alice-Bob Notation:\n%%  1. A -> S: A\n%%  2. S -> A: Ns.T.S\n%%  3. A -> S: F(SK.T)\n%%  where\n%%      Ns is a nonce generated by the server;\n%%      T is a timestamp (currently abstracted with a nonce)\n%%      SK is the shared key between A and S\n%%      F is a cryptographic hash function (MD5 in practice, but this is\n%%       unimportant for our purposes).  The use of F\n%%       is intended to ensure that only a digest of the shared\n%%       key is transmitted, with T assuring freshness of the \n%%       generated hash value.\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item We abstract away from the timestamp \\verb|T| using a \n%% standard nonce.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%% NOTES:\n%% RFC 2195~\\cite{RFC2195} states that the first message from the \n%% server S begins with a \"presumptively arbitrary string of random \n%% digits\"; that is, a nonce.  Unspecified, however, is what the \n%% client should do with this nonce.  It does not appear in subsequent\n%% protocol message.  We therefore presume it is intended to\n%% ensure replay protection, but our HLPSL specification at present does not \n%% explicitly model that the client should maintain a list of nonces\n%% previously received from the server.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole client(____(PARAM_1)____, S: agent,\n\t    ____(PARAM_0)____: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local  ____(VARIABLE_0)____ : nat, \n         T, Ns : text\n\n  const  sec_SK : ____(VARIABLE_1)____\n\n  init   State := 0\n\n  transition \n\n  1. State = ____(STATE_1)____   /\\ RCV(start) \n     =|>\n     State' := 1 /\\ SND(A)\n\n  2. State = ____(STATE_0)____   /\\ RCV(Ns'.T'.S)\n     =|>\n     State' := 2 /\\ SND(F(SK.T')) \n                 /\\ ____(EVENT_0)____(____(EVENT_1)____,S,auth,F(SK.T')) \n                 /\\ secret(____(EVENT_3)____,sec_SK,{____(EVENT_2)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole server(____(PARAM_2)____ : agent,\n\t    K, ____(PARAM_5)____: hash_func,\n\t    SND, ____(PARAM_4)____: channel (____(PARAM_3)____))\nplayed_by S\ndef=\n\n  local State : ____(VARIABLE_2)____,\n        A     : agent,\n        T, Ns : text,\n        Auth  : hash(hash(agent.agent).text)\n\n  init  State := 0\n\n  transition \n   1. State = 0   /\\ RCV(A') \n      =|>\n      State' := 1 /\\ Ns' := new()\n                  /\\ T' := new()\n                  /\\ SND(Ns'.T'.S)\n\n   2. State = 1   /\\ RCV(F(K(A.S).T)) \n      =|>\n      State' := 2 /\\ Auth' := F(K(A.S).T) \n                  /\\ ____(EVENT_4)____(S,A,auth,F(K(____(EVENT_5)____).T))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, S: agent,\n             ____(PARAM_6)____, ____(PARAM_7)____: ____(PARAM_8)____)\ndef=\n\n  local SK: hash(____(VARIABLE_3)____),\n        SNDA, SNDS, RCVA, RCVS: channel (dy)\n\n  init SK := K(A.S)\n\n  composition\n       client(A,S,SK,F,SNDA,RCVA)\n    /\\ server(S,K,F,SNDS,RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole ____(ROLE_0)____()\ndef=\n\n const ____(VARIABLE_4)____, s : agent,\n       k, f : hash_func,\n       auth : protocol_id\n\n intruder_knowledge = {a,s,i,f}\n\n composition\n      session(a,s,k,f)\n   /\\ session(i,s,k,f)\n   /\\ session(a,s,k,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_SK  % Addresses G12\n\n  %Server authenticates Client on auth\n  authentication_on auth  % Addresses G1, G2, G3\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: CRAM-MD5 Challenge-Response Authentication Mechanism\n%% PURPOSE:\n%% CRAM-MD5 is intended to provide an authentication extension to\n%% IMAP4 that neither transfers passwords in cleartext nor requires\n%% significant security infrastructure in order to function.  To this end,\n%% the protocol assumes a shared password (which we model, without loss of\n%% generality, as a shared cryptographic key) between the IMAP4 server\n%% (called S in our model) and each client A.  Only a hash value of\n%% the shared password is ever sent over the network, thus precluding\n%% plaintext transmission.\n%% \n%% REFERENCE:\n%% RFC 2195~\\cite{RFC2195}\n%% MODELER:\n%% Paul Hankes Drielsma, ETH Z\\\"urich, July 2004\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% Alice-Bob Notation:\n%%  1. A -> S: A\n%%  2. S -> A: Ns.T.S\n%%  3. A -> S: F(SK.T)\n%%  where\n%%      Ns is a nonce generated by the server;\n%%      T is a timestamp (currently abstracted with a nonce)\n%%      SK is the shared key between A and S\n%%      F is a cryptographic hash function (MD5 in practice, but this is\n%%       unimportant for our purposes).  The use of F\n%%       is intended to ensure that only a digest of the shared\n%%       key is transmitted, with T assuring freshness of the \n%%       generated hash value.\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item We abstract away from the timestamp \\verb|T| using a \n%% standard nonce.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%% NOTES:\n%% RFC 2195~\\cite{RFC2195} states that the first message from the \n%% server S begins with a \"presumptively arbitrary string of random \n%% digits\"; that is, a nonce.  Unspecified, however, is what the \n%% client should do with this nonce.  It does not appear in subsequent\n%% protocol message.  We therefore presume it is intended to\n%% ensure replay protection, but our HLPSL specification at present does not \n%% explicitly model that the client should maintain a list of nonces\n%% previously received from the server.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole client(A, S: agent,\n\t    SK: hash(agent.agent),\n\t    F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local  State : nat, \n         T, Ns : text\n\n  const  sec_SK : protocol_id\n\n  init   State := 0\n\n  transition \n\n  1. State = 0   /\\ RCV(start) \n     =|>\n     State' := 1 /\\ SND(A)\n\n  2. State = 1   /\\ RCV(Ns'.T'.S)\n     =|>\n     State' := 2 /\\ SND(F(SK.T')) \n                 /\\ witness(A,S,auth,F(SK.T')) \n                 /\\ secret(SK,sec_SK,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole server(S : agent,\n\t    K, F: hash_func,\n\t    SND, RCV: channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        A     : agent,\n        T, Ns : text,\n        Auth  : hash(hash(agent.agent).text)\n\n  init  State := 0\n\n  transition \n   1. State = 0   /\\ RCV(A') \n      =|>\n      State' := 1 /\\ Ns' := new()\n                  /\\ T' := new()\n                  /\\ SND(Ns'.T'.S)\n\n   2. State = 1   /\\ RCV(F(K(A.S).T)) \n      =|>\n      State' := 2 /\\ Auth' := F(K(A.S).T) \n                  /\\ request(S,A,auth,F(K(A.S).T))\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, S: agent,\n             K, F: hash_func)\ndef=\n\n  local SK: hash(agent.agent),\n        SNDA, SNDS, RCVA, RCVS: channel (dy)\n\n  init SK := K(A.S)\n\n  composition\n       client(A,S,SK,F,SNDA,RCVA)\n    /\\ server(S,K,F,SNDS,RCVS)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n\n const a, s : agent,\n       k, f : hash_func,\n       auth : protocol_id\n\n intruder_knowledge = {a,s,i,f}\n\n composition\n      session(a,s,k,f)\n   /\\ session(i,s,k,f)\n   /\\ session(a,s,k,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of SK\n  secrecy_of sec_SK  % Addresses G12\n\n  %Server authenticates Client on auth\n  authentication_on auth  % Addresses G1, G2, G3\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/crocus.hlpsl",
        "incomplete": "role alice ( \n\t____(PARAM_4)____,B:agent,\n\t____(PARAM_6)____,Yb:public_key,\n\tSign,KDF,____(PARAM_1)____,____(PARAM_2)____: ____(PARAM_5)____,\n\t____(PARAM_3)____,RCV:channel(____(PARAM_0)____)\n\t)\nplayed_by A def=\nlocal \n\tNa,Nb,____(VARIABLE_0)____,____(VARIABLE_1)____:nat,\n\tKa,Kb:nat, %%% Kex() --->>> Ka Ra\n\tT1,T2,T3,T4,H1,H2,H4,H3,H5,H6,REPLY,REQ:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 \n/\\ H1' := new() \n/\\ Na' := new()\n/\\ T1' := new()\n/\\ S1' := {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n/\\ SND(H1'.Na'.T1'.S1') /\\ ____(EVENT_1)____(A,B,____(EVENT_0)____,H1'.Na'.T1'.S1')\n\n2. State = ____(STATE_1)____ /\\ RCV(H2'.Nb'.T2'.S2') /\\ S2' = {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n=|> State' := 2 \n/\\ Ka' := new()\n/\\ H3':= new()\n/\\ S3' := {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n/\\ SND(H3'.KEX(Ka').S3') /\\ request(____(EVENT_3)____,B,aut2,____(EVENT_2)____) /\\ witness(A,____(EVENT_4)____,____(EVENT_5)____,H3'.KEX(Ka').S3')\n\n3. State = ____(STATE_0)____ /\\ RCV(H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) \n=|> State' := 3 \n/\\ H5' := new()\n/\\ T4' := new()\n/\\ REQ' := new()\n/\\ ET2' := {T4'.REQ'}_KDF(ECP(Ka,KEX(Kb')))\n/\\ S5' := {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ')}_inv(Ya)\n/\\ SND(H5'.ET2'.S5') /\\ request(A,____(EVENT_6)____,aut4,H4'.KEX(____(EVENT_7)____).ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) /\\ ____(EVENT_9)____(A,____(EVENT_8)____,aut5,H5'.ET2'.S5')\n/\\ ____(EVENT_11)____(REQ,____(EVENT_10)____,A)\n/\\ ____(EVENT_13)____(REQ,sec1,____(EVENT_12)____)\n\n4. State = ____(STATE_2)____ /\\ RCV(H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb))\n=|>\nState' := 4 /\\ ____(EVENT_14)____(A,B,____(EVENT_15)____,H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)) /\\ ____(EVENT_16)____(REPLY,sec2,____(EVENT_17)____) /\\ ____(EVENT_18)____(REPLY,____(EVENT_19)____,B)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____ (\n\t____(PARAM_12)____,____(PARAM_7)____:agent,\n\t____(PARAM_8)____,____(PARAM_10)____:public_key,\n\tSign,____(PARAM_13)____,ECP,KEX:hash_func,\n\tSND,____(PARAM_11)____:channel(____(PARAM_9)____)\n\t)\t\nplayed_by B def=\nlocal\n\t____(VARIABLE_3)____,Na,Ra,SID,____(VARIABLE_2)____,____(VARIABLE_5)____,____(VARIABLE_4)____,Rb:nat,\n\tT2,T3,H1,H2,H3,H4,H5,H6,T4,REQ,REPLY,T1,TT:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6,CK:message,\n\tState:nat\ninit State := 0\ntransition\n\n1. State =0 /\\ RCV(H1'.Na'.T1'.S1') /\\ S1' = {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n=|> State' := 1\n/\\ H2' := new() \n/\\ Nb' := new()\n/\\ T2' := new()\n/\\ S2' := {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n/\\ SND(H2'.Nb'.T2'.S2') /\\ ____(EVENT_21)____(____(EVENT_20)____,A,aut1,H1'.Na'.T1'.S1') /\\ ____(EVENT_23)____(B,____(EVENT_22)____,aut2,H2'.Nb'.T2'.S2')\n\n2. State = 1 /\\ RCV(H3'.KEX(Ka').S3') /\\ S3' = {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n=|> State' := 2 \n/\\ H4' :=new() \n/\\ Kb' := new()\n/\\ T3' := new()\n/\\ S4' := {Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)\n/\\ ET1' := {T3'}_KDF(ECP(Kb'.KEX(Ka')).A.B)\n/\\ SND(H4'.KEX(Kb').ET1'.S4') /\\ request(____(EVENT_25)____,A,____(EVENT_24)____,H3'.KEX(Ka').S3') /\\ witness(B,A,____(EVENT_27)____,H4'.KEX(____(EVENT_26)____).ET1'.S4')\n\n3. State = 2 /\\ RCV(H5'.ET2'.S5') /\\ S5' = {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3'.T4'.REQ')}_inv(Ya)\n%%%%{T4'.REQ'}_KDF(ECP(Ka,KEX(Kb)) \n=|> State':=3 \n/\\ REPLY' := new()\n/\\ H6' := new()\n/\\ ET3' := {REPLY'}_KDF(ECP(Kb,KEX(Ka)))\n/\\ S6' := {Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)\n/\\ SND(H6'.ET3'.S6') \n/\\ ____(EVENT_29)____(REPLY,sec2,____(EVENT_28)____)\n/\\ ____(EVENT_31)____(REPLY,sec2,____(EVENT_30)____)\n/\\ ____(EVENT_33)____(REQ,____(EVENT_32)____,A)\n/\\ ____(EVENT_35)____(REQ,____(EVENT_34)____,B)\n/\\ request(B,A,____(EVENT_37)____,____(EVENT_36)____) /\\ witness(____(EVENT_39)____,____(EVENT_38)____,aut6,H6'.ET3'.S6')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session ( A,B:____(PARAM_18)____,Ya,____(PARAM_16)____:____(PARAM_17)____,Sign,KDF,ECP,____(PARAM_15)____:____(PARAM_14)____ )\ndef=\nlocal SA,____(VARIABLE_7)____,RA,____(VARIABLE_6)____ : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SA,RA) \n/\\ bob(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____()\ndef=\n\nconst a,____(VARIABLE_8)____:agent,\nsec1,sec2,aut1,aut2,aut3,aut4,aut5,aut6: protocol_id,\nya,yb:public_key,\nsign:hash_func,\nkdf:hash_func,\necp:hash_func,\nkex:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,ecp,kex}\n\ncomposition\n\nsession(a,b,ya,yb,sign,kdf,ecp,kex)\n\nend role\n\ngoal\n\t____(GOAL_40)____ aut1\n\tauthentication_on ____(GOAL_41)____\n\tauthentication_on ____(GOAL_42)____\n\tauthentication_on ____(GOAL_43)____\n\t____(GOAL_44)____ aut5\n\t____(GOAL_45)____ aut6\n\tsecrecy_of ____(GOAL_46)____\n\t____(GOAL_47)____ sec2\nend goal\n\n\nenvironment()",
        "complete:": "role alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tNa,Nb,SID,Rb:nat,\n\tKa,Kb:nat, %%% Kex() --->>> Ka Ra\n\tT1,T2,T3,T4,H1,H2,H4,H3,H5,H6,REPLY,REQ:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 \n/\\ H1' := new() \n/\\ Na' := new()\n/\\ T1' := new()\n/\\ S1' := {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n/\\ SND(H1'.Na'.T1'.S1') /\\ witness(A,B,aut1,H1'.Na'.T1'.S1')\n\n2. State = 1 /\\ RCV(H2'.Nb'.T2'.S2') /\\ S2' = {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n=|> State' := 2 \n/\\ Ka' := new()\n/\\ H3':= new()\n/\\ S3' := {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n/\\ SND(H3'.KEX(Ka').S3') /\\ request(A,B,aut2,H2'.Nb'.T2'.S2') /\\ witness(A,B,aut3,H3'.KEX(Ka').S3')\n\n3. State = 2 /\\ RCV(H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) \n=|> State' := 3 \n/\\ H5' := new()\n/\\ T4' := new()\n/\\ REQ' := new()\n/\\ ET2' := {T4'.REQ'}_KDF(ECP(Ka,KEX(Kb')))\n/\\ S5' := {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ')}_inv(Ya)\n/\\ SND(H5'.ET2'.S5') /\\ request(A,B,aut4,H4'.KEX(Kb').ET1'.{Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)) /\\ witness(A,B,aut5,H5'.ET2'.S5')\n/\\ secret(REQ,sec1,A)\n/\\ secret(REQ,sec1,B)\n\n4. State = 3 /\\ RCV(H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb))\n=|>\nState' := 4 /\\ request(A,B,aut6,H6'.ET3'.{Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)) /\\ secret(REPLY,sec2,A) /\\ secret(REPLY,sec2,B)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tSign,KDF,ECP,KEX:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tNb,Na,Ra,SID,Q,Kb,Ka,Rb:nat,\n\tT2,T3,H1,H2,H3,H4,H5,H6,T4,REQ,REPLY,T1,TT:text,\n\tET1,ET2,ET3,S1,S2,S3,S4,S5,S6,CK:message,\n\tState:nat\ninit State := 0\ntransition\n\n1. State =0 /\\ RCV(H1'.Na'.T1'.S1') /\\ S1' = {Sign(H1'.A.Na'.T1'.B)}_inv(Ya)\n=|> State' := 1\n/\\ H2' := new() \n/\\ Nb' := new()\n/\\ T2' := new()\n/\\ S2' := {Sign(H2'.A.Na'.T1'.B.Nb'.T2')}_inv(Yb)\n/\\ SND(H2'.Nb'.T2'.S2') /\\ request(B,A,aut1,H1'.Na'.T1'.S1') /\\ witness(B,A,aut2,H2'.Nb'.T2'.S2')\n\n2. State = 1 /\\ RCV(H3'.KEX(Ka').S3') /\\ S3' = {Sign(H3'.A.Na.B.Nb.KEX(Ka'))}_inv(Ya)\n=|> State' := 2 \n/\\ H4' :=new() \n/\\ Kb' := new()\n/\\ T3' := new()\n/\\ S4' := {Sign(H4'.A.Na.B.Nb.KEX(Ka').KEX(Kb').T3')}_inv(Yb)\n/\\ ET1' := {T3'}_KDF(ECP(Kb'.KEX(Ka')).A.B)\n/\\ SND(H4'.KEX(Kb').ET1'.S4') /\\ request(B,A,aut3,H3'.KEX(Ka').S3') /\\ witness(B,A,aut4,H4'.KEX(Kb').ET1'.S4')\n\n3. State = 2 /\\ RCV(H5'.ET2'.S5') /\\ S5' = {Sign(H5'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3'.T4'.REQ')}_inv(Ya)\n%%%%{T4'.REQ'}_KDF(ECP(Ka,KEX(Kb)) \n=|> State':=3 \n/\\ REPLY' := new()\n/\\ H6' := new()\n/\\ ET3' := {REPLY'}_KDF(ECP(Kb,KEX(Ka)))\n/\\ S6' := {Sign(H6'.A.Na.B.Nb.KEX(Ka).KEX(Kb).T3.T4'.REQ'.REPLY')}_inv(Yb)\n/\\ SND(H6'.ET3'.S6') \n/\\ secret(REPLY,sec2,A)\n/\\ secret(REPLY,sec2,B)\n/\\ secret(REQ,sec1,A)\n/\\ secret(REQ,sec1,B)\n/\\ request(B,A,aut5,H5'.ET2'.S5') /\\ witness(B,A,aut6,H6'.ET3'.S6')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session ( A,B:agent,Ya,Yb:public_key,Sign,KDF,ECP,KEX:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SA,RA) \n/\\ bob(A,B,Ya,Yb,Sign,KDF,ECP,KEX,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nsec1,sec2,aut1,aut2,aut3,aut4,aut5,aut6: protocol_id,\nya,yb:public_key,\nsign:hash_func,\nkdf:hash_func,\necp:hash_func,\nkex:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,ecp,kex}\n\ncomposition\n\nsession(a,b,ya,yb,sign,kdf,ecp,kex)\n\nend role\n\ngoal\n\tauthentication_on aut1\n\tauthentication_on aut2\n\tauthentication_on aut3\n\tauthentication_on aut4\n\tauthentication_on aut5\n\tauthentication_on aut6\n\tsecrecy_of sec1\n\tsecrecy_of sec2\nend goal\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/device6g.hlpsl",
        "incomplete": "____(ROLE_1)____ device (____(PARAM_2)____:____(PARAM_5)____, KM:agent,\t\n\t____(PARAM_1)____,____(PARAM_0)____:____(PARAM_4)____,\n\tD,ND,NWS:____(PARAM_3)____,\n\t____(PARAM_6)____, RCV:channel (dy))\nplayed_by DEV\ndef=\nlocal ____(VARIABLE_0)____:nat,  \nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, ____(VARIABLE_2)____, ____(VARIABLE_1)____: protocol_id\n\ninit State:=0\n\ntransition\n\n1. State=____(STATE_0)____ /\\ RCV(start)=|> \nState':=1 /\\D':=new()\n/\\HNWS':=H(NWS)\n/\\HND':=H4B(ND)\n/\\Nonce':=new()\n/\\HM':=H4B(NWS.ND.Nonce'.D')\n/\\SND(HNWS'.HND'.Nonce'.HM'.D')\n/\\____(EVENT_1)____(____(EVENT_0)____,sec_1,{DEV,KM})\n/\\____(EVENT_3)____(ND,sec_2,{____(EVENT_2)____,KM})\n%%/\\witness(DEV,KM,auth_dev_km_hm1,HM')\n\nend role\n\n\nrole keymanager (KM,DEV:____(PARAM_7)____,\n\tH,____(PARAM_12)____:hash_func,\n\t____(PARAM_9)____,ND,NWS:____(PARAM_8)____,\n\t____(PARAM_10)____,____(PARAM_11)____:channel (dy))\nplayed_by KM\n\ndef=\nlocal State:____(VARIABLE_3)____,\nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, ____(VARIABLE_4)____, ____(VARIABLE_5)____: protocol_id\n\ninit State:=0\ntransition\n\n1. State=0/\\RCV(HNWS'.HND'.Nonce'.HM'.D')=|>\nState':=1 /\\ HM1':=H4B(NWS.ND.Nonce'.D')\n%%/\\request(DEV,KM,auth_dev_km_hm1,HM1')\n\nend role\n\n\nrole session(DEV:agent,____(PARAM_16)____:agent,\n\t____(PARAM_13)____,____(PARAM_14)____:hash_func,\n\tD,____(PARAM_17)____,NWS:____(PARAM_15)____)\n\ndef=\nlocal ____(VARIABLE_7)____,____(VARIABLE_6)____,____(VARIABLE_8)____,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\ndevice (DEV,KM,H,H4B,D,ND,NWS,SND1,RCV1)\n/\\keymanager (KM,DEV,H,H4B,D,ND,NWS,SND2,RCV2)\n\nend role\n\nrole environment()\ndef=\n\tconst\n\tdev,____(VARIABLE_9)____:____(VARIABLE_10)____,\n\th,h4b:hash_func,\n\td,nd,nws:text,\n\tnonce, hm, hm1, hnws, hnd : message,\n\tsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\n\tintruder_knowledge = {dev, km, nonce, hm, hm1, hnws, hnd, d}\n\n\tcomposition\n\t\tsession(dev,km,h,h4b,d,nd,nws)\n\t\t/\\ session(km,dev,h,h4b,d,nd,nws) \n\t\t\n\nend role\n\n____(ROLE_0)____\n\tsecrecy_of ____(GOAL_8)____\n\tsecrecy_of ____(GOAL_9)____\n\t%%authentication_on auth_dev_km_hm1\nend goal\nenvironment()",
        "complete:": "role device (DEV:agent, KM:agent,\t\n\tH,H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND, RCV:channel (dy))\nplayed_by DEV\ndef=\nlocal State:nat,  \nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\ninit State:=0\n\ntransition\n\n1. State=0 /\\ RCV(start)=|> \nState':=1 /\\D':=new()\n/\\HNWS':=H(NWS)\n/\\HND':=H4B(ND)\n/\\Nonce':=new()\n/\\HM':=H4B(NWS.ND.Nonce'.D')\n/\\SND(HNWS'.HND'.Nonce'.HM'.D')\n/\\secret(NWS,sec_1,{DEV,KM})\n/\\secret(ND,sec_2,{DEV,KM})\n%%/\\witness(DEV,KM,auth_dev_km_hm1,HM')\n\nend role\n\n\nrole keymanager (KM,DEV:agent,\n\tH,H4B:hash_func,\n\tD,ND,NWS:text,\n\tSND,RCV:channel (dy))\nplayed_by KM\n\ndef=\nlocal State:nat,\nNonce, HM, HM1, HNWS, HND:message\n\n\tconst\nsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\ninit State:=0\ntransition\n\n1. State=0/\\RCV(HNWS'.HND'.Nonce'.HM'.D')=|>\nState':=1 /\\ HM1':=H4B(NWS.ND.Nonce'.D')\n%%/\\request(DEV,KM,auth_dev_km_hm1,HM1')\n\nend role\n\n\nrole session(DEV:agent,KM:agent,\n\tH,H4B:hash_func,\n\tD,ND,NWS:text)\n\ndef=\nlocal SND1,RCV1,SND2,RCV2,SND3,RCV3:channel(dy)\n\tcomposition\ndevice (DEV,KM,H,H4B,D,ND,NWS,SND1,RCV1)\n/\\keymanager (KM,DEV,H,H4B,D,ND,NWS,SND2,RCV2)\n\nend role\n\nrole environment()\ndef=\n\tconst\n\tdev,km:agent,\n\th,h4b:hash_func,\n\td,nd,nws:text,\n\tnonce, hm, hm1, hnws, hnd : message,\n\tsec_1, sec_2, auth_dev_km_hm1: protocol_id\n\n\tintruder_knowledge = {dev, km, nonce, hm, hm1, hnws, hnd, d}\n\n\tcomposition\n\t\tsession(dev,km,h,h4b,d,nd,nws)\n\t\t/\\ session(km,dev,h,h4b,d,nd,nws) \n\t\t\n\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\t%%authentication_on auth_dev_km_hm1\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/device_registration.hlpsl",
        "incomplete": "%%% activation  \n%%% 1. device -> AS: SD.R1.{Hash(SD.R1)}_PS               SD,R1,HMAC(PS,SD||R1)    ->  SD,R1,En(PS,Hash(SD||R1)) \n%%% 2. AS -> device: SD.R2.{DS}_PS.{Hash(SD.R2.{DS}_PS)}_PS       SD,R2,En(PS,DS),HMAC(PS,SD||R2||En(PS,DS))\n%%% 3. device -> AS: SD.R3.{R2}_DS                         SD,R3,En(DS,R2)\n%%% 4. AS -> device: {R3}_DS                                En(DS,R3)\n\nrole device(SD,____(PARAM_1)____:____(PARAM_4)____,PS:symmetric_key,____(PARAM_2)____:____(PARAM_3)____,SND,____(PARAM_0)____:channel(dy))\nplayed_by SD\ndef=\n    local\n        State:____(VARIABLE_0)____,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=____(STATE_1)____ /\\ RCV(start) =|>\n           State':=1 /\\ R1':=new() /\\ SND(SD.R1'.{Hash(SD.R1')}_PS)  %Here I use En(PS, Hash(SD || R1)) instead of HMAC(PS, SD || R1)\n\n        2. State=____(STATE_0)____ /\\ RCV(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) =|>\n           State':=2 /\\ R3':=new() /\\ SND(SD.R3'.{R2'}_DS') /\\ ____(EVENT_0)____(____(EVENT_1)____,AS,auth_r2,R2')\n\n        3. State=2 /\\ RCV({R3}_DS) =|>\n\t   State':=3 /\\ request(SD,____(EVENT_3)____,____(EVENT_2)____,R3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____(____(PARAM_7)____,SD:agent,____(PARAM_9)____:____(PARAM_8)____,Hash:____(PARAM_6)____,SND,____(PARAM_5)____:channel(dy))\nplayed_by AS\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(SD.R1'.{Hash(SD.R1')}_PS) =|>\n           State':=1 /\\ DS':=new() /\\ R2':=new() /\\ SND(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) /\\ secret(DS',____(EVENT_4)____,{AS,____(EVENT_5)____}) \n\n        2. State=1 /\\ RCV(SD.R3'.{R2}_DS) =|>\n           State':=2 /\\ SND({R3'}_DS) /\\ witness(____(EVENT_7)____,SD,____(EVENT_6)____,R3') /\\ ____(EVENT_8)____(____(EVENT_9)____,SD,auth_r2,R2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____(SD,____(PARAM_12)____:____(PARAM_11)____,PS:symmetric_key,____(PARAM_10)____:hash_func)\ndef=\n    local\n        SND2,RCV2,____(VARIABLE_2)____,RCV1:channel(____(VARIABLE_1)____)\n    composition\n        device(SD,AS,PS,Hash,SND1,RCV1) /\\\n        authserver(AS,SD,PS,Hash,SND2,RCV2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n    const\n        sd1,____(VARIABLE_4)____,____(VARIABLE_3)____:agent,\n        ps:symmetric_key,\n        myhash:hash_func,\n        sec_ds,auth_r2,auth_r3:protocol_id\n\n        intruder_knowledge = {sd1, sd2, as, myhash}\n        composition\n            session(sd1,as,ps,myhash)\n            /\\ session(sd2,as,ps,myhash)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    ____(GOAL_10)____ sec_ds\n    authentication_on ____(GOAL_11)____\n    ____(GOAL_12)____ auth_r3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%%% activation  \n%%% 1. device -> AS: SD.R1.{Hash(SD.R1)}_PS               SD,R1,HMAC(PS,SD||R1)    ->  SD,R1,En(PS,Hash(SD||R1)) \n%%% 2. AS -> device: SD.R2.{DS}_PS.{Hash(SD.R2.{DS}_PS)}_PS       SD,R2,En(PS,DS),HMAC(PS,SD||R2||En(PS,DS))\n%%% 3. device -> AS: SD.R3.{R2}_DS                         SD,R3,En(DS,R2)\n%%% 4. AS -> device: {R3}_DS                                En(DS,R3)\n\nrole device(SD,AS:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by SD\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(start) =|>\n           State':=1 /\\ R1':=new() /\\ SND(SD.R1'.{Hash(SD.R1')}_PS)  %Here I use En(PS, Hash(SD || R1)) instead of HMAC(PS, SD || R1)\n\n        2. State=1 /\\ RCV(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) =|>\n           State':=2 /\\ R3':=new() /\\ SND(SD.R3'.{R2'}_DS') /\\ witness(SD,AS,auth_r2,R2')\n\n        3. State=2 /\\ RCV({R3}_DS) =|>\n\t   State':=3 /\\ request(SD,AS,auth_r3,R3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authserver(AS,SD:agent,PS:symmetric_key,Hash:hash_func,SND,RCV:channel(dy))\nplayed_by AS\ndef=\n    local\n        State:nat,\n        R1, R2, R3: text,\n        DS: symmetric_key\n    init\n        State := 0\n    transition\n        1. State=0 /\\ RCV(SD.R1'.{Hash(SD.R1')}_PS) =|>\n           State':=1 /\\ DS':=new() /\\ R2':=new() /\\ SND(SD.R2'.{DS'}_PS.{Hash(SD.R2'.{DS'}_PS)}_PS) /\\ secret(DS',sec_ds,{AS,SD}) \n\n        2. State=1 /\\ RCV(SD.R3'.{R2}_DS) =|>\n           State':=2 /\\ SND({R3'}_DS) /\\ witness(AS,SD,auth_r3,R3') /\\ request(AS,SD,auth_r2,R2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(SD,AS:agent,PS:symmetric_key,Hash:hash_func)\ndef=\n    local\n        SND2,RCV2,SND1,RCV1:channel(dy)\n    composition\n        device(SD,AS,PS,Hash,SND1,RCV1) /\\\n        authserver(AS,SD,PS,Hash,SND2,RCV2)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n    const\n        sd1,sd2,as:agent,\n        ps:symmetric_key,\n        myhash:hash_func,\n        sec_ds,auth_r2,auth_r3:protocol_id\n\n        intruder_knowledge = {sd1, sd2, as, myhash}\n        composition\n            session(sd1,as,ps,myhash)\n            /\\ session(sd2,as,ps,myhash)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n    secrecy_of sec_ds\n    authentication_on auth_r2\n    authentication_on auth_r3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/DHCP-delayed-auth.hlpsl",
        "incomplete": "%% PROTOCOL: DHCP-Delayed-Auth\n%% PURPOSE:\n%%    Delayed entity and message authentication for DHCP\n%%\n%% REFERENCE: RFC 3118, \\url{http://www.faqs.org/rfcs/rfc3118.html}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%%1. C -> S : C, delayedAuthReq, Time1\n%%2. S -> C : S, delayedAuthReq, succ(Time1), KeyID(K), \n%%            H(S, delayedAuthReq, succ(Time1), K)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%The RFC describes different options and checks in terms of key words MAY, MUST etc.\n%%This model is of the minimum protocol, i.e. only the MUST checks.\n%%In real life, message looks like\n%%\\begin{itemize}\n%%\\item 90 (auth requested), \n%%\\item length, \n%%\\item 1 (for delayed auth), \n%%\\item 1 (to indicate standard HMAC algorithm),\n%%\\item 0 (standard Replay Detection Mechanism, monotonically increasing counter),\n%%\\item counter value.\n%%\\end{itemize}\n%%We ignore length field (as it cannot be, yet, expressed in HLPSL), \n%%use fresh nonce to model RDM, and\n%%assume 'DelayedAuthReq' token is enough to specify algorithm, type of auth,\n%%and type of RDM.\n%%\n%%The server returns the nonce + 1 (or \\verb|succ(nonce)| to be exact) \n%%instead of a timestamp with a higher value.\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%%\n%% NOTES: Client is the initiator. Sends a DHCP discover and requests authentication\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(____(PARAM_1)____))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : ____(VARIABLE_1)____,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = ____(STATE_0)____\n      /\\ ____(MESSAGE_6)____(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ ____(MESSAGE_7)____(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ ____(MESSAGE_8)____(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ ____(EVENT_1)____(C,S,____(EVENT_0)____,Sig') \n      /\\ ____(EVENT_2)____(K,____(EVENT_3)____,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        ____(PARAM_6)____, Rcv : channel (____(PARAM_7)____))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ ____(MESSAGE_9)____(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(____(MESSAGE_10)____).KeyID(K).Sig')\n      /\\ witness(____(EVENT_5)____,C,____(EVENT_4)____,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____(C, ____(PARAM_11)____  : agent,\n\t     H, KeyID : ____(PARAM_8)____,\n\t     ____(PARAM_9)____     : ____(PARAM_10)____)\ndef=\n\n  local ____(VARIABLE_2)____, ____(VARIABLE_3)____, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____()\ndef=\n \n const a, ____(VARIABLE_4)____       : ____(VARIABLE_5)____,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: DHCP-Delayed-Auth\n%% PURPOSE:\n%%    Delayed entity and message authentication for DHCP\n%%\n%% REFERENCE: RFC 3118, \\url{http://www.faqs.org/rfcs/rfc3118.html}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%%1. C -> S : C, delayedAuthReq, Time1\n%%2. S -> C : S, delayedAuthReq, succ(Time1), KeyID(K), \n%%            H(S, delayedAuthReq, succ(Time1), K)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%The RFC describes different options and checks in terms of key words MAY, MUST etc.\n%%This model is of the minimum protocol, i.e. only the MUST checks.\n%%In real life, message looks like\n%%\\begin{itemize}\n%%\\item 90 (auth requested), \n%%\\item length, \n%%\\item 1 (for delayed auth), \n%%\\item 1 (to indicate standard HMAC algorithm),\n%%\\item 0 (standard Replay Detection Mechanism, monotonically increasing counter),\n%%\\item counter value.\n%%\\end{itemize}\n%%We ignore length field (as it cannot be, yet, expressed in HLPSL), \n%%use fresh nonce to model RDM, and\n%%assume 'DelayedAuthReq' token is enough to specify algorithm, type of auth,\n%%and type of RDM.\n%%\n%%The server returns the nonce + 1 (or \\verb|succ(nonce)| to be exact) \n%%instead of a timestamp with a higher value.\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%%\n%% NOTES: Client is the initiator. Sends a DHCP discover and requests authentication\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ request(C,S,sig,Sig') \n      /\\ secret(K,sec_k,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S  : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/DPP-I.hlpsl",
        "incomplete": "%Device Provisioning Protocol (DPP-I) is a Wi-Fi Alliance specification and also known\n%as 'Wi-Fi CERTIFIED Easy Connect\u2122'. The protocol aims to provide a user-friendly way\n%to provision diverse IoT devices to secure Wi-Fi securely. DPP refers the new\n%out-of-the-box device as Enrollee. A logical entity that configures the enrollee\n%to the secure Wi-Fi is called Configurator . It could be an application on a device.\n%DPP uses four sub-protocols and works in the following phases:\n%1. Bootstrapping: The enrollee announces its presence by sending its Bootstrapping-public\n%   key (and some metadata) to the configurator using an out-of-the-band mechanism. It can\n%   be done by scanning a QR code, an NFC tap, or a bluetooth exchange.\n%2. Authentication Protocol: DPP defines two roles 'Initiator' and 'Responder'. Either\n%   configurator or enrollee can act as initiator and initiate the authentication phase.\n%   We have considered configurator as an initiator for implementation purposes in this paper.\n%   Both configurator and enrollee have two public-private key pairs: bootstrapping and protocol\n%   keys. In this phase configurator and enrollee perform an ECDH (Elliptic-curve Diffie\u2013Hellman)\n%   handshake using the public-private key pairs to establish a common secret session key. After\n%   receiving the enrollee's presence announcement configurator initiates the authentication by\n%   sending a DPP-authentication-request encrypted by an ephemeral intermediate ECDH key. The\n%   authentication request contains a nonce. The enrollee returns the nonce as part of its DPP-\n%   authentication-response and proves that it possess the private key corresponding to the\n%   bootstrapping public received by the configurator in bootstrapping phase. After receiving the\n%   correct nonce, the configurator sends a DPP- authentication-confirm message and authenticates\n%   the enrollee.\n%3. Configuration Protocol: Once the enrollee is authenticated, it sends a DPP configuration request\n%   (requesting configurator for its configuration information) encrypted by the session key. The\n%   configurator responds with the configuration credential in the form of a configuration object\n%   secured by the session key. The configuration object could be a passphrase, password, or a DPP\n%   connector. In our implementations, the DPP connector has been taken as the configuration object.\n%\tDPP connector is basically a certificate from the configurator, containing the public-protocol\n%   key of the enrollee signed by the configurator. Using this, the enrollee can connect to the\n%   network and the other devices on the network.\n\n\n\n____(ROLE_0)____ configurator(____(PARAM_2)____, E : agent,\n\t   ____(PARAM_1)____, Nx, Lx: symmetric_key,  \n           ____(PARAM_0)____ : ____(PARAM_3)____,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local ____(VARIABLE_0)____, Nc, Nr, ____(VARIABLE_1)____, ____(VARIABLE_3)____, ____(VARIABLE_2)____, PMS: text,\n\t Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, ____(VARIABLE_5)____, ____(VARIABLE_4)____, auth_nr : ____(VARIABLE_6)____,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = ____(STATE_0)____\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ ____(EVENT_0)____(K1,____(EVENT_1)____,{C,E})\n\t\t/\\ ____(EVENT_2)____(C,E,auth_ni,____(EVENT_3)____)\n\n  3.  State = ____(STATE_2)____\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ ____(EVENT_4)____(Iauth,sec_iauth,{C,____(EVENT_5)____})\n\t\t/\\ request(____(EVENT_7)____,____(EVENT_6)____,auth_nr,Nr)\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n       \n\n\n\nend role\n\n\n\nrole enrollee(C, ____(PARAM_9)____ : ____(PARAM_8)____,\n\t ____(PARAM_11)____, ____(PARAM_10)____, ____(PARAM_13)____: symmetric_key,\n         H : hash_func,\n         Br, ____(PARAM_7)____, ____(PARAM_14)____: public_key,\n         ____(PARAM_12)____, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local ____(VARIABLE_10)____, ____(VARIABLE_7)____, Na, ____(VARIABLE_8)____, Ne, Sid, ____(VARIABLE_9)____, PMS: text,\n\t Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, ____(VARIABLE_13)____, sec_ne, auth_ni, ____(VARIABLE_11)____ : ____(VARIABLE_12)____,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       %/\\ Chirp' := 'Chirping'\n       /\\ SND(H(chirp.Br))\n   2. State = ____(STATE_1)____ /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(____(EVENT_9)____,____(EVENT_8)____,{E,C})\n\t\t/\\ ____(EVENT_11)____(E,C,auth_nr,____(EVENT_10)____)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ ____(EVENT_12)____(Ne,sec_ne,{____(EVENT_13)____,C})\n\t\t/\\ request(____(EVENT_15)____,C,auth_ni,____(EVENT_14)____)\n\t\n\n  6.  State = ____(STATE_3)____ /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(____(PARAM_20)____,E: ____(PARAM_16)____,\n\t     Mx, ____(PARAM_19)____, ____(PARAM_21)____: symmetric_key,\n             H : hash_func,\n             ____(PARAM_15)____, ____(PARAM_18)____, Br, Pr, ____(PARAM_17)____: public_key)\ndef=\n\n   local  ____(VARIABLE_15)____, SR, RC, ____(VARIABLE_14)____: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, ____(VARIABLE_16)____      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(i,e,mx,nx,lx,h,kib,kip,br,pr,kca)\n%   /\\  session(c,i,mx,nx,lx,h,bi,pi,kib,kip,kca)\n\nend role\n\n\n\n____(ROLE_1)____\n\n  secrecy_of sec_k1, sec_k2, ____(GOAL_17)____, ____(GOAL_16)____  \n  ____(GOAL_18)____ auth_ni, auth_nr  \n  authentication_on ____(GOAL_19)____  \n  \nend goal\n\n\n\nenvironment()",
        "complete:": "%Device Provisioning Protocol (DPP-I) is a Wi-Fi Alliance specification and also known\n%as 'Wi-Fi CERTIFIED Easy Connect\u2122'. The protocol aims to provide a user-friendly way\n%to provision diverse IoT devices to secure Wi-Fi securely. DPP refers the new\n%out-of-the-box device as Enrollee. A logical entity that configures the enrollee\n%to the secure Wi-Fi is called Configurator . It could be an application on a device.\n%DPP uses four sub-protocols and works in the following phases:\n%1. Bootstrapping: The enrollee announces its presence by sending its Bootstrapping-public\n%   key (and some metadata) to the configurator using an out-of-the-band mechanism. It can\n%   be done by scanning a QR code, an NFC tap, or a bluetooth exchange.\n%2. Authentication Protocol: DPP defines two roles 'Initiator' and 'Responder'. Either\n%   configurator or enrollee can act as initiator and initiate the authentication phase.\n%   We have considered configurator as an initiator for implementation purposes in this paper.\n%   Both configurator and enrollee have two public-private key pairs: bootstrapping and protocol\n%   keys. In this phase configurator and enrollee perform an ECDH (Elliptic-curve Diffie\u2013Hellman)\n%   handshake using the public-private key pairs to establish a common secret session key. After\n%   receiving the enrollee's presence announcement configurator initiates the authentication by\n%   sending a DPP-authentication-request encrypted by an ephemeral intermediate ECDH key. The\n%   authentication request contains a nonce. The enrollee returns the nonce as part of its DPP-\n%   authentication-response and proves that it possess the private key corresponding to the\n%   bootstrapping public received by the configurator in bootstrapping phase. After receiving the\n%   correct nonce, the configurator sends a DPP- authentication-confirm message and authenticates\n%   the enrollee.\n%3. Configuration Protocol: Once the enrollee is authenticated, it sends a DPP configuration request\n%   (requesting configurator for its configuration information) encrypted by the session key. The\n%   configurator responds with the configuration credential in the form of a configuration object\n%   secured by the session key. The configuration object could be a passphrase, password, or a DPP\n%   connector. In our implementations, the DPP connector has been taken as the configuration object.\n%\tDPP connector is basically a certificate from the configurator, containing the public-protocol\n%   key of the enrollee signed by the configurator. Using this, the enrollee can connect to the\n%   network and the other devices on the network.\n\n\n\nrole configurator(C, E : agent,\n\t   Mx, Nx, Lx: symmetric_key,  \n           H : hash_func,\n           Bi, Pi, Kca: public_key,  %% Kca is the public key of a T3P (ie. CA)\n           SND, RCV: channel (dy))\nplayed_by C\ndef=\n\n   local Ni, Nc, Nr, Ne, Sid, Pa, PMS: text,\n\t Channellist, Capi, Capr, Pver: text,\n\t K1,K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n         Br, Pr: public_key,\n         M: hash(text.text.text),\n\t Configreq,Configpayrol,Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_k1, sec_iauth, auth_ni, auth_nr : protocol_id,\n\t chirp  : text,\n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(H(chirp.Br'))\n       =|>\n       State' := 3\n\t\t/\\ Ni':= new()\n\t\t/\\ Channellist' := new()\n\t\t/\\ Capi' := new()\n\t\t/\\ Pver':= new()\t\n\t\t/\\ K1' := H(salt.first_intermediate_key.Mx)\n\t\t/\\ SND(H(Br).H(Bi).Pi.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ secret(K1,sec_k1,{C,E})\n\t\t/\\ witness(C,E,auth_ni,Ni)\n\n  3.  State = 3\n\t\t/\\ RCV(H(Br').H(Bi').Pr'.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\n\t\t/\\ Rauth'=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' = H(salt.second_intermediate_key.Nx)\n\t\t/\\ Ke' = H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t=|>\n\t\tState' := 5\n\t\t/\\ Iauth' := H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t/\\ SND(H(Br).H(Bi).{Iauth'}_Ke')\n\t\t/\\ secret(Iauth,sec_iauth,{C,E})\n\t\t/\\ request(C,E,auth_nr,Nr)\n  5.  State = 5\n\t\t/\\ RCV({Ne'.Configreq'}_Ke')\n\t\t=|> \n\t\tState' :=7\n\t\t/\\ Configpayrol' := new()\n\t\t/\\ Sendconnstatus' := new()\n\t\t/\\ SND({Ne'.Configpayrol'.Sendconnstatus'}_Ke)\n  7.  State = 7\n\t\t/\\ RCV({Ne'}_Ke')\n\t\t=|> State':=9\n       \n\n\n\nend role\n\n\n\nrole enrollee(C, E : agent,\n\t Mx, Nx, Lx: symmetric_key,\n         H : hash_func,\n         Br, Pr, Kca: public_key,\n         SND, RCV: channel (dy))\nplayed_by E\ndef=\n\n   local Ni, Nr, Na, Nb, Ne, Sid, Pa, PMS: text,\n\t Channellist, Capi, Capr, Pver: text, \n\t K1, K2: hash(text.text.symmetric_key),\n\t Bk: hash(text.text.symmetric_key.symmetric_key.symmetric_key),\n\t Ke: hash(hash(text.text.symmetric_key.symmetric_key.symmetric_key).text.nat),\n         State: nat,\n\t Bi, Pi : public_key,\n\t Configreq, Configpayrol, Sendconnstatus : text,\n\t Iauth : hash(text.text.public_key.public_key.public_key.public_key.nat),\n\t Rauth : hash(text.text.public_key.public_key.public_key.public_key.nat)\n\n   const sec_nr, sec_k2, sec_rauth, sec_ne, auth_ni, auth_nr : protocol_id,\n\t chirp  : text, \n\t first_intermediate_key, second_intermediate_key, dpp_status : text,\n\t salt : text,\n\t len : nat\n\n   init  State := 0\n\n   transition\n\n   0.  State = 0 /\\ RCV(start)\n       =|>\n       State' := 2\n       %/\\ Chirp' := 'Chirping'\n       /\\ SND(H(chirp.Br))\n   2. State = 2 /\\ RCV(H(Br').H(Bi').Pi'.Pver'.Channellist'.{Ni'.Capi'}_K1')\n\t\t/\\ K1' = H(salt.first_intermediate_key.Mx)\n\t\t=|> \n\t\tState' := 4\n\t\t/\\ Nr' := new() \n\t\t/\\ Capr' := new()\n\t\t/\\ Rauth' :=H(Ni'.Nr'.Pi.Pr.Bi.Br.0)\n\t\t/\\ K2' := H(salt.second_intermediate_key.Nx)\n\t\t/\\ Bk' := H(Ni.Nr.Mx.Nx.Lx)\n\t\t/\\ Ke' := H(H(Ni.Nr.Mx.Nx.Lx).dpp_status.len)\n\t\t/\\ SND(H(Br).H(Bi').Pr.Pver'.{Nr'.Ni'.Capr'.{Rauth'}_K2'}_Ke')\t\n\t\t/\\ secret(K2,sec_k2,{E,C})\n\t\t/\\ witness(E,C,auth_nr,Nr)\n\t\t\t\t\n  4.  State = 4 /\\ RCV(H(Br').H(Bi').{Iauth'}_Ke')\n\t\t/\\ Iauth' = H(Nr.Ni.Pr.Pi.Br.Bi.1)\n\t\t=|>\n\t\tState' := 6\n\t\t/\\ Ne' := new()\n\t\t/\\ Configreq' := new()\n\t\t/\\ SND ({Ne'.Configreq'}_Ke)\n\t\t/\\ secret(Ne,sec_ne,{E,C})\n\t\t/\\ request(E,C,auth_ni,Ni)\n\t\n\n  6.  State = 6 /\\ RCV({Ne'.Configpayrol'.Sendconnstatus'}_Ke')\n\t\t=|>\n\t\tState' := 8\n\t\t/\\ SND({Ne}_Ke)\n\t\t\n       \n\n\nend role\n\n\n\nrole session(C,E: agent,\n\t     Mx, Nx, Lx: symmetric_key,\n             H : hash_func,\n             Bi, Pi, Br, Pr, Kca: public_key)\ndef=\n\n   local  SC, SR, RC, RR: channel (dy)\n\n   composition\n\n\n                configurator(C,E,Mx,Nx,Lx,H,Bi,Pi,Kca,SC,RC)\n              /\\    enrollee(C,E,Mx,Nx,Lx,H,Br,Pr,Kca,SR,RR)\n\nend role\n\n\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2      : protocol_id,\n         c, e                : agent,\n\t mx, nx, lx: symmetric_key,\n         h     : hash_func,\n         bi, pi, br, pr, kca, ki, kib, kip : public_key\n\n   intruder_knowledge = { c, e, bi, pi, br, pr, kca, ki, kib, kip, inv(ki), inv(kib), inv(kip),\n                          {i.ki}_(inv(kca)) }  \n\n   composition\n        session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(c,e,mx,nx,lx,h,bi,pi,br,pr,kca)\n%   /\\  session(i,e,mx,nx,lx,h,kib,kip,br,pr,kca)\n%   /\\  session(c,i,mx,nx,lx,h,bi,pi,kib,kip,kca)\n\nend role\n\n\n\ngoal\n\n  secrecy_of sec_k1, sec_k2, sec_iauth, sec_ne  \n  authentication_on auth_ni, auth_nr  \n  authentication_on na_nb2  \n  \nend goal\n\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/drone_to_gss_protocol.hlpsl",
        "incomplete": "%%% Blockchain-based access control scheme in IoT-enabled Internet of Drones deployment \n%%% Drone to GSS\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Control Room %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole controlroom(CR, ____(PARAM_0)____, GSS: ____(PARAM_2)____,____(PARAM_3)____: hash_func, Snd, ____(PARAM_1)____: channel(dy)) \n\nplayed_by CR\ndef= \nlocal ____(VARIABLE_1)____: nat,\n    SKcrdr, SKcrgss: symmetric_key, \n    %%% F is ECC point mutiplicatIon operator \n    F, Add: hash_func, \n    Rcr, Pubcr, RTSdrj, TCdrj, IDdrj, IDcr, IDgss, Certdrj, Certgss: text,\n    G, MKdrj, Rdrj, Pubdrj, Rgss, Pubgss, RTSgss, TCgss: text\nconst ____(VARIABLE_0)____, sp2: protocol_id \n\ninit State := 0\ntransition\n\n%%%Drone registration phase \n\n1.State = ____(STATE_0)____ /\\ ____(MESSAGE_30)____(start) =|>\nState' := 1 /\\ Rcr' := new() /\\ Pubcr' := F(Rcr'.G)\n            /\\ Rdrj' := new() /\\ RTSdrj' := new()\n            /\\ Pubdrj' := F(Rdrj'.G)\n            /\\ TCdrj' := H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj')\n            /\\ Certdrj' := Add(Rdrj'.H(Pubdrj'.Pubcr'.IDgss).Rcr')\n%%% Send registration message to DRj via secure channel\n            /\\ ____(MESSAGE_31)____({IDdrj.IDgss.TCdrj'.Certdrj'}_SKcrdr)\n            /\\ ____(EVENT_1)____({Rcr',____(EVENT_0)____,RTSdrj',____(EVENT_2)____}, sp1, {CR})\n\n%%% GSS registration phase\n    /\\ Rgss' := new() /\\ Pubgss' := F(Rgss'.G)\n    /\\ RTSgss' := new()\n    /\\ TCgss' := H(IDgss.IDcr.Rgss'.RTSgss')\n    /\\ Certgss' := Add(Rgss'.H(IDgss.Pubgss'.Pubcr').Rcr')\n    %%% Send registration message to the GSS via secure channel\n    /\\ ____(MESSAGE_32)____({IDdrj.IDgss.TCgss'.Certgss'}_SKcrgss)\n    /\\ secret({RTSgss',Rgss'}, ____(EVENT_4)____, {____(EVENT_3)____})\n    end role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Drone DRj %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole ____(ROLE_2)____(____(PARAM_5)____, DR, ____(PARAM_6)____: agent,\n            H: hash_func,\n            Snd, ____(PARAM_7)____: channel(____(PARAM_4)____))\n% Player: Drone DRj\nplayed_by DR\ndef=\nlocal State: ____(VARIABLE_6)____,\n    SKcrdr: symmetric_key,\n    %%% F is ECC point mutiplication operation\n    F, Add, Poly: hash_func,\n    G, MKdrj, Rdrj, Pubdrj : text,\n    IDdrj, IDgss, IDcr, RTSdrj, Rcr, Rdr, TSdr, Adr: text,\n    Adr1, Rgss, RTSgss, TSgss, Bgss, Rgss1: text,\n    TSdr1, ACKdrgss: text\nconst ____(VARIABLE_5)____, ____(VARIABLE_3)____, dr_gss_rdr, ____(VARIABLE_2)____, ____(VARIABLE_4)____, gss_dr_rgss1, gss_dr_tsgss : protocol_id\n\ninit State := 0\ntransition\n%%%Drone registration phase\n%%%Receive registration message securely from the CR\n1. State = ____(STATE_2)____ /\\ Rcv({IDdrj.IDgss.H(____(MESSAGE_33)____).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr')}_SKcrdr) =|>\nState' := 2 /\\ ____(EVENT_5)____({Rcr',Rdrj', RTSdrj',____(EVENT_6)____}, ____(EVENT_7)____, {CR})\n\n%%% Access control phase\n    /\\ Rdr' := new() /\\ TSdr' := new()\n    /\\ Adr' := H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr')\n    /\\ Adr1' := F(Adr'.G)\n\n%%% Send message Msg1 to GSS via public channel\n    /\\ ____(MESSAGE_34)____(IDdrj.Adr1'.Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')\n\n%% DRj has freshly generated the values rdrk and TSdrk for GSS that are induded in Msg1\n    /\\ ____(EVENT_9)____(DR, GSS, ____(EVENT_8)____, Rdr')\n    /\\ witness(DR, ____(EVENT_10)____, dr_gss_tsdr, ____(EVENT_11)____)\n\n%%% Receive message Msg2 from the GSS via public channel\n2. State = 2 /\\ Rcv(IDgss.F(H(IDgss.H(____(MESSAGE_35)____).Rgss1'.TSgss').G).\n                H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr).\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'. TSgss').\n                F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).TSgss'.IDgss).\n                TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')) =|>\n\nState' := 4 /\\ TSdr1' := new()\n        /\\ ACKdrgss' := H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G)).\n            Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n            Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr').TSdr'.TSgss').TSdr1')\n\n%%% Send message Msqg3 to GSS via public channel\n        /\\ Snd(____(MESSAGE_36)____)\n\n%% DRj has freshly generated the value TSdr1 for GSS that is included in Msg3\n        /\\ ____(EVENT_13)____(DR, GSS, ____(EVENT_12)____, TSdr1')\n\n% DRj's acceptance of the values rgss1, TSgss (message Msq2) for GSS by DRj\n        /\\ request(____(EVENT_14)____, DR, ____(EVENT_15)____, Rgss1')\n        /\\ ____(EVENT_16)____(GSS, DR, ____(EVENT_17)____, TSgss')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GSS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole ____(ROLE_1)____(____(PARAM_10)____, ____(PARAM_8)____, GSS: agent,\n        ____(PARAM_11)____: ____(PARAM_9)____,\n        Snd, Rcv: channel(dy))\n\n% Player: GSS\nplayed_by GSS\ndef=\nlocal State: nat,\n            SKcrgss: symmetric_key,\n%%% F is ECC point mutiplication operation\n            F, Add: hash_func,\n            Poly: hash_func,\n            G, MKdrj, Rdrj, Pubdrj : text,\n            IDdrj, IDgss, IDcr, Rgss, RTSgss, Rcr: text,\n            RTSdrj, Rdr, TSdr, Rgss1, TSgss, DKgss, Bgss, Bgss12: text,\n            SKgssdr, SKVgssdr, TSdr1: text\n\nconst ____(VARIABLE_7)____, sp2, dr_gss_rdr, dr_gss_tsdr, ____(VARIABLE_9)____, gss_dr_rgss1, ____(VARIABLE_8)____: ____(VARIABLE_10)____\n\ninit State := 0\ntransition\n%%% GSS registration phase\n%%% receive registration message securely from the CR\n1. State = 0 /\\ ____(MESSAGE_37)____({IDdrj.IDgss. H(IDgss.IDcr.Rgss'.RTSgss').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')}_SKcrgss) =|>\nState' := 3 /\\ secret({____(EVENT_19)____,Rgss'}, ____(EVENT_18)____, {CR})\n\n%%% Access control phase\n%%% Receive message Msq1 from the DRj via public channel\n2. State = ____(STATE_1)____ /\\ ____(MESSAGE_38)____(IDdrj.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')=|>\nState' := 5 /\\ Rgss1' := new() /\\ TSgss' := new() /\\ RTSgss' := new() /\\ Rgss' := new()\n            /\\ Bgss' := H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss')\n            /\\ Bgss12' := F(Bgss'.G)\n            /\\ DKgss' := F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G))\n            /\\ SKgssdr' := H(DKgss'.Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss')\n\n            /\\ SKVgssdr' := H(SKgssdr'.Bgss12'.TSgss'.IDgss)\n%%% Send message Msg? to the drone via public channel\n            /\\ ____(MESSAGE_39)____(IDgss.Bgss12'.SKVgssdr'.TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'))\n%% GSS has freshly generated the values rgss1 and TSgss for DRj that are induded in Msg2\n            /\\ witness(GSS, DR, ____(EVENT_20)____, ____(EVENT_21)____)\n            /\\ witness(____(EVENT_23)____, DR, gss_dr_tsgss, ____(EVENT_22)____)\n\n%%% Receive message Msg3 from the drone via public channel\n3. State = 5 /\\ Rcv(H(H(F(Bgss'.F(H(IDdrj.H(____(MESSAGE_40)____).Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss').TSdr1').TSdr1') =|>\n\n% GSS's acceptance of the values rdr, TSdr (message Msg1) and TSdr1 (message Msg3) for GSS by DRj\n\nState' := 7 /\\ request(DR, ____(EVENT_25)____, dr_gss_rdr, ____(EVENT_24)____)\n        /\\ request(DR, GSS, ____(EVENT_27)____, ____(EVENT_26)____)\n        /\\ request(DR, ____(EVENT_28)____, dr_gss_tsdr1, ____(EVENT_29)____)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole ____(ROLE_0)____ (CR, DR, ____(PARAM_14)____: ____(PARAM_13)____,\n            ____(PARAM_12)____: hash_func)\ndef=\n    local Sn1, Sn2, ____(VARIABLE_12)____, Rv1, ____(VARIABLE_11)____, Rv3: channel (____(VARIABLE_13)____)\n    composition\n        controlroom (CR, DR, GSS, H, Sn1, Rv1)\n        /\\ drone (CR, DR, GSS, H, Sn2, Rv2)\n        /\\ groundserver (CR, DR, GSS, H, Sn3, Rv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n    const cr, dr, gss: ____(VARIABLE_14)____,\n        h, f, add, poly: hash_func,\n        tsdr, tsdr1, tsgss: text,\n        sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\n    intruder_knowledge = {cr, dr, gss, h, f, add, poly, tsdr, tsdr1, tsgss}\n\n    composition\n        session(cr, dr, gss, h)\n        /\\ session(cr, i, gss, h)\n        /\\session(cr, dr, i, h)\n    end role\n\ngoal\n\n%%% Authentication\nauthentication_on ____(GOAL_41)____, dr_gss_tsdr, ____(GOAL_42)____\n____(GOAL_43)____ gss_dr_rgss1, gss_dr_tsgss\n\n%%% Confidentiality\nsecrecy_of ____(GOAL_44)____, sp2\n\nend goal\nenvironment()",
        "complete:": "%%% Blockchain-based access control scheme in IoT-enabled Internet of Drones deployment \n%%% Drone to GSS\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Control Room %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole controlroom(CR, DR, GSS: agent,H: hash_func, Snd, Rcv: channel(dy)) \n\nplayed_by CR\ndef= \nlocal State: nat,\n    SKcrdr, SKcrgss: symmetric_key, \n    %%% F is ECC point mutiplicatIon operator \n    F, Add: hash_func, \n    Rcr, Pubcr, RTSdrj, TCdrj, IDdrj, IDcr, IDgss, Certdrj, Certgss: text,\n    G, MKdrj, Rdrj, Pubdrj, Rgss, Pubgss, RTSgss, TCgss: text\nconst spl, sp2: protocol_id \n\ninit State := 0\ntransition\n\n%%%Drone registration phase \n\n1.State = 0 /\\ Rcv(start) =|>\nState' := 1 /\\ Rcr' := new() /\\ Pubcr' := F(Rcr'.G)\n            /\\ Rdrj' := new() /\\ RTSdrj' := new()\n            /\\ Pubdrj' := F(Rdrj'.G)\n            /\\ TCdrj' := H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj')\n            /\\ Certdrj' := Add(Rdrj'.H(Pubdrj'.Pubcr'.IDgss).Rcr')\n%%% Send registration message to DRj via secure channel\n            /\\ Snd({IDdrj.IDgss.TCdrj'.Certdrj'}_SKcrdr)\n            /\\ secret({Rcr',Rdrj',RTSdrj',MKdrj}, sp1, {CR})\n\n%%% GSS registration phase\n    /\\ Rgss' := new() /\\ Pubgss' := F(Rgss'.G)\n    /\\ RTSgss' := new()\n    /\\ TCgss' := H(IDgss.IDcr.Rgss'.RTSgss')\n    /\\ Certgss' := Add(Rgss'.H(IDgss.Pubgss'.Pubcr').Rcr')\n    %%% Send registration message to the GSS via secure channel\n    /\\ Snd({IDdrj.IDgss.TCgss'.Certgss'}_SKcrgss)\n    /\\ secret({RTSgss',Rgss'}, sp2, {CR})\n    end role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Drone DRj %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole drone(CR, DR, GSS: agent,\n            H: hash_func,\n            Snd, Rcv: channel(dy))\n% Player: Drone DRj\nplayed_by DR\ndef=\nlocal State: nat,\n    SKcrdr: symmetric_key,\n    %%% F is ECC point mutiplication operation\n    F, Add, Poly: hash_func,\n    G, MKdrj, Rdrj, Pubdrj : text,\n    IDdrj, IDgss, IDcr, RTSdrj, Rcr, Rdr, TSdr, Adr: text,\n    Adr1, Rgss, RTSgss, TSgss, Bgss, Rgss1: text,\n    TSdr1, ACKdrgss: text\nconst sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss : protocol_id\n\ninit State := 0\ntransition\n%%%Drone registration phase\n%%%Receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr')}_SKcrdr) =|>\nState' := 2 /\\ secret({Rcr',Rdrj', RTSdrj',MKdrj}, sp1, {CR})\n\n%%% Access control phase\n    /\\ Rdr' := new() /\\ TSdr' := new()\n    /\\ Adr' := H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr')\n    /\\ Adr1' := F(Adr'.G)\n\n%%% Send message Msg1 to GSS via public channel\n    /\\ Snd(IDdrj.Adr1'.Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')\n\n%% DRj has freshly generated the values rdrk and TSdrk for GSS that are induded in Msg1\n    /\\ witness(DR, GSS, dr_gss_rdr, Rdr')\n    /\\ witness(DR, GSS, dr_gss_tsdr, TSdr')\n\n%%% Receive message Msg2 from the GSS via public channel\n2. State = 2 /\\ Rcv(IDgss.F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).\n                H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr).\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'. TSgss').\n                F(H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss').G).TSgss'.IDgss).\n                TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')) =|>\n\nState' := 4 /\\ TSdr1' := new()\n        /\\ ACKdrgss' := H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G)).\n            Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n            Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr').TSdr'.TSgss').TSdr1')\n\n%%% Send message Msqg3 to GSS via public channel\n        /\\ Snd(ACKdrgss'.TSdr1')\n\n%% DRj has freshly generated the value TSdr1 for GSS that is included in Msg3\n        /\\ witness(DR, GSS, dr_gss_tsdr1, TSdr1')\n\n% DRj's acceptance of the values rgss1, TSgss (message Msq2) for GSS by DRj\n        /\\ request(GSS, DR, gss_dr_rgss1, Rgss1')\n        /\\ request(GSS, DR, gss_dr_tsgss, TSgss')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GSS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \nrole groundserver(CR, DR, GSS: agent,\n        H: hash_func,\n        Snd, Rcv: channel(dy))\n\n% Player: GSS\nplayed_by GSS\ndef=\nlocal State: nat,\n            SKcrgss: symmetric_key,\n%%% F is ECC point mutiplication operation\n            F, Add: hash_func,\n            Poly: hash_func,\n            G, MKdrj, Rdrj, Pubdrj : text,\n            IDdrj, IDgss, IDcr, Rgss, RTSgss, Rcr: text,\n            RTSdrj, Rdr, TSdr, Rgss1, TSgss, DKgss, Bgss, Bgss12: text,\n            SKgssdr, SKVgssdr, TSdr1: text\n\nconst sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\ninit State := 0\ntransition\n%%% GSS registration phase\n%%% receive registration message securely from the CR\n1. State = 0 /\\ Rcv({IDdrj.IDgss. H(IDgss.IDcr.Rgss'.RTSgss').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr')}_SKcrgss) =|>\nState' := 3 /\\ secret({RTSgss',Rgss'}, sp2, {CR})\n\n%%% Access control phase\n%%% Receive message Msq1 from the DRj via public channel\n2. State = 3 /\\ Rcv(IDdrj.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G).\n                Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').TSdr')=|>\nState' := 5 /\\ Rgss1' := new() /\\ TSgss' := new() /\\ RTSgss' := new() /\\ Rgss' := new()\n            /\\ Bgss' := H(IDgss.H(IDgss.IDcr.Rgss'.RTSgss').Rgss1'.TSgss')\n            /\\ Bgss12' := F(Bgss'.G)\n            /\\ DKgss' := F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'. TSdr').G))\n            /\\ SKgssdr' := H(DKgss'.Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss')\n\n            /\\ SKVgssdr' := H(SKgssdr'.Bgss12'.TSgss'.IDgss)\n%%% Send message Msg? to the drone via public channel\n            /\\ Snd(IDgss.Bgss12'.SKVgssdr'.TSgss'.Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'))\n%% GSS has freshly generated the values rgss1 and TSgss for DRj that are induded in Msg2\n            /\\ witness(GSS, DR, gss_dr_rgss1, Rgss1')\n            /\\ witness(GSS, DR, gss_dr_tsgss, TSgss')\n\n%%% Receive message Msg3 from the drone via public channel\n3. State = 5 /\\ Rcv(H(H(F(Bgss'.F(H(IDdrj.H(MKdrj.IDdrj.IDcr.IDgss.RTSdrj').Rdr'.TSdr').G)).\n                Poly(IDgss.IDdrj). Add(Rdrj'.H(F(Rdrj'.G).F(Rcr'.G).IDgss).Rcr').\n                Add(Rgss'.H(IDgss.F(Rgss'.G).F(Rcr'.G)).Rcr'). TSdr'.TSgss').TSdr1').TSdr1') =|>\n\n% GSS's acceptance of the values rdr, TSdr (message Msg1) and TSdr1 (message Msg3) for GSS by DRj\n\nState' := 7 /\\ request(DR, GSS, dr_gss_rdr, Rdr')\n        /\\ request(DR, GSS, dr_gss_tsdr, TSdr')\n        /\\ request(DR, GSS, dr_gss_tsdr1, TSdr1')\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Session %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session (CR, DR, GSS: agent,\n            H: hash_func)\ndef=\n    local Sn1, Sn2, Sn3, Rv1, Rv2, Rv3: channel (dy)\n    composition\n        controlroom (CR, DR, GSS, H, Sn1, Rv1)\n        /\\ drone (CR, DR, GSS, H, Sn2, Rv2)\n        /\\ groundserver (CR, DR, GSS, H, Sn3, Rv3)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Environment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n    const cr, dr, gss: agent,\n        h, f, add, poly: hash_func,\n        tsdr, tsdr1, tsgss: text,\n        sp1, sp2, dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1, gss_dr_rgss1, gss_dr_tsgss: protocol_id\n\n    intruder_knowledge = {cr, dr, gss, h, f, add, poly, tsdr, tsdr1, tsgss}\n\n    composition\n        session(cr, dr, gss, h)\n        /\\ session(cr, i, gss, h)\n        /\\session(cr, dr, i, h)\n    end role\n\ngoal\n\n%%% Authentication\nauthentication_on dr_gss_rdr, dr_gss_tsdr, dr_gss_tsdr1\nauthentication_on gss_dr_rgss1, gss_dr_tsgss\n\n%%% Confidentiality\nsecrecy_of sp1, sp2\n\nend goal\nenvironment()"
    },
    {
        "file": "HLPSL-1/Dynamic_group_key_distribution_scheme_with_three-factor_identification_for_IoT_environments.hlpsl",
        "incomplete": "____(ROLE_1)____ ____(ROLE_0)____ (U, ____(PARAM_7)____: agent, ____(PARAM_2)____, SKij, GkiAT: ____(PARAM_5)____, ____(PARAM_10)____: ____(PARAM_3)____, H, ____(PARAM_12)____, H2, H4, H5, ____(PARAM_0)____, ____(PARAM_6)____, ____(PARAM_8)____, ____(PARAM_4)____, Sub, Add, ____(PARAM_1)____, ____(PARAM_11)____: hash_func, SND, ____(PARAM_9)____: channel (dy))\nplayed_by U def=\n\nlocal State: ____(VARIABLE_0)____,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1.  State = ____(STATE_0)____ /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new()\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ ____(EVENT_1)____(____(EVENT_0)____,g1,{U}) /\\ ____(EVENT_2)____(IDi,g2,{____(EVENT_3)____,S}) /\\ ____(EVENT_4)____(PWi,____(EVENT_5)____,{U}) /\\ ____(EVENT_7)____(____(EVENT_6)____,g4,{U})\n2.  State = ____(STATE_1)____ /\\ RCV({IDi.Nj.({H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj)}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi and Bi in the smart card\n%/\\ Store Ej, IDj and Nj in the USB\n\n% Login and authentication procedure\n\n3.  State = ____(STATE_2)____ /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card\n%/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose b = 3\n/\\ N' := H(H(H(V')))\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n/\\ Tu' := new()\n/\\ A' := xor(xor(BBi',W'),Tu')\n/\\ Yij' := xor(E,Ej)\n/\\ K' := {IDj.IDi.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,____(EVENT_9)____,____(EVENT_8)____)\n/\\ ____(EVENT_11)____(U,____(EVENT_10)____,u_s_tu,Tu')\n/\\ secret(IDi,____(EVENT_12)____,{U,____(EVENT_13)____})\n/\\ ____(EVENT_14)____(PWi,g3,{____(EVENT_15)____})\n/\\ secret(____(EVENT_16)____,____(EVENT_17)____,{U})\n4.  State = ____(STATE_3)____ /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts'\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n%/\\ Confirm B\n%/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts')\n/\\ Gki' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n%/\\ Obtain ATia, ATib, Ti1 and Ti2 from Cki'\n/\\ GkiAT' := H(H1(H6(H(Xj.As))).H2(H14(H(Xj.Bs))))\n/\\ request(____(EVENT_19)____,U,____(EVENT_18)____,Ts')\n\n% Dynamic key derivation procedure\n\n5. State = 0 /\\ RCV({H6(H(Xj.As.M')).H14(H(Xj.Bs.M'))}_GkiAT') =|>\nState':= 1\n/\\ GkiAT' := H(H2(H6(H(Xj.As))).H1(H14(H(Xj.Bs))))\n%/\\ Use CkiAT to decrypt Q1 and obtains ATia' = H6(H(Xj.As.M')) and ATib' = H14(H(Xj.Bs.M'))\n/\\ GkiATNew' := H(H2(H6(H(Xj.As.M'))).H1(H14(H(Xj.Bs.M'))))\n/\\ request(S,____(EVENT_21)____,s_u_m,____(EVENT_20)____)\n\nend role\n\n\nrole server (____(PARAM_16)____, S: ____(PARAM_21)____, ____(PARAM_17)____, ____(PARAM_20)____, GkiAT: symmetric_key, Ks: public_key, ____(PARAM_14)____, ____(PARAM_22)____, H2, ____(PARAM_15)____, ____(PARAM_13)____, H6, ____(PARAM_23)____, ____(PARAM_25)____, H15, ____(PARAM_18)____, Add, Mul, Div: hash_func, ____(PARAM_24)____, RCV: channel (____(PARAM_19)____))\nplayed_by S def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, X, Y, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({Nj.Yij'}_Kus)\n/\\ ____(EVENT_22)____(____(EVENT_23)____,g5,{S})\n\n% Login and authentication procedure\n\n2. State = 0 /\\ RCV({IDj.IDi.{H(Xj).IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj.H(H(H(V'))).xor(xor(H(PWi.Bi),H(H(PWi.E).xor(h(xor(IDi,IDj)),E))),Tu').Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu'\n%/\\ Use Xj to decrypt Yij\n%/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi,W),Tu')\n%/\\ Confirm A\n/\\ Ts' := new()\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n/\\ IDinew' := H(Yij.IDi.H(Xj))\n/\\ SKij' := H(xor(H(H(H(V'))),Yij))\n/\\ As' := new() /\\ Bs' := new()\n/\\ Ti1' := new() /\\ Ti2' := new()\n%/\\ Z =24, suppose Ti1=7, Ti2=10\n/\\ ATia' := H6(H(Xj.As'))\n/\\ ATib' := H14(H(Xj.Bs'))\n/\\ Gki' := (ATia'.ATib'.Ti1'.Ti2')\n/\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion.\n/\\ C1' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C2').Mul(Hi'.C3'))).Hi')\n/\\ C2' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C3'))).Hi')\n/\\ C3' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C2'))).Hi')\n/\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ secret(____(EVENT_24)____,g6,{____(EVENT_25)____}) /\\ ____(EVENT_27)____(____(EVENT_26)____,g7,{S}) /\\ ____(EVENT_29)____(Ti1',g8,{U,____(EVENT_28)____}) /\\ ____(EVENT_31)____(Ti2',g9,{____(EVENT_30)____,S})\n/\\ witness(S,U,____(EVENT_33)____,____(EVENT_32)____)\n/\\ ____(EVENT_35)____(____(EVENT_34)____,S,u_s_v,V')\n/\\ request(U,____(EVENT_36)____,____(EVENT_37)____,Tu')\n\n% Dynamic key derivation procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ M' := new()\n/\\ ATia' := H6(H(Xj.As.M'))\n/\\ ATib' := H14(H(Xj.Bs.M'))\n/\\ X' := H(Xj.As)\n/\\ Y' := H(Xj.Bs)\n%/\\ Suppose current T = 9\n/\\ GkiAT' := H(H8(X').H15(Y'))\n/\\ Q1' := {ATia'.ATib'}_GkiAT'\n/\\ SND (Q1')\n/\\ ____(EVENT_38)____(S,U,s_u_m,____(EVENT_39)____)\n/\\ secret(____(EVENT_41)____,____(EVENT_40)____,{U,S})\n/\\ secret(____(EVENT_43)____,g11,{____(EVENT_42)____,S})\n\nend role\n\nrole session (____(PARAM_29)____, ____(PARAM_33)____: agent, ____(PARAM_35)____, SKij, ____(PARAM_34)____: ____(PARAM_28)____, Ks: ____(PARAM_32)____, ____(PARAM_27)____, H1, ____(PARAM_30)____, H4, H5, ____(PARAM_31)____, ____(PARAM_26)____, H14, H15, Sub, ____(PARAM_36)____, Mul, Div: hash_func) def=\n\nlocal SU, ____(VARIABLE_2)____, ____(VARIABLE_1)____, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SU,RU)\n/\\ server (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SS,RS)\n\nend role\n\nrole environment() def=\n\nconst u, ____(VARIABLE_3)____: ____(VARIABLE_4)____,\nkus, skij, gkiat, kui: symmetric_key,\nks, ki: public_key,\nh, h1, h2, h4, h5, h6, h8, h14, h15, sub, add, mul, div: hash_func,\ng1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, u_s_v, u_s_tu, s_u_ts, s_u_m: protocol_id\n\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\n\ncomposition\n\nsession(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(u,i,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(i,s,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n\nend role\n\ngoal\n\n____(GOAL_46)____ ____(GOAL_48)____, g2, ____(GOAL_45)____, g4, ____(GOAL_44)____, g6, g7, ____(GOAL_47)____, g9, ____(GOAL_49)____, g11\nauthentication_on u_s_v, ____(GOAL_51)____, s_u_ts, ____(GOAL_50)____\n\nend goal\n\nenvironment()",
        "complete:": "role user (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Enter IDi, PWi & Bi\n/\\ E' := new()\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n/\\ SND({IDi.W'.BBi'}_Kus)\n/\\ secret(E',g1,{U}) /\\ secret(IDi,g2,{U,S}) /\\ secret(PWi,g3,{U}) /\\ secret(Bi,g4,{U})\n2.  State = 1 /\\ RCV({IDi.Nj.({H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj)}_Kus) =|>\nState':= 2\n/\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n%/\\ Store E, IDi, PWi and Bi in the smart card\n%/\\ Store Ej, IDj and Nj in the USB\n\n% Login and authentication procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n%/\\ Insert smart card\n%/\\ Enter PWi* & Bi*\n/\\ V' := new()\n%/\\ Suppose b = 3\n/\\ N' := H(H(H(V')))\n/\\ BBi' := H(PWi.Bi)\n/\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n/\\ Tu' := new()\n/\\ A' := xor(xor(BBi',W'),Tu')\n/\\ Yij' := xor(E,Ej)\n/\\ K' := {IDj.IDi.Yij'.N'.A'.Tu'}_Ks\n/\\ SND(K')\n/\\ witness(U,S,u_s_v,V')\n/\\ witness(U,S,u_s_tu,Tu')\n/\\ secret(IDi,g2,{U,S})\n/\\ secret(PWi,g3,{U})\n/\\ secret(Bi,g4,{U})\n4.  State = 1 /\\ RCV(({xor(H(H(H(H(V')))),Ts').H(Yij.IDi.H(Xj)).Ts'}_SKij').C1'.C2'.C3') =|>\nState':= 2\n/\\ SKij' := H(xor(N,Yij))\n%/\\ Confirm Ts'\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n%/\\ Confirm B\n%/\\ Store IDinew in the smart card\n/\\ Hi' := H5(SKij'.Ts')\n/\\ Gki' := Sub(H4(SKij'.Ts').Add(Mul(Hi'.C1').Mul(Hi'.C2').Mul(Hi'.C3')))\n%/\\ Obtain ATia, ATib, Ti1 and Ti2 from Cki'\n/\\ GkiAT' := H(H1(H6(H(Xj.As))).H2(H14(H(Xj.Bs))))\n/\\ request(S,U,s_u_ts,Ts')\n\n% Dynamic key derivation procedure\n\n5. State = 0 /\\ RCV({H6(H(Xj.As.M')).H14(H(Xj.Bs.M'))}_GkiAT') =|>\nState':= 1\n/\\ GkiAT' := H(H2(H6(H(Xj.As))).H1(H14(H(Xj.Bs))))\n%/\\ Use CkiAT to decrypt Q1 and obtains ATia' = H6(H(Xj.As.M')) and ATib' = H14(H(Xj.Bs.M'))\n/\\ GkiATNew' := H(H2(H6(H(Xj.As.M'))).H1(H14(H(Xj.Bs.M'))))\n/\\ request(S,U,s_u_m,M')\n\nend role\n\n\nrole server (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, IDinew, IDj, Nj, PWi, Bi, Gki, GkiATNew, E, Ej, X, Y, Xj, V, M, N, N1, Hi, BBi, W, Yij, Tu, Ts, T1, Ti1, T2, Ti2, A, As, B, Bs, ATia, ATib, SKijNew: text, K, Q, Q1, C1, C2, C3: message\n\ninit State := 0\n\ntransition\n\n% Registration procedure\n\n1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\nState':= 1\n/\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n%/\\ Store IDj\n/\\ SND({Nj.Yij'}_Kus)\n/\\ secret(Xj,g5,{S})\n\n% Login and authentication procedure\n\n2. State = 0 /\\ RCV({IDj.IDi.{H(Xj).IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj.H(H(H(V'))).xor(xor(H(PWi.Bi),H(H(PWi.E).xor(h(xor(IDi,IDj)),E))),Tu').Tu'}_Ks) =|>\nState':= 1\n%/\\ Confirm Tu'\n%/\\ Use Xj to decrypt Yij\n%/\\ Confirm H(Xj), IDsj & IDi\n/\\ A' := xor(xor(BBi,W),Tu')\n%/\\ Confirm A\n/\\ Ts' := new()\n/\\ B' := xor(H(H(H(H(V')))),Ts')\n/\\ IDinew' := H(Yij.IDi.H(Xj))\n/\\ SKij' := H(xor(H(H(H(V'))),Yij))\n/\\ As' := new() /\\ Bs' := new()\n/\\ Ti1' := new() /\\ Ti2' := new()\n%/\\ Z =24, suppose Ti1=7, Ti2=10\n/\\ ATia' := H6(H(Xj.As'))\n/\\ ATib' := H14(H(Xj.Bs'))\n/\\ Gki' := (ATia'.ATib'.Ti1'.Ti2')\n/\\ Hi' := H5(SKij'.Ts')\n%/\\ Suppose there are three users in this communication sesstion.\n/\\ C1' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C2').Mul(Hi'.C3'))).Hi')\n/\\ C2' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C3'))).Hi')\n/\\ C3' := Div(Sub(H4(SKij'.Ts').Add(Gki'.Mul(Hi'.C1').Mul(Hi'.C2'))).Hi')\n/\\ Q':= {B'.IDinew'.Ts'}_SKij'\n/\\ SND (Q'.C1'.C2'.C3')\n/\\ secret(As',g6,{S}) /\\ secret(Bs',g7,{S}) /\\ secret(Ti1',g8,{U,S}) /\\ secret(Ti2',g9,{U,S})\n/\\ witness(S,U,s_u_ts,Ts')\n/\\ request(U,S,u_s_v,V')\n/\\ request(U,S,u_s_tu,Tu')\n\n% Dynamic key derivation procedure\n\n3.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ M' := new()\n/\\ ATia' := H6(H(Xj.As.M'))\n/\\ ATib' := H14(H(Xj.Bs.M'))\n/\\ X' := H(Xj.As)\n/\\ Y' := H(Xj.Bs)\n%/\\ Suppose current T = 9\n/\\ GkiAT' := H(H8(X').H15(Y'))\n/\\ Q1' := {ATia'.ATib'}_GkiAT'\n/\\ SND (Q1')\n/\\ witness(S,U,s_u_m,M')\n/\\ secret(ATia',g10,{U,S})\n/\\ secret(ATib',g11,{U,S})\n\nend role\n\nrole session (U, S: agent, Kus, SKij, GkiAT: symmetric_key, Ks: public_key, H, H1, H2, H4, H5, H6, H8, H14, H15, Sub, Add, Mul, Div: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SU,RU)\n/\\ server (U,S,Kus,SKij,GkiAT,Ks,H,H1,H2,H4,H5,H6,H8,H14,H15,Sub,Add,Mul,Div,SS,RS)\n\nend role\n\nrole environment() def=\n\nconst u, s: agent,\nkus, skij, gkiat, kui: symmetric_key,\nks, ki: public_key,\nh, h1, h2, h4, h5, h6, h8, h14, h15, sub, add, mul, div: hash_func,\ng1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, u_s_v, u_s_tu, s_u_ts, s_u_m: protocol_id\n\nintruder_knowledge = {u,s,ks,ki,inv(ki)}\n\ncomposition\n\nsession(u,s,kus,skij,gkiat,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(u,i,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n/\\ session(i,s,kui,kui,kui,ks,h,h1,h2,h4,h5,h6,h8,h14,h15,sub,add,mul,div)\n\nend role\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11\nauthentication_on u_s_v, u_s_tu, s_u_ts, s_u_m\n\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/eap-lorawan.hlpsl",
        "incomplete": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_3)____ (____(PARAM_0)____,GNB,AMF,SMF,AUSF,UDM,____(PARAM_2)____ : ____(PARAM_5)____, ____(PARAM_3)____,____(PARAM_1)____ : nat , K,AppKey : ____(PARAM_8)____, ____(PARAM_6)____ : hash_func, SND,____(PARAM_7)____ : channel(____(PARAM_4)____))\n\t\n\tplayed_by ED\n\n\tdef=\n\n\t\tlocal\t\n\t\t\t____(VARIABLE_1)____, ____(VARIABLE_0)____, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tJoinRequest, JoinAccept : message,\n\t\t\tMICJR, MICAAA, MICJA : message\n\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= ____(STATE_1)____ /\\ RCV(start) =|>\n\t\t\t\tState' := 1 /\\ DevNonce':= new()\n\t\t\t\t\t\t\t/\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ MICJR':=H(JoinEUI.DevEUI.DevNonce'.NwkKey')\n\t\t\t\t\t\t\t/\\ MICAAA':=H(JoinEUI.DevEUI.DevNonce'.AppKey)\n\t\t\t\t\t\t\t/\\ SND(JoinRequest.JoinEUI.DevEUI.DevNonce'.MICJR'.MICAAA')\n\t\t\t\t\t\t\t/\\ witness(____(EVENT_0)____,AUSF,____(EVENT_1)____,NwkKey')\n\t\t\t\t\t\t\t/\\ ____(EVENT_3)____(ED,____(EVENT_2)____,auth_dn_ed,AppKey)\n\n\t\t\t1.\tState\t= ____(STATE_3)____ /\\ RCV(JoinAccept.JoinNonce'.MICJA') /\\ MICJA'=H(JoinNonce'.NwkKey) =|>\n\t\t\t\tState' := 2 /\\ request(ED,____(EVENT_4)____,auth_ed_cn,____(EVENT_5)____)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____ (ED,____(PARAM_9)____,AMF,____(PARAM_12)____,AUSF,UDM,AAA : ____(PARAM_14)____, ____(PARAM_11)____ : hash_func, SND,____(PARAM_10)____ : channel(____(PARAM_13)____))\n\t\t\t\n\tplayed_by GNB\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, ____(VARIABLE_3)____ : ____(VARIABLE_2)____,\n\t\t\tJoinRequest, JoinAccept, AuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANCN, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICAAA, MICJA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= ____(STATE_4)____ /\\ RCV(JoinRequest.JoinEUI'.DevEUI'.DevNonce'.MICJR'.MICAAA') =|>\n\t\t\t\tState' := 1 /\\ SND(AuthenticationRequest.ED)\n\n\t\t\t1.\tState\t= ____(STATE_7)____ /\\ RCV(EAPLoRaWANCN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ JoinNonce':=new()\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICJR)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA') =|>\n\t\t\t\tState' := 3 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t3.\tState\t= ____(STATE_0)____ /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce.MICAAA)\n\n\t\t\t4.\tState\t= 4 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 5 /\\ SND(JoinAccept.JoinNonce.MICJA)  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____ (____(PARAM_20)____,GNB,____(PARAM_17)____,SMF,AUSF,____(PARAM_16)____,AAA : ____(PARAM_18)____, ____(PARAM_19)____ : hash_func, ____(PARAM_15)____,RCV : channel(dy))\n\t\t\t\n\tplayed_by AMF\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\tState, JoinEUI, ____(VARIABLE_6)____, DevNonce, ____(VARIABLE_4)____ : ____(VARIABLE_5)____,\n\t\t\tAuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANCN, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA, MICAAA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= ____(STATE_6)____ /\\ RCV(AuthenticationRequest.ED) =|>\n\t\t\t\tState' := 1 /\\ SND(AuthenticationRequest.ED)\n\n\t\t\t1.\tState\t= ____(STATE_9)____ /\\ RCV(EAPLoRaWANCN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANCN.EAPRQST.ED)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') =|>\t\t\t\t\t\n\t\t\t\tState' := 3 /\\ SND(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR')\n\n\t\t\t3.\tState\t= ____(STATE_10)____ /\\ RCV(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA') =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\n\t\t\t4.\tState\t= 4 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\t\tState' := 5 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t5.\tState\t= 5 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 6 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t6.\tState\t= ____(STATE_2)____ /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICAAA') =|>\n\t\t\t\tState' := 7 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICAAA')\n\n\t\t\t7.\tState\t= ____(STATE_5)____ /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 8 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_2)____ (____(PARAM_25)____,____(PARAM_23)____,AMF,____(PARAM_26)____,AUSF,____(PARAM_21)____,____(PARAM_24)____ : agent, ____(PARAM_22)____ : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by SMF\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\t____(VARIABLE_7)____, JoinEUI, DevEUI, ____(VARIABLE_9)____, JoinNonce : ____(VARIABLE_8)____,\n\t\t\tAuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= ____(STATE_8)____ /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\t\tState' := 1 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t1.\tState\t= ____(STATE_11)____ /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') =|>\n\t\t\t\tState' := 3 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA')\n\n\t\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authentication_server_function (ED,GNB,AMF,____(PARAM_29)____,AUSF,____(PARAM_31)____,____(PARAM_27)____ : agent, ____(PARAM_30)____ : ____(PARAM_33)____, H : ____(PARAM_28)____, SND,RCV : channel(____(PARAM_32)____))\n\t\t\t\n\tplayed_by AUSF \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\t____(VARIABLE_10)____, ____(VARIABLE_11)____, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse, EAPLoRaWANCN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationResponse.{NwkKey'}_SK) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANCN.EAPRQST.ED) \n\t\t\t\t\t\t\t\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') \n\t\t\t\t\t\t\t/\\ MICJR'=H(JoinEUI'.DevEUI'.DevNonce'.NwkKey) =|>\t\t\t\t\t\n\t\t\t\tState' := 2 /\\ MICJA':=H(JoinNonce'.NwkKey)\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\t\t\t\t\t\t\t/\\ request(____(EVENT_7)____,ED,____(EVENT_6)____,NwkKey)\n\t\t\t\t\t\t\t/\\ witness(AUSF,____(EVENT_9)____,____(EVENT_8)____,NwkKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole unified_data_management (ED,GNB,____(PARAM_34)____,SMF,____(PARAM_35)____,UDM,____(PARAM_41)____ : ____(PARAM_39)____, ____(PARAM_37)____,SK : ____(PARAM_40)____, H : ____(PARAM_38)____, SND,____(PARAM_36)____ : channel(dy))\n\t\t\t\n\tplayed_by UDM \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\t____(VARIABLE_12)____ : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ SND(AuthenticationResponse.{NwkKey'}_SK)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_server (____(PARAM_42)____,____(PARAM_45)____,____(PARAM_48)____,____(PARAM_46)____,AUSF,UDM,AAA : ____(PARAM_44)____, AppKey : symmetric_key, ____(PARAM_43)____ : ____(PARAM_47)____, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AAA \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\t____(VARIABLE_14)____, JoinEUI, DevEUI, DevNonce, ____(VARIABLE_15)____ : ____(VARIABLE_13)____,\n\t\t\tSessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') /\\ MICAAA' = H(JoinEUI'.DevEUI'.DevNonce'.AppKey) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\t\t\t\t\t\t\t/\\ ____(EVENT_11)____(____(EVENT_10)____,ED,auth_dn_ed,AppKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (ED,GNB,AMF,____(PARAM_58)____,____(PARAM_50)____,____(PARAM_55)____,____(PARAM_57)____ : ____(PARAM_53)____, ____(PARAM_52)____,DevEUI : ____(PARAM_49)____ , K,____(PARAM_51)____,SK : ____(PARAM_54)____, H : hash_func, ____(PARAM_56)____,RCV : channel(dy))\n\n\tdef=\n\t\tcomposition\t\n\t\t\tend_device(ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey,H,SND,RCV)\n\t\t\t/\\\n\t\t\tg_node_b(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\taccess_and_mobility_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tsession_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tauthentication_server_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\tunified_data_management(ED,GNB,AMF,SMF,AUSF,UDM,AAA,K,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\taaa_server(ED,GNB,AMF,SMF,AUSF,UDM,AAA,AppKey,H,SND,RCV)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole enviroment() \n\n\tdef=\n\n\t\tconst\t\n\t\t\t____(VARIABLE_18)____,gnb,____(VARIABLE_19)____,____(VARIABLE_17)____,ausf,____(VARIABLE_16)____,aaa : agent,\n\t\t\tjoineui,deveui : nat,\n\t\t\th : hash_func,\n\t\t\tk,appkey,sk : symmetric_key,\n\t\t\tsnd,rcv\t: channel(dy),\n\t\t\t\n\t\t\tauth_cn_ed, auth_ed_cn, auth_dn_ed : protocol_id\n\n\t\tintruder_knowledge = {ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,h,i}\n\n\t\tcomposition\n\t\t\tsession(ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,k,appkey,sk,h,snd,rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n\tauthentication_on ____(GOAL_12)____\n\t____(GOAL_13)____ auth_ed_cn\n\tauthentication_on ____(GOAL_14)____\n\nend goal\n\nenviroment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
        "complete:": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole end_device (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, JoinEUI,DevEUI : nat , K,AppKey : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\n\tplayed_by ED\n\n\tdef=\n\n\t\tlocal\t\n\t\t\tState, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tJoinRequest, JoinAccept : message,\n\t\t\tMICJR, MICAAA, MICJA : message\n\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(start) =|>\n\t\t\t\tState' := 1 /\\ DevNonce':= new()\n\t\t\t\t\t\t\t/\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ MICJR':=H(JoinEUI.DevEUI.DevNonce'.NwkKey')\n\t\t\t\t\t\t\t/\\ MICAAA':=H(JoinEUI.DevEUI.DevNonce'.AppKey)\n\t\t\t\t\t\t\t/\\ SND(JoinRequest.JoinEUI.DevEUI.DevNonce'.MICJR'.MICAAA')\n\t\t\t\t\t\t\t/\\ witness(ED,AUSF,auth_cn_ed,NwkKey')\n\t\t\t\t\t\t\t/\\ witness(ED,AAA,auth_dn_ed,AppKey)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(JoinAccept.JoinNonce'.MICJA') /\\ MICJA'=H(JoinNonce'.NwkKey) =|>\n\t\t\t\tState' := 2 /\\ request(ED,AUSF,auth_ed_cn,NwkKey)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole g_node_b (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by GNB\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tJoinRequest, JoinAccept, AuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANCN, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICAAA, MICJA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(JoinRequest.JoinEUI'.DevEUI'.DevNonce'.MICJR'.MICAAA') =|>\n\t\t\t\tState' := 1 /\\ SND(AuthenticationRequest.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ JoinNonce':=new()\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICJR)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA') =|>\n\t\t\t\tState' := 3 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce.MICAAA)\n\n\t\t\t4.\tState\t= 4 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 5 /\\ SND(JoinAccept.JoinNonce.MICJA)  \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole access_and_mobility_management_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AMF\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tAuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANCN, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA, MICAAA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\n\t\t\t\tState' := 1 /\\ SND(AuthenticationRequest.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANCN.EAPRQST.ED)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') =|>\t\t\t\t\t\n\t\t\t\tState' := 3 /\\ SND(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR')\n\n\t\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA') =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\n\t\t\t4.\tState\t= 4 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\t\tState' := 5 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t5.\tState\t= 5 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 6 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t6.\tState\t= 6 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICAAA') =|>\n\t\t\t\tState' := 7 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI.DevEUI.DevNonce.JoinNonce'.MICAAA')\n\n\t\t\t7.\tState\t= 7 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 8 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session_management_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by SMF\n\n\tdef= \n\t\n\t\tlocal \t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tAuthenticationRequest, SessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\n\t\tinit\n\t\t\tState  := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\n\t\t\t\tState' := 1 /\\ SND(SessionEstablishmentRequest.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRQST.ED) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t2.\tState\t= 2 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') =|>\n\t\t\t\tState' := 3 /\\ SND(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA')\n\n\t\t\t3.\tState\t= 3 /\\ RCV(EAPLoRaWANDN.EAPSUCCESS.ED) =|>\n\t\t\t\tState' := 4 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authentication_server_function (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AUSF \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse, EAPLoRaWANCN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICJR, MICJA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationResponse.{NwkKey'}_SK) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANCN.EAPRQST.ED) \n\t\t\t\t\t\t\t\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANCN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICJR') \n\t\t\t\t\t\t\t/\\ MICJR'=H(JoinEUI'.DevEUI'.DevNonce'.NwkKey) =|>\t\t\t\t\t\n\t\t\t\tState' := 2 /\\ MICJA':=H(JoinNonce'.NwkKey)\n\t\t\t\t\t\t\t/\\ SND(EAPLoRaWANCN.EAPSUCCESS.ED.MICJA')\n\t\t\t\t\t\t\t/\\ request(AUSF,ED,auth_cn_ed,NwkKey)\n\t\t\t\t\t\t\t/\\ witness(AUSF,ED,auth_ed_cn,NwkKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole unified_data_management (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, K,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by UDM \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState : nat,\n\t\t\tNwkKey : hash(symmetric_key),\n\t\t\tAuthenticationRequest, AuthenticationResponse : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(AuthenticationRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ NwkKey':= H(K)\n\t\t\t\t\t\t\t/\\ SND(AuthenticationResponse.{NwkKey'}_SK)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole aaa_server (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, AppKey : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\t\t\t\n\tplayed_by AAA \n\n\tdef=\n\n\t\tlocal\t\t\n\t\t\tState, JoinEUI, DevEUI, DevNonce, JoinNonce : nat,\n\t\t\tSessionEstablishmentRequest, EAPLoRaWANDN, EAPRQST, EAPRESP, EAPSUCCESS : message,\n\t\t\tMICAAA : message\n\t\t\t\n\t\tinit\t\n\t\t\tState := 0\n\n\t\ttransition\n\n\t\t\t0.\tState\t= 0 /\\ RCV(SessionEstablishmentRequest.ED) =|>\t\t\t\t\t\n\t\t\t\tState' := 1 /\\ SND(EAPLoRaWANDN.EAPRQST.ED)\n\n\t\t\t1.\tState\t= 1 /\\ RCV(EAPLoRaWANDN.EAPRESP.JoinEUI'.DevEUI'.DevNonce'.JoinNonce'.MICAAA') /\\ MICAAA' = H(JoinEUI'.DevEUI'.DevNonce'.AppKey) =|>\n\t\t\t\tState' := 2 /\\ SND(EAPLoRaWANDN.EAPSUCCESS.ED)\n\t\t\t\t\t\t\t/\\ request(AAA,ED,auth_dn_ed,AppKey)\n\t\t\t\t\nend role\t\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (ED,GNB,AMF,SMF,AUSF,UDM,AAA : agent, JoinEUI,DevEUI : nat , K,AppKey,SK : symmetric_key, H : hash_func, SND,RCV : channel(dy))\n\n\tdef=\n\t\tcomposition\t\n\t\t\tend_device(ED,GNB,AMF,SMF,AUSF,UDM,AAA,JoinEUI,DevEUI,K,AppKey,H,SND,RCV)\n\t\t\t/\\\n\t\t\tg_node_b(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\taccess_and_mobility_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tsession_management_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,H,SND,RCV)\n\t\t\t/\\\n\t\t\tauthentication_server_function(ED,GNB,AMF,SMF,AUSF,UDM,AAA,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\tunified_data_management(ED,GNB,AMF,SMF,AUSF,UDM,AAA,K,SK,H,SND,RCV)\n\t\t\t/\\\n\t\t\taaa_server(ED,GNB,AMF,SMF,AUSF,UDM,AAA,AppKey,H,SND,RCV)\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole enviroment() \n\n\tdef=\n\n\t\tconst\t\n\t\t\ted,gnb,amf,smf,ausf,udm,aaa : agent,\n\t\t\tjoineui,deveui : nat,\n\t\t\th : hash_func,\n\t\t\tk,appkey,sk : symmetric_key,\n\t\t\tsnd,rcv\t: channel(dy),\n\t\t\t\n\t\t\tauth_cn_ed, auth_ed_cn, auth_dn_ed : protocol_id\n\n\t\tintruder_knowledge = {ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,h,i}\n\n\t\tcomposition\n\t\t\tsession(ed,gnb,amf,smf,ausf,udm,aaa,joineui,deveui,k,appkey,sk,h,snd,rcv)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n\tauthentication_on auth_cn_ed\n\tauthentication_on auth_ed_cn\n\tauthentication_on auth_dn_ed\n\nend goal\n\nenviroment()\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
    },
    {
        "file": "HLPSL-1/EKE2.hlpsl",
        "incomplete": "%% PROTOCOL*: EKE2\n%% VARIANT: EKE2 (with mutual authentication)\n%% PURPOSE: Encrypted key exchange with mutual authentication\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : A.{exp(g,X)}_K(A,B)\n%%\n%%     B computes master key MK\n%%     MK = H(A,B,exp(g,X),exp(g,Y),exp(g,XY))\n%%\n%% 2. B -> A : {exp(g,Y)}_K(A,B), H(MK,1)\n%%\n%%      A computes master key MK\n%%\n%% 3. A -> B : H(MK,2)\n%%\n%%      Session key K = H(MK,0)\n%%\n%% H : hash function\n%% K(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%         \n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%%\n%% NOTES: For information, this protocol is an example of  \n%% the proposition done in \n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html} showing that\n%% any secure AKE (Authentication Key Exchange) protocol can be easily \n%% improved to also provide MA (Mutual Authentication).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole ____(ROLE_1)____ (A,B : ____(PARAM_3)____,\n                ____(PARAM_0)____: text,\n\t\tH: ____(PARAM_4)____,\n                ____(PARAM_5)____ : symmetric_key,\n             \tSnd,____(PARAM_1)____: channel(____(PARAM_2)____))\nplayed_by A\ndef=\n\n  local State     : ____(VARIABLE_0)____, \n\tX         : text, \n\tGY        : message,\n        MK_A,MK_B : message\n\n  const ____(VARIABLE_1)____ : text,\n        sec_i_MK_A : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = ____(STATE_1)____  /\\ Rcv(____(MESSAGE_12)____) =|> \n      State':= 1 /\\ X' := new()\n                 /\\ Snd(A.{exp(G,____(MESSAGE_13)____)}_Kab) \n\n   2. State = ____(STATE_0)____  /\\ Rcv({GY'}_Kab.H(H(A.B.exp(____(MESSAGE_14)____,X).GY'.exp(GY',X)).one)) =|> \n      State':= 2 /\\ MK_A' := A.B.exp(G,X).GY'.exp(GY',X)\n\t\t /\\ MK_B' := MK_A'% Message authentication (G2)\n\t\t /\\ ____(MESSAGE_15)____(H(H(MK_A').two)) \n\t\t /\\ secret(____(EVENT_1)____,____(EVENT_0)____,{A,B})\n\t\t /\\ request(____(EVENT_2)____,B,mk_a,____(EVENT_3)____)\n\t\t /\\ witness(A,____(EVENT_4)____,mk_b,____(EVENT_5)____) \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke2_Resp (____(PARAM_6)____,A : agent,\n                ____(PARAM_11)____: text,\n\t\t____(PARAM_8)____: ____(PARAM_10)____,\n                Kab : symmetric_key,\n                Snd,____(PARAM_7)____ : channel(____(PARAM_9)____))\nplayed_by B\ndef=% Message authentication (G2)\n\n  local State     : ____(VARIABLE_2)____, \n\tY         : text,\n\tGX        : message,\n        MK_A,MK_B : message\n\n  const one : ____(VARIABLE_3)____,\n        sec_r_MK_B : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ ____(MESSAGE_16)____(A.{GX'}_Kab) =|> \n      State':= 1 /\\ Y' := new()\n                 /\\ MK_B' := A.B.GX'.exp(G,Y').exp(GX',Y')\n                 /\\ MK_A' := MK_B'\n\t\t /\\ ____(MESSAGE_17)____({exp(G,Y')}_Kab.H(H(MK_B').one))\n\t\t /\\ secret(MK_B',sec_r_MK_B,{A,B})% Message authentication (G2)\n\t \t /\\ ____(EVENT_8)____(____(EVENT_9)____,A,mk_a,MK_A')\n\n   2. State = 1  /\\ ____(MESSAGE_18)____(H(H(MK_B).two)) =|> \n      State':= 2 /\\ request(____(EVENT_11)____,____(EVENT_10)____,mk_b,MK_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____ (____(PARAM_13)____,____(PARAM_12)____: agent,\n              ____(PARAM_14)____: text,\n\t      H: hash_func,\n\t      ____(PARAM_15)____: symmetric_key) def=\n\n   local   SA,RA,SB,____(VARIABLE_4)____: channel(____(VARIABLE_5)____)\n\n   composition\n\n           eke2_Init(A,B,G,H,Kab,SA,RB)  /\\\n           eke2_Resp(B,A,G,H,Kab,SB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Message authentication (G2)\n\nrole environment() def=\n\n  const ____(VARIABLE_6)____, ____(VARIABLE_7)____  : protocol_id,\n        a,b,c       : agent,\n        kab,kai,kib : symmetric_key,\n        g           : text,\n        h           : hash_func\n\n  intruder_knowledge  = {a,b,c,kai,kib}\n\n  composition\n\n\tsession(a,b,g,h,kab) /\\\n\tsession(a,i,g,h,kai) /\\\n\tsession(i,b,g,h,kib)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  % secrecy_of MK\n  ____(GOAL_19)____ sec_i_MK_A, sec_r_MK_B\n\n  % Message authentication (G2)\n  % Eke2_Init authenticates Eke2_Resp on mk_a\n  authentication_on ____(GOAL_20)____\n\n  % Message authentication (G2)\n  % Eke2_Resp authenticates Eke2_Init on mk_b\n  authentication_on ____(GOAL_21)____\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL*: EKE2\n%% VARIANT: EKE2 (with mutual authentication)\n%% PURPOSE: Encrypted key exchange with mutual authentication\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. A -> B : A.{exp(g,X)}_K(A,B)\n%%\n%%     B computes master key MK\n%%     MK = H(A,B,exp(g,X),exp(g,Y),exp(g,XY))\n%%\n%% 2. B -> A : {exp(g,Y)}_K(A,B), H(MK,1)\n%%\n%%      A computes master key MK\n%%\n%% 3. A -> B : H(MK,2)\n%%\n%%      Session key K = H(MK,0)\n%%\n%% H : hash function\n%% K(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%         \n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%%\n%% NOTES: For information, this protocol is an example of  \n%% the proposition done in \n%% \\url{http://citeseer.ist.psu.edu/bellare00authenticated.html} showing that\n%% any secure AKE (Authentication Key Exchange) protocol can be easily \n%% improved to also provide MA (Mutual Authentication).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole eke2_Init (A,B : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n             \tSnd,Rcv: channel(dy))\nplayed_by A\ndef=\n\n  local State     : nat, \n\tX         : text, \n\tGY        : message,\n        MK_A,MK_B : message\n\n  const two : text,\n        sec_i_MK_A : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(start) =|> \n      State':= 1 /\\ X' := new()\n                 /\\ Snd(A.{exp(G,X')}_Kab) \n\n   2. State = 1  /\\ Rcv({GY'}_Kab.H(H(A.B.exp(G,X).GY'.exp(GY',X)).one)) =|> \n      State':= 2 /\\ MK_A' := A.B.exp(G,X).GY'.exp(GY',X)\n\t\t /\\ MK_B' := MK_A'% Message authentication (G2)\n\t\t /\\ Snd(H(H(MK_A').two)) \n\t\t /\\ secret(MK_A',sec_i_MK_A,{A,B})\n\t\t /\\ request(A,B,mk_a,MK_A')\n\t\t /\\ witness(A,B,mk_b,MK_B') \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole eke2_Resp (B,A : agent,\n                G: text,\n\t\tH: hash_func,\n                Kab : symmetric_key,\n                Snd,Rcv : channel(dy))\nplayed_by B\ndef=% Message authentication (G2)\n\n  local State     : nat, \n\tY         : text,\n\tGX        : message,\n        MK_A,MK_B : message\n\n  const one : text,\n        sec_r_MK_B : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0  /\\ Rcv(A.{GX'}_Kab) =|> \n      State':= 1 /\\ Y' := new()\n                 /\\ MK_B' := A.B.GX'.exp(G,Y').exp(GX',Y')\n                 /\\ MK_A' := MK_B'\n\t\t /\\ Snd({exp(G,Y')}_Kab.H(H(MK_B').one))\n\t\t /\\ secret(MK_B',sec_r_MK_B,{A,B})% Message authentication (G2)\n\t \t /\\ witness(B,A,mk_a,MK_A')\n\n   2. State = 1  /\\ Rcv(H(H(MK_B).two)) =|> \n      State':= 2 /\\ request(B,A,mk_b,MK_B)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n              G: text,\n\t      H: hash_func,\n\t      Kab: symmetric_key) def=\n\n   local   SA,RA,SB,RB: channel(dy)\n\n   composition\n\n           eke2_Init(A,B,G,H,Kab,SA,RB)  /\\\n           eke2_Resp(B,A,G,H,Kab,SB,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Message authentication (G2)\n\nrole environment() def=\n\n  const mk_a, mk_b  : protocol_id,\n        a,b,c       : agent,\n        kab,kai,kib : symmetric_key,\n        g           : text,\n        h           : hash_func\n\n  intruder_knowledge  = {a,b,c,kai,kib}\n\n  composition\n\n\tsession(a,b,g,h,kab) /\\\n\tsession(a,i,g,h,kai) /\\\n\tsession(i,b,g,h,kib)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Confidentiality (G12)\n  % secrecy_of MK\n  secrecy_of sec_i_MK_A, sec_r_MK_B\n\n  % Message authentication (G2)\n  % Eke2_Init authenticates Eke2_Resp on mk_a\n  authentication_on mk_a\n\n  % Message authentication (G2)\n  % Eke2_Resp authenticates Eke2_Init on mk_b\n  authentication_on mk_b\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/EVauthenticate.hlpsl",
        "incomplete": "____(ROLE_0)____ role_EV(\n  EV,____(PARAM_1)____,SMF                 : ____(PARAM_2)____,\n  ____(PARAM_0)____                         : ____(PARAM_5)____,\n  H,PUF1,PRNG                : hash_func,\n  SND,____(PARAM_3)____                    : channel(____(PARAM_4)____))\nplayed_by EV def=\n  \n  local\n    State         :____(VARIABLE_0)____,\n\tN2,N3         :text,\n\tR1,N2M,N3M    :hash(text),\n\tSK            :hash(hash(text).hash(text).text),\n\tZ             :message\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = ____(STATE_0)____ /\\ RCV(N2') =|>\n     State' := 2 /\\ N2M' := PRNG(N2') /\\ R1':= PUF1(C1) /\\ N3' := new() /\\ SND({R1'.N3'}_N2M')\n\t\t\t\t /\\ ____(EVENT_1)____(EV,____(EVENT_0)____,ev_smf_r1,R1') /\\ ____(EVENT_3)____(EV,____(EVENT_2)____,ev_smf_n3,N3')\n  2. State = ____(STATE_1)____ /\\ RCV(Z') /\\ R1 = xor(Z',N3)=|>\n     State' := 4 /\\ SK' := H(N2M.N3)\n\t\t\t\t /\\ request(____(EVENT_5)____,GNB,____(EVENT_4)____,N2)\n\t\t\t\t /\\ request(____(EVENT_7)____,SMF,____(EVENT_6)____,Z')\n\t\t\t\t /\\ secret(____(EVENT_9)____,sk,{EV,____(EVENT_8)____})\n\nend ____(ROLE_1)____\n\nrole role_GNB(\n  ____(PARAM_10)____,____(PARAM_11)____,____(PARAM_7)____                    : agent,\n  C2                            : text,\n  ____(PARAM_9)____,____(PARAM_8)____                        : hash_func,\n  SND,RCV                       : channel(____(PARAM_6)____))\nplayed_by GNB def=\n  \n  local\n    State             :____(VARIABLE_1)____,\n\tN1,N2             :text,\n\tR2                :hash(text)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = ____(STATE_2)____ /\\ RCV(start) =|>\n     State' := 2 /\\ N1' := new() /\\ R2':= PUF2(C2) /\\ SND({N1'}_R2')\n\t             /\\ witness(____(EVENT_10)____,SMF,gnb_smf_n1,____(EVENT_11)____)\n  2. State = 2 /\\ RCV({N2'}_N1) =|>\n     State' := 4 /\\ SND(N2')\n\t             /\\ ____(EVENT_13)____(GNB,SMF,smf_gnb_n2,____(EVENT_12)____)\n\t\t\t\t /\\ witness(GNB,____(EVENT_15)____,____(EVENT_14)____,N2')\n\t\t\t\t \n\nend role\n\n\n\nrole role_SMF(\n  ____(PARAM_12)____,GNB,SMF                 : agent,\n  ____(PARAM_14)____,____(PARAM_16)____                      : text,\n  H,____(PARAM_15)____,PUF2,____(PARAM_13)____           : ____(PARAM_17)____,\n  SND,RCV                    : channel(____(PARAM_18)____))\nplayed_by SMF def=\n  \n  local\n    State                     :nat,\n\tN1,N2,N3               :text,\n\tR1,R2,N2M,N3M,N4M             :hash(text),\n\tSK                        :hash(hash(text).hash(text).text),\n\tZ                         :message\n\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV({N1'}_R2') /\\ R2' = PUF2(C2) =|>\n     State' := 3 /\\ N2' := new() /\\ N2M' := PRNG(N2') /\\ SND({N2'}_N1')\n\t\t\t\t /\\ witness(SMF,____(EVENT_16)____,____(EVENT_17)____,N2')\n  2. State = 3 /\\ RCV({R1'.N3'}_N2M) /\\  R1' = PUF1(C1) =|>\n     State' := 5 /\\ SK' := H(N2M.N3') /\\ Z' := xor(R1',N3') /\\ SND(Z')\n\t\t\t\t /\\ request(____(EVENT_19)____,GNB,____(EVENT_18)____,N1) /\\ ____(EVENT_20)____(SMF,____(EVENT_21)____,ev_smf_n3,N3') \n\t\t\t\t /\\ request(SMF,EV,____(EVENT_22)____,____(EVENT_23)____) /\\ ____(EVENT_25)____(____(EVENT_24)____,EV,smf_ev_z,Z') \n\t\t\t\t /\\ ____(EVENT_26)____(____(EVENT_27)____,sk,{EV,SMF})/\\ ____(EVENT_29)____(R1',r1,{____(EVENT_28)____,SMF}) \n\t\t\t\t /\\ secret(____(EVENT_31)____,r2,{GNB,____(EVENT_30)____})/\\ secret(N1,____(EVENT_32)____,{____(EVENT_33)____,SMF})\n\t\t\t\t /\\ secret(N2M,____(EVENT_34)____,{____(EVENT_35)____,SMF})/\\ secret(N3',n3,{____(EVENT_37)____,____(EVENT_36)____})\n\n\nend role\n\n\nrole session(\n  EV,GNB,____(PARAM_23)____               : ____(PARAM_22)____,\n  C1,C2                    : ____(PARAM_24)____,\n  H,____(PARAM_19)____,PUF2,____(PARAM_21)____         : ____(PARAM_20)____)\ndef=\n  local ____(VARIABLE_2)____,SSMF,____(VARIABLE_3)____,REV,RSMF,RGNB : channel(____(VARIABLE_4)____)\n  \n  composition\n    role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SEV,REV) /\\ role_GNB(EV,GNB,SMF,C2,H,PUF2,SGNB,RGNB) /\\ role_SMF(EV,GNB,SMF,C1,C2,H,PUF1,PUF2,PRNG,SSMF,RSMF) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    n1,n2m,n3,____(VARIABLE_8)____,r2,____(VARIABLE_7)____,ev_smf_r1,____(VARIABLE_6)____,gnb_smf_n1,____(VARIABLE_10)____,____(VARIABLE_9)____,smf_ev_z   : ____(VARIABLE_5)____,\n    sm,gw,sp                                            : agent,\n    c1,c2,sk0                                           : text,\n    h,puf1,puf2,puf3,puf4,prng1,prng2                                    : hash_func\n  intruder_knowledge = {sm,gw,sp,h,sk0} \n  \n  composition\n    session(sm,gw,sp,c1,c2,h,puf1,puf2,prng1) /\\ session(sm,gw,sp,c1,c2,h,puf3,puf4,prng2)\n\nend role\n\n____(ROLE_2)____ \n  ____(GOAL_38)____ sk\n  secrecy_of ____(GOAL_39)____\n  ____(GOAL_40)____ r2\n  ____(GOAL_41)____ n1\n  ____(GOAL_42)____ n2m\n  ____(GOAL_43)____ n3\n  authentication_on ____(GOAL_44)____\n  authentication_on ____(GOAL_45)____\n  authentication_on ____(GOAL_46)____\n  ____(GOAL_47)____ gnb_ev_n2\n  authentication_on ____(GOAL_48)____\n  %%authentication_on smf_ev_z\n\nend goal\n\nenvironment()",
        "complete:": "role role_EV(\n  EV,GNB,SMF                 : agent,\n  C1                         : text,\n  H,PUF1,PRNG                : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by EV def=\n  \n  local\n    State         :nat,\n\tN2,N3         :text,\n\tR1,N2M,N3M    :hash(text),\n\tSK            :hash(hash(text).hash(text).text),\n\tZ             :message\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(N2') =|>\n     State' := 2 /\\ N2M' := PRNG(N2') /\\ R1':= PUF1(C1) /\\ N3' := new() /\\ SND({R1'.N3'}_N2M')\n\t\t\t\t /\\ witness(EV,SMF,ev_smf_r1,R1') /\\ witness(EV,SMF,ev_smf_n3,N3')\n  2. State = 2 /\\ RCV(Z') /\\ R1 = xor(Z',N3)=|>\n     State' := 4 /\\ SK' := H(N2M.N3)\n\t\t\t\t /\\ request(EV,GNB,gnb_ev_n2,N2)\n\t\t\t\t /\\ request(EV,SMF,smf_ev_z,Z')\n\t\t\t\t /\\ secret(SK',sk,{EV,SMF})\n\nend role\n\nrole role_GNB(\n  EV,GNB,SMF                    : agent,\n  C2                            : text,\n  H,PUF2                        : hash_func,\n  SND,RCV                       : channel(dy))\nplayed_by GNB def=\n  \n  local\n    State             :nat,\n\tN1,N2             :text,\n\tR2                :hash(text)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ N1' := new() /\\ R2':= PUF2(C2) /\\ SND({N1'}_R2')\n\t             /\\ witness(GNB,SMF,gnb_smf_n1,N1')\n  2. State = 2 /\\ RCV({N2'}_N1) =|>\n     State' := 4 /\\ SND(N2')\n\t             /\\ request(GNB,SMF,smf_gnb_n2,N2')\n\t\t\t\t /\\ witness(GNB,EV,gnb_ev_n2,N2')\n\t\t\t\t \n\nend role\n\n\n\nrole role_SMF(\n  EV,GNB,SMF                 : agent,\n  C1,C2                      : text,\n  H,PUF1,PUF2,PRNG           : hash_func,\n  SND,RCV                    : channel(dy))\nplayed_by SMF def=\n  \n  local\n    State                     :nat,\n\tN1,N2,N3               :text,\n\tR1,R2,N2M,N3M,N4M             :hash(text),\n\tSK                        :hash(hash(text).hash(text).text),\n\tZ                         :message\n\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV({N1'}_R2') /\\ R2' = PUF2(C2) =|>\n     State' := 3 /\\ N2' := new() /\\ N2M' := PRNG(N2') /\\ SND({N2'}_N1')\n\t\t\t\t /\\ witness(SMF,GNB,smf_gnb_n2,N2')\n  2. State = 3 /\\ RCV({R1'.N3'}_N2M) /\\  R1' = PUF1(C1) =|>\n     State' := 5 /\\ SK' := H(N2M.N3') /\\ Z' := xor(R1',N3') /\\ SND(Z')\n\t\t\t\t /\\ request(SMF,GNB,gnb_smf_n1,N1) /\\ request(SMF,EV,ev_smf_n3,N3') \n\t\t\t\t /\\ request(SMF,EV,ev_smf_r1,R1') /\\ witness(SMF,EV,smf_ev_z,Z') \n\t\t\t\t /\\ secret(SK',sk,{EV,SMF})/\\ secret(R1',r1,{EV,SMF}) \n\t\t\t\t /\\ secret(R2,r2,{GNB,SMF})/\\ secret(N1,n1,{GNB,SMF})\n\t\t\t\t /\\ secret(N2M,r2,{EV,SMF})/\\ secret(N3',n3,{EV,SMF})\n\n\nend role\n\n\nrole session(\n  EV,GNB,SMF               : agent,\n  C1,C2                    : text,\n  H,PUF1,PUF2,PRNG         : hash_func)\ndef=\n  local SEV,SSMF,SGNB,REV,RSMF,RGNB : channel(dy)\n  \n  composition\n    role_EV(EV,GNB,SMF,C1,H,PUF1,PRNG,SEV,REV) /\\ role_GNB(EV,GNB,SMF,C2,H,PUF2,SGNB,RGNB) /\\ role_SMF(EV,GNB,SMF,C1,C2,H,PUF1,PUF2,PRNG,SSMF,RSMF) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    n1,n2m,n3,r1,r2,sk,ev_smf_r1,ev_smf_n3,gnb_smf_n1,gnb_ev_n2,smf_gnb_n2,smf_ev_z   : protocol_id,\n    sm,gw,sp                                            : agent,\n    c1,c2,sk0                                           : text,\n    h,puf1,puf2,puf3,puf4,prng1,prng2                                    : hash_func\n  intruder_knowledge = {sm,gw,sp,h,sk0} \n  \n  composition\n    session(sm,gw,sp,c1,c2,h,puf1,puf2,prng1) /\\ session(sm,gw,sp,c1,c2,h,puf3,puf4,prng2)\n\nend role\n\ngoal \n  secrecy_of sk\n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of n1\n  secrecy_of n2m\n  secrecy_of n3\n  authentication_on ev_smf_r1\n  authentication_on ev_smf_n3\n  authentication_on gnb_smf_n1\n  authentication_on gnb_ev_n2\n  authentication_on smf_gnb_n2\n  %%authentication_on smf_ev_z\n\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/GetServAuth.hlpsl",
        "incomplete": "____(ROLE_0)____ ____(ROLE_2)____(____(PARAM_5)____:____(PARAM_0)____,W:agent,____(PARAM_3)____:text,____(PARAM_2)____:____(PARAM_4)____,Y:text,SND,____(PARAM_1)____:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\t____(VARIABLE_2)____:nat,____(VARIABLE_0)____:____(VARIABLE_1)____,F:hash_func\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Y' := new() /\\ secret(Y',sec_2,{____(EVENT_1)____,____(EVENT_0)____}) /\\ N':=new() /\\ secret(N',____(EVENT_2)____,{C,____(EVENT_3)____}) /\\ SND({C.QR.N'.Y}_Kc)\n\t\t2. State=____(STATE_0)____ /\\ RCV({C.F(QR.N).Y}_Kc) =|> State':=2 /\\ Y' := new() /\\ secret(Y',____(EVENT_5)____,{____(EVENT_4)____,W}) /\\ N' := new() /\\ secret(N',____(EVENT_6)____,{C,____(EVENT_7)____})\nend ____(ROLE_1)____\n\nrole role_W(C:____(PARAM_8)____,____(PARAM_9)____:agent,Kc:____(PARAM_6)____,____(PARAM_7)____,RCV:channel(dy))\nplayed_by W\ndef=\n\tlocal\n\t\t____(VARIABLE_5)____:nat,____(VARIABLE_3)____:____(VARIABLE_4)____,____(VARIABLE_7)____:____(VARIABLE_6)____,F:hash_func,Y:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.QR'.N'.Y'}_Kc) =|> State':=1 /\\ secret(____(EVENT_9)____,sec_2,{____(EVENT_8)____,W}) /\\ secret(N',sec_1,{____(EVENT_11)____,____(EVENT_10)____}) /\\ SND({C.F(QR'.N').Y'}_Kc)\nend role\n\nrole session1(Y:____(PARAM_11)____,____(PARAM_10)____:____(PARAM_14)____,C:____(PARAM_13)____,W:agent,Kc:____(PARAM_12)____)\ndef=\n\tlocal\n\t\t____(VARIABLE_8)____,RCV2,____(VARIABLE_9)____,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session2(Y:text,____(PARAM_19)____:text,____(PARAM_15)____:____(PARAM_16)____,W:____(PARAM_17)____,____(PARAM_18)____:symmetric_key)\ndef=\n\tlocal\n\t\t____(VARIABLE_10)____,RCV2,SND1,____(VARIABLE_11)____:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session3(____(PARAM_20)____:____(PARAM_22)____,QR:____(PARAM_23)____,C:____(PARAM_21)____,W:agent,Kc:____(PARAM_24)____)\ndef=\n\tlocal\n\t\t____(VARIABLE_13)____,RCV2,SND1,RCV1:channel(____(VARIABLE_12)____)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\t____(VARIABLE_21)____:____(VARIABLE_19)____,y:____(VARIABLE_15)____,____(VARIABLE_18)____:agent,hash_0:hash_func,qr:text,____(VARIABLE_16)____:____(VARIABLE_17)____,____(VARIABLE_20)____:____(VARIABLE_14)____,sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(y,qr,i,miner,kc) /\\ session2(y,qr,client,i,kc) /\\ session1(y,qr,client,miner,kc)\nend role\n\ngoal\n\t____(GOAL_12)____ sec_1\n\tsecrecy_of ____(GOAL_13)____\nend goal\n\nenvironment()",
        "complete:": "role role_C(C:agent,W:agent,QR:text,Kc:symmetric_key,Y:text,SND,RCV:channel(dy))\nplayed_by C\ndef=\n\tlocal\n\t\tState:nat,N:text,F:hash_func\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N':=new() /\\ secret(N',sec_1,{C,W}) /\\ SND({C.QR.N'.Y}_Kc)\n\t\t2. State=1 /\\ RCV({C.F(QR.N).Y}_Kc) =|> State':=2 /\\ Y' := new() /\\ secret(Y',sec_2,{C,W}) /\\ N' := new() /\\ secret(N',sec_1,{C,W})\nend role\n\nrole role_W(C:agent,W:agent,Kc:symmetric_key,SND,RCV:channel(dy))\nplayed_by W\ndef=\n\tlocal\n\t\tState:nat,N:text,QR:text,F:hash_func,Y:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({C.QR'.N'.Y'}_Kc) =|> State':=1 /\\ secret(Y',sec_2,{C,W}) /\\ secret(N',sec_1,{C,W}) /\\ SND({C.F(QR'.N').Y'}_Kc)\nend role\n\nrole session1(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session2(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole session3(Y:text,QR:text,C:agent,W:agent,Kc:symmetric_key)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_W(C,W,Kc,SND2,RCV2) /\\ role_C(C,W,QR,Kc,Y,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tminer:agent,y:text,client:agent,hash_0:hash_func,qr:text,kc:symmetric_key,sec_1:protocol_id,sec_2:protocol_id\n\tintruder_knowledge = {client,miner}\n\tcomposition\n\t\tsession3(y,qr,i,miner,kc) /\\ session2(y,qr,client,i,kc) /\\ session1(y,qr,client,miner,kc)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/h.530-fix.hlpsl",
        "incomplete": "%% PROTOCOL*: H.530: Symmetric security procedures for H.323 mobility in H.510\n%% VARIANT: Fixed version\n%% PURPOSE: Establish an authenticated (Diffie-Hellman) shared-key\n%% between a mobile terminal (MT) and a visited gate-keeper (VGK), who do not\n%% know each other in advance, but who have a \"mutual friend\", an \n%% authentication facility (AuF) in the home domain of MT. \n%%\n%% REFERENCE: \\url{http://www.itu.int/rec/recommendation.asp?type=folders&lang=e&parent=T-REC-H.530}\\\\\n%% (with \"corrigendum\")\n%% MODELER: Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  Macros\n%%  M1 = MT,VGK,NIL,CH1,exp(G,X)\n%%  M2 = M1,F(ZZ,M1),VGK,exp(G,X) XOR exp(G,Y)\n%%  M3 = VGK,MT,F(ZZ,VGK),F(ZZ,exp(G,X) XOR exp(G,Y)),\n%%       exp(G,X) XOR exp(G,Y)  \n%%                              \n%%  M4 = VGK,MT,CH1,CH2,exp(G,Y),F(ZZ,exp(G,X) XOR exp(G,Y)),F(ZZ,VGK)\n%%  M5 = MT,VGK,CH2,CH3\n%%  M6 = VGK,MT,CH3,CH4\n%%-------------------------------------------------------------------\n%%  1. MT  -> VGK : M1,F(ZZ,M1)\n%%  2. VGK -> AuF : M2,F(ZZ_VA,M2) \n%%  3. AuF -> VGK : M3,F(ZZ_VA,M3) \n%%  4. VGK -> MT  : M4,F(exp(exp(G,X),Y),M4) \n%%  5. MT  -> VGK : M5,F(exp(exp(G,X),Y),M5)\n%%  6. VGK -> MT  : M6,F(exp(exp(G,X),Y),M6)\n%% \\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% NOTES: This is the fixed version.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%  HLPSL:\n\nrole mobileTerminal (\n    MT,VGK,AuF : ____(PARAM_2)____,\n    ____(PARAM_0)____,RCV    : channel(____(PARAM_1)____),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    ____(VARIABLE_0)____       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : ____(VARIABLE_1)____\n    \n  init  State := 0\n\n  transition\n\n 1. State  = ____(STATE_0)____ /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = ____(STATE_1)____ /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(____(EVENT_1)____,VGK,____(EVENT_0)____,Key')\n\n 3. State  = ____(STATE_2)____ /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,____(EVENT_3)____,____(EVENT_2)____)\n\t       /\\ ____(EVENT_5)____(Key,sec_m_Key,{VGK,____(EVENT_4)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____ (\n    MT,VGK,____(PARAM_3)____ : ____(PARAM_4)____,\n    ____(PARAM_5)____,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : ____(VARIABLE_2)____\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(____(EVENT_6)____,MT,____(EVENT_7)____,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ ____(EVENT_9)____(____(EVENT_8)____,MT,key1,Key)\n                /\\ secret(____(EVENT_11)____,sec_v_Key,{____(EVENT_10)____})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____(\n    ____(PARAM_7)____,____(PARAM_6)____,AuF : agent,\n    SND,RCV    : channel(____(PARAM_8)____),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    ____(VARIABLE_3)____         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,____(PARAM_10)____ : ____(PARAM_9)____,\n    F          : ____(PARAM_11)____,\n    ____(PARAM_13)____,____(PARAM_12)____   : symmetric_key,\n    NIL,____(PARAM_14)____      : text)\ndef=\n\n  local ____(VARIABLE_4)____,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,____(VARIABLE_5)____,auf                    : agent,\n    f                          : hash_func,\n    key, key1                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  ____(GOAL_12)____ key\n  authentication_on ____(GOAL_13)____\n  secrecy_of sec_m_Key, ____(GOAL_14)____\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL*: H.530: Symmetric security procedures for H.323 mobility in H.510\n%% VARIANT: Fixed version\n%% PURPOSE: Establish an authenticated (Diffie-Hellman) shared-key\n%% between a mobile terminal (MT) and a visited gate-keeper (VGK), who do not\n%% know each other in advance, but who have a \"mutual friend\", an \n%% authentication facility (AuF) in the home domain of MT. \n%%\n%% REFERENCE: \\url{http://www.itu.int/rec/recommendation.asp?type=folders&lang=e&parent=T-REC-H.530}\\\\\n%% (with \"corrigendum\")\n%% MODELER: Sebastian M\\\"odersheim, ETH Z\\\"urich\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%%  Macros\n%%  M1 = MT,VGK,NIL,CH1,exp(G,X)\n%%  M2 = M1,F(ZZ,M1),VGK,exp(G,X) XOR exp(G,Y)\n%%  M3 = VGK,MT,F(ZZ,VGK),F(ZZ,exp(G,X) XOR exp(G,Y)),\n%%       exp(G,X) XOR exp(G,Y)  \n%%                              \n%%  M4 = VGK,MT,CH1,CH2,exp(G,Y),F(ZZ,exp(G,X) XOR exp(G,Y)),F(ZZ,VGK)\n%%  M5 = MT,VGK,CH2,CH3\n%%  M6 = VGK,MT,CH3,CH4\n%%-------------------------------------------------------------------\n%%  1. MT  -> VGK : M1,F(ZZ,M1)\n%%  2. VGK -> AuF : M2,F(ZZ_VA,M2) \n%%  3. AuF -> VGK : M3,F(ZZ_VA,M3) \n%%  4. VGK -> MT  : M4,F(exp(exp(G,X),Y),M4) \n%%  5. MT  -> VGK : M5,F(exp(exp(G,X),Y),M5)\n%%  6. VGK -> MT  : M6,F(exp(exp(G,X),Y),M6)\n%% \\end{verbatim}\n%% PROBLEMS: 3\n%% ATTACKS: None\n%% NOTES: This is the fixed version.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%  HLPSL:\n\nrole mobileTerminal (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ\t       : symmetric_key,\n    NIL,G      : text)\nplayed_by MT def=\n\n  local\n    State       : nat,\n    X,CH1,CH3   : text,\n    CH2,CH4     : text,\n    GY,Key      : message\n\n  const sec_m_Key : protocol_id\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 1 /\\ X' := new()\n               /\\ CH1' := new()\n               /\\ SND(MT.VGK.NIL.CH1'.exp(G,X').F(ZZ.MT.VGK.NIL.CH1'.exp(G,X')))\n\n 2. State  = 1 /\\ RCV(VGK.MT.CH1.CH2'.GY'.\n                      F(ZZ.xor(exp(G,X),GY')).\n                      F(ZZ.VGK).\n\t\t      F(exp(GY',X).VGK.MT.CH1.CH2'.GY'.\n                        F(ZZ.xor(exp(G,X),GY')).\n                        F(ZZ.VGK)))\n              =|>\n    State':= 2 /\\ CH3' := new()\n               /\\ Key' := exp(GY',X)\n               /\\ SND(MT.VGK.CH2'.CH3'.F(Key'.MT.VGK.CH2'.CH3'))\n\t       /\\ witness(MT,VGK,key1,Key')\n\n 3. State  = 2 /\\ RCV(VGK.MT.CH3.CH4'.F(Key.VGK.MT.CH3.CH4')) =|>\n    State':= 3 /\\ request(MT,VGK,key,Key)\n\t       /\\ secret(Key,sec_m_Key,{VGK,AuF})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole visitedGateKeeper (\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ_VA      : symmetric_key,\n    NIL,G      : text)\nplayed_by VGK def=\n\n  local\n    State          : nat,\n    GX,Key         : message,\n    FM1 : hash(symmetric_key.agent.agent.text.text.message),\n    FM2 : hash(symmetric_key.agent),\n    FM3 : hash(symmetric_key.message),\n    M2 : message,\n    Y,CH2,CH4      : text,\n    CH1,CH3        : text\n\n  const sec_v_Key : protocol_id\n\n  init  State := 0\n\n  transition\n\n  1. State = 0  /\\ RCV(MT.VGK.NIL.CH1'.GX'.FM1') =|>\n     State':= 1 /\\ Y' := new()\n                /\\ Key' := exp(GX',Y')\n                /\\ M2' := MT.VGK.NIL.CH1'.GX'.FM1'.VGK.xor(GX',exp(G,Y'))\n\t        /\\ SND(M2'.F(ZZ_VA.M2'))\n                /\\ witness(VGK,MT,key,Key')\n \n  2. State = 1  /\\ RCV(VGK.MT.FM2'.FM3'.\n                       xor(GX,exp(G,Y)).\n                       F(ZZ_VA.VGK.MT.FM2'.FM3'.xor(GX,exp(G,Y)))) =|>\n     State':= 2 /\\ CH2' := new()\n                /\\ SND(  VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'.\n\t \t         F(Key.VGK.MT.CH1.CH2'.exp(G,Y).FM3'.FM2'))\n\n  3. State = 2  /\\ RCV(MT.VGK.CH2.CH3'.F(Key.MT.VGK.CH2.CH3')) =|>\n     State':= 3 /\\ CH4' := new()\n                /\\ SND(VGK.MT.CH3'.CH4'.F(Key.VGK.MT.CH3'.CH4'))\n\t        /\\ request(VGK,MT,key1,Key)\n                /\\ secret(Key,sec_v_Key,{MT})\n \nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole authenticationFacility(\n    MT,VGK,AuF : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\nplayed_by AuF def=\n\n  local\n    State         : nat,\n    GX,GY\t  : message,\n    CH1           : text\n\n  init\n    State := 0\n\n  transition\n\n  1. State = 0 /\\  RCV(       MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY').\n\t\t      F(ZZ_VA.MT.VGK.NIL.CH1'.GX'.\n                         F(ZZ.MT.VGK.NIL.CH1'.GX').\n\t                      VGK.xor(GX',GY')))  =|>\n\n     State':= 1 /\\ SND(       VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY').\n                      F(ZZ_VA.VGK.MT.F(ZZ.VGK).F(ZZ.xor(GX',GY')).xor(GX',GY')))\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n    MT,VGK,AuF : agent,\n    F          : hash_func,\n    ZZ,ZZ_VA   : symmetric_key,\n    NIL,G      : text)\ndef=\n\n  local SND,RCV : channel (dy)\n\n  composition\n    mobileTerminal(MT,VGK,AuF,SND,RCV,F,ZZ,NIL,G)\n /\\ authenticationFacility(MT,VGK,AuF,SND,RCV,F,ZZ,ZZ_VA,NIL,G)\n /\\ visitedGateKeeper(MT,VGK,AuF,SND,RCV,F,ZZ_VA,NIL,G)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const\n    a,b,auf                    : agent,\n    f                          : hash_func,\n    key, key1                  : protocol_id,\n    zz_a_auf,zz_b_auf,zz_i_auf : symmetric_key,\n    nil,g                      : text\n\n  intruder_knowledge = {a,b,auf,f,zz_i_auf}\n\n  composition\n    session(a,b,auf,f,zz_a_auf,zz_b_auf,nil,g)\n /\\ session(i,b,auf,f,zz_i_auf,zz_b_auf,nil,g)\n /\\ session(a,i,auf,f,zz_a_auf,zz_i_auf,nil,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % Entity authentication (G1)\n  % Message authentication (G2)\n  % Replay protection (G3)\n  % Authorization (by T3P) (G6)\n  % Key authentication (G7)\n  authentication_on key\n  authentication_on key1\n  secrecy_of sec_m_Key, sec_v_Key\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/hash_n_single.hlpsl",
        "incomplete": "%% Lamport, L. (1981). \"Password authentication with insecure communication.\" Commun. ACM 24(11): 770-772. -> hash^1000\n%% \u90ed\u4e39\u9752 (2014). \"OAuth2. 0 \u534f\u8bae\u5f62\u5f0f\u5316\u9a8c\u8bc1: \u4f7f\u7528 AVISPA.\" \u8ba1\u7b97\u673a\u7cfb\u7edf\u5e94\u7528 23(11): 196-202. -> AVISPA\t\n\n____(ROLE_0)____ user (\n    U,____(PARAM_1)____ : agent,\n    ____(PARAM_2)____,____(PARAM_0)____    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Nah4      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\t       /\\ witness(____(EVENT_0)____,S,____(EVENT_1)____,Nah4')\n\t\t\t   \nend role\n\n\nrole server (\n    ____(PARAM_3)____,____(PARAM_5)____ : agent,\n    SND,____(PARAM_4)____    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : ____(VARIABLE_0)____\n\n  init  State := 1\n\n  transition\n\n  1. State = ____(STATE_0)____ /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ request(S,U,____(EVENT_2)____,F(F(F(F(____(EVENT_3)____)))))\n\n         \nend role\n\n\nrole session(\n    ____(PARAM_6)____,S : agent,\n    F          : ____(PARAM_7)____,\n    ____(PARAM_8)____      : text)\ndef=\n\n  local ____(VARIABLE_1)____,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s      : ____(VARIABLE_2)____,\n    f            : hash_func,\n    user_server_nah4     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\n____(ROLE_1)____\n  ____(GOAL_4)____ user_server_nah4\n\nend goal\n\n\nenvironment()",
        "complete:": "%% Lamport, L. (1981). \"Password authentication with insecure communication.\" Commun. ACM 24(11): 770-772. -> hash^1000\n%% \u90ed\u4e39\u9752 (2014). \"OAuth2. 0 \u534f\u8bae\u5f62\u5f0f\u5316\u9a8c\u8bc1: \u4f7f\u7528 AVISPA.\" \u8ba1\u7b97\u673a\u7cfb\u7edf\u5e94\u7528 23(11): 196-202. -> AVISPA\t\n\nrole user (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by U def=\n\n  local\n    State       : nat,\n    Nah4      : message\n    \n  init  State := 0\n\n  transition\n\n 1. State  = 0 /\\ RCV(start) =|>\n    State':= 2 /\\ Nah4' := F(F(F(F(PW))))\n               /\\ SND(Nah4'.U)\n\t       /\\ witness(U,S,user_server_nah4,Nah4')\n\t\t\t   \nend role\n\n\nrole server (\n    U,S : agent,\n    SND,RCV    : channel(dy),\n    F          : hash_func,\n    PW      : text)\nplayed_by S def=\n\n  local\n    State          : nat\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV(F(F(F(F(PW)))).U) =|> \n     State':= 3 /\\ request(S,U,user_server_nah4,F(F(F(F(PW)))))\n\n         \nend role\n\n\nrole session(\n    U,S : agent,\n    F          : hash_func,\n    PW      : text)\ndef=\n\n  local SU,RU : channel (dy)\n\n  composition\n    user(U,S,SU,RU,F,PW)\n /\\ server(U,S,SU,RU,F,PW)\n\nend role\n\nrole environment()\ndef=\n\n  const\n    u,s      : agent,\n    f            : hash_func,\n    user_server_nah4     : protocol_id,\n    pw,pwi,pwi2        : text\n\n  intruder_knowledge = {u,s,f,pwi,pwi2}\n\n  composition\n     session(u,s,f,pw)\n  /\\ session(u,i,f,pwi)\n  /\\ session(i,s,f,pwi2)\nend role\n\n\ngoal\n  authentication_on user_server_nah4\n\nend goal\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/IIOT.hlpsl",
        "incomplete": "%IIoT\n____(ROLE_0)____ nodeU (____(PARAM_2)____,____(PARAM_0)____: ____(PARAM_4)____,\n            ____(PARAM_1)____: hash_func,\n       Qca,____(PARAM_6)____,Qu: public_key,\n       Dg,____(PARAM_5)____,Kug: symmetric_key,\n         SND,____(PARAM_3)____: channel (____(PARAM_7)____))\nplayed_by U def=\nlocal\nState: ____(VARIABLE_0)____,\nIdu,Idg,Certu,Certg,Su,Sg,Ts0,\nTs1,Lt0,Lt1,N5,Au,Ag,H4:text,\nM5: message\ninit State:= 0\ntransition\n1. State = 0 /\\ RCV(start) =|>\n  State':= 1 /\\ N5' := new()\n             /\\ Ag' := {Idg.Certg.Sg.Ts0.Lt0}_Qca\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ M5' := {Idg.N5.Au.H4}_Qg\n             /\\ SND(M5')\n             /\\ secret({Idg,____(EVENT_0)____},sub1,{____(EVENT_2)____,____(EVENT_1)____})\nend role\n\nrole gateway (U,____(PARAM_13)____: agent,\n              Hmac: hash_func,\n         ____(PARAM_12)____,____(PARAM_11)____,____(PARAM_14)____: ____(PARAM_8)____,\n         ____(PARAM_10)____,Du,Kug: ____(PARAM_9)____,\n           ____(PARAM_15)____,RCV: channel (dy))\nplayed_by Gw def=\nlocal\n____(VARIABLE_1)____ :nat,\nIdu,Idg,Certu,Su,\nTs1,Lt1,N5,Au,H4:text,\nM5: message\ninit State:= 1\ntransition\n1. State = ____(STATE_0)____ /\\ RCV(M5') =|>\n  State':= 2 /\\ M5' := {Idg.N5.Au.H4}_Dg\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ ____(EVENT_3)____(Gw,U,____(EVENT_4)____,N5)\n             /\\ witness(____(EVENT_5)____,U,____(EVENT_6)____,Lt1) \nend role\n\nrole session (____(PARAM_21)____,Gw: agent,\n              ____(PARAM_16)____: hash_func,\n         ____(PARAM_20)____,____(PARAM_19)____,____(PARAM_17)____: public_key,\n         Dg,____(PARAM_18)____,Kug: symmetric_key)\ndef=\nlocal SU,RU,____(VARIABLE_2)____,RGw: channel(____(VARIABLE_3)____)\ncomposition\n  nodeU(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SU,RU)\n/\\gateway(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SGw,RGw)\nend role\n\nrole environment ()\ndef=\nconst    ____(VARIABLE_4)____,gateway: agent,\n             qca,qg,qu: public_key,\ndg,du,kug,dgi,dui,kugi:symmetric_key,\nidu,idg,certu,certg,su,sg,\nts0,ts1,lt0,lt1,n5,au,ag,h4: text,\nhmac: hash_func,\nnodeU_gateway_n5,nodeU_gateway_lt1,sub1: protocol_id\nintruder_knowledge = {nodeU,gateway,hmac,dgi,dui,qca,qg,qu}\ncomposition\n  session(nodeU,gateway,hmac,qca,qg,qu,dg,du,kug)\n/\\session(nodeU,i,hmac,qca,qg,qu,dgi,dui,kugi)\n/\\session(i,gateway,hmac,qca,qg,qu,dgi,dui,kugi)\nend role\n\n____(ROLE_1)____\n____(GOAL_7)____ sub1\n____(GOAL_8)____ nodeU_gateway_n5\nauthentication_on ____(GOAL_9)____\nend goal\nenvironment ()",
        "complete:": "%IIoT\nrole nodeU (U,Gw: agent,\n            Hmac: hash_func,\n       Qca,Qg,Qu: public_key,\n       Dg,Du,Kug: symmetric_key,\n         SND,RCV: channel (dy))\nplayed_by U def=\nlocal\nState: nat,\nIdu,Idg,Certu,Certg,Su,Sg,Ts0,\nTs1,Lt0,Lt1,N5,Au,Ag,H4:text,\nM5: message\ninit State:= 0\ntransition\n1. State = 0 /\\ RCV(start) =|>\n  State':= 1 /\\ N5' := new()\n             /\\ Ag' := {Idg.Certg.Sg.Ts0.Lt0}_Qca\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ M5' := {Idg.N5.Au.H4}_Qg\n             /\\ SND(M5')\n             /\\ secret({Idg,Au'},sub1,{U,Gw})\nend role\n\nrole gateway (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key,\n           SND,RCV: channel (dy))\nplayed_by Gw def=\nlocal\nState :nat,\nIdu,Idg,Certu,Su,\nTs1,Lt1,N5,Au,H4:text,\nM5: message\ninit State:= 1\ntransition\n1. State = 1 /\\ RCV(M5') =|>\n  State':= 2 /\\ M5' := {Idg.N5.Au.H4}_Dg\n             /\\ Au' := {Idu.Certu.Su.Ts1.Lt1}_Qca\n             /\\ H4' := Hmac(Kug.Idg.N5.Au)\n             /\\ witness(Gw,U,nodeU_gateway_n5,N5)\n             /\\ witness(Gw,U,nodeU_gateway_lt1,Lt1) \nend role\n\nrole session (U,Gw: agent,\n              Hmac: hash_func,\n         Qca,Qg,Qu: public_key,\n         Dg,Du,Kug: symmetric_key)\ndef=\nlocal SU,RU,SGw,RGw: channel(dy)\ncomposition\n  nodeU(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SU,RU)\n/\\gateway(U,Gw,Hmac,Qca,Qg,Qu,Dg,Du,Kug,SGw,RGw)\nend role\n\nrole environment ()\ndef=\nconst    nodeU,gateway: agent,\n             qca,qg,qu: public_key,\ndg,du,kug,dgi,dui,kugi:symmetric_key,\nidu,idg,certu,certg,su,sg,\nts0,ts1,lt0,lt1,n5,au,ag,h4: text,\nhmac: hash_func,\nnodeU_gateway_n5,nodeU_gateway_lt1,sub1: protocol_id\nintruder_knowledge = {nodeU,gateway,hmac,dgi,dui,qca,qg,qu}\ncomposition\n  session(nodeU,gateway,hmac,qca,qg,qu,dg,du,kug)\n/\\session(nodeU,i,hmac,qca,qg,qu,dgi,dui,kugi)\n/\\session(i,gateway,hmac,qca,qg,qu,dgi,dui,kugi)\nend role\n\ngoal\nsecrecy_of sub1\nauthentication_on nodeU_gateway_n5\nauthentication_on nodeU_gateway_lt1\nend goal\nenvironment ()"
    },
    {
        "file": "HLPSL-1/IKEv2-MAC.hlpsl",
        "incomplete": "%% PROTOCOL*: IKEv2\n%% VARIANT: authentication based on MACs\n%% PURPOSE:\n%% IKE is designed to perform mutual authentication and key\n%% exchange prior to setting up an IPsec connection.\n%% IKEv2 exists in several variants, the defining difference\n%% being the authentication method used.\n%%\n%% This variant, which\n%% we call IKEv2-MAC, is based on exchanging the MAC of a\n%% pre-shared secret that both nodes possess.\n%%\n%% REFERENCE:\n%% \\cite{ipsec-ikev2}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\item Paul Hankes Drielsma, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%% ALICE_BOB:\n%% IKEv2-MAC proceeds in two so-called exchanges.  In the first,\n%% called IKE\\_SA\\_INIT, the users exchange nonces and perform \n%% a Diffie-Hellman exchange, establishing an initial security \n%% association called the IKE\\_SA.  The second exchange,\n%% IKE\\_SA\\_AUTH, then authenticates the previous messages,\n%% exchanges the user identities, and establishes the first \n%% so-called \"child security association\" or CHILD\\_SA which will\n%% be used to secure the subsequent IPsec tunnel.\n%% A (respectively B) generates a nonce Na and a Diffie-Hellman \n%% half key KEa (respectively KEb).  In addition, SAa1 contains A's \n%% cryptosuite offers and SAb1 B's preference for the establishment\n%% of the IKE\\_SA.  Similarly SAa2 and SAb2 for the establishment of \n%% the CHILD\\_SA.  The two parties share a secret in advance, the \n%% so-called PSK or pre-shared key.  The authenticator message is\n%% built by taking a hash of the PSK and the previously exchanged\n%% messages.\n%%\\begin{verbatim}\n%% IKE_SA_INIT\n%% 1. A -> B: SAa1, KEa, Na\n%% 2. B -> A: SAb1, KEb, Nb\n%% IKE_SA_AUTH\n%% 3. A -> B: {A, AUTHa, SAa2}K\n%%    where K = H(Na.Nb.SAa1.g^KEa^KEb) and \n%%      AUTHa = F(PSK.SAa1.KEa.Na.Nb)\n%% 4. B -> A: {B, AUTHb, SAb2}K\n%%    where \n%%      AUTHb = F(PSK.SAa1.KEr.Na.Nb)\n%%\\end{verbatim}\n%% Note that because we abstract away from the negotiation of \n%% cryptographic algorithms, we have SAa1 = SAb1 and \n%% SAa2 = SAb2.  \n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item The parties, Alice and Bob, should negotiate mutually \n%% acceptable cryptographic algorithms.  This we abstract by\n%% modelling that Alice sends only a single offer for a crypto-suite,\n%% and Bob must accept this offer.  We thus assume that goal G11\n%% is fulfilled.\n%%\\item There are goals of IKEv2 which we do not yet consider.  For\n%% instance, identity hiding.\n%%\\item We do not model the exchange of traffic selectors, which\n%% are specific to the IP network model and would be meaningless\n%% in our abstract communication model.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G3, G7, G9, G10, G11\n%% ATTACKS: None.  Note that the use of MAC-based authentication\n%% precludes the man-in-the-middle attack that is possible on\n%% the first variant, IKEv2-DS.  \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole alice(____(PARAM_0)____,B: agent,\n\t   ____(PARAM_5)____: ____(PARAM_3)____,\n\t   ____(PARAM_1)____: hash_func,\n           ____(PARAM_2)____: symmetric_key,\n\t   SND_B, RCV_B: channel (____(PARAM_4)____))\nplayed_by A\ndef=\n\n  local ____(VARIABLE_0)____, SA1, SA2, ____(VARIABLE_1)____: text, \n\tNr: text,\n\tKEr: message, %% more spefic: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat,\n\tAUTH_B: message\n\n  const ____(VARIABLE_2)____ : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = ____(STATE_0)____  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,____(EVENT_0)____,sk2,F(Ni.Nr'.SA1.exp(____(EVENT_1)____,____(EVENT_2)____)))\n\n  3. State = ____(STATE_1)____  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(____(EVENT_4)____,sec_a_SK,{____(EVENT_3)____,B})\n                /\\ ____(EVENT_6)____(A,B,____(EVENT_5)____,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole ____(ROLE_1)____(B,A:____(PARAM_6)____,\n\t     G: text,\n\t     ____(PARAM_9)____: hash_func,\n\t     ____(PARAM_7)____: ____(PARAM_8)____,\n\t     ____(PARAM_10)____, RCV_A: channel (____(PARAM_11)____))\nplayed_by B\ndef=\n\n  local ____(VARIABLE_4)____, SA1, SA2: ____(VARIABLE_3)____, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat,\n\tAUTH_A: message\n\n  const sec_b_SK : ____(VARIABLE_5)____\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,____(EVENT_8)____,____(EVENT_7)____)\n               /\\ ____(EVENT_10)____(____(EVENT_9)____,sec_b_SK,{A,B})\n               /\\ request(B,____(EVENT_11)____,____(EVENT_12)____,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole ____(ROLE_0)____(____(PARAM_15)____, B: agent,\n\t     PSK: ____(PARAM_13)____,\n\t     ____(PARAM_12)____: text,\n             F: ____(PARAM_14)____)\ndef=\n\n  local ____(VARIABLE_6)____, RA, SB, ____(VARIABLE_7)____: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,SA,RA)\n\t/\\ bob(B,A,G,F,PSK,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, ____(VARIABLE_9)____      : ____(VARIABLE_8)____,\n        a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi\n                       }\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()",
        "complete:": "%% PROTOCOL*: IKEv2\n%% VARIANT: authentication based on MACs\n%% PURPOSE:\n%% IKE is designed to perform mutual authentication and key\n%% exchange prior to setting up an IPsec connection.\n%% IKEv2 exists in several variants, the defining difference\n%% being the authentication method used.\n%%\n%% This variant, which\n%% we call IKEv2-MAC, is based on exchanging the MAC of a\n%% pre-shared secret that both nodes possess.\n%%\n%% REFERENCE:\n%% \\cite{ipsec-ikev2}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\item Paul Hankes Drielsma, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%% ALICE_BOB:\n%% IKEv2-MAC proceeds in two so-called exchanges.  In the first,\n%% called IKE\\_SA\\_INIT, the users exchange nonces and perform \n%% a Diffie-Hellman exchange, establishing an initial security \n%% association called the IKE\\_SA.  The second exchange,\n%% IKE\\_SA\\_AUTH, then authenticates the previous messages,\n%% exchanges the user identities, and establishes the first \n%% so-called \"child security association\" or CHILD\\_SA which will\n%% be used to secure the subsequent IPsec tunnel.\n%% A (respectively B) generates a nonce Na and a Diffie-Hellman \n%% half key KEa (respectively KEb).  In addition, SAa1 contains A's \n%% cryptosuite offers and SAb1 B's preference for the establishment\n%% of the IKE\\_SA.  Similarly SAa2 and SAb2 for the establishment of \n%% the CHILD\\_SA.  The two parties share a secret in advance, the \n%% so-called PSK or pre-shared key.  The authenticator message is\n%% built by taking a hash of the PSK and the previously exchanged\n%% messages.\n%%\\begin{verbatim}\n%% IKE_SA_INIT\n%% 1. A -> B: SAa1, KEa, Na\n%% 2. B -> A: SAb1, KEb, Nb\n%% IKE_SA_AUTH\n%% 3. A -> B: {A, AUTHa, SAa2}K\n%%    where K = H(Na.Nb.SAa1.g^KEa^KEb) and \n%%      AUTHa = F(PSK.SAa1.KEa.Na.Nb)\n%% 4. B -> A: {B, AUTHb, SAb2}K\n%%    where \n%%      AUTHb = F(PSK.SAa1.KEr.Na.Nb)\n%%\\end{verbatim}\n%% Note that because we abstract away from the negotiation of \n%% cryptographic algorithms, we have SAa1 = SAb1 and \n%% SAa2 = SAb2.  \n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item The parties, Alice and Bob, should negotiate mutually \n%% acceptable cryptographic algorithms.  This we abstract by\n%% modelling that Alice sends only a single offer for a crypto-suite,\n%% and Bob must accept this offer.  We thus assume that goal G11\n%% is fulfilled.\n%%\\item There are goals of IKEv2 which we do not yet consider.  For\n%% instance, identity hiding.\n%%\\item We do not model the exchange of traffic selectors, which\n%% are specific to the IP network model and would be meaningless\n%% in our abstract communication model.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G3, G7, G9, G10, G11\n%% ATTACKS: None.  Note that the use of MAC-based authentication\n%% precludes the man-in-the-middle attack that is possible on\n%% the first variant, IKEv2-DS.  \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole alice(A,B: agent,\n\t   G: text,\n\t   F: hash_func,\n           PSK: symmetric_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more spefic: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat,\n\tAUTH_B: message\n\n  const sec_a_SK : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t     G: text,\n\t     F: hash_func,\n\t     PSK: symmetric_key,\n\t     SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat,\n\tAUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk1,SK)\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, B: agent,\n\t     PSK: symmetric_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,SA,RA)\n\t/\\ bob(B,A,G,F,PSK,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : protocol_id,\n        a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi\n                       }\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/InitialAuth.hlpsl",
        "incomplete": "____(ROLE_0)____ role_Newnode(Newnode:____(PARAM_1)____,ClusterAdmin:____(PARAM_3)____,____(PARAM_4)____:text,Knc:____(PARAM_0)____,____(PARAM_2)____:____(PARAM_5)____,SND,RCV:channel(dy))\nplayed_by Newnode\ndef=\n\tlocal\n\t\t____(VARIABLE_1)____:nat,____(VARIABLE_0)____:____(VARIABLE_2)____,____(VARIABLE_5)____:____(VARIABLE_4)____,Solution:text,____(VARIABLE_3)____:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=____(STATE_0)____ /\\ RCV(start) =|> State':=1 /\\ SND({AuthRequest}_Knc)\n\t\t2. State=____(STATE_2)____ /\\ RCV({Challenge'.T'}_Knc) =|> State':=2 /\\ Solution':=new() /\\ SND({Solution'.inv(Kn)}_Knc)\n\t\t4. State=2 /\\ RCV({Uniqid'.Success'}_inv(Kn)) =|> State':=3 /\\ ____(EVENT_1)____(Newnode,ClusterAdmin,auth_1,____(EVENT_0)____)\nend ____(ROLE_1)____\n\n____(ROLE_2)____ role_ClusterAdmin(Newnode:____(PARAM_13)____,____(PARAM_10)____:agent,____(PARAM_6)____:agent,____(PARAM_12)____:public_key,Knc:____(PARAM_7)____,Kcc:____(PARAM_9)____,____(PARAM_11)____:text,SND,RCV:channel(____(PARAM_8)____))\nplayed_by ClusterAdmin\ndef=\n\tlocal\n\t\t____(VARIABLE_7)____:nat,AuthRequest:____(VARIABLE_8)____,Challenge:____(VARIABLE_9)____,Solution:____(VARIABLE_11)____,____(VARIABLE_6)____:text,____(VARIABLE_10)____:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=____(STATE_1)____ /\\ RCV({AuthRequest'}_Knc) =|> State':=1 /\\ Challenge':=new() /\\ SND({Challenge'.T}_Knc)\n\t\t3. State=1 /\\ RCV({Solution'.inv(Kn)}_Knc) =|> State':=2 /\\ Success':=new() /\\ Uniqid':=new() /\\ ____(EVENT_2)____(ClusterAdmin,Newnode,auth_1,____(EVENT_3)____) /\\ SND({Uniqid'.Success'}_inv(Kn)) /\\ SND({Uniqid'}_Kcc)\nend role\n\nrole role_OtherClusterAdmins(____(PARAM_20)____:____(PARAM_14)____,____(PARAM_18)____:____(PARAM_16)____,ClusterAdmin:agent,Kn:____(PARAM_15)____,____(PARAM_17)____:____(PARAM_19)____,Knc:symmetric_key,SND,RCV:channel(dy))\nplayed_by OtherClusterAdmins\ndef=\n\tlocal\n\t\tState:____(VARIABLE_12)____,____(VARIABLE_13)____:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t5. State=0 /\\ RCV({Uniqid'}_Kcc) =|> State':=1\nend role\n\nrole session1(T:____(PARAM_23)____,AuthRequest:text,OtherClusterAdmins:____(PARAM_24)____,Newnode:____(PARAM_25)____,____(PARAM_21)____:____(PARAM_28)____,Kn:public_key,____(PARAM_27)____:____(PARAM_22)____,Knc:____(PARAM_26)____)\ndef=\n\tlocal\n\t\tSND3,____(VARIABLE_15)____,SND2,____(VARIABLE_14)____,SND1,____(VARIABLE_16)____:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole session2(____(PARAM_33)____:____(PARAM_29)____,AuthRequest:text,____(PARAM_32)____:____(PARAM_30)____,____(PARAM_34)____:____(PARAM_31)____,____(PARAM_36)____:agent,____(PARAM_35)____:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,____(VARIABLE_19)____,____(VARIABLE_17)____,RCV2,____(VARIABLE_18)____,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkcc:____(VARIABLE_26)____,clusteradmin:____(VARIABLE_20)____,knc:____(VARIABLE_27)____,newnode:____(VARIABLE_29)____,____(VARIABLE_21)____:____(VARIABLE_23)____,hash_0:____(VARIABLE_22)____,otherclusteradmins:agent,____(VARIABLE_24)____:public_key,kic:symmetric_key,____(VARIABLE_25)____:____(VARIABLE_28)____\n\tintruder_knowledge = {newnode,clusteradmin,kic,kn}\n\tcomposition\n\t\tsession2(const_1,const_1,otherclusteradmins,i,clusteradmin,kn,kcc,kic) /\\ session1(const_1,const_1,otherclusteradmins,newnode,clusteradmin,kn,kcc,knc)\nend role\n\ngoal\n\t____(GOAL_4)____ auth_1\nend goal\n\nenvironment()",
        "complete:": "role role_Newnode(Newnode:agent,ClusterAdmin:agent,AuthRequest:text,Knc:symmetric_key,Kn:public_key,SND,RCV:channel(dy))\nplayed_by Newnode\ndef=\n\tlocal\n\t\tState:nat,Challenge:text,T:text,Solution:text,Uniqid:text,Success:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ SND({AuthRequest}_Knc)\n\t\t2. State=1 /\\ RCV({Challenge'.T'}_Knc) =|> State':=2 /\\ Solution':=new() /\\ SND({Solution'.inv(Kn)}_Knc)\n\t\t4. State=2 /\\ RCV({Uniqid'.Success'}_inv(Kn)) =|> State':=3 /\\ request(Newnode,ClusterAdmin,auth_1,Uniqid')\nend role\n\nrole role_ClusterAdmin(Newnode:agent,ClusterAdmin:agent,OtherClusterAdmins:agent,Kn:public_key,Knc:symmetric_key,Kcc:symmetric_key,T:text,SND,RCV:channel(dy))\nplayed_by ClusterAdmin\ndef=\n\tlocal\n\t\tState:nat,AuthRequest:text,Challenge:text,Solution:text,Success:text,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({AuthRequest'}_Knc) =|> State':=1 /\\ Challenge':=new() /\\ SND({Challenge'.T}_Knc)\n\t\t3. State=1 /\\ RCV({Solution'.inv(Kn)}_Knc) =|> State':=2 /\\ Success':=new() /\\ Uniqid':=new() /\\ witness(ClusterAdmin,Newnode,auth_1,Uniqid') /\\ SND({Uniqid'.Success'}_inv(Kn)) /\\ SND({Uniqid'}_Kcc)\nend role\n\nrole role_OtherClusterAdmins(OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key,SND,RCV:channel(dy))\nplayed_by OtherClusterAdmins\ndef=\n\tlocal\n\t\tState:nat,Uniqid:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t5. State=0 /\\ RCV({Uniqid'}_Kcc) =|> State':=1\nend role\n\nrole session1(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole session2(T:text,AuthRequest:text,OtherClusterAdmins:agent,Newnode:agent,ClusterAdmin:agent,Kn:public_key,Kcc:symmetric_key,Knc:symmetric_key)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_OtherClusterAdmins(OtherClusterAdmins,Newnode,ClusterAdmin,Kn,Kcc,Knc,SND3,RCV3) /\\ role_ClusterAdmin(Newnode,ClusterAdmin,OtherClusterAdmins,Kn,Knc,Kcc,T,SND2,RCV2) /\\ role_Newnode(Newnode,ClusterAdmin,AuthRequest,Knc,Kn,SND1,RCV1)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tkcc:symmetric_key,clusteradmin:agent,knc:symmetric_key,newnode:agent,const_1:text,hash_0:hash_func,otherclusteradmins:agent,kn:public_key,kic:symmetric_key,auth_1:protocol_id\n\tintruder_knowledge = {newnode,clusteradmin,kic,kn}\n\tcomposition\n\t\tsession2(const_1,const_1,otherclusteradmins,i,clusteradmin,kn,kcc,kic) /\\ session1(const_1,const_1,otherclusteradmins,newnode,clusteradmin,kn,kcc,knc)\nend role\n\ngoal\n\tauthentication_on auth_1\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/IoT-HAN.hlpsl",
        "incomplete": "%Formal Verification of RLAS\nrole ____(ROLE_1)____ (U,V: ____(PARAM_0)____,\n\t   ____(PARAM_2)____: hash_func,\n\t    Qca: ____(PARAM_5)____,\n  Key1,____(PARAM_1)____,____(PARAM_4)____: ____(PARAM_3)____,\n       SND, ____(PARAM_6)____: channel (dy))\t\nplayed_by U def= \nlocal \nState\t\t\t\t   :____(VARIABLE_0)____,\nIdu,Certu,Lt,Idca,Nv,Certv,Nu,Idv  :text, \nToken1,Token2,Z1,Z2\t           :message\n\ninit State:= 0\ntransition\n1. State = ____(STATE_0)____  /\\ RCV(start)  =|>\n  State':= 1  /\\ Nu' := new()\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n\t      /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ SND(Token1',Z1')\n              /\\ secret ({____(EVENT_0)____,Nu'},____(EVENT_1)____,{U,____(EVENT_2)____})\n\n\n2. State = 2  /\\ RCV(Token2',Z2') =|>\n   State':= 3 /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ ____(EVENT_4)____(____(EVENT_3)____,V,nodeV_nodeU_lt,Lt)\nend role\n\nrole nodeV (U,____(PARAM_10)____: ____(PARAM_7)____,\n\t   Hash: hash_func,\n\t    Qca: ____(PARAM_12)____,\n  ____(PARAM_9)____,Key2,Ks1: symmetric_key,\n       ____(PARAM_8)____, ____(PARAM_11)____: channel (____(PARAM_13)____))\t\nplayed_by V def= \nlocal \nState\t\t\t           :____(VARIABLE_1)____,\nIdu,Certu,Lt,Idca,Nv,Nu,Certv,Idv,E:text, \nToken1,Token2,Z1,Z2\t\t   :message\n\ninit State:= 1\ntransition\n1. State = 1  /\\ RCV(Token1',Z1')  =|>\n   State':= 2 /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n              /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ SND (Token2',Z2')\n              /\\ secret ({____(EVENT_7)____,Nv},sub2,{____(EVENT_5)____,____(EVENT_6)____})\n              /\\ witness(____(EVENT_8)____,____(EVENT_9)____,nodeU_nodeV_lt,Lt)\nend role\n\nrole session (U,V: ____(PARAM_14)____,\n\t     ____(PARAM_17)____: hash_func,\n\t      Qca: ____(PARAM_16)____,\n    ____(PARAM_15)____,Key2,Ks1: ____(PARAM_18)____)\ndef=\nlocal SU,RU,____(VARIABLE_2)____,____(VARIABLE_3)____: channel(dy)\ncomposition\n   nodeU(U,V,Hash,Qca,Key1,Key2,Ks1,SU,RU) \n/\\ nodeV(U,V,Hash,Qca,Key1,Key2,Ks1,SV,RV)\nend role\n\nrole environment ()\ndef=\nconst nodeU,nodeV: ____(VARIABLE_4)____,\nqca: public_key,\nkey1,key2,ks1,key1i,key2i,ks1i: symmetric_key,\nidu,certu,lt,idca,e,nv,nu,certv,idv: text,\nh: hash_func,\nnodeU_nodeV_lt,nodeV_nodeU_lt,sub1,sub2: protocol_id\n\nintruder_knowledge={nodeU,nodeV,h,key1i,key2i,ks1i,qca}\n\ncomposition\nsession(nodeU,nodeV,h,qca,key1,key2,ks1)\n/\\session(nodeU,i,h,qca,key1i,key2i,ks1i)\n/\\session(i,nodeV,h,qca,key1i,key2i,ks1i)     \n\nend role\n\n____(ROLE_0)____\nsecrecy_of ____(GOAL_10)____\n____(GOAL_11)____ sub2\nauthentication_on ____(GOAL_12)____\nauthentication_on ____(GOAL_13)____\nend goal\n\nenvironment ()",
        "complete:": "%Formal Verification of RLAS\nrole nodeU (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by U def= \nlocal \nState\t\t\t\t   :nat,\nIdu,Certu,Lt,Idca,Nv,Certv,Nu,Idv  :text, \nToken1,Token2,Z1,Z2\t           :message\n\ninit State:= 0\ntransition\n1. State = 0  /\\ RCV(start)  =|>\n  State':= 1  /\\ Nu' := new()\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n\t      /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ SND(Token1',Z1')\n              /\\ secret ({Certu,Nu'},sub1,{U,V})\n\n\n2. State = 2  /\\ RCV(Token2',Z2') =|>\n   State':= 3 /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ witness(U,V,nodeV_nodeU_lt,Lt)\nend role\n\nrole nodeV (U,V: agent,\n\t   Hash: hash_func,\n\t    Qca: public_key,\n  Key1,Key2,Ks1: symmetric_key,\n       SND, RCV: channel (dy))\t\nplayed_by V def= \nlocal \nState\t\t\t           :nat,\nIdu,Certu,Lt,Idca,Nv,Nu,Certv,Idv,E:text, \nToken1,Token2,Z1,Z2\t\t   :message\n\ninit State:= 1\ntransition\n1. State = 1  /\\ RCV(Token1',Z1')  =|>\n   State':= 2 /\\ Z1' := {Certu.Lt.Nu.Idu.Idca}_Ks1\n              /\\ Key1' := xor(Nu,xor(Idu,Idca))\n              /\\ Token1' := Hash(Certu.Lt.Nu.Idu.Idca)\n              /\\ Key2' := xor(Nv,xor(Idv,Idca))\n\t      /\\ Token2' := Hash(Certv.Lt.Nv.Idv.Idca)\n\t      /\\ Z2' := {Certv.Lt.Nv.Idv.Idca}_Key2'\n              /\\ SND (Token2',Z2')\n              /\\ secret ({Certv,Nv},sub2,{U,V})\n              /\\ witness(V,U,nodeU_nodeV_lt,Lt)\nend role\n\nrole session (U,V: agent,\n\t     Hash: hash_func,\n\t      Qca: public_key,\n    Key1,Key2,Ks1: symmetric_key)\ndef=\nlocal SU,RU,SV,RV: channel(dy)\ncomposition\n   nodeU(U,V,Hash,Qca,Key1,Key2,Ks1,SU,RU) \n/\\ nodeV(U,V,Hash,Qca,Key1,Key2,Ks1,SV,RV)\nend role\n\nrole environment ()\ndef=\nconst nodeU,nodeV: agent,\nqca: public_key,\nkey1,key2,ks1,key1i,key2i,ks1i: symmetric_key,\nidu,certu,lt,idca,e,nv,nu,certv,idv: text,\nh: hash_func,\nnodeU_nodeV_lt,nodeV_nodeU_lt,sub1,sub2: protocol_id\n\nintruder_knowledge={nodeU,nodeV,h,key1i,key2i,ks1i,qca}\n\ncomposition\nsession(nodeU,nodeV,h,qca,key1,key2,ks1)\n/\\session(nodeU,i,h,qca,key1i,key2i,ks1i)\n/\\session(i,nodeV,h,qca,key1i,key2i,ks1i)     \n\nend role\n\ngoal\nsecrecy_of sub1\nsecrecy_of sub2\nauthentication_on nodeU_nodeV_lt\nauthentication_on nodeV_nodeU_lt\nend goal\n\nenvironment ()"
    },
    {
        "file": "HLPSL-1/ISO2.hlpsl",
        "incomplete": "%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole ____(ROLE_1)____ (____(PARAM_0)____,____(PARAM_3)____    : ____(PARAM_2)____,\n                ____(PARAM_1)____    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : ____(VARIABLE_0)____,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = ____(STATE_0)____\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ ____(MESSAGE_4)____(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,____(EVENT_0)____,____(EVENT_1)____,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,____(PARAM_4)____    : ____(PARAM_6)____,\n                Pka,Pks: ____(PARAM_5)____,\n                Snd,Rec: channel(____(PARAM_7)____))\nplayed_by A\ndef=\n\n  local  State     : ____(VARIABLE_1)____,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ ____(MESSAGE_5)____(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,____(EVENT_3)____,____(EVENT_2)____,Ra')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (____(PARAM_8)____, A : ____(PARAM_10)____,\n\t      Pka  : public_key,\n              ____(PARAM_9)____  : public_key) def=\n\n  local SA, RA, ____(VARIABLE_3)____, RB: channel (____(VARIABLE_2)____)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : ____(VARIABLE_4)____,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()",
        "complete:": "%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso2_Init (B,A    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ Snd(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,A,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,B,ra,Ra')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (B, A : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()"
    },
    {
        "file": "HLPSL-1/ISO4.hlpsl",
        "incomplete": "%% PROTOCOL*: ISO4 Public Key Mutual Authentication Protocol\n%% VARIANT: three-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this protocol\n%% a confirmation of the successful authentication is sent by the initiator.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey, ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Nb, Text1\n%% 2. A -> B : PKa,A,{PKa,A}inv(PKs),Na,Nb,B,Text3,{Na,Nb,B,Text2}inv(PKa)\n%% 3. B -> A : PKb,B,{PKb,B}inv(PKs),Nb,Na,A,Text5,{Nb,Na,A,Text4}inv(PKb)\n%% \\end{verbatim}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!, and\\\\\n%% \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole ____(ROLE_0)____ ( A,____(PARAM_0)____: ____(PARAM_3)____,\n                 ____(PARAM_2)____,Pks: public_key, \n                 ____(PARAM_1)____,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State         : nat,\n         Pka           : public_key,\n         Nb            : text,\n         Na,Text2,Text3: text\n\n  const ctext1,ctext4,____(VARIABLE_0)____: ____(VARIABLE_1)____\n\n  init State := 0 \n\n%%%  knowledge(B)={A,B,Pkb,inv(Pkb),Pks,ctext1,ctext4,ctext5,{Pkb.B}_inv(Pks)}\n\n  transition\n\n   1. State = ____(STATE_0)____\n      /\\ Rec(start) \n      =|> \n      State' := 1\n      /\\ Nb' := new() \n      /\\ ____(MESSAGE_10)____(Nb'.ctext1) \n      /\\ witness(____(EVENT_1)____,____(EVENT_0)____,nb,Nb')\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.Nb.B.Text3'.\n             {Na'.Nb.B.Text2'}_inv(Pka'))\n      =|> \n      State' := 2\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(____(MESSAGE_11)____).Nb.Na'.A.ctext5.{Nb.Na'.A.ctext4}_inv(Pkb))\n%%%   /\\ witness(B,A,nb,Nb)\n      /\\ request(B,____(EVENT_4)____,na,____(EVENT_5)____)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole ____(ROLE_1)____ ( ____(PARAM_7)____,A: agent,\n                 ____(PARAM_6)____,Pks: public_key, \n                 ____(PARAM_5)____,Rec: channel(____(PARAM_4)____))\nplayed_by A\ndef=\n\n  local  State               : ____(VARIABLE_2)____,\n         Pkb                 : public_key,\n         Na                  : text,\n         Nb,Text1,Text4,Text5: text\n\n  const ____(VARIABLE_3)____,ctext3: text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,inv(Pka),Pks,ctext2,ctext3,{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = ____(STATE_1)____\n      /\\ Rec(Nb'.Text1') \n      =|>\n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(____(MESSAGE_12)____).\n             Na'.Nb'.B.ctext3.{Na'.Nb'.B.ctext2}_inv(Pka))\n      /\\ witness(____(EVENT_7)____,____(EVENT_6)____,na,Na')\n\n   2. State = 1\n      /\\ Rec(Pkb'.B.{Pkb'.B}_inv(Pks).\n             Nb.Na.A.Text5'.{Nb.Na.A.Text4'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ request(____(EVENT_8)____,B,nb,____(EVENT_9)____)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,____(PARAM_9)____:agent,\n\t      Pka,____(PARAM_8)____,Pks: ____(PARAM_10)____) def=       \n\n  local ____(VARIABLE_5)____,RA,SB,RB: channel (____(VARIABLE_4)____)\n\n  composition\n\n          iso4_Init(A,B,Pkb,Pks,SA,RA)\n       /\\ iso4_Resp(B,A,Pka,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n const ____(VARIABLE_6)____, nb             : protocol_id,\n       a, b, i            : agent,\n       pka, pkb, pks, pki : public_key\n\n intruder_knowledge={a,b,pki,inv(pki),pks,\n                     ctext1,ctext4,ctext5,{pki.i}_inv(pks),  %%% 2nd session\n                     ctext2,ctext3,{pki.i}_inv(pks)}         %%% 3rd session\n\n composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,i,pka,pki,pks)\n     /\\\tsession(i,b,pki,pkb,pks)\n%%%     /\\\tsession(b,a,pkb,pka,pks,sa4,ra4,sb4,rb4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO4_Resp authenticates ISO4_Init on nb\n   authentication_on nb % addressess G1 and G2\n\n   %ISO4_Init authenticates ISO4_Resp on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()",
        "complete:": "%% PROTOCOL*: ISO4 Public Key Mutual Authentication Protocol\n%% VARIANT: three-pass mutual authentication\n%% PURPOSE: Two parties authenticate each other. Aim of the Mutual authentication\n%% is to make sure to each of the parties of the other's identity. In this protocol\n%% a confirmation of the successful authentication is sent by the initiator.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey, ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER: \n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Nb, Text1\n%% 2. A -> B : PKa,A,{PKa,A}inv(PKs),Na,Nb,B,Text3,{Na,Nb,B,Text2}inv(PKa)\n%% 3. B -> A : PKb,B,{PKb,B}inv(PKs),Nb,Na,A,Text5,{Nb,Na,A,Text4}inv(PKb)\n%% \\end{verbatim}\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!, and\\\\\n%% \\verb!{PKb,B}inv(PKs)! is the certificate of agent \\verb!B!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso4_Init ( A,B: agent,\n                 Pkb,Pks: public_key, \n                 Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State         : nat,\n         Pka           : public_key,\n         Nb            : text,\n         Na,Text2,Text3: text\n\n  const ctext1,ctext4,ctext5: text\n\n  init State := 0 \n\n%%%  knowledge(B)={A,B,Pkb,inv(Pkb),Pks,ctext1,ctext4,ctext5,{Pkb.B}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start) \n      =|> \n      State' := 1\n      /\\ Nb' := new() \n      /\\ Snd(Nb'.ctext1) \n      /\\ witness(B,A,nb,Nb')\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Na'.Nb.B.Text3'.\n             {Na'.Nb.B.Text2'}_inv(Pka'))\n      =|> \n      State' := 2\n      /\\ Snd(Pkb.B.{Pkb.B}_inv(Pks).Nb.Na'.A.ctext5.{Nb.Na'.A.ctext4}_inv(Pkb))\n%%%   /\\ witness(B,A,nb,Nb)\n      /\\ request(B,A,na,Na')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso4_Resp ( B,A: agent,\n                 Pka,Pks: public_key, \n                 Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State               : nat,\n         Pkb                 : public_key,\n         Na                  : text,\n         Nb,Text1,Text4,Text5: text\n\n  const ctext2,ctext3: text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,inv(Pka),Pks,ctext2,ctext3,{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Nb'.Text1') \n      =|>\n      State' := 1\n      /\\ Na' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).\n             Na'.Nb'.B.ctext3.{Na'.Nb'.B.ctext2}_inv(Pka))\n      /\\ witness(A,B,na,Na')\n\n   2. State = 1\n      /\\ Rec(Pkb'.B.{Pkb'.B}_inv(Pks).\n             Nb.Na.A.Text5'.{Nb.Na.A.Text4'}_inv(Pkb'))\n      =|> \n      State' := 2\n      /\\ request(A,B,nb,Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (A,B:agent,\n\t      Pka,Pkb,Pks: public_key) def=       \n\n  local SA,RA,SB,RB: channel (dy)\n\n  composition\n\n          iso4_Init(A,B,Pkb,Pks,SA,RA)\n       /\\ iso4_Resp(B,A,Pka,Pks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n const na, nb             : protocol_id,\n       a, b, i            : agent,\n       pka, pkb, pks, pki : public_key\n\n intruder_knowledge={a,b,pki,inv(pki),pks,\n                     ctext1,ctext4,ctext5,{pki.i}_inv(pks),  %%% 2nd session\n                     ctext2,ctext3,{pki.i}_inv(pks)}         %%% 3rd session\n\n composition\n\n\tsession(a,b,pka,pkb,pks)\n     /\\\tsession(a,i,pka,pki,pks)\n     /\\\tsession(i,b,pki,pkb,pks)\n%%%     /\\\tsession(b,a,pkb,pka,pks,sa4,ra4,sb4,rb4)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO4_Resp authenticates ISO4_Init on nb\n   authentication_on nb % addressess G1 and G2\n\n   %ISO4_Init authenticates ISO4_Resp on na\n   authentication_on na % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Ju(2024)protocol.hlpsl",
        "incomplete": "____(ROLE_0)____ role_U(U:____(PARAM_1)____,____(PARAM_0)____:agent,D:agent,____(PARAM_2)____:(____(PARAM_3)____) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by U\ndef=\n\tlocal\n\t\t____(VARIABLE_13)____:nat,IDuj:____(VARIABLE_0)____,IDcsk:____(VARIABLE_1)____,PIDuj:____(VARIABLE_5)____,____(VARIABLE_9)____:____(VARIABLE_11)____,____(VARIABLE_2)____:____(VARIABLE_12)____,M3:text,____(VARIABLE_14)____:text,M2:text,____(VARIABLE_10)____:text,____(VARIABLE_7)____:text,____(VARIABLE_6)____:text,V3:text,____(VARIABLE_8)____:____(VARIABLE_3)____,Key_1:____(VARIABLE_4)____\n,RPWuj,PWuj,RR3,CERTuj,ECujj,RR4,PIDdri,TIDuj,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t\n\t\t%%% User registration\n\t\t2. State=____(STATE_1)____ /\\ RCV(start) =|> State':=1 \n\t\t/\\ RPWuj':=h(IDuj,PWuj) \n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_U_CS':=cons(Key_1',Key_set_U_CS) \n\t\t/\\ SND({IDuj}_Key_1')\n\n\n\t\t3. State=____(STATE_0)____ /\\ in(Key_3',Key_set_CS_U) \n\t\t/\\ RCV({PIDuj'.ECuj'.IDcsk}_Key_3') =|> State':=2 \n\t\t/\\ Key_set_CS_U':=delete(Key_3',Key_set_CS_U) \n\t\t/\\ RR3':=new()\n\t\t/\\ CERTuj':=xor(ECuj',h(RR3',PWuj))\n\t\t\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t/\\ ECujj':=xor(CERTuj',h(RR3',PWuj))\n\t\t/\\ RR4':=new()\n\t\t/\\ TS1':=new()\n\t\t/\\ M1':= xor(h(IDcsk,TS1'),PIDuj)\n\t\t/\\ M2':= xor(h(PIDuj',ECuj',TS1'),PIDdri)\n\t\t/\\ M3':= xor(h(PIDuj',IDcsk,ECuj',TS1'),TIDuj)\n\t\t/\\ V1':=h(PIDuj',PIDdri,ECuj',TS1')\n\t\t/\\ SND(M1'.M2'.M3'.V1'.TS1')\n\t\t/\\ secret(ECujj',____(EVENT_0)____,{U,____(EVENT_1)____}) \n\t\t/\\ witness(____(EVENT_3)____,____(EVENT_2)____,u_cs_TS1,TS1')\n\n\n\t\t6. State=2 /\\ RCV(M6'.V3'.TS3') =|> State':=3\n\t\t/\\ request(____(EVENT_5)____,____(EVENT_4)____,d_u_TS3,TS3')\n\t\t/\\ TIDdri':=xor(M6',h(TIDuj,PIDdri,TS3'))\n\t\t/\\ SK':= h(TIDuj,TIDdri,TS3')\nend ____(ROLE_1)____\n\n\n\n\n\n____(ROLE_2)____ role_CS(____(PARAM_4)____:____(PARAM_6)____,CS:agent,____(PARAM_5)____:agent,Key_set_CS_D:(____(PARAM_7)____) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by CS\ndef=\n\tlocal\n\t\tState:nat,RTSdri:____(VARIABLE_15)____,____(VARIABLE_22)____:____(VARIABLE_16)____,____(VARIABLE_17)____:____(VARIABLE_20)____,RR1:____(VARIABLE_23)____,IDuj:____(VARIABLE_24)____,____(VARIABLE_28)____:____(VARIABLE_25)____,PIDuj:____(VARIABLE_26)____,____(VARIABLE_30)____:____(VARIABLE_29)____,TS1:____(VARIABLE_32)____,____(VARIABLE_19)____:text,____(VARIABLE_34)____:text,M2:text,V1:text,____(VARIABLE_21)____:text,M4:text,____(VARIABLE_18)____:text,____(VARIABLE_27)____:symmetric_key,____(VARIABLE_31)____:symmetric_key,____(VARIABLE_33)____:symmetric_key,\nCCdri,PIDdri,ECdri,XXcsk,RR2,RTSuj,ECtuj,IDsck,TIDuj,CRdri,CRtdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=____(STATE_2)____ /\\ RCV(start) =|> State':=1 \n\t\t/\\ RR1':=new()\n\t\t/\\ CCdri':=new()\n\t\t/\\ RTSdri':=new()\n\t\t/\\ PIDdri':=h(IDdri,RTSdri')\n\t\t/\\ ECdri':=h(IDdri,XXcsk,RR1',RTSdri')\n\t\t/\\ secret(ECdri',sec_ECdri,{____(EVENT_7)____,____(EVENT_6)____}) \n\t\t/\\ ECtdri':=xor(ECdri',h(XXcsk,RTSdri'))\n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_CS_D':=cons(Key_1',Key_set_CS_D) \n\t\t/\\ SND({IDdri.CCdri'.ECdri'}_Key_1')\n\n\n\t\t%% Users registration\n\t\t2. State=____(STATE_3)____ /\\ in(Key_2',Key_set_U_CS) \n\t\t/\\ RCV({IDuj}_Key_2') =|> State':=2 \n\t\t/\\ Key_set_U_CS':=delete(Key_2',Key_set_U_CS) \t\t\t\n\t\t/\\ RR2':=new()\n\t\t/\\ PIDuj':=h(IDuj,RTSuj,XXcsk)\n\t\t/\\ ECuj':=h(PIDuj', RTSuj,RR2',XXcsk)\n\t\t/\\ secret(ECuj',sec_ECuj,{____(EVENT_8)____,____(EVENT_9)____}) \n\t\t/\\ ECtuj':=xor(ECuj,h(XXcsk,RTSuj))\n\t\t/\\ Key_3':=new() \n\t\t/\\ Key_set_CS_U':=cons(Key_3',Key_set_CS_U) \n\t\t/\\ SND({PIDuj'.ECuj'.IDcsk}_Key_3')\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t4. State=2 /\\ RCV(M1'.M2'.M3'.V1'.TS1') =|> State':=3 \n\t\t/\\ request(____(EVENT_11)____,U,u_cs_TS1,____(EVENT_10)____)\n\t\t/\\ PIDuj':=xor(M1',h(IDsck,TS1'))\n\t\t/\\ ECuj':=xor(ECtuj,h(XXcsk,RTSuj))\n\t\t/\\ PIDdri':=xor(M2',h(PIDuj',ECuj',TS1'))\n\t\t/\\ TIDuj':=xor(h(PIDuj',IDcsk,ECuj',TS1'),M3)\n\t\t/\\ CRdri':= xor(CRtdri,h(XXcsk,RTSdri))\n\t\t/\\ TS2':=new()\n\t\t/\\ M4':= xor(h(CRdri,PIDdri',TS2'),TIDuj)\n\t\t/\\ V2':=h(CRdri,PIDdri',TIDuj,TS2')\n\t\t/\\ SND(M4'.V2'.TS2')\n\t\t/\\ ____(EVENT_12)____(CRdri',sec_CRdri,{CS,____(EVENT_13)____}) \n\t\t/\\ witness(CS,D,____(EVENT_15)____,____(EVENT_14)____)\nend role\n\nrole role_D(U:____(PARAM_8)____,CS:____(PARAM_10)____,____(PARAM_11)____:agent,____(PARAM_9)____:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,____(VARIABLE_36)____:____(VARIABLE_37)____,ECtdri:____(VARIABLE_40)____,____(VARIABLE_45)____:____(VARIABLE_41)____,____(VARIABLE_38)____:____(VARIABLE_42)____,TS2:____(VARIABLE_44)____,M4:text,____(VARIABLE_39)____:text,____(VARIABLE_43)____:text,M6:text,V3:text,Key_1:____(VARIABLE_35)____,\nCCdri,ECdri,CRdri,CERTdri,TIDuj,PIDdri,RR5,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ in(Key_1',Key_set_CS_D) \n\t\t/\\ RCV({IDdri.CCdri'.ECdri'}_Key_1') =|> State':=1 \n\t\t/\\ Key_set_CS_D':=delete(Key_1',Key_set_CS_D)\n\t\t/\\ CRdri':=h(CCdri')\n\t\t/\\ CERTdri':=xor(ECdri',h(CRdri',IDdri))\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t5. State=1 /\\ RCV(M4'.V2'.TS2') =|> State':=2 \n\t\t/\\ ____(EVENT_16)____(____(EVENT_17)____,CS,cs_d_TS2,TS2')\n\t\t/\\ CRdri':= h(CCdri)\n\t\t/\\ TIDuj':=xor(M4',h(CRdri',PIDdri,TS2'))\n\t\t/\\ RR5':=new()\n\t\t/\\ TIDdri':= h(CRdri',RR5',TIDuj')\n\t\t/\\ TS3':=new()\n\t\t/\\ SK':= h(TIDuj',TIDdri,TS3')\n\t\t/\\ M6':=xor(h(TIDuj',PIDdri,TS3'), TIDdri')\n\t\t/\\ V3':=h(TIDuj',TIDdri',SK',PIDdri,TS3')\n\t\t/\\ SND(M6'.V3'.TS3')\n\t\t/\\ witness(____(EVENT_19)____,____(EVENT_18)____,d_u_TS3,TS3')\nend role\n\nrole session(U:____(PARAM_12)____,____(PARAM_15)____:____(PARAM_14)____,D:agent,Key_set_CS_U:(____(PARAM_13)____) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_D:(symmetric_key) set)\ndef=\n\tlocal\n\t\t____(VARIABLE_48)____,____(VARIABLE_47)____,SND2,RCV2,____(VARIABLE_46)____,RCV1:channel(dy)\n\tcomposition\n\t\trole_U(U,CS,D,Key_set_U_CS,Key_set_CS_U,SND1,RCV1)\n\t\t/\\ role_CS(U,CS,D,Key_set_CS_D,Key_set_U_CS,Key_set_CS_U,SND2,RCV2) \n\t\t/\\ role_D(U,CS,D,Key_set_CS_D,SND3,RCV3)  \nend role\n \nrole environment()\ndef=\n\tconst\n\t\t____(VARIABLE_49)____:____(VARIABLE_50)____,h:hash_func,drone:____(VARIABLE_51)____,____(VARIABLE_52)____:agent,\nsec_ECdri,sec_ECuj,sec_ECujj,sec_CRdri, u_cs_TS1,d_u_TS3,cs_d_TS2:protocol_id\n\tintruder_knowledge = {users,server,drone}\n\tcomposition\n\t\tsession(users,server,drone,{},{},{})\n\t\t/\\ session(users,server,drone,{},{},{})\n\t\t/\\ session(i,server,drone,{},{},{})\n\t\t/\\ session(users,i,drone,{},{},{})\n\t\t/\\ session(users,server,i,{},{},{})\nend role\n\ngoal\n\tsecrecy_of sec_ECdri % secrecy of Drone's ephemeral credential\n\tsecrecy_of sec_ECuj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_ECujj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_CRdri % secrecy of Drone's CRdri\n\tauthentication_on ____(GOAL_24)____\n\tauthentication_on ____(GOAL_25)____\n\tauthentication_on ____(GOAL_26)____\n\nend goal\n\nenvironment()",
        "complete:": "role role_U(U:agent,CS:agent,D:agent,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by U\ndef=\n\tlocal\n\t\tState:nat,IDuj:text,IDcsk:text,PIDuj:text,ECuj:text,TS1:text,M3:text,M1:text,M2:text,V1:text,TS3:text,M6:text,V3:text,Key_3:symmetric_key,Key_1:symmetric_key\n,RPWuj,PWuj,RR3,CERTuj,ECujj,RR4,PIDdri,TIDuj,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\t\t\n\t\t%%% User registration\n\t\t2. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RPWuj':=h(IDuj,PWuj) \n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_U_CS':=cons(Key_1',Key_set_U_CS) \n\t\t/\\ SND({IDuj}_Key_1')\n\n\n\t\t3. State=1 /\\ in(Key_3',Key_set_CS_U) \n\t\t/\\ RCV({PIDuj'.ECuj'.IDcsk}_Key_3') =|> State':=2 \n\t\t/\\ Key_set_CS_U':=delete(Key_3',Key_set_CS_U) \n\t\t/\\ RR3':=new()\n\t\t/\\ CERTuj':=xor(ECuj',h(RR3',PWuj))\n\t\t\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t/\\ ECujj':=xor(CERTuj',h(RR3',PWuj))\n\t\t/\\ RR4':=new()\n\t\t/\\ TS1':=new()\n\t\t/\\ M1':= xor(h(IDcsk,TS1'),PIDuj)\n\t\t/\\ M2':= xor(h(PIDuj',ECuj',TS1'),PIDdri)\n\t\t/\\ M3':= xor(h(PIDuj',IDcsk,ECuj',TS1'),TIDuj)\n\t\t/\\ V1':=h(PIDuj',PIDdri,ECuj',TS1')\n\t\t/\\ SND(M1'.M2'.M3'.V1'.TS1')\n\t\t/\\ secret(ECujj',sec_ECujj,{U,CS}) \n\t\t/\\ witness(U,CS,u_cs_TS1,TS1')\n\n\n\t\t6. State=2 /\\ RCV(M6'.V3'.TS3') =|> State':=3\n\t\t/\\ request(U,D,d_u_TS3,TS3')\n\t\t/\\ TIDdri':=xor(M6',h(TIDuj,PIDdri,TS3'))\n\t\t/\\ SK':= h(TIDuj,TIDdri,TS3')\nend role\n\n\n\n\n\nrole role_CS(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_U:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by CS\ndef=\n\tlocal\n\t\tState:nat,RTSdri:text,ECtdri:text,IDdri:text,RR1:text,IDuj:text,IDcsk:text,PIDuj:text,ECuj:text,TS1:text,M3:text,M1:text,M2:text,V1:text,TS2:text,M4:text,V2:text,Key_3:symmetric_key,Key_2:symmetric_key,Key_1:symmetric_key,\nCCdri,PIDdri,ECdri,XXcsk,RR2,RTSuj,ECtuj,IDsck,TIDuj,CRdri,CRtdri:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 \n\t\t/\\ RR1':=new()\n\t\t/\\ CCdri':=new()\n\t\t/\\ RTSdri':=new()\n\t\t/\\ PIDdri':=h(IDdri,RTSdri')\n\t\t/\\ ECdri':=h(IDdri,XXcsk,RR1',RTSdri')\n\t\t/\\ secret(ECdri',sec_ECdri,{CS,D}) \n\t\t/\\ ECtdri':=xor(ECdri',h(XXcsk,RTSdri'))\n\t\t/\\ Key_1':=new() \n\t\t/\\ Key_set_CS_D':=cons(Key_1',Key_set_CS_D) \n\t\t/\\ SND({IDdri.CCdri'.ECdri'}_Key_1')\n\n\n\t\t%% Users registration\n\t\t2. State=1 /\\ in(Key_2',Key_set_U_CS) \n\t\t/\\ RCV({IDuj}_Key_2') =|> State':=2 \n\t\t/\\ Key_set_U_CS':=delete(Key_2',Key_set_U_CS) \t\t\t\n\t\t/\\ RR2':=new()\n\t\t/\\ PIDuj':=h(IDuj,RTSuj,XXcsk)\n\t\t/\\ ECuj':=h(PIDuj', RTSuj,RR2',XXcsk)\n\t\t/\\ secret(ECuj',sec_ECuj,{CS,U}) \n\t\t/\\ ECtuj':=xor(ECuj,h(XXcsk,RTSuj))\n\t\t/\\ Key_3':=new() \n\t\t/\\ Key_set_CS_U':=cons(Key_3',Key_set_CS_U) \n\t\t/\\ SND({PIDuj'.ECuj'.IDcsk}_Key_3')\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t4. State=2 /\\ RCV(M1'.M2'.M3'.V1'.TS1') =|> State':=3 \n\t\t/\\ request(CS,U,u_cs_TS1,TS1')\n\t\t/\\ PIDuj':=xor(M1',h(IDsck,TS1'))\n\t\t/\\ ECuj':=xor(ECtuj,h(XXcsk,RTSuj))\n\t\t/\\ PIDdri':=xor(M2',h(PIDuj',ECuj',TS1'))\n\t\t/\\ TIDuj':=xor(h(PIDuj',IDcsk,ECuj',TS1'),M3)\n\t\t/\\ CRdri':= xor(CRtdri,h(XXcsk,RTSdri))\n\t\t/\\ TS2':=new()\n\t\t/\\ M4':= xor(h(CRdri,PIDdri',TS2'),TIDuj)\n\t\t/\\ V2':=h(CRdri,PIDdri',TIDuj,TS2')\n\t\t/\\ SND(M4'.V2'.TS2')\n\t\t/\\ secret(CRdri',sec_CRdri,{CS,D}) \n\t\t/\\ witness(CS,D,cs_d_TS2,TS2')\nend role\n\nrole role_D(U:agent,CS:agent,D:agent,Key_set_CS_D:(symmetric_key) set,SND,RCV:channel(dy))\nplayed_by D\ndef=\n\tlocal\n\t\tState:nat,RTSdri:text,ECtdri:text,IDdri:text,RR1:text,TS2:text,M4:text,V2:text,TS3:text,M6:text,V3:text,Key_1:symmetric_key,\nCCdri,ECdri,CRdri,CERTdri,TIDuj,PIDdri,RR5,TIDdri,SK:text\n\tinit\n\t\tState := 0\n\ttransition\n\n\t\t%% Drone registraion\n\t\t1. State=0 /\\ in(Key_1',Key_set_CS_D) \n\t\t/\\ RCV({IDdri.CCdri'.ECdri'}_Key_1') =|> State':=1 \n\t\t/\\ Key_set_CS_D':=delete(Key_1',Key_set_CS_D)\n\t\t/\\ CRdri':=h(CCdri')\n\t\t/\\ CERTdri':=xor(ECdri',h(CRdri',IDdri))\n\n\t\t%% Login and Authentication key Agreement phase\n\t\t5. State=1 /\\ RCV(M4'.V2'.TS2') =|> State':=2 \n\t\t/\\ request(D,CS,cs_d_TS2,TS2')\n\t\t/\\ CRdri':= h(CCdri)\n\t\t/\\ TIDuj':=xor(M4',h(CRdri',PIDdri,TS2'))\n\t\t/\\ RR5':=new()\n\t\t/\\ TIDdri':= h(CRdri',RR5',TIDuj')\n\t\t/\\ TS3':=new()\n\t\t/\\ SK':= h(TIDuj',TIDdri,TS3')\n\t\t/\\ M6':=xor(h(TIDuj',PIDdri,TS3'), TIDdri')\n\t\t/\\ V3':=h(TIDuj',TIDdri',SK',PIDdri,TS3')\n\t\t/\\ SND(M6'.V3'.TS3')\n\t\t/\\ witness(D,U,d_u_TS3,TS3')\nend role\n\nrole session(U:agent,CS:agent,D:agent,Key_set_CS_U:(symmetric_key) set,Key_set_U_CS:(symmetric_key) set,Key_set_CS_D:(symmetric_key) set)\ndef=\n\tlocal\n\t\tSND3,RCV3,SND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_U(U,CS,D,Key_set_U_CS,Key_set_CS_U,SND1,RCV1)\n\t\t/\\ role_CS(U,CS,D,Key_set_CS_D,Key_set_U_CS,Key_set_CS_U,SND2,RCV2) \n\t\t/\\ role_D(U,CS,D,Key_set_CS_D,SND3,RCV3)  \nend role\n \nrole environment()\ndef=\n\tconst\n\t\tusers:agent,h:hash_func,drone:agent,server:agent,\nsec_ECdri,sec_ECuj,sec_ECujj,sec_CRdri, u_cs_TS1,d_u_TS3,cs_d_TS2:protocol_id\n\tintruder_knowledge = {users,server,drone}\n\tcomposition\n\t\tsession(users,server,drone,{},{},{})\n\t\t/\\ session(users,server,drone,{},{},{})\n\t\t/\\ session(i,server,drone,{},{},{})\n\t\t/\\ session(users,i,drone,{},{},{})\n\t\t/\\ session(users,server,i,{},{},{})\nend role\n\ngoal\n\tsecrecy_of sec_ECdri % secrecy of Drone's ephemeral credential\n\tsecrecy_of sec_ECuj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_ECujj % secrecy of User's's ephemeral credential\n\tsecrecy_of sec_CRdri % secrecy of Drone's CRdri\n\tauthentication_on u_cs_TS1\n\tauthentication_on cs_d_TS2\n\tauthentication_on d_u_TS3\n\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Kerberos.hlpsl",
        "incomplete": "%% PROTOCOL: Kerberos Network Authentication Service (V5)\n%% VARIANT: basic (core)\n%% PURPOSE: Authentication, Authorisation, Key Exchange\n%%\n%% Kerberos is a distributed authentication service that allows a process\n%% (a client) running on behalf of a principal (a user) to prove its identity\n%% to a verifier (an application server, or just server) without sending data\n%% across the network that might allow an attacker or the verifier to\n%% subsequently impersonate the principal. Kerberos optionally provides\n%% integrity and confidentiality for data sent between the client and server.\n%% \n%% REFERENCE: \n%%\\begin{itemize}\n%%\\item \\url{http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt}\n%%\\end{itemize}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M\\\"odersheim, Computer Security Group,\n%%\tETH Z\\\"{u}rich, January 2004\n%%   \\item AVISPA team (since then)\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% C: Client\n%% A: Authentication Server\n%% G: Ticket Granting Server\n%% S: Server (that the client wants to talk to)\n%%\n%% K_AB: key shared or intended to be shared between A and B\n%%       Initially shared: K_CA, K_AG, K_GS\n%%       Established during protocol: K_CG, K_CS\n%%\n%% All things marked * are timestamp-related and will be simply replaced\n%% with fresh text. \n%% \n%% Macros:\n%% Ticket_1 := { C,G, K_CG, Tstart*, Texpire* }K_AG\n%% Ticket_2 := { C,S, K_CS, Tstart2*, Texpire2* }K_GS\n%%\n%% 1. C -> A : C,G,Lifetime_1*,N_1\n%% 2. A -> C : C, Ticket_1, { G, K_CG, Tstart*, Texpire*, N_1 }K_CA\n%%\n%% 3. C -> G : S,Lifetime_2*,N_2,Ticket_1, { C,T* }K_CG\n%% 4. G -> C : C, Ticket_2, { S, K_CS, Tstart2*, Texpire2*, N_2 }K_CG\n%%\n%% 5. C -> S : Ticket_2, { C, T2* }K_CS\n%% 6. S -> C : { T2* }K_CS\n%%\\end{verbatim}\n%%\n%% LIMITATIONS: \n%% \n%% Ticket Caching is not performed, so only weak authentication is provided.\n%% It is rumoured that implementations do not perform ticket caching.\n%%\n%% PROBLEMS: 8\n%% ATTACKS: None\n%% \n%% NOTES: \n%%\n%% Agents involved: Client,  Authentication Server (AS), Ticket Granting server \n%% (TGS),  Server where the client needs to authenticate (Server) \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\n% Authentication Server\nrole kerberos_A (A, ____(PARAM_2)____, G : ____(PARAM_1)____,\n                 Snd, ____(PARAM_0)____   : channel (dy),\n                 K_CA, K_AG : symmetric_key)\nplayed_by A\ndef=\n\n  local St              : nat,\n        K_CG            : symmetric_key,\n        N1, Lifetime_1  : text,\n        Tstart, Texpire : text\n\n  const ____(VARIABLE_0)____ : protocol_id,\n        sec_a_K_CG : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ ____(MESSAGE_32)____(C.G.Lifetime_1'.N1') =|> \n      St':= 1 /\\ Tstart' := new()\n              /\\ Texpire' := new()\n              /\\ K_CG' := new()\n              /\\ Snd(C.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.\n\t                {G.K_CG'.Tstart'.Texpire'.N1'}_K_CA) \n\t      /\\ witness(____(EVENT_1)____,____(EVENT_0)____,k_cg,K_CG')\n\t      /\\ ____(EVENT_3)____(____(EVENT_2)____,G,k_cg,K_CG')\n\t      /\\ ____(EVENT_5)____(____(EVENT_6)____,sec_a_K_CG,{A,C,____(EVENT_4)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Ticket Granting Server\nrole ____(ROLE_1)____ (G, ____(PARAM_6)____, S, C  : ____(PARAM_5)____,\n                 Snd, ____(PARAM_3)____    : channel (____(PARAM_4)____),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local ____(VARIABLE_1)____                                 : nat,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2 : text,\n        Tstart2, Texpire2                  : text\n\n  const ____(VARIABLE_3)____,____(VARIABLE_2)____ : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       ____(MESSAGE_33)____(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ ____(EVENT_8)____(G,S,k_cs,____(EVENT_7)____)\n\t      /\\ witness(G,____(EVENT_10)____,k_cs,____(EVENT_9)____)\n\t      /\\ secret(____(EVENT_12)____,____(EVENT_11)____,{____(EVENT_13)____,C,G})\n\t      /\\ secret(____(EVENT_14)____,sec_g_K_CS,{____(EVENT_16)____,C,____(EVENT_15)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : ____(PARAM_9)____,\n                 ____(PARAM_8)____, Rcv : channel (____(PARAM_7)____),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : ____(VARIABLE_4)____,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const ____(VARIABLE_6)____, ____(VARIABLE_5)____ : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ ____(MESSAGE_34)____({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  ____(MESSAGE_35)____({T2'}_K_CS')\n\t      /\\ ____(EVENT_17)____(S,C,____(EVENT_18)____,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',____(EVENT_20)____,{G,____(EVENT_19)____,____(EVENT_21)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (____(PARAM_12)____, A, ____(PARAM_11)____, S : agent,\n                 Snd, ____(PARAM_10)____   : channel (____(PARAM_13)____),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : ____(VARIABLE_7)____,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, ____(VARIABLE_9)____, k_cs, t2a, t2b : ____(VARIABLE_8)____,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ ____(MESSAGE_36)____(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ ____(MESSAGE_37)____(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ ____(MESSAGE_38)____(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ ____(MESSAGE_39)____(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,____(EVENT_22)____,____(EVENT_23)____,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ ____(EVENT_25)____(K_CG',sec_c_K_CG,{____(EVENT_24)____,____(EVENT_26)____,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{____(MESSAGE_40)____}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{____(MESSAGE_41)____}_K_CS') \n\t      /\\ ____(EVENT_28)____(C,S,t2b,____(EVENT_27)____)\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(____(EVENT_31)____,sec_c_K_CS,{G,____(EVENT_30)____,____(EVENT_29)____})\n\n   4. St = 3  /\\ ____(MESSAGE_42)____({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____( ____(PARAM_16)____, ____(PARAM_17)____, ____(PARAM_14)____, S                             : agent,\n\t      K_CA, K_AG, ____(PARAM_15)____                       : symmetric_key)\ndef=\n\n   local ____(VARIABLE_12)____, R_C, S_A, R_A, S_G, ____(VARIABLE_10)____, ____(VARIABLE_13)____, R_S : channel (____(VARIABLE_11)____)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_2)____() def=\n\n  const  c, ____(VARIABLE_16)____, ____(VARIABLE_15)____, s, ____(VARIABLE_14)____           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  ____(GOAL_43)____ sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on ____(GOAL_44)____\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on ____(GOAL_45)____\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on ____(GOAL_46)____\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on ____(GOAL_47)____\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  ____(GOAL_48)____ t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on ____(GOAL_49)____\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on ____(GOAL_50)____\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: Kerberos Network Authentication Service (V5)\n%% VARIANT: basic (core)\n%% PURPOSE: Authentication, Authorisation, Key Exchange\n%%\n%% Kerberos is a distributed authentication service that allows a process\n%% (a client) running on behalf of a principal (a user) to prove its identity\n%% to a verifier (an application server, or just server) without sending data\n%% across the network that might allow an attacker or the verifier to\n%% subsequently impersonate the principal. Kerberos optionally provides\n%% integrity and confidentiality for data sent between the client and server.\n%% \n%% REFERENCE: \n%%\\begin{itemize}\n%%\\item \\url{http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt}\n%%\\end{itemize}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M\\\"odersheim, Computer Security Group,\n%%\tETH Z\\\"{u}rich, January 2004\n%%   \\item AVISPA team (since then)\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% C: Client\n%% A: Authentication Server\n%% G: Ticket Granting Server\n%% S: Server (that the client wants to talk to)\n%%\n%% K_AB: key shared or intended to be shared between A and B\n%%       Initially shared: K_CA, K_AG, K_GS\n%%       Established during protocol: K_CG, K_CS\n%%\n%% All things marked * are timestamp-related and will be simply replaced\n%% with fresh text. \n%% \n%% Macros:\n%% Ticket_1 := { C,G, K_CG, Tstart*, Texpire* }K_AG\n%% Ticket_2 := { C,S, K_CS, Tstart2*, Texpire2* }K_GS\n%%\n%% 1. C -> A : C,G,Lifetime_1*,N_1\n%% 2. A -> C : C, Ticket_1, { G, K_CG, Tstart*, Texpire*, N_1 }K_CA\n%%\n%% 3. C -> G : S,Lifetime_2*,N_2,Ticket_1, { C,T* }K_CG\n%% 4. G -> C : C, Ticket_2, { S, K_CS, Tstart2*, Texpire2*, N_2 }K_CG\n%%\n%% 5. C -> S : Ticket_2, { C, T2* }K_CS\n%% 6. S -> C : { T2* }K_CS\n%%\\end{verbatim}\n%%\n%% LIMITATIONS: \n%% \n%% Ticket Caching is not performed, so only weak authentication is provided.\n%% It is rumoured that implementations do not perform ticket caching.\n%%\n%% PROBLEMS: 8\n%% ATTACKS: None\n%% \n%% NOTES: \n%%\n%% Agents involved: Client,  Authentication Server (AS), Ticket Granting server \n%% (TGS),  Server where the client needs to authenticate (Server) \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\n% Authentication Server\nrole kerberos_A (A, C, G : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA, K_AG : symmetric_key)\nplayed_by A\ndef=\n\n  local St              : nat,\n        K_CG            : symmetric_key,\n        N1, Lifetime_1  : text,\n        Tstart, Texpire : text\n\n  const k_cg : protocol_id,\n        sec_a_K_CG : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(C.G.Lifetime_1'.N1') =|> \n      St':= 1 /\\ Tstart' := new()\n              /\\ Texpire' := new()\n              /\\ K_CG' := new()\n              /\\ Snd(C.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.\n\t                {G.K_CG'.Tstart'.Texpire'.N1'}_K_CA) \n\t      /\\ witness(A,C,k_cg,K_CG')\n\t      /\\ witness(A,G,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_a_K_CG,{A,C,G})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Ticket Granting Server\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local St                                 : nat,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2 : text,\n        Tstart2, Texpire2                  : text\n\n  const t1,k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 Snd, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2a, t2b : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2a,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2a\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/KEY_EXCHANGE.hlpsl",
        "incomplete": "%% key exchange\n\n____(ROLE_1)____ ____(ROLE_0)____(SM:____(PARAM_0)____,DS:____(PARAM_3)____,Sigmau:____(PARAM_4)____,PKs:____(PARAM_1)____,H:____(PARAM_2)____,____(PARAM_5)____,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\t____(VARIABLE_0)____:nat,\n\t\tIDu,Cu,Aa,Bu,T1:text,\n\t\tI1,S1:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=____(STATE_0)____ /\\ RCV(start) =|> State':=1 /\\ S1' := H(IDu.Aa.Cu) /\\ I1' := xor(IDu,(xor(H(Aa),Aa))) /\\ SND({Bu.Aa.S1'.Cu}_PKs,I1',T1)\nend role\n\nrole role_DS(____(PARAM_7)____:____(PARAM_6)____,DS:agent,Sigmau:____(PARAM_10)____,____(PARAM_8)____:____(PARAM_9)____,H:hash_func,SND,____(PARAM_11)____:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tSKs:symmetric_key,\n\t\tAa,Bu,Cu,IDu,IDs,Bb,Gg,T1,T3,Xi,Cs:text,\n\t\tI1,S1,Xi1,Eta:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Bu.Aa.S1'.Cu}_PKs,I1',T1) =|> State':=1 /\\ SKs' := new() /\\ Xi1' := xor(Xi,H(Cu.IDu.Sigmau)) /\\ Eta' := xor(IDs,H(Bb.Cs.Cu)) /\\ SND({Eta'.Xi1'.Cs.Bb}_Sigmau,T3) /\\ secret(____(EVENT_1)____,____(EVENT_0)____,{SM,DS}) /\\ witness(DS,SM,____(EVENT_3)____,____(EVENT_2)____)\nend role\n\nrole session(____(PARAM_12)____:____(PARAM_16)____,DS:agent,Sigmau,____(PARAM_14)____:symmetric_key,PKs:____(PARAM_13)____,H:____(PARAM_15)____)\ndef=\n\tlocal\n\t\tSND2,RCV2,____(VARIABLE_1)____,____(VARIABLE_2)____:channel(dy)\n\tcomposition\n                role_SM(SM,DS,Sigmau,PKs,H,SND1,RCV1) /\\\n\t\trole_DS(DS,SM,Sigmau,PKs,H,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tpks,pki:____(VARIABLE_3)____,\n\t\tsigmau,sigmai,sks:symmetric_key,\n\t\th:hash_func,\n                smart_meter,distributed_server:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {smart_meter,distributed_server,sks}    %% ... and we give it to the intruder\n\tcomposition\n                  %% We run the regular session\n\t\tsession(smart_meter,distributed_server,sigmau,sks,pks,h) \n                  %% in parallel with another regular session\n                /\\ session(distributed_server,smart_meter,sigmau,sks,pks,h) \n\n                  %% and a session between the intruder (with key kit) and bob\n                /\\ session(i,distributed_server,sigmai,sks,pks,h) \n                  %% and a session between alice and the intruder (with key kit)\n                /\\ session(smart_meter,i,sigmau,sks,pki,h) \nend role\n\ngoal\n    secrecy_of ____(GOAL_4)____\n\t____(GOAL_5)____ auth_1\nend goal\n\nenvironment()",
        "complete:": "%% key exchange\n\nrole role_SM(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tIDu,Cu,Aa,Bu,T1:text,\n\t\tI1,S1:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|> State':=1 /\\ S1' := H(IDu.Aa.Cu) /\\ I1' := xor(IDu,(xor(H(Aa),Aa))) /\\ SND({Bu.Aa.S1'.Cu}_PKs,I1',T1)\nend role\n\nrole role_DS(SM:agent,DS:agent,Sigmau:symmetric_key,PKs:public_key,H:hash_func,SND,RCV:channel(dy))\nplayed_by SM\ndef=\n\tlocal\n\t\tState:nat,\n\t\tSKs:symmetric_key,\n\t\tAa,Bu,Cu,IDu,IDs,Bb,Gg,T1,T3,Xi,Cs:text,\n\t\tI1,S1,Xi1,Eta:message\n\t\t\n\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV({Bu.Aa.S1'.Cu}_PKs,I1',T1) =|> State':=1 /\\ SKs' := new() /\\ Xi1' := xor(Xi,H(Cu.IDu.Sigmau)) /\\ Eta' := xor(IDs,H(Bb.Cs.Cu)) /\\ SND({Eta'.Xi1'.Cs.Bb}_Sigmau,T3) /\\ secret(SKs',sec_1,{SM,DS}) /\\ witness(DS,SM,auth_1,SKs')\nend role\n\nrole session(SM:agent,DS:agent,Sigmau,SKs:symmetric_key,PKs:public_key,H:hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n                role_SM(SM,DS,Sigmau,PKs,H,SND1,RCV1) /\\\n\t\trole_DS(DS,SM,Sigmau,PKs,H,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tpks,pki:public_key,\n\t\tsigmau,sigmai,sks:symmetric_key,\n\t\th:hash_func,\n                smart_meter,distributed_server:agent,        \n                sec_1,auth_1:protocol_id\n\tintruder_knowledge = {smart_meter,distributed_server,sks}    %% ... and we give it to the intruder\n\tcomposition\n                  %% We run the regular session\n\t\tsession(smart_meter,distributed_server,sigmau,sks,pks,h) \n                  %% in parallel with another regular session\n                /\\ session(distributed_server,smart_meter,sigmau,sks,pks,h) \n\n                  %% and a session between the intruder (with key kit) and bob\n                /\\ session(i,distributed_server,sigmai,sks,pks,h) \n                  %% and a session between alice and the intruder (with key kit)\n                /\\ session(smart_meter,i,sigmau,sks,pki,h) \nend role\n\ngoal\n    secrecy_of sec_1\n\tauthentication_on auth_1\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/L-3.hlpsl",
        "incomplete": "role alice ( \n\t____(PARAM_6)____,B:____(PARAM_11)____,\n\tYa,Yb:public_key,\n\t____(PARAM_2)____:____(PARAM_0)____,\n\t____(PARAM_13)____,M1,Q1:____(PARAM_14)____,\n\t____(PARAM_7)____,M2,____(PARAM_10)____:nat,\n\t____(PARAM_3)____,____(PARAM_12)____:text,\n\t____(PARAM_8)____,____(PARAM_1)____,CERT,MUL,PI,____(PARAM_9)____,HIG,MAC: ____(PARAM_4)____,\n\tSND,RCV:channel(____(PARAM_5)____)\n\t)\nplayed_by A def=\nlocal \n\tIb,K_a,K_b:____(VARIABLE_0)____, \n\tKa,Kb,CertificateB,Qba,Rba,Tba,TagB,TagA,Kba,Mba,CertificateA,H4:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = ____(STATE_0)____ /\\ RCV(start)\n=|> State' := 1 /\\ \nK_a' := new() /\\\nKa' := MUL(K_a'.P2) /\\\nCertificateA' := CERT(Ia.Ya) /\\\nSND(Ia.CertificateA'.Ka') /\\ ____(EVENT_1)____(____(EVENT_0)____,B,ss1,Ia.CertificateA'.Ka')\n\n\n2. State = 1 /\\ RCV(Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib'))) \n/\\ CertificateB' = CERT(Ib.Yb) \n=|>\nState' := 2 /\\\nQba' := MUL(M1.Q1.inv(Ya).Kb') /\\\nRba' := MUL(M2.Q2.K_a.Yb) /\\\nTba' := KDF(PI(Qba').PI(Rba').Ia.Ib') /\\\nKba' := LOW(Tba') /\\\nMba' := HIG(Tba') /\\\nTagA' := {MAC(H3.PI(Ka).PI(Kb').Ia.Ib')}_Mba' /\\\nSND(TagA') \n/\\ secret(____(EVENT_2)____,____(EVENT_3)____,A)\n/\\ ____(EVENT_5)____(A,B,ss2,Ib'.CertificateB'.____(EVENT_4)____.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib')))\n/\\ witness(____(EVENT_6)____,____(EVENT_7)____,ss3,TagA')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\t____(PARAM_15)____,B:____(PARAM_26)____,\n\t____(PARAM_18)____,____(PARAM_29)____:public_key,\n\tIb:____(PARAM_20)____,\n\tP1,M1,____(PARAM_24)____:____(PARAM_21)____,\n\tP2,M2,Q2:nat,\n\tH2,____(PARAM_19)____:____(PARAM_17)____,\n\tSign,____(PARAM_23)____,CERT,____(PARAM_25)____,PI,____(PARAM_28)____,____(PARAM_27)____,MAC:hash_func,\n\t____(PARAM_16)____,____(PARAM_22)____:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tIa:____(VARIABLE_1)____,\n\tK_b,K_a:nat,\n\tKa,Kb,Qab,Rab,Tab,Kab,Mab,TagA,TagB,CertificateB,CertificateA:message,\n\tState:nat\ninit State := 10\ntransition\n\n10. State =____(STATE_1)____ /\\ RCV(Ia'.CertificateA'.Ka') /\\ CertificateA' = CERT(Ia.Ya)\n=|> State' := 20 /\\ \nK_b' := new() /\\\nKb' := MUL(K_b'.P1) /\\\nQab' := MUL(M1.Q1.K_b.Ya) /\\\nRab' := MUL(M2.Q2.inv(Yb).Ka') /\\\nTab' := KDF(PI(Qab').PI(Rab').Ia'.Ib) /\\\nKab' := LOW(Tab') /\\\nMab' := HIG(Tab') /\\\nTagB' := {MAC(H2.PI(Kb').PI(Ka').Ib.Ia')}_Mab' /\\\nCertificateB' := CERT(Ib.Yb) /\\\nSND(Ib.CertificateB'.Kb'.TagB') \n/\\ ____(EVENT_8)____(Kab,____(EVENT_9)____,B) \n/\\ request(B,____(EVENT_10)____,ss1,____(EVENT_11)____)\n/\\ ____(EVENT_12)____(____(EVENT_13)____,A,ss2,Ib.CertificateB'.Kb'.TagB')\n\n\n\n20. State = 20 /\\ RCV({MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n=|>\nState' := 40 /\\ Ka' := new() /\\ SND(Ka') /\\ request(____(EVENT_15)____,A,ss3,{MAC(H3.PI(____(EVENT_14)____).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n\n% End\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (____(PARAM_43)____,B:agent,Ya,Yb:public_key,____(PARAM_36)____,____(PARAM_40)____:____(PARAM_30)____,____(PARAM_35)____,M1,Q1,P2,M2,____(PARAM_41)____:nat,H2,____(PARAM_33)____:____(PARAM_38)____,____(PARAM_42)____,KDF,____(PARAM_32)____,____(PARAM_39)____,PI,LOW,____(PARAM_31)____,____(PARAM_34)____:____(PARAM_37)____ )\ndef=\nlocal SA,SB,____(VARIABLE_2)____,____(VARIABLE_3)____ : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Ia,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SA,RA) \n/\\ bob(A,B,Ya,Yb,Ib,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____()\ndef=\n\nconst a,____(VARIABLE_4)____:____(VARIABLE_5)____,\nss1,ss2,ss3,secka,seckb: protocol_id,\nya,yb:public_key,\nia,ib:nat,\np1,m1,q1:nat,\np2,m2,q2:nat,\nh2,h3:text,\nsign:hash_func,\nkdf:hash_func,\ncert:hash_func,\nmul:hash_func,\npi:hash_func,\nlow:hash_func,\nhig:hash_func,\nmac:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,cert,mul,pi,low,hig,mac,p1,m1,q1,p2,m2,q2,h2,h3}\n\ncomposition\n\nsession(a,b,ya,yb,ia,ib,p1,m1,q1,p2,m2,q2,h2,h3,sign,kdf,cert,mul,pi,low,hig,mac)\n\nend role\n\n____(ROLE_0)____\n\tauthentication_on ____(GOAL_16)____\n\t____(GOAL_17)____ ss2\n\t____(GOAL_18)____ ss3\n\tsecrecy_of ____(GOAL_19)____\n\tsecrecy_of ____(GOAL_20)____\nend goal\n\nenvironment()",
        "complete:": "role alice ( \n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIa:nat,\n\tP1,M1,Q1:nat,\n\tP2,M2,Q2:nat,\n\tH2,H3:text,\n\tSign,KDF,CERT,MUL,PI,LOW,HIG,MAC: hash_func,\n\tSND,RCV:channel(dy)\n\t)\nplayed_by A def=\nlocal \n\tIb,K_a,K_b:nat, \n\tKa,Kb,CertificateB,Qba,Rba,Tba,TagB,TagA,Kba,Mba,CertificateA,H4:message,\n\tState : nat\ninit State := 0\ntransition\n\n1. State = 0 /\\ RCV(start)\n=|> State' := 1 /\\ \nK_a' := new() /\\\nKa' := MUL(K_a'.P2) /\\\nCertificateA' := CERT(Ia.Ya) /\\\nSND(Ia.CertificateA'.Ka') /\\ witness(A,B,ss1,Ia.CertificateA'.Ka')\n\n\n2. State = 1 /\\ RCV(Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib'))) \n/\\ CertificateB' = CERT(Ib.Yb) \n=|>\nState' := 2 /\\\nQba' := MUL(M1.Q1.inv(Ya).Kb') /\\\nRba' := MUL(M2.Q2.K_a.Yb) /\\\nTba' := KDF(PI(Qba').PI(Rba').Ia.Ib') /\\\nKba' := LOW(Tba') /\\\nMba' := HIG(Tba') /\\\nTagA' := {MAC(H3.PI(Ka).PI(Kb').Ia.Ib')}_Mba' /\\\nSND(TagA') \n/\\ secret(Kba,secka,A)\n/\\ request(A,B,ss2,Ib'.CertificateB'.Kb'.{MAC(H2.PI(Kb').PI(Ka).Ib'.Ia)}_HIG(KDF(PI(MUL(M1.Q1.K_b'.Ya)).PI(MUL(M2.Q2.inv(Yb).Ka)).Ia.Ib')))\n/\\ witness(A,B,ss3,TagA')\n\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob (\n\tA,B:agent,\n\tYa,Yb:public_key,\n\tIb:nat,\n\tP1,M1,Q1:nat,\n\tP2,M2,Q2:nat,\n\tH2,H3:text,\n\tSign,KDF,CERT,MUL,PI,LOW,HIG,MAC:hash_func,\n\tSND,RCV:channel(dy)\n\t)\t\nplayed_by B def=\nlocal\n\tIa:nat,\n\tK_b,K_a:nat,\n\tKa,Kb,Qab,Rab,Tab,Kab,Mab,TagA,TagB,CertificateB,CertificateA:message,\n\tState:nat\ninit State := 10\ntransition\n\n10. State =10 /\\ RCV(Ia'.CertificateA'.Ka') /\\ CertificateA' = CERT(Ia.Ya)\n=|> State' := 20 /\\ \nK_b' := new() /\\\nKb' := MUL(K_b'.P1) /\\\nQab' := MUL(M1.Q1.K_b.Ya) /\\\nRab' := MUL(M2.Q2.inv(Yb).Ka') /\\\nTab' := KDF(PI(Qab').PI(Rab').Ia'.Ib) /\\\nKab' := LOW(Tab') /\\\nMab' := HIG(Tab') /\\\nTagB' := {MAC(H2.PI(Kb').PI(Ka').Ib.Ia')}_Mab' /\\\nCertificateB' := CERT(Ib.Yb) /\\\nSND(Ib.CertificateB'.Kb'.TagB') \n/\\ secret(Kab,seckb,B) \n/\\ request(B,A,ss1,Ia'.CertificateA'.Ka')\n/\\ witness(B,A,ss2,Ib.CertificateB'.Kb'.TagB')\n\n\n\n20. State = 20 /\\ RCV({MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n=|>\nState' := 40 /\\ Ka' := new() /\\ SND(Ka') /\\ request(B,A,ss3,{MAC(H3.PI(Ka).PI(Kb).Ia.Ib)}_HIG(KDF(PI(MUL(M1.Q1.inv(Ya).Kb)).PI(MUL(M2.Q2.K_a'.Yb)).Ia.Ib)))\n\n% End\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B:agent,Ya,Yb:public_key,Ia,Ib:nat,P1,M1,Q1,P2,M2,Q2:nat,H2,H3:text,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC:hash_func )\ndef=\nlocal SA,SB,RA,RB : channel (dy)\n\ncomposition\n\nalice(A,B,Ya,Yb,Ia,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SA,RA) \n/\\ bob(A,B,Ya,Yb,Ib,P1,M1,Q1,P2,M2,Q2,H2,H3,Sign,KDF,CERT,MUL,PI,LOW,HIG,MAC,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\nconst a,b:agent,\nss1,ss2,ss3,secka,seckb: protocol_id,\nya,yb:public_key,\nia,ib:nat,\np1,m1,q1:nat,\np2,m2,q2:nat,\nh2,h3:text,\nsign:hash_func,\nkdf:hash_func,\ncert:hash_func,\nmul:hash_func,\npi:hash_func,\nlow:hash_func,\nhig:hash_func,\nmac:hash_func\n\nintruder_knowledge = {a,b,ya,yb,sign,kdf,cert,mul,pi,low,hig,mac,p1,m1,q1,p2,m2,q2,h2,h3}\n\ncomposition\n\nsession(a,b,ya,yb,ia,ib,p1,m1,q1,p2,m2,q2,h2,h3,sign,kdf,cert,mul,pi,low,hig,mac)\n\nend role\n\ngoal\n\tauthentication_on ss1\n\tauthentication_on ss2\n\tauthentication_on ss3\n\tsecrecy_of seckb\n\tsecrecy_of secka\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/lipkey-spkm-known-initiator.hlpsl",
        "incomplete": "%% PROTOCOL: SPKM-LIPKEY\n%% VARIANT: Known initiator\n%% PURPOSE:\n%% Provide a secure channel between a client and server,\n%% authenticating the client with a password, and a server with a public key\n%% certificate.\n%%\n%% REFERENCE: \\cite{RFC2847,RFC2025}\n%% MODELER: \n%% \\begin{itemize}\n%%  \\item Boichut Yohan, LIFC-INRIA Besancon, May 2004 \n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, January 2005\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%%   \\verb!1. A -> S:  A.S.Na.exp(G,X).{A.S.Na.exp(G,X)}_inv(Ka)!\\\\\n%%   \\verb!2. S -> A:  A.S.Na.Nb.exp(G,Y).{A.S.Na.Nb.exp(G,Y)}_inv(Ks)!\\\\\n%%   \\verb!3. A -> S: {login.pwd}_K where K= exp(exp(G,Y),X) = exp(exp(G,X),Y)!\\\\\n%%\n%% LIMITATIONS:\n%%\n%% In reality, the messages 1 and 2 contain respectively the two following items lists.\n%% \\begin{itemize}\n%%\t\\item the initiator and target names,\n%%      \\item a fresh random number,\n%%      \\item a list of available confidentiality algorithms,\n%%      \\item a list of available integrity algorithms,\n%%      \\item a list of available key establishment algorithms,\n%%      \\item a context key (or half key) corresponding to the first key establishment algorithm given in the previous list,\n%%      \\item GSS context options/choices (such as unilateral or mutual authentication, use of sequencing and replay detection, and so on).\n%% \\end{itemize}\n%%      \n%% and\n%% \\begin{itemize}\n%%\t\\item the initiator and target names,\n%%      \\item the random number sent by the initiator,\n%%      \\item a fresh random number,\n%%      \\item the subset of offered confidentiality algorithms which are supported by the target,\n%%      \\item the subset of offered integrity algorithms which are supported by the target,\n%%\t\\item an alternative key establishment algorithm (chosen from the offered list) if the first one offered is unsuitable,\n%%      \\item the half key corresponding to the initiator's key establishment algorithm (if necessary), or a context key (or half key) corresponding to the \n%%\tkey establishment algorithm above,\n%%      \\item GSS context options/choices (such as unilateral or mutual authentication, use of sequencing and replay detection, and so on).\n%% \\end{itemize}\n%%\n%%\n%% The sets of algorithms agreed are not used by LIPKEY, indeed LIPKEY only uses SPKM\n%% for key establishment. Thus they are not modelled. Furthermore, the key\n%% establishment modelled is \\`a la Diffie-Hellman and GSS context options are not modelled.\n%%\n%% PROBLEMS: 6\n%% CLASSIFICATION: G1, G2, G3, G7, G10\n%% ATTACKS: None\n%%\n%% NOTES: \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole initiator (\n        ____(PARAM_5)____: ____(PARAM_6)____,\n\t____(PARAM_0)____: agent,             \n        ____(PARAM_3)____: nat,\n\tH: hash_func,\n\t____(PARAM_1)____: ____(PARAM_4)____,\n\tKs: public_key,\n\t____(PARAM_2)____: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : ____(VARIABLE_1)____,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const ____(VARIABLE_2)____, sec_i_Pwd: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = ____(STATE_0)____ /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = ____(STATE_1)____ /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ ____(EVENT_1)____(Login_A_S,sec_i_Log,{____(EVENT_0)____}) \n\t      \t /\\ ____(EVENT_3)____(Pwd_A_S,  sec_i_Pwd,{____(EVENT_2)____})  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,____(EVENT_4)____,ktrgtint,____(EVENT_5)____) \n\t         /\\ ____(EVENT_7)____(A,S,k,____(EVENT_6)____) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,____(PARAM_12)____           : agent,      \n\tG             : ____(PARAM_7)____,\n\tH             : ____(PARAM_13)____,\n\t____(PARAM_9)____,____(PARAM_10)____         : ____(PARAM_11)____,\n\t____(PARAM_14)____, Pwd    : hash_func,\n        ____(PARAM_8)____, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : ____(VARIABLE_3)____,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: ____(VARIABLE_4)____\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ ____(EVENT_8)____(Login(A.S),sec_t_Log,{A}) \n\t        /\\ secret(Pwd(____(EVENT_9)____),  sec_t_Pwd,{A}) \n\t\t/\\ ____(EVENT_10)____(S,A,____(EVENT_11)____,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ ____(EVENT_12)____(S,A,____(EVENT_13)____,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_0)____(\n\t  A,S : agent,\n\t  Login, ____(PARAM_15)____: ____(PARAM_18)____,\n\t  Ka: ____(PARAM_17)____,\n          ____(PARAM_21)____: ____(PARAM_20)____,\n\t  ____(PARAM_19)____: hash_func,\n\t  ____(PARAM_16)____: nat)\ndef=  \n\n  local   SndI, ____(VARIABLE_5)____,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const ____(VARIABLE_6)____,s,i,b: ____(VARIABLE_7)____,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k % addresses G1, G2, G3\n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint % addresses G1, G2, G3\n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, % adresses G7, G10\n             sec_t_Log, sec_t_Pwd  % adresses G7, G10\n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL: SPKM-LIPKEY\n%% VARIANT: Known initiator\n%% PURPOSE:\n%% Provide a secure channel between a client and server,\n%% authenticating the client with a password, and a server with a public key\n%% certificate.\n%%\n%% REFERENCE: \\cite{RFC2847,RFC2025}\n%% MODELER: \n%% \\begin{itemize}\n%%  \\item Boichut Yohan, LIFC-INRIA Besancon, May 2004 \n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, January 2005\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%%   \\verb!1. A -> S:  A.S.Na.exp(G,X).{A.S.Na.exp(G,X)}_inv(Ka)!\\\\\n%%   \\verb!2. S -> A:  A.S.Na.Nb.exp(G,Y).{A.S.Na.Nb.exp(G,Y)}_inv(Ks)!\\\\\n%%   \\verb!3. A -> S: {login.pwd}_K where K= exp(exp(G,Y),X) = exp(exp(G,X),Y)!\\\\\n%%\n%% LIMITATIONS:\n%%\n%% In reality, the messages 1 and 2 contain respectively the two following items lists.\n%% \\begin{itemize}\n%%\t\\item the initiator and target names,\n%%      \\item a fresh random number,\n%%      \\item a list of available confidentiality algorithms,\n%%      \\item a list of available integrity algorithms,\n%%      \\item a list of available key establishment algorithms,\n%%      \\item a context key (or half key) corresponding to the first key establishment algorithm given in the previous list,\n%%      \\item GSS context options/choices (such as unilateral or mutual authentication, use of sequencing and replay detection, and so on).\n%% \\end{itemize}\n%%      \n%% and\n%% \\begin{itemize}\n%%\t\\item the initiator and target names,\n%%      \\item the random number sent by the initiator,\n%%      \\item a fresh random number,\n%%      \\item the subset of offered confidentiality algorithms which are supported by the target,\n%%      \\item the subset of offered integrity algorithms which are supported by the target,\n%%\t\\item an alternative key establishment algorithm (chosen from the offered list) if the first one offered is unsuitable,\n%%      \\item the half key corresponding to the initiator's key establishment algorithm (if necessary), or a context key (or half key) corresponding to the \n%%\tkey establishment algorithm above,\n%%      \\item GSS context options/choices (such as unilateral or mutual authentication, use of sequencing and replay detection, and so on).\n%% \\end{itemize}\n%%\n%%\n%% The sets of algorithms agreed are not used by LIPKEY, indeed LIPKEY only uses SPKM\n%% for key establishment. Thus they are not modelled. Furthermore, the key\n%% establishment modelled is \\`a la Diffie-Hellman and GSS context options are not modelled.\n%%\n%% PROBLEMS: 6\n%% CLASSIFICATION: G1, G2, G3, G7, G10\n%% ATTACKS: None\n%%\n%% NOTES: \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\n\nrole initiator (\n        A: agent,\n\tS: agent,             \n        G: nat,\n\tH: hash_func,\n\tKa: public_key,\n\tKs: public_key,\n\tLogin_A_S: hash(agent.agent), \n\tPwd_A_S: hash(agent.agent), \n\t\t\t    \n        SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n  local \n\tState        : nat,\n        Na,Nb        : text,\n        Rnumber1     : text,\n        X            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_i_Log, sec_i_Pwd: protocol_id\n\n  init  State := 0\n\n  transition     \n\n  1.  State  = 0 /\\ RCV(start) =|>\n      State':= 1 /\\ Na' := new()\n                 /\\ Rnumber1' := new()\n                 /\\ SND(A.S.Na'.exp(G,Rnumber1').\n\t               {A.S.Na'.exp(G,Rnumber1')}_inv(Ka))\n\n  2.  State  = 1 /\\ RCV(A.S.Na.Nb'.X'.{A.S.Na.Nb'.X'}_inv(Ks)) =|>\n      State':= 2 /\\ Keycompleted' := exp(X',Rnumber1)\n\t         /\\ SND({Login_A_S.Pwd_A_S}_Keycompleted' ) \n         \t /\\ secret(Login_A_S,sec_i_Log,{S}) \n\t      \t /\\ secret(Pwd_A_S,  sec_i_Pwd,{S})  \n\t         /\\ K' := Login_A_S.Pwd_A_S\n\t         /\\ request(A,S,ktrgtint,Keycompleted') \n\t         /\\ witness(A,S,k,Keycompleted') \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole target( \n\tA,S           : agent,      \n\tG             : nat,\n\tH             : hash_func,\n\tKa,Ks         : public_key,\n\tLogin, Pwd    : hash_func,\n        SND, RCV      : channel (dy))\nplayed_by S def=\n\n  local\tState        : nat,\n        Na,Nb        : text,\n        Rnumber2     : text,\n        Y            : message,\n        Keycompleted : message,\n        W            : nat,\n        K            : text.text\n\n  const sec_t_Log, sec_t_Pwd: protocol_id\n\n  init  State := 0\n\n  transition \n\n  1. State  = 0 /\\ RCV(A.S.Na'.Y'.{A.S.Na'.Y'}_inv(Ka)) =|>\n     State':= 1 /\\ Nb' := new()\n                /\\ Rnumber2' := new()\n                /\\ SND(A.S.Na'.Nb'.exp(G,Rnumber2').\n                      {A.S.Na'.Nb'.exp(G,Rnumber2')}_inv(Ks))\n\t        /\\ Keycompleted':=exp(Y',Rnumber2')\n\t        /\\ secret(Login(A.S),sec_t_Log,{A}) \n\t        /\\ secret(Pwd(A.S),  sec_t_Pwd,{A}) \n\t\t/\\ witness(S,A,ktrgtint,Keycompleted')\n\n  2. State  = 1 /\\ RCV({Login(A.S).Pwd(A.S)}_Keycompleted) =|>\n     State':= 2 /\\ K':=Login(A.S).Pwd(A.S)\n                /\\ request(S,A,k,Keycompleted) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(\n\t  A,S : agent,\n\t  Login, Pwd: hash_func,\n\t  Ka: public_key,\n          Ks: public_key,\n\t  H: hash_func,\n\t  G: nat)\ndef=  \n\n  local   SndI, RcvI,\n          SndT, RcvT : channel (dy) \n  composition \n\n     initiator(A,S,G,H,Ka,Ks,Login(A.S),Pwd(A.S),SndI,RcvI)\n  /\\ target(   A,S,G,H,Ka,Ks,Login,Pwd,SndT,RcvT)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a,s,i,b: agent,\n        ka, ki, kb, ks: public_key,\n        login, pwd : hash_func,\n\th: hash_func,\n\tg: nat,\n\tk,ktrgtint: protocol_id\n\n  intruder_knowledge = {ki,i, inv(ki),a,b,s,h,g,ks,login(i.s),pwd(i.s),ka\n                       } \n\n  composition\n            session(a,s,login,pwd,ka,ks,h,g)\n\t/\\  session(b,s,login,pwd,kb,ks,h,g)\n\t/\\  session(i,s,login,pwd,ki,ks,h,g)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal \n\n  %Target authenticates Initiator on k\n  authentication_on k % addresses G1, G2, G3\n  %Initiator authenticates Target on ktrgtint\n  authentication_on ktrgtint % addresses G1, G2, G3\n\n  %secrecy_of Login, Pwd\n  secrecy_of sec_i_Log, sec_i_Pwd, % adresses G7, G10\n             sec_t_Log, sec_t_Pwd  % adresses G7, G10\n\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/liteCrypto.hlpsl",
        "incomplete": "%%% 1. A -> B : PID, S\n%%% 2. A -> B : M1, MAC, Sig\n%%% 3. B -> A : A, B, SAC\n\n____(ROLE_1)____ ____(ROLE_0)____(____(PARAM_4)____, B: agent, ____(PARAM_5)____: public_key, ____(PARAM_3)____:hash_func, ____(PARAM_2)____:hash_func, ____(PARAM_0)____, RCV: channel(____(PARAM_1)____))\nplayed_by A\ndef=\n\tlocal\n\t\tState:____(VARIABLE_0)____,\n\t\tChe,Ts,Ts2:text,\n\t\tRes,S,PID,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Che':=new() /\\ Res':=Ha(Che') /\\ S':=Hb(Res') /\\ PID':=Ha(A.S')\n\t\t/\\ SND({A.B.PID'.S'}_Pubkey)\n\t\t/\\ Ts':=new() /\\ M1':={A.B.PID'.Ts'}_Pubkey /\\ MAC1':=Ha(M1') /\\ SIG1':={Hb(M1').Ha(S'.PID')}\n\t\t/\\ SND({M1'.MAC1'.SIG1'.Ts'}_Pubkey)\n\n\t\t/\\ secret(____(EVENT_1)____,____(EVENT_0)____,{A,B})\n\t\t/\\ secret(S',____(EVENT_3)____,{A,____(EVENT_2)____})\n\n\t\t2. State=____(STATE_0)____ /\\ RCV({A.B.Ts.Ts2'.SAC'}_Pubkey) =|>\n\t\tState':=4\n\n\t\t/\\ ____(EVENT_5)____(A,____(EVENT_4)____,auth_1,MAC1)\n\t\t/\\ request(A,____(EVENT_6)____,____(EVENT_7)____,SIG1)\n\t\t/\\ request(A,B,____(EVENT_8)____,____(EVENT_9)____)\nend role\n\nrole role_B(A, ____(PARAM_6)____: ____(PARAM_7)____, Pubkey: public_key, Ha:hash_func,____(PARAM_10)____:hash_func, ____(PARAM_9)____, ____(PARAM_8)____: channel(____(PARAM_11)____))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tTs,Ts2:text,\n\t\tPID,S,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.B.PID'.S'}_Pubkey) /\\ RCV({M1'.MAC1'.SIG1'.Ts'}_Pubkey) =|>\n\t\tState':=3 /\\ Key':=Ha(PID'.S') /\\ Ts2':=new() /\\ SAC':=Ha(Key,A,B)\n\t\t/\\ SND({A.B.Ts'.Ts2'.SAC'}_Pubkey)\n\n\t\t/\\ secret(SAC',____(EVENT_10)____,{____(EVENT_11)____,B})\n\n\t\t/\\ ____(EVENT_12)____(B,____(EVENT_13)____,auth_1,MAC1')\n\t\t/\\ ____(EVENT_14)____(B,____(EVENT_15)____,auth_2,SIG1')\n\t\t/\\ ____(EVENT_16)____(B,____(EVENT_17)____,auth_3,M1')\nend role\n\nrole session(____(PARAM_16)____,____(PARAM_13)____:agent, PubA,____(PARAM_12)____: public_key, Ha:____(PARAM_14)____, Hb: ____(PARAM_15)____)\ndef=\n\tlocal\n\t\t____(VARIABLE_1)____,RCV2,SND1,RCV1:channel(____(VARIABLE_2)____)\n\tcomposition\n\t\trole_A(A,B,PubB,Ha,Hb,SND1,RCV1) /\\ \n\t\trole_B(A,B,PubA,Ha,Hb,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\t____(VARIABLE_3)____,groundstation:____(VARIABLE_4)____,\n\t\tpubA:public_key,\n\t\tpubB:public_key,\n\t\tha:hash_func,\n\t\thb:hash_func,\n\t\tsec_1,sec_2,sec_3,auth_1,auth_2,auth_3:protocol_id\n\tintruder_knowledge = {drone,groundstation,ha,hb}\n\n\tcomposition\n\t\tsession(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(i,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,i,pubA,pubB,ha,hb)\nend role\n\ngoal\n\t____(GOAL_18)____ sec_1\n\t____(GOAL_19)____ sec_2\n\tsecrecy_of ____(GOAL_20)____\n\tauthentication_on ____(GOAL_21)____\n\t____(GOAL_22)____ auth_2\n\t____(GOAL_23)____ auth_3\nend goal\n\nenvironment()",
        "complete:": "%%% 1. A -> B : PID, S\n%%% 2. A -> B : M1, MAC, Sig\n%%% 3. B -> A : A, B, SAC\n\nrole role_A(A, B: agent, Pubkey: public_key, Ha:hash_func, Hb:hash_func, SND, RCV: channel(dy))\nplayed_by A\ndef=\n\tlocal\n\t\tState:nat,\n\t\tChe,Ts,Ts2:text,\n\t\tRes,S,PID,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 0\n\ttransition\n\t\t1. State=0 /\\ RCV(start) =|>\n\t\tState':=2 /\\ Che':=new() /\\ Res':=Ha(Che') /\\ S':=Hb(Res') /\\ PID':=Ha(A.S')\n\t\t/\\ SND({A.B.PID'.S'}_Pubkey)\n\t\t/\\ Ts':=new() /\\ M1':={A.B.PID'.Ts'}_Pubkey /\\ MAC1':=Ha(M1') /\\ SIG1':={Hb(M1').Ha(S'.PID')}\n\t\t/\\ SND({M1'.MAC1'.SIG1'.Ts'}_Pubkey)\n\n\t\t/\\ secret(M1',sec_1,{A,B})\n\t\t/\\ secret(S',sec_2,{A,B})\n\n\t\t2. State=2 /\\ RCV({A.B.Ts.Ts2'.SAC'}_Pubkey) =|>\n\t\tState':=4\n\n\t\t/\\ request(A,B,auth_1,MAC1)\n\t\t/\\ request(A,B,auth_2,SIG1)\n\t\t/\\ request(A,B,auth_3,M1)\nend role\n\nrole role_B(A, B: agent, Pubkey: public_key, Ha:hash_func,Hb:hash_func, SND, RCV: channel(dy))\nplayed_by B\ndef=\n\tlocal\n\t\tState:nat,\n\t\tTs,Ts2:text,\n\t\tPID,S,M1,MAC1,SIG1,SAC,Key:message\n\tinit\n\t\tState := 1\n\ttransition\n\t\t1. State=1 /\\ RCV({A.B.PID'.S'}_Pubkey) /\\ RCV({M1'.MAC1'.SIG1'.Ts'}_Pubkey) =|>\n\t\tState':=3 /\\ Key':=Ha(PID'.S') /\\ Ts2':=new() /\\ SAC':=Ha(Key,A,B)\n\t\t/\\ SND({A.B.Ts'.Ts2'.SAC'}_Pubkey)\n\n\t\t/\\ secret(SAC',sec_3,{A,B})\n\n\t\t/\\ witness(B,A,auth_1,MAC1')\n\t\t/\\ witness(B,A,auth_2,SIG1')\n\t\t/\\ witness(B,A,auth_3,M1')\nend role\n\nrole session(A,B:agent, PubA,PubB: public_key, Ha:hash_func, Hb: hash_func)\ndef=\n\tlocal\n\t\tSND2,RCV2,SND1,RCV1:channel(dy)\n\tcomposition\n\t\trole_A(A,B,PubB,Ha,Hb,SND1,RCV1) /\\ \n\t\trole_B(A,B,PubA,Ha,Hb,SND2,RCV2)\nend role\n\nrole environment()\ndef=\n\tconst\n\t\tdrone,groundstation:agent,\n\t\tpubA:public_key,\n\t\tpubB:public_key,\n\t\tha:hash_func,\n\t\thb:hash_func,\n\t\tsec_1,sec_2,sec_3,auth_1,auth_2,auth_3:protocol_id\n\tintruder_knowledge = {drone,groundstation,ha,hb}\n\n\tcomposition\n\t\tsession(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(i,groundstation,pubA,pubB,ha,hb)\n\t\t/\\ session(drone,i,pubA,pubB,ha,hb)\nend role\n\ngoal\n\tsecrecy_of sec_1\n\tsecrecy_of sec_2\n\tsecrecy_of sec_3\n\tauthentication_on auth_1\n\tauthentication_on auth_2\n\tauthentication_on auth_3\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/LPD-IMSR.hlpsl",
        "incomplete": "%% PROTOCOL*: LPD IMSR\n%% VARIANT: IMSR: Improved Modulo Square Root\n%% LPD (Low-Powered Devices) Improved MSR (Modulo Square Root) protocol\n%% is a key establishment protocol for secure mobile communications. It\n%% has been designed by Beller, Chang, and Yacobi in 1990s as an\n%% improvement of MSR. Namely IMSR overcomes a major weakness of MSR by\n%% including a certificate of the base station in the first\n%% message. Apart from this feature it is identical to the basic MSR\n%% protocol, and therefore does not address the problem of replay\n%% \n%% PURPOSE: \n%% Key establishment protocol for secure mobile communications.\n%%   \n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[pages 5-6]{MutAuthLPD}\n%% \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M    : agent\n%% PKb     : public key\n%% SCm     : text\n%% Nb      : text (fresh)\n%% Cert(B) : message\n%% X       : symmetric key (fresh)\n%%\n%% 1. B -> M : B, Nb, PKb, Cert(B)\n%% 2. M -> B : {X}PKb\n%% 3. M -> B : {Nb, M, SCm}X\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% {\\texttt{M}} which is issued by a trusted central\n%% authority. {\\texttt{Cert(B)}} is the public certificate previously\n%% issued by some server for {\\texttt{B}}.  \n%% We assume \\verb|Cert(B) = {B.PKb}inv(PKs)|.\n%%\n%% Notice that wrt MSR there is a\n%% twofold increase in the complexity of this protocol as compared to the\n%% basic MSR protocol. The mobile now calculates an additional modulo\n%% square to verify the base's certificate on receiving message 1. Upon\n%% receiving the final message, {\\texttt{B}} decrypts it using the\n%% session key {\\texttt{X}}, and checks that the value {\\texttt{Nb}} is\n%% the same as the random challenge sent in message 1.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%% \n%% CLASSIFICATION: G1, G2, G12\n%% \n%% ATTACKS: None\n%% \n%% NOTES:\n%% \n%% The added public certificate and nonce exchange give some more\n%% protection. Boyd et al.~\\cite{MutAuthLPD} recommend moving the nonce\n%% and {\\texttt{M}} into message 2. \\\\\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole ____(ROLE_0)____(____(PARAM_1)____, ____(PARAM_5)____     : agent,\n               SCm      : ____(PARAM_2)____,\n               PKb      : public_key, \n               ____(PARAM_0)____      : public_key, \n               ____(PARAM_3)____, Rcv : channel (____(PARAM_4)____))\nplayed_by B\ndef=\n\n  local State   : nat,\n        X       : symmetric_key,\n        Nb      : text,\n        Package : message\t\n\n  const  ____(VARIABLE_0)____ : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = ____(STATE_0)____\n      /\\ Rcv(____(MESSAGE_4)____)\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(B.Nb'.PKb.{B.PKb}_inv(____(MESSAGE_5)____))\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{____(MESSAGE_6)____}_X')\n      =|> \n      State' := 2 \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole imsr_Mobile(B, M     : agent,\n                 SCm      : text, \n                 ____(PARAM_6)____      : ____(PARAM_8)____,\n                 ____(PARAM_10)____, ____(PARAM_7)____ : channel (____(PARAM_9)____))\nplayed_by M\ndef=\n\n  local State  : ____(VARIABLE_1)____,\n        PKb    : public_key,\n        X      : symmetric_key,\n        Nb     : text,\n        Cert   : message\n\n  const ____(VARIABLE_2)____   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ ____(MESSAGE_7)____(B.Nb'.PKb'.Cert')\n      /\\ Cert' = {B.PKb'}_inv(PKs)  \n      =|> \n      State':=1\n      /\\ X' := new()\n      /\\ Snd({X'}_PKb'.{____(MESSAGE_8)____}_X')\n      /\\ ____(EVENT_0)____(X',____(EVENT_1)____,{B,M})\n      /\\ witness(M,____(EVENT_3)____,____(EVENT_2)____,X') \t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(____(PARAM_12)____, ____(PARAM_14)____           : agent,\n             SCm            : ____(PARAM_13)____,\t\n             PKb, ____(PARAM_11)____       : public_key) def=\n\n  local ____(VARIABLE_3)____, ____(VARIABLE_4)____, SB, RB : channel (dy)\n\n\n  composition\n\t\n       imsr_Base(B,M,SCm,PKb,PKs,SA,RA)\n    /\\ imsr_Mobile(B,M,SCm,PKs,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole ____(ROLE_1)____() def=\n \n  const b, ____(VARIABLE_6)____                                   : ____(VARIABLE_5)____,\n        kb, ki, ks                             : public_key,\n        scm1, scm2, scm3                       : text\n\n  intruder_knowledge = {b,m,scm2,scm3,i,ki,ks,inv(ki),\n                        m,{i.ki}_inv(ks)         \n                       }\n\n  composition\n\n\tsession(b,m,scm1,kb,ks) \n    /\\  session(b,i,scm2,kb,ks) \n    /\\  session(i,m,scm3,ki,ks) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %IMSR_Base weakly authenticates IMSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "complete:": "%% PROTOCOL*: LPD IMSR\n%% VARIANT: IMSR: Improved Modulo Square Root\n%% LPD (Low-Powered Devices) Improved MSR (Modulo Square Root) protocol\n%% is a key establishment protocol for secure mobile communications. It\n%% has been designed by Beller, Chang, and Yacobi in 1990s as an\n%% improvement of MSR. Namely IMSR overcomes a major weakness of MSR by\n%% including a certificate of the base station in the first\n%% message. Apart from this feature it is identical to the basic MSR\n%% protocol, and therefore does not address the problem of replay\n%% \n%% PURPOSE: \n%% Key establishment protocol for secure mobile communications.\n%%   \n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite[pages 5-6]{MutAuthLPD}\n%% \\end{itemize}\n%%\n%% MODELER:\n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% B, M    : agent\n%% PKb     : public key\n%% SCm     : text\n%% Nb      : text (fresh)\n%% Cert(B) : message\n%% X       : symmetric key (fresh)\n%%\n%% 1. B -> M : B, Nb, PKb, Cert(B)\n%% 2. M -> B : {X}PKb\n%% 3. M -> B : {Nb, M, SCm}X\n%% \\end{verbatim}\n%% The object {\\texttt{SCm}} denotes the secret certificate of the mobile\n%% {\\texttt{M}} which is issued by a trusted central\n%% authority. {\\texttt{Cert(B)}} is the public certificate previously\n%% issued by some server for {\\texttt{B}}.  \n%% We assume \\verb|Cert(B) = {B.PKb}inv(PKs)|.\n%%\n%% Notice that wrt MSR there is a\n%% twofold increase in the complexity of this protocol as compared to the\n%% basic MSR protocol. The mobile now calculates an additional modulo\n%% square to verify the base's certificate on receiving message 1. Upon\n%% receiving the final message, {\\texttt{B}} decrypts it using the\n%% session key {\\texttt{X}}, and checks that the value {\\texttt{Nb}} is\n%% the same as the random challenge sent in message 1.\n%%\n%% LIMITATIONS:\n%% The protocol would require the mobile {\\texttt{M}} to send two\n%% sequential messages to the base station {\\texttt{B}} in a row. We\n%% model such a situation by sending in one single transition the pair of\n%% the two messages.\n%% \n%% PROBLEMS: 2\n%% \n%% CLASSIFICATION: G1, G2, G12\n%% \n%% ATTACKS: None\n%% \n%% NOTES:\n%% \n%% The added public certificate and nonce exchange give some more\n%% protection. Boyd et al.~\\cite{MutAuthLPD} recommend moving the nonce\n%% and {\\texttt{M}} into message 2. \\\\\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\nrole imsr_Base(B, M     : agent,\n               SCm      : text,\n               PKb      : public_key, \n               PKs      : public_key, \n               Snd, Rcv : channel (dy))\nplayed_by B\ndef=\n\n  local State   : nat,\n        X       : symmetric_key,\n        Nb      : text,\n        Package : message\t\n\n  const  x : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Nb' := new()\n      /\\ Snd(B.Nb'.PKb.{B.PKb}_inv(PKs))\n\n   2. State = 1\n      /\\ Rcv({X'}_PKb.{Nb.M.SCm}_X')\n      =|> \n      State' := 2 \n      /\\ wrequest(B,M,x,X')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole imsr_Mobile(B, M     : agent,\n                 SCm      : text, \n                 PKs      : public_key,\n                 Snd, Rcv : channel (dy))\nplayed_by M\ndef=\n\n  local State  : nat,\n        PKb    : public_key,\n        X      : symmetric_key,\n        Nb     : text,\n        Cert   : message\n\n  const secx   : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(B.Nb'.PKb'.Cert')\n      /\\ Cert' = {B.PKb'}_inv(PKs)  \n      =|> \n      State':=1\n      /\\ X' := new()\n      /\\ Snd({X'}_PKb'.{Nb'.M.SCm}_X')\n      /\\ secret(X',secx,{B,M})\n      /\\ witness(M,B,x,X') \t\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(B, M           : agent,\n             SCm            : text,\t\n             PKb, PKs       : public_key) def=\n\n  local SA, RA, SB, RB : channel (dy)\n\n\n  composition\n\t\n       imsr_Base(B,M,SCm,PKb,PKs,SA,RA)\n    /\\ imsr_Mobile(B,M,SCm,PKs,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n \n  const b, m                                   : agent,\n        kb, ki, ks                             : public_key,\n        scm1, scm2, scm3                       : text\n\n  intruder_knowledge = {b,m,scm2,scm3,i,ki,ks,inv(ki),\n                        m,{i.ki}_inv(ks)         \n                       }\n\n  composition\n\n\tsession(b,m,scm1,kb,ks) \n    /\\  session(b,i,scm2,kb,ks) \n    /\\  session(i,m,scm3,ki,ks) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  % The established key X must be a secret between the base and the mobile\n  secrecy_of secx % addresses G12\n\n  % Authentication: base station authenticates mobile \n  %IMSR_Base weakly authenticates IMSR_Mobile on x\n  weak_authentication_on x % addresses G1, G2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/main.hlpsl",
        "incomplete": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Registration Authority\n____(ROLE_1)____ ____(ROLE_0)____(RA, ____(PARAM_0)____, ____(PARAM_1)____: agent, ____(PARAM_2)____: ____(PARAM_3)____, Snd, Rcv: channel(dy))\n\nplayed_by RA def=\nlocal\n    State: nat,\n    Skcon, Sksw: symmetric_key,\n    %%% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add: hash_func,\n    IDCon, IDSw, IDClus, PRVRa, PRVCon, PRVSw, PUBRa, PUBCon, PUBSw, G, CERTCon, CERTSw: message\nconst ____(VARIABLE_1)____, prvcon, prvsw: ____(VARIABLE_0)____\n\ninit\n    State := 0\n\ntransition\n\n%%% Controller Registration\n1. State = 0 /\\ ____(MESSAGE_30)____(start) =|> State':= 1 /\\\n\n%%% Generate private key and public key for Registration Authority \nPRVRa' := new() /\\ PUBRa' := F(PRVRa'.G) /\\\n\n%%% Generate private key and public key for Controller\nPRVCon' := new() /\\ PUBCon' := F(PRVCon'.G) /\\\n\n%%% Generate certificate for controller\nCERTCon' := Add(PRVCon'.H(IDCon.IDClus.PUBCon'.PUBRa').PRVRa') /\\\n\n%%% Send Registration message via secure channel\n____(MESSAGE_31)____({IDCon.PRVCon'.CERTCon'}_Skcon) /\\\n____(EVENT_1)____({PRVRa'}, ____(EVENT_0)____, RA) /\\\n____(EVENT_3)____({PRVCon'}, prvcon, {RA, ____(EVENT_2)____}) /\\\n\n%%% Switch Registration\nPRVSw' := new() /\\ PUBSw' := F(PRVSw'.G) /\\\nCERTSw' := Add(PRVSw'.H(IDSw.IDClus.PUBSw'.PUBRa').PRVRa') /\\\n\n%%% Send Registration via secure channel(offline registration)\nSnd({____(MESSAGE_32)____}_Sksw) /\\\nsecret({____(EVENT_5)____}, prvsw, {RA, ____(EVENT_4)____})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Controller\nrole controller(____(PARAM_5)____, SC, ____(PARAM_6)____: agent, ____(PARAM_4)____: hash_func, Snd, Rcv: channel(____(PARAM_7)____))\n\nplayed_by SC def=\nlocal\n    State : ____(VARIABLE_2)____,\n    Skcon: symmetric_key,\n    %%% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    G, IDCon, IDSw, PRVCon, IDClus, PRVRa, R1, R2, TS1, FCONSWI, ACON, BCON: message,\n    TS2, PRVSw: message\n\ninit\n    State := 0\n    \ntransition\n\n%%% Registration phase acceptance\n1. State = 0 /\\ ____(MESSAGE_33)____({IDCon.PRVCon'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')}_Skcon)\n=|> State' := 2 /\\ ____(EVENT_7)____(____(EVENT_6)____, prvra, RA) /\\ secret(____(EVENT_9)____, ____(EVENT_8)____, {RA, SC}) /\\\n\n%%% Access control phase\nR1' := new() /\\ TS1' := new() /\\ FCONSWI':= Poly(IDCon.IDSw) /\\\nACON' := H(R1'.TS1').xor(H(FCONSWI'.TS1')) /\\\nBCON' := H(IDCon.IDSw.ACON'.TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').FCONSWI')\n/\\\n\n%%% Send message over public channel\nSnd(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(____(MESSAGE_34)____).F(PRVRa'.G)).PRVRa').ACON'.BCON'.TS1') /\\\n\n%%% SC has freshly generated the values R1' and TS1' for SSW\nwitness(____(EVENT_10)____, SSW, scsswr1, ____(EVENT_11)____) /\\\nwitness(SC, SSW, ____(EVENT_12)____, ____(EVENT_13)____)\n\n2. State = ____(STATE_1)____ /\\ Rcv(IDCon'.IDSw'.Add(PRVSw'.H(IDSw'.IDClus'.F(____(MESSAGE_35)____).F(PRVRa'.G')).PRVRa').\n(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).H(H(Poly(IDSw'.IDCon').((H(R1'.TS1').\nxor(H(Poly(IDCon'.IDSw').TS1'))).xor(H(Poly(IDSw'.IDCon').TS1'))).H(R2'.TS2').\nAdd(PRVCon'.H(IDCon'.IDClus'.F(PRVCon'.G').F(PRVRa'.G')).PRVRa')\n.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa'))\n.(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G')\n.F(PRVRa'.G')).PRVRa').IDCon'.IDSw'.TS2').TS2') =|>\nState' := 5 /\\\nrequest(____(EVENT_15)____, SC, sswscr2, ____(EVENT_14)____) /\\\nrequest(____(EVENT_16)____, SC, ____(EVENT_17)____, TS2')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Switch\nrole switch(RA, SC, SSW: agent, ____(PARAM_8)____: ____(PARAM_9)____, ____(PARAM_10)____, ____(PARAM_11)____: channel(dy))\n\nplayed_by SSW def=\nlocal\n    ____(VARIABLE_3)____ : nat,\n    Sksw: symmetric_key,\n    %% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    IDCon, IDSw, PRVSw, IDClus, G, PRVRa, R2, TS2, ASWI, SKswicon, R1 : message,\n    TS1, PRVCon, SKVswicon: message\n    \ninit\n    State := 0\n\ntransition\n\n% Registration acceptance phase\n1. State = 0 /\\ ____(MESSAGE_36)____({IDSw.PRVSw'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')}_Sksw) =|>\nState' := 3 /\\ ____(EVENT_18)____(PRVRa', ____(EVENT_19)____, RA) /\\ ____(EVENT_21)____(____(EVENT_20)____, prvsw, {RA, SSW})\n\n% Access Control Phase\n\n2. State = ____(STATE_0)____ /\\ Rcv(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(____(MESSAGE_37)____).F(PRVRa'.G)).PRVRa').\n        H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1')).\n        H(IDCon.IDSw.H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))\n        .TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').Poly(IDCon.IDSw))\n        .TS1') =|>\nState' := 4 /\\\nR2' := new() /\\ TS2' := new() /\\\nASWI' := H(R2'.TS2').xor(H(Poly(IDSw.IDCon).TS2')) /\\\nPRVSw' := new() /\\\nSKswicon' := H(Poly(IDSw.IDCon).((H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))).xor(H(Poly(IDSw.IDCon).TS1'))).H(R2'.TS2').\n            Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')\n            .Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')) /\\\nSKVswicon' := H(SKswicon'.ASWI'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').IDCon.IDSw.TS2') /\\\nSnd(IDCon.IDSw.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').ASWI'.SKVswicon'.TS2') /\\ % \n\nwitness(SSW, SC, ____(EVENT_23)____, ____(EVENT_22)____) /\\\n____(EVENT_25)____(SSW, SC, ____(EVENT_24)____, TS2') /\\\n____(EVENT_27)____(SC, SSW, ____(EVENT_26)____, R1') /\\\nrequest(SC, SSW, ____(EVENT_28)____, ____(EVENT_29)____)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define session role\nrole session(RA, SC, ____(PARAM_13)____: agent, ____(PARAM_14)____: ____(PARAM_12)____)\ndef=\nlocal\n    ____(VARIABLE_5)____, SCRCV, SSWSND, SSWRCV, ____(VARIABLE_4)____, ____(VARIABLE_6)____: channel(dy)\ncomposition\n    registrationAuth(RA, SC, SSW, H, RASND, RARCV) /\\\n    controller(RA, SC, SSW, H, SCSND, SCRCV) /\\\n    switch(RA, SC, SSW, H, SSWSND, SSWRCV)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define environment role\nrole environment() def= \nconst \n    ra, ____(VARIABLE_7)____, ____(VARIABLE_8)____: agent,\n    h, f, add, poly: hash_func,\n    prvra, prvcon, prvsw: protocol_id,\n    scsswts1, scsswr1 : protocol_id,\n    sswscr2, sswscts2 : protocol_id\nintruder_knowledge = {ra, sc, ssw, h, f, add, poly}\n\ncomposition\n    session(ra, sc, ssw, h) /\\\n    session(ra, sc, i, h) /\\\n    session(ra, i, ssw, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n% Confidentiality of Private Keys\n____(GOAL_39)____ prvra\nsecrecy_of ____(GOAL_40)____\nsecrecy_of ____(GOAL_41)____\n\n% Authentication\n____(GOAL_42)____ scsswr1 \n____(GOAL_43)____ scsswts1\n____(GOAL_44)____ sswscr2\n____(GOAL_45)____ sswscts2\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()",
        "complete:": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Registration Authority\nrole registrationAuth(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\n\nplayed_by RA def=\nlocal\n    State: nat,\n    Skcon, Sksw: symmetric_key,\n    %%% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add: hash_func,\n    IDCon, IDSw, IDClus, PRVRa, PRVCon, PRVSw, PUBRa, PUBCon, PUBSw, G, CERTCon, CERTSw: message\nconst prvra, prvcon, prvsw: protocol_id\n\ninit\n    State := 0\n\ntransition\n\n%%% Controller Registration\n1. State = 0 /\\ Rcv(start) =|> State':= 1 /\\\n\n%%% Generate private key and public key for Registration Authority \nPRVRa' := new() /\\ PUBRa' := F(PRVRa'.G) /\\\n\n%%% Generate private key and public key for Controller\nPRVCon' := new() /\\ PUBCon' := F(PRVCon'.G) /\\\n\n%%% Generate certificate for controller\nCERTCon' := Add(PRVCon'.H(IDCon.IDClus.PUBCon'.PUBRa').PRVRa') /\\\n\n%%% Send Registration message via secure channel\nSnd({IDCon.PRVCon'.CERTCon'}_Skcon) /\\\nsecret({PRVRa'}, prvra, RA) /\\\nsecret({PRVCon'}, prvcon, {RA, SC}) /\\\n\n%%% Switch Registration\nPRVSw' := new() /\\ PUBSw' := F(PRVSw'.G) /\\\nCERTSw' := Add(PRVSw'.H(IDSw.IDClus.PUBSw'.PUBRa').PRVRa') /\\\n\n%%% Send Registration via secure channel(offline registration)\nSnd({IDSw.PRVSw'.CERTSw'}_Sksw) /\\\nsecret({PRVSw'}, prvsw, {RA, SSW})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Controller\nrole controller(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\n\nplayed_by SC def=\nlocal\n    State : nat,\n    Skcon: symmetric_key,\n    %%% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    G, IDCon, IDSw, PRVCon, IDClus, PRVRa, R1, R2, TS1, FCONSWI, ACON, BCON: message,\n    TS2, PRVSw: message\n\ninit\n    State := 0\n    \ntransition\n\n%%% Registration phase acceptance\n1. State = 0 /\\ Rcv({IDCon.PRVCon'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')}_Skcon)\n=|> State' := 2 /\\ secret(PRVRa', prvra, RA) /\\ secret(PRVCon', prvcon, {RA, SC}) /\\\n\n%%% Access control phase\nR1' := new() /\\ TS1' := new() /\\ FCONSWI':= Poly(IDCon.IDSw) /\\\nACON' := H(R1'.TS1').xor(H(FCONSWI'.TS1')) /\\\nBCON' := H(IDCon.IDSw.ACON'.TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').FCONSWI')\n/\\\n\n%%% Send message over public channel\nSnd(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').ACON'.BCON'.TS1') /\\\n\n%%% SC has freshly generated the values R1' and TS1' for SSW\nwitness(SC, SSW, scsswr1, R1') /\\\nwitness(SC, SSW, scsswts1, TS1')\n\n2. State = 2 /\\ Rcv(IDCon'.IDSw'.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa').\n(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).H(H(Poly(IDSw'.IDCon').((H(R1'.TS1').\nxor(H(Poly(IDCon'.IDSw').TS1'))).xor(H(Poly(IDSw'.IDCon').TS1'))).H(R2'.TS2').\nAdd(PRVCon'.H(IDCon'.IDClus'.F(PRVCon'.G').F(PRVRa'.G')).PRVRa')\n.Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G').F(PRVRa'.G')).PRVRa'))\n.(H(R2'.TS2').xor(H(Poly(IDSw'.IDCon').TS2'))).Add(PRVSw'.H(IDSw'.IDClus'.F(PRVSw'.G')\n.F(PRVRa'.G')).PRVRa').IDCon'.IDSw'.TS2').TS2') =|>\nState' := 5 /\\\nrequest(SSW, SC, sswscr2, R2') /\\\nrequest(SSW, SC, sswscts2, TS2')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%% Switch\nrole switch(RA, SC, SSW: agent, H: hash_func, Snd, Rcv: channel(dy))\n\nplayed_by SSW def=\nlocal\n    State : nat,\n    Sksw: symmetric_key,\n    %% F is elliptical curve multiplication & Add is addition/multiplication operator\n    F, Add, Poly: hash_func,\n    IDCon, IDSw, PRVSw, IDClus, G, PRVRa, R2, TS2, ASWI, SKswicon, R1 : message,\n    TS1, PRVCon, SKVswicon: message\n    \ninit\n    State := 0\n\ntransition\n\n% Registration acceptance phase\n1. State = 0 /\\ Rcv({IDSw.PRVSw'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')}_Sksw) =|>\nState' := 3 /\\ secret(PRVRa', prvra, RA) /\\ secret(PRVSw', prvsw, {RA, SSW})\n\n% Access Control Phase\n\n2. State = 3 /\\ Rcv(IDCon.IDSw.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').\n        H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1')).\n        H(IDCon.IDSw.H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))\n        .TS1'.Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa').Poly(IDCon.IDSw))\n        .TS1') =|>\nState' := 4 /\\\nR2' := new() /\\ TS2' := new() /\\\nASWI' := H(R2'.TS2').xor(H(Poly(IDSw.IDCon).TS2')) /\\\nPRVSw' := new() /\\\nSKswicon' := H(Poly(IDSw.IDCon).((H(R1'.TS1').xor(H(Poly(IDCon.IDSw).TS1'))).xor(H(Poly(IDSw.IDCon).TS1'))).H(R2'.TS2').\n            Add(PRVCon'.H(IDCon.IDClus.F(PRVCon'.G).F(PRVRa'.G)).PRVRa')\n            .Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa')) /\\\nSKVswicon' := H(SKswicon'.ASWI'.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').IDCon.IDSw.TS2') /\\\nSnd(IDCon.IDSw.Add(PRVSw'.H(IDSw.IDClus.F(PRVSw'.G).F(PRVRa'.G)).PRVRa').ASWI'.SKVswicon'.TS2') /\\ % \n\nwitness(SSW, SC, sswscr2, R2') /\\\nwitness(SSW, SC, sswscts2, TS2') /\\\nrequest(SC, SSW, scsswr1, R1') /\\\nrequest(SC, SSW, scsswts1, TS1')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define session role\nrole session(RA, SC, SSW: agent, H: hash_func)\ndef=\nlocal\n    SCSND, SCRCV, SSWSND, SSWRCV, RASND, RARCV: channel(dy)\ncomposition\n    registrationAuth(RA, SC, SSW, H, RASND, RARCV) /\\\n    controller(RA, SC, SSW, H, SCSND, SCRCV) /\\\n    switch(RA, SC, SSW, H, SSWSND, SSWRCV)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Define environment role\nrole environment() def= \nconst \n    ra, sc, ssw: agent,\n    h, f, add, poly: hash_func,\n    prvra, prvcon, prvsw: protocol_id,\n    scsswts1, scsswr1 : protocol_id,\n    sswscr2, sswscts2 : protocol_id\nintruder_knowledge = {ra, sc, ssw, h, f, add, poly}\n\ncomposition\n    session(ra, sc, ssw, h) /\\\n    session(ra, sc, i, h) /\\\n    session(ra, i, ssw, h)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n% Confidentiality of Private Keys\nsecrecy_of prvra\nsecrecy_of prvcon\nsecrecy_of prvsw\n\n% Authentication\nauthentication_on scsswr1 \nauthentication_on scsswts1\nauthentication_on sswscr2\nauthentication_on sswscts2\nend goal\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()"
    }
]