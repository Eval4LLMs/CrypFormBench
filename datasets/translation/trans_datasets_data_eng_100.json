[
    {
        "filefrom": "SPDL-1/yahalom.spdl",
        "fileto": "MAUDE-1/Yahalom.maude",
        "logicfrom": "---\n\n## Description of the Yahalom Protocol\n\n### Overview\nThe Yahalom protocol is a security protocol designed for secure session key establishment and authentication. It involves three parties: the initiator (I), the responder (R), and a server (S). The protocol aims to ensure that both parties can establish a shared session key while preventing replay attacks and ensuring mutual authentication.\n\n### Participants\n1. **Initiator (I)**: The entity that starts the communication and requests a session key.\n2. **Responder (R)**: The entity that responds to the initiator's request and participates in the session key establishment.\n3. **Server (S)**: The entity that facilitates the communication between the initiator and the responder and can issue tickets.\n\n### Variables\n- **Nonces**: Random values (`Ni` for the initiator and `Nr` for the responder) used to ensure freshness and prevent replay attacks.\n- **Ticket (T)**: A credential issued by the server that contains information about the session and is used to authenticate the participants.\n- **Session Key (Kir)**: A key that is established for secure communication between the initiator and responder.\n\n### Protocol Steps\n1. **Initiator's Step**:\n   - The initiator generates a nonce `Ni` and sends it to the responder (R) along with its identity.\n   - **Message 1**: `I -> R : (I, Ni)`\n\n2. **Responder's Step**:\n   - Upon receiving the message, the responder generates its own nonce `Nr` and creates a ticket `T` for the session.\n   - The responder then sends a message to the server (S) with the initiator's identity, the session key `Kir`, and both nonces, all encrypted with a shared key (`k(R, S)`).\n   - **Message 2**: `R -> S : (R, {I, Ni, Nr}k(R, S))`\n\n3. **Server's Step**:\n   - The server processes the request and sends back a response to the responder containing the session key and a ticket, encrypted with the same shared key.\n   - **Message 3**: `S -> R : {R, Kir, Ni, Nr}k(I, S), T`\n\n4. **Responder's Final Step**:\n   - The responder then forwards the session key to the initiator, sending it alongside `Nr`, both encrypted with the session key `Kir`.\n   - **Message 4**: `R -> I : {I, Kir}k(R, S), {Nr}Kir`\n\n5. **Claims**:\n   - The initiator claims that the session key `Kir` is secret.\n   - The responder claims that the session key `Kir` is also secret.\n   - The server claims the nonces `Ni` and `Nr` are secret.\n\n### Claims\n- **Initiator (I)**: Claims that the session key `Kir` is secret (claim_I1).\n- **Responder (R)**: Claims that the session key `Kir` is secret (claim_R1).\n- **Server (S)**: Claims that both nonces `Ni` and `Nr` are secret.\n\n### Security Goals\nThe Yahalom protocol aims to achieve the following security properties:\n- Mutual authentication between the initiator and responder.\n- Confidentiality of the session key and nonces.\n- Resistance to replay attacks.\n\n### Conclusion\nThe Yahalom protocol effectively establishes a secure session key while ensuring the identities of the parties involved are authenticated. The use of nonces and encryption plays a crucial role in maintaining the security of the communication.\n\n---",
        "codefrom:": "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "yahalom",
                        "I",
                        "yahalom,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "yahalom,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "S",
                        "yahalom,S1",
                        "Secret Ni",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "",
                        "yahalom,S2",
                        "Secret Nr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.47480297088623047
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Yahalom.maude",
        "fileto": "SPDL-1/yahalom.spdl",
        "logicfrom": "---\n\n### Yahalom Protocol Description\n\nThe Yahalom Protocol is a cryptographic protocol designed for secure authentication and key exchange between two users (Alice and Bob) with the involvement of a trusted server. The protocol utilizes symmetric encryption and nonces to ensure secure communication and prevent replay attacks.\n\n#### Participants:\n- **Alice (A)**: One of the users initiating the communication.\n- **Bob (B)**: The other user involved in the communication.\n- **Server (S)**: A trusted server that facilitates the key exchange.\n\n#### Key Elements:\n- **Keys**: \n  - **Master Keys (mkey)**: Each user has a master key shared with the server.\n  - **Session Keys (seskey)**: The session key is generated for communication between Alice and Bob.\n- **Nonces**: Random values generated by the participants to ensure freshness in the communication.\n\n#### Protocol Steps:\n1. **Alice Initiates Communication**:\n   - Alice generates a nonce (Na) and sends it along with her identifier (A) to Bob.\n   \n2. **Bob Responds with a Message to the Server**:\n   - Bob receives Alice's message and generates a nonce (Nb). He sends a message to the server, which includes Alice's identifier (A), nonce (Na), and his own nonce (Nb) encrypted using the master key shared with Alice.\n   \n3. **Server Responds to Alice**:\n   - The server decrypts Bob's message, verifies it, and generates a session key (SK) for Alice and Bob. The server sends back two encrypted messages: one containing the session key and the nonces, encrypted with Bob's master key, and the other encrypted with Alice's master key.\n   \n4. **Alice Completes the Protocol**:\n   - Alice decrypts the server's response, retrieves the session key and nonces, and sends a confirmation to Bob, encrypted with the session key.\n\n#### Security Features:\n- **Confidentiality**: Messages are encrypted, ensuring that only the intended recipients can read them.\n- **Integrity**: The use of nonces prevents replay attacks by ensuring that each message is fresh and unique.\n- **Authentication**: Both participants can prove their identities by demonstrating knowledge of the shared keys.\n\n### Maude Implementation\n\nIn the Maude implementation:\n- The protocol is defined using sorts for usernames, keys, nonces, and messages.\n- Operations for encryption and decryption are included, as well as the structure of the protocol's communication strands.\n- The protocol's execution is represented through various equations that outline the communication between Alice, Bob, and the server.\n\nThe Maude-NPA module structure includes:\n- A module for symbols defining the sorts and operations used in the protocol.\n- An algebraic module defining properties of encryption and decryption.\n- A specification module that includes the strands of the protocol and the attack state.\n\nThis structured approach allows the Maude-NPA tool to analyze the protocol for potential vulnerabilities and verify its correctness.\n\n---",
        "codefrom:": "---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(p(M)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , NB)) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(a ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "resultsfrom": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Fri May  2 19:12:32 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 15139949 in 14256ms cpu (14264ms real) (1062005 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(a ; NA:Nonce), \n   +(b ; e(mkey(b, s), a ; NA:Nonce ; n(b, r:Fresh))), \n   -(e(mkey(b, s), a ; SK:Sessionkey) ; e(SK:Sessionkey, n(b, r:Fresh))) | nil]\n    \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 82393020 in 90512ms cpu (90513ms real) (910299 rewrites/second)\nresult IdSystemSet: (< 1 . 5 . 7 . 1 . 1 > (\n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil)\n< 1 . 2 . 6 . 6 . (8{1}) . 3 . (9{2}) . 3 . 1 . 1 > (\n:: nil ::\n[ nil | \n   -(#3:Msg), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), nil]  & \n:: nil ::\n[ nil | \n   -(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   +(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n   +(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n#3:Msg !inI,\ne(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) !inI,\ne(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) !inI,\ne(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh)) !inI,\n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) != e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(\n    a, #0:Fresh) ; n(b, #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s,\n    #1:Fresh)))\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \ngeneratedByIntruder(#3:Msg), \n-(#3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n+(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n+(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                105.78698182106018
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/yahalom.spdl",
        "fileto": "PV-1/Yahalom.pv",
        "logicfrom": "---\n\n## Description of the Yahalom Protocol\n\n### Overview\nThe Yahalom protocol is a security protocol designed for secure session key establishment and authentication. It involves three parties: the initiator (I), the responder (R), and a server (S). The protocol aims to ensure that both parties can establish a shared session key while preventing replay attacks and ensuring mutual authentication.\n\n### Participants\n1. **Initiator (I)**: The entity that starts the communication and requests a session key.\n2. **Responder (R)**: The entity that responds to the initiator's request and participates in the session key establishment.\n3. **Server (S)**: The entity that facilitates the communication between the initiator and the responder and can issue tickets.\n\n### Variables\n- **Nonces**: Random values (`Ni` for the initiator and `Nr` for the responder) used to ensure freshness and prevent replay attacks.\n- **Ticket (T)**: A credential issued by the server that contains information about the session and is used to authenticate the participants.\n- **Session Key (Kir)**: A key that is established for secure communication between the initiator and responder.\n\n### Protocol Steps\n1. **Initiator's Step**:\n   - The initiator generates a nonce `Ni` and sends it to the responder (R) along with its identity.\n   - **Message 1**: `I -> R : (I, Ni)`\n\n2. **Responder's Step**:\n   - Upon receiving the message, the responder generates its own nonce `Nr` and creates a ticket `T` for the session.\n   - The responder then sends a message to the server (S) with the initiator's identity, the session key `Kir`, and both nonces, all encrypted with a shared key (`k(R, S)`).\n   - **Message 2**: `R -> S : (R, {I, Ni, Nr}k(R, S))`\n\n3. **Server's Step**:\n   - The server processes the request and sends back a response to the responder containing the session key and a ticket, encrypted with the same shared key.\n   - **Message 3**: `S -> R : {R, Kir, Ni, Nr}k(I, S), T`\n\n4. **Responder's Final Step**:\n   - The responder then forwards the session key to the initiator, sending it alongside `Nr`, both encrypted with the session key `Kir`.\n   - **Message 4**: `R -> I : {I, Kir}k(R, S), {Nr}Kir`\n\n5. **Claims**:\n   - The initiator claims that the session key `Kir` is secret.\n   - The responder claims that the session key `Kir` is also secret.\n   - The server claims the nonces `Ni` and `Nr` are secret.\n\n### Claims\n- **Initiator (I)**: Claims that the session key `Kir` is secret (claim_I1).\n- **Responder (R)**: Claims that the session key `Kir` is secret (claim_R1).\n- **Server (S)**: Claims that both nonces `Ni` and `Nr` are secret.\n\n### Security Goals\nThe Yahalom protocol aims to achieve the following security properties:\n- Mutual authentication between the initiator and responder.\n- Confidentiality of the session key and nonces.\n- Resistance to replay attacks.\n\n### Conclusion\nThe Yahalom protocol effectively establishes a secure session key while ensuring the identities of the parties involved are authenticated. The use of nonces and encryption plays a crucial role in maintaining the security of the communication.\n\n---",
        "codefrom:": "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "yahalom",
                        "I",
                        "yahalom,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "yahalom,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "S",
                        "yahalom,S1",
                        "Secret Ni",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "",
                        "yahalom,S2",
                        "Secret Nr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.47480297088623047
            ]
        ]
    }
]