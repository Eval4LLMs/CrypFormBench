[
    {
        "filefrom": "SPDL-1/yahalom.spdl",
        "fileto": "MAUDE-1/Yahalom.maude",
        "logicfrom": "---\n\n## Description of the Yahalom Protocol\n\n### Overview\nThe Yahalom protocol is a security protocol designed for secure session key establishment and authentication. It involves three parties: the initiator (I), the responder (R), and a server (S). The protocol aims to ensure that both parties can establish a shared session key while preventing replay attacks and ensuring mutual authentication.\n\n### Participants\n1. **Initiator (I)**: The entity that starts the communication and requests a session key.\n2. **Responder (R)**: The entity that responds to the initiator's request and participates in the session key establishment.\n3. **Server (S)**: The entity that facilitates the communication between the initiator and the responder and can issue tickets.\n\n### Variables\n- **Nonces**: Random values (`Ni` for the initiator and `Nr` for the responder) used to ensure freshness and prevent replay attacks.\n- **Ticket (T)**: A credential issued by the server that contains information about the session and is used to authenticate the participants.\n- **Session Key (Kir)**: A key that is established for secure communication between the initiator and responder.\n\n### Protocol Steps\n1. **Initiator's Step**:\n   - The initiator generates a nonce `Ni` and sends it to the responder (R) along with its identity.\n   - **Message 1**: `I -> R : (I, Ni)`\n\n2. **Responder's Step**:\n   - Upon receiving the message, the responder generates its own nonce `Nr` and creates a ticket `T` for the session.\n   - The responder then sends a message to the server (S) with the initiator's identity, the session key `Kir`, and both nonces, all encrypted with a shared key (`k(R, S)`).\n   - **Message 2**: `R -> S : (R, {I, Ni, Nr}k(R, S))`\n\n3. **Server's Step**:\n   - The server processes the request and sends back a response to the responder containing the session key and a ticket, encrypted with the same shared key.\n   - **Message 3**: `S -> R : {R, Kir, Ni, Nr}k(I, S), T`\n\n4. **Responder's Final Step**:\n   - The responder then forwards the session key to the initiator, sending it alongside `Nr`, both encrypted with the session key `Kir`.\n   - **Message 4**: `R -> I : {I, Kir}k(R, S), {Nr}Kir`\n\n5. **Claims**:\n   - The initiator claims that the session key `Kir` is secret.\n   - The responder claims that the session key `Kir` is also secret.\n   - The server claims the nonces `Ni` and `Nr` are secret.\n\n### Claims\n- **Initiator (I)**: Claims that the session key `Kir` is secret (claim_I1).\n- **Responder (R)**: Claims that the session key `Kir` is secret (claim_R1).\n- **Server (S)**: Claims that both nonces `Ni` and `Nr` are secret.\n\n### Security Goals\nThe Yahalom protocol aims to achieve the following security properties:\n- Mutual authentication between the initiator and responder.\n- Confidentiality of the session key and nonces.\n- Resistance to replay attacks.\n\n### Conclusion\nThe Yahalom protocol effectively establishes a secure session key while ensuring the identities of the parties involved are authenticated. The use of nonces and encryption plays a crucial role in maintaining the security of the communication.\n\n---",
        "codefrom:": "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "yahalom",
                        "I",
                        "yahalom,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "yahalom,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "S",
                        "yahalom,S1",
                        "Secret Ni",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "",
                        "yahalom,S2",
                        "Secret Nr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.47480297088623047
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Yahalom.maude",
        "fileto": "SPDL-1/yahalom.spdl",
        "logicfrom": "---\n\n### Yahalom Protocol Description\n\nThe Yahalom Protocol is a cryptographic protocol designed for secure authentication and key exchange between two users (Alice and Bob) with the involvement of a trusted server. The protocol utilizes symmetric encryption and nonces to ensure secure communication and prevent replay attacks.\n\n#### Participants:\n- **Alice (A)**: One of the users initiating the communication.\n- **Bob (B)**: The other user involved in the communication.\n- **Server (S)**: A trusted server that facilitates the key exchange.\n\n#### Key Elements:\n- **Keys**: \n  - **Master Keys (mkey)**: Each user has a master key shared with the server.\n  - **Session Keys (seskey)**: The session key is generated for communication between Alice and Bob.\n- **Nonces**: Random values generated by the participants to ensure freshness in the communication.\n\n#### Protocol Steps:\n1. **Alice Initiates Communication**:\n   - Alice generates a nonce (Na) and sends it along with her identifier (A) to Bob.\n   \n2. **Bob Responds with a Message to the Server**:\n   - Bob receives Alice's message and generates a nonce (Nb). He sends a message to the server, which includes Alice's identifier (A), nonce (Na), and his own nonce (Nb) encrypted using the master key shared with Alice.\n   \n3. **Server Responds to Alice**:\n   - The server decrypts Bob's message, verifies it, and generates a session key (SK) for Alice and Bob. The server sends back two encrypted messages: one containing the session key and the nonces, encrypted with Bob's master key, and the other encrypted with Alice's master key.\n   \n4. **Alice Completes the Protocol**:\n   - Alice decrypts the server's response, retrieves the session key and nonces, and sends a confirmation to Bob, encrypted with the session key.\n\n#### Security Features:\n- **Confidentiality**: Messages are encrypted, ensuring that only the intended recipients can read them.\n- **Integrity**: The use of nonces prevents replay attacks by ensuring that each message is fresh and unique.\n- **Authentication**: Both participants can prove their identities by demonstrating knowledge of the shared keys.\n\n### Maude Implementation\n\nIn the Maude implementation:\n- The protocol is defined using sorts for usernames, keys, nonces, and messages.\n- Operations for encryption and decryption are included, as well as the structure of the protocol's communication strands.\n- The protocol's execution is represented through various equations that outline the communication between Alice, Bob, and the server.\n\nThe Maude-NPA module structure includes:\n- A module for symbols defining the sorts and operations used in the protocol.\n- An algebraic module defining properties of encryption and decryption.\n- A specification module that includes the strands of the protocol and the attack state.\n\nThis structured approach allows the Maude-NPA tool to analyze the protocol for potential vulnerabilities and verify its correctness.\n\n---",
        "codefrom:": "---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(p(M)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , NB)) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(a ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "resultsfrom": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Fri May  2 19:12:32 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 15139949 in 14256ms cpu (14264ms real) (1062005 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(a ; NA:Nonce), \n   +(b ; e(mkey(b, s), a ; NA:Nonce ; n(b, r:Fresh))), \n   -(e(mkey(b, s), a ; SK:Sessionkey) ; e(SK:Sessionkey, n(b, r:Fresh))) | nil]\n    \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 82393020 in 90512ms cpu (90513ms real) (910299 rewrites/second)\nresult IdSystemSet: (< 1 . 5 . 7 . 1 . 1 > (\n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil)\n< 1 . 2 . 6 . 6 . (8{1}) . 3 . (9{2}) . 3 . 1 . 1 > (\n:: nil ::\n[ nil | \n   -(#3:Msg), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), nil]  & \n:: nil ::\n[ nil | \n   -(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   +(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n   +(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n#3:Msg !inI,\ne(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) !inI,\ne(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) !inI,\ne(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh)) !inI,\n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) != e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(\n    a, #0:Fresh) ; n(b, #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s,\n    #1:Fresh)))\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \ngeneratedByIntruder(#3:Msg), \n-(#3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n+(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n+(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                105.78698182106018
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/yahalom.spdl",
        "fileto": "PV-1/Yahalom.pv",
        "logicfrom": "---\n\n## Description of the Yahalom Protocol\n\n### Overview\nThe Yahalom protocol is a security protocol designed for secure session key establishment and authentication. It involves three parties: the initiator (I), the responder (R), and a server (S). The protocol aims to ensure that both parties can establish a shared session key while preventing replay attacks and ensuring mutual authentication.\n\n### Participants\n1. **Initiator (I)**: The entity that starts the communication and requests a session key.\n2. **Responder (R)**: The entity that responds to the initiator's request and participates in the session key establishment.\n3. **Server (S)**: The entity that facilitates the communication between the initiator and the responder and can issue tickets.\n\n### Variables\n- **Nonces**: Random values (`Ni` for the initiator and `Nr` for the responder) used to ensure freshness and prevent replay attacks.\n- **Ticket (T)**: A credential issued by the server that contains information about the session and is used to authenticate the participants.\n- **Session Key (Kir)**: A key that is established for secure communication between the initiator and responder.\n\n### Protocol Steps\n1. **Initiator's Step**:\n   - The initiator generates a nonce `Ni` and sends it to the responder (R) along with its identity.\n   - **Message 1**: `I -> R : (I, Ni)`\n\n2. **Responder's Step**:\n   - Upon receiving the message, the responder generates its own nonce `Nr` and creates a ticket `T` for the session.\n   - The responder then sends a message to the server (S) with the initiator's identity, the session key `Kir`, and both nonces, all encrypted with a shared key (`k(R, S)`).\n   - **Message 2**: `R -> S : (R, {I, Ni, Nr}k(R, S))`\n\n3. **Server's Step**:\n   - The server processes the request and sends back a response to the responder containing the session key and a ticket, encrypted with the same shared key.\n   - **Message 3**: `S -> R : {R, Kir, Ni, Nr}k(I, S), T`\n\n4. **Responder's Final Step**:\n   - The responder then forwards the session key to the initiator, sending it alongside `Nr`, both encrypted with the session key `Kir`.\n   - **Message 4**: `R -> I : {I, Kir}k(R, S), {Nr}Kir`\n\n5. **Claims**:\n   - The initiator claims that the session key `Kir` is secret.\n   - The responder claims that the session key `Kir` is also secret.\n   - The server claims the nonces `Ni` and `Nr` are secret.\n\n### Claims\n- **Initiator (I)**: Claims that the session key `Kir` is secret (claim_I1).\n- **Responder (R)**: Claims that the session key `Kir` is secret (claim_R1).\n- **Server (S)**: Claims that both nonces `Ni` and `Nr` are secret.\n\n### Security Goals\nThe Yahalom protocol aims to achieve the following security properties:\n- Mutual authentication between the initiator and responder.\n- Confidentiality of the session key and nonces.\n- Resistance to replay attacks.\n\n### Conclusion\nThe Yahalom protocol effectively establishes a secure session key while ensuring the identities of the parties involved are authenticated. The use of nonces and encryption plays a crucial role in maintaining the security of the communication.\n\n---",
        "codefrom:": "# Yahalom\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/yahalom.html\n#\n#\n\nusertype SessionKey;\n\nprotocol yahalom(I,R,S)\n{\n    role I\n    {\n        fresh Ni: Nonce;\n        var Nr: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        send_1(I,R, I,Ni);\n        recv_3(S,I, {R,Kir,Ni,Nr}k(I,S), T );\n        send_4(I,R, T, {Nr}Kir );\n\n        claim_I1(I, Secret,Kir);\n    }\n\n    role R\n    {\n        fresh Nr: Nonce;\n        var Ni: Nonce;\n        var T: Ticket;\n        var Kir: SessionKey;\n\n        recv_1(I,R, I,Ni);\n        send_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        recv_4(I,R, {I,Kir}k(R,S) , {Nr}Kir );\n\n        claim_R1(R, Secret,Kir);\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var Ni,Nr: Nonce;\n\n        recv_2(R,S, R, {I,Ni,Nr}k(R,S) );\n        send_3(S,I, {R,Kir,Ni,Nr}k(I,S), {I,Kir}k(R,S) );\n\n        claim(S, Secret, Ni);\n        claim(S, Secret, Nr);\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "yahalom",
                        "I",
                        "yahalom,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "yahalom,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "S",
                        "yahalom,S1",
                        "Secret Ni",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "",
                        "yahalom,S2",
                        "Secret Nr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.47480297088623047
            ]
        ]
    },
    {
        "filefrom": "PV-1/Yahalom.pv",
        "fileto": "SPDL-1/yahalom.spdl",
        "logicfrom": "---\n\n### Description of the Yahalom Protocol\n\nThe Yahalom protocol is a cryptographic protocol aimed at establishing secure communication between two parties, referred to as hosts A and B, with the involvement of a server S. The protocol ensures confidentiality and integrity of messages exchanged between the parties using symmetric key encryption.\n\n#### Components\n\n1. **Participants**:\n   - **A**: Initiator (one of the hosts)\n   - **B**: Responder (the other host)\n   - **S**: Server that facilitates the key exchange between A and B.\n\n2. **Keys**:\n   - Each host has a shared key with the server:\n     - `Kas`: Key shared between host A and server S.\n     - `Kbs`: Key shared between host B and server S.\n   - The protocol assumes that keys `Kas` and `Kbs` are secret and not known to the attacker.\n\n3. **Nonces**:\n   - **Na**: A nonce generated by host A.\n   - **Nb**: A nonce generated by host B.\n   - Nonces are used to ensure freshness and prevent replay attacks.\n\n4. **Messages**:\n   The protocol consists of four main messages exchanged between the participants:\n\n   - **Message 1**: Host A sends its identity and nonce to Host B.\n     ```\n     A -> B: A; Na\n     ```\n\n   - **Message 2**: Host B sends its identity and a message encrypted with its shared key with the server S, which contains A's identity, A's nonce, and B's nonce.\n     ```\n     B -> S: B; { A; Na; Nb }Kbs\n     ```\n\n   - **Message 3**: The server S responds to Host A with a message containing Host B's identity, a session key (Kab), and both nonces, encrypted with Host A's shared key with S. It also includes a message for Host B encrypted with Host B's shared key.\n     ```\n     S -> A: { B; Kab; Na; Nb }Kas ; { A; Kab }Kbs\n     ```\n\n   - **Message 4**: Finally, Host A sends a message to Host B, which includes its identity encrypted with the session key, along with B's nonce encrypted with the session key.\n     ```\n     A -> B: { A; Kab }Kbs ; { Nb }Kab\n     ```\n\n#### Protocol Operations\n\n1. **Key Registration**: The protocol allows for the registration of new hosts and their respective keys with the server.\n2. **Session Management**: The protocol supports multiple concurrent sessions through the use of unbounded processes for initiators, responders, and the server.\n\n#### Security Goals\n\n1. **Secrecy**: The protocol aims to keep the secrets (e.g., `secretA` and `secretB`) confidential from potential attackers.\n2. **Non-interference**: The protocol should ensure that the secrets of one host do not interfere with the secrets of another.\n\n#### Assumptions\n\n- The protocol assumes that there is a secure communication channel and that the keys shared between hosts and the server are not compromised.\n- The attacker cannot access the shared keys `Kas` and `Kbs`.\n\n#### Process Definitions\n\n- `processInitiator`: Defines the actions taken by the initiator (Host A).\n- `processResponder`: Defines the actions taken by the responder (Host B).\n- `processS`: Defines the actions taken by the server (S).\n- `processK`: Handles the registration of new keys for new hosts.\n\n#### Execution\n\nThe protocol is initiated with the generation of the keys `Kas` and `Kbs`, followed by the instantiation of the processes for the initiator, responder, server, and key registration.\n\n---",
        "codefrom:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(*\nYahalom protocol. Version of Burrows, Abadi, Needham, SRC039\n\nMessage 1 A -> B: A; Na \nMessage 2 B -> S: B; { A; Na; Nb }Kbs \nMessage 3 S -> A: { B; Kab; Na; Nb }Kas ; { A; Kab }Kbs \nMessage 4 A -> B: { A; Kab }Kbs ; { Nb }Kab\n\n*)\n\nfree c: channel.\n\ntype key.\ntype host.\ntype nonce.\n\nfun nonce_to_bitstring(nonce): bitstring [data,typeConverter].\n\n(* Shared key encryption *)\n\nfun encrypt(bitstring,key): bitstring.\nreduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new Kas).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nfree secretA, secretB: bitstring [private].\nnoninterf secretA, secretB.\nnoninterf secretA.\nnoninterf secretB.\n\n(* Role of the initiator with identity xA and key kas shared with S *)\n\nlet processInitiator =\n        (* The attacker starts the initiator by choosing identity xA.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, xA: host);\n\tif xA = A || xA = B then\n\tget keys(=xA, kas) in\n\t(* Real start of the role *)\n\tnew Na: nonce;\n\tout(c, (xA, Na));\n\tin(c, (cert1: bitstring, cert2: bitstring));\n\tlet (b: host, k: key, =Na, nb: nonce) = decrypt(cert1, kas) in\n\tout(c, (cert2, encrypt(nonce_to_bitstring(nb), k)));\n\t(* OK *)\n\tif b = A || b = B then\n\tout(c, encrypt(secretA, k)).\n\n(* Role of the responder with identity xB and key kbs shared with S *)\n                         \nlet processResponder =\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kbs) in\n\t(* Real start of the role *)\n\tin(c, (a: host, na: nonce));\n\tnew Nb: nonce;\n\tout(c, (xB, encrypt((a, na, Nb), kbs)));\n\tin(c, (cert2: bitstring, m: bitstring));\n\tlet (=a, k: key) = decrypt(cert2, kbs) in\n\tif nonce_to_bitstring(Nb) = decrypt(m, k) then\n\t(* OK *)\n\tif a = A || a = B then\n\tout(c, encrypt(secretB, k)).\n\n(* Server *)\n\nlet processS =\n\tin(c, (h2: host, m: bitstring));\n\tget keys(=h2, k2) in (* get the key of h2 from the key table *)\n\tlet (h1: host, n1: nonce, n2: nonce) = decrypt(m, k2) in\n\tget keys(=h1, k1) in (* get the key of h1 from the key table *)\n\tnew k: key;\n\tout(c, (encrypt((h2, k, n1, n2), k1), encrypt((h1, k), k2))).\n\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB cannot be proved.\nRESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\n0.103s (user 0.095s + system 0.008s), max rss 11800K\nEND *)",
        "resultsfrom": [
            true,
            [
                false,
                "RESULT Non-interference secretA, secretB cannot be proved.\nRESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\n",
                0.11953186988830566
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Yahalom.maude",
        "fileto": "PV-1/Yahalom.pv",
        "logicfrom": "---\n\n### Yahalom Protocol Description\n\nThe Yahalom Protocol is a cryptographic protocol designed for secure authentication and key exchange between two users (Alice and Bob) with the involvement of a trusted server. The protocol utilizes symmetric encryption and nonces to ensure secure communication and prevent replay attacks.\n\n#### Participants:\n- **Alice (A)**: One of the users initiating the communication.\n- **Bob (B)**: The other user involved in the communication.\n- **Server (S)**: A trusted server that facilitates the key exchange.\n\n#### Key Elements:\n- **Keys**: \n  - **Master Keys (mkey)**: Each user has a master key shared with the server.\n  - **Session Keys (seskey)**: The session key is generated for communication between Alice and Bob.\n- **Nonces**: Random values generated by the participants to ensure freshness in the communication.\n\n#### Protocol Steps:\n1. **Alice Initiates Communication**:\n   - Alice generates a nonce (Na) and sends it along with her identifier (A) to Bob.\n   \n2. **Bob Responds with a Message to the Server**:\n   - Bob receives Alice's message and generates a nonce (Nb). He sends a message to the server, which includes Alice's identifier (A), nonce (Na), and his own nonce (Nb) encrypted using the master key shared with Alice.\n   \n3. **Server Responds to Alice**:\n   - The server decrypts Bob's message, verifies it, and generates a session key (SK) for Alice and Bob. The server sends back two encrypted messages: one containing the session key and the nonces, encrypted with Bob's master key, and the other encrypted with Alice's master key.\n   \n4. **Alice Completes the Protocol**:\n   - Alice decrypts the server's response, retrieves the session key and nonces, and sends a confirmation to Bob, encrypted with the session key.\n\n#### Security Features:\n- **Confidentiality**: Messages are encrypted, ensuring that only the intended recipients can read them.\n- **Integrity**: The use of nonces prevents replay attacks by ensuring that each message is fresh and unique.\n- **Authentication**: Both participants can prove their identities by demonstrating knowledge of the shared keys.\n\n### Maude Implementation\n\nIn the Maude implementation:\n- The protocol is defined using sorts for usernames, keys, nonces, and messages.\n- Operations for encryption and decryption are included, as well as the structure of the protocol's communication strands.\n- The protocol's execution is represented through various equations that outline the communication between Alice, Bob, and the server.\n\nThe Maude-NPA module structure includes:\n- A module for symbols defining the sorts and operations used in the protocol.\n- An algebraic module defining properties of encryption and decryption.\n- A specification module that includes the strands of the protocol and the attack state.\n\nThis structured approach allows the Maude-NPA tool to analyze the protocol for potential vulnerabilities and verify its correctness.\n\n---",
        "codefrom:": "---  Yahalom Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg )) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B  : UName .  \n  var r r' r'' r''' r# r## rM : Fresh .\n  var SID : Id .\n  vars NA NB  : Nonce .\n  vars M1 M2 M N MA MB : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(p(M)), +(M), nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n   [nonexec] . \n \n  \n  eq STRANDS-PROTOCOL\n  ---A->B: A,Na\n  ---B->S: B,E(Kbs:A,Na,Nb)\n  ---S->A: E(Kas:B, Kab, Na, Nb), E(Kbs:A, Kab) \n  ---A->B: E(Kbs:A, Kab) E(Kab:Nb)\n   = :: r ::\n --- Alice's Strand\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , B ; SK ; n(A,r) ; NB) ; MB),\n             +(MB ; e(SK , NB)) , nil ]\n   &\n     :: r :: \n ---Bob's Strand    \n     [ nil | -(A ; NA),\n             +(B ; e(mkey(B,s) , A ; NA ; n(B,r))),\n             -(e(mkey(B,s) , A ; SK) ; e(SK , n(B,r))) , nil ] \n   & \n     :: r ::\n---Server's Strand     \n    [ nil |  -(B ; e(mkey(B,s) , A ; NA ; NB)),\n             +( e(mkey(A,s) , B ; seskey(A , B , n(s,r)) ; NA ; NB) \n              ; e(mkey(B,s) , A ; seskey(A , B , n(s,r)))) , nil ] \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n    :: r ::\n--- A normal execution of the protocol\n    [ nil ,  -(a ; NA),\n          \t +(b ; e(mkey(b,s) , a ; NA ; n(b,r))),\n          \t -(e(mkey(b,s) , a ; SK) ; e(SK , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "resultsfrom": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Fri May  2 19:12:32 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 15139949 in 14256ms cpu (14264ms real) (1062005 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(a ; NA:Nonce), \n   +(b ; e(mkey(b, s), a ; NA:Nonce ; n(b, r:Fresh))), \n   -(e(mkey(b, s), a ; SK:Sessionkey) ; e(SK:Sessionkey, n(b, r:Fresh))) | nil]\n    \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 82393020 in 90512ms cpu (90513ms real) (910299 rewrites/second)\nresult IdSystemSet: (< 1 . 5 . 7 . 1 . 1 > (\n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil)\n< 1 . 2 . 6 . 6 . (8{1}) . 3 . (9{2}) . 3 . 1 . 1 > (\n:: nil ::\n[ nil | \n   -(#3:Msg), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), nil]  & \n:: nil ::\n[ nil | \n   -(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n   +(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), nil]  & \n:: nil ::\n[ nil | \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n   +(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #1:Fresh ::\n[ nil | \n   -(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), nil]  & \n:: #2:Fresh ::\n[ nil | \n   -(a ; n(a, #0:Fresh)), \n   +(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n   -(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   +(a ; n(a, #0:Fresh)), \n   -(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n   +(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), nil] )\n|| \n#3:Msg !inI,\ne(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) !inI,\ne(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) !inI,\ne(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh)) !inI,\n(a ; n(a, #0:Fresh)) !inI,\n(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))) !inI,\n(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))) !inI,\n(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))) !inI,\n(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg) != e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(\n    a, #0:Fresh) ; n(b, #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s,\n    #1:Fresh)))\n|| \n+(a ; n(a, #0:Fresh)), \n-(a ; n(a, #0:Fresh)), \n+(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n-(b ; e(mkey(b, s), a ; n(a, #0:Fresh) ; n(b, #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \ngeneratedByIntruder(#3:Msg), \n-(#3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh))), \n+(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; #3:Msg), \n+(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(a, s), b ; seskey(a, b, n(s, #1:Fresh)) ; n(a, #0:Fresh) ; n(b,\n    #2:Fresh)) ; e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n-(#3:Msg ; e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n+(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(seskey(a, b, n(s, #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh)))), \n+(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh))), \n-(e(mkey(b, s), a ; seskey(a, b, n(s, #1:Fresh))) ; e(seskey(a, b, n(s,\n    #1:Fresh)), n(b, #2:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                105.78698182106018
            ]
        ]
    },
    {
        "filefrom": "PV-1/Yahalom.pv",
        "fileto": "MAUDE-1/Yahalom.maude",
        "logicfrom": "---\n\n### Description of the Yahalom Protocol\n\nThe Yahalom protocol is a cryptographic protocol aimed at establishing secure communication between two parties, referred to as hosts A and B, with the involvement of a server S. The protocol ensures confidentiality and integrity of messages exchanged between the parties using symmetric key encryption.\n\n#### Components\n\n1. **Participants**:\n   - **A**: Initiator (one of the hosts)\n   - **B**: Responder (the other host)\n   - **S**: Server that facilitates the key exchange between A and B.\n\n2. **Keys**:\n   - Each host has a shared key with the server:\n     - `Kas`: Key shared between host A and server S.\n     - `Kbs`: Key shared between host B and server S.\n   - The protocol assumes that keys `Kas` and `Kbs` are secret and not known to the attacker.\n\n3. **Nonces**:\n   - **Na**: A nonce generated by host A.\n   - **Nb**: A nonce generated by host B.\n   - Nonces are used to ensure freshness and prevent replay attacks.\n\n4. **Messages**:\n   The protocol consists of four main messages exchanged between the participants:\n\n   - **Message 1**: Host A sends its identity and nonce to Host B.\n     ```\n     A -> B: A; Na\n     ```\n\n   - **Message 2**: Host B sends its identity and a message encrypted with its shared key with the server S, which contains A's identity, A's nonce, and B's nonce.\n     ```\n     B -> S: B; { A; Na; Nb }Kbs\n     ```\n\n   - **Message 3**: The server S responds to Host A with a message containing Host B's identity, a session key (Kab), and both nonces, encrypted with Host A's shared key with S. It also includes a message for Host B encrypted with Host B's shared key.\n     ```\n     S -> A: { B; Kab; Na; Nb }Kas ; { A; Kab }Kbs\n     ```\n\n   - **Message 4**: Finally, Host A sends a message to Host B, which includes its identity encrypted with the session key, along with B's nonce encrypted with the session key.\n     ```\n     A -> B: { A; Kab }Kbs ; { Nb }Kab\n     ```\n\n#### Protocol Operations\n\n1. **Key Registration**: The protocol allows for the registration of new hosts and their respective keys with the server.\n2. **Session Management**: The protocol supports multiple concurrent sessions through the use of unbounded processes for initiators, responders, and the server.\n\n#### Security Goals\n\n1. **Secrecy**: The protocol aims to keep the secrets (e.g., `secretA` and `secretB`) confidential from potential attackers.\n2. **Non-interference**: The protocol should ensure that the secrets of one host do not interfere with the secrets of another.\n\n#### Assumptions\n\n- The protocol assumes that there is a secure communication channel and that the keys shared between hosts and the server are not compromised.\n- The attacker cannot access the shared keys `Kas` and `Kbs`.\n\n#### Process Definitions\n\n- `processInitiator`: Defines the actions taken by the initiator (Host A).\n- `processResponder`: Defines the actions taken by the responder (Host B).\n- `processS`: Defines the actions taken by the server (S).\n- `processK`: Handles the registration of new keys for new hosts.\n\n#### Execution\n\nThe protocol is initiated with the generation of the keys `Kas` and `Kbs`, followed by the instantiation of the processes for the initiator, responder, server, and key registration.\n\n---",
        "codefrom:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(*\nYahalom protocol. Version of Burrows, Abadi, Needham, SRC039\n\nMessage 1 A -> B: A; Na \nMessage 2 B -> S: B; { A; Na; Nb }Kbs \nMessage 3 S -> A: { B; Kab; Na; Nb }Kas ; { A; Kab }Kbs \nMessage 4 A -> B: { A; Kab }Kbs ; { Nb }Kab\n\n*)\n\nfree c: channel.\n\ntype key.\ntype host.\ntype nonce.\n\nfun nonce_to_bitstring(nonce): bitstring [data,typeConverter].\n\n(* Shared key encryption *)\n\nfun encrypt(bitstring,key): bitstring.\nreduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new Kas).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nfree secretA, secretB: bitstring [private].\nnoninterf secretA, secretB.\nnoninterf secretA.\nnoninterf secretB.\n\n(* Role of the initiator with identity xA and key kas shared with S *)\n\nlet processInitiator =\n        (* The attacker starts the initiator by choosing identity xA.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, xA: host);\n\tif xA = A || xA = B then\n\tget keys(=xA, kas) in\n\t(* Real start of the role *)\n\tnew Na: nonce;\n\tout(c, (xA, Na));\n\tin(c, (cert1: bitstring, cert2: bitstring));\n\tlet (b: host, k: key, =Na, nb: nonce) = decrypt(cert1, kas) in\n\tout(c, (cert2, encrypt(nonce_to_bitstring(nb), k)));\n\t(* OK *)\n\tif b = A || b = B then\n\tout(c, encrypt(secretA, k)).\n\n(* Role of the responder with identity xB and key kbs shared with S *)\n                         \nlet processResponder =\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kbs) in\n\t(* Real start of the role *)\n\tin(c, (a: host, na: nonce));\n\tnew Nb: nonce;\n\tout(c, (xB, encrypt((a, na, Nb), kbs)));\n\tin(c, (cert2: bitstring, m: bitstring));\n\tlet (=a, k: key) = decrypt(cert2, kbs) in\n\tif nonce_to_bitstring(Nb) = decrypt(m, k) then\n\t(* OK *)\n\tif a = A || a = B then\n\tout(c, encrypt(secretB, k)).\n\n(* Server *)\n\nlet processS =\n\tin(c, (h2: host, m: bitstring));\n\tget keys(=h2, k2) in (* get the key of h2 from the key table *)\n\tlet (h1: host, n1: nonce, n2: nonce) = decrypt(m, k2) in\n\tget keys(=h1, k1) in (* get the key of h1 from the key table *)\n\tnew k: key;\n\tout(c, (encrypt((h2, k, n1, n2), k1), encrypt((h1, k), k2))).\n\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT Non-interference secretA, secretB cannot be proved.\nRESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\n0.103s (user 0.095s + system 0.008s), max rss 11800K\nEND *)",
        "resultsfrom": [
            true,
            [
                false,
                "RESULT Non-interference secretA, secretB cannot be proved.\nRESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\n",
                0.11953186988830566
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/TLS_Handshake.spthy",
        "fileto": "HLPSL-1/TLS.hlpsl",
        "logicfrom": "---\n\n## TLS Handshake Protocol Description\n\n### Overview\nThe TLS Handshake protocol is a cryptographic protocol that enables secure communication between a client and a server. The handshake process establishes the session keys used for encryption and ensures mutual authentication. This description outlines the critical components, message exchanges, and security properties modeled in Tamarin.\n\n### Components\n1. **Participants**: \n   - Client (C)\n   - Server (S)\n\n2. **Key Material**:\n   - Long-term keys: `ltkA` (long-term key for A), `ltkC` (long-term key for Client), `ltkS` (long-term key for Server).\n   - Public keys: `pk(A)` for each participant.\n   - Session parameters: Nonces `nc` and `ns`, session identifiers `sid`, and pre-master secret `pms`.\n\n### Protocol Steps\n1. **Client Hello**: \n   - The client initiates the handshake by sending its identity, a nonce, a session identifier, and a public certificate to the server.\n   - Message format: `C -> S: <C, nc, sid, pc>`\n\n2. **Server Hello**: \n   - The server responds with its identity, a nonce, a session identifier, and its public certificate.\n   - Message format: `C <- S: <ns, sid, ps>`\n\n3. **Client Key Exchange and Finished**:\n   - The client sends its pre-master secret encrypted with the server's public key, a signed message containing the nonce and session information, and a session message encrypted with the derived client key.\n   - Message format: \n     ```plaintext\n     C -> S:\n     { '31', pms }pk(S),\n     sign{ '32', h('32', ns, S, pms) }pk(C),\n     { '33', sid, PRF(pms, nc, ns), nc, pc, C, ns, ps, S }\n     h('clientKey', nc, ns, PRF(pms, nc, ns))\n     ```\n\n4. **Server Finished**:\n   - The server sends a message containing session information encrypted with the derived server key.\n   - Message format: \n     ```plaintext\n     C <- S:\n     { '4', sid, PRF(pms, nc, ns), nc, pc, C, ns, ps, S }\n     h('serverKey', nc, ns, PRF(pms, nc, ns))\n     ```\n\n### Security Properties\n1. **Session Key Secrecy**: Ensures that the session keys established between the client and server are not compromised by an adversary who has not revealed long-term keys.\n   \n2. **Injective Agreement**: Guarantees that if a participant commits to a session with specific parameters, another participant must also be running a session with the same parameters, or an adversary must have revealed a long-term key.\n\n3. **Session Key Setup**: Demonstrates that it is possible to establish session keys between honest participants without revealing long-term keys.\n\n### Conclusion\nThe TLS Handshake protocol is modeled in Tamarin to verify its security properties and correctness. The model captures both the message flows and the requisite encryption mechanisms, ensuring that the protocol provides strong security guarantees against potential adversaries. \n\n---",
        "codefrom:": "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hashes of the relevant information.\n       Due to our support for composed keys, we do not need any custom\n       axiomatization as Paulson does.\n\n*}\n\nfunctions: PRF/1\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following signature based TLS handshake.\n\n  protocol TLS {\n    1. C -> S: C, nc, sid, pc\n    2. C <- S: ns, sid, ps\n\n    3. C -> S: { '31', pms                     }pk(S) ,\n               sign{ '32', h('32', ns, S, pms) }pk(C) ,\n               { '33', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('clientKey', nc, ns, PRF(pms, nc, ns))\n\n    4. C <- S: { '4', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('serverKey', nc, ns, PRF(pms, nc, ns))\n  }\n*/\n\nrule C_1:\n    [ Fr(~nc)\n    , Fr(~sid)\n    ]\n  --[]->\n    [ Out(\n        <$C, ~nc, ~sid, $pc>\n      )\n    , St_C_1($C, ~nc, ~sid, $pc)\n    ]\n\nrule S_1:\n    [ In(\n        <$C, nc, sid, pc>\n      )\n    , Fr(~ns)\n    ]\n  --[]->\n    [ Out(\n        <$S, ~ns, sid, $ps>\n      )\n    , St_S_1($S, $C, sid, nc, pc, ~ns, $ps)\n    ]\n\nrule C_2:\n  let\n      MS   = PRF(~pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_1(C, nc, sid, pc)\n    , In(\n        <S, ns, sid, ps>\n      )\n    , Fr(~pms)\n    , !Pk(S, pkS)\n    , !Ltk(C, ltkC)\n    ]\n  --[ Running(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        < aenc{ '31', ~pms }pkS\n        , sign{ '32', h('32', ns, S, ~pms) }ltkC\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , St_C_2(S, C, sid, nc, pc, ns, ps, ~pms)\n    ]\n\nrule S_2:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_S_1(S, C, sid, nc, pc, ns, ps)\n    , In(\n        < aenc{ '31', pms }pk(ltkS)\n        , signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , !Pk(C, pkC)\n    , !Ltk(S, ltkS)\n    ]\n    /* Explicit equality check, enforced as part of the property. */\n  --[ Eq(verify(signature, <'32', h('32', ns, S, pms)>, pkC), true )\n    , SessionKeys( S, C, Skey, Ckey )\n    , Running(C, S, <'client', MS, Skey, Ckey>)\n    , Commit(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey\n      )\n    ]\n\nrule C_3:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_2(S, C, sid, nc, pc, ns, ps, pms)\n    , In( senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey )\n    ]\n  --[ Commit(C, S, <'client', MS, Skey, Ckey>)\n    , SessionKeys( S, C, Skey, Ckey )\n    ]->\n    []\n\n\n/* TODO: Also model session-key reveals and adapt security properties. */\n\nrestriction Eq_check_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/* Session key secrecy from the perspective of both the server and the client\n * for both the key of the server and the key of the client. Note that this\n * lemma thus captures four security properties at once. */\nlemma session_key_secrecy:\n     /* It cannot be that */\n   \"not(\n         Ex S C keyS keyC #k.\n           /* somebody claims to have setup session keys, */\n           SessionKeys(S, C, keyS, keyC) @ k\n           /* but the adversary knows one of them */\n         & ( (Ex #i. K(keyS) @ i)\n           | (Ex #i. K(keyC) @ i)\n           )\n           /* without having performed a long-term key reveal. */\n         & not (Ex #r. RevLtk(S) @ r)\n         & not (Ex #r. RevLtk(C) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor peer params #i.\n        Commit(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (Ex #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex actor2 peer2 #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #r. RevLtk(actor) @ r)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n/* Consistency check: ensure that session-keys can be setup between honest\n * agents. */\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* There is a trace satisfying all equality checks */\n     (All x y #i. Eq(x,y) @ i ==> x = y)\n  &  /* Session keys have been setup */\n     (Ex S C keyS keyC #k.  SessionKeys(S, C, keyS, keyC) @ k\n      /* without having performed a long-term key reveal. */\n      & not (Ex #r. RevLtk(S) @ r)\n      & not (Ex #r. RevLtk(C) @ r)\n      )\n   \"\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/TLS_Handshake.spthy\n\n  session_key_secrecy (all-traces): verified (95 steps)\n  injective_agree (all-traces): verified (44 steps)\n  session_key_setup_possible (exists-trace): verified (11 steps)\n\n",
                2.2397873401641846
            ]
        ]
    },
    {
        "filefrom": "HLPSL-1/TLS.hlpsl",
        "fileto": "SPTHY-1/TLS_Handshake.spthy",
        "logicfrom": "### Protocol Description for TLS (Transport Layer Security)\n\n#### Overview\nThe TLS protocol is designed to provide secure communication over a computer network. It ensures privacy, integrity, and authenticity of the data exchanged between two parties, typically referred to as a client (Alice) and a server (Bob). The protocol achieves these goals through cryptographic techniques, including the use of public and private keys, hash functions, and session keys.\n\n#### Roles\n1. **Alice (Client)**: Represents the client in the communication. Alice initiates the connection and sends a start message to the server.\n2. **Bob (Server)**: Represents the server that responds to the client's requests. Bob processes the messages received from Alice and manages the session keys.\n3. **Session Role**: Manages the composition of both Alice and Bob, ensuring the transfer of messages between them.\n4. **Environment Role**: Represents the external environment, including the intruder and the agents. It initializes the protocol and defines the knowledge of the intruder.\n\n#### Protocol Steps\n1. **Initiation**:\n   - Alice starts the protocol by sending a message that includes a nonce (`Na`), a session identifier (`Sid`), and a public key (`Pa`).\n\n2. **Response**:\n   - Upon receiving the start message, Bob generates a nonce (`Nb`) and sends a response back to Alice, which contains the nonce, the session identifier, and the public key encrypted with its own private key.\n\n3. **Key Generation**:\n   - Alice and Bob then generate a pre-master secret (`PMS`) based on their nonces and the public keys exchanged. They also compute session keys (`ClientK` for Alice and `ServerK` for Bob) using a key generation function that combines their identities and the `PMS`.\n\n4. **Message Authentication**:\n   - Both parties send hashed messages to each other, which include the nonces and the session keys, ensuring the authenticity of the communication.\n\n5. **Finished Message**:\n   - Finally, Bob sends a finished message to Alice, indicating that the session is established and secure. This message is also protected using the server's session key.\n   \n#### Security Goals\nThe protocol aims to achieve the following security goals:\n- **Secrecy**: The shared session keys (`sec_clientk` and `sec_serverk`) should remain confidential between Alice and Bob.\n- **Authentication**: Alice should be able to authenticate Bob using nonce `na_nb1`, and Bob should be able to authenticate Alice using nonce `na_nb2`.\n\n#### Intruder Model\nThe environment includes an intruder who has access to certain public keys and can intercept messages. The intruder's knowledge includes the identities and public keys of Alice and Bob, as well as the ability to generate responses based on intercepted messages, but does not have access to the private keys.",
        "codefrom:": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const sec_clientk, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (dy))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Ka, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2 : protocol_id,\n         h, prf, keygen : hash_func,\n         a, b           : agent,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "  SAFE\n",
                    0.17033934593200684
                ]
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/ikev2-mac.spdl",
        "fileto": "HLPSL-1/IKEv2-MAC.hlpsl",
        "logicfrom": "---\n\n### Protocol Description for IKEv2\n\n#### Overview\nThe Internet Key Exchange version 2 (IKEv2) is a protocol used to set up a secure, authenticated communication channel between two parties over an insecure network. This protocol is commonly employed in virtual private networks (VPNs) and involves the exchange of cryptographic keys and security associations (SAs) to ensure confidentiality and integrity of the messages.\n\n#### Roles\nThe protocol consists of three roles:\n1. **DH (Diffie-Hellman Role)**: Responsible for establishing a shared secret using Diffie-Hellman key exchange.\n2. **SWAP (Swap Role)**: Engages in message exchanges that involve key derivation functions and message authentication codes (MACs).\n3. **E (Executability Role)**: Acts as the intermediary that facilitates the communication between the initiator (I) and responder (R).\n\n#### Cryptographic Functions\n- **Hash Functions**: `g`, `h`, `MAC` are used for generating message digests and ensuring data integrity.\n- **Pseudo-Random Function (PRF)** and **Key Derivation Function (KDF)**: Used to derive keys and ensure that the keys are securely generated from the nonces and other parameters exchanged during the protocol.\n\n#### Message Exchanges\n1. **DH Role**:\n   - Sends `DH1`: Involves sending a nonce and a hashed value derived from the other party's nonce and its own.\n   - Receives `DH2`: Receives a similar hashed value from the other party.\n\n2. **SWAP Role**:\n   - Receives `SWAP1`: Accepts a KDF-generated message from the other party.\n   - Sends `SWAP2`: Sends a KDF-generated message back to the other party.\n\n3. **Executability Role (E)**:\n   - Receives `E1`: Receives a message containing initiator and responder identities, along with a MAC that ensures the integrity of the message.\n   - Sends `E2`: Sends a similar message back to the initiator.\n   - Receives `E3`: Accepts a message from the responder and validates its integrity.\n   - Sends `E4`: Sends a message back to the responder.\n\n4. **Initiator Role (I)**:\n   - Sends `1`: Initiator sends its nonce and security association.\n   - Receives `2`: Receives the responder's nonce and security association.\n   - Sends message `3`: Sends a message containing a MAC for integrity and other relevant data.\n   - Receives message `4`: Receives a message containing a MAC from the responder.\n\n5. **Responder Role (R)**:\n   - Receives `1`: Receives the initial message from the initiator.\n   - Sends `2`: Sends the responder's nonce in response.\n   - Receives message `3`: Accepts a message from the initiator and validates its integrity.\n   - Sends message `4`: Sends a message back to the initiator containing a MAC.\n\n#### Claims\n- Both roles (I and R) make claims at various points during the protocol:\n  - **Running**: Indicates that the role is actively participating in the protocol.\n  - **SKR (Session Key Ready)**: Claims that a session key has been successfully established.\n  - **Alive**: Indicates that the role is still operational and has not exited prematurely.\n  - **Weak Agreement**: Claims that both parties have reached a weak agreement on the established keys.\n  - **Commit**: Indicates that both parties have committed to the established session and security parameters.\n\n#### Security Associations\n- The protocol utilizes various security associations (SA1, SA2, SA3) to ensure that the exchanged messages adhere to established security standards.\n\n### Conclusion\nThis description provides a comprehensive overview of the IKEv2 protocol implemented in the provided SPDL file. The interactions between roles, the cryptographic functions used, and the claims made ensure that the protocol maintains a secure and robust communication channel between the parties involved.\n\n---",
        "codefrom:": "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n }\n\n\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector;\nconst O: Number;\nconst SA1 ,SA2, SA3: SecurityAssociation;\nconst TSi, TSr: TrafficSelector;\n\n\n\n\n\n\nprotocol @executability(E) {\n\n\n role E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {R, MAC(k(I,R), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n\n }\n\n\n}\n\n\nprotocol ikev2-mac(I, R)\n{\n\n role I {\n  fresh i, Ni, SPIi: Nonce;\n  var Nr, SPIr: Nonce;\n  var Gr: Ticket;\n\n\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni );\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr );\n\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr);\n  send_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr);\n\n }\n\n role R {\n  fresh r, Nr, SPIr: Nonce;\n  var Ni, SPIi: Nonce;\n  var Gi: Ticket;\n\n\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni );\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr );\n\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr);\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr);\n }\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "ikev2-mac",
                        "I",
                        "ikev2-mac,I2",
                        "SKR KDF(Ni,Nr,h(Gr,i),SPIi,SPIr)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,I3",
                        "Alive",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,I4",
                        "Weakagree",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,I5",
                        "Commit R,Ni,g(i),Nr,Gr,TSi,TSr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "ikev2-mac,R2",
                        "SKR KDF(Ni,Nr,h(Gi,r),SPIi,SPIr)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,R3",
                        "Alive",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,R4",
                        "Weakagree",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "ikev2-mac,R5",
                        "Commit I,Ni,Gi,Nr,g(r),TSi,TSr",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                5.206128358840942
            ]
        ]
    },
    {
        "filefrom": "HLPSL-1/IKEv2-MAC.hlpsl",
        "fileto": "SPDL-1/ikev2-mac.spdl",
        "logicfrom": "### Description of the IKEv2-MAC Protocol\n\n#### Overview\nThe Internet Key Exchange version 2 (IKEv2) is a protocol designed to facilitate mutual authentication and secure key exchange between two parties, typically prior to establishing an IPsec connection. The IKEv2 protocol is capable of implementing various authentication methods; this specific variant, referred to as IKEv2-MAC, employs a Message Authentication Code (MAC) based on a pre-shared key (PSK) that both communicating parties possess. \n\n#### Purpose\nThe primary purpose of the IKEv2-MAC protocol is to establish a secure communication channel between two agents\u2014referred to as Alice and Bob\u2014in a manner that ensures both mutual authentication and the generation of cryptographic keys that will be used for further secure communications. \n\n#### Protocol Structure\nThe IKEv2-MAC protocol operates through two main exchanges:\n\n1. **IKE_SA_INIT**: \n   - In this initial phase, Alice and Bob exchange nonces (random values) and perform a Diffie-Hellman key exchange to establish an initial security association known as the IKE Security Association (IKE_SA). \n   - Alice generates a nonce (Na) and a Diffie-Hellman half key (KEa), while Bob generates his own nonce (Nb) and Diffie-Hellman half key (KEb). \n   - Each party also includes their cryptographic suite offers in the messages they send.\n\n   The exchange can be summarized as follows:\n   - 1. Alice sends: `A -> B: SAa1, KEa, Na`\n   - 2. Bob responds: `B -> A: SAb1, KEb, Nb`\n\n2. **IKE_SA_AUTH**:\n   - In the second phase, the parties authenticate the messages exchanged previously, exchange their identities, and establish the first child security association (CHILD_SA) that will be utilized for securing subsequent IPsec traffic.\n   - Alice constructs an authenticator by hashing the PSK with the exchanged messages and sends it to Bob.\n   - Bob then sends his own response, similarly constructed.\n\n   The messages in this phase are:\n   - 3. Alice sends: `A -> B: {A, AUTHa, SAa2}K`, where `K = H(Na.Nb.SAa1.g^KEa^KEb)` and `AUTHa = F(PSK.SAa1.KEa.Na.Nb)`\n   - 4. Bob responds: `B -> A: {B, AUTHb, SAb2}K`, where `AUTHb = F(PSK.SAa1.KEr.Na.Nb)`\n\n#### Limitations\nThe protocol abstracts certain complexities:\n- It assumes that Alice and Bob negotiate a compatible cryptographic algorithm, which is simplified by modeling that Alice sends a single offer for a cryptographic suite which Bob must accept.\n- Other goals of IKEv2, such as identity hiding, are not considered in this variant.\n- The exchange of traffic selectors, which is specific to IP networking, is also not modeled in this abstract communication framework.\n\n#### Security Considerations\nThe use of MAC-based authentication in IKEv2-MAC mitigates certain types of attacks, including man-in-the-middle attacks, that could occur in other variants of IKEv2. \n\n#### Modeling and Goals\nThe protocol is modeled in a way that supports the following goals:\n- **Secrecy** of the generated session keys (`SK`) that Alice and Bob share.\n- **Authentication** of both parties: Alice authenticates Bob and vice versa.\n\nThe classification of potential issues within this protocol has been identified as G1, G2, G3, G7, G9, G10, and G11, with no identified attacks on the protocol. \n\n### Conclusion\nThe IKEv2-MAC protocol effectively establishes a secure channel between two parties using a pre-shared key for authentication. Through a structured two-phase exchange, it ensures mutual authentication and the establishment of secure keys for subsequent communications, while abstracting away certain complexities in cryptographic negotiations and identity management. \n\nThis description can serve as a basis for generating the corresponding HLPSL file that can be executed by the AVISPA tool for formal verification and analysis.",
        "codefrom:": "%% PROTOCOL*: IKEv2\n%% VARIANT: authentication based on MACs\n%% PURPOSE:\n%% IKE is designed to perform mutual authentication and key\n%% exchange prior to setting up an IPsec connection.\n%% IKEv2 exists in several variants, the defining difference\n%% being the authentication method used.\n%%\n%% This variant, which\n%% we call IKEv2-MAC, is based on exchanging the MAC of a\n%% pre-shared secret that both nodes possess.\n%%\n%% REFERENCE:\n%% \\cite{ipsec-ikev2}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\item Paul Hankes Drielsma, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%% ALICE_BOB:\n%% IKEv2-MAC proceeds in two so-called exchanges.  In the first,\n%% called IKE\\_SA\\_INIT, the users exchange nonces and perform \n%% a Diffie-Hellman exchange, establishing an initial security \n%% association called the IKE\\_SA.  The second exchange,\n%% IKE\\_SA\\_AUTH, then authenticates the previous messages,\n%% exchanges the user identities, and establishes the first \n%% so-called \"child security association\" or CHILD\\_SA which will\n%% be used to secure the subsequent IPsec tunnel.\n%% A (respectively B) generates a nonce Na and a Diffie-Hellman \n%% half key KEa (respectively KEb).  In addition, SAa1 contains A's \n%% cryptosuite offers and SAb1 B's preference for the establishment\n%% of the IKE\\_SA.  Similarly SAa2 and SAb2 for the establishment of \n%% the CHILD\\_SA.  The two parties share a secret in advance, the \n%% so-called PSK or pre-shared key.  The authenticator message is\n%% built by taking a hash of the PSK and the previously exchanged\n%% messages.\n%%\\begin{verbatim}\n%% IKE_SA_INIT\n%% 1. A -> B: SAa1, KEa, Na\n%% 2. B -> A: SAb1, KEb, Nb\n%% IKE_SA_AUTH\n%% 3. A -> B: {A, AUTHa, SAa2}K\n%%    where K = H(Na.Nb.SAa1.g^KEa^KEb) and \n%%      AUTHa = F(PSK.SAa1.KEa.Na.Nb)\n%% 4. B -> A: {B, AUTHb, SAb2}K\n%%    where \n%%      AUTHb = F(PSK.SAa1.KEr.Na.Nb)\n%%\\end{verbatim}\n%% Note that because we abstract away from the negotiation of \n%% cryptographic algorithms, we have SAa1 = SAb1 and \n%% SAa2 = SAb2.  \n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item The parties, Alice and Bob, should negotiate mutually \n%% acceptable cryptographic algorithms.  This we abstract by\n%% modelling that Alice sends only a single offer for a crypto-suite,\n%% and Bob must accept this offer.  We thus assume that goal G11\n%% is fulfilled.\n%%\\item There are goals of IKEv2 which we do not yet consider.  For\n%% instance, identity hiding.\n%%\\item We do not model the exchange of traffic selectors, which\n%% are specific to the IP network model and would be meaningless\n%% in our abstract communication model.\n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G3, G7, G9, G10, G11\n%% ATTACKS: None.  Note that the use of MAC-based authentication\n%% precludes the man-in-the-middle attack that is possible on\n%% the first variant, IKEv2-DS.  \n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole alice(A,B: agent,\n\t   G: text,\n\t   F: hash_func,\n           PSK: symmetric_key,\n\t   SND_B, RCV_B: channel (dy))\nplayed_by A\ndef=\n\n  local Ni, SA1, SA2, DHX: text, \n\tNr: text,\n\tKEr: message, %% more spefic: exp(text,text)\n\tSK: hash(text.text.text.message),\n\tState: nat,\n\tAUTH_B: message\n\n  const sec_a_SK : protocol_id\n\n  init  State := 0\n\n  transition\n\n  %% The IKE_SA_INIT exchange:\n  1. State = 0  /\\ RCV_B(start) =|>\n     State':= 2 /\\ SA1' := new()\n                /\\ DHX' := new()\n                /\\ Ni' := new()\n                /\\ SND_B( SA1'.exp(G,DHX').Ni' )\n\n  %% Alice receives message 2 of IKE_SA_INIT, checks that Bob has\n  %% indeed sent the same nonce in SAr1, and then sends the first \n  %% message of IKE_AUTH.\n  %% As authentication Data, she signs her first message and Bob's nonce.\n  2. State = 2  /\\ RCV_B(SA1.KEr'.Nr') =|>\n     State':= 4 /\\ SA2' := new()\n                /\\ SK' := F(Ni.Nr'.SA1.exp(KEr',DHX))\n                /\\ SND_B( {A.F(PSK.SA1.exp(G,DHX).Ni.Nr').SA2'}_SK' )\n                /\\ witness(A,B,sk2,F(Ni.Nr'.SA1.exp(KEr',DHX)))\n\n  3. State = 4  /\\ RCV_B({B.F(PSK.SA1.KEr.Ni.Nr).SA2}_SK) =|>\n     State':= 6 /\\ AUTH_B' := F(PSK.SA1.KEr.Ni.Nr)\n                /\\ secret(SK,sec_a_SK,{A,B})\n                /\\ request(A,B,sk1,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole bob(B,A:agent,\n\t     G: text,\n\t     F: hash_func,\n\t     PSK: symmetric_key,\n\t     SND_A, RCV_A: channel (dy))\nplayed_by B\ndef=\n\n  local Ni, SA1, SA2: text, \n\tNr, DHY: text,\n\tSK: hash(text.text.text.message),\n\tKEi: message,\n\tState: nat,\n\tAUTH_A: message\n\n  const sec_b_SK : protocol_id\n\n  init  State := 1\n\n  transition\n\n  1. State = 1 /\\ RCV_A( SA1'.KEi'.Ni' ) =|>\n     State':=3 /\\ DHY' := new()\n               /\\ Nr' := new()\n               /\\ SND_A(SA1'.exp(G,DHY').Nr')\n               /\\ SK' := F(Ni'.Nr'.SA1'.exp(KEi',DHY'))\n\n  2. State = 3 /\\ RCV_A( {A.F(PSK.SA1.KEi.Ni.Nr).SA2'}_SK ) =|>\n     State':=5 /\\ SND_A( {B.F(PSK.SA1.exp(G,DHY).Ni.Nr).SA2'}_SK )\n               /\\ AUTH_A' := F(PSK.SA1.KEi.Ni.Nr)\n               /\\ witness(B,A,sk1,SK)\n               /\\ secret(SK,sec_b_SK,{A,B})\n               /\\ request(B,A,sk2,SK)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole session(A, B: agent,\n\t     PSK: symmetric_key,\n\t     G: text,\n             F: hash_func)\ndef=\n\n  local SA, RA, SB, RB: channel (dy)\n\n  composition\n\n\t   alice(A,B,G,F,PSK,SA,RA)\n\t/\\ bob(B,A,G,F,PSK,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nrole environment()\ndef=\n \n  const sk1, sk2      : protocol_id,\n        a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        g             : text, \n\tf             : hash_func\n\n  intruder_knowledge = {g,f,a,b,i,kai,kbi\n                       }\n\n  composition\n\n\tsession(a,b,kab,g,f)\n     /\\ session(a,i,kai,g,f)\n     /\\\tsession(i,b,kbi,g,f)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\ngoal  \t\n  %secrecy_of SK\n  secrecy_of sec_a_SK, sec_b_SK % Addresses G9\n\n  %Alice authenticates Bob on sk1\n  authentication_on sk1 % Addresses G1, G2, G3, G7, G10\n  %Bob authenticates Alice on sk2\n  authentication_on sk2 % Addresses G1, G2, G3, G7, G10\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n\nenvironment()",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "  SAFE\n",
                    1.692772626876831
                ]
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/kerberos-rddm.spdl",
        "fileto": "HLPSL-1/Kerberos.hlpsl",
        "logicfrom": "---\n\n**Kerberos Protocol Description**\n\nThe Kerberos protocol, as outlined in the provided SPDL file, is designed to facilitate secure communication between a client (C), a key distribution center (K), a service ticket granting server (T), and a service provider (S). The protocol employs session keys to ensure confidentiality and authentication between the involved parties.\n\n### Roles:\n\n1. **Client (C)**: \n   The client initiates the communication by sending a request to the key distribution center (K) for a ticket granting ticket (TGT). Upon receiving the TGT and session keys, the client uses them to request access to a service from the server (S).\n\n2. **Key Distribution Center (K)**: \n   The key distribution center is responsible for issuing session keys. It receives requests from the client, verifies them, and responds with session keys and a ticket that the client can use to access services.\n\n3. **Ticket Granting Server (T)**: \n   The ticket granting server validates the tickets presented by the client and issues service tickets that allow the client to access specific services.\n\n4. **Service Provider (S)**: \n   The service provider receives requests from the client and responds based on the validity of the service tickets presented.\n\n### Protocol Steps:\n\n1. **Initial Request**: \n   The client (C) sends a message to the key distribution center (K) requesting access to a service (T) along with a nonce (n1) to ensure freshness.\n\n2. **Ticket Granting**: \n   The key distribution center (K) responds with a ticket granting ticket (TGT) and a session key (AKey) encrypted with the client's key (kck). This message also includes the nonce (n1) for verification.\n\n3. **Service Request**: \n   The client (C) sends the TGT to the ticket granting server (T) along with another nonce (n2) and its identity, encrypted with the session key (AKey).\n\n4. **Service Response**: \n   The ticket granting server (T) responds with a service ticket (st) and the session key (SKey) encrypted with the session key (AKey) and the nonce (n2).\n\n5. **Final Service Access**: \n   The client (C) sends the service ticket (st) to the service provider (S) along with a text message (t) encrypted with the service session key (SKey).\n\n6. **Service Confirmation**: \n   The service provider (S) responds back to the client (C) with the encrypted message (t), confirming access to the requested service.\n\n### Claims:\n\n- **Claim 1**: If both the client (C) and the key distribution center (K) are honest, the communication is reachable.\n- **Claim 2**: If the client (C), key distribution center (K), and ticket granting server (T) are honest, the session key (AKey) remains confidential.\n- **Claim 3**: If the client (C), key distribution center (K), and service provider (S) are honest, the communication is reachable.\n- **Claim 4**: If the client (C), key distribution center (K), and service provider (S) are honest, the service session key (SKey) remains confidential.\n- **Additional Claims**: The ticket granting server (T) also makes claims about the security of the session key (AKey) and the service key (SKey).\n\n### Security Properties:\nThe protocol ensures that:\n- Only authenticated clients can access services.\n- Session keys are generated fresh for each session, preventing replay attacks.\n- Confidentiality of messages is maintained through encryption using session keys.\n\n### Conclusion:\nThe Kerberos protocol implemented in this SPDL file provides a robust framework for secure authentication and communication between a client and service providers, ensuring that sensitive information remains protected throughout the interaction.\n\n---",
        "codefrom:": "/*\n * Scyther description of Kerberos as in RDDM'07\n *\n */\n\nusertype Sessionkey;\nusertype Text;\nsecret ktk: Function;\nsecret kck: Function;\nsecret kst: Function;\n\nprotocol @swapkey-ktk(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}ktk(I,R));\n        send_!X2(I,R,{T}ktk(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kck(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}kck(I,R));\n        send_!X2(I,R,{T}kck(R,I));\n    }\n    role R\n    {\n    }\n}\nprotocol @swapkey-kst(I,R)\n{\n    # Protocol added to work around the symmetry problems where k(I,R) != k(R,I)\n    role I\n    {\n        var T:Ticket;\n\n\n        recv_!X1(R,I,{T}kst(I,R));\n        send_!X2(I,R,{T}kst(R,I));\n    }\n    role R\n    {\n    }\n}\n\nprotocol kerberos(C,K,T,S) {\n\n\trole C {\n\t\tfresh n1: Nonce;\n\t\tfresh n2: Nonce;\n\t\tvar tgt: Ticket;\n\t\tvar st: Ticket;\n\t\tvar AKey: Sessionkey;\n\t\tvar SKey: Sessionkey;\n\t\tfresh t: Text;\n\n\t\tsend_1(C,K, C,T,n1);\n\t\trecv_2(K,C, tgt, { AKey,n1,T }kck(C,K) );\n\n\t\t// Stage boundary\n\t\t\n\t\tsend_3(C,T, tgt, { C }AKey,C,S,n2 );\n\t\trecv_4(T,C, C, st, { SKey, n2, S }AKey );\n\t\t\n\t\t// Stage boundary\n\t\t\n\t\tsend_5(C,S, st, { C,t }SKey );\n\t\trecv_6(S,C, { t }SKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(C,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(C,Secret,AKey);\n\t\t// Theorem 7 (a)\n\t\t// If C,K,S are all honest\n\t\tclaim(C, Reachable);\n\t\t// Theorem 8\n\t\t// If C,K,S are all honest\n                claim(C, Secret, SKey);\n\t}\n\trole K {\n\t\tvar n1: Nonce;\n\t\tfresh AKey: Sessionkey;\n\n\t\trecv_1(C,K, C,T,n1);\n\t\tsend_2(K,C, { AKey, C }ktk(T,K), { AKey,n1,T }kck(C,K) );\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim_K1(K,Secret,AKey);\n\t}\n\n\trole T {\n\t\tvar AKey: Sessionkey;\n\t\tvar n2: Nonce;\n\t\tfresh SKey: Sessionkey;\n\n\t\trecv_3(C,T, { AKey, C }ktk(T,K), { C }AKey,C,S,n2 );\n\t\tsend_4(T,C, C,{ SKey, C }kst(S,T), { SKey, n2, S }AKey );\n\n\t\t// Theorem 5 (a)\n                // If C,K are honest\n                claim(T,Reachable);\n\t\t// Theorem 6 (a)\n\t\t// If C,K,T are all honest\n\t\tclaim(T,Secret,AKey);\n\n\t\t// My own\n\t\tclaim(T,Secret,SKey);\n\t}\n\trole S {\n\t\tvar t: Text;\n\t\tvar SKey: Sessionkey;\n\n\t\trecv_5(C,S, { SKey, C }kst(S,T), { C,t }SKey );\n\t\tsend_6(S,C, { t }SKey );\n\t\t// Theorem 7 (b)\n\t\t// If C,K,S,T are honest\n\t\tclaim(S, Reachable);\n\n\t\t// My own\n\t\tclaim(S, Secret, t);\n\t\tclaim(S, Secret, SKey);\n\t}\n}\n\nconst Alice,Bob,Charlie,Eve: Agent;\n\n// C untrusted\n\n// K untrusted\n\n// T untrusted\n\n// S untrusted",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "kerberos",
                        "C",
                        "kerberos,C1",
                        "Reachable",
                        "OK",
                        "Verified",
                        "At least 1 trace pattern.",
                        1,
                        "trace pattern"
                    ],
                    [
                        "",
                        "",
                        "kerberos,C2",
                        "Secret AKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "kerberos,C3",
                        "Reachable",
                        "OK",
                        "Verified",
                        "At least 1 trace pattern.",
                        1,
                        "trace pattern"
                    ],
                    [
                        "",
                        "",
                        "kerberos,C4",
                        "Secret SKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "K",
                        "kerberos,K1",
                        "Secret AKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "T",
                        "kerberos,T1",
                        "Reachable",
                        "OK",
                        "Verified",
                        "At least 1 trace pattern.",
                        1,
                        "trace pattern"
                    ],
                    [
                        "",
                        "",
                        "kerberos,T2",
                        "Secret AKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "kerberos,T3",
                        "Secret SKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "S",
                        "kerberos,S1",
                        "Reachable",
                        "OK",
                        "Verified",
                        "At least 1 trace pattern.",
                        1,
                        "trace pattern"
                    ],
                    [
                        "",
                        "",
                        "kerberos,S2",
                        "Secret t",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "kerberos,S3",
                        "Secret SKey",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                23.344940662384033
            ]
        ]
    },
    {
        "filefrom": "HLPSL-1/Kerberos.hlpsl",
        "fileto": "SPDL-1/kerberos-rddm.spdl",
        "logicfrom": "### Description of the Kerberos Network Authentication Service (V5)\n\n#### Overview\nKerberos is a network authentication protocol designed to provide secure authentication, authorization, and key exchange across insecure networks. It employs a trusted third-party approach, where a client (representing a user) can prove its identity to a server (an application or service) without the need to transmit sensitive information that could be intercepted by attackers. The protocol ensures that even if the communication is intercepted, it does not compromise the user's credentials.\n\n#### Components\n- **Client (C)**: The entity (user or application) that seeks to authenticate itself to the server.\n- **Authentication Server (A)**: The server that verifies the client's identity and provides it with credentials to access the Ticket Granting Server (TGS).\n- **Ticket Granting Server (G)**: This server issues tickets that the client can use to request access to specific services on the network.\n- **Server (S)**: The application server that the client wants to communicate with after authentication.\n\n#### Keys\n- **K_AB**: Shared or intended shared key between the Authentication Server and the principal (client).\n- **K_CA**: Key shared between the client and the authentication server.\n- **K_AG**: Key shared between the authentication server and the ticket granting server.\n- **K_GS**: Key shared between the ticket granting server and the service server.\n- **K_CG**: Key established during the protocol for communication between the client and the ticket granting server.\n- **K_CS**: Key established for communication between the client and the server.\n\n#### Protocol Steps\n1. The **client (C)** sends a request to the **authentication server (A)**, including the desired service (G), the requested lifetime for the ticket, and a nonce (N1) for freshness.\n2. The **authentication server (A)** responds to the client with a ticket (Ticket_1) for the ticket granting server and a session key (K_CG), encrypted with the client\u2019s key (K_CA).\n3. The client then forwards the received ticket along with a request for the desired server (S) to the **ticket granting server (G)**, including a nonce (N2) for freshness.\n4. The **ticket granting server (G)** verifies the request and responds with a ticket for the desired service (Ticket_2) and a session key (K_CS), encrypted with the key shared between the TGS and the service server (K_GS).\n5. The client sends the ticket for the service (Ticket_2) and a request to the **server (S)**.\n6. The server responds to the client with a confirmation message, completing the authentication process.\n\n#### Limitations\nThe protocol does not implement ticket caching, which could potentially lead to weaknesses in authentication. Some implementations may not perform ticket caching as expected.\n\n#### Agents Involved\n- **Client (C)**\n- **Authentication Server (A)**\n- **Ticket Granting Server (G)**\n- **Service Server (S)**\n\n#### Goals of the Protocol\nThe key goals of the Kerberos protocol include:\n- Ensuring the secrecy of session keys (K_CG and K_CS) shared between the client and the servers.\n- Providing weak authentication guarantees, which verify that the client, authentication server, ticket granting server, and service server recognize each other during the authentication process.\n\n#### Security Objectives\n- Secrecy of the keys used in the authentication process.\n- Weak authentication of the involved parties, ensuring that each server can ascertain the authenticity of the client and vice versa.\n\n### Reference\nFor additional details on Kerberos, refer to the IETF draft: [Kerberos Clarifications](http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt).\n\n### Modelers\nThe protocol was initially modeled by:\n- Haykal Tej, Siemens CT IC 3, 2003\n- Sebastian M\u00f6dersheim, Computer Security Group, ETH Z\u00fcrich, January 2004\n- The AVISPA team (since then)",
        "codefrom:": "%% PROTOCOL: Kerberos Network Authentication Service (V5)\n%% VARIANT: basic (core)\n%% PURPOSE: Authentication, Authorisation, Key Exchange\n%%\n%% Kerberos is a distributed authentication service that allows a process\n%% (a client) running on behalf of a principal (a user) to prove its identity\n%% to a verifier (an application server, or just server) without sending data\n%% across the network that might allow an attacker or the verifier to\n%% subsequently impersonate the principal. Kerberos optionally provides\n%% integrity and confidentiality for data sent between the client and server.\n%% \n%% REFERENCE: \n%%\\begin{itemize}\n%%\\item \\url{http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt}\n%%\\end{itemize}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M\\\"odersheim, Computer Security Group,\n%%\tETH Z\\\"{u}rich, January 2004\n%%   \\item AVISPA team (since then)\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% C: Client\n%% A: Authentication Server\n%% G: Ticket Granting Server\n%% S: Server (that the client wants to talk to)\n%%\n%% K_AB: key shared or intended to be shared between A and B\n%%       Initially shared: K_CA, K_AG, K_GS\n%%       Established during protocol: K_CG, K_CS\n%%\n%% All things marked * are timestamp-related and will be simply replaced\n%% with fresh text. \n%% \n%% Macros:\n%% Ticket_1 := { C,G, K_CG, Tstart*, Texpire* }K_AG\n%% Ticket_2 := { C,S, K_CS, Tstart2*, Texpire2* }K_GS\n%%\n%% 1. C -> A : C,G,Lifetime_1*,N_1\n%% 2. A -> C : C, Ticket_1, { G, K_CG, Tstart*, Texpire*, N_1 }K_CA\n%%\n%% 3. C -> G : S,Lifetime_2*,N_2,Ticket_1, { C,T* }K_CG\n%% 4. G -> C : C, Ticket_2, { S, K_CS, Tstart2*, Texpire2*, N_2 }K_CG\n%%\n%% 5. C -> S : Ticket_2, { C, T2* }K_CS\n%% 6. S -> C : { T2* }K_CS\n%%\\end{verbatim}\n%%\n%% LIMITATIONS: \n%% \n%% Ticket Caching is not performed, so only weak authentication is provided.\n%% It is rumoured that implementations do not perform ticket caching.\n%%\n%% PROBLEMS: 8\n%% ATTACKS: None\n%% \n%% NOTES: \n%%\n%% Agents involved: Client,  Authentication Server (AS), Ticket Granting server \n%% (TGS),  Server where the client needs to authenticate (Server) \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\n% Authentication Server\nrole kerberos_A (A, C, G : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA, K_AG : symmetric_key)\nplayed_by A\ndef=\n\n  local St              : nat,\n        K_CG            : symmetric_key,\n        N1, Lifetime_1  : text,\n        Tstart, Texpire : text\n\n  const k_cg : protocol_id,\n        sec_a_K_CG : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(C.G.Lifetime_1'.N1') =|> \n      St':= 1 /\\ Tstart' := new()\n              /\\ Texpire' := new()\n              /\\ K_CG' := new()\n              /\\ Snd(C.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.\n\t                {G.K_CG'.Tstart'.Texpire'.N1'}_K_CA) \n\t      /\\ witness(A,C,k_cg,K_CG')\n\t      /\\ witness(A,G,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_a_K_CG,{A,C,G})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Ticket Granting Server\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local St                                 : nat,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2 : text,\n        Tstart2, Texpire2                  : text\n\n  const t1,k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 Snd, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2a, t2b : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2a,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2a\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "  SAFE\n",
                    0.5766615867614746
                ]
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/NAXOS.spdl",
        "fileto": "SPTHY-1/ake_NAXOS.spthy",
        "logicfrom": "The NAXOS Authenticated Key Exchange (AKE) protocol is a cryptographic protocol designed to establish a shared secret key between two parties, referred to as the initiator (I) and the responder (R). This protocol is modeled after the ideas presented in \"Stronger Security of Authenticated Key Exchange\" by LaMacchia, Lauter, and Mityagin. \n\n### Description of the Protocol\n\n1. **Purpose**:\n   The primary goal of the NAXOS protocol is to securely exchange keys between two parties while providing mutual authentication. It ensures that both parties can verify each other's identity and agree on a shared session key.\n\n2. **Roles**:\n   - **Initiator (I)**: The party that starts the key exchange process.\n   - **Responder (R)**: The party that responds to the initiator's request.\n\n3. **Key Components**:\n   - **Nonces**: Freshly generated random values used to ensure the freshness of the session and to prevent replay attacks.\n   - **Tickets**: Used to carry relevant information during the exchange.\n   - **Hash Functions (h1, h2)**: Cryptographic hash functions used to ensure data integrity and authenticity.\n   - **Exponentiation Function (p)**: A one-way function used in the protocol that simulates the properties of exponentiation.\n\n4. **Protocol Flow**:\n   - The initiator generates a nonce (`eskI`) and computes a value using its secret key and the provided generator `g`. It sends this computed value to the responder.\n   - The responder receives the value, computes its own nonce (`eskR`), and sends back a computed value using its secret key.\n   - Both parties generate a shared session key based on the received messages and their own secret keys, which they can later use for secure communication.\n\n5. **Claims**:\n   - Both I and R make claims about the established session key, which involves hashing various components to ensure that the key is derived correctly and securely.\n\n6. **Security Considerations**:\n   - The protocol is designed to resist various attacks, including state-reveal attacks against both the initiator and responder roles. \n   - It accounts for the possibility of message interception or replay attacks by incorporating nonces and hash functions.\n\n7. **Helper Protocols**:\n   - The protocol makes use of helper protocols that define the public knowledge of public keys and the properties of exponentiation, ensuring that the protocol can leverage these aspects without compromising security.\n\n### Summary\nThe NAXOS AKE protocol provides a robust framework for secure key exchange, ensuring authenticity and confidentiality. It utilizes cryptographic primitives such as hash functions and one-way functions to create a secure communication channel between two parties. The careful design of the message flow and the incorporation of nonces and claims help to mitigate potential security risks.\n\nThis description can be utilized to create or modify the corresponding SPDL (Scyther Protocol Description Language) file for the NAXOS protocol, allowing for formal analysis and verification of its security properties using the Scyther tool.",
        "codefrom:": "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "naxos",
                        "I",
                        "naxos,I1",
                        "SKR h2(p(Y,sk(I)),p(p(g,sk(R)),h1(eskI,sk(I))),p(Y,h1(eskI,sk(I))),I,R)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "naxos,R4",
                        "SKR h2(p(p(g,sk(I)),h1(eskR,sk(R))),p(X,sk(R)),p(X,h1(eskR,sk(R))),I,R)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                22.14284372329712
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/ake_NAXOS.spthy",
        "fileto": "SPDL-1/NAXOS.spdl",
        "logicfrom": "---\n\n### Protocol Description: NAXOS\n\n#### Overview\nThe NAXOS protocol is an authenticated key exchange protocol designed to ensure that the keys used for communication are indistinguishable from random values. This property is crucial for maintaining the confidentiality and integrity of the exchanged keys, thus providing a secure channel for communication between parties.\n\n#### Authors and Source\n- **Modelers:** Jannik Dreier, Ralf Sasse\n- **Trace-Version Contributors:** Cas Cremers, Benedikt Schmidt\n- **Date:** January 2012 / April 2012\n- **Source:** \"Stronger Security of Authenticated Key Exchange\" by LaMacchia, Lauter, Mityagin, 2007\n\n#### Security Properties\nThe NAXOS protocol aims to achieve the following security properties:\n- **Key Indistinguishability from Randomness:** The keys generated during the exchange should not be distinguishable from random values, ensuring their secrecy and security.\n- **Perfect Forward Secrecy (PFS):** Even if a long-term key is compromised in the future, past session keys remain secure.\n\n#### Protocol Steps\n1. **Key Generation:**\n   - Each party generates a long-term key pair consisting of a private key (lk) and a corresponding public key (pk).\n   - The public key is derived from the private key using a generator `g`.\n\n2. **Initiator's Actions:**\n   - The initiator (I) generates an ephemeral secret key (eskI) and computes a hash value (exI) using a function `h1`.\n   - The initiator sends an initial message containing its ephemeral key and public key to the responder (R).\n\n3. **Responder's Actions:**\n   - Upon receiving the initiator's message, the responder (R) also generates its ephemeral secret key (eskR) and computes a corresponding hash (exR).\n   - The responder then computes a session key (kR) based on received values and sends back a response.\n\n4. **Session Key Establishment:**\n   - Both the initiator and responder compute their respective session keys (kI and kR) using hash functions (h2) based on exchanged values.\n   - The keys are registered for future use in secure communication.\n\n#### Rules and Constraints\n- **Long-term Key Pair Generation:** Each party generates a long-term key pair and registers their public keys.\n- **Session Management:** The initiator and responder keep track of session identifiers to match and verify the sessions.\n- **Restrictions:** The protocol ensures that each party registers at most one public key, preventing key collisions.\n\n#### Security Lemmas\n- **Session Key Consistency Lemma:** If two matching sessions accept different keys, it violates the security of the protocol.\n- **Forward Secrecy Lemma:** If a test session is compromised, certain conditions must be met regarding key reveals to maintain security.\n\n---",
        "codefrom:": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* Responder */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n/*\nlemma eCK_PFS_key_secrecy:\n  /* \n   * The property specification very closely follows the original eCK\n   * (ProvSec) paper:\n   *\n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/ake_NAXOS.spthy\n\n",
                0.4244534969329834
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/nsl3.spdl",
        "fileto": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "logicfrom": "The Needham-Schroeder-Lowe protocol is a cryptographic protocol designed for secure communication between two parties, typically referred to as initiator (I) and responder (R). The protocol employs public key cryptography to establish a shared secret communication channel while providing authentication and ensuring that both parties agree on the session parameters.\n\n### Protocol Description\n\nThe protocol operates as follows:\n\n1. **Initialization**: The initiator (I) generates a fresh nonce `ni` to ensure the uniqueness of the session. The responder (R) generates its own fresh nonce `nr`.\n\n2. **Step 1**: The initiator sends a message to the responder that contains its identity `I` and the nonce `ni`, encrypted with the public key of the responder (`pk(R)`). This serves as an initial request to establish a secure session.\n\n   - **Message format**: `{I, ni}pk(R)`\n\n3. **Step 2**: Upon receiving the first message, the responder (R) decrypts the message to reveal the initiator's identity and the nonce `ni`. The responder then prepares a response message that includes the nonce `ni`, its own nonce `nr`, and its identity `R`, all encrypted with the public key of the initiator (`pk(I)`).\n\n   - **Message format**: `{ni, nr, R}pk(I)`\n\n4. **Step 3**: The initiator receives the second message from the responder. It decrypts the message to retrieve the nonces and the responder's identity. Subsequently, the initiator sends a message back to the responder containing the nonce `nr`, encrypted with the responder's public key (`pk(R)`).\n\n   - **Message format**: `{nr}pk(R)`\n\n5. **Claims**: Throughout the protocol, each party makes claims about the secrets and agreements established during the exchange:\n   - The initiator claims that `ni` is a secret, `nr` is a secret, and asserts that both parties agree on the session parameters (`Niagree`) and are synchronized (`Nisynch`).\n   - The responder makes similar claims about `ni`, `nr`, and the agreement and synchronization with the initiator.\n\n### Key Properties\n- **Authentication**: Each party verifies the identity of the other through the exchange of encrypted messages.\n- **Confidentiality**: The use of public key encryption ensures that only the intended recipient can decrypt the messages.\n- **Freshness**: The nonces ensure that each session is unique, preventing replay attacks.\n\n### Conclusion\nThe Needham-Schroeder-Lowe protocol is a foundational example in the study of cryptographic protocols, illustrating key concepts of authentication, confidentiality, and the importance of nonce generation in securing communication channels.\n\nThis description encapsulates the protocol's flow and properties, which can serve as a basis for generating the corresponding SPDL file that can be executed by the Scyther tool.",
        "codefrom:": "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "nsl3",
                        "I",
                        "nsl3,i1",
                        "Secret ni",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,i2",
                        "Secret nr",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,i3",
                        "Niagree",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,i4",
                        "Nisynch",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "nsl3,r1",
                        "Secret ni",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,r2",
                        "Secret nr",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,r3",
                        "Niagree",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "nsl3,r4",
                        "Nisynch",
                        "OK",
                        "Verified",
                        "No attacks.",
                        0,
                        ""
                    ]
                ],
                0.22157740592956543
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "fileto": "SPDL-1/nsl3.spdl",
        "logicfrom": "---\n\n### Nedham-Schroeder-Lowe Modified Protocol Description\n\n**Protocol Overview:**\nThe Nedham-Schroeder-Lowe Modified Protocol is a cryptographic protocol designed for secure communication between two parties, Alice (A) and Bob (B), with provisions for nonce generation to prevent replay attacks. The protocol utilizes public-key cryptography for secure message exchanges.\n\n**Participants:**\n- **Alice (A)**: Initiator of the communication.\n- **Bob (B)**: Respondent who receives the initial message from Alice.\n- **Intruder (i)**: An adversary that may attempt to intercept or manipulate the messages exchanged between Alice and Bob.\n\n**Message Structure:**\n- The messages exchanged in the protocol are encrypted using the public keys of the intended recipients:\n  - `pk(B, A ; N_A)` denotes a message encrypted with Bob's public key, containing Alice's identity and a nonce `N_A`.\n  - `pk(A, N_A ; N_B ; B)` denotes a response message encrypted with Alice's public key, containing the nonce `N_A`, a newly generated nonce `N_B`, and Bob's identity.\n  - `pk(B, N_B)` denotes the final message sent by Alice to Bob, containing the nonce `N_B`, encrypted with Bob's public key.\n\n**Nonces:**\n- **N_A**: A nonce generated by Alice.\n- **N_B**: A nonce generated by Bob in response to Alice's initial message. Nonces are crucial for ensuring that each session of communication is unique and helps prevent replay attacks.\n\n**Encryption Scheme:**\n- The protocol employs public-key encryption (denoted by `pk`) and private-key decryption (denoted by `sk`). The following algebraic properties hold:\n  - `pk(K, sk(K, M)) = M`: Decrypting a message M encrypted with a key K using the corresponding private key returns the original message.\n  - `sk(K, pk(K, M)) = M`: Encrypting a message M with a key K and then decrypting it with the same key returns the original message.\n\n**Protocol Steps:**\n1. **Initiation**:\n   - Alice generates a nonce `N_A` and sends the message `pk(B, A ; N_A)` to Bob.\n2. **Response**:\n   - Bob receives Alice's message, decrypts it using his private key, and generates a nonce `N_B`. He then sends the message `pk(A, N_A ; N_B ; B)` back to Alice.\n3. **Completion**:\n   - Alice receives Bob's message, decrypts it using her private key, and sends back the message `pk(B, N_B)` to Bob, confirming the successful exchange of nonces.\n\n**Security Goals:**\n- The protocol aims to achieve mutual authentication between Alice and Bob while ensuring confidentiality through encryption.\n- The use of nonces in the protocol helps to prevent replay attacks and ensures freshness of the messages.\n\n**Intruder Model:**\n- The protocol is designed with the assumption that an intruder may attempt to intercept and manipulate the messages. The defined strands in the protocol specification correspond to both legitimate communication and potential attack scenarios.\n\n---",
        "codefrom:": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "resultsfrom": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:51 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 4806911 in 4896ms cpu (4894ms real) (981803 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(pk(b, a ; N:Nonce)), \n   +(pk(a, N:Nonce ; n(b, r:Fresh) ; b)), \n   -(pk(b, n(b, r:Fresh))) | nil] \n|| \nn(b, r:Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 7440742 in 9096ms cpu (9096ms real) (818023 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                14.922515392303467
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/Signed-DH.spdl",
        "fileto": "SPTHY-1/signed_dh.spthy",
        "logicfrom": "To generate a description content for the given SPDL file of a protocol, we will outline the key elements and operations of the Two-move Diffie-Hellman protocol as implemented in the provided SPDL content.\n\n---\n\n### Protocol Description: Two-move Diffie-Hellman in the Universal Model (UM)\n\n**Overview:**\nThe Two-move Diffie-Hellman (DH) protocol enables two parties, identified as initiator (I) and responder (R), to establish a shared secret key in a secure manner. The protocol is structured in two main communication phases, utilizing nonce values and a series of cryptographic operations to ensure confidentiality and authenticity.\n\n**Roles:**\n1. **Initiator (I)**:\n   - The initiator generates two fresh nonce values, `s` and `x`, which are unique for each execution of the protocol. \n   - The initiator sends a message to the responder containing its identity, the nonce `s`, and a computed value `g1(x)`.\n   - Upon receiving a response from the responder, which includes a ticket (`beta`), the initiator sends a final message encapsulating its identity, nonce `s`, and a signed message that includes its identity and the received ticket.\n   - Finally, the initiator claims the secret key (`SKR`) derived from the responder\u2019s ticket (`beta`) and its own nonce (`x`).\n\n2. **Responder (R)**:\n   - The responder generates a fresh nonce `y` for its part in the exchange.\n   - It receives the initial message from the initiator and extracts the initiator's identity, nonce `s`, and the ticket (`alpha`).\n   - After verifying the message, the responder claims the session identifier (`SID`) linked to nonce `s`.\n   - The responder then constructs a message that includes its identity, nonce `s`, a computed value `g1(y)`, and a signed ticket back to the initiator.\n   - Once it receives the final message, it verifies the signature and claims the secret key (`SKR`) derived from its own ticket (`alpha`) and the nonce `y`.\n\n**Security Claims:**\n- The protocol guarantees that both parties can derive a shared secret key (`SKR`) without exposure to their individual nonce values or tickets.\n- The use of signatures ensures that the messages exchanged between the initiator and responder are authenticated, preventing impersonation attacks.\n\n**Hash Functions:**\n- The protocol employs hash functions (`h1`, `h2`, `g1`, `g2`) for generating cryptographic values, ensuring that all exchanged information remains secure and confidential.\n\n**Helper Protocol:**\n- An auxiliary protocol `@exponentiation` is defined to simulate the mathematical exponentiation operation necessary for the protocol's cryptographic computations. This helper protocol is used for clarity in the Scyther tool's display and does not affect the automatic generation of protocol modifiers.\n\n---\n\nThis description clarifies the intentions, actions, and security aspects of the Two-move Diffie-Hellman protocol, enabling the generation of the corresponding SPDL file suitable for use with the Scyther tool.",
        "codefrom:": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "SIG-DH-UM",
                        "I",
                        "SIG-DH-UM,I2",
                        "SKR g2(beta,x)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "SIG-DH-UM,R2",
                        "SKR g2(alpha,y)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.3245728015899658
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/signed_dh.spthy",
        "fileto": "SPDL-1/Signed-DH.spdl",
        "logicfrom": "---\n\n## Description of the Signed Diffie-Hellman Protocol\n\n### Overview\nThe Signed Diffie-Hellman protocol allows two parties, traditionally named Alice (A) and Bob (B), to securely establish a shared secret key over an insecure channel. The protocol utilizes asymmetric key pairs for each participant, where each has a public key and a corresponding private key.\n\n### Key Components\n1. **Functions**:\n   - `pk/1`: Represents the public key of a participant.\n   - `sk/1`: Represents the private key of a participant.\n   - `aenc/2`: Represents asymmetric encryption of a message with a public key.\n   - `adec/2`: Represents asymmetric decryption of a message with a private key.\n   - `g/0`: A generator used in the Diffie-Hellman key exchange.\n\n2. **Built-ins**:\n   - `diffie-hellman`: Built-in support for the Diffie-Hellman key agreement.\n\n### Equations\nThe protocol defines two equations for the encryption and decryption processes, ensuring that the decryption of an encrypted message returns the original message when the correct key is used.\n\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{sk}(x.2)), \\text{pk}(x.2)) = x.1 \\)\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{pk}(x.2)), \\text{sk}(x.2)) = x.1 \\)\n\n### Protocol Steps\n1. **Asymmetric Key Setup**:\n   - Each participant generates a pair of keys (public and private). The public keys are published.\n\n2. **Publish Public Keys**:\n   - Participants publish their public keys to the network.\n\n3. **Initialization of Knowledge**:\n   - Both participants initialize their state with their own and the other participant's public and private keys.\n\n4. **Role A (Alice)**:\n   - **Step 1 (dh_1_A)**: Alice sends an encrypted message containing the string \"One\", her identity, Bob's identity, and a random value \\( x \\) to Bob.\n   - **Step 2 (dh_2_A)**: Upon receiving Bob's response (an encrypted message containing \"Two\" and a value \\( \\alpha \\)), Alice computes her secret key by combining \\( \\alpha \\) and her random value \\( x \\).\n\n5. **Role B (Bob)**:\n   - **Step 1 (dh_1_B)**: Bob, upon initialization, waits for Alice's message.\n   - **Step 2 (dh_2_B)**: Bob sends a response to Alice with an encrypted message containing \"Two\" and a random value \\( y \\). He computes his secret key by combining \\( \\alpha \\) and his random value \\( y \\).\n\n### Security Properties\nThe protocol includes lemmas that assert the secrecy of the generated keys:\n- **Key Secrecy**: Ensures that no message can reveal the secret keys held by either party.\n- **Key Secrecy for Alice**: Ensures that Alice's derived secret key is kept secret.\n- **Key Secrecy for Bob**: Ensures that Bob's derived secret key is kept secret.\n\n---",
        "codefrom:": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/signed_dh.spthy\n\n  key_secret (all-traces): verified (15 steps)\n  key_secretA (all-traces): verified (9 steps)\n  key_secretB (all-traces): verified (9 steps)\n\n",
                1.3853743076324463
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/Signed-DH.spdl",
        "fileto": "MAUDE-1/signed_dh.maude",
        "logicfrom": "To generate a description content for the given SPDL file of a protocol, we will outline the key elements and operations of the Two-move Diffie-Hellman protocol as implemented in the provided SPDL content.\n\n---\n\n### Protocol Description: Two-move Diffie-Hellman in the Universal Model (UM)\n\n**Overview:**\nThe Two-move Diffie-Hellman (DH) protocol enables two parties, identified as initiator (I) and responder (R), to establish a shared secret key in a secure manner. The protocol is structured in two main communication phases, utilizing nonce values and a series of cryptographic operations to ensure confidentiality and authenticity.\n\n**Roles:**\n1. **Initiator (I)**:\n   - The initiator generates two fresh nonce values, `s` and `x`, which are unique for each execution of the protocol. \n   - The initiator sends a message to the responder containing its identity, the nonce `s`, and a computed value `g1(x)`.\n   - Upon receiving a response from the responder, which includes a ticket (`beta`), the initiator sends a final message encapsulating its identity, nonce `s`, and a signed message that includes its identity and the received ticket.\n   - Finally, the initiator claims the secret key (`SKR`) derived from the responder\u2019s ticket (`beta`) and its own nonce (`x`).\n\n2. **Responder (R)**:\n   - The responder generates a fresh nonce `y` for its part in the exchange.\n   - It receives the initial message from the initiator and extracts the initiator's identity, nonce `s`, and the ticket (`alpha`).\n   - After verifying the message, the responder claims the session identifier (`SID`) linked to nonce `s`.\n   - The responder then constructs a message that includes its identity, nonce `s`, a computed value `g1(y)`, and a signed ticket back to the initiator.\n   - Once it receives the final message, it verifies the signature and claims the secret key (`SKR`) derived from its own ticket (`alpha`) and the nonce `y`.\n\n**Security Claims:**\n- The protocol guarantees that both parties can derive a shared secret key (`SKR`) without exposure to their individual nonce values or tickets.\n- The use of signatures ensures that the messages exchanged between the initiator and responder are authenticated, preventing impersonation attacks.\n\n**Hash Functions:**\n- The protocol employs hash functions (`h1`, `h2`, `g1`, `g2`) for generating cryptographic values, ensuring that all exchanged information remains secure and confidential.\n\n**Helper Protocol:**\n- An auxiliary protocol `@exponentiation` is defined to simulate the mathematical exponentiation operation necessary for the protocol's cryptographic computations. This helper protocol is used for clarity in the Scyther tool's display and does not affect the automatic generation of protocol modifiers.\n\n---\n\nThis description clarifies the intentions, actions, and security aspects of the Two-move Diffie-Hellman protocol, enabling the generation of the corresponding SPDL file suitable for use with the Scyther tool.",
        "codefrom:": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "SIG-DH-UM",
                        "I",
                        "SIG-DH-UM,I2",
                        "SKR g2(beta,x)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "SIG-DH-UM,R2",
                        "SKR g2(alpha,y)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.3245728015899658
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/signed_dh.maude",
        "fileto": "SPDL-1/Signed-DH.spdl",
        "logicfrom": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "codefrom:": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "resultsfrom": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:05:58 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 3936654 in 4176ms cpu (4176ms real) (942685 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   +(a ; b ; exp(g, n(a, r:Fresh)) ; sign(a, b ; exp(g, n(a, r:Fresh)))), \n   -(a ; b ; XE:Exp ; sign(b, a ; XE:Exp)) | nil] \n|| \nexp(XE:Exp, n(a, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 5388413 in 7228ms cpu (7229ms real) (745491 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                12.282142162322998
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/Signed-DH.spdl",
        "fileto": "PV-1/signedDH.pv",
        "logicfrom": "To generate a description content for the given SPDL file of a protocol, we will outline the key elements and operations of the Two-move Diffie-Hellman protocol as implemented in the provided SPDL content.\n\n---\n\n### Protocol Description: Two-move Diffie-Hellman in the Universal Model (UM)\n\n**Overview:**\nThe Two-move Diffie-Hellman (DH) protocol enables two parties, identified as initiator (I) and responder (R), to establish a shared secret key in a secure manner. The protocol is structured in two main communication phases, utilizing nonce values and a series of cryptographic operations to ensure confidentiality and authenticity.\n\n**Roles:**\n1. **Initiator (I)**:\n   - The initiator generates two fresh nonce values, `s` and `x`, which are unique for each execution of the protocol. \n   - The initiator sends a message to the responder containing its identity, the nonce `s`, and a computed value `g1(x)`.\n   - Upon receiving a response from the responder, which includes a ticket (`beta`), the initiator sends a final message encapsulating its identity, nonce `s`, and a signed message that includes its identity and the received ticket.\n   - Finally, the initiator claims the secret key (`SKR`) derived from the responder\u2019s ticket (`beta`) and its own nonce (`x`).\n\n2. **Responder (R)**:\n   - The responder generates a fresh nonce `y` for its part in the exchange.\n   - It receives the initial message from the initiator and extracts the initiator's identity, nonce `s`, and the ticket (`alpha`).\n   - After verifying the message, the responder claims the session identifier (`SID`) linked to nonce `s`.\n   - The responder then constructs a message that includes its identity, nonce `s`, a computed value `g1(y)`, and a signed ticket back to the initiator.\n   - Once it receives the final message, it verifies the signature and claims the secret key (`SKR`) derived from its own ticket (`alpha`) and the nonce `y`.\n\n**Security Claims:**\n- The protocol guarantees that both parties can derive a shared secret key (`SKR`) without exposure to their individual nonce values or tickets.\n- The use of signatures ensures that the messages exchanged between the initiator and responder are authenticated, preventing impersonation attacks.\n\n**Hash Functions:**\n- The protocol employs hash functions (`h1`, `h2`, `g1`, `g2`) for generating cryptographic values, ensuring that all exchanged information remains secure and confidential.\n\n**Helper Protocol:**\n- An auxiliary protocol `@exponentiation` is defined to simulate the mathematical exponentiation operation necessary for the protocol's cryptographic computations. This helper protocol is used for clarity in the Scyther tool's display and does not affect the automatic generation of protocol modifiers.\n\n---\n\nThis description clarifies the intentions, actions, and security aspects of the Two-move Diffie-Hellman protocol, enabling the generation of the corresponding SPDL file suitable for use with the Scyther tool.",
        "codefrom:": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "SIG-DH-UM",
                        "I",
                        "SIG-DH-UM,I2",
                        "SKR g2(beta,x)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "SIG-DH-UM,R2",
                        "SKR g2(alpha,y)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.3245728015899658
            ]
        ]
    },
    {
        "filefrom": "PV-1/signedDH.pv",
        "fileto": "SPDL-1/Signed-DH.spdl",
        "logicfrom": "---\n\n### Description of the Signed Diffie-Hellman Protocol\n\n**Overview:**\nThe Signed Diffie-Hellman protocol is a cryptographic method that allows two parties, A and B, to establish a shared secret key over an insecure channel. The protocol utilizes public key cryptography to ensure the authenticity of the messages exchanged between the two parties. Each participant has a private key (skey) and a corresponding public key (pkey).\n\n**Participants:**\n- **A (Alice)**: One party in the communication, holds a secret key `skA` and its public key `pkA`.\n- **B (Bob)**: The other party in the communication, holds a secret key `skB` and its public key `pkB`.\n\n**Protocol Steps:**\n1. **Key Generation**:\n   - A generates a secret key `skA` and computes its public key `pkA` using the function `pk(skey)`.\n\n2. **Public Key Exchange**:\n   - A sends its public key `pkA` to B over a channel `c`.\n\n3. **Nonce Generation**:\n   - A generates a fresh nonce `n0` (an exponent in the Diffie-Hellman context) and computes a signature on the value `exp(g, n0)` using its secret key `skA`. The message sent to B includes the signed value and A's public key: `{ exp(g, n0) }skA, pkA`.\n\n4. **Response from B**:\n   - B receives the message containing A's signed value and public key. B uses the public key `pkX` (which is `pkA`) to verify the signature. \n   - Upon successful verification, B generates a fresh nonce `n1` and computes the shared key `k` using the received value: `k = exp(exp(g, n0), n1)` (which can also be written as `k = exp(exp(g, n1), n0)` due to the properties of exponentiation).\n   - B then sends back a signed message `{ exp(g, n1) }skB` to A.\n\n5. **Final Message**:\n   - A receives the signed message from B and verifies it using `pkB`. \n   - A then computes the shared key `k` again (the same as B), and sends a secret message `s`, encrypted with the shared key `k`, to B using the encryption function `enc(bitstring, G)`.\n\n**Security Goal**:\n- The protocol aims to ensure that the secret message `s` remains confidential and not accessible by an attacker. The attacker is queried to determine if they can successfully learn the value of `s`.\n\n**Key Functions**:\n- `sign(G, skey)`: Generates a signature for a message `G` using the secret key `skey`.\n- `pk(skey)`: Computes the public key from the secret key.\n- `enc(bitstring, G)`: Encrypts a bitstring using a shared key `G`.\n- `dec(enc(x,y),y)`: Decrypts the encrypted message using the key `y`.\n\n**Conclusion**:\nThis protocol successfully establishes a shared secret key between two parties while ensuring the authenticity of the exchanged messages through digital signatures. The use of nonces helps prevent replay attacks, and the secure exchange of public keys ensures that the parties can derive the same shared key independently.\n\n---",
        "codefrom:": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree c: channel.\n\ntype pkey.\ntype skey.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(skey):pkey.\nreduc forall m: G, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(s).\n\n(* The process *)\n\nlet p0(skA: skey, pkA: pkey, pkB: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(g, n0), skA), pkA));\n\t in(c,m1: bitstring); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = pkB then\n\t out(c, enc(s,k)).\n\nlet p1(skB: skey, pkB: pkey, pkA: pkey) = \n         in(c, (m0: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, n1) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(m,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew skB: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)",
        "resultsfrom": [
            true,
            [
                true,
                "RESULT not attacker(s[]) is true.\n",
                0.010365009307861328
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/Signed-DH.spdl",
        "fileto": "CV-1/template-signedDH.ocv",
        "logicfrom": "To generate a description content for the given SPDL file of a protocol, we will outline the key elements and operations of the Two-move Diffie-Hellman protocol as implemented in the provided SPDL content.\n\n---\n\n### Protocol Description: Two-move Diffie-Hellman in the Universal Model (UM)\n\n**Overview:**\nThe Two-move Diffie-Hellman (DH) protocol enables two parties, identified as initiator (I) and responder (R), to establish a shared secret key in a secure manner. The protocol is structured in two main communication phases, utilizing nonce values and a series of cryptographic operations to ensure confidentiality and authenticity.\n\n**Roles:**\n1. **Initiator (I)**:\n   - The initiator generates two fresh nonce values, `s` and `x`, which are unique for each execution of the protocol. \n   - The initiator sends a message to the responder containing its identity, the nonce `s`, and a computed value `g1(x)`.\n   - Upon receiving a response from the responder, which includes a ticket (`beta`), the initiator sends a final message encapsulating its identity, nonce `s`, and a signed message that includes its identity and the received ticket.\n   - Finally, the initiator claims the secret key (`SKR`) derived from the responder\u2019s ticket (`beta`) and its own nonce (`x`).\n\n2. **Responder (R)**:\n   - The responder generates a fresh nonce `y` for its part in the exchange.\n   - It receives the initial message from the initiator and extracts the initiator's identity, nonce `s`, and the ticket (`alpha`).\n   - After verifying the message, the responder claims the session identifier (`SID`) linked to nonce `s`.\n   - The responder then constructs a message that includes its identity, nonce `s`, a computed value `g1(y)`, and a signed ticket back to the initiator.\n   - Once it receives the final message, it verifies the signature and claims the secret key (`SKR`) derived from its own ticket (`alpha`) and the nonce `y`.\n\n**Security Claims:**\n- The protocol guarantees that both parties can derive a shared secret key (`SKR`) without exposure to their individual nonce values or tickets.\n- The use of signatures ensures that the messages exchanged between the initiator and responder are authenticated, preventing impersonation attacks.\n\n**Hash Functions:**\n- The protocol employs hash functions (`h1`, `h2`, `g1`, `g2`) for generating cryptographic values, ensuring that all exchanged information remains secure and confidential.\n\n**Helper Protocol:**\n- An auxiliary protocol `@exponentiation` is defined to simulate the mathematical exponentiation operation necessary for the protocol's cryptographic computations. This helper protocol is used for clarity in the Scyther tool's display and does not affect the automatic generation of protocol modifiers.\n\n---\n\nThis description clarifies the intentions, actions, and security aspects of the Two-move Diffie-Hellman protocol, enabling the generation of the corresponding SPDL file suitable for use with the Scyther tool.",
        "codefrom:": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "resultsfrom": [
            true,
            [
                true,
                [
                    [
                        "SIG-DH-UM",
                        "I",
                        "SIG-DH-UM,I2",
                        "SKR g2(beta,x)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "R",
                        "SIG-DH-UM,R2",
                        "SKR g2(alpha,y)",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ]
                ],
                0.3245728015899658
            ]
        ]
    },
    {
        "filefrom": "CV-1/template-signedDH.ocv",
        "fileto": "SPDL-1/Signed-DH.spdl",
        "logicfrom": "To create a description content for the protocol that corresponds to the provided OCV file, we need to detail the components of the protocol, their roles, and the overall logic flow in a way that allows for the regeneration of the OCV file.\n\nHere's a structured description of the protocol based on the given content:\n\n---\n\n### Protocol Description\n\n#### Overview\nThis protocol describes a secure communication mechanism between two parties, denoted as agents A and B, using a combination of the Diffie-Hellman key exchange, digital signatures, and a public key infrastructure (PKI). The protocol aims to establish a secure channel for message exchange while ensuring authenticity and integrity through the use of cryptographic signatures.\n\n#### Participants\n- **Agents**: The protocol involves `NA` instances of agent A and `NB` instances of agent B.\n- **Public Keys**: The protocol supports `NK` public keys for signing purposes.\n\n#### Cryptographic Primitives\n1. **Diffie-Hellman Key Exchange**:\n   - Utilizes a finite group `G` and a generator `g` to enable agents to derive a shared secret key through exponentiation.\n   - Assumptions include collision probabilities (`PCollKey1` and `PCollKey2`) to ensure security against certain types of attacks.\n\n2. **Hash Function**:\n   - A random oracle model is employed to define a hash function which maps inputs from group `G` to a finite key space.\n   - This hash function plays a crucial role in the signing and verification process.\n\n3. **Digital Signatures**:\n   - The protocol employs a signature scheme characterized by the security properties of unforgeability under chosen-message attacks (UF-CMA).\n   - The signature scheme involves the generation of secret keys and public keys, signing messages, and verifying signatures.\n\n#### Processes\n1. **Key Generation**:\n   - Each agent generates a signing key pair consisting of a secret key (`skey`) and a public key (`pkey`) using a key seed (`keyseed`).\n\n2. **Process A**:\n   - Runs concurrently for each instance of agent A.\n   - Engages in message signing and verification, utilizing the hash function to ensure message integrity.\n\n3. **Process B**:\n   - Similar to process A, but for agent B.\n   - Also involves signing and verification of messages.\n\n4. **Public Key Infrastructure (PKI)**:\n   - Handles the association between public keys of agents A and B.\n   - Ensures that agents can verify each other's signatures based on their public keys.\n\n5. **Execution Flow**:\n   - The protocol starts by generating a hash function and the key pairs for agents A and B.\n   - Each instance of agent A and B runs concurrently, performing their respective operations, alongside the PKI processes and the hash oracle.\n\n#### Security Assumptions\n- **Collision Resistance**: The protocol assumes certain probabilities (`PCollKey1`, `PCollKey2`) concerning the difficulty of finding collisions in the derived keys.\n- **Computational Diffie-Hellman (CDH) Assumption**: Assumes difficulty in solving the CDH problem within group `G`.\n\n#### Conclusion\nThis protocol ensures secure communication between multiple instances of agents A and B through a well-defined process utilizing Diffie-Hellman key exchange, digital signatures, and a robust public key infrastructure, while maintaining the security properties required for reliable and authenticated message exchange.\n\n---\n\n### Final Notes\n- The description provides a comprehensive overview while preserving the technical details necessary for the reconstruction of the OCV file.\n- The placeholders marked as `TODO` in the original OCV file imply that additional specifications, such as the event definitions and secrecy queries, need to be addressed in the final implementation based on the protocol's requirements.\n\nThis description can be further tailored to include specific details about the actions taken by processes A and B, the exact nature of the messages exchanged, or any additional security features relevant to the protocol's implementation.",
        "codefrom:": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers *)\ntype keyseed [large,fixed].  (* seed for signing key generation *)\ntype pkey [bounded].  (* signing public key *)\ntype skey [bounded].  (* signing secret key *)\ntype message [bounded]. (* the signed message space *)\ntype signature [bounded]. (* the output signature space *)\n\ntype G [large,bounded]. (* the finite group definition *)\ntype Z [large,bounded]. (* the field of the exponents of the group *)\ntype key [fixed]. (* the output of the hash function, also corresponding to the final keys space *)\n\n(* Basic Diffie-Hellman declarations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* This collision assumption is needed to prove an injective\n   correspondence, because we use ephemerals to distinguish sessions. *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision says that\n   - the probability that exp(g, x) = Y for random x and Y independent of x\n   is at most PCollKey1, and\n   - the probability that exp(g, mult(x,y)) = Y where x and y are independent\n   random private keys and Y is independent of x or y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator *)\n  exp,      (* exponentiation function *)\n  exp',     (* exp. func. after transformation *)\n  mult,     (* func. for exponent multiplication *)\n  PCollKey1,(*  *)\n  PCollKey2\n).\n\n(* CDH assumption *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n\n(* Hash in the random oracle model *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input *)\n  key,          (* type of output *)\n  hash,         (* name of hash function *)\n  hashoracle,   (* process defining the hash oracle *)\n  qH            (* parameter: number of calls *)\n).\n\n\n(* Signatures *)\nproba Psign.\nproba Psigncoll.\n(* expand UF_CMA_det_signature( *)\nexpand UF_CMA_proba_signature(\n  (* types, to be defined outside the macro *)\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  (* names for functions defined by the macro *)\n  skgen,\n  pkgen,\n  sign,\n  verify,\n  (* probabilities, to be defined outside the macro *)\n  Psign,     (* breaking the UF-CMA property *)\n  Psigncoll  (* collision between independently gen. keys *)\n).\n\n\n(* The two honest peers *)\nconst A,B:host.\n\n(* TODO secrecy queries *)\n\n(* TODO event definition + authentication queries *)\n\n(* TODO table definition for public key infrastructure *)\n\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO. *)\n\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO. *)\n\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO *) \n   SomeOtherOtherOracleTODO () := return.\n   \nletfun keygen() =\n  rk <-R keyseed;\n  sk <- skgen(rk);\n  pk <- pkgen(rk);\n  (sk, pk).\n\n(* final process declaration *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction;\n    let (skA: skey, pkA: pkey) = keygen() in\n    let (skB: skey, pkB: pkey) = keygen() in\n    return(pkA, pkB);\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))\n     |\n      run hashoracle(hf)\n    )",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved indistinguishability between the input game and the final game up to probability Psign(time_2, 0) + Psign(time_1, 0)\nRESULT time_1 = time(pkgen) + time + -1 * time(verify)\nRESULT time_2 = time(pkgen2) + time + -1 * time(verify)\nAll queries proved.",
                    0.06919527053833008
                ]
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/signed_dh.spthy",
        "fileto": "MAUDE-1/signed_dh.maude",
        "logicfrom": "---\n\n## Description of the Signed Diffie-Hellman Protocol\n\n### Overview\nThe Signed Diffie-Hellman protocol allows two parties, traditionally named Alice (A) and Bob (B), to securely establish a shared secret key over an insecure channel. The protocol utilizes asymmetric key pairs for each participant, where each has a public key and a corresponding private key.\n\n### Key Components\n1. **Functions**:\n   - `pk/1`: Represents the public key of a participant.\n   - `sk/1`: Represents the private key of a participant.\n   - `aenc/2`: Represents asymmetric encryption of a message with a public key.\n   - `adec/2`: Represents asymmetric decryption of a message with a private key.\n   - `g/0`: A generator used in the Diffie-Hellman key exchange.\n\n2. **Built-ins**:\n   - `diffie-hellman`: Built-in support for the Diffie-Hellman key agreement.\n\n### Equations\nThe protocol defines two equations for the encryption and decryption processes, ensuring that the decryption of an encrypted message returns the original message when the correct key is used.\n\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{sk}(x.2)), \\text{pk}(x.2)) = x.1 \\)\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{pk}(x.2)), \\text{sk}(x.2)) = x.1 \\)\n\n### Protocol Steps\n1. **Asymmetric Key Setup**:\n   - Each participant generates a pair of keys (public and private). The public keys are published.\n\n2. **Publish Public Keys**:\n   - Participants publish their public keys to the network.\n\n3. **Initialization of Knowledge**:\n   - Both participants initialize their state with their own and the other participant's public and private keys.\n\n4. **Role A (Alice)**:\n   - **Step 1 (dh_1_A)**: Alice sends an encrypted message containing the string \"One\", her identity, Bob's identity, and a random value \\( x \\) to Bob.\n   - **Step 2 (dh_2_A)**: Upon receiving Bob's response (an encrypted message containing \"Two\" and a value \\( \\alpha \\)), Alice computes her secret key by combining \\( \\alpha \\) and her random value \\( x \\).\n\n5. **Role B (Bob)**:\n   - **Step 1 (dh_1_B)**: Bob, upon initialization, waits for Alice's message.\n   - **Step 2 (dh_2_B)**: Bob sends a response to Alice with an encrypted message containing \"Two\" and a random value \\( y \\). He computes his secret key by combining \\( \\alpha \\) and his random value \\( y \\).\n\n### Security Properties\nThe protocol includes lemmas that assert the secrecy of the generated keys:\n- **Key Secrecy**: Ensures that no message can reveal the secret keys held by either party.\n- **Key Secrecy for Alice**: Ensures that Alice's derived secret key is kept secret.\n- **Key Secrecy for Bob**: Ensures that Bob's derived secret key is kept secret.\n\n---",
        "codefrom:": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/signed_dh.spthy\n\n  key_secret (all-traces): verified (15 steps)\n  key_secretA (all-traces): verified (9 steps)\n  key_secretB (all-traces): verified (9 steps)\n\n",
                1.3853743076324463
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/signed_dh.maude",
        "fileto": "SPTHY-1/signed_dh.spthy",
        "logicfrom": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "codefrom:": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "resultsfrom": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:05:58 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 3936654 in 4176ms cpu (4176ms real) (942685 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   +(a ; b ; exp(g, n(a, r:Fresh)) ; sign(a, b ; exp(g, n(a, r:Fresh)))), \n   -(a ; b ; XE:Exp ; sign(b, a ; XE:Exp)) | nil] \n|| \nexp(XE:Exp, n(a, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 5388413 in 7228ms cpu (7229ms real) (745491 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                12.282142162322998
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/signed_dh.spthy",
        "fileto": "PV-1/signedDH.pv",
        "logicfrom": "---\n\n## Description of the Signed Diffie-Hellman Protocol\n\n### Overview\nThe Signed Diffie-Hellman protocol allows two parties, traditionally named Alice (A) and Bob (B), to securely establish a shared secret key over an insecure channel. The protocol utilizes asymmetric key pairs for each participant, where each has a public key and a corresponding private key.\n\n### Key Components\n1. **Functions**:\n   - `pk/1`: Represents the public key of a participant.\n   - `sk/1`: Represents the private key of a participant.\n   - `aenc/2`: Represents asymmetric encryption of a message with a public key.\n   - `adec/2`: Represents asymmetric decryption of a message with a private key.\n   - `g/0`: A generator used in the Diffie-Hellman key exchange.\n\n2. **Built-ins**:\n   - `diffie-hellman`: Built-in support for the Diffie-Hellman key agreement.\n\n### Equations\nThe protocol defines two equations for the encryption and decryption processes, ensuring that the decryption of an encrypted message returns the original message when the correct key is used.\n\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{sk}(x.2)), \\text{pk}(x.2)) = x.1 \\)\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{pk}(x.2)), \\text{sk}(x.2)) = x.1 \\)\n\n### Protocol Steps\n1. **Asymmetric Key Setup**:\n   - Each participant generates a pair of keys (public and private). The public keys are published.\n\n2. **Publish Public Keys**:\n   - Participants publish their public keys to the network.\n\n3. **Initialization of Knowledge**:\n   - Both participants initialize their state with their own and the other participant's public and private keys.\n\n4. **Role A (Alice)**:\n   - **Step 1 (dh_1_A)**: Alice sends an encrypted message containing the string \"One\", her identity, Bob's identity, and a random value \\( x \\) to Bob.\n   - **Step 2 (dh_2_A)**: Upon receiving Bob's response (an encrypted message containing \"Two\" and a value \\( \\alpha \\)), Alice computes her secret key by combining \\( \\alpha \\) and her random value \\( x \\).\n\n5. **Role B (Bob)**:\n   - **Step 1 (dh_1_B)**: Bob, upon initialization, waits for Alice's message.\n   - **Step 2 (dh_2_B)**: Bob sends a response to Alice with an encrypted message containing \"Two\" and a random value \\( y \\). He computes his secret key by combining \\( \\alpha \\) and his random value \\( y \\).\n\n### Security Properties\nThe protocol includes lemmas that assert the secrecy of the generated keys:\n- **Key Secrecy**: Ensures that no message can reveal the secret keys held by either party.\n- **Key Secrecy for Alice**: Ensures that Alice's derived secret key is kept secret.\n- **Key Secrecy for Bob**: Ensures that Bob's derived secret key is kept secret.\n\n---",
        "codefrom:": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/signed_dh.spthy\n\n  key_secret (all-traces): verified (15 steps)\n  key_secretA (all-traces): verified (9 steps)\n  key_secretB (all-traces): verified (9 steps)\n\n",
                1.3853743076324463
            ]
        ]
    },
    {
        "filefrom": "PV-1/signedDH.pv",
        "fileto": "SPTHY-1/signed_dh.spthy",
        "logicfrom": "---\n\n### Description of the Signed Diffie-Hellman Protocol\n\n**Overview:**\nThe Signed Diffie-Hellman protocol is a cryptographic method that allows two parties, A and B, to establish a shared secret key over an insecure channel. The protocol utilizes public key cryptography to ensure the authenticity of the messages exchanged between the two parties. Each participant has a private key (skey) and a corresponding public key (pkey).\n\n**Participants:**\n- **A (Alice)**: One party in the communication, holds a secret key `skA` and its public key `pkA`.\n- **B (Bob)**: The other party in the communication, holds a secret key `skB` and its public key `pkB`.\n\n**Protocol Steps:**\n1. **Key Generation**:\n   - A generates a secret key `skA` and computes its public key `pkA` using the function `pk(skey)`.\n\n2. **Public Key Exchange**:\n   - A sends its public key `pkA` to B over a channel `c`.\n\n3. **Nonce Generation**:\n   - A generates a fresh nonce `n0` (an exponent in the Diffie-Hellman context) and computes a signature on the value `exp(g, n0)` using its secret key `skA`. The message sent to B includes the signed value and A's public key: `{ exp(g, n0) }skA, pkA`.\n\n4. **Response from B**:\n   - B receives the message containing A's signed value and public key. B uses the public key `pkX` (which is `pkA`) to verify the signature. \n   - Upon successful verification, B generates a fresh nonce `n1` and computes the shared key `k` using the received value: `k = exp(exp(g, n0), n1)` (which can also be written as `k = exp(exp(g, n1), n0)` due to the properties of exponentiation).\n   - B then sends back a signed message `{ exp(g, n1) }skB` to A.\n\n5. **Final Message**:\n   - A receives the signed message from B and verifies it using `pkB`. \n   - A then computes the shared key `k` again (the same as B), and sends a secret message `s`, encrypted with the shared key `k`, to B using the encryption function `enc(bitstring, G)`.\n\n**Security Goal**:\n- The protocol aims to ensure that the secret message `s` remains confidential and not accessible by an attacker. The attacker is queried to determine if they can successfully learn the value of `s`.\n\n**Key Functions**:\n- `sign(G, skey)`: Generates a signature for a message `G` using the secret key `skey`.\n- `pk(skey)`: Computes the public key from the secret key.\n- `enc(bitstring, G)`: Encrypts a bitstring using a shared key `G`.\n- `dec(enc(x,y),y)`: Decrypts the encrypted message using the key `y`.\n\n**Conclusion**:\nThis protocol successfully establishes a shared secret key between two parties while ensuring the authenticity of the exchanged messages through digital signatures. The use of nonces helps prevent replay attacks, and the secure exchange of public keys ensures that the parties can derive the same shared key independently.\n\n---",
        "codefrom:": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree c: channel.\n\ntype pkey.\ntype skey.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(skey):pkey.\nreduc forall m: G, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(s).\n\n(* The process *)\n\nlet p0(skA: skey, pkA: pkey, pkB: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(g, n0), skA), pkA));\n\t in(c,m1: bitstring); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = pkB then\n\t out(c, enc(s,k)).\n\nlet p1(skB: skey, pkB: pkey, pkA: pkey) = \n         in(c, (m0: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, n1) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(m,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew skB: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)",
        "resultsfrom": [
            true,
            [
                true,
                "RESULT not attacker(s[]) is true.\n",
                0.010365009307861328
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/signed_dh.spthy",
        "fileto": "CV-1/template-signedDH.ocv",
        "logicfrom": "---\n\n## Description of the Signed Diffie-Hellman Protocol\n\n### Overview\nThe Signed Diffie-Hellman protocol allows two parties, traditionally named Alice (A) and Bob (B), to securely establish a shared secret key over an insecure channel. The protocol utilizes asymmetric key pairs for each participant, where each has a public key and a corresponding private key.\n\n### Key Components\n1. **Functions**:\n   - `pk/1`: Represents the public key of a participant.\n   - `sk/1`: Represents the private key of a participant.\n   - `aenc/2`: Represents asymmetric encryption of a message with a public key.\n   - `adec/2`: Represents asymmetric decryption of a message with a private key.\n   - `g/0`: A generator used in the Diffie-Hellman key exchange.\n\n2. **Built-ins**:\n   - `diffie-hellman`: Built-in support for the Diffie-Hellman key agreement.\n\n### Equations\nThe protocol defines two equations for the encryption and decryption processes, ensuring that the decryption of an encrypted message returns the original message when the correct key is used.\n\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{sk}(x.2)), \\text{pk}(x.2)) = x.1 \\)\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{pk}(x.2)), \\text{sk}(x.2)) = x.1 \\)\n\n### Protocol Steps\n1. **Asymmetric Key Setup**:\n   - Each participant generates a pair of keys (public and private). The public keys are published.\n\n2. **Publish Public Keys**:\n   - Participants publish their public keys to the network.\n\n3. **Initialization of Knowledge**:\n   - Both participants initialize their state with their own and the other participant's public and private keys.\n\n4. **Role A (Alice)**:\n   - **Step 1 (dh_1_A)**: Alice sends an encrypted message containing the string \"One\", her identity, Bob's identity, and a random value \\( x \\) to Bob.\n   - **Step 2 (dh_2_A)**: Upon receiving Bob's response (an encrypted message containing \"Two\" and a value \\( \\alpha \\)), Alice computes her secret key by combining \\( \\alpha \\) and her random value \\( x \\).\n\n5. **Role B (Bob)**:\n   - **Step 1 (dh_1_B)**: Bob, upon initialization, waits for Alice's message.\n   - **Step 2 (dh_2_B)**: Bob sends a response to Alice with an encrypted message containing \"Two\" and a random value \\( y \\). He computes his secret key by combining \\( \\alpha \\) and his random value \\( y \\).\n\n### Security Properties\nThe protocol includes lemmas that assert the secrecy of the generated keys:\n- **Key Secrecy**: Ensures that no message can reveal the secret keys held by either party.\n- **Key Secrecy for Alice**: Ensures that Alice's derived secret key is kept secret.\n- **Key Secrecy for Bob**: Ensures that Bob's derived secret key is kept secret.\n\n---",
        "codefrom:": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "resultsfrom": [
            true,
            [
                true,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/signed_dh.spthy\n\n  key_secret (all-traces): verified (15 steps)\n  key_secretA (all-traces): verified (9 steps)\n  key_secretB (all-traces): verified (9 steps)\n\n",
                1.3853743076324463
            ]
        ]
    },
    {
        "filefrom": "CV-1/template-signedDH.ocv",
        "fileto": "SPTHY-1/signed_dh.spthy",
        "logicfrom": "To create a description content for the protocol that corresponds to the provided OCV file, we need to detail the components of the protocol, their roles, and the overall logic flow in a way that allows for the regeneration of the OCV file.\n\nHere's a structured description of the protocol based on the given content:\n\n---\n\n### Protocol Description\n\n#### Overview\nThis protocol describes a secure communication mechanism between two parties, denoted as agents A and B, using a combination of the Diffie-Hellman key exchange, digital signatures, and a public key infrastructure (PKI). The protocol aims to establish a secure channel for message exchange while ensuring authenticity and integrity through the use of cryptographic signatures.\n\n#### Participants\n- **Agents**: The protocol involves `NA` instances of agent A and `NB` instances of agent B.\n- **Public Keys**: The protocol supports `NK` public keys for signing purposes.\n\n#### Cryptographic Primitives\n1. **Diffie-Hellman Key Exchange**:\n   - Utilizes a finite group `G` and a generator `g` to enable agents to derive a shared secret key through exponentiation.\n   - Assumptions include collision probabilities (`PCollKey1` and `PCollKey2`) to ensure security against certain types of attacks.\n\n2. **Hash Function**:\n   - A random oracle model is employed to define a hash function which maps inputs from group `G` to a finite key space.\n   - This hash function plays a crucial role in the signing and verification process.\n\n3. **Digital Signatures**:\n   - The protocol employs a signature scheme characterized by the security properties of unforgeability under chosen-message attacks (UF-CMA).\n   - The signature scheme involves the generation of secret keys and public keys, signing messages, and verifying signatures.\n\n#### Processes\n1. **Key Generation**:\n   - Each agent generates a signing key pair consisting of a secret key (`skey`) and a public key (`pkey`) using a key seed (`keyseed`).\n\n2. **Process A**:\n   - Runs concurrently for each instance of agent A.\n   - Engages in message signing and verification, utilizing the hash function to ensure message integrity.\n\n3. **Process B**:\n   - Similar to process A, but for agent B.\n   - Also involves signing and verification of messages.\n\n4. **Public Key Infrastructure (PKI)**:\n   - Handles the association between public keys of agents A and B.\n   - Ensures that agents can verify each other's signatures based on their public keys.\n\n5. **Execution Flow**:\n   - The protocol starts by generating a hash function and the key pairs for agents A and B.\n   - Each instance of agent A and B runs concurrently, performing their respective operations, alongside the PKI processes and the hash oracle.\n\n#### Security Assumptions\n- **Collision Resistance**: The protocol assumes certain probabilities (`PCollKey1`, `PCollKey2`) concerning the difficulty of finding collisions in the derived keys.\n- **Computational Diffie-Hellman (CDH) Assumption**: Assumes difficulty in solving the CDH problem within group `G`.\n\n#### Conclusion\nThis protocol ensures secure communication between multiple instances of agents A and B through a well-defined process utilizing Diffie-Hellman key exchange, digital signatures, and a robust public key infrastructure, while maintaining the security properties required for reliable and authenticated message exchange.\n\n---\n\n### Final Notes\n- The description provides a comprehensive overview while preserving the technical details necessary for the reconstruction of the OCV file.\n- The placeholders marked as `TODO` in the original OCV file imply that additional specifications, such as the event definitions and secrecy queries, need to be addressed in the final implementation based on the protocol's requirements.\n\nThis description can be further tailored to include specific details about the actions taken by processes A and B, the exact nature of the messages exchanged, or any additional security features relevant to the protocol's implementation.",
        "codefrom:": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers *)\ntype keyseed [large,fixed].  (* seed for signing key generation *)\ntype pkey [bounded].  (* signing public key *)\ntype skey [bounded].  (* signing secret key *)\ntype message [bounded]. (* the signed message space *)\ntype signature [bounded]. (* the output signature space *)\n\ntype G [large,bounded]. (* the finite group definition *)\ntype Z [large,bounded]. (* the field of the exponents of the group *)\ntype key [fixed]. (* the output of the hash function, also corresponding to the final keys space *)\n\n(* Basic Diffie-Hellman declarations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* This collision assumption is needed to prove an injective\n   correspondence, because we use ephemerals to distinguish sessions. *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision says that\n   - the probability that exp(g, x) = Y for random x and Y independent of x\n   is at most PCollKey1, and\n   - the probability that exp(g, mult(x,y)) = Y where x and y are independent\n   random private keys and Y is independent of x or y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator *)\n  exp,      (* exponentiation function *)\n  exp',     (* exp. func. after transformation *)\n  mult,     (* func. for exponent multiplication *)\n  PCollKey1,(*  *)\n  PCollKey2\n).\n\n(* CDH assumption *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n\n(* Hash in the random oracle model *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input *)\n  key,          (* type of output *)\n  hash,         (* name of hash function *)\n  hashoracle,   (* process defining the hash oracle *)\n  qH            (* parameter: number of calls *)\n).\n\n\n(* Signatures *)\nproba Psign.\nproba Psigncoll.\n(* expand UF_CMA_det_signature( *)\nexpand UF_CMA_proba_signature(\n  (* types, to be defined outside the macro *)\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  (* names for functions defined by the macro *)\n  skgen,\n  pkgen,\n  sign,\n  verify,\n  (* probabilities, to be defined outside the macro *)\n  Psign,     (* breaking the UF-CMA property *)\n  Psigncoll  (* collision between independently gen. keys *)\n).\n\n\n(* The two honest peers *)\nconst A,B:host.\n\n(* TODO secrecy queries *)\n\n(* TODO event definition + authentication queries *)\n\n(* TODO table definition for public key infrastructure *)\n\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO. *)\n\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO. *)\n\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO *) \n   SomeOtherOtherOracleTODO () := return.\n   \nletfun keygen() =\n  rk <-R keyseed;\n  sk <- skgen(rk);\n  pk <- pkgen(rk);\n  (sk, pk).\n\n(* final process declaration *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction;\n    let (skA: skey, pkA: pkey) = keygen() in\n    let (skB: skey, pkB: pkey) = keygen() in\n    return(pkA, pkB);\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))\n     |\n      run hashoracle(hf)\n    )",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved indistinguishability between the input game and the final game up to probability Psign(time_2, 0) + Psign(time_1, 0)\nRESULT time_1 = time(pkgen) + time + -1 * time(verify)\nRESULT time_2 = time(pkgen2) + time + -1 * time(verify)\nAll queries proved.",
                    0.06919527053833008
                ]
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/signed_dh.maude",
        "fileto": "PV-1/signedDH.pv",
        "logicfrom": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "codefrom:": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "resultsfrom": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:05:58 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 3936654 in 4176ms cpu (4176ms real) (942685 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   +(a ; b ; exp(g, n(a, r:Fresh)) ; sign(a, b ; exp(g, n(a, r:Fresh)))), \n   -(a ; b ; XE:Exp ; sign(b, a ; XE:Exp)) | nil] \n|| \nexp(XE:Exp, n(a, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 5388413 in 7228ms cpu (7229ms real) (745491 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                12.282142162322998
            ]
        ]
    },
    {
        "filefrom": "PV-1/signedDH.pv",
        "fileto": "MAUDE-1/signed_dh.maude",
        "logicfrom": "---\n\n### Description of the Signed Diffie-Hellman Protocol\n\n**Overview:**\nThe Signed Diffie-Hellman protocol is a cryptographic method that allows two parties, A and B, to establish a shared secret key over an insecure channel. The protocol utilizes public key cryptography to ensure the authenticity of the messages exchanged between the two parties. Each participant has a private key (skey) and a corresponding public key (pkey).\n\n**Participants:**\n- **A (Alice)**: One party in the communication, holds a secret key `skA` and its public key `pkA`.\n- **B (Bob)**: The other party in the communication, holds a secret key `skB` and its public key `pkB`.\n\n**Protocol Steps:**\n1. **Key Generation**:\n   - A generates a secret key `skA` and computes its public key `pkA` using the function `pk(skey)`.\n\n2. **Public Key Exchange**:\n   - A sends its public key `pkA` to B over a channel `c`.\n\n3. **Nonce Generation**:\n   - A generates a fresh nonce `n0` (an exponent in the Diffie-Hellman context) and computes a signature on the value `exp(g, n0)` using its secret key `skA`. The message sent to B includes the signed value and A's public key: `{ exp(g, n0) }skA, pkA`.\n\n4. **Response from B**:\n   - B receives the message containing A's signed value and public key. B uses the public key `pkX` (which is `pkA`) to verify the signature. \n   - Upon successful verification, B generates a fresh nonce `n1` and computes the shared key `k` using the received value: `k = exp(exp(g, n0), n1)` (which can also be written as `k = exp(exp(g, n1), n0)` due to the properties of exponentiation).\n   - B then sends back a signed message `{ exp(g, n1) }skB` to A.\n\n5. **Final Message**:\n   - A receives the signed message from B and verifies it using `pkB`. \n   - A then computes the shared key `k` again (the same as B), and sends a secret message `s`, encrypted with the shared key `k`, to B using the encryption function `enc(bitstring, G)`.\n\n**Security Goal**:\n- The protocol aims to ensure that the secret message `s` remains confidential and not accessible by an attacker. The attacker is queried to determine if they can successfully learn the value of `s`.\n\n**Key Functions**:\n- `sign(G, skey)`: Generates a signature for a message `G` using the secret key `skey`.\n- `pk(skey)`: Computes the public key from the secret key.\n- `enc(bitstring, G)`: Encrypts a bitstring using a shared key `G`.\n- `dec(enc(x,y),y)`: Decrypts the encrypted message using the key `y`.\n\n**Conclusion**:\nThis protocol successfully establishes a shared secret key between two parties while ensuring the authenticity of the exchanged messages through digital signatures. The use of nonces helps prevent replay attacks, and the secure exchange of public keys ensures that the parties can derive the same shared key independently.\n\n---",
        "codefrom:": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree c: channel.\n\ntype pkey.\ntype skey.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(skey):pkey.\nreduc forall m: G, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(s).\n\n(* The process *)\n\nlet p0(skA: skey, pkA: pkey, pkB: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(g, n0), skA), pkA));\n\t in(c,m1: bitstring); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = pkB then\n\t out(c, enc(s,k)).\n\nlet p1(skB: skey, pkB: pkey, pkA: pkey) = \n         in(c, (m0: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, n1) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(m,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew skB: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)",
        "resultsfrom": [
            true,
            [
                true,
                "RESULT not attacker(s[]) is true.\n",
                0.010365009307861328
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/signed_dh.maude",
        "fileto": "CV-1/template-signedDH.ocv",
        "logicfrom": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "codefrom:": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "resultsfrom": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:05:58 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 3936654 in 4176ms cpu (4176ms real) (942685 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   +(a ; b ; exp(g, n(a, r:Fresh)) ; sign(a, b ; exp(g, n(a, r:Fresh)))), \n   -(a ; b ; XE:Exp ; sign(b, a ; XE:Exp)) | nil] \n|| \nexp(XE:Exp, n(a, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 5388413 in 7228ms cpu (7229ms real) (745491 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                12.282142162322998
            ]
        ]
    },
    {
        "filefrom": "CV-1/template-signedDH.ocv",
        "fileto": "MAUDE-1/signed_dh.maude",
        "logicfrom": "To create a description content for the protocol that corresponds to the provided OCV file, we need to detail the components of the protocol, their roles, and the overall logic flow in a way that allows for the regeneration of the OCV file.\n\nHere's a structured description of the protocol based on the given content:\n\n---\n\n### Protocol Description\n\n#### Overview\nThis protocol describes a secure communication mechanism between two parties, denoted as agents A and B, using a combination of the Diffie-Hellman key exchange, digital signatures, and a public key infrastructure (PKI). The protocol aims to establish a secure channel for message exchange while ensuring authenticity and integrity through the use of cryptographic signatures.\n\n#### Participants\n- **Agents**: The protocol involves `NA` instances of agent A and `NB` instances of agent B.\n- **Public Keys**: The protocol supports `NK` public keys for signing purposes.\n\n#### Cryptographic Primitives\n1. **Diffie-Hellman Key Exchange**:\n   - Utilizes a finite group `G` and a generator `g` to enable agents to derive a shared secret key through exponentiation.\n   - Assumptions include collision probabilities (`PCollKey1` and `PCollKey2`) to ensure security against certain types of attacks.\n\n2. **Hash Function**:\n   - A random oracle model is employed to define a hash function which maps inputs from group `G` to a finite key space.\n   - This hash function plays a crucial role in the signing and verification process.\n\n3. **Digital Signatures**:\n   - The protocol employs a signature scheme characterized by the security properties of unforgeability under chosen-message attacks (UF-CMA).\n   - The signature scheme involves the generation of secret keys and public keys, signing messages, and verifying signatures.\n\n#### Processes\n1. **Key Generation**:\n   - Each agent generates a signing key pair consisting of a secret key (`skey`) and a public key (`pkey`) using a key seed (`keyseed`).\n\n2. **Process A**:\n   - Runs concurrently for each instance of agent A.\n   - Engages in message signing and verification, utilizing the hash function to ensure message integrity.\n\n3. **Process B**:\n   - Similar to process A, but for agent B.\n   - Also involves signing and verification of messages.\n\n4. **Public Key Infrastructure (PKI)**:\n   - Handles the association between public keys of agents A and B.\n   - Ensures that agents can verify each other's signatures based on their public keys.\n\n5. **Execution Flow**:\n   - The protocol starts by generating a hash function and the key pairs for agents A and B.\n   - Each instance of agent A and B runs concurrently, performing their respective operations, alongside the PKI processes and the hash oracle.\n\n#### Security Assumptions\n- **Collision Resistance**: The protocol assumes certain probabilities (`PCollKey1`, `PCollKey2`) concerning the difficulty of finding collisions in the derived keys.\n- **Computational Diffie-Hellman (CDH) Assumption**: Assumes difficulty in solving the CDH problem within group `G`.\n\n#### Conclusion\nThis protocol ensures secure communication between multiple instances of agents A and B through a well-defined process utilizing Diffie-Hellman key exchange, digital signatures, and a robust public key infrastructure, while maintaining the security properties required for reliable and authenticated message exchange.\n\n---\n\n### Final Notes\n- The description provides a comprehensive overview while preserving the technical details necessary for the reconstruction of the OCV file.\n- The placeholders marked as `TODO` in the original OCV file imply that additional specifications, such as the event definitions and secrecy queries, need to be addressed in the final implementation based on the protocol's requirements.\n\nThis description can be further tailored to include specific details about the actions taken by processes A and B, the exact nature of the messages exchanged, or any additional security features relevant to the protocol's implementation.",
        "codefrom:": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers *)\ntype keyseed [large,fixed].  (* seed for signing key generation *)\ntype pkey [bounded].  (* signing public key *)\ntype skey [bounded].  (* signing secret key *)\ntype message [bounded]. (* the signed message space *)\ntype signature [bounded]. (* the output signature space *)\n\ntype G [large,bounded]. (* the finite group definition *)\ntype Z [large,bounded]. (* the field of the exponents of the group *)\ntype key [fixed]. (* the output of the hash function, also corresponding to the final keys space *)\n\n(* Basic Diffie-Hellman declarations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* This collision assumption is needed to prove an injective\n   correspondence, because we use ephemerals to distinguish sessions. *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision says that\n   - the probability that exp(g, x) = Y for random x and Y independent of x\n   is at most PCollKey1, and\n   - the probability that exp(g, mult(x,y)) = Y where x and y are independent\n   random private keys and Y is independent of x or y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator *)\n  exp,      (* exponentiation function *)\n  exp',     (* exp. func. after transformation *)\n  mult,     (* func. for exponent multiplication *)\n  PCollKey1,(*  *)\n  PCollKey2\n).\n\n(* CDH assumption *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n\n(* Hash in the random oracle model *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input *)\n  key,          (* type of output *)\n  hash,         (* name of hash function *)\n  hashoracle,   (* process defining the hash oracle *)\n  qH            (* parameter: number of calls *)\n).\n\n\n(* Signatures *)\nproba Psign.\nproba Psigncoll.\n(* expand UF_CMA_det_signature( *)\nexpand UF_CMA_proba_signature(\n  (* types, to be defined outside the macro *)\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  (* names for functions defined by the macro *)\n  skgen,\n  pkgen,\n  sign,\n  verify,\n  (* probabilities, to be defined outside the macro *)\n  Psign,     (* breaking the UF-CMA property *)\n  Psigncoll  (* collision between independently gen. keys *)\n).\n\n\n(* The two honest peers *)\nconst A,B:host.\n\n(* TODO secrecy queries *)\n\n(* TODO event definition + authentication queries *)\n\n(* TODO table definition for public key infrastructure *)\n\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO. *)\n\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO. *)\n\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO *) \n   SomeOtherOtherOracleTODO () := return.\n   \nletfun keygen() =\n  rk <-R keyseed;\n  sk <- skgen(rk);\n  pk <- pkgen(rk);\n  (sk, pk).\n\n(* final process declaration *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction;\n    let (skA: skey, pkA: pkey) = keygen() in\n    let (skB: skey, pkB: pkey) = keygen() in\n    return(pkA, pkB);\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))\n     |\n      run hashoracle(hf)\n    )",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved indistinguishability between the input game and the final game up to probability Psign(time_2, 0) + Psign(time_1, 0)\nRESULT time_1 = time(pkgen) + time + -1 * time(verify)\nRESULT time_2 = time(pkgen2) + time + -1 * time(verify)\nAll queries proved.",
                    0.06919527053833008
                ]
            ]
        ]
    },
    {
        "filefrom": "PV-1/signedDH.pv",
        "fileto": "CV-1/template-signedDH.ocv",
        "logicfrom": "---\n\n### Description of the Signed Diffie-Hellman Protocol\n\n**Overview:**\nThe Signed Diffie-Hellman protocol is a cryptographic method that allows two parties, A and B, to establish a shared secret key over an insecure channel. The protocol utilizes public key cryptography to ensure the authenticity of the messages exchanged between the two parties. Each participant has a private key (skey) and a corresponding public key (pkey).\n\n**Participants:**\n- **A (Alice)**: One party in the communication, holds a secret key `skA` and its public key `pkA`.\n- **B (Bob)**: The other party in the communication, holds a secret key `skB` and its public key `pkB`.\n\n**Protocol Steps:**\n1. **Key Generation**:\n   - A generates a secret key `skA` and computes its public key `pkA` using the function `pk(skey)`.\n\n2. **Public Key Exchange**:\n   - A sends its public key `pkA` to B over a channel `c`.\n\n3. **Nonce Generation**:\n   - A generates a fresh nonce `n0` (an exponent in the Diffie-Hellman context) and computes a signature on the value `exp(g, n0)` using its secret key `skA`. The message sent to B includes the signed value and A's public key: `{ exp(g, n0) }skA, pkA`.\n\n4. **Response from B**:\n   - B receives the message containing A's signed value and public key. B uses the public key `pkX` (which is `pkA`) to verify the signature. \n   - Upon successful verification, B generates a fresh nonce `n1` and computes the shared key `k` using the received value: `k = exp(exp(g, n0), n1)` (which can also be written as `k = exp(exp(g, n1), n0)` due to the properties of exponentiation).\n   - B then sends back a signed message `{ exp(g, n1) }skB` to A.\n\n5. **Final Message**:\n   - A receives the signed message from B and verifies it using `pkB`. \n   - A then computes the shared key `k` again (the same as B), and sends a secret message `s`, encrypted with the shared key `k`, to B using the encryption function `enc(bitstring, G)`.\n\n**Security Goal**:\n- The protocol aims to ensure that the secret message `s` remains confidential and not accessible by an attacker. The attacker is queried to determine if they can successfully learn the value of `s`.\n\n**Key Functions**:\n- `sign(G, skey)`: Generates a signature for a message `G` using the secret key `skey`.\n- `pk(skey)`: Computes the public key from the secret key.\n- `enc(bitstring, G)`: Encrypts a bitstring using a shared key `G`.\n- `dec(enc(x,y),y)`: Decrypts the encrypted message using the key `y`.\n\n**Conclusion**:\nThis protocol successfully establishes a shared secret key between two parties while ensuring the authenticity of the exchanged messages through digital signatures. The use of nonces helps prevent replay attacks, and the secure exchange of public keys ensures that the parties can derive the same shared key independently.\n\n---",
        "codefrom:": "(* From Proverif git examples directory *)\n\n(* Signed Diffie-Hellman\n\tA -> B : { e^n0 }skA, pkA    (n0 fresh)\n        B -> A : { e^n1 }skB         (n1 fresh)\n          A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0\n        A -> B : { s }k\n\n *)\n\nfree c: channel.\n\ntype pkey.\ntype skey.\ntype G.\ntype exponent.\n\n(* Signatures *)\n\nfun sign(G, skey): bitstring.\nfun pk(skey):pkey.\nreduc forall m: G, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: G, k: skey; checksign(sign(m,k), pk(k)) = m.\n\n(* Shared key encryption *)\n\nfun enc(bitstring, G): bitstring.\nreduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.\n\n(* Diffie-Hellman *)\n\nconst g: G.\nfun exp(G, exponent): G.\nequation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).\n\n(* Test whether s is secret *)\n\nfree s: bitstring [private].\nquery attacker(s).\n\n(* The process *)\n\nlet p0(skA: skey, pkA: pkey, pkB: pkey) = \n         in(c, pkX: pkey);\n\t new n0: exponent; \n         out(c,(sign(exp(g, n0), skA), pkA));\n\t in(c,m1: bitstring); \n\t let x1 = checksign(m1, pkX) in\n\t let k = exp(x1, n0) in \n  \t if pkX = pkB then\n\t out(c, enc(s,k)).\n\nlet p1(skB: skey, pkB: pkey, pkA: pkey) = \n         in(c, (m0: bitstring, pkY: pkey));\n\t let x0 = checksign(m0, pkY) in\n\t new n1: exponent; \n         let k = exp(x0, n1) in \n         out(c,sign(exp(g, n1), skB));\n         in (c,m: bitstring); \n         let s2 = dec(m,k) in 0.\n\nprocess \n\tnew skA: skey;\n\tlet pkA = pk(skA) in\n\tout(c, pkA);\n\tnew skB: skey;\n\tlet pkB = pk(skB) in\n\tout(c, pkB);\n\t((!p0(skA, pkA, pkB)) | (!p1(skB, pkB, pkA)))\n\n(* EXPECTPV\nRESULT not attacker(s[]) is true.\n0.009s (user 0.006s + system 0.003s), max rss 10060K\nEND *)",
        "resultsfrom": [
            true,
            [
                true,
                "RESULT not attacker(s[]) is true.\n",
                0.010365009307861328
            ]
        ]
    },
    {
        "filefrom": "CV-1/template-signedDH.ocv",
        "fileto": "PV-1/signedDH.pv",
        "logicfrom": "To create a description content for the protocol that corresponds to the provided OCV file, we need to detail the components of the protocol, their roles, and the overall logic flow in a way that allows for the regeneration of the OCV file.\n\nHere's a structured description of the protocol based on the given content:\n\n---\n\n### Protocol Description\n\n#### Overview\nThis protocol describes a secure communication mechanism between two parties, denoted as agents A and B, using a combination of the Diffie-Hellman key exchange, digital signatures, and a public key infrastructure (PKI). The protocol aims to establish a secure channel for message exchange while ensuring authenticity and integrity through the use of cryptographic signatures.\n\n#### Participants\n- **Agents**: The protocol involves `NA` instances of agent A and `NB` instances of agent B.\n- **Public Keys**: The protocol supports `NK` public keys for signing purposes.\n\n#### Cryptographic Primitives\n1. **Diffie-Hellman Key Exchange**:\n   - Utilizes a finite group `G` and a generator `g` to enable agents to derive a shared secret key through exponentiation.\n   - Assumptions include collision probabilities (`PCollKey1` and `PCollKey2`) to ensure security against certain types of attacks.\n\n2. **Hash Function**:\n   - A random oracle model is employed to define a hash function which maps inputs from group `G` to a finite key space.\n   - This hash function plays a crucial role in the signing and verification process.\n\n3. **Digital Signatures**:\n   - The protocol employs a signature scheme characterized by the security properties of unforgeability under chosen-message attacks (UF-CMA).\n   - The signature scheme involves the generation of secret keys and public keys, signing messages, and verifying signatures.\n\n#### Processes\n1. **Key Generation**:\n   - Each agent generates a signing key pair consisting of a secret key (`skey`) and a public key (`pkey`) using a key seed (`keyseed`).\n\n2. **Process A**:\n   - Runs concurrently for each instance of agent A.\n   - Engages in message signing and verification, utilizing the hash function to ensure message integrity.\n\n3. **Process B**:\n   - Similar to process A, but for agent B.\n   - Also involves signing and verification of messages.\n\n4. **Public Key Infrastructure (PKI)**:\n   - Handles the association between public keys of agents A and B.\n   - Ensures that agents can verify each other's signatures based on their public keys.\n\n5. **Execution Flow**:\n   - The protocol starts by generating a hash function and the key pairs for agents A and B.\n   - Each instance of agent A and B runs concurrently, performing their respective operations, alongside the PKI processes and the hash oracle.\n\n#### Security Assumptions\n- **Collision Resistance**: The protocol assumes certain probabilities (`PCollKey1`, `PCollKey2`) concerning the difficulty of finding collisions in the derived keys.\n- **Computational Diffie-Hellman (CDH) Assumption**: Assumes difficulty in solving the CDH problem within group `G`.\n\n#### Conclusion\nThis protocol ensures secure communication between multiple instances of agents A and B through a well-defined process utilizing Diffie-Hellman key exchange, digital signatures, and a robust public key infrastructure, while maintaining the security properties required for reliable and authenticated message exchange.\n\n---\n\n### Final Notes\n- The description provides a comprehensive overview while preserving the technical details necessary for the reconstruction of the OCV file.\n- The placeholders marked as `TODO` in the original OCV file imply that additional specifications, such as the event definitions and secrecy queries, need to be addressed in the final implementation based on the protocol's requirements.\n\nThis description can be further tailored to include specific details about the actions taken by processes A and B, the exact nature of the messages exchanged, or any additional security features relevant to the protocol's implementation.",
        "codefrom:": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers *)\ntype keyseed [large,fixed].  (* seed for signing key generation *)\ntype pkey [bounded].  (* signing public key *)\ntype skey [bounded].  (* signing secret key *)\ntype message [bounded]. (* the signed message space *)\ntype signature [bounded]. (* the output signature space *)\n\ntype G [large,bounded]. (* the finite group definition *)\ntype Z [large,bounded]. (* the field of the exponents of the group *)\ntype key [fixed]. (* the output of the hash function, also corresponding to the final keys space *)\n\n(* Basic Diffie-Hellman declarations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* This collision assumption is needed to prove an injective\n   correspondence, because we use ephemerals to distinguish sessions. *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision says that\n   - the probability that exp(g, x) = Y for random x and Y independent of x\n   is at most PCollKey1, and\n   - the probability that exp(g, mult(x,y)) = Y where x and y are independent\n   random private keys and Y is independent of x or y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator *)\n  exp,      (* exponentiation function *)\n  exp',     (* exp. func. after transformation *)\n  mult,     (* func. for exponent multiplication *)\n  PCollKey1,(*  *)\n  PCollKey2\n).\n\n(* CDH assumption *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n\n(* Hash in the random oracle model *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input *)\n  key,          (* type of output *)\n  hash,         (* name of hash function *)\n  hashoracle,   (* process defining the hash oracle *)\n  qH            (* parameter: number of calls *)\n).\n\n\n(* Signatures *)\nproba Psign.\nproba Psigncoll.\n(* expand UF_CMA_det_signature( *)\nexpand UF_CMA_proba_signature(\n  (* types, to be defined outside the macro *)\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  (* names for functions defined by the macro *)\n  skgen,\n  pkgen,\n  sign,\n  verify,\n  (* probabilities, to be defined outside the macro *)\n  Psign,     (* breaking the UF-CMA property *)\n  Psigncoll  (* collision between independently gen. keys *)\n).\n\n\n(* The two honest peers *)\nconst A,B:host.\n\n(* TODO secrecy queries *)\n\n(* TODO event definition + authentication queries *)\n\n(* TODO table definition for public key infrastructure *)\n\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO. *)\n\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO. *)\n\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO *) \n   SomeOtherOtherOracleTODO () := return.\n   \nletfun keygen() =\n  rk <-R keyseed;\n  sk <- skgen(rk);\n  pk <- pkgen(rk);\n  (sk, pk).\n\n(* final process declaration *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction;\n    let (skA: skey, pkA: pkey) = keygen() in\n    let (skB: skey, pkB: pkey) = keygen() in\n    return(pkA, pkB);\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))\n     |\n      run hashoracle(hf)\n    )",
        "resultsfrom": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved indistinguishability between the input game and the final game up to probability Psign(time_2, 0) + Psign(time_1, 0)\nRESULT time_1 = time(pkgen) + time + -1 * time(verify)\nRESULT time_2 = time(pkgen2) + time + -1 * time(verify)\nAll queries proved.",
                    0.06919527053833008
                ]
            ]
        ]
    },
    {
        "filefrom": "SPTHY-1/STS_MAC.spthy",
        "fileto": "SPDL-1/sts-mac.spdl",
        "logicfrom": "---\n\n### Protocol Description: Station-To-Station (STS) Protocol - MAC Variant\n\n**Overview:**\nThe Station-To-Station (STS) protocol is a cryptographic protocol designed to establish a shared secret key between two parties (often referred to as Alice and Bob) while ensuring authentication and confidentiality. This specific variant incorporates Message Authentication Codes (MACs) to provide integrity and authenticity for the messages exchanged between the parties.\n\n**Modeler:** Cas Cremers  \n**Date:** January 2012  \n**Source:** \"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\" by Blake-Wilson, Simon, and Menezes, Alfred, PKC '99, Springer, 1999  \n**Status:** Working\n\n---\n\n**Key Features:**\n\n1. **Public Key Infrastructure:**\n   - The protocol assumes a public key infrastructure where public keys are regarded as certificates.\n   - Adversaries may re-register public keys, claiming ownership of the keys associated with corrupt identities.\n\n2. **Protocol Steps:**\n   - The protocol consists of two main phases: initialization and response, where each party generates ephemeral keys and signs messages.\n   - **Initialization Phase:**\n     - Party I generates its ephemeral public key (`epkI`) and sends it alongside its identity and a nonce to party R.\n     - Party R responds with its ephemeral public key (`epkR`), a signature on the message received from I, and the corresponding MAC.\n   - **Response Phase:**\n     - Party R receives I's message and verifies it using the MAC and signature.\n     - Party I and R calculate a shared secret key using a Key Derivation Function (KDF) based on the exchanged nonces and ephemeral keys.\n\n3. **Session Key Management:**\n   - The protocol allows for the revelation of session keys under certain conditions, ensuring that only authorized parties can access the shared secret.\n\n---\n\n**Security Properties:**\n- The protocol aims to provide Perfect Forward Secrecy (PFS), meaning that even if long-term private keys are compromised, past session keys remain secure and cannot be derived.\n- Two lemmas ensure that if a session key is accepted by a party, it cannot be revealed to an adversary who has not corrupted either party involved in the session.\n\n---\n\n**Implementation in Tamarin:**\nThe Tamarin tool is employed to formally verify the security properties of the STS protocol. The verification rules defined in the Tamarin script include:\n\n- **Register_pk_clone:** Models the re-registration of public keys by an adversary.\n- **Init_1 & Init_2:** Define the initialization steps of the protocol, including the generation of ephemeral keys and the sending of messages.\n- **Resp_1 & Resp_2:** Outline the response steps where party R verifies the message from party I and sends back its own response.\n- **Sessionkey_Reveal:** Allows for the controlled revelation of session keys under specific conditions.\n- **Lemmas for Perfect Forward Secrecy:** Ensure that session keys remain secure despite potential adversarial actions.\n\n---",
        "codefrom:": "theory STS_MAC\nbegin\n\nbuiltins: diffie-hellman, hashing, signing\n\nfunctions: mac/2\nfunctions: KDF/1\n\nsection{* The Station-To-Station Protocol (MAC version) *}\n\n/*\n * Protocol:\tStation-To-Station, MAC variant\n * Modeler: \tCas Cremers\n * Date: \tJanuary 2012\n * Source:\t\"Unknown Key-Share Attacks on the Station-to-Station (STS) Protocol\"\n *\t\tBlake-Wilson, Simon and Menezes, Alfred\n * \t\tPKC '99, Springer, 1999\n *\n * Status: \tworking\n */\n\n// Public key infrastructure\n/**\n * The !Pk facts can be regarded as certificates\n *\n * Here we model that the adversary might (and in fact always does)\n * re-registers the public keys as his own, i.e., he claims a copy of\n * the public key for the corrupt name E.\n */\nrule Register_pk_clone:\n  [ Fr(~ltk) ] \n  --[ LtkSet($A, ~ltk), Corrupt($E) ]-> \n  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), !Pk($E, pk(~ltk)), Out(pk(~ltk)) ]\n\n// Protocol\nrule Init_1:\n  let epkI = 'g'^~ekI\n  in\n  [ Fr(~ekI), !Ltk($I, ~ltkI) ]\n  -->\n  [ Init_1( $I, $R, ~ltkI, ~ekI )\n  , Out( <$I, $R, epkI> ) ]\n\nrule Init_2:\n  let epkI = 'g'^~ekI\n      sigI = sign{ epkI, Y }~ltkI\n      sigR = sign{ Y, epkI }~ltkR\n      keymat = Y^~ekI\n      key = KDF(keymat)\n  in\n    [ Init_1( $I, $R, ~ltkI, ~ekI )\n    , !Pk($R, pk(~ltkR))\n    , In( <$R, $I, Y, sigR, mac( keymat, sigR)\n      > ) ]\n  --[ AcceptedI(~ekI,$I,$R,epkI,Y, key) ]->\n    [ Out( <$I, $R, sigI, mac( keymat, sigI) > ),\n      !SessionKey(~ekI,$I,$R, key)\n    ]\n\nrule Resp_1:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Ltk($R, ~ltkR)\n    , Fr(~ekR)\n    , In( <$I, $R, X > ) ]\n  -->\n    [ Resp_1( $I, $R, ~ltkR, ~ekR, X )\n    , Out(< $R, $I, epkR, sigR, mac( keymat, sigR ) >) \n    ]\n\n\nrule Resp_2:\n  let epkR = 'g'^~ekR\n      sigI = sign{ X, epkR }~ltkI\n      sigR = sign{ epkR, X }~ltkR\n      keymat = X^~ekR\n      key = KDF(keymat)\n  in\n    [ !Pk($I, pk(~ltkI))\n    , Resp_1( $I, $R, ~ltkR, ~ekR, X )\n    , In( <$I, $R, sigI, mac( keymat, sigI ) >)\n    ]\n  --[ AcceptedR(~ekR,$I,$R,X,epkR, key ) ]->\n    [ !SessionKey(~ekR,$I,$R, key) ]\n\n\n\nrule Sessionkey_Reveal:\n    [ !SessionKey(~tid, $I,$R,k) ]\n  --[ SesskRev(~tid) ]->\n    [ Out(k) ]\n\nlemma KI_Perfect_Forward_Secrecy_I:\n  \"not (Ex ttest I R sessKey #i1 #k hki hkr.\n     AcceptedI(ttest,I,R,hki,hkr,sessKey) @ i1 &\n     not (Ex #r. Corrupt(I) @ r) &\n     not (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session key reveal of test\n     not (Ex #i3. SesskRev(ttest) @ i3) &\n     // No session key reveal of partner\n     not (Ex #i3 #i4 tpartner kpartner. SesskRev(tpartner) @ i3\n          & AcceptedR(tpartner,I,R,hki,hkr,kpartner) @ i4\n         ) \n     )\n  \"\n\nlemma KI_Perfect_Forward_Secrecy_R:\n  \"not (Ex ttest I R sessKey #i1 #k hki hkr.\n     AcceptedR(ttest,I,R,hki,hkr,sessKey) @ i1 &\n     not (Ex #r. Corrupt(I) @ r) &\n     not (Ex #r. Corrupt(R) @ r) &\n     K(sessKey) @ k &\n     // No session key reveal of test\n     not (Ex #i3. SesskRev(ttest) @ i3) &\n     // No session key reveal of partner\n     not (Ex #i3 #i4 tpartner kpartner. SesskRev(tpartner) @ i3\n          & AcceptedI(tpartner,I,R,hki,hkr,kpartner) @ i4\n         ) \n     )\n  \"\n\n\n\nend",
        "resultsfrom": [
            true,
            [
                false,
                "summary of summaries:\n\nanalyzed: /home/usr/\u684c\u9762/ProtocolFA-main/dataset/dataset/SPTHY-1/STS_MAC.spthy\n\n  KI_Perfect_Forward_Secrecy_I (all-traces): falsified - found trace (12 steps)\n  KI_Perfect_Forward_Secrecy_R (all-traces): falsified - found trace (12 steps)\n\n",
                1.5244934558868408
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/sts-mac.spdl",
        "fileto": "SPTHY-1/STS_MAC.spthy",
        "logicfrom": "To generate a description content for the given SPDL file that can be used to recreate the corresponding SPDL file in Scyther, we can break down the protocol into its key components, including the roles, messages exchanged, cryptographic functions used, and the claims made by each role. Below is the description content based on the provided SPDL file.\n\n---\n\n### Description of the Protocol\n\n**Protocol Name:** STS-MAC\n\n**Overview:**\nThe STS-MAC (Secure Ticketing System with Message Authentication Code) protocol is designed to facilitate secure communication between two parties, denoted as initiator (I) and responder (R), using Diffie-Hellman key exchange and message authentication codes (MAC). The protocol ensures the confidentiality and integrity of the messages exchanged, as well as mutual authentication and agreement on a shared secret.\n\n**Roles:**\n1. **Initiator (I)**\n2. **Responder (R)**\n3. **Oracle (O)**\n4. **Diffie-Hellman (DH)**\n5. **SWAP**\n\n**Cryptographic Functions:**\n- **Hash Functions:**\n  - `g`: A hash function used in the protocol.\n  - `h`: Another hash function used for generating MAC keys.\n- **Key Derivation Functions:**\n  - `KDF`: A key derivation function used to derive session keys from shared secrets.\n- **Message Authentication Codes:**\n  - `MAC`: A function used to ensure the integrity and authenticity of messages.\n\n**Messages:**\n- **From Initiator (I) to Responder (R):**\n  1. `send_1`: Initiator sends a public value `g(i)` (where `i` is a nonce).\n  2. `recv_!2`: Responder receives a ticket `Gr`, a signature {Gr, g(i)} encrypted with the responder's secret key, and a MAC of the form `MAC(h(Gr,i), Gr, g(i))`.\n  3. `send_!3`: Initiator sends a signature {g(i), Gr} encrypted with the initiator's secret key and a MAC of the form `MAC(h(Gr,i), g(i), Gr)`.\n\n- **From Responder (R) to Initiator (I):**\n  1. `recv_1`: Responder receives the public value `Gi`.\n  2. `send_!2`: Responder sends the ticket `Gi`, a signature {g(r), Gi} encrypted with the responder's secret key, and a MAC of the form `MAC(h(Gi,r), g(r), Gi)`.\n  3. `recv_!3`: Responder receives a signature {Gi, g(r)} encrypted with the initiator's secret key and a MAC of the form `MAC(h(Gi,r), Gi, g(r))`.\n\n**Claims:**\n- Both roles (I and R) make the following claims:\n  - `claim( SKR, KDF(h(Gr,i)) )`: The shared secret key `SKR` is derived using the key derivation function and the hash of the ticket and nonce.\n  - `claim( Alive )`: Ensures that both parties are alive and reachable.\n  - `claim( Weakagree )`: Ensures that both parties have agreed on the same session key.\n\n**Additional Protocols:**\n- **Diffie-Hellman Protocol:**\n  - The `DH` role initiates the key exchange using nonces and hash functions.\n- **SWAP Protocol:**\n  - The `SWAP` role is responsible for handling message exchanges with the derived keys.\n\n---\n\nThis structured description can be used to generate a corresponding SPDL file for Scyther, capturing the essential details of the STS-MAC protocol. If you need specific code snippets or further details on any sections, please let me know!",
        "codefrom:": "# 1 \"sts-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"sts-mac.cpp\"\n# 16 \"sts-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 94 \"common.h\"\nhashfunction MAC;\n\n\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 17 \"sts-mac.cpp\" 2\n\n\n\n\n\n\n\nprotocol @executability(O) {\n\n\n role O {\n  var i, r: Nonce;\n\n\n  recv_!O1( O, O, MAC(h(g(i),r), g(r), g(i)) );\n  send_!O2( O, O, MAC(h(g(r),i), g(r), g(i)) );\n\n\n  recv_!O3( O, O, MAC(h(g(r),i), g(i), g(r)) );\n  send_!O4( O, O, MAC(h(g(i),r), g(i), g(r)) );\n\n }\n\n\n}\n\n\n\nprotocol sts-mac(I, R)\n{\n role I {\n  fresh i: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, g(i) );\n  recv_!2( R, I, Gr, {Gr, g(i)}sk(R), MAC(h(Gr,i), Gr, g(i)) );\n  send_!3( I, R, {g(i), Gr}sk(I), MAC(h(Gr,i), g(i), Gr) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, Gi );\n  send_!2( R, I, Gi, {g(r), Gi}sk(R), MAC(h(Gi,r), g(r), Gi) );\n  recv_!3( I, R, {Gi, g(r)}sk(I), MAC(h(Gi,r), Gi, g(r)) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "sts-mac",
                        "I",
                        "sts-mac,I1",
                        "SKR KDF(h(Gr,i))",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "sts-mac,I2",
                        "Alive",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "sts-mac,I3",
                        "Weakagree",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "R",
                        "sts-mac,R1",
                        "SKR KDF(h(Gi,r))",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "sts-mac,R2",
                        "Alive",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "sts-mac,R3",
                        "Weakagree",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ]
                ],
                21.312886238098145
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/otwayrees.spdl",
        "fileto": "PV-1/OtwayRees.pv",
        "logicfrom": "### Description of the Otway-Rees Protocol\n\n#### Overview\nThe Otway-Rees protocol is a key exchange protocol that facilitates secure communication between two parties, I (Initiator) and R (Responder), using a trusted server S (Server) to mediate the exchange. The protocol utilizes nonces to ensure freshness and prevent replay attacks, and it incorporates symmetric encryption to protect the confidentiality of the messages exchanged.\n\n#### Participants\n- **Initiator (I)**: The party that starts the communication and wants to establish a secure session with the responder.\n- **Responder (R)**: The party that receives the request from the initiator and responds back with the necessary information to establish the session.\n- **Server (S)**: A trusted party that assists in generating and distributing session keys securely between the initiator and responder.\n\n#### Steps of the Protocol\n\n1. **Session Initialization**:\n   - The Initiator (I) generates a nonce (`Ni`) and a message (`M`) and sends an initial request to the Responder (R) and the Server (S). This message includes the nonce and the intended recipients' identities along with a ticket encrypted with the session key.\n\n2. **Response from Responder**:\n   - Upon receiving the initial request, the Responder (R) generates its own nonce (`Nr`) and processes the request. It sends a response back to the Server (S) that includes the nonces and the message. The response is also encrypted with a session key associated with the Responder.\n\n3. **Key Generation and Sending to Initiator**:\n   - The Server (S) receives the request from the Responder and generates a session key (`Kir`). It then sends this key back to the Responder along with the necessary nonces and the message. The Responder forwards the information to the Initiator.\n\n4. **Key Confirmation**:\n   - Finally, the Initiator receives the session key and confirms the establishment of the secure session. Both parties can now use the session key for encrypted communication.\n\n#### Claims\nThe protocol includes several claims that are essential for security verification:\n- **Claim I1**: The Initiator (I) claims that it possesses the session key (`Kir`), asserting its secrecy.\n- **Claim I2**: The Initiator (I) claims that it is synchronized with the Responder (R).\n- **Claim I3**: The Initiator (I) asserts that the session key (`Kir`) is fresh and unique.\n\n- **Claim R1**: The Responder (R) claims possession of the session key (`Kir`), ensuring its secrecy.\n- **Claim R2**: The Responder (R) claims to be synchronized with the Initiator (I).\n- **Claim R3**: The Responder (R) asserts that the session key (`Kir`) is fresh and unique.\n\n#### Security Properties\nThe Otway-Rees protocol is designed to ensure:\n- **Confidentiality**: Information exchanged is only accessible to participating parties.\n- **Authentication**: Only legitimate parties can establish the session.\n- **Freshness**: Nonces ensure that old messages cannot be reused in the protocol.\n- **Key Secrecy**: The session key established is kept secret from eavesdroppers.",
        "codefrom:": "# Otway Rees\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/otwayRees.html\n#\n\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nusertype String,SessionKey;\n\nprotocol otwayrees(I,R,S)\n{\n    role I\n    {\n        fresh Ni : Nonce;\n        fresh M : String;\n        var Kir : SessionKey;\n\n        send_1(I,R, M,I,R,{Ni,M,I,R}k(I,S) );\n        recv_4(R,I, M,{Ni,Kir}k(I,S) );\n\n        claim_I1(I, Secret,Kir);\n        claim_I2(I, Nisynch);\n        claim_I3(I, Empty, (Fresh,Kir));\n    }\n\n    role R\n    {\n        var M : String;\n        fresh Nr : Nonce;\n        var Kir : SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, M,I,R, T1 );\n        send_2(R,S, M,I,R, T1, { Nr,M,I,R }k(R,S) );\n        recv_3(S,R, M, T2, { Nr,Kir }k(R,S) );\n        send_4(R,I, M, T2 );\n\n        claim_R1(R, Secret,Kir);\n        claim_R2(R, Nisynch);\n        claim_R3(R, Empty, (Fresh,Kir));\n    }\n\n    role S\n    {\n        var Ni,Nr : Nonce;\n        var M : String;\n        fresh Kir : SessionKey;\n        \n        recv_2(R,S, M,I,R, { Ni,M,I,R}k(I,S), { Nr,M,I,R }k(R,S) );\n        send_3(S,R, M, { Ni,Kir }k(I,S) , { Nr,Kir }k(R,S) );\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "otwayrees",
                        "I",
                        "otwayrees,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "otwayrees,I2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "R",
                        "otwayrees,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "otwayrees,R2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ]
                ],
                2.409329414367676
            ]
        ]
    },
    {
        "filefrom": "PV-1/OtwayRees.pv",
        "fileto": "SPDL-1/otwayrees.spdl",
        "logicfrom": "---\n\n### Description of the Otway-Rees Protocol\n\nThe Otway-Rees protocol is a cryptographic protocol designed for secure communication between two parties, A and B, with the involvement of a trusted server S. The protocol aims to establish a shared secret (session key) between the two parties while ensuring that their identities and the integrity of the exchanged messages are protected from potential attackers.\n\n#### Protocol Overview\n\n1. **Participants**:\n   - **Initiator (A)**: The party that initiates the communication.\n   - **Responder (B)**: The party that responds to the initiator's request.\n   - **Server (S)**: A trusted third party that assists in key distribution.\n\n2. **Key Definitions**:\n   - Each participant has a unique shared key with the server: \n     - `Kas`: Shared key between participant A and server S.\n     - `Kbs`: Shared key between participant B and server S.\n   - The protocol also uses nonces (random numbers used once) to ensure freshness and prevent replay attacks:\n     - `Na`: Nonce generated by A.\n     - `Nb`: Nonce generated by B.\n     - `C`: A session identifier.\n\n3. **Protocol Steps**:\n   - **Step 1**: A sends a message to B containing a session identifier `C`, its identity `A`, the identity of B, and an encrypted message containing the nonce `Na`, session identifier `C`, and identities of both A and B, encrypted with A's shared key `kA`.\n   - **Step 2**: B receives the message, decrypts it using its own key `kB`, and generates its own nonce `Nb`. B then sends a message to S containing the session information and the encrypted message which includes `Nb`, encrypted with `kB`.\n   - **Step 3**: The server S receives the request from B. It uses the keys of both A and B to decrypt the messages, and then generates a new session key `k`, which it sends back to B, along with the nonces `Na` and `Nb` encrypted with their respective keys.\n   - **Step 4**: B forwards the session information and the server's response back to A, allowing A to complete the session establishment.\n\n4. **Security Properties**:\n   - The protocol ensures confidentiality of the session keys and nonces.\n   - The protocol also guarantees that nonces are unique and not reused, preventing replay attacks.\n   - The secrecy of sensitive information (like `secretA` and `secretB`) is preserved.\n\n5. **Assumptions**:\n   - The protocol assumes the presence of a secure channel for communication.\n   - The keys used for encryption are assumed to be secret and not compromised.\n   - Only two honest hosts A and B are participating in the protocol, while the attacker cannot interfere with the key generation processes.\n\n#### Queries\n\nThe ProVerif tool is used to verify the security properties of the protocol. The following properties are checked:\n- Non-interference of `secretA` and `secretB`, ensuring that these secrets cannot be inferred by an attacker.\n- The system can verify that `secretA` and `secretB` are not exposed during the execution of the protocol.\n\n---\n\n### Generating the PV File\n\nTo generate the corresponding pv file based on this description, you can follow the structure and details provided in the original pv file. Ensure that all types, functions, and roles are accurately represented, along with the necessary queries for ProVerif to analyze the security properties of the protocol.",
        "codefrom:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\n(* Otway Rees protocol.\n   Version of Otway Rees, Operating Systems Review Vol 21 no 1, p 8-10, 1987 \n\nA -> B: (C, A, B, { Na, C, A, B }_kA)\nB -> S: (C, A, B, { Na, C, A, B }_kA, { Nb, C, A, B }_kB)\nS -> B: (C, { Na, k }_kA, { Nb, k }_kB)\nB -> A: (C, { Na, k }_kA)\n\n*)\n\nfree c: channel.\n\ntype key.\ntype host.\ntype nonce.\n\n(* Shared key encryption *)\n\nfun encrypt(bitstring,key): bitstring.\nreduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.\n\n(* Secrecy assumptions *)\n\nnot attacker(new Kas).\nnot attacker(new Kbs).\n\n(* 2 honest host names A and B *)\n\nfree A, B: host.\n\n(* the table host names/keys \n   The key table consists of pairs \n   (host, key shared between the host and the server) *)\ntable keys(host, key).\n\n(* Queries *)\n\nfree secretA, secretB: bitstring [private].\nnoninterf secretA.\nnoninterf secretB.\nnoninterf secretA, secretB.\n\n(* Role of the initiator with identity xA and key kA shared with S *)\n\nlet processInitiator =\n        (* The attacker starts the initiator by choosing identity xA,\n\t   and its interlocutor xB0.\n\t   We check that xA is honest (i.e. is A or B)\n\t   and get its corresponding key.\n\t*)\n        in(c, (xA: host, xB0: host));\n\tif xA = A || xA = B then\n\tget keys(=xA, kA) in\n\t(* Real start of the role *)\n\tnew C: nonce; \n\tnew Na: nonce;\n        out(c, (C, xA, xB0, encrypt((Na, C, xA, xB0), kA)));\n\tin(c, (=C, m2: bitstring));\n\tlet (=Na, k: key) = decrypt(m2, kA) in\n\t(* OK *)\n\tif xB0 = A || xB0 = B then \n\tout(c, encrypt(secretA, k)).\n\n(* Role of the responder with identity xB and key kB shared with S *)\n\nlet processResponder =\n        (* The attacker starts the responder by choosing identity xB.\n\t   We check that xB is honest (i.e. is A or B)\n\t   and get its corresponding key. *)\n        in(c, xB: host);\n\tif xB = A || xB = B then\n\tget keys(=xB, kB) in\n\t(* Real start of the role *)\n\tin(c, (C1: nonce, xA1: host, =xB, m2: bitstring));\n\tnew Nb: nonce;\n\tout(c, (C1, xA1, xB, m2, encrypt((Nb, C1, xA1, xB), kB)));\n\tin(c, (=C1, m3: bitstring, m4: bitstring));\n\tlet (=Nb, k: key) = decrypt(m4, kB) in\n\tout(c, (C1, m3));\n\t(* OK *)\n\tif xA1 = A || xA1 = B then\n\tout(c, encrypt(secretB, k)).\n\n(* Server *)\n\nlet processS = \n        in(c, (C1: nonce, xA1: host, xB1: host, m2: bitstring, m3: bitstring));\n    \tget keys(=xA1, kA1) in\n\tget keys(=xB1, kB1) in\n\tlet (Na1: nonce, =C1, =xA1, =xB1) = decrypt(m2, kA1) in\n\tlet (Nb1: nonce, =C1, =xA1, =xB1) = decrypt(m3, kB1) in\n\tnew k: key;\n        out(c, (C1, encrypt((Na1, k), kA1), \n                    encrypt((Nb1, k), kB1))).\n\n\n(* Key registration *)\n\nlet processK =\n        in(c, (h: host, k: key));\n        if h <> A && h <> B then insert keys(h,k).\n\n(* Start process *)\n\nprocess\n\tnew Kas: key; new Kbs: key;\n\tinsert keys(A, Kas);\n\tinsert keys(B, Kbs);\n\t(\n          (* Launch an unbounded number of sessions of the initiator *)\n          (!processInitiator) | \n          (* Launch an unbounded number of sessions of the responder *)\n          (!processResponder) |\n          (* Launch an unbounded number of sessions of the server *)\n          (!processS) |\n          (* Key registration process *)\n\t  (!processK)\n        )\n\n\n(* EXPECTPV\nRESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\nRESULT Non-interference secretA, secretB cannot be proved.\n0.184s (user 0.180s + system 0.004s), max rss 13316K\nEND *)",
        "resultsfrom": [
            true,
            [
                false,
                "RESULT Non-interference secretA is true.\nRESULT Non-interference secretB is true.\nRESULT Non-interference secretA, secretB cannot be proved.\n",
                0.22212743759155273
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/woo-lam.spdl",
        "fileto": "MAUDE-1/Woo-Lam_Authentication.maude",
        "logicfrom": "---\n\n## Woo and Lam Mutual Authentication Protocol\n\n### Overview\n\nThe Woo and Lam mutual authentication protocol is designed to facilitate secure authentication between two parties (the initiator `I` and the responder `R`) with the involvement of a trusted server `S`. The protocol ensures that both parties can authenticate each other while protecting their identities and ensuring the freshness of the exchanged messages.\n\n### Participants\n\n1. **Initiator (I)**: The party that starts the authentication process.\n2. **Responder (R)**: The party that responds to the initiator's authentication request.\n3. **Server (S)**: A trusted third-party server that helps facilitate the secure exchange of session keys.\n\n### Key Concepts\n\n- **Nonce**: A random number used only once in a session to prevent replay attacks.\n- **Session Key (Kir)**: A key established for secure communication between `I` and `R`.\n- **Ticket**: A piece of information used for authentication, typically containing encrypted data to prove identity.\n\n### Protocol Steps\n\n1. **Step 1 (Initiation)**: The initiator (`I`) generates a nonce (`N1`) and sends it to the responder (`R`) along with its identity.\n   \n   ```\n   send_1(I, R, I, N1);\n   ```\n\n2. **Step 2 (Response)**: The responder (`R`) generates its own nonce (`N2`) and sends it back to `I`, along with its identity.\n   \n   ```\n   recv_2(R, I, R, N2);\n   ```\n\n3. **Step 3 (Session Key Request)**: The initiator sends a message containing its identity, the responder\u2019s identity, and both nonces, encrypted with a session key (`k(I, S)`) to the server.\n   \n   ```\n   send_3(I, R, {I, R, N1, N2}k(I, S));\n   ```\n\n4. **Step 4 (Ticket Generation)**: The server generates a session key (`Kir`) and sends a message to `R`, which includes the responder's identity, both nonces, and the session key, encrypted with `k(R, S)`.\n   \n   ```\n   recv_6(R, I, {R, N1, N2, Kir}k(I, S), {N1, N2}Kir);\n   ```\n\n5. **Step 5 (Final Response)**: The responder (`R`) sends the nonce `N2` back to `I`, encrypted with the session key (`Kir`).\n   \n   ```\n   send_7(I, R, {N2}Kir);\n   ```\n\n### Claims\n\n- **Claim I1**: The initiator (`I`) claims that it has established a secret session key (`Kir`).\n- **Claim I2**: The initiator (`I`) claims that there is no synchronization issue.\n- **Claim I3**: The initiator (`I`) claims that the session key is fresh and has not been compromised.\n\n- **Claim R1**: The responder (`R`) claims that it has established a secret session key (`Kir`).\n- **Claim R2**: The responder (`R`) claims that there is no synchronization issue.\n- **Claim R3**: The responder (`R`) claims that the session key is fresh and has not been compromised.\n\n### Conclusion\n\nThe Woo and Lam mutual authentication protocol effectively provides a mechanism for two parties to authenticate each other and establish a secure session key through a trusted server, while ensuring the freshness of the session keys and preventing replay attacks.\n\n---",
        "codefrom:": "# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var Kir: SessionKey;\n        var N2: Nonce;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, N2);\n        send_3(I,R, {I, R, N1, N2}k(I,S));\n        recv_6(R,I, {R, N1, N2, Kir}k(I,S), {N1,N2}Kir);\n        send_7(I,R, {N2}Kir);\n        \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var Kir: SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, N2);\n        recv_3(I,R, T1);\n        send_4(R,S, T1, {I, R, N1, N2}k(R,S));\n        recv_5(S,R, T2, {I, N1, N2, Kir}k(R,S));\n        send_6(R,I, T2, {N1,N2}Kir);\n        recv_7(I,R, {N2}Kir);\n        \n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var N1,N2: Nonce;\n\n        recv_4(R,S, {I, R, N1, N2}k(I,S), {I, R, N1, N2}k(R,S));\n        send_5(S,R, {R, N1, N2, Kir}k(I,S), {I, N1, N2, Kir}k(R,S));\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "woolam",
                        "I",
                        "woolam,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "woolam,I2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "R",
                        "woolam,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "woolam,R2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ]
                ],
                61.608691692352295
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Woo-Lam_Authentication.maude",
        "fileto": "SPDL-1/woo-lam.spdl",
        "logicfrom": "---\n\n### Woo and Lam Authentication Protocol\n\n#### Overview\nThe Woo and Lam Authentication Protocol is a cryptographic protocol designed to facilitate secure authentication between two users (Alice and Bob) through a trusted server (denoted as 's'). The protocol employs asymmetric encryption, using public keys for secure messaging and nonce values to prevent replay attacks.\n\n#### Participants\n1. **Alice (A)**: A user who wants to authenticate herself to Bob.\n2. **Bob (B)**: A user who wants to verify Alice's identity.\n3. **Server (s)**: A trusted third party that assists in the authentication process.\n\n#### Key Concepts\n- **Public Key Encryption**: The protocol uses a master key (mkey) for encryption and decryption of messages between participants.\n- **Nonces**: Unique values (fresh random numbers) generated for each session to ensure that messages cannot be reused in replay attacks.\n- **Session Keys**: Temporary keys generated for securing the communication session between Alice and Bob.\n\n#### Protocol Steps\n1. **Initialization**: \n   - Alice starts the protocol by generating a nonce (NB) and sending it to the server encrypted with her master key.\n   \n2. **Alice's Request**:\n   - Alice sends an encrypted message containing her nonce to the server, requesting authentication.\n\n3. **Bob's Response**:\n   - Upon receiving the request, the server forwards a message to Bob that includes Alice's encrypted nonce.\n   - Bob generates a nonce (n(B,r)) and sends it back to the server along with an encrypted message containing Alice's identity (A) and the previously received nonce.\n\n4. **Server's Confirmation**:\n   - The server then sends back a confirmation to Alice, encrypting the nonce from Bob to ensure that she can verify Bob's identity.\n\n5. **Completion**:\n   - The communication concludes with both parties having verified each other\u2019s identities through the nonce exchanges and encrypted messages.\n\n#### Security Properties\n- **Confidentiality**: Messages exchanged between participants are encrypted using their respective public keys.\n- **Authentication**: Each participant can verify the identity of the other through the use of nonces.\n- **Replay Protection**: The use of fresh nonces ensures that old messages cannot be reused in future sessions.\n\n#### Maude Implementation Components\n- **Sorts**:\n  - **UName**: User names (Alice, Bob).\n  - **SName**: Server name.\n  - **Nonce**: Fresh random numbers used in the protocol.\n  - **Key**: Cryptographic keys (master and session keys).\n  - **Msg**: Messages exchanged during the protocol.\n\n- **Operations**:\n  - **Encryption (e)** and **Decryption (d)**: Functions for cryptographic operations.\n  - **Nonce Generation (n, mr)**: Functions for generating nonce values.\n  - **Message Construction (txt, _;_)**: Methods for creating messages from various components.\n\n- **Strands**:\n  - **Alice's Strand**: Initiates the protocol by sending a nonce to the server.\n  - **Bob's Strand**: Responds to the server, verifies Alice's message, and generates his nonce.\n  - **Server's Strand**: Forwards messages between Alice and Bob to facilitate authentication.\n\n#### Conclusion\nThe Woo and Lam Authentication Protocol effectively demonstrates the principles of secure authentication using cryptographic techniques. The Maude-NPA implementation captures the crucial elements of the protocol, allowing for formal verification and analysis of its security properties.\n\n---",
        "codefrom:": "---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce  Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S Z G : UName .  \n  vars r r' r'' r''' r# r## r1 rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars M1 M2 MA MB MS MZ N M MB1 MB2 : Msg . \n  var K Kz Kb : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand. \n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)), \n             nil ]\n   &\n     :: r  :: \n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(MA),\n             +(e(mkey(B,s), A ; MA)),\n             -(e(mkey(B,s), n(B,r))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(e(mkey(B,s), A ; e(mkey(A,s) , NB))),\n             +(e(mkey(B,s), NB)), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(MA),\n            +(e(mkey(b,s) , a ; MA)),\n            -(e(mkey(b,s) , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n \nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "resultsfrom": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Thu May  1 01:07:53 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 1043897 in 1196ms cpu (1194ms real) (872823 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(a), \n   +(n(b, r:Fresh)), \n   -(MA:Msg), \n   +(e(mkey(b, s), a ; MA:Msg)), \n   -(e(mkey(b, s), n(b, r:Fresh))) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 6217575 in 6248ms cpu (6248ms real) (995130 rewrites/second)\nresult IdSystem: < 1 . 4 . 1 . 1 . 1 > (\n:: nil ::\n[ nil | \n   +(b), \n   -(n(b, #0:Fresh)), \n   +(e(mkey(b, s), n(b, #0:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   -(a), \n   +(n(b, #0:Fresh)), \n   -(#1:Msg), \n   +(e(mkey(b, s), a ; #1:Msg)), \n   -(e(mkey(b, s), n(b, #0:Fresh))), nil] )\n|| \n#1:Msg !inI,\nn(b, #0:Fresh) !inI,\ne(mkey(b, s), n(b, #0:Fresh)) !inI\n|| \n-(a), \n+(n(b, #0:Fresh)), \ngeneratedByIntruder(#1:Msg), \n-(#1:Msg), \n+(e(mkey(b, s), a ; #1:Msg)), \n+(b), \n-(n(b, #0:Fresh)), \n+(e(mkey(b, s), n(b, #0:Fresh))), \n-(e(mkey(b, s), n(b, #0:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                8.358871459960938
            ]
        ]
    },
    {
        "filefrom": "SPDL-1/woo-lam.spdl",
        "fileto": "PV-1/piwoolam.pi",
        "logicfrom": "---\n\n## Woo and Lam Mutual Authentication Protocol\n\n### Overview\n\nThe Woo and Lam mutual authentication protocol is designed to facilitate secure authentication between two parties (the initiator `I` and the responder `R`) with the involvement of a trusted server `S`. The protocol ensures that both parties can authenticate each other while protecting their identities and ensuring the freshness of the exchanged messages.\n\n### Participants\n\n1. **Initiator (I)**: The party that starts the authentication process.\n2. **Responder (R)**: The party that responds to the initiator's authentication request.\n3. **Server (S)**: A trusted third-party server that helps facilitate the secure exchange of session keys.\n\n### Key Concepts\n\n- **Nonce**: A random number used only once in a session to prevent replay attacks.\n- **Session Key (Kir)**: A key established for secure communication between `I` and `R`.\n- **Ticket**: A piece of information used for authentication, typically containing encrypted data to prove identity.\n\n### Protocol Steps\n\n1. **Step 1 (Initiation)**: The initiator (`I`) generates a nonce (`N1`) and sends it to the responder (`R`) along with its identity.\n   \n   ```\n   send_1(I, R, I, N1);\n   ```\n\n2. **Step 2 (Response)**: The responder (`R`) generates its own nonce (`N2`) and sends it back to `I`, along with its identity.\n   \n   ```\n   recv_2(R, I, R, N2);\n   ```\n\n3. **Step 3 (Session Key Request)**: The initiator sends a message containing its identity, the responder\u2019s identity, and both nonces, encrypted with a session key (`k(I, S)`) to the server.\n   \n   ```\n   send_3(I, R, {I, R, N1, N2}k(I, S));\n   ```\n\n4. **Step 4 (Ticket Generation)**: The server generates a session key (`Kir`) and sends a message to `R`, which includes the responder's identity, both nonces, and the session key, encrypted with `k(R, S)`.\n   \n   ```\n   recv_6(R, I, {R, N1, N2, Kir}k(I, S), {N1, N2}Kir);\n   ```\n\n5. **Step 5 (Final Response)**: The responder (`R`) sends the nonce `N2` back to `I`, encrypted with the session key (`Kir`).\n   \n   ```\n   send_7(I, R, {N2}Kir);\n   ```\n\n### Claims\n\n- **Claim I1**: The initiator (`I`) claims that it has established a secret session key (`Kir`).\n- **Claim I2**: The initiator (`I`) claims that there is no synchronization issue.\n- **Claim I3**: The initiator (`I`) claims that the session key is fresh and has not been compromised.\n\n- **Claim R1**: The responder (`R`) claims that it has established a secret session key (`Kir`).\n- **Claim R2**: The responder (`R`) claims that there is no synchronization issue.\n- **Claim R3**: The responder (`R`) claims that the session key is fresh and has not been compromised.\n\n### Conclusion\n\nThe Woo and Lam mutual authentication protocol effectively provides a mechanism for two parties to authenticate each other and establish a secure session key through a trusted server, while ensuring the freshness of the session keys and preventing replay attacks.\n\n---",
        "codefrom:": "# Woo and Lam Mutual Authentication\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/wooLamMutual.html\n#\n\n\nusertype SessionKey;\n\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol woolam(I,R,S)\n{\n    role I\n    {\n        fresh N1: Nonce;\n        var Kir: SessionKey;\n        var N2: Nonce;\n\n        send_1(I,R, I, N1); \n        recv_2(R,I, R, N2);\n        send_3(I,R, {I, R, N1, N2}k(I,S));\n        recv_6(R,I, {R, N1, N2, Kir}k(I,S), {N1,N2}Kir);\n        send_7(I,R, {N2}Kir);\n        \n\n        claim_I1(I,Secret,Kir);\n        claim_I2(I,Nisynch);\n        claim_I3(I,Empty,(Fresh,Kir));\n    }    \n    \n    role R\n    {\n        fresh N2: Nonce;\n        var N1: Nonce;\n        var Kir: SessionKey;\n        var T1,T2: Ticket;\n\n        recv_1(I,R, I, N1);\n        send_2(R,I, R, N2);\n        recv_3(I,R, T1);\n        send_4(R,S, T1, {I, R, N1, N2}k(R,S));\n        recv_5(S,R, T2, {I, N1, N2, Kir}k(R,S));\n        send_6(R,I, T2, {N1,N2}Kir);\n        recv_7(I,R, {N2}Kir);\n        \n        claim_R1(R,Secret,Kir);\n        claim_R2(R,Nisynch);\n        claim_R3(R,Empty,(Fresh,Kir));\n    }\n\n    role S\n    {\n        fresh Kir: SessionKey;\n        var N1,N2: Nonce;\n\n        recv_4(R,S, {I, R, N1, N2}k(I,S), {I, R, N1, N2}k(R,S));\n        send_5(S,R, {R, N1, N2, Kir}k(I,S), {I, N1, N2, Kir}k(R,S));\n    }\n}",
        "resultsfrom": [
            true,
            [
                false,
                [
                    [
                        "woolam",
                        "I",
                        "woolam,I1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "woolam,I2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ],
                    [
                        "",
                        "R",
                        "woolam,R1",
                        "Secret Kir",
                        "OK",
                        null,
                        "No attacks within bounds.",
                        0,
                        ""
                    ],
                    [
                        "",
                        "",
                        "woolam,R2",
                        "Nisynch",
                        "Fail",
                        "Falsified",
                        "At least 1 attack.",
                        1,
                        "attack"
                    ]
                ],
                61.608691692352295
            ]
        ]
    },
    {
        "filefrom": "PV-1/piwoolam.pi",
        "fileto": "SPDL-1/woo-lam.spdl",
        "logicfrom": "### Protocol Description: WooLam Shared-Key Authentication Protocol\n\n#### Overview:\nThe WooLam protocol is a shared-key authentication protocol designed for secure communication between two parties, A and B, with the involvement of a trusted server, S. The protocol aims to establish mutual authentication between A and B using shared keys.\n\n#### Participants:\n1. **A**: The initiator of the protocol.\n2. **B**: The responder who interacts with A and the server S.\n3. **S**: The trusted server that assists in the authentication process.\n\n#### Cryptographic Primitives:\n- **Encryption**: A cryptographic function that takes a message and a key to produce a ciphertext.\n- **Decryption**: The reverse process of encryption, which takes a ciphertext and a key to retrieve the original message.\n\n#### Key Management:\n- **Keys**: The protocol uses two keys:\n  - `kAS`: The shared key between A and S.\n  - `kBS`: The shared key between B and S.\n  \n#### Message Flow:\n1. **Step 1**: A sends its identity to B.\n   - `A -> B : A`\n  \n2. **Step 2**: B responds to A with a fresh nonce `N`.\n   - `B -> A : N`\n\n3. **Step 3**: A sends a message containing its identity, B's identity, and the nonce `N`, encrypted with the key `kAS`.\n   - `A -> B : { A,B,N }_kAS`\n\n4. **Step 4**: B forwards the encrypted message to the server S, using its own key `kBS`.\n   - `B -> S : { A,B,{ A,B,N }_kAS }_kBS`\n\n5. **Step 5**: S decrypts the message and verifies the contents. It then sends back the message containing A's identity, B's identity, and nonce `N`, encrypted with `kBS`.\n   - `S -> B : { A,B,N }_kBS`\n\n6. **Step 6**: B verifies the received message from S by decrypting it. It checks if the decrypted values match its expectations (i.e., A's identity, B's identity, and nonce `N`).\n   - `B: verify { A,B,N }_kBS = the message from S`\n\n#### Security Assumptions:\n- The keys `kAS` and `kBS` are kept secret and are not known to any adversaries.\n- The nonce `N` is freshly generated for each session to prevent replay attacks.\n\n#### Attack Scenario:\nThe protocol is designed to be secure; however, it has been noted that it terminates with an attack in certain configurations of the messages. The events `endBparam` and `endBfull` indicate the termination of the protocol, and the queries check if these events can be attacked.\n\n### ProVerif Queries:\nThe ProVerif tool is used to verify the security properties of the protocol. The queries check if certain events can be attacked:\n1. The event indicating the end of the protocol `endBparam` should not lead to a successful attack.\n2. The event indicating the end of the full protocol `endBfull` should also not lead to a successful attack.\n\n### Conclusion:\nThe WooLam shared-key authentication protocol employs a trusted server to facilitate secure communication between two parties. It uses cryptographic techniques to ensure mutual authentication, while the ProVerif tool can assist in identifying potential vulnerabilities in the implementation of the protocol.",
        "codefrom:": "(*************************************************************\n *                                                           *\n *  Cryptographic protocol verifier                          *\n *                                                           *\n *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *\n *                                                           *\n *  Copyright (C) INRIA, CNRS 2000-2023                      *\n *                                                           *\n *************************************************************)\n\n(*\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details (in file LICENSE).\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*)\nfree c.\n(*\n\nWooLam shared-key auth protocol (1997)\n\nA -> B : A\nB -> A : N (fresh)\nA -> B : { A,B,N }_kAS\nB -> S : { A,B,{ A,B,N }_kAS }_kBS\nS -> B : { A,B,N }_kBS\nB: verify { A,B,N }_kBS = the message from S\n\nTerminates with an attack\n\n*)\n\n(* Shared-key cryptography *)\n\nfun encrypt/2.\nreduc decrypt(encrypt(m,k),k) = m.\n\n(* Host name / key *)\n\nfun host/1.\nprivate reduc getkey(host(x)) = x.\n\n(* Secrecy assumptions *)\n\nnot kBS.\nnot kAS.\n\nquery evinj:endBparam(x) ==> evinj:beginBparam(x).\nquery evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z).\n\n\nlet processA = \n\tin(c, hostB2); (* Choose the B host *)\n\tevent beginBparam(hostB2);\n        out(c,hostA); in(c,n); \n\tevent beginBfull(hostB2, hostA, n);\n        out(c, encrypt((hostA, hostB2, n), kAS)).\n\nlet processB = \n\tin(c, hostA2); \n\tnew N; \n\tout(c, N); \n\tin(c, m);\n        out(c, encrypt((hostA2, hostB, m), kBS));\n        in(c, m2);\n\tlet (=hostA2, =hostB, =N) = decrypt(m2, kBS) in\n        (* OK *)\n        if hostA2 = hostA then \n\tevent endBparam(hostB);\n\tevent endBfull(hostB, hostA2, N).\n\n\nlet processS = \n\tin(c, hostB0);(* Choose the B host *)\n        in(c,m);\n        let (hostA1, =hostB0, m2) = decrypt(m, getkey(hostB0)) in\n        let (=hostA1, =hostB0, n) = decrypt(m2, getkey(hostA1)) in\n        out(c, encrypt((hostA1, hostB0, n), getkey(hostB0))).\n\nprocess new kAS; new kBS;\n        let hostA = host(kAS) in\n        let hostB = host(kBS) in\n\tout(c, hostA); out(c, hostB);\n\t((!processA) | (!processB) | (!processS))\n\n(* EXPECTPV\nRESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is false.\nRESULT (even ev:endBparam(x) ==> ev:beginBparam(x) is false.)\nRESULT evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z) is false.\nRESULT (even ev:endBfull(x,y,z) ==> ev:beginBfull(x,y,z) is false.)\n0.012s (user 0.008s + system 0.004s), max rss 8560K\nEND *)",
        "resultsfrom": [
            true,
            [
                false,
                "RESULT evinj:endBparam(x) ==> evinj:beginBparam(x) is false.\nRESULT (even ev:endBparam(x) ==> ev:beginBparam(x) is false.)\nRESULT evinj:endBfull(x,y,z) ==> evinj:beginBfull(x,y,z) is false.\nRESULT (even ev:endBfull(x,y,z) ==> ev:beginBfull(x,y,z) is false.)",
                0.01190328598022461
            ]
        ]
    },
    {
        "filefrom": "MAUDE-1/Woo-Lam_Authentication.maude",
        "fileto": "PV-1/piwoolam.pi",
        "logicfrom": "---\n\n### Woo and Lam Authentication Protocol\n\n#### Overview\nThe Woo and Lam Authentication Protocol is a cryptographic protocol designed to facilitate secure authentication between two users (Alice and Bob) through a trusted server (denoted as 's'). The protocol employs asymmetric encryption, using public keys for secure messaging and nonce values to prevent replay attacks.\n\n#### Participants\n1. **Alice (A)**: A user who wants to authenticate herself to Bob.\n2. **Bob (B)**: A user who wants to verify Alice's identity.\n3. **Server (s)**: A trusted third party that assists in the authentication process.\n\n#### Key Concepts\n- **Public Key Encryption**: The protocol uses a master key (mkey) for encryption and decryption of messages between participants.\n- **Nonces**: Unique values (fresh random numbers) generated for each session to ensure that messages cannot be reused in replay attacks.\n- **Session Keys**: Temporary keys generated for securing the communication session between Alice and Bob.\n\n#### Protocol Steps\n1. **Initialization**: \n   - Alice starts the protocol by generating a nonce (NB) and sending it to the server encrypted with her master key.\n   \n2. **Alice's Request**:\n   - Alice sends an encrypted message containing her nonce to the server, requesting authentication.\n\n3. **Bob's Response**:\n   - Upon receiving the request, the server forwards a message to Bob that includes Alice's encrypted nonce.\n   - Bob generates a nonce (n(B,r)) and sends it back to the server along with an encrypted message containing Alice's identity (A) and the previously received nonce.\n\n4. **Server's Confirmation**:\n   - The server then sends back a confirmation to Alice, encrypting the nonce from Bob to ensure that she can verify Bob's identity.\n\n5. **Completion**:\n   - The communication concludes with both parties having verified each other\u2019s identities through the nonce exchanges and encrypted messages.\n\n#### Security Properties\n- **Confidentiality**: Messages exchanged between participants are encrypted using their respective public keys.\n- **Authentication**: Each participant can verify the identity of the other through the use of nonces.\n- **Replay Protection**: The use of fresh nonces ensures that old messages cannot be reused in future sessions.\n\n#### Maude Implementation Components\n- **Sorts**:\n  - **UName**: User names (Alice, Bob).\n  - **SName**: Server name.\n  - **Nonce**: Fresh random numbers used in the protocol.\n  - **Key**: Cryptographic keys (master and session keys).\n  - **Msg**: Messages exchanged during the protocol.\n\n- **Operations**:\n  - **Encryption (e)** and **Decryption (d)**: Functions for cryptographic operations.\n  - **Nonce Generation (n, mr)**: Functions for generating nonce values.\n  - **Message Construction (txt, _;_)**: Methods for creating messages from various components.\n\n- **Strands**:\n  - **Alice's Strand**: Initiates the protocol by sending a nonce to the server.\n  - **Bob's Strand**: Responds to the server, verifies Alice's message, and generates his nonce.\n  - **Server's Strand**: Forwards messages between Alice and Bob to facilitate authentication.\n\n#### Conclusion\nThe Woo and Lam Authentication Protocol effectively demonstrates the principles of secure authentication using cryptographic techniques. The Maude-NPA implementation captures the crucial elements of the protocol, allowing for formal verification and analysis of its security properties.\n\n---",
        "codefrom:": "---- Woo and Lam Authentication Protocols\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey Text .\n  subsort Name Nonce  Key Text < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n  \n     --- text\n  op txt : Name Name Nonce  -> Text [frozen] .\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i z g nm : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e  : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e (K:Key, Z:Msg )) = Z:Msg [variant] .\n eq e(K:Key, d (K:Key, Z:Msg )) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S Z G : UName .  \n  vars r r' r'' r''' r# r## r1 rM : Fresh .\n  var TS NA NMA NB NMB NMS NB1 NZ : Nonce .\n  vars M1 M2 MA MB MS MZ N M MB1 MB2 : Msg . \n  var K Kz Kb : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(M), -(K), +(e(K, M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(A,i)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n\n--- Alice's Strand. \n   = :: nil ::\n     [ nil | +(A),\n             -(NB),\n             +(e(mkey(A,s), NB)), \n             nil ]\n   &\n     :: r  :: \n   --- Bob's Strand.\n     [ nil | -(A),\n             +(n(B,r)),\n             -(MA),\n             +(e(mkey(B,s), A ; MA)),\n             -(e(mkey(B,s), n(B,r))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil |  -(e(mkey(B,s), A ; e(mkey(A,s) , NB))),\n             +(e(mkey(B,s), NB)), \n             nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n:: r ::\n--- A normal execution of the protocol\n    [ nil,  -(a),\n            +(n(b,r)),\n            -(MA),\n            +(e(mkey(b,s) , a ; MA)),\n            -(e(mkey(b,s) , n(b,r))) | nil ]  \n     || empty\n     || nil\n     || nil\n     || nil\n[nonexec] . \n \nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "resultsfrom": [
            true,
            [
                false,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Thu May  1 01:07:53 2025\nMaude> \n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 1043897 in 1196ms cpu (1194ms real) (872823 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(a), \n   +(n(b, r:Fresh)), \n   -(MA:Msg), \n   +(e(mkey(b, s), a ; MA:Msg)), \n   -(e(mkey(b, s), n(b, r:Fresh))) | nil] \n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 6217575 in 6248ms cpu (6248ms real) (995130 rewrites/second)\nresult IdSystem: < 1 . 4 . 1 . 1 . 1 > (\n:: nil ::\n[ nil | \n   +(b), \n   -(n(b, #0:Fresh)), \n   +(e(mkey(b, s), n(b, #0:Fresh))), nil]  & \n:: #0:Fresh ::\n[ nil | \n   -(a), \n   +(n(b, #0:Fresh)), \n   -(#1:Msg), \n   +(e(mkey(b, s), a ; #1:Msg)), \n   -(e(mkey(b, s), n(b, #0:Fresh))), nil] )\n|| \n#1:Msg !inI,\nn(b, #0:Fresh) !inI,\ne(mkey(b, s), n(b, #0:Fresh)) !inI\n|| \n-(a), \n+(n(b, #0:Fresh)), \ngeneratedByIntruder(#1:Msg), \n-(#1:Msg), \n+(e(mkey(b, s), a ; #1:Msg)), \n+(b), \n-(n(b, #0:Fresh)), \n+(e(mkey(b, s), n(b, #0:Fresh))), \n-(e(mkey(b, s), n(b, #0:Fresh)))\n|| \nnil\n|| \nnil\nMaude> Bye.",
                8.358871459960938
            ]
        ]
    }
]