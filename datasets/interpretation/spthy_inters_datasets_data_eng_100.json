[
    {
        "file": "SPTHY-1/ake_KEAplus.spthy",
        "logic": "---\n\n### KEA+ Protocol Description\n\n**Protocol Name**: KEA+  \n**Modelers**: Jannik Dreier, Ralf Sasse  \n**Date**: April 2015  \n**Source**: Lauter, Mityagin, 2006  \n**Property**: Key indistinguishable from randomness  \n**Status**: (To be determined)\n\n#### Overview\nKEA+ is a key exchange protocol that allows two parties to establish a shared secret key over an insecure channel. The protocol is based on the Diffie-Hellman key exchange mechanism and incorporates additional security measures to ensure that the keys generated are indistinguishable from random values.\n\n#### Key Components\n1. **Functions**:\n   - `h/1`: A cryptographic hash function used to generate keys from given inputs.\n   - `g/0`: A generator for the Diffie-Hellman group used in the protocol.\n\n2. **Long-term Keypair Generation**:\n   - Each participant generates a long-term public/private key pair. The public key is derived from the private key using the generator.\n\n3. **Initiator**:\n   - **Step 1**: The initiator generates a session key using their ephemeral secret and sends it along with their identity and the public key of the responder to the responder.\n   - **Step 2**: The initiator computes a derived key based on the public key received from the responder and their long-term key.\n\n4. **Responder**:\n   - **Step 1**: The responder receives the initiator's message, extracts the necessary information, and computes their own session key.\n   - **Step 2**: The responder sends their ephemeral public key along with their computed session key back to the initiator.\n\n#### Protocol Rules\n- **Long-term Key Generation**: Each participant generates a long-term key pair and outputs their public key.\n- **Initiation Phase**: The initiator sends a message to the responder containing their information and the computed session key.\n- **Response Phase**: The responder processes the initiator's message, computes their session key, and sends a response back to the initiator.\n  \n#### Restrictions and Properties\n- **One Key per Name**: A restriction is placed to ensure that each participant has a unique long-term key.\n- **Key Initialization and Response**: The protocol ensures that both parties successfully derive and agree on the session key.\n\n#### Security Lemmas\n- The protocol guarantees that there exists a trace in which both the key initialization by the initiator and the key response by the responder can be observed, ensuring that the keys are established.\n\n### Additional Notes\n- The protocol is designed to prevent key compromise and ensure that the generated keys are secure.\n- The key exchange is modeled within the eCK (extended Canetti-Krawczyk) framework to evaluate its security properties.\n\n---",
        "code": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk($R, pkR) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( Y ) ]\n   --[ //Accept( ~eskI, $I, $R, kI)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(kI)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ~eskR, $R, $I, kR )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\nlemma executable:\n  exists-trace\n  \" Ex #i #j k. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend",
        "codenote": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n   /* pkA is derived from the long-term secret key lkA \n      using the Diffie-Hellman generator g. This rule outputs \n      the long-term key (Ltk) and public key (Pk) for the entity A,\n      and sends pkA to the network. */\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk($R, pkR) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n   /* The initiator generates the ephemeral key hkI \n      and sends the initialization message, including the ephemeral \n      key, to the responder. */\n\n\n/* Second message of Initiator */\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( Y ) ]\n   --[ //Accept( ~eskI, $I, $R, kI)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(kI)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n   /* Upon receiving response Y from the responder,\n      the initiator computes the session key kI and registers \n      the session. */\n\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ~eskR, $R, $I, kR )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n   /* The responder calculates its ephemeral key hkR and session \n      key kR. It sends back hkR and registers the session key. */\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n  /* This restriction ensures that there is only one registration\n     of keys per entity A at a time, maintaining uniqueness in the \n     key registrations. */\n\nlemma executable:\n  exists-trace\n  \" Ex #i #j k. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n  /* The lemma states that there exists a trace where a session \n     key was initialized by the initiator and responded by the \n     responder, ensuring the functionality of the protocol. */\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend"
    },
    {
        "file": "SPTHY-1/ake_NAXOS.spthy",
        "logic": "---\n\n### Protocol Description: NAXOS\n\n#### Overview\nThe NAXOS protocol is an authenticated key exchange protocol designed to ensure that the keys used for communication are indistinguishable from random values. This property is crucial for maintaining the confidentiality and integrity of the exchanged keys, thus providing a secure channel for communication between parties.\n\n#### Authors and Source\n- **Modelers:** Jannik Dreier, Ralf Sasse\n- **Trace-Version Contributors:** Cas Cremers, Benedikt Schmidt\n- **Date:** January 2012 / April 2012\n- **Source:** \"Stronger Security of Authenticated Key Exchange\" by LaMacchia, Lauter, Mityagin, 2007\n\n#### Security Properties\nThe NAXOS protocol aims to achieve the following security properties:\n- **Key Indistinguishability from Randomness:** The keys generated during the exchange should not be distinguishable from random values, ensuring their secrecy and security.\n- **Perfect Forward Secrecy (PFS):** Even if a long-term key is compromised in the future, past session keys remain secure.\n\n#### Protocol Steps\n1. **Key Generation:**\n   - Each party generates a long-term key pair consisting of a private key (lk) and a corresponding public key (pk).\n   - The public key is derived from the private key using a generator `g`.\n\n2. **Initiator's Actions:**\n   - The initiator (I) generates an ephemeral secret key (eskI) and computes a hash value (exI) using a function `h1`.\n   - The initiator sends an initial message containing its ephemeral key and public key to the responder (R).\n\n3. **Responder's Actions:**\n   - Upon receiving the initiator's message, the responder (R) also generates its ephemeral secret key (eskR) and computes a corresponding hash (exR).\n   - The responder then computes a session key (kR) based on received values and sends back a response.\n\n4. **Session Key Establishment:**\n   - Both the initiator and responder compute their respective session keys (kI and kR) using hash functions (h2) based on exchanged values.\n   - The keys are registered for future use in secure communication.\n\n#### Rules and Constraints\n- **Long-term Key Pair Generation:** Each party generates a long-term key pair and registers their public keys.\n- **Session Management:** The initiator and responder keep track of session identifiers to match and verify the sessions.\n- **Restrictions:** The protocol ensures that each party registers at most one public key, preventing key collisions.\n\n#### Security Lemmas\n- **Session Key Consistency Lemma:** If two matching sessions accept different keys, it violates the security of the protocol.\n- **Forward Secrecy Lemma:** If a test session is compromised, certain conditions must be met regarding key reveals to maintain security.\n\n---",
        "code": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* Responder */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n/*\nlemma eCK_PFS_key_secrecy:\n  /* \n   * The property specification very closely follows the original eCK\n   * (ProvSec) paper:\n   *\n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend",
        "codenote": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* \n * This rule generates a long-term key pair for the initiator agent A. \n * It uses a secret long-term key (lkA) to derive a public key (pkA).\n */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* \n * Initiator's first message in the NAXOS protocol. It includes creating \n * a session-specific ephemeral key from its secret key (eskI) and long-term key (lkI). \n */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\n/* \n * Initiator's second message. It involves responding to the initiator's \n * first message, using the responder's public key (pkR) to compute the session key \n * and ensuring the initiation of a secure session.\n */\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* \n * Responder's first message in the NAXOS protocol. It computes the session key \n * using its long-term key (lkR) and the initiator's public key (pkI), \n * and responds with the calculated key (hkr).\n */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\n/* \n * Restriction to ensure that each agent can register only one \n * public key throughout the protocol execution.\n */\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n\n/* \n * Lemma stating that if every agent registers at most one public key, \n * then matching sessions accept the same key. This is vital for security \n * since it prevents key mismatch in concurrent sessions.\n */\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n\n/* \n * Lemma for Perfect Forward Secrecy (PFS) in the eCK model.\n * This specifies that if a Test session's key is known to an adversary,\n * certain session conditions must be true, indicating a compromise.\n */\nlemma eCK_PFS_key_secrecy:\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend"
    }
]