[
    {
        "file": "SPTHY-1/ake_KEAplus.spthy",
        "logic": "---\n\n### KEA+ Protocol Description\n\n**Protocol Name**: KEA+  \n**Modelers**: Jannik Dreier, Ralf Sasse  \n**Date**: April 2015  \n**Source**: Lauter, Mityagin, 2006  \n**Property**: Key indistinguishable from randomness  \n**Status**: (To be determined)\n\n#### Overview\nKEA+ is a key exchange protocol that allows two parties to establish a shared secret key over an insecure channel. The protocol is based on the Diffie-Hellman key exchange mechanism and incorporates additional security measures to ensure that the keys generated are indistinguishable from random values.\n\n#### Key Components\n1. **Functions**:\n   - `h/1`: A cryptographic hash function used to generate keys from given inputs.\n   - `g/0`: A generator for the Diffie-Hellman group used in the protocol.\n\n2. **Long-term Keypair Generation**:\n   - Each participant generates a long-term public/private key pair. The public key is derived from the private key using the generator.\n\n3. **Initiator**:\n   - **Step 1**: The initiator generates a session key using their ephemeral secret and sends it along with their identity and the public key of the responder to the responder.\n   - **Step 2**: The initiator computes a derived key based on the public key received from the responder and their long-term key.\n\n4. **Responder**:\n   - **Step 1**: The responder receives the initiator's message, extracts the necessary information, and computes their own session key.\n   - **Step 2**: The responder sends their ephemeral public key along with their computed session key back to the initiator.\n\n#### Protocol Rules\n- **Long-term Key Generation**: Each participant generates a long-term key pair and outputs their public key.\n- **Initiation Phase**: The initiator sends a message to the responder containing their information and the computed session key.\n- **Response Phase**: The responder processes the initiator's message, computes their session key, and sends a response back to the initiator.\n  \n#### Restrictions and Properties\n- **One Key per Name**: A restriction is placed to ensure that each participant has a unique long-term key.\n- **Key Initialization and Response**: The protocol ensures that both parties successfully derive and agree on the session key.\n\n#### Security Lemmas\n- The protocol guarantees that there exists a trace in which both the key initialization by the initiator and the key response by the responder can be observed, ensuring that the keys are established.\n\n### Additional Notes\n- The protocol is designed to prevent key compromise and ensure that the generated keys are secure.\n- The key exchange is modeled within the eCK (extended Canetti-Krawczyk) framework to evaluate its security properties.\n\n---",
        "code": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk($R, pkR) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( Y ) ]\n   --[ //Accept( ~eskI, $I, $R, kI)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(kI)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ~eskR, $R, $I, kR )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\nlemma executable:\n  exists-trace\n  \" Ex #i #j k. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend",
        "codenote": "theory ake_KEAplus\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* KEA+ *}\n\n/*\n * Protocol:\tKEA+\n * Modeler: \tJannik Dreier, Ralf Sasse\n * Date: \tApril 2015\n * Source:\tLauter, Mityagin, 2006\n * Property: \tKey indistinguishable from randomness\n *\n * Status: \t??\n */\n\nfunctions: h/1, g/0\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = g^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n   /* pkA is derived from the long-term secret key lkA \n      using the Diffie-Hellman generator g. This rule outputs \n      the long-term key (Ltk) and public key (Pk) for the entity A,\n      and sends pkA to the network. */\n\n\n/* Initiator */\nrule Init_1:\n  let // exI = h1(<~eskI, ~lkI >)\n      hkI = g^~eskI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) , !Pk($R, pkR) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n   /* The initiator generates the ephemeral key hkI \n      and sends the initialization message, including the ephemeral \n      key, to the responder. */\n\n\n/* Second message of Initiator */\nrule Init_2:\n  let pkR = g^~lkR\n      kI  = h(< Y^~lkI, pkR^~eskI, g^~lkI, pkR >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI, pkR, hkI),  In( Y ) ]\n   --[ //Accept( ~eskI, $I, $R, kI)\n//     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n//     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n       KeyInit(kI)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n   /* Upon receiving response Y from the responder,\n      the initiator computes the session key kI and registers \n      the session. */\n\n\n/* Responder */\nrule Resp_1:\n  let pkI = g^~lkI\n      hkR = g^~eskR\n      kR  = h(< pkI^~eskR, X^~lkR, pkI, g^~lkR >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ //Accept( ~eskR, $R, $I, kR )\n//     , Sid( ~eskR, <'Resp', $R, $I, X, hkR >)\n//     , Match( ~eskR, <'Init', $I, $R, X, hkR > )\n       KeyResp(kR)\n     ]->\n   [   Out( hkR ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n   /* The responder calculates its ephemeral key hkR and session \n      key kR. It sends back hkR and registers the session key. */\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n  /* This restriction ensures that there is only one registration\n     of keys per entity A at a time, maintaining uniqueness in the \n     key registrations. */\n\nlemma executable:\n  exists-trace\n  \" Ex #i #j k. KeyInit(k)@ i & KeyResp(k)@ j\n  \"\n  /* The lemma states that there exists a trace where a session \n     key was initialized by the initiator and responded by the \n     responder, ensuring the functionality of the protocol. */\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\nend"
    },
    {
        "file": "SPTHY-1/ake_NAXOS.spthy",
        "logic": "---\n\n### Protocol Description: NAXOS\n\n#### Overview\nThe NAXOS protocol is an authenticated key exchange protocol designed to ensure that the keys used for communication are indistinguishable from random values. This property is crucial for maintaining the confidentiality and integrity of the exchanged keys, thus providing a secure channel for communication between parties.\n\n#### Authors and Source\n- **Modelers:** Jannik Dreier, Ralf Sasse\n- **Trace-Version Contributors:** Cas Cremers, Benedikt Schmidt\n- **Date:** January 2012 / April 2012\n- **Source:** \"Stronger Security of Authenticated Key Exchange\" by LaMacchia, Lauter, Mityagin, 2007\n\n#### Security Properties\nThe NAXOS protocol aims to achieve the following security properties:\n- **Key Indistinguishability from Randomness:** The keys generated during the exchange should not be distinguishable from random values, ensuring their secrecy and security.\n- **Perfect Forward Secrecy (PFS):** Even if a long-term key is compromised in the future, past session keys remain secure.\n\n#### Protocol Steps\n1. **Key Generation:**\n   - Each party generates a long-term key pair consisting of a private key (lk) and a corresponding public key (pk).\n   - The public key is derived from the private key using a generator `g`.\n\n2. **Initiator's Actions:**\n   - The initiator (I) generates an ephemeral secret key (eskI) and computes a hash value (exI) using a function `h1`.\n   - The initiator sends an initial message containing its ephemeral key and public key to the responder (R).\n\n3. **Responder's Actions:**\n   - Upon receiving the initiator's message, the responder (R) also generates its ephemeral secret key (eskR) and computes a corresponding hash (exR).\n   - The responder then computes a session key (kR) based on received values and sends back a response.\n\n4. **Session Key Establishment:**\n   - Both the initiator and responder compute their respective session keys (kI and kR) using hash functions (h2) based on exchanged values.\n   - The keys are registered for future use in secure communication.\n\n#### Rules and Constraints\n- **Long-term Key Pair Generation:** Each party generates a long-term key pair and registers their public keys.\n- **Session Management:** The initiator and responder keep track of session identifiers to match and verify the sessions.\n- **Restrictions:** The protocol ensures that each party registers at most one public key, preventing key collisions.\n\n#### Security Lemmas\n- **Session Key Consistency Lemma:** If two matching sessions accept different keys, it violates the security of the protocol.\n- **Forward Secrecy Lemma:** If a test session is compromised, certain conditions must be met regarding key reveals to maintain security.\n\n---",
        "code": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* Initiator */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* Responder */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n/*\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n/*\nlemma eCK_PFS_key_secrecy:\n  /* \n   * The property specification very closely follows the original eCK\n   * (ProvSec) paper:\n   *\n   * If there exists a Test session whose key k is known to the\n   * Adversary, then...\n   */\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend",
        "codenote": "theory ake_NAXOS\nbegin\n\nbuiltins: diffie-hellman\n\nsection{* NAXOS *}\n\n/*\n * Protocol:\tNAXOS\n * Modeler: \tJannik Dreier, Ralf Sasse (based on trace-version by Cas Cremers, Benedikt Schmidt)\n * Date: \tJanuary 2012/April 2012\n * Source:\t\"Stronger Security of Authenticated Key Exchange\"\n * \t\tLaMacchia, Lauter, Mityagin, 2007\n * Property: \tKey indistinguishable from randomness [[[previously: eCK security with PFS]]]\n *\n * Status: \t??\n */\n\nfunctions: h1/1, h2/1\n\n/* Protocol rules */\n\n/* \n * This rule generates a long-term key pair for the initiator agent A. \n * It uses a secret long-term key (lkA) to derive a public key (pkA).\n */\nrule generate_ltk:\n   let pkA = 'g'^~lkA \n   in\n   [ Fr(~lkA) ] \n   --[ RegKey($A) ]->\n   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]\n\n/* \n * Initiator's first message in the NAXOS protocol. It includes creating \n * a session-specific ephemeral key from its secret key (eskI) and long-term key (lkI). \n */\nrule Init_1:\n  let exI = h1(<~eskI, ~lkI >)\n      hkI = 'g'^exI\n  in\n   [   Fr( ~eskI ), !Ltk( $I, ~lkI ) ]\n   -->\n   [   Init_1( ~eskI, $I, $R, ~lkI, hkI )\n     , !Ephk(~eskI, ~eskI)\n     , Out( hkI ) ]\n\n/* \n * Initiator's second message. It involves responding to the initiator's \n * first message, using the responder's public key (pkR) to compute the session key \n * and ensuring the initiation of a secure session.\n */\nrule Init_2:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n\n\n/*\n// Test session rule for initiator, removed to reduce state space, still too much.\nrule Init_2_testsession:\n  let pkR = 'g'^~lkR\n      exI = h1(< ~eskI, ~lkI >)\n      kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) \n  in\n   [   Init_1( ~eskI, $I, $R, ~lkI , hkI), !Pk( $R, pkR ), In( Y ) ]\n   --[ Accept( ~eskI, $I, $R, kI)\n     , Sid( ~eskI, < 'Init', $I, $R, hkI, Y >)\n     , Match( ~eskI, < 'Resp', $R, $I, hkI, Y >)\n     ]->\n   [   !Sessk( ~eskI, kI) ]\n*/\n\n/* \n * Responder's first message in the NAXOS protocol. It computes the session key \n * using its long-term key (lkR) and the initiator's public key (pkI), \n * and responds with the calculated key (hkr).\n */\nrule Resp_1:\n  let pkI = 'g'^~lkI\n      exR = h1(< ~eskR, ~lkR >)\n      hkr = 'g'^exR\n      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >) \n  in\n   [   Fr( ~eskR ), !Ltk($R, ~lkR), !Pk($I, pkI), In( X ) ]\n   --[ Accept( ~eskR, $R, $I, kR )\n     , Sid( ~eskR, <'Resp', $R, $I, X, hkr >)\n     , Match( ~eskR, <'Init', $I, $R, X, hkr> )\n     ]->\n   [   Out( hkr ),\n       !Ephk(~eskR, ~eskR),\n       !Sessk( ~eskR, kR) ]\n\n/* \n * Restriction to ensure that each agent can register only one \n * public key throughout the protocol execution.\n */\nrestriction one_key_per_name:\n  \"All A #i #j. RegKey(A) @i & RegKey(A) @j ==> #i = #j\"\n\n\n/* Key Reveals for the eCK model */\n//rule Sessk_reveal: \n//   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]\n\n//rule Ltk_reveal:\n//   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]\n\n//rule Ephk_reveal:\n//   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]\n\n\n/* Security properties */\n\n/* \n * Lemma stating that if every agent registers at most one public key, \n * then matching sessions accept the same key. This is vital for security \n * since it prevents key mismatch in concurrent sessions.\n */\nlemma eCK_same_key:\n  \" // If every agent registered at most one public key\n  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))\n  ==> // then matching sessions accept the same key\n  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .\n              Accept(s, A, B, k ) @ i1\n\t    & Accept(ss, B, A, kk) @ i2\n\t    & Sid(s, minfo) @ i3\n\t    & Match(ss, minfo) @i4\n\t    & not( k = kk )\n  ) )\"\n*/\n\n/* \n * Lemma for Perfect Forward Secrecy (PFS) in the eCK model.\n * This specifies that if a Test session's key is known to an adversary,\n * certain session conditions must be true, indicating a compromise.\n */\nlemma eCK_PFS_key_secrecy:\n  \"(All #i1 #i2 Test A B k.\n    Accept(Test, A, B, k) @ i1 & K( k ) @ i2\n    ==> ( \n    /* ... the Test session must be \"not clean\".\n     * Test is not clean if one of the following has happened:\n     */\n    /* 1a. session-key-reveal of test thread. */\n      (Ex #i3. SesskRev( Test ) @ i3 )\n\n    /* 1b. session-key-reveal of matching session */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t     (Ex #i5. SesskRev( MatchingSession ) @ i5 )\n\t   )\n      )\n    /* 2. If matching session exists and ... */\n    | (Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           ( Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4)\n\t   & (\n\t   /* 2a. reveal either both sk_A and esk_A, or */\n\t     (Ex #i5 #i6. LtkRev  ( A ) @ i5  & EphkRev ( Test  ) @ i6 )\n\t   /* 2b. both sk_B and esk_B */\n\t   | (Ex #i5 #i6. LtkRev  ( B ) @ i5  & EphkRev ( MatchingSession ) @ i6 )\n\t   )\n      )\n    /* 3. No matching session exists and ... */\n    | ( ( not(Ex MatchingSession #i3 #i4 ms.\n    \t   /* ( MatchingSession's 'ms' info matches with Test ) */\n           Sid ( MatchingSession, ms ) @ i3 & Match( Test, ms ) @ i4 ) )\n\t   & (\n\t   /* 3a. reveal either sk_B, or */\n\t     (Ex #i5    . LtkRev (B) @ i5 & i5 < i1 )\t/* Perfect Forward Secrecy (PFS) modification */\n\t   /* 3b. both sk_A and esk_A */\n\t   | (Ex #i5 #i6. LtkRev (A) @ i5 & EphkRev ( Test ) @ i6 )\n\t   )\n      )\n    )\n  )\"\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/KAS1.spthy",
        "logic": "---\n\n### Protocol Description: KAS1\n\n#### Overview\nThe KAS1 protocol is a key agreement protocol that facilitates secure communication between two parties, referred to as the Initiator (I) and the Responder (R). This protocol is a weakened version modeled after the KAS2 protocol variant proposed by Chatterjee et al. in 2011. The KAS1 protocol is designed to ensure that both parties can establish a shared session key without exposing their long-term keys or ephemeral keys to potential attackers.\n\n#### Modeler and Date\n- **Modeler**: Cas Cremers\n- **Date**: April 2012\n\n#### Source\n- \"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\" by Chatterjee, Menezes, Ustaoglu, 2011.\n\n#### Purpose\nThe KAS1 protocol aims to provide a secure means of key establishment between two parties while addressing the following security concerns:\n- Compromise of the peer's long-term key.\n- Compromise of the test session's ephemeral key.\n\n#### Protocol Structure\n1. **Key Generation**:\n   - The Initiator generates a long-term key pair (private and public keys) and registers them.\n\n2. **Initiation Phase**:\n   - The Initiator sends an encrypted message (`c1`) containing a nonce (`m1`) to the Responder.\n\n3. **Response Phase**:\n   - Upon receiving the message, the Responder decrypts it to obtain the nonce and generates a session key using a key derivation function (KDF). The Responder also creates a message authentication code (MAC) to ensure integrity.\n\n4. **Session Key Confirmation**:\n   - The Responder sends back a message containing the nonce and the MAC, which the Initiator verifies. If the verification is successful, the session key is accepted.\n\n5. **Reveal Rules**:\n   - The protocol includes rules for revealing session keys, long-term keys, and ephemeral keys under certain conditions.\n\n#### Security Properties\nThe primary security property of the KAS1 protocol is key secrecy, which states:\n- A session key should remain confidential, meaning that an attacker should not be able to derive it even if they have access to certain information, including the long-term keys of the parties or the ephemeral keys used in the session.\n\n#### Important Considerations\n- The protocol is designed to prevent key compromise impersonation (KCI) and ensure key independence (KI) during its operation.\n- The model incorporates checks to ensure that no session key or ephemeral key is revealed during the protocol execution, maintaining the confidentiality of the exchanged keys.\n\n---",
        "code": "theory KAS1\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS1 *}\n\n/*\n * Protocol:\tKAS1\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\tWeakened version of the model for the initiator only,\n * \t\tmotivated by the informal remarks for KAS1 security in the paper.\n *\n * Status: \tworking\n *\n * Notes:\tConfirming the results from the paper, we find that we\n * \t\tcannot allow:\n * \t\t- compromise of the peer's long-term key\n * \t\t- compromise of the test session's ephemeral key\n *\n * \t\tThe model covers KCI and KI.\n */\n\nfunctions: KDF/1\nfunctions: MAC/2\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule Register_pk:\n  let pkA = pk(~ltkA)\n  in\n  [ Fr(~ltkA) ] \n  --> \n  [ !Ltk($A, ~ltkA), !Pk($A, pkA), Out(pkA) ]\n\n/* Initiator */\nrule Init_K1_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr( ~m1 ), !Ltk( $I, ~lkI ), !Pk($R,pkR) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1>) ]->\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1), !Ephk( ~m1,~m1 ), Out( c1 ) ]\n\nrule Resp_K1_1:\n  let m1     = adec(c1, ~lkR)\n      nonceB = ~m2\n      key    = KDF(< m1, $I, $R, nonceB, c1 >)\n      tagB   = MAC(key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !Pk($I,pkI) ]\n   --[  SidR ( ~m2, $R, $I, <$R, $I, 'Resp', nonceB, c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1, nonceB>)\n     ]->\n   [ Out(< nonceB , tagB >), !Sessk( ~m2, key ) ]\n\nrule Init_K1_2:\n  let m2   = adec(nonceB, ~lkI)\n      key  = KDF(< ~m1, $I, $R, nonceB, c1 >)\n      tagB = MAC( key, (< 'KC_1_V', $R, $I, nonceB, c1 >) )\n  in\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ) , In(< nonceB, tagB >) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1, nonceB> )\n     , Match( ~m1, <$R, $I, 'Resp', nonceB, c1> )\n     , Accept( ~m1, $I, $R, key) \n     ]->\n   [ !Sessk( ~m1, key ) ]\n\n\n\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ]\n\nrule Ltk_reveal:\n   [ !Ltk($A, lkA) ]\n   --[ LtkRev($A) ]->\n   [ Out(lkA) ]\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ]\n   --[ EphkRev(~s) ]->\n   [ Out(~ek) ]\n\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\nlemma KAS1_key_secrecy:\n  \"not (Ex #i1 #i2 s A B k .\n\t    Accept(s, A, B, k) @ i1 & K( k ) @ i2 \n\n            /* No session-key-reveal of test thread. */\n            & not(Ex #i4. SesskRev( s ) @ i4 )\n\n            /* No ephemeral key reveal of the test thread */\n\t    & not(Ex #i4. EphkRev( s ) @ i4 )\n\n\t    /* If matching session exists (for all matching sessions...) */\n\t    & (All ss #i4 #i5 C D ms.\n\t           ( SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5)\n\t\t     ==>\n\t\t   ( not(Ex #i6    . SesskRev( ss ) @ i6 )\n\t\t   & not(Ex #i6    . LtkRev  ( B ) @ i6  )\n\t\t   & not(Ex #i6 #i7. LtkRev  ( A ) @ i6  & LtkRev  ( B  ) @ i7 )\n\t\t   )\n\t      )\n\n\t    /* No matching session exists */\n\t    & ( ( not(Ex ss #i4 #i5 C D ms.\n\t           SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5 ) )\n\t\t     ==>\n\t\t   ( not(Ex #i6. LtkRev  ( B ) @ i6 & i6 < i1 )\n\t\t   )\n\t      )\n  )\"\n\nend",
        "codenote": "theory KAS1\nbegin\n\nbuiltins: hashing, asymmetric-encryption\n\nsection{* KAS1 *}\n\n/*\n * Protocol:\tKAS1\n * Modeler: \tCas Cremers\n * Date: \tApril 2012\n * Source:\t\"A Generic Variant of NISTS's KAS2 Key Agreement Protocol\"\n * \t\tChatterjee, Menezes, Ustaoglu, 2011\n * Model:\tWeakened version of the model for the initiator only,\n * \t\tmotivated by the informal remarks for KAS1 security in the paper.\n *\n * Status: \tworking\n *\n * Notes:\tConfirming the results from the paper, we find that we\n * \t\tcannot allow:\n * \t\t- compromise of the peer's long-term key\n * \t\t- compromise of the test session's ephemeral key\n *\n * \t\tThe model covers KCI and KI.\n */\n\n/* Description of functions used in the protocol */\nfunctions: KDF/1   // Key Derivation Function used to generate keys\nfunctions: MAC/2    // Message Authentication Code for ensuring message integrity\n\n/* Protocol rules */\n\n/* Generate long-term keypair */\nrule Register_pk:\n  let pkA = pk(~ltkA)\n  in\n  [ Fr(~ltkA) ] \n  --> \n  [ !Ltk($A, ~ltkA), !Pk($A, pkA), Out(pkA) ]   // Registers the long-term key for an entity\n\n/* Initiator */\nrule Init_K1_1:\n  let c1 = aenc{ ~m1 }pkR\n  in\n   [ Fr( ~m1 ), !Ltk( $I, ~lkI ), !Pk($R,pkR) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1>) ]->\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1), !Ephk( ~m1,~m1 ), Out( c1 ) ] // Initiator sends initial message encrypted with receiver's public key\n\nrule Resp_K1_1:\n  let m1     = adec(c1, ~lkR)        // Decrypt received message using own long-term key\n      nonceB = ~m2                   // Nonce generated by responder\n      key    = KDF(< m1, $I, $R, nonceB, c1 >) // Derive session key from shared parameters\n      tagB   = MAC(key, (< 'KC_1_V', $R, $I, nonceB, c1 >) ) // Create a message authentication tag\n  in\n   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !Pk($I,pkI) ]\n   --[  SidR ( ~m2, $R, $I, <$R, $I, 'Resp', nonceB, c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1>)\n     ,  Match( ~m2, <$I, $R, 'Init', c1, nonceB>)\n     ]->\n   [ Out(< nonceB , tagB >), !Sessk( ~m2, key ) ] // Responder outputs nonce and tag, initializes session key\n\nrule Init_K1_2:\n  let m2   = adec(nonceB, ~lkI)          // Decrypt nonce with initiator's long-term key\n      key  = KDF(< ~m1, $I, $R, nonceB, c1 >) // Derive session key\n      tagB = MAC( key, (< 'KC_1_V', $R, $I, nonceB, c1 >) ) // Create message authentication tag\n  in\n   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ) , In(< nonceB, tagB >) ]\n   --[ SidI ( ~m1, $I, $R, <$I, $R, 'Init', c1, nonceB> )\n     , Match( ~m1, <$R, $I, 'Resp', nonceB, c1> )\n     , Accept( ~m1, $I, $R, key) \n     ]->\n   [ !Sessk( ~m1, key ) ] // Initiator accepts response and stores session key\n\n/* Key Reveals for the eCK model */\nrule Sessk_reveal: \n   [ !Sessk(~tid, k) ]\n   --[ SesskRev(~tid) ]->\n   [ Out(k) ] // Reveal session key\n\nrule Ltk_reveal:\n   [ !Ltk($A, lkA) ]\n   --[ LtkRev($A) ]->\n   [ Out(lkA) ] // Reveal long-term key\n\nrule Ephk_reveal:\n   [ !Ephk(~s, ~ek) ]\n   --[ EphkRev(~s) ]->\n   [ Out(~ek) ] // Reveal ephemeral key\n\n/* Security properties */\n\n/*\nlemma key_agreement_reachable:\n  \"not (Ex #i1 #i2 ekI ekR I R k hkI hkR.\n          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)\"\n*/\nlemma KAS1_key_secrecy:\n  \"not (Ex #i1 #i2 s A B k .\n\t    Accept(s, A, B, k) @ i1 & K( k ) @ i2 \n\n            /* No session-key-reveal of test thread. */\n            & not(Ex #i4. SesskRev( s ) @ i4 )\n\n            /* No ephemeral key reveal of the test thread */\n\t    & not(Ex #i4. EphkRev( s ) @ i4 )\n\n\t    /* If matching session exists (for all matching sessions...) */\n\t    & (All ss #i4 #i5 C D ms.\n\t           ( SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5)\n\t\t     ==>\n\t\t   ( not(Ex #i6    . SesskRev( ss ) @ i6 )\n\t\t   & not(Ex #i6    . LtkRev  ( B ) @ i6  )\n\t\t   & not(Ex #i6 #i7. LtkRev  ( A ) @ i6  & LtkRev  ( B  ) @ i7 )\n\t\t   )\n\t      )\n\n\t    /* No matching session exists */\n\t    & ( ( not(Ex ss #i4 #i5 C D ms.\n\t           SidR ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5 ) )\n\t\t     ==>\n\t\t   ( not(Ex #i6. LtkRev  ( B ) @ i6 & i6 < i1 )\n\t\t   )\n\t      )\n  )\"\n\nend"
    },
    {
        "file": "SPTHY-1/KCL07.spthy",
        "logic": "---\n\n### Protocol Description: KCL07\n\n#### Roles:\n1. **Reader (R)**: An entity that initiates communication with the RFID tag. It possesses shared knowledge `k` and the ID of the tag.\n2. **RFID Tag (T)**: An entity that responds to the Reader's challenge. It shares the same knowledge `k` and ID with the Reader.\n\n#### Shared Knowledge:\n- **k**: A secret key shared between the Reader and the RFID Tag.\n- **ID**: The unique identifier for the RFID Tag.\n\n#### Interaction Steps:\n1. **Setup Phase**:\n   - The Reader and the RFID Tag are initialized with fresh values for `k` and `ID`.\n   - Both entities are set up as valid roles in the system.\n\n2. **Challenge from Reader**:\n   - The Reader generates a fresh random nonce `r1` and sends it to the RFID Tag.\n   - This nonce is used to ensure that each session is unique.\n\n3. **Response from RFID Tag**:\n   - Upon receiving the nonce `r1`, the RFID Tag generates its own fresh random nonce `r2`.\n   - It responds to the Reader with two pieces of data:\n     - The XOR of the ID and `r2`: `ID XOR r2`\n     - The XOR of the hash of the nonce `r1` with the shared key `k` and the nonce `r2`: `h(r1, k) XOR r2`\n\n4. **Recent Aliveness Check**:\n   - The Reader checks the validity of the response from the RFID Tag.\n   - The Reader considers the RFID Tag to be \"recently alive\" if it can find `ID` and `k` such that:\n     - `ID XOR r2 XOR h(r1, k) XOR r2 = ID XOR h(r1, k)`\n   - This check ensures that the Tag is alive and responding correctly, based on the most recent interaction.\n\n#### Security Properties:\n- **Recent Aliveness**: The protocol ensures that the Reader can confirm that the Tag is alive based on the response it receives.\n- **Untraceability**: Although the protocol supports recent aliveness, it does not guarantee untraceability, meaning that an adversary could potentially trace the interactions based on the received nonces and responses.\n\n#### Restrictions:\n- **Equality Restriction**: Ensures that if two terms are considered equal at a certain point in time, they must be equal in all instances.\n- **Unique Restriction**: Guarantees that any particular instance of an event (like `OnlyOnce`) can occur only once.\n\n#### Proofs:\n- **Recent Aliveness Lemma**: Demonstrates that if the Tag is alive, there must have been a valid challenge-response interaction.\n- **Executable Lemma**: Shows that there exists a trace of execution where the Tag can be confirmed to be alive based on its response.\n\n---",
        "code": "theory KCL07 begin\n\nbuiltins: xor, hashing\n\n/*\nKCL07: Reader R, RFID tag T, shared knowledge k, ID\n\n   R: knows(k, ID)\n   T: knows(k, ID)\n   R: fresh(r1)\nR->T: r1\n   T: fresh(r2)\nT->R: ID XOR r2,  h(r1,k) XOR r2  \n   \n   R considers T recent alive if it can find ID, k such that\n     the pair of terms received from T in the last step satisfies\n     \n     ID XOR r2  XOR  h(r1,k) XOR r2   =   ID XOR h(r1,k)\n\nrecent aliveness is satisfied, but untracability is not.\nThe model below only considers recent aliveness at the moment.\n*/\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ OnlyOnce( ) ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) \n   ]\n\nrule tag1:\n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' )\n   ]->\n   [ Out( <~id XOR ~r2, h(<r1,~k>) XOR ~r2>)\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n//   , In( <idr2, hashr2> ) // This is how it should be\n   , In( xoredhash )        // This is the only way I can make it work\n   ]\n --[ Alive( ~k, 'Tag' )\n//   , Eq( idr2 XOR hashr2, ~id XOR h(<~r1,~k>) ) // How it should be\n   , Eq( xoredhash, ~id XOR h(<~r1,~k>) )  // how it works\n   ]->\n   []\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\"\n\nrestriction unique:\n  \"\u2200 #i #j. ((OnlyOnce( ) @ #i) \u2227 (OnlyOnce( ) @ #j)) \u21d2 (#i = #j)\"\n\n\n// PROOF FOUND AUTOMATICALLY\nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Reader') @k & Response( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n\n// SHOWS CORRECT EXECUTION\nlemma executable:\n  exists-trace \"\u2203 x #i #j. (Alive( x, 'Tag' ) @ #i) \u2227 (Response( x, 'Tag' ) @ #j)\n     // further restriction to automatically get the desired execution\n     \u2227 (not Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend",
        "codenote": "theory KCL07 begin\n\nbuiltins: xor, hashing\n\n/*\nKCL07: Reader R, RFID tag T, shared knowledge k, ID\n\n   R: knows(k, ID)\n   T: knows(k, ID)\n   R: fresh(r1)\nR->T: r1\n   T: fresh(r2)\nT->R: ID XOR r2,  h(r1,k) XOR r2  \n   \n   R considers T recent alive if it can find ID, k such that\n     the pair of terms received from T in the last step satisfies\n     \n     ID XOR r2  XOR  h(r1,k) XOR r2   =   ID XOR h(r1,k)\n\nrecent aliveness is satisfied, but untracability is not.\nThe model below only considers recent aliveness at the moment.\n*/\n\n/* Notation: Set up initial conditions for shared knowledge and identity */\nrule Setup:\n   [ Fr( ~k )  /* fresh knowledge k */\n   , Fr(~id)   /* fresh ID */\n   ]\n --[ OnlyOnce( ) ]-> \n   [ !Reader( ~k, ~id ) /* declare R as Reader with k and ID */\n   , !Tag( ~k, ~id )    /* declare T as Tag with k and ID */\n   ]\n\n/* Notation: Reader issues a challenge to the Tag with fresh random number r1 */\nrule reader1:\n   [ Fr( ~r1 )  /* fresh random number r1 */\n   ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )  /* output the challenge r1 */\n   , Initiated( ~r1 )  /* record that the challenge was initiated */\n   ]\n\n/* Notation: Tag responds with ID and hash of the challenge combined with fresh random number r2 */\nrule tag1:\n   [ In( r1 )  /* input the challenge r1 from Reader */\n   , Fr( ~r2 )  /* fresh random number r2 */\n   , !Tag( ~k, ~id ) /* assure T's knowledge about k and ID */\n   ]\n --[ Response( ~k, 'Tag' )  /* Tag generates a response */\n   ]->\n   [ Out( <~id XOR ~r2, h(<r1,~k>) XOR ~r2>)  /* output the response: XORed ID and hash */\n   ]\n\n/* Notation: Reader checks the aliveness of the Tag based on the received data */\nrule reader2:\n   [ Initiated( ~r1 )  /* check if the challenge was initiated */\n   , !Reader( ~k, ~id )  /* assure R's knowledge about k and ID */\n   //   , In( <idr2, hashr2> ) // This is how it should be\n   , In( xoredhash )        /* input the hashed response from the Tag */\n   ]\n --[ Alive( ~k, 'Tag' )  /* Check if Tag is alive */\n   //   , Eq( idr2 XOR hashr2, ~id XOR h(<~r1,~k>) ) // How it should be\n   , Eq( xoredhash, ~id XOR h(<~r1,~k>) )  /* Check equality for aliveness criteria */\n   ]->\n   []  /* No additional output after evaluation */\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\"  /* Enforce that equals means terms are the same */\n\nrestriction unique:\n  \"\u2200 #i #j. ((OnlyOnce( ) @ #i) \u2227 (OnlyOnce( ) @ #j)) \u21d2 (#i = #j)\" /* Ensure uniqueness of occurrence */\n\n// PROOF FOUND AUTOMATICALLY\nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Reader') @k & Response( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n// SHOWS CORRECT EXECUTION\nlemma executable:\n  exists-trace \"\u2203 x #i #j. (Alive( x, 'Tag' ) @ #i) \u2227 (Response( x, 'Tag' ) @ #j)\n     // further restriction to automatically get the desired execution\n     \u2227 (not Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend"
    },
    {
        "file": "SPTHY-1/SAKE.spthy",
        "logic": "### Protocol Description for SAKE\n\n**Involved Parties:**\n- **Verifier (V):** The party that initiates the protocol and verifies the identity of the device.\n- **Device (D):** The party that responds to the verifier and establishes a shared secret key.\n\n**Protocol Steps:**\n\n1. **Initialization by Verifier:**\n   - V generates a random secret \\( a \\).\n   - Computes \\( v0 = g^a \\mod p \\).\n   - Computes \\( v1 = h(v0) \\) and \\( v2 = h(v1) \\).\n   - Computes a checksum \\( c = cksum(v2) \\).\n   - Sends \\( v2 \\) to D.\n\n2. **Response from Device:**\n   - D computes the checksum \\( c = cksum(v2) \\).\n   - Generates a random value \\( r \\) and computes:\n     - \\( w0 = h(c | r) \\)\n     - \\( w1 = h(w0) \\)\n     - \\( w2 = h(w1) \\)\n   - Generates another random value \\( b \\) and computes \\( k = g^b \\mod p \\).\n   - Sends \\( (w2, mac(c, w2)) \\) to V.\n\n3. **Verification by Verifier:**\n   - V checks if the received MAC \\( mac(c, w2) \\) matches the computed MAC.\n   - If valid, V sends \\( v1 \\) to D.\n\n4. **Device Verification:**\n   - D checks if \\( v2 \\) is equal to \\( h(v1) \\).\n   - If valid, D sends \\( (w1, k, mac(w2, k)) \\) to V.\n\n5. **Final Verification by Verifier:**\n   - V checks if the received MAC \\( mac(w2, k) \\) matches the computed MAC.\n   - Also checks if \\( w2 \\) is equal to \\( h(w1) \\).\n   - If both checks pass, V sends \\( v0 \\) to D.\n\n6. **Final Device Verification:**\n   - D checks if \\( v1 \\) is equal to \\( h(v0) \\).\n   - If valid, computes the shared secret \\( sk_{VD} = v0^b = (g^a)^b \\mod p \\).\n   - D sends \\( w0 \\) to V.\n\n7. **Final Verification by Verifier:**\n   - V checks if \\( w1 \\) is equal to \\( h(w0) \\).\n   - If valid, it confirms the shared secret \\( sk_{VD} = k^a = (g^b)^a \\mod p \\).\n\n**Security Properties:**\n- **Secrecy** of the shared key \\( sk_{VD} \\).\n- **Authentication** of both parties.\n- **Integrity** of the messages exchanged through the use of MACs.\n- **Freshness** guaranteed by the use of random values and checksums.",
        "code": "/* Modified SAKE Protocol Description used for SAGE\n\nInvolved parties: verifier V, device D\n\nV:  random a\n    v0 = g^a mod p\n    v1 = h(v0)\n    v2 = h(v1)\n    c = cksum(v2)\n\nV -> D: v2\n\nD:  c = cksum(v2)\n    random r\n    w0 = h(c | r)\n    w1 = h(w0)\n    w2 = h(w1)\n    random b\n    k = g^b mod p\n\nD -> V: w2, mac(c, w2)\n\nV:  check if mac(c, w2) matches received mac\n\nV -> D: v1\n\nD:  check if v2 == h(v1)\n\nD -> V: w1, k, mac(w2, k)\n  \nV:  check if mac(w2, k) matches received mac\n    check if w2 == h(w1)\n\nV -> D: v0\n\nD:  check if v1 == h(v0)\n    sk_VD = v0^b = (g^a)^b mod p\n\nD -> V: w0\n\nV:  check if w1 == h(w0)\n    sk_VD = k^a = (g^b)^a mod p\n\n*/\n\n\ntheory SAKE\nbegin\n\nbuiltins: hashing, diffie-hellman\nfunctions: g/0, mac/2, cksum/1\n\n/* Channel rules for authentic channels */\n\nrule ChanOut_A:\n    [ Out_A($A,$B,x) ]\n    --[ ChanOut_A($A,$B,x) ]->\n    [ !Auth($A,x), Out(<$A,$B,x>) ]\n\nrule ChanIn_A:\n    [ !Auth($A,x), In($B) ]\n    --[ ChanIn_A($A,$B,x) ]->\n    [ In_A($A,$B,x) ]\n\n\n/* Model of protocol */\n\nrule Verifier_1:\n    let v0 = g^(~a)\n        v1 = h(v0)\n        v2 = h(v1)\n        c  = cksum(v2)\n    in\n    [ Fr(~a) ]\n  --[ Neq( $V, $D )\n    , StartV( $V )\n    ]->\n    [ Verifier_1( $V, $D, ~a, v0, v1, c )\n    , Out( v2 )\n    ]\n\nrule Verifier_2:\n    let w2 = fst( w2_msg )\n        w2_mac = snd( w2_msg )\n    in\n    [ Verifier_1( $V, $D, a, v0, v1, c )\n    , In_A( $V, $D, <w2_msg, $D> )\n    ]\n  --[ Eq(mac(c, w2), w2_mac) ]->\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , Out( v1 )\n    ]\n\nrule Verifier_3:\n    let w1 = fst( w1_msg )\n        k = snd(fst( w1_msg ))\n        w1_mac = snd(snd( w1_msg ))\n    in\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , In( w1_msg )\n    ]\n  --[ Eq(mac(w2, k), w1_mac)\n    , Eq(h(w1), w2)\n    ]->\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , Out( v0 ) \n    ]\n\nrule Verifier_4:\n    let sk = k^a\n    in\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , In( w0 )\n    ]\n  --[ SecretV( sk )\n    , Eq(h(w0), w1)\n    , Commit( $V, $D, sk)\n    ]->\n    [  ]\n\n\n\nrule Device_1:\n    let c  = cksum(v2)\n        w0 = h(c, ~r)\n        w1 = h(w0)\n        w2 = h(w1)\n        k = g^(~b)\n    in\n    [ Fr(~r), Fr(~b)\n    , In( v2 )\n    ]\n  --[ AliveD( $D ) ]->\n    [ Out_A( $D, $V, <<w2, mac(c, w2)>, $D> )\n    , Device_1( $D, $V, ~b, w0, w1, w2, k, v2 )\n    ]\n\nrule Device_2:\n    [ Device_1( $D, $V, b, w0, w1, w2, k, v2 )\n    , In( v1 )\n    ]\n  --[ Eq(h(v1), v2)\n    , AliveD( $D )\n    ]->\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , Out( <w1, k, mac(w2, k)> )\n    ]\n\nrule Device_3:\n    let sk = v0^b\n    in\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , In( v0 )\n    ]\n  --[ Eq(h(v0), v1)\n    , Running( $D, $V, sk )\n    , AliveD( $D )\n    ]->\n    [ Out( w0 )\n    ]\n\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\n\nrestriction Inequality:\n  \"All x #i. Neq(x,x) @ #i ==> F\"\n\n\nlemma secrecyV:\n  \"All x #i. \n    SecretV(x) @i ==> not (Ex #j. K(x)@j)\"\n    \nlemma weak_agreement:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j. Running(b,a,key) @j)\"\n\nlemma recent_aliveness:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j #k. AliveD(b) @j & StartV(a) @k & #k < #j & #j < #i)\"\n\nend",
        "codenote": "/* Modified SAKE Protocol Description used for SAGE\n\nInvolved parties: verifier V, device D\n\nV:  random a\n    v0 = g^a mod p\n    v1 = h(v0)\n    v2 = h(v1)\n    c = cksum(v2)\n\nV -> D: v2\n\nD:  c = cksum(v2)\n    random r\n    w0 = h(c | r)\n    w1 = h(w0)\n    w2 = h(w1)\n    random b\n    k = g^b mod p\n\nD -> V: w2, mac(c, w2)\n\nV:  check if mac(c, w2) matches received mac\n\nV -> D: v1\n\nD:  check if v2 == h(v1)\n\nD -> V: w1, k, mac(w2, k)\n  \nV:  check if mac(w2, k) matches received mac\n    check if w2 == h(w1)\n\nV -> D: v0\n\nD:  check if v1 == h(v0)\n    sk_VD = v0^b = (g^a)^b mod p\n\nD -> V: w0\n\nV:  check if w1 == h(w0)\n    sk_VD = k^a = (g^b)^a mod p\n\n*/\n\n\ntheory SAKE\nbegin\n\nbuiltins: hashing, diffie-hellman\nfunctions: g/0, mac/2, cksum/1\n\n/* Channel rules for authentic channels */\n  \n/* Send a message from A to B over an authenticated channel */\nrule ChanOut_A:\n    [ Out_A($A,$B,x) ]\n    --[ ChanOut_A($A,$B,x) ]->\n    [ !Auth($A,x), Out(<$A,$B,x>) ]\n\n/* Receive a message at B from A, ensuring authenticity */\nrule ChanIn_A:\n    [ !Auth($A,x), In($B) ]\n    --[ ChanIn_A($A,$B,x) ]->\n    [ In_A($A,$B,x) ]\n\n\n/* Model of protocol */\n\nrule Verifier_1:\n    let v0 = g^(~a)\n        v1 = h(v0)\n        v2 = h(v1)\n        c  = cksum(v2)\n    in\n    [ Fr(~a) ]\n  --[ Neq( $V, $D )\n    , StartV( $V )\n    ]->\n    [ Verifier_1( $V, $D, ~a, v0, v1, c )\n    , Out( v2 )\n    ]\n\nrule Verifier_2:\n    let w2 = fst( w2_msg )\n        w2_mac = snd( w2_msg )\n    in\n    [ Verifier_1( $V, $D, a, v0, v1, c )\n    , In_A( $V, $D, <w2_msg, $D> )\n    ]\n  --[ Eq(mac(c, w2), w2_mac) ]->\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , Out( v1 )\n    ]\n\nrule Verifier_3:\n    let w1 = fst( w1_msg )\n        k = snd(fst( w1_msg ))\n        w1_mac = snd(snd( w1_msg ))\n    in\n    [ Verifier_2( $V, $D, a, v0, v1, w2 )\n    , In( w1_msg )\n    ]\n  --[ Eq(mac(w2, k), w1_mac)\n    , Eq(h(w1), w2)\n    ]->\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , Out( v0 ) \n    ]\n\nrule Verifier_4:\n    let sk = k^a\n    in\n    [ Verifier_3( $V, $D, a, v0, v1, w2, w1, k )\n    , In( w0 )\n    ]\n  --[ SecretV( sk )\n    , Eq(h(w0), w1)\n    , Commit( $V, $D, sk)\n    ]->\n    [  ]\n\n/* Device's part of the protocol */\n\nrule Device_1:\n    let c  = cksum(v2)\n        w0 = h(c, ~r)\n        w1 = h(w0)\n        w2 = h(w1)\n        k = g^(~b)\n    in\n    [ Fr(~r), Fr(~b)\n    , In( v2 )\n    ]\n  --[ AliveD( $D ) ]->\n    [ Out_A( $D, $V, <<w2, mac(c, w2)>, $D> )\n    , Device_1( $D, $V, ~b, w0, w1, w2, k, v2 )\n    ]\n\nrule Device_2:\n    [ Device_1( $D, $V, b, w0, w1, w2, k, v2 )\n    , In( v1 )\n    ]\n  --[ Eq(h(v1), v2)\n    , AliveD( $D )\n    ]->\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , Out( <w1, k, mac(w2, k)> )\n    ]\n\nrule Device_3:\n    let sk = v0^b\n    in\n    [ Device_2( $D, $V, b, w0, w1, w2, k, v2, v1 )\n    , In( v0 )\n    ]\n  --[ Eq(h(v0), v1)\n    , Running( $D, $V, sk )\n    , AliveD( $D )\n    ]->\n    [ Out( w0 )\n    ]\n\n\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x #i. Neq(x,x) @ #i ==> F\"\n\n\nlemma secrecyV:\n  \"All x #i. \n    SecretV(x) @i ==> not (Ex #j. K(x)@j)\"\n    \nlemma weak_agreement:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j. Running(b,a,key) @j)\"\n\nlemma recent_aliveness:\n  \"All a b key #i. \n    Commit(a,b,key) @i\n    ==> (Ex #j #k. AliveD(b) @j & StartV(a) @k & #k < #j & #j < #i)\"\n\nend"
    },
    {
        "file": "SPTHY-1/RFID_Simple.spthy",
        "logic": "---\n\n**Protocol Description: Extended RFID Protocol**\n\n**Overview:**\nThe protocol is an extended version of a simple RFID system, inspired by the running example from the StatVerif paper by Simon Meier, dated May 2012. It incorporates asymmetric encryption to manage the communication between an RFID device and an external entity, referred to as \"Bob\". The design aims to secure the interaction and ensure that sensitive data is transmitted only when appropriate conditions are met.\n\n**Key Components:**\n1. **Asymmetric Encryption:** The protocol utilizes asymmetric encryption to ensure secure communication. Each RFID device generates a public/private key pair, where the public key is made available to the adversary for encryption purposes.\n\n2. **Device Initialization:** Each RFID device is identified by its private key, which is essential for the device's operations. The device generates a unique key during initialization.\n\n3. **Communication Flow:**\n   - The device (Alice) can send encrypted messages to Bob containing sensitive information, but only after it has been authorized to do so.\n   - The device allows access to specific information based on the conditions defined in the protocol, ensuring that only the intended data is revealed.\n\n**Rules:**\n1. **Key Generation (`GenKey`):** \n   - A new key is generated for the device, which is then made public, allowing the adversary to know the public key while keeping the private key secret.\n\n2. **Alice Sending Data (`Alice`):**\n   - When Alice (the device) is ready to use the key, it generates a pair of unique identifiers (`~x` and `~y`) and sends them encrypted using its public key.\n\n3. **Device Communication to Bob (`DeviceToBob`):**\n   - The device communicates with Bob by transitioning its state to `Device_Select`, indicating readiness to process requests.\n\n4. **Selection Rules (`Select_Left`, `Select_Right`):**\n   - The device can select which piece of information to disclose (left or right) based on internal logic.\n\n5. **Decryption Rules (`Decrypt_Left`, `Decrypt_Right`):**\n   - Based on the selection made, the device can decrypt and send the appropriate information (`x` or `y`) to Bob, provided Bob has the necessary access rights.\n\n**Lemmas:**\n1. **Types Lemma:** Ensures that for any message `m` accessed, there exists either a knowledge or exclusivity condition that holds true.\n  \n2. **Device to Bob Lemma:** Establishes that once the device is in use, it cannot be handed over to Bob without following the proper sequence of events.\n\n3. **Device Initialization and Use Lemma:** Guarantees that a device cannot be reused after it has been initialized and used, maintaining the integrity of the device's state.\n\n4. **Reachability Lemmas:** \n   - The protocol includes reachability properties that show the potential for exclusive access to resources under certain conditions.\n\n5. **Secrecy Lemma:** Asserts that under the protocol, no two pieces of exclusive information can be simultaneously known.\n\n**Security Considerations:**\nThe protocol ensures that sensitive information is only accessible under specific conditions, thereby mitigating risks associated with unauthorized access. The use of asymmetric encryption adds a layer of security by separating the key used for encryption from the key used for decryption.\n\n---",
        "code": "theory RFID_Simple begin\n\n/*\n   Protocol:    Extended version of the running example from StatVerif paper\n   Modeler:     Simon Meier\n   Date:        May 2012\n\n   Status:      working\n\n   ...\n\n*/\n\n// Declare RFID/1 fact as globally fresh...for testing purposes.\n// unique_insts: RFID/1\n\nbuiltins: asymmetric-encryption\n\n// RFID Memory Cell model\n\nrule GenKey:\n    [ Fr(~sk)  // We let the key identify the device.\n    ]\n  --[ Device_Key(~sk) ]->\n    [ Device_Init(~sk)\n    , Device_Alice(~sk)\n    , Out(pk(~sk)) // make the public key available to the adversary\n    ]\n\nrule Alice:\n    [ Device_Alice(sk)\n    , Fr(~x)\n    , Fr(~y)\n    ]\n  --[ Exclusive(~x,~y)\n    , Device_Use(sk)\n    ]->\n    [ Device_Alice(sk)\n    , Out( aenc{~x,~y}pk(sk) )\n    ]\n\nrule DeviceToBob:\n    [ Device_Init(sk), Device_Alice(sk) ]\n  --[ ToBob(sk) ]->\n    [ Device_Select(sk) ]\n\nrule Select_Left:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Left(sk) ]\n\nrule Select_Right:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Right(sk) ]\n\nrule Decrypt_Left:\n    [ !Device_Left(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(x) ]->\n    [ Out(x) ]\n\nrule Decrypt_Right:\n    [ !Device_Right(sk), In(aenc{x,y}pk(sk)) ]\n  --[ Access(y) ]->\n    [ Out(y) ]\n\nlemma types [sources]:\n  \"All m #i. Access(m) @ i ==>\n      (Ex   #j. KU(m) @ j & j < i)\n    | (Ex x #j. Exclusive(x,m) @ j)\n    | (Ex y #j. Exclusive(m,y) @ j)\n  \"\n\nlemma Device_ToBob [use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\"\n\nlemma Device_Init_Use_Set [reuse, use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\n    & (Ex #j. Device_Key(sk) @ j & j < i)\"\n\n// attackable\nlemma reachability_left:\n  exists-trace\n  \"Ex x y #i #j. Exclusive(x,y) @i & K(x) @ j\"\n\nend\n\n/*\nlemma reachability_right:\n  exists-trace\n  \"Ex x y #i #k.  Exclusive(x,y) @i & K(y) @ k\"\n\nlemma secrecy:\n  \"not(Ex x y #i #k1 #k2.\n         Exclusive(x,y) @i & K(x) @ k1 & K(y) @ k2\n      )\n  \"\n\n/*\n// We cannot prove this lemma with the current system. We cannot state that\n// the ressource \"Device_Alice\" is no longer available after the device has\n// been handed to Bob.\n//\n// The fundamental problem is that we cannot express the multiplicity of a\n// fact in the *state* in our formula language, as we are always talking about\n// the whole history. It's also unclear how to exploit such state use_inductions\n// in our backwards approach.\nlemma Alice_before_to_bob:\n  \"All sk #i #j. Device_Use(sk) @ i & ToBob(sk) @ j ==> i < j\"\n\n*/\n*/\n*/\n\nend",
        "codenote": "theory RFID_Simple begin\n\n/*\n   Protocol:    Extended version of the running example from StatVerif paper\n   Modeler:     Simon Meier\n   Date:        May 2012\n\n   Status:      working\n\n   ...\n\n*/\n\n// Declare RFID/1 fact as globally fresh...for testing purposes.\n// unique_insts: RFID/1\n\nbuiltins: asymmetric-encryption\n\n// RFID Memory Cell model\n\n// Rule to generate a unique device key, associating it with the device.\nrule GenKey:\n    [ Fr(~sk)  // We let the key identify the device.\n    ]\n  --[ Device_Key(~sk) ]->\n    [ Device_Init(~sk) // Initialize the device with its key.\n    , Device_Alice(~sk) // Mark the device as belonging to Alice initially.\n    , Out(pk(~sk)) // Make the public key available to the adversary\n    ]\n\n// Rule for Alice to send a secure message to the device.\nrule Alice:\n    [ Device_Alice(sk) // The device is recognized as Alice's.\n    , Fr(~x) // Fresh message x.\n    , Fr(~y) // Fresh message y.\n    ]\n  --[ Exclusive(~x,~y) // Ensure messages x and y are exclusive.\n    , Device_Use(sk) // The device is being used.\n    ]->\n    [ Device_Alice(sk) // Device remains owned by Alice after use.\n    , Out( aenc{~x,~y}pk(sk) ) // Send encrypted messages.\n    ]\n\n// Rule for the device to transition to sending to Bob.\nrule DeviceToBob:\n    [ Device_Init(sk), Device_Alice(sk) ] // Device must be initialized and owned by Alice.\n  --[ ToBob(sk) ]->\n    [ Device_Select(sk) // Select to which party to send.\n    ]\n\n// Rule to select the left option for message routing.\nrule Select_Left:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Left(sk) // Transition to left processing.\n    ]\n\n// Rule to select the right option for message routing.\nrule Select_Right:\n    [ Device_Select(sk) ]\n    -->\n    [ !Device_Right(sk) // Transition to right processing.\n    ]\n\n// Decryption rule for the left device.\nrule Decrypt_Left:\n    [ !Device_Left(sk), In(aenc{x,y}pk(sk)) ] // Ensure left device is active and has message.\n  --[ Access(x) ]->\n    [ Out(x) // Output message x.\n    ]\n\n// Decryption rule for the right device.\nrule Decrypt_Right:\n    [ !Device_Right(sk), In(aenc{x,y}pk(sk)) ] // Ensure right device is active and has message.\n  --[ Access(y) ]->\n    [ Out(y) // Output message y.\n    ]\n\n// Lemma stating the conditions under which messages can be accessed.\nlemma types [sources]:\n  \"All m #i. Access(m) @ i ==>\n      (Ex   #j. KU(m) @ j & j < i) // Key usage occurs before access.\n    | (Ex x #j. Exclusive(x,m) @ j) // Exclusive condition on x.\n    | (Ex y #j. Exclusive(m,y) @ j) // Exclusive condition on y.\n  \"\n\n// Lemma ensuring Device_Use leads to ToBob in a temporal order.\nlemma Device_ToBob [use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j)\" // Device must be used before sending to Bob.\n\nlemma Device_Init_Use_Set [reuse, use_induction]:\n  \"All sk #i. Device_Use(sk) @ i ==>\n      (All #j. ToBob(sk) @ j ==> i < j) // Ensures usage precedes sending.\n    & (Ex #j. Device_Key(sk) @ j & j < i)\" // Device key must exist before usage.\n\n// Attackable state indicating potential exploitability.\nlemma reachability_left:\n  exists-trace\n  \"Ex x y #i #j. Exclusive(x,y) @i & K(x) @ j\" // Possible state capture via exclusiveness.\n\nend\n\n/*\nlemma reachability_right:\n  exists-trace\n  \"Ex x y #i #k.  Exclusive(x,y) @i & K(y) @ k\"\n\nlemma secrecy:\n  \"not(Ex x y #i #k1 #k2.\n         Exclusive(x,y) @i & K(x) @ k1 & K(y) @ k2\n      )\n  \"\n\n/*\n// We cannot prove this lemma with the current system. We cannot state that\n// the resource \"Device_Alice\" is no longer available after the device has\n// been handed to Bob.\n//\n// The fundamental problem is that we cannot express the multiplicity of a\n// fact in the *state* in our formula language, as we are always talking about\n// the whole history. It's also unclear how to exploit such state use_inductions\n// in our backwards approach.\nlemma Alice_before_to_bob:\n  \"All sk #i #j. Device_Use(sk) @ i & ToBob(sk) @ j ==> i < j\"\n\n*/\n*/\n*/\n\nend"
    },
    {
        "file": "SPTHY-1/sigma-1.spthy",
        "logic": "To create a description for the given Tamarin specification, we need to outline the protocol being modeled, its key components, the rules governing its behavior, and the properties being verified. Below is a structured description based on the elements present in your provided `.spthy` file.\n\n---\n\n### Description of the Protocol\n\n**Protocol Name:** Sigma Protocol\n\n**Overview:**\nThe Sigma protocol is a secure key exchange mechanism that utilizes Diffie-Hellman key exchange, signing, and message authentication codes (MAC) to establish a shared session key between a client and a server. The protocol ensures that both parties can authenticate each other and that the session key remains confidential, even against active adversaries.\n\n**Key Components:**\n1. **Key Management:**\n   - Each participant has a long-term key (LTK) and a corresponding public key (PK).\n   - The public key is derived from the long-term key using a public key infrastructure (PKI).\n\n2. **Message Types:**\n   - Messages exchanged include Diffie-Hellman values, signatures, and MACs for integrity and authenticity.\n\n3. **Functions:**\n   - **MAC Function:** A cryptographic function used to ensure message integrity.\n   - **Signing Function:** A cryptographic function that allows a party to sign messages to prove authenticity.\n\n**Protocol Flow:**\n1. **Registration:**\n   - A participant registers their long-term key and public key with the system, making it available for others to use.\n\n2. **Client Initialization:**\n   - The client generates a random value `x`, sends `g^x` to the server, and waits for a response.\n\n3. **Server Response:**\n   - The server receives `g^x`, generates a random value `y`, calculates `g^y`, and sends back `g^y`, its signature on the initial message, and a MAC for verification.\n\n4. **Client Finalization:**\n   - The client, upon receiving the server's message, verifies the signature and MAC, then sends a confirmation message back to the server, including its own signature and MAC.\n\n5. **Server Finalization:**\n   - The server verifies the client's response and confirms the session establishment.\n\n**Security Properties:**\n- **Key Secrecy:** The session key established between the client and server should remain unknown to any adversary unless one of the long-term keys is compromised.\n- **Liveness:** Ensures that if a client successfully completes the protocol, the server must have responded to the client\u2019s request.\n- **Injective Agreement:** Guarantees that if a server has successfully established a session key with one client, it cannot establish the same session key with a different client.\n\n**Restrictions:**\n- The protocol employs restrictions on equality and inequality to ensure that the protocol's rules maintain the necessary properties without ambiguity.\n\n**Lemmas:**\n1. **Honest Trace:** There exists a trace where both the client and server complete the protocol without revealing any long-term keys.\n2. **Key Secrecy:** If a session key is established, it is not known to anyone unless a long-term key is revealed.\n3. **Server Liveness:** If a client completes the protocol, the server must have responded to its request.\n4. **Client Liveness:** If a server completes the protocol, the client must have initiated the request.\n5. **Injective Agreement:** If a server completes the protocol with a client, it cannot do so with a different client for the same session key.\n\n---\n\nThis description gives a comprehensive overview of the protocol modeled in the provided Tamarin specification and can serve as a basis for generating similar `.spthy` files in the future.",
        "code": "theory SIGMA\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// MAC\nfunctions: mac/2\n\n// PKI Provisioning\nrule RegisterPK:\n  [ Fr(~ltk) ]\n  -->\n  [\n    !Ltk($A, ~ltk),\n    !Pk($A, pk(~ltk)),\n    Out(pk(~ltk))\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ]\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ]\n\n\n// C->S: g^x\n// S->C: g^y, S, Sig_S(g^x, g^y) MAC_k(S)\n// C->S: C, Sig_C(g^y, g^x) MAC_k(C)\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC),\n    Fr(~x)\n  ]\n  --[ ClientSentRequest(C, $S, ~x) ]->\n  [\n    ClientWait(C, $S, ~x, ltkC),\n    Out('g'^~x)\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <'g'^x, gy>\n    msgOut = <gy, 'g'^x>\n    sigOut = sign(msgOut, ltkC)\n    k = gy^x\n    macOut = mac(C, k)\n  in\n  [\n    In(<gy, sigIn, macIn>),\n    ClientWait(C, S, x, ltkC),\n    !Pk(S, pkS)\n  ]\n  --[ Neq(gy, 'g'^x),\n      Eq(mac(k, S), macIn),\n      Eq(verify(sigIn, msgIn, pkS), true),\n      ClientDone(C, S, 'g'^x, gy, k) ]->\n  [\n    Out(<C, sigOut, macOut>)\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <gx, 'g'^~y>\n    sig = sign(msg, ltkS)\n    k = gx^~y\n    macVal = mac(k, S)\n  in\n  [\n    In(<gx>),\n    !Ltk(S, ltkS),\n    Fr(~y)\n  ]\n  --[ ServerResponded(S, gx, 'g'^~y) ]->\n  [\n    ServerWait(S, gx, ~y, k),\n    Out(<'g'^~y, sig, macVal>)\n  ]\n\nrule ServerFinish:\n  let\n    msg = <'g'^y, gx>\n  in\n  [\n    In(<C, sig, macVal>),\n    !Pk(C, pkC),\n    ServerWait(S, gx, y, k)\n  ]\n  --[ Eq(mac(k, C), macVal),\n      Eq(verify(sig, msg, pkC), true),\n      ServerDone(S, C, gx, 'g'^y, k) ]->\n  []\n\n// Restrictions\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\"\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\"\n\n// Functionality test\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #i #j.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k)\n  \"\n\n// If a client has established a session key,\n// ... then the server has the same key,\n// ... and it is not known to the attacker\n// ... unless one of the long-term keys was compromised\nlemma KeySecrecy:\n  \"\n  not(Ex C S gx gy k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k\n      & not(Ex #rc. LtkReveal(C) @ #rc)\n      & not(Ex #rs. LtkReveal(S) @ #rs)\n  )\n  \"\n\n// If a client has established a session key\n// ... then it's based on a response from a server\nlemma ServerLiveness:\n  \"\n  All C S gx gy k #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ServerResponded(S, gx, gy) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// If a server has established a session key\n// ... then it's based on a request from a client\nlemma ClientLiveness:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i))\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// ... injective agreement\nlemma InjectiveAgreement:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( not(Ex C2 S2 gx2 gy2 #i2.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i)\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend",
        "codenote": "theory SIGMA\nbegin\n\nbuiltins: diffie-hellman, signing\n\n// MAC (Message Authentication Code)\nfunctions: mac/2\n\n// PKI Provisioning (Public Key Infrastructure)\nrule RegisterPK:\n  [ Fr(~ltk) ] // Fresh long-term key creation\n  -->\n  [\n    !Ltk($A, ~ltk), // Register the long-term key for agent A\n    !Pk($A, pk(~ltk)), // Register the public key for A\n    Out(pk(~ltk)) // Output the public key\n  ]\n\nrule RevealLTK:\n  [ !Ltk(A, ltk) ] // If the long-term key for A is known\n  --[ LtkReveal(A) ]->\n  [ Out(ltk) ] // Reveal the long-term key\n\n// C->S: g^x (Client sends ephemeral public key)\n// S->C: g^y, S, Sig_S(g^x, g^y) MAC_k(S) // Server responds with its ephemeral key, identity, and a signature with MAC\n// C->S: C, Sig_C(g^y, g^x) MAC_k(C) // Client responds with its identity, signature, and MAC\n\n// Client logic\nrule ClientInit:\n  [\n    !Ltk(C, ltkC), // Get long-term key for client C\n    Fr(~x) // Generate fresh ephemeral value x\n  ]\n  --[ ClientSentRequest(C, $S, ~x) ]->\n  [\n    ClientWait(C, $S, ~x, ltkC), // Client waits for server response\n    Out('g'^~x) // Send g^x to server\n  ]\n\nrule ClientFinish:\n  let\n    msgIn = <'g'^x, gy> // Message input consists of received messages\n    msgOut = <gy, 'g'^x> // Message output to be sent back to server\n    sigOut = sign(msgOut, ltkC) // Sign the output message with client's long-term key\n    k = gy^x // Establish shared session key k\n    macOut = mac(C, k) // Compute MAC for the output\n  in\n  [\n    In(<gy, sigIn, macIn>), // Receive the server's response\n    ClientWait(C, S, x, ltkC), // Client is waiting for server's response\n    !Pk(S, pkS) // Public key for server S is available\n  ]\n  --[ Neq(gy, 'g'^x), // Check that received gy differs from the computed g^x\n      Eq(mac(k, S), macIn), // Check MAC integrity\n      Eq(verify(sigIn, msgIn, pkS), true), // Verify server's signature\n      ClientDone(C, S, 'g'^x, gy, k) ]->\n  [\n    Out(<C, sigOut, macOut>) // Output client's response\n  ]\n\n// Server logic\nrule ServerInit:\n  let\n    msg = <gx, 'g'^~y> // Message sent by server\n    sig = sign(msg, ltkS) // Sign the message using server's long-term key\n    k = gx^~y // Establish shared session key k\n    macVal = mac(k, S) // Compute MAC for the response\n  in\n  [\n    In(<gx>), // Receive the client's message\n    !Ltk(S, ltkS), // Get long-term key for server S\n    Fr(~y) // Generate fresh ephemeral value y\n  ]\n  --[ ServerResponded(S, gx, 'g'^~y) ]->\n  [\n    ServerWait(S, gx, ~y, k), // Server waits for client's response\n    Out(<'g'^~y, sig, macVal>) // Send response with gy, signature, and MAC\n  ]\n\nrule ServerFinish:\n  let\n    msg = <'g'^y, gx> // Message received from client in their response\n  in\n  [\n    In(<C, sig, macVal>), // Receive the client's message and verify it\n    !Pk(C, pkC), // Public key for client C is available\n    ServerWait(S, gx, y, k) // Server wait for the corresponding session state\n  ]\n  --[ Eq(mac(k, C), macVal), // Verify the MAC\n      Eq(verify(sig, msg, pkC), true), // Verify the signature\n      ServerDone(S, C, gx, 'g'^y, k) ]->\n  []\n\n// Restrictions to ensure properties of identities\nrestriction Equality:\n  \"All x y #i. Eq(x,y) @i ==> x = y\" // Two equal entities must be the same\n\nrestriction Inequality:\n  \"All x y #i. Neq(x,y) @i ==> not(x = y)\" // Two non-equal entities cannot be the same\n\n// Functionality test for honesty of the protocol\nlemma HonestTrace:\n  exists-trace\n  \"\n    Ex C S gx gy k #i #j.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & not(Ex A #k. LtkReveal(A) @ #k) // No long-term key revealed\n  \"\n\n// Key secrecy properties\nlemma KeySecrecy:\n  \"\n  not(Ex C S gx gy k #i #j #k.\n        ClientDone(C, S, gx, gy, k) @ #i\n      & ServerDone(S, C, gx, gy, k) @ #j\n      & K(k) @ #k // Session key k should not be compromised\n      & not(Ex #rc. LtkReveal(C) @ #rc) // Long-term key for client C not revealed\n      & not(Ex #rs. LtkReveal(S) @ #rs) // Long-term key for server S not revealed\n  )\n  \"\n\n// Liveness of clients and servers\nlemma ServerLiveness:\n  \"\n  All C S gx gy k #i.\n    ClientDone(C, S, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ServerResponded(S, gx, gy) @ #j) & (#j < #i)) // Server must respond before client is done\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nlemma ClientLiveness:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( (Ex #j. (ClientDone(C, S, gx, gy, k) @ #j) & (#j < #i)) // Client must respond before server is done\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\n// Ensures injectivity of server responses\nlemma InjectiveAgreement:\n  \"\n  All C S gx gy k #i.\n    ServerDone(S, C, gx, gy, k) @ #i\n    ==> ( not(Ex C2 S2 gx2 gy2 #i2.\n              ServerDone(S2, C2, gx2, gy2, k) @ #i2\n             & not(#i2 = #i) // No other server response can be equal\n             )\n        | (Ex #rc. LtkReveal(C) @ #rc)\n        | (Ex #rs. LtkReveal(S) @ #rs)\n        )\n  \"\n\nend"
    },
    {
        "file": "SPTHY-1/signed_dh.spthy",
        "logic": "---\n\n## Description of the Signed Diffie-Hellman Protocol\n\n### Overview\nThe Signed Diffie-Hellman protocol allows two parties, traditionally named Alice (A) and Bob (B), to securely establish a shared secret key over an insecure channel. The protocol utilizes asymmetric key pairs for each participant, where each has a public key and a corresponding private key.\n\n### Key Components\n1. **Functions**:\n   - `pk/1`: Represents the public key of a participant.\n   - `sk/1`: Represents the private key of a participant.\n   - `aenc/2`: Represents asymmetric encryption of a message with a public key.\n   - `adec/2`: Represents asymmetric decryption of a message with a private key.\n   - `g/0`: A generator used in the Diffie-Hellman key exchange.\n\n2. **Built-ins**:\n   - `diffie-hellman`: Built-in support for the Diffie-Hellman key agreement.\n\n### Equations\nThe protocol defines two equations for the encryption and decryption processes, ensuring that the decryption of an encrypted message returns the original message when the correct key is used.\n\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{sk}(x.2)), \\text{pk}(x.2)) = x.1 \\)\n- \\( \\text{adec}(\\text{aenc}(x.1, \\text{pk}(x.2)), \\text{sk}(x.2)) = x.1 \\)\n\n### Protocol Steps\n1. **Asymmetric Key Setup**:\n   - Each participant generates a pair of keys (public and private). The public keys are published.\n\n2. **Publish Public Keys**:\n   - Participants publish their public keys to the network.\n\n3. **Initialization of Knowledge**:\n   - Both participants initialize their state with their own and the other participant's public and private keys.\n\n4. **Role A (Alice)**:\n   - **Step 1 (dh_1_A)**: Alice sends an encrypted message containing the string \"One\", her identity, Bob's identity, and a random value \\( x \\) to Bob.\n   - **Step 2 (dh_2_A)**: Upon receiving Bob's response (an encrypted message containing \"Two\" and a value \\( \\alpha \\)), Alice computes her secret key by combining \\( \\alpha \\) and her random value \\( x \\).\n\n5. **Role B (Bob)**:\n   - **Step 1 (dh_1_B)**: Bob, upon initialization, waits for Alice's message.\n   - **Step 2 (dh_2_B)**: Bob sends a response to Alice with an encrypted message containing \"Two\" and a random value \\( y \\). He computes his secret key by combining \\( \\alpha \\) and his random value \\( y \\).\n\n### Security Properties\nThe protocol includes lemmas that assert the secrecy of the generated keys:\n- **Key Secrecy**: Ensures that no message can reveal the secret keys held by either party.\n- **Key Secrecy for Alice**: Ensures that Alice's derived secret key is kept secret.\n- **Key Secrecy for Bob**: Ensures that Bob's derived secret key is kept secret.\n\n---",
        "code": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\nend",
        "codenote": "theory SIGNED_DIFFIE_HELLMAN\nbegin\n\nfunctions: pk/1, sk/1, aenc/2, adec/2, g/0\n\nbuiltins: diffie-hellman\n\nequations:\n    adec(aenc(x.1, sk(x.2)), pk(x.2)) = x.1,\n    adec(aenc(x.1, pk(x.2)), sk(x.2)) = x.1\n\nrule Asymmetric_key_setup:\n    [ Fr(~f) ] --> [ !Sk($A, sk(~f)), !Pk($A, pk(~f)) ]\n\n    (* Notation: This rule sets up asymmetric keys for participants A with a fresh factor ~f. *)\n\nrule Publish_public_keys:\n    [ !Pk(A, pkA) ] --> [ Out(pkA) ]\n\n    (* Notation: This rule allows the public key of participant A to be published. *)\n\nrule Init_Knowledge:\n        [ !Pk($A, pk(k_A)),\n          !Pk($B, pk(k_B)),\n          !Sk($A, sk(k_A)),\n          !Sk($B, sk(k_B))\n        ]\n        --[  ]->\n        [ St_init_A($A, $B, sk(k_A), pk(k_A), pk(k_B)),\n          St_init_B($A, $B, sk(k_B), pk(k_A), pk(k_B))\n        ]\n\n    (* Notation: This rule initializes the knowledge of both participants A and B. *)\n\n// ROLE A\nrule dh_1_A:\n        [ St_init_A(A, B, sk(k_A), pk(k_A), pk(k_B)),\n          Fr(~x)\n        ]\n        --[  ]->\n        [ Out(aenc{<'One', A, B, (g() ^ ~x)>}sk(k_A)),\n          St_dh_1_A(A, B, ~x, sk(k_A), pk(k_A), pk(k_B))\n        ]\n\n    (* Notation: In this rule, participant A sends a message containing the value 'One' and a fresh factor ~x. *)\n\nrule dh_2_A:\n    let\n        beta = aenc{<'Two', B, A, alpha>}sk(k_B)\n    in\n        [ St_dh_1_A(A, B, x, sk(k_A), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[ Secret_key_secret_A((alpha ^ x)),\n            Secret_key_secretA_A((alpha ^ x)) ]->\n        [ St_dh_2_A(A, B, x, sk(k_A), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n    (* Notation: Participant A processes the incoming beta message and creates a secret key using alpha. *)\n\n// ROLE B\nrule dh_1_B:\n    let\n        beta = aenc{<'One', A, B, alpha>}sk(k_A)\n    in\n        [ St_init_B(A, B, sk(k_B), pk(k_A), pk(k_B)),\n          In(beta)\n        ]\n        --[  ]->\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n    (* Notation: In this rule, participant B receives a message, which includes the value 'One' and uses the fresh term alpha. *)\n\nrule dh_2_B:\n        [ St_dh_1_B(A, B, sk(k_B), pk(k_A), pk(k_B), beta, alpha),\n          Fr(~y)\n        ]\n        --[ Secret_key_secret_B((alpha ^ ~y)),\n            Secret_key_secretB_B((alpha ^ ~y)) ]->\n        [ Out(aenc{<'Two', B, A, (g() ^ ~y)>}sk(k_B)),\n          St_dh_2_B(A, B, ~y, sk(k_B), pk(k_A), pk(k_B), beta, alpha)\n        ]\n\n    (* Notation: Participant B sends back a message containing the value 'Two' and incorporates a fresh factor ~y. *)\n\nlemma key_secret:\n    \" not(\n        Ex msg #i1 #i2 #j .\n            Secret_key_secret_A(msg) @ #i1 &\n            Secret_key_secret_B(msg) @ #i2 &\n            K(msg) @ #j\n    )\"\n\n    (* Notation: This lemma states that there cannot be any message that is both secret to A and B simultaneously. *)\n\nlemma key_secretA:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretA_A(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\n    (* Notation: This lemma expresses that A cannot have a secret message that can be known by anyone. *)\n\nlemma key_secretB:\n    \" not(\n        Ex msg #i1 #j .\n            Secret_key_secretB_B(msg) @ #i1 &\n            K(msg) @ #j\n    )\"\n\n    (* Notation: This lemma expresses that B cannot have a secret message that can be known by anyone. *)\n\nend"
    },
    {
        "file": "SPTHY-1/TLS_Handshake.spthy",
        "logic": "---\n\n## TLS Handshake Protocol Description\n\n### Overview\nThe TLS Handshake protocol is a cryptographic protocol that enables secure communication between a client and a server. The handshake process establishes the session keys used for encryption and ensures mutual authentication. This description outlines the critical components, message exchanges, and security properties modeled in Tamarin.\n\n### Components\n1. **Participants**: \n   - Client (C)\n   - Server (S)\n\n2. **Key Material**:\n   - Long-term keys: `ltkA` (long-term key for A), `ltkC` (long-term key for Client), `ltkS` (long-term key for Server).\n   - Public keys: `pk(A)` for each participant.\n   - Session parameters: Nonces `nc` and `ns`, session identifiers `sid`, and pre-master secret `pms`.\n\n### Protocol Steps\n1. **Client Hello**: \n   - The client initiates the handshake by sending its identity, a nonce, a session identifier, and a public certificate to the server.\n   - Message format: `C -> S: <C, nc, sid, pc>`\n\n2. **Server Hello**: \n   - The server responds with its identity, a nonce, a session identifier, and its public certificate.\n   - Message format: `C <- S: <ns, sid, ps>`\n\n3. **Client Key Exchange and Finished**:\n   - The client sends its pre-master secret encrypted with the server's public key, a signed message containing the nonce and session information, and a session message encrypted with the derived client key.\n   - Message format: \n     ```plaintext\n     C -> S:\n     { '31', pms }pk(S),\n     sign{ '32', h('32', ns, S, pms) }pk(C),\n     { '33', sid, PRF(pms, nc, ns), nc, pc, C, ns, ps, S }\n     h('clientKey', nc, ns, PRF(pms, nc, ns))\n     ```\n\n4. **Server Finished**:\n   - The server sends a message containing session information encrypted with the derived server key.\n   - Message format: \n     ```plaintext\n     C <- S:\n     { '4', sid, PRF(pms, nc, ns), nc, pc, C, ns, ps, S }\n     h('serverKey', nc, ns, PRF(pms, nc, ns))\n     ```\n\n### Security Properties\n1. **Session Key Secrecy**: Ensures that the session keys established between the client and server are not compromised by an adversary who has not revealed long-term keys.\n   \n2. **Injective Agreement**: Guarantees that if a participant commits to a session with specific parameters, another participant must also be running a session with the same parameters, or an adversary must have revealed a long-term key.\n\n3. **Session Key Setup**: Demonstrates that it is possible to establish session keys between honest participants without revealing long-term keys.\n\n### Conclusion\nThe TLS Handshake protocol is modeled in Tamarin to verify its security properties and correctness. The model captures both the message flows and the requisite encryption mechanisms, ensuring that the protocol provides strong security guarantees against potential adversaries. \n\n---",
        "code": "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hashes of the relevant information.\n       Due to our support for composed keys, we do not need any custom\n       axiomatization as Paulson does.\n\n*}\n\nfunctions: PRF/1\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following signature based TLS handshake.\n\n  protocol TLS {\n    1. C -> S: C, nc, sid, pc\n    2. C <- S: ns, sid, ps\n\n    3. C -> S: { '31', pms                     }pk(S) ,\n               sign{ '32', h('32', ns, S, pms) }pk(C) ,\n               { '33', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('clientKey', nc, ns, PRF(pms, nc, ns))\n\n    4. C <- S: { '4', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('serverKey', nc, ns, PRF(pms, nc, ns))\n  }\n*/\n\nrule C_1:\n    [ Fr(~nc)\n    , Fr(~sid)\n    ]\n  --[]->\n    [ Out(\n        <$C, ~nc, ~sid, $pc>\n      )\n    , St_C_1($C, ~nc, ~sid, $pc)\n    ]\n\nrule S_1:\n    [ In(\n        <$C, nc, sid, pc>\n      )\n    , Fr(~ns)\n    ]\n  --[]->\n    [ Out(\n        <$S, ~ns, sid, $ps>\n      )\n    , St_S_1($S, $C, sid, nc, pc, ~ns, $ps)\n    ]\n\nrule C_2:\n  let\n      MS   = PRF(~pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_1(C, nc, sid, pc)\n    , In(\n        <S, ns, sid, ps>\n      )\n    , Fr(~pms)\n    , !Pk(S, pkS)\n    , !Ltk(C, ltkC)\n    ]\n  --[ Running(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        < aenc{ '31', ~pms }pkS\n        , sign{ '32', h('32', ns, S, ~pms) }ltkC\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , St_C_2(S, C, sid, nc, pc, ns, ps, ~pms)\n    ]\n\nrule S_2:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_S_1(S, C, sid, nc, pc, ns, ps)\n    , In(\n        < aenc{ '31', pms }pk(ltkS)\n        , signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey\n        >\n      )\n    , !Pk(C, pkC)\n    , !Ltk(S, ltkS)\n    ]\n    /* Explicit equality check, enforced as part of the property. */\n  --[ Eq(verify(signature, <'32', h('32', ns, S, pms)>, pkC), true )\n    , SessionKeys( S, C, Skey, Ckey )\n    , Running(C, S, <'client', MS, Skey, Ckey>)\n    , Commit(S, C, <'server', MS, Skey, Ckey>)\n    ]->\n    [ Out(\n        senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey\n      )\n    ]\n\nrule C_3:\n  let\n      MS   = PRF(pms, nc, ns)\n      Ckey = h('clientKey', nc, ns, MS)\n      Skey = h('serverKey', nc, ns, MS)\n  in\n    [ St_C_2(S, C, sid, nc, pc, ns, ps, pms)\n    , In( senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey )\n    ]\n  --[ Commit(C, S, <'client', MS, Skey, Ckey>)\n    , SessionKeys( S, C, Skey, Ckey )\n    ]->\n    []\n\n\n/* TODO: Also model session-key reveals and adapt security properties. */\n\nrestriction Eq_check_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/* Session key secrecy from the perspective of both the server and the client\n * for both the key of the server and the key of the client. Note that this\n * lemma thus captures four security properties at once. */\nlemma session_key_secrecy:\n     /* It cannot be that */\n   \"not(\n         Ex S C keyS keyC #k.\n           /* somebody claims to have setup session keys, */\n           SessionKeys(S, C, keyS, keyC) @ k\n           /* but the adversary knows one of them */\n         & ( (Ex #i. K(keyS) @ i)\n           | (Ex #i. K(keyC) @ i)\n           )\n           /* without having performed a long-term key reveal. */\n         & not (Ex #r. RevLtk(S) @ r)\n         & not (Ex #r. RevLtk(C) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor peer params #i.\n        Commit(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (Ex #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex actor2 peer2 #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #r. RevLtk(actor) @ r)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n/* Consistency check: ensure that session-keys can be setup between honest\n * agents. */\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* There is a trace satisfying all equality checks */\n     (All x y #i. Eq(x,y) @ i ==> x = y)\n  &  /* Session keys have been setup */\n     (Ex S C keyS keyC #k.  SessionKeys(S, C, keyS, keyC) @ k\n      /* without having performed a long-term key reveal. */\n      & not (Ex #r. RevLtk(S) @ r)\n      & not (Ex #r. RevLtk(C) @ r)\n      )\n   \"\n\nend",
        "codenote": "theory TLS_Handshake\nbegin\n\nbuiltins: hashing, symmetric-encryption, asymmetric-encryption, signing\n\nsection{* TLS Handshake *}\n\n/*\n * Protocol:\tTLS Handshake\n * Modeler: \tSimon Meier, minor update by Cas Cremers\n * Date: \tJanuary 2012\n * Source:\tModeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy.\n *\n * Status: \tworking (2.5 seconds on an i7 Quad-Core CPU with +RTS -N)\n */\n\ntext{*\n  Modeled after Paulson`s TLS model in Isabelle/src/HOL/Auth/TLS.thy. Notable\n  differences are:\n\n    1. We use explicit global constants to differentiate between different\n       encryptions instead of implicit sources.\n\n    2. We model session keys directly as hashes of the relevant information.\n       Due to our support for composed keys, we do not need any custom\n       axiomatization as Paulson does.\n\n*}\n\nfunctions: PRF/1\n\n// Public key infrastructure\nrule Register_pk:\n  [ Fr(~ltkA) ]\n  -->\n  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]\n\nrule Reveal_ltk:\n  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]\n\n\n/* We formalize the following signature based TLS handshake.\n\n  protocol TLS {\n    1. C -> S: C, nc, sid, pc\n    2. C <- S: ns, sid, ps\n\n    3. C -> S: { '31', pms                     }pk(S) ,\n               sign{ '32', h('32', ns, S, pms) }pk(C) ,\n               { '33', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('clientKey', nc, ns, PRF(pms, nc, ns))\n\n    4. C <- S: { '4', sid, PRF(pms, nc, ns),\n                 nc, pc, C, ns, ps, S\n               }\n               h('serverKey', nc, ns, PRF(pms, nc, ns))\n  }\n*/\n\nrule C_1:\n    [ Fr(~nc)      // Nonce generated for client\n    , Fr(~sid)     // Session ID generated for client\n    ]\n  --[]->\n    [ Out(\n        <$C, ~nc, ~sid, $pc>  // Client sends its identity, nonce, session ID, and public certificate\n      )\n    , St_C_1($C, ~nc, ~sid, $pc)  // Update client state\n    ]\n\nrule S_1:\n    [ In(\n        <$C, nc, sid, pc>  // Server receives client's message\n      )\n    , Fr(~ns)   // Nonce generated for server\n    ]\n  --[]->\n    [ Out(\n        <$S, ~ns, sid, $ps>  // Server responds with its nonce, session ID, and public certificate\n      )\n    , St_S_1($S, $C, sid, nc, pc, ~ns, $ps)  // Update server state\n    ]\n\nrule C_2:\n  let\n      MS   = PRF(~pms, nc, ns) // Master secret derivation\n      Ckey = h('clientKey', nc, ns, MS) // Client key generation using hash\n      Skey = h('serverKey', nc, ns, MS) // Server key generation using hash\n  in\n    [ St_C_1(C, nc, sid, pc)  // State before sending second message\n    , In(\n        <S, ns, sid, ps>  // Client receives server message\n      )\n    , Fr(~pms) // Pre-master secret generated\n    , !Pk(S, pkS) // Public key for server\n    , !Ltk(C, ltkC) // Long-term key for client\n    ]\n  --[ Running(S, C, <'server', MS, Skey, Ckey>) // Server is running a session with the client\n    ]->\n    [ Out(\n        < aenc{ '31', ~pms }pkS  // Encrypted pre-master secret\n        , sign{ '32', h('32', ns, S, ~pms) }ltkC  // Client's signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey  // Encrypted session information\n        >\n      )\n    , St_C_2(S, C, sid, nc, pc, ns, ps, ~pms)  // Update client state\n    ]\n\nrule S_2:\n  let\n      MS   = PRF(pms, nc, ns) // Master secret derivation\n      Ckey = h('clientKey', nc, ns, MS) // Client key generation using hash\n      Skey = h('serverKey', nc, ns, MS) // Server key generation using hash\n  in\n    [ St_S_1(S, C, sid, nc, pc, ns, ps)  // State before receiving second client's message\n    , In(\n        < aenc{ '31', pms }pk(ltkS) // Server receives encrypted message\n        , signature // Client's signature\n        , senc{ '33', sid, MS, nc, pc, C, ns, ps, S}Ckey  // Decrypted session information\n        >\n      )\n    , !Pk(C, pkC) // Public key for client\n    , !Ltk(S, ltkS) // Long-term key for server\n    ]\n    /* Explicit equality check, enforced as part of the property. */\n  --[ Eq(verify(signature, <'32', h('32', ns, S, pms)>, pkC), true ) // Signature verification\n    , SessionKeys( S, C, Skey, Ckey ) // Establish session keys\n    , Running(C, S, <'client', MS, Skey, Ckey>) // Client is running a session with the server\n    , Commit(S, C, <'server', MS, Skey, Ckey>) // Server commits to session\n    ]->\n    [ Out(\n        senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey  // Server sends final message with session information\n      )\n    ]\n\nrule C_3:\n  let\n      MS   = PRF(pms, nc, ns) // Master secret derivation\n      Ckey = h('clientKey', nc, ns, MS) // Client key generation using hash\n      Skey = h('serverKey', nc, ns, MS) // Server key generation using hash\n  in\n    [ St_C_2(S, C, sid, nc, pc, ns, ps, pms) // State after receiving server's final message\n    , In( senc{ '4', sid, MS, nc, pc, C, ns, ps, S}Skey ) // Client receives server's final message\n    ]\n  --[ Commit(C, S, <'client', MS, Skey, Ckey>) // Client commits to session\n    , SessionKeys( S, C, Skey, Ckey ) // Establish session keys\n    ]->\n    []\n\n\n/* TODO: Also model session-key reveals and adapt security properties. */\n\nrestriction Eq_check_succeed: \"All x y #i. Eq(x,y) @ i ==> x = y\"\n\n\n/* Session key secrecy from the perspective of both the server and the client\n * for both the key of the server and the key of the client. Note that this\n * lemma thus captures four security properties at once. */\nlemma session_key_secrecy:\n     /* It cannot be that */\n   \"not(\n         Ex S C keyS keyC #k.\n           /* somebody claims to have setup session keys, */\n           SessionKeys(S, C, keyS, keyC) @ k\n           /* but the adversary knows one of them */\n         & ( (Ex #i. K(keyS) @ i)\n           | (Ex #i. K(keyC) @ i)\n           )\n           /* without having performed a long-term key reveal. */\n         & not (Ex #r. RevLtk(S) @ r)\n         & not (Ex #r. RevLtk(C) @ r)\n       )\"\n\n// Injective agreement from the perspective of both the initiator and the responder.\nlemma injective_agree:\n  \" /* Whenever somebody commits to running a session, then*/\n    All actor peer params #i.\n        Commit(actor, peer, params) @ i\n      ==>\n        /* there is somebody running a session with the same parameters */\n          (Ex #j. Running(actor, peer, params) @ j & j < i\n            /* and there is no other commit on the same parameters */\n            & not(Ex actor2 peer2 #i2.\n                    Commit(actor2, peer2, params) @ i2 & not(#i = #i2)\n                 )\n          )\n        /* or the adversary perform a long-term key reveal on actor or peer */\n        | (Ex #r. RevLtk(actor) @ r)\n        | (Ex #r. RevLtk(peer)  @ r)\n  \"\n\n/* Consistency check: ensure that session-keys can be setup between honest\n * agents. */\nlemma session_key_setup_possible:\n  exists-trace\n  \" /* There is a trace satisfying all equality checks */\n     (All x y #i. Eq(x,y) @ i ==> x = y)\n  &  /* Session keys have been setup */\n     (Ex S C keyS keyC #k.  SessionKeys(S, C, keyS, keyC) @ k\n      /* without having performed a long-term key reveal. */\n      & not (Ex #r. RevLtk(S) @ r)\n      & not (Ex #r. RevLtk(C) @ r)\n      )\n   \"\n\nend"
    },
    {
        "file": "SPTHY-1/injectivity.spthy",
        "logic": "---\n\n**Protocol Description: Injectivity Test**\n\n**Overview:**\nThe Injectivity Test protocol is a simple yet illustrative example designed to demonstrate the injectivity constraint-reduction rule within the Tamarin verification framework. This protocol serves as a foundational model for understanding how injectivity can be preserved in the presence of operations that manipulate states.\n\n**Purpose:**\nThe primary objective of the Injectivity Test is to ensure that once an object (or identifier) has been initiated, it cannot be simultaneously copied and removed in such a way that would violate its injectivity. This is critical in scenarios where the uniqueness of identifiers must be maintained throughout various operations.\n\n**Components:**\n1. **Rules:**\n   - **Init Rule:** This rule initiates an identifier `~i`. When an identifier is fresh (not previously initiated), the action of initiating (`Initiated(~i)`) transforms the state to reflect that the identifier is now considered injected (`Inj(~i)`).\n   - **Copy Rule:** The copy rule allows for the duplication of an already injected identifier. When an identifier `i` is marked as injected (`Inj(i)`), it can be copied, and the resulting state remains injected.\n   - **Remove Rule:** This rule allows for the removal of an injected identifier. If an identifier `i` is injected, it can be removed, transitioning the state to an empty set, indicating that the identifier is no longer present.\n\n2. **Lemma:**\n   - The protocol includes a lemma named `injectivity_check`, which states that it is impossible to have a sequence of events where an identifier is initiated, removed, and copied in a way that contradicts injectivity. The lemma asserts that there cannot be an identifier `id` that exists in such a conflicting series of operations (`Initiated(id)`, `Removed(id)`, and `Copied(id)`) occurring in strict chronological order.\n\n**Status:**\nThe Injectivity Test protocol is currently in a working state, having been validated for its intended constraints and operational rules.\n\n**Modeler:**\nThis protocol was modeled by Nick Moore in May 2017, reflecting a straightforward application of Tamarin's capabilities to enforce injectivity constraints.\n\n---",
        "code": "/*\n   Protocol:    Injectivity test\n   Modeler:     Nick Moore\n   Date:        May 2017\n\n   Status:      working\n\n   A simple toy example that requires the injectivity constraint-reduction rule\n   to terminate.\n\n*/\n\ntheory injectivity begin\n\nrule Init:\n  [ Fr(~i) ]\n--[ Initiated(~i) ]->\n  [ Inj(~i) ]\n\nrule Copy:\n  [ Inj(i) ]\n--[ Copied(i) ]->\n  [ Inj(i) ]\n\nrule Remove:\n  [ Inj(i) ]\n--[ Removed(i) ]->\n  []\n\nlemma injectivity_check[use_induction]: all-traces\n  \"\u00ac(Ex id #i #j #k.\n        Initiated(id) @ i & Removed(id) @ j & Copied(id) @ k\n        & #i < #j & #j < #k)\"\n\nend",
        "codenote": "/*\n   Protocol:    Injectivity test\n   Modeler:     Nick Moore\n   Date:        May 2017\n\n   Status:      working\n\n   A simple toy example that requires the injectivity constraint-reduction rule\n   to terminate.\n\n*/\n\ntheory injectivity begin\n\nrule Init:\n  [ Fr(~i) ]\n--[ Initiated(~i) ]->\n  [ Inj(~i) ]  (* Initial rule that introduces an injected value *)\n\nrule Copy:\n  [ Inj(i) ]\n--[ Copied(i) ]->\n  [ Inj(i) ]  (* Rule that allows copying of an already injected value *)\n\nrule Remove:\n  [ Inj(i) ]\n--[ Removed(i) ]->\n  []  (* Rule that removes an injected value *)\n\nlemma injectivity_check[use_induction]: all-traces\n  \"\u00ac(Ex id #i #j #k.\n        Initiated(id) @ i & Removed(id) @ j & Copied(id) @ k\n        & #i < #j & #j < #k)\"  (* Lemma ensuring injectivity over all traces *)\n\nend"
    },
    {
        "file": "SPTHY-1/CH07.spthy",
        "logic": "---\n\n**Protocol Description: RFID Protocol for Authentication**\n\nThis model represents an RFID protocol designed to facilitate secure communication between a Reader (R) and a Tag (T). The primary focus of the protocol is to ensure authentication properties, specifically recent aliveness and agreement, as outlined in the paper \"Attacks on RFID protocols\" by Ton van Deursen and Sasa Radomirovic (v1.1, Aug 6, 2009).\n\n**Components**:\n- **Entities**: \n  - Reader (R)\n  - Tag (T)\n\n- **Shared Knowledge**: \n  - A secret key \\( k \\)\n  - An identifier \\( ID \\)\n\n**Initial Setup**:\n- Both the Reader (R) and the Tag (T) possess the shared knowledge of the key \\( k \\) and the identifier \\( ID \\).\n- The protocol begins with the Reader generating a fresh random number \\( r1 \\) and sending it to the Tag.\n\n**Protocol Steps**:\n1. **Reader Initialization**: \n   - The Reader generates a random challenge \\( r1 \\) and sends it to the Tag.\n   \n2. **Tag Response**:\n   - Upon receiving \\( r1 \\), the Tag generates its own fresh random number \\( r2 \\).\n   - The Tag computes a hash based on the challenge values and the shared secret, and sends back \\( r2 \\) along with a hashed value that combines the identifier and the challenges.\n\n3. **Reader Verification**:\n   - The Reader verifies the response from the Tag by checking the received values against expected computations.\n   - If verification is successful, the Reader sends a confirmation response back to the Tag.\n\n4. **Tag Confirmation**:\n   - The Tag, upon receiving the confirmation from the Reader, acknowledges the communication, thus completing the authentication process.\n\n**Security Properties**:\n- **Recent Aliveness**: Ensures that both entities can prove they are alive and engaged in the session.\n- **Agreement**: Ensures that both parties agree on the established session parameters and that no other entity can impersonate them.\n\n**Rules**:\n- The model encapsulates several rules regarding the initialization, communication, and verification processes. These rules dictate how the entities interact, handle fresh random numbers, and verify the integrity of the exchanged messages.\n\n**Lemmas**:\n- The model includes lemmas to automatically find potential attacks, ensure the correctness of execution, and prove properties like non-injective agreement between the Reader and the Tag.\n\n---",
        "code": "theory CH07 begin\n\n/* \n  CH07 RFID protocol model based on \n  \"Attacks on RFID protocols\" v1.1 from Aug 6, 2009, by Ton van Deursen and Sasa Radomirovic\n  This model focuses on authentication properties (recent aliveness and \n  agreement.)\n\n  Reader R, Tag T, shared knowledge k, ID.\n\n  R: knows(k,ID) \n  T: knows(k,ID) \n  R: fresh(r1)\n  R -> T: r1\n  T: fresh(r2)\n  T -> R: r2,lh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k)) \n  R -> T: rh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k))\n\n*/\n\nbuiltins: xor, hashing\nfunctions: rot/2, lh/1, rh/1\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) \n   ]\n\nrule tag1:\n   let hash = h((r1\u2295~r2\u2295~k)) in \n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' )\n   , Challenge(~r2, 'Tag') \n   , Running(<'R','T',<~k XOR r1 XOR ~r2>>)\n//   , Running(<'R','T',<~k, r1, ~r2>>)\n   ]->\n   [ Out( <~r2,lh(rot(~id,hash) XOR hash)>)\n   , TagState(~k, r1, ~r2, hash)\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n   , In( <r2, lh(rot(~id,hash) XOR hash)> ) \n   ]\n --[ Alive( ~k, 'Tag' )\n   , Response(~k, 'Reader') \n   , Eq( h((~r1\u2295r2\u2295~k)), hash )\n   , Running(<'T','R',<~k XOR ~r1 XOR r2>>)\n//   , Running(<'T','R',<~k, ~r1, r2>>)\n   , Commit(<'R','T',<~k XOR ~r1 XOR r2>>)\n//   , Commit(<'R','T',<~k, ~r1, r2>>)\n   ]->\n   [ Out( rh(rot(~id,hash) XOR hash) ) ]\n\nrule tag2:\n   [ In( rh(rot(~id,hash) XOR hash) )\n   , !Tag( ~k, ~id) \n   , TagState(~k, r1, ~r2, hash)\n   ]\n --[ Alive( ~k, 'Reader' )\n   , Commit(<'T','R',<~k XOR r1 XOR ~r2>>)\n//   , Commit(<'T','R',<~k, r1, ~r2>>)\n   ]->\n   [ ]\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\"\n\n// FINDS ATTACK AUTOMATICALLY \nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Reader') @k & Response( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n// FINDS PROOF AUTOMATICALLY \nlemma recentalive_reader:\n  all-traces \"\u2200 x #i. (Alive( x, 'Reader' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Tag') @k & Response( x, 'Reader' ) @ #j & k < j & j < i)\"\n\n// Depends on what data t is specified. Use the commented out Running/Commit\n// claims above for attack. \n// FINDS PROOF/ATTACK AUTOMATICALLY. \nlemma noninjectiveagreement_tag:\n  \"All t #i. \n    Commit(<'T','R',t>) @i\n    ==> (Ex #j. Running(<'T','R',t>) @j)\"\n\n\n// Depends on what data t is specified. FINDS PROOF/ATTACK AUTOMATICALLY. \nlemma noninjectiveagreement_reader:\n  \"All t #i. \n    Commit(<'R','T',t>) @i\n    ==> (Ex #j. Running(<'R','T',t>) @j)\"\n\n// SHOWS CORRECT EXECUTION \nlemma executable:\n  exists-trace \"\u2203 x #i #j. (Alive( x, 'Reader' ) @ #i) \u2227 (Response( x, 'Tag' ) @ #j) \n           // further restriction to automatically get the desired execution\n           \u2227 (not Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend",
        "codenote": "theory CH07 begin\n\n/* \n  CH07 RFID protocol model based on \n  \"Attacks on RFID protocols\" v1.1 from Aug 6, 2009, by Ton van Deursen and Sasa Radomirovic\n  This model focuses on authentication properties (recent aliveness and \n  agreement.)\n\n  Reader R, Tag T, shared knowledge k, ID.\n\n  R: knows(k,ID) \n  T: knows(k,ID) \n  R: fresh(r1)\n  R -> T: r1\n  T: fresh(r2)\n  T -> R: r2,lh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k)) \n  R -> T: rh(rot(ID,h(r1\u2295r2\u2295k))\u2295h(r1\u2295r2\u2295k))\n\n*/\n\nbuiltins: xor, hashing\nfunctions: rot/2, lh/1, rh/1\n\nrule Setup:\n   [ Fr( ~k )\n   , Fr(~id) \n   ]\n --[ ]-> \n   [ !Reader( ~k, ~id )\n   , !Tag( ~k, ~id ) \n   ]\n\nrule reader1:\n   [ Fr( ~r1 ) ]\n --[ Challenge( ~r1, 'Reader' ) ]->\n   [ Out( ~r1 )\n   , Initiated( ~r1 ) // Reader initiates the communication by sending a challenge\n   ]\n\nrule tag1:\n   let hash = h((r1\u2295~r2\u2295~k)) in \n   [ In( r1 )\n   , Fr( ~r2 )\n   , !Tag( ~k, ~id ) ]\n --[ Response( ~k, 'Tag' ) // Tag responds with its knowledge\n   , Challenge(~r2, 'Tag') \n   , Running(<'R','T',<~k XOR r1 XOR ~r2>>)\n   //   , Running(<'R','T',<~k, r1, ~r2>>)\n   ]->\n   [ Out( <~r2, lh(rot(~id, hash) XOR hash)>)\n   , TagState(~k, r1, ~r2, hash) // Maintains the state of the Tag\n   ]\n\nrule reader2:\n   [ Initiated( ~r1 )\n   , !Reader( ~k, ~id )\n   , In( <r2, lh(rot(~id, hash) XOR hash)> ) \n   ]\n --[ Alive( ~k, 'Tag' ) // Verifies that Tag is alive\n   , Response(~k, 'Reader') \n   , Eq( h((~r1\u2295r2\u2295~k)), hash ) // Ensures that the received hash is correct\n   , Running(<'T','R',<~k XOR ~r1 XOR r2>>)\n   //   , Running(<'T','R',<~k, ~r1, r2>>)\n   , Commit(<'R','T',<~k XOR ~r1 XOR r2>>)\n   //   , Commit(<'R','T',<~k, ~r1, r2>>)\n   ]->\n   [ Out( rh(rot(~id, hash) XOR hash) ) // Reader sends the response back\n   ]\n\nrule tag2:\n   [ In( rh(rot(~id, hash) XOR hash) )\n   , !Tag( ~k, ~id) \n   , TagState(~k, r1, ~r2, hash)\n   ]\n --[ Alive( ~k, 'Reader' ) // Verifies that Reader is alive\n   , Commit(<'T','R',<~k XOR r1 XOR ~r2>>)\n   //   , Commit(<'T','R',<~k, r1, ~r2>>)\n   ]->\n   [ ] // Tag does not output anything in this step\n\nrestriction equality:\n  \"\u2200 x y #i. (Eq( x, y ) @ #i) \u21d2 (x = y)\" // Enforces the equality of inputs\n\n// FINDS ATTACK AUTOMATICALLY \nlemma recentalive_tag:\n  all-traces \"\u2200 x #i. (Alive( x, 'Tag' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Reader') @k & Response( x, 'Tag' ) @ #j & k < j & j < i)\"\n\n// FINDS PROOF AUTOMATICALLY \nlemma recentalive_reader:\n  all-traces \"\u2200 x #i. (Alive( x, 'Reader' ) @ #i) \u21d2 (\u2203 y #j #k. Challenge(y, 'Tag') @k & Response( x, 'Reader' ) @ #j & k < j & j < i)\"\n\n// Depends on what data t is specified. Use the commented out Running/Commit\n// claims above for attack. \n// FINDS PROOF/ATTACK AUTOMATICALLY. \nlemma noninjectiveagreement_tag:\n  \"All t #i. \n    Commit(<'T','R',t>) @i\n    ==> (Ex #j. Running(<'T','R',t>) @j)\"\n\n// Depends on what data t is specified. FINDS PROOF/ATTACK AUTOMATICALLY. \nlemma noninjectiveagreement_reader:\n  \"All t #i. \n    Commit(<'R','T',t>) @i\n    ==> (Ex #j. Running(<'R','T',t>) @j)\"\n\n// SHOWS CORRECT EXECUTION \nlemma executable:\n  exists-trace \"\u2203 x #i #j. (Alive( x, 'Reader' ) @ #i) \u2227 (Response( x, 'Tag' ) @ #j) \n           // further restriction to automatically get the desired execution\n           \u2227 (not Ex #k. Response( x, 'Tag' ) @ #k & (not (#j=#k)))\"\n\nend"
    }
]