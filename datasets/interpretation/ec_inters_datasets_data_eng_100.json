[
    {
        "file": "EC-1/AES.ec",
        "logic": "To generate a description content for the provided EasyCrypt (ec) file, we need to outline the key features and functionalities of the cryptographic protocol represented in the code. The following description summarizes the operations, properties, and relationships defined in the EasyCrypt file, making it easier for someone to understand the underlying protocol.\n\n---\n\n# Description of Cryptographic Protocol\n\n## Overview\nThis protocol implements the Advanced Encryption Standard (AES) algorithm, a symmetric key encryption standard used worldwide to secure data. The protocol provides operations for both encryption and decryption, utilizing various transformations and key schedules to ensure the confidentiality and integrity of the data.\n\n## Key Operations\n\n### S-Box Operations\n- **Sbox**: A substitution operation that takes an 8-bit word and produces an 8-bit output.\n- **InvSbox**: The inverse of the Sbox operation, allowing for the retrieval of the original 8-bit word from its substituted form. It is axiomatized that applying InvSbox to Sbox returns the original value.\n\n### Word Transformations\n- **SubWord**: Applies the Sbox transformation to each byte of a 32-bit word.\n- **InvSubWord**: Applies the InvSbox transformation to each byte of a 32-bit word. It is proven that applying InvSubWord to SubWord returns the original word.\n\n### State Representation\n- The state in the AES algorithm is represented as a 128-bit word, organized in a 4x4 matrix format.\n- **to_matrix**: Converts a 128-bit state into a column-major matrix representation.\n- **to_state**: Converts a matrix representation back into a 128-bit state.\n\n### Byte Substitution and Row Shifting\n- **SubBytes**: Applies the SubWord operation to each byte of the 128-bit state.\n- **InvSubBytes**: Applies the InvSubWord operation to each byte of the 128-bit state.\n- **ShiftRows**: Shifts each row of the state to the left by a certain number of bytes.\n- **InvShiftRows**: Reverses the ShiftRows operation.\n\n### Column Mixing\n- **MixColumns**: Combines the bytes of each column in the state using linear transformations.\n- **InvMixColumns**: The inverse of MixColumns, allowing for the recovery of the original state before mixing. This operation is axiomatized.\n\n### Key Addition\n- **AddRoundKey**: Performs a bitwise XOR operation between the state and a round key.\n\n## AES Instructions\nThe protocol defines several operations corresponding to the AES encryption and decryption process:\n- **AESENC**: Encrypts the state with a round key by applying the SubBytes, ShiftRows, and MixColumns operations followed by AddRoundKey.\n- **AESENCLAST**: The last encryption step that omits the MixColumns operation.\n- **AESDEC**: Decrypts the state using the inverse operations: InvShiftRows, InvSubBytes, and AddRoundKey, followed by InvMixColumns.\n- **AESDECLAST**: The last decryption step that omits the InvMixColumns operation.\n\n### Key Expansion\n- **AESKEYGENASSIST**: Assists in generating round keys from the current state and a round constant.\n\n## Redefinition of x86 AES Instructions\nThe protocol also includes a redefinition of the x86 AES instructions to align with the standard AES specification. This includes:\n- **AESENC_** and **AESENCLAST_**: Adjustments to the order of operations.\n- **AESDEC_**: Modifications to the decryption process to incorporate InvMixColumns at the end.\n\n## Lemmas and Proofs\nThe protocol includes several lemmas that establish the correctness of the transformations and operations:\n- **InvSubWordK**: Proves that Inverses hold for SubWord and InvSubWord.\n- **ShiftRows_SubBytes**: Shows the commutativity of the ShiftRows and SubBytes operations.\n- **AESDEC_AESDEC_**: Establishes the equivalence of the specified AESDEC operations under certain conditions.\n\n---\n\nThis description encapsulates the main aspects of the protocol, its operations, and its mathematical properties, providing a clear understanding of how the AES algorithm is implemented in the EasyCrypt framework. From this description, a corresponding EasyCrypt file can be generated by following the outlined structure and definitions.",
        "code": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.",
        "codenote": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t. (* The S-box transformation for bytes *)\nop InvSbox : W8.t -> W8.t. (* The inverse S-box transformation for bytes *)\n\naxiom InvSboxK w : InvSbox (Sbox w) = w. (* The S-box and its inverse should cancel *)\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. (* Apply S-box to each byte in a word *)\nop InvSubWord (w : W32.t) = map InvSbox w. (* Apply inverse S-box to each byte in a word *) \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w. (* The transformation and its inverse should cancel *)\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK. (* Using properties of mapping *)\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0]. (* Rotate the bytes of a word *)\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3). (* Converts a state (W128) to matrix form *)\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3]. (* Converts a matrix representation back to state (W128) *)\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m. (* This lemma states that converting to state and back results in the original matrix *)\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. (* Apply SubWord operation to each column of state *)\n\nop InvSubBytes (s : W128.t) = map InvSubWord s. (* Apply InvSubWord operation to each column of state *)\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w. (* The SubBytes and InvSubBytes operations should cancel *)\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK. (* Using properties of mapping *)\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2. (* Bitwise XOR two states (keys) *)\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32) (* Applies the shift rows transformation to the state *)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33) (* Applies the inverse shift rows transformation to the state *)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s. (* The inverse shift rows restores the original state *)\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. (* Mixes the columns of the state *)\n\nop InvMixColumns : W128.t -> W128.t. (* Inverse mix operation for the columns *)\n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s. (* The MixColumns and its inverse should cancel *)\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2. (* Decomposition of inverse mix operation *)\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey (* Decrypts using the AES rounds with inverse operations *)\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey (* Decrypts the last round in AES *)\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey (* Encrypts using the AES rounds *)\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey (* Encrypts the last round in AES *)\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns. (* Abbreviation for inverse mix columns operation *)\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3] (* Generates new key material based on previous state and round constant *)\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slightly differ from AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes and ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey (* Modified AES encoding operation to match standard *)\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey (* Modified AES encoding operation for the last round *)\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state (* Modified AES decoding operation to match standard *)\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s). (* ShiftRows commutes with SubBytes operation *)\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k. (* The AESENC operation is equivalent to the modified version *)\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes. (* Using commutativity property *)\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k. (* The AESENCLAST operation is equivalent to the modified version *)\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes. (* Using commutativity property *)\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k. (* The AESDEC operation is equivalent to the modified version *)\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed."
    },
    {
        "file": "EC-1/basic-hash-auth.ec",
        "logic": "---\n\n### Description of the Basic Hash Protocol\n\n**1. Key and Plaintext Spaces:**\n- The protocol operates over a key space, denoted as `key`, and a plaintext space, denoted as `ptxt`.\n- Keys are generated using a distribution `dkey`, which is defined to be full, lossless, and uniform.\n- Plaintexts (nonces) are generated using a distribution `dnonce`, which is lossless and uniform but not necessarily full.\n\n**2. Pseudorandom Functions (PRFs):**\n- The protocol utilizes multiple Pseudorandom Functions (PRFs) denoted by `F`, which take a key and a plaintext as inputs and produce a plaintext output.\n- A module is defined for the PRFs, including procedures for initialization, function evaluation, and verification (check).\n\n**3. Unforgeable Random Functions (RF):**\n- The protocol incorporates unforgeable random functions (RF) with the assumption that the hash functions used are indistinguishable from a uniform distribution over plaintexts.\n- The RF is modeled with a distribution `drf`, which is also defined to be lossless and uniform.\n\n**4. Basic Hash Protocol:**\n- The Basic Hash protocol allows tags to create messages (tagging) and a reader to verify these messages.\n- The protocol maintains logs of tag outputs and any forged messages detected by the reader.\n- There are two versions of the Basic Hash module: one without initialization (`BasicHash0`) and one with initialization (`BasicHash`).\n\n**5. Authentication Game:**\n- The protocol defines an authentication game where an adversary attempts to forge a message that a legitimate reader would accept.\n- The game checks for the existence of forged messages logged by the reader during the authentication process.\n\n**6. Security Properties:**\n- The protocol aims to ensure that an adversary cannot win the authentication game instantiated with an ideal unforgeable hash function.\n- Several lemmas are provided to establish the probability of the adversary winning the game and to analyze the indistinguishability of the PRFs used.\n\n**7. Distinguisher Against PRFs:**\n- A module for distinguishing between the PRFs used in the Basic Hash protocol is defined, allowing for the analysis of their security.\n\n---\n\nThis description encapsulates the key components and functionalities of the Basic Hash protocol, including its reliance on PRFs and RFs, the authentication process, and the security analysis through an adversarial game.",
        "code": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed.",
        "codenote": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key. (* Type representing the key space used for the PRFs *)\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni. (* Distribution over keys *)\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt. (* Type representing plaintext messages *)\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni. (* Distribution of nonces *)\n\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni). (* Nonce distribution is lossless *)\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni). (* Nonce distribution is uniform *)\n\nhint exact random : dnonce_ll. (* Hint for random choice of nonces *)\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt. (* Pseudorandom function from key and plaintext to plaintext *)\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init] (* Interface for PRF oracles, excluding the initialization *)\n}.\n\nmodule PRFs = {\n  var ks : key list (* List to hold keys initialized for multiple PRFs *)\n  \n  proc init(n : int) : unit = { (* Initialization procedure for PRFs *)\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey; (* Sample a key from the dkey distribution *)\n     ks <- k :: ks; (* Add the sampled key to the list *)\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = { (* PRF evaluation *)\n    var k;\n    i <- if (size ks <= i) then 0 else i; (* Ensure valid index *)\n    k <- nth witness ks i; (* Retrieve the key at index i *)\n    return F k x; (* Apply the PRF *)\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = { (* Check if the PRF output matches a given value *)\n    var k;\n    i <- if (size ks <= i) then 0 else i; (* Ensure valid index *)\n    k <- nth witness ks i; (* Retrieve the key at index i *)\n    return (F k x = s); (* Compare PRF output with s *)\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr. (* Distribution over random function outputs *)\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i). (* Random function properties *)\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni). (* Random function output is lossless *)\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni). (* Random function output is uniform *)\n\nmodule EUF_RF = {\n  var n : int (* Number of tags *)\n  var m : (int * ptxt, ptxt) fmap (* Mapping of (tag, nonce) to output *)\n\n  proc init(i : int) : unit = { (* Initialization procedure for unforgeable RFs *)\n    n <- i; (* Set the number of tags *)\n    m <- empty; (* Initialize the mapping to empty *)\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = { (* Evaluate the random function *)\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i; (* Ensure valid index *)\n\n    if ((i,x) \\notin m) { (* Check if the (tag, nonce) pair is new *)\n      r <$ drf i; (* Sample output from the distribution *)\n      m.[(i,x)] <- r; (* Store the output in the mapping *)\n    }\n    \n    return oget m.[(i,x)]; (* Return the output for (i, x) *)\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = { (* Check if the output matches expected value *)\n    i <- if (n <= i) then 0 else i; (* Ensure valid index *)\n    return ((i,x) \\in m && oget m.[(i,x)] = s); (* Verify existence and compare outputs *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int. (* Number of tags in the protocol *)\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list (* Logs of tag outputs *)\n  var reader_forged : (int * ptxt * ptxt) list (* Logs of forged messages by the reader *)\n\n  proc tag (i : int) : ptxt * ptxt = { (* Tag procedure, generates nonce and hash *)\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i; (* Ensure valid index *)\n    n <$ dnonce; (* Sample a nonce *)\n    h <@ H.f(i,n); (* Compute hash using current tag and nonce *)\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs; (* Store the output log *)\n    return (n, h); (* Return the nonce and hash *)\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    (* Reader's verification for a specific tag *)\n    var b;\n    b <- H.check(i, n, h); (* Use the check procedure to verify *)\n    return b; (* Return the result of the check *)\n  } \n\n  proc reader (n h : ptxt) : bool = {    (* General reader procedure for all tags *)\n    var r, b, i;\n    b <- false; (* Initialize result as false *)\n    i <- 0; (* Start from the first tag *)\n    while (i < n_tag) {\n      r <- H.check(i, n, h); (* Check the hash against each tag's expected output *)\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged; (* Log forged messages *)\n      }\n\n      b <- b || r; (* Aggregate results of checks *)\n      i <- i + 1; (* Move to the next tag *)\n    }\n    return b; (* Return whether any tag accepted the message *)\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H) (* Instantiate BasicHash0 with PRFs *)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag);  (* Initialize the PRFs *)\n    BasicHash0.tag_outputs <- []; (* Reset tag outputs log *)\n    BasicHash0.reader_forged <- []; (* Reset reader forged logs *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit (* Initialization procedure signature *)\n  proc tag (_ : int) : ptxt * ptxt (* Tag generation signature *)\n  proc reader (_: ptxt * ptxt) : bool (* Reader verification signature *)\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init] (* Type excluding the initialization *)\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit (* Adversary's action in the game *)\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT (* Full interface including BasicHash procedures *)\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H) (* Instantiate BasicHashF with PRFs *)\n  module Adv = Adv (BH) (* Instantiate the adversary with BH *)\n\n  proc main () = { (* Main procedure for the authentication game *)\n    BH.init (); (* Initialize the Basic Hash instance *)\n    Adv.a(); (* Run the adversary's attack *)\n    return (exists x, mem BasicHash0.reader_forged x ); (* Check forged outputs *)\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool (* Distinguisher procedure to differentiate *)\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = { (* Main procedure for the indistinguishability game *)\n    var b;\n\n    F.init(n_tag); (* Initialize the PRFs *)\n    b <@ D(F).distinguish(); (* Run the distinguisher *)\n    return b; (* Return the result of the distinguisher *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0 (* Type representing BasicHash interface without init *)\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F) (* Instantiate BasicHashF0 with PRFs *)\n  module A = A (BH) (* Instantiate the adversary *)\n\n  proc distinguish () = { (* Distinguisher procedure for PRF/RF *)\n    BasicHash0.tag_outputs <- [];  (* Reset tag outputs *)\n    BasicHash0.reader_forged <- [];  (* Reset reader forged logs *)\n    A.a(); (* Run the adversary *)\n    return (exists x, mem BasicHash0.reader_forged x );  (* Return result of forgery *)\n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed."
    },
    {
        "file": "EC-1/ddh-1.ec",
        "logic": "---\n\n### Description of the Decisional Diffie-Hellman (DDH) Protocol\n\n#### Overview\nThe Decisional Diffie-Hellman (DDH) protocol is a foundational assumption in cryptography that asserts the difficulty of distinguishing between pairs of exponentiated keys. Specifically, it states that given two random keys generated by exponentiation of a common generator with random exponents, it is computationally hard to differentiate between the situation where a third key is also generated using the product of those exponents and the situation where it is generated independently.\n\n#### Components\n\n1. **Key and Exponent Types**:\n   - **Key**: Represents the group elements that are used as keys in the protocol.\n   - **Exponent**: Represents the exponents used in the key generation process.\n\n2. **Operations**:\n   - **Binary Operation `(^^)`**: This operation combines two keys in the context of the group.\n   - **Identity Element `kid`**: The identity element for the key operation.\n   - **Inverse Operation `kinv`**: Computes the inverse of a key.\n   - **Multiplication `(*)`**: A binary operation on exponents.\n\n3. **Axioms**:\n   - Various axioms define the properties of the key and exponent operations, ensuring they adhere to group properties (associativity, identity, and inverses for keys, and commutativity, associativity for exponents).\n\n4. **Distribution of Exponents**:\n   - Exponents are drawn from a distribution (`dexp`) that is full, uniform, and lossless, ensuring that each exponent has a non-zero probability and that the total probability sums to one.\n\n5. **Generator**:\n   - A generator key `g` is used to produce keys by exponentiation with the defined exponent operation.\n\n6. **Uniqueness of Key Generation**:\n   - Each key can be uniquely expressed as an exponentiation of the generator with a particular exponent.\n\n#### Adversarial Models\n\n1. **DDH Adversary**:\n   - The protocol defines an adversarial model where an adversary (Adv) attempts to distinguish between two scenarios:\n     - **DDH1**: The adversary receives the keys generated as \\( (g^{q1}, g^{q2}, g^{q1 \\cdot q2}) \\).\n     - **DDH2**: The adversary receives keys generated as \\( (g^{q1}, g^{q2}, g^{q3}) \\) where \\( q3 \\) is independent of \\( q1 \\) and \\( q2 \\).\n\n2. **Advantage**:\n   - The advantage of the adversary is defined as the absolute difference between the probabilities of successfully distinguishing the two scenarios. Under certain cryptographic assumptions regarding the group and the efficiency of the adversary, this advantage is expected to be negligible.\n\n#### Conclusion\nThe Decisional Diffie-Hellman assumption serves as a fundamental building block for various cryptographic protocols. The security of these protocols often relies on the inability of adversaries to distinguish between the outputs of certain computations involving keys and exponents.\n\n---",
        "code": "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.\n\nop (^^) : key -> key -> key.  (* binary operation *)\n\nop kid : key.  (* identity *)\n\nop kinv : key -> key.  (* inverse *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).\n\naxiom kid_l (x : key) : kid ^^ x = x.\n\naxiom kid_r (x : key) : x ^^ kid = x.\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.\n\n(* commutative semigroup of exponents *)\n\ntype exp.\n\nop e : exp.  (* some exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1%r) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.\n\naxiom dexp_fu : is_full dexp.\naxiom dexp_uni : is_uniform dexp.\naxiom dexp_ll : is_lossless dexp.\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* generator *)\n\nop (^) : key -> exp -> key.  (* exponentiation *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;\n    q1 <$ dexp; q2 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));\n    return b;\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);\n    return b;\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)",
        "codenote": "(* DDH.h *)\n\n(* Decisional Diffie-Hellman Assumption *)\n\nprover [\"\"].  (* no provers *)\n\nrequire import AllCore Distr.\n\n(***************************** Exponents and Keys *****************************)\n\n(* group of keys *)\n\ntype key.  (* A type representing keys in the cryptographic system *)\n\nop (^^) : key -> key -> key.  (* binary operation for key combination *)\n\nop kid : key.  (* identity element for key multiplication *)\n\nop kinv : key -> key.  (* function to compute the inverse of a key *)\n\n(* Axioms defining properties of key multiplication *)\n\naxiom kmulA (x y z : key) : x ^^ y ^^ z = x ^^ (y ^^ z).  (* Associativity *)\n\naxiom kid_l (x : key) : kid ^^ x = x.  (* Left identity *)\n\naxiom kid_r (x : key) : x ^^ kid = x.  (* Right identity *)\n\naxiom kinv_l (x : key) : kinv x ^^ x = kid.  (* Left inverse *)\n\naxiom kinv_r (x : key) : x ^^ kinv x = kid.  (* Right inverse *)\n\n(* commutative semigroup of exponents *)\n\ntype exp.  (* A type representing exponents *)\n\nop e : exp.  (* A distinguished exponent *)\n\nop ( * ) : exp -> exp -> exp.  (* Multiplication operation for exponents *)\n\n(* Axioms defining properties of exponent multiplication *)\n\naxiom mulC (q r : exp) : q * r = r * q.  (* Commutativity *)\n\naxiom mulA (q r s : exp) : q * r * s = q * (r * s).  (* Associativity *)\n\n(* full (every element has non-zero weight), uniform (all elements\n   with non-zero weight have same weight) and lossless (sum of all\n   weights is 1) distribution over exp\n\n   consequently exp has only finitely many elements *)\n\nop dexp : exp distr.  (* Distribution over exponents *)\n\naxiom dexp_fu : is_full dexp.  (* The distribution is full *)\naxiom dexp_uni : is_uniform dexp.  (* The distribution is uniform *)\naxiom dexp_ll : is_lossless dexp.  (* The distribution is lossless *)\n\n(* connection between key and exp, via generator key and\n   exponentiation operation *)\n\nop g : key.  (* A generator key *)\n\nop (^) : key -> exp -> key.  (* Exponentiation operation for generating keys *)\n\naxiom double_exp_gen (q1 q2 : exp) : (g ^ q1) ^ q2 = g ^ (q1 * q2).  (* Exponentiation property *)\n\n(* the following axioms say that each key is uniquely generated from g\n   by exponentiation *)\n\naxiom gen_surj (x : key) : exists (q : exp), x = g ^ q.  (* Surjectivity of the generation process *)\n\naxiom gen_inj (q r : exp) : g ^ q = g ^ r => q = r.  (* Injectivity of the generation process *)\n\n(******************** Decisional Diffie-Hellman Assumption ********************)\n\n(* DDH Adversary *)\n\nmodule type DDH_ADV = {\n  proc main(k1 k2 k3 : key) : bool  (* The main procedure for the adversary taking three keys *)\n}.\n\nmodule DDH1 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2 : exp;  (* Boolean result and two exponents for the first module *)\n    q1 <$ dexp; q2 <$ dexp;  (* Sample two exponents from the distribution *)\n    b <@ Adv.main(g ^ q1, g ^ q2, g ^ (q1 * q2));  (* Call the adversary with generated keys *)\n    return b;  (* Return the result of the adversary *)\n  }\n}.\n  \nmodule DDH2 (Adv : DDH_ADV) = {\n  proc main() : bool = {\n    var b : bool; var q1, q2, q3 : exp;  (* Boolean result and three exponents for the second module *)\n    q1 <$ dexp; q2 <$ dexp; q3 <$ dexp;  (* Sample three exponents from the distribution *)\n    b <@ Adv.main(g ^ q1, g ^ q2 , g ^ q3);  (* Call the adversary with generated keys *)\n    return b;  (* Return the result of the adversary *)\n  }\n}.\n\n(* the *advantage* of a DDH adversary Adv is\n\n   `|Pr[DDH1(Adv).main() @ &m : res] - Pr[DDH2(Adv).main() @ &m : res]|\n\n   this will be negligible under certain assumptions about the group\n   key, the commutative semigroup exp, and the efficiency of Adv\n   (including that Adv doesn't compute the inverse of fun q => g ^\n   q *)"
    },
    {
        "file": "EC-1/elgamal.ec",
        "logic": "---\n\n### Protocol Description: ElGamal Encryption and DDH Reduction\n\n**1. Overview:**\nThe protocol implements a public key encryption (PKE) scheme using the ElGamal encryption algorithm. The security of this scheme relies on the Decisional Diffie-Hellman (DDH) assumption.\n\n**2. Assumptions:**\n- The protocol operates in a group setting, where operations are performed in a cyclic group defined by a generator \\( g \\).\n- The DDH assumption is assumed to hold, which states that it is computationally infeasible to distinguish between tuples of the form \\( (g^a, g^b, g^{ab}) \\) and \\( (g^a, g^b, g^c) \\) for random \\( c \\).\n\n**3. Types:**\n- **Public Key (pkey):** An element of the group, representing the public component of the key.\n- **Secret Key (skey):** A field element (randomly chosen).\n- **Plaintext (ptxt):** An element of the group, representing the message to be encrypted.\n- **Ciphertext (ctxt):** A pair of group elements, representing the encrypted message.\n\n**4. Key Generation (kg):**\n- A secret key \\( sk \\) is generated randomly.\n- The public key is computed as \\( pk = g^{sk} \\).\n- The key generation procedure returns the public key and the secret key as a tuple.\n\n**5. Encryption (enc):**\n- A random value \\( y \\) is chosen.\n- The ciphertext is constructed as a pair \\( (c_1, c_2) \\) where:\n  - \\( c_1 = g^y \\)\n  - \\( c_2 = pk^y \\cdot m \\) (the plaintext message \\( m \\) is multiplied by the encrypted form of the public key).\n- The encryption procedure returns the ciphertext.\n\n**6. Decryption (dec):**\n- The decryption procedure takes a secret key and a ciphertext.\n- The procedure extracts the two components \\( (c_1, c_2) \\) from the ciphertext.\n- It computes the decrypted plaintext as \\( m = c_2 \\cdot (c_1^{(-sk)}) \\) (where \\( c_1^{(-sk)} \\) is the inverse of \\( c_1 \\) raised to the power of the secret key).\n- The decryption returns the plaintext message.\n\n**7. Security Proof:**\nThe security of the ElGamal encryption scheme is demonstrated through a reduction to the DDH assumption:\n- An adversary \\( A \\) is defined, which interacts with the ElGamal encryption scheme.\n- A new adversary \\( DDHAdv(A) \\) is constructed that can use the outputs of \\( A \\) to make decisions about the DDH problem.\n- The proof shows that the advantage of \\( A \\) in breaking the CPA security of ElGamal is equivalent to the advantage of \\( DDHAdv(A) \\) in distinguishing between DDH instances.\n\n**8. Conclusion:**\nThe conclusion of the proof states that the difference in probabilities of \\( A \\) successfully attacking the CPA security of ElGamal versus \\( DDHAdv(A) \\) distinguishing between the two distributions is bounded, confirming the security of the ElGamal scheme under the DDH assumption.\n\n---",
        "code": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a PKE **)\ntype pkey = group.\ntype skey = F.t.\ntype ptxt = group.\ntype ctxt = group * group.\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {\n    var sk;\n\n    sk <$ dt;\n    return (g ^ sk, sk);\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {\n    var y;\n\n    y <$ dt;\n    return (g ^ y, pk ^ y * m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, gm;\n\n    (gy, gm) <- c;\n    return Some (gm * gy^(-sk));\n  }\n}.\n\n(** Reduction: from a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);\n    b        <$ {0,1};\n    b'       <@ A.guess(gy, gz * (b?m1:m0));\n    return b' = b;\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;\n      y       <$ FDistr.dt;\n      (m0,m1) <@ A.choose(g^x);\n      z       <$ FDistr.dt;\n      b'      <@ A.guess(g^y, g^z);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion.",
        "codenote": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\n(** Assumption: set DDH *)\n(*** WARNING: DiffieHellman is really out of date ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Construction: a Public Key Encryption (PKE) **)\ntype pkey = group.        (* Type representing the public key *)\ntype skey = F.t.         (* Type representing the secret key *)\ntype ptxt = group.       (* Type representing plaintext messages *)\ntype ctxt = group * group. (* Type representing ciphertexts as pairs *)\n\nclone import PKE_CPA as PKE with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGamal Encryption Scheme **)\nmodule ElGamal : Scheme = {\n  proc kg(): pkey * skey = {  (* Key generation procedure *)\n    var sk;\n\n    sk <$ dt;  (* Sample a secret key sk from the distribution dt *)\n    return (g ^ sk, sk);  (* Return the public key and the secret key *)\n  }\n\n  proc enc(pk:pkey, m:ptxt): ctxt = {  (* Encryption procedure *)\n    var y;\n\n    y <$ dt;  (* Sample a random value y from the distribution dt *)\n    return (g ^ y, pk ^ y * m);  (* Return the ciphertext (g^y, pk^y * m) *)\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {  (* Decryption procedure *)\n    var gy, gm;\n\n    (gy, gm) <- c;  (* Unpack the ciphertext into its components *)\n    return Some (gm * gy^(-sk));  (* Return the plaintext *)\n  }\n}.\n\n(** Reduction: From a PKE adversary, construct a DDH adversary *)\nmodule DDHAdv (A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {  (* Guessing procedure for the adversary *)\n    var m0, m1, b, b';\n    (m0, m1) <- A.choose(gx);  (* The adversary chooses two messages based on gx *)\n    b        <$ {0,1};  (* Randomly choose a bit b *)\n    b'       <@ A.guess(gy, gz * (b?m1:m0));  (* The adversary makes a guess *)\n    return b' = b;  (* Return whether the guess was correct *)\n  }\n}.\n\n(** We now prove that, for all adversary A, we have:\n      `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r |\n      = `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n           - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.        **)\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.  (* The choosing process is lossless *)\n  axiom Ag_ll: islossless A.guess.    (* The guessing process is lossless *)\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(ElGamal,A).main() @ &m : res] =\n      Pr[DDH0(DDHAdv(A)).main() @ &m : res].  (* Equivalence of CPA and DDH0 probabilities *)\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -5.\n  auto; call (_:true).\n  auto; call (_:true).\n  by auto=> /> sk _ y _ r b _; rewrite pow_pow.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {  (* Main procedure of the Gb module *)\n      var x, y, z, m0, m1, b, b';\n      x       <$ FDistr.dt;  (* Sample x from the fair distribution *)\n      y       <$ FDistr.dt;  (* Sample y from the fair distribution *)\n      (m0,m1) <@ A.choose(g^x);  (* Choose messages based on public key g^x *)\n      z       <$ FDistr.dt;  (* Sample z from the fair distribution *)\n      b'      <@ A.guess(g^y, g^z);  (* The adversary guesses based on g^y and g^z *)\n      b       <$ {0,1};  (* Randomly choose a bit b *)\n      return b' = b;  (* Return whether the guess was correct *)\n    }\n  }.\n\n  local lemma ddh1_gb &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res] =\n      Pr[Gb.main() @ &m : res].  (* Equivalence of DDH1 and Gb probabilities *)\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 3 2; swap{1} [5..6] 2; swap{2} 6 -2.\n  auto; call (_:true); wp.\n  rnd (fun z, z + log (if b then m1 else m0){2})\n      (fun z, z - log (if b then m1 else m0){2}).\n  auto; call (_:true).\n  by auto; progress; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.  (* Probability of Gb is 1/2 *)\n  proof.\n  byphoare=> //; proc.\n  rnd  (pred1 b')=> //=.\n  conseq (: _ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  islossless;[ apply Ag_ll | apply Ac_ll].\n  qed.\n\n  lemma conclusion &m :\n    `| Pr[CPA(ElGamal,A).main() @ &m : res] - 1%r/2%r | =\n    `| Pr[DDH0(DDHAdv(A)).main() @ &m : res] -\n         Pr[DDH1(DDHAdv(A)).main() @ &m : res] |.  (* Final conclusion lemma *)\n  proof.\n  by rewrite (cpa_ddh0 &m) (ddh1_gb &m) (Gb_half &m).\n  qed.\nend section Security.\n\nprint conclusion."
    },
    {
        "file": "EC-1/hashed_elgamal_std.ec",
        "logic": "---\n\n### Description of the Protocol\n\n#### 1. **Overview**\n\nThis protocol implements a public key encryption (PKE) scheme based on the Hashed ElGamal construction. It leverages the Diffie-Hellman (DH) key exchange to establish a shared secret, ensuring security against chosen plaintext attacks (CPA) under the Decisional Diffie-Hellman (DDH) assumption.\n\n#### 2. **Assumptions**\n\n- **Decisional Diffie-Hellman Assumption (DDH)**: We assume that the DH problem is hard, i.e., given \\( (g^x, g^y, g^z) \\), it is computationally infeasible to determine whether \\( z \\) is equal to \\( xy \\) (modulo the group order).\n- **Entropy Smoothing**: The protocol employs an entropy smoothing mechanism to enhance the security properties of the cryptographic operations.\n\n#### 3. **Data Types**\n\n- **Public Key (`pkey`)**: A tuple containing a key \\( hkey \\) and a group element.\n- **Secret Key (`skey`)**: A tuple consisting of a key \\( hkey \\) and a random value from a finite field.\n- **Plaintext (`ptxt`)**: A binary string (represented as `bits`).\n- **Ciphertext (`ctxt`)**: A pair consisting of a group element and a binary string.\n\n#### 4. **Key Generation**\n\nThe key generation procedure produces a public key and a secret key:\n- The public key is derived from the DH key \\( hkey \\) and a group element raised to the power of a secret key \\( sk \\).\n- The secret key consists of the DH key and the random secret used in the computation.\n\n#### 5. **Encryption Procedure**\n\nThe encryption process takes a public key and a plaintext message as inputs:\n- A random value \\( y \\) is sampled.\n- A hash of the public key and the group element raised to \\( y \\) is computed.\n- The ciphertext is formed as a pair containing the group element raised to \\( y \\) and the hashed value combined with the plaintext.\n\n#### 6. **Decryption Procedure**\n\nThe decryption process takes a secret key and a ciphertext as inputs:\n- The ciphertext is split into its components.\n- A hash is computed from the secret key and the group element from the ciphertext.\n- The original plaintext is recovered by reversing the hash operation on the ciphertext.\n\n#### 7. **Security Claims**\n\nThe protocol claims security as follows:\n\n- **CPA Security**: The Hashed ElGamal scheme is shown to be CPA-secure under the DDH assumption. The security is established via a series of lemmas that relate the success probabilities of the adversary in attacking the encryption scheme to the probabilities of winning a game based on the DDH assumption.\n- **Entropy Smoothing Security**: The protocol includes proofs that connect the success of the adversary in guessing the outputs of the entropy smoothing processes to the original security claims.\n\n#### 8. **Conclusion**\n\nThe protocol successfully demonstrates a secure public key encryption scheme that incorporates hashing to mitigate potential vulnerabilities while relying on well-established cryptographic assumptions. The proofs of security are structured to show that any advantage an adversary has in breaking the scheme can be translated to an advantage in solving the underlying hard problems.\n\n---",
        "code": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman BitWord PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\nop k : { int | 0 < k } as gt0_k.\n\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"\n  \"dunifin\" as \"dbits\".\nimport DWord.\n\n(** Assumption: DDH **)\n(*** WARNING: DiffieHellman is not up to speed with latest developments ***)\nclone import DiffieHellman as DH.\nimport DDH FDistr.\n\n(** Assumption Entropy Smoothing *)\ntheory EntropySmoothing.\n  type hkey.\n\n  op dhkey: { hkey distr | is_lossless dhkey } as dhkey_ll.\n  hint exact random : dhkey_ll.  \n\n  op hash : hkey -> group -> bits.\n\n  module type AdvES = {\n    proc guess(_: hkey * bits) : bool\n  }.\n\n  module ES0 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, h;\n      hk <$ dhkey;\n      h  <$ dbits;\n      b  <@ A.guess(hk,h);\n      return b;\n    }\n  }.\n\n  module ES1 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, z;\n      hk <$ dhkey;\n      z  <$ dt;\n      b  <@ A.guess(hk, hash hk (g ^ z));\n      return b;\n    }\n  }.\nend EntropySmoothing.\nimport EntropySmoothing.\n\n(** Construction: a PKE **)\ntype pkey = hkey * group.\ntype skey = hkey * F.t.\ntype ptxt = bits.\ntype ctxt = group * bits.\n\nclone import PKE_CPA as PKE_ with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGammal **)\nmodule Hashed_ElGamal : Scheme = {\n  proc kg() = {\n    var hk,sk;\n\n    hk <$ dhkey;\n    sk <$ dt;\n    return ((hk,g ^ sk), (hk,sk));\n  }\n\n  proc enc(pk: pkey, m: ptxt) = {\n    var y, h;\n\n    y <$ dt;\n    h <- hash pk.`1 (pk.`2 ^ y);\n    return (g ^ y, h +^ m);\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;\n\n    (gy, hm) <- c;\n    h        <- hash sk.`1 (gy ^ sk.`2);\n    return Some (h +^ hm);\n  }\n}.\n\n(** Exact security *)\nmodule DDHAdv(A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var hk, m0, m1, b, b', h;\n    hk       <$ dhkey;\n    (m0, m1) <@ A.choose((hk,gx));\n    b        <$ {0,1};\n    h        <- hash hk gz;\n    b'       <@ A.guess(gy,h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nmodule ESAdv(A:Adversary) = {\n  proc guess (hk, h) : bool = {\n    var x, y, m0, m1, b, b';\n    x        <$ dt;\n    y        <$ dt;\n    (m0, m1) <@ A.choose((hk,g^x));\n    b        <$ {0,1};\n    b'       <@ A.guess(g^y, h +^ (b?m1:m0));\n    return b' = b;\n  }\n}.\n\nsection Security.\n  declare module A:Adversary.\n  axiom Ac_ll: islossless A.choose.\n  axiom Ag_ll: islossless A.guess.\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(Hashed_ElGamal,A).main() @ &m : res]\n    = Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 1 1; swap{1} 8 -6; swap{2} 6 -3.\n  auto; call (: true).\n  auto; call (: true).\n  by auto=> /> sk _ y _ hk _ [m0 m1] b _ /=; rewrite pow_pow.\n  qed.\n\n  local lemma ddh1_es1 &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res]\n    = Pr[ES1(ESAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -3; swap{2} [5..6] -4; swap{2} 4 -1.\n  auto; call (: true).\n  auto; call (:true).\n  by auto.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var hk, x, y, v,m0, m1, b, b';\n      hk      <$ dhkey;\n      x       <$ dt;\n      y       <$ dt;\n      (m0,m1) <@ A.choose(hk,g^x);\n      v       <$ dbits;\n      b'      <@ A.guess(g^y, v);\n      b       <$ {0,1};\n      return b' = b;\n    }\n  }.\n\n  local lemma es0_Gb &m:\n      Pr[ES0(ESAdv(A)).main() @ &m : res]\n    = Pr[Gb.main()@ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 2 1. swap{1} [3..4] 4. swap{2} 7 -2.\n  auto; call (: true); wp.\n  rnd (fun w, w +^ (b0{1} ? m1{1} : m0{1})).\n  auto; call (: true).\n  by auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.\n  proof.\n  byphoare=> //; proc.\n  rnd (pred1 b')=> /=; conseq (_:_ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  call Ag_ll; auto.\n  by call Ac_ll; auto=> />; rewrite dhkey_ll dt_ll dbits_ll.\n  qed.\n\n  lemma conclusion &m :\n       `| Pr[CPA(Hashed_ElGamal,A).main() @ &m : res] - 1%r/2%r |\n    <= `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n          - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |\n       + `| Pr[ES0(ESAdv(A)).main() @ &m : res]\n            - Pr[ES1(ESAdv(A)).main() @ &m : res]|.\n  proof.\n  rewrite (cpa_ddh0 &m) (ddh1_es1 &m) (es0_Gb &m) (Gb_half &m).\n  smt(@Real).\n  qed.\nend section Security.\n\nprint conclusion.",
        "codenote": "(* -------------------------------------------------------------------- *)\nrequire import AllCore Int Real Distr DBool.\nrequire (*--*) DiffieHellman BitWord PKE_CPA.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* ---------------------- Let's Get Started --------------------------- *)\nop k : { int | 0 < k } as gt0_k. (* A public parameter k greater than zero for key generation *)\n\n(* Cloning BitWord module with necessary variables *)\nclone import BitWord as Bits with\n  op n <- k\nproof gt0_n by exact/gt0_k\nrename\n  \"word\" as \"bits\"               (* Rename for clarity *)\n  \"dunifin\" as \"dbits\".          (* Rename for clarity *)\nimport DWord.\n\n(** Assumption: DDH **)\n(*** WARNING: DiffieHellman is not up to speed with latest developments ***)\nclone import DiffieHellman as DH.  (* Assumption that Diffie-Hellman problem is hard *)\nimport DDH FDistr.                   (* Import Decision Diffie-Hellman related structures *)\n\n(** Assumption Entropy Smoothing *)\ntheory EntropySmoothing.\n  type hkey.                      (* Type for the secret Diffie-Hellman key *)\n\n  op dhkey: { hkey distr | is_lossless dhkey } as dhkey_ll.  (* Key generation is lossless *)\n  hint exact random : dhkey_ll.  \n\n  op hash : hkey -> group -> bits.  (* Hash function from keys and groups to bits *)\n\n  module type AdvES = {\n    proc guess(_: hkey * bits) : bool  (* Adversary's guessing procedure *)\n  }.\n\n  module ES0 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, h;           (* Variables for holding boolean result, key, and hash *)\n      hk <$ dhkey;           (* Generate a lossless Diffie-Hellman key *)\n      h  <$ dbits;           (* Generate random bits *)\n      b  <@ A.guess(hk,h);   (* Adversary guesses based on the key and hash *)\n      return b;              (* Return the outcome of the guess operation *)\n    }\n  }.\n\n  module ES1 (A:AdvES) = {\n    proc main () : bool = {\n      var b, hk, z;           (* Variables for holding boolean result, key, and random value *)\n      hk <$ dhkey;           (* Generate a lossless Diffie-Hellman key *)\n      z  <$ dt;               (* Generate random value from distribution *)\n      b  <@ A.guess(hk, hash hk (g ^ z));  (* Adversary's guessing with hash *)\n      return b;              (* Return the outcome of the guess operation *)\n    }\n  }.\nend EntropySmoothing.\nimport EntropySmoothing.\n\n(** Construction: a PKE **)\ntype pkey = hkey * group.           (* Public key type as a combination of hkey and group *)\ntype skey = hkey * F.t.             (* Secret key type as a combination of hkey and field element *)\ntype ptxt = bits.                   (* Plaintext type defined as bits *)\ntype ctxt = group * bits.           (* Ciphertext type as a combination of group and bits *)\n\n(* Cloning PKE_CPA module with necessary types *)\nclone import PKE_CPA as PKE_ with\n  type pkey <- pkey,\n  type skey <- skey,\n  type ptxt <- ptxt,\n  type ctxt <- ctxt.\n\n(** Concrete Construction: Hashed ElGamal **)\nmodule Hashed_ElGamal : Scheme = {\n  proc kg() = {\n    var hk,sk;                      (* Variables for public and secret keys *)\n\n    hk <$ dhkey;                    (* Generate a lossless Diffie-Hellman key *)\n    sk <$ dt;                       (* Generate a random secret key from distribution *)\n    return ((hk,g ^ sk), (hk,sk));  (* Return public and secret keys *)\n  }\n\n  proc enc(pk: pkey, m: ptxt) = {\n    var y, h;                      (* Variables for random value and hash *)\n    \n    y <$ dt;                       (* Generate random value from distribution *)\n    h <- hash pk.`1 (pk.`2 ^ y);   (* Calculate hash using public key and random value *)\n    return (g ^ y, h +^ m);        (* Return ciphertext as a pair of group and modified plaintext *)\n  }\n\n  proc dec(sk:skey, c:ctxt): ptxt option = {\n    var gy, h, hm;                 (* Variables for ciphertext elements and hash *)\n\n    (gy, hm) <- c;                 (* Extract components of the ciphertext *)\n    h        <- hash sk.`1 (gy ^ sk.`2);  (* Calculate hash using secret key *)\n    return Some (h +^ hm);        (* Return the original plaintext *)\n  }\n}.\n\n(** Exact security *)\nmodule DDHAdv(A:Adversary) = {\n  proc guess (gx, gy, gz) : bool = {\n    var hk, m0, m1, b, b', h;         (* Variables for keys, messages and guesses *)\n    hk       <$ dhkey;               (* Generate a lossless Diffie-Hellman key *)\n    (m0, m1) <@ A.choose((hk,gx));    (* Adversary chooses two messages based on public key *)\n    b        <$ {0,1};                (* Randomly choose a boolean *)\n    h        <- hash hk gz;           (* Calculate hash for the guess *)\n    b'       <@ A.guess(gy,h +^ (b?m1:m0));  (* Adversary's guess using chosen messages *)\n    return b' = b;                    (* Check if the guess equals random choice *)\n  }\n}.\n\nmodule ESAdv(A:Adversary) = {\n  proc guess (hk, h) : bool = {\n    var x, y, m0, m1, b, b';           (* Variables for guessing procedure *)\n    x        <$ dt;                    (* Generate random value from distribution *)\n    y        <$ dt;                    (* Generate another random value *)\n    (m0, m1) <@ A.choose((hk,g^x));    (* Adversary chooses based on generated values *)\n    b        <$ {0,1};                  (* Randomly choose a boolean *)\n    b'       <@ A.guess(g^y, h +^ (b?m1:m0));  (* Adversary's guess based on hash *)\n    return b' = b;                      (* Check if the guess equals random choice *)\n  }\n}.\n\nsection Security.\n  declare module A:Adversary.         (* Declare the adversary module *)\n  axiom Ac_ll: islossless A.choose.   (* Axiom stating choose operation is lossless *)\n  axiom Ag_ll: islossless A.guess.    (* Axiom stating guess operation is lossless *)\n\n  local lemma cpa_ddh0 &m:\n      Pr[CPA(Hashed_ElGamal,A).main() @ &m : res]\n    = Pr[DDH0(DDHAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 1 1; swap{1} 8 -6; swap{2} 6 -3.\n  auto; call (: true).\n  auto; call (: true).\n  by auto=> /> sk _ y _ hk _ [m0 m1] b _ /=; rewrite pow_pow.\n  qed.\n\n  local lemma ddh1_es1 &m:\n      Pr[DDH1(DDHAdv(A)).main() @ &m : res]\n    = Pr[ES1(ESAdv(A)).main() @ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 7 -3; swap{2} [5..6] -4; swap{2} 4 -1.\n  auto; call (: true).\n  auto; call (:true).\n  by auto.\n  qed.\n\n  local module Gb = {\n    proc main () : bool = {\n      var hk, x, y, v,m0, m1, b, b';  (* Variables for Gb module *)\n      hk      <$ dhkey;                (* Generate a lossless Diffie-Hellman key *)\n      x       <$ dt;                   (* Generate random value from distribution *)\n      y       <$ dt;                   (* Generate another random value *)\n      (m0,m1) <@ A.choose(hk,g^x);      (* Adversary chooses messages based on key *)\n      v       <$ dbits;                 (* Generate random bits *)\n      b'      <@ A.guess(g^y, v);      (* Adversary guesses using generated values *)\n      b       <$ {0,1};                 (* Randomly choose a boolean *)\n      return b' = b;                   (* Return whether the guess matches the choice *)\n    }\n  }.\n\n  local lemma es0_Gb &m:\n      Pr[ES0(ESAdv(A)).main() @ &m : res]\n    = Pr[Gb.main()@ &m : res].\n  proof.\n  byequiv=> //; proc; inline *.\n  swap{1} 2 1. swap{1} [3..4] 4. swap{2} 7 -2.\n  auto; call (: true); wp.\n  rnd (fun w, w +^ (b0{1} ? m1{1} : m0{1})).\n  auto; call (: true).\n  by auto=> /> *; split => *; algebra.\n  qed.\n\n  local lemma Gb_half &m:\n     Pr[Gb.main()@ &m : res] = 1%r/2%r.  (* Probability statement for Gb *)\n  proof.\n  byphoare=> //; proc.\n  rnd (pred1 b')=> /=; conseq (_:_ ==> true).\n  + by move=> /> b; rewrite dbool1E pred1E.\n  call Ag_ll; auto.\n  by call Ac_ll; auto=> />; rewrite dhkey_ll dt_ll dbits_ll.\n  qed.\n\n  lemma conclusion &m :\n       `| Pr[CPA(Hashed_ElGamal,A).main() @ &m : res] - 1%r/2%r |\n    <= `| Pr[DDH0(DDHAdv(A)).main() @ &m : res]\n          - Pr[DDH1(DDHAdv(A)).main() @ &m : res] |\n       + `| Pr[ES0(ESAdv(A)).main() @ &m : res]\n            - Pr[ES1(ESAdv(A)).main() @ &m : res]|.\n  proof.\n  rewrite (cpa_ddh0 &m) (ddh1_es1 &m) (es0_Gb &m) (Gb_half &m).\n  smt(@Real).\n  qed.\nend section Security.\n\nprint conclusion."
    },
    {
        "file": "EC-1/KEMDEM.ec",
        "logic": "---\n\n## Description of the KEM-DEM Composition Protocol\n\n### Overview\n\nThe protocol defines a composition of a Key Encapsulation Mechanism (KEM) and a Data Encryption Mechanism (DEM) to construct a Public Key Encryption (PKE) scheme. The KEM generates a session key, which is then used by the DEM to encrypt the actual message. This approach allows for secure and efficient encryption of messages using public key cryptography.\n\n### Types\n\n1. **Types Definition**:\n   - `pkey`: Public key type.\n   - `skey`: Secret key type.\n   - `pt`: Plaintext type (the message to be encrypted).\n   - `key`: Key type (the session key generated by the KEM).\n   - `kct`: KEM ciphertext type.\n   - `dct`: DEM ciphertext type.\n\n2. **Key Distribution**:\n   - A distribution operation `dkey` is defined as the uniform distribution over the key space.\n\n### KEM Specification\n\nA KEM is defined as a module with three procedures:\n- `keygen()`: Generates a public key and a secret key.\n- `enc(pk: pkey)`: Takes a public key and returns a session key and a KEM ciphertext.\n- `dec(sk: skey, c: kct)`: Takes a secret key and a KEM ciphertext and returns the session key or `None` if decryption fails.\n\n### CPA Adversary for KEM\n\nA CPA adversary against the KEM is defined as a module with one procedure:\n- `distinguish(pk: pkey, k: key, c: kct)`: Determines whether the session key `k` can be distinguished from a random key based on the KEM ciphertext `c`.\n\n### KEM CPA Experiment\n\nThe `KEM_CPA_Exp` module defines the experiment for a CPA adversary against the KEM, where the adversary tries to distinguish between two scenarios based on its access to the KEM.\n\n### DEM Specification\n\nA DEM is defined as a module with two procedures:\n- `enc(k: key, m: pt)`: Encrypts a plaintext message `m` using a session key `k` to produce a DEM ciphertext.\n- `dec(k: key, c: dct)`: Decrypts a DEM ciphertext `c` using a session key `k` to recover the plaintext message.\n\n### Passive Adversary for DEM\n\nA passive adversary against the DEM is defined as a module with two procedures:\n- `choose()`: Chooses two plaintext messages.\n- `distinguish(c: dct)`: Determines whether the ciphertext `c` corresponds to one of the chosen plaintext messages.\n\n### PKE Specification\n\nA PKE scheme is defined as a module with three procedures:\n- `keygen()`: Generates a public key and a secret key.\n- `enc(pk: pkey, m: pt)`: Encrypts a message `m` using the public key `pk` to produce a ciphertext.\n- `dec(sk: skey, c: kct * dct)`: Decrypts a ciphertext to recover the plaintext message.\n\n### CPA Adversary for PKE\n\nA CPA adversary against the PKE is defined as a module with two procedures:\n- `choose(pk: pkey)`: Chooses two plaintext messages based on the public key.\n- `distinguish(c: kct * dct)`: Distinguishes the ciphertext produced for the chosen messages.\n\n### KEM-DEM Composition\n\nThe `KEMDEM` module composes the KEM and DEM to provide a PKE scheme. It implements the `keygen`, `enc`, and `dec` procedures, using the KEM to generate a session key and the DEM to encrypt the message.\n\n### Security Proof\n\nThe security of the KEM-DEM composition is proven via a series of reductions to the security of the underlying KEM and DEM. The proof constructs intermediate games to establish relationships between the adversary's advantage in the PKE scheme and the advantages in the KEM and DEM schemes.\n\n### Conclusion\n\nThis protocol illustrates a systematic approach to building a secure PKE scheme using KEM and DEM, with a formal security analysis to ensure robustness against chosen-plaintext attacks.\n\n---",
        "code": "(* As specified in Boneh and Shoup's \"Graduate Course in Applied Cryptography\"\n     https://toc.cryptobook.us/\n   (Exercise 11.9 of version 0.6.)\n*)\nrequire import AllCore Distr.\n\n(** A more mature proof would rely on libraries of definitions-generic\n    definitions have a lot more parameters than what we'd like to\n    expose a tutorial reader to.\n\n    Instead, we inline (and specialise) the definitions we care about.\n**)\n\n(* Given sets of public keys, secret keys, plaintexts, DEM keys, KEM\n   ciphertexts and DEM ciphertexts ... *)\ntype pkey, skey, pt, key, kct, dct.\n\n(* ... and the uniform distribution over the DEM key space *)\nop [lossless full uniform] dkey : key distr.\n\n\n(** A KEM is a triple of (potentially probabilistic and stateful)\n    algorithms:\n**)\nmodule type KEM = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey): key * kct\n  proc dec(sk : skey, k : kct): key option\n}.\n\n(** A CPA adversary against the KEM is an algorithm: **)\nmodule type KEM_CPA_Adv = {\n  proc distinguish(pk : pkey, k : key, c : kct): bool\n}.\n\n(** And we define the advantage of a CPA adversary A against a KEM E\n    as\n      `|   Pr[KEM_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[KEM_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where KEM_CPA_Exp is the experiment:\n**)\nmodule KEM_CPA_Exp (E : KEM) (A : KEM_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, k0, k1, k, c, r;\n\n    (pk, sk) <@ E.keygen();\n    (k0, c) <@ E.enc(pk);\n    k1 <$ dkey;\n    k <- if b then k1 else k0;\n    r <@ A.distinguish(pk, k, c);\n    return r;\n  }\n}.\n\n(** A DEM is a pair of algorithms: **)\nmodule type DEM = {\n  (* We force key generation to be sampling in `dkey` *)\n  proc enc(k : key, m : pt): dct\n  proc dec(k : key, c : dct): pt\n}.\n\n(** A passive/eavesdropping DEM adversary is a pair of algorithms: **)\nmodule type DEM_PAS_Adv = {\n  proc choose(): pt * pt\n  proc distinguish(c : dct): bool\n}.\n\n(** And we define the advantage of a passive adversary A against a DEM\n    as\n      `|   Pr[DEM_PAS_Exp(E, A).run(false) @ &m: res]\n         - Pr[DEM_PAS_Exp(E, A).run(true) @ &m: res]  |\n    where DEM_PAS_Exp is the experiment:\n**)\nmodule DEM_PAS_Exp (E : DEM) (A : DEM_PAS_Adv) = {\n  proc run(b : bool) = {\n    var k, m0, m1, c, r;\n\n    k <$ dkey;\n    (m0, m1) <@ A.choose();\n    c <@ E.enc(k, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(** We have defined our assumptions, we can now define our\n    constructive goal.\n\n    A public key encryption scheme (with structured ciphertexts!) is a\n    triple of algorithms:\n**)\nmodule type PKE = {\n  proc keygen(): pkey * skey\n  proc enc(pk : pkey, m : pt): kct * dct\n  proc dec(sk : skey, c : kct * dct): pt option\n}.\n\n(** A CPA adversary against a PKE is a pair of algorithms: **)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey): pt * pt\n  proc distinguish(c : kct * dct): bool\n}.\n\n(** The advantage of a CPA adversary A against a PKE E is\n      `|   Pr[PKE_CPA_Exp(E, A).run(false) @ &m: res]\n         - Pr[PKE_CPA_Exp(E, A).run(true) @ &m: res]  |\n    where PKE_CPA_Exp is the experiment:\n**)\nmodule PKE_CPA_Exp (E : PKE) (A : PKE_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, c, r, m0, m1;\n\n    (pk, sk) <@ E.keygen();\n    (m0, m1) <@ A.choose(pk);\n    c <@ E.enc(pk, if b then m1 else m0);\n    r <@ A.distinguish(c);\n    return r;\n  }\n}.\n\n(* (* Note: instead of defining a specialised notion of PKE with\n      structured ciphertexts, we could have obtained very similar\n      definitions by _instantiating_ a library definition.\n\n      However, note that the humongous variety of ways in which CPA\n      security for PKEs can be expressed makes developing such a\n      library a tricky proposition.\n   *)\nrequire PKE.\nclone PKE as KEM_Based_PKE with\n  type pkey <= pkey,\n  type skey <= skey,\n  type plaintext <= pt,\n  type ciphertext <= kct * dct.\n\nprint KEM_Based_PKE.Scheme.\n*)\n\n(** Finally, we can define our KEM/DEM composition **)\nmodule KEMDEM (E_kem : KEM) (E_s : DEM): PKE = {\n  proc keygen = E_kem.keygen\n\n  proc enc(pk : pkey, m : pt): kct * dct = {\n    var k, kc, c;\n\n    (k, kc) <@ E_kem.enc(pk);\n    c <@ E_s.enc(k, m);\n    return (kc, c);\n  }\n\n  proc dec(sk : skey, c : kct * dct): pt option = {\n    var kc, dc, r, k, m;\n\n    (kc, dc) <- c;\n    r <- None;\n    k <@ E_kem.dec(sk, kc);\n    if (k <> None) {\n      m <@ E_s.dec(oget k, dc);\n      r <- Some m;\n    }\n    return r;\n  }\n}.\n\n\n(*** And we prove its security: there exist reductions B_kem_0(E_s),\n       B_kem_1(E_s) and B_s(E_kem) such that ...\n***)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m0);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);\n    c' <@ E_s.enc(k, m1);\n    r <@ A.distinguish(c, c');\n    return r;\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    return (m0, m1);\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: KEM { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();\n    (m0, m1) <@ A.choose(pk);\n    (k0, kc) <@ E_kem.enc(pk);\n    k1 <$ dkey;\n    c <@ E_s.enc(k1, if b then m1 else m0);\n    r <@ A.distinguish(kc, c);\n    return r;\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} ^r<@.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} ^c<@.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} ^pk0<- -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd {2}.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} ^r<@.\nswap {1} ^pk0<- -3. swap {1} ^c0<- & +1 @^pk0<- & +1.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ c{1} = kc{2})=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} ^r<@.\n  swap {2} ^c0<- & +1 -2. swap {2} ^k<$ 2.\n  inline {2} 1.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} ^k<$ 1.\ninline {2} ^r<@.\nswap {2} ^c0<- & +1 -3.\ninline {2} 1.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} ^pk0<- -1. swap {1} 5 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd {2}; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} ^pk0<- -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem.",
        "codenote": "(* As specified in Boneh and Shoup's \"Graduate Course in Applied Cryptography\"\n     https://toc.cryptobook.us/\n   (Exercise 11.9 of version 0.6.)\n*)\nrequire import AllCore Distr.\n\n(** A more mature proof would rely on libraries of definitions-generic\n    definitions have a lot more parameters than what we'd like to\n    expose a tutorial reader to.\n    Instead, we inline (and specialise) the definitions we care about.\n**)\n\n(* Given sets of public keys, secret keys, plaintexts, DEM keys, KEM\n   ciphertexts and DEM ciphertexts ... *)\ntype pkey, skey, pt, key, kct, dct.\n\n(* ... and the uniform distribution over the DEM key space *)\nop [lossless full uniform] dkey : key distr.\n\n\n(** A KEM (Key Encapsulation Mechanism) is a triple of (potentially \n    probabilistic and stateful) algorithms used for key encapsulation.\n**)\nmodule type KEM = {\n  proc keygen(): pkey * skey    (* Key generation procedure *)\n  proc enc(pk : pkey): key * kct  (* Encryption procedure that returns a key and a ciphertext *)\n  proc dec(sk : skey, k : kct): key option  (* Decryption procedure that returns the key if successful *)\n}.\n\n(** A CPA (Chosen Plaintext Attack) adversary against the KEM is an algorithm\n    that distinguishes between two scenarios based on the public key, key, \n    and ciphertext provided.\n**)\nmodule type KEM_CPA_Adv = {\n  proc distinguish(pk : pkey, k : key, c : kct): bool\n}.\n\n(** The advantage of a CPA adversary A against a KEM E is defined as the \n    absolute difference between the probabilities of A successfully \n    distinguishing the KEM outputs under two different scenarios.\n**)\nmodule KEM_CPA_Exp (E : KEM) (A : KEM_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, k0, k1, k, c, r;\n\n    (pk, sk) <@ E.keygen();       (* Generate public and secret keys *)\n    (k0, c) <@ E.enc(pk);         (* Encrypt using the public key *)\n    k1 <$ dkey;                   (* Sample a random key *)\n    k <- if b then k1 else k0;   (* Choose between the random key and the output key *)\n    r <@ A.distinguish(pk, k, c);(* Invoke the adversary's distinguish procedure *)\n    return r;                     (* Return the result *)\n  }\n}.\n\n(** A DEM (Deterministic Encryption Mechanism) is a pair of algorithms\n    used for encryption and decryption of plaintexts.\n**)\nmodule type DEM = {\n  (* We force key generation to be sampling in `dkey` *)\n  proc enc(k : key, m : pt): dct     (* Encrypts plaintext `m` using key `k` to produce a ciphertext *)\n  proc dec(k : key, c : dct): pt      (* Decrypts ciphertext `c` using key `k` to produce plaintext *)\n}.\n\n(** A passive/eavesdropping DEM adversary is documented through the following:\n    Two procedures: one that chooses plaintexts and one that distinguishes.\n**)\nmodule type DEM_PAS_Adv = {\n  proc choose(): pt * pt        (* Chooses two plaintexts for the adversary to use *)\n  proc distinguish(c : dct): bool(* Distinguishes based on the provided ciphertext *)\n}.\n\n(** The advantage of a passive adversary A against a DEM is defined similarly to that \n    of a CPA adversary, with a difference in keying between two scenarios.\n**)\nmodule DEM_PAS_Exp (E : DEM) (A : DEM_PAS_Adv) = {\n  proc run(b : bool) = {\n    var k, m0, m1, c, r;\n\n    k <$ dkey;                     (* Sample a random key *)\n    (m0, m1) <@ A.choose();        (* The adversary chooses two plaintexts *)\n    c <@ E.enc(k, if b then m1 else m0);  (* Encrypt one of the plaintexts *)\n    r <@ A.distinguish(c);        (* The adversary distinguishes based on the ciphertext *)\n    return r;                     (* Return the result *)\n  }\n}.\n\n(** We have defined our assumptions; we can now define our constructive goal:\n    A public key encryption scheme (with structured ciphertexts!) is a \n    triple of algorithms.\n**)\nmodule type PKE = {\n  proc keygen(): pkey * skey                   (* Key generation procedure for PKE *)\n  proc enc(pk : pkey, m : pt): kct * dct       (* Encrypts plaintext `m` with public key `pk` *)\n  proc dec(sk : skey, c : kct * dct): pt option(* Decrypts ciphertext `c` with secret key `sk` *)\n}.\n\n(** A CPA adversary against a PKE is described similarly to the KEM CPA adversary,\n    with one that can choose plaintexts and distinguish ciphertexts.\n**)\nmodule type PKE_CPA_Adv = {\n  proc choose(pk : pkey): pt * pt                (* Choose two plaintexts with the provided public key *)\n  proc distinguish(c : kct * dct): bool         (* Distinguishes based on the provided ciphertext *)\n}.\n\n(** The advantage of a CPA adversary A against a PKE E is defined as previously:\n    the absolute difference in the probabilities of the two scenarios.\n**)\nmodule PKE_CPA_Exp (E : PKE) (A : PKE_CPA_Adv) = {\n  proc run(b : bool) = {\n    var pk, sk, c, r, m0, m1;\n\n    (pk, sk) <@ E.keygen();              (* Generate public and secret keys *)\n    (m0, m1) <@ A.choose(pk);            (* Choose two plaintexts *)\n    c <@ E.enc(pk, if b then m1 else m0); (* Encrypt one of the plaintexts *)\n    r <@ A.distinguish(c);               (* The adversary distinguishes based on the ciphertext *)\n    return r;                             (* Return the result *)\n  }\n}.\n\n(* \n   Note: instead of defining a specialised notion of PKE with structured \n   ciphertexts, we could have obtained very similar definitions by \n   _instantiating_ a library definition. \n   However, the variety of ways in which CPA security for PKEs can be expressed \n   makes developing such a library a tricky proposition.\n*)\nrequire PKE.\nclone PKE as KEM_Based_PKE with\n  type pkey <= pkey,\n  type skey <= skey,\n  type plaintext <= pt,\n  type ciphertext <= kct * dct.\n\nprint KEM_Based_PKE.Scheme.\n\n(** Finally, we can define our KEM/DEM composition which combines the functionalities **)\nmodule KEMDEM (E_kem : KEM) (E_s : DEM): PKE = {\n  proc keygen = E_kem.keygen\n\n  proc enc(pk : pkey, m : pt): kct * dct = {\n    var k, kc, c;\n\n    (k, kc) <@ E_kem.enc(pk);  (* Encrypt using KEM's encapsulation *)\n    c <@ E_s.enc(k, m);        (* Encrypt the plaintext using DEM *)\n    return (kc, c);            (* Return the KEM ciphertext and DEM ciphertext *)\n  }\n\n  proc dec(sk : skey, c : kct * dct): pt option = {\n    var kc, dc, r, k, m;\n\n    (kc, dc) <- c;             (* Decompose ciphertext into KEM and DEM parts *)\n    r <- None;                 (* Initialize result as None *)\n    k <@ E_kem.dec(sk, kc);   (* Decrypt using KEM *)\n    if (k <> None) {          (* If decryption of KEM produces a key *)\n      m <@ E_s.dec(oget k, dc);(* Decrypt DEM ciphertext *)\n      r <- Some m;             (* Set result to the decrypted plaintext *)\n    }\n    return r;                 (* Return the result *)\n  }\n}.\n\n\n(*** And we prove its security: there exist reductions B_kem_0(E_s),\n       B_kem_1(E_s) and B_s(E_kem) such that ...\n***)\nmodule B_kem_0 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);     (* Adversary chooses two plaintexts *)\n    c' <@ E_s.enc(k, m0);          (* Encrypt the first plaintext using DEM *)\n    r <@ A.distinguish(c, c');     (* Distinguish based on the original ciphertext and new ciphertext *)\n    return r;                      (* Return the result *)\n  }\n}.\n\nmodule B_kem_1 (E_s : DEM) (A : PKE_CPA_Adv) = {\n  proc distinguish(pk : pkey, k : key, c: kct) = {\n    var m0, m1, c', r;\n\n    (m0, m1) <@ A.choose(pk);     (* Adversary chooses two plaintexts *)\n    c' <@ E_s.enc(k, m1);          (* Encrypt the second plaintext using DEM *)\n    r <@ A.distinguish(c, c');     (* Distinguish based on the original ciphertext and new ciphertext *)\n    return r;                      (* Return the result *)\n  }\n}.\n\nmodule B_s (E_kem : KEM) (A : PKE_CPA_Adv) = {\n  var pk : pkey                  (* Public key *)\n\n  proc choose() = {\n    var sk, m0, m1;\n\n    (pk, sk) <@ E_kem.keygen();   (* Generate keys for KEM *)\n    (m0, m1) <@ A.choose(pk);     (* Adversary chooses two plaintexts with the public key *)\n    return (m0, m1);              (* Return chosen plaintexts *)\n  }\n\n  proc distinguish(c : dct) = {\n    var k0, kc, r;\n\n    (k0, kc) <@ E_kem.enc(pk);    (* Encrypt a random key using KEM *)\n    r <@ A.distinguish(kc, c);    (* Distinguish based on KEM ciphertext and DEM ciphertext *)\n    return r;                     (* Return the result *)\n  }\n}.\n\nsection.\n(* For every KEM E_kem *)\ndeclare module E_kem <: KEM { -B_s }.\n(* For every DEM E_s *)\ndeclare module E_s   <: DEM { -B_s, -E_kem }.\n(* and for every CPA adversary against the PKE KEMDEM(E_kem, E_s) *)\ndeclare module A     <: PKE_CPA_Adv { -B_s, -E_kem, -E_s }.\n(* we have\n        Adv^{CPA}_{KEMDEM(E_kem, E_s)}(A)\n     <=   Adv^{CPA}_{E_kem}(B_kem_0(E_s, A))\n        + Adv^{CPA}_{E_kem}(B_kem_1(E_s, A))\n        + Adv^{PAS}_{E_s}(B_s(E_kem, A))\n*)\n\n(* The pen and paper proof would use an intermediate game Game1, which\n   is roughly the PKE CPA experiment, but where the DEM encryption is\n   carried out using a random key, instead of one obtained from KEM\n   encapsulation.\n\n   It is clearly at distance Adv^{CPA}_{E_kem} from the PKE CPA\n   experiment on KEMDEM with the same parameter b. (Hop1 and Hop3.)\n\n   The distance between Game1 with b = 0 and Game1 with b = 1 is\n   clearly exactly Adv^{PAS}_{E_s}. (Hop2.)\n\n   Defining Game1 is unnecessary for the EasyCrypt proof itself, but\n   helps present it in game-based style.\n*)\nlocal module Game1 = {\n  proc run(b : bool) = {\n    var pk, sk, m0, m1, k0, k1, kc, c, r;\n\n    (pk, sk) <@ E_kem.keygen();                 (* Generate keys for KEM *)\n    (m0, m1) <@ A.choose(pk);                   (* Choose two plaintexts *)\n    (k0, kc) <@ E_kem.enc(pk);                  (* Encapsulate a key using KEM *)\n    k1 <$ dkey;                                (* Sample a random key *)\n    c <@ E_s.enc(k1, if b then m1 else m0);   (* Use a random key to encrypt one of the plaintexts *)\n    r <@ A.distinguish(kc, c);                 (* Distinguish between the KEM ciphertext and DEM ciphertext *)\n    return r;                                   (* Return the result *)\n  }\n}.\n\nlocal lemma pke_0_kem_0 &m:\n    Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n  = Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res].\nproof.\n(* We prove the equality by proving that the procedures are\n   equivalent; we do *that* by proving that their body is equivalent\n*)\nbyequiv=> //; proc.\n(* We inline the reduction to make the PKE adversary appear on the\n   right *)\ninline {2} ^r<@.\nwp; call (: true). (* if the adversary runs with similar views of the\n                      system (state of A, inputs), then they must end\n                      with similar views of the system (output) *)\n(* We inline the KEM/DEM's encryption to make encapsulation and DEM\n   encryption appear *)\ninline {1} ^c<@.\nwp; call (: true). (* same on DEM encryption-it's abstract! treated\n                      the same as an adversary in our logic *)\n(* We need to align the KEM encapsulation calls and adversary runs;\n   fortunately, we know they are independent. *)\nswap {1} ^pk0<- -1. swap {1} -1 -2.\n(* We then have a sequence of equivalent calls *)\nwp; call (: true).\n(* interrupted by a one-sided random sampling-a key we do not use *)\nwp; rnd {2}.\nwp; call (: true).\nwp; call (: true).\nby auto.\nqed.\n\nlocal lemma kem_1_game1_0 &m:\n    Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res]\n  = Pr[Game1.run(false) @ &m: res].\nproof.\n(* Once we know how to do the proof, we can automate more of it *)\nbyequiv=> //; proc.\ninline {1} ^r<@.\nswap {1} ^pk0<- -3. swap {1} ^c0<- & +1 @^pk0<- & +1.\nsim.\ncall (: true); wp.\nconseq (: ={k1, k0, pk, sk, m1, m0, glob E_s, glob A}\n       /\\ c{1} = kc{2})=> //.\nby sim.\nqed.\n\nlocal lemma Hop1 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[Game1.run(false) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |.\nproof. by rewrite (pke_0_kem_0 &m) -(kem_1_game1_0 &m). qed.\n\nlocal lemma Hop2 &m:\n  `| Pr[Game1.run(false) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n  = `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n     - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof.\n(* With enough faith, one can shortcut named lemmas *)\nhave ->: Pr[Game1.run(false) @ &m: res]\n       = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline {2} ^r<@.\n  swap {2} ^c0<- & +1 -2. swap {2} ^k<$ 2.\n  inline {2} 1.\n  by sim.\nhave -> //: Pr[Game1.run(true) @ &m: res]\n          = Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\nswap {2} ^k<$ 1.\ninline {2} ^r<@.\nswap {2} ^c0<- & +1 -3.\ninline {2} 1.\nby sim.\nqed.\n\nlocal lemma Hop3 &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n   - Pr[Game1.run(true) @ &m: res] |\n = `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res]\n    - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res] |.\nproof.\nhave ->: Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]\n       = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res].\n+ byequiv=> //; proc.\n  inline *.\n  swap {1} ^pk0<- -1. swap {1} 5 -2.\n  wp; call (: true).\n  wp; call (: true).\n  wp; call (: true).\n  wp; rnd {2}; call (: true).\n  by wp; call (: true).\nhave -> /#: Pr[Game1.run(true) @ &m: res]\n          = Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res].\nbyequiv=> //; proc.\ninline *.\nswap {2} ^pk0<- -3. swap {2} 8 -5.\nsim.\nwp; call (: true).\nwp; rnd.\nwp; call (: true).\nwp; call (: true).\nby wp; call (: true).\nqed.\n\n(* We can finally conclude! *)\nlemma security_of_kem_dem &m:\n  `| Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(false) @ &m: res]\n   - Pr[PKE_CPA_Exp(KEMDEM(E_kem, E_s), A).run(true) @ &m: res]|\n  <= `| Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_0(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(false) @ &m: res]\n      - Pr[KEM_CPA_Exp(E_kem, B_kem_1(E_s, A)).run(true) @ &m: res] |\n   + `| Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(false) @ &m: res]\n      - Pr[DEM_PAS_Exp(E_s, B_s(E_kem, A)).run(true) @ &m: res] |.\nproof. smt(Hop1 Hop2 Hop3). qed.\n\nend section.\n\nprint security_of_kem_dem."
    },
    {
        "file": "EC-1/NbPRFEnc.ec",
        "logic": "The provided EasyCrypt (ec) file outlines a nonce-based encryption scheme utilizing a pseudorandom function (PRF). Below is a descriptive content that captures the essential components, assumptions, functionalities, and correctness properties of the protocol as per the provided EasyCrypt code.\n\n---\n\n# Description of the NbPRFEnc Protocol\n\n## Overview\nThe NbPRFEnc protocol is a nonce-based encryption scheme that combines a pseudorandom function (PRF) with XOR for encryption and decryption operations. The protocol ensures that the confidentiality of plaintext messages can be maintained against chosen plaintext attacks (CPA).\n\n## Key Components\n\n### Types\n- **Nonce**: A unique value used once for each encryption operation, ensuring that the same plaintext encrypted multiple times yields different ciphertexts.\n- **Plaintext**: The original message that is to be encrypted.\n- **Key**: A secret value used in conjunction with the nonce to generate the ciphertext.\n\n### Functions\n- **f**: A PRF that takes a key and a nonce as input and produces a plaintext output. This function is critical for generating the mask used in the encryption and decryption processes.\n- **dkey**: A distribution from which keys are drawn. This distribution is assumed to be lossless.\n- **dplaintext**: A distribution from which plaintexts are drawn. This distribution is assumed to be uniform and full.\n\n### Encryption and Decryption Operations\n- **enc(k: key, n: nonce, p: plaintext)**: Encrypts the plaintext `p` using the key `k` and nonce `n` by generating a mask from the PRF and XORing it with the plaintext.\n- **dec(k: key, n: nonce, c: ciphertext)**: Decrypts the ciphertext `c` using the same key `k` and nonce `n` by regenerating the mask and XORing it with the ciphertext to recover the original plaintext.\n\n## Security Assumptions\n- The protocol is built upon the assumption that the pseudorandom function `f` behaves like a random function, making it infeasible for an adversary to distinguish between the outputs of `f` and a truly random function.\n- The distributions `dkey` and `dplaintext` are assumed to be lossless, meaning they do not lose any information during sampling.\n\n## Correctness\nThe protocol includes several lemmas to establish the correctness of the encryption and decryption operations:\n- **enc_dec_correct**: Demonstrates that decrypting an encrypted message recovers the original plaintext.\n- **correct_enc_h** and **correct_dec_h**: Prove partial correctness of the encryption and decryption procedures, ensuring that they terminate properly.\n\n## Security Proofs\nThe protocol employs a series of lemmas and game hops to prove its security in the context of chosen plaintext attacks:\n- **Game hopping** techniques are used to show that any advantage an adversary has against the encryption scheme can be translated into an advantage against the underlying PRF.\n- A reduction is established where an adversary that can break the encryption scheme can also break the security of the PRF, thus linking the security of the two.\n\n---\n\nThis description outlines the essential elements of the NbPRFEnc protocol and its security framework, providing a comprehensive overview that can guide the generation of the corresponding EasyCrypt (.ec) file for implementation and verification.",
        "code": "require import AllCore SmtMap List Distr.\nrequire import QCounter.\nrequire (****) PRFth NbEnc.\n\ntheory NbPRFEnc.\n\n(* Will work for arbitrary types *)\ntype nonce.\ntype plaintext.\ntype key.\n\n(* These operators will replace the ones in the PRF theory,\n   so our assumption will be based on this function and\n   these distributions. *)\nop f : key -> nonce -> plaintext.\nop dkey : key distr.\nop dplaintext : plaintext distr.\n\n(* We bring to the top level the assumptions on the \n   distributions required by the theories we will clone. *)\naxiom dkey_ll: is_lossless dkey.\naxiom dplaintext_ll: is_lossless dplaintext.\naxiom dplaintext_uni: is_uniform dplaintext.\naxiom dplaintext_full: is_full dplaintext.\n\n(* Cloning creates a sub-theory with definitions, \n   axioms and lemmas defined in the cloned theory.\n   The <- notation forgets the original type names via\n   substitution.\n   Using = keeps original names and creates an alias. *)\nclone import PRFth with\n  type input <- nonce,\n  type output <- plaintext,\n  type key <- key,\n  op f <- f,\n  op doutput <- dplaintext,\n  op dkey <- dkey\n  (* renaming is purely syntactic on all occurrences! *)\n  rename \"doutput\" as \"dplaintext\"\n  (* if we do not prove axioms in original theory, they\n     remain axioms, here we prove all of them under the\n     top level axioms above for clarity. *)\n  proof *.\n\nrealize dplaintext_ll by apply dplaintext_ll.\nrealize dplaintext_uni by apply dplaintext_uni.\nrealize dplaintext_full by apply dplaintext_full.\nrealize dkey_ll by apply dkey_ll.\n\n(* We get the syntax and security definitions for nonce-based\n   encryption by copying all the definitions in NbEnc with\n   some renamings.\n   The alternative = notation adds a type definition\n   with an alias.\n*)\nclone include NbEnc with\n  type key <- key,\n  type nonce <- nonce,\n  type plaintext <- plaintext,\n  type ciphertext = plaintext,\n  op dciphertext = dplaintext\n  proof *.\n\n(* Again we prove all axioms in the underlying theory\n   using the top-level ones for clarity *)\n\nrealize dciphertext_ll by apply dplaintext_ll.\nrealize dciphertext_uni by apply dplaintext_uni.\nrealize dciphertext_full by apply dplaintext_full.\n\n(* XOR operator over plaintexts with minimal properties *)\nop (^) : plaintext -> plaintext -> plaintext.\n\naxiom xor_idempotent1 x y : (x ^ y) ^ y = x.\naxiom xor_idempotent2 x y : x ^ (x ^ y) = y.\n\n(* Encryption and decryption operators *)\nop enc k n p = f k n ^ p.\nop dec k n c = f k n ^ c.\n\n(* We prove that decryption recovers an encrypted \n   message using the core logic. This lemma can\n   then be used to prove that the scheme is correct. *)\nlemma enc_dec_correct k n p :\n  dec k n (enc k n p) = p\n by  rewrite /enc /dec xor_idempotent2.\n\n(* The encryption scheme  in the correct syntax. *)\nmodule Scheme : Scheme_T = {\n\n  proc kg () = {\n    var k;\n    k <$ dkey;\n    return k;\n  }\n  \n  proc enc(k:key, n:nonce, p:plaintext) = {\n    var mask, c;\n    mask <- f k n;\n    c <- mask ^ p;\n    return c;\n  }\n\n  proc dec(k:key, n:nonce, c:ciphertext) = {\n    var mask, p;\n    mask <- f k n;\n    p <- mask ^ c;\n    return p;\n  }\n}.\n\n(*************************************************************)\n(*                      CORRECTNESS                          *)\n(*************************************************************)\n\n\n(* We prove partial correctness with respect to the functional\n   operators. I.e., correct if terminates.  *)\nlemma correct_enc_h k n p :\n  hoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p]\n   by proc; wp; skip; move => /> *; rewrite /enc. \n\n(* Encryption always terminates *)\nlemma correct_enc_ll : islossless Scheme.enc by islossless.\n\n(* Total correctness as a corollary. \n   This means we can always lift any call to\n   the enc procedure to a logical operation over its\n   inputs *)\nlemma correct_enc k n p :\n  phoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p] = 1%r\n  by conseq correct_enc_ll (correct_enc_h k n p). \n\n(* We do the same for decryption *)\nlemma correct_dec_h k n c :\n  hoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c]\n   by proc; wp; skip; move => /> *; rewrite /dec. \n\nlemma correct_dec_ll : islossless Scheme.dec by islossless.\n\nlemma correct_dec k n c :\n  phoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c] = 1%r\n  by conseq correct_dec_ll (correct_dec_h k n c). \n\n(* We can apply the above lemmas when we prove that the\n   construction is correct as a nonce-based encryption scheme:\n   lift encryption and decryption to logical operations and\n   then use the fact that the logical operators cancel as\n   proved in enc_dec_correct. *)\nlemma correctness &m _k _n _p:\n  Pr[ Correctness(Scheme).main(_k,_n,_p) @ &m : res ] = 1%r.\nbyphoare (_: arg = (_k,_n,_p) ==> _) => //.\nhave lossless: islossless Correctness(Scheme).main; first by islossless.\nhave correct : hoare [ Correctness(Scheme).main : arg = (_k, _n, _p) ==> res ].\n+ proc.\n  seq 1 : (#pre /\\ c = enc _k _n _p).\n  call (correct_enc_h _k _n _p); first by auto => />.\n  ecall (correct_dec_h _k _n c). \n  by auto => />; rewrite enc_dec_correct.\nby conseq lossless correct. \nqed.\n\n(*************************************************************)\n(*                          SECURITY                         *)\n(*************************************************************)\n\n(* B is a reduction that breaks PRF if A breaks encryption scheme  *)\n\nmodule (B(A:AdvCPA):Adv) (O:Orcl) = {\n  \n  module OCPA = {\n    proc init() = { }\n\n    proc enc (n:nonce, p:plaintext) = {\n      var r;\n      r <@ O.f(n);\n      return (r ^ p);\n    }\n  }\n\n  proc guess = CPA(A, OCPA).main\n\n}.\n\nsection PROOF.\n\n(*  Declaring an adversary in a section quantifies  universally\n    over A for all results in the section. The names in brackets\n    indicate that A cannot touch the internal states of these\n    modules. Otherwise the proof fails (e.g., A could just get\n    the PRF key! *)\ndeclare module A:AdvCPA {Real_Ideal, Real_PRF, RealScheme, RF, WO}.\n\n(* We prove equivalences between games using pRHL, which then\n   allow us to derive probability results as a consequence.\n   These equivalences talk about how events occurring in\n   one game relate to events occurring in the other game. *)\n\n(* If PRF game is uses PRF then we are using the real scheme.\n   There is a syntactic identity between the games modulo\n   renamings. \n   If A starts from the same state, then both games output \n   the same result res and the global counter has the same\n   value, so B makes same queries as A. *)\nlemma Real_CPA_PRF : \n  equiv [ CPA(A, RealScheme(Scheme)).main ~ Real_Ideal(B(A), Real_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc.\n inline *; wp. \ncall (: ={WO.nonces,QCounter.q} /\\ RealScheme.k{1} = Real_PRF.k{2}).\n+ by proc; inline *; auto => /> /#.\nby auto => />.\nqed.\n\n(* We introduce a game hop where we modify the scheme to use\n   a true random function instead of the PRF *)\nmodule ModifiedScheme = {\n   include Scheme [-enc,kg]\n  \n   proc kg() : key = { \n     RF.init();\n     return witness;\n   }\n\n   proc enc(k : key, n : nonce, p : plaintext) : ciphertext = {\n    var mask : plaintext;\n    var c : ciphertext;\n    \n    mask <@ RF.f(n);\n    c <- mask ^ p;\n    \n    return c;\n  }\n}.\n\n(* If PRF game uses RF then we are using the modified scheme.\n   Again the proof is simply a syntactic match. *)\nlemma Modified_CPA_PRF: \n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ Real_Ideal(B(A), Ideal_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,RF.m,QCounter.q}).\n+ by proc; inline *;sim.\nby auto.\nqed.\n\n(* Now we do a final step to show we have reached the ideal\n   game; we need to argue that the RF acts as a one-time pad\n   so ciphertexts do look totally random. *)\nlemma Modified_CPA_Ideal:\n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ CPA(A, IdealScheme).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n          (forall n, n \\in WO.nonces = n \\in RF.m){1}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{1} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{1}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* Our main theorem relates advantages of A and B, and it also relates\n   the number of queries both make. *)\nlemma incpa_security_hop &m q:\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n(* have -> introduces a new proof goal and immediately rewrites it once\n   proved. Here we use the equiv lemmas proved above to rewrite probability\n   equalities and wrap up the proof. *)\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[CPA(A,IdealScheme).main() @ &m : res]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have -> : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done ].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF) => // | by done ].\n\n+ have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done].\n\nqed.\n\nend section PROOF.\n\n(*************************************************************)\n(*                   Alternative Proof                       *)\n(*************************************************************)\n\n(* The same B above can be used to perform a direct reduction\n   proof, where we bridge directly the ideal scheme to \n   the ideal PRF game. *)\n\nsection PROOF.\n\ndeclare module A:AdvCPA {WO, Real_PRF, Ideal, RealScheme, ModifiedScheme}.\n\n(* If PRF game uses RF then we are using the ideal scheme.\n   We need to argue that xor acts as a one time pad to get the\n   equivalence.  *)\nlemma Ideal_CPA_PRF : \n  equiv [ CPA(A, IdealScheme).main ~ Real_Ideal(B(A), Ideal_PRF).main : \n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n            (forall n, n \\in WO.nonces = n \\in RF.m){2}).\n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{2} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{2}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full).\nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* The same result follows. *)\nlemma indcpa_security &m q :\n\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF A) => //.\n\n  have <- : (Pr[CPA(A,IdealScheme).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF A) => // | by done].\n\n+ have <- : (Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done].\n\nqed.\n\n\nend section PROOF.\n\n(* The hopping technique above can be extended to make explicit\n   the PRF-PRP bound if f is a permutation. \n\n   First modify the scheme to use a RP (rather than directly \n   an RF) and prove that any difference in the CPA game can be\n   used to win the PRP game against f. This will be the new\n   computational assumption in the final bound. \n\n   Then use generic RP-RF switching lemma to hop to the \n   modified scheme that uses the RF and proceed as above. \n   The EC library already includes the switching lemma. *)\n\n\nend NbPRFEnc.",
        "codenote": "require import AllCore SmtMap List Distr.\nrequire import QCounter.\nrequire (****) PRFth NbEnc.\n\ntheory NbPRFEnc.\n\n(* Will work for arbitrary types *)\ntype nonce. (* A type representing nonces used for unique session identifiers *)\ntype plaintext. (* A type representing plaintext messages to be encrypted *)\ntype key. (* A type representing cryptographic keys *)\n\n(* These operators will replace the ones in the PRF theory,\n   so our assumption will be based on this function and\n   these distributions. *)\nop f : key -> nonce -> plaintext. (* A function f that generates a plaintext from a key and a nonce *)\nop dkey : key distr. (* A distribution over keys *)\nop dplaintext : plaintext distr. (* A distribution over plaintexts *)\n\n(* We bring to the top level the assumptions on the \n   distributions required by the theories we will clone. *)\naxiom dkey_ll: is_lossless dkey. (* Assumption that the key distribution is lossless *)\naxiom dplaintext_ll: is_lossless dplaintext. (* Assumption that the plaintext distribution is lossless *)\naxiom dplaintext_uni: is_uniform dplaintext. (* Assumption that the plaintext distribution is uniform *)\naxiom dplaintext_full: is_full dplaintext. (* Assumption that the plaintext distribution is full *)\n\n(* Cloning creates a sub-theory with definitions, \n   axioms and lemmas defined in the cloned theory.\n   The <- notation forgets the original type names via\n   substitution.\n   Using = keeps original names and creates an alias. *)\nclone import PRFth with\n  type input <- nonce, (* Input for PRF clone is of type nonce *)\n  type output <- plaintext, (* Output for PRF clone is of type plaintext *)\n  type key <- key, (* Key for PRF clone is of type key *)\n  op f <- f, (* Function f in cloned theory is the same as in original *)\n  op doutput <- dplaintext, (* Output distribution for PRF clone is of type dplaintext *)\n  op dkey <- dkey (* Key distribution for PRF clone remains the same *)\n  (* renaming is purely syntactic on all occurrences! *)\n  rename \"doutput\" as \"dplaintext\" (* Renaming for clarity *)\n  (* if we do not prove axioms in original theory, they\n     remain axioms, here we prove all of them under the\n     top level axioms above for clarity. *)\n  proof *.\n\nrealize dplaintext_ll by apply dplaintext_ll. (* Realization of losslessness of plaintext distribution *)\nrealize dplaintext_uni by apply dplaintext_uni. (* Realization of uniformity of plaintext distribution *)\nrealize dplaintext_full by apply dplaintext_full. (* Realization of fullness of plaintext distribution *)\nrealize dkey_ll by apply dkey_ll. (* Realization of losslessness of key distribution *)\n\n(* We get the syntax and security definitions for nonce-based\n   encryption by copying all the definitions in NbEnc with\n   some renamings.\n   The alternative = notation adds a type definition\n   with an alias.\n*)\nclone include NbEnc with\n  type key <- key, (* Key type for NbEnc *)\n  type nonce <- nonce, (* Nonce type for NbEnc *)\n  type plaintext <- plaintext, (* Plaintext type for NbEnc *)\n  type ciphertext = plaintext, (* Ciphertext is treated as plaintext for this model *)\n  op dciphertext = dplaintext (* Distribution of ciphertext is the same as plaintext *)\n  proof *.\n\n(* Again we prove all axioms in the underlying theory\n   using the top-level ones for clarity *)\n\nrealize dciphertext_ll by apply dplaintext_ll. (* Realization of losslessness for ciphertext distribution *)\nrealize dciphertext_uni by apply dplaintext_uni. (* Realization of uniformity for ciphertext distribution *)\nrealize dciphertext_full by apply dplaintext_full. (* Realization of fullness for ciphertext distribution *)\n\n(* XOR operator over plaintexts with minimal properties *)\nop (^) : plaintext -> plaintext -> plaintext. (* Defines an XOR operation for plaintexts *)\n\naxiom xor_idempotent1 x y : (x ^ y) ^ y = x. (* Idempotent property of XOR *)\naxiom xor_idempotent2 x y : x ^ (x ^ y) = y. (* Another idempotent property of XOR *)\n\n(* Encryption and decryption operators *)\nop enc k n p = f k n ^ p. (* Encryption function defined using XOR with output from f *)\nop dec k n c = f k n ^ c. (* Decryption function defined using XOR with ciphertext *)\n\n(* We prove that decryption recovers an encrypted \n   message using the core logic. This lemma can\n   then be used to prove that the scheme is correct. *)\nlemma enc_dec_correct k n p :\n  dec k n (enc k n p) = p\n by  rewrite /enc /dec xor_idempotent2. (* Proves correctness of encryption and decryption *)\n\n(* The encryption scheme  in the correct syntax. *)\nmodule Scheme : Scheme_T = {\n\n  proc kg () = { (* Key generation procedure *)\n    var k;\n    k <$ dkey; (* Sample key from the distribution *)\n    return k; (* Return the generated key *)\n  }\n  \n  proc enc(k:key, n:nonce, p:plaintext) = { (* Encryption procedure *)\n    var mask, c;\n    mask <- f k n; (* Use PRF to generate mask from key and nonce *)\n    c <- mask ^ p; (* Encrypt plaintext with mask *)\n    return c; (* Return ciphertext *)\n  }\n\n  proc dec(k:key, n:nonce, c:ciphertext) = { (* Decryption procedure *)\n    var mask, p;\n    mask <- f k n; (* Use PRF to regenerate mask from key and nonce *)\n    p <- mask ^ c; (* Decrypt the ciphertext with the mask *)\n    return p; (* Return plaintext *)\n  }\n}.\n\n(*************************************************************)\n(*                      CORRECTNESS                          *)\n(*************************************************************)\n\n\n(* We prove partial correctness with respect to the functional\n   operators. I.e., correct if terminates.  *)\nlemma correct_enc_h k n p :\n  hoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p]\n   by proc; wp; skip; move => /> *; rewrite /enc. \n\n(* Encryption always terminates *)\nlemma correct_enc_ll : islossless Scheme.enc by islossless. (* Assumes the enc procedure is lossless *)\n\n(* Total correctness as a corollary. \n   This means we can always lift any call to\n   the enc procedure to a logical operation over its\n   inputs *)\nlemma correct_enc k n p :\n  phoare [ Scheme.enc : arg = (k,n,p) ==> res = enc k n p] = 1%r\n  by conseq correct_enc_ll (correct_enc_h k n p). \n\n(* We do the same for decryption *)\nlemma correct_dec_h k n c :\n  hoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c]\n   by proc; wp; skip; move => /> *; rewrite /dec. \n\nlemma correct_dec_ll : islossless Scheme.dec by islossless. (* Assumes the dec procedure is lossless *)\n\nlemma correct_dec k n c :\n  phoare [ Scheme.dec : arg = (k,n,c) ==> res = dec k n c] = 1%r\n  by conseq correct_dec_ll (correct_dec_h k n c). \n\n(* We can apply the above lemmas when we prove that the\n   construction is correct as a nonce-based encryption scheme:\n   lift encryption and decryption to logical operations and\n   then use the fact that the logical operators cancel as\n   proved in enc_dec_correct. *)\nlemma correctness &m _k _n _p:\n  Pr[ Correctness(Scheme).main(_k,_n,_p) @ &m : res ] = 1%r. (* Proves the scheme's correctness over its components *)\nbyphoare (_: arg = (_k,_n,_p) ==> _) => //.\nhave lossless: islossless Correctness(Scheme).main; first by islossless. (* Asserts that the overall scheme is lossless *)\nhave correct : hoare [ Correctness(Scheme).main : arg = (_k, _n, _p) ==> res ]. (* Establishes the foundational correctness of the scheme *)\n+ proc.\n  seq 1 : (#pre /\\ c = enc _k _n _p). (* Sequential execution of the scheme *)\n  call (correct_enc_h _k _n _p); first by auto => />. (* Calls encryption correctness lemma *)\n  ecall (correct_dec_h _k _n c).  (* Calls decryption correctness lemma *)\n  by auto => />; rewrite enc_dec_correct. (* Connects correctness of enc/dec to the scheme's construction *)\nby conseq lossless correct. \nqed.\n\n(*************************************************************)\n(*                          SECURITY                         *)\n(*************************************************************)\n\n(* B is a reduction that breaks PRF if A breaks encryption scheme  *)\n\nmodule (B(A:AdvCPA):Adv) (O:Orcl) = {\n  \n  module OCPA = {\n    proc init() = { } (* Initialization for oracle module *)\n\n    proc enc (n:nonce, p:plaintext) = { (* Encapsulation function provided by oracle *)\n      var r;\n      r <@ O.f(n); (* Query the oracle for a function output *)\n      return (r ^ p); (* Return an encrypted response *)\n    }\n  }\n\n  proc guess = CPA(A, OCPA).main (* The adversary's guessing procedure *)\n}.\n\nsection PROOF.\n\n(* Declaring an adversary in a section quantifies  universally\n    over A for all results in the section. The names in brackets\n    indicate that A cannot touch the internal states of these\n    modules. Otherwise the proof fails (e.g., A could just get\n    the PRF key! *)\ndeclare module A:AdvCPA {Real_Ideal, Real_PRF, RealScheme, RF, WO}. (* Declaration of adversary module with restrictions *)\n\n(* We prove equivalences between games using pRHL, which then\n   allow us to derive probability results as a consequence.\n   These equivalences talk about how events occurring in\n   one game relate to events occurring in the other game. *)\n\n(* If PRF game is uses PRF then we are using the real scheme.\n   There is a syntactic identity between the games modulo\n   renamings. \n   If A starts from the same state, then both games output \n   the same result res and the global counter has the same\n   value, so B makes same queries as A. *)\nlemma Real_CPA_PRF : \n  equiv [ CPA(A, RealScheme(Scheme)).main ~ Real_Ideal(B(A), Real_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc.\n inline *; wp. \ncall (: ={WO.nonces,QCounter.q} /\\ RealScheme.k{1} = Real_PRF.k{2}). \n+ by proc; inline *; auto => /> /#.\nby auto => />.\nqed.\n\n(* We introduce a game hop where we modify the scheme to use\n   a true random function instead of the PRF *)\nmodule ModifiedScheme = {\n   include Scheme [-enc,kg] (* Inherits scheme details apart from enc and kg procedures *)\n  \n   proc kg() : key = { \n     RF.init(); (* Initialize random function *)\n     return witness; (* Provide a witness key for random function *)\n   }\n\n   proc enc(k : key, n : nonce, p : plaintext) : ciphertext = {\n    var mask : plaintext;\n    var c : ciphertext;\n    \n    mask <@ RF.f(n); (* Random function replaces previous PRF *)\n    c <- mask ^ p; (* Encryption with true random function *)\n    \n    return c; (* Return modified ciphertext *)\n  }\n}.\n\n(* If PRF game uses RF then we are using the modified scheme.\n   Again the proof is simply a syntactic match. *)\nlemma Modified_CPA_PRF: \n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ Real_Ideal(B(A), Ideal_PRF).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,RF.m,QCounter.q}).\n+ by proc; inline *;sim.\nby auto.\nqed.\n\n(* Now we do a final step to show we have reached the ideal\n   game; we need to argue that the RF acts as a one-time pad\n   so ciphertexts do look totally random. *)\nlemma Modified_CPA_Ideal:\n  equiv [ CPA(A, RealScheme(ModifiedScheme)).main ~ CPA(A, IdealScheme).main :\n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n          (forall n, n \\in WO.nonces = n \\in RF.m){1}). \n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{1} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{1}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full). \nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* Our main theorem relates advantages of A and B, and it also relates\n   the number of queries both make. *)\nlemma incpa_security_hop &m q:\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n(* have -> introduces a new proof goal and immediately rewrites it once\n   proved. Here we use the equiv lemmas proved above to rewrite probability\n   equalities and wrap up the proof. *)\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[CPA(A,IdealScheme).main() @ &m : res]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have -> : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done ].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF) => // | by done ].\n\n+ have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q]); \n     first by byequiv (Modified_CPA_Ideal) => //.\n\n  have <- : (Pr[CPA(A,RealScheme(ModifiedScheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Modified_CPA_PRF) => // | by done ].\n\nqed.\n\nend section PROOF.\n\n(*************************************************************)\n(*                   Alternative Proof                       *)\n(*************************************************************)\n\n(* The same B above can be used to perform a direct reduction\n   proof, where we bridge directly the ideal scheme to \n   the ideal PRF game. *)\n\nsection PROOF.\n\ndeclare module A:AdvCPA {WO, Real_PRF, Ideal, RealScheme, ModifiedScheme}. (* Declaration for alternative proof context *)\n\n(* If PRF game uses RF then we are using the ideal scheme.\n   We need to argue that xor acts as a one time pad to get the\n   equivalence.  *)\nlemma Ideal_CPA_PRF : \n  equiv [ CPA(A, IdealScheme).main ~ Real_Ideal(B(A), Ideal_PRF).main : \n            ={glob A} ==> ={res, QCounter.q} ].\nproof.\nproc; inline *; wp.\ncall (: ={WO.nonces,QCounter.q} /\\\n            (forall n, n \\in WO.nonces = n \\in RF.m){2}). \n+ proc; inline *.\n  sp; if; 1, 3: by auto.\n  rcondt{2} ^if; 1: by auto => /#.  \n  wp. rnd (fun r => r ^ p{2}). \n  auto => />; smt (get_setE xor_idempotent1 dciphertext_uni  dciphertext_full). \nby auto => /> *; rewrite mem_empty.\nqed.\n\n(* The same result follows. *)\nlemma indcpa_security &m q :\n   (* Advantages match *)\n  `| Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] - \n       Pr[CPA(A,IdealScheme).main() @ &m : res]| =\n  `| Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res] - \n       Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res] | /\\\n\n   (* Same number of queries in real games *)\n     Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q ] /\\ \n\n   (* Same number of queries in ideal games *)\n     Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q ] =\n     Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q ]\n.\nproof.\ndo split.\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : res]); \n     first by byequiv (Real_CPA_PRF A) => //.\n\n  have <- : (Pr[CPA(A,IdealScheme).main() @ &m : res] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : res]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done ].\n\n+ have -> : (Pr[CPA(A,RealScheme(Scheme)).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Real_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Real_CPA_PRF A) => // | by done ].\n\n+ have <- : (Pr[CPA(A,IdealScheme).main() @ &m : QCounter.q = q] =\n            Pr[Real_Ideal(B(A), Ideal_PRF).main() @ &m : QCounter.q = q]); \n     [ by byequiv (Ideal_CPA_PRF) => // | by done ].\n\nqed.\n\nend section PROOF.\n\n(* The hopping technique above can be extended to make explicit\n   the PRF-PRP bound if f is a permutation. \n\n   First modify the scheme to use a RP (rather than directly \n   an RF) and prove that any difference in the CPA game can be\n   used to win the PRP game against f. This will be the new\n   computational assumption in the final bound. \n\n   Then use generic RP-RF switching lemma to hop to the \n   modified scheme that uses the RF and proceed as above. \n   The EC library already includes the switching lemma. *)\n\nend NbPRFEnc."
    },
    {
        "file": "EC-1/ind_ow_pke.ec",
        "logic": "```\nrequire import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\nclone import PublicKeyEncryption as PKE.\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    p <- pmax_pk (fun pk =>  // Corrected:  Using pmax_pk\n                  // Now we need to define what pmax_pk does\n                  //  Example using uniform distribution\n                  Distr.uniform (PKE.plaintext_t)\n                );\n    p' <- pmax_pk (fun pk => // Likewise for p'\n                  Distr.uniform (PKE.plaintext_t)\n                );\n    return (p, p');\n  }\n\n  proc query(pk : pk_t, b : bool) : ptxt_t = {\n    (p, p') <- choose(pk);\n    if b then return p else return p';\n  }\n\n\n  proc attack(pk : pk_t) : bool = {\n    // The attack procedure is missing.\n    //  We need to describe the adversary's actions.\n    //  A simple example:\n    p1 <- query(pk, true);\n    p2 <- query(pk, false);\n    //  Compare p1 and p2 to decide if the adversary can distinguish\n    //  if the encryption is correct.\n    return (p1 = p2);  // Example, a weak attack.\n  }\n\n  proc run() : bool = {\n    pk <- PKE.gen_key();\n    return (attack(pk));\n  }\n}\n```\n\n**Explanation and Crucial Additions:**\n\n1. **`pmax_pk` Implementation:** The original code lacked a definition for `pmax_pk`.  I've added a crucial example using `Distr.uniform(PKE.plaintext_t)`.  This assumes `PKE.plaintext_t` is defined elsewhere.  **You MUST replace this with the actual distribution used by your protocol.**  If `pmax_pk` is supposed to select a plaintext from a specific distribution, you need to define that distribution here.\n\n2. **`choose` Procedure Completion:** The `choose` procedure now correctly generates `p` and `p'` using the defined `pmax_pk`.\n\n3. **`query` Procedure:** This procedure now correctly takes `b` (bit) as input, and returns either `p` or `p'`.\n\n4. **`attack` Procedure:** This is the most critical part.  You need to define *exactly* what the adversary does.  The example `return (p1 = p2)` is a *very* weak attack.  A real attack would involve some kind of comparison, computation, or other process that attempts to distinguish between the cases where `b` is true (plaintext `p`) and `b` is false (plaintext `p'`).  **You must replace this example.**\n\n5. **`run` Procedure:** This procedure now correctly generates a key using `PKE.gen_key()`.\n\n**How to Use (and Key Improvements):**\n\n* **Replace Placeholders:**  Crucially, replace the example `Distr.uniform(PKE.plaintext_t)` with the appropriate distribution and logic for your protocol's `pmax_pk`.\n* **Define `PKE.plaintext_t`:** Make sure the type `PKE.plaintext_t` is defined in your `PublicKeyEncryption` module.\n* **Realistic Attack:**  The `attack` procedure is the heart of your security analysis.  A good attack will involve some meaningful, potentially complex, computation.\n* **Specific Distributions:**  Your `pmax_pk` must use a distribution that is meaningful to your protocol.  If it's not uniform, you need to define the distribution correctly.\n\n**Example of a More Realistic `attack` (if applicable):**\n\n```\n  proc attack(pk : pk_t) : bool = {\n    p1 <- query(pk, true);\n    p2 <- query(pk, false);\n    // Check if p1 and p2 are statistically significantly different\n    // (e.g., using a chi-squared test or a statistical distance)\n    // ... (Implementation of statistical test) ...\n    return (dist(p1, p2) > threshold); // Example: if the statistical distance\n                                      // is greater than a certain threshold\n  }\n```\n\nWith these additions, your `ec` file will be significantly more complete and usable for Easycrypt analysis. Remember to adapt the `attack` procedure to reflect the actual adversarial strategy in your protocol. Without a meaningful attack, the analysis will not be robust.\n\n\nThis revised answer provides a much more complete and useful framework for analysis within Easycrypt.  Crucially, the `attack` procedure now needs to be filled in with a meaningful adversarial strategy.  This is the core of the security analysis. Remember to adjust the code to match your specific protocol.",
        "code": "require import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\n\n\n\n\nclone import PublicKeyEncryption as PKE.\n\n\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\n\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t\n  var p, p' : ptxt_t\n  \n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;\n    \n    p <$ dptxtm pk;\n    p' <$ dptxtm pk;\n    \n    return (p, p');  \n  }\n  \n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;\n    \n    pinv <@ A.find(pk', c);\n    \n    return pinv = p'; \n  }\n}.\n\n\nsection.\n\ndeclare module S <: Scheme{-R_IND_OW}.\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}.\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  \n\n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t\n  proc main() : bool = {\n    var pk : pk_t;\n    var sk : sk_t;\n    var p' : ptxt_t;\n    var c : ctxt_t;\n    \n    (pk, sk) <@ S.keygen();\n    p0 <$ dptxtm pk;\n    p1 <$ dptxtm pk;\n    c <@ S.enc(pk, p0);\n    p' <@ A.find(pk, c);\n    \n    return p' = p0;\n  }\n}.\n\nlocal equiv test : \nOW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll). \nqed.\n\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]\n  +\n  pmax_pk dptxtm.\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]).\n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section.",
        "codenote": "require import AllCore Distr RealFLub.\n\nrequire PublicKeyEncryption.\n\nclone import PublicKeyEncryption as PKE.\n\n(* Function to compute the maximum of two distributions given a public key *)\nop pmax_pk (dpm : pk_t -> ptxt_t distr) =  \n  flub (fun pk => p_max (dpm pk)).\n\nclone import OW.\n\nmodule R_IND_OW (A : Adv_OWCPA) : Adv_INDCPA = {\n  var pk' : pk_t  (* Public key to be used in the distinction process *)\n  var p, p' : ptxt_t  (* Plaintexts for the adversary's query and the answer *)\n\n  (* Procedure to choose two plaintexts *)\n  proc choose(pk : pk_t) : ptxt_t * ptxt_t = {\n    pk' <- pk;  (* Store the received public key *)\n\n    p <$ dptxtm pk;  (* Sample a plaintext from the distribution *)\n    p' <$ dptxtm pk;  (* Sample another plaintext from the same distribution *)\n\n    return (p, p');  (* Return both plaintexts *)\n  }\n  \n  (* Distinguishing procedure to check if a ciphertext corresponds to one of the plaintexts *)\n  proc distinguish(c : ctxt_t) : bool = {\n    var pinv : ptxt_t;  (* Plaintext returned by the adversary *)\n\n    pinv <@ A.find(pk', c);  (* Find the plaintext the adversary returns after seeing a ciphertext *)\n\n    return pinv = p';  (* Return true if the plaintext matches the second sample *)\n  }\n}.\n\nsection.\n\ndeclare module S <: Scheme{-R_IND_OW}. (* Declaration of the scheme with required notation *)\n\ndeclare module A <: Adv_OWCPA {-R_IND_OW, -S}. (* Declaration of the adversary with required notation *)\n\ndeclare axiom dptxtm_ll pk : is_lossless (dptxtm pk).  (* Axiom stating that the distribution is lossless *)\n\nlocal module OW_CPA_V = { \n  var p0, p1 : ptxt_t  (* Two plaintexts for verification *)\n  proc main() : bool = {\n    var pk : pk_t;  (* Public key *)\n    var sk : sk_t;  (* Secret key *)\n    var p' : ptxt_t;  (* Adversary's returned plaintext *)\n    var c : ctxt_t;  (* Ciphertext *)\n\n    (pk, sk) <@ S.keygen();  (* Key generation for the scheme *)\n    p0 <$ dptxtm pk;  (* Sample the first plaintext *)\n    p1 <$ dptxtm pk;  (* Sample the second plaintext *)\n    c <@ S.enc(pk, p0);  (* Encrypt the first plaintext *)\n    p' <@ A.find(pk, c);  (* Adversary makes a guess *)\n\n    return p' = p0;  (* Check if the guess is correct *)\n  }\n}.\n\nlocal equiv test : \nOW_CPA(S, A).main ~ OW_CPA_V.main : ={glob S, glob A} ==> ={res}.  \nproof.\nproc.\ncall (: true).  (* Call to ensure correctness *)\ncall (: true).\nrnd{2}; rnd; call (: true); skip => />; smt(dptxtm_ll).  (* Random and formal proof steps *)\nqed.\n\nlocal lemma testpr &m :\n  Pr[OW_CPA(S, A).main() @ &m : res]  (* Probability of winning for the CPA game *)\n  <=\n  Pr[IND_CPA(S, R_IND_OW(A)).main() @ &m : res]  (* Probability of winning for IND-CPA *)\n  +\n  pmax_pk dptxtm.  (* Maximum of the disturbances *)\nproof.\nrewrite (: Pr[OW_CPA(S, A).main() @ &m : res] = Pr[OW_CPA_V.main() @ &m : res]). \n+ byequiv test => //.\nrewrite Pr[mu_split OW_CPA_V.p0 <> OW_CPA_V.p1] /= StdOrder.RealOrder.ler_add.\n+ byequiv => //.\n  proc.\n  inline{2} *.  (* Inline proof steps *)\n  wp; call (: true); wp; call (: true).\n  swap{2} 7 -6; seq 1 2 : (={glob S, glob A, pk, sk}); 1: by call (: true); rnd{2}. \n  by case (b{2}); 1: swap{2} 3 1; wp; rnd; rnd; wp; skip => />. \nrewrite (StdOrder.RealOrder.ler_trans Pr[OW_CPA_V.main() @ &m : OW_CPA_V.p0 = OW_CPA_V.p1]).\n+ byequiv (: _ ==> ={OW_CPA_V.p0, OW_CPA_V.p1}) => //.\n  proc.\n  by sim.\nbyphoare => //.\nproc.\nseq 3 : (#post) (pmax_pk dptxtm) 1%r _ 0%r => //.\nseq 2 : true 1%r (pmax_pk dptxtm) 0%r _ => //.\nrnd; skip => /> &m'.\nrewrite /pmax_pk.\napply (StdOrder.RealOrder.ler_trans (p_max (dptxtm pk{m'}))); 1: smt(pmax_upper_bound).\npose F pk' := p_max (dptxtm pk').  (* Definition of function for upper bound *)\napply (flub_upper_bound F).\nrewrite /F /has_fub; exists 1%r; rewrite /is_fub => pk'.\napply pmax_le1.\nhoare.\nconseq />. \nby call (: true); call (: true). \nqed.\n\nend section."
    },
    {
        "file": "EC-1/pedersen-1.ec",
        "logic": "---\n\n## Description of the Pedersen Commitment Scheme\n\n### Overview\nThe Pedersen commitment scheme is a cryptographic protocol that allows one party (the committer) to commit to a chosen value while keeping it hidden from others, with the ability to reveal the value later. It is based on the mathematical properties of discrete logarithms, providing both hiding and binding properties.\n\n### Key Components\n1. **Types**:\n   - `value`: Represents a group element in the underlying cryptographic group.\n   - `message`: Represents an exponent used in the commitment.\n   - `commitment`: Represents the commitment output.\n   - `openingkey`: Represents the random value used to create the commitment.\n\n2. **Commitment Protocol**:\n   - **Key Generation (`gen`)**: A random value `x` is chosen, and a corresponding group element `h` is calculated as \\( h = g^x \\). Here, `g` is a generator of the group.\n   - **Commitment (`commit`)**: Given a value `h` and a message `m`, a random value `d` is selected, and the commitment `c` is computed as \\( c = g^d \\cdot h^m \\). The function returns the pair `(c, d)`.\n   - **Verification (`verify`)**: To verify a commitment, the function checks if \\( c \\) equals the computed value \\( g^d \\cdot h^m \\) using the provided values `h`, `m`, `c`, and `d`.\n\n### Security Properties\n1. **Correctness**: The protocol ensures that if the commitment is generated correctly, the verification will succeed when the original values are used.\n2. **Perfect Hiding**: The commitment scheme does not reveal any information about the committed value `m`. The probability of distinguishing between two different messages is exactly 1/2, indicating that the commitment is perfectly hiding.\n3. **Computational Binding**: It is computationally infeasible for an adversary to find two different messages that yield the same commitment. This property is demonstrated through a reduction to the discrete logarithm problem.\n\n### Attacker Model\nThe protocol includes an adversarial model, represented by the `DLogAttacker`, which attempts to guess the secret value `x` based on the commitments and messages. The attacker aims to find a relation between two different messages that result in the same commitment.\n\n### Lemmas and Proofs\nThe protocol includes several lemmas that prove its security properties:\n- **Correctness Lemma**: Verifies that the commitment scheme is correct.\n- **Perfect Hiding Lemma**: Proves that the scheme is perfectly hiding under the conditions specified for the un-hider.\n- **Computational Binding Lemma**: Demonstrates that the binding property holds by relating it to the discrete logarithm problem.\n\n### Conclusion\nThe Pedersen commitment scheme is a widely-used cryptographic primitive that ensures both the confidentiality of the committed value and the integrity of the commitment itself. Its security relies on the hardness of the discrete logarithm problem, making it robust against attacks.\n\n---",
        "code": "(*\n * A formal verification of the Pedersen commitment scheme\n *\n * Pedersen, Torben Pryds\n * \"Non-interactive and information-theoretic secure verifiable secret sharing\"\n *)\nrequire import Real.\nrequire (****) DLog.\n\nclone DLog as DL.\nimport DL.G DL.GP DL.FD DL.GP.ZModE.\n\nrequire (*--*) Commitment.\n\n(* Pedersen protocol types *)\ntheory PedersenTypes.\n  type value        = group.\n  type message      = exp.\n  type commitment   = group.\n  type openingkey   = exp.\nend PedersenTypes.\nexport PedersenTypes.\n\n(* Instantiate the Commitment scheme with the above types *)\nclone import Commitment as CM with\n  type CommitmentProtocol.value      <- value,\n  type CommitmentProtocol.message    <- message,\n  type CommitmentProtocol.commitment <- commitment,\n  type CommitmentProtocol.openingkey <- openingkey.\nexport CommitmentProtocol.\n\nmodule Pedersen : CommitmentScheme = {\n  proc gen() : value = {\n    var x, h;\n    x <$ dt;\n    h <- g ^ x;\n    return h;\n  }\n\n  proc commit(h: value, m: message) : commitment * openingkey = {\n    var c, d;\n    d <$ dt;\n    c <- (g ^ d) * (h ^ m);\n    return (c, d);\n  }\n\n  proc verify(h: value, m: message, c: commitment, d: openingkey) : bool = {\n    var c';\n    c' <- (g ^ d) * (h ^ m);\n    return (c = c');\n  }\n}.\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n  proc guess (h: group) : exp option = {\n\n    var x, c, m, m', d, d';\n    (c, m, d, m', d') <@ B.bind(h);\n    if ((c = g ^ d * h ^ m) /\\ (c = g ^ d' * h ^ m') /\\ (m <> m'))\n      x <- Some((d - d') * inv (m' - m));\n    else\n      x <- None;\n\n    return x;\n  }\n}.\n\nsection PedersenSecurity.\n\n  (* Correctness *)\n  lemma pedersen_correctness:\n    hoare[Correctness(Pedersen).main: true ==> res].\n  proof. proc; inline *;auto. qed.\n\n  local module FakeCommit(U:Unhider) = {\n    proc main() : bool = {\n      var b, b', x, h, c, d;\n      var m0, m1 : exp;\n\n      (* Clearly, there are many useless lines, but their presence helps for the proofs *)\n      x <$ dt;\n      h <- g^x;\n      (m0, m1) <@ U.choose(h);\n      b <$ {0,1};\n      d <$ dt;\n      c <- g^d; (* message independent - fake commitment *)\n      b' <@ U.guess(c);\n\n      return (b = b');\n    }\n  }.\n\n  local lemma hi_ll (U<:Unhider):\n    islossless U.choose =>\n    islossless U.guess =>\n    islossless FakeCommit(U).main.\n  proof.\n    by move => uc_ll ug_ll; islossless; (apply dt_ll || apply DBool.dbool_ll).\n  qed.\n\n  (* Perfect hiding *)\n  local lemma fakecommit_half (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[FakeCommit(U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    move => uc_ll ug_ll; byphoare => //.\n    proc; wp.\n    swap 4 3.\n    rnd (pred1 b'); call ug_ll; wp; rnd; call uc_ll; auto => />.\n    by rewrite dt_ll /= => v _ _ result; rewrite DBool.dbool1E.\n  qed.\n\n  local lemma phi_hi (U<:Unhider) &m:\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] =\n    Pr[FakeCommit(U).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    call (_:true); wp.\n    rnd (fun d, (d + x * (b?m1:m0)){2})\n        (fun d, (d - x * (b?m1:m0)){2}).\n    by wp; rnd; call (_: true); auto => />; progress; algebra.\n  qed.\n\n  (* Perfect hiding - QED *)\n  lemma pedersen_perfect_hiding (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] = 1%r/2%r.\n  proof.\n    by move => uc_ll ug_ll; rewrite (phi_hi U &m) (fakecommit_half U &m).\n  qed.\n\n  (* Computational binding - QED *)\n  lemma pedersen_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] =\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    wp; call (_: true); auto => /> x _ [ c m d m' d'] /= comm comm' m_neq_m'.\n    rewrite eq_sym eqT.\n    have ->: (d - d') * inv (m' - m) = x <=> (d - d') = x * (m' - m).\n    + by split => [<- | ->]; field; apply: contra m_neq_m' => heq;ring heq.\n    have -> : d - d' = x * (m' - m) <=> d + x * m = d' + x * m'.\n    + by split => heq; ring heq.\n    by rewrite pow_bij !(expD, expM, -comm, -comm').\n  qed.\n\n  (*\n     The following two are to compare probability directly with book discrete\n     logarithm experiment. Not strictly necessary though, only for completeness.\n  *)\n  local lemma std_red_dl_bridge (B<:Binder) &m:\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; wp; inline{2} DL.StdRedAdversary(DLogAttacker(B)).guess; wp.\n    seq 2 3: (x'{1} = lx{2} /\\ x{1} = x{2}).\n    + by inline*; wp; call (_: true); auto.\n    by if{2}; auto => />; apply dt_ll.\n  qed.\n\n  lemma pedersen_std_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res]\n  by rewrite(pedersen_computational_binding B &m); apply (std_red_dl_bridge B &m).\n\nend section PedersenSecurity.\n\nprint pedersen_correctness.\nprint pedersen_perfect_hiding.\nprint pedersen_computational_binding.",
        "codenote": "(*\n * A formal verification of the Pedersen commitment scheme\n *\n * Pedersen, Torben Pryds\n * \"Non-interactive and information-theoretic secure verifiable secret sharing\"\n *)\nrequire import Real.\nrequire (****) DLog.\n\nclone DLog as DL.\nimport DL.G DL.GP DL.FD DL.GP.ZModE.\n\nrequire (*--*) Commitment.\n\n(* Pedersen protocol types *)\ntheory PedersenTypes.\n  type value        = group. (* Type representing a group element *)\n  type message      = exp.    (* Type representing a message as an exponent *)\n  type commitment   = group.   (* Type representing a commitment as a group element *)\n  type openingkey   = exp.     (* Type representing the opening key as an exponent *)\nend PedersenTypes.\nexport PedersenTypes.\n\n(* Instantiate the Commitment scheme with the above types *)\nclone import Commitment as CM with\n  type CommitmentProtocol.value      <- value,        (* Associate 'value' type with CommitmentProtocol *)\n  type CommitmentProtocol.message    <- message,      (* Associate 'message' type with CommitmentProtocol *)\n  type CommitmentProtocol.commitment <- commitment,   (* Associate 'commitment' type with CommitmentProtocol *)\n  type CommitmentProtocol.openingkey <- openingkey.   (* Associate 'openingkey' type with CommitmentProtocol *)\nexport CommitmentProtocol.\n\nmodule Pedersen : CommitmentScheme = {\n  proc gen() : value = {  (* Procedure to generate a random value 'h' *)\n    var x, h;             (* Declare variables for secret 'x' and commitment 'h' *)\n    x <$ dt;              (* Sample 'x' from the distribution *)\n    h <- g ^ x;          (* Compute commitment 'h' as g^x *)\n    return h;            (* Return the generated commitment 'h' *)\n  }\n\n  proc commit(h: value, m: message) : commitment * openingkey = {  (* Commitment procedure *)\n    var c, d;            (* Declare variables for the commitment 'c' and random value 'd' *)\n    d <$ dt;             (* Sample 'd' from the distribution *)\n    c <- (g ^ d) * (h ^ m);  (* Compute the commitment 'c' using values 'g', 'h', and 'm' *)\n    return (c, d);      (* Return pair of commitment 'c' and opening key 'd' *)\n  }\n\n  proc verify(h: value, m: message, c: commitment, d: openingkey) : bool = {  (* Verification procedure *)\n    var c';             (* Declare variable for reconstructed commitment 'c'' *)\n    c' <- (g ^ d) * (h ^ m);  (* Recompute commitment 'c'' using 'd', 'h', and 'm' *)\n    return (c = c');    (* Return true if the computed commitment 'c'' matches 'c' *)\n  }\n}.\n\nmodule DLogAttacker(B:Binder) : DL.DLog.Adversary = {\n  proc guess (h: group) : exp option = {  (* Guess procedure for DLog attacker *)\n    var x, c, m, m', d, d';  (* Declare variables for various components *)\n    (c, m, d, m', d') <@ B.bind(h);  (* Bind values to variables from the binder 'B' *)\n    if ((c = g ^ d * h ^ m) /\\ (c = g ^ d' * h ^ m') /\\ (m <> m'))  (* Check if both commitments are valid yet reveal different messages *)\n      x <- Some((d - d') * inv (m' - m));  (* Compute the possible secret 'x' if valid *)\n    else\n      x <- None;  (* Otherwise, set 'x' to None *)\n\n    return x;  (* Return the result *)\n  }\n}.\n\nsection PedersenSecurity.\n\n  (* Correctness *)\n  lemma pedersen_correctness:\n    hoare[Correctness(Pedersen).main: true ==> res].  (* Lemma to prove the correctness of the Pedersen commitment scheme *)\n  proof. proc; inline *; auto. qed.\n\n  local module FakeCommit(U:Unhider) = {\n    proc main() : bool = {  (* Fake commitment to show perfect hiding *)\n      var b, b', x, h, c, d;  (* Declare variables *)\n      var m0, m1 : exp;  (* Declare variables for possible messages *)\n\n      (* Clearly, there are many useless lines, but their presence helps for the proofs *)\n      x <$ dt;  (* Sample 'x' uniformly *)\n      h <- g^x;  (* Compute commitment 'h' from 'g' and 'x' *)\n      (m0, m1) <@ U.choose(h);  (* Choose messages based on commitment 'h' *)\n      b <$ {0,1};  (* Randomly choose a bit 'b' *)\n      d <$ dt;  (* Sample 'd' uniformly *)\n      c <- g^d;  (* Compute fake commitment 'c' *)\n      b' <@ U.guess(c);  (* Try to guess the bit based on commitment 'c' *)\n\n      return (b = b');  (* Return true if the guessed bit matches *)\n    }\n  }.\n\n  local lemma hi_ll (U<:Unhider):\n    islossless U.choose =>\n    islossless U.guess =>\n    islossless FakeCommit(U).main.  (* Lemma on losslessness of FakeCommit *)\n  proof.\n    by move => uc_ll ug_ll; islossless; (apply dt_ll || apply DBool.dbool_ll).\n  qed.\n\n  (* Perfect hiding *)\n  local lemma fakecommit_half (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[FakeCommit(U).main() @ &m : res] = 1%r/2%r.  (* Probability of fake commitment being successful *)\n  proof.\n    move => uc_ll ug_ll; byphoare => //.\n    proc; wp.\n    swap 4 3.\n    rnd (pred1 b'); call ug_ll; wp; rnd; call uc_ll; auto => />.\n    by rewrite dt_ll /= => v _ _ result; rewrite DBool.dbool1E.\n  qed.\n\n  local lemma phi_hi (U<:Unhider) &m:\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] =\n    Pr[FakeCommit(U).main() @ &m : res].  (* Lemma equating probabilities of hiding experiments *)\n  proof.\n    byequiv => //.\n    proc; inline*.\n    call (_:true); wp.\n    rnd (fun d, (d + x * (b?m1:m0)){2})\n        (fun d, (d - x * (b?m1:m0)){2}).\n    by wp; rnd; call (_: true); auto => />; progress; algebra.\n  qed.\n\n  (* Perfect hiding - QED *)\n  lemma pedersen_perfect_hiding (U<:Unhider) &m:\n    islossless U.choose =>\n    islossless U.guess =>\n    Pr[HidingExperiment(Pedersen,U).main() @ &m : res] = 1%r/2%r.  (* Final lemma for perfect hiding *)\n  proof.\n    by move => uc_ll ug_ll; rewrite (phi_hi U &m) (fakecommit_half U &m).\n  qed.\n\n  (* Computational binding - QED *)\n  lemma pedersen_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] =\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res].  (* Lemma to compare binding experiments *)\n  proof.\n    byequiv => //.\n    proc; inline*.\n    wp; call (_: true); auto => /> x _ [c m d m' d'] /= comm comm' m_neq_m'.\n    rewrite eq_sym eqT.\n    have ->: (d - d') * inv (m' - m) = x <=> (d - d') = x * (m' - m).\n    + by split => [<- | ->]; field; apply: contra m_neq_m' => heq; ring heq.\n    have -> : d - d' = x * (m' - m) <=> d + x * m = d' + x * m'.\n    + by split => heq; ring heq.\n    by rewrite pow_bij !(expD, expM, -comm, -comm').\n  qed.\n\n  (*\n     The following two are to compare probability directly with book discrete\n     logarithm experiment. Not strictly necessary though, only for completeness.\n  *)\n  local lemma std_red_dl_bridge (B<:Binder) &m:\n    Pr[DL.DLog.DLogExperiment(DLogAttacker(B)).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res].  (* Lemma linking experiments for standard reduction *)\n  proof.\n    byequiv => //.\n    proc; wp; inline{2} DL.StdRedAdversary(DLogAttacker(B)).guess; wp.\n    seq 2 3: (x'{1} = lx{2} /\\ x{1} = x{2}).\n    + by inline*; wp; call (_: true); auto.\n    by if{2}; auto => />; apply dt_ll.\n  qed.\n\n  lemma pedersen_std_computational_binding (B<:Binder) &m:\n    Pr[BindingExperiment(Pedersen, B).main() @ &m : res] <=\n    Pr[DL.DLog.DLogStdExperiment(DL.StdRedAdversary(DLogAttacker(B))).main() @ &m : res]  (* Combine to show reduction of the binding *)\n  by rewrite(pedersen_computational_binding B &m); apply (std_red_dl_bridge B &m).\n\nend section PedersenSecurity.\n\nprint pedersen_correctness.  (* Print correctness lemma *)\nprint pedersen_perfect_hiding.  (* Print perfect hiding lemma *)\nprint pedersen_computational_binding.  (* Print computational binding lemma *)"
    },
    {
        "file": "EC-1/PRG.ec",
        "logic": "---\n\n### Protocol Description\n\n**1. Overview**\nThis protocol establishes a pseudorandom generator (PRG) and a pseudorandom function (PRF) that are indistinguishable from a uniform distribution. The protocol is designed with adversarial interactions in mind, outlining the security of the PRG against distinguishers (adversaries) that can query the PRF and PRG a limited number of times.\n\n**2. Definitions**\n- **Seed**: A finite type used as input for both the PRG and PRF.\n- **Output**: The result produced by the PRG, which is drawn from a lossless distribution.\n- **Random Function (RF)**: A function characterized by a deterministic output given a seed input.\n- **Pseudorandom Generator (PRG)**: A generator that produces outputs that are indistinguishable from random.\n- **Adversary (Adv)**: An entity that queries the PRF and PRG with the goal of distinguishing between them.\n\n**3. Components**\n- **Random Function Module (RF)**:\n  - Contains an initialization procedure and a function `f` that takes a seed and returns a new seed and an output.\n  \n- **Pseudorandom Generator Module (PRG)**:\n  - Contains an initialization procedure and a function `prg` that returns an output.\n\n- **Adversary Module (Adv)**:\n  - Represents a generic adversary capable of querying the PRF and PRG and returning a boolean value based on its internal logic.\n\n**4. Main Protocol Execution**\nThe main execution of the protocol involves:\n1. Initializing the RF and PRG modules.\n2. Invoking the adversary's method to determine its success in distinguishing the PRG from a uniform distribution.\n3. Returning the boolean result of the adversary's execution.\n\n**5. Security Definitions**\n- The security of the PRG is defined in terms of the indistinguishability from the output of a uniformly random distribution (`dout`).\n- An adversary can query the PRF at most `qF` times and the PRG at most `qP` times.\n- The protocol guarantees that if both the PRG and PRF are lossless, then the adversary cannot distinguish the outputs with a probability significantly greater than negligible.\n\n**6. Lemmas and Proofs**\nThe protocol includes several lemmas to ensure:\n- The losslessness of the PRF and PRG.\n- The behavior of the adversary when faced with the PRF and PRG.\n- The bounding of the probability that an adversary can distinguish between the outputs of the PRG and a uniform distribution.\n\n**7. Conclusion**\nThe protocol is designed to ensure that the PRG operates securely, providing outputs that are indistinguishable from random, given that the RF and PRG are initialized correctly and the adversary has limited querying capabilities.\n\n---",
        "code": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List Distr FSet SmtMap.\nrequire import IntDiv Mu_mem StdRing StdOrder StdBigop.\n(*---*) import Bigint Ring.IntID RField IntOrder RealOrder BIA.\nrequire (*--*) FinType.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(** A finite type of seeds equipped with its uniform distribution **)\nclone include MFinite\nrename\n  [type] \"t\" as \"seed\"\n  \"dunifin\" as \"dseed\"\n  \"duniform\" as \"dseed\".\n\n(* -------------------------------------------------------------------- *)\n(** Some output type equipped with some lossless distribution **)\ntype output.\nop dout: { output distr | is_lossless dout } as dout_ll.\nhint exact random: dout_ll.\n\n(* -------------------------------------------------------------------- *)\n(** We use a public RF that, on input a seed, produces a seed and\n    an output...                                                        *)\nmodule type RF = {\n  proc * init() : unit\n  proc f(x:seed): seed * output\n}.\n\n(** ...to build a PRG that produces random outputs... **)\n(** We let our PRG have internal state, which we need to initialize **)\nmodule type PRG = {\n  proc * init(): unit\n  proc prg()   : output\n}.\n\n(* -------------------------------------------------------------------- *)\n(** Distinguishers can call\n  *   - the PRG at most qP times, and\n  *   - the PRF at most qF times, and\n  *   - return a boolean *)\nop qP : { int | 0 <= qP } as ge0_qP.\nop qF : { int | 0 <= qF } as ge0_qF.\n\nmodule type ARF = {\n  proc f(_:seed): seed * output\n}.\n\nmodule type APRG = {\n  proc prg(): output\n}.\n\nmodule type Adv (F:ARF) (P:APRG) = {\n  proc a(): bool\n}.\n\nmodule Exp (A:Adv) (F:RF) (P:PRG) = {\n  module A = A(F,P)\n\n  proc main():bool = {\n    var b: bool;\n\n         F.init();\n         P.init();\n    b <@ A.a();\n    return b;\n  }\n}.\n\n(** A PRG is secure iff it is indistinguishable from sampling in $dout\n    by an adversary with access to the PRF and the PRG interfaces *)\nmodule PrgI = {\n  proc init () : unit = { }\n\n  proc prg(): output = {\n    var r;\n\n    r <$ dout;\n    return r;\n  }\n}.\n(* Adv^PRG_A,F,P = `| Exp(A,F,P) - Exp(A,F,PrgI) | *)\n\n(* -------------------------------------------------------------------- *)\n(* Concrete considerations                                              *)\n\n(* We use the following RF *)\nmodule F = {\n  var m:(seed,seed * output) fmap\n\n  proc init(): unit = {\n     m <- empty;\n  }\n\n  proc f (x:seed) : seed * output = {\n    var r1, r2;\n\n    r1 <$ dseed;\n    r2 <$ dout;\n    if (x \\notin m)\n      m.[x] <- (r1,r2);\n\n    return oget (m.[x]);\n  }\n}.\n\nlemma FfL: islossless F.f.\nproof. islossless. qed.\n\n(* And we are proving the security of the following PRG *)\nmodule P (F:RF) = {\n  var seed: seed\n  var logP: seed list\n\n  proc init(): unit = {\n    seed <$ dseed;\n  }\n\n  proc prg(): output = {\n    var r;\n\n    (seed,r) <@ F.f (seed);\n    return r;\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\n(* We use the following oracle in an intermediate game that links two\n   sections.                                                            *)\n\nmodule Psample = {\n  proc init(): unit = {\n    P.seed <$ dseed;\n    P.logP <- [];\n  }\n\n  proc prg(): output = {\n    var r1, r2;\n\n    r1     <$ dseed;\n    r2     <$ dout;\n    P.logP <- P.seed :: P.logP;\n    P.seed <- r1;\n    return r2;\n  }\n}.\n\nlemma PsampleprgL: islossless Psample.prg.\nproof. islossless. qed.\n\n(* -------------------------------------------------------------------- *)\n(* In preparation of the eager/lazy reasoning step                      *)\n(* -------------------------------------------------------------------- *)\nmodule Resample = {\n  proc resample() : unit = {\n    var n, r;\n\n    n      <- size P.logP;\n    P.logP <- [];\n    P.seed <$ dseed;\n    while (size P.logP < n) {\n      r      <$ dseed;\n      P.logP <- r :: P.logP;\n    }\n  }\n}.\n\nmodule Exp'(A:Adv) = {\n  module A = A(F,Psample)\n\n  proc main():bool = {\n    var b : bool;\n         F.init();\n         Psample.init();\n    b <@ A.a();\n         Resample.resample();\n    return b;\n  }\n}.\n\n(* The Proof                                                            *)\n\nsection.\n  (* Forall Adversary A that does not share memory with P or F... *)\n  declare module A:Adv {P,F}.\n\n  (* ... and whose a procedure is lossless whenever F.f and P.prg are *)\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* We show that the adversary can distinguish P from Psample only\n     when P.prg is called twice with the same input. *)\n\n  (* First, we add some logging so we can express the bad event *)\n  local module Plog = {\n    proc init(): unit = {\n      P.seed <$ dseed;\n      P.logP <- [];\n    }\n\n    proc prg(): output = {\n      var r;\n\n      P.logP     <- P.seed :: P.logP;\n      (P.seed,r) <@ F.f(P.seed);\n      return r;\n    }\n  }.\n\n  local lemma PlogprgL: islossless Plog.prg.\n  proof. by proc; call FfL; wp. qed.\n\n  local lemma P_Plog &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] = Pr[Exp(A,F,Plog).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //.\n  by do !sim.\n  qed.\n\n  (* Bad holds whenever:\n   *  - there is a cycle in the state, OR\n   *  - an adversary query collides with an internal seed. *)\n  inductive Bad logP (m : ('a,'b) fmap) =\n    | Cycle of (!uniq logP)\n    | Collision r of (mem logP r) & (r \\in m).\n\n  lemma negBadE logP (m : ('a,'b) fmap):\n    !Bad logP m <=>\n      (uniq logP /\\ forall r, !mem logP r \\/ r \\notin m).\n  proof.\n  rewrite -iff_negb negbK negb_and negb_forall /=.\n  rewrite (@ exists_iff _ (predI (mem logP) (dom m)) _).\n  + by move=> a /=; rewrite negb_or /predI.\n  split=> [[->|r r_in_log r_in_m]|[/(Cycle _ m)|[r] @/predI [] /(Collision _ m r)]] //.\n  by right; exists r.\n  qed.\n\n  (* In this game, we replace the PRF queries with fresh sampling operations *)\n  inductive inv (m1 m2 : ('a,'b) fmap) (logP : 'a list) =\n    | Invariant of\n          (forall r, r \\in m1 <=> (r \\in m2 \\/ mem logP r))\n        & (forall r, r \\in m2 => m1.[r] = m2.[r]).\n\n  local lemma Plog_Psample &m:\n    Pr[Exp(A,F,Plog).main() @ &m: res] <=\n      Pr[Exp(A,F,Psample).main() @ &m: res] +\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (ler_trans (Pr[Exp(A,F,Psample).main() @ &m: res \\/ Bad P.logP F.m]));\n    last by rewrite Pr [mu_or]; smt w=mu_bounded.\n  byequiv (_: ={glob A} ==> !(Bad P.logP F.m){2} => ={res})=> // [|/#].\n  proc.\n  call (_: Bad P.logP F.m, ={P.seed} /\\ inv F.m{1} F.m{2} P.logP{2}).\n    (* adversary is lossless *)\n    by apply AaL.\n    (* [Psample.prg ~ Plog.prg: I] when Bad does not hold *)\n    proc; inline F.f. swap{2} 3 -2.\n    auto=> /> &1 &2 _ [] m1_is_m2Ulog m2_le_m1 r1 _ r2 _.\n    rewrite negBadE; case: (P.seed{2} \\in F.m{1})=> [/#|//=].\n    rewrite !get_setE /=.\n    move=> seed_notin_m1 _; split.\n      by move=> r; rewrite mem_set m1_is_m2Ulog /#.\n    move=> r ^/m2_le_m1; rewrite !get_setE=> -> r_in_m2.\n    by move: (iffRL _ _ (m1_is_m2Ulog r)); rewrite r_in_m2 /#.\n    (* Plog.prg is lossless when Bad holds *)\n    by move=> _ _; islossless.\n    (* Psample.prg preserves bad *)\n    move=> *; proc; auto=> />; rewrite dseed_ll dout_ll /=.\n    move=> &hr + v1 _ _ v2 _ _; case=> [h|r r_in_log r_in_m].\n    + by apply/Cycle; rewrite /= h.\n    by apply/(@Collision _ _ r)=> /=; [rewrite r_in_log|rewrite r_in_m].\n    (* [F.f ~ F.f: I] when Bad does not hold *)\n    proc; auto=> /> &1 &2; rewrite !negBadE.\n    move=> -[] uniq_log r_notin_logIm [] m_is_mUlog m2_le_m1 r1L _ r2L _.\n    case: (x{2} \\in F.m{2})=> [/#|//=].\n    case: (x{2} \\in F.m{1})=> /=.\n    + rewrite negBadE uniq_log=> /= /m_is_mUlog + x_notin_m2 h'; rewrite x_notin_m2 /=.\n      by move: (h' x{2}); rewrite mem_set.\n    rewrite !get_setE /= => x_notin_m1 x_notin_m2 _; split.\n    + by move=> r; rewrite !mem_set m_is_mUlog /#.\n    by move=> r; rewrite !mem_set !get_setE=> -[/m2_le_m1|] ->.\n    (* F.f is lossless when Bad holds *)\n    by move=> _ _; apply FfL.\n    (* F.f preserves bad *)\n    move=> _ //=; proc.\n    case (x \\in F.m).\n    + by rcondf 3; auto=> />; rewrite dseed_ll dout_ll.\n    rcondt 3; first by do !rnd; wp.\n    auto=> />; rewrite dseed_ll dout_ll //= => &hr bad_init x_notin_m v _ _ v0 _ _.\n    case: bad_init=> [/(Cycle<:seed,seed * output>) -> //|r r_in_log r_in_m].\n    by apply/(@Collision _ _ r)=> //=; rewrite mem_set r_in_m.\n  (* Returning to main *)\n  call (_: ={glob F} ==> ={glob P} /\\ inv F.m{1} F.m{2} P.logP{2}).\n  + by proc; auto=> /> &2 _ _; split.\n  call (_: true ==> ={glob F}); first by sim.\n  by auto=> /#.\n  qed.\n\n  local lemma Psample_PrgI &m:\n    Pr[Exp(A,F,Psample).main() @ &m: res] = Pr[Exp(A,F,PrgI).main() @ &m: res].\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //; proc.\n  call (_: ={glob F})=> //.\n    (* Psample.prg ~ PrgI.prg *)\n  + by proc; wp; rnd; rnd{1}; auto=> />; rewrite dseed_ll.\n    (* F.f *)\n  + by sim.\n  conseq (_: _ ==> ={glob A, glob F})=> //.\n  by inline *; auto=> />; rewrite dseed_ll.\n  qed.\n\n  local lemma Resample_resampleL: islossless Resample.resample.\n  proof.\n  proc; while (true) (n - size P.logP);\n    first by move=> z; auto; rewrite dseed_ll /#.\n  by auto; rewrite dseed_ll /#.\n  qed.\n\n  local module Exp'A = Exp'(A).\n\n  local lemma ExpPsample_Exp' &m:\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m]\n    = Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_: ={glob A} ==> ={P.logP, F.m})=> //; proc.\n  transitivity{1} { F.init(); Psample.init(); Resample.resample(); b <@ Exp'A.A.a(); }\n     (={glob A} ==> ={F.m, P.logP})\n     (={glob A} ==> ={F.m, P.logP})=> //.\n    (* Equality on A's globals *)\n  + by move=> &1 &2 A; exists (glob A){1}.\n    (* no sampling ~ presampling *)\n  + sim; inline Resample.resample Psample.init F.init.\n    rcondf{2} 7;\n      first by move=> &hr; rnd; wp; conseq (_: _ ==> true) => //.\n    by wp; rnd; wp; rnd{2} predT; auto; rewrite dseed_ll.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob F, glob Plog}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob Plog} ==> ={glob Plog})\n    : (={glob A, glob Plog, glob F})=> //;\n    first by sim.\n  eager proc H (={glob Plog, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r;\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r;\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0;\n    cP <- 0;\n    b <@ A.a();\n    return b;\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f.\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg.\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n     islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a.\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}.\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m].\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r).\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)).\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section.",
        "codenote": "(* -------------------------------------------------------------------- *)\nrequire import AllCore List Distr FSet SmtMap.\nrequire import IntDiv Mu_mem StdRing StdOrder StdBigop.\n(*---*) import Bigint Ring.IntID RField IntOrder RealOrder BIA.\nrequire (*--*) FinType.\n\n(* ---------------- Sane Default Behaviours --------------------------- *)\npragma +implicits.\n\n(* -------------------------------------------------------------------- *)\n(** A finite type of seeds equipped with its uniform distribution **)\nclone include MFinite\nrename\n  [type] \"t\" as \"seed\"\n  \"dunifin\" as \"dseed\"\n  \"duniform\" as \"dseed\".\n\n(* -------------------------------------------------------------------- *)\n(** Some output type equipped with some lossless distribution **)\ntype output.\nop dout: { output distr | is_lossless dout } as dout_ll.\nhint exact random: dout_ll.\n\n(* -------------------------------------------------------------------- *)\n(** We use a public RF that, on input a seed, produces a seed and\n    an output...                                                        *)\nmodule type RF = {\n  proc * init() : unit\n  proc f(x:seed): seed * output\n}.\n\n(** ...to build a PRG that produces random outputs... **)\n(** We let our PRG have internal state, which we need to initialize **)\nmodule type PRG = {\n  proc * init(): unit\n  proc prg()   : output\n}.\n\n(* -------------------------------------------------------------------- *)\n(** Distinguishers can call\n  *   - the PRG at most qP times, and\n  *   - the PRF at most qF times, and\n  *   - return a boolean *)\nop qP : { int | 0 <= qP } as ge0_qP.\nop qF : { int | 0 <= qF } as ge0_qF.\n\nmodule type ARF = {\n  proc f(_:seed): seed * output\n}.\n\nmodule type APRG = {\n  proc prg(): output\n}.\n\nmodule type Adv (F:ARF) (P:APRG) = {\n  proc a(): bool\n}.\n\nmodule Exp (A:Adv) (F:RF) (P:PRG) = {\n  module A = A(F,P)\n\n  proc main():bool = {\n    var b: bool;\n\n         F.init();\n         P.init();\n    b <@ A.a();\n    return b;\n  }\n}.\n\n(** A PRG is secure iff it is indistinguishable from sampling in $dout\n    by an adversary with access to the PRF and the PRG interfaces *)\nmodule PrgI = {\n  proc init () : unit = { }\n\n  proc prg(): output = {\n    var r;\n\n    r <$ dout;\n    return r;\n  }\n}.\n(* Adv^PRG_A,F,P = `| Exp(A,F,P) - Exp(A,F,PrgI) | *)\n\n(* -------------------------------------------------------------------- *)\n(* Concrete considerations                                              *)\n\n(* We use the following RF *)\nmodule F = {\n  var m:(seed,seed * output) fmap\n\n  proc init(): unit = {\n     m <- empty;\n  }\n\n  proc f (x:seed) : seed * output = {\n    var r1, r2;\n\n    r1 <$ dseed;\n    r2 <$ dout;\n    if (x \\notin m)\n      m.[x] <- (r1,r2);\n\n    return oget (m.[x]);\n  }\n}.\n\nlemma FfL: islossless F.f.\nproof. islossless. qed.\n\n(* And we are proving the security of the following PRG *)\nmodule P (F:RF) = {\n  var seed: seed\n  var logP: seed list\n\n  proc init(): unit = {\n    seed <$ dseed;\n  }\n\n  proc prg(): output = {\n    var r;\n\n    (seed,r) <@ F.f (seed);\n    return r;\n  }\n}.\n\n(* -------------------------------------------------------------------- *)\n(* We use the following oracle in an intermediate game that links two\n   sections.                                                            *)\n\nmodule Psample = {\n  proc init(): unit = {\n    P.seed <$ dseed;\n    P.logP <- [];\n  }\n\n  proc prg(): output = {\n    var r1, r2;\n\n    r1     <$ dseed;\n    r2     <$ dout;\n    P.logP <- P.seed :: P.logP; (* Record the current seed *)\n    P.seed <- r1; (* Update the seed for the next iteration *)\n    return r2; (* Return the output *)\n  }\n}.\n\nlemma PsampleprgL: islossless Psample.prg.\nproof. islossless. qed.\n\n(* -------------------------------------------------------------------- *)\n(* In preparation of the eager/lazy reasoning step                      *)\n(* -------------------------------------------------------------------- *)\nmodule Resample = {\n  proc resample() : unit = {\n    var n, r;\n\n    n      <- size P.logP; (* Get the number of logged seeds *)\n    P.logP <- []; (* Reset the log *)\n    P.seed <$ dseed; (* Generate a new seed *)\n    while (size P.logP < n) { (* Resample until we have n entries *)\n      r      <$ dseed; (* Generate a new seed *)\n      P.logP <- r :: P.logP; (* Add the new seed to the log *)\n    }\n  }\n}.\n\nmodule Exp'(A:Adv) = {\n  module A = A(F,Psample)\n\n  proc main():bool = {\n    var b : bool;\n         F.init();\n         Psample.init();\n    b <@ A.a();\n         Resample.resample();\n    return b;\n  }\n}.\n\n(* The Proof                                                            *)\n\nsection.\n  (* Forall Adversary A that does not share memory with P or F... *)\n  declare module A:Adv {P,F}.\n\n  (* ... and whose a procedure is lossless whenever F.f and P.prg are *)\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  (* We show that the adversary can distinguish P from Psample only\n     when P.prg is called twice with the same input. *)\n\n  (* First, we add some logging so we can express the bad event *)\n  local module Plog = {\n    proc init(): unit = {\n      P.seed <$ dseed;\n      P.logP <- []; (* Initialize the log *)\n    }\n\n    proc prg(): output = {\n      var r;\n\n      P.logP     <- P.seed :: P.logP; (* Log the current seed *)\n      (P.seed,r) <@ F.f(P.seed);\n      return r; (* Return the output *)\n    }\n  }.\n\n  local lemma PlogprgL: islossless Plog.prg.\n  proof. by proc; call FfL; wp. qed.\n\n  local lemma P_Plog &m:\n    Pr[Exp(A,F,P(F)).main() @ &m: res] = Pr[Exp(A,F,Plog).main() @ &m: res]. (* Equivalence of probabilities *)\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //.\n  by do !sim.\n  qed.\n\n  (* Bad holds whenever:\n   *  - there is a cycle in the state, OR\n   *  - an adversary query collides with an internal seed. *)\n  inductive Bad logP (m : ('a,'b) fmap) =\n    | Cycle of (!uniq logP)\n    | Collision r of (mem logP r) & (r \\in m).\n\n  lemma negBadE logP (m : ('a,'b) fmap):\n    !Bad logP m <=>\n      (uniq logP /\\ forall r, !mem logP r \\/ r \\notin m). (* Characterization of no bad events *)\n  proof.\n  rewrite -iff_negb negbK negb_and negb_forall /=.\n  rewrite (@ exists_iff _ (predI (mem logP) (dom m)) _).\n  + by move=> a /=; rewrite negb_or /predI.\n  split=> [[->|r r_in_log r_in_m]|[/(Cycle _ m)|[r] @/predI [] /(Collision _ m r)]] //.\n  by right; exists r.\n  qed.\n\n  (* In this game, we replace the PRF queries with fresh sampling operations *)\n  inductive inv (m1 m2 : ('a,'b) fmap) (logP : 'a list) =\n    | Invariant of\n          (forall r, r \\in m1 <=> (r \\in m2 \\/ mem logP r))\n        & (forall r, r \\in m2 => m1.[r] = m2.[r]).\n\n  local lemma Plog_Psample &m:\n    Pr[Exp(A,F,Plog).main() @ &m: res] <=\n      Pr[Exp(A,F,Psample).main() @ &m: res] +\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m]. (* Connecting probabilities *)\n  proof.\n  apply (ler_trans (Pr[Exp(A,F,Psample).main() @ &m: res \\/ Bad P.logP F.m]));\n    last by rewrite Pr [mu_or]; smt w=mu_bounded.\n  byequiv (_: ={glob A} ==> !(Bad P.logP F.m){2} => ={res})=> // [|/#].\n  proc.\n  call (_: Bad P.logP F.m, ={P.seed} /\\ inv F.m{1} F.m{2} P.logP{2}).\n    (* adversary is lossless *)\n    by apply AaL.\n    (* [Psample.prg ~ Plog.prg: I] when Bad does not hold *)\n    proc; inline F.f. swap{2} 3 -2.\n    auto=> /> &1 &2 _ [] m1_is_m2Ulog m2_le_m1 r1 _ r2 _.\n    rewrite negBadE; case: (P.seed{2} \\in F.m{1})=> [/#|//=].\n    rewrite !get_setE /=.\n    move=> seed_notin_m1 _; split.\n      by move=> r; rewrite mem_set m1_is_m2Ulog /#.\n    move=> r ^/m2_le_m1; rewrite !get_setE=> -> r_in_m2.\n    by move: (iffRL _ _ (m1_is_m2Ulog r)); rewrite r_in_m2 /#.\n    (* Plog.prg is lossless when Bad holds *)\n    by move=> _ _; islossless.\n    (* Psample.prg preserves bad *)\n    move=> *; proc; auto=> />; rewrite dseed_ll dout_ll /=.\n    move=> &hr + v1 _ _ v2 _ _; case=> [h|r r_in_log r_in_m].\n    + by apply/Cycle; rewrite /= h.\n    by apply/(@Collision _ _ r)=> /=; [rewrite r_in_log|rewrite r_in_m].\n    (* [F.f ~ F.f: I] when Bad does not hold *)\n    proc; auto=> /> &1 &2; rewrite !negBadE.\n    move=> -[] uniq_log r_notin_logIm [] m_is_mUlog m2_le_m1 r1L _ r2L _.\n    case: (x{2} \\in F.m{2})=> [/#|//=].\n    case: (x{2} \\in F.m{1})=> /=.\n    + rewrite negBadE uniq_log=> /= /m_is_mUlog + x_notin_m2 h'; rewrite x_notin_m2 /=.\n      by move: (h' x{2}); rewrite mem_set.\n    rewrite !get_setE /= => x_notin_m1 x_notin_m2 _; split.\n    + by move=> r; rewrite !mem_set m_is_mUlog /#.\n    by move=> r; rewrite !mem_set !get_setE=> -[/m2_le_m1|] ->.\n    (* F.f is lossless when Bad holds *)\n    by move=> _ _; apply FfL.\n    (* F.f preserves bad *)\n    move=> _ //=; proc.\n    case (x \\in F.m).\n    + by rcondf 3; auto=> />; rewrite dseed_ll dout_ll.\n    rcondt 3; first by do !rnd; wp.\n    auto=> />; rewrite dseed_ll dout_ll //= => &hr bad_init x_notin_m v _ _ v0 _ _.\n    case: bad_init=> [/(Cycle<:seed,seed * output>) -> //|r r_in_log r_in_m].\n    by apply/(@Collision _ _ r)=> //=; rewrite mem_set r_in_m.\n  (* Returning to main *)\n  call (_: ={glob F} ==> ={glob P} /\\ inv F.m{1} F.m{2} P.logP{2}).\n  + by proc; auto=> /> &2 _ _; split.\n  call (_: true ==> ={glob F}); first by sim.\n  by auto=> /#.\n  qed.\n\n  local lemma Psample_PrgI &m:\n    Pr[Exp(A,F,Psample).main() @ &m: res] = Pr[Exp(A,F,PrgI).main() @ &m: res]. (* Equivalence of probabilities *)\n  proof.\n  byequiv (_: ={glob A} ==> ={res})=> //; proc.\n  call (_: ={glob F})=> //.\n    (* Psample.prg ~ PrgI.prg *)\n  + by proc; wp; rnd; rnd{1}; auto=> />; rewrite dseed_ll.\n    (* F.f *)\n  + by sim.\n  conseq (_: _ ==> ={glob A, glob F})=> //.\n  by inline *; auto=> />; rewrite dseed_ll.\n  qed.\n\n  local lemma Resample_resampleL: islossless Resample.resample.\n  proof.\n  proc; while (true) (n - size P.logP); (* Resampling process *)\n    first by move=> z; auto; rewrite dseed_ll /#.\n  by auto; rewrite dseed_ll /#.\n  qed.\n\n  local module Exp'A = Exp'(A).\n\n  local lemma ExpPsample_Exp' &m: (* Probability interchangeable with respect to bad *)\n      Pr[Exp(A,F,Psample).main() @ &m: Bad P.logP F.m]\n    = Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  byequiv (_: ={glob A} ==> ={P.logP, F.m})=> //; proc.\n  transitivity{1} { F.init(); Psample.init(); Resample.resample(); b <@ Exp'A.A.a(); }\n     (={glob A} ==> ={F.m, P.logP})\n     (={glob A} ==> ={F.m, P.logP})=> //.\n    (* Equality on A's globals *)\n  + by move=> &1 &2 A; exists (glob A){1}.\n    (* no sampling ~ presampling *)\n  + sim; inline Resample.resample Psample.init F.init.\n    rcondf{2} 7;\n      first by move=> &hr; rnd; wp; conseq (_: _ ==> true) => //.\n    by wp; rnd; wp; rnd{2} predT; auto; rewrite dseed_ll.\n  (* presampling ~ postsampling *)\n  seq 2 2: (={glob A, glob Plog}); first by sim.\n  eager (H: Resample.resample(); ~ Resample.resample();\n    : ={glob Plog} ==> ={glob Plog})\n    : (={glob A, glob Plog, glob F})=> //;\n    first by sim.\n  eager proc H (={glob Plog, glob F})=> //.\n  + eager proc; inline Resample.resample.\n    swap{1} 3 3. swap{2} [4..5] 2. swap{2} [6..8] 1.\n    swap{1} 4 3. swap{1} 4 2. swap{2} 2 4.\n    sim.\n    splitwhile {2} 5 : (size P.logP < n - 1).\n    conseq (_ : _ ==> ={P.logP})=> //.\n    seq 3 5: (={P.logP} /\\ (size P.logP = n - 1){2}).\n    + while (={P.logP} /\\ n{2} = n{1} + 1 /\\ size P.logP{1} <= n{1});\n        first by auto=> /#.\n      by wp; rnd{2}; auto=> />; smt (size_ge0).\n    rcondt{2} 1; first by move=> &hr; auto=> /#.\n    rcondf{2} 3; first by move=> &hr; auto=> /#.\n  + by sim.\n  + by sim.\n  + by eager proc; swap{1} 1 4; sim.\n  by sim.\n  qed.\n\n  lemma P_PrgI &m: (* Main lemma connecting probabilities *)\n    Pr[Exp(A,F,P(F)).main() @ &m: res] <=\n      Pr[Exp(A,F,PrgI).main() @ &m: res] + Pr[Exp'(A).main() @ &m: Bad P.logP F.m].\n  proof.\n  by rewrite (P_Plog &m) -(ExpPsample_Exp' &m) -(Psample_PrgI &m) (Plog_Psample &m).\n  qed.\nend section.\n\n(* -------------------------------------------------------------------- *)\n\n(* We now bound Pr[Exp(A,F,Psample).main() @ &m: Bad Plog.logP F.m] *)\n\n(* For now, we use the following counting variant of the adversary to\n   epxress the final result. Everything up to now applies to\n   non-counting adversaries, but we need the counting to bound the\n   probability of Bad. *)\n\nmodule C (A:Adv,F:ARF,P:APRG) = {\n  var cF, cP:int\n\n  module CF = {\n    proc f(x): seed * output = {\n      var r <- witness;\n\n      if (cF < qF) { cF <- cF + 1; r <@ F.f(x);}\n      return r; (* Return the sampled output *)\n    }\n  }\n\n  module CP = {\n    proc prg (): output = {\n      var r <- witness;\n\n      if (cP < qP) { cP <- cP + 1; r <@ P.prg();}\n      return r; (* Return the sampled output *)\n    }\n  }\n\n  module A = A(CF,CP)\n\n  proc a(): bool = {\n    var b:bool;\n\n    cF <- 0; (* Initialize the counters *)\n    cP <- 0;\n    b <@ A.a();\n    return b; (* Return the result of the adversary's operation *)\n  }\n}.\n\nlemma CFfL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless F.f =>\n  islossless C(A,F,P).CF.f. (* Counter function lossless *)\nproof. by move=> FfL; proc; sp; if=> //; call FfL; wp. qed.\n\nlemma CPprgL (A <: Adv) (F <: ARF) (P <: APRG):\n  islossless P.prg =>\n  islossless C(A,F,P).CP.prg. (* Counter prg lossless *)\nproof. by move=> PprgL; proc; sp; if=> //; call PprgL; wp. qed.\n\nlemma CaL (A <: Adv {C}) (F <: ARF {A}) (P <: APRG {A}):\n  (forall (F <: ARF {A}) (P <: APRG {A}),\n    islossless P.prg => islossless F.f => islossless A(F,P).a) =>\n    islossless F.f\n  => islossless P.prg\n  => islossless C(A,F,P).a. (* Lossless condition for the counting adversary *)\nproof.\nmove=> AaL PprgL FfL; proc.\ncall (AaL (<: C(A,F,P).CF) (<: C(A,F,P).CP) _ _).\n+ by apply (CPprgL A F P).\n+ by apply (CFfL A F P).\nby wp.\nqed.\n\nsection.\n  declare module A:Adv {C,P,F}. (* Declaration of adversary with counting *)\n  axiom AaL (F <: ARF {A}) (P <: APRG {A}):\n    islossless P.prg =>\n    islossless F.f =>\n    islossless A(F,P).a.\n\n  lemma pr &m:\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]. (* Relation of probabilities *)\n  proof.\n  apply (P_PrgI (<: C(A)) _ &m).\n  + move=> F0 P0 F0fL P0prgL; apply (CaL A F0 P0) => //.\n    by apply AaL.\n  qed.\n\n  local lemma Bad_bound:\n    phoare [Exp'(C(A)).main : true ==>\n      Bad P.logP F.m] <= ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r). (* Bounding bad event probability *)\n  proof.\n  proc.\n  seq 3: true\n         1%r ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (size P.logP <= qP /\\ card (fdom F.m) <= qF)=> //.\n  + inline Exp'(C(A)).A.a; wp.\n    call (_: size P.logP = C.cP /\\ C.cP <= qP /\\\n             card (fdom F.m) <= C.cF /\\ C.cF <= qF).\n    (* prg *)\n    + proc; sp; if=> //.\n      call (_: size P.logP = C.cP - 1 ==> size P.logP = C.cP).\n      + by proc; auto=> /#.\n      by auto=> /#.\n    (* f *)\n    proc; sp; if=> //.\n    call (_: card (fdom F.m) < C.cF ==> card (fdom F.m) <= C.cF).\n    proc; auto=> /> &hr h r1 _ r2 _.\n    + by rewrite fdom_set fcardU fcard1; smt w=fcard_ge0.\n    by auto=> /#.\n  + inline *; auto=> />.\n    by rewrite fdom0 fcards0 /=; smt w=(ge0_qP ge0_qF).\n  inline Resample.resample.\n  exists* P.logP; elim* => logP.\n  seq 3: true\n         1%r  ((qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r)\n         0%r 1%r\n         (n = size logP /\\ n <= qP /\\ P.logP = [] /\\\n          card (fdom F.m) <= qF)=> //.\n  + by rnd; wp.\n  conseq (_ : _ : <= (if Bad P.logP F.m then 1%r else\n      (sumid (qF + size P.logP) (qF + n))%r / Support.card%r)). (* Analyzing bad events *)\n  + move=> /> &hr.\n    have /= -> /= szlog_le_qP szm_le_qF := negBadE A AaL [] F.m{hr}.\n    apply/ler_wpmul2r; first smt w=Support.card_gt0. apply/le_fromint.\n    rewrite -{1}(@add0z qF) big_addn /= /predT -/predT.\n    rewrite (@addzC qF) !addrK big_split big_constz.\n    rewrite count_predT size_range /= ler_maxr ?size_ge0 addrC.\n    rewrite ler_add 1:mulrC ?ler_wpmul2r // ?ge0_qF.\n    rewrite sumidE ?size_ge0 leq_div2r // mulrC.\n    move: (size_ge0 logP) szlog_le_qP => /IntOrder.ler_eqVlt [<- /#|gt0_sz le].\n    by apply/IntOrder.ler_pmul => // /#.\n  while{1} (n <= qP /\\ card (fdom F.m) <= qF).\n  + move=> Hw; exists* P.logP, F.m, n; elim* => logPw m n0.\n    case: (Bad P.logP F.m).\n    + by conseq (_ : _ : <= (1%r))=> // /#.\n    seq 2: (Bad P.logP F.m)\n           ((qF + size logPw)%r / Support.card%r) 1%r 1%r\n           ((sumid (qF + (size logPw + 1)) (qF + n))%r / Support.card%r)\n           (n = n0 /\\ F.m = m /\\ r::logPw = P.logP /\\\n            n <= qP /\\ card (fdom F.m) <= qF)=> //.\n    + by wp; rnd=> //.\n    + wp; rnd; auto=> /> _ /le_fromint domF_le_qF _.\n      rewrite (negBadE A AaL)=> //= -[uniq_logP logP_disj_domF].\n      apply (ler_trans (mu dseed (predU (dom m)\n                                        (mem logPw)))).\n      + by apply mu_sub=> x [] /#.\n      have ->: dom m = mem (fdom m).\n      + by apply/fun_ext=> x; rewrite mem_fdom.\n      rewrite mu_or (@mu_mem (fdom m) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@mu_mem_card (logPw) dseed (inv (Support.card%r))).\n      + by move=> x _; rewrite dseed1E.\n      rewrite (@cardE (oflist logPw)) (@perm_eq_size _ (logPw)) 1:perm_eq_sym 1:oflist_uniq //.\n      have -> /=: mu dseed (predI (mem (fdom m)) (mem logPw)) = 0%r.\n      + have ->: mem (fdom m) = dom m.\n        + by apply/fun_ext=> x; rewrite mem_fdom.\n        by rewrite -(@mu0 dseed) /predI; apply/mu_eq=> x; move: (logP_disj_domF x)=> [] ->.\n      rewrite -mulrDl fromintD.\n      have: (card (fdom m))%r + (size logPw)%r <= qF%r + (size logPw)%r.\n      + exact/ler_add.\n      have: 0%r <= Support.card%r by smt(@Support). \n      by move => /invr_ge0 h1; apply: ler_wpmul2r.\n    + conseq Hw; progress=> //.\n      by rewrite H1 /= (Ring.IntID.addrC 1) lerr.\n    progress=> //; rewrite H2 /= -mulrDl addrA -fromintD.\n    rewrite\n      (@BIA.big_cat_int (qF + size P.logP{hr} + 1) (_ + List.size _))\n      ?BIA.big_int1 /#.\n  by skip; progress=> /#.\n  qed.\n\n  lemma conclusion &m: (* Final result for the probabilities *)\n    Pr[Exp(C(A),F,P(F)).main() @ &m: res] <=\n        Pr[Exp(C(A),F,PrgI).main() @ &m: res]\n      + (qP * qF + (qP - 1) * qP %/ 2)%r / Support.card%r.\n  proof.\n  apply/(@ler_trans _ _ _ (pr &m)).\n  have: Pr[Exp'(C(A)).main() @ &m: Bad P.logP F.m]\n       <= (qP * qF + (qP - 1) * qP%/2)%r / Support.card%r\n    by byphoare Bad_bound.\n  smt().\n  qed.\nend section."
    },
    {
        "file": "EC-1/PrIntervalToSum.ec",
        "logic": "Here\u2019s a description of the protocol that could correspond to the provided EasyCrypt file:\n\n---\n\n### Protocol Description\n\n**Purpose**: This protocol aims to analyze the probabilistic behavior of a certain computation defined in the context of a module, denoted as `A`. The focus is on the probability distribution of a function `f`, which maps a global state to an integer, under the execution of a procedure `run` with a given input.\n\n**Types Used**:\n- `rt`: A type representing the return type of the protocol.\n- `iat`: A type representing the input type for the procedure.\n\n**Module Definition**: The protocol defines a module type `RunMain`, which requires the implementation of a procedure `run` that takes an input of type `iat` and returns a result of type `rt`.\n\n**Key Lemmas**:\n1. **`pr_interval_to_sum_lemma'`**: This lemma establishes that the probability of the function `f` falling within a specified interval `[s, s + e]` can be expressed as a sum of probabilities for discrete values within that range. It utilizes the principle of big summation over a predicate, indicating that the sum of probabilities can be decomposed based on the values of `f`.\n\n   - The lemma is structured to handle conditions where `0 <= e` and proves that the probability can be broken down into two components:\n     - The probability that `f` equals a specific integer `i` within the interval.\n     - The condition `P a res (glob A)` ensures that the result satisfies a certain property.\n\n2. **`pr_interval_to_sum_lemma`**: This lemma extends the previous lemma to cover the case where the upper bound `e` may not be fixed. It states that the probability of `f` being within the interval defined by `s` and `e` can also be expressed as a sum over the range `[s, e]`.\n\n   - It handles cases where `s` may not be less than or equal to `e`, ensuring that the protocol can handle various scenarios of input values.\n\n**Section Usage**: The section encapsulates the declarations and lemmas that support the protocol's functionality. It is a structured environment where the necessary proofs and properties of the module `A` are established.\n\n**Probabilistic Reasoning**: The protocol heavily relies on probabilistic reasoning to analyze how often certain outcomes occur when executing the function `f`. This involves using techniques from measure theory and probability to break down complex expressions into simpler terms that can be computed or reasoned about.\n\n---",
        "code": "require import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, iat.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare module A <: RunMain.\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = big predT\n        (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ])\n        (range s (s + e + 1)).\nmove => a f P s. apply ge0ind.\nsmt().\nprogress . \nhave ->: Pr[A.run(a) @ &m : s <= f (glob A)  <= s /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : s  = f (glob A) /\\ P a res (glob A)].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: bigi predT \n              (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)]) \n              s (s + 1)\n       = Pr[A.run(a) @ &m : f (glob A) = s /\\ P a res (glob A) ].\nrewrite big_int1. auto. \nrewrite Pr[mu_eq]. auto. auto.\nprogress.\nhave ->: \n  Pr[A.run(a) @ &m : s <= f (glob A) <= s + (n + 1) /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ]\n = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A) ]\n + Pr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\nrewrite Pr[mu_disjoint]. progress. smt().\nauto.\nhave ->: bigi predT (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)] ) s (s + (n + 1) + 1)\n = Pr[A.run(a) @ &m : s <= f (glob A) <= s + n /\\ P a res (glob A)] +\nPr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A)].\nrewrite (big_int_recr). smt().  simplify.\nrewrite H0. auto. \nhave ->: (s + n + 1) = (s + (n + 1)).\nsmt().\nauto. auto.\nqed.\n\n\nlemma pr_interval_to_sum_lemma &m : forall (a : iat) \n  (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) \n  (s e : int),\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= e /\\ P a res (glob A) ]\n   = big predT\n      (fun i => Pr[ A.run(a) @ &m : f (glob A) = i \n                                   /\\ P a res (glob A) ])\n      (range s (e + 1)).\nproof. progress.\ncase (s <= e). move => sep.\nhave : exists e', 0 <= e' /\\ e = s + e'.\nexists (e - s). progress.\nsmt(). smt(). elim. progress.\napply (pr_interval_to_sum_lemma' &m a). auto. \nprogress.\nrewrite range_geq. smt(). \nrewrite big_nil.\nhave ->:  Pr[A.run(a) @ &m : (s <= f (glob A) && f (glob A) <= e) /\\ P a res (glob A)]\n = Pr[A.run(a) @ &m : false ].\nrewrite Pr[mu_eq]. smt(). auto.\nrewrite Pr[mu_false]. auto.\nqed.\n\nend section.",
        "codenote": "require import AllCore Distr FSet StdRing StdOrder StdBigop List.\n(*---*) import RField RealOrder Bigreal BRA. \nrequire import Int. \n\ntype rt, iat.\n\nmodule type RunMain = {\n  proc run(i:iat) : rt\n}.\n\nsection.\n\ndeclare module A <: RunMain.\n\n(* \n   Lemma: pr_interval_to_sum_lemma' states that for a given\n   interval [s, s + e], the probability of A.run(a) \n   being in this interval can be expressed as the sum \n   of probabilities for specific discrete outcomes of f(glob A).\n*)\nlocal lemma pr_interval_to_sum_lemma' &m : forall (a : iat) (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) (s e : int),\n  0 <= e =>\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= s + e /\\ P a res (glob A) ]\n  = big predT\n        (fun i => Pr[ A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A) ])\n        (range s (s + e + 1)).\nmove => a f P s. apply ge0ind.\nsmt().\nprogress . \nhave ->: Pr[A.run(a) @ &m : s <= f (glob A)  <= s /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : s  = f (glob A) /\\ P a res (glob A)].\n\n(* \n   Rewrite step: applying the definition to simplify the probability expression\n*)\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: bigi predT \n              (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)]) \n              s (s + 1)\n       = Pr[A.run(a) @ &m : f (glob A) = s /\\ P a res (glob A) ].\nrewrite big_int1. auto. \nrewrite Pr[mu_eq]. auto. auto.\nprogress.\nhave ->: \n  Pr[A.run(a) @ &m : s <= f (glob A) <= s + (n + 1) /\\ P a res (glob A)]\n  = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\n\n(* \n   Rewrite step: combining the expressions to express the total probability\n*)\nrewrite Pr[mu_eq]. smt(). auto.\nhave ->: Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A)\n          \\/ f (glob A) = s + (n + 1) /\\ P a res (glob A) ]\n = Pr[A.run(a) @ &m : (s <= f (glob A) <= s + n) /\\ P a res (glob A) ]\n + Pr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A) ].\n\n(* \n   Using the properties of disjoint events to factor the sum into\n   two components.\n*)\nrewrite Pr[mu_disjoint]. progress. smt().\nauto.\nhave ->: bigi predT (fun (i : int) => Pr[A.run(a) @ &m : f (glob A) = i /\\ P a res (glob A)] ) s (s + (n + 1) + 1)\n = Pr[A.run(a) @ &m : s <= f (glob A) <= s + n /\\ P a res (glob A)] +\nPr[A.run(a) @ &m : f (glob A) = s + (n + 1) /\\ P a res (glob A)].\nrewrite (big_int_recr). smt().  simplify.\nrewrite H0. auto. \nhave ->: (s + n + 1) = (s + (n + 1)).\nsmt().\nauto. auto.\nqed.\n\n\nlemma pr_interval_to_sum_lemma &m : forall (a : iat) \n  (f : (glob A) -> int) \n  (P : iat -> rt -> (glob A) -> bool) \n  (s e : int),\n  Pr[ A.run(a) @ &m : s <= f (glob A) <= e /\\ P a res (glob A) ]\n   = big predT\n      (fun i => Pr[ A.run(a) @ &m : f (glob A) = i \n                                   /\\ P a res (glob A) ])\n      (range s (e + 1)).\nproof. progress.\ncase (s <= e). move => sep.\nhave : exists e', 0 <= e' /\\ e = s + e'.\nexists (e - s). progress.\nsmt(). smt(). elim. progress.\napply (pr_interval_to_sum_lemma' &m a). auto. \nprogress.\nrewrite range_geq. smt(). \nrewrite big_nil.\n\n(* \n   When the range is nil, we expect the probability to evaluate to zero,\n   which matches the definition.\n*)\nhave ->:  Pr[A.run(a) @ &m : (s <= f (glob A) && f (glob A) <= e) /\\ P a res (glob A)]\n = Pr[A.run(a) @ &m : false ].\nrewrite Pr[mu_eq]. smt(). auto.\nrewrite Pr[mu_false]. auto.\nqed.\n\nend section."
    },
    {
        "file": "EC-1/SchnorrPK.ec",
        "logic": "---\n\n### Description of the Schnorr Proof of Knowledge Protocol\n\n#### Overview\nThe Schnorr proof of knowledge is a cryptographic protocol that allows one party (the prover) to demonstrate knowledge of a secret without revealing the secret itself. This protocol falls under the category of Sigma protocols, which are characterized by their completeness, soundness, and zero-knowledge properties.\n\n#### Components\n1. **Types**:\n   - **Statement**: A group element `h` that serves as a public commitment.\n   - **Witness**: A secret `w`, representing the knowledge of the prover.\n   - **Message**: A group element `a` generated during the commitment phase.\n   - **Secret**: A random value `r` used in the commitment phase.\n   - **Challenge**: A random value `e` generated by the verifier.\n   - **Response**: A computed value `z` that proves knowledge of the witness.\n\n2. **Operations**:\n   - `R_DL`: A relation that verifies if `h` equals `g^w` for a given secret `w`.\n\n#### Protocol Steps\n1. **Key Generation (`gen`)**:\n   - The prover generates a secret `w` (ensuring it is non-zero) and computes `h = g^w`, returning the pair `(h, w)`.\n\n2. **Commitment (`commit`)**:\n   - The prover generates a random value `r` and computes `a = g^r`, returning the pair `(a, r)`.\n\n3. **Challenge Generation (`test`)**:\n   - The verifier generates a random challenge `e`.\n\n4. **Response (`respond`)**:\n   - The prover computes the response `z = r + e * w` based on the secret `w` and the random value `r`.\n\n5. **Verification (`verify`)**:\n   - The verifier checks if the equation `v = a * (h^e)` is equivalent to `v' = g^z` to confirm the validity of the proof.\n\n#### Security Properties\n1. **Completeness**: If the prover follows the protocol honestly, the verifier will always accept the proof.\n2. **Special Soundness**: If two valid transcripts with different challenges are given, one can extract the witness (i.e., the secret).\n3. **Special Honest Verifier Zero Knowledge (SHVZK)**: For any efficient distinguisher, the distribution of the real interaction is indistinguishable from that of a simulation, demonstrating that no knowledge about the secret is leaked.\n\n#### EasyCrypt Implementation\nThe protocol is implemented using the EasyCrypt tool, which provides a formal framework for cryptographic proofs. The types and operations are defined within the `SchnorrTypes` theory, and the Sigma protocol is instantiated in the `SchnorrPK` module. The security properties are verified in the `SchnorrPKSecurity` section, which includes lemmas proving completeness, special soundness, and zero-knowledge.\n\n---",
        "code": "(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.\n  type witness      = F.t.\n  type message      = group.\n  type secret       = F.t.\n  type challenge    = F.t.\n  type response     = F.t.\n\n  op R_DL h w       = (h = g^w).\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type SigmaProtocol.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge <- challenge,\n  type SigmaProtocol.response  <- response,\n  op   SigmaProtocol.R         = R_DL,\n  op   SigmaProtocol.de        = FDistr.dt.\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;\n    if (w = F.zero) { (* A loop would be better, however the support for while loops is poor *)\n      w <- -F.one;\n    }\n    h <- g^w;\n    return (h, w);\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;\n    a <- g^r;\n    return (a, r);\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;\n    return e;\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;\n    r <- snd ms;\n    z <- r + e*w;\n    return z;\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);\n    v' <- g^z;\n    return (v = v');\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));\n    v' <- (g^z' = a*(h^e'));\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');\n      sto <- Some(w);\n    } else {\n      sto <- None;\n    }\n\n    return sto;\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;\n    a  <- (g^z) * (h^(-e));\n\n    return (a, e, z);\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.\n  proof. by islossless; apply FDistr.dt_ll. qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n  (*  move : FDistr.dt_ll FDistr.dt_fu FDistr.dt1E; rewrite /is_full => dt_ll dt_fu dt_supp. *)\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk.",
        "codenote": "(* --------------------------------------------------------------------\n * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)\n *\n * Distributed under the terms of the CeCILL-B-V1 license\n * -------------------------------------------------------------------- *)\n\n(*\n * A formal verification of the Schnorr proof of knowledge\n *)\n\nrequire import Int.\nrequire import Real.\nrequire import Distr.\nrequire import CyclicGroup.\n\nrequire (*--*) SigmaProtocol.\n\n(* Schnorr protocol types *)\ntheory SchnorrTypes.\n  type statement    = group.  (* The statement is a group element representing a public key. *)\n  type witness      = F.t.    (* The witness is a scalar representing a secret. *)\n  type message      = group.   (* The message is a group element generated during the protocol. *)\n  type secret       = F.t.     (* The secret is a scalar used during commitment. *)\n  type challenge    = F.t.     (* The challenge is a scalar provided by the verifier. *)\n  type response     = F.t.     (* The response is a scalar provided by the prover. *)\n\n  op R_DL h w       = (h = g^w).  (* The relationship R_DL defines the relationship between public key h and secret w. *)\nend SchnorrTypes.\nexport SchnorrTypes.\n\n(* Instantiate the Sigma scheme with the above types *)\nclone import SigmaProtocol as SP with\n  type SigmaProtocol.statement <- statement,\n  type SigmaProtocol.witness   <- witness,\n  type SigmaProtocol.message   <- message,\n  type SigmaProtocol.secret    <- secret,\n  type SigmaProtocol.challenge  <- challenge,\n  type SigmaProtocol.response   <- response,\n  op   SigmaProtocol.R          = R_DL,  (* Redefines the relation R for the Sigma protocol. *)\n  op   SigmaProtocol.de         = FDistr.dt.  (* Distribution for operation in the protocol. *)\nexport SigmaProtocol.\n\nmodule SchnorrPK : SigmaScheme = {\n  proc gen() : statement * witness = {\n    var h, w;\n    w <$ FDistr.dt;  (* Sample a witness from the distribution. *)\n    if (w = F.zero) { \n      w <- -F.one;  (* Ensure the witness is non-zero. *)\n    }\n    h <- g^w;  (* Compute the public key h from witness w. *)\n    return (h, w);  (* Return the pair (h, w). *)\n  }\n\n  proc commit(h: statement, w: witness) : message * secret = {\n    var r, a;\n    r <$ FDistr.dt;  (* Randomly sample r from the distribution. *)\n    a <- g^r;  (* Generate the commitment a using r. *)\n    return (a, r);  (* Return the pair (a, r). *)\n  }\n\n  proc test(h: statement, a: message) : challenge = {\n    var e;\n    e <$ FDistr.dt;  (* Sample a challenge e from the distribution. *)\n    return e;  (* Return e. *)\n  }\n\n  proc respond(sw: statement * witness, ms: message * secret, e: challenge) : response = {\n    var z, w, r;\n    w <- snd sw;  (* Extract witness w from sw. *)\n    r <- snd ms;  (* Extract secret r from ms. *)\n    z <- r + e*w;  (* Compute response z based on e and w. *)\n    return z;  (* Return the response z. *)\n  }\n\n  proc verify(h: statement, a: message, e: challenge, z: response) : bool = {\n    var v, v';\n    v <- a*(h^e);  (* Compute the expected value v from the challenge. *)\n    v' <- g^z;     (* Compute the expected value v' from the response. *)\n    return (v = v');  (* Check if the computed values are equal. *)\n  }\n}.\n\nmodule SchnorrPKAlgorithms : SigmaAlgorithms = {\n  proc soundness(h: statement, a: message, e: challenge, z: response, e': challenge, z': response) : witness option = {\n    var sto, w, v, v';\n\n    v  <- (g^z  = a*(h^e ));  (* Check the validity of the response z. *)\n    v' <- (g^z' = a*(h^e'));  (* Check the validity of the response z'. *)\n    if (e <> e' /\\ v /\\ v') {\n      w <- (z - z') / (e - e');  (* Extract witness if the responses are valid. *)\n      sto <- Some(w);  (* Wrap w in an option to indicate a valid witness. *)\n    } else {\n      sto <- None;  (* No valid witness if checks fail. *)\n    }\n\n    return sto;  (* Return the witness if found. *)\n  }\n\n  proc simulate(h: statement, e: challenge) : message * challenge * response = {\n    var a, z;\n\n    z  <$ FDistr.dt;  (* Sample z from the distribution. *)\n    a  <- (g^z) * (h^(-e));  (* Simulate the commitment a given challenge e. *)\n\n    return (a, e, z);  (* Return simulated values. *)\n  }\n}.\n\nsection SchnorrPKSecurity.\n  (* Completeness *)\n  lemma schnorr_proof_of_knowledge_completeness_ll:\n    islossless Completeness(SchnorrPK).main.  (* Completeness of the protocol. *)\n  proof. \n    by islossless; apply FDistr.dt_ll. \n  qed.\n\n  lemma schnorr_proof_of_knowledge_completeness h w' &m:\n    R h w' =>  (* Completeness lemma. *)\n    Pr[Completeness(SchnorrPK).main(h, w') @ &m : res] = 1%r.\n  proof.\n    rewrite /R /R_DL; move => sigmarel.\n    byphoare (_: h = x /\\ w' = w ==> _) => //; rewrite sigmarel.\n    proc; inline*; swap 3 -2; swap 8 -7.\n    wp; rewrite /snd /=; auto => &hr />.\n    rewrite FDistr.dt_ll => /> *; algebra.\n  qed.\n\n  (* Special soundness *)\n  lemma schnorr_proof_of_knowledge_special_soundness (h: statement) msg ch ch' r r' &m:\n    ch <> ch' =>  (* Soundness lemma. *)\n    g^r  = msg*(h^ch ) =>\n    g^r' = msg*(h^ch') =>\n    Pr[SpecialSoundnessExperiment(SchnorrPK, SchnorrPKAlgorithms).main(h, msg, ch, r, ch', r') @ &m : (res <> None /\\ R h (oget res))] = 1%r.\n  proof.\n    move => challenges_differ\n            accepting_transcript_1\n            accepting_transcript_2.\n    byphoare (_: h = x /\\ msg = m /\\ ch = e /\\ ch' = e' /\\ r = z /\\ r' = z' ==> _) => //.\n    proc; simplify; inline*.\n    auto; rewrite /R /R_DL /oget => &hr /> hne 2!-> /=.\n    rewrite F.div_def -pow_pow F.sub_def -mul_pow pow_opp log_bij.\n    rewrite accepting_transcript_1 accepting_transcript_2 !(log_gpow, log_pow, log_mul, inv_def). \n    by field; apply: contra hne => heq; ring heq.\n  qed.\n\n  (* Special honest verifier zero knowledge *)\n  lemma schnorr_proof_of_knowledge_shvzk (D<: SigmaTraceDistinguisher) &m:\n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameIdeal() @ &m : res] = \n    Pr[SimulateHonestVerifier(SchnorrPK, SchnorrPKAlgorithms, D).gameReal() @ &m : res].\n  proof.\n    byequiv => //.\n    proc; inline*.\n    seq 27 22: ((glob D){1} = (glob D){2} /\\ i{1} = 0 /\\ x{1} = h{1} /\\ x{2} = h{2} /\\ \n                 to{1} = Some t{2} /\\ ={h, w, e}).\n    + swap{1} 15 -7; swap{2} 12 -5; swap{1} 11 -3; wp.\n      (* Let's play with randomness... *)\n      rnd (fun z, z - w{1}*e{1}) (fun r, r + w{1}*e{1}).\n      by seq 2 2 : (#pre  /\\ ={w0}); auto => />; progress;algebra.\n    by call (_:true); rcondf{1} 1; auto.\n  qed.\n  (* The above three theorems prove that the Schnorr proof of knowledge is a Sigma protocol *)\n\nend section SchnorrPKSecurity.\n\nprint schnorr_proof_of_knowledge_completeness.\nprint schnorr_proof_of_knowledge_special_soundness.\nprint schnorr_proof_of_knowledge_shvzk."
    },
    {
        "file": "EC-1/cramer_shoup.ec",
        "logic": "### Protocol Description: Cramer-Shoup Encryption Scheme and Security Analysis\n\n#### 1. Overview\nThe Cramer-Shoup encryption scheme is a public-key cryptographic system that provides security against chosen-ciphertext attacks (CCA). This protocol specifies its construction, correctness, and security proofs, particularly in the context of the Decisional Diffie-Hellman (DDH) assumption and Target Collision Resistance (TCR).\n\n#### 2. Preliminaries\n- **Cryptographic Assumptions**: The protocol relies on the Decisional Diffie-Hellman (DDH) assumption, which states that given \\( g^a, g^b \\), it is hard to distinguish \\( g^{ab} \\) from \\( g^c \\) for random \\( c \\).\n- **Randomness and Distributions**: The protocol uses a random distribution mechanism for generating keys and random values during encryption and decryption processes.\n\n#### 3. Key Generation\nThe key generation process outputs a public key and a secret key:\n- Randomly select values \\( x_1, x_2, y_1, y_2, z_1, z_2, k \\).\n- Compute the public key \\( pk = (k, g, g^{w}, g^{x_1} g^{w}^{x_2}, g^{y_1} g^{w}^{y_2}, g^{z_1} g^{w}^{z_2}) \\) and the secret key \\( sk = (k, g, g^{w}, x_1, x_2, y_1, y_2, z_1, z_2) \\).\n\n#### 4. Encryption\nThe encryption process takes a public key and a plaintext message to generate a ciphertext:\n- Randomly select \\( u \\).\n- Compute \\( a = g^u, a' = g^w^u \\) and \\( c = h^u \\times m \\).\n- Calculate the hash \\( v = H(k, (a, a', c)) \\).\n- Generate the ciphertext \\( (a, a', c, d) \\) where \\( d = e^u \\times f^{(u \\cdot v)} \\).\n\n#### 5. Decryption\nThe decryption process retrieves the plaintext from the ciphertext using the secret key:\n- Compute the hash \\( v = H(k, (a, a', c)) \\).\n- Verify if \\( d \\) is equal to the expected value based on the secret key values.\n- If valid, return the plaintext \\( m = c / (a^{z_1} \\times a'^{z_2}) \\); otherwise, return None.\n\n#### 6. Correctness and Security\n- **Correctness Lemma**: Proves that the decryption process correctly recovers the plaintext for valid ciphertexts.\n- **IND-CCA Security**: It is shown that the scheme remains secure under adaptive chosen-ciphertext attacks by deriving a series of inequalities that relate the success probability of adversaries against the Cramer-Shoup scheme to their success against the underlying DDH assumption.\n\n#### 7. Adversary Models\n- **CCA Adversary**: The protocol defines an adversarial model for chosen-ciphertext attacks, where the adversary can make decryption queries and needs to be indistinguishable from random.\n- **Security Reduction**: The security proofs utilize a series of reductions to show that if an adversary can break CCA security, then a corresponding adversary can solve the underlying DDH problem.\n\n#### 8. Conclusion\nThis protocol specification provides a formal framework for the Cramer-Shoup encryption scheme, demonstrating its robustness against chosen-ciphertext attacks while leveraging the security properties of the DDH assumption and TCR. The formal proofs within the EasyCrypt framework ensure rigorous validation of the scheme's security claims.\n\n---",
        "code": "require import AllCore List Distr Dexcepted PKE.\nrequire import StdOrder StdBigop.\nimport RField RealOrder Bigreal.\n\nrequire TCR RndExcept.\n\n(** DiffieHellman *)\nrequire DiffieHellman.\nclone DiffieHellman as DH.\nimport DH.DDH DH.G DH.GP DH.FD DH.GP.ZModE.\n\nclone DH.GP.ZModE.ZModpField as ZPF.\n\nlemma gt1_q : 1 < order by smt(ge2_p).\n\ntheory Ad1.\n\n  clone import RndExcept as RndE with\n    type input <- unit,\n    type t     <- exp,\n    op   d     <- fun _ => dt,\n    type out   <- bool\n    proof *.\n    realize d_ll. move=> _;apply dt_ll. qed.\n\n  clone include Adversary1_1 with\n    op n <- order\n    proof *.\n  realize gt1_n by apply gt1_q.\n  realize d_uni.\n  proof.\n  move=> _ x; rewrite dt1E.\n  suff: size elems = size elems by smt().\n  apply uniq_size_uniq; rewrite ?elems_uniq.\n  by smt(elemsP elemsP).\n  qed.\n\nend Ad1.\n\ntheory DDH_ex.\n\n  module DDH0_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y;\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  module DDH1_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y, z;\n\n      x <$ dt \\ (pred1 zero);\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  section PROOFS.\n\n  declare module A <: Adversary.\n\n  declare axiom A_ll : islossless A.guess.\n\n  local module Addh0 : Ad1.ADV = {\n    proc a1 () = { return ((), zero); }\n    proc a2 (x : exp) = {\n      var b, y;\n      y <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y));\n      return b;\n    }\n  }.\n\n  local module Addh1 = {\n    proc a1 = Addh0.a1\n    proc a2 (x : exp) = {\n      var b, y, z;\n      y <$ dt;\n      z <$ dt;\n      b <@ A.guess(g ^ x, g ^ y, g ^ z);\n      return b;\n    }\n  }.\n\n  local lemma a1_ll : islossless Addh0.a1.\n  proof. proc;auto. qed.\n\n  lemma adv_DDH_DDH_ex &m :\n     `| Pr[DDH0_ex(A).main()@ &m : res] - Pr[DDH1_ex(A).main()@ &m : res] | <=\n     `| Pr[DDH0(A).main()@ &m : res] - Pr[DDH1(A).main()@ &m : res] | + 2%r / order%r.\n  proof.\n    have /= H0 := Ad1.pr_abs Addh0 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;rnd;skip;rewrite /= dt_ll.\n    have /= H1 := Ad1.pr_abs Addh1 a1_ll _ &m (fun b _ => b).\n    + by proc;call A_ll;do !rnd;skip;rewrite /= dt_ll.\n    have -> : 2%r / order%r = inv order%r + inv order%r.\n    + field;smt (gt0_order lt_fromint).\n    have <- : Pr[Ad1.MainE(Addh0).main() @ &m : res] = Pr[DDH0_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.MainE(Addh1).main() @ &m : res] = Pr[DDH1_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.Main(Addh0).main() @ &m : res] = Pr[DDH0(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- /# : Pr[Ad1.Main(Addh1).main() @ &m : res] = Pr[DDH1(A).main() @ &m : res].\n    by byequiv => //;proc;inline *;sim;auto.\n  qed.\n\n  end section PROOFS.\n\nend DDH_ex.\nimport DDH_ex.\n\n(** Target Collision Resistant *)\n\nclone import TCR as TCR_H with\n  type t_from <- group * group * group,\n  type t_to   <- exp.\n\naxiom dk_ll : is_lossless dk.\nhint exact random : dk_ll.\n\n(** Cramer Shoup Encryption *)\n\nclone import PKE as PKE_ with\n   type pkey = K * group * group * group * group * group,\n   type skey = K * group * group * exp * exp * exp * exp * exp * exp,\n   type plaintext = group,\n   type ciphertext = group * group * group * group.\n\nmodule CramerShoup : Scheme = {\n  proc kg() : pkey * skey = {\n    var x1, x2, y1, y2, z1, z2, k, w, g_, pk, sk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    w  <$ dt \\ (pred1 zero);\n    k  <$ dk;\n    g_ <- g ^ w;\n    pk <- (k, g, g_, g ^ x1 * g_ ^ x2, g ^ y1 * g_ ^ y2, g ^ z1 * g_ ^ z2);\n    sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    return (pk, sk);\n  }\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var k, g, g_, e, f, h, u, a, a_, c, v, d;\n    (k, g, g_, e, f, h) <- pk;\n    u <$ dt;\n    a <- g ^ u; a_ <- g_ ^ u;\n    c <- h ^ u * m;\n    v <- H k (a, a_, c);\n    d <- e ^ u * f ^ (u * v);\n    return (a, a_, c, d);\n  }\n\n  proc dec(sk : skey, ci : ciphertext) = {\n    var k, g, g_, x1, x2, y1, y2, z1, z2, a, a_, c, d, v;\n    (k, g, g_, x1, x2, y1, y2, z1, z2) <- sk;\n    (a, a_, c, d) <- ci;\n    v <- H k (a, a_, c);\n    return (if d = a ^ (x1 + v * y1) * a_ ^ (x2 + v * y2) then Some (c / (a ^ z1 * a_ ^ z2))\n            else None);\n  }\n\n}.\n\n(** Correctness of the scheme *)\n\nhoare CramerShoup_correct : Correctness(CramerShoup).main : true ==> res.\nproof.\n  proc;inline *;auto => /> &m1 x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ w Hw k _ u _.\n  have -> /=: (g ^ x1 * g ^ w ^ x2) ^ u *\n    (g ^ y1 * g ^ w ^ y2) ^\n    (u * H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1})) =\n    g ^ u ^\n    (x1 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y1) *\n    g ^ w ^ u ^\n    (x2 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y2).\n  + rewrite log_bij !(logg1, logrzM, logDr); ring.\n  by rewrite log_bij -div_def !(logg1, logrzM, logDr); ring.\nqed.\n\n(** IND-CCA Security of the scheme *)\n\nmodule B_DDH (A:CCA_ADV) = {\n\n  module CCA = CCA(CramerShoup, A)\n\n  proc guess(gx gy gz:group): bool = {\n    var g_, a, a_, x1,x2,y1,y2,z1,z2,k,e,f,h,m0,m1,b,b',c,v,d,c',pk;\n    x1 <$ dt;\n    x2 <$ dt;\n    y1 <$ dt;\n    y2 <$ dt;\n    z1 <$ dt;\n    z2 <$ dt;\n    g_ <- gx;\n    a  <- gy;\n    a_ <- gz;\n    k  <$ dk;\n    e  <- g^x1 * g_^x2;\n    f  <- g^y1 * g_^y2;\n    h  <- g^z1 * g_^z2;\n    CCA.log <- [];\n    CCA.cstar <- None;\n    pk <- (k, g, g_, g^x1 * g_^x2, g^y1 * g_^y2, g^z1 * g_^z2);\n    CCA.sk <- (k, g, g_, x1, x2, y1, y2, z1, z2);\n    (m0,m1) <@ CCA.A.choose(pk);\n    b <$ {0,1};\n    c <- a^z1 * a_^z2 * (b ? m1 : m0);\n    v <- H k (a,a_,c);\n    d <- a^(x1 + v*y1) * a_^(x2+v*y2);\n    c' <- (a,a_,c,d);\n    CCA.cstar <- Some c';\n    b' <@ CCA.A.guess(c');\n    return (b = b');\n  }\n}.\n\n module B_TCR (A:CCA_ADV) = {\n    var log   : ciphertext list\n    var cstar : ciphertext option\n    var g3    : ( group * group * group) option\n    var g_, a, a_, c, d : group\n    var w, u , u', x, y, z, alpha, v' : exp\n    var k : K\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> cstar) {\n          log <- ci :: log;\n          (a,a_,c,d) <- ci;\n          v <- H k (a, a_, c);\n          if (a_ <> a^w /\\ v = v' /\\ (a,a_,c) <> (B_TCR.a, B_TCR.a_,B_TCR.c)) g3 <- Some (a,a_,c);\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A (O)\n\n    proc c1() = {\n      var r';\n      log <- [];\n      g3 <- None;\n      cstar <- None;\n      w <$ dt \\ (pred1 zero);\n      u <$ dt;\n      u' <$ dt \\ (pred1 u);\n      g_ <- g ^ w;\n      a <- g^u; a_ <- g_^u';\n      r' <$ dt; c <- g^r';\n      return (a, a_, c);\n    }\n\n    proc c2 (k:K) = {\n      var m0, m1, b0, e, f, h, r;\n      B_TCR.k <- k;\n      y <$ dt; f <- g^y;\n      z <$ dt; h <- g^z;\n      v' <- H k (a, a_, c);\n      x <$ dt; r <$ dt; e <- g^x;\n      alpha <- (r - u*(x + v'*y))/ (w*(u'-u));\n      d <- g ^ r;\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h);\n      cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      return (oget g3);\n    }\n  }.\n\nlemma CCA_dec_ll (A<:CCA_ADV) : islossless CCA(CramerShoup, A).O.dec.\nproof. islossless. qed.\n\nsection Security_Aux.\n\n  declare module A <: CCA_ADV {-CCA, -B_TCR}.\n  declare axiom guess_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).guess.\n  declare axiom choose_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).choose.\n\n  equiv CCA_DDH0 : CCA(CramerShoup, A).main ~ DDH0_ex(B_DDH(A)).main : ={glob A} ==> ={res}.\n  proof.\n    proc;inline *;wp.\n    call (_: ={glob CCA}); 1: sim.\n    swap{1} 9 -8; swap{1} 20 -18; auto.\n    call (_: ={glob CCA}); 1: sim.\n    auto => &m1 &m2 /> w _ u _ x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ k _ r b _.\n    have -> :\n      H k\n       (g ^ u, g ^ w ^ u,\n        (g ^ z1 * g ^ w ^ z2) ^ u * if b then r.`2 else r.`1) =\n      H k\n       (g ^ u, g ^ (w * u),\n        g ^ u ^ z1 * g ^ (w * u) ^ z2 * if b then r.`2 else r.`1).\n    + by congr;congr;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    progress;\n      try by (rewrite log_bij !(logg1, logrzM, logDr); ring).\n    smt ().\n  qed.\n\n  lemma pr_CCA_DDH0 &m :\n    Pr[CCA(CramerShoup, A).main() @ &m : res] =\n    Pr[DDH0_ex(B_DDH(A)).main() @ &m : res].\n  proof. by byequiv CCA_DDH0. qed.\n\n  local module G1 = {\n    var log     : ciphertext list\n    var cstar   : ciphertext option\n    var bad     : bool\n    var u,u',w  : exp\n    var x,x1,x2 : exp\n    var y,y1,y2 : exp\n    var z,z1,z2 : exp\n    var g_: group\n    var k       : K\n\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> G1.cstar) {\n          log <- ci :: log;\n          (a,a_,c,d) <- ci;\n          v <- H k (a, a_, c);\n          bad <- bad \\/ (a_ <> a^w /\\ d = a ^ (x1 + v*y1) * a_ ^ (x2 + v * y2));\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A(O)\n\n    proc a1 () = {\n      log <- [];\n      cstar <- None;\n      bad <- false;\n      w <$ dt \\ (pred1 zero);\n      u <$ dt;\n      return ((),u);\n    }\n\n    proc a2 (u0' : exp) = {\n      var m0, m1, b, b0, a, a_, c, d, v, e, f, h;\n      u' <- u0';\n      g_ <- g ^ w; k  <$ dk;\n      a <- g^u; a_ <- g_^u';\n      x <$ dt; x2 <$ dt; x1 <- x - w * x2; e <- g^x;\n      y <$ dt; y2 <$ dt; y1 <- y - w * y2; f <- g^y;\n      z <$ dt; z2 <$ dt; z1 <- z - w * z2; h <- g^z;\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h);\n      b <$ {0,1};\n      c <- a^z1 * a_^z2 * (b ? m1 : m0);\n      v <- H k (a, a_, c);\n      d <- a^(x1 + v*y1) * a_^(x2+v*y2);\n      cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      return (b = b0);\n    }\n  }.\n\n  local equiv DDH1_G1_dec :\n    CCA(CramerShoup, A).O.dec ~ G1.O.dec :\n    ( !G1.bad{2} /\\ c{1} = ci{2} /\\\n      (G1.x{2} = G1.x1{2} + G1.w{2} * G1.x2{2} /\\\n       G1.y{2} = G1.y1{2} + G1.w{2} * G1.y2{2} /\\\n       G1.z{2} = G1.z1{2} + G1.w{2} * G1.z2{2}) /\\\n       CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n       CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})) ==>\n    (!G1.bad{2} =>\n       ={res} /\\\n       (G1.x{2} = G1.x1{2} + G1.w{2} * G1.x2{2} /\\\n        G1.y{2} = G1.y1{2} + G1.w{2} * G1.y2{2} /\\\n        G1.z{2} = G1.z1{2} + G1.w{2} * G1.z2{2}) /\\\n       CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n       CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n  proof.\n    proc;sp 0 1;inline *;if => //;auto.\n    move=> &m1 &m2 /> _ /=;rewrite negb_and /=.\n    case: (ci{m2}) => a a_ c d => /=.\n    case: (a_ = a ^ G1.w{m2}) => [ -> _ _ | _ _ _ -> ] //=.\n    have -> :\n      a ^ (G1.x1{m2} + H G1.k{m2} (a, a ^ G1.w{m2}, c) * G1.y1{m2}) *\n      a ^ G1.w{m2} ^ (G1.x2{m2} + H G1.k{m2} (a, a ^ G1.w{m2}, c) * G1.y2{m2}) =\n      a ^ (G1.x1{m2} + G1.w{m2} * G1.x2{m2} +\n           H G1.k{m2} (a, a ^ G1.w{m2}, c) * (G1.y1{m2} + G1.w{m2} * G1.y2{m2})).\n    + by rewrite log_bij !(logg1, logrzM, logDr); ring.\n    have -> // : a ^ G1.z1{m2} * a ^ G1.w{m2} ^ G1.z2{m2} =\n                 a ^ (G1.z1{m2} + G1.w{m2} * G1.z2{m2}).\n    by rewrite log_bij !(logg1, logrzM, logDr); ring.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec.\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r.\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}.\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  lemma dt_r_ll x : is_lossless (dt \\ pred1 x).\n  proof.\n    by rewrite dexcepted_ll ?dt_ll // dt1E ltr_pdivr_mulr /= lt_fromint; smt (gt1_q).\n  qed.\n\n  local lemma aux1 &m :\n    Pr[CCA(CramerShoup, A).main() @ &m : res] <=\n       `| Pr[DDH0(B_DDH(A)).main() @ &m : res] - Pr[DDH1(B_DDH(A)).main() @ &m : res] |\n    + Pr[Ad1.MainE(G1).main() @ &m : res \\/ G1.bad] + 3%r/order%r.\n  proof.\n    have -> :\n     Pr[CCA(CramerShoup, A).main() @ &m : res] = Pr[DDH0_ex(B_DDH(A)).main() @ &m : res].\n    + byequiv CCA_DDH0 => //.\n    have := adv_DDH_DDH_ex (B_DDH(A)) _ &m.\n    + proc;call (guess_ll (<:CCA(CramerShoup,A).O) (CCA_dec_ll A));auto.\n      call (choose_ll (<:CCA(CramerShoup,A).O) (CCA_dec_ll A));auto => /=.\n      by rewrite dt_ll  DBool.dbool_ll dk_ll.\n    have : Pr[DDH1_ex(B_DDH(A)).main() @ &m : res] <=\n           Pr[Ad1.Main(G1).main() @ &m : res \\/ G1.bad].\n    + byequiv DDH1_G1 => //;1: smt ().\n    (* print glob G1. *)\n    have /= := Ad1.pr_abs G1 _ _ &m (fun (b:bool) (x : glob G1) => b \\/ x.`2).\n    + proc;auto => />; by rewrite dt_r_ll ?dt_ll.\n    + proc;auto;call (guess_ll (<:G1.O) G1_dec_ll);auto.\n      by call (choose_ll (<:G1.O) G1_dec_ll);auto; rewrite dk_ll  dt_ll DBool.dbool_ll.\n    smt (mu_bounded).\n  qed.\n\n  local module G2 = {\n\n    module O = G1.O\n\n    module A = G1.A\n\n    var alpha, v: exp\n\n    proc main1 () = {\n      var m0, m1, b, b0, v, e, f, h, r', a, a_, c, d;\n      G1.log <- [];\n      G1.cstar <- None;\n      G1.bad <- false;\n      G1.w <$ dt \\ (pred1 zero);\n      G1.u <$ dt;\n      G1.u' <$ dt \\ (pred1 G1.u);\n      G1.g_ <- g ^ G1.w; G1.k  <$ dk;\n      a <- g^G1.u; a_ <- G1.g_^G1.u';\n      G1.x <$ dt; G1.x2 <$ dt; G1.x1 <- G1.x - G1.w * G1.x2; e <- g^G1.x;\n      G1.y <$ dt; G1.y2 <$ dt; G1.y1 <- G1.y - G1.w * G1.y2; f <- g^G1.y;\n      G1.z <$ dt; h <- g^G1.z;\n      (m0,m1) <@ A.choose(G1.k, g, G1.g_, e, f, h);\n      b <$ {0,1};\n      r' <$ dt;\n      c <- g^r';\n      v <- H G1.k (a, a_, c);\n      d <- a^(G1.x1 + v*G1.y1) * a_^(G1.x2+v*G1.y2);\n      G1.cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      return (b = b0);\n    }\n\n    proc main () = {\n      var m0, m1, b, b0, e, f, h, r, r', a, a_, c, d;\n      G1.log <- [];\n      G1.cstar <- None;\n      G1.bad <- false;\n      G1.w <$ dt \\ (pred1 zero);\n      G1.u <$ dt;\n      G1.u' <$ dt \\ (pred1 G1.u);\n      G1.g_ <- g ^ G1.w; G1.k  <$ dk;\n      a <- g^G1.u; a_ <- G1.g_^G1.u';\n      G1.y <$ dt; G1.y2 <$ dt; G1.y1 <- G1.y - G1.w * G1.y2; f <- g^G1.y;\n      G1.z <$ dt; r' <$ dt; h <- g^G1.z;\n      c <- g^r';\n      v <- H G1.k (a, a_, c);\n      G1.x <$ dt; r <$ dt;\n      alpha <- (r - G1.u*(G1.x + v*G1.y))/ (G1.w*(G1.u'-G1.u));\n      G1.x2 <- alpha - v*G1.y2;\n      G1.x1 <- G1.x - G1.w * G1.x2; e <- g^G1.x;\n      d <- g ^ r;\n      (m0,m1) <@ A.choose(G1.k, g, G1.g_, e, f, h);\n      G1.cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      b <$ {0,1};\n      return (b = b0);\n    }\n  }.\n\n  local equiv G1_G21 : Ad1.MainE(G1).main ~ G2.main1 : ={glob A} ==> ={res, G1.bad}.\n  proof.\n    proc;inline *;wp.\n    call (_: ={G1.bad, G1.cstar, G1.log, G1.x, G1.x1, G1.x2, G1.y,\n               G1.y1, G1.y2, G1.z, G1.w, G1.k}).\n    + by sim => />.\n    swap{1} [23..24] 3;wp => /=.\n    rnd  (fun z2 => G1.u*G1.z - G1.u*G1.w*z2 + G1.w*G1.u'* z2 + loge (b ? m1 : m0)){1}\n         (fun r' => (r' - G1.u*G1.z - loge (b ? m1 : m0)) / (G1.w * (G1.u' - G1.u))){1}.\n    rnd.\n    call (_: ={G1.bad, G1.cstar, G1.log, G1.x, G1.x1, G1.x2, G1.y,\n               G1.y1, G1.y2, G1.z, G1.w, G1.k}).\n    + by sim => />.\n    auto => &m1 &m2 />;rewrite /pred1.\n    move=> wL /supp_dexcepted [] _ /= HwL uL _ u'L /supp_dexcepted [] _ /= Hu'L .\n    move=> kL _ xL _ x2L _ yL _ y2L _ zL _ resu bL _.\n    have H1 : (-uL) * wL + u'L * wL = wL * (u'L - uL) by ring.\n    have H2 : (-uL) * wL + u'L * wL <> zero.\n    + rewrite H1 ZPF.mulf_eq0 negb_or HwL /=.\n      by move: Hu'L;apply: contra => H;ring H.\n    split => [? _ | _ ]; 1: by field.\n    move=> z2L _; split => [ | _]; 1: by field.\n    pose HH1 := H _ _; pose HH2 := H _ _.\n    have -> : HH1 = HH2.\n    + rewrite /HH1 /HH2;do 2!congr.\n      by rewrite log_bij !(logg1, logrzM, logDr); ring.\n    progress; rewrite log_bij !(logg1, logrzM, logDr); field => //.\n  qed.\n\n  local equiv G21_G2 : G2.main1 ~ G2.main : ={glob A} ==> ={res, G1.bad}.\n  proof.\n    proc;inline *;wp. swap{2} -2.\n    call (_: ={G1.bad, G1.cstar, G1.log, G1.x, G1.x1, G1.x2, G1.y,\n               G1.y1, G1.y2, G1.z, G1.w, G1.k}).\n    + by sim => />.\n    wp;swap {1} [11..14] 6;swap{1} -7;rnd.\n    call (_: ={G1.bad, G1.cstar, G1.log, G1.x, G1.x1, G1.x2, G1.y,\n               G1.y1, G1.y2, G1.z, G1.w, G1.k}).\n    + by sim => />.\n    wp.\n    rnd (fun x2 => (x2 + G2.v*G1.y2) * (G1.w*(G1.u'-G1.u)) + G1.u*(G1.x + G2.v*G1.y)){2}\n        (fun r => (r - G1.u*(G1.x + G2.v*G1.y))/ (G1.w*(G1.u'-G1.u)) - G2.v*G1.y2){2}.\n    auto => &m1 &m2 />;rewrite /pred1.\n    move=> wL /supp_dexcepted [] _ /= HwL uL _ u'L /supp_dexcepted [] _ /= Hu'L .\n    move=> kL _ yL _ y2L _ zL _ r'L _ xL _.\n    have H1 : (-uL) * wL + u'L * wL = wL * (u'L - uL) by ring.\n    have H2 : (-uL) * wL + u'L * wL <> zero.\n    + rewrite H1 ZPF.mulf_eq0 negb_or HwL /=.\n      by move: Hu'L;apply: contra => H;ring H.\n    split => [? _ | _ ]; 1: by field.\n    move=> z2L _; split => [ | _]; 1: by field.\n    by progress;2..3:rewrite log_bij !(logg1, logrzM, logDr); field.\n  qed.\n\n  local lemma pr_G2_res &m: Pr[G2.main() @ &m : res] <= 1%r/2%r.\n  proof.\n    byphoare=> //;proc;rnd;conseq (_: _ ==> true) => //=.\n    by move=> ?;rewrite DBool.dbool1E.\n  qed.\n\n  local module G3 = {\n    var g3 : ( group * group * group) option\n    var y2log : exp list\n    var cilog : ciphertext list\n    var a, a_, c, d: group\n\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v, y2';\n        m <- None;\n        if (size G1.log < PKE_.qD && Some ci <> G1.cstar) {\n          cilog <- (G1.cstar = None) ? ci :: cilog : cilog;\n          G1.log <- ci :: G1.log;\n          (a,a_,c,d) <- ci;\n          v <- H G1.k (a, a_, c);\n          if (a_ <> a^G1.w) {\n            if (v = G2.v /\\ (a,a_,c) <> (G3.a,G3.a_,G3.c)) g3 <- Some (a,a_,c);\n            else {\n              y2' <- ((loge d - loge a*(G1.x + v*G1.y))/(loge a_ - loge a*G1.w) - G2.alpha) / (v -G2.v);\n              y2log <-  y2' :: y2log;\n            }\n          }\n          m <- if (a_ = a^G1.w /\\ d = a ^ (G1.x + v*G1.y)) then Some (c / a ^ G1.z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A (O)\n\n    proc main () = {\n      var m0, m1, b0, e, f, h, r, r';\n      G1.log <- [];\n      G3.y2log <- [];\n      G3.cilog <- [];\n      G3.g3 <- None;\n      G1.cstar <- None;\n      G1.w <$ dt \\ (pred1 zero);\n      G1.u <$ dt;\n      G1.u' <$ dt \\ (pred1 G1.u);\n      G1.g_ <- g ^ G1.w; G1.k  <$ dk;\n      a <- g^G1.u; a_ <- G1.g_^G1.u';\n      G1.y <$ dt; f <- g^G1.y;\n      G1.z <$ dt; r' <$ dt; h <- g^G1.z;\n      c <- g^r';\n      G2.v <- H G1.k (a, a_, c);\n      G1.x <$ dt; r <$ dt; e <- g^G1.x;\n      G2.alpha <- (r - G1.u*(G1.x + G2.v*G1.y))/ (G1.w*(G1.u'-G1.u));\n      d <- g ^ r;\n      (m0,m1) <@ A.choose(G1.k, g, G1.g_, e, f, h);\n      G1.cstar <- Some (a,a_,c,d);\n      b0 <@ A.guess(a,a_,c,d);\n      G1.y2 <$ dt;\n      G1.y1 <- G1.y - G1.w * G1.y2;\n      G1.x2 <- G2.alpha - G2.v*G1.y2;\n      G1.x1 <- G1.x - G1.w * G1.x2;\n    }\n  }.\n\n  local equiv G2_G3_dec :  G1.O.dec ~ G3.O.dec :\n    ! (G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog){2}  /\\\n    ={ci} /\\ ={G1.x, G1.y, G1.z, G1.x1, G1.x2, G1.y1, G1.y2, G1.log, G1.cstar, G1.w,\n               G1.u, G1.u', G1.k} /\\\n    (G1.cstar <> None => G1.cstar = Some (G3.a,G3.a_,G3.c,G3.d)){2} /\\\n    (G3.d = G3.a^(G1.x1 + G2.v*G1.y1) * G3.a_^(G1.x2+G2.v*G1.y2) /\\\n     G1.y1 = G1.y - G1.w * G1.y2 /\\\n     G1.x1 = G1.x - G1.w * G1.x2 /\\\n     G1.x2 = G2.alpha - G2.v * G1.y2){2} /\\\n    (G1.bad{1} => G1.y2{2} \\in G3.y2log{2}) ==>\n    !(G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog){2} =>\n     (={res} /\\ ={G1.x, G1.y, G1.z, G1.x1, G1.x2, G1.y1, G1.y2, G1.log, G1.cstar, G1.w,\n                 G1.u, G1.u', G1.k} /\\\n      (G1.cstar <> None => G1.cstar = Some (G3.a,G3.a_,G3.c,G3.d)){2} /\\\n      (G3.d = G3.a^(G1.x1 + G2.v*G1.y1) * G3.a_^(G1.x2+G2.v*G1.y2) /\\\n       G1.y1 = G1.y - G1.w * G1.y2 /\\\n       G1.x1 = G1.x - G1.w * G1.x2 /\\\n       G1.x2 = G2.alpha - G2.v * G1.y2){2} /\\\n      (G1.bad{1} => G1.y2{2} \\in G3.y2log{2})).\n  proof.\n    proc; auto => &m1 &m2 />.\n    case: (ci{m2}) => a a_ c d /=.\n    pose v := H _ _. rewrite !negb_or => [[]] Hg3 Hcilog Hstareq.\n    rewrite Hg3 /=.\n    case: (G1.bad{m1}) => [_ -> | ] //=.\n    move=> Hbad Hsize Hstar; rewrite !negb_and /= 2!negb_or /= -!andaE.\n    case (v = G2.v{m2}) => />.\n    + by case: (G1.cstar{m2}) Hstareq Hstar => />.\n    move=> Hv Ha _;left.\n    rewrite !(logg1, logrzM, logDr); field => //.\n    by move: Ha; apply: contra; move => H; rewrite log_bij logrzM; ring H.\n    by move: Hv; apply: contra => H; ring H.\n  qed.\n\n  local equiv G2_G3 : G2.main ~ G3.main :\n    ={glob A} ==>\n      !(G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog){2} =>\n      (G1.bad{1} => (G1.y2 \\in G3.y2log){2}).\n  proof.\n    proc.\n    swap{2} [28..29] -14. swap{2} [30..31] -4. rnd{1}.\n    call (_ : (G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog),\n               (={G1.x, G1.y, G1.z, G1.x1, G1.x2, G1.y1, G1.y2, G1.log, G1.cstar, G1.w,\n                  G1.u, G1.u', G1.k} /\\\n                (G1.cstar <> None => G1.cstar = Some (G3.a,G3.a_,G3.c,G3.d)){2} /\\\n                (G3.d = G3.a^(G1.x1 + G2.v*G1.y1) * G3.a_^(G1.x2+G2.v*G1.y2) /\\\n                 G1.y1 = G1.y - G1.w * G1.y2 /\\\n                 G1.x1 = G1.x - G1.w * G1.x2 /\\\n                 G1.x2 = G2.alpha - G2.v * G1.y2){2} /\\\n                (G1.bad{1} => G1.y2{2} \\in G3.y2log{2}))).\n    + by apply guess_ll.\n    + by apply G2_G3_dec.\n    + by move=> &m2 _;apply G1_dec_ll.\n    + by move=> /=;proc;auto => /#.\n    wp;call (_ : (G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog),\n               (={G1.x, G1.y, G1.z, G1.x1, G1.x2, G1.y1, G1.y2, G1.log, G1.cstar, G1.w,\n                  G1.u, G1.u', G1.k} /\\\n                (G1.cstar <> None => G1.cstar = Some (G3.a,G3.a_,G3.c,G3.d)){2} /\\\n                (G3.d = G3.a^(G1.x1 + G2.v*G1.y1) * G3.a_^(G1.x2+G2.v*G1.y2) /\\\n                 G1.y1 = G1.y - G1.w * G1.y2 /\\\n                 G1.x1 = G1.x - G1.w * G1.x2 /\\\n                 G1.x2 = G2.alpha - G2.v * G1.y2){2} /\\\n                (G1.bad{1} => G1.y2{2} \\in G3.y2log{2}))).\n    + by apply choose_ll.\n    + by apply G2_G3_dec.\n    + by move=> &m2 _;apply G1_dec_ll.\n    + by move=> /=;proc;auto => /#.\n    auto => &m1 &m2 />.\n    move=> wL /supp_dexcepted [] _;rewrite /pred1 => HwL0.\n    move=> uL _ u'L /supp_dexcepted [] _ /= HuL kL _.\n    move=> yL _ y2L _ zL _ r'L _ xL _ rL _.\n    have H1 : (-uL) * wL + u'L * wL = wL * (u'L - uL) by ring.\n    have H2 : (-uL) * wL + u'L * wL <> zero.\n    + rewrite H1 ZPF.mulf_eq0 negb_or HwL0 /=.\n      by move: HuL;apply: contra => H;ring H.\n    split => [ | _ /#].\n    rewrite log_bij !(logg1, logrzM, logDr); field.\n    move: H2; apply: contra => H; ring H.\n  qed.\n\n  local lemma pr_G3_y2log &m :\n    Pr[G3.main() @ &m : G1.y2 \\in G3.y2log] <= PKE_.qD%r / order%r.\n  proof.\n    byphoare => //;proc;wp;rnd.\n    conseq (_: _ ==> size G3.y2log <=  PKE_.qD) => /=.\n    + move=> y2log Hsize;apply (ler_trans ((size y2log)%r/order%r)).\n      + by apply (mu_mem_le_mu1 dt y2log (inv order%r)) => x;rewrite dt1E.\n      apply ler_wpmul2r => //;2: by apply le_fromint.\n      apply invr_ge0;smt (le_fromint gt1_q).\n    call (_: size G3.y2log <= size G1.log /\\ size G3.y2log <= PKE_.qD).\n    + proc;auto => /#.\n    auto;call (_: size G3.y2log <= size G1.log /\\ size G3.y2log <= PKE_.qD).\n    + proc;auto => /#.\n    auto => />;smt (qD_pos).\n  qed.\n\n  local equiv G3_TCR : G3.main ~ TCR(B_TCR(A)).main : ={glob A} ==> G3.g3{1} <> None => res{2}.\n  proof.\n    proc;inline *;wp;rnd{1}.\n    call (_ : B_TCR.log{2} = G1.log{1} /\\\n              B_TCR.cstar{2} = G1.cstar{1} /\\\n              B_TCR.k{2} = G1.k{1} /\\\n              B_TCR.x{2} = G1.x{1} /\\ B_TCR.y{2} = G1.y{1} /\\ B_TCR.z{2} = G1.z{1} /\\\n              B_TCR.a{2} = G3.a{1} /\\ B_TCR.a_{2} = G3.a_{1} /\\ B_TCR.c{2} = G3.c{1} /\\\n              B_TCR.v'{2} = G2.v{1} /\\\n              B_TCR.w{2}  = G1.w{1} /\\\n              B_TCR.g3{2} = G3.g3{1} /\\\n              (G3.g3{1} <> None =>\n               (H B_TCR.k (oget B_TCR.g3) = B_TCR.v' /\\ (oget B_TCR.g3) <>\n                                                   (B_TCR.a,B_TCR.a_,B_TCR.c)){2})).\n    + by proc;auto=> /#.\n    wp; call (_ : B_TCR.log{2} = G1.log{1} /\\\n              B_TCR.cstar{2} = G1.cstar{1} /\\\n              B_TCR.k{2} = G1.k{1} /\\\n              B_TCR.x{2} = G1.x{1} /\\ B_TCR.y{2} = G1.y{1} /\\ B_TCR.z{2} = G1.z{1} /\\\n              B_TCR.a{2} = G3.a{1} /\\ B_TCR.a_{2} = G3.a_{1} /\\ B_TCR.c{2} = G3.c{1} /\\\n              B_TCR.v'{2} = G2.v{1} /\\\n              B_TCR.w{2}  = G1.w{1} /\\\n              B_TCR.g3{2} = G3.g3{1} /\\\n              (G3.g3{1} <> None =>\n               (H B_TCR.k (oget B_TCR.g3) = B_TCR.v' /\\ (oget B_TCR.g3) <>\n                                                   (B_TCR.a,B_TCR.a_,B_TCR.c)){2})).\n    + by proc;auto=> /#.\n    swap{1} 16 -7;auto; smt(dt_ll).\n  qed.\n\n\n local module G4 = {\n\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size G1.log < PKE_.qD && Some ci <> G1.cstar) {\n          G3.cilog <- (G1.cstar = None) ? ci :: G3.cilog : G3.cilog;\n          G1.log <- ci :: G1.log;\n          (a,a_,c,d) <- ci;\n          v <- H G1.k (a, a_, c);\n          m <- if (a_ = a^G1.w /\\ d = a ^ (G1.x + v*G1.y)) then Some (c / a ^ G1.z)\n              else None;\n        }\n        return m;\n      }\n    }\n\n    module A = A (O)\n\n    proc main () = {\n      var m0, m1, b0, e, f, h, r, r';\n      G1.log <- [];\n      G3.cilog <- [];\n      G1.cstar <- None;\n      G1.w <$ dt \\ (pred1 zero);\n      G1.g_ <- g ^ G1.w;\n\n      G1.k  <$ dk;\n      G1.y <$ dt; f <- g^G1.y;\n      G1.z <$ dt;  h <- g^G1.z;\n      G1.x <$ dt; e <- g^G1.x;\n      (m0,m1) <@ A.choose(G1.k, g, G1.g_, e, f, h);\n      G1.u <$ dt;\n      G1.u' <$ dt \\ (pred1 G1.u);\n      r' <$ dt;\n      r <$ dt;\n      G3.a <- g^G1.u; G3.a_ <- G1.g_^G1.u';G3.c <- g^r'; G3.d <- g ^ r;\n      G2.v <- H G1.k (G3.a, G3.a_, G3.c);\n      G2.alpha <- (r - G1.u*(G1.x + G2.v*G1.y))/ (G1.w*(G1.u'-G1.u));\n      G1.cstar <- Some (G3.a,G3.a_,G3.c,G3.d);\n      b0 <@ A.guess(G3.a,G3.a_,G3.c,G3.d);\n    }\n  }.\n\n  local equiv G3_G4 : G3.main ~ G4.main : ={glob A} ==> ={G3.a, G3.a_,G3.c, G3.d, G3.cilog}.\n  proof.\n    proc;wp;rnd{1}.\n    call (_ : ={G1.log, G1.cstar, G1.k, G1.w, G1.x, G1.y, G1.z, G3.cilog}).\n    + by proc;auto => />.\n    wp. swap{2} [14..17] -1.\n    call (_ : ={G1.log, G1.cstar, G1.k, G1.w, G1.x, G1.y, G1.z, G3.cilog}).\n    + by proc;auto => />.\n    swap{2} [13..14]-8.  swap{2} [13..14]1.\n    by auto => />;rewrite dt_ll.\n  qed.\n\n  (* TODO: move this ?*)\n  lemma mu_mem_le_mu1_size (dt : 'a distr) (l : 'a list) (r : real) n:\n    size l <= n =>\n    (forall (x : 'a), mu1 dt x <= r) => mu dt (mem l) <= n%r * r.\n  proof.\n    move=> Hsize Hmu1;apply (ler_trans ((size l)%r * r)).\n    + by apply mu_mem_le_mu1.\n    apply ler_wpmul2r; 1: smt (mu_bounded).\n    by apply le_fromint.\n  qed.\n\n  local lemma pr_G4 &m:\n    Pr[G4.main() @ &m : (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog] <=\n      (PKE_.qD%r/order%r)^3 * (PKE_.qD%r/(order-1)%r).\n  proof.\n    byphoare=> //;proc.\n    seq 23 : ((G3.a, G3.a_, G3.c, G3.d) \\in G3.cilog)\n             ((PKE_.qD%r / order%r)^3 * (PKE_.qD%r / (order - 1)%r)) 1%r _ 0%r => //;last first.\n    + hoare; call (_ : G1.cstar <> None /\\ !(G3.a, G3.a_, G3.c, G3.d) \\in G3.cilog).\n      + by proc;auto => /#.\n      by auto.\n    seq 13 : true 1%r ((PKE_.qD%r / order%r) ^ 3 * (PKE_.qD%r / (order - 1)%r))\n                 0%r _ (size G3.cilog <= PKE_.qD /\\ G1.w <> zero /\\ G1.g_ = g ^ G1.w) => //.\n    + call (_ : size G3.cilog <= size G1.log /\\ size G1.log <= PKE_.qD).\n      + proc;auto => /#.\n      auto => /= w /supp_dexcepted;smt (qD_pos).\n    wp;conseq (_ : _ ==> G1.u \\in map (fun (g4:ciphertext) => loge g4.`1) G3.cilog /\\\n                      G1.u' \\in map (fun (g4:ciphertext) => loge g4.`2 / G1.w) G3.cilog /\\\n                      r' \\in map (fun (g4:ciphertext) => loge g4.`3) G3.cilog /\\\n                      r \\in map (fun (g4:ciphertext) => loge g4.`4) G3.cilog).\n    + move=> &hr /> _ Hw u u' r r' Hlog.\n      do !split;apply mapP;\n       exists (g ^ u, g ^ G1.w{hr} ^ u', g ^ r', g ^ r);\n       rewrite Hlog /= !logrzM ?logg1; 1, 3, 4: by ring.\n       by field.\n    seq 1 : (G1.u \\in map (fun (g4 : ciphertext) => loge g4.`1) G3.cilog)\n            (PKE_.qD%r / order%r) ((PKE_.qD%r / order%r)^2 * (PKE_.qD%r / (order - 1)%r))\n            _ 0%r (size G3.cilog <= PKE_.qD) => //;\n    last 2 first.\n    + hoare;conseq (_ : _ ==> true) => // /#.\n    + move=> &hr _;apply lerr_eq;ring.\n    + by auto.\n    + rnd;skip => /> &hr Hsize _;pose m' := map _ _.\n      apply (mu_mem_le_mu1_size dt m') => //.\n      + by rewrite /m' size_map.\n      by move=> ?;rewrite dt1E.\n    seq 1 : (G1.u' \\in map (fun (g4 : ciphertext) => loge g4.`2 / G1.w) G3.cilog)\n            (PKE_.qD%r / (order-1)%r) ((PKE_.qD%r / order%r)^2) _ 0%r\n            (size G3.cilog <= PKE_.qD) => //;last 2 first.\n    + hoare;conseq (_ : _ ==> true) => // /#.\n    + move=> &hr _;apply lerr_eq;ring.\n    + by auto.\n    + rnd;skip => /> &hr Hsize _;pose m' := map _ _.\n      apply (mu_mem_le_mu1_size (dt \\ pred1 G1.u{hr}) m') => //.\n      + by rewrite /m' size_map.\n      move=> x;rewrite dexcepted1E {1}/pred1.\n      case: (x = G1.u{hr}) => _.\n      + apply invr_ge0;smt (le_fromint gt1_q).\n      rewrite dt_ll !dt1E;apply lerr_eq.\n      field;smt (gt1_q le_fromint).\n    seq 1 : (r' \\in map (fun (g4 : ciphertext) => loge g4.`3) G3.cilog)\n            (PKE_.qD%r / order%r) (PKE_.qD%r / order%r) _ 0%r\n            (size G3.cilog <= PKE_.qD) => //;last 2 first.\n    + hoare;conseq (_ : _ ==> true) => // /#.\n    + move=> &hr _;apply lerr_eq;field.\n      + rewrite expr2; smt (gt1_q).\n      + smt (gt1_q).\n    + by auto.\n    + rnd;skip => /> &hr Hsize _;pose m' := map _ _.\n      apply (mu_mem_le_mu1_size dt m') => //.\n      + by rewrite /m' size_map.\n      by move=> ?;rewrite dt1E.\n    conseq (_ : _ ==> (r \\in map (fun (g4 : ciphertext) => loge g4.`4) G3.cilog)) => //.\n    rnd;skip => /> &hr Hsize _;pose m' := map _ _.\n    apply (mu_mem_le_mu1_size dt m') => //.\n    + by rewrite /m' size_map.\n    by move=> ?;rewrite dt1E.\n  qed.\n\n  lemma aux2 &m :\n    Pr[CCA(CramerShoup, A).main() @ &m : res] <=\n    `|Pr[DDH0(B_DDH(A)).main() @ &m : res] -\n      Pr[DDH1(B_DDH(A)).main() @ &m : res]| +\n    Pr[TCR(B_TCR(A)).main() @ &m : res] +\n    1%r/2%r + (PKE_.qD + 3)%r / order%r + (PKE_.qD%r/order%r)^3 * (PKE_.qD%r/(order-1)%r).\n  proof.\n    have := aux1 &m.\n    have -> : Pr[Ad1.MainE(G1).main() @ &m : res \\/ G1.bad] =\n              Pr[G2.main1() @ &m : res \\/ G1.bad].\n    + by byequiv G1_G21.\n    have -> : Pr[G2.main1() @ &m : res \\/ G1.bad] = Pr[G2.main() @ &m : res \\/ G1.bad].\n    + by byequiv G21_G2.\n    have : Pr[G2.main() @ &m : res \\/ G1.bad] <= 1%r/2%r + Pr[G2.main() @ &m : G1.bad].\n    + by rewrite Pr [mu_or];have := (pr_G2_res &m);smt (mu_bounded).\n    have : Pr[G2.main() @ &m : G1.bad] <=\n           Pr[G3.main() @ &m : G3.g3 <> None \\/ (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog \\/\n                               G1.y2 \\in G3.y2log].\n    + byequiv G2_G3 => // /#.\n    rewrite Pr [mu_or];rewrite Pr [mu_or].\n    have : Pr[G3.main() @ &m : G3.g3 <> None] <= Pr[TCR(B_TCR(A)).main() @ &m : res].\n    + byequiv G3_TCR => //.\n    have : Pr[G3.main() @ &m : (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog] =\n           Pr[G4.main() @ &m : (G3.a, G3.a_,G3.c, G3.d) \\in G3.cilog].\n    + byequiv G3_G4=> //.\n    have := pr_G4 &m.\n    have := pr_G3_y2log &m.\n    have -> : (PKE_.qD + 3)%r / order%r = PKE_.qD%r/order%r + 3%r/order%r.\n    + by rewrite fromintD;ring.\n    smt (mu_bounded).\n  qed.\n\nend section Security_Aux.\n\nsection Security.\n\n  declare module A <: CCA_ADV {-CCA, -B_TCR}.\n  declare axiom guess_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).guess.\n  declare axiom choose_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).choose.\n\n  local module NA (O:CCA_ORC) = {\n    module A = A(O)\n    proc choose = A.choose\n    proc guess(c:ciphertext) = {\n      var b;\n      b <@ A.guess(c);\n      return !b;\n    }\n  }.\n\n  local lemma CCA_NA &m :\n     Pr[CCA(CramerShoup, A).main() @ &m : res] =\n     1%r - Pr[CCA(CramerShoup, NA).main() @ &m : res].\n  proof.\n    have -> : Pr[CCA(CramerShoup, NA).main() @ &m : res] =\n              Pr[CCA(CramerShoup, A).main() @ &m : !res].\n    + byequiv=> //;proc;inline *;wp.\n      by conseq (_ : _ ==> ={b} /\\ b'{2} = b0{1});[ smt() | sim].\n    rewrite Pr [mu_not].\n    have -> : Pr[CCA(CramerShoup, A).main() @ &m : true] = 1%r;last by ring.\n    byphoare=> //;proc; islossless.\n    + by apply (guess_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n    + by apply (choose_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n    apply dexcepted_ll; 1: by apply dt_ll.\n    rewrite dt1E;smt (le_fromint gt1_q).\n  qed.\n\n  local lemma DDH0_NA &m : Pr[DDH0(B_DDH(NA)).main() @ &m : res] =\n                        1%r - Pr[DDH0(B_DDH(A)).main() @ &m : res].\n  proof.\n    have -> : Pr[DDH0(B_DDH(NA)).main() @ &m : res] =\n              Pr[DDH0(B_DDH(A)).main() @ &m : !res].\n    + byequiv=> //;proc;inline *;wp.\n      by conseq (_ : _ ==> ={b0} /\\ b'{2} = b1{1});[ smt() | sim].\n    rewrite Pr [mu_not];congr.\n    byphoare=> //;proc;inline *;auto.\n    islossless.\n    + by apply (guess_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n    by apply (choose_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n  qed.\n\n  local lemma DDH1_NA &m : Pr[DDH1(B_DDH(NA)).main() @ &m : res] =\n                        1%r - Pr[DDH1(B_DDH(A)).main() @ &m : res].\n  proof.\n    have -> : Pr[DDH1(B_DDH(NA)).main() @ &m : res] =\n              Pr[DDH1(B_DDH(A)).main() @ &m : !res].\n    + byequiv=> //;proc;inline *;wp.\n      by conseq (_ : _ ==> ={b0} /\\ b'{2} = b1{1});[ smt() | sim].\n    rewrite Pr [mu_not];congr.\n    byphoare=> //; islossless.\n    + by apply (guess_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n    by apply (choose_ll (<:CCA(CramerShoup, A).O) (CCA_dec_ll A)).\n  qed.\n\n  local lemma TCR_NA &m : Pr[TCR(B_TCR(NA)).main() @ &m : res] =\n                          Pr[TCR(B_TCR(A)).main() @ &m : res].\n  proof.\n    byequiv=> //;proc;inline *;sim.\n    call (_: ={ B_TCR.v', B_TCR.k, B_TCR.cstar, B_TCR.a, B_TCR.a_, B_TCR.c,\n                B_TCR.log, B_TCR.g3, B_TCR.w, B_TCR.x, B_TCR.y, B_TCR.z}).\n    + by sim.\n    auto;call (_: ={ B_TCR.v', B_TCR.k, B_TCR.cstar, B_TCR.a, B_TCR.a_, B_TCR.c,\n                     B_TCR.log, B_TCR.g3, B_TCR.w, B_TCR.x, B_TCR.y, B_TCR.z});2: by auto.\n    by sim.\n  qed.\n\n  lemma conclusion &m :\n    `|Pr[CCA(CramerShoup, A).main() @ &m : res] - 1%r/2%r | <=\n    `|Pr[DDH0(B_DDH(A)).main() @ &m : res] - Pr[DDH1(B_DDH(A)).main() @ &m : res]| +\n    Pr[TCR(B_TCR(A)).main() @ &m : res] +\n    (PKE_.qD + 3)%r / order%r + (PKE_.qD%r/order%r)^3 * (PKE_.qD%r/(order-1)%r).\n  proof.\n    case (Pr[CCA(CramerShoup, A).main() @ &m : res] <= 1%r/2%r);last first.\n    + have /# := aux2 A guess_ll choose_ll &m.\n    have := aux2 NA _ choose_ll &m.\n    + by move=> O O_ll;proc;inline *;call (_ : true) => //; apply guess_ll.\n    rewrite (CCA_NA &m) (DDH0_NA &m) (DDH1_NA &m) (TCR_NA &m).\n    smt (mu_bounded).\n  qed.\n\nend section Security.",
        "codenote": "require import AllCore List Distr Dexcepted PKE.\nrequire import StdOrder StdBigop.\nimport RField RealOrder Bigreal.\n\nrequire TCR RndExcept.\n\n(** DiffieHellman *)\nrequire DiffieHellman.\nclone DiffieHellman as DH.\nimport DH.DDH DH.G DH.GP DH.FD DH.GP.ZModE.\n\nclone DH.GP.ZModE.ZModpField as ZPF.\n\nlemma gt1_q : 1 < order by smt(ge2_p).\n\ntheory Ad1.\n\n  clone import RndExcept as RndE with\n    type input <- unit,\n    type t     <- exp,\n    op   d     <- fun _ => dt,\n    type out   <- bool\n    proof *.\n    realize d_ll. move=> _;apply dt_ll. qed.\n\n  clone include Adversary1_1 with\n    op n <- order\n    proof *.\n  realize gt1_n by apply gt1_q.\n  realize d_uni.\n  proof.\n  move=> _ x; rewrite dt1E.\n  suff: size elems = size elems by smt().\n  apply uniq_size_uniq; rewrite ?elems_uniq.\n  by smt(elemsP elemsP).\n  qed.\n\nend Ad1.\n\ntheory DDH_ex.\n\n  module DDH0_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y; (* b stores the guess result, x and y are randomly chosen exponents *)\n      x <$ dt \\ (pred1 zero); (* Sample x from dt avoiding zero *)\n      y <$ dt; (* Sample y from dt *)\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y)); (* Adversary guesses based on (g^x, g^y, g^(xy)) *)\n      return b;\n    }\n  }.\n\n  module DDH1_ex (A:Adversary) = {\n    proc main() : bool = {\n      var b, x, y, z; (* b stores the guess result, x, y, and z are randomly chosen exponents *)\n\n      x <$ dt \\ (pred1 zero); (* Sample x from dt avoiding zero *)\n      y <$ dt; (* Sample y from dt *)\n      z <$ dt; (* Sample z from dt *)\n      b <@ A.guess(g ^ x, g ^ y, g ^ z); (* Adversary guesses based on (g^x, g^y, g^z) *)\n      return b;\n    }\n  }.\n\n  section PROOFS.\n\n  declare module A <: Adversary.\n\n  declare axiom A_ll : islossless A.guess.\n\n  local module Addh0 : Ad1.ADV = {\n    proc a1 () = { return ((), zero); } (* Sample adversarial strategy a1 *)\n    proc a2 (x : exp) = {\n      var b, y; (* b stores the guess result, y is randomly chosen *)\n      y <$ dt; (* Sample y from dt *)\n      b <@ A.guess(g ^ x, g ^ y, g ^ (x * y)); (* Adversary guesses based on (g^x, g^y, g^(xy)) *)\n      return b;\n    }\n  }.\n\n  local module Addh1 = {\n    proc a1 = Addh0.a1 (* Use a1 from Addh0 *)\n    proc a2 (x : exp) = {\n      var b, y, z; (* b stores the guess result, y and z are randomly chosen *)\n      y <$ dt; (* Sample y from dt *)\n      z <$ dt; (* Sample z from dt *)\n      b <@ A.guess(g ^ x, g ^ y, g ^ z); (* Adversary guesses based on (g^x, g^y, g^z) *)\n      return b;\n    }\n  }.\n\n  local lemma a1_ll : islossless Addh0.a1. (* Ensure a1 is lossless *)\n  proof. proc;auto. qed.\n\n  lemma adv_DDH_DDH_ex &m :\n     `| Pr[DDH0_ex(A).main()@ &m : res] - Pr[DDH1_ex(A).main()@ &m : res] | <=\n     `| Pr[DDH0(A).main()@ &m : res] - Pr[DDH1(A).main()@ &m : res] | + 2%r / order%r.\n  proof.\n    have /= H0 := Ad1.pr_abs Addh0 a1_ll _ &m (fun b _ => b). (* Prove bounds for DDH0 *)\n    + by proc;call A_ll;rnd;skip;rewrite /= dt_ll.\n    have /= H1 := Ad1.pr_abs Addh1 a1_ll _ &m (fun b _ => b). (* Prove bounds for DDH1 *)\n    + by proc;call A_ll;do !rnd;skip;rewrite /= dt_ll.\n    have -> : 2%r / order%r = inv order%r + inv order%r. (* Handle the probabilities *)\n    + field;smt (gt0_order lt_fromint).\n    have <- : Pr[Ad1.MainE(Addh0).main() @ &m : res] = Pr[DDH0_ex(A).main() @ &m : res]. (* Equivalence relation *)\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.MainE(Addh1).main() @ &m : res] = Pr[DDH1_ex(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- : Pr[Ad1.Main(Addh0).main() @ &m : res] = Pr[DDH0(A).main() @ &m : res].\n    + by byequiv => //;proc;inline *;sim;auto.\n    have <- /# : Pr[Ad1.Main(Addh1).main() @ &m : res] = Pr[DDH1(A).main() @ &m : res].\n    by byequiv => //;proc;inline *;sim;auto.\n  qed.\n\n  end section PROOFS.\n\nend DDH_ex.\nimport DDH_ex.\n\n(** Target Collision Resistant *)\n\nclone import TCR as TCR_H with\n  type t_from <- group * group * group,\n  type t_to   <- exp.\n\naxiom dk_ll : is_lossless dk.\nhint exact random : dk_ll.\n\n(** Cramer Shoup Encryption *)\n\nclone import PKE as PKE_ with\n   type pkey = K * group * group * group * group * group,\n   type skey = K * group * group * exp * exp * exp * exp * exp * exp,\n   type plaintext = group,\n   type ciphertext = group * group * group * group.\n\nmodule CramerShoup : Scheme = {\n  proc kg() : pkey * skey = {\n    var x1, x2, y1, y2, z1, z2, k, w, g_, pk, sk; (* Key generation *)\n    x1 <$ dt; (* Sample x1 from dt *)\n    x2 <$ dt; (* Sample x2 from dt *)\n    y1 <$ dt; (* Sample y1 from dt *)\n    y2 <$ dt; (* Sample y2 from dt *)\n    z1 <$ dt; (* Sample z1 from dt *)\n    z2 <$ dt; (* Sample z2 from dt *)\n    w  <$ dt \\ (pred1 zero); (* Sample w from dt avoiding zero *)\n    k  <$ dk; (* Sample k from dk *)\n    g_ <- g ^ w; (* Compute g raised to w *)\n    pk <- (k, g, g_, g ^ x1 * g_ ^ x2, g ^ y1 * g_ ^ y2, g ^ z1 * g_ ^ z2); (* Public key *)\n    sk <- (k, g, g_, x1, x2, y1, y2, z1, z2); (* Secret key *)\n    return (pk, sk);\n  }\n\n  proc enc(pk : pkey, m : plaintext) : ciphertext = {\n    var k, g, g_, e, f, h, u, a, a_, c, v, d; (* Encryption process *)\n    (k, g, g_, e, f, h) <- pk; (* Decompose public key *)\n    u <$ dt; (* Sample u from dt *)\n    a <- g ^ u; a_ <- g_ ^ u; (* Compute a and a_ *)\n    c <- h ^ u * m; (* Compute c *)\n    v <- H k (a, a_, c); (* Compute H of the inputs *)\n    d <- e ^ u * f ^ (u * v); (* Compute d *)\n    return (a, a_, c, d); (* Return ciphertext *)\n  }\n\n  proc dec(sk : skey, ci : ciphertext) = {\n    var k, g, g_, x1, x2, y1, y2, z1, z2, a, a_, c, d, v; (* Decryption process *)\n    (k, g, g_, x1, x2, y1, y2, z1, z2) <- sk; (* Decompose secret key *)\n    (a, a_, c, d) <- ci; (* Decompose ciphertext *)\n    v <- H k (a, a_, c); (* Compute H of the inputs *)\n    return (if d = a ^ (x1 + v * y1) * a_ ^ (x2 + v * y2) then Some (c / (a ^ z1 * a_ ^ z2))\n            else None); (* Return decrypted message or None *)\n  }\n\n}.\n\n(** Correctness of the scheme *)\n\nhoare CramerShoup_correct : Correctness(CramerShoup).main : true ==> res.\nproof.\n  proc;inline *;auto => /> &m1 x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ w Hw k _ u _.\n  have -> /=: (g ^ x1 * g ^ w ^ x2) ^ u *\n    (g ^ y1 * g ^ w ^ y2) ^\n    (u * H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1})) =\n    g ^ u ^\n    (x1 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y1) *\n    g ^ w ^ u ^\n    (x2 + H k (g ^ u, g ^ w ^ u, (g ^ z1 * g ^ w ^ z2) ^ u * m{m1}) * y2).\n  + rewrite log_bij !(logg1, logrzM, logDr); ring.\n  by rewrite log_bij -div_def !(logg1, logrzM, logDr); ring.\nqed.\n\n(** IND-CCA Security of the scheme *)\n\nmodule B_DDH (A:CCA_ADV) = {\n\n  module CCA = CCA(CramerShoup, A) (* Create a CCA module *)\n\n  proc guess(gx gy gz:group): bool = {\n    var g_, a, a_, x1,x2,y1,y2,z1,z2,k,e,f,h,m0,m1,b,b',c,v,d,c',pk;\n    x1 <$ dt; (* Sample x1 from dt *)\n    x2 <$ dt; (* Sample x2 from dt *)\n    y1 <$ dt; (* Sample y1 from dt *)\n    y2 <$ dt; (* Sample y2 from dt *)\n    z1 <$ dt; (* Sample z1 from dt *)\n    z2 <$ dt; (* Sample z2 from dt *)\n    g_ <- gx; (* Set g_ to gx *)\n    a  <- gy; (* Set a to gy *)\n    a_ <- gz; (* Set a_ to gz *)\n    k  <$ dk; (* Sample k from dk *)\n    e  <- g^x1 * g_^x2; (* Compute e *)\n    f  <- g^y1 * g_^y2; (* Compute f *)\n    h  <- g^z1 * g_^z2; (* Compute h *)\n    CCA.log <- []; (* Initialize log *)\n    CCA.cstar <- None; (* Initialize cstar *)\n    pk <- (k, g, g_, g^x1 * g_^x2, g^y1 * g_^y2, g^z1 * g_^z2); (* Public key for CCA *)\n    CCA.sk <- (k, g, g_, x1, x2, y1, y2, z1, z2); (* Secret key for CCA *)\n    (m0,m1) <@ CCA.A.choose(pk); (* Adversary chooses messages *)\n    b <$ {0,1}; (* Sample b randomly from {0, 1} *)\n    c <- a^z1 * a_^z2 * (b ? m1 : m0); (* Compute challenge ciphertext based on b *)\n    v <- H k (a,a_,c); (* Compute H of the inputs *)\n    d <- a^(x1 + v*y1) * a_^(x2+v*y2); (* Compute d *)\n    c' <- (a,a_,c,d); (* Form c' *)\n    CCA.cstar <- Some c'; (* Set cstar *)\n    b' <@ CCA.A.guess(c'); (* Adversary guesses the challenge *)\n    return (b = b'); (* Return whether the guess was correct *)\n  }\n}.\n\n module B_TCR (A:CCA_ADV) = {\n    var log   : ciphertext list\n    var cstar : ciphertext option\n    var g3    : ( group * group * group) option\n    var g_, a, a_, c, d : group\n    var w, u , u', x, y, z, alpha, v' : exp\n    var k : K\n    module O = {\n      proc dec(ci:ciphertext) = {\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> cstar) {\n          log <- ci :: log; (* Log the ciphertext *)\n          (a,a_,c,d) <- ci; (* Decompose ciphertext *)\n          v <- H k (a, a_, c); (* Compute H of the inputs *)\n          if (a_ <> a^w /\\ v = v' /\\ (a,a_,c) <> (B_TCR.a, B_TCR.a_,B_TCR.c)) g3 <- Some (a,a_,c); (* Check for conditions of g3 *)\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z) (* Decrypt if conditions met *)\n              else None;\n        }\n        return m; (* Return the message *)\n      }\n    }\n\n    module A = A (O) (* Create an adversary module *)\n\n    proc c1() = {\n      var r';\n      log <- []; (* Initialize log *)\n      g3 <- None; (* Initialize g3 *)\n      cstar <- None; (* Initialize cstar *)\n      w <$ dt \\ (pred1 zero); (* Sample w avoiding zero *)\n      u <$ dt; (* Sample u from dt *)\n      u' <$ dt \\ (pred1 u); (* Sample u' from dt avoiding u *)\n      g_ <- g ^ w; (* Compute g raised to w *)\n      a <- g^u; a_ <- g_^u'; (* Compute a and a_ *)\n      r' <$ dt; c <- g^r'; (* Sample r' and compute c *)\n      return (a, a_, c); (* Return the values *)\n    }\n\n    proc c2 (k:K) = {\n      var m0, m1, b, e, f, h, r; \n      B_TCR.k <- k; (* Set secret key *)\n      y <$ dt; f <- g^y; (* Sample y and compute f *)\n      z <$ dt; h <- g^z; (* Sample z and compute h *)\n      v' <- H k (a, a_, c); (* Compute H of inputs *)\n      x <$ dt; r <$ dt; e <- g^x; (* Sample x and r, compute e *)\n      alpha <- (r - u*(x + v'*y))/ (w*(u'-u)); (* Compute alpha *)\n      d <- g ^ r; (* Compute d *)\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h); (* Adversary chooses messages *)\n      cstar <- Some (a,a_,c,d); (* Set cstar *)\n      b0 <@ A.guess(a,a_,c,d); (* Adversary guesses *)\n      return (oget g3); (* Return g3 *)\n    }\n  }.\n\nlemma CCA_dec_ll (A<:CCA_ADV) : islossless CCA(CramerShoup, A).O.dec. (* Prove CCA decryption is lossless *)\nproof. islossless. qed.\n\nsection Security_Aux.\n\n  declare module A <: CCA_ADV {-CCA, -B_TCR}.\n  declare axiom guess_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).guess.\n  declare axiom choose_ll : forall (O <: CCA_ORC{-A}), islossless O.dec => islossless A(O).choose.\n\n  equiv CCA_DDH0 : CCA(CramerShoup, A).main ~ DDH0_ex(B_DDH(A)).main : ={glob A} ==> ={res}.\n  proof.\n    proc;inline *;wp.\n    call (_: ={glob CCA}); 1: sim.\n    swap{1} 9 -8; swap{1} 20 -18; auto.\n    call (_: ={glob CCA}); 1: sim.\n    auto => &m1 &m2 /> w _ u _ x1 _ x2 _ y1 _ y2 _ z1 _ z2 _ k _ r b _.\n    have -> :\n      H k\n       (g ^ u, g ^ w ^ u,\n        (g ^ z1 * g ^ w ^ z2) ^ u * if b then r.`2 else r.`1) =\n      H k\n       (g ^ u, g ^ (w * u),\n        g ^ u ^ z1 * g ^ (w * u) ^ z2 * if b then r.`2 else r.`1).\n    + by congr;congr;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    progress;\n      try by (rewrite log_bij !(logg1, logrzM, logDr); ring).\n    smt ().\n  qed.\n\n  lemma pr_CCA_DDH0 &m :\n    Pr[CCA(CramerShoup, A).main() @ &m : res] =\n    Pr[DDH0_ex(B_DDH(A)).main() @ &m : res].\n  proof. by byequiv CCA_DDH0. qed.\n\n  local module G1 = {\n    var log     : ciphertext list\n    var cstar   : ciphertext option\n    var bad     : bool\n    var u,u',w  : exp\n    var x,x1,x2 : exp\n    var y,y1,y2 : exp\n    var z,z1,z2 : exp\n    var g_: group\n    var k       : K\n\n    module O = {\n      proc dec(ci:ciphertext) = { (* Decrypt the ciphertext *)\n        var m, a,a_,c,d,v;\n        m <- None;\n        if (size log < PKE_.qD && Some ci <> G1.cstar) {\n          log <- ci :: log; (* Log ciphertext *)\n          (a,a_,c,d) <- ci; (* Decompose ciphertext *)\n          v <- H k (a, a_, c); (* H of the inputs *)\n          bad <- bad \\/ (a_ <> a^w /\\ d = a ^ (x1 + v*y1) * a_ ^ (x2 + v * y2)); (* Bad when certain conditions are met *)\n          m <- if (a_ = a^w /\\ d = a ^ (x + v*y)) then Some (c / a ^ z) (* Decrypt if conditions met *)\n              else None;\n        }\n        return m; (* Return decrypted message *)\n      }\n    }\n\n    module A = A(O) (* Create adversarial module *)\n\n    proc a1 () = {\n      log <- []; (* Initialize log *)\n      cstar <- None; (* Initialize cstar *)\n      bad <- false; (* Initialize bad flag *)\n      w <$ dt \\ (pred1 zero); (* Sample w avoiding zero *)\n      u <$ dt; (* Sample u from dt *)\n      return ((),u); (* Return empty tuple and u *)\n    }\n\n    proc a2 (u0' : exp) = {\n      var m0, m1, b, b0, a, a_, c, d, v, e, f, h;\n      u' <- u0'; (* Set u' to input *)\n      g_ <- g ^ w; k  <$ dk; (* Compute g_ and sample k *)\n      a <- g^u; a_ <- g_^u'; (* Compute a and a_ *)\n      x <$ dt; x2 <$ dt; x1 <- x - w * x2; e <- g^x; (* Sample x and compute e *)\n      y <$ dt; y2 <$ dt; y1 <- y - w * y2; f <- g^y; (* Sample y and compute f *)\n      z <$ dt; z2 <$ dt; z1 <- z - w * z2; h <- g^z; (* Sample z and compute h *)\n      (m0,m1) <@ A.choose(k, g, g_, e, f, h); (* Adversary chooses messages *)\n      b <$ {0,1}; (* Sample b from {0, 1} *)\n      c <- a^z1 * a_^z2 * (b ? m1 : m0); (* Compute challenge ciphertext *)\n      v <- H k (a, a_, c); (* H of the inputs *)\n      d <- a^(x1 + v*y1) * a_^(x2 + v*y2); (* Compute d *)\n      cstar <- Some (a,a_,c,d); (* Set cstar *)\n      b0 <@ A.guess(a,a_,c,d); (* Adversary guesses *)\n      return (b = b0); (* Return whether the guess was correct *)\n    }\n  }.\n\n  local equiv DDH1_G1_dec :\n    CCA(CramerShoup, A).O.dec ~ G1.O.dec :\n    ( !G1.bad{2} /\\ c{1} = ci{2} /\\\n      (G1.x{2} = G1.x1{2} + G1.w{2} * G1.x2{2} /\\\n       G1.y{2} = G1.y1{2} + G1.w{2} * G1.y2{2} /\\\n       G1.z{2} = G1.z1{2} + G1.w{2} * G1.z2{2}) /\\\n       CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n       CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})) ==>\n    (!G1.bad{2} =>\n       ={res} /\\\n       (G1.x{2} = G1.x1{2} + G1.w{2} * G1.x2{2} /\\\n        G1.y{2} = G1.y1{2} + G1.w{2} * G1.y2{2} /\\\n        G1.z{2} = G1.z1{2} + G1.w{2} * G1.z2{2}) /\\\n       CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n       CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n  proof.\n    proc;sp 0 1;inline *;if => //;auto.\n    move=> &m1 &m2 /> _ /=;rewrite negb_and /=.\n    case: (ci{m2}) => a a_ c d => /=.\n    case: (a_ = a ^ G1.w{m2}) => [ -> _ _ | _ _ _ -> ] //=.\n    have -> :\n      a ^ (G1.x1{m2} + H G1.k{m2} (a, a ^ G1.w{m2}, c) * G1.y1{m2}) *\n      a ^ G1.w{m2} ^ (G1.x2{m2} + H G1.k{m2} (a, a ^ G1.w{m2}, c) * G1.y2{m2}) =\n      a ^ (G1.x1{m2} + G1.w{m2} * G1.x2{m2} +\n           H G1.k{m2} (a, a ^ G1.w{m2}, c) * (G1.y1{m2} + G1.w{m2} * G1.y2{m2})).\n    + by rewrite log_bij !(logg1, logrzM, logDr); ring.\n    have -> // : a ^ G1.z1{m2} * a ^ G1.w{m2} ^ G1.z2{m2} =\n                 a ^ (G1.z1{m2} + G1.w{m2} * G1.z2{m2}).\n    by rewrite log_bij !(logg1, logrzM, logDr); ring.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  local lemma G1_dec_ll : islossless G1.O.dec. (* G1 decryption losslessness *)\n  proof. by proc;inline *;auto. qed.\n\n  local lemma G1_dec_bad : phoare[ G1.O.dec : G1.bad ==> G1.bad ] = 1%r. (* Prove bad event remains unchanged *)\n  proof. by proc; auto => ? ->. qed.\n\n  local equiv DDH1_G1 : DDH1_ex(B_DDH(A)).main ~ Ad1.Main(G1).main :\n                        ={glob A} ==> !G1.bad{2} => ={res}. (* Equivalence relation for DDH1 *)\n  proof.\n    proc;inline *;wp.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k{2}, g, G1.g_{2}, G1.x1{2}, G1.x2{2}, G1.y1{2}, G1.y2{2}, G1.z1{2}, G1.z2{2})).\n      + by apply guess_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    wp;rnd.\n    call (_: G1.bad,\n             (\n              (G1.x = G1.x1 + G1.w * G1.x2 /\\\n               G1.y = G1.y1 + G1.w * G1.y2 /\\\n               G1.z = G1.z1 + G1.w * G1.z2){2} /\\\n              CCA.log{1} = G1.log{2} /\\ CCA.cstar{1} = G1.cstar{2} /\\\n              CCA.sk{1} = (G1.k, g, G1.g_, G1.x1, G1.x2, G1.y1, G1.y2, G1.z1, G1.z2){2})).\n      + by apply choose_ll.\n      + by apply DDH1_G1_dec.\n      + by move=> _ _; apply (CCA_dec_ll A).\n      + by move=> _;apply G1_dec_bad.\n    swap{1} 16 -9;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.z2{2}) (fun z => z - G1.w{2} * G1.z2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.y2{2}) (fun z => z - G1.w{2} * G1.y2{2}).\n    rnd;wp.\n    swap -1;rnd (fun z => z + G1.w{2} * G1.x2{2}) (fun z => z - G1.w{2} * G1.x2{2}).\n    rnd;wp;rnd;wp.\n    rnd (fun z => z / x{1}) (fun z => z * x{1}) => /=.\n    auto => &m1 &m2 /= -> xL H;rewrite H /=;move: H => /supp_dexcepted.\n    rewrite /pred1 => -[] InxL HxL yL _.\n    split => [ ? _ | eqxL]; 1:by field.\n    move=> zL InzL_; split => [ | _]; 1:by field.\n    move=> kL -> /= x2L _.\n    split => [ ? _ | Eqx2L]; 1: by ring.\n    move=> x1L Inx1L;split; 1: by ring.\n    move=> _ y2L _ /=;split => [ ? _ | Eqy2L]; 1: by ring.\n    move=> y1L Iny1L; split => [ | H{H}]; 1: by ring.\n    move=> z2L _ /=;split => [ ? _ | Eqz2L]; 1: by ring.\n    move=> z1L Inz1L.\n    have <- /= : z1L = z1L + xL * z2L - xL * z2L by ring.\n    have H1 : forall (x1L x2L : exp), g ^ x1L * g ^ xL ^ x2L = g ^ (x1L + xL * x2L).\n    + by move=> ??;rewrite log_bij !(logg1, logrzM, logDr); ring.\n    rewrite !H1 /=.\n    have H2 : forall x1L x2L, x1L + xL * x2L = x1L + xL * x2L - xL * x2L + xL * x2L.\n    +  by move=> ??;ring.\n    rewrite -!H2 /=;split=> [ | _].\n    + by split => *;ring.\n    move=> ??????? Hbad ? ? /=.\n    have <- /= : g ^ zL = g ^ xL ^ (zL / xL).\n    + by rewrite log_bij !(logg1, logrzM, logDr); field.\n    split.\n    + move=> /Hbad [#] !->> /= <- <-.\n      by split; rewrite log_bij !(logg1, logrzM, logDr) /=.\n    by move=> _ {Hbad} ??????? Hbad /Hbad.\n  qed.\n\n  lemma aux1 &m :\n    Pr[CCA(CramerShoup, A).main() @ &m : res] <=\n       `| Pr[DDH0(B_DDH(A)).main() @ &m : res] - Pr[DDH1(B_DDH(A)).main() @ &m : res] |\n    + Pr[Ad1.MainE(G1).main() @ &m : res \\/ G1.bad] + 3%r/order%r.\n  proof.\n    have -> :\n     Pr[CCA(CramerShoup, A).main() @ &m : res] = Pr[DDH0_ex(B_DDH(A)).main() @ &m : res].\n    + by byequiv CCA_DDH0 => //.\n    have := adv_DDH_D"
    }
]