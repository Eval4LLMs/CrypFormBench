[
    {
        "file": "EC-1/AES.ec",
        "logic": "To generate a description content for the provided EasyCrypt (ec) file, we need to outline the key features and functionalities of the cryptographic protocol represented in the code. The following description summarizes the operations, properties, and relationships defined in the EasyCrypt file, making it easier for someone to understand the underlying protocol.\n\n---\n\n# Description of Cryptographic Protocol\n\n## Overview\nThis protocol implements the Advanced Encryption Standard (AES) algorithm, a symmetric key encryption standard used worldwide to secure data. The protocol provides operations for both encryption and decryption, utilizing various transformations and key schedules to ensure the confidentiality and integrity of the data.\n\n## Key Operations\n\n### S-Box Operations\n- **Sbox**: A substitution operation that takes an 8-bit word and produces an 8-bit output.\n- **InvSbox**: The inverse of the Sbox operation, allowing for the retrieval of the original 8-bit word from its substituted form. It is axiomatized that applying InvSbox to Sbox returns the original value.\n\n### Word Transformations\n- **SubWord**: Applies the Sbox transformation to each byte of a 32-bit word.\n- **InvSubWord**: Applies the InvSbox transformation to each byte of a 32-bit word. It is proven that applying InvSubWord to SubWord returns the original word.\n\n### State Representation\n- The state in the AES algorithm is represented as a 128-bit word, organized in a 4x4 matrix format.\n- **to_matrix**: Converts a 128-bit state into a column-major matrix representation.\n- **to_state**: Converts a matrix representation back into a 128-bit state.\n\n### Byte Substitution and Row Shifting\n- **SubBytes**: Applies the SubWord operation to each byte of the 128-bit state.\n- **InvSubBytes**: Applies the InvSubWord operation to each byte of the 128-bit state.\n- **ShiftRows**: Shifts each row of the state to the left by a certain number of bytes.\n- **InvShiftRows**: Reverses the ShiftRows operation.\n\n### Column Mixing\n- **MixColumns**: Combines the bytes of each column in the state using linear transformations.\n- **InvMixColumns**: The inverse of MixColumns, allowing for the recovery of the original state before mixing. This operation is axiomatized.\n\n### Key Addition\n- **AddRoundKey**: Performs a bitwise XOR operation between the state and a round key.\n\n## AES Instructions\nThe protocol defines several operations corresponding to the AES encryption and decryption process:\n- **AESENC**: Encrypts the state with a round key by applying the SubBytes, ShiftRows, and MixColumns operations followed by AddRoundKey.\n- **AESENCLAST**: The last encryption step that omits the MixColumns operation.\n- **AESDEC**: Decrypts the state using the inverse operations: InvShiftRows, InvSubBytes, and AddRoundKey, followed by InvMixColumns.\n- **AESDECLAST**: The last decryption step that omits the InvMixColumns operation.\n\n### Key Expansion\n- **AESKEYGENASSIST**: Assists in generating round keys from the current state and a round constant.\n\n## Redefinition of x86 AES Instructions\nThe protocol also includes a redefinition of the x86 AES instructions to align with the standard AES specification. This includes:\n- **AESENC_** and **AESENCLAST_**: Adjustments to the order of operations.\n- **AESDEC_**: Modifications to the decryption process to incorporate InvMixColumns at the end.\n\n## Lemmas and Proofs\nThe protocol includes several lemmas that establish the correctness of the transformations and operations:\n- **InvSubWordK**: Proves that Inverses hold for SubWord and InvSubWord.\n- **ShiftRows_SubBytes**: Shows the commutativity of the ShiftRows and SubBytes operations.\n- **AESDEC_AESDEC_**: Establishes the equivalence of the specified AESDEC operations under certain conditions.\n\n---\n\nThis description encapsulates the main aspects of the protocol, its operations, and its mathematical properties, providing a clear understanding of how the AES algorithm is implemented in the EasyCrypt framework. From this description, a corresponding EasyCrypt file can be generated by following the outlined structure and definitions.",
        "code": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t.\nop InvSbox : W8.t -> W8.t.\n\naxiom InvSboxK w : InvSbox (Sbox w) = w.\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. \nop InvSubWord (w : W32.t) = map InvSbox w. \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w.\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK.\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0].\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3).\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3].\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m.\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. \n\nop InvSubBytes (s : W128.t) = map InvSubWord s.\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w.\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK.\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2.\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s.\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. \n\nop InvMixColumns : W128.t -> W128.t. \n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s.\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2.\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns.\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3]\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slittly differs form AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes annd ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s).\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k.\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k.\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes.\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k.\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed.",
        "codenote": "require import List JArray JWord.\n\n(* --------------------------------------------------------------- *)\n(* Operation on bytes                                              *)\nop Sbox : W8.t -> W8.t. (* The S-box transformation for bytes *)\nop InvSbox : W8.t -> W8.t. (* The inverse S-box transformation for bytes *)\n\naxiom InvSboxK w : InvSbox (Sbox w) = w. (* The S-box and its inverse should cancel *)\n\n(* --------------------------------------------------------------- *)\n(* Operations on word                                              *)\nop SubWord (w : W32.t) = map Sbox w. (* Apply S-box to each byte in a word *)\nop InvSubWord (w : W32.t) = map InvSbox w. (* Apply inverse S-box to each byte in a word *) \n\nlemma InvSubWordK w : InvSubWord (SubWord w) = w. (* The transformation and its inverse should cancel *)\nproof. \n  rewrite /SubWord /InvSubWord; apply W4u8.wordP => i hi.\n  by rewrite !W4u8.mapbE 1,2:// InvSboxK. (* Using properties of mapping *)\nqed.\n\nop RotWord (w:W32.t) = \n  W4u8.pack4 [w \\bits8 1; w \\bits8 2; w \\bits8 3; w \\bits8 0]. (* Rotate the bytes of a word *)\n\n(* --------------------------------------------------------------- *)\n(* Operations on state                                             *)\n\n(* Column representation of matrix *)\n(* s00, s01, s02, s03\n   s10, s11, s12, s13\n   s20, s21, s22, s23\n   s30, s31, s32, s33 *)\n\nop to_matrix (s:W128.t) = \n  let s_ = fun i j => (s \\bits32 j) \\bits8 i in\n  (s_ 0 0, s_ 0 1, s_ 0 2, s_ 0 3,\n   s_ 1 0, s_ 1 1, s_ 1 2, s_ 1 3,\n   s_ 2 0, s_ 2 1, s_ 2 2, s_ 2 3,\n   s_ 3 0, s_ 3 1, s_ 3 2, s_ 3 3). (* Converts a state (W128) to matrix form *)\n\nop to_state m = \n  let (s00, s01, s02, s03,\n       s10, s11, s12, s13,\n       s20, s21, s22, s23,\n       s30, s31, s32, s33) = m in\n   let c0 = W4u8.pack4 [s00; s10; s20; s30] in\n   let c1 = W4u8.pack4 [s01; s11; s21; s31] in\n   let c2 = W4u8.pack4 [s02; s12; s22; s32] in\n   let c3 = W4u8.pack4 [s03; s13; s23; s33] in\n   W4u32.pack4 [c0; c1; c2; c3]. (* Converts a matrix representation back to state (W128) *)\n(*\nlemma to_state_to_matrix m : \n  to_matrix (to_state m) = m. (* This lemma states that converting to state and back results in the original matrix *)\nproof. by case m => *; rewrite /to_state /to_matrix /=. qed.\n*)\n\n(* SubBytes *)\n\nop SubBytes (s : W128.t) = map SubWord s. (* Apply SubWord operation to each column of state *)\n\nop InvSubBytes (s : W128.t) = map InvSubWord s. (* Apply InvSubWord operation to each column of state *)\n\nlemma InvSubBytesK w : InvSubBytes (SubBytes w) = w. (* The SubBytes and InvSubBytes operations should cancel *)\nproof. \n  rewrite /SubBytes /InvSubBytes; apply W4u32.wordP => i hi.\n  by rewrite !W4u32.mapbE 1,2:// InvSubWordK. (* Using properties of mapping *)\nqed.\n\n(* AddRoundKey *)\n\nop AddRoundKey (w1 w2 : W128.t) = w1 `^` w2. (* Bitwise XOR two states (keys) *)\n\n(* ShiftRows *)\n\nop ShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s10, s11, s12, s13,\n      s20, s21, s22, s23,\n      s30, s31, s32, s33) = to_matrix s in\n  to_state (s00, s01, s02, s03,\n            s11, s12, s13, s10,\n            s22, s23, s20, s21,\n            s33, s30, s31, s32) (* Applies the shift rows transformation to the state *)\naxiomatized by ShiftRowsE.\n\nop InvShiftRows (s : W128.t) = \n let (s00, s01, s02, s03,\n      s11, s12, s13, s10,\n      s22, s23, s20, s21,\n      s33, s30, s31, s32) = to_matrix s in\n  to_state \n     (s00, s01, s02, s03,\n      s10, s11, s12, s13,           \n      s20, s21, s22, s23,           \n      s30, s31, s32, s33) (* Applies the inverse shift rows transformation to the state *)\naxiomatized by InvShiftRowsE.\n           \nlemma InvShiftRowsK s  : InvShiftRows (ShiftRows s) = s. (* The inverse shift rows restores the original state *)\nproof.\n  by apply W16u8.allP; rewrite ShiftRowsE InvShiftRowsE /to_matrix /to_state /=.\nqed.\n\n(* MixColumns *)\n\nop MixColumns : W128.t -> W128.t. (* Mixes the columns of the state *)\n\nop InvMixColumns : W128.t -> W128.t. (* Inverse mix operation for the columns *)\n\naxiom InvMixColumnsK s : InvMixColumns (MixColumns s) = s. (* The MixColumns and its inverse should cancel *)\naxiom InvMixColumnsD (s1 s2:W128.t) : InvMixColumns (s1 `^` s2) = InvMixColumns s1 `^` InvMixColumns s2. (* Decomposition of inverse mix operation *)\n\n(* --------------------------------------------------------------- *)\n(* Semantic of x86 AES Instructions                                *)\n\nop AESDEC (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = InvMixColumns state in\n  AddRoundKey state rkey (* Decrypts using the AES rounds with inverse operations *)\naxiomatized by AESDECE.\n\nop AESDECLAST (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  AddRoundKey state rkey (* Decrypts the last round in AES *)\naxiomatized by AESDECLASTE.\n\nop AESENC (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  let state = MixColumns state in\n  AddRoundKey state rkey (* Encrypts using the AES rounds *)\naxiomatized by AESENCE.\n\nop AESENCLAST (state rkey: W128.t) = \n  let state = ShiftRows state in\n  let state = SubBytes state in\n  AddRoundKey state rkey (* Encrypts the last round in AES *)\naxiomatized by AESENCLASTE.\n\nabbrev [-printing] AESIMC = InvMixColumns. (* Abbreviation for inverse mix columns operation *)\n\nop AESKEYGENASSIST (state: W128.t) (rcon:W8.t) = \n  let rcon = W4u8.pack4 [rcon; W8.zero; W8.zero; W8.zero] in\n  let x1 = state \\bits32 1 in \n  let x3 = state \\bits32 3 in \n  let y0 = SubWord x1 in\n  let y1 = RotWord (SubWord x1) `^` rcon in\n  let y2 = SubWord x3 in \n  let y3 = RotWord (SubWord x3) `^` rcon in\n  W4u32.pack4 [y0; y1; y2; y3] (* Generates new key material based on previous state and round constant *)\naxiomatized by AESKEYGENASSISTE.\n\n(* --------------------------------------------------------------------- *)\n(* x86 AES instructions slightly differ from AES specification           *) \n(* - x86 AESENC/AESENCLAST swap the SubBytes and ShiftRows operations   *)   \n(* - x86 AESDEC instruction assumes that InvMixColumns has been applied  *)\n(*   to rkeys, we do not assume it here and use the normal specification *)\n(* So we redefine it to have the standard specification                  *)\n\nop AESENC_ (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  let state = MixColumns state in\n  AddRoundKey state rkey (* Modified AES encoding operation to match standard *)\naxiomatized by AESENC_E.\n\nop AESENCLAST_  (state rkey: W128.t) =\n  let state = SubBytes state in \n  let state = ShiftRows state in\n  AddRoundKey state rkey (* Modified AES encoding operation for the last round *)\naxiomatized by AESENCLAST_E.\n  \nop AESDEC_ (state rkey: W128.t) = \n  let state = InvShiftRows state in\n  let state = InvSubBytes state in\n  let state = AddRoundKey state rkey in\n  InvMixColumns state (* Modified AES decoding operation to match standard *)\naxiomatized by AESDEC_E.\n\nlemma ShiftRows_SubBytes s : ShiftRows (SubBytes s) = SubBytes (ShiftRows s). (* ShiftRows commutes with SubBytes operation *)\nproof. by rewrite !ShiftRowsE; cbv delta. qed.\n\nlemma AESENC_AESENC_ s k : AESENC s k = AESENC_ s k. (* The AESENC operation is equivalent to the modified version *)\nproof.\n  by rewrite AESENCE AESENC_E /= ShiftRows_SubBytes. (* Using commutativity property *)\nqed.\n\nlemma AESENCLAST_AESENCLAST_ s k : AESENCLAST s k = AESENCLAST_ s k. (* The AESENCLAST operation is equivalent to the modified version *)\nproof.\n  by rewrite AESENCLASTE AESENCLAST_E /= ShiftRows_SubBytes. (* Using commutativity property *)\nqed.\n\nlemma AESDEC_AESDEC_ s k : AESDEC s (InvMixColumns k) = AESDEC_ s k. (* The AESDEC operation is equivalent to the modified version *)\nproof. by rewrite AESDECE AESDEC_E /= InvMixColumnsD. qed."
    },
    {
        "file": "EC-1/basic-hash-auth.ec",
        "logic": "---\n\n### Description of the Basic Hash Protocol\n\n**1. Key and Plaintext Spaces:**\n- The protocol operates over a key space, denoted as `key`, and a plaintext space, denoted as `ptxt`.\n- Keys are generated using a distribution `dkey`, which is defined to be full, lossless, and uniform.\n- Plaintexts (nonces) are generated using a distribution `dnonce`, which is lossless and uniform but not necessarily full.\n\n**2. Pseudorandom Functions (PRFs):**\n- The protocol utilizes multiple Pseudorandom Functions (PRFs) denoted by `F`, which take a key and a plaintext as inputs and produce a plaintext output.\n- A module is defined for the PRFs, including procedures for initialization, function evaluation, and verification (check).\n\n**3. Unforgeable Random Functions (RF):**\n- The protocol incorporates unforgeable random functions (RF) with the assumption that the hash functions used are indistinguishable from a uniform distribution over plaintexts.\n- The RF is modeled with a distribution `drf`, which is also defined to be lossless and uniform.\n\n**4. Basic Hash Protocol:**\n- The Basic Hash protocol allows tags to create messages (tagging) and a reader to verify these messages.\n- The protocol maintains logs of tag outputs and any forged messages detected by the reader.\n- There are two versions of the Basic Hash module: one without initialization (`BasicHash0`) and one with initialization (`BasicHash`).\n\n**5. Authentication Game:**\n- The protocol defines an authentication game where an adversary attempts to forge a message that a legitimate reader would accept.\n- The game checks for the existence of forged messages logged by the reader during the authentication process.\n\n**6. Security Properties:**\n- The protocol aims to ensure that an adversary cannot win the authentication game instantiated with an ideal unforgeable hash function.\n- Several lemmas are provided to establish the probability of the adversary winning the game and to analyze the indistinguishability of the PRFs used.\n\n**7. Distinguisher Against PRFs:**\n- A module for distinguishing between the PRFs used in the Basic Hash protocol is defined, allowing for the analysis of their security.\n\n---\n\nThis description encapsulates the key components and functionalities of the Basic Hash protocol, including its reliance on PRFs and RFs, the authentication process, and the security analysis through an adversarial game.",
        "code": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key.\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni.\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt.\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni.\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni).\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni).\n\nhint exact random : dnonce_ll.\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt.\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init]\n}.\n\nmodule PRFs = {\n  var ks : key list\n  \n  proc init(n : int) : unit = {\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey;\n     ks <- k :: ks;\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return F k x;\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    var k;\n    i <- if (size ks <= i) then 0 else i;\n    k <- nth witness ks i;\n    return (F k x = s);\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr.\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i).\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni).\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni).\n\nmodule EUF_RF = {\n  var n : int\n  var m : (int * ptxt, ptxt) fmap\n  \n  proc init(i : int) : unit = {\n    n <- i;\n    m <- empty;\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = {\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i;\n\n    if ((i,x) \\notin m) {\n      r <$ drf i;\n      m.[(i,x)] <- r;\n    }\n    \n    return oget m.[(i,x)];\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = {\n    i <- if (n <= i) then 0 else i;\n    return ((i,x) \\in m && oget m.[(i,x)] = s);\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int.\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list\n  var reader_forged : (int * ptxt * ptxt) list\n\n  proc tag (i : int) : ptxt * ptxt = {\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i;\n    n <$ dnonce;\n    h <@ H.f(i,n);\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs;\n    return (n, h);\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    \n    var b;\n    b <- H.check(i, n, h);\n    return b;\n  } \n\n  proc reader (n h : ptxt) : bool = {    \n    var r, b, i;\n    b <- false;\n    i <- 0;\n    while (i < n_tag) {\n      r <- H.check(i, n, h);\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged;\n      }\n\n      b <- b || r;\n      i <- i + 1;\n    }\n    return b;\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag); \n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit\n  proc tag (_ : int) : ptxt * ptxt\n  proc reader (_: ptxt * ptxt) : bool\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init]\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H)\n  module Adv = Adv (BH)\n\n  proc main () = {\n    BH.init ();\n    Adv.a();\n    return (exists x, mem BasicHash0.reader_forged x );\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = {\n    var b;\n\n    F.init(n_tag);\n    b <@ D(F).distinguish();\n    return b;\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F)\n  module A = A (BH)\n  \n  proc distinguish () = {\n    BasicHash0.tag_outputs <- [];\n    BasicHash0.reader_forged <- [];\n    A.a();\n    return (exists x, mem BasicHash0.reader_forged x ); \n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed.",
        "codenote": "(* Authentication of the Basic Hash protocol, multiple tags. *)\nrequire import AllCore List FSet SmtMap.\nrequire import Distr DBool.\nrequire FelTactic.\n\n(*-----------------------------------------------------------------------*)\n(* Key space *)\ntype key. (* Type representing the key space used for the PRFs *)\n\n(* Full, lossless and uniform distribution over keys. *)\nop dkey: { key distr |     is_lossless dkey\n                        /\\ is_full dkey\n                        /\\ is_uniform dkey } as dkey_llfuuni. (* Distribution over keys *)\n\n(*-----------------------------------------------------------------------*)\n(* Ptxt space *)\ntype ptxt. (* Type representing plaintext messages *)\n\n(* Lossless and uniform distribution over ptxts (not full). *)\nop dnonce: { ptxt distr |    is_lossless dnonce\n                          /\\ is_uniform dnonce } as dnonce_lluni. (* Distribution of nonces *)\n\nlemma dnonce_ll (i : int) : is_lossless dnonce by smt (dnonce_lluni). (* Nonce distribution is lossless *)\nlemma dnonce_uni (i : int) : is_uniform dnonce by smt (dnonce_lluni). (* Nonce distribution is uniform *)\n\nhint exact random : dnonce_ll. (* Hint for random choice of nonces *)\n\n(*-----------------------------------------------------------------------*)\n(* multiple PRF *)\nop F : key -> ptxt -> ptxt. (* Pseudorandom function from key and plaintext to plaintext *)\n\nmodule type PRFs = {\n  proc init (n : int) : unit\n  proc f(i : int, x : ptxt) : ptxt\n  proc check(i : int, x : ptxt, s : ptxt) : bool\n}.\n\nmodule type PRFs_Oracles = {\n  include PRFs[-init] (* Interface for PRF oracles, excluding the initialization *)\n}.\n\nmodule PRFs = {\n  var ks : key list (* List to hold keys initialized for multiple PRFs *)\n  \n  proc init(n : int) : unit = { (* Initialization procedure for PRFs *)\n    var i, k;\n    i <- 0;\n    while (i < n){\n     k <$ dkey; (* Sample a key from the dkey distribution *)\n     ks <- k :: ks; (* Add the sampled key to the list *)\n    } \n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = { (* PRF evaluation *)\n    var k;\n    i <- if (size ks <= i) then 0 else i; (* Ensure valid index *)\n    k <- nth witness ks i; (* Retrieve the key at index i *)\n    return F k x; (* Apply the PRF *)\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = { (* Check if the PRF output matches a given value *)\n    var k;\n    i <- if (size ks <= i) then 0 else i; (* Ensure valid index *)\n    k <- nth witness ks i; (* Retrieve the key at index i *)\n    return (F k x = s); (* Compare PRF output with s *)\n  }\n}.\n\n(* Unforgeable multiple RF *)\n(* We assume that: \n   i) the hash functions are indistinguishable from a lossless and uniform\n   distributions over ptxts (not full).\n   ii) the hash functions are unforgeable.\n   \n   ii) is a consequence of i) whenever the hash function image set is large. *)\nop drf (i : int) : ptxt distr. (* Distribution over random function outputs *)\naxiom drf_lluni (i : int) : is_lossless (drf i) /\\ is_uniform (drf i). (* Random function properties *)\nlemma drf_ll (i : int) : is_lossless (drf i) by smt (drf_lluni). (* Random function output is lossless *)\nlemma drf_uni (i : int) : is_uniform (drf i) by smt (drf_lluni). (* Random function output is uniform *)\n\nmodule EUF_RF = {\n  var n : int (* Number of tags *)\n  var m : (int * ptxt, ptxt) fmap (* Mapping of (tag, nonce) to output *)\n\n  proc init(i : int) : unit = { (* Initialization procedure for unforgeable RFs *)\n    n <- i; (* Set the number of tags *)\n    m <- empty; (* Initialize the mapping to empty *)\n  }\n  \n  proc f(i : int, x : ptxt) : ptxt = { (* Evaluate the random function *)\n    var r : ptxt;\n    i <- if (n <= i) then 0 else i; (* Ensure valid index *)\n\n    if ((i,x) \\notin m) { (* Check if the (tag, nonce) pair is new *)\n      r <$ drf i; (* Sample output from the distribution *)\n      m.[(i,x)] <- r; (* Store the output in the mapping *)\n    }\n    \n    return oget m.[(i,x)]; (* Return the output for (i, x) *)\n  }\n\n  proc check(i : int, x : ptxt, s : ptxt) = { (* Check if the output matches expected value *)\n    i <- if (n <= i) then 0 else i; (* Ensure valid index *)\n    return ((i,x) \\in m && oget m.[(i,x)] = s); (* Verify existence and compare outputs *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\n(* Basic Hash protocol, multiple tags and one reader. *)\n\nop n_tag : int. (* Number of tags in the protocol *)\naxiom n_tag_p : 0 < n_tag.  (* We have at least one tag. *)\n\n(* Without initialization, with logs to express the authentication property. *)\nmodule BasicHash0 (H : PRFs_Oracles) = {\n  var tag_outputs   : (int * ptxt * ptxt) list (* Logs of tag outputs *)\n  var reader_forged : (int * ptxt * ptxt) list (* Logs of forged messages by the reader *)\n\n  proc tag (i : int) : ptxt * ptxt = { (* Tag procedure, generates nonce and hash *)\n    var n, h;\n    i <- if (n_tag <= i) then 0 else i; (* Ensure valid index *)\n    n <$ dnonce; (* Sample a nonce *)\n    h <@ H.f(i,n); (* Compute hash using current tag and nonce *)\n    (* We log the output message *)\n    tag_outputs <- (i,n,h) :: tag_outputs; (* Store the output log *)\n    return (n, h); (* Return the nonce and hash *)\n  }    \n  \n  proc reader_i (i : int, n h : ptxt) : bool = {    (* Reader's verification for a specific tag *)\n    var b;\n    b <- H.check(i, n, h); (* Use the check procedure to verify *)\n    return b; (* Return the result of the check *)\n  } \n\n  proc reader (n h : ptxt) : bool = {    (* General reader procedure for all tags *)\n    var r, b, i;\n    b <- false; (* Initialize result as false *)\n    i <- 0; (* Start from the first tag *)\n    while (i < n_tag) {\n      r <- H.check(i, n, h); (* Check the hash against each tag's expected output *)\n      (* If the message is accepted but was not sent by a honest tag, \n         we log it. *)\n      if (r && ! (mem tag_outputs (i,n,h))){ \n        reader_forged <- (i,n,h) :: reader_forged; (* Log forged messages *)\n      }\n\n      b <- b || r; (* Aggregate results of checks *)\n      i <- i + 1; (* Move to the next tag *)\n    }\n    return b; (* Return whether any tag accepted the message *)\n  }\n}.\n\n(* With initialization *)\nmodule BasicHash (H : PRFs) = {\n  module BH0 = BasicHash0(H) (* Instantiate BasicHash0 with PRFs *)\n  include BH0\n\n  proc init () : unit = { \n    H.init(n_tag);  (* Initialize the PRFs *)\n    BasicHash0.tag_outputs <- []; (* Reset tag outputs log *)\n    BasicHash0.reader_forged <- []; (* Reset reader forged logs *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashT = {\n  proc init () : unit (* Initialization procedure signature *)\n  proc tag (_ : int) : ptxt * ptxt (* Tag generation signature *)\n  proc reader (_: ptxt * ptxt) : bool (* Reader verification signature *)\n}.\n\nmodule type BasicHashT0 = {\n  include BasicHashT[-init] (* Type excluding the initialization *)\n}.\n\n(* Adversary against the Basic Hash protocol authentication *)\nmodule type Adv (BH : BasicHashT0) = {\n  proc a () : unit (* Adversary's action in the game *)\n}.\n\nmodule type BasicHashF (H : PRFs) = {\n  include BasicHashT (* Full interface including BasicHash procedures *)\n}.\n\n(* Basic Hash protocol authentication game *)\nmodule AuthGame (Adv : Adv) (BH : BasicHashF) (H : PRFs) = {\n  module BH = BH(H) (* Instantiate BasicHashF with PRFs *)\n  module Adv = Adv (BH) (* Instantiate the adversary with BH *)\n\n  proc main () = { (* Main procedure for the authentication game *)\n    BH.init (); (* Initialize the Basic Hash instance *)\n    Adv.a(); (* Run the adversary's attack *)\n    return (exists x, mem BasicHash0.reader_forged x ); (* Check forged outputs *)\n  }\n}.\n\n\n(*-----------------------------------------------------------------------*)\n(* Distinguisher against n_tag PRFs. *)\nmodule type Distinguisher (F : PRFs_Oracles) = {\n  proc distinguish(): bool (* Distinguisher procedure to differentiate *)\n}.\n\n(* Indistinguishability game for unforgeable PRFs. *)\nmodule EUF_PRF_IND (F : PRFs) (D : Distinguisher) = {\n  proc main(): bool = { (* Main procedure for the indistinguishability game *)\n    var b;\n\n    F.init(n_tag); (* Initialize the PRFs *)\n    b <@ D(F).distinguish(); (* Run the distinguisher *)\n    return b; (* Return the result of the distinguisher *)\n  }\n}.\n\n(*-----------------------------------------------------------------------*)\nmodule type BasicHashF0 (H : PRFs_Oracles) = {\n  include BasicHashT0 (* Type representing BasicHash interface without init *)\n}.\n\n(* The PRF/RF distinguisher is almost identical to the authentication game,\n   except that it does not initialize the PRF. *)\nmodule D (A : Adv) (BH : BasicHashF0) (F : PRFs_Oracles) = {\n  module BH = BH(F) (* Instantiate BasicHashF0 with PRFs *)\n  module A = A (BH) (* Instantiate the adversary *)\n\n  proc distinguish () = { (* Distinguisher procedure for PRF/RF *)\n    BasicHash0.tag_outputs <- [];  (* Reset tag outputs *)\n    BasicHash0.reader_forged <- [];  (* Reset reader forged logs *)\n    A.a(); (* Run the adversary *)\n    return (exists x, mem BasicHash0.reader_forged x );  (* Return result of forgery *)\n  } \n}.\n\n(*-----------------------------------------------------------------------*)\n(* Given an adversary A against the Authentication Game, we build an\n   an adversary B against the unforgeable PRF H. *)\n\n(* The probability of winning the indistinguishability game against\n   the RF is identical to the authentication game using the RF. *)\nlemma eq_RF &m (A <: Adv {BasicHash, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] =\n    Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* Idem with PRF *)\nlemma eq_PRF &m (A <: Adv {BasicHash, PRFs}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] =\n    Pr[EUF_PRF_IND(PRFs, D(A, BasicHash0)).main() @ &m : res]\nby byequiv; auto; proc; inline *; wp; sim; auto. \n\n(* The adversary cannot win the authentication game instantiated\n    with the ideal unforgeable hash function. *)\nlemma res_0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, EUF_RF).main() @ &m : res] = 0%r.\nproof.\n  byphoare; auto. \n  hoare; proc*; inline *; wp; sp. \n  call (_: BasicHash0.reader_forged = [] /\\ EUF_RF.n = n_tag /\\\n           forall j x y, (EUF_RF.m.[(j,x)] <> None && oget EUF_RF.m.[(j,x)] = y)\n                          => (j, x, y) \\in BasicHash0.tag_outputs{hr}); auto.\n\n  (* tag *)\n  + proc; inline *; auto; sp.\n    seq 1: (#pre); 1  : by conseq />; auto; smt().\n    sp; if; 2: by conseq/>;auto;smt().\n    by auto; smt(get_setE).\n\n  (* reader *)\n  + proc; inline *; conseq />.\n    while (0 <= i <= n_tag /\\ #pre) => //; 2 : by conseq />; auto; smt(n_tag_p).\n    conseq />; auto => /> *; smt(get_setE).\n\n  + by move => *; smt.\nqed.\n\n(* We conclude. *)\nlemma auth0 &m (A <: Adv {BasicHash, PRFs, EUF_RF}) : \n    Pr[AuthGame(A, BasicHash, PRFs).main() @ &m : res] = \n      (   Pr[EUF_PRF_IND(PRFs,   D(A, BasicHash0)).main() @ &m : res] \n        - Pr[EUF_PRF_IND(EUF_RF, D(A, BasicHash0)).main() @ &m : res] ).\nproof.\n  rewrite (eq_PRF &m A) -(eq_RF &m A) (res_0 &m A); by smt ().\nqed."
    }
]