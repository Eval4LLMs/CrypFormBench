[
    {
        "file": "SPDL-1/andrew-lowe-ban.spdl",
        "logic": "---\n\n### Protocol Description: Andrew Secure RPC\n\n**Overview:**\nThe Andrew Secure RPC protocol is a secure communication protocol designed for two parties, an Initiator (I) and a Responder (R), to establish a secure session using a shared secret key. The protocol ensures confidentiality and integrity of messages exchanged between the parties while preventing unauthorized access.\n\n**Roles:**\n1. **Initiator (I)**: The party that starts the communication and sends the initial message.\n2. **Responder (R)**: The party that responds to the Initiator's message and completes the session establishment.\n\n**Key Components:**\n- **Nonces**: Random values (`ni` for Initiator and `nr` for Responder) used to ensure freshness of messages and prevent replay attacks.\n- **Session Key (kir)**: A key shared between the Initiator and Responder for the duration of the session. This key is derived during the protocol execution.\n\n**Message Flow:**\n1. **Step 1**: The Initiator (I) generates a nonce (`ni`) and sends a message to the Responder (R) containing its identity (`I`) and the nonce (`ni`).\n   - Message: `send_1(I, R, I, ni)`\n\n2. **Step 2**: The Responder (R) receives the message, generates its own nonce (`nr`), and creates a session key (`kir`). It then sends back a message to the Initiator containing the nonce (`ni`), the session key (`kir`), and its identity (`R`), all encrypted with the shared key `k(I, R)`.\n   - Message: `send_2(R, I, {ni, kir, R}k(I, R))`\n\n3. **Step 3**: The Initiator (I) receives the message, extracts the session key (`kir`), and sends a confirmation message back to the Responder (R) containing the nonce (`ni`) encrypted with the session key (`kir`).\n   - Message: `send_3(I, R, {ni}kir)`\n\n4. **Step 4**: After confirmation, the Responder (R) sends its nonce (`nr`) back to the Initiator (I) to complete the session establishment.\n   - Message: `send_4(R, I, nr)`\n\n**Claims:**\n- **Initiator Claims**:\n  1. `claim_I1(I, Nisynch)`: The Initiator claims that the session is synchronized.\n  2. `claim_I2(I, Secret, kir)`: The Initiator claims that it has established a secret session key (`kir`).\n  3. `claim_I3(I, Empty, (Fresh, kir))`: The Initiator claims the session key (`kir`) is fresh.\n\n- **Responder Claims**:\n  1. `claim_R1(R, Nisynch)`: The Responder claims that the session is synchronized.\n  2. `claim_R2(R, Secret, kir)`: The Responder claims that it has established a secret session key (`kir`).\n  3. `claim_R3(R, Empty, (Fresh, kir))`: The Responder claims the session key (`kir`) is fresh.\n\n**Important Notes:**\n- The shared key between the Initiator and Responder (`k(I, R)`) is modeled as a symmetric key, and there is currently no formalism in the model to express that this key is equal to `k(R, I)`. \n- The placement of the reception of message 4 by the Initiator after the synchronization claim is intentional to prevent trivial synchronization attacks.\n- According to the SPORE library, there are no known attacks on this protocol, indicating a robust design against common vulnerabilities.\n\n---",
        "code": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}",
        "codenote": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possible that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initiator has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;  # Nonce generated by I for freshness\n        var nr: Nonce;    # Nonce received from R\n        var kir: SessionKey; # Session key to be established\n\n        send_1(I,R, I,ni );  # I sends its identity and nonce ni to R\n        recv_2(R,I, {ni,kir,R}k(I,R) );  # R responds with a secured message containing ni, the session key, and R's identity\n        send_3(I,R, {ni}kir );  # I sends the nonce ni encrypted with the session key to R\n        claim_I1(I,Nisynch);  # I claims synchronization\n        claim_I2(I,Secret, kir);  # I claims possession of the session key kir\n        claim_I3(I,Empty, (Fresh,kir));  # I claims that kir is fresh\n        recv_4(R,I, nr );  # I receives a nonce nr from R\n    }    \n    \n    role R\n    {\n        var ni: Nonce;  # Nonce received from I\n        fresh nr: Nonce; # Nonce generated by R for freshness\n        fresh kir: SessionKey; # Session key to be established\n\n        recv_1(I,R, I,ni );  # R receives identity and nonce ni from I\n        send_2(R,I, {ni,kir,R}k(I,R) );  # R sends back the secured message with ni, the session key, and its identity\n        recv_3(I,R, {ni}kir );  # R receives the secured nonce ni from I\n        send_4(R,I, nr );  # R sends its nonce nr back to I\n        claim_R1(R,Nisynch);  # R claims synchronization\n        claim_R2(R,Secret, kir);  # R claims possession of the session key kir\n        claim_R3(R,Empty, (Fresh,kir));  # R claims that kir is fresh\n    }\n}"
    },
    {
        "file": "SPDL-1/DHKE-1.spdl",
        "logic": "---\n\n**Protocol Description: Two-Move Diffie-Hellman with Pseudo-Random Functions**\n\nThis protocol is an adaptation of the two-move Diffie-Hellman key exchange method specified in ISO 9798-3, utilizing pseudo-random functions instead of signatures for message integrity. The protocol consists of two main roles: the initiator (I) and the responder (R). \n\n### Roles\n\n#### 1. Initiator (I)\n- **Initialization**: The initiator begins by creating a fresh nonce `x` to ensure the freshness of the session.\n- **Compromise Message**: The initiator sends a compromise message to itself, indicating that it is initiating a session.\n- **First Message**: The initiator sends a message to the responder (R), which includes:\n  - The value `g1(x)`, a transformed version of the nonce `x`.\n  - The identity of the responder (R).\n  - A signed message containing `g1(x)` and the responder's identity, ensuring the authenticity of the message using `sk(I)`, the secret key of the initiator.\n  \n- **Second Message Reception**: The initiator waits to receive a message from the responder, which should contain:\n  - The value `beta`, a ticket sent by the responder.\n  - The nonce `i`, which is unique for this session.\n  - The identity of the initiator (I) and a signed message ensuring the integrity of the response using `sk(R)`.\n\n- **Final Computation**: After receiving the second message, the initiator computes a hash value using the pseudo-random function `h1` on the concatenated values of `beta` and `x` and sends this as the final message.\n\n- **Claim**: The initiator claims that the shared secret key `SKR` is equal to `g2(beta, x)`.\n\n#### 2. Responder (R)\n- **Initialization**: The responder starts by creating a fresh nonce `y` and another fresh nonce `i` for session uniqueness.\n- **Compromise Message**: The responder sends a compromise message to itself, indicating readiness to participate in the exchange.\n- **First Message Reception**: The responder receives the first message from the initiator, which includes:\n  - The `alpha` value (the first part of the key exchange).\n  - The identity of the responder (R).\n  - A signed message ensuring the integrity of the incoming message using `sk(I)`.\n\n- **Second Message**: The responder prepares to send a message back to the initiator, which includes:\n  - The value `alpha`, received from the initiator.\n  - The transformed nonce `g1(y)`.\n  - The nonce `i` and the identity of the initiator (I), all signed with `sk(R)` for authenticity.\n\n- **Final Message Reception**: The responder awaits the final message from the initiator, which is a hash value generated by the initiator.\n\n- **Claim**: The responder claims that the shared secret key `SKR` is equal to `g2(alpha, y)`.\n\n### Key Properties\n- **Security**: The use of nonces and pseudo-random functions enhances security by ensuring messages cannot be reused or replayed.\n- **Authentication**: The inclusion of secret keys in the signing process guarantees that messages are authentic and have not been tampered with.\n\n### Conclusion\nThis two-move Diffie-Hellman protocol allows two parties to securely establish a shared secret key over an insecure channel, leveraging the properties of nonce generation and hash functions to ensure the integrity and confidentiality of the exchanged information.\n\n---",
        "code": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "codenote": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA  // Initiator role\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );  // RA receives message\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );  // RA sends response\n\t}\n\trole RS  // Responder role\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) ); // RS receives a hashed message\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) ); // RS sends a hashed response\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R) // Two-party authenticated key exchange\n{\n\trole I  // Initiator role\n\t{\n\t\tfresh x: Nonce;  // Nonce generation for freshness\n\t\tvar i: Nonce;  // Verifier nonce\n\t\tvar beta: Ticket;  // Ticket received from R\n\n\t\tsend_Compromise(I,I, x ); // Initiator sends a compromise message\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        ); // First message to R\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) ); // Initiator receives response from R\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) ); // Send hashed key derived from beta and x\n\n\t\tclaim(I,SKR, g2(beta,x) ); // Claim key SKR\n\t}\t\n\t\n\trole R  // Responder role\n\t{\n\t\tfresh y: Nonce;  // Nonce generation for freshness\n\t\tfresh i: Nonce;  // Initiator nonce\n\t\tvar alpha: Ticket;  // Ticket received from I\n\n\t\tsend_Compromise(R,R, y,i ); // Responder sends a compromise message\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         ); // Respond to initiator's message\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) ); // Send response to initiator\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) ); // Receive hashed key\n\n\t\tclaim(R,SKR, g2(alpha,y) ); // Claim key SKR\n\t}\n}"
    }
]