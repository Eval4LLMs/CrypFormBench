[
    {
        "file": "SPDL-1/andrew-lowe-ban.spdl",
        "logic": "---\n\n### Protocol Description: Andrew Secure RPC\n\n**Overview:**\nThe Andrew Secure RPC protocol is a secure communication protocol designed for two parties, an Initiator (I) and a Responder (R), to establish a secure session using a shared secret key. The protocol ensures confidentiality and integrity of messages exchanged between the parties while preventing unauthorized access.\n\n**Roles:**\n1. **Initiator (I)**: The party that starts the communication and sends the initial message.\n2. **Responder (R)**: The party that responds to the Initiator's message and completes the session establishment.\n\n**Key Components:**\n- **Nonces**: Random values (`ni` for Initiator and `nr` for Responder) used to ensure freshness of messages and prevent replay attacks.\n- **Session Key (kir)**: A key shared between the Initiator and Responder for the duration of the session. This key is derived during the protocol execution.\n\n**Message Flow:**\n1. **Step 1**: The Initiator (I) generates a nonce (`ni`) and sends a message to the Responder (R) containing its identity (`I`) and the nonce (`ni`).\n   - Message: `send_1(I, R, I, ni)`\n\n2. **Step 2**: The Responder (R) receives the message, generates its own nonce (`nr`), and creates a session key (`kir`). It then sends back a message to the Initiator containing the nonce (`ni`), the session key (`kir`), and its identity (`R`), all encrypted with the shared key `k(I, R)`.\n   - Message: `send_2(R, I, {ni, kir, R}k(I, R))`\n\n3. **Step 3**: The Initiator (I) receives the message, extracts the session key (`kir`), and sends a confirmation message back to the Responder (R) containing the nonce (`ni`) encrypted with the session key (`kir`).\n   - Message: `send_3(I, R, {ni}kir)`\n\n4. **Step 4**: After confirmation, the Responder (R) sends its nonce (`nr`) back to the Initiator (I) to complete the session establishment.\n   - Message: `send_4(R, I, nr)`\n\n**Claims:**\n- **Initiator Claims**:\n  1. `claim_I1(I, Nisynch)`: The Initiator claims that the session is synchronized.\n  2. `claim_I2(I, Secret, kir)`: The Initiator claims that it has established a secret session key (`kir`).\n  3. `claim_I3(I, Empty, (Fresh, kir))`: The Initiator claims the session key (`kir`) is fresh.\n\n- **Responder Claims**:\n  1. `claim_R1(R, Nisynch)`: The Responder claims that the session is synchronized.\n  2. `claim_R2(R, Secret, kir)`: The Responder claims that it has established a secret session key (`kir`).\n  3. `claim_R3(R, Empty, (Fresh, kir))`: The Responder claims the session key (`kir`) is fresh.\n\n**Important Notes:**\n- The shared key between the Initiator and Responder (`k(I, R)`) is modeled as a symmetric key, and there is currently no formalism in the model to express that this key is equal to `k(R, I)`. \n- The placement of the reception of message 4 by the Initiator after the synchronization claim is intentional to prevent trivial synchronization attacks.\n- According to the SPORE library, there are no known attacks on this protocol, indicating a robust design against common vulnerabilities.\n\n---",
        "code": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possile that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initatior has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;\n        var nr: Nonce;\n        var kir: SessionKey;\n\n        send_1(I,R, I,ni );\n        recv_2(R,I, {ni,kir,R}k(I,R) );\n        send_3(I,R, {ni}kir );\n        claim_I1(I,Nisynch);\n        claim_I2(I,Secret, kir);\n        claim_I3(I,Empty, (Fresh,kir));\n        recv_4(R,I, nr );\n    }    \n    \n    role R\n    {\n        var ni: Nonce;\n        fresh nr: Nonce;\n        fresh kir: SessionKey;\n\n        recv_1(I,R, I,ni );\n        send_2(R,I, {ni,kir,R}k(I,R) );\n        recv_3(I,R, {ni}kir );\n        send_4(R,I, nr );\n        claim_R1(R,Nisynch);\n        claim_R2(R,Secret, kir);\n        claim_R3(R,Empty, (Fresh,kir));\n    }\n}",
        "codenote": "# Lowe modified BAN concrete Andrew Secure RPC\n#\n# Modelled after the description in the SPORE library\n# http://www.lsv.ens-cachan.fr/spore/andrewLowe.html\n#\n# Note:\n# The shared key between I and R is modelled as k(I,R) currently\n# there is no way to express that this key is equal to k(R,I)\n# So it is possible that certain attacks that use this property are not found\n#\n# Note:\n# Recv 4 by the Initiator has been placed after the synchronisation claim\n# as it allows trivial synchronisation attacks otherwise (the message is\n# completely fresh and can therefore always be replaced by an arbitrary value\n# created by the intruder) which are not considered in SPORE\n#\n# Note:\n# According to SPORE there are no known attacks on this protocol\n#\n\nusertype SessionKey;\nconst Fresh: Function;\nconst Compromised: Function;\n\nprotocol andrew-LoweBan(I,R)\n{\n    role I\n    {\n        fresh ni: Nonce;  # Nonce generated by I for freshness\n        var nr: Nonce;    # Nonce received from R\n        var kir: SessionKey; # Session key to be established\n\n        send_1(I,R, I,ni );  # I sends its identity and nonce ni to R\n        recv_2(R,I, {ni,kir,R}k(I,R) );  # R responds with a secured message containing ni, the session key, and R's identity\n        send_3(I,R, {ni}kir );  # I sends the nonce ni encrypted with the session key to R\n        claim_I1(I,Nisynch);  # I claims synchronization\n        claim_I2(I,Secret, kir);  # I claims possession of the session key kir\n        claim_I3(I,Empty, (Fresh,kir));  # I claims that kir is fresh\n        recv_4(R,I, nr );  # I receives a nonce nr from R\n    }    \n    \n    role R\n    {\n        var ni: Nonce;  # Nonce received from I\n        fresh nr: Nonce; # Nonce generated by R for freshness\n        fresh kir: SessionKey; # Session key to be established\n\n        recv_1(I,R, I,ni );  # R receives identity and nonce ni from I\n        send_2(R,I, {ni,kir,R}k(I,R) );  # R sends back the secured message with ni, the session key, and its identity\n        recv_3(I,R, {ni}kir );  # R receives the secured nonce ni from I\n        send_4(R,I, nr );  # R sends its nonce nr back to I\n        claim_R1(R,Nisynch);  # R claims synchronization\n        claim_R2(R,Secret, kir);  # R claims possession of the session key kir\n        claim_R3(R,Empty, (Fresh,kir));  # R claims that kir is fresh\n    }\n}"
    },
    {
        "file": "SPDL-1/DHKE-1.spdl",
        "logic": "---\n\n**Protocol Description: Two-Move Diffie-Hellman with Pseudo-Random Functions**\n\nThis protocol is an adaptation of the two-move Diffie-Hellman key exchange method specified in ISO 9798-3, utilizing pseudo-random functions instead of signatures for message integrity. The protocol consists of two main roles: the initiator (I) and the responder (R). \n\n### Roles\n\n#### 1. Initiator (I)\n- **Initialization**: The initiator begins by creating a fresh nonce `x` to ensure the freshness of the session.\n- **Compromise Message**: The initiator sends a compromise message to itself, indicating that it is initiating a session.\n- **First Message**: The initiator sends a message to the responder (R), which includes:\n  - The value `g1(x)`, a transformed version of the nonce `x`.\n  - The identity of the responder (R).\n  - A signed message containing `g1(x)` and the responder's identity, ensuring the authenticity of the message using `sk(I)`, the secret key of the initiator.\n  \n- **Second Message Reception**: The initiator waits to receive a message from the responder, which should contain:\n  - The value `beta`, a ticket sent by the responder.\n  - The nonce `i`, which is unique for this session.\n  - The identity of the initiator (I) and a signed message ensuring the integrity of the response using `sk(R)`.\n\n- **Final Computation**: After receiving the second message, the initiator computes a hash value using the pseudo-random function `h1` on the concatenated values of `beta` and `x` and sends this as the final message.\n\n- **Claim**: The initiator claims that the shared secret key `SKR` is equal to `g2(beta, x)`.\n\n#### 2. Responder (R)\n- **Initialization**: The responder starts by creating a fresh nonce `y` and another fresh nonce `i` for session uniqueness.\n- **Compromise Message**: The responder sends a compromise message to itself, indicating readiness to participate in the exchange.\n- **First Message Reception**: The responder receives the first message from the initiator, which includes:\n  - The `alpha` value (the first part of the key exchange).\n  - The identity of the responder (R).\n  - A signed message ensuring the integrity of the incoming message using `sk(I)`.\n\n- **Second Message**: The responder prepares to send a message back to the initiator, which includes:\n  - The value `alpha`, received from the initiator.\n  - The transformed nonce `g1(y)`.\n  - The nonce `i` and the identity of the initiator (I), all signed with `sk(R)` for authenticity.\n\n- **Final Message Reception**: The responder awaits the final message from the initiator, which is a hash value generated by the initiator.\n\n- **Claim**: The responder claims that the shared secret key `SKR` is equal to `g2(alpha, y)`.\n\n### Key Properties\n- **Security**: The use of nonces and pseudo-random functions enhances security by ensuring messages cannot be reused or replayed.\n- **Authentication**: The inclusion of secret keys in the signing process guarantees that messages are authentic and have not been tampered with.\n\n### Conclusion\nThis two-move Diffie-Hellman protocol allows two parties to securely establish a shared secret key over an insecure channel, leveraging the properties of nonce generation and hash functions to ensure the integrity and confidentiality of the exchanged information.\n\n---",
        "code": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RS\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) );\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) );\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar i: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x );\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        );\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) );\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tfresh i: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\tsend_Compromise(R,R, y,i );\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         );\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) );\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "codenote": "/* \n * Adaption of two-move Diffie-Hellman ISO-9798-3 according to Shmatikov, Gupta\n *\n * Version with no signatures, but pseudo-random functions\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RS)\n{\n\trole RA  // Initiator role\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );  // RA receives message\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );  // RA sends response\n\t}\n\trole RS  // Responder role\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!3(RS,RS, h1( g2(g1(T1),T2) ) ); // RS receives a hashed message\n\t\tsend_!4(RS,RS, h1( g2(g1(T2),T1) ) ); // RS sends a hashed response\n\t}\n}\n\n// The protocol description\n\nprotocol twoDHiso-prf(I,R) // Two-party authenticated key exchange\n{\n\trole I  // Initiator role\n\t{\n\t\tfresh x: Nonce;  // Nonce generation for freshness\n\t\tvar i: Nonce;  // Verifier nonce\n\t\tvar beta: Ticket;  // Ticket received from R\n\n\t\tsend_Compromise(I,I, x ); // Initiator sends a compromise message\n\n\t\tsend_1(I,R,  g1(x),R,         { g1(x),R }sk(I)        ); // First message to R\n\t\trecv_2(R,I,  g1(x),beta,i,I,  { g1(x),beta,i,I }sk(R) ); // Initiator receives response from R\n\t\tsend_!3(I,R,  h1( g2(beta,x ) ) ); // Send hashed key derived from beta and x\n\n\t\tclaim(I,SKR, g2(beta,x) ); // Claim key SKR\n\t}\t\n\t\n\trole R  // Responder role\n\t{\n\t\tfresh y: Nonce;  // Nonce generation for freshness\n\t\tfresh i: Nonce;  // Initiator nonce\n\t\tvar alpha: Ticket;  // Ticket received from I\n\n\t\tsend_Compromise(R,R, y,i ); // Responder sends a compromise message\n\n\t\trecv_1(I,R,  alpha,R,          { alpha,R }sk(I)         ); // Respond to initiator's message\n\t\tsend_2(R,I,  alpha,g1(y),i,I,  { alpha,g1(y),i,I }sk(R) ); // Send response to initiator\n\t\trecv_!3(I,R,  h1( g2(alpha,y ) ) ); // Receive hashed key\n\n\t\tclaim(R,SKR, g2(alpha,y) ); // Claim key SKR\n\t}\n}"
    },
    {
        "file": "SPDL-1/HMQV.spdl",
        "logic": "---\n\n### HMQV Two-Pass Protocol Description\n\n**Overview:**\nThe HMQV (Hankerson-Menezes-Qu-Vanstone) two-pass protocol is a key exchange mechanism that allows two parties to securely derive a shared secret key using their respective private keys and public key information. The protocol is designed to be secure against various attacks while ensuring efficient key exchange.\n\n**Hash Functions:**\nThe protocol utilizes several hash functions:\n- `h1`, `h2`: General hash functions used for hashing inputs.\n- `gexp`, `exp`: Functions for exponentiation, representing the operation of raising a base to a power in the context of cryptographic operations.\n- `KDF`: Key Derivation Function to generate symmetric keys from shared secrets.\n- `H`: A hash function used to ensure integrity and authenticity.\n\n**Addition and Multiplication:**\nThe protocol simulates addition and multiplication operations using hash functions `add` and `mult`. These operations are crucial for combining values during key derivation.\n\n**Public Key Simulation:**\nThe protocol includes a helper protocol `@publickeys(PK)` for simulating the public knowledge of public keys. It allows the PK role to send its public key and a computed value based on its secret key.\n\n**Exponentiation Helper Protocol:**\nThe helper protocol `@exponentiation(RA, RB, RC)` simulates the operation of exponentiation and ensures the correct flow of messages between three roles (RA, RB, and RC). Each role receives and sends messages containing hash operations and exponentiated values.\n\n**Addition and Multiplication Helper Protocol:**\nThe `@addmult(I, R)` protocol simulates addition and multiplication operations for the roles I and R, allowing them to exchange combined values securely.\n\n**Key Swap Protocol:**\nThe `@keyswap(I, R)` protocol allows roles I and R to swap keys securely by using their respective nonces and secret keys to derive a shared key.\n\n**Main HMQV Protocol:**\nThe main protocol is defined as `symmetric-role protocol HMQV-twopass(I,R)`. It includes two roles, I and R:\n\n- **Role I:**\n  - Generates a fresh nonce `x`.\n  - Sends the exponentiated value `gexp(x)` to role R.\n  - Receives a ticket `Y` from role R.\n  - Claims a session key `SKR` by deriving it from the exchanged values and its own nonce.\n\n- **Role R:**\n  - Generates a fresh nonce `y`.\n  - Receives the value `X` from role I.\n  - Sends the exponentiated value `gexp(y)` back to role I.\n  - Claims a session key `SKR` similar to role I, using its nonce and the received value.\n\n**Security Claims:**\nEach role claims a session key `SKR`, which is derived using a combination of the received tickets, the respective nonces, and the secret keys. This ensures that both roles can independently compute the same shared secret key.\n\n---",
        "code": "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The protocol description\n\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar Y: Ticket;\n\n\t\tsend_1(I,R, gexp(x) );\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar X: Ticket;\n\n\t\trecv_1(I,R, X );\n\t\tsend_2(R,I, gexp(y) );\n\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}",
        "codenote": "/* \n * HMQV two pass version\n *\n */\n\n// Hash functions\nhashfunction h1,h2,gexp,exp,KDF,H;\n\n// Addition, multiplication\n// For now, simply hashes\nhashfunction mult,add;\n\n/*\n * Hack to simulate public knowledge of public keys.\n * This protocol allows the public disclosure of the public key.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\t// PK shares its public key and computes a value based on the secret key\n\t\tsend_!1(PK,PK, gexp(sk(PK)));\n\t}\n}\n\t\t\n/*\n * Hack to simulate g^ab = g^ba inside terms.\n * The '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// RA receives an exponentiation result and sends back a computed value\n\t\trecv_!1(RA,RA, h2(\n\t\t  exp(gexp(X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  exp(gexp(Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// RB receives a ticket with an exponentiation result and responds with another\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  exp(gexp(Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// RC handles the final exponentiation and sends back the result\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  exp(gexp(Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\n// Protocol to handle addition and multiplication\nprotocol @addmult(I,R)\n{\n\trole I\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\t// I receives two tickets and performs addition\n\t\trecv_!1(I,I, add(X,Y) );\n\t\tsend_!2(I,I, add(Y,X) );\n\t}\n\trole R\n\t{\n\t\tvar X,Y: Ticket;\n\n\t\t// R receives two tickets and performs multiplication\n\t\trecv_!3(R,R, mult(X,Y) );\n\t\tsend_!4(R,R, mult(Y,X) );\n\t}\n}\n\n// Protocol for key swapping\nprotocol @keyswap(I,R)\n{\n\trole I\n\t{\n\t\tvar x,y: Nonce;\n\t\t\n\t\t// I performs a KDF operation based on received values and sends a KDF result back\n\t\trecv_!1(I,I, KDF(exp(mult(gexp(y),exp(gexp(sk(R)),H(gexp(y),I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t\tsend_!2(I,I, KDF(exp(mult(gexp(x),exp(gexp(sk(I)),H(gexp(x),R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}\n\n// The main protocol description for HMQV two pass\nsymmetric-role protocol HMQV-twopass(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce; // Fresh nonce generated by I\n\t\tvar Y: Ticket;   // Ticket received from R\n\n\t\t// I sends its public value of x\n\t\tsend_1(I,R, gexp(x) );\n\t\t// I receives a ticket from R\n\t\trecv_2(R,I, Y );\n\n\t\t// I computes a symmetric key SKR based on exchanged values\n\t\tclaim(I,SKR,    KDF(exp(mult(Y,exp(gexp(sk(R)),H(Y,I))),add(x,mult(H(gexp(x),R),sk(I))))) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce; // Fresh nonce generated by R\n\t\tvar X: Ticket;   // Ticket received from I\n\n\t\t// R receives the public value of x from I\n\t\trecv_1(I,R, X );\n\t\t// R sends its public value of y to I\n\t\tsend_2(R,I, gexp(y) );\n\n\t\t// R computes a symmetric key SKR based on exchanged values\n\t\tclaim(R,SKR,    KDF(exp(mult(X,exp(gexp(sk(I)),H(X,R))),add(y,mult(H(gexp(y),I),sk(R))))) );\n\t}\n}"
    },
    {
        "file": "SPDL-1/ikev2-mac.spdl",
        "logic": "---\n\n### Protocol Description for IKEv2\n\n#### Overview\nThe Internet Key Exchange version 2 (IKEv2) is a protocol used to set up a secure, authenticated communication channel between two parties over an insecure network. This protocol is commonly employed in virtual private networks (VPNs) and involves the exchange of cryptographic keys and security associations (SAs) to ensure confidentiality and integrity of the messages.\n\n#### Roles\nThe protocol consists of three roles:\n1. **DH (Diffie-Hellman Role)**: Responsible for establishing a shared secret using Diffie-Hellman key exchange.\n2. **SWAP (Swap Role)**: Engages in message exchanges that involve key derivation functions and message authentication codes (MACs).\n3. **E (Executability Role)**: Acts as the intermediary that facilitates the communication between the initiator (I) and responder (R).\n\n#### Cryptographic Functions\n- **Hash Functions**: `g`, `h`, `MAC` are used for generating message digests and ensuring data integrity.\n- **Pseudo-Random Function (PRF)** and **Key Derivation Function (KDF)**: Used to derive keys and ensure that the keys are securely generated from the nonces and other parameters exchanged during the protocol.\n\n#### Message Exchanges\n1. **DH Role**:\n   - Sends `DH1`: Involves sending a nonce and a hashed value derived from the other party's nonce and its own.\n   - Receives `DH2`: Receives a similar hashed value from the other party.\n\n2. **SWAP Role**:\n   - Receives `SWAP1`: Accepts a KDF-generated message from the other party.\n   - Sends `SWAP2`: Sends a KDF-generated message back to the other party.\n\n3. **Executability Role (E)**:\n   - Receives `E1`: Receives a message containing initiator and responder identities, along with a MAC that ensures the integrity of the message.\n   - Sends `E2`: Sends a similar message back to the initiator.\n   - Receives `E3`: Accepts a message from the responder and validates its integrity.\n   - Sends `E4`: Sends a message back to the responder.\n\n4. **Initiator Role (I)**:\n   - Sends `1`: Initiator sends its nonce and security association.\n   - Receives `2`: Receives the responder's nonce and security association.\n   - Sends message `3`: Sends a message containing a MAC for integrity and other relevant data.\n   - Receives message `4`: Receives a message containing a MAC from the responder.\n\n5. **Responder Role (R)**:\n   - Receives `1`: Receives the initial message from the initiator.\n   - Sends `2`: Sends the responder's nonce in response.\n   - Receives message `3`: Accepts a message from the initiator and validates its integrity.\n   - Sends message `4`: Sends a message back to the initiator containing a MAC.\n\n#### Claims\n- Both roles (I and R) make claims at various points during the protocol:\n  - **Running**: Indicates that the role is actively participating in the protocol.\n  - **SKR (Session Key Ready)**: Claims that a session key has been successfully established.\n  - **Alive**: Indicates that the role is still operational and has not exited prematurely.\n  - **Weak Agreement**: Claims that both parties have reached a weak agreement on the established keys.\n  - **Commit**: Indicates that both parties have committed to the established session and security parameters.\n\n#### Security Associations\n- The protocol utilizes various security associations (SA1, SA2, SA3) to ensure that the exchanged messages adhere to established security standards.\n\n### Conclusion\nThis description provides a comprehensive overview of the IKEv2 protocol implemented in the provided SPDL file. The interactions between roles, the cryptographic functions used, and the claims made ensure that the protocol maintains a secure and robust communication channel between the parties involved.\n\n---",
        "code": "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 43 \"common.h\"\nhashfunction MAC;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!SWAP2( SWAP, SWAP, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n }\n\n\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector;\nconst O: Number;\nconst SA1 ,SA2, SA3: SecurityAssociation;\nconst TSi, TSr: TrafficSelector;\n\n\n\n\n\n\nprotocol @executability(E) {\n\n\n role E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce;\n  var I, R: Agent;\n\n\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {R, MAC(k(I,R), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n\n }\n\n\n}\n\n\nprotocol ikev2-mac(I, R)\n{\n\n role I {\n  fresh i, Ni, SPIi: Nonce;\n  var Nr, SPIr: Nonce;\n  var Gr: Ticket;\n\n\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni );\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr );\n\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr);\n  send_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr);\n\n }\n\n role R {\n  fresh r, Nr, SPIr: Nonce;\n  var Ni, SPIi: Nonce;\n  var Gi: Ticket;\n\n\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni );\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr );\n\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr);\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr);\n }\n}",
        "codenote": "# 1 \"ikev2-mac.cpp\"\n# 1 \"<command-line>\"\n# 1 \"ikev2-mac.cpp\"\n# 15 \"ikev2-mac.cpp\"\n# 1 \"common.h\" 1\n\nhashfunction prf, KDF; // Pseudorandom function and key derivation function\n\nhashfunction g, h; // Hash functions for cryptographic operations\n# 43 \"common.h\"\nhashfunction MAC; // Message Authentication Code function\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) { // Oracle protocol for Diffie-Hellman (DH) and SWAP operations\n\n role DH {\n  var i, r: Nonce; // Nonces for freshness in DH protocol\n\n  recv_!DH1( DH, DH, h(g(r),i) ); // Receiving DH1 message\n  send_!DH2( DH, DH, h(g(i),r) ); // Sending DH2 message\n }\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce; // Nonces for SWAP role\n# 132 \"common.h\"\n  var SPIi, SPIr: Nonce; // Session identifiers for initiator and responder\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) ); // Receiving SWAP1 message\n  send_!SWAP2( SWAP, SWAP, KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) ); // Sending SWAP2 message\n }\n}\n# 16 \"ikev2-mac.cpp\" 2\n# 24 \"ikev2-mac.cpp\"\nusertype Number, SecurityAssociation, TrafficSelector; // User-defined types for protocol elements\nconst O: Number; // Constant number used in the protocol\nconst SA1 ,SA2, SA3: SecurityAssociation; // Security Associations used in the protocol\nconst TSi, TSr: TrafficSelector; // Traffic selectors for identifying traffic flows\n\nprotocol @executability(E) { // Executability protocol for entity E\n\n role E {\n  var i, r, Ni, Nr, SPIi, SPIr: Nonce; // Nonces for E role\n  var I, R: Agent; // Participants in the protocol\n\n  // Processing messages between the entities\n  recv_!E1( E, E, {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n  send_!E2( E, E, {I, R, MAC(k(R,I), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n\n  recv_!E3( E, E, {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(i),r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(i),r),SPIi,SPIr) );\n  send_!E4( E, E, {R, MAC(k(I,R), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(g(r),i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(g(r),i),SPIi,SPIr) );\n }\n}\n\nprotocol ikev2-mac(I, R) // Main IKEv2 MAC protocol with initiator I and responder R\n{\n\n role I {\n  fresh i, Ni, SPIi: Nonce; // Fresh nonces for I\n  var Nr, SPIr: Nonce; // Nonces and session identifier for R\n  var Gr: Ticket; // Ticket for authentication\n\n  send_1( I, R, SPIi, O, SA1, g(i), Ni ); // Initial message from I to R\n  recv_2( R, I, (SPIi,SPIr), SA1, Gr, Nr ); // Receiving response from R\n\n  claim( I, Running, R, Ni,g(i),Nr,Gr,TSi,TSr); // Claiming the running state\n  send_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(I,R), SPIi, O, SA1, g(i), Ni, Nr, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) ); // Sending authenticated message\n  recv_!4( R, I, (SPIi,SPIr), {R, MAC(k(I,R), SPIi, SPIr, SA1, Gr, Nr, Ni, prf(KDF(Ni,Nr,h(Gr,i),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) ); // Receiving response from R\n\n  claim( I, SKR, KDF(Ni,Nr,h(Gr,i),SPIi,SPIr) ); // Claiming shared key SKR\n  claim( I, Alive ); // Claiming the alive status\n  claim( I, Weakagree ); // Claiming weak agreement status\n  claim( I, Commit, R, Ni,g(i),Nr,Gr,TSi,TSr); // Claiming commitment to the state\n }\n\n role R {\n  fresh r, Nr, SPIr: Nonce; // Fresh nonces for R\n  var Ni, SPIi: Nonce; // Nonces and session identifier for I\n  var Gi: Ticket; // Ticket for authentication\n\n  recv_1( I, R, SPIi, O, SA1, Gi, Ni ); // Initial message from I to R\n  send_2( R, I, (SPIi,SPIr), SA1, g(r), Nr ); // Sending response to I\n\n  recv_!3( I, R, (SPIi,SPIr), {I, R, MAC(k(R,I), SPIi, O, SA1, Gi, Ni, Nr, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), I)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) ); // Receiving authenticated message\n  claim( R, Running, I, Ni,Gi,Nr,g(r),TSi,TSr); // Claiming the running state\n  send_!4( R, I, (SPIi,SPIr), {R, MAC(k(R,I), SPIi, SPIr, SA1, g(r), Nr, Ni, prf(KDF(Ni,Nr,h(Gi,r),SPIi,SPIr), R)), SA2, TSi, TSr}KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) ); // Sending authenticated message back to I\n\n  claim( R, SKR, KDF(Ni,Nr,h(Gi,r),SPIi,SPIr) ); // Claiming shared key SKR\n  claim( R, Alive ); // Claiming the alive status\n  claim( R, Weakagree ); // Claiming weak agreement status\n  claim( R, Commit, I, Ni,Gi,Nr,g(r),TSi,TSr); // Claiming commitment to the state\n }\n}"
    },
    {
        "file": "SPDL-1/isoiec-9798-2-1.spdl",
        "logic": "To generate a descriptive content for the provided SPDL files related to the protocols `@keysymm-21` and `isoiec-9798-2-1`, we'll break down the core components of each protocol and describe their functionality, intended use, and the roles involved.\n\n### Protocol Descriptions\n\n#### 1. Protocol: `@keysymm-21`\n\n**Description:**\nThe `@keysymm-21` protocol is a symmetric, one-pass, unilateral authentication protocol modeled after ISO/IEC 9798. This protocol facilitates secure communication between two parties, A and B, utilizing symmetric key cryptography. The primary aim is to ensure that party A can authenticate itself to party B while also securely sending a nonce and a ticket.\n\n**Roles:**\n- **Role A:** \n  - Generates a nonce (`T`) and a ticket (`Text`).\n  - Receives a message from B containing a nonce and a ticket encrypted with the symmetric key `k(A,B)`.\n  - Sends a response back to B, including the nonce and the ticket encrypted with the symmetric key `k(B,A)`.\n\n- **Role B:**\n  - Also generates a nonce (`T`) and a ticket (`Text`).\n  - Receives a message from A containing a nonce and a ticket encrypted with the symmetric key `k(A,B)`.\n  - Sends a response to A, including its own nonce and ticket encrypted with the symmetric key `k(B,A)`.\n\n**Key Features:**\n- The protocol supports secure one-pass authentication, where A can authenticate itself to B without requiring B to authenticate back to A immediately.\n- The use of nonces prevents replay attacks by ensuring freshness in the communication.\n- The handling of tickets allows for the inclusion of additional context or authorization data within the protocol.\n\n#### 2. Protocol: `isoiec-9798-2-1`\n\n**Description:**\nThe `isoiec-9798-2-1` protocol is a symmetric authentication protocol that is part of the ISO/IEC 9798 standard. This protocol is designed for mutual authentication, where both parties (A and B) can confirm each other's identities while securely exchanging data. It incorporates freshness and claims to ensure the integrity and authenticity of the exchanged information.\n\n**Roles:**\n- **Role A:**\n  - Generates a fresh nonce (`TNA`) and two tickets (`Text1`, `Text2`).\n  - Claims its intent to run the authentication by asserting its identity and the nonce.\n  - Sends a message to B containing the second ticket (`Text2`) along with an encrypted message that includes the nonce, B's identity, and the first ticket (`Text1`).\n\n- **Role B:**\n  - Receives the message from A, which includes the second ticket and the encrypted nonce and ticket.\n  - Decrypts the received message to validate A's identity and the freshness of the nonce.\n  - Claims its commitment to the authentication, confirms its identity, and asserts that both parties are alive and have reached a weak agreement.\n\n**Key Features:**\n- The protocol emphasizes mutual authentication, where both parties verify each other's identities.\n- Freshness is ensured through the use of nonces, preventing replay attacks.\n- The protocol includes claims that can be used to assert the status of the communication, such as `Running`, `Commit`, `Alive`, and `Weakagree`.\n\n### Summary\n\nBoth protocols are designed for secure communication using symmetric key cryptography, though they serve different purposes and levels of authentication. The `@keysymm-21` protocol focuses on unilateral authentication for party A, while the `isoiec-9798-2-1` protocol provides mutual authentication and includes additional claims for enhanced security.",
        "code": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be ommitted, if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) );\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) );\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce;\n\t\tvar Text: Ticket;\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) );\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) );\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce;\n\t\tfresh Text1,Text2: Ticket;\n\n\t\tclaim(A,Running,B,TNA,Text1);\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce;\n\t\tvar Text1,Text2: Ticket;\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) );\n\n\t\tclaim(B,Commit,A,TNA,Text1);\n\t\tclaim(B,Alive);\n\t\tclaim(B,Weakagree);\n\t}\n}",
        "codenote": "/*\n * Modeled from ISO/IEC 9798\n * Modeler: Cas Cremers, Dec. 2010\n *\n * symmetric\n * one-pass\n * unilateral\n *\n * Note: the identity B may be omitted if\n *   (a) the environment disallows such attacks, or\n *   (b) a unidirectional key is used\n */\nprotocol @keysymm-21(A,B)\n{\n\trole A\n\t{\n\t\tvar T: Nonce; // Nonce for freshness\n\t\tvar Text: Ticket; // Ticket representing credentials or session information\n\n\t\trecv_!1(B,A, { T, A, Text }k(A,B) ); // Receiving message from B encrypted with symmetric key k(A, B)\n\t\tsend_!2(A,B, { T, A, Text }k(B,A) ); // Sending response to B encrypted with symmetric key k(B, A)\n\t}\n\trole B\n\t{\n\t\tvar T: Nonce; // Nonce for freshness\n\t\tvar Text: Ticket; // Ticket representing credentials or session information\n\n\t\trecv_!3(A,B, { T, B, Text }k(A,B) ); // Receiving message from A encrypted with symmetric key k(A, B)\n\t\tsend_!4(B,A, { T, B, Text }k(B,A) ); // Sending response to A encrypted with symmetric key k(B, A)\n\t}\n}\n\nprotocol isoiec-9798-2-1(A,B)\n{\n\trole A\n\t{\n\t\tfresh TNA: Nonce; // Fresh nonce to protect against replay attacks\n\t\tfresh Text1,Text2: Ticket; // Fresh tickets for authentication and session management\n\n\t\tclaim(A,Running,B,TNA,Text1); // Claim that A is running with B using specific nonce and ticket\n\t\tsend_1(A,B, Text2, { TNA, B, Text1 }k(A,B) ); // Sending second ticket and encrypted message to B\n\t}\n\trole B\n\t{\n\t\tvar TNA: Nonce; // Nonce received from A\n\t\tvar Text1,Text2: Ticket; // Tickets received from A\n\n\t\trecv_1(A,B, Text2, { TNA, B, Text1 }k(A,B) ); // Receiving message from A encrypted with symmetric key k(A, B)\n\n\t\tclaim(B,Commit,A,TNA,Text1); // Claim B has committed to the session with specific nonce and ticket from A\n\t\tclaim(B,Alive); // Claim that B is alive and participating in the protocol\n\t\tclaim(B,Weakagree); // Claim weak agreement on the state of the session\n\t}\n}"
    },
    {
        "file": "SPDL-1/KAS1.spdl",
        "logic": "---\n\n### KEA+ Protocol Description\n\n#### Overview\nThe KEA+ (Key Exchange Algorithm Plus) protocol is designed to facilitate secure authenticated key exchange between two parties, denoted as `I` (Initiator) and `R` (Responder). The protocol incorporates the use of ephemeral keys and nonces to ensure freshness and resistance against replay attacks.\n\n#### Goals\nThe primary goal of the KEA+ protocol is to allow two parties, `I` and `R`, to establish a shared secret key (`SKR`) while ensuring the authenticity of each party. The protocol achieves this by utilizing cryptographic primitives such as hash functions and Diffie-Hellman key exchanges.\n\n#### Roles and Messages\nThe KEA+ protocol involves two roles: Initiator (`I`) and Responder (`R`). Each role is responsible for sending and receiving specific messages to facilitate the key exchange.\n\n1. **Role I (Initiator)**\n   - **Step 1:** The initiator generates a fresh nonce `x` and sends a \"compromise\" message to itself, indicating its state of readiness.\n   - **Step 2:** It then sends the value `g1(x)` (a transformation of the nonce `x` using a public function `g1`) to the responder `R`.\n   - **Step 3:** The initiator waits to receive a value `beta` from `R`, which is expected to be generated from `R`\u2019s secret key and its own nonce.\n\n   - **Claim:** Upon receiving `beta`, the initiator claims the shared key `SKR` by computing the hash using the value `beta`, the public key of `R`, and the nonce `x`.\n\n2. **Role R (Responder)**\n   - **Step 1:** The responder receives the value `alpha` (the transformed nonce from `I`) and generates a fresh nonce `y`.\n   - **Step 2:** It sends a \"compromise\" message to itself, indicating its readiness, before sending the value `g1(y)` to the initiator.\n   - **Step 3:** Finally, the responder claims the shared key `SKR` by computing a hash that incorporates `I`'s public key, its nonce `y`, and the value `alpha` it received.\n\n#### Security Considerations\n- The use of fresh nonces (`x` and `y`) ensures that each execution of the protocol is unique and protects against replay attacks.\n- The protocol claims (`SKR`) ensure that both parties can independently compute the same shared secret key based on the values exchanged during the protocol execution.\n- The reliance on cryptographic hash functions (`h1`, `g1`, and `g2`) provides necessary security properties for the key derivation process.\n\n#### Conclusion\nThe KEA+ protocol serves as a robust method for secure key exchange, leveraging fresh nonces and cryptography to ensure authenticity and confidentiality of the shared key between the communicating parties. The successful execution of this protocol allows both parties to derive the same shared secret key, which can be used for subsequent secure communications.\n\n---",
        "code": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is\n * revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tsend_!1(RA,RA, g1(sk(RA)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,RA) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,RA) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\t\trecv_2(R,I, beta );\n\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}",
        "codenote": "/* \n * KEA+\n *\n * From \"Security Analysis of KEA Authenticated Key Exchange Protocol\"\n * Lauter, Mityagin, 2006.\n * \n * We find no attacks in CK if only the ephemeral key is revealed.\n * We do find attacks for both roles in CK if the input to hash1 is revealed.\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to gain equivalence of public keys to g^private.\n */\nprotocol @publickeys(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\t// RA sends its public key derived from its private key\n\t\tsend_!1(RA,RA, g1(sk(RA)) );\n\t}\n\trole RB\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\t// RB receives a key encapsulated with a ticket, computes g2 and sends back\n\t\trecv_!2(RB,RB, g2(g1(T),sk(RB)) );\n\t\tsend_!3(RB,RB, g2(pk(RB),T) );\n\t}\n\trole RC\n\t{\n\t\t// Special one to go into DH g2\n\t\tvar T: Ticket;\n\n\t\t// RC receives a key encapsulated with a ticket and sends it back\n\t\trecv_!4(RC,RC, g2(pk(RC),T) );\n\t\tsend_!5(RC,RC, g2(g1(T),sk(RC)) );\n\t}\n}\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\t// RA receives an exponentiated value and sends back a commuted value\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n\trole RB\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\t// RB receives a hash input, computes the hash with T3 and sends a commuted value\n\t\trecv_!3(RB,RB, h1(g2(g1(T1),T2),T3,RC,RB) );\n\t\tsend_!4(RB,RB, h1(g2(g1(T2),T1),T3,RC,RB) );\n\t}\n\trole RC\n\t{\n\t\tvar T1,T2,T3: Ticket;\n\n\t\t// RC receives a hash input from RB and sends back a commuted hash\n\t\trecv_!5(RC,RC, h1(T3,g2(g1(T1),T2),RC,RA) );\n\t\tsend_!6(RC,RC, h1(T3,g2(g1(T2),T1),RC,RA) );\n\t}\n}\n\n// The protocol description\n\nprotocol KEAplus(I,R)\n{\n\trole I\n\t{\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\t// I starts the protocol by sending a compromise message and its nonce x\n\t\tsend_Compromise(I,I, x);\n\t\tsend_1(I,R, g1(x) );\n\n\t\t// I waits for a ticket in response from R\n\t\trecv_2(R,I, beta );\n\n\t\t// I claims the session key SKR created via h1\n\t\tclaim(I,SKR, h1(\n\t\t  g2(beta,sk(I)),\n\t\t  g2(pk(R),x),\n\t\t  I,R\n\t\t));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\t// R receives the message with I's nonce and sends its own compromise message\n\t\trecv_1(I,R, alpha );\n\t\tsend_Compromise(R,R, y);\n\t\tsend_2(R,I, g1(y) );\n\n\t\t// R claims the session key SKR created via h1\n\t\tclaim(R,SKR, h1(\n\t\t  g2(pk(I),y),\n\t\t  g2(alpha,sk(R)),\n\t\t  I,R\n\t\t));\n\t}\n}"
    },
    {
        "file": "SPDL-1/NAXOS.spdl",
        "logic": "The NAXOS Authenticated Key Exchange (AKE) protocol is a cryptographic protocol designed to establish a shared secret key between two parties, referred to as the initiator (I) and the responder (R). This protocol is modeled after the ideas presented in \"Stronger Security of Authenticated Key Exchange\" by LaMacchia, Lauter, and Mityagin. \n\n### Description of the Protocol\n\n1. **Purpose**:\n   The primary goal of the NAXOS protocol is to securely exchange keys between two parties while providing mutual authentication. It ensures that both parties can verify each other's identity and agree on a shared session key.\n\n2. **Roles**:\n   - **Initiator (I)**: The party that starts the key exchange process.\n   - **Responder (R)**: The party that responds to the initiator's request.\n\n3. **Key Components**:\n   - **Nonces**: Freshly generated random values used to ensure the freshness of the session and to prevent replay attacks.\n   - **Tickets**: Used to carry relevant information during the exchange.\n   - **Hash Functions (h1, h2)**: Cryptographic hash functions used to ensure data integrity and authenticity.\n   - **Exponentiation Function (p)**: A one-way function used in the protocol that simulates the properties of exponentiation.\n\n4. **Protocol Flow**:\n   - The initiator generates a nonce (`eskI`) and computes a value using its secret key and the provided generator `g`. It sends this computed value to the responder.\n   - The responder receives the value, computes its own nonce (`eskR`), and sends back a computed value using its secret key.\n   - Both parties generate a shared session key based on the received messages and their own secret keys, which they can later use for secure communication.\n\n5. **Claims**:\n   - Both I and R make claims about the established session key, which involves hashing various components to ensure that the key is derived correctly and securely.\n\n6. **Security Considerations**:\n   - The protocol is designed to resist various attacks, including state-reveal attacks against both the initiator and responder roles. \n   - It accounts for the possibility of message interception or replay attacks by incorporating nonces and hash functions.\n\n7. **Helper Protocols**:\n   - The protocol makes use of helper protocols that define the public knowledge of public keys and the properties of exponentiation, ensuring that the protocol can leverage these aspects without compromising security.\n\n### Summary\nThe NAXOS AKE protocol provides a robust framework for secure key exchange, ensuring authenticity and confidentiality. It utilizes cryptographic primitives such as hash functions and one-way functions to create a secure communication channel between two parties. The careful design of the message flow and the incorporation of nonces and claims help to mitigate potential security risks.\n\nThis description can be utilized to create or modify the corresponding SPDL (Scyther Protocol Description Language) file for the NAXOS protocol, allowing for formal analysis and verification of its security properties using the Scyther tool.",
        "code": "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\trecv_2(R,I, Y );\n\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\n\t\trecv_1(I,R, X );\n\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}",
        "codenote": "/* \n * NAXOS AKE (Authenticated Key Exchange) protocol\n *\n * Modeled by Cas Cremers, 2009\n *\n * From \"Stronger Security of Authenticated Key Exchange\" LaMacchia\n * Lauter Mityagin 2006\n *\n * Attacks:\n * \n * For state-reveal with automatic state inference, we find attacks for\n * both the initiator and responder roles.\n */\n\n// Hash functions\nhashfunction h1,h2;\n\n// Exponentiation operator modeled using one-way function and helper\n// protocols (see below)\nhashfunction p;\n\n// Generator\nconst g;\n\n/*\n * Simulate public knowledge of public keys.\n *\n * The '@' prefix of the protocol name denotes that it is a helper\n * protocol, which is used by Scyther for displaying, and such protocols\n * are ignored in auto-generation of protocol modifiers.\n */\nprotocol @publickeys(PK)\n{\n\trole PK\n\t{\n\t\t// Sending the public key and a derived value as a commitment\n\t\tsend_!1(PK,PK, p(g,sk(PK)));\n\t}\n}\n\t\t\n/*\n * Approximation for the equational theory g^ab = g^ba in subterms of\n * the Naxos protocol.\n */\nprotocol @exponentiation(RA,RB,RC)\n{\n\trole RA\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// Receiving a value from role RA to confirm exponentiation operation\n\t\trecv_!1(RA,RA, h2(\n\t\t  p(p(g,X),Y),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t\t// Sending back a paired value after processing\n\t\tsend_!2(RA,RA, h2(\n\t\t  p(p(g,Y),X),\n\t\t  T1, T2, RA,RB\n\t\t  ));\n\t}\n\trole RB\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// Receiving an intermediate value for verification\n\t\trecv_!3(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,X),Y),\n\t\t  T2, RA,RB\n\t\t  ));\n\t\t// Responding with computed results based on received values\n\t\tsend_!4(RB,RB, h2(\n\t\t  T1,\n\t\t  p(p(g,Y),X),\n\t\t  T2, RA,RB\n\t\t  ));\n\t}\n\trole RC\n\t{\n\t\tvar X,Y, T1,T2: Ticket;\n\n\t\t// Collecting values needed for security assertions\n\t\trecv_!5(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,X),Y),\n\t\t  RA,RB\n\t\t  ));\n\t\t// Finalizing the communication with a secure result\n\t\tsend_!6(RC,RC, h2(\n\t\t  T1, T2,\n\t\t  p(p(g,Y),X),\n\t\t  RA,RB\n\t\t  ));\n\t}\n}\n\nprotocol @keysymmetry(R1,R2,R3)\n{\n\trole R1\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\t// Symmetrically exchanging keys to ensure mutual authentication\n\t\trecv_!1(R1,R1, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t\tsend_!2(R1,R1, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,Z2,\n\t\t\tR1,R2));\n\t}\n\trole R2\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\t// Continuing the exchange with role R2 interacting with received values\n\t\trecv_!4(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,Y),X),\n\t\t\tZ2,\n\t\t\tR2,R3));\n\t\tsend_!5(R2,R2, h2( \n\t\t\tZ1,\n\t\t\tp(p(g,X),Y), \n\t\t\tZ2,\n\t\t\tR2,R3));\n\t}\n\trole R3\n\t{\n\t\tvar Y,X: Ticket;\n\t\tvar Z1,Z2: Ticket;\n\n\t\t// Completing the key symmetry communication with final confirmations\n\t\trecv_!5(R3,R3, h2( \n\t\t\tp(p(g,Y),X),\n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t\tsend_!6(R3,R3, h2( \n\t\t\tp(p(g,X),Y), \n\t\t\tZ1,\n\t\t\tZ2,\n\t\t\tR3,R1));\n\t}\n}\n\n// The Naxos protocol description\n\nprotocol naxos(I,R)\n{\n\trole I\n\t{\n\t\tfresh eskI: Nonce;\n\t\tvar Y: Ticket;\n\n\t\t// Initiator sends encrypted message with derived session key\n\t\tsend_1(I,R, p(g,h1(eskI,sk(I))) );\n\n\t\t// Waiting for a response from R\n\t\trecv_2(R,I, Y );\n\n\t\t// Claiming possession of a session key based on received ticket\n\t\tclaim(I,SKR,h2( \n\t\t\tp(Y,sk(I)),\n\t\t\tp(p(g,sk(R)),h1(eskI,sk(I))), \n\t\t\tp(Y,h1(eskI,sk(I))),\n\t\t\tI,R));\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh eskR: Nonce;\n\t\tvar X: Ticket;\n\n\t\t// Receiving the initial message containing a ticket\n\t\trecv_1(I,R, X );\n\n\t\t// R responds with its key based on its own nonce\n\t\tsend_2(R,I, p(g,h1(eskR,sk(R))) );\n\n\t\t// Claiming the session key using the data shared with I\n\t\tclaim(R,SKR,h2( \n\t\t\tp(p(g,sk(I)),h1(eskR,sk(R))), \n\t\t\tp(X,sk(R)),\n\t\t\tp(X,h1(eskR,sk(R))),\n\t\t\tI,R));\n\t}\n}"
    },
    {
        "file": "SPDL-1/nsl3.spdl",
        "logic": "The Needham-Schroeder-Lowe protocol is a cryptographic protocol designed for secure communication between two parties, typically referred to as initiator (I) and responder (R). The protocol employs public key cryptography to establish a shared secret communication channel while providing authentication and ensuring that both parties agree on the session parameters.\n\n### Protocol Description\n\nThe protocol operates as follows:\n\n1. **Initialization**: The initiator (I) generates a fresh nonce `ni` to ensure the uniqueness of the session. The responder (R) generates its own fresh nonce `nr`.\n\n2. **Step 1**: The initiator sends a message to the responder that contains its identity `I` and the nonce `ni`, encrypted with the public key of the responder (`pk(R)`). This serves as an initial request to establish a secure session.\n\n   - **Message format**: `{I, ni}pk(R)`\n\n3. **Step 2**: Upon receiving the first message, the responder (R) decrypts the message to reveal the initiator's identity and the nonce `ni`. The responder then prepares a response message that includes the nonce `ni`, its own nonce `nr`, and its identity `R`, all encrypted with the public key of the initiator (`pk(I)`).\n\n   - **Message format**: `{ni, nr, R}pk(I)`\n\n4. **Step 3**: The initiator receives the second message from the responder. It decrypts the message to retrieve the nonces and the responder's identity. Subsequently, the initiator sends a message back to the responder containing the nonce `nr`, encrypted with the responder's public key (`pk(R)`).\n\n   - **Message format**: `{nr}pk(R)`\n\n5. **Claims**: Throughout the protocol, each party makes claims about the secrets and agreements established during the exchange:\n   - The initiator claims that `ni` is a secret, `nr` is a secret, and asserts that both parties agree on the session parameters (`Niagree`) and are synchronized (`Nisynch`).\n   - The responder makes similar claims about `ni`, `nr`, and the agreement and synchronization with the initiator.\n\n### Key Properties\n- **Authentication**: Each party verifies the identity of the other through the exchange of encrypted messages.\n- **Confidentiality**: The use of public key encryption ensures that only the intended recipient can decrypt the messages.\n- **Freshness**: The nonces ensure that each session is unique, preventing replay attacks.\n\n### Conclusion\nThe Needham-Schroeder-Lowe protocol is a foundational example in the study of cryptographic protocols, illustrating key concepts of authentication, confidentiality, and the importance of nonce generation in securing communication channels.\n\nThis description encapsulates the protocol's flow and properties, which can serve as a basis for generating the corresponding SPDL file that can be executed by the Scyther tool.",
        "code": "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\tfresh ni: Nonce;\n\t\tvar nr: Nonce;\n\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\tclaim_i1(I,Secret,ni);\n\t\tclaim_i2(I,Secret,nr);\n\t\tclaim_i3(I,Niagree);\n\t\tclaim_i4(I,Nisynch);\n\t}\t\n\t\n\trole R\n\t{\n\t\tvar ni: Nonce;\n\t\tfresh nr: Nonce;\n\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\tclaim_r1(R,Secret,ni);\n\t\tclaim_r2(R,Secret,nr);\n\t\tclaim_r3(R,Niagree);\n\t\tclaim_r4(R,Nisynch);\n\t}\n}",
        "codenote": "/* \n * Needham-Schroeder-Lowe protocol\n */\n\n// The protocol description\n\nprotocol nsl3(I,R)\n{\n\trole I\n\t{\n\t\t// I generates a fresh nonce ni\n\t\tfresh ni: Nonce;\n\t\t// I receives nonce nr from R\n\t\tvar nr: Nonce;\n\n\t\t// I sends its identity and nonce ni encrypted with R's public key\n\t\tsend_1(I,R, {I,ni}pk(R) );\n\t\t// I receives the response from R containing its nonce ni, R's nonce nr, and R's identity\n\t\trecv_2(R,I, {ni,nr,R}pk(I) );\n\t\t// I sends R's nonce nr back encrypted with R's public key\n\t\tsend_3(I,R, {nr}pk(R) );\n\n\t\t// Claims regarding the knowledge of secrets and agreement\n\t\tclaim_i1(I,Secret,ni);   // Claim that I knows its own nonce ni\n\t\tclaim_i2(I,Secret,nr);   // Claim that I knows R's nonce nr\n\t\tclaim_i3(I,Niagree);      // Claim that both parties agree on the nonce\n\t\tclaim_i4(I,Nisynch);      // Claim that both parties are synchronized\n\t}\t\n\t\n\trole R\n\t{\n\t\t// R receives nonce ni from I\n\t\tvar ni: Nonce;\n\t\t// R generates a fresh nonce nr\n\t\tfresh nr: Nonce;\n\n\t\t// R receives I's identity and nonce ni encrypted with R's public key\n\t\trecv_1(I,R, {I,ni}pk(R) );\n\t\t// R sends back ni, its nonce nr, and I's identity encrypted with I's public key\n\t\tsend_2(R,I, {ni,nr,R}pk(I) );\n\t\t// R receives the nonce nr encrypted with R's public key from I\n\t\trecv_3(I,R, {nr}pk(R) );\n\n\t\t// Claims regarding the knowledge of secrets and agreement\n\t\tclaim_r1(R,Secret,ni);   // Claim that R knows I's nonce ni\n\t\tclaim_r2(R,Secret,nr);   // Claim that R knows its own nonce nr\n\t\tclaim_r3(R,Niagree);      // Claim that both parties agree on the nonce\n\t\tclaim_r4(R,Nisynch);      // Claim that both parties are synchronized\n\t}\n}"
    },
    {
        "file": "SPDL-1/Signed-DH.spdl",
        "logic": "To generate a description content for the given SPDL file of a protocol, we will outline the key elements and operations of the Two-move Diffie-Hellman protocol as implemented in the provided SPDL content.\n\n---\n\n### Protocol Description: Two-move Diffie-Hellman in the Universal Model (UM)\n\n**Overview:**\nThe Two-move Diffie-Hellman (DH) protocol enables two parties, identified as initiator (I) and responder (R), to establish a shared secret key in a secure manner. The protocol is structured in two main communication phases, utilizing nonce values and a series of cryptographic operations to ensure confidentiality and authenticity.\n\n**Roles:**\n1. **Initiator (I)**:\n   - The initiator generates two fresh nonce values, `s` and `x`, which are unique for each execution of the protocol. \n   - The initiator sends a message to the responder containing its identity, the nonce `s`, and a computed value `g1(x)`.\n   - Upon receiving a response from the responder, which includes a ticket (`beta`), the initiator sends a final message encapsulating its identity, nonce `s`, and a signed message that includes its identity and the received ticket.\n   - Finally, the initiator claims the secret key (`SKR`) derived from the responder\u2019s ticket (`beta`) and its own nonce (`x`).\n\n2. **Responder (R)**:\n   - The responder generates a fresh nonce `y` for its part in the exchange.\n   - It receives the initial message from the initiator and extracts the initiator's identity, nonce `s`, and the ticket (`alpha`).\n   - After verifying the message, the responder claims the session identifier (`SID`) linked to nonce `s`.\n   - The responder then constructs a message that includes its identity, nonce `s`, a computed value `g1(y)`, and a signed ticket back to the initiator.\n   - Once it receives the final message, it verifies the signature and claims the secret key (`SKR`) derived from its own ticket (`alpha`) and the nonce `y`.\n\n**Security Claims:**\n- The protocol guarantees that both parties can derive a shared secret key (`SKR`) without exposure to their individual nonce values or tickets.\n- The use of signatures ensures that the messages exchanged between the initiator and responder are authenticated, preventing impersonation attacks.\n\n**Hash Functions:**\n- The protocol employs hash functions (`h1`, `h2`, `g1`, `g2`) for generating cryptographic values, ensuring that all exchanged information remains secure and confidential.\n\n**Helper Protocol:**\n- An auxiliary protocol `@exponentiation` is defined to simulate the mathematical exponentiation operation necessary for the protocol's cryptographic computations. This helper protocol is used for clarity in the Scyther tool's display and does not affect the automatic generation of protocol modifiers.\n\n---\n\nThis description clarifies the intentions, actions, and security aspects of the Two-move Diffie-Hellman protocol, enabling the generation of the corresponding SPDL file suitable for use with the Scyther tool.",
        "code": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) );\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce;\n\t\tfresh x: Nonce;\n\t\tvar beta: Ticket;\n\n\t\tclaim(I, SID, s);\n\t\tsend_1(I,R, I,s,g1(x) );\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n\n\t\tclaim(I,SKR, g2(beta,x) );\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce;\n\t\tvar s: Nonce;\n\t\tvar alpha: Ticket;\n\n\t\trecv_1(I,R, I,s,alpha );\n\t\tclaim(R, SID, s);\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) );\n\n\t\tclaim(R,SKR, g2(alpha,y) );\n\t}\n}",
        "codenote": "/* \n * Two-move Diffie-Hellman in the UM\n * From CK2001, p. 20\n */\n\n// Hash functions\nhashfunction h1,h2,g1,g2;\n\n/*\n * Hack to simulate g^ab = g^ba.\n * '@' prefix of protocol name denotes helper protocol, which is used by\n * Scyther for displaying, and such protocols are ignored in\n * auto-generation of protocol modifiers.\n */\nprotocol @exponentiation(RA)\n{\n\trole RA\n\t{\n\t\tvar alpha,beta, T1,T2: Ticket;\n\n\t\trecv_!1(RA,RA, g2(g1(T1),T2) ); \n        // RA receives the first message and computes g2(g1(T1), T2)\n\t\tsend_!2(RA,RA, g2(g1(T2),T1) );\n        // RA sends the second message with the computed value\n\t}\n}\n\n// The protocol description\n\nprotocol SIG-DH-UM(I,R)\n{\n\trole I\n\t{\n\t\tfresh s: Nonce; // Nonce for session identifier\n\t\tfresh x: Nonce; // Nonce for private key\n\t\tvar beta: Ticket; // Ticket received from role R\n\n\t\tclaim(I, SID, s); // Claim the session identifier\n\t\tsend_1(I,R, I,s,g1(x) ); \n        // I sends its identity, session identifier, and its public key g1(x) to R\n\t\trecv_2(R,I, R,s,beta, { R,s,beta,g1(x),I }sk(R) );\n        // I receives the second message which includes R's response and verifies it\n\t\tsend_3(I,R, I,s, { I,s,g1(x),beta,R }sk(I) );\n        // I sends its response back to R with the ticket received\n\n\t\tclaim(I,SKR, g2(beta,x) ); // Claim the shared secret key SKR\n\t}\t\n\t\n\trole R\n\t{\n\t\tfresh y: Nonce; // Nonce for private key\n\t\tvar s: Nonce; // Session nonce from I\n\t\tvar alpha: Ticket; // Ticket received from role I\n\n\t\trecv_1(I,R, I,s,alpha ); \n        // R receives the first message and the public key g1(x)\n\t\tclaim(R, SID, s); // Claim the session identifier\n\t\tsend_2(R,I, R,s,g1(y), { R,s,g1(y),alpha,I }sk(R) );\n        // R sends its response, including its own public key g1(y) and verifies it\n\t\trecv_3(I,R, I,s, { I,s,alpha,g1(y),R }sk(I) ); \n        // R receives I's final response and verifies it\n\n\t\tclaim(R,SKR, g2(alpha,y) ); // Claim the shared secret key SKR\n\t}\n}"
    },
    {
        "file": "SPDL-1/skeme-basic.spdl",
        "logic": "---\n\n### Protocol Description: SKEME Basic Protocol\n\n**Overview:**\nThe SKEME Basic protocol is a cryptographic key exchange protocol that enables two parties, referred to as Initiator (I) and Responder (R), to establish a shared secret key securely. It employs nonces for freshness and uses cryptographic primitives such as public-key encryption, hash functions, and a pseudo-random function (PRF) to ensure security properties.\n\n**Roles:**\n1. **Initiator (I):** This role represents the party that initiates the communication and key exchange.\n2. **Responder (R):** This role represents the party that responds to the Initiator's requests and participates in the key exchange.\n\n**Key Variables:**\n- **Nonces (i, r, Ni, Nr):** These are fresh random values generated by the parties to prevent replay attacks.\n- **Tickets (Gr, Gi):** These are values that may represent shared secrets or session identifiers.\n  \n**Cryptographic Functions:**\n- **Public Key Encryption (pk):** This is used to encrypt messages using the recipient's public key.\n- **Pseudo-Random Function (prf):** This function takes inputs and produces a pseudo-random output, which is used to derive keys.\n- **Key Derivation Function (KDF):** This function takes a hash value and derives a key from it.\n- **Hash Functions (g, h):** These functions are used for creating fixed-size output from arbitrary input.\n\n**Message Sequence:**\n1. **Initiator to Responder:**\n   - The Initiator sends a message containing its identity (I) and a nonce (Ni) encrypted with the Responder's public key, along with a value `g(i)` (a transformation of the nonce `i`).\n   \n2. **Responder to Initiator:**\n   - The Responder receives the first message and sends back its own nonce (Nr), encrypted with the Initiator's public key, along with a value `g(r)` and a computed value using the PRF based on the nonces and the ticket.\n   \n3. **Initiator Finalizes the Exchange:**\n   - The Initiator receives the second message and sends a final message back to the Responder, containing a computed value using the PRF, which is based on the nonces, the ticket, and both parties' identities.\n   \n**Claims:**\n- Each role makes claims about the security properties they have established:\n  - **SKR (Session Key Ready):** Each party claims to have derived a session key (`KDF(h(Gr, i))` for Initiator and `KDF(h(Gi, r))` for Responder) that can be used for secure communication.\n  - **Alive:** Each party claims that the other is active and present in the protocol.\n  - **Weak Agreement:** Each party claims that they have agreed on a common value (the session key).\n\n**Security Properties:**\nThe protocol is designed to ensure:\n- **Confidentiality:** Messages are encrypted to protect against eavesdropping.\n- **Integrity:** The use of nonces and PRFs ensures that messages cannot be tampered with without detection.\n- **Authenticity:** Both parties authenticate each other through the exchange of encrypted messages and the use of nonces.\n\n---",
        "code": "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n }\n}",
        "codenote": "# 1 \"skeme-basic.cpp\"\n# 1 \"<command-line>\"\n# 1 \"skeme-basic.cpp\"\n# 21 \"skeme-basic.cpp\"\n# 1 \"common.h\" 1\n\n\n\n\n hashfunction prf, KDF;\n\n\n\n\n\n\nhashfunction g, h;\n# 97 \"common.h\"\nprotocol @oracle (DH, SWAP) {\n\n\n\n\n\n\n\n role DH {\n  var i, r: Nonce;\n\n  recv_!DH1( DH, DH, h(g(r),i) );\n  send_!DH2( DH, DH, h(g(i),r) );\n }\n\n\n\n\n role SWAP {\n  var i, r, Ni, Nr: Nonce;\n# 150 \"common.h\"\n  recv_!SWAP1( SWAP, SWAP, KDF(h(g(r),i)) );\n  send_!SWAP2( SWAP, SWAP, KDF(h(g(i),r)) );\n\n }\n\n\n}\n# 22 \"skeme-basic.cpp\" 2\n\n\n\n\nprotocol skeme-basic(I, R)\n{\n role I {\n  fresh i, Ni: Nonce;\n  var Nr: Nonce;\n  var Gr: Ticket;\n\n  send_1( I, R, {I, Ni}pk(R), g(i) );\n  recv_2( R, I, {Nr}pk(I), Gr, prf(prf(Ni,Nr), g(i), Gr, R, I) );\n  send_3( I, R, prf(prf(Ni,Nr), Gr, g(i), I, R) );\n\n\n  claim( I, SKR, KDF(h(Gr,i)) );\n\n  claim( I, Alive );\n  claim( I, Weakagree );\n\n  /* Annotations for role I */\n  claim( I, secrecy(Ni) ); // Ni should remain secret to R\n  claim( I, secrecy(Nr) ); // Nr should remain secret to I\n  claim( I, auth(I, R) );  // I should be authenticated to R\n\n }\n\n role R {\n  fresh r, Nr: Nonce;\n  var Ni: Nonce;\n  var Gi: Ticket;\n\n  recv_1( I, R, {I, Ni}pk(R), Gi );\n  send_2( R, I, {Nr}pk(I), g(r), prf(prf(Ni,Nr), Gi, g(r), R, I) );\n  recv_3( I, R, prf(prf(Ni,Nr), g(r), Gi, I, R) );\n\n\n  claim( R, SKR, KDF(h(Gi,r)) );\n\n  claim( R, Alive );\n  claim( R, Weakagree );\n\n  /* Annotations for role R */\n  claim( R, secrecy(Nr) ); // Nr should remain secret to I\n  claim( R, secrecy(Ni) ); // Ni should remain secret to R\n  claim( R, auth(R, I) );  // R should be authenticated to I\n\n }\n}"
    }
]