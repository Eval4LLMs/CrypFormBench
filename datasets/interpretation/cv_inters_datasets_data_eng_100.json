[
    {
        "file": "CV-1/Avik-elgamal.cv",
        "logic": "To generate a description content of the ElGamal encryption scheme based on the provided CryptoVerif (cv) file, we will outline the key components and assumptions used in the protocol. This description will serve as a basis for creating the corresponding cv file for CryptoVerif.\n\n---\n\n**ElGamal Encryption Scheme Description**\n\nThe ElGamal encryption scheme is a public key cryptographic system that relies on the difficulty of the discrete logarithm problem. This scheme consists of key generation, encryption, and decryption processes. In our construction, we provide a proof of security under the Decisional Diffie-Hellman (DDH) assumption.\n\n### Parameters\n- **n**: A security parameter that defines the size of the group used in the encryption scheme.\n- **q**: A parameter related to the order of the group.\n\n### Types\n- **Z**: A type representing integers in a finite field, where the size is fixed.\n- **G**: A type representing elements of a cyclic group, where the size is fixed.\n\n### Probability\n- **pDDH**: A probability function representing the advantage of an adversary in distinguishing between the real and random tuples in the context of the DDH assumption.\n\n### Functions and Constants\n- **exp(G,Z)**: A function that computes the exponentiation of a group element.\n- **gamma**: A constant representing a uniform generator of the group G.\n\n### Equivalence Relations\n1. **BB condition**: The difference in probability between two distributions is zero, indicating that they are computationally indistinguishable.\n2. The exponentiation function is defined such that multiplication of exponents corresponds to the multiplication of group elements.\n\n### Properties of Functions\n- **mult(Z,Z)**: A function for multiplying two exponents.\n- **dot(G,G)**: A function for combining two group elements, with the property that it is a uniform function.\n- **invdot(G,G)**: The left-inverse function for the dot function.\n\n### Security Assumption\nThe scheme relies on the Decisional Diffie-Hellman assumption, which asserts that given three group elements \\(g^a\\), \\(g^b\\), and \\(g^{ab}\\), it is hard to distinguish these from a random triple of group elements.\n\n### Choose Function\n- **choose(bool,G,G)**: A function that selects one of two group elements based on a boolean condition.\n\n### Query\nThe security of the encryption scheme is analyzed through a query to check the secrecy of the encrypted messages.\n\n### Communication Channels\n- **cPK**: Channel for sending the public key.\n- **cE**: Channel for sending encryption requests.\n- **cEret**: Channel for returning the encryption results.\n- **start**: A channel to initiate the encryption process.\n\n### Processes\n1. **processE**: This process handles the encryption of messages based on the secret key and random choices. It computes the ciphertext by generating a random exponent and using it to encrypt one of the two possible messages.\n2. **Main Process**: The process begins by receiving a start signal, generating a secret key, and sending the public key to the requester. It then calls the encryption process to handle encryption requests.\n\n### Expected Output\nWhen the CryptoVerif tool runs successfully, it should confirm that all queries have been proved with no security violations detected.\n\n---\n\nWith this description content, you can re-create the corresponding cv file for CryptoVerif based on the structure and elements outlined above. The cv file provided initially reflects the described protocol accurately and can be run in CryptoVerif to verify its security properties under the DDH assumption.",
        "code": "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q.\n\ntype Z [fixed].\n\ntype G [fixed].\n\nproba pDDH.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new x:Z; exp(gamma,x) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun dot(G,G): G.\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\nfun invdot(G,G): G.\n\n(* invdot is the left-inverse of dot *)\n\nforall a:G, b:G;\n  invdot(a, dot(a,b)) = b.\n\n(* the DDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, mult(x,y)) ) (* BB: removed [all] *)\n<=(pDDH(time) * n)=>  (* BB: Was pDDH(time,n) *)\n    !n new x:Z; new y:Z; new z:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, z) ).\n\nfun choose(bool,G,G): G.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:G, z:G;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret b.\n\nchannel cPK, cE, cEret, start.\n\nlet processE = \n    in(cE, (m0:G, m1:G));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let zeta = dot(delta, m) in\n    out(cEret, (beta,zeta)).\n\nprocess\n  !q  (* BB: Replication not present in Shoup's paper, but ok *)\n  in(start, ());\n  new x:Z;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  processE\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)",
        "codenote": "(** ElGamal encryption scheme **)\n\n(** An encryption scheme is shown to be SS\n    under the DDH assumption.\n    See Section 3, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q.\n\ntype Z [fixed].                           (* Type Z to represent integers in the protocol *)\n\ntype G [fixed].                           (* Type G to represent group elements incompatible with Z *)\n\nproba pDDH.                              (* Probability function for the DDH assumption *)\n\nfun exp(G,Z): G.                          (* Exponentiation function: computes g^x for g in G and x in Z *)\nconst gamma:G.                           (* A fixed generator of group G *)\n\n(* gamma is a uniform generator *)\n\nequiv \n    () n -> new x:Z; exp(gamma,x) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    () n -> new y:G; y.\n\nfun mult(Z,Z): Z.                        (* Function to multiply two integers *)\n\nequation commut(mult).                   (* Commutativity property of multiplication *)\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)). (* Associativity of exponentiation *)\n\nfun dot(G,G): G.                         (* Inner product-like function, operates on G *)\n\n(* dot(.,y) is a uniform function *)\n\nequiv \n    (y:G) n -> new x:G; dot(x,y) [all]\n<=(0)=> (* BB: The difference of probability is 0 *)\n    (y:G) n -> new x:G; x.\n\nfun invdot(G,G): G.                      (* Function to compute the left-inverse of the dot function *)\n\n(* invdot is the left-inverse of dot *)\n\nforall a:G, b:G;\n  invdot(a, dot(a,b)) = b.               (* Left-inverse property of the dot function *)\n\n(* the DDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, mult(x,y)) ) (* BB: removed [all] *)\n<=(pDDH(time) * n)=>  (* BB: Was pDDH(time,n) *)\n    !n new x:Z; new y:Z; new z:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      () -> exp(gamma, z) ).\n\nfun choose(bool,G,G): G.                  (* Function to choose between two group elements based on a boolean *)\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:G, z:G;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).  (* Correct behavior for choosing elements based on a boolean *)\n\n(* query *)\nquery secret b.                          (* Querying for a secret value, represented by b *)\n\nchannel cPK, cE, cEret, start.          (* Channels for public key, encryption, encryption return, and start signal *)\n\nlet processE = \n    in(cE, (m0:G, m1:G));               (* Receiving two messages (m0 and m1) through channel cE *)\n    new b:bool;                        (* New boolean value to determine choice *)\n    let m = choose(b,m1,m0) in       (* Choosing between m1 and m0 based on b *)\n    new y:Z;                          (* New integer value y for encryption *)\n    let beta = exp(gamma,y) in        (* Beta is the result of gamma raised to y *)\n    let delta = exp(alpha,y) in       (* Delta is computed from alpha raised to y *)\n    let zeta = dot(delta, m) in       (* Zeta is the dot product of delta and the chosen message *)\n    out(cEret, (beta,zeta)).          (* Sending the pair (beta, zeta) over channel cEret *)\n\nprocess\n  !q  (* BB: Replication not present in Shoup's paper, but ok *)\n  in(start, ());                      (* Start the process upon receiving a signal *)\n  new x:Z;                            (* New integer value x for public key generation *)\n  let alpha = exp(gamma,x) in        (* Alpha is computed as gamma raised to x *)\n  out(cPK, alpha);                   (* Sending the public key alpha over channel cPK *) \n  processE                            (* Proceed to the encryption process *)\n\n(* EXPECTED\nAll queries proved.\n0.020s (user 0.020s + system 0.000s), max rss 16560K\nEND *)"
    },
    {
        "file": "CV-1/Avik-hash-elgamal-CDH.cv",
        "logic": "---\n\n### Description of the Hashed ElGamal Encryption Scheme\n\n**Overview:**\nThe Hashed ElGamal encryption scheme is an asymmetric encryption scheme that utilizes the hardness of the Computational Diffie-Hellman (CDH) problem for its security. It operates within the random oracle model, which is a theoretical framework where hash functions behave like random functions. This scheme provides confidentiality through the use of a hash function and allows for the encryption of messages.\n\n**Key Components:**\n\n1. **Parameters:**\n   - `n`: A security parameter that defines the size of the groups and other cryptographic parameters.\n   - `q`: A parameter related to the number of queries allowed.\n   - `nH`: The number of queries to the random oracle.\n   - `nCDH`, `nCDH'`: Parameters related to the CDH assumption.\n\n2. **Types:**\n   - `Z`: Represents integers (exponents).\n   - `G`: Represents a group element (the multiplicative group).\n   - `K`: Represents the key space.\n   - `D`: Represents data (messages).\n\n3. **Probability:**\n   - `pCDH`: Represents the probability associated with the CDH assumption.\n\n4. **Functions:**\n   - `exp(G, Z)`: Exponentiation function for group elements.\n   - `mult(Z, Z)`: Multiplication of integers (exponents).\n   - `xor(D, D)`: XOR operation for data.\n   - `h(K, G)`: A hash function mapping from keys and group elements to data.\n\n5. **Security Properties:**\n   - The scheme is shown to be selectively secure (SS) under the CDH assumption in the random oracle model.\n   - The security relies on the difficulty of solving the CDH problem, which states that given `g^x` and `g^y`, it is hard to compute `g^{xy}`.\n   - The XOR operation is used as a one-time pad for ensuring confidentiality of the messages.\n\n6. **Processes:**\n   - **Encryption Process (processE):** \n     - Takes two messages (m0 and m1) and a boolean `b` to choose between them.\n     - Computes the necessary group elements and hashes the output to produce the ciphertext (beta, v).\n   - **Hashing Process (processH):**\n     - Takes an input `xH` and outputs the hash value.\n\n7. **Main Process:**\n   - Initiates by generating a public key (`alpha`).\n   - Supports concurrent processing of encryption and hashing requests.\n\n**Conclusion:**\nThe Hashed ElGamal encryption scheme provides a secure method for encrypting messages while relying on the CDH assumption and using a random oracle for hashing. The defined processes and functions in the protocol allow for the establishment of a secure communication channel.\n\n---",
        "code": "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q, nH, nCDH, nCDH'.\n\ntype Z [fixed].\ntype G.\ntype K [large,fixed].\ntype D [fixed].\n\nproba pCDH.\n\nfun exp(G,Z): G.\nconst gamma:G.\n\nfun mult(Z,Z): Z.\nequation commut(mult).\n\n(* exponents multiply *)\n\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)).\n\nfun xor(D,D): D.\n\n(* xor self-cancels *)\n\nforall x:D, y:D;\n  xor(x, xor(x,y)) = y.\n\n(* xor(.,y) is a one-time pad *)\n\nequiv \n    (y:D) n -> new x:D; xor(x,y) [all]\n<=(0)=>   (* BB: The difference of probability is 0 *)\n    (y:D) n -> new x:D; x.\n\n(* the CDH assumption *) \n\nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> z = exp(gamma, mult(x,y))\n )\n<=(pCDH(time,n,nCDH))=>\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> false ).\n\nfun h(K,G): D.\n\n(* h in the random oracle model *)\n\nequiv !n new k:K; (x:G) nH -> h(k,x)\n      <=(0)=>\n      !n new k:K; (x:G) nH -> find j <= nH suchthat defined(x[j],r[j]) && otheruses(r[j]) && x= x[j] then r[j] else\n\t\t\t new r:D; r.\n\n    \nfun choose(bool,D,D): D.\n\n(* choose(b,M,N) = if b then M else N *)\n\nforall x:bool, y:D, z:D;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z).\n\n(* query *)\nquery secret b.\n\nchannel dummy, cPK, cE, cEret, cH, cHret, start.\n\nlet processE = \n    in(cE, (m0:D, m1:D));\n    new b:bool;\n    let m = choose(b,m1,m0) in\n    new y:Z;\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let hash = h(k,delta) in\n    let v = xor(hash, m) in\n    out(cEret, (beta,v)).\n\nlet processH =\n  !nH\n  in(cH, xH:G);\n  out(cHret, h(k,xH)).\n\nprocess\n  !q   (* BB: Replication not present in Shoup's paper, but ok *)\n  in(dummy, ());\n  new x:Z;\n  new k:K;\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha); \n  (processE | processH)\n\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19040K\nEND *)",
        "codenote": "(** Hashed ElGamal encryption scheme, in the random oracle model **)\n\n(** An encryption scheme is shown to be SS\n    under the CDH assumption, in the random oracle model.\n    See Section 8, \"Sequences of Games\", Victor Shoup. **)\n\nparam n, q, nH, nCDH, nCDH'.\n\ntype Z [fixed]. (** Type for integers modulo a prime. *)\ntype G. (** Type for the group elements (for ElGamal). *)\ntype K [large,fixed]. (** Type for cryptographic keys. *)\ntype D [fixed]. (** Type for data/messages to be encrypted. *)\n\nproba pCDH. (** Probability associated with the Computational Diffie-Hellman assumption. *)\n\nfun exp(G,Z): G. (** Exponentiation function for group elements in G. *)\nconst gamma:G. (** A generator of the group G. *)\n\nfun mult(Z,Z): Z. (** Multiplication operation on Z. *)\nequation commut(mult). (** Commutativity of the multiplication operation. *)\n\n(* exponents multiply *)\nforall a:G, x:Z, y:Z;\n  exp(exp(a,x), y) = exp(a, mult(x,y)). (** Property of exponentiation. *)\n\nfun xor(D,D): D. (** XOR function for data messages. *)\n\n(* xor self-cancels *)\nforall x:D, y:D;\n  xor(x, xor(x,y)) = y. (** XOR self-cancellation property. *)\n\n(* xor(.,y) is a one-time pad *)\nequiv \n    (y:D) n -> new x:D; xor(x,y) [all]\n<=(0)=>   (* BB: The difference of probability is 0 *)\n    (y:D) n -> new x:D; x. (** Expected equivalence for the XOR operation. *)\n\n(* the CDH assumption *) \nequiv\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> z = exp(gamma, mult(x,y))\n )\n<=(pCDH(time,n,nCDH))=>\n    !n new x:Z; new y:Z; (\n      () -> exp(gamma,x), \n      () -> exp(gamma,y), \n      (z:G) nCDH -> false ). (** CDH assumption holds under defined conditions. *)\n\nfun h(K,G): D. (** Hash function definition in the random oracle model. *)\n\n(* h in the random oracle model *)\nequiv !n new k:K; (x:G) nH -> h(k,x)\n      <=(0)=>\n      !n new k:K; (x:G) nH -> find j <= nH suchthat defined(x[j],r[j]) && otheruses(r[j]) && x= x[j] then r[j] else\n\t\t\t new r:D; r. (** Behavior of the hash function. *)\n    \nfun choose(bool,D,D): D. (** Conditional selection function; chooses one of two values. *)\n\n(* choose(b,M,N) = if b then M else N *)\nforall x:bool, y:D, z:D;\n  (x && choose(x,y,z) = y) || (not(x) && choose(x,y,z) = z). (** Conditional logic properties. *)\n\n(* query *)\nquery secret b. (** Query for secret information with boolean flag. *)\n\nchannel dummy, cPK, cE, cEret, cH, cHret, start. (** Channel definitions for communication. *)\n\nlet processE = \n    in(cE, (m0:D, m1:D)); (** Process for encryption. Input two messages m0 and m1. *)\n    new b:bool; (** Choose between the two messages based on a boolean. *)\n    let m = choose(b,m1,m0) in\n    new y:Z; (** Random exponent for encryption. *)\n    let beta = exp(gamma,y) in\n    let delta = exp(alpha,y) in\n    let hash = h(k,delta) in\n    let v = xor(hash, m) in\n    out(cEret, (beta,v)). (** Output the encrypted message. *)\n\nlet processH =\n  !nH\n  in(cH, xH:G); (** Process for hash extraction. Input a group element xH. *)\n  out(cHret, h(k,xH)). (** Output the hash of xH. *)\n\nprocess\n  !q   (* BB: Replication not present in Shoup's paper, but ok *)\n  in(dummy, ()); (** Start the process by receiving a dummy message. *)\n  new x:Z; (** Random value for CDH assumption. *)\n  new k:K; (** Generate a new cryptographic key. *)\n  let alpha = exp(gamma,x) in\n  out(cPK, alpha);  (** Output the public key. *)\n  (processE | processH) (** Concurrently run the encryption and hash processes. *)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19040K\nEND *)"
    },
    {
        "file": "CV-1/ind_cca2.cv",
        "logic": "---\n\n### Protocol Description\n\n**Protocol Name**: Public Key Encryption Protocol\n\n**Overview**: This protocol describes a public key encryption scheme where messages can be encrypted using public keys generated from a common key seed. The protocol ensures that any ciphertext can only be decrypted by the corresponding secret key, thus maintaining confidentiality against chosen ciphertext attacks (CCA2).\n\n**Entities**:\n1. **Users**: Each user has a public/private key pair.\n2. **Key Seed**: A fixed-length seed that is used to generate the public and secret keys.\n3. **Public Key (pkey)**: The public component of the key pair, used for encryption.\n4. **Secret Key (skey)**: The private component of the key pair, used for decryption.\n5. **Cleartext**: The original message that needs to be encrypted.\n6. **Ciphertext**: The encrypted message produced after the encryption process.\n7. **Encryption Seed (enc_seed)**: A random value used during the encryption process to ensure that the same plaintext encrypts to different ciphertexts.\n\n**Functions**:\n1. **`skgen(keyseed): skey`**: Generates a secret key from the key seed.\n2. **`pkgen(keyseed): pkey`**: Generates a public key from the key seed.\n3. **`enc(cleartext, pkey, enc_seed): ciphertext`**: Encrypts a cleartext message using the public key and encryption seed.\n4. **`dec(ciphertext, skey): bitstringbot`**: Decrypts a ciphertext message using the secret key, yielding the original cleartext message.\n5. **`Z(cleartext): cleartext`**: A function used to denote a transformation or representation of the cleartext in a certain context.\n\n**Security Properties**:\n- **Indistinguishability under Chosen Ciphertext Attack (IND-CCA2)**: The protocol is designed to ensure that an attacker cannot distinguish between encryptions of two different messages, even when they can query the decryption oracle with chosen ciphertexts. \n\n**Equations**:\n- The main equation ensures that decrypting the ciphertext produced by encrypting a cleartext with the corresponding keys results in the original cleartext, represented as:\n  \\[\n  \\forall m:cleartext, k:keyseed, r:enc_seed; \\; dec(enc(m, pkgen(k), r), skgen(k)) = injbot(m).\n  \\]\n\n**Processes**:\n- The protocol includes processes for handling public key generation, encryption, and decryption requests, ensuring that the operations adhere to the defined security assumptions.\n\n**Parameters**:\n- **N**: Number of encryption operations allowed.\n- **N2**: Number of decryption operations allowed.\n- **Penc**: Probability distribution for encryption operations.\n\n---\n\n### Next Steps\n\nBased on this description, the provided cv file can be generated, which includes the formal definitions of types, functions, parameters, and security assumptions as outlined above. This cv file can then be processed using the CryptoVerif tool to verify the security properties of the described public key encryption protocol.",
        "code": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [fixed].\ntype cleartext.\ntype ciphertext.\ntype enc_seed [bounded].\n\nparam N, N2.\n\nproba Penc.\n\nfun Z(cleartext):cleartext.\nfun enc(cleartext, pkey, enc_seed): ciphertext.\nfun skgen(keyseed):skey.\nfun pkgen(keyseed):pkey.\n\n(* part displayed in the paper starts here *)\nfun dec(ciphertext, skey): bitstringbot.\nfun injbot(cleartext):bitstringbot [data].\n\nequation forall m:cleartext, k:keyseed, r:enc_seed; \n  dec(enc(m, pkgen(k), r), skgen(k)) = injbot(m).\n\ntable cipher(cleartext, ciphertext).\n\nequiv(ind_cca2(enc))\n  k <-R keyseed; (\n    Opk() := return(pkgen(k)) |\n    foreach i2 <= N2 do Odec(c:ciphertext) :=\n      return(dec(c, skgen(k))) |\n    foreach i <= N do r <-R enc_seed;\n      Oenc(m:cleartext) := return(enc(m, pkgen(k),r)))\n<=(N * Penc(time + (N-1) * time(enc, maxlength(m)), N2))=>\n  k <-R keyseed; (\n   Opk() := return(pkgen(k)) |\n   foreach i2 <= N2 do Odec(c:ciphertext) :=\n     get cipher(m1, =c) in return(injbot(m1))\n     else return(dec(c, skgen(k))) |\n   foreach i <= N do r <-R enc_seed;\n     Oenc(m:cleartext) :=\n       c1 <- enc(Z(m), pkgen(k), r);\n       insert cipher(m, c1); return(c1)).\n\nprocess 0",
        "codenote": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype pkey [bounded].   (* Public key type *)\ntype skey [bounded].   (* Secret key type *)\ntype keyseed [fixed].   (* Seed for key generation *)\ntype cleartext.        (* Type representing plaintext messages *)\ntype ciphertext.       (* Type representing encrypted messages *)\ntype enc_seed [bounded]. (* Random seed used in encryption *)\n\nparam N, N2.            (* Parameters defining the limits of operations *)\n\nproba Penc.            (* Probability of encryption operation *)\n\nfun Z(cleartext):cleartext.  (* Identity function on cleartext *)\nfun enc(cleartext, pkey, enc_seed): ciphertext.  (* Encryption function *)\nfun skgen(keyseed):skey.     (* Secret key generation function *)\nfun pkgen(keyseed):pkey.     (* Public key generation function *)\n\n(* Part displayed in the paper starts here *)\nfun dec(ciphertext, skey): bitstringbot. (* Decryption function *)\nfun injbot(cleartext):bitstringbot [data].  (* Injection of bottom element *)\n\nequation forall m:cleartext, k:keyseed, r:enc_seed; \n  dec(enc(m, pkgen(k), r), skgen(k)) = injbot(m). (* Decryption correctness *)\n\ntable cipher(cleartext, ciphertext).  (* Table for recording ciphertexts *)\n\nequiv(ind_cca2(enc))  (* Indistinguishability in the chosen-ciphertext attack model *)\n  k <-R keyseed; (\n    Opk() := return(pkgen(k)) |  (* Generate public key from seed *)\n    foreach i2 <= N2 do Odec(c:ciphertext) :=\n      return(dec(c, skgen(k))) |  (* Decrypt ciphertext using secret key *)\n    foreach i <= N do r <-R enc_seed;  (* Randomly select enc_seed *)\n      Oenc(m:cleartext) := return(enc(m, pkgen(k), r)))  (* Encrypt message *)\n<=(N * Penc(time + (N-1) * time(enc, maxlength(m)), N2)) =>\n  k <-R keyseed; (\n   Opk() := return(pkgen(k)) |  (* Regenerate public key *)\n   foreach i2 <= N2 do Odec(c:ciphertext) :=\n     get cipher(m1, =c) in return(injbot(m1))  (* Check cipher table for matches *)\n     else return(dec(c, skgen(k))) |  (* Decrypt or return bottom element *)\n   foreach i <= N do r <-R enc_seed;  (* Again randomly select enc_seed *)\n     Oenc(m:cleartext) :=  (* Encrypt with transformation *)\n       c1 <- enc(Z(m), pkgen(k), r);\n       insert cipher(m, c1); return(c1)).  (* Store ciphertext in table *)\n\nprocess 0"
    },
    {
        "file": "CV-1/ind_cpa.cv",
        "logic": "---\n\n### Protocol Description\n\n**Protocol Name:** Indistinguishability under Chosen Plaintext Attack (IND-CPA) Secure Encryption Protocol\n\n**Overview:**\nThe protocol implements a cryptographic encryption scheme that ensures security against chosen plaintext attacks (CPA). The primary goal is to maintain the confidentiality of messages encrypted under an adversarial model where the attacker can choose plaintexts to be encrypted and analyze the resulting ciphertexts.\n\n**Key Components:**\n1. **Types:**\n   - `cleartext`: Represents the original message or data before encryption.\n   - `ciphertext`: Represents the encrypted output of the encryption function.\n   - `key`: A bounded type that represents the secret key used for encryption.\n   - `enc_seed`: A bounded type that serves as a random seed for the encryption process.\n\n2. **Functions:**\n   - `enc(cleartext, key, enc_seed)`: This function takes a `cleartext`, a `key`, and an `enc_seed` as inputs and returns the corresponding `ciphertext`. This is the core encryption function of the protocol.\n   - `Z(cleartext)`: This function is a deterministic transformation of `cleartext`. It represents a potential modification of the input before encryption, ensuring that the original message is altered in a controlled manner.\n\n3. **Parameters:**\n   - `N`: Represents the number of encryption operations to be performed in a single execution of the protocol.\n   - `Penc`: A probability distribution that models the probability of successful encryption attempts over time, given the maximum length of the input.\n\n**Security Model:**\nThe security of the protocol is established through an equivalence relation defined in the context of IND-CPA. The protocol ensures that an adversary cannot distinguish between the ciphertexts produced from two different plaintexts, even when they can request the encryption of chosen plaintexts.\n\n**Equivalence Assertion:**\n1. The protocol first generates a random `key` for encryption.\n2. For each encryption operation up to `N`, a random `enc_seed` is generated.\n3. The output of the encryption function is defined as `Oenc(x:cleartext) := return(enc(x, k, r))`, where `x` is the plaintext input.\n4. The equivalence is established by showing that if an adversary can break the encryption given `x`, they can also break it given `Z(x)`, which is a modified version of `x`.\n\n**Process:**\nThe encryption process is initiated with a process identifier of `0`, indicating the start of the protocol execution.\n\n---",
        "code": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\ntype cleartext.\ntype ciphertext.\ntype key [bounded].\ntype enc_seed [bounded].\n\nfun enc(cleartext, key, enc_seed): ciphertext.\nfun Z(cleartext):cleartext.\n\nparam N.\nproba Penc.\n\nequiv(ind_cpa(enc))\n  k <-R key; \n  foreach i <= N do \n    r <-R enc_seed; \n    Oenc(x:cleartext) :=  return(enc(x, k, r)) \n<=(Penc(time, N, maxlength(x)))=> \n  k <-R key;\n  foreach i <= N do \n  r <-R enc_seed; \n  Oenc(x:cleartext) := return(enc(Z(x), k, r)).\n\nprocess 0",
        "codenote": "(*************************************************************\n *                                                           *\n *       Translation from CryptoVerif to EasyCrypt           *\n *                                                           *\n *       Bruno Blanchet, Pierre Boutry, Christian Doczkal,   *\n *       and Pierre-Yves Strub                               *\n *                                                           *\n *       Copyright INRIA, MPI-SP, Ecole Polytechnique,       *\n *\t 2019-2024                                           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright INRIA, MPI-SP, Ecole Polytechnique\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  Pierre Boutry, Pierre.Boutry@inria.fr\n                  Christian Doczkal, Christian.Doczkal@mpi-sp.org\n                  Pierre-Yves Strub, pierre-yves@strub.nu\n\nThis software is a computer program whose purpose is to translate\nCryptoVerif security assumptions into EasyCrypt.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n\n(* Types for the protocol *)\ntype cleartext. (* Represents the plaintext data *)\ntype ciphertext. (* Represents the encrypted data *)\ntype key [bounded]. (* Represents the keys used for encryption *)\ntype enc_seed [bounded]. (* Represents the seeds used for the encryption process *)\n\nfun enc(cleartext, key, enc_seed): ciphertext. (* Encryption function *)\nfun Z(cleartext):cleartext. (* The function Z transforms cleartext data *)\n\nparam N. (* Number of encryption attempts *)\nproba Penc. (* Probability used in the security argument *)\n\n(* Security notion: ind-cpa (indistinguishability under chosen plaintext attack) *)\nequiv(ind_cpa(enc))\n  k <-R key;  (* Choose a random key *)\n  \n  foreach i <= N do \n    r <-R enc_seed;  (* Choose a random encryption seed *)\n    \n    Oenc(x:cleartext) := return(enc(x, k, r)) (* Real encryption operation *)\n    \n<=(Penc(time, N, maxlength(x)))=> \n\n  k <-R key; (* Choose a new random key for the second experiment *)\n  \n  foreach i <= N do \n    r <-R enc_seed;  (* Choose a random encryption seed again *)\n    \n    Oenc(x:cleartext) := return(enc(Z(x), k, r)). (* Encryption of transformed input *)\n\nprocess 0. (* Processing of protocol starts here *)"
    },
    {
        "file": "CV-1/pfdh.cv",
        "logic": "To generate a description content for the protocol you're working on, we need to summarize its key components, mechanisms, and objectives. Below is a structured description that can be used to create a corresponding CV file for CryptoVerif:\n\n---\n\n## Description of the Protocol\n\n### Protocol Overview\nThis protocol is a cryptographic communication scheme that utilizes a one-way trapdoor permutation (OW-TP) and a hash function modeled as a random oracle. The main objective of the protocol is to securely send messages between a sender (processS) and a receiver (processT) using asymmetric key cryptography.\n\n### Key Components\n1. **Key Generation**:\n   - **Keyseed**: Randomly generated seed used to derive both the secret key (skey) and the public key (pkey).\n   - **Public Key Generation (pkgen)**: A function that takes a keyseed and produces a public key.\n   - **Secret Key Generation (skgen)**: A function that derives the secret key from the keyseed.\n\n2. **One-Way Trapdoor Permutation (OW-TP)**:\n   - A mathematical function that is easy to compute in one direction but difficult to invert without a secret (trapdoor). This is used to secure the messages.\n\n3. **Hash Function**:\n   - Implemented as a random oracle, it takes input messages combined with random seeds and produces hash values that are used for message authentication.\n\n### Processes\n1. **Sender Process (processS)**:\n   - Waits for a message (m) from channel `c1`.\n   - Generates a new random seed (sr) for each message.\n   - Computes the message authentication tag using the secret key and the hash of the message concatenated with the seed.\n   - Sends the tuple `(sr, mf(sk, hash(hk, (m,sr))))` over channel `c2`.\n\n2. **Receiver Process (processT)**:\n   - Receives a message tuple from channel `c3` which includes a message (m2), a seed (sr), and a value (s).\n   - Validates the authenticity of the received message by checking if the computed hash matches the value in the tuple.\n   - If the validation fails, it triggers a `bad` event indicating a potential security breach.\n\n### Security Properties\n- The protocol ensures that an adversary cannot forge a valid message without knowledge of the secret key. The use of the OW-TP and the hash function in the random oracle model provides strong security guarantees against forgery attacks.\n- The `bad` event is defined to capture any instance where the integrity of the communication is compromised, allowing for the detection of anomalies in the messaging process.\n\n### Expected Outcomes\nThe protocol aims to successfully execute message exchanges while maintaining security, with all queries expected to be proved valid.\n\n---\n\nThis description can be used to construct the CV file for CryptoVerif, ensuring that each component is clearly defined and the overall purpose of the protocol is articulated. You may adjust the terminology or details based on specific aspects of the protocol that you wish to emphasize or clarify.",
        "code": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* PFDH signature scheme\n   The prover finds the same probability as for FDH, not the better\n   reduction by J.S.Coron. This is ok, because we do not give the\n   hypothesis of random self-reducibility.\n *)\n\n(* Example updated from CV 1.28 by Benjamin Beurdouche *)\n\n(*\nset interactiveMode = true.\n\nProof:\n\ncrypto hash\ncrypto mf r r_35 r_38\ncrypto f r\nsuccess\n\nThe prover finds the proof automatically, like for fdh, but is unable to find\nthe better reduction which exists for this scheme...\n*)\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [(*large,*)fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation *)\nproba pOW.\nexpand OW_trapdoor_perm(keyseed, pkey, skey, D, pkgen, skgen, f, mf, pOW).\n\n(* Hash function, random oracle model *)\n\ntype hashkey [fixed].\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Queries *)\nevent bad.\nquery event(bad) ==> false.\n\n(* Channels and Processes *)\nchannel c0, c1, c2, c3, c4, c5, start.\n\nlet processS(hk:hashkey, sk:skey) =\n\t! qS\n\tin(c1, m:bitstring);\n\tnew sr:seed;\n\tout(c2, (sr,mf(sk, hash(hk, (m,sr))))).\n\nlet processT(hk:hashkey, pk:pkey) =\n\tin(c3, (m2:bitstring, sr:seed, s:D));\n\tif f(pk, s) = hash(hk, (m2,sr)) then\n\tfind j <= qS suchthat defined(m[j]) && (m2 = m[j]) then yield else\n\tevent bad.\n\nprocess\n\t(in(start, ());\n\tnew hk: hashkey;\n\tnew r:keyseed;\n\tlet sk = skgen(r) in\n\tlet pk = pkgen(r) in\n\tout(c0, pk);\n\t(hashoracle(hk) | processS(hk,sk) | processT(hk,pk)))\n\n(* EXPECTED\nAll queries proved.\n0.061s (user 0.057s + system 0.004s), max rss 21056K\nEND *)",
        "codenote": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* PFDH signature scheme\n   The prover finds the same probability as for FDH, not the better\n   reduction by J.S.Coron. This is ok, because we do not give the\n   hypothesis of random self-reducibility.\n *)\n\n(* Example updated from CV 1.28 by Benjamin Beurdouche *)\n\n(*\nset interactiveMode = true.\n\nProof:\n\ncrypto hash\ncrypto mf r r_35 r_38\ncrypto f r\nsuccess\n\nThe prover finds the proof automatically, like for fdh, but is unable to find\nthe better reduction which exists for this scheme...\n*)\n\n(* Parameter defining the maximum number of signatures allowed. *)\nparam qS.\n\n(* Types for public key, secret key, key seed, and seed in the scheme *)\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [(*large,*)fixed].\ntype D [large,fixed].\n\n(* One-way trapdoor permutation definition. *)\nproba pOW.\nexpand OW_trapdoor_perm(keyseed, pkey, skey, D, pkgen, skgen, f, mf, pOW).\n\n(* Hash function, modeled as a random oracle *)\ntype hashkey [fixed].\nexpand ROM_hash_large(hashkey, bitstring, D, hash, hashoracle, qH).\n\n(* Events and queries: defining a bad event that leads to failure *)\nevent bad.\nquery event(bad) ==> false.\n\n(* Channels for communication between processes *)\nchannel c0, c1, c2, c3, c4, c5, start.\n\n(* Process for the signer S, generates signatures based on the hash of messages *)\nlet processS(hk:hashkey, sk:skey) =\n\t! qS\n\tin(c1, m:bitstring);    (* Receiver receives a message m *)\n\tnew sr:seed;             (* New random seed for the signature generation *)\n\tout(c2, (sr,mf(sk, hash(hk, (m,sr))))).  (* Sends the signature along with the seed *)\n\n(* Process for the verifier T, checks the signatures for validity *)\nlet processT(hk:hashkey, pk:pkey) =\n\tin(c3, (m2:bitstring, sr:seed, s:D));  (* Receives a message with its signature and a seed *)\n\tif f(pk, s) = hash(hk, (m2,sr)) then  (* Verifies the signature using the public key *)\n\tfind j <= qS suchthat defined(m[j]) && (m2 = m[j]) then yield else\n\tevent bad.  (* If verification fails, triggers the bad event *)\n\nprocess\n\t(in(start, ());\n\tnew hk: hashkey;             (* Generate new hash key for the protocol *)\n\tnew r:keyseed;               (* Generate new key seed for the signing key *)\n\tlet sk = skgen(r) in        (* Generate secret key from key seed *)\n\tlet pk = pkgen(r) in        (* Generate public key from key seed *)\n\tout(c0, pk);                (* Output the public key over channel c0 *)\n\t(hashoracle(hk) | processS(hk,sk) | processT(hk,pk)))  (* Run processes with oracle *)\n\n(* EXPECTED\nAll queries proved.\n0.061s (user 0.057s + system 0.004s), max rss 21056K\nEND *)"
    },
    {
        "file": "CV-1/Kyber.ocv",
        "logic": "---\n\n### Protocol Description\n\n**1. Overview:**\nThe protocol is a Cryptographic Key Encapsulation Mechanism (KEM) that provides both confidentiality and integrity. It consists of a public key encryption scheme (CPA KEM) and a final KEM that ensures secure key exchange.\n\n**2. Types:**\n- **CPA KEM Types:**\n  - `cpa_pk`: Public key of the CPA KEM.\n  - `cpa_sk`: Secret key of the CPA KEM.\n  - `cpa_ciphertext`: Ciphertext produced by the CPA KEM.\n  - `cpa_key_seed`: Seed used for generating keys.\n  - `cpa_enc_seed`: Seed used for encryption.\n\n- **Final KEM Types:**\n  - `kemskey`: Key material for the KEM.\n  - `ciphertext`: The ciphertext resulting from the KEM.\n  - `kem_seed`: Seed for KEM initialization.\n  - `kem_enc_seed`: Seed used for KEM encapsulation.\n  - `kemsec`: Secret output of the KEM.\n\n**3. Hash Functions:**\n- **Hash Outputs**:\n  - `hashes`: Output type for hash functions.\n  - `hashkey`, `hashkey2`, `hashkey3`: Keys for different hash functions.\n- **Collision Resistance**: The protocol employs collision-resistant hash functions to ensure that outputs are secure against collisions.\n\n**4. Functions:**\n- **KEM Key Generation:**\n  - `KEM_KeyPair(cpa_pk, kemskey)`: Generates a key pair consisting of a public key and secret key.\n\n- **CPA Key Generation Functions:**\n  - `cpa_pkgen(cpa_key_seed)`: Generates a CPA public key from a seed.\n  - `cpa_skgen(cpa_key_seed)`: Generates a CPA secret key from a seed.\n  \n- **Encryption and Decryption:**\n  - `cpa_enc(cpa_pk, hashes, cpa_enc_seed)`: Encrypts a message using the public key and returns a ciphertext.\n  - `cpa_dec(cpa_sk, cpa_ciphertext)`: Decrypts the ciphertext using the secret key and returns the original message.\n\n- **KEM Functions:**\n  - `KEMEncaps(cpa_ciphertext, kemsec)`: Encapsulates a key within a ciphertext.\n  - `cca_encaps(hk, hk2, hk3, pk, k)`: Main encapsulation function that uses hash keys and generates the ciphertext.\n  - `cca_decap(hk, hk2, hk3, c, sk)`: Decapsulation function that retrieves the key from the ciphertext and secret key.\n\n**5. Security Query:**\n- The protocol includes a security query to verify the secrecy of the derived keys.\n\n**6. Process:**\n- The protocol starts by generating random hash keys and a secret bit. \n- A key pair is generated using the `cca_gen` function.\n- The encapsulation process is executed to produce a ciphertext based on the public key and the encapsulation seed.\n- Finally, the protocol checks if the decapsulation of the ciphertext correctly retrieves the key or checks for validity against the expected values.\n\n**7. Conclusion:**\nThe protocol ensures that the encapsulated keys, when processed through the provided functions and under the defined security conditions, maintain confidentiality and integrity.\n\n---",
        "code": "proof {\nsimplify coll_elim(variables:z_1);\ninsert before \"if secb\" \"if pk_6 = pk' then\";\ninsert before_nth 1 \"if secb\" \"if ct_3 = c_1 then\";\n\nall_simplify;\nall_simplify;\nsuccess\n}\n\n\n(* Types for abstract CPA KEM *)\n\n \ntype cpa_pk [bounded].\ntype cpa_sk [bounded].\ntype cpa_ciphertext [bounded].\ntype cpa_key_seed [large,fixed].\ntype cpa_enc_seed [large,fixed].\n\n\n\n\n(* Types for final CCA  KEM *)\n\ntype kemskey [bounded].\n\ntype ciphertext.\ntype kem_seed [large,fixed].\ntype kem_enc_seed [large,fixed].\n\n\ntype kemsec [large,fixed].\n\ntype kem_keypair.\nfun KEM_KeyPair(cpa_pk, kemskey) : kem_keypair [data].\n\n\n\n(* Hash functions *)\n\ntype hashes [bounded]. (* H output *)\n\ntype B [large,fixed].\ntype hashkey [large,fixed]. \nproba qH2.\nexpand CollisionResistant_hash_2(hashkey, B,hashes, kemsec, KDF, hashoracleKDF, qH2).\n\ntype hashkey2 [large,fixed].\n\nproba qH3.\nexpand CollisionResistant_hash_1(hashkey2, B, hashes, H, hashoracleH, qH3).\n\nfun cpa_pk_to_B(cpa_pk) :B [data].\n\nfun cpa_ct_to_B(cpa_ciphertext) :B [data].\n\nletfun H1(hk2:hashkey2,pk: cpa_pk) =\n       H(hk2, cpa_pk_to_B(pk)).\n\nletfun H2(hk2:hashkey2,b: B) =\n       H(hk2, b).\n\nletfun H3(hk2:hashkey2,ct:cpa_ciphertext) =\n       H(hk2, cpa_ct_to_B(ct) ).\n\n\nproba qH4.\ntype hashkey3 [large,fixed].\nexpand CollisionResistant_hash_2(hashkey3, hashes, hashes, B, G1, hashoracleG1, qH4).\n\n\n\nfun G2(hashes,hashes) : cpa_enc_seed.\n\n\n\n\n\nfun cpa_pkgen(cpa_key_seed):cpa_pk.\nfun cpa_skgen(cpa_key_seed):cpa_sk.\n\nfun cpa_enc(cpa_pk,hashes, cpa_enc_seed) : cpa_ciphertext.\nfun cpa_dec(cpa_sk,cpa_ciphertext) : hashes.\n\n\n\n\nequation forall m:hashes, s:cpa_key_seed, r:cpa_enc_seed;\n\t cpa_dec( cpa_skgen(s), cpa_enc( cpa_pkgen(s), m, r)) =m.\n\n\n(* type kempkey [bounded]. *) (* this is already cpa_pk *)\n\n\nfun kem_to_cpa_seed(kem_seed) : cpa_key_seed.\n\n\n\n\n\nfun concat4(cpa_sk,cpa_pk,hashes,B) : kemskey [data].\n\nletfun cca_gen(hk2: hashkey2, k : kem_seed)  =\n       z <-R B;\n       cpas <-  kem_to_cpa_seed(k);\n       pk <- cpa_pkgen(cpas);\n       sk' <- cpa_skgen(cpas);\n       sk <- concat4(sk',pk,H1(hk2,pk),z);\n       KEM_KeyPair(pk, sk).\n     \n\n\n\n\ntype encapspair.\nfun KEMEncaps(cpa_ciphertext,kemsec) : encapspair [data].\n\n\nfun kseedToB(kem_enc_seed) : B.\nletfun cca_encaps(hk:hashkey, hk2: hashkey2, hk3: hashkey3, pk : cpa_pk, k : kem_enc_seed) =\n       m' <- kseedToB(k);\n       m <- H2(hk2,m');\n       Kt <- G1(hk3,m,H1(hk2,pk));\n       r <- G2(m,H1(hk2,pk));\n       c <- cpa_enc(pk,m,r);\n       KEMEncaps(c,KDF(hk,Kt, H3(hk2,c))).\n\n\nconst nullsec : kemsec.\n\nletfun cca_decap(hk:hashkey, hk2: hashkey2, hk3: hashkey3, c : cpa_ciphertext, sk : kemskey) =\n       let concat4(sk',pk,h,z) = sk in\n       m' <- cpa_dec(sk',c);\n       Kt' <- G1(hk3, m',H1(hk2,pk));\n       r' <- G2(m',H1(hk2, pk));\n       c' <- cpa_enc(pk,m',r');\n       (if c = c' then\n              KDF(hk,Kt', H3(hk2,c'))\n\t      else\n\t     KDF(hk,z, H3(hk2,c)))\n\t else\n\t  nullsec (*cannot occur *)\n.       \n\n\n(* We prove the equivalent of \n\nfun decap(ciphertext, kemskey): kemsec.\n\nfun kem_secret(kempkey, kem_enc_seed) : kemsec.\nfun kem_encap(kempkey, kem_enc_seed): ciphertext.\n\ncollision r <-R kem_seed; k <-R kem_enc_seed;  forall ct: ciphertext, pk:kempkey;\n\t  return(decap(ct,kemskgen(r))= kem_secret(pk,k))\n\t  <=(KEMcollNew)=> return(ct=kem_encap(pk,k) && pk = kempkgen(r)).\n*)\n\n\nquery secret secb [cv_bit].\n\nset autoMergeBranches = true.\nset autoSARename = true.\n\nprocess\n    Start() :=\n    \t    hk <-R hashkey;\n    \t    hk2 <-R hashkey2;\n    \t    hk3 <-R hashkey3;\t    \n    \t    secb <-R bool;\n    \t    r <-R kem_seed;\n\t    k <-R kem_enc_seed;\n\t    let  KEM_KeyPair(pk, sk) = cca_gen(hk2,r) in\n\t    return(r,k);\n\n\t    run hashoracleKDF(hk) |\n\t    run hashoracleH(hk2) |\n\t    run hashoracleG1(hk3) |\t  \t    \n\t    OChall(ct: cpa_ciphertext, pk':cpa_pk) :=\n    \t    let KEMEncaps(c,K) = cca_encaps(hk,hk2,hk3,pk',k) in\n\t    (\n\t    \t   if secb then \n\t\t      \t    return(cca_decap(hk,hk2,hk3,ct, sk) = K)\n\t\t    else\n\t\t\treturn( (ct = c) && (pk' = pk))\n\t\t\t\t    )",
        "codenote": "proof {\nsimplify coll_elim(variables:z_1);\ninsert before \"if secb\" \"if pk_6 = pk' then\";\ninsert before_nth 1 \"if secb\" \"if ct_3 = c_1 then\";\n\nall_simplify;\nall_simplify;\nsuccess\n}\n\n\n(* Types for abstract CPA KEM *)\n(* cpa_pk: public key for CPA KEM *)\ntype cpa_pk [bounded].\n(* cpa_sk: secret key for CPA KEM *)\ntype cpa_sk [bounded].\n(* cpa_ciphertext: ciphertext produced by CPA KEM *)\ntype cpa_ciphertext [bounded].\n(* cpa_key_seed: seed for generating CPA key pair *)\ntype cpa_key_seed [large,fixed].\n(* cpa_enc_seed: seed for encryption in CPA KEM *)\ntype cpa_enc_seed [large,fixed].\n\n(* Types for final CCA KEM *)\n(* kemskey: encapsulated secret key for KEM *)\ntype kemskey [bounded].\n(* ciphertext: generic type for ciphertexts *)\ntype ciphertext.\n(* kem_seed: seed used in KEM generation *)\ntype kem_seed [large,fixed].\n(* kem_enc_seed: seed used for encapsulation in KEM *)\ntype kem_enc_seed [large,fixed].\n(* kemsec: secret information in the KEM *)\ntype kemsec [large,fixed].\n(* kem_keypair: keypair structure consisting of public and secret keys *)\ntype kem_keypair.\n(* Function to derive a KEM keypair from a public key and a secret key *)\nfun KEM_KeyPair(cpa_pk, kemskey) : kem_keypair [data].\n\n(* Hash functions *)\n(* hashes: bounded type for hash outputs *)\ntype hashes [bounded]. (* H output *)\n\n(* B: type for generic data size *)\ntype B [large,fixed].\n(* Hashkey: type for hash keys *)\ntype hashkey [large,fixed]. \n(* Probability for second hash oracle access *)\nproba qH2.\n(* Expand the collision-resistant hash function *)\nexpand CollisionResistant_hash_2(hashkey, B,hashes, kemsec, KDF, hashoracleKDF, qH2).\n\n(* Second hashkey *)\ntype hashkey2 [large,fixed].\n(* Probability for third hash oracle access *)\nproba qH3.\n(* Expand the collision-resistant first hash function *)\nexpand CollisionResistant_hash_1(hashkey2, B, hashes, H, hashoracleH, qH3).\n\n(* Function to map CPA public key to some data format B *)\nfun cpa_pk_to_B(cpa_pk) :B [data].\n(* Function to map CPA ciphertext to some data format B *)\nfun cpa_ct_to_B(cpa_ciphertext) :B [data].\n\n(* Hash computations for the KEM protocol *)\nletfun H1(hk2:hashkey2,pk: cpa_pk) =\n       H(hk2, cpa_pk_to_B(pk)).\nletfun H2(hk2:hashkey2,b: B) =\n       H(hk2, b).\nletfun H3(hk2:hashkey2,ct:cpa_ciphertext) =\n       H(hk2, cpa_ct_to_B(ct)).\n\n(* Additional hash function and its usage *)\nproba qH4.\ntype hashkey3 [large,fixed].\nexpand CollisionResistant_hash_2(hashkey3, hashes, hashes, B, G1, hashoracleG1, qH4).\n\n(* Function to generate encryption seed from hashes *)\nfun G2(hashes,hashes) : cpa_enc_seed.\n(* Function to generate CPA public key from seed *)\nfun cpa_pkgen(cpa_key_seed):cpa_pk.\n(* Function to generate CPA secret key from seed *)\nfun cpa_skgen(cpa_key_seed):cpa_sk.\n(* Function for encrypting with CPA public key *)\nfun cpa_enc(cpa_pk,hashes, cpa_enc_seed) : cpa_ciphertext.\n(* Function for decrypting CPA ciphertext *)\nfun cpa_dec(cpa_sk,cpa_ciphertext) : hashes.\n\n(* Equation demonstrating CPA security: encryption and decryption *)\nequation forall m:hashes, s:cpa_key_seed, r:cpa_enc_seed;\n\t cpa_dec( cpa_skgen(s), cpa_enc( cpa_pkgen(s), m, r)) =m.\n\n(* Function to convert KEM seed to CPA seed *)\nfun kem_to_cpa_seed(kem_seed) : cpa_key_seed.\n\n(* Function to concatenate components into the encapsulated secret key *)\nfun concat4(cpa_sk,cpa_pk,hashes,B) : kemskey [data].\n\nletfun cca_gen(hk2: hashkey2, k : kem_seed)  =\n       z <-R B;\n       cpas <-  kem_to_cpa_seed(k);\n       pk <- cpa_pkgen(cpas);\n       sk' <- cpa_skgen(cpas);\n       sk <- concat4(sk',pk,H1(hk2,pk),z);\n       KEM_KeyPair(pk, sk).\n\n(* Type for encapsulated secret key pair *)\ntype encapspair.\n(* Function for encapsulation process in KEM *)\nfun KEMEncaps(cpa_ciphertext,kemsec) : encapspair [data].\n\n(* Converting KEM encapsulation seed to B format *)\nfun kseedToB(kem_enc_seed) : B.\nletfun cca_encaps(hk:hashkey, hk2: hashkey2, hk3: hashkey3, pk : cpa_pk, k : kem_enc_seed) =\n       m' <- kseedToB(k);\n       m <- H2(hk2,m');\n       Kt <- G1(hk3,m,H1(hk2,pk));\n       r <- G2(m,H1(hk2,pk));\n       c <- cpa_enc(pk,m,r);\n       KEMEncaps(c,KDF(hk,Kt, H3(hk2,c))).\n\n(* Null secret constant for cases where decryption cannot succeed *)\nconst nullsec : kemsec.\n\nletfun cca_decap(hk:hashkey, hk2: hashkey2, hk3: hashkey3, c : cpa_ciphertext, sk : kemskey) =\n       let concat4(sk',pk,h,z) = sk in\n       m' <- cpa_dec(sk',c);\n       Kt' <- G1(hk3, m',H1(hk2,pk));\n       r' <- G2(m',H1(hk2, pk));\n       c' <- cpa_enc(pk,m',r');\n       (if c = c' then\n              KDF(hk,Kt', H3(hk2,c'))\n\t      else\n\t     KDF(hk,z, H3(hk2,c))) (* Handle decryption outcome *)\n\t else\n\t  nullsec (* Case where decryption cannot occur *)\n.       \n\n(* We prove the equivalent of \nfun decap(ciphertext, kemskey): kemsec.\nfun kem_secret(kempkey, kem_enc_seed) : kemsec.\nfun kem_encap(kempkey, kem_enc_seed): ciphertext.\n\ncollision r <-R kem_seed; k <-R kem_enc_seed;  forall ct: ciphertext, pk:kempkey;\n\t  return(decap(ct,kemskgen(r))= kem_secret(pk,k))\n\t  <=(KEMcollNew)=> return(ct=kem_encap(pk,k) && pk = kempkgen(r)).\n*)\n\n(* Querying the secret security bit *)\nquery secret secb [cv_bit].\n\n(* Configuration for automated proof adjustments *)\nset autoMergeBranches = true.\nset autoSARename = true.\n\nprocess\n    Start() :=\n    \t    hk <-R hashkey;                (* Randomly generate hash key *)\n    \t    hk2 <-R hashkey2;              (* Randomly generate second hash key *)\n    \t    hk3 <-R hashkey3;              (* Randomly generate third hash key *)\n    \t    secb <-R bool;                 (* Randomly determine secret bit *)\n    \t    r <-R kem_seed;                (* Randomly generate KEM seed *)\n\t    k <-R kem_enc_seed;             (* Randomly generate KEM encapsulation seed *)\n\t    let  KEM_KeyPair(pk, sk) = cca_gen(hk2,r) in\n\t    return(r,k);                   (* Return the generated seeds *)\n\n\t    run hashoracleKDF(hk) |        (* Run KDF hash oracle *)\n\t    run hashoracleH(hk2) |         (* Run H hash oracle *)\n\t    run hashoracleG1(hk3) |        (* Run G1 hash oracle *)\n\t    OChall(ct: cpa_ciphertext, pk':cpa_pk) :=\n    \t    let KEMEncaps(c,K) = cca_encaps(hk,hk2,hk3,pk',k) in\n\t    (\n\t    \t   if secb then \n\t\t      \t    return(cca_decap(hk,hk2,hk3,ct, sk) = K)  (* Conditional return for secure bit *)\n\t\t    else\n\t\t\treturn( (ct = c) && (pk' = pk))       (* Otherwise return consistency *)\n\t\t\t\t    )"
    },
    {
        "file": "CV-1/OAEP-CPA.cv",
        "logic": "To generate a description content for the given OAEP (Optimal Asymmetric Encryption Padding) scheme and its proof of CPA (Chosen Plaintext Attack) security, we can break down the components and explain the protocol's construction, its security assumptions, and its operational procedures. Below is a description that can be aligned with the provided CV file for CryptoVerif:\n\n---\n\n### Description of OAEP Scheme and CPA Security Proof\n\n**Overview:**\nThe OAEP scheme is a cryptographic protocol designed to securely encrypt messages using a public key. The scheme utilizes a one-way trapdoor permutation, alongside random oracles for hash functions, to ensure that the encryption process is both secure against chosen plaintext attacks and resistant to various cryptographic attacks.\n\n**Key Components:**\n1. **Key Generation:**\n   - The protocol involves two key generation procedures: `pkgen` for generating a public key (`pkey`) and `skgen` for producing a secret key (`skey`). These keys are generated from a random seed (`seed`).\n\n2. **One-Way Trapdoor Permutation:**\n   - An essential aspect of the OAEP scheme is the use of a partial-domain one-way trapdoor permutation. This allows the encryption to be secure while enabling decryption with the secret key.\n\n3. **Hash Functions:**\n   - The protocol employs two cryptographic hash functions, `H` and `G`, modeled as random oracles. These hash functions are used to derive additional randomness and ensure unpredictability in the encryption process.\n\n4. **XOR Operations:**\n   - The use of XOR operations (`xorDr` and `xorDow`) is implemented to combine different elements of the encryption process, enhancing security by obscuring the underlying data.\n\n5. **Message Processing:**\n   - The main processing routine reads two messages (`m1` and `m2`) and determines which to encrypt based on a boolean (`b1`). A random value (`r`) is generated, and the messages are combined with the output of the hash functions and the trapdoor permutation to create the final ciphertext.\n\n**Security Proof:**\nThe security proof is structured as follows:\n- The proof utilizes a series of games to demonstrate that an adversary cannot distinguish between the real encryption scheme and a random one.\n- Events such as `bad1` and `bad2` are inserted to denote potential failure conditions for the adversary, and the proof ensures that these conditions are unlikely to occur.\n- The proof concludes with a success statement, indicating that the adversary's advantage is negligible, confirming the CPA security of the OAEP scheme.\n\n**Query Handling:**\nThe protocol supports queries that allow for interaction with the encryption process, enabling an adversary to challenge the security of the scheme, which is critical for establishing its robustness against chosen plaintext attacks.\n\n---\n\n### Note for CryptoVerif\n\nWhen implementing this description into a `.cv` file, ensure that all the cryptographic primitives, parameters, and types are accurately represented as in the provided code. The logical structure, events, and functions should maintain their integrity to facilitate the correct execution of the security proof within the CryptoVerif tool.\n\nThis description should serve as a comprehensive overview of the OAEP scheme and its CPA security proof, allowing for the generation of a corresponding CV file that adheres to the specified protocol.",
        "code": "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);\n      crypto rom(G);\n      show_game occ;\n      insert_event bad1 31;\n      show_game occ;\n      insert_event bad2 59;\n      crypto remove_xor(xorDr) \"@10_r_129\";\n      crypto remove_xor(xorDow) \"@9_r_137\";      \n      remove_assign binder pk;\n      crypto pd_ow(f) \"r_107\" \"@9_r_146\" \"@10_r_144\";\n      success\n}\n\nparam qS.\n\ntype pkey [bounded].\ntype skey [bounded].\ntype seed [large,fixed].\ntype D [fixed,large].\ntype Dow [fixed,large].\ntype Dr [fixed,large].\n\n(* Set partial-domain one-way trapdoor permutation *)\n\nproba P_PD_OW.\n\nexpand set_PD_OW_trapdoor_perm(seed, pkey, skey, D, Dow, Dr, pkgen, skgen, f, invf, concat, P_PD_OW).\n\n(* Hash functions, random oracle model *)\n\ntype hashkey [fixed].\n\nexpand ROM_hash(hashkey, Dr, Dow, G).\nparam qG [noninteractive].\nchannel ch1, ch2.\nlet hashoracleG = !qG in(ch1, x:Dr); out(ch2, G(hkg,x)).\n\nexpand ROM_hash(hashkey, Dow, Dr, H).\nparam qH [noninteractive].\nchannel ch3, ch4.\nlet hashoracleH = !qH in(ch3, x:Dow); out(ch4, H(hkh,x)).\n\n(* concatenation *)\ntype Dm.\ntype Dz [large].\n\nfun concatm(Dm,Dz):Dow [compos].\nconst zero: Dz.\n\n(* Xor *)\n\nexpand Xor(Dow, xorDow, zeroDow).\nexpand Xor(Dr, xorDr, zeroDr).\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\n\nfun test(bool, Dm, Dm):Dm.\nforall x:Dm,y:Dm; test(true,x,y) = x.\nforall x:Dm,y:Dm; test(false,x,y) = y.\n\n(* Queries *)\n\nquery secret1 b1.\n\nchannel c0, c1, c2.\n\nlet processT = \n\tin(c1, (m1: Dm, m2: Dm));\n\tnew b1: bool;\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(b1, m1, m2) in\n\tnew r: Dr;\n\tlet s = xorDow(concatm(menc, zero), G(hkg,r)) in\n\tlet t = xorDr(r, H(hkh,s)) in\n\tout(c2, f(pk, concat(s,t))).\n\nprocess \n\tin(c0, ());\n\tnew hkh: hashkey;\n\tnew hkg: hashkey;\n\tnew r: seed; \n\tlet pk = pkgen(r) in\n\tlet sk = skgen(r) in\n\tout(c0, pk);\n\t(hashoracleG | hashoracleH | processT)\n\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)",
        "codenote": "(* OAEP scheme, proof of CPA security *)\n\nproof {\n      crypto rom(H);  (* Random oracle for hash function H *)\n      crypto rom(G);  (* Random oracle for hash function G *)\n      show_game occ;\n      insert_event bad1 31;  (* Insertion of bad event 1 for security proof *)\n      show_game occ;\n      insert_event bad2 59;  (* Insertion of bad event 2 for security proof *)\n      crypto remove_xor(xorDr) \"@10_r_129\";  (* Removing XOR with Dr involving key *)\n      crypto remove_xor(xorDow) \"@9_r_137\";  (* Removing XOR with Dow involving key *)\n      remove_assign binder pk;  (* Assigning public key *)\n      crypto pd_ow(f) \"r_107\" \"@9_r_146\" \"@10_r_144\";  (* Private proof of one-wayness for f *)\n      success  (* Successfully completed proof *)\n}\n\nparam qS.  (* Maximum number of signing queries allowed *)\n\ntype pkey [bounded].  (* Type for public keys with specific bounds *)\ntype skey [bounded].  (* Type for secret keys with specific bounds *)\ntype seed [large,fixed].  (* Type for random seeds, fixed size but large value *)\ntype D [fixed,large].  (* Type for data input with fixed but large size *)\ntype Dow [fixed,large].  (* Type for random output from the oracle G *)\ntype Dr [fixed,large].  (* Type for random output from the oracle H *)\n\n(* Set partial-domain one-way trapdoor permutation *)\nproba P_PD_OW.  (* Probability of successful pre-image attacks limited by domain *)\n\nexpand set_PD_OW_trapdoor_perm(seed, pkey, skey, D, Dow, Dr, pkgen, skgen, f, invf, concat, P_PD_OW).  (* Definition of the trapdoor permutation *)\n\n(* Hash functions, random oracle model *)\ntype hashkey [fixed].  (* Fixed size hash key type *)\n\nexpand ROM_hash(hashkey, Dr, Dow, G).  (* Random oracle model for G *)\nparam qG [noninteractive].  (* Non-interactive queries to the oracle G *)\nchannel ch1, ch2.  (* Channels for communication between parties *)\nlet hashoracleG = !qG in(ch1, x:Dr); out(ch2, G(hkg,x)).  (* Hash oracle G handling input *)\n\nexpand ROM_hash(hashkey, Dow, Dr, H).  (* Random oracle model for H *)\nparam qH [noninteractive].  (* Non-interactive queries to the oracle H *)\nchannel ch3, ch4.  (* Channels for communication between parties *)\nlet hashoracleH = !qH in(ch3, x:Dow); out(ch4, H(hkh,x)).  (* Hash oracle H handling input *)\n\n(* concatenation *)\ntype Dm.  (* Type for message data *)\ntype Dz [large].  (* Type for additional data, large size *)\n\nfun concatm(Dm,Dz):Dow [compos].  (* Function for concatenating message and additional data *)\nconst zero: Dz.  (* Constant representing zero for type Dz *)\n\n(* Xor *)\nexpand Xor(Dow, xorDow, zeroDow).  (* Definition for XOR operation with Dow *)\nexpand Xor(Dr, xorDr, zeroDr).  (* Definition for XOR operation with Dr *)\n\n(* Implementing a test as a function.\n   Useful to avoid expanding if, which is necessary for this proof. *)\nfun test(bool, Dm, Dm):Dm.  (* Function to select between two messages based on a boolean *)\nforall x:Dm,y:Dm; test(true,x,y) = x.  (* If true, return first message *)\nforall x:Dm,y:Dm; test(false,x,y) = y.  (* If false, return second message *)\n\n(* Queries *)\nquery secret1 b1.  (* Definition of a secret query for security analysis *)\n\nchannel c0, c1, c2.  (* Channels for communication in the process *)\n\nlet processT = \n\tin(c1, (m1: Dm, m2: Dm));  (* Input two messages from channel *)\n\tnew b1: bool;  (* Variable to hold a boolean decision *)\n\t(* The next line is equivalent to an \"if\" that will not be\n\texpanded. This is necessary for the system to succeed in\n\tproving the protocol. *)\n\tlet menc = test(b1, m1, m2) in  (* Select one message based on the boolean *)\n\tnew r: Dr;  (* New random data r from Dr *)\n\tlet s = xorDow(concatm(menc, zero), G(hkg,r)) in  (* Concatenation and hashing to produce s *)\n\tlet t = xorDr(r, H(hkh,s)) in  (* Hashing and combining to produce t *)\n\tout(c2, f(pk, concat(s,t))).  (* Output results through the channel *)\n\nprocess \n\tin(c0, ());  (* Initial input from channel c0 *)\n\tnew hkh: hashkey;  (* New hash key for H *)\n\tnew hkg: hashkey;  (* New hash key for G *)\n\tnew r: seed;  (* New random seed for key generation *)\n\tlet pk = pkgen(r) in  (* Generate public key from seed *)\n\tlet sk = skgen(r) in  (* Generate secret key from seed *)\n\tout(c0, pk);  (* Send public key through channel c0 *)\n\t(hashoracleG | hashoracleH | processT)  (* Run hash oracles and the process *)\n\n(* EXPECTED\nAll queries proved.\n0.030s (user 0.030s + system 0.000s), max rss 19856K\nEND *)"
    },
    {
        "file": "CV-1/template-signedDH.ocv",
        "logic": "To create a description content for the protocol that corresponds to the provided OCV file, we need to detail the components of the protocol, their roles, and the overall logic flow in a way that allows for the regeneration of the OCV file.\n\nHere's a structured description of the protocol based on the given content:\n\n---\n\n### Protocol Description\n\n#### Overview\nThis protocol describes a secure communication mechanism between two parties, denoted as agents A and B, using a combination of the Diffie-Hellman key exchange, digital signatures, and a public key infrastructure (PKI). The protocol aims to establish a secure channel for message exchange while ensuring authenticity and integrity through the use of cryptographic signatures.\n\n#### Participants\n- **Agents**: The protocol involves `NA` instances of agent A and `NB` instances of agent B.\n- **Public Keys**: The protocol supports `NK` public keys for signing purposes.\n\n#### Cryptographic Primitives\n1. **Diffie-Hellman Key Exchange**:\n   - Utilizes a finite group `G` and a generator `g` to enable agents to derive a shared secret key through exponentiation.\n   - Assumptions include collision probabilities (`PCollKey1` and `PCollKey2`) to ensure security against certain types of attacks.\n\n2. **Hash Function**:\n   - A random oracle model is employed to define a hash function which maps inputs from group `G` to a finite key space.\n   - This hash function plays a crucial role in the signing and verification process.\n\n3. **Digital Signatures**:\n   - The protocol employs a signature scheme characterized by the security properties of unforgeability under chosen-message attacks (UF-CMA).\n   - The signature scheme involves the generation of secret keys and public keys, signing messages, and verifying signatures.\n\n#### Processes\n1. **Key Generation**:\n   - Each agent generates a signing key pair consisting of a secret key (`skey`) and a public key (`pkey`) using a key seed (`keyseed`).\n\n2. **Process A**:\n   - Runs concurrently for each instance of agent A.\n   - Engages in message signing and verification, utilizing the hash function to ensure message integrity.\n\n3. **Process B**:\n   - Similar to process A, but for agent B.\n   - Also involves signing and verification of messages.\n\n4. **Public Key Infrastructure (PKI)**:\n   - Handles the association between public keys of agents A and B.\n   - Ensures that agents can verify each other's signatures based on their public keys.\n\n5. **Execution Flow**:\n   - The protocol starts by generating a hash function and the key pairs for agents A and B.\n   - Each instance of agent A and B runs concurrently, performing their respective operations, alongside the PKI processes and the hash oracle.\n\n#### Security Assumptions\n- **Collision Resistance**: The protocol assumes certain probabilities (`PCollKey1`, `PCollKey2`) concerning the difficulty of finding collisions in the derived keys.\n- **Computational Diffie-Hellman (CDH) Assumption**: Assumes difficulty in solving the CDH problem within group `G`.\n\n#### Conclusion\nThis protocol ensures secure communication between multiple instances of agents A and B through a well-defined process utilizing Diffie-Hellman key exchange, digital signatures, and a robust public key infrastructure, while maintaining the security properties required for reliable and authenticated message exchange.\n\n---\n\n### Final Notes\n- The description provides a comprehensive overview while preserving the technical details necessary for the reconstruction of the OCV file.\n- The placeholders marked as `TODO` in the original OCV file imply that additional specifications, such as the event definitions and secrecy queries, need to be addressed in the final implementation based on the protocol's requirements.\n\nThis description can be further tailored to include specific details about the actions taken by processes A and B, the exact nature of the messages exchanged, or any additional security features relevant to the protocol's implementation.",
        "code": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers *)\ntype keyseed [large,fixed].  (* seed for signing key generation *)\ntype pkey [bounded].  (* signing public key *)\ntype skey [bounded].  (* signing secret key *)\ntype message [bounded]. (* the signed message space *)\ntype signature [bounded]. (* the output signature space *)\n\ntype G [large,bounded]. (* the finite group definition *)\ntype Z [large,bounded]. (* the field of the exponents of the group *)\ntype key [fixed]. (* the output of the hash function, also corresponding to the final keys space *)\n\n(* Basic Diffie-Hellman declarations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* This collision assumption is needed to prove an injective\n   correspondence, because we use ephemerals to distinguish sessions. *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision says that\n   - the probability that exp(g, x) = Y for random x and Y independent of x\n   is at most PCollKey1, and\n   - the probability that exp(g, mult(x,y)) = Y where x and y are independent\n   random private keys and Y is independent of x or y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator *)\n  exp,      (* exponentiation function *)\n  exp',     (* exp. func. after transformation *)\n  mult,     (* func. for exponent multiplication *)\n  PCollKey1,(*  *)\n  PCollKey2\n).\n\n(* CDH assumption *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n\n(* Hash in the random oracle model *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input *)\n  key,          (* type of output *)\n  hash,         (* name of hash function *)\n  hashoracle,   (* process defining the hash oracle *)\n  qH            (* parameter: number of calls *)\n).\n\n\n(* Signatures *)\nproba Psign.\nproba Psigncoll.\n(* expand UF_CMA_det_signature( *)\nexpand UF_CMA_proba_signature(\n  (* types, to be defined outside the macro *)\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  (* names for functions defined by the macro *)\n  skgen,\n  pkgen,\n  sign,\n  verify,\n  (* probabilities, to be defined outside the macro *)\n  Psign,     (* breaking the UF-CMA property *)\n  Psigncoll  (* collision between independently gen. keys *)\n).\n\n\n(* The two honest peers *)\nconst A,B:host.\n\n(* TODO secrecy queries *)\n\n(* TODO event definition + authentication queries *)\n\n(* TODO table definition for public key infrastructure *)\n\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO. *)\n\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO. *)\n\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO *) \n   SomeOtherOtherOracleTODO () := return.\n   \nletfun keygen() =\n  rk <-R keyseed;\n  sk <- skgen(rk);\n  pk <- pkgen(rk);\n  (sk, pk).\n\n(* final process declaration *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction;\n    let (skA: skey, pkA: pkey) = keygen() in\n    let (skB: skey, pkB: pkey) = keygen() in\n    return(pkA, pkB);\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))\n     |\n      run hashoracle(hf)\n    )",
        "codenote": "(* Declaration *)\nparam NA, NB, NK. (* number of agents A, number of agents B and number of public keys. *)\n\ntype host [bounded].  (* hostname identifiers for agents in the protocol *)\ntype keyseed [large,fixed].  (* seed for generating signing keys *)\ntype pkey [bounded].  (* signing public key used for verification *)\ntype skey [bounded].  (* signing secret key used for signing messages *)\ntype message [bounded]. (* the space of messages that can be signed *)\ntype signature [bounded]. (* the space of output signatures *)\n\ntype G [large,bounded]. (* definition of the finite group used for Diffie-Hellman *)\ntype Z [large,bounded]. (* field of the exponents of the group *)\ntype key [fixed]. (* output from the hash function representing final keys *)\n\n(* Basic Diffie-Hellman declarations for group operations *)\nexpand DH_basic(G, Z, g, exp, exp', mult).\n\n(* Collision probability assumptions for key agreement *)\nproba PCollKey1.\nproba PCollKey2.\n\n(* DH_proba_collision states the probability bounds for DH challenges:\n   - The probability that exp(g, x) = Y for random x is at most PCollKey1\n   - The probability that exp(g, mult(x,y)) = Y for independent x and y is at most PCollKey2.\n*)\nexpand DH_proba_collision(\n  G,        (* type of group elements *)\n  Z,        (* type of exponents *)\n  g,        (* group generator used in DH *)\n  exp,      (* exponentiation function for group elements *)\n  exp',     (* transformed exponentiation function *)\n  mult,     (* multiplication function for exponents *)\n  PCollKey1,(* collision probability 1 *)\n  PCollKey2  (* collision probability 2 *)\n).\n\n(* CDH assumption for security analysis *)\nproba pCDH.\nexpand CDH(G, Z, g, exp, exp', mult, pCDH).\n\n(* Hash in the random oracle model - provides security guarantees for hash functions *)\ntype hashfunction [fixed].\nexpand ROM_hash(\n  hashfunction, (* type for hash function choice *)\n  G,            (* type of input to the hash function *)\n  key,          (* type of output from the hash function *)\n  hash,         (* name of the hash function *)\n  hashoracle,   (* process defining the behavior of the hash oracle *)\n  qH            (* parameter: maximum number of hash oracle calls *)\n).\n\n(* Signatures and their security properties *)\nproba Psign.      (* probability that signature scheme is broken *)\nproba Psigncoll.  (* probability of signature collision *)\n(* The following expands the unforgeability under chosen message attack (UF-CMA) *)\nexpand UF_CMA_proba_signature(\n  keyseed,\n  pkey,\n  skey,\n  message,\n  signature,\n  skgen,  (* secret key generator function *)\n  pkgen,  (* public key generator function *)\n  sign,   (* signing function *)\n  verify,  (* verification function *)\n  Psign,     (* probability of breaking the UF-CMA property *)\n  Psigncoll  (* probability of collision between independently generated keys *)\n).\n\n(* The two honest peers participating in the protocol *)\nconst A,B:host.\n\n(* TODO secrecy queries - you will need to define what should be kept secret in this protocol *)\n\n(* TODO event definition + authentication queries - specify how events are defined for authentication verification *)\n\n(* TODO table definition for public key infrastructure - define how public keys are managed *)\n\n(* Process of agent A which will interact with the hash function *)\nlet processA(hf:hashfunction, skA:skey) =\n   SomeOracleTODO () := return.\n  (* TODO: specify the interaction protocol for agent A *)\n\n(* Process of agent B which will interact with the hash function *)\nlet processB(hf:hashfunction, skB:skey) =\n   SomeOtherOracleTODO () := return.\n  (* TODO: specify the interaction protocol for agent B *)\n\n(* Public key infrastructure to manage public keys of A and B *)\nlet pki(pkA:pkey, pkB:pkey) =\n  (* TODO: implement behavior for managing the public key infrastructure *) \n   SomeOtherOtherOracleTODO () := return.\n   \n(* Key generation function - generates secret and public keys for an agent *)\nletfun keygen() =\n  rk <-R keyseed;      (* Generating a random keyseed *)\n  sk <- skgen(rk);     (* Generating a secret key from the seed *)\n  pk <- pkgen(rk);     (* Generating a public key from the seed *)\n  (sk, pk).            (* Returning the pair of secret and public keys *)\n\n(* Final process declaration for initiating the protocol execution *)\nprocess\n  Ostart() :=\n    hf <-R hashfunction; (* Randomly selecting a hash function for this run *)\n    let (skA: skey, pkA: pkey) = keygen() in  (* Generate keys for agent A *)\n    let (skB: skey, pkB: pkey) = keygen() in  (* Generate keys for agent B *)\n    return(pkA, pkB);   (* Return public keys of A and B *)\n\n    (\n     (foreach iA <= NA do\n      run processA(hf, skA))  (* Running processA for all agents A *)\n     |\n     (foreach iB <= NB do\n      run processB(hf, skB))  (* Running processB for all agents B *)\n     |\n     (foreach iK <= NK do\n      run pki(pkA, pkB))      (* Running public key infrastructure for all keys *)\n     |\n      run hashoracle(hf)      (* Interacting with the hash oracle *)\n    )"
    },
    {
        "file": "CV-1/tls13-core-RecordProtocol-0RTT.cv",
        "logic": "---\n\n### Protocol Description\n\n#### Protocol Name: Record Protocol\n\nThis protocol is designed to facilitate secure communication between a client and a server by ensuring confidentiality and authenticity of the messages exchanged. The security of the protocol relies on the use of cryptographic primitives and a shared secret, referred to as the \"traffic secret,\" which is established at the beginning of the communication.\n\n#### Components:\n\n1. **Key Types**:\n    - `key`: Represents cryptographic keys used for encryption and authentication.\n    - `seqn`: Represents sequence numbers to ensure message ordering and prevent replay attacks.\n    - `nonce_t`: Represents nonces used in the encryption process.\n    - `nocolltype`: A type used to ensure uniqueness in session identifiers.\n\n2. **Parameters**:\n    - `N`, `Nk`, `Ne`, `Nd`, `Ns`, `NSr`, `Nr`: These parameters control various aspects of the protocol, such as the number of messages exchanged and the characteristics of the cryptographic operations.\n\n3. **Functions**:\n    - `HKDF_expand_upd_label`, `HKDF_expand_key_label`, `HKDF_expand_iv_label`: Functions for deriving keys and initialization vectors from the traffic secret using HKDF (HMAC-based Key Derivation Function).\n\n4. **Probabilities**:\n    - `Pprf_upd_key_iv`, `Penc`, `Pencctxt`: Probabilities associated with the security properties of the key derivation and encryption processes.\n\n5. **Cryptographic Operations**:\n    - The protocol utilizes authenticated encryption with associated data (AEAD), ensuring the confidentiality and integrity of the messages. The encryption function `AEAD_encrypt` and decryption function `AEAD_decrypt` are defined to operate with a nonce and a key.\n\n6. **Tables**:\n    - `table_count_send`: Records sequence numbers that have been sent to prevent reuse.\n    - `table_count_recv`: Records sequence numbers that have been received to avoid replay attacks.\n\n#### Security Properties\n\n1. **Secrecy of Plaintexts**:\n   - The protocol ensures that the plaintext messages remain secret, even to potential attackers.\n\n2. **Message Authenticity**:\n   - The protocol guarantees that a message received is the same as the one sent, linking the `sent` and `received` events through the sequence number and message content.\n\n3. **Secrecy of Updated Key**:\n   - The traffic secret, which is updated during the protocol execution, is kept secret from any external observer.\n\n#### Execution Flow\n\n1. The protocol initiates with the client and server sharing a random traffic secret.\n2. The traffic secret is expanded into keys for encryption and initialization vectors.\n3. The sender uses the `send` function to transmit messages, ensuring that the sequence number is unique and that the messages are encrypted.\n4. The receiver uses the `receive` function to accept messages, verifying that sequence numbers are not reused and decrypting the messages upon receipt.\n5. Throughout the execution, the protocol maintains the integrity and confidentiality of the messages exchanged.\n\n---",
        "code": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                  Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves properties of the record protocol,\nassuming the client and server initially share a random\ntraffic secret. *)\n\n\ntype key [fixed, large].\ntype seqn [fixed].\ntype nonce_t [fixed, large].\ntype nocolltype [fixed, large].\n\nparam N, Nk, Ne, Nd, Ns, NSr, Nr.\n\n(* We use the lemma proved in HKDFexpand.cv *)\n\nfun HKDF_expand_upd_label(key): key.\nfun HKDF_expand_key_label(key): key.\nfun HKDF_expand_iv_label(key): key.\n\nproba Pprf_upd_key_iv.\n\nequiv(prf_upd_key_iv)\n      !N new r: key; (O1() := return(HKDF_expand_upd_label(r)) |\n      \t      \t      O2() := return(HKDF_expand_key_label(r)) |\n\t\t      O3() := return(HKDF_expand_iv_label(r)))\n    <=(N * Pprf_upd_key_iv(time + (N-1)*(time(HKDF_expand_upd_label) + time(HKDF_expand_key_label) + time(HKDF_expand_iv_label))))=>\n      !N (O1() := new r1: key; return(r1) |\n      \t  O2() := new r2: key; return(r2) |\n\t  O3() := new r3: key; return(r3)).\n\n(* Injectivity of xor *)\n\nfun xor(key, seqn): nonce_t.\n\nequation forall k: key, n: seqn, n': seqn;\n       (xor(k, n) = xor(k,n')) = (n = n').\n\n(* AEAD, with empty additional data *)\n\ntype add_data.\nconst nil: add_data.\n\nproba Penc.\nproba Pencctxt.\n\n(* encryption is IND-CPA and INT-CTXT provided the nonce is distinct\n   for each encryption *)\nexpand AEAD_nonce(key, bitstring, bitstring, add_data, nonce_t, enc, dec, injbot, Z, Penc, Pencctxt).\n\nletfun AEAD_encrypt(k: key, n: nonce_t, m: bitstring) =\n   enc(m, nil, k, n).\nletfun AEAD_decrypt(k: key, n: nonce_t, c: bitstring) =\n   dec(c, nil, k, n).\n\n(* Tables used to record previously used sequence numbers,\n   to avoid reusing them *)\n\ntable table_count_send(seqn).\ntable table_count_recv(nocolltype, seqn).\n\n(* Secrecy of plaintexts *)\n\nquery secret b0 public_vars traffic_secret_Nplus1 [cv_bit].\n\n(* Message authenticity *)\n\nevent sent(seqn, bitstring).\nevent received(seqn, bitstring).\n\nquery count: seqn, msg: bitstring;\n      event(received(count, msg)) ==> event(sent(count, msg))\n      public_vars b0, traffic_secret_Nplus1.\n(* The injective variant does not hold: messages\n   can be replayed in a different session *)\n\n(* Secrecy of updated key *)\n\nquery secret traffic_secret_Nplus1 public_vars b0.\n\nchannel io1, io2, io3, io4, io5, io6, io7, io8.\n\nlet send(k: key, iv: key, b: bool) =\n    !Ns\n    in(io5, (clear1: bitstring, clear2: bitstring, count: seqn));\n    (* Make sure that count has not been used before *)\n    get table_count_send(=count) in yield else\n    insert table_count_send(count);\n    (* The two candidate plaintexts must have the same (padded) length *)\n    if Z(clear1) = Z(clear2) then\n    let clear = if_fun(b, clear1, clear2) in\n    event sent(count, clear);\n    let nonce = xor(iv, count) in\n    let cipher = AEAD_encrypt(k, nonce, clear) in\n    out(io6, cipher).\n\nlet receive(k: key, iv: key) =\n    !isr <= NSr\n    in(io3, ());\n    new sessionid: nocolltype; (* used to make sure that for different sessions\n    \t\t   \t       \t  of the receiver (that is, for different values of isr)\n\t\t\t\t  a different table is used *)\n    out(io4, ());\n    !Nr\n    in(io7, (cipher: bitstring, count: seqn));\n    (* Make sure that count has not been used before in this session *)\n    get table_count_recv(=sessionid, =count) in yield else\n    insert table_count_recv(sessionid, count);\n    let nonce = xor(iv, count) in\n    let injbot(clear) = AEAD_decrypt(k, nonce, cipher) in\n    event received(count, clear).    \n    \n\nprocess\n\tin(io1, ());\n\tnew b0: bool;\n\tnew traffic_secret_N: key;\n\tlet traffic_secret_Nplus1: key = HKDF_expand_upd_label(traffic_secret_N) in\n\tlet k = HKDF_expand_key_label(traffic_secret_N) in\n\tlet iv = HKDF_expand_iv_label(traffic_secret_N) in\n\tout(io2, ());\n\t(send(k, iv, b0) | receive(k, iv))\n\n(* EXPECTED\nAll queries proved.\n0.079s (user 0.067s + system 0.012s), max rss 20904K\nEND *)",
        "codenote": "(******************************************************************\n *                                                                *\n * Cryptographic protocol verifier                                *\n *                                                                *\n * Bruno Blanchet, David Cad\u00e9, Aymeric Fromherz, Charlie Jacomme, *\n * and Benjamin Lipp                                              *\n *                                                                *\n * Copyright (C) ENS, CNRS, INRIA, MPI-SP, 2005-2024              *\n *                                                                *\n ******************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA, MPI-SP\n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n                  Aymeric Fromherz, Aymeric.Fromherz@inria.fr\n                  Charlie Jacomme, Charlie.Jacomme@inria.fr\n                 Benjamin Lipp, benjamin.lipp@mpi-sp.org\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(* This file proves properties of the record protocol,\nassuming the client and server initially share a random\ntraffic secret. *)\n\n\ntype key [fixed, large]. (* key type for cryptographic keys *)\ntype seqn [fixed]. (* type for sequence numbers used in the protocol *)\ntype nonce_t [fixed, large]. (* type for nonces used in encryption *)\ntype nocolltype [fixed, large]. (* type for non-colliding identifiers *)\n\nparam N, Nk, Ne, Nd, Ns, NSr, Nr. (* Parameters for the protocol *)\n\n(* We use the lemma proved in HKDFexpand.cv *)\nfun HKDF_expand_upd_label(key): key. (* Function to expand secrets for updating *)\nfun HKDF_expand_key_label(key): key. (* Key expansion function for encryption *)\nfun HKDF_expand_iv_label(key): key. (* IV expansion function for encryption *)\n\nproba Pprf_upd_key_iv. (* Probability of Pseudo-Random Function for key/IV updates *)\n\nequiv(prf_upd_key_iv)\n      !N new r: key; (O1() := return(HKDF_expand_upd_label(r)) |\n                      O2() := return(HKDF_expand_key_label(r)) |\n                      O3() := return(HKDF_expand_iv_label(r)))\n    <=(N * Pprf_upd_key_iv(time + (N-1)*(time(HKDF_expand_upd_label) + time(HKDF_expand_key_label) + time(HKDF_expand_iv_label))))=>\n      !N (O1() := new r1: key; return(r1) |\n          O2() := new r2: key; return(r2) |\n          O3() := new r3: key; return(r3)).\n\n(* Injectivity of xor - ensures unique sequence numbers for distinct keys *)\n\nfun xor(key, seqn): nonce_t. (* XOR function for nonce generation *)\n\nequation forall k: key, n: seqn, n': seqn; \n       (xor(k, n) = xor(k,n')) = (n = n').\n\n(* AEAD encryption with empty additional data *)\n\ntype add_data. (* Type for additional data in AEAD *)\nconst nil: add_data. (* No additional data for encryption *)\n\nproba Penc. (* Probability of encryption *)\nproba Pencctxt. (* Probability of encryption under context *)\n\n(* encryption is IND-CPA and INT-CTXT provided the nonce is distinct\n   for each encryption *)\nexpand AEAD_nonce(key, bitstring, bitstring, add_data, nonce_t, enc, dec, injbot, Z, Penc, Pencctxt).\n\nletfun AEAD_encrypt(k: key, n: nonce_t, m: bitstring) =\n   enc(m, nil, k, n). (* Function to perform AEAD encryption *)\nletfun AEAD_decrypt(k: key, n: nonce_t, c: bitstring) =\n   dec(c, nil, k, n). (* Function to perform AEAD decryption *)\n\n(* Tables used to record previously used sequence numbers,\n   to avoid reusing them *)\n\ntable table_count_send(seqn). (* Table to track sent sequence numbers *)\ntable table_count_recv(nocolltype, seqn). (* Table to track received sequence numbers *)\n\n(* Secrecy of plaintexts - ensures that plaintexts remain confidential *)\n\nquery secret b0 public_vars traffic_secret_Nplus1 [cv_bit].\n\n(* Message authenticity - ensures sent messages are received as sent *)\n\nevent sent(seqn, bitstring).\nevent received(seqn, bitstring).\n\nquery count: seqn, msg: bitstring;\n      event(received(count, msg)) ==> event(sent(count, msg)) \n      public_vars b0, traffic_secret_Nplus1.\n(* The injective variant does not hold: messages\n   can be replayed in a different session *)\n\n(* Secrecy of updated key - ensures that the updated traffic secret remains confidential *)\n\nquery secret traffic_secret_Nplus1 public_vars b0.\n\nchannel io1, io2, io3, io4, io5, io6, io7, io8.\n\nlet send(k: key, iv: key, b: bool) =\n    !Ns\n    in(io5, (clear1: bitstring, clear2: bitstring, count: seqn));\n    (* Ensure that count has not been used before to prevent replay attacks *)\n    get table_count_send(=count) in yield else\n    insert table_count_send(count);\n    (* The two candidate plaintexts must have the same (padded) length *)\n    if Z(clear1) = Z(clear2) then\n    let clear = if_fun(b, clear1, clear2) in\n    event sent(count, clear);\n    let nonce = xor(iv, count) in\n    let cipher = AEAD_encrypt(k, nonce, clear) in\n    out(io6, cipher).\n\nlet receive(k: key, iv: key) =\n    !isr <= NSr\n    in(io3, ());\n    new sessionid: nocolltype; (* Unique identifier for each session *)\n    out(io4, ());\n    !Nr\n    in(io7, (cipher: bitstring, count: seqn));\n    (* Ensure that count has not been used before in this session *)\n    get table_count_recv(=sessionid, =count) in yield else\n    insert table_count_recv(sessionid, count);\n    let nonce = xor(iv, count) in\n    let injbot(clear) = AEAD_decrypt(k, nonce, cipher) in\n    event received(count, clear).    \n\nprocess\n    in(io1, ());\n    new b0: bool; (* Boolean variable for the message selection *)\n    new traffic_secret_N: key; (* Initial traffic secret key *)\n    let traffic_secret_Nplus1: key = HKDF_expand_upd_label(traffic_secret_N) in\n    let k = HKDF_expand_key_label(traffic_secret_N) in\n    let iv = HKDF_expand_iv_label(traffic_secret_N) in\n    out(io2, ());\n    (send(k, iv, b0) | receive(k, iv))\n\n(* EXPECTED\nAll queries proved.\n0.079s (user 0.067s + system 0.012s), max rss 20904K\nEND *)"
    },
    {
        "file": "CV-1/woolampkcorrSimp.cv",
        "logic": "---\n\n**Description of the Protocol:**\n\nThis protocol is a public-key authentication protocol inspired by the work of Woo and Lam (1997). The goal of this protocol is to establish a secure communication channel between two hosts, A and B, using public and private keys for authentication and message integrity.\n\n**Participants:**\n- **Host A:** The initiator of the protocol that wants to prove its identity to Host B.\n- **Host B:** The responder that verifies the identity of Host A and establishes a session.\n\n**Parameters:**\n- **N:** A nonce generated by Host A to ensure freshness of the message.\n- **B:** The identifier of Host B.\n- **pkA:** Public key of Host A.\n- **skA:** Secret key of Host A.\n- **r:** A random seed used for signing.\n- **s:** A signature created by Host A.\n\n**Protocol Steps:**\n1. **Key Generation:**\n   - Host A generates a key pair (public key `pkA` and secret key `skA`) using a key generation function based on a random seed `rkA`.\n   - Host A sends its public key `pkA` to Host B.\n\n2. **Message Exchange:**\n   - Host B receives `pkA` and generates a nonce `n`.\n   - Host B sends a message containing the nonce `n` and its identifier `B` to Host A.\n   - Host A receives the message from Host B, which includes the nonce and identifier.\n\n3. **Signing the Message:**\n   - Host A concatenates its public key, the identifier of Host B, and the nonce received from Host B, then signs this concatenated message using its secret key `skA` to produce a signature `s`.\n   - Host A sends the signature back to Host B.\n\n4. **Verification:**\n   - Host B receives the signature and checks its validity using the public key `pkA`. If the signature is valid and corresponds to the public key of Host A, Host B confirms the identity of Host A.\n\n**Security Goals:**\n- Authenticity: Host B should be able to verify that the message comes from Host A.\n- Integrity: The message signed by Host A cannot be altered without detection.\n\n**Assumptions:**\n- The public and secret keys are generated securely.\n- Nonces are used to prevent replay attacks.\n\n**Conclusion:**\nThe protocol leverages digital signatures for authentication and ensures that each session remains unique through the use of nonces. This design helps to maintain the confidentiality and integrity of messages exchanged between the two hosts.\n\n---",
        "code": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(*\nRunning example for correspondences paper.\nInspired freely from Woo and Lam public-key auth protocol (1997)\n\nB -> A: N, B\nA -> B: { pkA, B, N }_skA\n\n*)\n\nparam N.\nparam N2.\nparam N3.\nparam N4.\n\ntype nonce [large,fixed].\ntype host [bounded].\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype signature [bounded].\ntype blocksize [fixed].\ntype blocksizebot [bounded].\n\nfun concat1(pkey, host, nonce):blocksize [compos].\n\n(* Signatures *)\n\nproba Psign.\nproba Psigncoll.\n\nexpand UF_CMA_signature(keyseed, pkey, skey, blocksize, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll).\n\n(* Queries *)\n\nchannel c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13.\nconst B:host.\nevent eA(pkey,host,nonce).\nevent eB(pkey,host,nonce).\n\nquery x:pkey,y:host, z:nonce;\n\tevent eB(x,y,z) ==> eA(x,y,z).\nquery x:pkey,y:host, z:nonce;\n\tevent inj:eB(x,y,z) ==> inj:eA(x,y,z).\n\nlet processA =\n\tin(c2, (xN:nonce, xB:host));\n\tevent eA(pkA, xB, xN);\n\tnew r:seed;\n\tout(c3, sign(concat1(pkA, xB, xN), skA, r)).\n\nlet processB =\n\tin(c4, xpkA:pkey);\n\tnew n:nonce;\n\tout(c5, (n, B));\n\tin(c6, s:signature);\n\tif check(concat1(xpkA, B, n), xpkA, s) then\n\t(* OK *)\n\tif xpkA = pkA then\n\tevent eB(xpkA, B, n).\n\nprocess \n\tin(c0, ());\n\tnew rkA: keyseed;\n\tlet pkA = pkgen(rkA) in\n\tlet skA = skgen(rkA) in\n\tout(c1, pkA);\n\t((! N processA) |\n\t (! N processB))",
        "codenote": "(*************************************************************\n *                                                           *\n *       Cryptographic protocol verifier                     *\n *                                                           *\n *       Bruno Blanchet and David Cad\u00e9                       *\n *                                                           *\n *       Copyright (C) ENS, CNRS, INRIA, 2005-2015           *\n *                                                           *\n *************************************************************)\n\n(*\n\n    Copyright ENS, CNRS, INRIA \n    contributors: Bruno Blanchet, Bruno.Blanchet@inria.fr\n                  David Cad\u00e9\n\nThis software is a computer program whose purpose is to verify \ncryptographic protocols in the computational model.\n\nThis software is governed by the CeCILL-B license under French law and\nabiding by the rules of distribution of free software.  You can  use, \nmodify and/ or redistribute the software under the terms of the CeCILL-B\nlicense as circulated by CEA, CNRS and INRIA at the following URL\n\"http://www.cecill.info\". \n\nAs a counterpart to the access to the source code and  rights to copy,\nmodify and redistribute granted by the license, users are provided only\nwith a limited warranty  and the software's author,  the holder of the\neconomic rights,  and the successive licensors  have only  limited\nliability. \n\nIn this respect, the user's attention is drawn to the risks associated\nwith loading,  using,  modifying and/or developing or reproducing the\nsoftware by the user in light of its specific status of free software,\nthat may mean  that it is complicated to manipulate,  and  that  also\ntherefore means  that it is reserved for developers  and  experienced\nprofessionals having in-depth computer knowledge. Users are therefore\nencouraged to load and test the software's suitability as regards their\nrequirements in conditions enabling the security of their systems and/or \ndata to be ensured and,  more generally, to use and operate it in the \nsame conditions as regards security. \n\nThe fact that you are presently reading this means that you have had\nknowledge of the CeCILL-B license and that you accept its terms.\n\n*)\n(*\nRunning example for correspondences paper.\nInspired freely from Woo and Lam public-key auth protocol (1997)\n\nB -> A: N, B\nA -> B: { pkA, B, N }_skA\n\nThis protocol involves two parties:\n- A (the initiator): Authenticates to B using a signature.\n- B (the responder): Responds to A's request using a nonce.\n\nThe protocol's security relies on the secrecy of the private key skA \nand the authenticity of the sign function.\n\n*)\n\nparam N.\nparam N2.\nparam N3.\nparam N4.\n\ntype nonce [large,fixed].\ntype host [bounded].\ntype pkey [bounded].\ntype skey [bounded].\ntype keyseed [large,fixed].\ntype seed [fixed].\ntype signature [bounded].\ntype blocksize [fixed].\ntype blocksizebot [bounded].\n\nfun concat1(pkey, host, nonce):blocksize [compos].\n\n(* Signatures *)\n\nproba Psign.  (* Probability of signing a message *)\nproba Psigncoll.  (* Probability of signature collision *)\n\nexpand UF_CMA_signature(keyseed, pkey, skey, blocksize, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll).\n\n(* Queries *)\n\nchannel c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13.\nconst B:host.  (* Constant representing the host B *)\nevent eA(pkey,host,nonce).  (* Event signifying A's action *)\nevent eB(pkey,host,nonce).  (* Event signifying B's action *)\n\nquery x:pkey,y:host, z:nonce;  (* Query over the public key, host, and nonce *)\n\tevent eB(x,y,z) ==> eA(x,y,z).  (* Expectation of event order in security *)\nquery x:pkey,y:host, z:nonce;  (* Query for injecting events *)\n\tevent inj:eB(x,y,z) ==> inj:eA(x,y,z). \n\nlet processA =\n\tin(c2, (xN:nonce, xB:host));  (* Process A listening on channel c2 for a nonce and host *)\n\tevent eA(pkA, xB, xN);  (* Event signifying A has sent the public key, host, and nonce *)\n\tnew r:seed;  (* New seed for signature generation *)\n\tout(c3, sign(concat1(pkA, xB, xN), skA, r)).  (* Output signed message on channel c3 *)\n\nlet processB =\n\tin(c4, xpkA:pkey);  (* Process B listening on channel c4 for public key from A *)\n\tnew n:nonce;  (* B generates a new nonce *)\n\tout(c5, (n, B));  (* B responds with its nonce and its identity on channel c5 *)\n\tin(c6, s:signature);  (* B listens for a signature on channel c6 *)\n\tif check(concat1(xpkA, B, n), xpkA, s) then  (* Check if signature is valid *)\n\t(* OK *)\n\tif xpkA = pkA then  (* Validate if A's public key matches *)\n\tevent eB(xpkA, B, n).  (* Event signifying B's acknowledgment *)\n\nprocess \n\tin(c0, ());  (* Initial process waiting on channel c0 *)\n\tnew rkA: keyseed;  (* A's keyseed generation *)\n\tlet pkA = pkgen(rkA) in  (* A generates its public key *)\n\tlet skA = skgen(rkA) in  (* A generates its secret key *)\n\tout(c1, pkA);  (* A sends its public key to B on channel c1 *)\n\t((! N processA) |\n\t (! N processB))  (* Run processes A and B in parallel *)"
    }
]