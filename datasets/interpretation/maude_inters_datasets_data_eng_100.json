[
    {
        "file": "MAUDE-1/Denning-Sacco.maude",
        "logic": "---\n\n### Denning Sacco Protocol Description\n\n#### Overview\nThe Denning Sacco Protocol is a cryptographic protocol designed to facilitate secure communication between two users, Alice and Bob, through a trusted server. It employs public key encryption and session keys to ensure confidentiality and authentication during message exchanges.\n\n#### Participants\n1. **Alice (A)**: A user who initiates communication.\n2. **Bob (B)**: A user who receives messages from Alice.\n3. **Server (S)**: A trusted third party that facilitates the key exchange and communication between Alice and Bob.\n\n#### Key Components\n- **Keys**: \n  - **Master Key (mkey)**: A key associated with each user and the server, used for encryption and decryption of messages.\n  - **Session Key (seskey)**: A temporary key generated for a specific session between Alice and Bob.\n- **Nonces**: Random values generated during the protocol execution to ensure freshness and prevent replay attacks.\n- **Messages**: Encrypted and concatenated messages exchanged between the participants.\n\n#### Protocol Steps\n1. **Initial Setup**: \n   - Both Alice and Bob generate their respective Master Keys with the server's help.\n   - The server can derive the Master Key for communication with either Alice or Bob.\n   \n2. **Alice Initiates Communication**:\n   - Alice sends a message to the server containing her identity (A) and Bob's identity (B).\n   - This initiates the process of establishing a session key between Alice and Bob.\n\n3. **Server Responds**:\n   - The server generates a session key for Alice and Bob and sends an encrypted message back to Alice. This message includes:\n     - The session key.\n     - A timestamp (to prevent replay attacks).\n     - An additional encrypted message for Bob.\n\n4. **Bob Receives the Message**:\n   - Bob receives the encrypted message intended for him and uses his Master Key to decrypt it, obtaining the session key and the necessary information to communicate with Alice.\n\n5. **Alice and Bob Communicate**:\n   - After establishing a session key, Alice and Bob can securely exchange messages using this session key, ensuring confidentiality and integrity.\n\n#### Security Properties\n- **Confidentiality**: Messages are encrypted using keys, ensuring that only the intended recipient can read them.\n- **Authentication**: The use of Master Keys allows both users to verify the identity of each other through the server.\n- **Freshness**: Nonces are used to prevent replay attacks by ensuring that old messages cannot be reused in the session.\n\n#### Notation in Maude-NPA\n- `mkey(A, S)`: Denotes the Master Key for Alice with the server.\n- `seskey(A, B, nonce)`: Represents the Session Key for communication between Alice and Bob, with a nonce for freshness.\n- `e(key, message)`: Represents the encryption of a message using a specified key.\n- `d(key, message)`: Represents the decryption of a message using a specified key.\n- Concatenation of messages is denoted by `_ ; _`.\n\nThis structure encompasses the essential elements and processes of the Denning Sacco Protocol, guiding the construction of the corresponding Maude file for simulation and analysis using the Maude-NPA tool.\n\n---",
        "code": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "codenote": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  --- Generates a nonce for the given name and freshness value\n  op t : Name Fresh -> Nonce [frozen] . --- Nonce del server, representing a server-generated nonce\n\n  --- User names\n  ops a b i : -> UName .  --- User name operators for Alice, Bob, and an identifier i\n\n  --- Server name\n  op s : ->  SName .  --- Operator defining the server's name\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] . --- Operator to generate a master key from two user names\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] . --- Creates a session key using two names and a nonce\n\n  --- encrypt\n  op e : Key Msg -> Msg [frozen] . --- Encryption operator\n  op d : Key Msg -> Msg  [frozen] . --- Decryption operator\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- Concatenation operator on messages\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .  --- Decrypting an encrypted message returns the original message\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  --- Encrypting a decrypted message returns the original message\n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  --- Variables for user names Alice and Bob\n  var D : Name .     --- Variable for name or identifier\n  var r r' r'' r''' r# r## : Fresh . --- Freshness variables for nonce generation\n  vars TS : Nonce .  --- Timestamp variable\n  vars M1 M2 M N : Msg .  --- Variables for messages\n  var K : Key .       --- Variable for keys\n  var SK : Sessionkey .  --- Variable for session keys\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &  --- Dolev-Yao strand initiation \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &  --- Decrypting\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &  --- Encrypting \n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &  --- Message concatenation\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &  --- Separating concatenated messages\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &  --- Another separation of concatenated messages\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &  --- Creating a master key with identifier i \n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),  --- Alice sends her encrypted message including session key and timestamp\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)),  --- Bob receives and decrypts his message\n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),  --- Server's operations including key and timestamp\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]  --- Attack state simulation with key and nonces\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm"
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "logic": "---\n\n### Nedham-Schroeder-Lowe Modified Protocol Description\n\n**Protocol Overview:**\nThe Nedham-Schroeder-Lowe Modified Protocol is a cryptographic protocol designed for secure communication between two parties, Alice (A) and Bob (B), with provisions for nonce generation to prevent replay attacks. The protocol utilizes public-key cryptography for secure message exchanges.\n\n**Participants:**\n- **Alice (A)**: Initiator of the communication.\n- **Bob (B)**: Respondent who receives the initial message from Alice.\n- **Intruder (i)**: An adversary that may attempt to intercept or manipulate the messages exchanged between Alice and Bob.\n\n**Message Structure:**\n- The messages exchanged in the protocol are encrypted using the public keys of the intended recipients:\n  - `pk(B, A ; N_A)` denotes a message encrypted with Bob's public key, containing Alice's identity and a nonce `N_A`.\n  - `pk(A, N_A ; N_B ; B)` denotes a response message encrypted with Alice's public key, containing the nonce `N_A`, a newly generated nonce `N_B`, and Bob's identity.\n  - `pk(B, N_B)` denotes the final message sent by Alice to Bob, containing the nonce `N_B`, encrypted with Bob's public key.\n\n**Nonces:**\n- **N_A**: A nonce generated by Alice.\n- **N_B**: A nonce generated by Bob in response to Alice's initial message. Nonces are crucial for ensuring that each session of communication is unique and helps prevent replay attacks.\n\n**Encryption Scheme:**\n- The protocol employs public-key encryption (denoted by `pk`) and private-key decryption (denoted by `sk`). The following algebraic properties hold:\n  - `pk(K, sk(K, M)) = M`: Decrypting a message M encrypted with a key K using the corresponding private key returns the original message.\n  - `sk(K, pk(K, M)) = M`: Encrypting a message M with a key K and then decrypting it with the same key returns the original message.\n\n**Protocol Steps:**\n1. **Initiation**:\n   - Alice generates a nonce `N_A` and sends the message `pk(B, A ; N_A)` to Bob.\n2. **Response**:\n   - Bob receives Alice's message, decrypts it using his private key, and generates a nonce `N_B`. He then sends the message `pk(A, N_A ; N_B ; B)` back to Alice.\n3. **Completion**:\n   - Alice receives Bob's message, decrypts it using her private key, and sends back the message `pk(B, N_B)` to Bob, confirming the successful exchange of nonces.\n\n**Security Goals:**\n- The protocol aims to achieve mutual authentication between Alice and Bob while ensuring confidentiality through encryption.\n- The use of nonces in the protocol helps to prevent replay attacks and ensures freshness of the messages.\n\n**Intruder Model:**\n- The protocol is designed with the assumption that an intruder may attempt to intercept and manipulate the messages. The defined strands in the protocol specification correspond to both legitimate communication and potential attack scenarios.\n\n---",
        "code": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "codenote": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)      --- Alice sends a message to Bob encrypted with Bob's public key\nB --> A: pk(A, N_A ; N_B ; B) --- Bob replies to Alice with a message encrypted with Alice's public key\nA --> B: pk(B, N_B)          --- Alice sends back a nonce to Bob encrypted with Bob's public key\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encrypted using public \nkey x, and sk(x,y) means message y encrypted using private key x. \nMoreover, encryption/decryption have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .        --- Encrypting and then decrypting yields the original message\n  sk(K,pk(K,M)) = M .        --- Decrypting and then encrypting yields the original message\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .       --- Definition of sorts used in the protocol\n  subsort Name Nonce Key < Msg .--- Defining subsort relations for messages\n  subsort Name < Key .         --- Names are also considered Keys\n  subsort Name < Public .      --- Names are also considered Public keys\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .  --- Public key encryption operator\n  op sk : Key Msg -> Msg [frozen] .  --- Private key decryption operator\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  --- Nonce generation operator, associates a Name with Fresh\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .  --- Agent message sequencing operator\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .  --- Variable representing a message\n  var Ke : Key . --- Variable representing a key\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .  --- Cancel out encryption with its corresponding decryption\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .  --- Cancel out decryption with its corresponding encryption\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .    --- Variable representing the key in communication\n  vars X Y Z : Msg . --- Message variables\n  vars r r' : Fresh .--- Fresh nonces for unique session identification\n  vars A B : Name .  --- Principals involved in the protocol\n  vars N N1 N2 : Nonce .  --- Nonce variables for the protocol\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &    --- Dolev-Yao strands for generic message process\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] & --- Protocol strands for message exchange\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ] \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]  --- Initial attack state demonstration\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    }
]