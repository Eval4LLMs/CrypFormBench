[
    {
        "file": "MAUDE-1/Denning-Sacco.maude",
        "logic": "---\n\n### Denning Sacco Protocol Description\n\n#### Overview\nThe Denning Sacco Protocol is a cryptographic protocol designed to facilitate secure communication between two users, Alice and Bob, through a trusted server. It employs public key encryption and session keys to ensure confidentiality and authentication during message exchanges.\n\n#### Participants\n1. **Alice (A)**: A user who initiates communication.\n2. **Bob (B)**: A user who receives messages from Alice.\n3. **Server (S)**: A trusted third party that facilitates the key exchange and communication between Alice and Bob.\n\n#### Key Components\n- **Keys**: \n  - **Master Key (mkey)**: A key associated with each user and the server, used for encryption and decryption of messages.\n  - **Session Key (seskey)**: A temporary key generated for a specific session between Alice and Bob.\n- **Nonces**: Random values generated during the protocol execution to ensure freshness and prevent replay attacks.\n- **Messages**: Encrypted and concatenated messages exchanged between the participants.\n\n#### Protocol Steps\n1. **Initial Setup**: \n   - Both Alice and Bob generate their respective Master Keys with the server's help.\n   - The server can derive the Master Key for communication with either Alice or Bob.\n   \n2. **Alice Initiates Communication**:\n   - Alice sends a message to the server containing her identity (A) and Bob's identity (B).\n   - This initiates the process of establishing a session key between Alice and Bob.\n\n3. **Server Responds**:\n   - The server generates a session key for Alice and Bob and sends an encrypted message back to Alice. This message includes:\n     - The session key.\n     - A timestamp (to prevent replay attacks).\n     - An additional encrypted message for Bob.\n\n4. **Bob Receives the Message**:\n   - Bob receives the encrypted message intended for him and uses his Master Key to decrypt it, obtaining the session key and the necessary information to communicate with Alice.\n\n5. **Alice and Bob Communicate**:\n   - After establishing a session key, Alice and Bob can securely exchange messages using this session key, ensuring confidentiality and integrity.\n\n#### Security Properties\n- **Confidentiality**: Messages are encrypted using keys, ensuring that only the intended recipient can read them.\n- **Authentication**: The use of Master Keys allows both users to verify the identity of each other through the server.\n- **Freshness**: Nonces are used to prevent replay attacks by ensuring that old messages cannot be reused in the session.\n\n#### Notation in Maude-NPA\n- `mkey(A, S)`: Denotes the Master Key for Alice with the server.\n- `seskey(A, B, nonce)`: Represents the Session Key for communication between Alice and Bob, with a nonce for freshness.\n- `e(key, message)`: Represents the encryption of a message using a specified key.\n- `d(key, message)`: Represents the decryption of a message using a specified key.\n- Concatenation of messages is denoted by `_ ; _`.\n\nThis structure encompasses the essential elements and processes of the Denning Sacco Protocol, guiding the construction of the corresponding Maude file for simulation and analysis using the Maude-NPA tool.\n\n---",
        "code": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op t : Name Fresh -> Nonce [frozen] . ---Nonce del server\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg  [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  \n  var D : Name .\n  var r r' r'' r''' r# r## : Fresh . --- Comerntario chorra\n  vars TS : Nonce .\n  vars M1 M2 M N : Msg .\n  var K : Key . \n  var SK : Sessionkey .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  & \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &\n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)), \n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "codenote": "----  Denning Sacco Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  --- Generates a nonce for the given name and freshness value\n  op t : Name Fresh -> Nonce [frozen] . --- Nonce del server, representing a server-generated nonce\n\n  --- User names\n  ops a b i : -> UName .  --- User name operators for Alice, Bob, and an identifier i\n\n  --- Server name\n  op s : ->  SName .  --- Operator defining the server's name\n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen] . --- Operator to generate a master key from two user names\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] . --- Creates a session key using two names and a nonce\n\n  --- encrypt\n  op e : Key Msg -> Msg [frozen] . --- Encryption operator\n  op d : Key Msg -> Msg  [frozen] . --- Decryption operator\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- Concatenation operator on messages\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .  --- Decrypting an encrypted message returns the original message\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] .  --- Encrypting a decrypted message returns the original message\n   \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B : UName .  --- Variables for user names Alice and Bob\n  var D : Name .     --- Variable for name or identifier\n  var r r' r'' r''' r# r## : Fresh . --- Freshness variables for nonce generation\n  vars TS : Nonce .  --- Timestamp variable\n  vars M1 M2 M N : Msg .  --- Variables for messages\n  var K : Key .       --- Variable for keys\n  var SK : Sessionkey .  --- Variable for session keys\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | +(D), nil ]  &  --- Dolev-Yao strand initiation \n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &  --- Decrypting\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &  --- Encrypting \n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &  --- Message concatenation\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &  --- Separating concatenated messages\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &  --- Another separation of concatenated messages\n     :: nil :: [ nil | +(mkey(i,D)), nil ]  &  --- Creating a master key with identifier i \n     :: nil :: [ nil | +(mkey(D,i)), nil ]  \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL =\n   --- A -> S : A,B \n   --- S -> A : E(Kas: B, Kab, T, E(Kbs: A, Kab, T)) \n   --- A -> B : E(Kbs: A, Kab, T)\n\n   --- Alice's Strand\n    :: nil ::\n    [ nil | +(A ; B),\n            -(e(mkey(A,s), B ; SK ; TS ; M)),  --- Alice sends her encrypted message including session key and timestamp\n            +(M), \n            nil ]\n &\n    --- Bob's Strand\n    :: nil :: \n    [ nil | -(e(mkey(B,s), A ; SK ; TS)),  --- Bob receives and decrypts his message\n            nil ] \n &\n     :: r,r' ::\n     --- Server's Strand \n    [ nil | -(A ; B),\n            +(e(mkey(A,s), B \n                         ; seskey(A,B,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(B,s), A ; seskey(A,B,n(s,r)) ; t(s,r')))),  --- Server's operations including key and timestamp\n            nil ]\n\n  [nonexec] .\n  \neq ATTACK-STATE(0) =\n    :: r,r' ::\n     --- Server's Strand \n    [ nil,  -(a ; b),\n            +(e(mkey(a,s), b \n                         ; seskey(a,b,n(s,r)) \n                         ; t(s,r') \n                         ; e(mkey(b,s), a ; seskey(a,b,n(s,r)) ; t(s,r')))) | nil ]  --- Attack state simulation with key and nonces\n    || seskey(a,b,n(s,r)) inI\n    || nil\n    || nil\n    || nil\n    [nonexec] .\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm"
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "logic": "---\n\n### Nedham-Schroeder-Lowe Modified Protocol Description\n\n**Protocol Overview:**\nThe Nedham-Schroeder-Lowe Modified Protocol is a cryptographic protocol designed for secure communication between two parties, Alice (A) and Bob (B), with provisions for nonce generation to prevent replay attacks. The protocol utilizes public-key cryptography for secure message exchanges.\n\n**Participants:**\n- **Alice (A)**: Initiator of the communication.\n- **Bob (B)**: Respondent who receives the initial message from Alice.\n- **Intruder (i)**: An adversary that may attempt to intercept or manipulate the messages exchanged between Alice and Bob.\n\n**Message Structure:**\n- The messages exchanged in the protocol are encrypted using the public keys of the intended recipients:\n  - `pk(B, A ; N_A)` denotes a message encrypted with Bob's public key, containing Alice's identity and a nonce `N_A`.\n  - `pk(A, N_A ; N_B ; B)` denotes a response message encrypted with Alice's public key, containing the nonce `N_A`, a newly generated nonce `N_B`, and Bob's identity.\n  - `pk(B, N_B)` denotes the final message sent by Alice to Bob, containing the nonce `N_B`, encrypted with Bob's public key.\n\n**Nonces:**\n- **N_A**: A nonce generated by Alice.\n- **N_B**: A nonce generated by Bob in response to Alice's initial message. Nonces are crucial for ensuring that each session of communication is unique and helps prevent replay attacks.\n\n**Encryption Scheme:**\n- The protocol employs public-key encryption (denoted by `pk`) and private-key decryption (denoted by `sk`). The following algebraic properties hold:\n  - `pk(K, sk(K, M)) = M`: Decrypting a message M encrypted with a key K using the corresponding private key returns the original message.\n  - `sk(K, pk(K, M)) = M`: Encrypting a message M with a key K and then decrypting it with the same key returns the original message.\n\n**Protocol Steps:**\n1. **Initiation**:\n   - Alice generates a nonce `N_A` and sends the message `pk(B, A ; N_A)` to Bob.\n2. **Response**:\n   - Bob receives Alice's message, decrypts it using his private key, and generates a nonce `N_B`. He then sends the message `pk(A, N_A ; N_B ; B)` back to Alice.\n3. **Completion**:\n   - Alice receives Bob's message, decrypts it using her private key, and sends back the message `pk(B, N_B)` to Bob, confirming the successful exchange of nonces.\n\n**Security Goals:**\n- The protocol aims to achieve mutual authentication between Alice and Bob while ensuring confidentiality through encryption.\n- The use of nonces in the protocol helps to prevent replay attacks and ensures freshness of the messages.\n\n**Intruder Model:**\n- The protocol is designed with the assumption that an intruder may attempt to intercept and manipulate the messages. The defined strands in the protocol specification correspond to both legitimate communication and potential attack scenarios.\n\n---",
        "code": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)\nB --> A: pk(A, N_A ; N_B ; B)\nA --> B: pk(B, N_B)\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encripted using public \nkey x, and sk(x,y) means message y encripted using private key x. \nMoreover, encription/decription have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .\n  sk(K,pk(K,M)) = M .\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .\n  subsort Name Nonce Key < Msg .\n  subsort Name < Key .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .\n  op sk : Key Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n  \nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .\n  var Ke : Key .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .\n  vars X Y Z : Msg .\n  vars r r' : Fresh .\n  vars A B : Name .\n  vars N N1 N2 : Nonce .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ nil | +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] &\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ]\n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "codenote": "--- Nedhham-Schroeder-Lowe Modified Protocol\n***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: pk(B,A ; N_A)      --- Alice sends a message to Bob encrypted with Bob's public key\nB --> A: pk(A, N_A ; N_B ; B) --- Bob replies to Alice with a message encrypted with Alice's public key\nA --> B: pk(B, N_B)          --- Alice sends back a nonce to Bob encrypted with Bob's public key\n\nwhere N_A and N_B are nonces, pk(x,y) means message y encrypted using public \nkey x, and sk(x,y) means message y encrypted using private key x. \nMoreover, encryption/decryption have the following algebraic properties:\n\n  pk(K,sk(K,M)) = M .        --- Encrypting and then decrypting yields the original message\n  sk(K,pk(K,M)) = M .        --- Decrypting and then encrypting yields the original message\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Key .       --- Definition of sorts used in the protocol\n  subsort Name Nonce Key < Msg .--- Defining subsort relations for messages\n  subsort Name < Key .         --- Names are also considered Keys\n  subsort Name < Public .      --- Names are also considered Public keys\n\n  --- Encoding operators for public/private encryption\n  op pk : Key Msg -> Msg [frozen] .  --- Public key encryption operator\n  op sk : Key Msg -> Msg [frozen] .  --- Private key decryption operator\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  --- Nonce generation operator, associates a Name with Fresh\n\n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- Associativity operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .  --- Agent message sequencing operator\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  var Z : Msg .  --- Variable representing a message\n  var Ke : Key . --- Variable representing a key\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(Ke,sk(Ke,Z)) = Z [variant] .  --- Cancel out encryption with its corresponding decryption\n  eq sk(Ke,pk(Ke,Z)) = Z [variant] .  --- Cancel out decryption with its corresponding encryption\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var Ke : Key .    --- Variable representing the key in communication\n  vars X Y Z : Msg . --- Message variables\n  vars r r' : Fresh .--- Fresh nonces for unique session identification\n  vars A B : Name .  --- Principals involved in the protocol\n  vars N N1 N2 : Nonce .  --- Nonce variables for the protocol\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &    --- Dolev-Yao strands for generic message process\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] & \n     :: nil :: [ nil | -(X), +(pk(Ke,X)), nil ] &\n     :: nil :: [ +(A), nil ] \n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: \n     [ nil | +(pk(B,A ; n(A,r))), -(pk(A,n(A,r) ; N ; B)), +(pk(B, N)), nil ] & --- Protocol strands for message exchange\n     :: r :: \n     [ nil | -(pk(B,A ; N)), +(pk(A, N ; n(B,r) ; B)), -(pk(B,n(B,r))), nil ] \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil, -(pk(b,a ; N)), +(pk(a, N ; n(b,r) ; b)), -(pk(b,n(b,r))) | nil ]  --- Initial attack state demonstration\n     || n(b,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/nsl-db-dc.maude",
        "logic": "### Protocol Description: NSL-Distance Bounding Protocol\n\nThe NSL-Distance Bounding (NSL-DB) protocol is designed to mitigate distance-based attacks, particularly the distance hijacking attack, by ensuring that a legitimate party can establish its proximity to another party before engaging in critical communications. The protocol utilizes a combination of nonce challenges, public-key cryptography, and message exchanges to validate the identities of the communicating parties and to prevent intruders from successfully impersonating them.\n\n#### Key Components of the Protocol\n\n1. **Roles**:\n   - **Alice (A)**: Initiator of the protocol who wants to prove her proximity to Bob.\n   - **Bob (B)**: Responder who confirms Alice's proximity and identity.\n   - **Intruder (I)**: An adversary attempting to disrupt or impersonate legitimate parties.\n\n2. **Messages**:\n   - Messages exchanged in the protocol are encrypted and include nonces to prevent replay attacks. Nonces are unique values that are used only once in a session.\n\n3. **Public Key Encryption**:\n   - The protocol employs public and private key pairs (pk and sk) for securing messages. \n   - Each principal has a public key (pk) which is used for encryption, and a corresponding private key (sk) for decryption.\n\n4. **Nonces**:\n   - Nonces are generated during the protocol execution to ensure freshness of the messages and to validate the communication's integrity.\n\n5. **Strands**:\n   - The protocol consists of multiple strands where each strand represents a sequence of actions taken by the principals (Alice and Bob) and the intruder.\n\n6. **Attack Patterns**:\n   - The protocol includes specific attack states to represent potential distance hijacking attacks, allowing the protocol's security properties to be analyzed.\n\n### Protocol Workflow\n\n1. **Initialization**:\n   - The protocol starts with Alice initiating a communication sequence where she sends a message encrypted with Bob's public key, containing a nonce and her identity.\n\n2. **Response**:\n   - Upon receiving Alice's message, Bob responds with a message that includes a nonce and is also encrypted. This message serves as a challenge to Alice.\n\n3. **Challenge-Response**:\n   - Alice must respond to Bob\u2019s challenge by sending back the correct nonce along with her identity, encrypted with Bob\u2019s public key.\n\n4. **Verification**:\n   - Bob verifies Alice's response by decrypting the message and confirming the nonce matches his expectation.\n\n5. **Intrusion Prevention**:\n   - The protocol incorporates measures to detect intruder attempts to impersonate or intercept the communication by introducing additional strands that represent possible attack scenarios.\n\n### Summary\n\nThe NSL-Distance Bounding protocol is structured to ensure secure communication between two legitimate parties while mitigating the risk of distance-related attacks. It leverages cryptographic techniques, nonce challenges, and structured message exchanges to validate the identities of the communicating principals, thereby ensuring that the communication remains secure against potential threats from intruders.\n\n---\n\nThis description can be used to create a corresponding Maude-NPA file that implements the protocol. The details outlined here guide the implementation of the roles, messages, encryption methods, and the structure of the strands in the Maude language, ensuring a coherent representation of the NSL-DB protocol.",
        "code": "--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n \n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < Msg .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n--- Variables \n  vars X Y Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r'' r# : Fresh .\n  vars A B C : Name .\n  vars NA NB N N' NC : Nonce .\n  vars NS NS' : NonceSet .\n  vars X Y Z H : Msg .\n  vars P Q : Name .\n\n  eq STRANDS-DOLEVYAO\n   =\n---     :: nil :: [ nil | -(NS), -(NS'), +(NS * NS'), nil ] &\n---     :: nil :: [ nil | -(NS), -(N), +(NS * N), nil ] & --- Alternative version\n     :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &\n     :: nil :: [ nil | +(A) , nil ] &\n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,r)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)) , \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; 1-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(B,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(B,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n--- Attack pattern to find Distance Hijacking attack\neq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "codenote": "--- Direct Composition\n--- NSL-Distance Bounding protocol\n\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Synchronization for composition\n  subsort Role < Msg .\n\n  --- Roles\n  ops init-nsl resp-nsl : -> Role .\n  ops init-db  resp-db :  -> Role .\n\n  --- Sort Information \n  sorts Name Nonce NonceSet . \n  subsort Name NonceSet < Msg .\n  subsort Nonce < NonceSet .\n  subsort Name < Public .\n\n  --- Encoding operators for public/private encryption\n  op pk : Name Msg -> Msg [frozen] .  \n  op sk : Name Msg -> Msg [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  \n\n  --- Concatenation operator\n  op _;_ : Msg  Msg  -> Msg [gather (e E) frozen] .\n\n  --- Exclusive-or operator\n  op _*_ : NonceSet NonceSet -> NonceSet  [assoc comm frozen] . --- xor operator\n  op null : -> NonceSet .\n\n  --- Notation: The above section defines the symbols used in the protocol including Roles, Concatenation and Encryption.\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n \n  --- Variables \n  vars X Y Z : Msg .\n  vars A B : Name .\n  vars XN YN : NonceSet .\n  \n  *** Encryption/Decryption Cancellation\n  eq pk(A,sk(A,Z)) = Z [variant] .\n  eq sk(A,pk(A,Z)) = Z [variant] .\n\n  *** Exclusive or properties\n  eq null * XN = XN [variant] .\n  eq XN * XN = null [variant] .\n  eq XN * XN * YN = YN [variant] .\n\n  --- Notation: The equations here define algebraic properties including cancellation of encryption and the properties of exclusive or (xor).\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars r r' r'' r# : Fresh .\n  vars A B C : Name .\n  vars NA NB N N' NC : Nonce .\n  vars NS NS' : NonceSet .\n  vars X Y Z H : Msg .\n  vars P Q : Name .\n\n  --- Strands for protocol execution illustrating the communication steps\n  eq STRANDS-DOLEVYAO\n   =\n     :: nil :: [ nil | -(X), -(Y), +(X ; Y), nil ] &  --- Message concatenation\n     :: nil :: [ nil | -(X ; Y), +(X), nil ] &         --- Message dependency\n     :: nil :: [ nil | -(X ; Y), +(Y), nil ] &\n     :: nil :: [ nil | -(X), +(sk(i,X)), nil ] &      --- Introduces the Intruder's sk\n     :: nil :: [ nil | -(X), +(pk(A,X)), nil ] &      --- Introduces Alice's pk\n     :: nil :: [ nil | +(A) , nil ] & \n     :: nil :: [ nil | +(null), nil ] & \n     :: r :: [ nil | +(n(i,r)), nil ]               --- Random nonce generation by Intruder\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n   = :: r :: --- NSL-Alice\n     [ nil | +(pk(B, n(A,r) ; A)), \n\t     -(pk(A, n(A,r) ; NB ; B )), \n\t     +(pk(B, NB)), \n\t     {init-nsl -> resp-db ;; 1-1 ;; A ; B ; n(A,r)}, nil ] &\n     :: r :: --- NSL-Bob\n     [ nil | -(pk(B,NA ; A)), \n\t     +(pk(A, NA ; n(B,r) ; B)), \n\t     -(pk(B,n(B,r))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA}, nil ] &\n     :: r' ::\n     [ nil | {resp-nsl -> init-db ;; 1-1 ;; A ; B ; NA},\n             +(n(B,r')), \n             -(NA * n(B,r')), nil] &\n     :: nil :: \n     [ nil | {init-nsl -> resp-db ;; 1-1 ;; A ; B ; NA },\n             -(N), \n             +(NA * N), nil ] \n  [nonexec] .\n\n  --- Attack pattern to find Distance Hijacking attack\n  eq ATTACK-STATE(0)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n  --- Attack pattern to find Distance Hijacking attack\n  eq ATTACK-STATE(1)\n   = :: r :: \n     [ nil,  +(pk(i,n(a,r) ; a)),\n\t     -(pk(a,n(a,r) ; NC ; i)), \n\t     +(pk(i, NC)),\n\t     {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) } | nil] &\n     :: r' :: \n     [ nil,  -(pk(b,n(a,r) ; i)), \n\t     +(pk(i,n(a,r) ; n(b,r') ; b)), \n\t     -(pk(b,n(b,r'))),\n   \t     {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r) } | nil ] &\n     :: r'' ::\n     [ nil,  {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a,r)},  \n             +(n(b,r'')),\n\t     -(n(a,r) * n(b,r''))  | nil] &\n     :: nil :: \n     [ nil,  {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a,r) },\n             -(n(b,r'')), \n             +(n(a,r) * n(b,r'')) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n [nonexec] . \n\n  --- Notation: The above sections define the strands for the protocol execution and potential attack patterns (Distance Hijacking).\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/signed_dh.maude",
        "logic": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "code": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encripted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encription/decription have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appopriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "codenote": "***(\nThe informal journal-level description of this protocol is as follows:\n\nA --> B: A ; B ; exp(g,N_A); sign(A, B; exp(g,N_A))\nB --> A: A ; B ; exp(g,N_B); sign(B, A; exp(g,N_B))\n// claim: secrecy of 'exp(exp(g,N_B),N_A)' for A and B provided both are\n// honest\n\nverify(A, sign(A, m), m) -> tt\n\nwhere N_A and N_B are nonces, exp(x,y) means x raised to y, enc(x,y) means\nmessage y encrypted using key x, and secret(A,B) is a secret shared between\nA and B. Moreover, exponentiation and encryption/decryption have the following \nalgebraic properties:\n\n  exp(exp(X,Y),Z) = exp(X, Y * Z)\n  e(K,d(K,M)) = M .\n  d(K,e(K,M)) = M .\n\nwhere * is the xor operator, though no algebraic property is given, since \nthey are not necessary for this protocol. However, note that the property \nfor exponentiation is restricted below by using appropriate sorts\nin such a way that variable X can be only the generator g. This is necessary\nto have a finitary unification procedure based on narrowing.\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .\n  subsort Gen Exp < GenvExp .\n  subsort Name NeNonceSet GenvExp Secret Key < Msg .\n  subsort Exp < Key .\n  subsort Name < Public . --- This is quite relevant and necessary\n  subsort Gen < Public . --- This is quite relevant and necessary\n\n  --- Secret\n  op sec : Name Fresh -> Secret [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n\n  --- Intruder\n  ops a b i : -> Name .\n\n  --- Encryption\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- Signing\n  op sign : Name Msg -> Msg [frozen] .\n\n  --- Exp\n  op exp : GenvExp NeNonceSet -> Exp [frozen] .\n\n  --- Gen\n  op g : -> Gen .\n\n  --- NeNonceSet\n  subsort Nonce < NeNonceSet .\n  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [frozen assoc comm] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) \n   = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) [metadata \"variant\"] .\n  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg [metadata \"variant\"] .\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars NS1 NS2 NS3 NS : NeNonceSet .\n  var NA NB N : Nonce .\n  var GE : GenvExp .\n  var G : Gen .\n  vars A B : Name .\n  vars r r' r1 r2 r3 : Fresh .\n  var Ke : Key .\n  vars XE YE : Exp .\n  vars M M1 M2 : Msg .\n  var Sr : Secret .\n\n  eq STRANDS-DOLEVYAO = \n     :: nil :: [ nil | -(M1 ; M2), +(M1), nil ] &\n     :: nil :: [ nil | -(M1 ; M2), +(M2), nil ] &\n     :: nil :: [ nil | -(M1), -(M2), +(M1 ; M2), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(e(Ke,M)), nil ] &\n     :: nil :: [ nil | -(Ke), -(M), +(d(Ke,M)), nil ] &\n     :: nil :: [ nil | -(NS1), -(NS2), +(NS1 * NS2), nil ] &\n     :: nil :: [ nil | -(GE), -(NS), +(exp(GE,NS)), nil ] &\n     :: r ::   [ nil | +(n(i,r)), nil ] &\n     :: nil :: [ nil | +(g), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | -(M), +(sign(i, M)), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL = \n     :: r :: \n     [nil | +(A ; B ; exp(g,n(A,r)) ; sign(A, B ; exp(g,n(A,r)))), \n            -(A ; B ; XE ;            sign(B, (A ; XE)           )), nil] &\n     :: r :: \n     [nil | -(A ; B ; XE ;            sign(A, B ; XE) ), \n            +(A ; B ; exp(g,n(B,r)) ; sign(B, A ; exp(g,n(B,r)))), nil]\n  [nonexec] .\n\n  eq EXTRA-GRAMMARS\n   = (grl empty => (NS * n(a,r)) inL . ;\n      grl empty => n(a,r) inL . ;\n      grl empty => (NS * n(b,r)) inL . ;\n      grl empty => n(b,r) inL .  \n      ! S2 )\n  [nonexec] .\n \n  eq ATTACK-STATE(0)\n   = :: r :: \n     [nil , +(a ; b ; exp(g,n(a,r)); sign(a, b ; exp(g,n(a,r)))),\n            -(a ; b ; XE ;           sign(b, a ; XE           )) | nil]\n     || exp(XE,n(a,r)) inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(1)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n \n  eq ATTACK-STATE(2)\n   = :: r :: \n     [nil, -(a ; b ; XE), \n           +(a ; b ; exp(g,n(b,r))), \n           -(e(exp(XE,n(b,r)),sec(a,r'))) | nil]\n     || sec(a,r') inI\n     || nil\n     || nil\n     || never(\n     *** Avoid infinite useless path\n      (:: nil :: \n      [ nil | -(exp(GE,NS1 * NS2)), -(NS3), \n          +(exp(GE,NS1 * NS2 * NS3)), nil ] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n             -(sec(A:Name, #2:Fresh)), \n             +(e(exp(#1:Exp, N2:Nonce), sec(A:Name, #2:Fresh))), nil] \n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (:: nil :: \n      [nil | -(exp(#1:Exp, N1:Nonce)), \n          -(e(exp(#1:Exp, N1:Nonce), S:Secret)), \n          +(S:Secret), nil]\n      & S:StrandSet || K:IntruderKnowledge)\n     *** Pattern to avoid unreachable states\n     (S:StrandSet \n      || (#4:Gen != #0:Gen), K:IntruderKnowledge)\n     )\n  [nonexec] .\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    },
    {
        "file": "MAUDE-1/lattice.maude",
        "logic": "### Description of the Lattice Protocol\n\n**Lattice Overview:**\nThis protocol defines a mathematical structure known as a lattice, which is a partially ordered set in which any two elements have a unique supremum (least upper bound) and an infimum (greatest lower bound). The lattice is represented by the sort `Lat`, which includes two distinguished elements: the bottom element (denoted as `0`) and the top element (denoted as `1`).\n\n**Operations:**\n- **Supremum (`\\/`)**: This operation takes two lattice elements and produces their least upper bound.\n- **Infimum (`/\\`)**: This operation takes two lattice elements and produces their greatest lower bound.\n- **Complement (`c`)**: This operation provides the complement of a lattice element.\n\n**Key Properties of the Lattice:**\n1. **Idempotency**:\n   - The supremum and infimum operations are idempotent:\n     - \\( X \\\\/ X = X \\) (LAT-01)\n     - \\( X \\\\/ X = X \\) (LAT-02)\n\n2. **Identity Elements**:\n   - The bottom element acts as the identity for supremum:\n     - \\( X \\\\/ 0 = X \\) (LAT-05)\n   - The top element acts as the identity for infimum:\n     - \\( X \\\\/ 1 = X \\) (LAT-06)\n\n3. **Absorption Laws**:\n   - These laws relate the supremum and infimum operations:\n     - \\( 1 \\\\/ X = 1 \\) (LAT-07)\n     - \\( 0 \\\\ X = 0 \\) (LAT-08)\n     - \\( X \\\\ (X \\\\/ Y) = X \\) (LAT-09)\n     - \\( X \\\\/ (X \\\\ Y) = X \\) (LAT-10)\n\n4. **Modular Lattice Axiom**:\n   - The modular property provides a specific relationship between the operations:\n     - If \\( (X \\\\ Z) = X \\), then \\( Z \\\\ (X \\\\/ Y) = X \\\\/ (Y \\\\ Z) \\) (LAT-13).\n\n5. **Complement Axioms**:\n   - These axioms define the behavior of complements with respect to the lattice elements:\n     - \\( X \\\\/ c(X) = 1 \\) (LAT-14)\n     - \\( X \\\\ c(X) = 0 \\) (LAT-15)\n\n6. **Extensions of Properties**:\n   - Several properties are extended to combinations of elements and their complements:\n     - \\( Z \\\\ X \\\\ (X \\\\/ Y) = Z \\\\ X \\) (LAT-11)\n     - \\( Z \\\\/ X \\\\/ (X \\\\ Y) = Z \\\\/ X \\) (LAT-12)\n     - \\( c(0) = 1 \\) (LAT-18)\n     - \\( c(1) = 0 \\) (LAT-19)\n     - \\( c(X \\\\ Y) \\\\/ X = 1 \\) (LAT-20)\n     - \\( c(X \\\\/ Y) \\\\ X = 0 \\) (LAT-21)\n\n### Summary\nThis Maude file represents a formal definition of a lattice structure with specific operations and axioms that govern its behavior. It captures the essential properties of lattices, including idempotency, absorption, modularity, and the existence of complements. The implementation in Maude allows for rigorous reasoning about these properties and can be used to prove various theorems related to lattice theory.\n\n### Generating a Corresponding Maude File\nTo create a runnable Maude file based on this description, you can use the provided Maude code directly, as it already encapsulates the definitions and rules necessary to represent the lattice structure as described. You may save the text in a `.maude` file and run it using the Maude-NPA tool for further analysis or verification of lattice properties.",
        "code": "set include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** sup\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** inf\n  op c :  Lat -> Lat .                     *** complement\n\n  vars X Y Z : Lat .\n\n  *** idempotency\n  eq [LAT-01] : X \\/ X = X .\n  eq [LAT-02] : X /\\ X = X .\n  *** extensions\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .\n\n  *** identities\n  eq [LAT-05] : X \\/ 0 = X .\n  eq [LAT-06] : X /\\ 1 = X .\n  \n  *** simple absorption (follows from identities and absorption)\n  eq [LAT-07] : 1 \\/ X = 1 .\n  eq [LAT-08] : 0 /\\ X = 0 .\n  *** absorption\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .\n  eq [LAT-10] : X \\/ (X /\\ Y) = X .\n  *** extensions\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .\n\n  *** modular lattice axiom\n ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) = X .\n\n  *** complement axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .\n  eq [LAT-15] : X /\\ c(X) = 0 .\n  *** extensions\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .\n  ***\n  eq [LAT-18] : c(0) = 1 .\n  eq [LAT-19] : c(1) = 0 .\n  ***\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .\n  *** extensions\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .\nendfm",
        "codenote": "set include BOOL off .\n\nfmod LATTICE is\n  sort Lat .\n  ops 0 1 : -> Lat .                       *** bottom and top of the lattice\n  op _\\/_ : Lat Lat -> Lat [assoc comm prec 55] .  *** supremum (least upper bound)\n  op _/\\_ : Lat Lat -> Lat [assoc comm prec 59] .  *** infimum (greatest lower bound)\n  op c :  Lat -> Lat .                     *** complement of an element in the lattice\n\n  vars X Y Z : Lat .\n\n  *** Idempotency Axioms\n  eq [LAT-01] : X \\/ X = X .                *** X joined with itself is X\n  eq [LAT-02] : X /\\ X = X .                *** X met with itself is X\n\n  *** Extensions of Idempotency\n  eq [LAT-03] : Y \\/ X \\/ X = Y \\/ X .     *** Repetition of X in supremum does not change the result\n  eq [LAT-04] : Y /\\ X /\\ X = Y /\\ X .     *** Repetition of X in infimum does not change the result\n\n  *** Identity Axioms\n  eq [LAT-05] : X \\/ 0 = X .                 *** 0 is the identity element for the join operation\n  eq [LAT-06] : X /\\ 1 = X .                 *** 1 is the identity element for the meet operation\n  \n  *** Simple Absorption Axioms\n  eq [LAT-07] : 1 \\/ X = 1 .                 *** 1 absorbs any element in the join operation\n  eq [LAT-08] : 0 /\\ X = 0 .                 *** 0 absorbs any element in the meet operation\n\n  *** Absorption Axioms\n  eq [LAT-09] : X /\\ (X \\/ Y) = X .          *** Absorption law for infimum over supremum\n  eq [LAT-10] : X \\/ (X /\\ Y) = X .          *** Absorption law for supremum over infimum\n\n  *** Extensions of Absorption\n  eq [LAT-11] : Z /\\ X /\\ (X \\/ Y) = Z /\\ X .   *** Extension of absorption property\n  eq [LAT-12] : Z \\/ X \\/ (X /\\ Y) = Z \\/ X .   *** Extension of absorption property\n\n  *** Modular Lattice Axiom\n  ceq [LAT-13] : Z /\\ (X \\/ Y) = X \\/ (Y /\\ Z) if (X /\\ Z) = X .\n  \n  *** Complement Axioms\n  eq [LAT-14] : X \\/ c(X) = 1 .               *** X joined with its complement is 1\n  eq [LAT-15] : X /\\ c(X) = 0 .               *** X met with its complement is 0\n\n  *** Extensions of Complement Axioms\n  eq [LAT-16] : Z \\/ X \\/ c(X) = 1 .          *** Z joined with X and its complement yields 1\n  eq [LAT-17] : Z /\\ X /\\ c(X) = 0 .          *** Z met with X and its complement yields 0\n\n  *** Additional Complement Axioms\n  eq [LAT-18] : c(0) = 1 .                    *** The complement of 0 is 1\n  eq [LAT-19] : c(1) = 0 .                    *** The complement of 1 is 0\n\n  *** Further Complement Axioms\n  eq [LAT-20] : c(X /\\ Y) \\/ X = 1 .          *** The complement of a meet with X yields 1\n  eq [LAT-21] : c(X \\/ Y) /\\ X = 0 .          *** The complement of a join with X yields 0\n\n  *** Extensions of Further Complement Axioms\n  eq [LAT-22] : c(X /\\ Y) \\/ X \\/ Z = 1 .     *** The extended complement property with Z\n  eq [LAT-23] : c(X \\/ Y) /\\ X /\\ Z = 0 .     *** The extended complement property with Z\nendfm"
    },
    {
        "file": "MAUDE-1/bank.maude",
        "logic": "### Description of the Banking Protocol\n\n**Protocol Name:** Banking Protocol with Account Management\n\n**Overview:**\nThe banking protocol is designed to manage user accounts, facilitating operations such as crediting, debiting, and transferring funds between accounts. It also includes mechanisms for handling account statuses and limits on the number of accounts.\n\n**Key Components:**\n\n1. **Data Types:**\n   - **Account:** Represents a user account consisting of an identifier, balance, and status.\n   - **Status:** Indicates the state of the account. Possible statuses are \"active\" and \"blocked.\"\n   - **Message:** Represents operations that can be performed on accounts, such as credit, debit, and transfer.\n   - **State:** Represents the overall state of the banking system, including all accounts and operations.\n\n2. **Account Creation and Management:**\n   - Each account is created with an identifier (Id), an initial balance (Int), and a status (Status).\n   - A predefined set of preferred clients (Bob and Charlie) is established, which may have special conditions in the protocol.\n\n3. **Account Operations:**\n   - **Credit:** Increases the account balance of a specified account.\n   - **Debit:** Decreases the account balance of a specified account, which may lead to the account being blocked if the balance goes negative.\n   - **Transfer:** Moves funds from one account to another, adjusting both accounts' balances accordingly.\n\n4. **Initial States:**\n   - The protocol defines multiple initial states (init1, init2, init3) that set up various scenarios with different transactions, allowing for testing of the protocol's behavior under different conditions.\n\n5. **Account Limitations:**\n   - The protocol allows for the creation of new accounts but limits the total number of active accounts to a maximum of 10.\n   - Accounts can be closed if they are blocked and have a balance below a certain negative limit.\n\n6. **Rules and Conditionals:**\n   - The protocol includes rules for updating account statuses based on transactions. For example, if an account balance falls below zero, its status is changed to \"blocked.\"\n   - Additional rules for creating and closing accounts based on the number of existing accounts and account balance are defined.\n\n**Protocol Operations:**\n- `credit(ID, M)`: Credits the account with the identifier `ID` by the amount `M`.\n- `debit(ID, M)`: Debits the account with the identifier `ID` by the amount `M`.\n- `transfer(ID1, ID2, M)`: Transfers the amount `M` from account `ID1` to account `ID2`.\n- `updateStatus(Account)`: Updates the status of an account based on its balance.\n\n**Special Conditions:**\n- Accounts may be flagged as \"blocked\" if their balance falls below zero.\n- Special handling is provided for accounts belonging to preferred clients.\n\nThis protocol can be further extended or modified to include additional features or restrictions as needed. The structured nature of the protocol ensures clarity in operations, making it suitable for formal verification and analysis using tools like Maude-NPA.\n\n### Generation of Maude File\nThis description can be used to develop a new Maude file that accurately reflects the protocol's requirements and operations. You can specify additional features or modifications based on testing and evaluation of the protocol's functionality.",
        "code": "fmod BANK-INT+ID is inc INT .\n    sort Id .\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .\n\n    sorts Account PremiumAccount Status Msg State .\n    subsort PremiumAccount < Account .\n    subsorts  Account Msg < State .\n\n    var ID : Id .            \n    var BAL : Int .         \n    var STS : Status .     \n\n    op <_|_|_> : Id Int Status -> Account [ctor] .\n\n    op active : -> Status [ctor] .\n    op blocked : -> Status [ctor] .\n\n    op Alice : -> Id [ctor] .         \n    op Bob : -> Id [ctor] .\n    op Charlie : -> Id [ctor] .       \n    op Daisy : -> Id [ctor] .\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .\n\n    op PreferredClients : -> Set{Id} .\n    eq PreferredClients = Bob, Charlie . \n\n    op updateStatus : Account -> Account .\n    ceq updateStatus(< ID | BAL | active >) = < ID | BAL | blocked > if BAL < 0 .\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .\n    vars BAL BAL1 BAL2 M : Int .\n    \n    op empty-state : -> State [ctor] .\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .\n    ops credit debit : Id Int -> Msg [ctor] .\n    op  transfer : Id Id Int -> Msg  [ctor] .\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .\n\n    op init1 : -> State .\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 30) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Bob, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 130) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for brnaching than init2\n    op init3 : -> State .\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Alice, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .\n\n    vars ST ST' : State .\n    var A : Account .\n    var ID : Id . var BAL : Int .\n\n    op numberOfAccounts : State -> Nat .\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .\n    eq numberOfAccounts(ST) = 0 [owise] .\n\n    subsort Nat < Id .\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocekd account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .\nendm",
        "codenote": "fmod BANK-INT+ID is inc INT .\n    sort Id .  *** Sort representing identifiers for accounts\nendfm\n\nview Id from TRIV to BANK-INT+ID is\n    sort Elt to Id .  *** View to map elements to Id type\nendv\n\nfmod BANK-EQ is \n\tinc BANK-INT+ID . \n    pr SET{Id} .  *** Set of identifiers representing accounts\n\n    sorts Account PremiumAccount Status Msg State .  *** Defining sorts used in the bank module\n    subsort PremiumAccount < Account .   *** PremiumAccounts are a specific type of Account\n    subsorts  Account Msg < State .   *** Accounts and Messages are subsorts of State\n\n    var ID : Id .  *** Variable for storing account identifiers\n    var BAL : Int .  *** Variable for storing balances\n    var STS : Status .   *** Variable for storing account status\n\n    op <_|_|_> : Id Int Status -> Account [ctor] .  *** Constructor for accounts\n\n    op active : -> Status [ctor] .  *** Represents an account that is active\n    op blocked : -> Status [ctor] .  *** Represents a blocked account\n\n    op Alice : -> Id [ctor] .  *** Identifier for Alice\n    op Bob : -> Id [ctor] .  *** Identifier for Bob\n    op Charlie : -> Id [ctor] .  *** Identifier for Charlie\n    op Daisy : -> Id [ctor] .  *** Identifier for Daisy\n\n    cmb < ID | BAL | STS > : PremiumAccount if ID in PreferredClients .  *** Condition for premium accounts\n\n    op PreferredClients : -> Set{Id} .  *** Set of preferred clients\n    eq PreferredClients = Bob, Charlie .  *** Definition of preferred clients\n\n    op updateStatus : Account -> Account .  *** Operation to update the status of an account\n    ceq updateStatus(< ID | BAL | active >) = < ID | BAL | blocked > if BAL < 0 .  *** Rules for updating to blocked status\n    eq updateStatus(< ID | BAL | STS >) = < ID | BAL | STS > [owise] .  *** Keeping status unchanged otherwise\nendfm\n\nmod BANK is inc BANK-EQ .\n    vars ID ID1 ID2 : Id .  *** Variables for account identifiers\n    vars BAL BAL1 BAL2 M : Int .  *** Variables for balances and monetary values\n    \n    op empty-state : -> State [ctor] .  *** Empty initial state for the bank\n    op _;_ : State State -> State [ctor assoc comm id: empty-state] .  *** Operator to combine multiple states\n    ops credit debit : Id Int -> Msg [ctor] .  *** Operations for crediting and debiting accounts\n    op transfer : Id Id Int -> Msg [ctor] .  *** Operation for transferring money between accounts\n    \n    rl [credit] : credit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL + M | active >) .  *** Rule for crediting an account\n\n    rl [debit] : debit(ID, M) ; < ID | BAL | active > => \n                  updateStatus(< ID | BAL - M | active >) .  *** Rule for debiting an account\n\n    rl [transfer] : transfer(ID1, ID2, M) ; < ID1 | BAL1 | active > ; < ID2 | BAL2 | active > \n                  => updateStatus(< ID1 | BAL1 - M | active >) ; updateStatus(< ID2 | BAL2 + M | active >) .  *** Rule for transferring money\n\n    op init1 : -> State .  *** Initial state definition for the bank system\n    eq init1 = < Alice | 500 | active > ; < Bob | 200 | active > ; < Charlie | 200 | active > ; < Daisy | 100 | active > ; debit(Alice, 30) ; transfer(Bob, Charlie, 60) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Charlie, 50) ; debit(Daisy, 45) ; transfer(Alice, Charlie, 15) ; transfer(Alice, Bob, 10) ; transfer(Bob, Charlie, 4) ; transfer(Daisy, Bob, 30) .\n\n    *** State with more combinations for branching than init1\n    op init2 : -> State .  *** More complex initial state\n    eq init2 = init1 ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; credit(Daisy, 20) ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; transfer(Alice, Bob, 130) ; transfer(Bob, Alice, 60) ; credit(Bob, 200) .\n\n    *** State with even more combinations for branching than init2\n    op init3 : -> State .  *** Even more complex initial state\n    eq init3 = init2 ; debit(Alice, 45) ; transfer(Alice, Charlie, 125) ; credit(Alice, 10) ; credit(Daisy, 40) ; debit(Daisy, 45) ; transfer(Daisy, Bob, 10) ; debit(Charlie, 50) ; debit(Bob, 60) ; transfer(Bob, Charlie, 20) ; credit(Charlie, 110) ; debit(Charlie, 50) ; transfer(Daisy, Charlie, 4) ; transfer(Alice, Bob, 20) ; debit(Daisy, 15) ; transfer(Alice, Bob, 55) ; transfer(Alice, Bob, 10) .\nendm\n\nmod BANK-EXT is \n    inc BANK .  *** Extension of the BANK module\n\n    vars ST ST' : State .  *** Variables for states\n    var A : Account .  *** Variable for account\n    var ID : Id . var BAL : Int .  *** Variables for identifiers and balances\n\n    op numberOfAccounts : State -> Nat .  *** Operation to count number of accounts\n    eq numberOfAccounts(ST ; A ; ST') = s(numberOfAccounts(ST) + numberOfAccounts(ST')) .  *** Counting accounts recursively\n    eq numberOfAccounts(ST) = 0 [owise] .  *** Base case for counting accounts\n\n    subsort Nat < Id .  *** Natural numbers are a subsort of Id for account counting\n\n    *** Creates an account if the number of accounts is less than 10\n    crl [open-acc] : ST => < numberOfAccounts(ST) | 200 | active > ; ST if numberOfAccounts(ST) < 10 .\n\n    *** Closes a blocked account if the balance is below a negative limit\n    ---crl [close-acc] : < ID | BAL | blocked > ; ST => ST if BAL < -200 .  *** Rule for closing accounts based on balance\nendm"
    },
    {
        "file": "MAUDE-1/Example1.maude",
        "logic": "### Protocol Description\n\n#### Context\nIn this protocol, we are analyzing the behavior of a node \\( N \\) that is in a \"waiting\" state and is performing a lookup operation on a variable \\( X \\). The node will evaluate the result of the lookup and assign it to a local variable \\( x \\).\n\n#### Node Definition\n- **Node \\( N \\)**: This node is responsible for executing a lookup operation to retrieve the current value of a variable \\( X \\). The node's execution context is defined by various conditions that govern its behavior.\n\n#### Lookup Operation\n- The node executes the operation:\n  ```maude\n  x := LookUpNow(X);\n  ```\n  This means that at this point, node \\( N \\) is trying to obtain the value of \\( X \\) immediately.\n\n#### Assumptions\n1. The protocol assumes that there are **no other lookup operations** on variable \\( X \\) at the same time.\n2. The value obtained from the lookup operation is determined by the function \\( Sigma(i, X) \\), which is presumed to return the current value associated with \\( X \\).\n\n#### Execution Outcome\n- Since there are no monitors on variable \\( X \\), the execution of node \\( N \\) results in:\n  - The local variable \\( x \\) being assigned the value \\( Sigma(i, X) \\).\n  - The lookup operation evaluates to \\( Gamma(i, X) \\), which, by definition in this context, is equivalent to \\( Sigma(i, X) \\).\n\n#### Global State\n- The global state of the protocol is defined as follows:\n  - The node \\( N \\) is in an assignment state with specific parameters that dictate its behavior:\n    - **Status**: waiting\n    - **Outcome**: none\n    - **Active**: true\n    - **Condition Flags**: various flags controlling the node's execution (e.g., start condition, end condition, and post conditions).\n  - The variable \\( x \\) is categorized as memory with initial and active values.\n\n### Maude File Structure\nThe provided Maude file defines the following components:\n- **Module Declaration**: The module is defined as `EXAMPLE1`, which includes the protection of `PLEXILITE-PREDS`.\n- **Operations**:\n  - `Example1`: Represents the node's behavior and the lookup assignment.\n  - `Example1Env`: Defines the environment context containing the variable \\( X \\).\n  - `stateN`: Configures the global state of the protocol, capturing the current status of node \\( N \\) and the memory state of variable \\( x \\).\n\n### Execution\nThe execution of the protocol can be initiated using the command:\n```maude\nsrew stateN using micro ! .\n```\nThis command will simulate the execution of the protocol, allowing the Maude-NPA tool to analyze the behavior of the node and the interactions with the variable \\( X \\).\n\n### Summary\nThis protocol serves as a foundational example for demonstrating how a node can look up values in a shared context and how the state of the node can be represented and simulated using the Maude-NPA tool. The absence of concurrent lookups ensures that the lookup operation is straightforward, leading to predictable behavior in the protocol's execution.",
        "code": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! .",
        "codenote": "***(\nIn all the examples, assume we are just before a macro-step where a node N\nis in state waiting.\n\n1. Assume that N is\n\nNode N {\n  x:= LookUpNow(X);\n}\n\nand that there are no other Lookups of any kind on X. The execution of N\nends with x having the value of Sigma(i,X).\n\nExplanation:\nSince there are no monitors on the variable X, at the current time step\nGamma(i,X) gets the value Sigma(i,X). By definition, LookUpNow(X) evaluates\nto Gamma(i,X).\n***)\n\nmod EXAMPLE1 is\n protecting PLEXILITE-PREDS .\n\n *** Notation\n *** The following operation represents an example of execution for node N,\n *** where the variable x is defined within the context of node 'N.\n op Example1 : -> Plexil .\n eq Example1 = assignment(\n                 'N,\n                  ('x : v(0)),\n                  (\n                    (startc:   const(v(true))),\n                    (endc:     const(v(true))),\n                    (repeatc:  const(v(false))),\n                    (inv:      const(v(true))),\n                    (post:     const(v(true))),\n                    (pre:      const(v(true))),\n                    (skip:     const(v(false))),\n                    (priority: 1)\n                  ),\n                  (('x . 'N) := (lookup('X)))\n               ) .\n\n op Example1Env : -> ContextList .\n eq Example1Env = ('X : v(1)) .\n\n op stateN : -> GlobalConfig .\n eq stateN \n  = {nilcontexts} > 'X : v(1) |- \n    [\n < 'N : assignment | status: waiting,outcome: none,active: true,repeatc: const(v(false)),startc:\n    const(v(true)),endc: const(v(true)),post: const(v(true)),skip: const(v(false)),pre: const(v(\n    true)),inv: const(v(true)),priority: 1,loopenabled: true,('x . 'N) := lookup('X) >  \n < 'x . 'N : memory | initVal: v(0),actVal: v(0) > ]\n    {mtactions} {\"inactive-03\"} .\nendm\n\neof\n\nsrew stateN using micro ! ."
    },
    {
        "file": "MAUDE-1/multiset-algebra.maude",
        "logic": "### Protocol Description\n\n#### Overview\nThis protocol defines a formal framework for manipulating multisets of natural numbers. A multiset allows for the representation of collections where elements can appear multiple times, differing from a standard set where each element is unique. The operations defined include multiset union, intersection, difference, containment, membership, cardinality, and distinct element counting.\n\n#### Elements\n1. **Natural Numbers**: The protocol operates on natural numbers, where `0` is defined as the base element, and `s(N)` denotes the successor function, representing natural numbers greater than `0`.\n\n2. **Multisets**: The fundamental structure is the multiset, which can contain elements of type `Nat`. The operations defined allow for the construction and manipulation of these multisets.\n\n#### Operations\n- **Construction**:\n  - `mt`: Represents the empty multiset.\n  - `_,_`: The operator for multiset union, allowing the combination of two multisets.\n\n- **Set Operations**:\n  - `\\`: Multiset difference, which removes elements of one multiset from another.\n  - `C=`: Multiset containment, which checks if all elements of one multiset are present in another.\n  - `in`: Membership operator, checking if an element belongs to a multiset.\n  - `/\\`: Multiset intersection, yielding a new multiset containing only the common elements.\n\n- **Cardinality**:\n  - `|_|`: Calculates the total count of elements in a multiset, considering repetitions.\n  - `[_]`: Counts the number of distinct elements in a multiset.\n\n- **Element Removal**:\n  - `rem`: Removes all occurrences of a specified element from a multiset.\n\n- **Equality**:\n  - The protocol defines equality between multisets based on their contents, ensuring that two multisets are equal if they contain the same elements in the same multiplicities.\n\n#### Properties\nSeveral equations are defined to ensure the consistency and properties of the operations:\n- Operations such as union, intersection, and difference follow specific algebraic rules.\n- The definition ensures that operations behave identically regardless of the order of the multisets (commutativity and associativity).\n- Special cases are handled, like the empty multiset behaving neutrally in operations.\n\n#### Examples\nThe protocol includes several reduction examples to demonstrate the expected behavior of operations:\n- Checking containment and membership of elements in multisets.\n- Performing multiset union and difference operations.\n- Verifying the cardinality and distinct counts of multisets.\n\n### Conclusion\nThis protocol lays the groundwork for performing algebraic operations on multisets of natural numbers within a formal system. It is suitable for applications that require mathematical guarantees about the behavior of collections of elements, such as in cryptographic protocols and formal verification systems.\n\n### Maude File Generation\nWith this description, you can generate a corresponding Maude file that implements the operations and properties as described, ensuring it can be executed in the Maude-NPA environment. The file should include all the defined sorts, operations, equations, and reduction examples to validate the functionality of the multiset algebra.",
        "code": "set include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  ---- protecting NAT .\n  sort Nat .\n  op 0 : -> Nat .\n  op s : Nat -> Nat .\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  vars N M K : Nat .\n  eq [set00]: N ~ N = true .\n  eq [set01]: 0 ~ s(N) = false .\n  eq [set02]: s(N) ~ s(M) = N ~ M .\n  ---- protecting NAT .\n\n  ---- TRUTH\n  op if_then_else_fi : Bool Mult Mult -> Mult [strat (1 0 2 3 0)].\n  eq [set03]: if true then U else V fi = U .\n  eq [set04]: if false then U else V fi = V .\n  ---- TRUTH\n\n  sort Mult .\n  subsort Nat < Mult .\n  op mt : -> Mult [ctor] .                              *** empty multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] . *** multiset union\n  op _~_ : Nat Nat -> Bool [comm] .       *** equality predicate on naturals\n  op _\\_  : Mult Mult -> Mult .           *** multiset difference\n  op _C=_ : Mult Mult -> Bool .           *** multiset containment\n  op _in_ : Nat Mult -> Bool .            *** multiset membership\n  op _/\\_ : Mult Mult -> Mult .           *** multiset intersection\n  op rem : Nat Mult -> Mult .             *** removes N everywhere in U\n  op |_| : Mult -> Nat .                  *** cardinality with repetitions\n  op [_] : Mult -> Nat .                  *** number of distinct elements\n\n   vars U V W : Mult .\n\n  eq [set05]: mt \\ U = mt .\n  eq [set06]: U \\ mt = U .\n  eq [set07]: (M, U) \\ N = if N ~ M then U else M, (U \\ N) fi .\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .\n\n  eq [set09]: U C= (U,V) = true .\n  eq [set10]: N C= mt = false .\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .\n\n  eq [set13]: N in U = N C= U .\n\n  ---- eq U ~ V = (U C= V) and (V C= U) .\n  eq [set17]: mt ~ U = U C= mt .\n  eq [set18]: N, K, U ~ V = ((N, K, U) C= V) and (V C= (N, K, U)) .\n\n  eq [set15]: mt /\\ V = mt .\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .\n\n  eq [set17]: rem(N, mt) = mt .\n  eq [set18]: rem(N, (M, U)) = if (N ~ M) then rem(N, U) else M, (rem(N, U)) fi .\n\n  eq [set19]: | mt | = 0 .\n  eq [set20]: | N, U | = s(| U |) .\n\n  eq [set21]: [ mt ] = 0 .\n  eq [set22]: [ N, U ] = s([ rem(N, U) ]) .\nendfm\n\n---- the use of if-then-else results in a bunch of cps which do not lead to\n---- natural equations, e.g.,\n----   cp MULTISET-ALGEBRA100 for set07 and set07\n----     @4:[Mult],if @1:Nat ~ @3:Nat then @2:Nat else @3:Nat,if @1:Nat ~ @2:Nat then mt else @2:Nat fi fi\n----     = @4:[Mult],if @1:Nat ~ @2:Nat then @3:Nat else @2:Nat,if @1:Nat ~ @3:Nat then mt else @3:Nat fi fi\n----     .\n---- doesn't lead to a useful equation in the context of multisets. Indeed, it cannot\n---- be oriented so that we avoid nonterminating problems.\n---- Something similar happens with\n---- cp MULTISET-ALGEBRA1838\n----   (@3:Mult \\ @1:Nat)\\ @2:Nat\n----   =(@3:Mult \\ @2:Nat)\\ @1:Nat .\n---- Nothing can be done but proving its joinability.\n\n\n\neof\n\nred 5 ~ 12 .                  *** should be false\nred 15 ~ 15 .                 *** should be true\n\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\n\nred (3,3,4,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\n\nred 3 in (3,3,4,4,7) .                      *** should be true\n\nred 9 in (3,3,4,4,7) .                      *** should be false\n\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\n\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\n\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\n\nred rem(2,(3,3,2,2,2,4,4,4)) .  *** should be 3,3,4,4,4\n\nred | 3,3,4,4,4,2,2,9 | .       *** should be 8\n\nred [ 3,3,4,4,4,2,2,9 ] .       *** should be 4",
        "codenote": "set include BOOL off .\nset include BOOL-OPS on .\n\nfmod MULTISET-ALGEBRA is\n  ---- Protecting Natural Numbers (Nat) ----\n  sort Nat .\n  op 0 : -> Nat .          *** Zero of Nat\n  op s : Nat -> Nat .      *** Successor function, s(N) means N + 1\n  op _~_ : Nat Nat -> Bool [comm] .  *** Equality predicate on naturals\n  vars N M K : Nat .\n\n  eq [set00]: N ~ N = true .          *** A number is equal to itself\n  eq [set01]: 0 ~ s(N) = false .      *** Zero is not equal to any successor of a number\n  eq [set02]: s(N) ~ s(M) = N ~ M .   *** Successors are equal if their predecessors are equal\n  ---- Protecting Natural Numbers End ----\n\n  ---- TRUTH ----\n  op if_then_else_fi : Bool Mult Mult -> Mult [strat (1 0 2 3 0)].\n  eq [set03]: if true then U else V fi = U .   *** If condition is true, choose U\n  eq [set04]: if false then U else V fi = V .  *** If condition is false, choose V\n  ---- TRUTH End ----\n\n  sort Mult .                      *** Multisets Definition\n  subsort Nat < Mult .            *** Naturals are a subtype of Multisets\n  op mt : -> Mult [ctor] .        *** Empty Multiset\n  op _,_ : Mult Mult -> Mult [ctor assoc comm id: mt] .  *** Multiset union\n  op _\\_ : Mult Mult -> Mult .     *** Multiset difference\n  op _C=_ : Mult Mult -> Bool .    *** Multiset containment\n  op _in_ : Nat Mult -> Bool .     *** Check membership of a number in a Multiset\n  op _/\\_ : Mult Mult -> Mult .     *** Multiset intersection\n  op rem : Nat Mult -> Mult .      *** Remove N everywhere in multiset U\n  op |_| : Mult -> Nat .           *** Cardinality with repetitions\n  op [_] : Mult -> Nat .           *** Count of distinct elements in multiset\n\n  vars U V W : Mult .\n\n  eq [set05]: mt \\ U = mt .                   *** Difference with an empty multiset\n  eq [set06]: U \\ mt = U .                    *** Difference from an empty multiset\n  eq [set07]: (M, U) \\ N = if N ~ M then U else M, (U \\ N) fi .  *** If elements match, remove N\n  eq [set08]: U \\ (N, M, V) = ((U \\ N) \\ M) \\ V .  *** Remove N and M from multiset U\n\n  eq [set09]: U C= (U,V) = true .            *** U is always contained in itself\n  eq [set10]: N C= mt = false .              *** No natural number is contained in an empty multiset\n  eq [set11]: N C= (M,V) = (N ~ M) or (N C= V) .   *** Containment definition\n  eq [set12]: (N, M, U) C= V = (N C= V) and (M, U) C= (V \\ N) .  *** Extended containment definition\n\n  eq [set13]: N in U = N C= U .              *** Membership relation \n\n  eq [set17]: mt ~ U = U C= mt .             *** Equality with empty multiset\n  eq [set18]: N, K, U ~ V = ((N, K, U) C= V) and (V C= (N, K, U)) .  *** Equality definition for multisets\n\n  eq [set15]: mt /\\ V = mt .                  *** Intersection with empty multiset\n  eq [set16]: (N, U) /\\ V = if (N in V) then N, (U /\\ (V \\ N)) else U /\\ V fi .  *** Intersection defining elements present in both sets \n\n  eq [set17]: rem(N, mt) = mt .               *** Removing N from empty multiset yields empty multiset\n  eq [set18]: rem(N, (M, U)) = if (N ~ M) then rem(N, U) else M, (rem(N, U)) fi .  *** Remove N from multiset\n\n  eq [set19]: | mt | = 0 .                     *** Cardinality of empty multiset is zero\n  eq [set20]: | N, U | = s(| U |) .            *** Cardinality counts occurrences\n\n  eq [set21]: [ mt ] = 0 .                     *** Number of distinct elements in empty multiset is zero\n  eq [set22]: [ N, U ] = s([ rem(N, U) ]) .   *** Counts distinct elements in U excluding N\nendfm\n\n---- The use of if-then-else results in a bunch of Continuation-Passing Style (CPS) transformations\n---- that do not lead to natural equations. For example, the equations generated in the comments\n---- after the MODULE can be complex and may not yield useful outcomes in the context of multisets.\n---- The consistent challenge with joinability during orientation of equations is noted.\n\neof\n\n-- Test Cases for validating the behavior of Multisets\nred 5 ~ 12 .                   *** should be false\nred 15 ~ 15 .                  *** should be true\n\n-- Test cases for multiset operations\nred (3,3,4,4,4,2,2,9) \\ (3,3,3,4,2,7) .  *** should be 2,4,4,9\nred (3,3,4,4,2,2,9) C= (3,3,3,4,2,7) .  *** should be false\nred (3,3,4,4,2,2,9) C= (3,3,3,4,4,2,2,2,7,9) .  *** should be true\nred 3 in (3,3,4,4,7) .                  *** should be true\nred 9 in (3,3,4,4,7) .                  *** should be false\nred (3,3,4,4,4,2,2,7) ~ (3,3,3,4,2,7) .  *** should be false\nred (3,3,3,4,2,2,7) ~ (3,3,3,4,2,2,7) .  *** should be true\nred (3,3,3,4,4,4,2,2,7,9) /\\ (3,3,3,3,4,4,2,7,7) . *** should be 2,3,3,3,4,4,7\nred rem(2,(3,3,2,2,2,4,4,4)) .           *** should be 3,3,4,4,4\nred | 3,3,4,4,4,2,2,9 | .                *** should be 8\nred [ 3,3,4,4,4,2,2,9 ] .                *** should be 4"
    },
    {
        "file": "MAUDE-1/hf-sets.maude",
        "logic": "---\n\n### Protocol Description: HF-SETS\n\n**Purpose**: The `HF-SETS` module defines a formal framework for manipulating sets and their properties in a way that supports algebraic operations, particularly in the context of set theory.\n\n#### Components\n\n1. **Sorts**:\n   - **Magma**: A general term for a set equipped with a binary operation.\n   - **Set**: A specific type of Magma that represents a collection of elements.\n\n2. **Operations**:\n   - **Binary Operations**: Defined for `Magma`, allowing for the construction of ordered pairs.\n   - **Set Constructor**: `{}` denotes the empty set, and `{M}` creates a singleton set from an element `M`.\n\n3. **Equations**:\n   - **Idempotent Law**: `S U S = S` (union of a set with itself is the set).\n   - **Membership**: Defines whether an element belongs to a set using `_in_`.\n   - **Set Equality**: Two sets are equal if they contain the same elements.\n   - **Set Containment**: A set is contained within another if all its elements are also in the other set.\n   - **Union**: The union operation combines elements from two sets.\n   - **Powerset**: The operation `P` generates the powerset of a given set, which includes all subsets.\n   - **Augmentation**: Augments a set with an additional element, creating new subsets.\n   - **Intersection**: The intersection of two sets is defined along with conditions for checking membership.\n\n4. **Critical Pairs**:\n   - The module includes critical pairs that must be checked for joinability to ensure that the definitions are coherent and do not lead to inconsistencies.\n\n5. **Extending the Module**:\n   - The `HF-SETS-1`, `HF-SETS-2`, and `HF-SETS-3` modules build upon `HF-SETS` by adding new equations that address identified critical pairs, ensuring properties such as commutativity and associativity are preserved across operations.\n\n#### Key Properties\n- **Associativity**: Operations such as union and intersection are associative, meaning the grouping of the operation does not affect the result.\n- **Commutativity**: The order in which sets are combined does not change the outcome (e.g., `S U T = T U S`).\n- **Closure**: The operations defined ensure that the resulting sets remain within the defined sort of `Set`.\n\n#### Goals\n- To provide a clear and formal framework for reasoning about sets and their relationships.\n- To ensure that all operations and properties defined are valid through rigorous algebraic proofs.\n\n### Conclusion\nThis description encapsulates the functionality and structure of the `HF-SETS` module in Maude. By following this outline, one can generate a corresponding Maude file that defines a coherent and robust set theory framework suitable for further analysis and computation.\n\n---",
        "code": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .\n    op {_} : Magma -> Set [ctor] .\n    op {} : -> Set [ctor] .\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .\n    eq [12]: S in {S'} = S ~ S' .\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .\n\n    op _~_ : Set Set -> Bool .      *** set equality\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .\n\n    op _<=_ : Set Set -> Bool .     *** set containment\n    eq [31]: {} <= S = true .\n    eq [32]: {M} <= S = M in S .\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union\n    eq [41]: S U {} = S .\n    eq [42]: {M} U {M'} = {M,M'} .\n    eq [43]: S U {M} U {M'} = S U {M, M'} .\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset\n    eq [51]: P({}) = {{}} .\n    eq [52]: P({S}) = {{},{S}} .\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .\n\n    op augment : Set Set -> Set .\n    eq [61]: augment({}, T) = {} .\n    eq [62]: augment({S}, T) = {{T} U S} .\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .\n\n    op _&_ : Set Set -> Set .       *** intersection\n    eq [71]: {} & S = {} .\n   ceq [72]: {S} & S' = {S} if S in S' = true .\n   ceq [73]: {S} & S' = {} if S in S' = false .\n   ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .\n   ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)",
        "codenote": "set include BOOL off .\n\n  fmod HF-SETS is\n    protecting BOOL-OPS .\n    sorts Magma Set .\n    subsort Set < Magma .\n    \n    op _,_ : Magma Magma -> Magma [ctor assoc comm] .  *** constructor for pairs in Magma, associative and commutative\n    op {_} : Magma -> Set [ctor] .                     *** singleton set constructor\n    op {} : -> Set [ctor] .                            *** empty set constructor\n\n    vars M M' : Magma .              vars S S' T : Set .\n\n ----   eq M, M, M' = M, M' . ---- the MFE completes for ACU coherence\n    eq [01]: M, M = M .                          *** idempotency of set elements\n\n    op _in_ : Magma Set -> Bool .   *** set membership for several elements\n    eq [11]: M in {} = false .                   *** an element cannot be in the empty set\n    eq [12]: S in {S'} = S ~ S' .                *** equality check for singletons\n    eq [13]: S in {S', M} = (S ~ S') or (S in {M}) .  *** membership allows for alternative checks\n    eq [14]: S, M in {M'} = (S in {M'}) and (M in {M'}) .  *** both elements must be in the same set\n\n    op _~_ : Set Set -> Bool .      *** set equality check\n    eq [21]: S ~ S' = (S <= S') and (S' <= S) .       *** two sets are equal if they contain each other\n\n    op _<=_ : Set Set -> Bool .     *** set containment relation\n    eq [31]: {} <= S = true .                    *** the empty set is contained in any set\n    eq [32]: {M} <= S = M in S .                 *** a singleton set is contained in a set if its element is in that set\n\n    op _U_ : Set Set -> Set [assoc comm] .   *** union operation on sets\n    eq [41]: S U {} = S .                       *** union with the empty set yields the original set\n    eq [42]: {M} U {M'} = {M,M'} .              *** union of two singletons produces a set with both elements\n    eq [43]: S U {M} U {M'} = S U {M, M'} .     *** union is associative\n\n----    eq [15]: T U S U S = T U S . ---- the MFE completes for ACU coherence\n\n    op P : Set -> Set .          *** powerset operation\n    eq [51]: P({}) = {{}} .       *** powerset of the empty set is the set containing the empty set\n    eq [52]: P({S}) = {{},{S}} .  *** powerset of a singleton set includes the empty set and the singleton itself\n    eq [53]: P({S, M}) = P({M}) U augment(P({M}), S) .  *** powerset of a two-element set based on singletons\n\n    op augment : Set Set -> Set .         *** augmentation operation for sets\n    eq [61]: augment({}, T) = {} .                      *** augmenting an empty set yields an empty set\n    eq [62]: augment({S}, T) = {{T} U S} .              *** augmenting a singleton set produces a set with T added to S\n    eq [63]: augment({M, M'}, T) = augment({M}, T) U augment({M'}, T) .  *** distributive property of augmentation\n\n    op _&_ : Set Set -> Set .       *** intersection operation on sets\n    eq [71]: {} & S = {} .                           *** intersection with the empty set yields the empty set\n    ceq [72]: {S} & S' = {S} if S in S' = true .     *** condensing intersection elements\n    ceq [73]: {S} & S' = {} if S in S' = false .    *** empty intersection if not contained\n    ceq [74]: {S, M} & S' = {S} U ({M} & S') if S in S' = true .  *** intersection of a set with union containing relevant elements\n    ceq [75]: {S, M} & S' = {M} & S' if S in S' = false .  *** contingent intersection depending on membership\n  endfm\n\n---(\nChurch-Rosser check for HF-SETS\nThe following critical pairs must be proved joinable:\n  cp HF-SETS100 for 01 and 63\n    augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@3:Magma},@6:Set)U augment({\n    @4:Magma},@6:Set)U augment({@5:Magma},@6:Set)\n    = augment({@1:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({@2:Magma},@6:Set)U augment({\n    @3:Magma},@6:Set)U augment({@4:Magma},@6:Set)U augment({@5:Magma},@6:Set).\n  cp HF-SETS4 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),@1:Set),\n    @2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@2:Set)U augment(P({@3:Magma})U augment(P({@3:Magma}),\n    @2:Set),@1:Set).\n  cp HF-SETS46 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS53 for 01 and 63\n    augment({@1:Magma},@2:Set)\n    = augment({@1:Magma},@2:Set)U augment({@1:Magma},@2:Set).\n  cp HF-SETS54 for 01 and 63\n    augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set)\n    = augment({@1:Magma},@3:Set)U augment({@1:Magma},@3:Set)U augment({@2:Magma},@3:Set).\n  cp HF-SETS57 for 01 and 63\n    augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@3:Magma},@4:Set)\n    = augment({@1:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({@2:Magma},@4:Set)U augment({\n    @3:Magma},@4:Set).\n  cp HF-SETS95 for 01 and 63\n    augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({@3:Magma},@5:Set)U augment({\n    @4:Magma},@5:Set)\n    = augment({@1:Magma},@5:Set)U augment({@1:Magma},@5:Set)U augment({@2:Magma},@5:Set)U augment({\n    @3:Magma},@5:Set)U augment({@4:Magma},@5:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cp HF-SETS100, for equations 01 and 63, cannot be further reduced because\n---- because there is no idempotency equation on sets. Same for cps HF-SETS53,\n---- HF-SETS54, HF-SETS57, and HF-SETS95.\n\nfmod HF-SETS-1 is\n  pr HF-SETS .\n  var S : Set .\n  eq [44]: S U S = S .  *** idempotency of union\nendfm\n\n---(\nrewrites: 914745 in 2708ms cpu (2773ms real) (337776 rewrites/second)\nChurch-Rosser check for HF-SETS-1\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-1211 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(P({@1:Magma})U augment(P({@1:Magma}),\n    @2:Set),@2:Set).\n  cp HF-SETS-14 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- cps HF-SETS-1211 and HF-SETS-14 suggest the need of the following equation\n----    eq augment(S U S', T) = augment(S, T) U augment(S', T) .\n\nfmod HF-SETS-2 is\n  pr HF-SETS-1 .\n  vars S S' T : Set .\n  eq [64]: augment(S U S', T) = augment(S, T) U augment(S', T) .  *** distributive property of augmentation\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-2\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-2261 for 01 and 53\n    P({@1:Magma})U augment(P({@1:Magma}),@2:Set)\n    = P({@1:Magma})U augment(P({@1:Magma}),@2:Set)U augment(augment(P({@1:Magma}),@2:Set),@2:Set).\n  cp HF-SETS-24 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- The first critical pair suggests the need of the equation\n----    eq augment(augment(S, T), T) = augment(S, T) .\n\nfmod HF-SETS-3 is\n  pr HF-SETS-2 .\n  vars S T : Set .\n  eq [65]: augment(augment(S, T), T) = augment(S, T) .  *** idempotent property of augmentation\nendfm\n\n---(\nChurch-Rosser check for HF-SETS-3\nThe following critical pairs must be proved joinable:\n  cp HF-SETS-34 for 53 and 53\n    P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@1:Set),@2:Set)\n    = P({@3:Magma})U augment(P({@3:Magma}),@1:Set)U augment(P({@3:Magma}),@2:Set)U augment(augment(P({\n    @3:Magma}),@2:Set),@1:Set).\n\tThe module is sort-decreasing.\n)\n\n---- We are left with this critical pair, which I don't see how to eliminate.\n----\n---- The specification seems however ground confluent, which can be proved by showing\n---- the following joinability proof obligation\n----\n----   augment(augment(S, S'), T) \\|/  augment(augment(S, T), S')\n----\n---- By using the chain theorem, once proven this proof obligation, we could conclude\n---- the ground confluence of the original specification by proving the joinability\n---- of the equations added:\n----\n---- S U S \\|/ S\n---- augment(S U S', T) \\|/ augment(S, T) U augment(S', T)\n---- augment(augment(S, T), T) \\|/ augment(S, T)"
    },
    {
        "file": "MAUDE-1/Carlsen_Secret_Key_Initiator.maude",
        "logic": "---\n\n### Carlsen's Secret Key Initiator Protocol\n\n**Overview:**\nCarlsen's Secret Key Initiator Protocol is a cryptographic protocol that facilitates secure communication between two parties (Alice and Bob) with the involvement of a server. The protocol employs a secret key mechanism, nonce values, and session keys to ensure the confidentiality and integrity of the messages exchanged.\n\n**Participants:**\n1. **Alice (A)** - The initiator of the communication.\n2. **Bob (B)** - The responder who receives messages from Alice.\n3. **Server (S)** - An entity that assists in the generation and distribution of keys.\n\n**Key Concepts:**\n1. **Nonce (N)** - A unique value generated for each session to prevent replay attacks.\n2. **Master Key (MKey)** - A long-term key shared between a participant and the server.\n3. **Session Key (SesKey)** - A temporary key generated for each session, used to encrypt messages between Alice and Bob.\n4. **Encryption (e)** and **Decryption (d)** - Functions used to secure and retrieve messages using keys.\n\n**Protocol Steps:**\n1. **Key Generation:** \n   - Alice generates a nonce `n(A, r)` where `A` is Alice's identifier and `r` is a fresh value to ensure uniqueness.\n   - Alice encrypts the nonce along with her identity and the session key `SK` using her master key with Bob's identity.\n\n2. **Message Exchange:**\n   - Alice sends an encrypted message containing the nonce, session key, and Bob\u2019s identity to Bob.\n   - Bob receives the message, decrypts it using his master key, and can respond with his own nonce and session key.\n\n3. **Server Role:**\n   - The server is responsible for facilitating the key exchange by providing keys to both Alice and Bob as needed.\n   - The server also encrypts the session keys before sending them to the respective parties.\n\n**Strands of the Protocol:**\n- **Alice's Strand:**\n  - Sends an initial message to Bob with an encrypted session key and nonce.\n  - Receives Bob's response encrypted with the session key.\n\n- **Bob's Strand:**\n  - Receives Alice's initial message and decrypts it using his master key.\n  - Sends back a response to Alice confirming the session.\n\n- **Server's Strand:**\n  - Facilitates the key exchange by sending encrypted session keys to both parties.\n\n**Security Goals:**\n- Confidentiality: Ensure that only the intended recipient can read the messages.\n- Integrity: Ensure that the messages are not altered during transmission.\n- Authentication: Confirm the identities of the communicating parties.\n\n**Conclusion:**\nCarlsen's Secret Key Initiator Protocol is designed to establish a secure communication channel between two participants using cryptographic techniques. The involvement of a server enhances the security of the key exchange process, making it robust against various attacks.\n\n---",
        "code": "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName .\n\n  --- Server name\n  op s : ->  SName . \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] .\n \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] .\n\n  ---encrypt\n  op e : Key Msg -> Msg [frozen] .\n  op d : Key Msg -> Msg [frozen] .\n\n  --- successor\n  op p : Msg -> Msg [frozen] .\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] .\n eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . \n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName .  \n  var r r' r'' r''' r# r## r1 rM : Fresh .\n  vars TS NA NMA NB NMB NMS NB1 : Nonce .\n  vars M1 M2 MA MB MS N M : Msg . \n  var K : Key .\n  var SK : Sessionkey .  \n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & \n     :: nil :: [ nil | +(s), nil ] &\n     :: nil :: [ nil | -(M), +(p(M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] &\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] &\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] &\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] &\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  &\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n   = :: r ::\n     [ nil | +(A ; n(A,r)),\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1),\n             +(e(SK , NB1)), \n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA),\n             +(A ; NA ; B ; n(B,r)),\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA),\n             +(MA ; e(SK, NA) ; n(B,r1)),\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB),\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))), \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA),\n            +(a ; NA ; b ; n(b,r)),\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA),\n            +(MA ; e(SK, NA) ; n(b,r1)),\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm",
        "codenote": "----  Carlsen's Secret Key Initiator Protocol\n\n---------------------------------------------------\n--- We modify only the relevant MAUDE-NPA modules \n---------------------------------------------------\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  --- Declaring all sorts used in the protocol and their relationships\n  sorts  UName SName Name Key Nonce  Masterkey Sessionkey .\n  subsort Name Nonce  Key < Msg .\n  subsort Masterkey  Sessionkey < Key .\n  subsort SName UName < Name .\n  subsort Name < Public . --- This is quite relevant and necessary\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .  --- Generating a nonce from a username and freshness\n  op mr : Name Fresh -> Nonce [frozen] . --- Nonce, run identifier\n\n  --- User names\n  ops a b i : -> UName . --- Declaring Usernames for Alice, Bob, and a third entity\n\n  --- Server name\n  op s : ->  SName . --- Declaring the Server name \n\n  --- MKey\n  op mkey : Name Name -> Masterkey [frozen comm] . --- Masterkey generation between two users\n  \n  --- Seskey\n  op seskey : Name Name Nonce -> Sessionkey [frozen] . --- Session key generation using names and nonce\n\n  --- Encryption and Decryption operators\n  op e : Key Msg -> Msg [frozen] . --- Encryption operation\n  op d : Key Msg -> Msg [frozen] . --- Decryption operation\n\n  --- Successor operation\n  op p : Msg -> Msg [frozen] . --- Next message successor in the protocol flow\n\n  --- Concatenation\n  op _;_ : Msg Msg -> Msg [frozen gather (e E)] . --- Message concatenation operation\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [variant] . --- Associativity of encryption and decryption\n  eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [variant] . --- Inverse property of encryption and decryption\n\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS . \n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  var A B S  : UName . --- Variables for Users\n  var r r' r'' r''' r# r## r1 rM : Fresh . --- Freshness variables for nonces\n  vars TS NA NMA NB NMB NMS NB1 : Nonce . --- Nonce variables \n  vars M1 M2 MA MB MS N M : Msg . --- Message variables\n  var K : Key . --- Key variable for encryption/decryption\n  var SK : Sessionkey . --- Session key variable for secure communication\n\n  eq STRANDS-DOLEVYAO\n  =  :: nil :: [ nil | +(A), nil ]  & --- Initial state of Alice's strand\n     :: nil :: [ nil | +(s), nil ] & --- Initial state of Server's strand\n     :: nil :: [ nil | -(M), +(p(M)), nil ] & --- Sending a message M and appointing a successor\n     :: nil :: [ nil | -(K), -(M), +(d(K,M)), nil ] & --- Sending key K and message M, then receiving decrypted message\n     :: nil :: [ nil | -(K), -(M), +(e(K,M)), nil ] & --- Sending key K and message M, then receiving encrypted message\n     :: nil :: [ nil | -(N), -(M), +(M ; N) , nil ] & --- Concatenating nonces and messages\n     :: nil :: [ nil | -(M ; N), +(M) , nil ] & --- Separate nonces from the concatenated messages\n     :: nil :: [ nil | -(M ; N), +(N) , nil ] & --- Separate messages from the concatenated nonces\n     :: nil :: [ nil | +(mkey(i,A)), nil ]  & --- Utilizing master key for Alice\n     :: nil :: [ nil | +(mkey(i,s)), nil ] \n  [nonexec] . \n\n  eq STRANDS-PROTOCOL\n  --- Alice's Strand. \n  = :: r ::\n     [ nil | +(A ; n(A,r)), --- Sending Alice's name and nonce\n             -(e(mkey(A,s) , n(A,r) ; B ; SK) ; e(SK , n(A,r)) ; NB1), --- Sending message with encryption\n             +(e(SK , NB1)), --- Receiving encrypted response\n             nil ]\n   &\n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil | -(A ; NA), --- Receiving Alice's name and nonce\n             +(A ; NA ; B ; n(B,r)), --- Sending message with nonce\n             -(e(mkey(B,s) , SK ; n(B,r) ; A) ; MA), --- Sending encrypted message to server\n             +(MA ; e(SK, NA) ; n(B,r1)), --- Returning encrypted response to Alice\n     \t     -(e(SK , n(B,r1))), \n             nil ] \n   & \n     :: r ::\n     --- Server's Strand \n    [ nil | -(A ; NA ; B ; NB), --- Server receives identities and nonces\n    \t    +(  e(mkey(B,s), seskey(A, B, n(S,r)) ; NB ; A) \n              ; e(mkey(A,s), NA ; B ; seskey(A, B, n(S,r)))), --- Server responds with session keys \n            nil]\n \n  [nonexec] .\n\neq ATTACK-STATE(0) =\n   --- A normal execution of the protocol \n     :: r , r1 :: \n   --- Bob's Strand.\n     [ nil, -(a ; NA), --- Bob receives Alice's identity and nonce\n            +(a ; NA ; b ; n(b,r)), --- Bob sends nonce and identities\n            -(e(mkey(b,s) , SK ; n(b,r) ; a) ; MA), --- Send encrypted message to server\n            +(MA ; e(SK, NA) ; n(b,r1)), --- Bob receives a message and nonce\n     \t    -(e(SK , n(b,r1))) | nil ] \n     || empty\n     || nil\n     || nil\n     || nil\n   [nonexec] . \n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nfmod MAUDE-NPA is\n  protecting GENERIC-TOOLS .\nendfm"
    },
    {
        "file": "MAUDE-1/ltv-F-tmn.maude",
        "logic": "### Protocol Description\n\n**Protocol Name:** LTV09 - Protocol F\n\n**Principals:**\n- Alice (A)\n- Bob (B)\n- Server (S)\n- Intruder (I)\n\n**Keys:**\n- \\( KA \\): Fresh symmetric key for Alice\n- \\( KB \\): Fresh symmetric key for Bob\n- \\( PKS \\): Public key of the server\n\n### Protocol Scheme\nThe protocol consists of the following message exchanges:\n\n1. **Step 1:** Alice (A) sends a message to the Server (S) containing Bob's identity (B) and her fresh symmetric key \\( KA \\) encrypted with the Server's public key \\( PKS \\):\n   \\[\n   A \\rightarrow S : B, \\{KA\\}_{PKS}\n   \\]\n\n2. **Step 2:** The Server (S) responds to Bob (B), revealing Alice's identity:\n   \\[\n   S \\rightarrow B : A\n   \\]\n\n3. **Step 3:** Bob (B) sends a message to the Server (S) containing Alice's identity (A) and his fresh symmetric key \\( KB \\) encrypted with the Server's public key \\( PKS \\):\n   \\[\n   B \\rightarrow S : A, \\{KB\\}_{PKS}\n   \\]\n\n4. **Step 4:** Finally, the Server (S) responds to Alice (A) with Bob's identity (B) and the result of the XOR operation on Bob's and Alice's keys \\( KB * KA \\):\n   \\[\n   S \\rightarrow A : B, KB * KA\n   \\]\n\n### Attack Description\nAn intruder (I) can exploit the protocol as follows:\n\n1. **Step 1:** The intruder intercepts the message sent from Alice (A) to the Server (S):\n   \\[\n   A \\rightarrow S : B, \\{KA\\}_{PKS}\n   \\]\n\n2. **Step 2:** The Server (S) responds to the intruder (I) instead of Bob (B), revealing Alice's identity:\n   \\[\n   S \\rightarrow I : A\n   \\]\n\n3. **Step 3:** The intruder (I), impersonating Bob (B), sends a message to the Server (S) containing Alice's identity (A) and his own symmetric key \\( KI \\) encrypted with the Server's public key \\( PKS \\):\n   \\[\n   I(B) \\rightarrow S : A, \\{KI\\}_{PKS}\n   \\]\n\n4. **Step 4:** The Server (S) responds to the intruder (I) with Bob's identity (B) and the result of the XOR operation on the keys \\( KB * KA \\):\n   \\[\n   S \\rightarrow I : B, KI * KA\n   \\]\n\nIn this way, the intruder can derive \\( KA \\) by computing:\n\\[\nKA = (KI * KA) * KI\n\\]\nThus, the intruder gains access to Alice's symmetric key \\( KA \\) and can transmit the message containing \\( B \\) and \\( KI * KA \\) back to Alice.\n\n### Corresponding Maude File Generation\nBased on the above description of the protocol and the attack, one can create a Maude file using the structure provided in the Maude examples. The file will define the sorts, operations, and strands according to the flows outlined for both the normal protocol execution and the attack scenario. \n\nThe operations and rules should reflect the encryption and the specific identifiers used in the messages, ensuring that the protocol's logic is accurately represented in the Maude-NPA format. Each step in the protocol and the attack must be coded to simulate the interactions and the potential vulnerabilities of the protocol effectively.",
        "code": "***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals\nKA,KB: fresh symmetric keys \nPKS: public key of the server\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS\n2. S \u2212-> B : A\n3. B \u2212-> S : A,{KB}PKS\n4. S \u2212-> A : B, KB * KA\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS \n2. S \u2212-> I : A\n3. I(B) \u2212-> S : A,{KI}PKS\n4. S \u2212-> I : B, KI * KA\nIn the first step, A starts a normal session with B. In the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. Finally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI . Finally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n\nop pair : Msg Msg -> Msg [frozen] .\n*** encryption here is thus that only the server can decrypt it!\nop enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * X:Msg * Y:Msg = Y:Msg [variant] .\n  eq X:Msg * null = X:Msg [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N N' NA NB : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA .",
        "codenote": "***(\nLTV09 paper - protocol F - TMN\nNotations: \nA, B, S : principals         --- A for Alice, B for Bob, S for Server\nKA, KB: fresh symmetric keys  --- KA and KB are fresh symmetric keys generated during the protocol\nPKS: public key of the server  --- PKS is the public key used to encrypt messages for Server\n\nProtocol scheme:\n1. A \u2212-> S : B,{KA}PKS        --- A sends a request to Server S to communicate with Bob using a key KA encrypted with PKS\n2. S \u2212-> B : A                --- Server S informs Bob about Alice\n3. B \u2212-> S : A,{KB}PKS        --- Bob sends a message back to Server S with his own key KB encrypted with PKS\n4. S \u2212-> A : B, KB * KA       --- Server S responds to Alice with Bob's identity and a combined key of Bob's and Alice's keys\n\n----\nthe attack:\n1. A \u2212-> S : B,{KA}PKS        --- A initiates the communication with Server S\n2. S \u2212-> I : A                --- Intruder I intercepts the message from S to A\n3. I(B) \u2212-> S : A,{KI}PKS     --- Intruder I impersonates Bob and sends his own key KI to Server S, pretending to be Bob\n4. S \u2212-> I : B, KI * KA       --- Server S responds to I with Bob's identity and the combined key based on keys KA and KI\n\nIn the first step, A starts a normal session with B. \nIn the second step, I intercepts the message sent by S and then, in step 3, he impersonates B and sends his own symmetric key to the server. \nFinally, the intruder intercepts B and KI \u2295 KA and as he knows KI, he can find KA by computing (KI \u2295 KA) \u2295 KI. \nFinally, I can transmit B, KI \u2295 KA to A.\n\nCODE BELOW IS FROM ANOTHER FILE AS TEMPLATE!!! CHANGE everything!\n)***\n\nfmod PROTOCOL-EXAMPLE-SYMBOLS is\n  --- Importing sorts Msg, Fresh, Public, and GhostData\n  protecting DEFINITION-PROTOCOL-RULES .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the syntax of your protocol\n  --- Notes:\n  --- * Sort Msg and Fresh are special and imported\n  --- * Every sort must be a subsort of Msg\n  --- * No sort can be a supersort of Msg\n  ----------------------------------------------------------\n\n  --- Sort Information \n  sorts Name Nonce Null .\n  subsort Name Nonce Null < Msg .\n  subsort Name < Public .\n\nop pair : Msg Msg -> Msg [frozen] .\n*** encryption here is thus that only the server can decrypt it!\nop enc : Msg -> Msg [frozen] .\n\n  --- Nonce operator\n  op n : Name Fresh -> Nonce [frozen] .\n  \n  --- Principals\n  op a : -> Name . --- Alice\n  op b : -> Name . --- Bob\n  op i : -> Name . --- Intruder\n  \n  --- XOR operator\n  op _*_ : Msg Msg -> Msg [frozen assoc comm] .\n  op null : -> Msg .\n\nendfm\n\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  \n  ----------------------------------------------------------\n  --- Overwrite this module with the algebraic properties \n  --- of your protocol\n  ----------------------------------------------------------\n\n  *** Exclusive or properties\n  eq X:Msg * X:Msg = null [variant] .\n  eq X:Msg * X:Msg * Y:Msg = Y:Msg [variant] .\n  eq X:Msg * null = X:Msg [variant] .\nendfm\n\nfmod PROTOCOL-SPECIFICATION is\n  protecting PROTOCOL-EXAMPLE-SYMBOLS .\n  protecting DEFINITION-PROTOCOL-RULES .\n  protecting DEFINITION-CONSTRAINTS-INPUT .\n\n  ----------------------------------------------------------\n  --- Overwrite this module with the strands \n  --- of your protocol\n  ----------------------------------------------------------\n  \n  vars X Y  : Msg .\n  vars r r' : Fresh .\n  vars N N' NA NB : Nonce .\n  vars A B C : Name .\n\n  eq STRANDS-DOLEVYAO\n   = :: nil :: [ nil | -(X), -(Y), +(X * Y), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(X), nil ] &\n     :: nil :: [ nil | -(pair(X,Y)), +(Y), nil ] &\n     :: nil :: [ nil | -(X), -(Y), +(pair(X,Y)), nil ] &\n     :: r   :: [ nil | +(n(i, r)), nil ] &\n     :: nil :: [ nil | -(N), +(enc(N)), nil ] &\n     :: nil :: [ nil | +(A), nil ] &\n     :: nil :: [ nil | +(null), nil ]\n  [nonexec] .\n\n  eq STRANDS-PROTOCOL\n  = *** A\n    :: r :: \n    [nil | +(pair(B, enc(n(A,r)))),\n           -(pair(B, n(A,r) * NB)), \n           nil] \n    &\n    *** B\n    :: r' :: \n    [nil | -(A),\n           +(pair(A, enc(n(B,r')))),\n           nil] \n    &\n    *** S\n    :: nil ::\n    [nil | -(pair(B, enc(NA))),\n           +(A),\n           -(pair(A, enc(NB))),\n           +(pair(B, NA * NB)), \n           nil] \n    \n  [nonexec] .\n\n  eq ATTACK-STATE(0)\n   = \n    :: r :: \n    [nil,  +(pair(b, enc(n(a,r)))),\n           -(pair(b, n(a,r) * NB)) | nil]\n     || n(a,r) inI, empty\n     || nil\n     || nil\n     || nil\n  [nonexec] .\n\n  ----------------------------------------------------------\n  --- Grammars for co-invariant generation\n  --- Keyword GENERATED-GRAMMARS -> seed terms for grammar generation \n  --- (if not, use automaticly generated seed terms)\n  --- Keyword EXTRA-GRAMMARS -> seed terms for grammar generation \n  --- apart of automaticly generated ones\n  --- Format of seed terms (grl Conditions => Term inL .) ! S1/S2\n  ----------------------------------------------------------\n\nendfm\n\n--- THIS HAS TO BE THE LAST LOADED MODULE !!!!\nselect MAUDE-NPA ."
    }
]