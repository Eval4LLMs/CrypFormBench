[
    {
        "file": "HLPSL-1/AKS.hlpsl",
        "logic": "### Protocol Description\n\nThe protocol is structured into three roles:\n\n1. **Role OBU1**: \n   - OBU1 initiates the protocol by sending a message containing a new identifier (A1), a public key (Q1), and a Message Authentication Code (MAC) derived from the identities of both parties and the public key.\n   - Upon receiving a message from OBU2 containing a challenge (C1), a public key (Q2), and a hash (H21), OBU1 computes a response using its local secret and sends back a hash (H12) to OBU2.\n   - It maintains security by ensuring that both parties can verify the authenticity of the messages exchanged and keeps secrets (A1, R1) within the context of the protocol.\n\n2. **Role OBU2**:\n   - OBU2 waits for a message from OBU1 that includes identifiers and a MAC for validation. It then responds by generating its own secret (R2) and sending a challenge back to OBU1 along with a public key (Q2) and a hash (H21).\n   - OBU2 ensures that the responses are valid by checking the integrity of the messages using hashes derived from the exchanged secrets and identifiers.\n   - It also makes sure to establish confidentiality through the generation of new keys and secrets (A2, R2).\n\n3. **Role SN**:\n   - The Sensor Node (SN) is responsible for verifying the identities of OBU1 and OBU2. It checks the received messages for integrity and authenticity by computing hashes.\n   - Upon receiving an initial message, it generates its own secrets (R1, R2) and sends a response back to both OBU1 and OBU2, thus facilitating the secure exchange of information.\n   - SN also keeps track of the shared secrets, ensuring they are securely maintained throughout the protocol.\n\n### Communication Channels\n- Each role communicates over distinct channels (SND for sending and RCV for receiving messages), ensuring that messages are directed appropriately between the parties.\n\n### Security Goals\nThe protocol aims to achieve the following security goals:\n- **Secrecy**: Ensuring that the secrets R1, R2, A1, and A2 remain confidential and are only known to the legitimate participants.\n- **Authentication**: Validating the authenticity of messages exchanged between OBU1 and OBU2, specifically ensuring that the identities of the participants (o1_o2_h12) and the integrity of the SN's responses (s_o2_hs2) are verified.\n\n### Conclusion\nThis protocol is designed to provide a secure communication mechanism between OBU1 and OBU2 with the assistance of a trusted third party (SN). It employs cryptographic techniques such as hashing and public key operations to ensure confidentiality, integrity, and authentication of the exchanged messages.\n\n### Note\nWhen creating the corresponding HLPSL file based on this description, ensure that the roles, transitions, and messages are accurately reflected, maintaining the structure and logic outlined in the original HLPSL content.",
        "code": "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1',r1,{OBU1,OBU2,SN})\n\nend role\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,OBU2,o2_o1_h21,H21')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(OBU2,SN,s_o2_hs2,Hs2) /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2,P                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,SS,RO,RS : channel(dy)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,a1,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of a1\n  secrecy_of a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()",
        "codenote": "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,  // OBU1 and OBU2 are the agents involved, along with the network's Sensor Node (SN).\n  PID1,PID2,P                     : text,   // Protocol identifiers for OBU1, OBU2, and the shared message P.\n  H,PUF1                          : hash_func, // Hash function and PUF (Physically Unclonable Function) for OBU1.\n  SND,RCV                        : channel(dy)) // Channels for sending and receiving messages dynamically.\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,            // Current state of the OBU1 protocol.\n\tA1,C1        :text,           // Local variables for messages.\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message, // Message variables for exchanges.\n\tMAC        :hash(text.text.message), // Message authentication code for integrity.\n\tH21        :hash(text.message.message.text.text.message) // H21 hash for message verification.\n%%\tH12        :hash(message.text.text.message.message) // Uncommented hash for clarity.\n\n  init\n    State := 0 // Initial state of the protocol.\n\n  transition\n  \n  // Transition from state 0 to state 2 upon receiving a start message.\n  1. State = 0 /\\ RCV(start) =|> \n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1') /\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC') // Witness for OBU1 authenticity.\n  \n  // Transition from state 2 to state 4 upon receiving the C1 and Q2 messages.\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|> \n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1',r1,{OBU1,OBU2,SN}) // Response and secrecy declarations.\n\nend role\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent, // OBU2 agent concerned with communication integrity and secrecy.\n  PID2,P                         : text, // Protocol identifier for OBU2 and shared message P.\n  H,PUF2                         : hash_func, // Hash function and PUF for OBU2.\n  SND,RCV                        : channel(dy)) // Channels for OBU2.\nplayed_by OBU2 def=\n  \n  local\n    State        :nat, // Current state of the OBU2 protocol.\n\tC1,C2,PID1,A2        :text, // Variables for message handling.\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message, // Message-related variables.\n\tHs2        :hash(text.text.message.text.message.message), // Hs2 hash for OBU2 processing.\n\tH21        :hash(text.message.message.text.text.message) // H21 hash for message verification.\n%%\tH12        :hash(message.text.text.message.message) // Uncommented hash for clarity.\n\n  init\n    State := 0 // Initial state of the protocol.\n\n  transition\n  \n  // Initial message reception and hash calculation.\n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\ H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,OBU2,o2_o1_h21,H21') // Authentication witness for mutual confirmation.\n\n  // Final state transition with received H12 for confirmation of the exchange.\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2)) =|>\n     State' := 4 /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\ secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(OBU2,SN,s_o2_hs2,Hs2) /\\ request(OBU2,OBU1,o1_o2_h12,H12') // Securing and verifying secrets.\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent, // Sensor Node role for orchestrating communication between OBU1 and OBU2.\n  PID1,PID2,C1,C2,P               : text, // Protocol identifiers and shared message P.\n  H,PUF1,PUF2                    : hash_func, // Hash functions for OBU1 and OBU2.\n  SND,RCV                       : channel(dy)) // Communication channels.\nplayed_by SN def=\n  \n  local\n    State        :nat, // Current state of the Sensor Node protocol.\n\tPID1n,PID2n        :text, // Variables for incoming request identifiers.\n\tQ1,R1,R2,R2en         :message, // Variables for message and hash handling.\n\tMAC        :hash(text.text.message), // Hash for authenticity.\n\tHs2        :hash(text.text.message.text.message.message) // Hs2 hash for processing.\n\n\t\n  init\n    State := 1 // Initial state of the Sensor Node protocol.\n\n  transition\n  \n  // Step for receiving identifiers and hashing for validation.\n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) // Ensuring service requests are validated and secrets declared.\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent, // Main session role coordinating OBU1, OBU2, and SN.\n  PID1,PID2,C1,C2,P          : text, // Shared identifiers among the roles.\n  H,PUF1,PUF2                : hash_func) // Hash functions for the communication.\ndef=\n  local SO,SS,RO : channel(dy) // Local channels for inter-role communication.\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) // Composing roles for interaction.\n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,a1,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id, // Definitions for protocol operations.\n    obu1,obu2,sn        : agent, // Agent constants for simulation.\n    pid1,pid2,c1,c2,p   : text, // Shared identifiers.\n    h,puf1,puf2        : hash_func // Hash functions used in the protocol.\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h}  // Setting intruder knowledge base for security analysis.\n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) // Running the session with necessary parameters.\n\nend role\n\ngoal \n  secrecy_of r1 // Ensuring the secrecy of extracted value r1.\n  secrecy_of r2 // Ensuring the secrecy of extracted value r2.\n  secrecy_of a1 // Ensuring the secrecy of generated identifier a1.\n  secrecy_of a2 // Ensuring the secrecy of generated identifier a2.\n  authentication_on o1_o2_h12 // Authentication goal for H12 message.\n  authentication_on s_o2_hs2 // Authentication goal for Hs2 message.\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl",
        "logic": "---\n\n### Protocol Description: Mutual Authentication and Key Exchange Protocol\n\n#### Overview\nThe protocol facilitates a mutual authentication and secure key exchange between a user (U), a server (S), and a foreign agent (F). It employs symmetric and asymmetric cryptography, along with hash functions, to ensure the confidentiality and integrity of communications.\n\n#### Roles\n1. **User (U)**: Initiates the registration and authentication process with the server.\n2. **Server (S)**: Validates the user\u2019s credentials and facilitates the key exchange.\n3. **Foreign Agent (F)**: Monitors and potentially intercepts communications between U and S.\n\n#### Key Components\n- **Agents**: U, S, and F represent the user, server, and foreign agent respectively.\n- **Keys**:\n  - `Kus`, `Rus`, `Kas`: Symmetric keys shared among the user and server.\n  - `Ks`: A public key used by the server for encryption.\n- **Functions**:\n  - `H`: A hash function to ensure data integrity.\n  - `Mul`: A multiplicative function used in key exchange and authentication.\n- **Channels**: Channels (e.g., `SND`, `RCV`) are used for message transmission between agents.\n\n#### Protocol Phases\n1. **Registration Phase**:\n   - The user sends a `start` signal to initiate registration.\n   - The server responds by sending back a challenge based on the user\u2019s secret password, establishing shared secrets for further communications.\n\n2. **Mutual Authentication and Key Exchange Phase**:\n   - The user initiates the authentication process by sending a message containing a nonce (random number) and their identity.\n   - The server responds with its computed values using cryptographic functions, including a nonce and a signature.\n   - The user and server exchange messages to confirm their identities and derive session keys.\n\n3. **Foreign Agent Interaction**:\n   - The foreign agent can intercept and respond to the messages exchanged during the mutual authentication phase but is restricted from accessing certain secrets.\n\n#### Goals\n- **Secrecy**: Ensures that certain secret values (g1, g2, g3, g4, g5, g6) remain confidential.\n- **Authentication**: The protocol aims to verify the identities of both the user and the server (u_s_tim, s_u_b1mi).\n\n#### Conclusion\nThis protocol is designed to provide secure registration and mutual authentication using cryptographic techniques. It safeguards against unauthorized access and ensures that session keys are established securely between the user and the server, despite potential interception by a foreign agent.\n\n---",
        "code": "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ secret(SAim',g2,{U,S})\n\t\t   /\\ secret(SPWim',g3,{U})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ witness(U,S,u_s_tim,Tim')\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ secret(Nfp',g5,{U,S,F})\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()",
        "codenote": "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% This phase allows the user to register with the server by sending their SID and a secure password.\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n           % The user initiates the registration process\n\t\t   /\\ SPWim' := new()  % New password for the user\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))  % Secure association ID\n\t\t   /\\ SND({SIDim.SAim'}_Kus)  % Send SID and SA to the server encrypted with Kus\n\t\t   /\\ secret(SIDim,g1,{U,S})  % Establish secret knowledge of SIDim\n\t\t   /\\ secret(SAim',g2,{U,S})  % Establish secret knowledge of SAim'\n\t\t   /\\ secret(SPWim',g3,{U})  % Establish secret knowledge of SPWim'\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))  % Compute Bmi' for further authentication\n           % The server verifies the user's registration and responds with the computed value.\n\n% Mutual authentication and key exchange phase\n% This phase facilitates mutual authentication between the user and the server.\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n           % User starts mutual authentication with the server\n\t\t   /\\ Uim' := xor(Bmi,SAim)  % Compute a unique identification message for user\n\t\t   /\\ Aim' := new()  % New session key\n\t\t   /\\ Tim' := new()  % New timestamp for freshness\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks  % Create a commitment message\n\t\t   /\\ SND(Cim1'.Tim')  % Send commitment message to the server\n\t\t   /\\ witness(U,S,u_s_tim,Tim')  % Establish a witness for the timing\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))  % Derive the session key for the user\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')  % Request for mutual authentication confirmation\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% Server's role in user registration, verifying the SID and processing secured data.\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)  % Compute user identifier using SID\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))  % Compute Bmi for the user\n\t\t   /\\ SND({Bmi'}_Kus)  % Send back the computed Bmi encrypted with Kus\n\t\t   /\\ secret(Bmi',g4,{U,S})  % Establish secret knowledge of Bmi'\n\n% Mutual authentication and key exchange phase\n% Server responds to the user's authentication request with mutual confirmation.\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')  % Create new commitment message\n\t\t   /\\ B1mi' := new()  % New session identifier\n\t\t   /\\ Wmi' := Mul(B1mi'.G)  % Derive a fresh key\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')  % Compute Ymi from Nfp and Rim \n\t\t   %/\\ Dm = Signature of Sm with Ymi'  % Signature creation (commented for clarity)\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)  % Derive key for the session\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)  % Compute verification value\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus  % Message to send to user\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)  % Send signed message to the user\n\t\t   /\\ request(U,S,u_s_tim,Tim')  % User requests confirmation\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')  % Record witness for authentication\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication phase\n% The foreign agent participates in the authentication phase by relaying messages.\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()  % Generate a new nonce for freshness\n\t\t   /\\ Nfp1' := new()  % Generate a second nonce for further security\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')  % Compute a joint value from nonces\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas  % Create a committed message for the server\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')  % New commitment message\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')  % Send messages securely\n\t\t   /\\ secret(Nfp',g5,{U,S,F})  % Establish secret knowledge of Nfp'\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})  % Establish secret knowledge of Nfp1'\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)  % Send the authentication response back\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n          /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6  % Ensure secrecy of crucial parameters\n  authentication_on u_s_tim, s_u_b1mi  % Confirm mutual authentication between parties\n\nend goal"
    }
]