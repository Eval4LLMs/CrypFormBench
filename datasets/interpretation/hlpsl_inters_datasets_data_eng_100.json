[
    {
        "file": "HLPSL-1/AKS.hlpsl",
        "logic": "### Protocol Description\n\nThe protocol is structured into three roles:\n\n1. **Role OBU1**: \n   - OBU1 initiates the protocol by sending a message containing a new identifier (A1), a public key (Q1), and a Message Authentication Code (MAC) derived from the identities of both parties and the public key.\n   - Upon receiving a message from OBU2 containing a challenge (C1), a public key (Q2), and a hash (H21), OBU1 computes a response using its local secret and sends back a hash (H12) to OBU2.\n   - It maintains security by ensuring that both parties can verify the authenticity of the messages exchanged and keeps secrets (A1, R1) within the context of the protocol.\n\n2. **Role OBU2**:\n   - OBU2 waits for a message from OBU1 that includes identifiers and a MAC for validation. It then responds by generating its own secret (R2) and sending a challenge back to OBU1 along with a public key (Q2) and a hash (H21).\n   - OBU2 ensures that the responses are valid by checking the integrity of the messages using hashes derived from the exchanged secrets and identifiers.\n   - It also makes sure to establish confidentiality through the generation of new keys and secrets (A2, R2).\n\n3. **Role SN**:\n   - The Sensor Node (SN) is responsible for verifying the identities of OBU1 and OBU2. It checks the received messages for integrity and authenticity by computing hashes.\n   - Upon receiving an initial message, it generates its own secrets (R1, R2) and sends a response back to both OBU1 and OBU2, thus facilitating the secure exchange of information.\n   - SN also keeps track of the shared secrets, ensuring they are securely maintained throughout the protocol.\n\n### Communication Channels\n- Each role communicates over distinct channels (SND for sending and RCV for receiving messages), ensuring that messages are directed appropriately between the parties.\n\n### Security Goals\nThe protocol aims to achieve the following security goals:\n- **Secrecy**: Ensuring that the secrets R1, R2, A1, and A2 remain confidential and are only known to the legitimate participants.\n- **Authentication**: Validating the authenticity of messages exchanged between OBU1 and OBU2, specifically ensuring that the identities of the participants (o1_o2_h12) and the integrity of the SN's responses (s_o2_hs2) are verified.\n\n### Conclusion\nThis protocol is designed to provide a secure communication mechanism between OBU1 and OBU2 with the assistance of a trusted third party (SN). It employs cryptographic techniques such as hashing and public key operations to ensure confidentiality, integrity, and authentication of the exchanged messages.\n\n### Note\nWhen creating the corresponding HLPSL file based on this description, ensure that the roles, transitions, and messages are accurately reflected, maintaining the structure and logic outlined in the original HLPSL content.",
        "code": "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,P                      : text,\n  H,PUF1                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,\n\tA1,C1        :text,\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message,\n\tMAC        :hash(text.text.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(start) =|>\n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1')/\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC')\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|>\n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1',r1,{OBU1,OBU2,SN})\n\nend role\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent,\n  PID2,P                      : text,\n  H,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by OBU2 def=\n  \n  local\n    State        :nat,\n\tC1,C2,PID1,A2        :text,\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message,\n\tHs2        :hash(text.text.message.text.message.message),\n\tH21        :hash(text.message.message.text.text.message)\n%%\tH12        :hash(message.text.text.message.message)\n\n  init\n    State := 0\n\n  transition\n  \n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\  H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,OBU2,o2_o1_h21,H21')\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2))  =|>\n     State' := 4 /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(OBU2,SN,s_o2_hs2,Hs2) /\\ request(OBU2,OBU1,o1_o2_h12,H12')\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent,\n  PID1,PID2,C1,C2,P                   : text,\n  H,PUF1,PUF2                : hash_func,\n  SND,RCV                  : channel(dy))\nplayed_by SN def=\n  \n  local\n    State        :nat,\n\tPID1n,PID2n        :text,\n\tQ1,R1,R2,R2en         :message,\n\tMAC        :hash(text.text.message),\n\tHs2        :hash(text.text.message.text.message.message)\n\n\t\n  init\n    State := 1\n\n  transition\n  \n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN})\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent,\n  PID1,PID2,C1,C2,P          : text,\n  H,PUF1,PUF2                : hash_func)\ndef=\n  local SO,SS,RO,RS : channel(dy)\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) \n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,a1,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id,\n    obu1,obu2,sn        : agent,\n    pid1,pid2,c1,c2,p   : text,\n    h,puf1,puf2        : hash_func\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h} \n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) \n\nend role\n\ngoal \n  secrecy_of r1\n  secrecy_of r2\n  secrecy_of a1\n  secrecy_of a2\n  authentication_on o1_o2_h12\n  authentication_on s_o2_hs2\nend goal\n\nenvironment()",
        "codenote": "role role_OBU1(\n  OBU1,OBU2,SN                   : agent,  // OBU1 and OBU2 are the agents involved, along with the network's Sensor Node (SN).\n  PID1,PID2,P                     : text,   // Protocol identifiers for OBU1, OBU2, and the shared message P.\n  H,PUF1                          : hash_func, // Hash function and PUF (Physically Unclonable Function) for OBU1.\n  SND,RCV                        : channel(dy)) // Channels for sending and receiving messages dynamically.\nplayed_by OBU1 def=\n  \n  local\n    State        :nat,            // Current state of the OBU1 protocol.\n\tA1,C1        :text,           // Local variables for messages.\n\tH12,S,Q1,Q2,Q2en,Key,R1         :message, // Message variables for exchanges.\n\tMAC        :hash(text.text.message), // Message authentication code for integrity.\n\tH21        :hash(text.message.message.text.text.message) // H21 hash for message verification.\n%%\tH12        :hash(message.text.text.message.message) // Uncommented hash for clarity.\n\n  init\n    State := 0 // Initial state of the protocol.\n\n  transition\n  \n  // Transition from state 0 to state 2 upon receiving a start message.\n  1. State = 0 /\\ RCV(start) =|> \n     State' := 2 /\\ A1' := new() /\\ Q1' := exp(P,A1') /\\ MAC' := H(PID1.PID2.Q1')  /\\ SND(PID1.PID2.Q1'.MAC') \n\t             /\\ witness(OBU1,SN,o1_s_mac,MAC') // Witness for OBU1 authenticity.\n  \n  // Transition from state 2 to state 4 upon receiving the C1 and Q2 messages.\n  2. State = 2 /\\ RCV(C1'.Q2'.H21')  /\\ H21' = H(C1'.PUF1(C1').Q2'.PID1.PID2.Q1) =|> \n     State' := 4  /\\ R1' := PUF1(C1') /\\ Key' := exp(Q2',A1) /\\ H12' := H(R1'.PID1.PID2.Q2'.Key') /\\ SND(H12')\n\t             /\\ witness(OBU1,OBU2,o1_o2_h12,H12') /\\ request(OBU1,OBU2,o2_o1_h21,H21') /\\ secret(A1,a1,{OBU1,OBU2,SN}) /\\ secret(R1',r1,{OBU1,OBU2,SN}) // Response and secrecy declarations.\n\nend role\n\nrole role_OBU2(\n  OBU1,OBU2,SN                   : agent, // OBU2 agent concerned with communication integrity and secrecy.\n  PID2,P                         : text, // Protocol identifier for OBU2 and shared message P.\n  H,PUF2                         : hash_func, // Hash function and PUF for OBU2.\n  SND,RCV                        : channel(dy)) // Channels for OBU2.\nplayed_by OBU2 def=\n  \n  local\n    State        :nat, // Current state of the OBU2 protocol.\n\tC1,C2,PID1,A2        :text, // Variables for message handling.\n\tH12,S,Q1,Q2,R1,R2,S1,R2en,Key         :message, // Message-related variables.\n\tHs2        :hash(text.text.message.text.message.message), // Hs2 hash for OBU2 processing.\n\tH21        :hash(text.message.message.text.text.message) // H21 hash for message verification.\n%%\tH12        :hash(message.text.text.message.message) // Uncommented hash for clarity.\n\n  init\n    State := 0 // Initial state of the protocol.\n\n  transition\n  \n  // Initial message reception and hash calculation.\n  1. State = 0 /\\ RCV(PID1'.C1'.C2'.R2en'.Q1'.Hs2') /\\ Hs2' = H(C1'.C2'.R2en'.PID1'.PUF2(C2').Q1') =|>\n     State' := 2 /\\ R2' := PUF2(C2') /\\ R1' := xor(R2en',R2') /\\ A2' := new() /\\ Q2' := exp(P,A2') /\\ H21' := H(C1'.R1'.Q2'.PID1'.PID2.Q1')  /\\ SND(C1'.Q2'.H21')\n\t             /\\ witness(OBU2,OBU2,o2_o1_h21,H21') // Authentication witness for mutual confirmation.\n\n  // Final state transition with received H12 for confirmation of the exchange.\n  2. State = 2 /\\ RCV(H12') /\\ H12' = H(R1.PID1.PID2.Q2.exp(Q1,A2)) =|>\n     State' := 4 /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) /\\ secret(A2,a2,{OBU1,OBU2,SN}) /\\ request(OBU2,SN,s_o2_hs2,Hs2) /\\ request(OBU2,OBU1,o1_o2_h12,H12') // Securing and verifying secrets.\n\nend role\n\n\n\nrole role_SN(\n  OBU1,OBU2,SN                   : agent, // Sensor Node role for orchestrating communication between OBU1 and OBU2.\n  PID1,PID2,C1,C2,P               : text, // Protocol identifiers and shared message P.\n  H,PUF1,PUF2                    : hash_func, // Hash functions for OBU1 and OBU2.\n  SND,RCV                       : channel(dy)) // Communication channels.\nplayed_by SN def=\n  \n  local\n    State        :nat, // Current state of the Sensor Node protocol.\n\tPID1n,PID2n        :text, // Variables for incoming request identifiers.\n\tQ1,R1,R2,R2en         :message, // Variables for message and hash handling.\n\tMAC        :hash(text.text.message), // Hash for authenticity.\n\tHs2        :hash(text.text.message.text.message.message) // Hs2 hash for processing.\n\n\t\n  init\n    State := 1 // Initial state of the Sensor Node protocol.\n\n  transition\n  \n  // Step for receiving identifiers and hashing for validation.\n  1. State = 1 /\\ RCV(PID1n'.PID2n'.Q1'.MAC') /\\ PID1n' = PID1 /\\ PID2n' = PID2 /\\ MAC' = H(PID1n'.PID2n'.Q1') =|>\n     State' := 3 /\\ R1' := PUF1(C1) /\\ R2' := PUF2(C2) /\\ R2en' := xor(R1',R2') /\\ Hs2' := H(C1.C2.R2en'.PID1.R2'.Q1') /\\ SND(PID1.C1.C2.R2en'.Q1'.Hs2') \n\t             /\\ witness(SN,OBU2,s_o2_hs2,Hs2') /\\ request(SN,OBU1,o1_s_mac,MAC') /\\ secret(R1,r1,{OBU1,OBU2,SN}) /\\ secret(R2,r2,{OBU1,OBU2,SN}) // Ensuring service requests are validated and secrets declared.\n\nend role\n\n\nrole session(\n  OBU1,OBU2,SN               : agent, // Main session role coordinating OBU1, OBU2, and SN.\n  PID1,PID2,C1,C2,P          : text, // Shared identifiers among the roles.\n  H,PUF1,PUF2                : hash_func) // Hash functions for the communication.\ndef=\n  local SO,SS,RO : channel(dy) // Local channels for inter-role communication.\n  \n  composition\n    role_OBU1(OBU1,OBU2,SN,PID1,PID2,P,H,PUF1,SO,RO) /\\ role_OBU2(OBU1,OBU2,SN,PID2,P,H,PUF2,SO,RO) /\\ role_SN(OBU1,OBU2,SN,PID1,PID2,C1,C2,P,H,PUF1,PUF2,SS,RS) // Composing roles for interaction.\n\nend role\n\nrole environment()\ndef=\n  \n  const\n    r1,r2,a1,a2,o1_s_mac,o1_o2_h12,o2_o1_h21,s_o2_hs2  :protocol_id, // Definitions for protocol operations.\n    obu1,obu2,sn        : agent, // Agent constants for simulation.\n    pid1,pid2,c1,c2,p   : text, // Shared identifiers.\n    h,puf1,puf2        : hash_func // Hash functions used in the protocol.\n  intruder_knowledge = {pid1,pid2,obu1,obu2,sn,h}  // Setting intruder knowledge base for security analysis.\n  \n  composition\n    session(obu1,obu2,sn,pid1,pid2,c1,c2,p,h,puf1,puf2) // Running the session with necessary parameters.\n\nend role\n\ngoal \n  secrecy_of r1 // Ensuring the secrecy of extracted value r1.\n  secrecy_of r2 // Ensuring the secrecy of extracted value r2.\n  secrecy_of a1 // Ensuring the secrecy of generated identifier a1.\n  secrecy_of a2 // Ensuring the secrecy of generated identifier a2.\n  authentication_on o1_o2_h12 // Authentication goal for H12 message.\n  authentication_on s_o2_hs2 // Authentication goal for Hs2 message.\nend goal\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Anonymous_E2E_authenticated_key_exchange_scheme.hlpsl",
        "logic": "---\n\n### Protocol Description: Mutual Authentication and Key Exchange Protocol\n\n#### Overview\nThe protocol facilitates a mutual authentication and secure key exchange between a user (U), a server (S), and a foreign agent (F). It employs symmetric and asymmetric cryptography, along with hash functions, to ensure the confidentiality and integrity of communications.\n\n#### Roles\n1. **User (U)**: Initiates the registration and authentication process with the server.\n2. **Server (S)**: Validates the user\u2019s credentials and facilitates the key exchange.\n3. **Foreign Agent (F)**: Monitors and potentially intercepts communications between U and S.\n\n#### Key Components\n- **Agents**: U, S, and F represent the user, server, and foreign agent respectively.\n- **Keys**:\n  - `Kus`, `Rus`, `Kas`: Symmetric keys shared among the user and server.\n  - `Ks`: A public key used by the server for encryption.\n- **Functions**:\n  - `H`: A hash function to ensure data integrity.\n  - `Mul`: A multiplicative function used in key exchange and authentication.\n- **Channels**: Channels (e.g., `SND`, `RCV`) are used for message transmission between agents.\n\n#### Protocol Phases\n1. **Registration Phase**:\n   - The user sends a `start` signal to initiate registration.\n   - The server responds by sending back a challenge based on the user\u2019s secret password, establishing shared secrets for further communications.\n\n2. **Mutual Authentication and Key Exchange Phase**:\n   - The user initiates the authentication process by sending a message containing a nonce (random number) and their identity.\n   - The server responds with its computed values using cryptographic functions, including a nonce and a signature.\n   - The user and server exchange messages to confirm their identities and derive session keys.\n\n3. **Foreign Agent Interaction**:\n   - The foreign agent can intercept and respond to the messages exchanged during the mutual authentication phase but is restricted from accessing certain secrets.\n\n#### Goals\n- **Secrecy**: Ensures that certain secret values (g1, g2, g3, g4, g5, g6) remain confidential.\n- **Authentication**: The protocol aims to verify the identities of both the user and the server (u_s_tim, s_u_b1mi).\n\n#### Conclusion\nThis protocol is designed to provide secure registration and mutual authentication using cryptographic techniques. It safeguards against unauthorized access and ensures that session keys are established securely between the user and the server, despite potential interception by a foreign agent.\n\n---",
        "code": "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter SIDim to smart card\n\t\t   /\\ SPWim' := new()\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))\n\t\t   /\\ SND({SIDim.SAim'}_Kus)\n\t\t   /\\ secret(SIDim,g1,{U,S})\n\t\t   /\\ secret(SAim',g2,{U,S})\n\t\t   /\\ secret(SPWim',g3,{U})\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   %/\\ Store Bmi in flash storage %/\\ Store SAim in smart card\n\n% Mutual authentication and key exchange phase\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDUi, PWUi to smart card %/\\ Smart card verify legitimacy of user %/\\ Enter SIDim to smart card\n\t\t   /\\ Uim' := xor(Bmi,SAim)\n\t\t   /\\ Aim' := new()\n\t\t   /\\ Tim' := new()\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks\n\t\t   /\\ SND(Cim1'.Tim')\n\t\t   /\\ witness(U,S,u_s_tim,Tim')\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))\n\t\t   /\\ SND({Bmi'}_Kus)\n\t\t   /\\ secret(Bmi',g4,{U,S})\n\n% Mutual authentication and key exchange phase\n\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')\n\t\t   /\\ B1mi' := new()\n\t\t   /\\ Wmi' := Mul(B1mi'.G)\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')\n\t\t   %/\\ Dm = Signature of Sm with Ymi'\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)\n\t\t   /\\ request(U,S,u_s_tim,Tim')\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication and key exchange phase\n\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()\n\t\t   /\\ Nfp1' := new()\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')\n\t\t   /\\ secret(Nfp',g5,{U,S,F})\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n         /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6\n  authentication_on u_s_tim, s_u_b1mi\n\nend goal\n\nenvironment()",
        "codenote": "role user (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% This phase allows the user to register with the server by sending their SID and a secure password.\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n           % The user initiates the registration process\n\t\t   /\\ SPWim' := new()  % New password for the user\n\t\t   /\\ SAim' := xor(H(SPWim'),H(Ri.SIDim))  % Secure association ID\n\t\t   /\\ SND({SIDim.SAim'}_Kus)  % Send SID and SA to the server encrypted with Kus\n\t\t   /\\ secret(SIDim,g1,{U,S})  % Establish secret knowledge of SIDim\n\t\t   /\\ secret(SAim',g2,{U,S})  % Establish secret knowledge of SAim'\n\t\t   /\\ secret(SPWim',g3,{U})  % Establish secret knowledge of SPWim'\n\n\t2.  State = 1 /\\ RCV({xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))  % Compute Bmi' for further authentication\n           % The server verifies the user's registration and responds with the computed value.\n\n% Mutual authentication and key exchange phase\n% This phase facilitates mutual authentication between the user and the server.\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n           % User starts mutual authentication with the server\n\t\t   /\\ Uim' := xor(Bmi,SAim)  % Compute a unique identification message for user\n\t\t   /\\ Aim' := new()  % New session key\n\t\t   /\\ Tim' := new()  % New timestamp for freshness\n\t\t   /\\ Cim1' := {xor((Uim'.SIDim),Tim')}_Ks  % Create a commitment message\n\t\t   /\\ SND(Cim1'.Tim')  % Send commitment message to the server\n\t\t   /\\ witness(U,S,u_s_tim,Tim')  % Establish a witness for the timing\n\n\t4.  State = 1 /\\ RCV(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Ymi'.Kmi'.SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp) =|>\n\t\t   State':= 2\n\t\t   /\\ Kua' := Mul(Nfp'.Aim.Mul(B1mi'.Ynj))  % Derive the session key for the user\n\t\t   /\\ request(S,U,s_u_b1mi,B1mi')  % Request for mutual authentication confirmation\n\nend role\n\nrole server (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% Server's role in user registration, verifying the SID and processing secured data.\n\t1. State = 0 /\\ RCV({SIDim.xor(H(SPWim'),H(Ri.SIDim))}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Umi' := H(SIDim.Xm)  % Compute user identifier using SID\n\t\t   /\\ Bmi' := xor(Umi',xor(H(SPWim'),H(Ri.SIDim)))  % Compute Bmi for the user\n\t\t   /\\ SND({Bmi'}_Kus)  % Send back the computed Bmi encrypted with Kus\n\t\t   /\\ secret(Bmi',g4,{U,S})  % Establish secret knowledge of Bmi'\n\n% Mutual authentication and key exchange phase\n% Server responds to the user's authentication request with mutual confirmation.\n\t2.  State = 0 /\\ RCV(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).({Qp'.Nfp1'}_Kas)) =|>\n\t\t   State':= 1\n\t\t   /\\ Cim1' := xor(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp'),Nfp')  % Create new commitment message\n\t\t   /\\ B1mi' := new()  % New session identifier\n\t\t   /\\ Wmi' := Mul(B1mi'.G)  % Derive a fresh key\n\t\t   /\\ Ymi' := Mul(Nfp'.Rim.B1mi')  % Compute Ymi from Nfp and Rim \n\t\t   %/\\ Dm = Signature of Sm with Ymi'  % Signature creation (commented for clarity)\n\t\t   %/\\ Send Dm to server Sn %/\\ Receive Dn' from Sn, verify identity of Sn, and open Dn'\n\t\t   /\\ Kmi' := Mul(B1mi'.Ynj)  % Derive key for the session\n\t\t   /\\ B2mi' := H(Ymi'.Kmi'.SIDim.IDsm)  % Compute verification value\n\t\t   /\\ Dmi' := {Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus  % Message to send to user\n\t\t   /\\ SND({{Wmi'.Kmi'.B2mi'.Nfp'.Nfp1'}_Rus}_Kas)  % Send signed message to the user\n\t\t   /\\ request(U,S,u_s_tim,Tim')  % User requests confirmation\n\t\t   /\\ witness(S,U,s_u_b1mi,B1mi')  % Record witness for authentication\n\nend role\n\nrole foreign (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func, SND, RCV: channel (dy))\nplayed_by F def=\n\n  local State: nat,\n       SPWim, SAim, Ri, SIDim, Umi, Bmi, Tim, Nfp, Nfp1, Qp, Cim1, G, B1mi, Aim, Wmi, Ymi, Dm, Kmi, B2mi, Dmi, Rim, Uim, Ynj, IDsm, Cim2, Kua, Xm, Bpm, A: text\n\n  init State := 0\n\n  transition\n\n% Mutual authentication phase\n% The foreign agent participates in the authentication phase by relaying messages.\n\t1. State = 0 /\\ RCV(({xor((Uim'.SIDim),Tim')}_Ks).Tim') =|>\n\t\t   State':= 1\n\t\t   /\\ Nfp' := new()  % Generate a new nonce for freshness\n\t\t   /\\ Nfp1' := new()  % Generate a second nonce for further security\n\t\t   /\\ Qp' := xor(Nfp',Nfp1')  % Compute a joint value from nonces\n\t\t   /\\ Bpm' := {Qp'.Nfp1'}_Kas  % Create a committed message for the server\n\t\t   /\\ Cim2' := xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp')  % New commitment message\n\t\t   /\\ SND(xor(({xor((Uim'.SIDim),Tim')}_Ks),Nfp').({xor((Uim'.SIDim),Tim')}_Ks).Bpm')  % Send messages securely\n\t\t   /\\ secret(Nfp',g5,{U,S,F})  % Establish secret knowledge of Nfp'\n\t\t   /\\ secret(Nfp1',g6,{U,S,F})  % Establish secret knowledge of Nfp1'\n\n\t2. State = 1 /\\ RCV({{Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus}_Kas) =|>\n\t\t   State':= 2\n\t\t   /\\ SND(({Mul(B1mi'.G).Mul(B1mi'.Ynj).H(Mul(Nfp'.Rim.B1mi').Mul(B1mi'.Ynj).SIDim.IDsm).Nfp'.Nfp1'}_Rus).Qp)  % Send the authentication response back\n\nend role\n\nrole session (U, S, F: agent, Kus, Rus, Kas: symmetric_key, Ks: public_key, H, Mul: hash_func) def=\n\n  local SU, RU, SS, RS, SF, RF: channel (dy)\n\n  composition\n\n\tuser (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SU,RU)\n          /\\ server (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SS,RS)\n          /\\ foreign (U,S,F,Kus,Rus,Kas,Ks,H,Mul,SF,RF)\n\nend role\n\nrole environment() def=\n\n    const u, s, f: agent,\n\t  kus, rus, kas, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, mul: hash_func,\n\t  u_s_tim, s_u_b1mi, g1, g2, g3, g4, g5, g6: protocol_id\n\n    intruder_knowledge = {u,s,f,ks,ki,inv(ki)}\n\n    composition\n\n\t   session(u,s,f,kus,rus,kas,ks,h,mul)\n\t/\\ session(i,s,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,i,f,kui,kui,kui,ks,h,mul)\n\t/\\ session(u,s,i,kui,kui,kui,ks,h,mul)\n\nend role\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6  % Ensure secrecy of crucial parameters\n  authentication_on u_s_tim, s_u_b1mi  % Confirm mutual authentication between parties\n\nend goal"
    },
    {
        "file": "HLPSL-1/A_Secure_and_Efficient_Smart_Card-based_UCSSO_Scheme_Using_Extended_Chebyshev_Chaotic_Maps_for_Telemedicine_Systems.hlpsl",
        "logic": "---\n\n### Protocol Description\n\n#### Overview\nThis protocol aims to provide secure registration and mutual authentication between a user (U) and a server (S). It utilizes symmetric keys, hash functions, and Chebyshev polynomials to ensure confidentiality, integrity, and authentication of messages exchanged between the two parties.\n\n#### Roles\n1. **User (U)**: Initiates the registration and authentication process. The user generates random values and computes necessary cryptographic parameters to authenticate with the server.\n2. **Server (S)**: Responds to the user's requests and performs authentication by validating the user's credentials and generating necessary responses.\n\n#### Phases of the Protocol\nThe protocol consists of two main phases: Registration and Mutual Authentication.\n\n##### 1. Registration Phase\n- The user starts in `State 0` and sends a message to the server indicating the start of the registration process. The user generates new identifiers (`IDi`, `SIDj`), a password (`PWi`), and a random value (`Yi`).\n- The user computes values `Ai` and `Aii` using the Chebyshev polynomial `T` and hash functions. The message sent to the server includes these computed values, encrypted with a symmetric key (`Kus`).\n- The user establishes secrets related to the identifiers and values shared with the server.\n\n##### 2. Mutual Authentication Phase\n- In `State 1`, the server receives the user's registration message and processes it. It computes values based on the received information and sends back encrypted values (`Bii`, `Bjj`) to the user.\n- The user computes additional parameters based on the received values, including a new random value (`Pi'`) and a message (`Mi'`), which is sent to the server.\n- The server, upon receiving the user's response, verifies the computed values and sends an acknowledgment back, completing the mutual authentication process.\n- Both parties confirm the integrity and authenticity of the exchanged messages by generating message authentication codes (MACs) based on shared keys.\n\n#### Security Goals\nThe protocol aims to achieve the following security properties:\n- **Secrecy**: The secrets (`g1`, `g2`, `g3`, `g4`, `g5`, `g6`) established during the protocol must remain confidential and protected from unauthorized access.\n- **Authentication**: The user and server must be assured of each other's identities through the authentication process (`u_s_pi`, `s_u_sj`).\n\n#### Environment\nThe protocol operates in an environment where both the user and server are aware of the cryptographic functions and keys required for secure communication. The environment also supports the presence of an intruder who may attempt to intercept or manipulate the messages exchanged.\n\n---",
        "code": "role user (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()\n/\\ SIDj' := new()\n/\\ PWi' := new()\n/\\ Yi' := new()\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X)\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))\n/\\ SND({IDi'.Aii'}_Kus)\n/\\ secret(IDi',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ secret(PWi',g3,{U})\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj\n\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii)\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai))\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai))\n/\\ Pi' := new()\n/\\ Mi' := T(Yi.Pi')\n/\\ Bi' := {Mi'}_Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki'\n/\\ SND(Ri'.Ci')\n/\\ witness(U,S,u_s_pi,Pi')\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi'))\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij'\n/\\ SND(MacUi')\n/\\ request(S,U,s_u_sj,Sj')\n\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U &S\n\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)\n/\\ Ui' := {H(IDi)}_Bj'\n/\\ Uj' := {H(SIDj)}_Bj'\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus)\n/\\ secret(Bii',g4,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Xsj,g6,{S})\n\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj))\n%/\\ Use Ki' to decrypt Ci\n%/\\ Use Ui to decrypt Bi and obtain Mi\n/\\ Sj' := new()\n/\\ Wj' := T(Sj'.Pi')\n/\\ Kij' := H(T(Sj'.Mi'))\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij'\n/\\ SND(MacSj'.Wj')\n/\\ witness(S,U,s_u_sj,Sj')\n/\\ request(U,S,u_s_pi,Pi')\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij\n\nend role\n\n\nrole session (U, S: agent, Kus: symmetric_key, T, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6 authentication_on u_s_pi, s_u_sj\n\nend goal\n\n\nenvironment()",
        "codenote": "role user (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\n% Notation: Initial state of the user is set to 0 indicating registration phase\ntransition\n\n% Registration phase\n1.  State = 0 /\\ RCV(start) =|>\nState':= 1\n/\\ IDi' := new()  % Generate a new identity for user\n/\\ SIDj' := new() % Generate a new session ID for server\n/\\ PWi' := new()  % Generate new password for user\n/\\ Yi' := new()   % Generate new secret value\n% Suppose T(.) is a Chebyshev polynomial\n/\\ Ai' := T(Yi'.X) % Compute Ai' using T and Yi'\n/\\ Aii' := xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')) % Compute Aii' for mutual authentication\n/\\ SND({IDi'.Aii'}_Kus) % Send message with IDi and Aii to server\n/\\ secret(IDi',g1,{U,S}) /\\ secret(Ai',g2,{U,S}) /\\ secret(PWi',g3,{U})  % Define secrets\n\n% Notation: Upon receiving the response from server, user transitions state\n2.  State = 1 /\\ RCV({xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))).xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))}_Kus) =|>\nState':= 2\n%/\\ Store Bii and Bjj \n\n% Notation: State now indicates that mutual authentication is in progress\n% Mutual authentication phase\n%/\\ Input IDi, SIDj, PWi, Bii and Bjj into smart card\n%/\\ Smart card checks PWi\n/\\ Ui' := xor(Bii,Aii) % Compute Ui' for session key\n/\\ Ki' := xor(Aii,({H(Yi)}_Ai)) % Derive session key for user\n/\\ Ri' := xor(Bjj,({H(Yi)}_Ai)) % Compute Ri for the server response\n/\\ Pi' := new()  \n/\\ Mi' := T(Yi.Pi') % Generate new message\n/\\ Bi' := {Mi'}_Ui' % Create Bi using Mi' and Ui'\n/\\ Ci' := {IDi.Bi'.Pi'}_Ki' % Create Ci using IDi, Bi' and Pi'\n/\\ SND(Ri'.Ci') % Send Ri and Ci to the server\n/\\ witness(U,S,u_s_pi,Pi') % Establish witness for the protocol\n3.  State = 2 /\\ RCV(({H(SIDj.IDi.Mi')}_Kij').T(Sj'.Pi')) =|>\nState':= 3\n/\\ Kij' := H(Yi.T(Sj'.Pi')) % Derive Kij for mutual session encryption\n%/\\ Confirm MacSj =? {H(SIDj.IDi.Mi)}_Kij  % For integrity checking\n/\\ MacUi' := {H(IDi.SIDj.T(Sj'.Pi'))}_Kij' % Compute MacUi for user validation\n/\\ SND(MacUi') % Send MacUi to server \n/\\ request(S,U,s_u_sj,Sj') % Request a response from server\n\nend role\n\n\nrole server (U, S: agent, Kus: symmetric_key, T, H: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\nlocal State: nat,\nIDi, SIDj, PWi, X, Yi, Ai, Aii, Bj, Ui, Uj, Bi, Ci, Bii, Bjj, Ki, Kij, Ri, Pi, Mi, Sj, Wj, MacSj, MacUi, Xsj: text\n\ninit State := 0\n%/\\ Suppose T(.) is a Chebyshev polynomial, and p & Ni are known to U & S\n\n% Notation: Server begins in initial state 0 waiting for user registration\ntransition\n\n% Registration phase\n1. State = 0 /\\ RCV({IDi'.xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai'))}_Kus) =|>\nState':= 1\n/\\ Bj' := T(Xsj.X)  % New session key Bj' using Chebyshev polynomial\n/\\ Ui' := {H(IDi)}_Bj'  % Compute Ui' based on IDi and Bj'\n/\\ Uj' := {H(SIDj)}_Bj'  % Compute Uj' for session identification\n/\\ Bii' := xor(Ui',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ Bjj' := xor(Uj',xor(({H(PWi')}_Ai'),({H(Yi'.SIDj')}_Ai')))\n/\\ SND({Bii'.Bjj'}_Kus) % Send Bii and Bjj to user\n/\\ secret(Bii',g4,{U,S}) /\\ secret(Bjj',g5,{U,S}) /\\ secret(Xsj,g6,{S}) % Define security parameters\n\n% Notation: State indicating server is ready for mutual authentication\n% Mutual authentication phase\n2. State = 1 /\\ RCV(xor(Bjj,({H(Yi)}_Ai)).({IDi.({Mi'}_Ui').Pi'}_Ki')) =|>\nState':= 2\n/\\ Ki' := xor(Ri,({SIDj}_Bj)) % Compute Ki' using Ri and SIDj\n%/\\ Use Ki' to decrypt Ci % Decrypt Ci for further operations\n%/\\ Use Ui to decrypt Bi and obtain Mi % Obtain Mi for further validation\n/\\ Sj' := new()  % Create new session ID\n/\\ Wj' := T(Sj'.Pi')  % Generate Wj' for user\n/\\ Kij' := H(T(Sj'.Mi')) % Compute mutual key Kij' based on Mi'\n/\\ MacSj' := {H(SIDj.IDi.Mi')}_Kij' % Calculate MacSj' for verification\n/\\ SND(MacSj'.Wj') % Send MacSj' and Wj' to user\n/\\ witness(S,U,s_u_sj,Sj') % Establish witness for the session\n/\\ request(U,S,u_s_pi,Pi') % Request user for further interaction\n3. State = 2 /\\ RCV({H(IDi.SIDj.T(Sj'.Pi'))}_Kij') =|>\nState':= 3\n%/\\ Confirm MacUi := {H(IDi.SIDj.T(Sj.Pi))}_Kij  % Final integrity check\n\nend role\n\n\nrole session (U, S: agent, Kus: symmetric_key, T, H: hash_func) def=\n\nlocal SU, RU, SS, RS: channel (dy)\n\ncomposition\n\nuser (U,S,Kus,T,H,SU,RU) /\\ server (U,S,Kus,T,H,SS,RS)\n\nend role\n\n\nrole environment() def=\n\nconst u, s: agent,\nkus, kui: symmetric_key,\nt, h: hash_func,\nu_s_pi, s_u_sj, g1, g2, g3, g4, g5, g6: protocol_id\n\nintruder_knowledge = {u,s}  % Initial knowledge of the intruder\n\ncomposition\n\nsession(u,s,kus,t,h)\n/\\ session(i,s,kui,t,h)\n/\\ session(u,i,kui,t,h)\n\nend role\n\n\ngoal\n\nsecrecy_of g1, g2, g3, g4, g5, g6 % Goals to preserve secrets\nauthentication_on u_s_pi, s_u_sj % Ensure mutual authentication succeeds\n\nend goal\n\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/CHAPv2.hlpsl",
        "logic": "---\n\n# Protocol Description: (MS-)CHAPv2\n\n## Overview\nThe Challenge-Handshake Authentication Protocol version 2 (CHAPv2) is designed to provide mutual authentication between a client (Alice, A) and a server (Bob, B) who share a secret password. This protocol is commonly used in Point-to-Point Tunneling Protocol (PPTP) authentication mechanisms.\n\n## Purpose\nThe primary goal of CHAPv2 is to ensure that both parties (the client and the server) can verify each other's identity while sharing a common secret, enhancing security in communication over potentially insecure channels.\n\n## Reference\nThe protocol is specified in [RFC2759](https://tools.ietf.org/html/rfc2759).\n\n## Participants\n- **Alice (A)**: The client attempting to authenticate to the server.\n- **Bob (B)**: The server providing authentication services.\n- **Shared Password (k(A,B))**: A pre-shared secret known only to Alice and Bob.\n\n## Protocol Steps\nThe CHAPv2 protocol operates through a series of message exchanges:\n\n1. **Initialization**:\n   - Alice sends a message to Bob to initiate authentication.\n\n2. **Challenge**:\n   - Bob responds with a nonce (Nb), which is a randomly generated value.\n\n3. **Response**:\n   - Alice generates her own nonce (Na) and sends it back to Bob along with a hash that includes her nonce, Bob's nonce, and her identity using the shared secret. This message is formatted as: `Na, H(k(A,B), (Na, Nb, A))`.\n\n4. **Final Challenge**:\n   - Bob verifies Alice's response by sending back a hash of his nonce (Na) using the shared secret.\n\n## Limitations\nThe protocol abstracts the concrete details of message structure, such as bit lengths and formatting, to simplify analysis. However, this abstraction may introduce redundancies that are eliminated to focus on the core data dependencies.\n\n## Security Issues\n- **Problems Addressed**: The protocol is classified under problems G1 (authentication), G2 (secrecy), and G12 (key secrecy).\n- **Attacks**: There are no known attacks against the protocol as modeled in this context.\n\n## Notes\nA thorough cryptanalysis of the CHAPv2 protocol can be found in Schneier's work, indicating potential weaknesses and areas for further research.\n\n## Goals\nThe security goals of the protocol include:\n- **Secrecy of the shared keys**: Ensuring that the shared secrets (sec_kab1, sec_kab2) remain confidential.\n- **Authentication**: Verifying that both parties (CHAP_Init and CHAP_Resp) can authenticate each other using the nonces (na, nb).\n\n## Roles\nThe protocol is defined through the following roles:\n- `chap_Init`: Represents the client (Alice) and manages the initial authentication steps.\n- `chap_Resp`: Represents the server (Bob) and handles the challenge-response mechanism.\n- `session`: Combines the client and server roles for a complete authentication session.\n- `environment`: Defines the context in which the protocol operates, including potential intruders.",
        "code": "%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole chap_Init (A,B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, Rcv: channel(dy))\nplayed_by A\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab1 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)\n\n   2. State   = 1 /\\ Rcv(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.Na'.Nb'.A))\n\t          /\\ witness(A,B,na,Na') \n\t\t  /\\ secret(Kab,sec_kab1,{A,B})\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na)) =|> \n      State' := 3 /\\ request(A,B,nb,Nb) \n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH: hash_func,\n                Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : nat,\n        Na, Nb : text\n\n  const sec_kab2 : protocol_id\n\n  init  State := 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')\n\t          /\\ witness(B,A,nb,Nb')\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.Na'.Nb.A)) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))\n\t          /\\ request(B,A,na,Na') \n\t\t  /\\ secret(Kab,sec_kab2,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(b,i,kbi,h)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "codenote": "%% PROTOCOL: (MS-)CHAPv2\n%% Challenge/Response Authentication Protocol, version 2\n%% PURPOSE:\n%% Mutual authentication between a server and a client who share a password.\n%% CHAPv2 is the authentication protocol for the Point-to-Point Tunneling Protocol\n%% suite (PPTP).\n%% REFERENCE:\n%% \\cite{RFC2759}\n%% MODELER:\n%%\\begin{itemize}\n%%\\item Haykal Tej, Siemens CT IC 3, 2003\n%%\\item Paul Hankes Drielsma, ETH Z\\\"urich\n%%\\end{itemize}\n%%\n%% ALICE_BOB:\n%% We assume that the server \\verb!B! and client \\verb!A! share \n%% password \\verb!k(A,B)! in advance.  The server and client generate\n%% nonces \\verb!Nb! and \\verb!Na!, respectively.\n%%\\begin{verbatim}\n%%  1. A -> B : A\n%%  2. B -> A : Nb\n%%  3. A -> B : Na,H(k(A,B),(Na,Nb,A))\n%%  4. B -> A : H(k(A,B),Na)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%\n%%Issues abstracted from:\n%%\\begin{itemize}\n%%\\item Message structure: As is standard, we abstract away from the concrete details\n%% of message structure such as bit lengths, etc.  What is left after this abstraction\n%% contains several redundancies, however (at least in the Dolev-Yao model).\n%% We therefore eliminate these redundancies, retaining the core of the data\n%% dependencies of the protocol. \n%%\\end{itemize}\n%%\n%% PROBLEMS: 3\n%% CLASSIFICATION: G1, G2, G12\n%% ATTACKS: None\n%%\n%% NOTES:\n%% A cryptanalysis of this protocol in its full complexity can be found\n%% in~\\cite{schneier99cryptanalysis}.\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%%HLPSL:\nrole chap_Init (A,B   : agent,\n           \tKab   : symmetric_key,\n\t   \tH     : hash_func,\n           \tSnd, Rcv: channel(dy))\nplayed_by A\ndef=\n           \n  local State  : nat,  %% Current state of the role\n        Na, Nb : text   %% Nonce values for authentication\n\n  const sec_kab1 : protocol_id  %% Identifier for the session key\n\n  init  State := 0  %% Initialize state to 0\n\n  transition\n   1. State   = 0 /\\ Rcv(start) =|>\n      State' := 1 /\\ Snd(A)  %% Client A initiates the protocol by sending its identity\n\n   2. State   = 1 /\\ Rcv(Nb') =|> \n      State' := 2 /\\ Na' := new() /\\ Snd(Na'.H(Kab.Na'.Nb'.A))  %% Generate Na and send authenticated nonce\n\t          /\\ witness(A,B,na,Na')  %% Document that A has sent Na\n\t\t  /\\ secret(Kab,sec_kab1,{A,B})  %% Declare shared session key as secret\n\n   3. State   = 2 /\\ Rcv(H(Kab.Na)) =|> \n      State' := 3 /\\ request(A,B,nb,Nb)  %% Request the nonce Nb from B\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole chap_Resp (B,A : agent,\n                Kab : symmetric_key,\n\t\tH: hash_func,\n                Snd, Rcv: channel(dy))\nplayed_by B\ndef=\n           \n  local State  : nat,  %% Current state of the role\n        Na, Nb : text   %% Nonce values for authentication\n\n  const sec_kab2 : protocol_id  %% Identifier for the session key\n\n  init  State := 0  %% Initialize state to 0\n\n  transition\n   1. State   = 0 /\\ Rcv(A') =|>  \n      State' := 1 /\\ Nb' := new() /\\ Snd(Nb')  %% Generate nonce Nb and send to A\n\t          /\\ witness(B,A,nb,Nb')  %% Document that B has sent Nb\n\n   2. State   = 1 /\\ Rcv(Na'.H(Kab.Na'.Nb.A)) =|>\n      State' := 2 /\\ Snd(H(Kab.Na'))  %% Send hashed value back to A\n\t          /\\ request(B,A,na,Na')  %% Request the nonce Na from A\n\t\t  /\\ secret(Kab,sec_kab2,{A,B})  %% Declare shared session key as secret\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\nrole session(A,B: agent,\n\t     Kab: symmetric_key,\n\t     H: hash_func)\ndef=\n\n  local SA, SB, RA, RB: channel (dy)  %% Define channels for communication\n\n  composition\n           chap_Init(A, B, Kab, H, SA, RA)\n       /\\  chap_Resp(B, A, Kab, H, SB, RB)  %% Combine both roles for the session\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        h             : hash_func,\n        na, nb        : protocol_id\n\n  intruder_knowledge = {a, b, h, kai, kbi }  %% Knowledge of the intruder\n\n  composition\n\tsession(a,b,kab,h) /\\\n\tsession(a,i,kai,h) /\\\n        session(b,i,kbi,h)  %% Run sessions for the client, server, and intruder\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n %secrecy of the shared key\n secrecy_of sec_kab1, sec_kab2\t% Addresses G12\n                         \n %CHAP_Init authenticates CHAP_Resp on nb\n authentication_on nb  % Addresses G1, G2\n %CHAP_Resp authenticates CHAP_Init on na\n authentication_on na  % Addresses G1, G2\n  \nend goal\n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nenvironment()"
    },
    {
        "file": "HLPSL-1/DHCP-delayed-auth.hlpsl",
        "logic": "Sure! Below is a detailed description content of the DHCP-Delayed-Auth protocol based on the provided HLPSL file. This description can aid in generating a corresponding HLPSL file for use with the AVISPA tool.\n\n---\n\n## Protocol Description: DHCP-Delayed-Auth\n\n### Purpose:\nThe DHCP-Delayed-Auth protocol is designed to provide delayed entity and message authentication in the Dynamic Host Configuration Protocol (DHCP). It enhances the security of DHCP by ensuring that clients can authenticate servers at a later time while maintaining the integrity and authenticity of the messages exchanged.\n\n### Reference:\nThis protocol follows the specifications outlined in RFC 3118, which can be accessed at [RFC 3118](http://www.faqs.org/rfcs/rfc3118.html).\n\n### Modelers:\nThe protocol model was developed by:\n- Graham Steel, University of Edinburgh, July 2004\n- Luca Compagna, AI-Lab, DIST University of Genova, November 2004\n\n### Participants:\n- **Client (C):** The entity that requests network configuration parameters from a DHCP server.\n- **Server (S):** The entity that provides network configuration parameters to the client.\n\n### Protocol Steps:\n1. **Client Request:**\n   - The client (C) initiates the communication by sending a message to the server (S) with the following details:\n     - Client identifier (C)\n     - Request for delayed authentication (delayedAuthReq)\n     - A nonce or timestamp (Time1).\n\n2. **Server Response:**\n   - The server (S) responds to the client with a message that includes:\n     - Server identifier (S)\n     - The same request for delayed authentication (delayedAuthReq)\n     - A successful nonce (succ(Time1))\n     - A key identifier derived from a pre-established shared key (KeyID(K))\n     - A hash signature that verifies the authenticity of the message (H(S, delayedAuthReq, succ(Time1), K)).\n\n### Limitations:\n- The protocol model presented here captures only the mandatory checks specified by the RFC. It does not account for the various optional checks indicated by the keywords MAY, MUST, etc.\n- The actual messages exchanged in a real implementation may include additional fields (e.g., authentication requested, message length, algorithm specifications) that are not explicitly represented in the HLPSL model. The model simplifies these aspects for clarity.\n- The server's response includes a nonce incremented by one (succ(nonce)), rather than a timestamp.\n\n### Security Goals:\nThe primary security goals of the DHCP-Delayed-Auth protocol are:\n- **Secrecy of Shared Secrets (sec_k):** Ensuring that the shared secret remains confidential and is not disclosed to unauthorized parties.\n- **Authentication of the Server (sig):** Ensuring that the client can authenticate the server based on the received signature.\n\n### Problems:\n- The protocol is classified under multiple problem categories: G1, G2, G3, G12, indicating various potential security concerns.\n\n### Attacks:\n- There are currently no identified attacks against the protocol as modeled.\n\n### Additional Notes:\n- The client acts as the initiator of the protocol by sending a DHCP discover request, which includes the authentication request.\n- The model considers the presence of an intruder (i) that may attempt to intercept, manipulate, or forge messages.\n\n### Roles Defined:\n- **dhcp_Delayed_Client:** Represents the client in the DHCP protocol, defining its state transitions based on received messages.\n- **dhcp_Delayed_Server:** Represents the server, handling incoming requests and responding with authentication details.\n- **session:** Represents the interaction between the client and server, encapsulating their respective roles.\n- **environment:** Models the overall setting, including potential intruders and their knowledge base.\n\n---\n\nThis description can be used to understand the purpose and functionality of the DHCP-Delayed-Auth protocol and assists in recreating the HLPSL file for analysis with AVISPA.",
        "code": "%% PROTOCOL: DHCP-Delayed-Auth\n%% PURPOSE:\n%%    Delayed entity and message authentication for DHCP\n%%\n%% REFERENCE: RFC 3118, \\url{http://www.faqs.org/rfcs/rfc3118.html}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%%1. C -> S : C, delayedAuthReq, Time1\n%%2. S -> C : S, delayedAuthReq, succ(Time1), KeyID(K), \n%%            H(S, delayedAuthReq, succ(Time1), K)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%The RFC describes different options and checks in terms of key words MAY, MUST etc.\n%%This model is of the minimum protocol, i.e. only the MUST checks.\n%%In real life, message looks like\n%%\\begin{itemize}\n%%\\item 90 (auth requested), \n%%\\item length, \n%%\\item 1 (for delayed auth), \n%%\\item 1 (to indicate standard HMAC algorithm),\n%%\\item 0 (standard Replay Detection Mechanism, monotonically increasing counter),\n%%\\item counter value.\n%%\\end{itemize}\n%%We ignore length field (as it cannot be, yet, expressed in HLPSL), \n%%use fresh nonce to model RDM, and\n%%assume 'DelayedAuthReq' token is enough to specify algorithm, type of auth,\n%%and type of RDM.\n%%\n%%The server returns the nonce + 1 (or \\verb|succ(nonce)| to be exact) \n%%instead of a timestamp with a higher value.\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%%\n%% NOTES: Client is the initiator. Sends a DHCP discover and requests authentication\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new()\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ request(C,S,sig,Sig') \n      /\\ secret(K,sec_k,{S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S  : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1)\n    /\\  session(a,i,h,keyid,k2)\n    /\\  session(i,b,h,keyid,k3)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "codenote": "%% PROTOCOL: DHCP-Delayed-Auth\n%% PURPOSE:\n%%    Delayed entity and message authentication for DHCP\n%%\n%% REFERENCE: RFC 3118, \\url{http://www.faqs.org/rfcs/rfc3118.html}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Graham Steel, University of Edinburgh, July 2004\n%%   \\item Luca Compagna, AI-Lab DIST University of Genova, November 2004\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%%1. C -> S : C, delayedAuthReq, Time1\n%%2. S -> C : S, delayedAuthReq, succ(Time1), KeyID(K), \n%%            H(S, delayedAuthReq, succ(Time1), K)\n%%\\end{verbatim}\n%%\n%% LIMITATIONS:\n%%The RFC describes different options and checks in terms of key words MAY, MUST etc.\n%%This model is of the minimum protocol, i.e. only the MUST checks.\n%%In real life, message looks like\n%%\\begin{itemize}\n%%\\item 90 (auth requested), \n%%\\item length, \n%%\\item 1 (for delayed auth), \n%%\\item 1 (to indicate standard HMAC algorithm),\n%%\\item 0 (standard Replay Detection Mechanism, monotonically increasing counter),\n%%\\item counter value.\n%%\\end{itemize}\n%%We ignore length field (as it cannot be, yet, expressed in HLPSL), \n%%use fresh nonce to model RDM, and\n%%assume 'DelayedAuthReq' token is enough to specify algorithm, type of auth,\n%%and type of RDM.\n%%\n%%The server returns the nonce + 1 (or \\verb|succ(nonce)| to be exact) \n%%instead of a timestamp with a higher value.\n%%\n%% PROBLEMS: 2\n%% CLASSIFICATION: G1, G2, G3, G12\n%% ATTACKS: None\n%%\n%% NOTES: Client is the initiator. Sends a DHCP discover and requests authentication\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%HLPSL:\nrole dhcp_Delayed_Client ( \n        C, S     : agent,    % C client, S server \n        H        : hash_func, % HMAC hash func.\n        KeyID    : hash_func, % get a key id from a key\n        K        : text,     % K is the pre-existing shared secret\n        Snd, Rcv : channel(dy))\nplayed_by C\ndef=\n\n  local State : nat,\n        Time1 : text,\n\tSig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func,   % Successor function\n        sec_k          : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(start)\n      =|> \n      State' := 1\n      /\\ Time1' := new() % Generate a new fresh nonce for replay detection\n      /\\ Snd(C.delayedAuthReq.Time1')\n\n   2. State = 1\n      /\\ Rcv(S.delayedAuthReq.succ(Time1).KeyID(K).\n             H(S.delayedAuthReq.succ(Time1).K))\n      =|> \n      State' := 2\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1).K) \n      /\\ request(C,S,sig,Sig') \n      /\\ secret(K,sec_k,{S}) % Associate the secret with the server\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole dhcp_Delayed_Server (\n        S,C      : agent,\n        H        : hash_func,  % HMAC hash func.\n        KeyID    : hash_func,  % get a key id from a key\n        K        : text,\n        Snd, Rcv : channel (dy))\nplayed_by S\ndef=\n\n  local State : nat,\n        Time1 : text, \n        Sig   : hash(agent.protocol_id.hash(text).text)\n\n  const delayedAuthReq : protocol_id,\n\tsucc           : hash_func   % Successor function\n\n  init State := 0\n\n  transition\n\n   1. State = 0\n      /\\ Rcv(C.delayedAuthReq.Time1')\n      =|> \n      State' := 1\n      /\\ Sig' := H(S.delayedAuthReq.succ(Time1').K) \n      /\\ Snd(S.delayedAuthReq.succ(Time1').KeyID(K).Sig')\n      /\\ witness(S,C,sig,Sig') % Witness the authentic signature for later verification\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(C, S  : agent,\n\t     H, KeyID : hash_func,\n\t     K     : text)\ndef=\n\n  local SA, RA, SB, RB : channel (dy)\n\n  composition\n\tdhcp_Delayed_Server(S,C,H,KeyID,K,SA,RA) /\\\n\tdhcp_Delayed_Client(C,S,H,KeyID,K,SB,RB) % Establish the client-server communication\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n \n const a, b       : agent,\n       k1, k2, k3 : text,\n       h, keyid   : hash_func,\n       sig        : protocol_id\n\n intruder_knowledge = {a,b,k2,i,delayedAuthReq,\n                       keyid,h,succ,        \n                       k3}                  \n\n composition\n\tsession(a,b,h,keyid,k1) % Session for the client and server\n    /\\  session(a,i,h,keyid,k2) % Session between client and intruder\n    /\\  session(i,b,h,keyid,k3) % Session between intruder and server\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ngoal\n  secrecy_of sec_k % addresses G12\n\n  %DHCP_Delayed_Client authenticates DHCP_Delayed_Server on sig\n  authentication_on sig % addresses G1, G2, G3\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Three-factor_fast_authentication_scheme_for_e-health_systems_in_5G_wireless_sensor_network.hlpsl",
        "logic": "### Protocol Description\n\n**Protocol Overview:**\nThe protocol is designed for secure communication between a user (U) and a server (S) using symmetric and public key cryptography. It involves registration, login, and fast authentication phases to ensure the security of the user's credentials and to establish a session key for communication.\n\n**Roles:**\n1. **User (U)**: The participant who wants to authenticate to the server.\n2. **Server (S)**: The server that validates the user's credentials and grants access.\n3. **Intruder**: An adversary trying to gain unauthorized access to the system.\n\n---\n\n### Phases of the Protocol:\n\n#### 1. Registration Phase:\n- The user initiates the registration process by sending a `start` message.\n- The user generates a new encryption key (E) and computes a hash of the password and biometric information (BBi).\n- The user also computes a value (W) to be used later in the authentication process and sends the registration information encrypted with a symmetric key (Kus).\n- The server receives the registration information, generates a nonce (Nj), and computes a response which is sent back to the user, encrypted with Kus.\n\n#### 2. Login and Initial Authentication Phase:\n- The user initiates the login process by sending a `start` message again after inserting a smart card.\n- The user computes several values, including a new nonce (N) and a hash of the password and biometric data for authentication.\n- The user sends the login request containing the identity of the user, the server, and other computed values encrypted with the server's public key (Ks).\n- The server verifies the login request, computes new values (A, B) based on the received data, and generates a response back to the user.\n\n#### 3. Fast Authentication Phase:\n- The user can request fast authentication by sending a `start` message and providing updated credentials.\n- The user computes a value (Ay) based on the server\u2019s responses from the previous phase.\n- The server verifies the fast authentication request and responds accordingly.\n\n---\n\n### Security Goals:\n- **Secrecy**: The protocol aims to ensure the confidentiality of the user's password, biometric data, and session keys (g1, g2, g3, g4, g5, g6, g7).\n- **Authentication**: The protocol guarantees that the user (U) is authenticated by the server (S) through mutual authentication guarantees (u_s_v, u_s_tu, s_u_ts).\n\n---\n\n### Key Features:\n- The use of hash functions (H, H1, H2, H6, H7, H14, H16) to ensure data integrity and confidentiality.\n- The generation of session keys for secure communication.\n- The protocol supports mutual authentication to prevent unauthorized access.",
        "code": "role user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDi, PWi & Bi\n\t\t   /\\ E' := new()\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E'))\n\t\t   /\\ SND({IDi.W'.BBi'}_Kus)\n\t\t   /\\ secret(E',g1,{U})\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g3,{U})\n\t\t   /\\ secret(Bi,g4,{U})\n\n\t2.  State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj))\n\t\t   %/\\ Store E, IDi, PWi & Bi in the smart card\n\t\t   %/\\ Store Ej', IDj, & Nj in the USB\n\n% Login and initial authentication phase\n\n\t3.  State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card\n\t\t   %/\\ Enter PWi* & Bi*\n\t\t   /\\ V' := new()\n\t\t   %/\\ Suppose b = 3\n\t\t   /\\ N' := H(H(H(V')))\n\t\t   /\\ BBi' := H(PWi.Bi)\n\t\t   /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E))\n\t\t   /\\ Yij' := xor(E,Ej)\n\t\t   /\\ Tu' := new()\n\t\t   /\\ A' := xor(xor(BBi',W'),Tu')\n\t\t   /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks\n\t\t   /\\ SND(K')\n\t\t   /\\ witness(U,S,u_s_v,V')\n\t\t   /\\ witness(U,S,u_s_tu,Tu')\n\t\t   /\\ secret(IDi,g2,{U,S})\n\t\t   /\\ secret(PWi,g3,{U})\n\t\t   /\\ secret(Bi,g4,{U})\n\n\t4.  State = 1 /\\ RCV(({B'.H(Yij.IDi.H(Xj)).H6(H(H(Yij.IDi.H(Xj)).Xj.As')).H14(H(H(Yij.IDi.H(Xj)).Xj.Bs')).Ts'}_SKij').T1'.T2') =|>\n\t\t   State':= 2\n\t\t   /\\ SKij' := H(xor(N,Yij))\n\t\t   %/\\ Confirm Ts'\n\t\t   %/\\ Confirm B\n\t\t   %/\\ Store IDinew, ATa, ATb in the smart card\n\t\t   %/\\ Store T1, T2 in the USB\n\t\t   /\\ request(S,U,s_u_ts,Ts')\n\n% Fast authentication phase\n\n \t5. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDinew, PWi & Bi\n\t\t   %/\\ Suppose Tlogin = 8\n\t\t   /\\ Ay' := H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As)))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs))))\n\t\t   /\\ SND(Ay')\n\n\t6. State = 1 /\\ RCV({H(xor(Ay',IDinew))}_SKij) =|>\n\t\t   State':= 2\n\t\t   %/\\ Confirm By'\nend role\n\n\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, X, Y, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n\n\t1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj\n\t\t   %/\\ Store IDj\n\t\t   /\\ SND({IDi.Nj.Yij'}_Kus)\n\t\t   /\\ secret(Xj,g5,{S})\n\n% Login and initial authentication phase\n\n\t2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\n\t\t   State':= 1\n\t\t   %/\\ Confirm Tu'\n\t\t   %/\\ Use Xj to decrypt Yij\n\t\t   %/\\ Confirm H(Xj), IDsj & IDi\n\t\t   /\\ A' := xor(xor(BBi.W).Tu')\n\t\t   %/\\ Confirm A\n\t\t   /\\ Ts' := new()\n\t\t   /\\ B' := xor(H(H(H(H(V')))),Ts')\n\t\t   /\\ IDinew' := H(Yij.IDi.H(Xj))\n\t\t   /\\ T1' := new()   /\\ T2' := new()\n\t\t   /\\ As' := new()   /\\ Bs' := new()\n\t\t   %/\\ Z =24, suppose T1=7, T2=10\n\t\t   /\\ ATa' := H6(H(IDinew'.Xj.As'))\n\t\t   /\\ ATb' := H14(H(IDinew'.Xj.Bs'))\n\t\t   /\\ SKij' := H(xor(H(H(H(V'))),Yij'))\n\t\t   /\\ Q':= {B'.IDinew'.ATa'.ATb'.Ts'}_SKij'\n\t\t   /\\ SND (Q'.T1'.T2')\n\t\t   /\\ witness(S,U,s_u_ts,Ts')\n\t\t   /\\ secret(As',g6,{S})\n\t\t   /\\ secret(Bs',g7,{S})\n\t\t   /\\ request(U,S,u_s_v,V')\n\t\t   /\\ request(U,S,u_s_tu,Tu')\n\n% Fast authentication phase\n\n\t3. State = 0 /\\ RCV(H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As')))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs'))))) =|>\n\t\t   State':= 1\n\t\t   /\\ X' := H(IDinew.Xj.As)\n\t\t   /\\ Y' := H(IDinew.Xj.Bs)\n\t\t   /\\ Ay' := H(H7(X').H16(Y'))\n\t\t   %/\\ Confirm Ay\n\t\t   /\\ By' := {H(xor(Ay',IDinew))}_SKij\n\t\t   /\\ SND(By')\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func) def=\n\n  local SU, RU, SS, RS: channel (dy)\n\n  composition\n\n\tuser (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SU,RU)\n          /\\ server (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SS,RS)\n\nend role\n\n\nrole environment() def=\n\n    const u, s: agent,\n\t  kus, skij, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, h1, h2, h6, h7, h14, h16: hash_func,\n\t  u_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5, g6, g7: protocol_id\n\n    intruder_knowledge = {u,s,ks,ki,inv(ki)}\n\n    composition\n\n\tsession(u,s,kus,skij,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(u,i,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\t/\\ session(i,s,kui,kui,ks,h,h1,h2,h6,h7,h14,h16)\n\nend role\n\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6, g7\n  authentication_on u_s_v, u_s_tu, s_u_ts\n\nend goal\n\n\n\nenvironment()",
        "codenote": "role user (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by U def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% In this phase, the user registers with the server by sending their ID, password, and a unique Bi.\n\t1. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   /\\ E' := new() % Generate a new ephemeral secret \n\t\t   /\\ BBi' := H(PWi.Bi) % Compute a hash to create BBi using password and identifier\n\t\t   /\\ W' := H(H(PWi.E').xor(h(xor(IDi,IDj)),E')) % Compute a value W' for later use\n\t\t   /\\ SND({IDi.W'.BBi'}_Kus) % Send registration information to the server securely\n\t\t   /\\ secret(E',g1,{U}) % Store E' as a secret\n\t\t   /\\ secret(IDi,g2,{U,S}) % Store user ID as a secret\n\t\t   /\\ secret(PWi,g3,{U}) % Store password as a secret\n\t\t   /\\ secret(Bi,g4,{U}) % Store biometric data as a secret\n\n% Login and initial authentication phase\n% The user initiates login and authenticates their identity.\n\t2. State = 1 /\\ RCV({IDi.Nj.{H(Xj').IDj.IDi.H(H(PWi.E).xor(h(xor(IDi,IDj)),E)).H(PWi.Bi)}_Xj'}_Kus) =|>\n\t\t   State':= 2\n\t\t   /\\ Ej' := xor(E,({H(Xj).IDj.IDi.W.BBi}_Xj)) % Compute Ej' for further authentication\n\t\t   %/\\ Store E, IDi, PWi & Bi in the smart card\n\t\t   %/\\ Store Ej', IDj, & Nj in the USB\n\n% Login and initial authentication phase\n% The user logs in by sending their ID and other necessary credentials.\n\t3. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Insert smart card\n\t\t   %/\\ Enter PWi* & Bi*\n\t\t   /\\ V' := new() % Generate new value V'\n\t\t   /\\ N' := H(H(H(V'))) % Generate nonce based on V'\n\t\t   /\\ BBi' := H(PWi.Bi) % Hash the password with biometric data\n\t\t   /\\ W' := H(H(PWi.E).xor(h(xor(IDi,IDj)),E)) % Compute W' for the session\n\t\t   /\\ Yij' := xor(E,Ej) % Compute Yij'\n\t\t   /\\ Tu' := new() % Create a new ephemeral value Tu'\n\t\t   /\\ A' := xor(xor(BBi',W'),Tu') % Calculate A' based on previous values\n\t\t   /\\ K' := {IDi.IDj.Yij'.N'.A'.Tu'}_Ks % Create a session key\n\t\t   /\\ SND(K') % Send the session key to the server for validation\n\t\t   /\\ witness(U,S,u_s_v,V') % Witness function for proof of values\n\t\t   /\\ witness(U,S,u_s_tu,Tu') % Witness function for proof of Tu'\n\t\t   /\\ secret(IDi,g2,{U,S}) % Secret of user ID remains secure\n\t\t   /\\ secret(PWi,g3,{U}) % Password is secret\n\t\t   /\\ secret(Bi,g4,{U}) % Biometric data is also kept secret\n\n\t4. State = 1 /\\ RCV(({B'.H(Yij.IDi.H(Xj)).H6(H(H(Yij.IDi.H(Xj)).Xj.As')).H14(H(H(Yij.IDi.H(Xj)).Xj.Bs')).Ts'}_SKij').T1'.T2') =|>\n\t\t   State':= 2\n\t\t   /\\ SKij' := H(xor(N,Yij)) % Compute the session key SKij' based on nonce and Yij\n\t\t   %/\\ Confirm Ts' % Confirm the time stamp for authentication\n\t\t   %/\\ Confirm B % Confirm that B holds\n\t\t   %/\\ Store IDinew, ATa, ATb in the smart card\n\t\t   %/\\ Store T1, T2 in the USB\n\t\t   /\\ request(S,U,s_u_ts,Ts') % Request to send a timestamp to server\n\n% Fast authentication phase\n% In cases of repeated logins, a faster method is applied for re-authentication\n\t5. State = 0 /\\ RCV(start) =|>\n\t\t   State':= 1\n\t\t   %/\\ Enter IDinew, PWi & Bi\n\t\t   %/\\ Suppose Tlogin = 8\n\t\t   /\\ Ay' := H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As)))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs)))) % Generate Ay' for fast authentication\n\t\t   /\\ SND(Ay') % Send Ay' to the server for verification\n\n\t6. State = 1 /\\ RCV({H(xor(Ay',IDinew))}_SKij) =|>\n\t\t   State':= 2\n\t\t   %/\\ Confirm By' % Confirm the response received from the server\n\t\t   %/\\ The server verifies the identity and responds accordingly\n\nend role\n\n\nrole server (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func, SND, RCV: channel (dy))\nplayed_by S def=\n\n  local State: nat,\n        IDi, IDinew, IDj, Nj, PWi, Bi, E, Ej, X, Y, Xj, V, N, N1, BBi, W, Yij, Tu, Ts, T1, T2, A, As, B, Bs, ATa, ATb, SKijNew: text, K, Q, Ay, By: message\n\n  init State := 0\n\n  transition\n\n% Registration phase\n% The server receives the ID and verifies the user's registration.\n\t1. State = 0 /\\ RCV({IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Kus) =|>\n\t\t   State':= 1\n\t\t   /\\ Yij' := {H(Xj).IDj.IDi.H(H(PWi.E').xor(h(xor(IDi,IDj)),E')).H(PWi.Bi)}_Xj % Prepare Yij' for response\n\t\t   %/\\ Store IDj % Store server ID for later references\n\t\t   /\\ SND({IDi.Nj.Yij'}_Kus) % Send the ID and Nj along with Yij back to the client\n\t\t   /\\ secret(Xj,g5,{S}) % Keep Xj secret as part of the protocol\n\n% Login and initial authentication phase\n% Responds to the user's login and continues authentication.\n\t2. State = 0 /\\ RCV({IDi.IDj.Yij'.H(H(H(V'))).A'.Tu'}_Ks) =|>\n\t\t   State':= 1\n\t\t   %/\\ Confirm Tu' % Ensure the timestamp Tu' is valid\n\t\t   %/\\ Use Xj to decrypt Yij\n\t\t   %/\\ Confirm H(Xj), IDsj & IDi\n\t\t   /\\ A' := xor(xor(BBi.W).Tu') % Compute A'\n\t\t   %/\\ Confirm A % Verify A's authenticity\n\t\t   /\\ Ts' := new() % Create new timestamp\n\t\t   /\\ B' := xor(H(H(H(H(V')))),Ts') % Compute response B'\n\t\t   /\\ IDinew' := H(Yij.IDi.H(Xj)) % Compute new IDinew\n\t\t   /\\ T1' := new()   /\\ T2' := new() % Generate new timing parameters\n\t\t   /\\ As' := new()   /\\ Bs' := new() % Generate new values for A and B\n\t\t   %/\\ Z =24, suppose T1=7, T2=10\n\t\t   /\\ ATa' := H6(H(IDinew'.Xj.As')) % Compute ATa'\n\t\t   /\\ ATb' := H14(H(IDinew'.Xj.Bs')) % Compute ATb'\n\t\t   /\\ SKij' := H(xor(H(H(H(V'))),Yij')) % Compute session key based on response\n\t\t   /\\ Q':= {B'.IDinew'.ATa'.ATb'.Ts'}_SKij' % Create a secure response to send to client\n\t\t   /\\ SND (Q'.T1'.T2') % Send the response to the client\n\t\t   /\\ witness(S,U,s_u_ts,Ts') % Witness function to confirm the timestamp\n\t\t   /\\ secret(As',g6,{S}) % Keep As' secret\n\t\t   /\\ secret(Bs',g7,{S}) % Keep Bs' secret\n\n% Fast authentication phase\n% Responds to fast authentication requests from the user.\n\t3. State = 0 /\\ RCV(H(H1(H6(H(H(Yij.IDi.H(Xj)).Xj.As')))).H(H2(H14(H(H(Yij.IDi.H(Xj)).Xj.Bs'))))) =|>\n\t\t   State':= 1\n\t\t   /\\ X' := H(IDinew.Xj.As) % Compute new X\n\t\t   /\\ Y' := H(IDinew.Xj.Bs) % Compute new Y\n\t\t   /\\ Ay' := H(H7(X').H16(Y')) % Compute Ay' for response\n\t\t   %/\\ Confirm Ay % Ensure that the Ay' is correct\n\t\t   /\\ By' := {H(xor(Ay',IDinew))}_SKij % Create a secure response By'\n\t\t   /\\ SND(By') % Send By' back to user for confirmation\n\nend role\n\nrole session (U, S: agent, Kus, SKij: symmetric_key, Ks: public_key, H, H1, H2, H6, H7, H14, H16: hash_func) def=\n\n  local SU, RU, SS, RS: channel (dy)\n\n  composition\n\n\tuser (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SU,RU) % User role execution\n          /\\ server (U,S,Kus,SKij,Ks,H,H1,H2,H6,H7,H14,H16,SS,RS) % Server role execution\n\nend role\n\n\nrole environment() def=\n\n    const u, s: agent,\n\t  kus, skij, kui: symmetric_key,\n\t  ks, ki: public_key,\n\t  h, h1, h2, h6, h7, h14, h16: hash_func,\n\t  u_s_v, u_s_tu, s_u_ts, g1, g2, g3, g4, g5, g6, g7: protocol_id\n\n    intruder_knowledge = {u,s,ks,ki,inv(ki)} % Specifies what the intruder knows initially\n\n    composition\n\n\tsession(u,s,kus,skij,ks,h,h1,h2,h6,h7,h14,h16) % Normal session with user and server\n\t/\\ session(u,i,kui,kui,ks,h,h1,h2,h6,h7,h14,h16) % Session with an intruder\n\t/\\ session(i,s,kui,kui,ks,h,h1,h2,h6,h7,h14,h16) % Session between server and intruder\n\nend role\n\n\ngoal\n\n  secrecy_of g1, g2, g3, g4, g5, g6, g7 % Ensure the secrecy of protocol IDs\n  authentication_on u_s_v, u_s_tu, s_u_ts % Ensure authenticated communication\n\nend goal"
    },
    {
        "file": "HLPSL-1/SPEKE.hlpsl",
        "logic": "---\n\n**Protocol Description: SPEKE (Strong Password-Only Authentication)**\n\n**Purpose**:  \nThe SPEKE (Strong Password-Only Key Exchange) protocol facilitates a secure key exchange between two parties, Alice and Bob, using only a shared password for authentication. The protocol ensures that both parties can establish a common secret key without transmitting the password directly, thus protecting it from potential eavesdroppers.\n\n**Roles**:  \n1. **Alice (A)**: Initiates the communication and starts the key exchange process.\n2. **Bob (B)**: Responds to Alice's requests and participates in the key exchange.\n\n**Key Operations**:  \nThe communication between Alice and Bob consists of several key operations:\n\n1. **Key Exchange Initialization**:\n   - Alice sends a message to Bob containing an exponentiation of the shared password (S(A,B)) and a nonce (Na) which ensures freshness and prevents replay attacks.\n   - Bob responds with a similar message, including his nonce (Nb).\n\n2. **Key Computation**:\n   - Both Alice and Bob compute the shared session key (K) using their received nonces and the shared password:  \n     \\( K = \\text{exp}(\\text{exp}(S(A,B), Na), Nb) = \\text{exp}(\\text{exp}(S(A,B), Nb), Na) \\).\n\n3. **Challenge/Response Authentication**:\n   - Alice sends a challenge (Ca) encrypted with the session key (K).\n   - Bob responds with his challenge (Cb) and Alice's challenge (Ca) encrypted with the session key.\n   - Finally, Alice sends Bob's challenge (Cb) encrypted with the session key to complete the authentication process.\n\n**Secret Management**:  \n- Both parties maintain secrets (Ca and Cb) that are tied to their identities and are used to establish the authenticity of messages exchanged during the protocol.\n- Each party is aware of their secrets and utilizes them for mutual authentication, ensuring that they can verify the identity of each other.\n\n**Security Goals**:  \n1. **Confidentiality**:  \n   - The secrets (Ca and Cb) are kept confidential and are not disclosed to unauthorized parties.\n   \n2. **Authentication**:  \n   - Both Alice and Bob authenticate each other through the exchange of encrypted challenges, ensuring that they are communicating with the intended party and not an imposter.\n\n**Limitations**:  \n- There are no known limitations to this protocol as per the current implementation.\n\n**Classification**:  \n- The protocol falls under classifications G2 and G12, which pertain to message authentication and confidentiality concerns.\n\n**Known Attacks**:  \n- The protocol has been evaluated and is reported to be resistant to known attacks at this time.\n\n**References**:  \n- For a detailed understanding and mathematical foundations of the SPEKE protocol, refer to the original work by Jablon: [Strong Password-Only Authenticated Key Exchange](http://citeseer.ist.psu.edu/jablon96strong.html).\n\n---",
        "code": "%% PROTOCOL*: SPEKE\n%% VARIANT: SPEKE (with strong password-only authentication)\n%% PURPOSE: Strong Password-Only Authenticated Key Exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/jablon96strong.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : exp(S(A,B), Na)     |    key exchange part\n%% B -> A : exp(S(A,B), Nb)     |\n%%\n%%               both A and B compute\n%%               K = exp(exp(S(A,B),Na), Nb) = exp(exp(S(A,B),Nb), Na)\n%%\n%% A -> B : {Ca}_K              |\n%% B -> A : {Cb,Ca}_K           |    challenge/response\n%% A -> B : {Cb}_K              |    authentication part\n%%\n%% S(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%% NOTES: None\n%%\t\n%%HLPSL:\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Init (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n                 \n  local  State: nat,\n         Na,Ca: text,\n         Cb   : text,\n         X,K  : message\n\n  const  sec_i_Ca, sec_i_Cb : protocol_id\n\n  init   State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|> \n      State':= 1 /\\ Na' := new()\n                 /\\ Snd(exp(Kab, Na')) \n        \n   2. State  = 1 /\\ Rcv(X') =|>  \n      State':= 2 /\\ Ca' := new()\n                 /\\ K' := exp(X',Na)\n\t\t /\\ Snd({Ca'}_exp(X',Na))\n\t\t /\\ secret(Ca',sec_i_Ca,{A,B})\n\t\t /\\ witness(A,B,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb'.Ca}_K ) =|> \n      State':= 3 /\\ Snd({Cb'}_K)\n\t\t /\\ secret(Cb',sec_i_Cb,{A,B})\n\t\t /\\ request(A,B,cb,Cb')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Resp (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n           \n\n  local State: nat, \n        Nb,Cb: text,\n        Ca   : text,\n        Y,K  : message\n\n  const sec_r_Ca, sec_r_Cb : protocol_id\n\n  init  State := 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(Y') =|> \n      State':= 1 /\\ Nb' := new()\n                 /\\ Snd(exp(Kab, Nb'))\n\t\t /\\ K' := exp(Y', Nb')\n\n   2. State  = 1 /\\ Rcv({Ca'}_K) =|>  \n      State':= 2 /\\ Cb' := new()\n                 /\\ Snd({Cb'.Ca'}_K)\n\t\t /\\ secret(Ca',sec_r_Ca,{A,B})\n\t\t /\\ secret(Cb',sec_r_Cb,{A,B})\n\t\t /\\ witness(B,A,cb,Cb')\n\t\t /\\ request(B,A,ca,Ca')\n\n   3. State  = 2 /\\ Rcv({Cb}_K) =|> \n      State':= 3 \n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n\t      Kab: symmetric_key)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)\n\n   composition\n\n       speke_Init(A,B,Kab,SA,RA)\n    /\\ speke_Resp(A,B,Kab,SB,RB)\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a, b          : agent,\n        kab, kai, kbi : symmetric_key,\n        ca, cb        : protocol_id\n\n  intruder_knowledge = {a, b, kai, kbi}\n\n  composition\n\tsession(a,b,kab)\n    /\\  session(a,i,kai)\n    /\\  session(i,b,kbi)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n   % Confidentiality (G12)\n   %secrecy_of Ca, Cb \n   secrecy_of sec_i_Ca,sec_i_Cb,\n              sec_r_Ca,sec_r_Cb\n\n   % Message Authentication (G2)\n   % SPEKE_Init authenticates SPEKE_Resp on cb\n   authentication_on cb\n\n   % Message Authentication (G2)\n   % SPEKE_Resp authenticates SPEKE_Init on ca\n   authentication_on ca\n\nend goal  \n \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "codenote": "%% PROTOCOL*: SPEKE\n%% VARIANT: SPEKE (with strong password-only authentication)\n%% PURPOSE: Strong Password-Only Authenticated Key Exchange\n%% REFERENCE:\n%% \\url{http://citeseer.ist.psu.edu/jablon96strong.html}\n%% MODELER:\n%% \\begin{itemize}\n%%  \\item Haykal Tej, Siemens CT IC 3, 2003\n%%  \\item Sebastian M{\\\"o}dersheim, ETH Z{\\\"u}rich, December 2003\n%% \\end{itemize}\n%%\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% A -> B : exp(S(A,B), Na)     |    key exchange part\n%% B -> A : exp(S(A,B), Nb)     |\n%%\n%%               both A and B compute\n%%               K = exp(exp(S(A,B),Na), Nb) = exp(exp(S(A,B),Nb), Na)\n%%\n%% A -> B : {Ca}_K              |\n%% B -> A : {Cb,Ca}_K           |    challenge/response\n%% A -> B : {Cb}_K              |    authentication part\n%%\n%% S(A,B): password (shared key)\n%% \\end{verbatim}\n%%\n%% LIMITATIONS: None\n%%\n%% PROBLEMS: 3\n%%\n%% CLASSIFICATION: G2 G12\n%%\n%% ATTACKS: None\n%% NOTES: None\n%%\t\n%%HLPSL:\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Init (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by A\ndef=\n                 \n  local  State: nat,          % State variable to track the protocol state\n         Na,Ca: text,        % Nonce for A (Na) and challenge for A (Ca)\n         Cb   : text,        % Challenge for B (Cb)\n         X,K  : message       % Received message (X) and computed key (K)\n\n  const  sec_i_Ca, sec_i_Cb : protocol_id  % Protocol IDs for secrets\n\n  init   State := 0           % Initializing the state to 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(start) =|>  % Transition from state 0 upon receiving 'start'\n      State':= 1 /\\ Na' := new()     % Move to state 1 and generate new nonce for A\n                 /\\ Snd(exp(Kab, Na'))  % Send the encrypted nonce to B\n        \n   2. State  = 1 /\\ Rcv(X') =|>  % Transition to state 2 upon receiving message from B\n      State':= 2 /\\ Ca' := new()     % Generate challenge for A\n                 /\\ K' := exp(X',Na)   % Compute the key K using received X'\n\t\t /\\ Snd({Ca'}_exp(X',Na)) % Send the challenge encrypted with the key\n\t\t /\\ secret(Ca',sec_i_Ca,{A,B}) % Declare Ca' as a secret\n\t\t /\\ witness(A,B,ca,Ca')   % Witness that A knows Ca'\n\n   3. State  = 2 /\\ Rcv({Cb'.Ca}_K ) =|>  % Transition to state 3 upon receiving response from B\n      State':= 3 /\\ Snd({Cb'}_K)          % Send the encrypted challenge Cb' back to B\n\t\t /\\ secret(Cb',sec_i_Cb,{A,B}) % Declare Cb' as a secret\n\t\t /\\ request(A,B,cb,Cb')   % Request to authenticate challenge Cb'\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole speke_Resp (A,B: agent,\n                 Kab: symmetric_key,\n                 Snd,Rcv: channel(dy))\nplayed_by B\ndef=\n           \n\n  local State: nat,       % State variable for B's protocol state\n        Nb,Cb: text,     % Nonce for B (Nb) and challenge for B (Cb)\n        Ca   : text,     % Challenge received from A (Ca)\n        Y,K  : message    % Received message (Y) and computed key (K)\n\n  const sec_r_Ca, sec_r_Cb : protocol_id  % Protocol IDs for secrets\n\n  init  State := 0        % Initializing the state to 0\n\n  transition\n\n   1. State  = 0 /\\ Rcv(Y') =|>   % Transition from state 0 upon receiving reply from A\n      State':= 1 /\\ Nb' := new()   % Move to state 1 and generate new nonce for B\n                 /\\ Snd(exp(Kab, Nb')) % Send the encrypted nonce to A\n\t\t /\\ K' := exp(Y', Nb')  % Compute the key K using received Y'\n\n   2. State  = 1 /\\ Rcv({Ca'}_K) =|>  % Transition to state 2 upon receiving challenge from A\n      State':= 2 /\\ Cb' := new()       % Generate challenge for B\n                 /\\ Snd({Cb'.Ca'}_K)   % Send back Cb' encrypted with the key K\n\t\t /\\ secret(Ca',sec_r_Ca,{A,B}) % Declare Ca' as a secret\n\t\t /\\ secret(Cb',sec_r_Cb,{A,B}) % Declare Cb' as a secret\n\t\t /\\ witness(B,A,cb,Cb')   % Witness that B knows Cb'\n\t\t /\\ request(B,A,ca,Ca')   % Request to authenticate challenge Ca'\n\n   3. State  = 2 /\\ Rcv({Cb}_K) =|>  % Transition to state 3 upon receiving response from A\n      State':= 3  % Protocol is complete for B\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session (A,B: agent,\n\t      Kab: symmetric_key)\ndef=\n\n   local SA,RA,SB,RB: channel (dy)  % Define channels for communication\n\n   composition\n\n       speke_Init(A,B,Kab,SA,RA)  % Initializing Alice's protocol\n    /\\ speke_Resp(A,B,Kab,SB,RB)  % Initializing Bob's protocol\n\nend role\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n  const a, b          : agent,            % Define agents\n        kab, kai, kbi : symmetric_key,    % Define symmetric keys\n        ca, cb        : protocol_id       % Define protocol IDs for challenges\n\n  intruder_knowledge = {a, b, kai, kbi}  % Knowledge of the intruder\n\n  composition\n\tsession(a,b,kab)          % Session between Alice (a) and Bob (b)\n    /\\  session(a,i,kai)      % Session between Alice (a) and the intruder (i)\n    /\\  session(i,b,kbi)      % Session between the intruder (i) and Bob (b)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n   % Confidentiality (G12)\n   %secrecy_of Ca, Cb \n   secrecy_of sec_i_Ca,sec_i_Cb,  % Ensure the secrets remain confidential\n              sec_r_Ca,sec_r_Cb\n\n   % Message Authentication (G2)\n   % SPEKE_Init authenticates SPEKE_Resp on cb\n   authentication_on cb  % Ensure initiation authenticates response\n\n   % Message Authentication (G2)\n   % SPEKE_Resp authenticates SPEKE_Init on ca\n   authentication_on ca  % Ensure response authenticates initiation\n\nend goal  \n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/ISO2.hlpsl",
        "logic": "---\n\n**Protocol Title**: ISO2 Public Key Unilateral Authentication Protocol\n\n**Variant**: Two-pass unilateral authentication\n\n**Purpose**: This protocol is designed for the authentication of a client (referred to as Alice) to a server (referred to as Bob). In this scenario, the server initiates the session and seeks to verify the identity of the client. The client responds by sending its digital signature.\n\n**Reference**:\n- The protocol draws on concepts from existing literature, including:\n  - Clark, J., & Jacob, J. (1997). A survey of authentication protocols.\n  - ISO/IEC 9798-3: Information technology - Security techniques - Entity authentication.\n\n**Modelers**:\n- Haykal Tej, Siemens CT IC 3, 2003\n- Luca Compagna et al., AI-Lab DIST, University of Genova, November 2004\n\n**Participants**: \n- **Alice (A)**: The client who wants to authenticate itself to the server.\n- **Bob (B)**: The server that requires verification of Alice's identity.\n\n**Protocol Steps**:\n1. Bob sends a nonce (Rb) and a text message (Text1) to Alice.\n2. Upon receiving the message, Alice generates a nonce (Ra) and sends back a message containing:\n   - Her public key (PKa) and her identity (A), signed with Bob's private key (inv(PKs)), \n   - The nonces Ra and Rb,\n   - Bob's identity (B),\n   - A second text message (Text2),\n   - A signature of the message composed of Ra, Rb, B, and Text1, signed with her private key (inv(PKa)).\n\n**Problems**: There is one identified problem in the protocol (details would be specified in an actual analysis).\n\n**Classification**: G1, G2 (indicating the goals related to authenticity and secrecy)\n\n**Attacks**: None identified in the protocol as presented.\n\n**Notes**:\n- The notation `inv(PKs)` refers to the private key of the server (Bob).\n- The notation `{PKa,A}inv(PKs)` denotes the certificate of the agent Alice.\n\n**Roles in the Protocol**:\n- **iso2_Init**: The role for the server (Bob) which starts the protocol by sending the initial message.\n- **iso2_Resp**: The role for the client (Alice) that responds to the server's challenge with a signed message.\n- **session**: This role orchestrates the interaction between the two roles, establishing the communication channels.\n\n**Environment**: \n- The environment consists of constants for text messages, agents, and public keys. It includes an intruder with knowledge of certain elements (e.g., public keys, messages) and allows for multiple sessions to be established.\n\n**Goal**: The primary goal of the protocol is to ensure that Alice successfully authenticates herself to Bob, which addresses the goals G1 and G2 in the AVISPA classification.\n\n---",
        "code": "%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\nrole iso2_Init (B,A    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()\n      /\\ Snd(Rb'.ctext1)\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,A,ra,Ra')\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,B,ra,Ra')\n\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole session (B, A : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session\n\n  composition\n\n\tsession(a,b,pkb,pks)\n     /\\\tsession(a,i,pki,pks)\n     /\\\tsession(i,b,pkb,pks)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()",
        "codenote": "%% PROTOCOL*: ISO2 Public Key Unilateral Authentication Protocol\n%% VARIANT: two-pass unilateral authentication\n%% PURPOSE: Authentication of a client to a server. This protocol models a situation\n%% in which the server wants to verify the client identity and starts the session.\n%% The client answers by sending his digital signature.\n%% REFERENCE:\n%% \\begin{itemize}\n%% \\item \\cite{clark97survey,ISO-IEC-9798-3}\n%% \\end{itemize}\n%% MODELER:\n%% \\begin{itemize}\n%% \\item Haykal Tej, Siemens CT IC 3, 2003 and\n%% \\item Luca Compagna et al, AI-Lab DIST University of Genova, November 2004\n%% \\end{itemize}\n%% ALICE_BOB:\n%% \\begin{verbatim}\n%% 1. B -> A : Rb, Text1\n%% 2. A -> B : {PKa,A}inv(PKs), Ra,Rb, B, Text2,{Ra,Rb,B,Text1}inv(PKa)\n%% \\end{verbatim}\n%% PROBLEMS: 1\n%% CLASSIFICATION: G1, G2\n%% ATTACKS: None\n%% NOTES:\n%% \\verb!inv(PKs)! is the private key of the server \\verb!C!;\n%% \\verb!{PKa,A}inv(PKs)! is the certificate of agent \\verb!A!.\\\\\n%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \t\n%% HLPSL:\n\n%% This role initiates the protocol session from server's perspective\nrole iso2_Init (B,A    : agent,\n                Pks    : public_key, \n                Snd,Rec: channel(dy))\nplayed_by B\ndef=\n\n  local  State     : nat,\n         Pka  \t   : public_key,\n         Rb   \t   : text,\n         Ra, Text2 : text\n\n  init State := 0\n\n%%%  knowledge(B)={A,B,ctext1,Pks}  %% Server's knowledge includes its own identity, client's identity, and relevant cryptographic elements.\n\n  transition\n\n   1. State = 0\n      /\\ Rec(start)\n      =|>\n      State' := 1 \n      /\\ Rb' := new()  %% Rb is a nonce generated by the server for session\n      /\\ Snd(Rb'.ctext1)  %% Server sends the nonce and a text message\n\n   2. State = 1\n      /\\ Rec(Pka'.A.{Pka'.A}_inv(Pks).Ra'.Rb.B.Text2'.\n                    {Ra'.Rb.B.ctext1}_inv(Pka'))  \n      =|> \n      State' := 2 \n      /\\ request(B,A,ra,Ra')  %% Request for authentication completion with the received Ra\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\n%% This role responds to the server's challenge from client's side\nrole iso2_Resp (A,B    : agent,\n                Pka,Pks: public_key,\n                Snd,Rec: channel(dy))\nplayed_by A\ndef=\n\n  local  State     : nat,\n         Ra\t   : text,\n         Rb, Text1 : text\n\n  init State := 0\n\n%%%  knowledge(A)={A,B,Pka,Pks,ctext2,inv(Pka),{Pka.A}_inv(Pks)}  %% Client's knowledge includes its own identity, server's identity, and relevant cryptographic elements.\n\n  transition\n\n   1. State = 0\n      /\\ Rec(Rb'.Text1')\n      =|> \n      State' := 2 \n      /\\ Ra' := new()  %% Client generates its nonce Ra for authentication\n      /\\ Snd(Pka.A.{Pka.A}_inv(Pks).Ra'.Rb'.B.ctext2.\n                   {Ra'.Rb'.B.Text1'}_inv(Pka))\n      /\\ witness(A,B,ra,Ra')  %% Client provides witness for authentication with Ra\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\n%% Session role combines the initialization and response parts of the protocol\nrole session (B, A : agent,\n\t      Pka  : public_key,\n              Pks  : public_key) def=\n\n  local SA, RA, SB, RB: channel (dy)\n  composition\n\n          iso2_Init(B,A,Pks,SB,RB)  %% Server initialization\n       /\\ iso2_Resp(A,B,Pka,Pks,SA,RA)  %% Client response\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\n%% The environment encompasses the entire protocol sessions and the intruder's knowledge\nrole environment() def=\n\n  const  ctext1,ctext2 : text,\n\t ra\t       : protocol_id,\n         a,b,i         : agent,\t\n         pkb,pks,pki   : public_key\n  \n  intruder_knowledge={i,a,b,pks,pki,inv(pki),ctext1,ctext2,\n                      {pki.i}_inv(pks)}   %%% 2nd session  %% Intruder's knowledge includes its own identity, the client's, the server's public key, and relevant cryptographic elements.\n\n  composition\n\n\tsession(a,b,pkb,pks)  %% First session between a client and the server\n     /\\\tsession(a,i,pki,pks)  %% Second session between client and an intruder\n     /\\\tsession(i,b,pkb,pks)  %% Third session between the intruder and the server\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\ngoal\n\n   %ISO2_Init  authenticates ISO2_Resp on ra\n   authentication_on ra % addressess G1 and G2   %% This goal defines the authentication target within the protocol\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\nenvironment()"
    },
    {
        "file": "HLPSL-1/Kerberos.hlpsl",
        "logic": "### Description of the Kerberos Network Authentication Service (V5)\n\n#### Overview\nKerberos is a network authentication protocol designed to provide secure authentication, authorization, and key exchange across insecure networks. It employs a trusted third-party approach, where a client (representing a user) can prove its identity to a server (an application or service) without the need to transmit sensitive information that could be intercepted by attackers. The protocol ensures that even if the communication is intercepted, it does not compromise the user's credentials.\n\n#### Components\n- **Client (C)**: The entity (user or application) that seeks to authenticate itself to the server.\n- **Authentication Server (A)**: The server that verifies the client's identity and provides it with credentials to access the Ticket Granting Server (TGS).\n- **Ticket Granting Server (G)**: This server issues tickets that the client can use to request access to specific services on the network.\n- **Server (S)**: The application server that the client wants to communicate with after authentication.\n\n#### Keys\n- **K_AB**: Shared or intended shared key between the Authentication Server and the principal (client).\n- **K_CA**: Key shared between the client and the authentication server.\n- **K_AG**: Key shared between the authentication server and the ticket granting server.\n- **K_GS**: Key shared between the ticket granting server and the service server.\n- **K_CG**: Key established during the protocol for communication between the client and the ticket granting server.\n- **K_CS**: Key established for communication between the client and the server.\n\n#### Protocol Steps\n1. The **client (C)** sends a request to the **authentication server (A)**, including the desired service (G), the requested lifetime for the ticket, and a nonce (N1) for freshness.\n2. The **authentication server (A)** responds to the client with a ticket (Ticket_1) for the ticket granting server and a session key (K_CG), encrypted with the client\u2019s key (K_CA).\n3. The client then forwards the received ticket along with a request for the desired server (S) to the **ticket granting server (G)**, including a nonce (N2) for freshness.\n4. The **ticket granting server (G)** verifies the request and responds with a ticket for the desired service (Ticket_2) and a session key (K_CS), encrypted with the key shared between the TGS and the service server (K_GS).\n5. The client sends the ticket for the service (Ticket_2) and a request to the **server (S)**.\n6. The server responds to the client with a confirmation message, completing the authentication process.\n\n#### Limitations\nThe protocol does not implement ticket caching, which could potentially lead to weaknesses in authentication. Some implementations may not perform ticket caching as expected.\n\n#### Agents Involved\n- **Client (C)**\n- **Authentication Server (A)**\n- **Ticket Granting Server (G)**\n- **Service Server (S)**\n\n#### Goals of the Protocol\nThe key goals of the Kerberos protocol include:\n- Ensuring the secrecy of session keys (K_CG and K_CS) shared between the client and the servers.\n- Providing weak authentication guarantees, which verify that the client, authentication server, ticket granting server, and service server recognize each other during the authentication process.\n\n#### Security Objectives\n- Secrecy of the keys used in the authentication process.\n- Weak authentication of the involved parties, ensuring that each server can ascertain the authenticity of the client and vice versa.\n\n### Reference\nFor additional details on Kerberos, refer to the IETF draft: [Kerberos Clarifications](http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt).\n\n### Modelers\nThe protocol was initially modeled by:\n- Haykal Tej, Siemens CT IC 3, 2003\n- Sebastian M\u00f6dersheim, Computer Security Group, ETH Z\u00fcrich, January 2004\n- The AVISPA team (since then)",
        "code": "%% PROTOCOL: Kerberos Network Authentication Service (V5)\n%% VARIANT: basic (core)\n%% PURPOSE: Authentication, Authorisation, Key Exchange\n%%\n%% Kerberos is a distributed authentication service that allows a process\n%% (a client) running on behalf of a principal (a user) to prove its identity\n%% to a verifier (an application server, or just server) without sending data\n%% across the network that might allow an attacker or the verifier to\n%% subsequently impersonate the principal. Kerberos optionally provides\n%% integrity and confidentiality for data sent between the client and server.\n%% \n%% REFERENCE: \n%%\\begin{itemize}\n%%\\item \\url{http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt}\n%%\\end{itemize}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M\\\"odersheim, Computer Security Group,\n%%\tETH Z\\\"{u}rich, January 2004\n%%   \\item AVISPA team (since then)\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% C: Client\n%% A: Authentication Server\n%% G: Ticket Granting Server\n%% S: Server (that the client wants to talk to)\n%%\n%% K_AB: key shared or intended to be shared between A and B\n%%       Initially shared: K_CA, K_AG, K_GS\n%%       Established during protocol: K_CG, K_CS\n%%\n%% All things marked * are timestamp-related and will be simply replaced\n%% with fresh text. \n%% \n%% Macros:\n%% Ticket_1 := { C,G, K_CG, Tstart*, Texpire* }K_AG\n%% Ticket_2 := { C,S, K_CS, Tstart2*, Texpire2* }K_GS\n%%\n%% 1. C -> A : C,G,Lifetime_1*,N_1\n%% 2. A -> C : C, Ticket_1, { G, K_CG, Tstart*, Texpire*, N_1 }K_CA\n%%\n%% 3. C -> G : S,Lifetime_2*,N_2,Ticket_1, { C,T* }K_CG\n%% 4. G -> C : C, Ticket_2, { S, K_CS, Tstart2*, Texpire2*, N_2 }K_CG\n%%\n%% 5. C -> S : Ticket_2, { C, T2* }K_CS\n%% 6. S -> C : { T2* }K_CS\n%%\\end{verbatim}\n%%\n%% LIMITATIONS: \n%% \n%% Ticket Caching is not performed, so only weak authentication is provided.\n%% It is rumoured that implementations do not perform ticket caching.\n%%\n%% PROBLEMS: 8\n%% ATTACKS: None\n%% \n%% NOTES: \n%%\n%% Agents involved: Client,  Authentication Server (AS), Ticket Granting server \n%% (TGS),  Server where the client needs to authenticate (Server) \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\n% Authentication Server\nrole kerberos_A (A, C, G : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA, K_AG : symmetric_key)\nplayed_by A\ndef=\n\n  local St              : nat,\n        K_CG            : symmetric_key,\n        N1, Lifetime_1  : text,\n        Tstart, Texpire : text\n\n  const k_cg : protocol_id,\n        sec_a_K_CG : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(C.G.Lifetime_1'.N1') =|> \n      St':= 1 /\\ Tstart' := new()\n              /\\ Texpire' := new()\n              /\\ K_CG' := new()\n              /\\ Snd(C.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.\n\t                {G.K_CG'.Tstart'.Texpire'.N1'}_K_CA) \n\t      /\\ witness(A,C,k_cg,K_CG')\n\t      /\\ witness(A,G,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_a_K_CG,{A,C,G})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Ticket Granting Server\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local St                                 : nat,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2 : text,\n        Tstart2, Texpire2                  : text\n\n  const t1,k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 Snd, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2a, t2b : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2a,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2a\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "codenote": "%% PROTOCOL: Kerberos Network Authentication Service (V5)\n%% VARIANT: basic (core)\n%% PURPOSE: Authentication, Authorisation, Key Exchange\n%%\n%% Kerberos is a distributed authentication service that allows a process\n%% (a client) running on behalf of a principal (a user) to prove its identity\n%% to a verifier (an application server, or just server) without sending data\n%% across the network that might allow an attacker or the verifier to\n%% subsequently impersonate the principal. Kerberos optionally provides\n%% integrity and confidentiality for data sent between the client and server.\n%% \n%% REFERENCE: \n%%\\begin{itemize}\n%%\\item \\url{http://www.ietf.org/internet-drafts/draft-ietf-krb-wg-kerberos-clarifications-07.txt}\n%%\\end{itemize}\n%% MODELER: \n%%   \\begin{itemize}\n%%   \\item Haykal Tej, Siemens CT IC 3, 2003\n%%   \\item Sebastian M\\\"odersheim, Computer Security Group,\n%%\tETH Z\\\"{u}rch, January 2004\n%%   \\item AVISPA team (since then)\n%%   \\end{itemize}\n%%\n%% ALICE_BOB:\n%%\\begin{verbatim}\n%% C: Client\n%% A: Authentication Server (AS)\n%% G: Ticket Granting Server (TGS)\n%% S: Server (that the client wants to talk to)\n%%\n%% K_AB: key shared or intended to be shared between A and B\n%%       Initially shared: K_CA, K_AG, K_GS\n%%       Established during protocol: K_CG, K_CS\n%%\n%% All things marked * are timestamp-related and will be simply replaced\n%% with fresh text. \n%% \n%% Macros:\n%% Ticket_1 := { C,G, K_CG, Tstart*, Texpire* }K_AG\n%% Ticket_2 := { C,S, K_CS, Tstart2*, Texpire2* }K_GS\n%%\n%% 1. C -> A : C,G,Lifetime_1*,N_1\n%% 2. A -> C : C, Ticket_1, { G, K_CG, Tstart*, Texpire*, N_1 }K_CA\n%%\n%% 3. C -> G : S,Lifetime_2*,N_2,Ticket_1, { C,T* }K_CG\n%% 4. G -> C : C, Ticket_2, { S, K_CS, Tstart2*, Texpire2*, N_2 }K_CG\n%%\n%% 5. C -> S : Ticket_2, { C, T2* }K_CS\n%% 6. S -> C : { T2* }K_CS\n%%\\end{verbatim}\n%%\n%% LIMITATIONS: \n%% \n%% Ticket Caching is not performed, so only weak authentication is provided.\n%% It is rumoured that implementations do not perform ticket caching.\n%%\n%% PROBLEMS: 8\n%% ATTACKS: None\n%% \n%% NOTES: \n%%\n%% Agents involved: Client, Authentication Server (AS), Ticket Granting Server \n%% (TGS), Server where the client needs to authenticate (Server) \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% HLPSL:\n\n% Authentication Server\nrole kerberos_A (A, C, G : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA, K_AG : symmetric_key)\nplayed_by A\ndef=\n\n  local St              : nat,\n        K_CG            : symmetric_key,\n        N1, Lifetime_1  : text,\n        Tstart, Texpire : text\n\n  const k_cg : protocol_id,\n        sec_a_K_CG : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(C.G.Lifetime_1'.N1') =|> \n      St':= 1 /\\ Tstart' := new()\n              /\\ Texpire' := new()\n              /\\ K_CG' := new()\n              /\\ Snd(C.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.\n\t                {G.K_CG'.Tstart'.Texpire'.N1'}_K_CA) \n\t      /\\ witness(A,C,k_cg,K_CG')\n\t      /\\ witness(A,G,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_a_K_CG,{A,C,G})\n\n      % State transition 0 to 1 upon successful request from client.\n      % Generates a new key (K_CG) and the timestamps needed for secure communication.\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Ticket Granting Server\nrole kerberos_G (G, A, S, C  : agent,\n                 Snd, Rcv    : channel (dy),\n                 K_AG, K_GS  : symmetric_key)\nplayed_by G\ndef=\n\n  local St                                 : nat,\n        K_CG                               : symmetric_key,\n        K_CS                               : symmetric_key,\n        Lifetime_2, Tstart, Texpire, T, N2 : text,\n        Tstart2, Texpire2                  : text\n\n  const t1,k_cs : protocol_id,\n        sec_g_K_CG, sec_g_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ \n       Rcv(S.Lifetime_2'.N2'.{C.G.K_CG'.Tstart'.Texpire'}_K_AG.{C.T'}_K_CG') =|>\n      St':= 1 /\\ K_CS' := new()\n              /\\ Tstart2' := new()\n              /\\ Texpire2' := new()\n              /\\ Snd(C.\n\t           {C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.\n\t             {S.K_CS'.Tstart2'.Texpire2'.N2'}_K_CG') \n\t      /\\ wrequest(G,C,t1,T')\n\t      /\\ wrequest(G,A,k_cg,K_CG')\n\t      /\\ witness(G,S,k_cs,K_CS')\n\t      /\\ witness(G,C,k_cs,K_CS')\n\t      /\\ secret(K_CG',sec_g_K_CG,{A,C,G})\n\t      /\\ secret(K_CS',sec_g_K_CS,{G,C,S})\n\n      % State transition 0 to 1 upon receiving client request and issuing server ticket.\n      % Generates new session key K_CS and manages associated timestamps for secure sessions.\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Server\nrole kerberos_S (S, G, C  : agent,\n                 Snd, Rcv : channel (dy),\n                 K_GS     : symmetric_key)\nplayed_by S\ndef=\n\n  local St                    : nat,\n        Tstart2, Texpire2, T2 : text,\n        K_CS                  : symmetric_key\n\n  const t2a, t2b : protocol_id,\n        sec_s_K_CS : protocol_id\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv({C.S.K_CS'.Tstart2'.Texpire2'}_K_GS.{C.T2'}_K_CS') =|> \n      St':= 1 /\\  Snd({T2'}_K_CS')\n\t      /\\ witness(S,C,t2a,T2') \n\t      /\\ wrequest(S,G,k_cs,K_CS')\n\t      /\\ wrequest(S,C,t2b,T2')\n\t      /\\ secret(K_CS',sec_s_K_CS,{G,C,S})\n\n      % State transition 0 to 1 after validation of the session ticket from client.\n      % Schedules the return of a secure token back to the client.\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Client\nrole kerberos_C (C, A, G, S : agent,\n                 Snd, Rcv   : channel (dy),\n                 K_CA       : symmetric_key)\nplayed_by C\ndef=\n\n  local St                                  : nat,\n      K_CG, K_CS                            : symmetric_key,\n      T, T2 : text,\n      Tstart, Texpire, Tstart2, Texpire2    : text,\n      Ticket_1, Ticket_2 : {agent.agent.symmetric_key.text.text}_symmetric_key,\n      N1, N2  : text\n\n  const t1, k_cg, k_cs, t2a, t2b : protocol_id,\n        sec_c_K_CG, sec_c_K_CS : protocol_id,\n        cLifetime_1, cLifetime_2: text\n\n  init  St := 0\n\n  transition\n\n   1. St = 0  /\\ Rcv(start) =|> \n      St':= 1 /\\ N1' := new()\n              /\\ Snd(C.G.cLifetime_1.N1') \n\n      % State transition from 0 to 1 when the client starts the authentication process.\n      % Produces a fresh nonce N1 that enhances security in subsequent exchanges.\n\n   2. St = 1  /\\ Rcv(C.Ticket_1'.{G.K_CG'.Tstart'.Texpire'.N1}_K_CA) =|> \n      St':= 2 /\\ N2' := new()\n              /\\ T' := new()\n              /\\ Snd(S.cLifetime_2.N2'.Ticket_1'.{C.T'}_K_CG') \n\t      /\\ witness(C,G,t1,T')\n\t      /\\ wrequest(C,A,k_cg,K_CG')\n\t      /\\ secret(K_CG',sec_c_K_CG,{A,C,G})\n\n      % State transition from 1 to 2 after receiving ticket from AS and validating it.\n      % This results in a fresh nonce N2 and prepares to request the service ticket.\n\n   3. St = 2  /\\ Rcv(C.Ticket_2'.{S.K_CS'.Tstart2'.Texpire2'.N2}_K_CG)  =|>\n      St':= 3 /\\ T2' := new()\n              /\\ Snd(Ticket_2'.{C.T2'}_K_CS') \n\t      /\\ witness(C,S,t2b,T2')\n\t      /\\ wrequest(C,G,k_cs,K_CS')\n\t      /\\ secret(K_CS',sec_c_K_CS,{G,C,S})\n\n      % State transition from 2 to 3 after obtaining service ticket from TGS.\n      % Generates a fresh token T2 for communication with the intended service.\n\n   4. St = 3  /\\ Rcv({T2}_K_CS) =|> \n      St':= 4 /\\ wrequest(C,S,t2a,T2)\n\n      % Final state transition upon receiving the service token from the server.\n      % Facilitates continuing communication securely with the server.\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session( C, A, G, S                             : agent,\n\t      K_CA, K_AG, K_GS                       : symmetric_key)\ndef=\n\n   local S_C, R_C, S_A, R_A, S_G, R_G, S_S, R_S : channel (dy)\n\n   composition\n\n        kerberos_C(C,A,G,S,S_C,R_C,K_CA) \n     /\\ kerberos_A(A,C,G,S_A,R_A,K_CA,K_AG)\n     /\\ kerberos_G(G,A,S,C,S_G,R_G,K_AG,K_GS)\n     /\\ kerberos_S(S,G,C,S_S,R_S,K_GS)\n\nend role\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment() def=\n\n  const  c, a, g, s, i           : agent,\n\t kca, kag, kgs, kia      : symmetric_key\n\n  intruder_knowledge = {c,a,g,s,kia\n                       }\n\n  composition\n\tsession(c,a,g,s,kca,kag,kgs)\n /\\\tsession(i,a,g,s,kia,kag,kgs)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n\n  %secrecy_of K_CG, K_CS \n  secrecy_of sec_a_K_CG,\n             sec_g_K_CG, sec_g_K_CS,\n             sec_s_K_CS,\n             sec_c_K_CG, sec_c_K_CS\n\n  %Kerberos_C weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n  %Kerberos_G weakly authenticates Kerberos_A on k_cg\n  weak_authentication_on k_cg\n\n  %Kerberos_C weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n  %Kerberos_S weakly authenticates Kerberos_G on k_cs\n  weak_authentication_on k_cs\n\n  %Kerberos_C weakly authenticates Kerberos_S on t2a\n  weak_authentication_on t2a\n  %Kerberos_S weakly authenticates Kerberos_C on t2b\n  weak_authentication_on t2a\n  \n  %Kerberos_G weakly authenticates Kerberos_C on t1\n  weak_authentication_on t1\n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()"
    },
    {
        "file": "HLPSL-1/TLS.hlpsl",
        "logic": "### Protocol Description for TLS (Transport Layer Security)\n\n#### Overview\nThe TLS protocol is designed to provide secure communication over a computer network. It ensures privacy, integrity, and authenticity of the data exchanged between two parties, typically referred to as a client (Alice) and a server (Bob). The protocol achieves these goals through cryptographic techniques, including the use of public and private keys, hash functions, and session keys.\n\n#### Roles\n1. **Alice (Client)**: Represents the client in the communication. Alice initiates the connection and sends a start message to the server.\n2. **Bob (Server)**: Represents the server that responds to the client's requests. Bob processes the messages received from Alice and manages the session keys.\n3. **Session Role**: Manages the composition of both Alice and Bob, ensuring the transfer of messages between them.\n4. **Environment Role**: Represents the external environment, including the intruder and the agents. It initializes the protocol and defines the knowledge of the intruder.\n\n#### Protocol Steps\n1. **Initiation**:\n   - Alice starts the protocol by sending a message that includes a nonce (`Na`), a session identifier (`Sid`), and a public key (`Pa`).\n\n2. **Response**:\n   - Upon receiving the start message, Bob generates a nonce (`Nb`) and sends a response back to Alice, which contains the nonce, the session identifier, and the public key encrypted with its own private key.\n\n3. **Key Generation**:\n   - Alice and Bob then generate a pre-master secret (`PMS`) based on their nonces and the public keys exchanged. They also compute session keys (`ClientK` for Alice and `ServerK` for Bob) using a key generation function that combines their identities and the `PMS`.\n\n4. **Message Authentication**:\n   - Both parties send hashed messages to each other, which include the nonces and the session keys, ensuring the authenticity of the communication.\n\n5. **Finished Message**:\n   - Finally, Bob sends a finished message to Alice, indicating that the session is established and secure. This message is also protected using the server's session key.\n   \n#### Security Goals\nThe protocol aims to achieve the following security goals:\n- **Secrecy**: The shared session keys (`sec_clientk` and `sec_serverk`) should remain confidential between Alice and Bob.\n- **Authentication**: Alice should be able to authenticate Bob using nonce `na_nb1`, and Bob should be able to authenticate Alice using nonce `na_nb2`.\n\n#### Intruder Model\nThe environment includes an intruder who has access to certain public keys and can intercept messages. The intruder's knowledge includes the identities and public keys of Alice and Bob, as well as the ability to generate responses based on intercepted messages, but does not have access to the private keys.",
        "code": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const sec_clientk, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (dy))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Ka, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2 : protocol_id,\n         h, prf, keygen : hash_func,\n         a, b           : agent,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nenvironment()",
        "codenote": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% YAZAR: MEHMET EM\u0130N KONUK\n%% PROTOKOL: TLS: Transport Layer Security (Ta\u015f\u0131ma Katman\u0131 G\u00fcvenli\u011fi)\n%% **Bu spesifikasyon TLS protokol\u00fcn\u00fcn AVISPA i\u00e7in k\u0131salt\u0131lm\u0131\u015f bir versiyonudur**\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nrole alice(A, B : agent,  \n\t   H, PRF, KeyGen: hash_func,\n\t   Ka, Ks: public_key,  %% Ks a\u00e7\u0131k anahtar\n\t   SND, RCV: channel (dy))\nplayed_by A\ndef=\n\n   local Na, Sid, Pa, PMS: text,\n         Nb: text,\n         State: nat,\n         Finished: hash(hash(text.text.text).agent.agent.text.text.text),\n         ClientK, ServerK: hash(agent.text.text.hash(text.text.text)),\n         Kb: public_key,\n         M: hash(text.text.text)\n\n   const sec_clientk, sec_serverk : protocol_id\n\n   init  State := 0\n\n   transition\n\n   1.  State = 0\n       /\\ RCV(start)\n       =|>\n       State' := 2\n       /\\ Na' := new()\n       /\\ Pa' := new()\n       /\\ Sid' := new()\n       /\\ SND(A.Na'.Sid'.Pa')\n\n   % K\u0131salt\u0131lm\u0131\u015f versiyon oldu\u011fu i\u00e7in sunucu direkt Pa'y\u0131 geri g\u00f6nderiyor.\n   2.  State = 2\n       /\\ RCV(Nb'.Sid.Pa.{B.Kb'}_(inv(Ks)))\n       =|>\n       State' := 3\n       /\\ PMS' := new()\n       /\\ M' := PRF(PMS'.Na.Nb')\n       /\\ Finished' := H(PRF(PMS'.Na.Nb').A.B.Na.Pa.Sid)\n       /\\ ClientK' := KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ ServerK' := KeyGen(B.Na.Nb'.PRF(PMS'.Na.Nb'))\n       /\\ SND({PMS'}_Kb'.\n              {A.Ka}_(inv(Ks)).\n              {H(Nb'.B.PMS')}_(inv(Ka)).\n              {H(PRF(PMS'.Na.Nb').\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb'.PRF(PMS'.Na.Nb')))\n       /\\ witness(A,B,na_nb2,Na.Nb')\n\n   4.  State = 3\n       /\\ RCV({Finished}_ServerK)\n       =|>\n       State' := 5\n       /\\ request(A,B,na_nb1,Na.Nb)\n       /\\ secret(ClientK,sec_clientk,{A,B})\n       /\\ secret(ServerK,sec_serverk,{A,B})\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole bob(A, B : agent,\n    \t H, PRF, KeyGen: hash_func,\n\t Kb, Ks: public_key,\n\t SND, RCV: channel (dy))\nplayed_by B\ndef=\n\n   local Na, Nb, Sid, Pa, PMS: text,\n         State: nat,\n         Ka: public_key\n\n   init  State := 1\n\n   transition\n\n   1.  State = 1\n       /\\ RCV(A.Na'.Sid'.Pa')\n       =|>\n       State' := 3\n       /\\ Nb' := new()\n       /\\ SND(Nb'.Sid'.Pa'.{B.Kb}_(inv(Ks)))\n       /\\ witness(B,A,na_nb1,Na'.Nb')\n\n   2.  State = 3\n       /\\ RCV({PMS'}_Kb.{A.Ka'}_(inv(Ks)).\n              {H(Nb.B.PMS')}_(inv(Ka')).\n              {H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(A.Na.Nb.PRF(PMS'.Na.Nb)))\n       =|>\n       State' := 5\n       /\\ SND({H(PRF(PMS'.Na.Nb).\n               A.B.Na.Pa.Sid)\n              }_KeyGen(B.Na.Nb.PRF(PMS'.Na.Nb)))\n       /\\ request(B,A,na_nb2,Na.Nb)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole session(A,B: agent,\n\t     Ka, Kb, Ks: public_key,\n\t     H, PRF, KeyGen: hash_func)\ndef=\n\n   local  SA, SB, RA, RB: channel (dy)\n\n   composition\n\t\talice(A,B,H,PRF,KeyGen,Ka,Ks,SA,RA)\n\t   /\\\tbob(A,B,H,PRF,KeyGen,Kb,Ks,SB,RB)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nrole environment()\ndef=\n\n   const na_nb1, na_nb2 : protocol_id,\n         h, prf, keygen : hash_func,\n         a, b           : agent,\n         ka, kb, ki, ks : public_key\n\n   intruder_knowledge = { a, b, ka, kb, ks, ki, inv(ki),\n                          {i.ki}_(inv(ks)) }\n\n   composition\n\tsession(a,b,ka,kb,ks,h,prf,keygen)\n    /\\\tsession(a,i,ka,ki,ks,h,prf,keygen)\n    /\\\tsession(i,b,ki,kb,ks,h,prf,keygen)\n\nend role\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngoal\n  %Gizlilik hedefi i\u00e7in server ve client'in g\u00fcvenlikleri\n  secrecy_of sec_clientk,sec_serverk \n  %Alice na_nb1 ile Bob'un kimli\u011fini do\u011frular\n  authentication_on na_nb1 \n  %Bob na_nb2 ile Alice'in kimli\u011fini do\u011frular\n  authentication_on na_nb2 \n\nend goal\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Annotations added to enhance understanding of protocol roles and transitions.\n% The \"alice\" and \"bob\" roles are responsible for initiating and responding to the TLS handshake.\n% The secrets (sec_clientk, sec_serverk) represent the generated session keys used for secure communication.\n\nenvironment()"
    }
]