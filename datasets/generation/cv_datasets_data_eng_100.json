[
    {
        "file": "CV-1/Aizatulin-RPC.parse.cv",
        "logic": "---\n\n### Protocol Description\n\nThis protocol is designed for secure communication between a client and a server using Message Authentication Codes (MACs) for data integrity and authenticity. The protocol involves the generation and verification of MACs to ensure that messages exchanged between the client and server have not been tampered with during transmission.\n\n#### Parameters\n- **N**: A parameter that defines the number of concurrent sessions or instances of the protocol.\n\n#### Channels\n- **c1 to c14**: Communication channels used for sending and receiving messages between the client and server, as well as for signaling the start and completion of the protocol.\n\n#### Types\n- **mkeyseed**: Represents a seed used to generate MAC keys. It is defined as a large, fixed-type.\n- **mkey**: Represents the actual MAC key used for creating and verifying MACs. It is a bounded type.\n- **macinput**: Represents the input types for the MAC function, which could be any binary string.\n- **macres**: Represents the result of the MAC operation (not explicitly defined in the provided code).\n\n#### Probability\n- **Pmac**: A probability measure associated with the MAC operation, indicating the likelihood of successful MAC generation and verification.\n\n#### MAC Operation\nThe MAC operation is defined as a universal forgery under a chosen message attack (UF-CMA). The protocol includes functions for generating MACs (`mkgen`), creating MACs from inputs, and checking the validity of MACs against a given payload.\n\n#### Functions\n- **concat1**: A function that concatenates two bitstrings. It is used to combine the original message payload with its MAC.\n- **parse1**: A function that extracts the original payload from the concatenated message.\n- **parse2**: A function that extracts the MAC from the concatenated message.\n\n#### Events\n- **client_begin**: An event that signifies the start of the client's operation with a specific payload.\n- **server_accept**: An event that signifies the server's acceptance of a valid payload.\n\n#### Queries\nThe protocol includes a query that states if the server accepts a message (payload), then the corresponding client should initiate the process with that same payload.\n\n#### Processes\n1. **Client Process (A)**:\n   - Waits for an incoming message on channel `c1`.\n   - Extracts the payload from the message.\n   - Sends a message on channel `c2` that includes the concatenated payload and its MAC.\n\n2. **Server Process (B)**:\n   - Waits for an incoming message on channel `c4`.\n   - Parses the received message to extract the payload and MAC.\n   - Checks the validity of the MAC against the payload using the shared key `kAB`.\n   - If the MAC is valid, it triggers the `server_accept` event.\n\n3. **Main Process**:\n   - Starts by waiting for a signal on the `start` channel.\n   - Generates a new MAC key (`kAB`) from a keyseed (`keyseed`).\n   - Sends a signal on the `finish` channel.\n   - Initiates the concurrent execution of client process (A) and server process (B).\n\n### Security Goals\nThe protocol's primary goal is to ensure that only authenticated messages are accepted by the server, preventing any unauthorized or malicious actors from tampering with the messages exchanged between the client and server.\n\n---",
        "results": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved event server_accept(x) ==> client_begin(x) up to probability Pmac(time(context for game 2) + time, N, N, max(maxlength(game 2: payload_38), maxlength(game 2: payload_37)))\nRESULT time(context for game 2) = N * time(concat1, maxlength(game 2: payload_37), length(mac, maxlength(game 2: payload_37))) + N * time(parse2, maxlength(game 2: m)) + N * time(parse1, maxlength(game 2: m))\nAll queries proved.",
                    0.019611358642578125
                ]
            ]
        ]
    },
    {
        "file": "CV-1/auto_sa_rename_after_simplify.cv",
        "logic": "---\n\n### Protocol Description\n\n**Protocol Name**: Membership Verification Protocol\n\n**Parameters**:\n- `N`: A natural number that defines the maximum size of a set of allowed values.\n\n**Channel**:\n- `c`: A communication channel used for transmitting messages between parties.\n\n**Processes**:\n1. **Verification Process**:\n   - This process listens for incoming messages on the channel `c`. Each message consists of a triplet `(x, y, z)` where:\n     - `x`: The value to be checked for membership.\n     - `y`: A potentially valid value that may match `x`.\n     - `z`: An alternative potentially valid value that may also match `x`.\n\n   - The process first checks if the value `x` is equal to either `y` or `z`.\n     - If this condition holds true, it further checks for the existence of an index `i` such that:\n       - `i` is less than or equal to `N`.\n       - The value `a[i]` is defined.\n       - The value of `x` matches with `a[i]`.\n     - If all these conditions are satisfied, the process outputs `true` on the channel `c`, indicating that `x` is a valid member of the set defined by `a`.\n     - If any condition fails, it outputs `false`, indicating that `x` is not a valid member.\n\n2. **Input Process**:\n   - This process continuously listens for incoming messages on the channel `c`, where each message consists of a single value `a` of type `bitstring`.\n   - This process could be used to populate or update the set of values that will be checked against in the verification process.\n\n**Expected Behavior**:\n- The protocol is designed to verify whether a given value `x` is a member of a predefined set of values, given certain conditions. It ensures that the verification is performed securely and efficiently by leveraging the communication channel `c`.\n\n---",
        "results": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved indistinguishability between the input game and the final game\nAll queries proved.",
                    0.07081222534179688
                ]
            ]
        ]
    },
    {
        "file": "CV-1/Avik-cc-sym-enc-prf-mac.cv",
        "logic": "---\n\n## Description of the Protocol\n\n### Protocol Overview\n\nThis protocol is a chosen ciphertext secure symmetric encryption scheme that employs a pseudo-random function (PRF) family and an unpredictable function (UF) family. It provides security under the IND-CCA2 (INDistinguishable under Chosen Ciphertext Attack) model, which ensures that an adversary cannot distinguish between the encryptions of two different plaintexts, even when given the ability to query a decryption oracle.\n\n### Key Components\n\n1. **Parameters**:\n   - `n`: Security parameter.\n   - `m`: Maximum number of messages.\n   - `p`: Probability parameter.\n   - `qE`: Number of encryption queries.\n   - `qD`: Number of decryption queries.\n\n2. **Types**:\n   - `S`: Secret key space (large, fixed).\n   - `K`: Key space (large, fixed).\n   - `N`: Nonce space (large, fixed).\n   - `L`: Label/message space (fixed).\n   - `W`: MAC output space (fixed).\n\n3. **Probabilities**:\n   - `pPRF`: Probability associated with the pseudo-random function.\n   - `pUF`: Probability associated with the unpredictable function.\n   - `pXOR`: Probability associated with the XOR operation.\n\n### Functions\n\n- **f(S, N) \u2192 L**: This function is a pseudo-random function that takes a secret key `S` and a nonce `N` as inputs and outputs a label `L`. It is defined to be indistinguishable from a truly random function.\n\n- **h(K, N, L) \u2192 W**: This function is an unpredictable function that serves as a message authentication code (MAC). It takes a key `K`, a nonce `N`, and a label `L` as inputs and produces a MAC output `W`.\n\n- **h'(K, N, L) \u2192 W**: This function is an alternative representation of the MAC function `h`. It is used to demonstrate the unpredictability of the MAC.\n\n- **xor(L, L) \u2192 L**: This function implements the XOR operation between two labels `L`, providing properties of XOR.\n\n- **choose(bool, L, L) \u2192 L**: A conditional function that selects one of two labels based on a boolean input.\n\n### Processes\n\n- **Encryption Process (`processE`)**:\n  - Listens for encryption requests on channel `cE`.\n  - Takes two messages `m0` and `m1`, generates a nonce `x'`, and computes a ciphertext `c'` by XORing the output of the PRF `f(s, x')` with the chosen message.\n  - Generates a MAC `t'` using the function `h(k, x', c')` and sends `(x', c', t')` back through channel `cEret`.\n\n- **Decryption Process (`processD`)**:\n  - Listens for decryption requests on channel `cD`.\n  - Validates the MAC `t` against the MAC generated by `h(k, x, c)`.\n  - If valid, computes the original message `m` by XORing the ciphertext `c` with the output of the PRF `f(s, x)`, and sends it back through channel `cDret`.\n  - If the MAC does not match, it sends a rejection signal.\n\n- **Initialization Process (`processI`)**:\n  - Initializes the protocol by generating a secret key `k`, a secret state `s`, and a boolean `b` for message selection.\n\n### Execution\n\nThe process begins by waiting for a signal on the `start` channel. Upon receiving the signal, it initiates the encryption and decryption processes.\n\n### Security Properties\n\nThe protocol is designed to ensure that:\n- The encryption scheme is secure against chosen ciphertext attacks (IND-CCA2).\n- The MAC provides integrity and authenticity for the messages.\n- The use of pseudo-random and unpredictable functions ensures that the outputs are indistinguishable from random values.\n\n### Conclusion\n\nThis protocol demonstrates a secure way to implement symmetric encryption and message authentication in a manner that defends against common cryptographic attacks, making it suitable for practical applications where confidentiality and integrity are critical.\n\n---",
        "results": [
            true,
            [
                [
                    true,
                    true,
                    "RESULT Proved secrecy of b up to probability 2. * pXOR(time(context for game 11) + time, qE * q) + 2. * pPRF(time(context for game 7) + time, q, qE) + 3. * qE * qE * q * q / |N| + 2. * pUF(time(context for game 2) + time, q, qE, qD)\nRESULT time(context for game 2) = (qD * q + qE * q) * time(f) + (qD * q + qE * q) * time(xor) + qE * q * time(choose)\nRESULT time(context for game 7) = qE * q * time(choose) + qE * q * time(xor) + qE * q * time(h')\nRESULT time(context for game 11) = qE * q * time(choose) + qE * q * time(h')\nAll queries proved.",
                    0.01964879035949707
                ]
            ]
        ]
    }
]