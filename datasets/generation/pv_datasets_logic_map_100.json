{
    "PV-1/AugmentedEKE2.pv": "---\n\n### Protocol Description: Augmented EKE Protocol\n\n#### Overview\nThe Augmented EKE protocol is designed for secure communication between two parties, identified as hosts A and B. The main goal of the protocol is to establish a shared secret key using a password-based method while ensuring mutual authentication and confidentiality.\n\n#### Participants\n- **Host A**: The initiator of the communication who wants to establish a secure channel with Host B.\n- **Host B**: The responder who receives requests from Host A and responds accordingly.\n\n#### Key Elements\n1. **Cryptographic Primitives**:\n   - **Diffie-Hellman Key Exchange**: Used to derive a shared key based on a common generator \\( g \\) and the secret exponents of each host.\n   - **Symmetric Encryption**: Utilizes encryption (enc) and decryption (dec) functions for secure message exchange.\n   - **Hash Function (h)**: Generates a key based on the password.\n   - **One-way Function (F)**: A function that takes a password and key to produce a bitstring.\n\n2. **Types**:\n   - `host`: Represents the identities of the participants (A and B).\n   - `passwd`: Represents the passwords of the participants.\n   - `nonce`: Represents unique values used to ensure freshness in the communication.\n   - `G`: Represents the group element in the key exchange.\n   - `exponent`: Represents the secret exponents used in the Diffie-Hellman exchange.\n   - `key`: Represents cryptographic keys derived from group elements.\n\n#### Protocol Steps\n1. **Initiation**:\n   - Host A generates a random exponent \\( RA \\) and sends an encrypted message containing the group element \\( g^{RA} \\) encrypted with the hash of its password \\( h(P) \\).\n\n2. **Response**:\n   - Host B receives the message from Host A, decrypts it to retrieve \\( g^{RA} \\), and generates its own random exponent \\( RB \\). Host B then computes the shared key \\( K \\) and sends back two messages: one encrypted with \\( K \\) containing \\( g^{RB} \\) and another containing a nonce (challenge).\n\n3. **Challenge-Response**:\n   - Host A receives the messages from Host B, decrypts the first message to get \\( g^{RB} \\) and computes the shared key \\( K \\). Host A creates its own nonce (challenge) and sends both challenges back encrypted with \\( K \\).\n\n4. **Finalization**:\n   - Host B receives the challenges, decrypts them, and verifies their correctness. If valid, both hosts complete the key exchange by confirming the shared key through further exchange of messages involving the one-way function \\( F \\).\n\n5. **Authentication**:\n   - The protocol ensures that both hosts can confirm each other's identity and that they share the same secret key derived from their passwords.\n\n#### Security Considerations\n- The protocol includes mechanisms to prevent replay attacks and ensures that the secrets (passwords) remain weakly secret.\n- An adversary\u2019s ability to distinguish between group elements and random bitstrings poses a potential attack vector, which the protocol aims to mitigate through proper encryption and the use of fresh nonces.\n\n#### Conclusion\nThe Augmented EKE protocol is a secure method for password-based authentication and key exchange, ensuring that both parties can derive a mutual secret while authenticated, even in the presence of potential adversaries.\n\n---",
    "PV-1/basic1-1.pv": "### Protocol Description\n\n---\n\n**Protocol Name:** Simple Hashing Protocol\n\n**Participants:**\n- A single participant (could be a client or server) that communicates over a channel.\n\n**Channel:**\n- A public channel `c` is used for sending messages.\n\n**Variables:**\n- `x`: A bitstring that represents the data to be sent.\n- `n`: A bitstring that is likely used as a nonce or a unique identifier to ensure freshness.\n- The `hash` function is defined to compute the hash of a given bitstring.\n\n**Cryptographic Primitives:**\n- **Hash Function:** The protocol utilizes a hash function, `hash(bitstring)`, which is expected to produce a fixed-size output that is difficult to reverse-engineer. This function is critical for ensuring data integrity and authenticity.\n\n**Process Overview:**\n1. The protocol initiates by sending the bitstring `x` over the public channel `c`.\n  \n**Security Properties:**\n- The primary focus of the protocol is non-interference, specifically ensuring that the value of `x` does not leak any information about the secret values `n` and `hash(n)`.\n- The verification goal is to prove that `x` is non-interfering with respect to the values of `n` and `hash(n)`. This means that an observer should not be able to derive any information about `n` or `hash(n)` from `x`.\n\n**Expected Result:**\n- The verification tool (Proverif) checks that the non-interference property holds, ensuring that `x` remains independent of `n` and `hash(n)`. The output confirms that the non-interference condition is satisfied.\n\n---\n\n### Corresponding Proverif .pv File Example\n\nBased on the description above, here's how you can structure a Proverif `.pv` file that corresponds to the given description:\n\n```proverif\n(* Simple Hashing Protocol *)\n\nfun hash(bitstring): bitstring.\n\nfree c: channel.\nfree x, n: bitstring [private].\n\nnoninterf x among (n, hash(n)).\n\nprocess\n    out(c, x)\n\n(* EXPECTPV\nRESULT Non-interference x among (n[], hash(n[])) is true.\nEND *)\n```\n\nIn this `.pv` file:\n- We define a hash function.\n- We declare a public channel and private bitstrings.\n- We specify the non-interference property we want to verify.\n- We outline the protocol process where `x` is sent over the channel.",
    "PV-1/basicweaksecret.pv": "---\n\n### Protocol Description\n\n**Protocol Name:** Basic Weak Secret Protocol\n\n**Overview:**\nThis protocol demonstrates the concept of weak secrets using probabilistic public-key encryption and a hash function. It illustrates how a password, denoted as \\( w \\), remains a weak secret when transmitted over a channel.\n\n**Key Components:**\n\n1. **Types:**\n   - `skey`: Represents a secret key used for decryption.\n   - `pkey`: Represents a public key used for encryption.\n   - `seed`: A random seed used in the encryption process.\n   - `passwd`: Represents the password that is kept as a weak secret.\n\n2. **Cryptographic Functions:**\n   - **Public-Key Encryption (PKE):**\n     - `pk(skey)`: A function that generates the public key corresponding to a given secret key.\n     - `penc(bitstring, pkey, seed)`: A function that encrypts a bitstring using the specified public key and random seed.\n     - `pdec(bitstring, skey)`: A function that decrypts a bitstring using the corresponding secret key.\n     - **Equation:** The encryption and decryption functions satisfy the property that decrypting the encryption of a bitstring returns the original bitstring:\n       \\[\n       \\forall x: \\text{bitstring}, y: \\text{skey}, z: \\text{seed}; \\quad pdec(penc(x, pk(y), z), y) = x.\n       \\]\n\n3. **Hash Function:**\n   - `h(passwd)`: A function that takes a password and produces a hashed output in the form of a bitstring.\n\n4. **Channels and Variables:**\n   - `c`: A public communication channel used for sending messages.\n   - `w`: A variable representing the password, marked as private to indicate its confidential nature.\n\n5. **Weak Secret Declaration:**\n   - The password \\( w \\) is declared as a weak secret, indicating that it can be learned by an adversary under certain conditions.\n\n**Process:**\nThe protocol consists of the following steps:\n- A new secret key \\( s \\) is generated.\n- A new random seed \\( a \\) is generated.\n- The public key \\( pk(s) \\) is sent over the communication channel \\( c \\).\n- The hashed password \\( h(w) \\) is encrypted using the public key \\( pk(s) \\) and the random seed \\( a \\). The encrypted result is then sent over the channel \\( c \\).\n\n**Expected Result:**\nWhen the protocol is executed, the expected output indicates that the weak secret \\( w \\) remains true, confirming the vulnerability of the password despite encryption.\n\n---\n\n### Corresponding Proverif (.pv) File\n\nBased on the description above, the corresponding Proverif file can be structured as follows:\n\n```proverif\n(* Basic weak secret example, from JLAP paper\n   Corrected version *)\n\ntype skey.\ntype pkey.\ntype seed.\ntype passwd.\n\n(* Probabilistic public-key encryption *)\n\nfun pk(skey): pkey.\nfun penc(bitstring, pkey, seed): bitstring.\nfun pdec(bitstring, skey): bitstring.\nequation forall x: bitstring, y: skey, z: seed;  pdec(penc(x, pk(y), z), y) = x.\n\n(* Hash function *)\n\nfun h(passwd): bitstring.\n\nfree c: channel.\nfree w: passwd [private].\n\nweaksecret w.\n\nprocess\n    new s: skey;\n    new a: seed;\n    out(c, pk(s));\n    out(c, penc(h(w), pk(s), a))\n\n(* EXPECTPV\nRESULT Weak secret w is true.\nEND *)\n```"
}